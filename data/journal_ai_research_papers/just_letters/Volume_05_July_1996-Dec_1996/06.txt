journal of artificial intelligence research                 

submitted       published      

muse csp  an extension to
the constraint satisfaction problem
randall a  helzerman
mary p  harper

school of electrical and computer engineering
     electrical engineering building
purdue university
west lafayette  in            usa

helz ecn purdue edu
harper ecn purdue edu

abstract

this paper describes an extension to the constraint satisfaction problem  csp  called
muse csp  mu ltiply se gmented c onstraint s atisfaction p roblem   this extension is
especially useful for those problems which segment into multiple sets of partially shared
variables  such problems arise naturally in signal processing applications including computer vision  speech processing  and handwriting recognition  for these applications  it is
often dicult to segment the data in only one way given the low level information utilized
by the segmentation algorithms  muse csp can be used to compactly represent several
similar instances of the constraint satisfaction problem  if multiple instances of a csp have
some common variables which have the same domains and constraints  then they can be
combined into a single instance of a muse csp  reducing the work required to apply the
constraints  we introduce the concepts of muse node consistency  muse arc consistency 
and muse path consistency  we then demonstrate how muse csp can be used to compactly represent lexically ambiguous sentences and the multiple sentence hypotheses that
are often generated by speech recognition algorithms so that grammar constraints can be
used to provide parses for all syntactically correct sentences  algorithms for muse arc
and path consistency are provided  finally  we discuss how to create a muse csp from a
set of csps which are labeled to indicate when the same variable is shared by more than
a single csp 

   introduction
this paper describes an extension to the constraint satisfaction problem  csp  called muse
csp  mu ltiply se gmented c onstraint s atisfaction p roblem   this extension is especially
useful for those problems which segment into multiple sets of partially shared variables 
first  we describe the constraint satisfaction problem and then define our extension 

    the constraint satisfaction problem
constraint satisfaction problems  csp  have a rich history in artificial intelligence  davis
  rosenfeld        dechter  meiri    pearl        dechter   pearl        freuder       
      mackworth        mackworth   freuder        villain   kautz        waltz       
 for a general reference  see tsang         constraint satisfaction provides a convenient way
to represent and solve certain types of problems  in general  these are problems which can
be solved by assigning mutually compatible values to a predetermined number of variables
c     


ai access foundation and morgan kaufmann publishers  all rights reserved 

fihelzerman   harper

under a set of constraints  this approach has been used in a variety of disciplines including
machine vision  belief maintenance  temporal reasoning  graph theory  circuit design  and
diagnostic reasoning  when using a csp approach  e g   figure     the variables are typically depicted as vertices or nodes  where each node is associated with a finite set of possible
values  and the constraints imposed on the variables are depicted using arcs  an arc looping
from a node to itself represents a unary constraint  a constraint on a single variable   and
an arc between two nodes represents a binary constraint  a constraint on two variables   a
classic example of a csp is the map coloring problem  e g   figure     where a color must
be assigned to each country such that no two neighboring countries have the same color  a
variable represents a country s color  and a constraint arc between two variables indicates
that the two joined countries are adjacent and should not be assigned the same color 
formally  a csp  mackworth        is defined in definition   

definition    constraint satisfaction problem 
n   fi  j       g is the set of nodes  or variables   with jn j   n 
l   fa  b       g is the set of labels  with jlj   l 
li   faja   l and  i  a  is admissibleg 
r  is a unary constraint  and  i  a  is admissible if r   i  a  
r  is a binary constraint   i  a     j  b  is admissible if r   i  a  j  b  
a csp network contains all n tuples in ln which satisfy r  and r    since some of the

labels associated with a node may be incompatible with labels assigned to other nodes  it
is desirable  when the constraints are suciently tight  van beek         to eliminate as
many of these labels as possible by enforcing local consistency conditions before a globally
consistent solution is extracted  dechter         node and arc consistency are defined in
definitions   and    respectively  in addition  it may be desirable to eliminate as many label
pairs as possible using path consistency  which is defined in definition   

definition    node consistency  an instance of csp is said to be node consistent if and only if
each node s domain contains only labels for which the unary constraint r  holds  i e  
 i   n    a   li   r   i  a 
definition    arc consistency  an instance of csp is said to be arc consistent if and only if for

every pair of nodes i and j   each element of li  the domain of i  has at least one element of lj for
which the binary constraint r  holds  i e  
 i  j   n    a   li    b   lj   r   i  a  j  b 
 red  green  blue 
different
color

 
 

 

 red  green  blue 

different
color

 
 

 

 red  green  blue 

different
color

figure    the map coloring problem as an example of csp 
   

fimuse csp  an extension to the constraint satisfaction problem

definition    path consistency  an instance of csp is said to be path consistent if and only if 
 i  j   n   i    j     a   li    b   lj    k   n   k    i   k    j   p ath i  k  j    
 r  i a j b    c   lk   r   i  a  k  c    r   k  c  j  b   
where path i  k  j   indicates that there is a path of arcs of length two connecting i and j which
goes through k 

node consistency is easily enforced by the operation li   li   fxjr   i  x g  requiring
o nl  time  where n is the number of variables and l is the maximum domain size   arc
consistency is enforced by ensuring that every label for a node is supported by at least one
label for each node with which it shares a binary constraint  mackworth        mackworth
  freuder        mohr   henderson         the arc consistency algorithm ac    mohr
  henderson        has an worst case running time of  el    where e is the number of
constraint arcs   ac    mackworth   freuder        often performs better than ac   in
practice  though it has a slower running time in the worst case  ac    bessiere        has
the same worst case running time as ac   and is faster than ac   and ac   in practice 
path consistency ensures that any pair of labelings  i  a     j  b  allowed by the  i  j   arc
directly are also allowed by all arc paths from i to j   montanari has proven that to ensure
path consistency for a complete graph  it suces to check every arc path of length two
 montanari         the path consistency algorithm pc    han   lee        has a worstcase running time of o n  l   time  where n is the number of variables in the csp  

    the multiply segmented constraint satisfaction problem

there are many types of problems which can be solved by using csp in a more or less direct
fashion  there are also problems which might benefit from the csp approach  but which are
dicult to represent with a single csp  this is the class of problems our paper addresses 
for example  suppose the map represented in figure   is scanned by a noisy computer
vision system  with a resulting uncertainty as to whether the line between regions   and  
is really a border or an artifact of the noise  this situation would yield two csp problems
as depicted in figure    a brute force approach would be to solve both of the problems 
which would be reasonable for scenes containing only a few ambiguous borders  however 
as the number of ambiguous borders increases  the number of csp networks would grow in
a combinatorially explosive fashion  in the case of ambiguous segmentation  it can be more
ecient to merge the constraint networks into a single network which would compactly
represent all of the instances simultaneously  as shown in figure    notice that the csp
instances are combined into a directed acyclic graph where the paths through the dag
from start to end correspond to those csps that were combined  in this paper  we develop
an extension to csp called muse csp  mu ltiply se gmented c onstraint s atisfaction
p roblem   which represents multiple instances of a csp problem as a dag 
if there are multiple  similar instances of a csp  then separately applying constraints
for each instance can result in much duplicated work  to avoid this duplication  we have
provided a way to combine the multiple instances of csp into a muse csp  and we have
   

fihelzerman   harper

 red  green  blue 

 red  green  blue 

 

 

 
different
color

 

 

 red  green  blue 

 

 
 

different
color

 

different
color

 

 
 red  green  blue 

 red  green  blue 

 

 

different
color

figure    an ambiguous map yields two csp problems 

start

 red  green  blue 

different
color

different
color

 
 red  green  blue 

 
 red  green  blue 

different
color

 

 red  green 
blue 

different
color

different
color

 

 

 

 

 

end

 red  green  blue 

 red  green  blue 

 red  green  blue 

different
color

 red  green  blue 

different
color

figure    how the two csp problems of figure   can be captured by a single instance of
muse csp  the directed edges form a dag such that the directed paths through
the dag correspond to instances of those csps that were combined 

   

fimuse csp  an extension to the constraint satisfaction problem

developed the concepts of muse node consistency  muse arc consistency  and muse path
consistency  formally  we define muse csp as follows 

definition    muse csp 
n   fi  j       g is the set of nodes  or variables   with jn j   n 
   n is a set of segments with jj   s 
l   fa  b       g is the set of labels  with jlj   l 
li   faja   l and  i  a  is admissible in at least one segmentg 
r  is a unary constraint  and  i  a  is admissible if r   i  a  
r  is a binary constraint   i  a     j  b  is admissible if r   i  a  j  b  
the segments in  are the different sets of nodes representing csp instances which are
combined to form a muse csp  a solution to a muse csp is defined to be a solution to
any one of its segments 

definition    solution to a muse csp  a solution to a muse csp is an assignment ff to a
segment    fi          ip g such that     and ff   li       lip such that r  ix   ff ix    holds for
every node ix     and r  ix   ff ix   iy   ff iy    holds for every pair of nodes ix   iy     such that
ix    iy  
depending on the application  the solution for a muse csp could also be the set of all
consistent labels for a single path through the muse csp  a single set of labels for each of
the paths  or csps   or all compatible sets of labels for each of the paths 
a muse csp can be solved with a modified backtracking algorithm which finds a
consistent label assignment for a segment  however  when the constraints are suciently
tight  the search space can be pruned by enforcing local consistency conditions  such as node 
arc  and path consistency  to gain the eciency resulting from enforcing local consistency
conditions before backtracking  node  arc  and path consistency must be modified for muse
csp  the definitions for muse csp node consistency  arc consistency  and path consistency
appear in definitions       and    respectively 

definition    muse node consistency  an instance of muse csp is said to be node consistent
if and only if each node s domain li contains only labels for which the unary constraint r  holds 
i e  
 i   n    a   li   r   i  a 
definition    muse arc consistency  an instance of muse csp is said to be muse arc consis 

tent if and only if for every label a in each domain li there is at least one segment  whose nodes 
domains contain at least one label b for which the binary constraint r  holds  i e  

 i   n    a   li          i       j      j    i    b   lj   r   i  a  j  b 

definition    muse path consistency  an instance of muse csp is said to be path consistent
if and only if 

 i  j   n   i    j     a   li    b   lj          i  j       k      k    i   k    j   p ath i  k  j    
 r   i  a  j  b     c   lk   r   i  a  k  c    r   k  c  j  b   
   

fihelzerman   harper

a 

b 

 

 c d 

start

 

 e 

 

 e 

 d 

end

 

 a b 

d
e  

b
e  

c d
e    

a b
e    

start

end

 

 
 b 

 

 
 f 

 f 
c d
a    
b    

d
a b
f    

c d
f    

b

 

b
f  

f

d
 

figure    a  a muse csp before muse arc consistency is achieved  b  a muse csp
after muse arc consistency is achieved 
a muse csp is node consistent if all of its segments are node consistent  unfortunately 
muse csp arc consistency requires more attention  when enforcing arc consistency in a
csp  a label a   li can be eliminated from node i whenever any other domain lj has
no labels which together with a satisfy the binary constraints  however  in a muse csp 
before a label can be eliminated from a node  it must be unsupported by the arcs of every
segment in which it appears  as required by the definition of muse arc consistency shown in
definition    notice that definition   reduces to definition   when the number of segments
is one 
to demonstrate how muse arc consistency applies to a muse csp  consider the muse
csp in figure  a  notice that label c   l  is not supported by any of the labels in l 
and l    but does receive support from the labels in l   should this label be considered
to be muse arc consistent  the answer is no because node   is only a member of paths
through the dag which contain node   or node    and neither of them support the label
c  because there is no segment such that all of its nodes have some label which supports
c  c should be eliminated from l   once c is eliminated from l   a will also be eliminated
from l    this is because the elimination of c from l  causes a to loose the support of node
   since node   is a member of every path  no other segment provides support for a  the
muse arc consistent dag is depicted in figure  b  note that muse arc consistency does
not ensure that the individual segments are arc consistent as csps  for example  figure
  is muse arc consistent even though its segments are not csp arc consistent  this is
because c receives arc support  which is a very local computation  from the arcs of at least
one of the paths  we cannot ensure that the values that support a label are themselves
mutually consistent by considering muse arc consistency alone  for this case  muse path
consistency together with muse arc consistency would be needed to eliminate the illegal
labels c and a 
when enforcing path consistency in a csp  r   i  a  j  b  becomes false if  for any third
node k  there is no label c   lk such that r   i  a  k  c  and r   k  c  j  b  are true  in
   

fimuse csp  an extension to the constraint satisfaction problem

c d
e    

a b
e    

 

 c d 

start

 

 e 

end

 

 a b 

 
 f 

c d
a    
b    

a b
f    

c d
f    

figure    a muse csp which is muse arc consistent  but not arc consistent for each
segment 
muse csp  if a binary constraint becomes path inconsistent in one segment  it could still
be allowed in another  therefore  the definition of muse path consistency is modified as
shown in definition   
enforcement of muse arc and path consistency requires modification of the traditional
csp algorithms  these algorithms will be described after we introduce several applications
for which muse csp has proven useful 

   muse csp and constraint based parsing
it is desirable to represent a muse csp as a directed acyclic graph  dag  where the
directed paths through the dag correspond to instances of csp problems  it is often
easy to determine which variables should be shared and how to construct the dag  the
application presented in this section is one for which muse csp is useful  a parsing
problem is naturally represented as a dag because of the presence of ambiguity  in many
cases  the same word can have multiple parts of speech  it is convenient to represent those
words as nodes in a muse csp  in speech recognition systems  the identification of the
correct words in a sentence can be improved by using syntactic constraints  however  a word
recognition algorithm often produces a lattice of word candidates  clearly  individually
parsing each of the sentences in a lattice can be inecient 

    parsing with constraint dependency grammar
maruyama developed a new grammar called constraint dependency grammar  cdg 
 maruyama      a      b      c   he then showed how cdg parsing can be cast as a
csp with a finite domain  so constraints can be used to rule out ungrammatical sentences 
a cdg is a four tuple  h  r  l  c i  where 
   

fihelzerman   harper

   a finite set of preterminal symbols  or lexical categories 
r   a finite set of uniquely named roles  or role ids    fr          rp g 
l   a finite set of labels   fl           lq g 
c   a finite set of constraints that an assignment a must satisfy 

a sentence s   w  w w       wn    is a string of length n  for each word wi    of a
sentence s  we must keep track of p different roles  or variables   a role is a variable which
takes on role values of the form  l  m   where l   l and m   fnil             ng  role values
are denoted in examples as label modifiee  in parsing  each label in l indicates a different
syntactic function  the value of m in the role value  l  m   when assigned to a particular
role of wi  specifies the position of the word that wi is modifying when it takes on the
function specified by the label  l  e g   subj   indicates that the word with that label is
a subject when it modifies the third word in the sentence   the sentence s is said to be
generated by the grammar g if there exists an assignment a which maps a role value to
each of the n  p roles for s such that the constraint set c  described in the next paragraph 
is satisfied 
a constraint set is a logical formula of the form   x    x          xa  and p  p        pm   
where each xi ranges over all of the role values in each of the roles for each word of s  each
subformula pi in c must be of the form   if antecedent consequent   where antecedent
and consequent are predicates or predicates joined by the logical connectives  below are
the basic components used to express constraints 

 variables  x    x         xa  a     in  maruyama      a   
 constants  elements and subsets of    l   r   fnil               ng  where n corresponds to
the number of words in a sentence 

 functions 
 pos x  returns the position of the word for role value x 
 rid x  returns the role id for role value x 
 lab x  returns the label for role value x 
 mod x  returns the position of the modifiee for role value x 
 cat y  returns the category  i e   the element in   for the word at position y 
 predicates            
 logical connectives  and  or  not 
a subformula pi is called a unary constraint if it contains one variable and a binary constraint if it contains two  a cdg grammar has two associated parameters  degree and
arity  the degree of a grammar g is the number of roles  the arity of the grammar  a 
corresponds to the maximum number of variables in the subformulas of c  
consider the example grammar  g    which is defined using the following four tuple 
h    fdet  noun  verbg  r    fgovernorg  l    fdet  root  subjg  c   see constraints in
figure   i  g  has a degree of one and an arity of two  to illustrate the process of parsing
   note that     nil or     nil is false  because nil is not an integer  for muse networks  we relate position
intervals using       and   

   

fimuse csp  an extension to the constraint satisfaction problem

with constraint satisfaction  figure   shows the steps for parsing the sentence the dog
eats  to simplify the presentation of this example  the grammar uses a single role  the
governor role  which is denoted as g in the constraint network in figure    the governor
role indicates the function a word fills in a sentence when it is governed by its head word 
a word is called the head of a phrase when it forms the basis of the phrase  e g   the verb
is the head of the sentence   in useful grammars  we would also include several needs roles
 e g  need   need   to make certain that a head word has all of the constituents it needs to
be complete  e g   a singular count noun needs a determiner to be a complete noun phrase  
to determine whether the sentence  the dog eats  is generated by the grammar  the cdg
parser must be able to assign at least one role value to each of the n  p roles that satisfies the
grammar constraints  n     is sentence length  and p     is the number of roles   because
the values for a role are selected from the finite set l   fnil         g  cdg parsing can
be viewed as a constraint satisfaction problem over a finite domain  therefore  constraint
satisfaction can be used to determine the possible parses of this sentence 
initially  for each word  all possible role values are assigned to the governor role  we
assume that a word must either modify another word  other than itself  or modify no
word  m nil   nothing is gained in cdg by having a word modify itself  next the unary
constraints are applied to all of the role values in the constraint network  a role value is
incompatible with a unary constraint if and only if it satisfies the antecedent  but not the
consequent  notice in figure   that all the role values associated with the governor role of
the first word  the  satisfy the antecedent of the first unary constraint  but det nil  subjnil  subj    subj    root nil  root    and root   do not satisfy the consequent  and so they
are incompatible with the constraint  when a role value violates a unary constraint  node
consistency eliminates those role values from their role because they can never participate
in a parse for the sentence  after all unary constraints are applied to the top constraint
network in figure    the second network is produced 
next  binary constraints are applied  binary constraints determine which pairs of role
values can legally coexist  to keep track of pairs of role values  arcs are constructed connecting each role to all other roles in the network  and each arc has an associated arc matrix 
whose row and column indices are the role values associated with the two roles it connects 
the entries in an arc matrix can either be    indicating that the two role values indexing
the entry are compatible  or    indicating that the role values cannot simultaneously exist   initially  all entries in each matrix are set to    indicating that the pair of role values
indexing the entry are initially compatible  because no constraints have been applied   in
our example  the single binary constraint  shown in figure    is applied to the pairs of
role values indexing the entries in the matrices  for example  when x det   for the and
y root nil for eats  the consequent of the binary constraint fails  hence  the role values are
incompatible  this is indicated by replacing the entry of   with   
following the binary constraints  the roles of the constraint network can still contain
role values which are incompatible with the parse for the sentence  role values that are not
supported by the binary constraints can be eliminated by achieving arc consistency  for
example  det   for the is not supported by the remaining role value for eats and is thus
deleted from the role 
after arc consistency  the example sentence has a single parse because there is only one
value per role in the sentence  a parse for a sentence consists of an assignment of role values
   

fihelzerman   harper

the
det
 

dog

eats

noun
 

verb
 

g

g
 detnil  det   det  
subjnil  subj   subj  
rootnil  root   root  

g

 detnil  det   det  
subjnil  subj   subj  
rootnil  root   root  

 detnil  det   det  
subjnil  subj   subj  
rootnil  root   root  

    if     cat  pos x   det 
    if     cat  pos x   noun 
 and     lab x  det 
 and     lab x  subj 
    pos x   mod x    
    pos x   mod x    

apply unary constraints and
enforce node consistency 

    if     cat  pos x   verb 
 and     lab x  root 
    mod x  nil   
the
det
 

dog

eats

noun
 

verb
 

g

g

g
 subj  

 det   det  

 rootnil 
rootnil

subj 
det 

 

det 

 

subj 

 

rootnil
det 

 

det 

 

 if  and     lab x  det 
    mod x   pos y   
    cat  pos y   noun  

apply binary constraints 

the
det
 

dog

eats

noun
 

g

verb
 

g

g
 subj  

 det   det  

 rootnil 
rootnil

subj 
det 

 

det 

 

subj 

 

rootnil
det 

 

det 

 

enforce arc consistency 

the
det
 

dog

eats

noun
 

verb
 

g

g

 det  

 subj  

g
 rootnil 

figure    using constraints to parse the sentence  the dog eats 
   

fimuse csp  an extension to the constraint satisfaction problem

to roles such that the unary and binary constraints are satisfied for that assignment  in
general  there can be more than one parse for a sentence  hence  there can be more than one
assignment of values to the roles of the sentence  note that the assignment for the example
sentence is 

pos word cat governor role s value
  the det
det  
  dog noun
subj  
  eats verb
root nil
if there is only one possible sentence such that the part of speech of each of the words
is known in advance  then the parsing problem can be cast as a csp  however  for the
ambiguity present in written and spoken sentences to be handled uniformly requires the use
of muse csp 

    processing lexically ambiguous sentences with cdg
one shortcoming of maruyama s constraint based parser is that it requires a word to have
a single part of speech  however  many words in the english language have more than one
lexical category  this assumption is captured in the way that maruyama writes constraints
involving category information  the category is determined based on the position of the
word in the sentence  however  even in our simple example  the word dog could have been
either a noun or a verb prior to the propagation of syntactic constraints  since parsing can
be used to lexically disambiguate the sentence  ideally  the parsing algorithm should not
require that the part of speech for the words be known prior to parsing 
lexically ambiguous words can easily be accommodated by creating a csp for each
possible combination of lexical categories  however  this would be combinatorially explosive 
in contrast  using a muse csp  we can create a separate word node for each legal part of
speech of a word  sharing those words that are not ambiguous across all segments  since
position does not uniquely define the category of a word  we must allow category information
to be accessed through the role value rather than the position of the word in the sentence
 i e   use  cat x  rather than  cat  pos x     once we associate category information
with a role value  we could instead create role values for each lexical category for a word
and store all of the values in a single word node  however  this representation is not as
convenient as the muse csp representation for the problem  in the lexically augmented
csp  when there is more than one role per word  this is usually the case   the role values
associated with one lexical category for one role cannot support the role values associated
with another lexical category in another role for the same word  additional constraints
must be propagated to enforce this requirement  the muse csp representation does not
suffer from this problem  by using a separate node for each part of speech  the muse csp
directly represents the independence of the alternative lexical categories for a given word 
the space requirements for the arc matrices in the muse representation is lower than for
the lexicalized csp as there is no arc between the roles for the different lexical categories
for a word in the muse representation  note that muse arc consistency is equivalent to
performing arc consistency on the lexically augmented csp  after the additional constraints
   

fihelzerman   harper

are propagated    most importantly  muse csp can represent lattices that cannot be
combined into a single csp 
the technique of creating separate nodes for different instances of a word can also be
used to handle feature analysis  like number and person  in parsing  harper   helzerman 
    b   since some words have multiple feature values  it is often more ecient to create a
single node with a set of feature values  apply syntactic constraints  and then split the node
into a set of nodes with a single feature value prior to applying the constraints pertaining
to the feature type  node splitting can also be used to support the use of context specific
constraints  harper   helzerman      b  

    lattice example

much of the motivation for extending csp comes from our work in spoken language parsing
 harper   helzerman      a  harper  jamieson  zoltowski    helzerman        zoltowski 
harper  jamieson    helzerman         the output of a hidden markov model based
speech recognizer can be thought of as a lattice of word candidates  unfortunately  a
lattice contains many word candidates that can never appear in a sentence covering the
duration of a speech utterance  by converting the lattice to a word graph  many word
candidates in the lattice can be eliminated  figure   depicts a word graph constructed
from a simple lattice  notice that the word tour can be eliminated when the word graph
is constructed  in order to accommodate words that occur over time intervals that may
overlap  each word s position in the lattice is now represented as a tuple  b  e  such that
b   e  the positional relations defined for constraints are easily modified to operate on
tuples  harper   helzerman      a  
after construction  the word graph often contains spurious sentence hypotheses which
can be pruned by using a variety of constraints  e g   syntactic  semantic  etc    we can
apply constraints to individual sentences to rule out those that are ungrammatical  however 
individually processing each sentence hypothesis is inecient since many have a high degree
of similarity  if the spoken language parsing problem is structured as a muse csp problem 
then the constraints used to parse individual sentences would be applied to the word graph
of sentence hypotheses  eliminating from further consideration many hypotheses which are
ungrammatical 
we have developed a muse csp constraint based parser  parsec  harper   helzerman      a      b  harper et al         zoltowski et al          which is capable of parsing
word graphs containing multiple sentences produced by a speech recognition module  we
have developed syntactic and semantic constraints for parsing single sentences  which when
applied to a word graph  eliminate those hypotheses that are syntactically or semantically
incorrect  the muse csp used by our parser can be thought of as a parse forest which
is pruned by using constraints  by applying constraints from a wide variety of knowledge
sources  the parser prunes the composite structure of many of the role values associated
with a role  as well as word nodes with no remaining role values  several experiments
 harper et al         zoltowski et al         have considered how effective syntactic and
   as a simple demonstration  consider merging nodes   and   from figure   into a single node such that the
value e and f keep track of the fact that they have type   and    respectively  under these circumstances 
csp arc consistency will give the same results as muse csp arc consistency  even though a and c appear
in no solutions  they are not eliminated  note that this example uses only one role per node 

   

fimuse csp  an extension to the constraint satisfaction problem

tour
its

wreck
hard

its
 

a

nice

beach

to
recognizes

 

 

 

 

wreck

its

     

     

hard

start

its
     

 

     

speech

 

 

a

nice

     

     

 

beach
     

to
     

end

recognizes
     

speech
     

figure    multiple sentence hypotheses can be parsed simultaneously by applying constraints over a word graph rather than individual sentences extracted from a
lattice 
semantic constraints are at pruning word nodes that can appear in no sentence hypothesis 
for our work in speech processing  the muse arc consistency algorithm is very effective
at pruning the role values from the composite structure that can never appear in a parse
for a sentence  i e   an individual csp   constraints are usually tight enough that muse
arc consistency eliminates role values that do not participate in at least one parse for the
represented sentences 
muse csp is a useful way to process multiple sentences because the arc consistency
algorithm is effective at eliminating role values that cannot appear in sentence parses 
several factors contribute to the effectiveness of the arc consistency algorithm for this
problem  first  the syntactic constraints are fairly tight constraints  second  the role
values contain some segmental information that constrain the problem  consider the word
graph in figure    the value s       associated with the role marked n for the word are
cannot support any of the values for the role marked g for the word dogs at position       
because it is not legal in a segment involving position        in the figure  we mark those
entries where a value associated with one role is segmentally incompatible with the values
of another with an n  these entries are equivalent to    third  many times constraints
create symmetric dependencies between words in the sentence  for example  one constraint
might indicate that a verb needs a subject to its left  and another that a subject must be
governed by a verb to its right 

    a demonstration of the utility of muse csp parsing

to demonstrate the utility of muse csp for simultaneously parsing multiple csp instances 
consider the problem of determining which strings of length  n consisting of a s  b s  and c s
   

fihelzerman   harper

obj      obj     
s     

n

n

s     

 

 

 obj      
obj      

 rootnil 

g

start

n

g

n

n  npnil 

g
dogs
     

 s      
s      

end

 blanknil 
 subj      
subj      
subj      

they
     

are
     
 obj      
obj      

g

n  np      
np      
dog
     

obj      obj     
s     

 

 

s     

n

n

figure    in parsing word graphs  some of the values assigned to roles contain segmental
information which make them incompatible with the values associated with some
of the other roles  for example  s       cannot support any of the values associated
with the g or n roles of the word dogs 
are in the language an bn cn   for the value of n      this problem can be represented as the
single muse csp problem shown in figure    the roles and role values are not depicted to
simplify the figure   we have devised constraints for this language  see figure     which
eliminate all role values for all sentences not in the language as well as all ungrammatical
role values for a sentence in the language  when these constraints are applied followed by
muse arc consistency to a lattice like that in figure   with a length divisible by three 
then only the grammatical sentence will remain with a single parse  for lattices containing
only sentences with lengths that are not divisible by three  all role values are eliminated
by muse arc consistency  there is no grammatical sentence   hence  there is no search
required to extract a parse if there is one  for the n     case of figure    the parse appears
in figure     a single parse will result regardless of the n chosen  note that the modifiees
for the role values in the parse are used to ensure that for each a  there is a corresponding
c  for each b  there is a corresponding a  and for each c  there is a corresponding b  figure
   examines the time needed to extract a parse for sentences in the language an bn cn from
muse csps representing all strings of length  n     n     containing a  b  and c  the
time to perform muse ac   and extract the solution is compared to the time to extract
the solution without any preprocessing  the time to perform muse ac   and extract the
parse is stable as sentence length grows  but the time to extract a parse grows quickly for
sentence lengths greater than    when muse arc consistency is not used 
the previous example involves a grammar where there can only be one parse for a single
sentence in the lattice  however  it is a simple matter to provide similar demonstrations for
   

fimuse csp  an extension to the constraint satisfaction problem

start

a

a

a

a

a

a

a

a

a

     

     

     

     

     

     

     

     

      

b

b

b

b

b

b

b

b

b

     

     

     

     

     

     

     

     

      

c

c

c

c

c

c

     

     

     

     

     

     

c

c

c

     

     

      

end

figure    a single muse csp can simultaneously test all possible orderings of a s  b s  and
c s for membership in the language anbncn   n     

 

  fa  b  cg
  fgovernorg
l    fa  b  cg
c    see below 
r 

    unary constraints
 if  and   
  
 and   
  

 cat
 rid
 lab
 mod

x 
x 
x 
x 

a 
governor  
a 
 pos x    

 if  and   
  
 and   
  

 cat
 rid
 lab
 mod

x 
x 
x 
x 

c 
governor  
c 
 pos x    

 if  and   
  
 and   
  

 cat
 rid
 lab
 mod

x 
x 
x 
x 

b 
governor  
b 
 pos x    

    binary constraints
 if  and     lab x  a 
 or     lab y  b 
    lab y  c   
    pos x   pos y   

 if  and     lab x  b 
    lab y  c  
    pos x   pos y   

 if  and   
  
  
    mod

 lab x 
 lab y 
 pos x 
x   mod

a 
a 
 pos y   
y   

 if  and   
  
  
    lab

 if  and   
  
  
    mod

 lab x 
 lab y 
 pos x 
x   mod

b 
b 
 pos y   
y   

 if  and     lab x  b 
    mod x   pos y  
    rid y  governor  
    lab y  a  

 if  and   
  
  
    mod

 lab x 
 lab y 
 pos x 
x   mod

c 
c 
 pos y   
y   

 if  and   
  
  
    lab

 lab x  a 
 mod x   pos y  
 rid y  governor  
y  c  

 lab x  c 
 mod x   pos y  
 rid y  governor  
y  b  

figure     g    h   r   l   c i accepts the language an bn cn   n    
   

fihelzerman   harper

pos
     
     
     
     
     
     
     
     
      

cat governor role s value
a
a
a
b
b
b
c
c
c

a       
a      
a      
b      
b      
b      
c      
c      
c      

figure     the single parse remaining in the network depicted in figure   after the applying
the constraints in g  and enforcing muse arc consistency 

    

cpu time in seconds

    

extract without muse ac 
    

    

   

extract plus muse ac 
 
 

 

 

 

  

  
  
lattice length

  

  

  

  

figure     this graph depicts the time to extract the parse for the language an bn cn from
a muse csp representing all sentences of length  n  where n varies from   to
   the time to extract the parse without muse arc consistency is compared to
the time to perform muse ac   and extract the parse 

   

fimuse csp  an extension to the constraint satisfaction problem

 

  fa  b  cg
  fgovernorg
l    fw   w g
c    see below 
r 

    unary constraints
 if     lab x  w  
    pos x   mod y   

 if     lab x  w  
    pos x   mod y   
    binary constraints

 if  and     lab x  w  
    lab y  w   
    pos x   pos y   
 if  and   
  
  
    mod

 lab x 
 lab y 
 pos x 
x   mod

w  
w  
 pos y   
y   

 if  and   
  
 and   
  

 lab
 mod
 lab
 cat

w  
 pos y   
w  
 cat y    

x 
x 
y 
x 

 if  and     lab x  w  
    lab y  w   
    mod x   mod y   
 if  and     lab x  w  
    lab y  w  
    pos x   pos y   
    mod x   mod y   
 if  and     lab x  w  
    mod x   pos y   
    lab y  w   

figure     g    h    r   l   c i accepts the language ww 
more complex cases  for example  the constraint grammar shown in figure    can be
to parse all possible sentences of a given length in the the language ww  such that w is
in fa  b  cg   consider the muse csp in figure     the roles and role values are not
depicted to simplify the figure   after applying the constraints and performing muse arc
consistency on this muse csp  there are precisely    strings that are in ww  and their
parses are compactly represented in the constraint network  the constraints plus muse
arc consistency eliminate every value that cannot appear in a parse  for lattices containing
odd length sentences  no role values remain after muse arc consistency  figure    shows
the time needed to extract all of the parses for sentences in the language ww from the
muse csps as we vary the length of w from   to    the time to perform muse ac   and
extract the parses grows slowly as sentence length increases because the number of parses
increases with sentence length  however  it grows more slowly than the time to extract the
parses when muse arc consistency is not used 
similar results have also been obtained with grammars used to parse word graphs constructed from spoken sentences in the resource management and atis domains  harper
et al         zoltowski et al         harper   helzerman      a  

   the muse csp arc consistency algorithm
in this section  we introduce an algorithm  muse ac    to achieve muse csp arc consistency  because our algorithm builds upon the ac   algorithm  mohr   henderson        
we present that algorithm first for comparison purposes 
   

fihelzerman   harper

start

a

a

a

a

a

a

a

a

     

     

     

     

     

     

     

     

b

b

b

b

b

b

b

b

     

     

     

     

     

     

     

     

c

c

c

c

c

c

     

     

     

     

     

     

c

c

     

     

end

figure     a single muse csp can simultaneously test all possible orderings of a s  b s 
and c s for membership in the language ww where jwj      

    

cpu time in seconds

    

    
extract without muse ac 
    

    

   
extract plus muse ac 
 
 

 

 

 
  
lattice length

  

  

  

figure     this graph depicts the time to extract all parses for the language ww from a
muse csp representing all sentences of length   to    such that w   fa  b  cg  
the time to extract all parses without muse arc consistency is compared to
the time to perform muse ac   and extract all parses 

   

fimuse csp  an extension to the constraint satisfaction problem

notation

meaning

an ordered pair of nodes 
all node pairs  i  j    if  i  j     e   then  j  i    e  
e
an ordered pair of node i and label a   li  
 i  a 
faja   l and  i  a  is permitted by the constraints  i e   admissible g
li
r   i  a  j  b      indicates the admissibility a   li and b   lj given
r   i  a  j  b 
binary constraints 
counter  i  j    a  the number of labels in lj which are compatible with a   li  
 j  b    s  i  a  means that a   li and b   lj are simultaneously
s  i  a 
admissible  this implies that a supports b 
m  i  a      indicates that the label a is not admissible for  and
m  i  a 
has already been eliminated from  node i 
a queue of arc support to be deleted 
list
 i  j  

figure     data structures and notation for the arc consistency algorithm  ac   

    csp arc consistency  ac  
ac   builds and maintains several data structures  described in figure     to allow it
to eciently achieve arc consistency in a csp  note that we have modified the notation
slightly to eliminate subscripts  which become quite cumbersome for the path consistency
algorithm   figure    shows the code for initializing the data structures  and figure   
contains the algorithm for eliminating inconsistent labels from the domains  this algorithm
requires  el   time  where e is the number of constraint arcs  and l is the domain size  mohr
  henderson        
in ac    if the label a   li is compatible with b   lj   then a supports b  and vice
versa   to keep track of how much support each label a has  the number of labels in lj
which are compatible with a in li are counted and the total stored in counter  i  j    a 
by the algorithm in figure     if any counter  i  j    a  is zero  then a is removed from li
 because it cannot appear in any solution   the ordered pair  i  a  is placed on the list  and
m i  a  is set to    to avoid removing the element a from li more than once   the algorithm
must also keep track of which labels that label a supports by using s i  a   a set of arc and
label pairs  for example  s i  a    f j  b    j  c g means that a in li supports b and c in lj  
if a is ever removed from li   then b and c will loose some of their support 
after the preprocessing step in figure     the algorithm in figure    loops until list
becomes empty  at which point the csp is arc consistent  when  i  a  is popped off list
by this procedure  for each element  j  b  in s i  a   counter  j  i   b  is decremented  if
counter  j  i   b  becomes zero  b would be removed from lj    j  b  placed on list  and
m j  b  set to   
   

fihelzerman   harper

   list     
   for i   n do
  
for a   li do f
  
s  i  a      
  
m  i  a        g
   for  i  j     e do
  
for a   li do f
  
total      
  
for b   lj do
   
if r   i  a  j  b  then f
   
total    total   
   
s  j  b     s  j  b    f i  a g  g
   
if total     then f
   
li    li   fag 
   
list    list   f i  a g 
   
m  i  a        g
   
counter  i  j    a     total  g

figure     initialization of the data structures for ac   

   while list     do f
  
pop  i  a  from list 
  
for  j  b    s i  a  do f
  
counter  j  i   b     counter  j  i   b      
  
if counter  j  i   b        m  j  b      then f
  
lj    lj   fbg 
  
list    list   f j  b g 
  
m  j  b        g g g

figure     eliminating inconsistent labels from the domains in ac   

   

fimuse csp  an extension to the constraint satisfaction problem

next  we describe the muse arc consistency algorithm for a muse csp  called muse
ac    we purposely keep our notation and presentation of muse ac   as close as possible
to that of ac   so that the reader can benefit from the similarity of the two algorithms 

    muse ac  

muse arc consistency is enforced by removing those labels in each li which violate the conditions of definition    muse ac   builds and maintains several data structures  described
in figure     to allow it to eciently perform this operation  many of these data structures
are borrowed from ac    while others exploit the dag representation of the muse csp
to determine when values are incompatible in all of the segments  figure    shows the
code for initializing the data structures  and figures    and    contain the algorithm for
eliminating inconsistent labels from the domains 
in muse ac   as in ac    if label a at node i is compatible with label b at node j   then
a supports b  to keep track of how much support each label a has  the number of labels in lj
which are compatible with a in li are counted  and the total is stored in counter  i  j    a  
for csp arc consistency  if counter  i  j    a  is zero  a would be immediately removed from
li  because that would mean that a could never appear in any solution  however  in muse
arc consistency  this may not be the case  because even though a does not participate in
a solution for any of the segments which contain i and j   there could be another segment
for which a would be perfectly legal  a label cannot become globally inadmissible until it
is incompatible with every segment  hence  in muse csp  if counter  i  j    a  is zero  the
algorithm simply places   i  j    a  on list and records that fact by setting m  i  j    a  to   
by placing   i  j    a  on list  the algorithm is indicating that the segments containing i and
j do not support the label a 
muse ac   must also keep track of those labels in j that label a in li supports by
using s  i  j    a   a set of node label pairs  for example  s  i  j    a    f j  b    j  c g means
that a in li supports b and c in lj   if a is ever invalid for li   then b and c will loose some
of their support 
because  is a dag  muse ac   is able to use the properties of the dag to identify
local  and hence eciently computable  conditions under which labels become globally
inadmissible  segments are defined as paths through the muse csp from start to end  if
a value associated with a variable is not supported by any of the variables which precede it
or follow it  then there is no way that the value can be used by any segment  so it can be
deleted by the arc consistency algorithm  in addition  if a value in a variable s domain is
supported by the constraints for values associated with a second variable  but the second
variable is preceded or followed by variables that have no values supporting the value  then
because a solution involves a path of variables in the muse dag  the value cannot be
supported for any segment involving the two variables  these two ideas provide the basis
for the remaining data structures used by muse ac   
consider figure     which shows the nodes which are adjacent to node i in the dag 
because every segment in the dag which contains node i is represented as a directed path in
the dag going through node i  either node j or node k must be in every segment containing
i  hence  if the label a is to remain in li  it must be compatible with at least one label in
either lj or lk   also  because either n or m must be contained in every segment containing
   

fihelzerman   harper

notation

meaning

 i  j  

an ordered pair of nodes 
all node pairs  i  j   such that there exists a path of directed edges in g
between i and j   if  i  j     e   then  j  i    e  
an ordered pair of node i and label a   li  

e

 i  a 
  i  j    a 

an ordered pair of a node pair  i  j   and a label a   li  
faja   l and  i  a  is permitted by the constraints  i e   admissible g

li

   i  a  j  b 

r

counter  i  j    a 
s  i  j    a 
m  i  j    a 
list

g

next edgei
prev edgei
local prev support i  a 
local next support i  a 
prev support  i  j    a 
next support  i  j    a 

   i  a  j  b      indicates the admissibility of a   li and b   lj given
binary constraints 
the number of labels in lj which are compatible with a   li  
 j  b    s   i  j    a  means that a   li and b   lj are simultaneously
admissible  this implies that a supports b 
m  i  j    a      indicates that the label a is not admissible for  and
has already been eliminated from  all segments containing i and j  
a queue of arc support to be deleted 
g is the set of node pairs  i  j   such that there exists a directed
edge from i to j  
next edgei contains all node pairs  i  j   such that there exists a
directed edge  i  j     g  it also contains  i  end  if i is the last node
in a segment 
prev edgei contains all node pairs  j  i  such that there exists a
directed edge  j  i    g  it also contains  start  i  if i is the first node
in a segment 
a set of elements  i  j   such that  j  i    prev edgei   and if j    start 
a must be compatible with at least one of j  s labels  if
local prev support i  a  becomes empty  a in i is no longer admissible 
a set of elements  i  j   such that  i  j     next edgei   and if j    end 
a must be compatible with at least one of j  s labels  if
local next support i  a  becomes empty  a in i is no longer admissible 
 i  k    prev support  i  j    a  implies that  k  j     prev edgej   and
if k    start  then a   li is compatible with at least one of j  s and
one of k s labels  if prev support  i  j    a  becomes empty  then a is
no longer admissible in segments containing i and j  
 i  k    next support  i  j    a  implies that  j  k    next edgej   and
if k    end  then a   li is compatible with at least one of j  s and
one of k s labels  if next support  i  j    a  becomes empty  then a is
no longer admissible in segments containing i and j  
r

figure     data structures and notation for muse ac   

   

fimuse csp  an extension to the constraint satisfaction problem

n

j
i

m

k
     a     

localprevsupport i a      i n   i m  
localnextsupport i a      i j  

figure     local prev support and local next support for an example dag  the sets indicate that the label a is allowed for every segment which contains n  m  and j  
but is disallowed for every segment which contains k  the solid directed lines
are members of g  and the solid undirected lines represent members of e  

i  if label a is to remain in li  it must also be compatible with at least one label in either
ln or lm  
in order to track this dependency  two sets are maintained for each label a at node i 
local next support i  a  and local prev support i  a   local next support i  a  is a set of
ordered node pairs  i  j   such that  i  j     next edgei   and if  i  j     e   there is at least one
label b   lj which is compatible with a  local prev support i  a  is a set of ordered pairs
 i  j   such that  j  i    prev edgei   and if  i  j     e   there is at least one label b   lj which
is compatible with a  dummy ordered pairs are also created to handle cases where a node
is at the beginning or end of a network  when  start  i    prev edgei    i  start  is added to
local prev support i  a   and when  i  end    next edgei    i  end  is added to local nextsupport i  a   this is to prevent a label from being ruled out because no nodes precede or
follow it in the dag  whenever one of i s adjacent nodes  j   no longer has any labels b in
its domain which are compatible with a  then  i  j   should be removed from local prevsupport i  a  or local next support i  a   depending on whether the edge is from j to i
or from i to j   respectively  if either local prev support i  a  or local next support i  a 
becomes empty  then a is no longer a part of any muse arc consistent instance  and should
be eliminated from li   in figure     the label a is admissible for the segments containing
both i and j   but not for the segments containing i and k  if because of constraints  the
labels in j become inconsistent with a on i   i  j   would be eliminated from local nextsupport a  i   leaving an empty set  in that case  a would no longer be supported by any

segment 
the algorithm can utilize similar conditions for nodes which are not directly connected
to i by next edgei or prev edgei   consider figure     suppose that the label a at node i is
compatible with a label in lj   but it is incompatible with the labels in lx and ly   then it is
reasonable to eliminate a for all segments containing both i and j   because those segments
would have to include either node x or y   to determine whether a label is admissible
for a set of segments containing i and j   we calculate prev support  i  j    a  and nextsupport  i  j    a  sets  next support  i  j    a  includes all  i  k  arcs which support a in i
   

fihelzerman   harper

z
     a      i

x
j

w

y

figure     if next edgej   f j  x    j  y  g  counter  i  x   a       and counter  i  y    a      
then a is inadmissible for every segment containing both i and j   the solid directed lines are members of g  and the solid undirected lines represent members
of e  
given that there is a directed edge from j to k  and  i  j   supports a  prev support  i  j    a 
includes all  i  k  arcs which support a in i given that there is a directed edge from k
to j   and  i  j   supports a  note that prev support  i  j    a  will contain an ordered pair
 i  j   if  i  j     prev edgej   and next support  i  j    a  will contain an ordered pair  i  j   if
 j  i    next edgej   these elements are included because the edge between nodes i and
j is sucient to allow j  s labels to support a in the segment containing i and j   dummy
ordered pairs are also created to handle cases where a node is at the beginning or end of
a network  when  start  j     prev edgej    i  start  is added to prev support  i  j    a   and
when  j  end    next edgej    i  end  is added to next support  i  j    a   this is to prevent
a label from being ruled out because no nodes precede or follow it in the dag 
figure    shows the prev support  next support  local next support  and local prevsupport sets that the initialization algorithm creates for a simple example dag  after the
initialization step  these sets contain all node pairs that are allowed based on the connectivity of g  later  during the consistency step those node pairs which do not support the
associated label are eliminated from each set 
to illustrate how these data structures are used by the second step of muse ac   shown
in figure     consider what happens if initially          a    list for the muse csp depicted
in figure              a  is placed on list to indicate that the label a in l  is not supported by
any of the labels associated with node    when that value is popped off list  it is necessary
for each     x    s         a  to decrement counter         x  by one  if any counter         x 
becomes    and          x  has not already been placed on the list  then it is added for future
processing  once this is done  it is necessary to remove          a  s inuence on the muse
dag  to handle this  we examine the two sets prev support         a    f              g and
   

fimuse csp  an extension to the constraint satisfaction problem

  
  
  
  
  
  
  
  
  
   
   
   
   
   
   
   
   
   
   
   
   
   
   

list     
e    f i  j  j       i  j      i    j   i  j   n g 
for  i  j    e do
for a   li do f
s  i  j    a      
m  i  j    a       
local prev support i  a       local next support i  a      
prev support  i  j    a       next support  i  j    a       g
for  i  j    e do
for a   li do f

total      

for b   lj do
if r   i  a  j  b  then f

total    total   
s  j  i   b     s  j  i   b    f i  a g  g
if total   then f
list    list   f  i  j    a g 
m  i  j    a        g
counter  i  j    a     total 
prev support  i  j    a     f i  x j i  x    e    x  j     prev edgej g
  f i  j  j i  j     prev edgej g
  f i  start j start  j     prev edgej g 
next support  i  j    a     f i  x j i  x    e    j  x    next edgej g
  f i  j  j j  i    next edgej g
  f i  end j j  end    next edgej g 
local prev support i  a     f i  x j i  x    e    x  i    prev edgei g
  f i  start j start  i    prev edgei g 
local next support i  a     f i  x j i  x    e    i  x    next edgei g
  f i  end j i  end    next edgei g  g
 c 

 

start

 

 

 a b 

end
 d 

prev support        a    f      g
prev support        a    f              g
prev support        b    f      g
prev support        b    f              g
prev support        c    f    start g
prev support        c    f              g
prev support        d    f    start g
prev support        d    f      g
local prev support   a    f    start g
local prev support   b    f    start g
local prev support   c    f      g
local prev support   d    f              g

next support        a    f      g
next support        a    f    end g
next support        b    f      g
next support        b    f    end g
next support        c    f              g
next support        c    f    end g
next support        d    f              g
next support        d    f      g
local next support   a    f              g
local next support   b    f              g
local next support   c    f      g
local next support   d    f    end g

figure     initialization of the data structures for muse ac   along with a simple example 
   

fihelzerman   harper

   while list     do f
  
pop   i  j    a  from list 
  
for  j  b    s  i  j    a  do f
  
counter  j  i   b     counter  j  i   b      
  
if counter  j  i   b        m  j  i   b      then f
  
list    list   f  j  i   b g 
  
m  j  i   b        g g
  
update support sets   i  j    a     see figure     g

figure     eliminating inconsistent labels from the domains in muse ac   
update support sets    i  j    a   f
   for  i  x    prev support  i  j    a    x    j   x    start do f
  
prev support  i  j    a     prev support  i  j    a    f i  x g  
  
next support  i  x   a     next support  i  x   a    f i  j  g 
  
if next support  i  x   a       m  i  x   a      then f
  
list    list   f  i  x   a g 
  
m  i  x   a        g g
   for  i  x    next support  i  j    a    x    j   x    end do f
  
next support  i  j    a     next support  i  j    a    f i  x g 
  
prev support  i  x   a     prev support  i  x   a    f i  j  g 
   
if prev support  i  x   a       m  i  x   a      then f
   
list    list   f  i  x   a g 
   
m  i  x   a        g g
    if  j  i    prev edgei then
    local prev support i  a     local prev support i  a    f i  j  g 
    if local prev support i  a     then f
    li    li   fag 
    for  i  x    local next support i  a    x    j   x    end do f
   
local next support i  a     local next support i  a    f i  x g 
   
if m  i  x   a      then f
   
list    list   f  i  x   a g 
   
m  i  x   a        g g g
    if  i  j     next edgei then
    local next support i  a     local next support i  a    f i  j  g 
    if local next support i  a     then f
    li    li   fag 
    for  i  x    local prev support i  a    x    j   x    start do f
   
local prev support i  a     local prev support i  a    f i  x g 
   
if m  i  x   a      then f
   
list    list   f  i  x   a g 
   
m  i  x   a        g g g g

figure     the function update support sets   i  j    a   for muse ac   
   

fimuse csp  an extension to the constraint satisfaction problem

next support         a    f    end g  note that the value     end  in next support         a 
and the value        in prev support         a   require no further action because they are
dummy values  however  the value        in prev support         a  indicates that        is
a member of next support         a   and since a is not admissible for                should
be removed from next support         a   leaving an empty set  note that because nextsupport         a  is empty  and assuming that m         a                a  is added to list for
further processing  next         is removed from local next support    a   leaving a set of
f      g  during the next iteration of the while loop          a  is popped from list  when
prev support         a  and next support         a  are processed  next support         a    
and prev support         a  contains only a dummy  requiring no action  finally  when       
is removed from local next support    a   the set becomes empty  so a is no longer compatible with any segment containing node   and can be eliminated from further consideration as
a possible label for node    once a is eliminated from node    it is also necessary to remove
the support of a   l  from all labels on nodes that precede node    that is for all nodes x
such that     x    local prev support    a   since local prev support    a    f    start g 
and start is a dummy node  there is no more work to be done 
in contrast  consider what happens if initially          a    list for the muse csp in
figure     in this case  prev support         a  contains        which requires no additional
work  whereas  next support         a  contains         indicating that        must be removed
from prev support         a  s set  after the removal  prev support         a  is non empty 
so the segment containing nodes   and   still supports the label a in l   the reason that
these two cases provide different results is that the constraint arc between nodes   and   is
contained in every segment  whereas  the constraint arc between nodes   and   is found in
only one of them 

    the running time and space complexity of muse ac  
the worst case running time of the routine to initialize the muse ac   data structures
 in figure     is o n  l    n  l   where n is the number of nodes in a muse csp and l
is the number of labels  given that the number of  i  j   elements in e is o n    and the
domain size is o l   the size of the counter and s arrays is o n  l   to determine the
number of supporters for a given arc label pair requires o l  work  hence  initializing the
counter and s arrays requires o n  l   time  however  there are o n  l  prev support and
next support sets  where each prev support  i  j    a  and next support  i  j    a  requires
o n  time to compute  so the time to calculate all prev support and next support sets
is o n  l   finally  the time needed to calculate all local next support and local prevsupport sets is o n  l  because there are o nl  sets with up to o n  elements per set 
the worst case running time for the algorithm which prunes labels that are not muse
arc consistent  in figures    and     also operates in o n  l    n  l  time  clearly the
counter array contains o n  l  entries  a similar argument can be made for the s array 
to keep track of in the algorithm  each counter  i  j    a  can be at most l in magnitude 
and it can never become negative  so the maximum running time for line   in figure   
 given that elements appear on list only once because of m  is o n  l    because there
are o n  l  next support and prev support lists  each up to o n  in size  the maximum
running time required for lines   and   in figure    is o n  l   finally  since there are o nl 
   

fihelzerman   harper

approach
csps
muse csp

nodes
degree of
number of
number of
per path node splitting constraint networks nodes

n
n

kn

k
k

 

n
kn

asymptotic
time

kn n  l 
 
 kn  l     kn   l

table    comparison of the space and time complexity for muse arc consistency on a
muse csp to arc consistency on multiple csps representing a node splitting
problem  e g   lexical ambiguity in parsing  
local prev support and local next support sets from which to eliminate o n  elements 
the maximum running time of lines    and    in figure    is o n  l   hence  the maximum
running time of the muse csp arc consistency algorithm is o n  l    n  l  
the space complexity of muse csp ac   is also o n  l    n  l  because the arrays
counter and m contain o n  l  elements  and there are o n  l  s sets  each containing o l 
items  o n  l  prev support and next support sets  each containing o n  items  and o nl 
local next support and local prev support sets  each containing o n  items 
by comparison  the worst case running time and space complexity for csp arc consistency is o n  l    assuming that there are n  constraint arcs  note that for applications
where l   n  the worst case running times of the algorithms are the same order  this is
true for parsing spoken language with a muse csp   also  if  is representable as planar
dag  in terms of prev edge and next edge  not e   then the running times of the two
algorithms are the same order because the average number of values in prev support and
next support would be a constant  on the other hand  if we compare muse csp to the
use of multiple csps for problems where there are k alternative variables for a particular
variable in a csp  then muse csp ac   is asymptotically more attractive  as shown in
table   

    the correctness of muse ac  

next we prove the correctness of muse ac   
theorem   a label a is eliminated from li by muse ac   if and only if that label is
unsupported by all the arcs  i  x  of every segment 

proof 
   we must show that if a label is eliminated  it is inadmissible in every segment  a
label is eliminated from a domain by muse ac    see lines    and    in figure     if
and only if its local prev support set or its local next support set becomes empty
 see lines    and    in figure      in either case  the label should be eliminated
to make the muse csp instance muse arc consistent  we prove that if a label s
local support sets become empty  that label cannot participate in any muse arc
consistent instance of muse csp  this is proven for local next support  localprev support follows by symmetry   observe that if a   li   and it is unsupported by
   

fimuse csp  an extension to the constraint satisfaction problem

all of the nodes which immediately follow i in the dag  then it cannot participate
in any muse arc consistent instance of muse csp  in line    of figure     if  i  j  
is removed from local next support i  a  set then   i  j    a  must have been popped
off list  the removal of  i  j   from local next support i  a  indicates that  in the
segment containing i and j   a   li is inadmissible  it remains to be shown that
  i  j    a  is put on list if a   li is unsupported by every segment which contains i
and j   this is proven by induction on the number of iterations of the while loop in
figure    
base case  the initialization routine only puts   i  j    a  on list if a   li is incompatible with every label in lj  line    of figure      therefore  a   li is unsupported
by all segments containing i and j  
induction step  assume that at the start of the kth iteration of the while loop
all   x  y    c  which have ever been put on list indicate that c   lx is inadmissible
in every segment which contains x and y   it remains to show that during the kth
iteration  if   i  j    a  is put on list  then a   li is unsupported by every segment
which contains i and j   there are several ways in which a new   i  j    a  can be put
on list 
 a  all labels in lj which were once compatible with a   li have been eliminated 
this item could have been placed on list either during initialization  see line   
in figure     or during a previous iteration of the while loop  see line   in figure
      just as in the csp ac   algorithm  it is obvious that  in this case  a   li
is inadmissible in every segment containing i and j  
 b  prev support  i  j    a      see line    in figure     indicating that a   li
is incompatible with all nodes k for  k  j     prev edgej   the only way for
  i  j    a  to be placed on list for this reason  at line     is because all tuples
of the form   i  k   a   where  k  j     prev edgej   were already put on list  by
the induction hypothesis  these   i  k   a  items were placed on the list because
a   li is inadmissible in with all segments containing i and k in the dag  but if
a is not supported by any node which immediately precedes j in the dag  then
a is unsupported by every segment which contains j   therefore  it is correct to
put   i  j    a  on list 
 c  next support  i  j    a      see line   in figure     indicating that a   li is
incompatible with all nodes k for  j  k    next edgej   the only way for   i  j    a 
to be placed on list  at line    for this reason is because all tuples of the form
  i  k   a   where  j  k    next edgej   were already put on list  by the induction
hypothesis  these   i  k   a  items were placed on the list because a   li is inadmissible in all segments containing i and k in the dag  but if a is not supported
by any node which immediately follows j in the dag  then a is inadmissible in
every segment which contains j   therefore  it is correct to put   i  j    a  on list 
 d  local next support i  a      see line    in figure     indicating that a   li is
incompatible with all nodes k such that  i  k    next edgei   the only way for
  i  j    a  to be placed on list  at line     for this reason is because no node which
follows i in the dag supports a  and so all pairs  i  k  have been legally removed
   

fihelzerman   harper

a

a

 

   

 

   

c

   

b

   

local prev support i a      i j      
local next support i a      i k      

j

i

k

 b     

prev support  i j  a  is nonempty
 c     

 a     
c

prev support  i k  a      i k      

   

next support  i k  a  is nonempty

 

b

   

next support  i j  a      i j      

 

figure     if a   li after muse ac    it must be preceded by some node j and followed
by some node k which support a 
from local next support i  a  during previous iterations  because there is no
segment containing i which supports a  it follows that no segment containing i
and j supports that label 
 e  local prev support i  a      see line    in figure     indicating that a   li
is incompatible with all nodes k such that  k  i    prev edgei   the only way
for   i  j    a  to be placed on list  at line     for this reason is because no node
which precedes i in the dag supports a  and so all pairs  i  k  have been legally
removed from local prev support i  a  during previous iterations  because there
is no segment containing i which supports a  it follows that no segment containing
i and j supports that label 
at the beginning of the  k     th iteration of the while loop  every   x  y    c  on list
implies that c is not supported by any segment which contains x and y   therefore 
by induction  it is true for all iterations of the while loop in figure     hence  if a
label s local support sets become empty  that label cannot participate in a muse arc
consistent instance of muse csp 
   we must also show that if a is not eliminated from li by the muse arc consistency
algorithm  then it must be muse arc consistent  for a to be muse arc consistent 
there must exist at least one path from start to end which goes through node i such
that all nodes n on that path contain at least one label which is compatible with
a   li   if a is not deleted after muse ac    then local next support i  a      and
local prev support i  a       hence  i must be preceded and followed by at least
one node which supports a   li   otherwise  a would have been deleted  as depicted
in figure     we know that there must be some node j which precedes i such that 
if it is not start  it must contain at least one label b which supports a  and nextsupport  i  j    a  and prev support  i  j    a  must be non empty  similarly  there must
be some node k which follows i such that  if it is not end  it must contain at least one
label c which supports a  and next support  i  k   a  and prev support  i  k   a  must
be non empty 
   

fimuse csp  an extension to the constraint satisfaction problem

to show there is a path through the dag  we must show that there is a path beginning
at start which reaches i such that all the nodes along that path support a   li   and
that there is a path beginning at i which reaches end such that all the nodes along
that path support a   li   we will show the necessity of the path from i to end such
that all nodes along that path support a   li given that a remains after muse ac   
the necessity of the path from start to i can be shown in a similar way 
base case  if a   li after muse ac    then there must exist at least one node
which follows i  say k  such that   i  k   a  has never been placed on list  hence 
r   i  a  k  c      for at least one c   lk and next support  i  k   a  and prevsupport  i  k   a  must be non empty 
induction step  assume that there is a path of n nodes that follows i that supports
a   li  but none of those nodes is the end node  this implies that each of the n
nodes contains at least one label compatible with a and that next support  i  n   a 
and prev support  i  n   a  must be non empty for each of the n nodes 
next  we show that a path of length  n      must also support a   li   otherwise 
the label a would have been deleted by muse ac    we have already noted that
for the nth node on the path in the induction step  next support  i  n   a  must be
non empty  hence  there must exist at least one node  say n    which follows the nth
node in the path of length n which supports a   li   if n  is the end node  then
this is the case  if n  is not end  then the only way that  i  n   can be a member
of next support  i  n   a  is if   i  n    a  has not been placed on list  if it hasn t 
then r   i  a  n   l      for at least one l   ln and next support  i  n    a  and prevsupport  i  n    a  must be non empty  if this were not the case  then  i  n   would have
been removed from next support  i  n   a   and n would no longer support a   li  
hence  if a   li after muse ac    then there must be a path of nodes to end such
that for each node n which is not the end node  r   i  a  n  l      for at least one l   ln
and next support  i  n   a  and prev support  i  n   a  must be non empty  hence a
is muse arc consistent 
 

 

from this theorem  we may conclude that muse ac   builds the largest muse arc
consistent structure  because muse arc consistency takes into account all of its segments 
if a single csp were selected from the muse csp after muse arc consistency is enforced 
csp arc consistency could eliminate additional labels 

    a profile of muse ac  

given the fact that muse ac   operates on a composite data structure  the benefits of
using this algorithm can have a high payoff over individually processing csps  in section     
we provided several examples where the payoff is obvious  to gain some insight into factors
inuencing the effectiveness of muse csp  we have conducted an experiment in which
we randomly generate muse csp instances with two different graph topologies  the tree
topology is characterized by two parameters  the branching factor  how many nodes follow
each non leaf node in the tree  and the path length  how many nodes there are in a path
from the root node to a leaf node   the lattice topology is characteristic of a muse csp
   

fihelzerman   harper

which is produced by a hidden markov model based spoken language recognition system
for our constraint based parser  lattices are also characterized by their length and their
branching factor 
for this experiment  we examined trees with a path length of four and a branching
factor of two or three  and lattices with a path length of four and a branching factor of
two or three  we initialized each variable to have either   or   labels  we then randomly
generated constraints in the network  varying the probability that r   i  a  j  b      from
     to     in steps of       for each probability    instances were generated  the lower
the probability that r   i  a  j  b       the tighter the constraints  note that the probability
of a constraint between two nodes should be understood as the probability of a constraint
between two nodes given that a constraint is allowed between them  for example  nodes
that are on the same level in the tree topology are in different segments  and so constraints
cannot occur between them 
the results of this experiment are displayed in figures    and     in each of the four
panels of each figure  four curves are displayed  after muse ac   appears on curves
displaying the average number of labels remaining after muse ac   is applied to instances
of a muse csp as the probability of a constraint varies  the curves labeled solution
indicate the average number of labels remaining after muse ac   that are used in a
solution  csp ac is associated with curves that display the number of labels that remain
in at least one segment when the segment is extracted from the muse csp and csp
arc consistency is applied  unused indicates the difference between the number of labels
that remain after muse ac   and the number that are csp arc consistent in at least one
segment 
for both of the topologies  if the probability r   i  a  j  b      is low  e g       or high
 e g        then muse ac   tracks the performance of arc consistency performed on the
individual instances for either topology  however  the topology does impact the range of
low and high probabilities for which this is true  when constraints are randomly generated 
after muse ac   is performed  the tree topology has fewer remaining values than the lattice
topology that are not csp arc consistent  these results suggest that muse csp ac   may
be more effective for some topologies than for others  however  in the tree topology the
randomly generated constraints between the values of two variables are independent of the
other probabilities generated  this is not the case for the lattice  once a pair of variables has
a set of randomly generated constraints  they are shared by all paths through the lattice 
notice that increasing the number of values in a domain seems to have more impact on
the tree than increasing the branching factor  probably because as the branching factor
increases  so does the number of independent nodes 
this experiment does show that if a problem is tightly constrained  muse ac   can
be effectively used to eliminate values that are unsupported by the constraints  clearly 
this was the case for the parsing problems presented in section      a small set of syntactic
constraints effectively eliminates values that can never be used in a parse for a sentence 
even in a lattice with a branching factor of three and arbitrarily long paths 
   

fimuse csp  an extension to the constraint satisfaction problem

a  tree with branching factor    path length      labels per variable     variables 

b  tree with branching factor    path length      labels per variable     variables 
 

average number of role values per role out of  

average number of role values per role out of  

 

   
after muse ac 
 

csp ac

   

solution

 

   

   
after muse ac 
 

csp ac

   
solution
 

   
unused

unused
 
 

   

   

   

   
   
   
   
probability that r  i a j b   

   

   

 
 

 

c  tree with branching factor    path length      labels per variable     variables 

   

   

   

   

 

average number of role values per role out of  

 

 
after muse ac 
 

csp ac
 

 
solution
 

 

 

after muse ac 
csp ac

 

solution

 

 

unused
 
 

   
   
   
   
probability that r  i a j b   

d  tree with branching factor    path length      labels per variable     variables 

 

average number of role values per role out of  

   

   

   

   

   
   
   
   
probability that r  i a j b   

unused
   

   

 
 

 

   

   

   

   
   
   
   
probability that r  i a j b   

   

   

 

figure     simulation results for trees with a path length of    a branching factor of   or
   and   or   labels per variable 

   

fihelzerman   harper

a  lattice with branching factor    path length      labels per variable    variables 

b  lattice with branching factor    path length      labels per variable     variables 

 

 
after muse ac 

average number of role values per role out of  

average number of role values per role out of  

csp ac
after muse ac 

   

 
solution
   

 

   
unused

 
 

   

   

   

   
   
   
   
probability that r  i a j b   

   

   

 

solution

   

 

unused
   

 
 

 

c  lattice with branching factor    path length      labels per variable    variables 

   

   

   

   
   
   
   
probability that r  i a j b   

   

   

 

d  lattice with branching factor    path length      labels per variable     variables 

 

 
after muse ac 

after muse ac 

average number of role values per role out of  

average number of role values per role out of  

csp ac

   

csp ac

 

 
solution
 

 

 

 
csp ac

 
solution
 

 

unused

 

unused
 
 

   

   

   

   
   
   
   
probability that r  i a j b   

   

   

 
 

 

   

   

   

   
   
   
   
probability that r  i a j b   

   

   

 

figure     simulation results for lattices with a path length of    a branching factor of   or
   and   or   labels per variable 

   

fimuse csp  an extension to the constraint satisfaction problem

local next support b  b       b  e  
local next support b  b       b  c    b  e  
local next support b  b       b  c  

next support  b  c   b       b  d  
next support  b  c   b       b  f  

c
 c  

start

a
 a  

d
 d  

b

end

 b   b   b  
 e  

 f  

e

f

figure     using muse arc consistency data structures to guide a backtracking search 

    extracting solutions from a muse csp after muse ac  
solutions to regular csp problems are typically generated by using backtracking  or fancier
search algorithms  to assemble a set of labels  one for each node  which are consistently
admissible  extracting solutions from muse csps can be done in a similar way  but it
is desirable to make a few modifications to the search algorithms to take advantage of the
extra information which is contained in the muse ac   data structures 
consider the example shown in figure     this figure presents a simple muse csp 
suppose we are only interested in solutions to the segment which is highlighted  fa  b  c 
dg  suppose also that there is only one solution to this segment  a  for a  b  for b  c  for
c  and d  for d  we wish to find this solution by depth first search 
we begin by assigning a  to a  however  the domain of b  in addition to the desired
label b   also contains the labels b  and b   which are valid only for other segments  if
we initially  and naively  choose b  for b and continue doing depth first search  we would
waste a lot of time backtracking  fortunately  after enforcing muse arc consistency  the
muse data structures contain useful information concerning the segments for which the
labels are valid  in this case  the backtracking algorithm can check local next support b 
b   to determine which of the outgoing nodes b  is compatible with  since  b  c  is not an
element of local next support b  b    a smart search algorithm would not choose b  as a
label for b 
however  just looking at the local support sets might not be enough  after the search
algorithm has rejected b  as a label for b  it would go on to consider b   local nextsupport b  b   indicates that b  is a valid label for some of the segments which contain
c  but it fails to tell us that b  is not valid for the segment we are examining  despite
this  the search algorithm can still eliminate b  by looking at next support  b  c   b   
which indicates that b  is only compatible with segments containing the node f  clearly 
this type of information will more effectively guide the search for a solution along a certain
path  improved search strategies for muse csps will be the focus of future research efforts 
   

fihelzerman   harper

   the muse csp path consistency algorithm
in this section  we introduce an algorithm to achieve muse csp path consistency  muse
pc    which builds upon the pc   algorithm  han   lee        

    muse pc  

muse path consistency is enforced by setting r   i  a  j  b  to false when it violates the
conditions of definition    muse pc   builds and maintains several data structures comparable to the data structures defined for muse ac    described in figure     to allow it to
eciently perform this operation  figure    shows the code for initializing the data structures  and figures    and    contain the algorithm for eliminating muse path inconsistent
binary constraints 
muse pc   must keep track of which labels in lk support r   i  a  j  b   to keep track
of how much path support each r   i  a  j  b  has  the number of labels in lk which satisfy
r   i  a  k  c  and r   k  c  j  b  are counted using counter  i  j    k  a  b   additionally  the
algorithm must keep track of the set s  i  j    k  a  b   which contains members of the form
 k  c  where r   i  a  k  c  and r   k  c  j  b  are supported by r   i  a  j  b   if r   i  a  j  b 
ever becomes false in the segment containing i  j   and k  then r   i  a  k  c  and r   k  c  j  b 
will loose some of their support  muse pc   also uses the local next support  local prevsupport  prev support  and next support sets similar to those in muse ac   
muse pc   is able to use the properties of the dag to identify local  and hence
eciently computable  conditions under which binary constraints fail because of lack of path
support  consider figure     which shows the nodes which are adjacent to node i and j in
the dag  because every segment in the dag which contains node i and j is represented as
a directed path in the dag going through both node i and node j   some node must precede
and follow nodes i and j for r   i  a  j  b  to hold  in order to track this dependency  two sets
are maintained for each   i  j    a  b  tuple  local prev support  i  j    a  b  and local nextsupport  i  j    a  b   note that we distinguish local prev support  i  j    a  b  from localprev support  j  i   b  a  to separately keep track of those elements directly preceding i and
those directly preceding j   we also distinguish local next support  i  j    a  b  from localnext support  j  i   b  a   if any of these sets become empty  then the  i  j   arc can no
longer support r   i  a  j  b   local prev support  i  j    a  b  is a set of ordered node pairs
 i  x  such that  x  i    prev edgei   and if  i  x    e   there is at least one label d   lx
which is compatible with r   i  a  j  b   local next support  i  j    a  b  is a set of ordered
node pairs  i  x  such that  i  x    next edgei   and if  i  x    e   there is at least one label
d   lx which is compatible with r   i  a  j  b   dummy ordered pairs are also created to
handle cases where a node is at the beginning or end of a network  when  start  i    prevedgei    i  start  is added to local prev support  i  j    a  b   and when  i  end    next edgei  
 i  end  is added to local next support  i  j    a  b  
the algorithm can utilize similar conditions for nodes which may not be directly connected to i and j   consider figure     suppose that r   i  a  j  b  is compatible with
a label in lk   but is incompatible with the labels in lx and ly   then r   i  a  j  b  and
r   j  b  i  a  are false for all segments containing i  j   and k because those segments would
have to include either node x or y   to determine whether a constraint is admissible for
a set of segments containing i  j   and k  we calculate prev support  i  j    k  a  b   prev   

fimuse csp  an extension to the constraint satisfaction problem

notation

meaning
an ordered pair of nodes 

 i  j  

all node pairs  i  j   such that there exists a path of directed edges in g
between i and j   if  i  j     e   then  j  i    e  
an ordered quadruple of a node pair  i  j    a node k  and the labels
a   li and b   lj  

e

  i  j    k  a  b 

faja   l and  i  a  is permitted by the constraints  i e   admissible g

li

   i  a  j  b      indicates the admissibility a   li and b   lj given
binary constraints 

   i  a  j  b 

r

r

counter  i  j    k  a  b 
s  i  j    k  a  b 
m  i  j    k  a  b 
list

g

next edgei
prev edgei
local prev support  i  j    a  b 
local next support  i  j    a  b 
prev support  i  j    k  a  b 
next support  i  j    k  a  b 

the number of labels in lk which are compatible with r   i  a  j  b  
 k  c    s   i  j    k  a  b  means that c   lk is compatible with
r   i  a  j  b  
m  i  j    k  a  b      indicates that r   i  a  j  b  is false for paths
including i  j   and k 
a queue of path support to be deleted 
g is the set of node pairs  i  j   such that there exists a directed
edge from i to j  
next edgei contains all node pairs  i  j   such that there exists a
directed edge  i  j     g  it also contains  i  end  if i is the last
node in a segment 
prev edgei contains all node pairs  j  i  such that there exists a
directed edge  j  i    g  it also contains  start  i  if i is the first
node in a segment 
a set of elements  i  k  such that  k  i    prev edgei   and if k    start 
r   i  a  j  b  must be compatible with one of k  s labels  if
local prev support  i  j    a  b  becomes empty  r   i  a  j  b  becomes false 
a set of elements  i  k  such that  i  k    next edgei   and if k    end 
r   i  a  j  b  must be compatible with one of k  s labels  if
local next support  i  j    a  b  becomes empty  r   i  a  j  b  becomes false 
 i  x    prev support  i  j    k  a  b  implies that  x  k    prev edgek   and
if x    start  then r   i  a  j  b  is compatible with at least one of k s and
one of x s labels  if prev support  i  j    k  a  b  becomes empty  then
r   i  a  j  b  is no longer true in segments containing i  j   and k  
 i  x    next support  i  j    k  a  b  means that  k  x    next edgek   and
if x    end  then r   i  a  j  b  is compatible with at least one of k s and
one of x s labels  if next support  i  j    k  a  b  becomes empty  then
r   i  a  j  b  is no longer true in segments containing i  j   and k  

figure     data structures and notation for muse pc   

   

fihelzerman   harper

l

     a      n
i

m

o

p

r
j

q

     b     

s

localprevsupport  i j   a  b      i l    i m  
localprevsupport  j i   b  a      j p    j q  
localnextsupport  i j   a  b      i n    i o  
localnextsupport  j i   b  a      j r    j s  

figure     local prev support and local next support for the path consistency of an example dag  the solid directed lines are members of g  and the solid undirected
line represents the  i  j   and  j  i  members of e  
support  j  i   k  b  a   next support  i  j    k  a  b   and next support  j  i   k  b  a  sets  nextsupport  i  j    k  a  b  includes all  i  x  arcs which support r   i  a  j  b  given that there is a
directed edge from k to x  r   i  a  j  b       r   i  a  k  c       and r   k  c  j  b       nextsupport  j  i   k  b  a  is defined similarly   prev support  i  j    k  a  b  includes all  i  x  arcs
which support r   i  a  j  b  given that there is a directed edge from x to k  r   i  a  j  b      
r   i  a  k  c       and r   k  c  j  b       prev support  j  i   k  b  a  is defined similarly  
note that prev support  i  j    k  a  b  will contain an ordered pair  i  k  if  i  k    prevedgek   and  i  j   if  j  k    prev edgek   next support  i  j    k  a  b  will contain an ordered
pair  i  k  if  k  i    next edgek and  i  j   if  k  j     next edgek   these elements are included because the edge between those nodes is sucient to allow the support  dummy
ordered pairs are also created to handle cases where a node is at the beginning or end of
a network  when  start  k    prev edgek    i  start  is added to prev support  i  j    k  a  b  
and when  k  end    next edgek    i  end  is added to next support  i  j    k  a  b  

    the running time  space complexity  and correctness of muse pc  
the worst case running time of the routine to initialize the muse pc   data structures  in
figure     is o n  l    n  l    where n is the number of nodes in a muse csp and l is the
number of labels  given that the number of  i  j   elements in e is o n    and the domain size
is o l   there are o n  l   entries in the counter array for which to determine the number
of supporters  requiring o l  work  hence  initializing the counter array requires o n  l  
time  additionally  there are o n  l   s sets to determine  each with o l  values  so the
time required to initialize them is o n  l    determining each prev support  i  j    k  a  b 
   

fimuse csp  an extension to the constraint satisfaction problem

z

x
     c     

     a     

i

k
w

j      b     
y

figure     if it is found that next edgek   f k  x    k  y  g  counter  i  j    x  a  b   
   and counter  i  j    y  a  b       then r   i  a  j  b  is ruled out for every segment containing i  j   and k  the solid directed lines are members of g  and the
solid undirected lines represent members of e  

   

fihelzerman   harper

  
  
  
  
  
  
  
  
  
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   

list     
e    f i  j  j       i  j      i    j   i  j   n g 
for  i  j    e do
for a   li do
for b   lj do f
local prev support  i  j    a  b       local next support  i  j    a  b      
for k   n such that  i  k    e    j  k    e do f
s  i  j    k  a  b      
m  i  j    k  a  b       
prev support  i  j    k  a  b       next support  i  j    k  a  b       g g
for  i  j    e do
for a   li do
for b   lj such that r   i  a  j  b  do f
for k   n such that  i  k    e    j  k    e do f

total      

for c   lk do
if r   i  a  k  c  and r   k  c  j  b  then f

total    total   
s  i  k   j  a  c     s  i  k   j  a  c    f j  b g  g
if total     then f
list    list   f  i  j    k  a  b g 
m  i  j    k  a  b        g
counter  i  j    k  a  b     total 
prev support  i  j    k  a  b    
f i  x j i  x    e    x   j    j  x    e      x  k    prev edgek g
  f i  k j i  k    prev edgek g
  f i  start j start  k    prev edgek g 
next support  i  j    k  a  b    
f i  x j i  x    e    x   j    j  x    e      k  x    next edgek g
  f i  k j k  i    next edgek g
  f i  end j k  end    next edgek g  g
local prev support  i  j    a  b    
f i  x j i  x    e    x   j    j  x    e      x  i    prev edge ig
  f i  start j start  i    prev edgei g 
local next support  i  j    a  b    
f i  x j i  x    e    x   j    j  x    e      i  x    next edgei g
  f i  end j i  end    next edgeig  g

figure     initialization of the data structures for muse pc   

   

fimuse csp  an extension to the constraint satisfaction problem

   while list     do
  
pop   i  j    k  a  b  from list 
  
for  k  c    s  i  j    k  a  b  do f
  
counter  i  k   j  a  c     counter  i  k   j  a  c      
  
counter  k  i   j  c  a     counter  k  i   j  c  a      
  
if counter  i  k   j  a  c        m  i  k   j  a  c      then f
  
list    list   f  i  k   j  a  c     k  i   j  c  a g 
  
m  i  k   j  a  c        m  k  i   j  c  a        g g
  
update support sets   i  j    k  a  b     see figure     g

figure     eliminating inconsistent binary constraints in muse pc   
update support sets    i  j    k  a  b  f
   for  i  x    prev support  i  j    k  a  b    x    j   x    k   x    start do f
  
prev support  i  j    k  a  b     prev support  i  j    k  a  b    f i  x g 
  
next support  i  j    x  a  b     next support  i  j    x  a  b    f i  k g 
  
if next support  i  j   x  a  b       m  i  j    x  a  b      then f
  
list    list   f  i  j    x  a  b     j  i   x  b  a g 
  
m  i  j    x  a  b        m  j  i   x  b  a        g g
   for  i  x    next support  i  j    k  a  b    x    j   x    k   x    end do f
  
next support  i  j    k  a  b     next support  i  j    k  a  b    f i  x g 
  
prev support  i  j    x  a  b     prev support  i  j    x  a  b    f i  k g 
   
if prev support  i  j   x  a  b       m  i  j    x  a  b      then f
   
list    list   f  i  j    x  a  b     j  i   x  a  b g 
   
m  i  j    x  a  b        m  j  i   x  b  a        g g
    if  k  i    prev edgei then
    local prev support  i  j    a  b     local prev support  i  j    a  b    f i  k g 
    if local prev support  i  j    a  b     then f
    r   i  a  j  b        r   j  b  i  a       
    for  i  x    local next support  i  j    a  b    x    j   x    k   x    end do f
   
local next support  i  j    a  b     local next support  i  j    a  b    f i  x g 
   
if m  i  j    x  a  b      then f
   
list    list   f  i  j    x  a  b     j  i   x  b  a g 
   
m  i  j    x  a  b        m  j  i   x  b  a        g g g
    if  i  k    next edgei then
    local next support  i  j    a  b     local next support  i  j    a  b    f i  k g 
    if local next support  i  j    a  b     then f
    r   i  a  j  b        r   j  b  i  a       
    for  i  x    local prev support  i  j    a  b    x    j   x    k   x    start dof
   
local prev support  i  j    a  b     local prev support  i  j    a  b    f i  x g 
   
if m  i  j    x  a  b      then f
   
list    list   f  i  j    x  a  b     j  i   x  b  a g 
   
m  i  j    x  a  b        m  j  i   x  b  a        g g g g

figure     the function update support sets   i  j    k  a  b   for muse pc   
   

fihelzerman   harper

approach
csps
muse csp

nodes
degree of
number of
number of
per path node splitting constraint networks nodes

n
n

kn

k
k

 

n
kn

asymptotic
time

knn  l 
 
 kn  l     kn   l 

table    comparison of the space and time complexity for muse path consistency on a
muse csp to path consistency on multiple csps representing a node splitting
problem  e g   lexical ambiguity in parsing  
and next support  i  j    k  a  b  requires o n  time  so the time required to calculate all
prev support and next support sets is o n  l    finally  the time needed to calculate all
local next support and local prev support sets is o n  l   because there are o n  l   sets
with up to o n  elements per set 
the worst case running time for the algorithm which enforces muse path consistency
 in figures    and     also operates in o n  l    n  l   time  clearly there are o n  l  
entries in the counter array to keep track of in the algorithm  each counter  i  j    k  a  b 
can be at most l in magnitude  and it can never become negative  so the maximum running
time for lines   and   in figure     given that elements  because of m  appear on the list
only once  is o n  l    because there are o n  l   prev support and next support lists 
each up to o n  in size  the maximum running time required to eliminate o n  elements
from those support sets is o n  l    finally  since there are o n  l   local next support
and local prev support sets from which to eliminate o n  elements  the worst case time
to eliminate items from the local sets is o n  l    hence  the worst case running time of the
muse csp path consistency algorithm is o n  l    n  l   
the space complexity of muse csp pc   is also o n  l    n  l    because the arrays
counter and m contain o n  l   elements and there are o n  l   s sets  each containing
o l  items  o n  l   prev support and next support sets  each containing o n  items  and
o n  l   local next support and local prev support sets  each containing o n  items 
by comparison  the worst case running time and space complexity for csp path consistency  pc    is o n  l    note that for applications where  is representable as planar dag
or l   n  the worst case running times of the algorithms are the same order  if we compare
muse csp to the use of multiple csps for problems where are k alternative variables for
a particular variable in a csp  then muse csp path consistency can be asymptotically
more attractive  as shown in table   
because the proof of correctness for muse pc   is similar to our proof for muse ac   
we will only briey outline the proof here  a binary constraint looses support in muse
pc    see lines    and    in figure     only if its local prev support set or its local nextsupport set becomes empty  see lines    and    in figure     respectively   in either case 
it is inadmissible in any muse path consistent instance  we prove that a constraint s local
support sets become empty if and only if it cannot participate in a muse path consistent
instance of muse csp  this is proven for local next support  local prev support follows
by symmetry   observe that if r   i  a  j  b       and all of the nodes which immediately
   

fimuse csp  an extension to the constraint satisfaction problem

    f  j   j   jg
    f  j   jg

 

 

 

start

end
 

 

figure     an example set of csp problems which would not be a good candidate for muse
csp because of the lack of node sharing 
follow i  and similarly j   in the dag are incompatible with the truth of the constraint 
then it cannot participate in a muse path consistent instance  in line    of figure    
 i  k  is removed from the local next support  i  j    a  b  only after   i  j    k  a  b  has been
popped off list  the removal of  i  k  from local next support  i  j    a  b  indicates that
the segment containing i  j   and k does not support r   i  a  j  b   it remains to be shown
that   i  j    k  a  b  is put on list only if r   i  a  j  b  must be false for every segment which
contains i  j   and k  this can be proven by induction on the number of iterations of the
while loop in figure     much like the proof for muse ac     we must also show that
if r   i  a  j  b      after muse pc    then it is muse path consistent  for r   i  a  j  b 
to be muse path consistent  there must exist at least one path from start to end which
goes through nodes i and j such that all nodes n on that path contain at least one label
consistent with the constraint  this proof would be similar to the second half of the proof
for muse ac   correctness  from this  we may conclude that muse pc   builds the
largest muse path consistent structure 

   combining csps into a muse csp
problems which have an inherent lattice structure or problems which can be solved by
the node splitting approach are natural areas of application for muse csp  because an
exponential number of csps are replaced by a single instance of muse csp  and the dag
representation of  is inherent in the problem  in this section we discuss dag construction
for other application areas which would benefit from the muse csp approach  but for
which it is not as obvious how to construct the dag  any set of csp problems can be
used as the segments of a muse csp  for example  figure    illustrates how two instances
of a csp can be combined into a single muse csp  however  using muse csp for this
example would not be the right choice  node sharing cannot offset the cost of using the
extra muse ac   data structures 
multiple nodes which have the same name in various csps can potentially be represented
as a single node in a muse csp  we assume that if two nodes  k  and k  are given the
same name  say k  in two instances of csp  then they have the same domain and obey the
same constraints  i e  
   lk    lk   i e   their domains are equal  
   r  k   a    r  k   a  for every a   lk    lk   i e   their unary constraints are the
same  
   

fihelzerman   harper

    f  j   jg
    f  j   jg
    f  j   jg

 

 
start

end

 

 

 

start

end

 

 

figure     an example of how maximal node sharing leads to spurious segments  the
first dag contains two paths  f     g and f g  which correspond with none of
the segments  the second dag presents a preferred sharing as created by the
create dag routine 
   r  k   a  i  b    r  k   a  i  b  for labels a   lk    lk  and b   li   where i is in both
segments  i e   their binary constraints are the same  
however  as illustrated in figure     too much sharing of common nodes can introduce
additional segments that do not appear in the original list of csps  because the extra
segments can cause extra work to be done  it is often desirable to create a dag which
shares nodes without introducing extra segments  the algorithm create dag  shown in
figure    takes an arbitrary set of csp problems as input  a list of segments   and outputs
a dag representation for those csps which shares nodes without introducing spurious
segments  create dag calls an auxiliary procedure order sigma defined in figure    
the data structures used in these two routines are defined in figure    
to hold the individual segments in   the routine create dag uses a special data
structure for ordered sets which supports some useful operations  if  is a segment and n
is an integer  then   n  is the node at position n in         is always the start node  and
  j j      is always the end node    k  m  is the ordered subset of  consisting of all the
nodes in positions k through m  in addition  the ordered set allows us to insert a node i
immediately after any node j which is already in the set  each node   pos  is a structure
with a name field and a next set field  which is the set of names of nodes that follow the
node   pos  in a set of segments 
create dag begins by adding special purpose start and end nodes to each segment 
it then calls the routine order sigma shown in figure    to order the nodes in each
segment  order sigma orders the nodes of each segment such that the ones that are the
most common tend to occur earlier in the set  to order the elements  it uses the operator
   i e   larger than  which is defined on nodes  note that the start node is defined to be
the  largest  node  and the end node the  smallest  node  in addition  i   j means either
that i appears in more segments than j does  or if they both appear in the same number of
segments  then i has a lower ordinal number than j   thus the operator   induces a total
ordering on the nodes in n  
when order sigma is first called by create dag it selects the largest node i which
is smaller than the start node  it then constructs the set s   which is a set of those segments
containing i  at this point  the segments in s are ordered such that the start node is first
and i is second  it then calls order sigma to order s for nodes smaller than i  once the
recursive call is done  any segments that were not in s are considered  i e   z    note that
   

fimuse csp  an extension to the constraint satisfaction problem

notation

meaning



a set of node sets  each node set represents a csp 
 is a node set or segment in   each  set is modified to include
begin and end nodes for the create dag algorithm to work
properly  note that     is always the start node  and  jj      is
always the end node  each node  pos  is a structure with a name
and a next set  names of nodes that follow the node in the dag  
g is the set of node pairs  i  j   such that there exists a
directed edge from i to j in the dag created by create dag 
n is the set of nodes that have been placed in the dag by
create dag 
z is a set of segments to order with respect to node j in
order sigma 
the node j is used in order sigma to order the remaining
elements which are smaller than that node 
u is a set of nodes already considered in the current call to
order sigma 
r is a set of nodes in z in order sigma 
the node i is the largest node which is smaller than j in r   u
 if non empty  or r in order sigma 
in order sigma  s is a set of segments in z which contain node i 


g
n
z
j
u
r
i
s

figure     data structures used in create dag and order sigma 

   

fihelzerman   harper

create dag    f

  
  
  
  
  
  
  
  
  

   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   

add start as the first node and end as the last node for every segment in  
order sigma   start  
for pos      to maximum segment length f
    copy   
for       jj       pos f
if  pos  name   end then f
g    g   f  pos        pos  g  g
 

 

else f

same edge set    f j   pos      name    pos      name  
  pos  name    pos  nameg 
next set    f pos      name j   same edge setg 
       same edge set 
if a node with  pos  name is not in n then f
n    n    pos  
 pos  next    next set 
g    g   f  pos        pos  g  g
 

 

else f
node    get the node in n with the name  pos  name 
if node next   next set then f
g    g   f  pos        pos  g  g
else f

new node     create a new node 
new node name    concatenate  pos  name     
node    get the node in n named new node name  if there is one  
while node    node next   next set do f
new node name    concatenate new node name     
node    get the node in n named new node name  if there is one   g
if  node   null  then
n    n   new node 
else new node    node 
new node next    next set 
replace  pos  name with new node name in  pos      next 
g    g   f  pos       new node g 
replace every occurance of  pos  at pos with new node
in all segments of same edge set  g g g g g
eliminate start and end from g and from each      g

figure     routine to create a dag to represent  

   

fimuse csp  an extension to the constraint satisfaction problem

order sigma  z  j   f
   u     
   while z     f
  
r   
 

 

  
  
  
  
  
  
   
   
   
   
   

  z

if r   u     then
i    the  largest  node in r   u which is less than j  
else
i    the  largest  node in r which is less than j  
s    fj   z   i   g  
z    z   s  
if i    end then f
for    s f
put i after j in  
u    u     g
order sigma s  i  g g g

figure     the routine to arrange the nodes within the segments for convenient merging 
after the first iteration of the loop  there is a preference to select the largest node that was
not contained in the segments that were ordered by the recursive call to order sigma 
these items are independent of the ordered segments  and so will not create spurious paths
when placed early in the dag  however  items that occur in the already ordered segments  if
placed earlier than items that do not occur in the ordered segments would tend to introduce
spurious paths  the while loop continues until all segments in  are ordered  the worstcase running time of order sigma is o n     where n is the sum of the cardinalities of the
segments in  
once order sigma orders the nodes in the segments  create dag begins to construct the dag  which is represented as a set of nodes n and a set of directed edges g 
the dag is constructed by going through each segment beginning with the position of the
second element  the position after start   the for loop on line   looks at nodes in a left to
right order  one position at a time  until all the elements of each segment have been added
to g  if a node with a certain name has not already been placed in n  i e   the set of nodes
already in the dag being created  then adding the node to the graph  as well as a directed
edge between   pos      and   pos  to g  cannot create any spurious paths in the dag  on
the other hand  if a node with the same name as   pos  had already been placed in n   then
it is possible that the current segment could add paths to the dag that do not correspond
to any of the segments in   to avoid adding spurious segments  we deal with all segments
at one time that share the same previous node and have a node with the same name at the
current position  the basic idea is to add that edge only once and to keep track of all nodes
that can follow that node in the dag  by doing this  we can easily determine whether that
same node can be used if it occurs in another segment in a later position  the same node
can be used only if it is followed by precisely the same set of next nodes that follow the
node already placed in the graph  otherwise  the second node would have to be renamed to
avoid adding spurious segments  in such an event  we create a new name for the node 
   

fihelzerman   harper

note that once the dag is complete  we eliminate the start and end nodes from g
 and their corresponding outgoing and incoming edges  to make g consistent with its use
in the muse arc consistency and muse path consistency algorithms  the running time of
create dag is also o n     where n is the sum of the cardinalities of the segments in  
even though the dags produced by the routine create dag do have nice properties 
this routine should probably be used only as a starting point for custom combining routines
which are specific to the intended application area  we believe that domain specific information can play an important role in muse combination  an example of a domain specific
combining algorithm is presented in  harper et al          which describes a spoken language
parsing system which uses muse csp  a distinguishing feature of this application s combining algorithm is that instead of avoiding the creation of extra segments  it allows controlled
introduction of extra segments because the extra segments often represent sentences which
an n best sentence spoken language recognition system would miss 

   conclusion

in conclusion  muse csp can be used to eciently represent several similar instances of the
constraint satisfaction problem simultaneously  if multiple instances of a csp have some
common variables with the same domains and compatible constraints  then they can be
combined into a single instance of a muse csp  and much of the work required to enforce
node  arc  and path consistency need not be duplicated across the instances  especially if
the constraints are suciently tight 
we have developed a muse csp constraint based parser  parsec  harper   helzerman      a  harper et al         zoltowski et al          which is capable of parsing word
graphs containing multiple sentence hypotheses  we have developed syntactic and semantic
constraints for parsing sentences  which when applied to a word graph  eliminate those hypotheses that are syntactically or semantically incorrect  for our work in speech processing 
the muse arc consistency algorithm is very effective at pruning the incompatible labels for
the individual csps represented in the composite structure  when extracting each of the
parses for sentences remaining in the muse csp after muse ac    it is usually unnecessary to enforce arc consistency on the csp represented by that directed path through the
network because of the tightness of the syntactic and semantic constraints 
speech processing is not the only area where segmenting the signal into higher level
chunks is problematic  vision systems and handwriting analysis systems have comparable
problems  in addition  problems that allow for parallel alternative choices for the type of
a variable  as in parsing lexically ambiguous sentences  are also excellent candidates for
muse csp 
c   implementations of the algorithms described in this paper are available at the following location  ftp   transform ecn purdue edu pub speech harper code   this directory
contains a readme file and a file called muse csp tar z 

   

fimuse csp  an extension to the constraint satisfaction problem

acknowledgements
this work was supported in part by the purdue research foundation and a grant from
intel research council  we would like to thank the anonymous reviewers for their insightful
recommendations for improving this paper 

references

bessiere  c          arc consistency and arc consistency again  artificial intelligence     
        
davis  a  l     rosenfeld  a          cooperating processes for low level vision  a survey 
artificial intelligence              
dechter  r          from local to global consistency  artificial intelligence             
dechter  r   meiri  i     pearl  j          temporal constraint networks  artificial intelligence            
dechter  r     pearl  j          network based heuristics for constraint satisfaction problems  artificial intelligence           
freuder  e          partial constraint satisfaction  in proceedings of the international joint
conference on artificial intelligence  pp          
freuder  e          complexity of k tree structured constraint satisfaction problems  in
proceedings of the eighth national conference on artificial intelligence  pp      
han  c     lee  c          comments on mohr and henderson s path consistency algorithm 
artificial intelligence              
harper  m  p     helzerman  r  a       a   extensions to constraint dependency parsing
for spoken language processing  computer speech and language                 
harper  m  p     helzerman  r  a       b   managing multiple knowledge sources in
constraint based parsing of spoken language  fundamenta informaticae             
        
harper  m  p   jamieson  l  h   zoltowski  c  b     helzerman  r          semantics and
constraint parsing of word graphs  in proceedings of the international conference on
acoustics  speech  and signal processing  pp  ii    ii    
mackworth  a  k          consistency in networks of relations  artificial intelligence        
       
mackworth  a  k     freuder  e          the complexity of some polynomial networkconsistency algorithms for constraint satisfaction problems  artificial intelligence     
      
   

fihelzerman   harper

maruyama  h       a   constraint dependency grammar  tech  rep   rt      ibm 
tokyo  japan 
maruyama  h       b   constraint dependency grammar and its weak generative capacity 
computer software 
maruyama  h       c   structural disambiguation with constraint propagation  in the
proceedings of the annual meeting of acl  pp        
mohr  r     henderson  t  c          arc and path consistency revisited  artificial intelligence              
montanari  u          networks of constraints  fundamental properties and applications
to picture processing  information science            
van beek  p          on the inherent level of local consistency in constraint networks  in
proceedings of the twelfth national conference on artificial intelligence  pp          
villain  m     kautz  h          constraint propagation algorithms for temporal reasoning 
in proceedings of the fifth national conference on artificial intelligence  pp          
waltz  d  l          understanding line drawings of scenes with shadows  in winston  p 
 ed    the psychology of computer vision  mcgraw hill  new york 
zoltowski  c  b   harper  m  p   jamieson  l  h     helzerman  r          parsec  a
constraint based framework for spoken language understanding  in proceedings of the
international conference on spoken language understanding  pp          

   

fi