journal artificial intelligence research                

submitted       published     

accelerating partial order planners  techniques
effective search control pruning
alfonso gerevini

gerevini ing unibs it

lenhart schubert

schubert cs rochester edu

dipartimento di elettronica per l automazione  universita di brescia
via branze     i       brescia  italy
department computer science  university rochester
rochester  ny             usa

abstract

propose domain independent techniques bringing well founded partialorder planners closer practicality  first two techniques aimed improving
search control keeping overhead costs low  one based simple adjustment
default a  heuristic used ucpop select plans refinement  based
preferring  zero commitment   forced  plan refinements whenever possible  using
lifo prioritization otherwise  radical technique use operator parameter
domains prune search  domains initially computed definitions
operators initial goal conditions  using polynomial time algorithm
propagates sets constants operator graph  starting initial conditions 
planning  parameter domains used prune nonviable operator instances
remove spurious clobbering threats  experiments based modifications ucpop 
improved plan goal selection strategies gave speedups factors ranging  
     variety problems nontrivial unmodified version 
crucially  hardest problems gave greatest improvements  pruning technique
based parameter domains often gave speedups order magnitude
dicult problems  default ucpop search strategy improved
strategy  lisp code techniques test problems provided on line
appendices 

   introduction

concerned improving performance  well founded  domain independent planners   planners permit proofs soundness  completeness  desirable
theoretical properties  state of the art example planner ucpop  barrett
et al         penberthy   weld         whose intellectual ancestry includes strips  fikes  
nilsson         tweak  chapman         snlp  mcallester   rosenblitt        
planners unfortunately perform well present  comparison practically
oriented planners sipe  wilkins         prs  georgeff   lansky         o plan
 currie   tate        
however  appear ample opportunities bringing well founded planners
closer practicality  following  begin suggesting improvements
search control planning  based carefully formulated strategies selecting partial
plans refinement  choosing open conditions selected partial plan  plan c      ai access foundation morgan kaufmann publishers  rights reserved 

figerevini   schubert
selection strategy uses s oc   number steps plan plus number open
conditions still established   heuristic measure ucpop s a  search
plan space   addition attenuated term ecting number threats  unsafe
conditions  uc     uc  sometimes advantageous    aw selection strategy 
term zlifo  prefers  zero commitment  plan refinements others  otherwise
uses lifo  stack  discipline  zero commitment refinements logically necessary ones 
either eliminate plan altogether contains irremediable aw  add
unique step unique causal link  from initial state  establish open condition
cannot established way  strategy closely related ones proposed
peot   smith        joslin   pollack        generally appears perform better
either 
describe two classes techniques section   below  section  
report experimental results based slightly modified versions ucpop  
dicult problems taken available ucpop test suite elsewhere  obtain
improvements factors ranging         hardest problems
giving greatest improvements 
turn proposal using computed operator parameter domains
planning  particular  section   motivate describe method precomputing parameter domains based propagating sets constants forward initial
conditions   process iterative  algorithm runs within time bound
polynomial size problem specification  provide details algorithm 
along theorems correctness tractability  sections         online
appendix   
section   show use parameter domain information ucpop style planner  planning  parameter domains used prune operator instances whose
parameter domains inconsistent binding constraints  eliminate spurious
threats cannot  fact  realized without violating domain constraints  illustrate
effectiveness technique examples drawn ucpop test suite well
trains transportation planning world developed rochester  allen   schubert 
      allen et al          tests  apply parameter domain information
context default ucpop search strategy  demonstrate significant gains
problems  particularly challenging ones  e g   speedups order
magnitude several problems strips world      fold speedup
trains problem  
another set tests trains world  use improved search strategies
baseline  i e   ask whether additional speedups obtainable use parameter
   search strategy described  a  ida   search  penberthy   weld         code
ucpop     described generally best first  since arbitrary ranking functions  necessarily
corresponding a  heuristics  may plugged in  choices s oc s oc uc
plan ranking heuristic  as discussed section       natural view strategy a  strategy 
   techniques describe applicable planners  focus ucpop
well known lisp code readily available  system obtained via anonymous ftp
cs washington edu 
   hope notion parameter domain  set admissible bindings  constants   cause
confusion notion planning domain  specified set operators  along constraints
admissible initial conditions goal conditions 

  

fiaccelerating partial order planners
domains  obtainable s oc zlifo search strategies  experimental results show speedups factor    use parameter
domains  top obtained improved search strategies  the combined speedup
      
evidence effectiveness using parameter domains combination
search strategy dependent peculiarity latter  include
results ucpop s default strategy  joslin pollack s  least cost aw repair   lcfr 
strategy  joslin   pollack        peot smith s  least commitment   lc  open
condition selection strategy  peot   smith        section   
section    state conclusions  comment related work mention
possible extensions techniques 

   plan selection goal selection

basing discussion experiments ucpop  algorithm exemplifying
state art well founded partial order planning  thus begin sketch
algorithm  referring reader  barrett et al         penberthy   weld        details 
next two subsections motivate describe improved plan selection
goal selection strategies 

    ucpop

ucpop uses strips like operators  positive negative preconditions positive

negative effects  initial state consists positive predications constant arguments
 if any   ground predications false default  unlike strips  ucpop
allows conditional effects  expressed   part when clauses specifying  possibly complex 
extra condition needed effect  possibly complex  effect itself  instance 
action puton  x  y  z    put  x  y  z   might conditional effects stating
 y table  clear end action  z
table  clear end action   u  ucpop indicates
universally quantified conditions effects permitted well  instance 
permissible precondition pickup  x  action says  y   not
 on  y  x   holds  universal statements handled explicit substitution domain
constants need concern us point 
essence  ucpop explores space partially specified plans  paired
agenda goals still satisfied threats still averted  initial plan contains
dummy  start  action whose effects given initial conditions  dummy
 end  action whose preconditions given goals  thus goals uniformly viewed
action preconditions  uniformly achieved effects actions  including
 start  action 
plans consist collection steps  i e   actions obtained instantiating available operators   along set causal links  set binding constraints 
set ordering constraints  open goal  precondition  selected
agenda  established  if possible  either adding step effect unifies
goal  using existing step effect unifies goal   in
latter case  must consistent current ordering constraints place existing
  

figerevini   schubert
step goal  i e   step whose preconditions generated goal  
new existing step used establish goal way  several side effects 
causal link  s   q    added  indicates step  producing 
goal condition q indicates step  consuming  q  causal link serves
protect intended effect added  or reused  step interference
steps 
binding constraints added  corresponding unifier action effect
question goal  precondition  achieves 
ordering constraint added  placing step question step whose
precondition achieves 
action question new  preconditions added agenda new
goals  except eq neq conditions integrated binding constraints   see
below  
new threats  unsafe conditions  determined  new step causal link 
steps threaten causal link effects unifiable condition
protected causal link  and effects occur temporally causal
link   effects new step may similarly threaten causal links 
either case  new threats placed agenda  useful distinguish definite
threats potential threats  former unification
confirmed threat involved new binding variables 
binding constraints assert identity  eq  nonidentity  neq  two variables variable
constant  eq constraints arise unifying open goals action effects  neqconstraints arise  i  neq preconditions newly instantiated actions   ii  matching
negative goals containing variables initial state   iii  averting threats
 separation   i e   forcing non equality two variables variable constant
unified threat detection  neq constraints may disjunctive  handled simply
generating separate plans disjunct 
overall control loop ucpop consists selecting plan current list
plans  initially single plan based  start   end    selecting goal threat
agenda  replacing plan corresponding refined plans  agenda item
goal  refined plans corresponding ways establishing goal using
new existing step  agenda item definite threat causal link  s   q    
three refined plans  two constrain threatening step
step  demotion  step  promotion   thus averting threat 
third possibility arises effect threatening  s   q    conditional effect
threatening action  conditional threat averted creating goal denying
precondition needed conditional effect 
ucpop  delay separation  switch   d sep   turned on 
definite threats dealt with  note potential threats may become definite result
added binding constraints   they may  expire  result added binding
ordering constraints  i e   threatening effect may longer unify threatened
condition may forced occur threatened causal link  expired
p

c

p

c

p

p

c

p

  

c

c

fiaccelerating partial order planners
threats removed agenda selected    d sep  off  potential threats
well definite ones averted  separation additional method
besides three methods above 
inconsistencies binding constraints ordering constraints detected
first occur  as result adding new constraint  corresponding plans eliminated  planning fails plans remain  success condition creation plan
consistent binding ordering constraints empty agenda 
allowance conditional effects universal conditions effects causes
minor perturbations operation ucpop  instance  conditional effects lead
multiple matches operators given goal  match generating different
preconditions   of course  multiple matches even without conditional effects 
predicates occur effects  
key issues us right strategic ones  plans selected
current set plans  discussed section       goals selected given plan
 discussed section      

    trouble counting unsafe conditions

choice next plan refine ucpop system based a  best first
search  recall a  uses heuristic estimate f  p  overall solution cost consisting
part g  p    cost current partial solution  plan  p part h p    estimate
additional cost best complete solution extends p  current context
helpful think f  p  measure plan complexity  i e    good  plans simple
 low complexity  plans 
two points reader reminded  first  order a 
guarantee discovery optimal plan  i e    admissibility  condition   h p 
overestimate remaining solution cost  nilsson         second  aim
necessarily find optimal solution find satisfactory solution quickly  f  p 
augmented include term estimates remaining cost finding solution 
one common way use term proportional h p  well  i e  
emphasize h component f relative g  component  reasonable
extent plans nearly complete  indicated low h value  likely
take least effort complete  thus prefer pursue plan p  seems closer
complete plan p completion  even though overall complexity
estimate p  may greater p  nilsson         pages         alternatively 
could add heuristic estimate remaining cost finding solution f  p 
less independent estimate h p  
considerations mind  evaluate advisability including
various terms ucpop s function guiding a  search  namely
s  oc  cl  uc 
number steps partial plan  oc number open conditions
 unsatisfied goals preconditions   cl number causal links  uc
number unsafe conditions  the number pairs steps causal links step
  

figerevini   schubert
threatens causal link   default combination used ucpop s oc uc  
becomes s oc uc f special open conditions called  facts  present 
conditions state dependent  e g   numerical relation  add one  x  y  
geometrical one  loc in room  x  y  room   established lisp functions
 barrett et al          since test problems involved facts  discuss
f term except say followed ucpop default strategy including
term relevant  see tileworld problems section     remarks
section     connection parameter domain experiments  
      s  number steps currently plan

naturally viewed comprising g  p   plan complexity far  intuitively 
plan complex extent contains many steps  domains might
want make distinctions among costs different kinds steps  simple step count
seems reasonable generic complexity measure 
      oc  number open conditions

viewed playing role h p   since remaining open condition must
established step  catch may possible use existing steps
plan  including  start   i e   initial conditions  establish remaining open conditions 
thus oc overestimate number steps still added  forfeiting admissibility 
despite criticism  several considerations favor retention oc term  first 
better estimator residual plan complexity seems hard come by  perhaps one could
modify oc discounting open conditions matched existing actions 
presumes open conditions actually achieved action re use 
improbable remaining threats  remaining goals requiring new steps   second 
possibility oc overestimate residual plan complexity rarely actualized  since typically steps still need added achieve goals 
steps typically introduce open conditions requiring new steps  finally  extent oc times overestimate residual plan complexity 
viewed emphasizing h p  term f  p   thus promoting faster problem solving
explained above 
      cl  number causal links

one might motivate inclusion term arguing numerous causal links
indicative complex plan  such  cl appears alternative step counting 
   way  recommended  strategy  ucpop implementation makes available various
options controlling search  used discretion experimenters  present work
prompted incorporation particular strategies option ucpop     
   note threats remaining goals impose constraints may consistent seemingly
possible instances action re use  clear enough threats  often imply temporal ordering
constraints inconsistent re use action  fairly clear remaining goals  instance 
towers hanoi small disk d  initially medium disk d   turn big disk
d   d  peg p   goal move tower third peg p   seems ucpop initially
 on d  d    on d  d   could achieved  re use   start   however  third goal  on
d  p   implies various actions must added plan inconsistent two
seemingly possible instances action re use 

   

fiaccelerating partial order planners
however  note cl general larger s  since every step plan establishes
least one open condition thus introduces least one causal link  larger cl
relative s  subgoals achieved action re use  hence  use cl instead
 or addition to  g  p  term  would effect saying achieving multiple
subgoals single step undesirable  would tend search ways achieving
multiple goals multiple steps  even achieved single step 
clearly good idea  justifies exclusion cl f  p  
      uc  number unsafe conditions

note first clearly g  measure  number threats
tend increase establish subgoals without curtailing threats  threats
elements plan constructed contribute
complexity  fact  plan done threats gone 
uc viewed h measure  one argument sorts armative
following  partial plans expandable complete plans  high value
uc makes likely partial plan contains irresolvable con icts  regard
impossible plans infinite cost  inclusion term increasing uc part
h measure reasonable  carries serious risk  though  since case
partial plan consistent completion  despite high uc count   inclusion
term greatly overestimate residual plan complexity 
another possible armative argument conditional threats sometimes resolved
 confrontation   introduces new goal denying condition required threatening conditional effect  new goal may turn require new steps achievement 
adding plan complexity  however  link complexity tenuous  first
place  many ucpop test domains involve conditional effects  threat removal
promotion  demotion separation adds steps  even conditional effects
present  many unconditional well conditional threats averted methods 
furthermore  uc could swamp terms since threats may appear expire
groups size o n   n number steps plan  instance  consider
partial plan involves moves robot r locations l        ln 
n causal links labeled  at r l          at r ln   new move location l
added  initially indefinite point departure  x  produces effects  at
r l   not  at r  x    latter threaten n causal links 
least new move first temporally unordered relative n existing moves 
new action subsequently happens demoted precede first move  or
promoted follow last    x becomes bound constant distinct
l        ln  n threats expire  keeping mind different steps plan may
similar effects  see half steps could threaten causal links
others  case could o n    unsafe conditions  destined expire result
o n  promotions demotions  fact even single new binding constraint may cause
o n    threats expire  instance  n   effects  not  p  x   threatening
n   causal links labeled  p  y   binding constraint  neq  x  y  added  n    
threats expire  recall expired threats selected agenda ucpop 
recognized discarded without action 
   

figerevini   schubert
conclusion would mistake include uc full general h measure 
though increasing function uc remains small enough mask oc may
worth including h 
finally  uc regarded measure remaining cost finding solution 
here  similar arguments apply  armative side  argue
high value uc indicates may facing combinatorially explosive  timeconsuming search set promotions demotions produce con ict free step
ordering  words  high value uc may indicate high residual problem solving
cost   and end search  may still lack solution  viable step
ordering exists   hand  already noted unsafe conditions include
many possible con icts may expire result subsequent partial ordering choices
variable binding choices specifically aimed removing con icts  counting
unsafe conditions arbitrarily overestimate number genuine refinement steps 
hence problem solving effort  still needed complete plan 
uc scarcely trustworthy measure residual planning cost
measure residual plan cost 
thus conclude promising general heuristic measure plan selection
s oc  possibly augmented attenuated form uc term dominate
s oc component   for instance  one might add small fraction term 
uc     subtly   avoid swamping quadratic component   term proportional
uc    
 

    goal selection strategy

important opportunity improving planning performance independently domain
lies identifying forced refinements  i e   refinements made deterministically 
specifically  considering possible refinements given partial plan  makes sense
give top priority open conditions cannot achieved  preferring open
conditions achieved one way   either addition action
yet plan  unique match initial conditions 
argument giving top priority unachievable goals plan containing
goals eliminated once  thus prevent allocation effort refinement
doomed plans  generation refinement doomed successor plans 
argument preferring open conditions achieved one way
equally apparent  since every open condition must eventually established
action  follows action unique  must part every possible completion
partial plan consideration  so  adding action  zero commitment 
refinement  involving choices guesswork  time  adding refinement
general narrows search space adding binding constraints  ordering constraints
threats  constrain existing steps subsequently added steps  unique
refinements narrowing down monotonic  never needing revocation  example 
suppose refinement happens add constraints eliminate certain action instance
possible way achieving certain open condition c   refinement unique 
assured completion plan contains way establishing c  
unique  assurance  since alternative refinement may
   

fiaccelerating partial order planners
compatible use achieve c   short  zero commitment strategy cuts
search space without loss access viable solutions 
peot smith        studied strategy preferring forced threats unforced
threats  used  least commitment   lc  strategy handling open conditions 
least commitment always selects open condition generates fewest refined
plans  thus entails priorities unachievable uniquely achievable goals
 while entailing certain prioritization nonuniquely achievable goals   joslin
pollack        studied uniform application strategy threats open
conditions ucpop  terming strategy  least cost aw repair   lcfr   combining
ucpop s default plan selection strategy  obtained significant search reductions
 though less significant running time reductions  mainly implementation reasons 
intrinsic overhead computing  repair costs   majority
problems ucpop test suite 
joslin   pollack        subsequently srinivasan   howe        proposed
variants lcfr designed reduce overhead incurred lcfr aw selection 
strategies employ various assumptions aw repair costs  allowing
arduous forms cost estimation  requiring look ahead generation plans  confined
subset aws plan  rest approximation used
significantly increase overhead  teams obtained quite significant reductions
overhead costs many cases  e g   factors ranging     
dicult problems  however  overall performance sometimes adversely affected 
joslin pollack found variant  qlcfr  solved fewer problems lcfr 
increase number plans generated cases  srinivasan  
howe s four strategies slightly better lcfr    problem domains
significantly worse others  terms plans examined search  best
overall strategy  uses similar action instances similar aws  slightly better
  domains  slightly worse    significantly worse    and cases
number plans examined factor    default ucpop  
unmodified form ucpop  goals selected agenda according
lifo  last in first out  i e   stack  discipline  based experience search processes
ai general  strategy much recommend it  simple default 
first place  overhead cost low compared strategies use heuristic evaluation
lookahead prioritize goals  well  tend maintain focus achievement
particular higher level goal regression   much prolog goal chaining   rather
attempting achieve multiple goals breadth first fashion 
maintaining focus single goal advantageous least
goals achieved independent  instance  suppose two goals g  g 
achieved various ways  choosing particular method achieving g 
rule methods achieving g   maintain focus g 
solved  attempting g   total cost solving goals sum
costs solving individually  switch back forth  solutions
goals involve searches encounter many dead ends  combined cost
much larger  tend search unsolvable subtree g  search
tree repeatedly  combination various alternatives g  search tree  and vice
versa   argument still validity even g  g  entirely
   

figerevini   schubert
independent  i e   long g  gives rise subproblems tend fail
way regardless choices made attempt solve g   or vice versa   shifting
attention g  g  tend generate set partial plans unnecessarily
 cross multiplies  alternatives 
therefore chosen stay ucpop s lifo strategy whenever
zero commitment choices  led substantial improvements lcfr
experiments 
thus strategy  term zlifo   zero commitment last in first out    chooses
next aw according following preferences 
   definite threat   d sep  turned on   using lifo pick among these 
   open condition cannot established way 
   open condition resolved one way  preferring open conditions
established introducing new action established
using  start   
   open condition  using lifo pick among these 
hence overhead incurred zlifo aw selection limited open conditions  lower overhead incurred lcfr  furthermore 
significantly lower practice overhead incurred lc  testing
whether oc zero commitment choice  i e   whether established
one way  less expensive computing total number ways achieve it 
online appendix   give pseudocode zlifo selection open
condition  preferences       recently implementation packaged
ucpop      new version ucpop available anonymous ftp cs washington edu 

   experiments using ucpop

order test ideas modified version     ucpop  barrett et al          replacing default plan selection strategy  s oc uc  goal selection strategy  lifo 
incorporate strategies discussed previous sections 
tested modified planner several problems ucpop suite  emphasizing
proved challenging previous strategies  artificial problems
due kambhampati et al          trains transportation domain developed
rochester  allen   schubert        allen et al          joslin   pollack s tileworld
domain  joslin   pollack         brie describe test problems platforms
parameter settings used  present experimental results improved
search strategies 
         zero commitment choices  experiments  described next section 
sub preference    gave improvements context russell s tire changing domain  in particular
fix    without significant deterioration performance domains 

   

fiaccelerating partial order planners

    test problems experimental settings

ucpop problems include towers hanoi  t h   fixa  fix   fixit  tower invert  
test ferry  sussman anomaly  case h  added   operator version
ucpop single operator version  since h particularly hard problem ucpop
diculty long known sensitive formalization  e g    green 
        fixa problem dan weld s  fridge domain   compressor
fridge exchanged  requiring unscrewing several screws  stopping fridge 
removing backplane  making exchange  fix  stuart russell s   tire
domain   new wheel mounted lowered ground  the old wheel
jacked already nuts loosened   requires unscrewing nuts holding
old wheel  removing wheel  putting new wheel  screwing nuts  jacking
hub  tightening nuts  fixit complicated  wheel yet
jacked initially nuts yet loosened  spare tire needs ated 
jack  wrench pump need taken trunk stowed
end  tower invert  problem blocks world  requiring topmost block stack
four blocks made bottom most  test ferry simple problem requiring two cars
moved b using one car ferry  boarding  sailing  unboarding
car 
artificial problems correspond two parameter settings art        one
two artificial domains served testbed kambhampati et al  s extensive
study behavior various planning strategies function problem parameters
 kambhampati et al          art      provides two layers    operators each 
layer   achieve preconditions layer    operator
layer   achieves one    goals  however  operators layer establish
clobber preconditions neighbors  force operators used
certain order 
version trains domain encoded involves four cities  avon  bath 
corning  dansville  connected four tracks diamond pattern  fifth city  elmira 
connected corning fifth track  available resources  located various
cities  consist banana warehouse  orange warehouse  orange juice factory  three
train engines  not coupled cars     boxcars  suitable transporting oranges
bananas   tanker car  suitable transporting orange juice   goals typically
deliver oranges  bananas  orange juice city  requiring engine car coupling  car
loading unloading  engine driving  possibly oj manufacture 
tileworld domain consists grid holes tiles scattered  given
tile may may fit particular hole  goals fill one holes
using three possible actions  picking tile  going x y location grid 
dropping tile hole  agent carry four tiles time 
formalizations domains terms ucpop s language provided online
appendix    experiments problems except fixit  trains problems
tileworld problems conducted sun    using lucid common lisp       
rest  tables x xi next subsection  conducted sun    using allegro
common lisp      judging repeated experiments  think
est

est

clob

   

clob

figerevini   schubert

goal selection plan selection cpu sec
lifo
lifo
zlifo
zlifo

s oc uc
s oc
s oc uc
s oc

      
    
    
    

plans

               
       
         
       

table i  performance plan goal selection strategies t of h 
differences platforms significantly impact performance improvements   among
search control functions provided ucpop  used default bestf search
problem solvable within search limit        plans generated  used
function id bf search  an implementation linear space best first search algorithm
given korf         limit exceeded   experiments delayseparation switch   d sep   on  except using lcfr strategy 

    experimental results zlifo s oc

tables i xi show cpu time  seconds  number plans created explored
ucpop twelve problems domains described above  towers hanoi three
disks either one operator  t of h   three operators  t of h    fridge domain
 fixa   tire changing domain  fix  fixit   blocks world  tower invert 
sussman anomaly   ferry domain  test ferry   artificial domain art     
 specifically  art     art       trains domain  trains   trains  trains  
tileworld domain  tw         tw     number plans created explored
cpu time important performance measures  number plans  indicates
search space size  stable measure sense depends search
algorithm  implementation   time still interest since improvement
search may purchased price time consuming evaluation
alternatives  turns pay price overhead substitute
strategies defaults  factors ranging          rarely higher  per plan
created   may due slightly greater inherent complexity zlifo versus lifo 
think differences could reduced substituting modified data structures
ucpop   committed altering these 
tables ii show h plan selection strategy s oc gives dramatic
improvements default s oc uc strategy   in tests default lifo goal
selection strategy used   fact  ucpop solved t of h       seconds using s oc
versus       seconds using s oc uc  t of h  proved harder solve t of h   reest

clob

   differences result available different times locales course
nearly two years experimentation 
   choice motivated observation problem relatively easy solve
bestf search appears ecient id bf search  hard problems
inecient considerable amount space used run time cpu time spent
garbage collection  cases made lisp crash  reporting internal error 
   worth noting number plans created implicitly takes account plan size  since
addition step plan counted creation new plan ucpop 

   

fiaccelerating partial order planners

goal selection plan selection cpu sec plans
lifo
s oc uc
               
lifo
zlifo
zlifo

s oc
s oc uc
s oc

    

     
    

         
         
       

table ii  performance plan goal selection strategies t of h 

goal selection plan selection cpu sec
lifo
lifo
zlifo
zlifo

s oc uc
s oc
s oc uc
s oc

    
    
    
    

plans

         
         
     
     

table iii  performance plan goal selection strategies fixa
quiring     seconds using s oc unknown time excess     cpu seconds using
s oc uc 
zlifo goal selection strategy significantly accelerate planning compared
simple lifo strategy  particular  zlifo combined s oc planselection strategy solving h  reduced number plans generated
factor   t of h  factor   t of h   overall performance improvement
t of h  thus factor     terms plans created factor     terms
cpu time  from            seconds  
tables iii viii provide data problems easier h  still challenging ucpop operating default strategy  namely fixa  table iii   fix   table iv  
tower invert   table v   test ferry  table vi  artificial domain art     
             table vii               table vii  
results show combination s oc zlifo substantially improves
performance ucpop comparison performance using s oc uc lifo 
number plans generated dropped factor    fixa  factor    
est

est

clob

est

goal selection plan selection cpu sec
lifo
lifo
zlifo
zlifo

s oc uc
s oc
s oc uc
s oc

    
    
    
    

clob

plans

         
       
       
       

table iv  performance plan goal selection strategies fix 

   

clob

figerevini   schubert

goal selection plan selection cpu sec plans
lifo
lifo
zlifo
zlifo

s oc uc
s oc
s oc uc
s oc

    
    
    
    

       
       
       
      

table v  performance plan goal selection strategies tower invert 

goal selection plan selection cpu sec plans
lifo
lifo
zlifo
zlifo

s oc uc
s oc
s oc uc
s oc

    
    
    
    

       
       
      
      

table vi  performance plan goal selection strategies test ferry

goal selection plan selection cpu sec
lifo
lifo
zlifo
zlifo

s oc uc
s oc
s oc uc
s oc

   
    
    
    

plans

       
        
     
     

table vii  performance plan goal selection strategies art     
       averaged     problems 
est

clob

     
est

clob

goal selection plan selection cpu sec
lifo
lifo
zlifo
zlifo

s oc uc
s oc
s oc uc
s oc

    
    
    
    

plans

       
         
     
     

table viii  performance plan goal selection strategies art     
       averaged     problems 
est

clob

     

clob

goal selection plan selection cpu sec plans
lifo
lifo
zlifo
zlifo

s oc uc
s oc
s oc uc
s oc

    
    
    
    

     
     
     
     

table ix  performance plan goal selection strategies sussman anomaly
   

est

fiaccelerating partial order planners

    

fixit
trains 
 

t of h   

performance
improvement

 

   

 
art       fixa
  search space reduction
art        
  fix 
speedup
tower invert 
test ferry
sussman anomaly
 
 e   
   
    
              e   
problem size

  
 
  

figure    performance improvement due zlifo s oc  relative number
plans generated lifo s oc uc  log log scale   improvements
problems ucpop unable solve even high search limit
 trains   trains   t of h   included 
fix   factor     tower invert   factor     test ferry  factor  
art      factor    art     
concerning art        note performance obtained unenhanced
ucpop      plans generated art         art      much
 just marginally better than  reported kambhampati et al         best planners
considered             plans generated art                art      
expected  since ucpop generalization earlier partial order planners 
relative standard ucpop predecessors   accelerated  planner thus order
magnitude faster  interestingly  entire improvement ascribed zlifo
 rather s oc plan selection  actually little worse s oc uc  
probably due unusual arrangement operators art       clobbering chain   a     clobbers         s preconditions       a    clobbers a    s preconditions 
similarly      makes immediate attention new unsafe conditions unusually
good strategy 
experimenting various combinatorially trivial problems unmodified ucpop
handles ease  found s oc zlifo strategy neither beneficial
harmful general  may slight improvement slight degradation performance  results sussman anomaly table ix provide illustrative example 
summarize results tables i x figure    showing performance improvements obtained combined zlifo goal selection strategy s oc plan selection
est

clob

est

n

 

n

 

 

i 

   

clob
 

figerevini   schubert

zlifo  
s oc
lc  
s oc
lcfr  
s oc
lifo  
s oc uc

trains 

trains 

trains 

fixit

plans
         
                           
         
time
    
    
     
    
plans
       
                             
             
time
   
     
      
     
plans
        
          
          
               
time
     
       
     
       
plans                               
                               
time
       
        
      
        

table x  performance plan selection strategy s oc combination goal
selection strategies zlifo  lcfr lc solving problems
hard default strategies ucpop  s oc uc lifo    the cpu seconds
include lisp garbage collection  number plans generated lcfr
include created order estimate repair cost aws  

problem
zlifo 
lcfr
name cpu time plans cpu time plans
tw  
tw  
tw  
tw  
tw  
tw  

    
    
    
    
     
     

     
     
      
       
       
       

    
    
    
     
     
     

     
     
      
       
       
       

table xi  performance ucpop tileworld domain using zlifo  lcfr
goal selection  s oc f    uc plan selection
strategy function problem diculty  as indicated number plans generated
default lifo plus s oc uc strategy   trend toward greater speedups
complex problems  though somewhat dependent problem type  quite apparent
log log plot 
direct comparison joslin pollack s lcfr strategy peot smith s
lc strategy  implemented strategies applied several problems 
well  sometimes better zlifo  problems lower end diculty
spectrum  poorly harder problems   for problems ran  lc
 d sep  switch performed better lcfr terms plans explored cpu
time required   t of h  lcfr combination default s oc uc plan
selection strategy  s oc plan strategy find solution within search
limit         plans generated  cf      zlifo s oc      zlifo
s oc uc   requiring unknown cpu time excess      seconds s oc uc 
   

fiaccelerating partial order planners
excess      seconds s oc  cf       seconds zlifo s oc    
lc performed much better lcfr still considerably worse zlifo  solving
t of h  generating exploring           plans s oc           plans
s oc uc  requiring      cpu secs        cpu secs  respectively  t ofh   lc found solution generating exploring               plans s oc uc
              plans s oc  requiring        cpu secs        cpu secs 
respectively 
table x shows results plan strategy s oc  goal strategies zlifo 
lcfr lc  applied three problems  trains   trains  fixit   shown data
table hard default strategies ucpop  lifo   s oc uc  
become relatively easy s oc used combination either zlifo  lcfr
lc  lcfr lc slightly better zlifo trains   the easiest
problems   performed quite poorly fixit  trains  trains   the hardest
problems  compared zlifo 
joslin pollack        tested lcfr strategy six problems tileworld
 tw         tw     five hard default ucpop  easy ucpop using
lcfr    tested zlifo strategy tileworld using six problems 
zlifo well tw      tw   tw   performance dropped well
lcfr  raised question whether particular problems crucial
minimize  repair cost  aw selection uniformly  rather certain special cases
 zlifo minimize repair cost threat aw list  least one zerocommitment open condition present   however  experiments aimed answering
question suggested poor choices made zlifo tileworld problems
due selection  high cost   low cost  aws  instead two factors appear
crucial improving zlifo   a  emphasizing zero commitment open conditions giving
higher priority threats   b  zero commitment open conditions 
resolving threats soon enter agenda   we realized relevance  b 
observing performance modified versions lcfr   d sep  switch
implicitly forced on  dramatically degraded tw   slightly different formulation
tileworld  
extended zlifo strategy include  a   b   brie tested
resulting variant zlifo  zlifo    table xi shows results zlifo  together
plan selection strategy s oc    uc f  discussed section     included
attenuated form uc term  uc      f term equal number facts
since tileworld uses facts track number tiles carried agent    zlifo 
     d sep  turned off  implicit setting lcfr  joslin         experiments
tested variant lcfr  switch forced on  resulting goal strategy
combination plan strategy s oc performed significantly better t of h   solving problem
generating exploring           plans  using        cpu seconds  note comparison
implementation lcfr joslin   pollack s implementation used experiments discussed
 joslin   pollack        showed implementation considerably faster  joslin        
    experiments tw    easiest among tw      solved ucpop even allowed run
eight hours  hand  ucpop using lcfr solves tw    hardest problem  without
ever reaching dead end node search tree 
    zlifo  experiments refined plans generated resolving threat added aw list
following order  first plan generated promotion  plan generated demotion 
finally plan generated confrontation separation 

   

figerevini   schubert
performed eciently six tileworld problems  fact little better lcfr 
note problems zlifo  ecient lcfr terms cpu time 
even though number plans generated explored two strategies approximately
same  overhead selecting next aw handled higher
lcfr zlifo   and zlifo   fact  lcfr needs compute  repair
cost  aw  including threats  current plan  zlifo   zlifo  needs
check presence zero commitment open conditions  without processing threats 
additional experiments indicated average performance zlifo  comparable
zlifo problems used experiments  terms
plans created explored  however  cpu time tends increase since overhead
computing goal selection function higher zlifo  zlifo 
extra agenda management costs  overhead  regard zlifo 
generally preferable zlifo  however  tileworld experiments underscored us
worlds refinements zlifo advantageous 
finally  another possible variant zlifo  suggested us david smith 
based following preferences next aw handled   i  threat cannot
resolved   ii  open condition cannot established   iii  threat
one possible resolution   iv  open condition established one way   v 
threats   vi  open conditions  using lifo pick among these   observe
strategy could give savings terms plans created explored 
imposes additional overhead respect zlifo zlifo  could
degrade performance terms cpu time 

   precomputing parameter domains

even speedups obtained improved search  ucpop like algorithm remains
severely limited complexity problems solve  believe significant
progress requires fuller use global properties search space  determined
structure operators  initial conditions  goals  one way would
in depth analysis alternatives search  lead high
overhead costs  another precompute constraints search space  use
planning prune search  parameter domain method motivate
describe latter type 

    parameter domains help 

previous experimentation ucpop strategies  found ucpop goal regression often hypothesized steps doomed abandoned eventually 
stipulated impossible parameter bindings  clear example occurred molgen
domain  encoded ucpop test suite  goal  rat insulin  test problem
 and  bacterium  b   molecule  m 
 contains ig  m   contains  m  b   pure  b  

 

 b  m existentially quantified variables  means wish
create purified bacterial culture  b   b contains molecule  m  necessarily
   

fiaccelerating partial order planners
exosome  turns out   molecule turn contains insulin gene  ig 
using abbreviations ig  ee  je  l insulin gene  e coli exosome  junk exosome 
linker  e  j  a  e coli  junk  antibiotic    roughly speaking  solution
involves processing initially given mrna form insulin gene produce
form insulin dna spliced e coli exosome  using ligate operator 
turn  exosome inserted e coli bacterium using transform operator 
bacterial culture purified using screen operator  antibiotic     the junk
bacterium exosome merely serve complicate task   nearly  quite 
substitutable e coli bacterium exosome  junk exosome  unlike e coli exosome 
resistant antibiotic    violating precondition screen  
now  initial regression goals  bacterium  b   molecule  m 
established  start  operator  i e   initial conditions  thus
instantiated bizarre values   the initial conditions supply e j
instances bacterium  ig  ee  je  l instances molecule  
hand  remaining goals turn match effects various instances
ligate  transform  screen operators molgen  follows 
 contains ig  m    ligate ig  m    transform ig  m 
 contains  m  b    ligate  m  b   transform  m  b 
 pure  b  
 screen  b  y  z 

 

ucpop happily regress actions  yet two them 

 transform ig  m 
doomed fail  perhaps great deal effort expended
trying satisfy preconditions  particular  examination constants
  ow into  transform operator initial conditions molgen operators
shows first argument restricted domain fee  jeg  i e   must one
given exosomes  second restricted fe  jg  i e   must one
given bacteria  consequently instance  transform ig  m  unrealizable  first
argument ig fee  jeg   note distinct constants denote distinct entities
according unique names assumption made ucpop    ligate  m  b  action
doomed slightly subtle reasons  result match  contains  m
 b   when clause   conditional effect  ligate operator  whose preconditions
reached second parameter  b lies set molecules fig  je  eeg 
yet  b restricted set bacteria fe  jg  result goal condition
 bacterium  b   fact sets disjoint allow us eliminate
 transform ig  m  action 
note elimination action candidates increases number zero commitment plan refinements made  example  left exactly one
action three goals  zlifo lcfr strategies prefer
regress goals rather regressing  bacterium  b   molecule  m   
would prematurely make arbitrary choices  b  m initial state 
 ligate  m  b  

    description algorithm

completed plan  precondition action must instantiated effect
earlier action  values parameters action values
   

figerevini   schubert
 produced  earlier actions  starting initial action   start   moreover 
suppose parameter x certain action occurs preconditions p        pk 
constant c possible value x earlier actions instantiate x c
p        pk 
algorithm find parameter domains based observations  beginning
initial state  propagates positive atomic predications possible operator preconditions  propagated ground atom  atom matches operator precondition 
algorithm adds constants ground atom individual domains
parameters unified with  individual domains particular specific preconditions  instance  individual domain  x operator preconditions
 on  x  y    clear  x  general distinct two preconditions 
soon nonempty individual domains parameters preconditions
operator  form intersection individual domains parameter
operator  example   on  x  y   so far  matched  on b 
 on b c    clear  x   so far  matched  clear a   clear table  
individual domain x fa bg first precondition fa tableg
second  thus  assuming preconditions  intersected domain
 x fag point  later  clear b  matched  clear  x  
intersected domain  x grow fa bg   x  y nonempty
intersected domains  effects  postconditions  operator turn propagated 
 x  y  bound  intersected domains 
propagated effects matched possible operator preconditions 
variable  bound  intersected domain successfully unified variable precondition  passes intersected domain individual domain
precondition variable  via union operation   lead growth intersected domains operator whose precondition matched  effects operator
may propagated  on  individual domains intersected domains grow
monotonically propagation process  end represent desired parameter domains operators 
illustrate process example  consider simple planning problem
depicted figure    operator graph   smith   peot        used describe
logical dependencies among operators  iterative computation parameter
domains graphically illustrated  domain propagation graph  operator
graph 
initial conditions  p a   p b  unify precondition  p  x  op   so 
individual domain  x relative precondition p op  fa bg 
hand  precondition  q  x  op  cannot satisfied initial state 
individual domain  x relative q initially empty set  hence intersected domain
 x op  empty set 
op  different situation  since one precondition
established initial state  therefore  individual domain  y relative
precondition r op  set constants fb cg  intersected domain  y
op  set  because r precondition op  involving  y   since
intersected domain  y enlarged  initially empty   propagated
individual domains operators effect  q  y  op   particular 
   

fiaccelerating partial order planners

 p  x 

indicates bundle edges
op 

 q  x 
 t b 

 start 
 r  y 

 end 

op 
init state   p a   p b   r b   r c   s c 
 s  z 

op  

preconds   p  x   q  x 

goal   t b 

op 
op  

preconds   r  y 

op  

preconds   s  z 
effects   t  z 

effects   q  y 

effects   s  x 

 p a 
 p  x 
 q  x 

id  x   b 

id  x    
op 

 p b 

 q  x 

op 
id p  x   a b 
id q  x   b c 

id p  x   a b 
id q  x    
 q  y 
id  y   b c 

 r b 
 r  y 
 r c 

 s  x 

op 
id r  y   b c 

id  z   a 
s a 

 s  z 

id  z   a b 

op 

 s  z 

id s  z   a 

op 
id s  z   a b 

figure    operator domain propagation graphs simple planning problem 
id  x p  indicates individual domain parameter  x relative precondition p  id  x  indicates intersected domain parameter  x  final
intersected domains indicated using bold fonts 
matches precondition  q  x  op   so  individual domain  x relative
precondition q op  updated adding constants intersected domain  y
it  thus intersected domain  x enlarged fbg  propagated
effect  s  x  op  
similarly  propagation  s  x  enlarge individual domain  z op  
intersected domain  set fa bg  therefore  final intersected domains
are  fbg  x op   fb cg  y op   fa bg  z op  
presenting algorithm little formally  note parameter domains sometimes  too large   including values would found impossible
 q  y 

   

figerevini   schubert
detailed state space exploration conducted  however  required
soundness use domains  too small   i e  
contain parameter values actually occur problem consideration  
course  practical use parameter domains operator exclude
constants occurring problem specification  particularly
intuitively obvious wrong sort fill particular argument slots
operator  turned case problem domains far
experimented with 
preceding sketch method oversimplification since preconditions
effects ucpop operators may particular when clause  case compute
individual domains intersected domains separately when clause  example 
consider following schematic representation operator 
 define  operator op  
 parameters   x  y 
 precondition  and p  p  
 effect  and e  e 
 when     
 when         

pe
p e

conditions starting p e denote atomic formulas may involve  x  y 
think operator consisting primary when clause whose preconditions
p  p  must always satisfied whose effects e  e  always asserted 
two secondary when clauses whose respective preconditions p   p   may may
satisfied  are  corresponding effects e   e   asserted 
algorithm would maintain individual domains  x  y preconditions
p   p   p     p    would maintain intersected domains  x  y
primary when clause two secondary clauses  intersected domains
secondary clauses would based individual domains  x  y
relative p   p    relative p  p   since  as noted  primary
preconditions must hold operator effects  including conditional
effects 
complications arise ucpop operators contain universally quantified preconditions effects  disjunctive preconditions  facts  mentioned section      
rather dealing complications directly  assume operators occur input algorithm  later describe semi automated way
handling operators containing additional constructs 
algorithm outlined  a detailed description given online appendix     w list  names of  when clauses whose effects propagated 
individual parameter domains initially nil  intersected parameter domains initially either nil  where universal domain   intersected domain
parameter  relative given when clause  case parameter occurs neither
preconditions when clause primary preconditions   in case
successful instantiation when clause clearly independent choice value
parameter question   unification step   a  usual  except
effect variable v unified constant c precondition  unification succeeds 
   

fiaccelerating partial order planners
unifier v   c  case c element intersected domain v  for relevant when clause   given inits  initial conditions  goals  which may omitted 
i e   nil  treated operator  start  preconditions operator  end 
effects  variables goals treated operator parameters  use terms
 parameters   variables  interchangeably here 
algorithm  find parameter domains operators inits goals 
   initialize w initial conditions  contains  primary  when clause
 start  
   repeat steps  a c  w   nil 
 a  unify positive effects when clauses w possible operator
preconditions  mark preconditions successfully matched way
 matched    this marking permanent   augment individual domain
matched precondition variable certain set c constants  defined
follows  precondition variable unified constant c  c   fcg 
unified effect variable  c intersected domain
effect variable  relative when clause effect belongs  
 b  mark when clauses  propagation candidates  preconditions  including corresponding primary preconditions  marked  matched 
involve least one variable relevant individual domain
augmented step  a  
 c  reset w nil  when clauses propagation candidates  compute
new intersected domains variables  intersected domain whenclause thereby enlarged  intersected domains when clause
nonempty  add when clause w 
   restrict intersected domains using equative preconditions form  eq u v  
i e   form common intersected domain u v variables  u
constant v variable  reduce intersected domain v intersecting
fug  similarly u variable v constant  equation belongs
primary when clause  use reduce intersected domains u v  whichever
variables  secondary clauses well 
   return intersected domains parameter domains  producing sequence
lists list form
 op  x  a  b  c        x  a  b  c            
operator op appears least once  op k conditional effects 
k     successive lists headed op  first provides parameter
domains primary effects op rest provide parameter domains
conditional effects  in order appearance ucpop definition op  
note match propagate negative conditions  problem negative
conditions large number may implicit initial conditions  given
   

figerevini   schubert
use closed world assumption ucpop  instance  world n blocks 
o n  on relations  assuming block one block  
necessarily o n    implicit  not  on       relations  fact  individual variable
domains negative preconditions goals really infinitely large  instance  given
empty initial state  paint red  x  operation precondition  not  red  x  
effect  red  x   achieve  red c  infinitely many constants c  perhaps
negative conditions could effectively dealt maintaining anti domains them 
explored since practice ignoring negative conditions seems cause
minimal  domain bloating    we proved actual domain elements
lost neglect preconditions  
use eq conditions could refined making use propagation
process  neq conditions could used  however  would probably
marginal impact 
final comment  note output format specified step   algorithm
actually generalized implementation report inaccessible preconditions
goals  inaccessible conditions simply appended list parameter
domains appropriate when clause appropriate operator  instance 
preconditions  oj  oj   at  oj  city  ld oj   load orange juice   operator
trains world  see online appendix    unreachable  say  oranges
producing orange juice provided   parameter domain list  unique 
when clause ld oj appearance
 ld oj   oj        car        city       oj  oj   at  oj  city   
feature turns useful debugging operator specifications detecting
unreachable goals 

    correctness tractability

keeping remarks previous section  call algorithm computing
parameter domains correct domains computes subsume possible parameter values
actually occur  in given primary secondary when clause  consider
possible sequences operator applications starting given initial state 
point property maintain soundness planning algorithm
uses precomputed parameter domains prune impossible actions  as well spurious
threats  partially constructed plan  assert following 

theorem   find parameter domains algorithm correct computing parameter

domains ucpop style sets operators  without quantification  disjunction  facts  
initial conditions   possibly  goal conditions 
proof given appendix a  preliminary step establish termination  using
monotonic growth domains finiteness set constants involved  correctness
established showing exists valid sequence a  a     a actions
 operator instances  starting a     start   instance operator
op  bindings parameters op received instance eventually added
relevant intersected domains op  where  relevant  refers when clauses op
whose preconditions satisfied beginning    proved induction n 
n

n

n

n

   

fiaccelerating partial order planners
indicate deal universally quantified preconditions effects 
disjunctive preconditions  facts  make simple changes operator definitions
hand preparation parameter domain precomputation  use domains
computed find parameter domains  together original operators  running
planner  steps preparing operator parameter domain precomputation
follows 
delete disjunctive preconditions  fact preconditions    universally quantified preconditions  this includes universally quantified goals  would include universally
quantified sentences embedded within antecedents when clauses  e g  
manner   when   forall   x       though occur problem
domains seen  
drop universal quantifiers occurring positively operator effects  i e   occurring
top level embedded one  and s  example  effect
  and  at robot  to 
  not  at robot  from  
  forall   x 
  when   and  grasping  x   object  x  
  and  at  x  to    not  at  x  from       

would become

  and  at robot  to 
  not  at robot  from  
  when   and  grasping  x   object  x  
  and  at  x  to    not  at  x  from       

note universally quantified variable renamed  necessary 
distinct variables operator parameters 
example universally quantified variable unrestricted 
quantified variable includes type restriction    forall  object  x    
type restriction needs become antecedent matrix sentence  
example hand  rewritten equivalent   when  object  x 
   since often when clause  done adding  object  x 
conjunct antecedent when clause  cases conjunction
when clauses  case quantifier restriction added
when clause antecedent 
drop existential quantifiers preconditions goals  adding restrictions
quantified variables conjuncts matrix sentence  example  goal
  exists  bacterium  y 
  exists  molecule  x 
  and  contains ig  x 
 contains  x  y 
 pure  y     

    e g   strips world would drop  fact
given coordinates lie given room 

 loc in room  x  y  room   

   

checks whether

figerevini   schubert
becomes
  and  bacterium  y   molecule  x   contains ig  x 
 contains  x  y   pure  y   

 actually   and dropped well  supplying goals find parameterdomains  
reductions  find parameter domains compute correct parameter
domains operators goals  see this  note first dropping preconditions  in initial step above  forfeit correctness  since
weaken constraints admissible parameter values  thus add constants
domains  effect dropping universal quantifier  perspective
find parameter domains  introduce new parameter place universal variable   the operator normalization subroutine detects variables operator preconditions
effects listed parameters  treats additional parameters  
course drastic change meaning operator  preserves correctness parameter domain calculation  domain new parameter
certainly contain constants  and hence  closed world assumption  objects  quantified variable ranges  example   x treated parameter
rather universally quantified variable conditional effect
  forall   x    when  object  x   in  x box    
domain  x when clause consist everything object 
state operator applied  thus effect  in  x box  propagated objects  required  finally  elimination existential quantifiers
preconditions goals seen preserve meaning preconditions
goals  hence preserves correctness parameter domain calculation 
next formally state tractability claim algorithm  follows  with
tacit assumptions  mentioned proof  
theorem   algorithm find parameter domains implemented run o mn n  n  
n    time o mn   space worst case  number constants
problem specification  n combined number preconditions operators  and
goals  included   n combined number operator effects  including
 start   
proof appendix a  time complexity find parameter domains
determined sum     cost unifications performed      costs
individual domain updates attempted      cost intersected domain
updates attempted  space complexity bound easily derived assuming
fixed upper bound number arguments predicate  in precondition
effect  have  fact when clause o m  constants
stored 
adding additional data structures find parameter domains obtain
version algorithm whose worst case time complexity slightly improved  fact 
step    c  instead propagating effects when clause enlarged
p

e

p

p

e

   

e

p

fiaccelerating partial order planners
intersected domain  i e   adding when clause list w   sucient propagate
effects when clause involve enlarged intersected domain  could
done setting when clause table maps parameter list
effects  of when clause  involving parameter 
improved algorithm use w store list effects  instead list whenclauses  propagated next cycle algorithm  steps     
find parameter domains modified following way 
    initialize w list effects  start  
    repeat steps  a c  w   nil 
 a   unify positive effects w possible operator preconditions  mark
preconditions successfully matched way  matched     
 
 b      b  
 c   reset w nil  when clauses propagation candidates  compute new intersected domains variables  intersected domain
when clause thereby enlarged  intersected domains when clause
nonempty  add w subset effects when clause
involving least one parameter whose intersected domain enlarged 
note worst case time complexity revised algorithm improved 
effect when clause propagated o m  times  decreases upper
bound number unifications performed  reducing complexity estimated step
    proof theorem   o mn n    hence proved following corollary 
e

p

corollary   exists improved version find parameter domains
implemented run o mn  n   time worst case 
p

e

   using parameter domains accelerating planner

already used example molgen motivate use precomputed parameter
domains planning  showing domains may allow us prune non viable actions
partial plan 
fundamentally  used time planner needs unify two predications involving parameter  either goal regression threat detection   in
either case  one predication  sub goal effect action
initial condition   unifier inconsistent parameter domain  count
failure even consistent binding constraints current  partial 
plan  inconsistency  use unifier intersect thus refine
domains parameters equated unifier 
example  suppose g    at  x  y  precondition step current
plan  e    at  w  z  effect another  possibly new  step   x   y 
 w  z parameters  or  case  w  z  existentially quantified variables 
binding constraints associated current plan  assume
domains parameters are 
   

figerevini   schubert
 x    agent   agent   agent  
 w    agent   agent  

 y    city   city  
 z    city   city  

unification g e gives binding constraints f x    w   y    zg 
viable parameter domains  y  z empty intersection 
hand  domain  z fcity   city   city g  unification g e would judged viable  domains parameters would
refined to 
 x    agent   agent  
 w    agent   agent  

 y    city  
 z    city  

thus parameter domains incrementally refined planning search progresses 
narrower become  often lead pruning 

    incorporating parameter domains ucpop

preceding consistency checks domain refinements used partial order 
causal link planner ucpop follows  given goal  open condition  g selected
ucpop next aw repaired 
    restrict set new operator instances ucpop would use establishing g 
instance operator effect e  matching g  disallowed precomputed
parameter domains relevant e incompatible current parameter domains binding constraints relevant g   note current parameter domains
associated g may refinements initial domains  
    restrict set existing steps ucpop would reuse establishing g  reusing
step effect e  matching g  disallowed current parameter domains relevant
e incompatible current parameter domains binding constraints
relevant g 
moreover  given potential threat effect q protected condition p  inspection
relevant parameter domains may reveal threat actually spurious 
happens unifier p q violates  possibly refined  domain constraints
parameter p q  thus often
    reduce number threats generated planner new causal
link introduced plan  this happens open condition established
either reusing step introducing new one  
    recognize threat list aws processed redundant  allowing
elimination   note since parameter domains incrementally refined
planning  even use     generation threats  still possible
threat becomes spurious added aw list  
four uses parameter domains cut search space without loss viable
solutions  since options eliminated cannot lead correct  complete plan 
   

fiaccelerating partial order planners
note         useful even planner deals definite
threats  i e    d sep  switch turned on  least three reasons  first  determining
threat definite threat  d sep  incurs overhead cost  so 
earlier elimination spurious threat could lead considerable savings threat
delayed many times search  second reason relates plan selection
strategies adopted  one uses function includes  attenuated  term corresponding
number threats currently aw list  eliminating spurious threats
advance give accurate measure  badness  plan  finally  parameter
domains could used threat processing prune search even  dsep 
on  particular  suppose modify notion definite threat 
parameter domains  e g    p  x   not  p  y   comprise definite threat
parameter domains associated  x  y c  case  even
d sep  on  may discover early threat become definite   case might
forced threat  i e   choice promotion demotion may dictated
ordering constraints  prune search space  however  current
implementation exploit third point 
incorporated techniques ucpop  version       along earlier
improvements plan goal selection strategies  parameter domains handled
extension  varset  data structure  weld        include domains
variables  parameters   extending unification process implement
filtering discussed above    describe experiments enhanced system 

    experimental results using parameter domains

main goal show overhead determined computing parameter domains significant  both preprocessing time planning time   exploitation parameter domains planning significantly prune search 
experiments used version find parameter domains described section
    online appendix    note domains complex ones
considered might worthwhile use improved version algorithm discussed
section       however  remains seen whether problems significantly complex
consider solved ucpop style planner  
cpu times needed implementation find parameter domains negligible problems looked at     msec less many problems
ucpop test suite  when running compiled allegro cl     sun         msec
two problems  fixa fridge repair domain fixit tire domain  
  msec trains world problems described below 
first set tests  relied search strategy used default ucpop 
function used a  plan selection thus s oc uc f  allowing problems
involve  facts    goals selected agenda according pure lifo
discipline   
    current implementation new threats filtered protected condition established
step already plan 
    experiments  d sep  switch on  default delay separation strategy selecting unsafe
conditions slightly modified version ucpop using parameter domains  particular 

   

figerevini   schubert
began experimenting variety problems ucpop s test suite  comparing performance without use parameter domains  relatively easy
problems sussman anomaly  fixa  test ferry  tower invert  showed improvement use parameter domains  problems   particularly harder
ones   solved easily parameter domains  example  rat insulin
problem molgen domain solved nearly twice fast  strips world
problems  move boxes variants    towers hanoi  t of h   solved
   times fast  note strips world problems involve facts universally
quantified conditional effects  two problems oce world  oce  oce  
knew readily solvable improved search strategy  remained dicult  in case oce   unsolvable  default ucpop strategy  despite use
parameter domains    experiments revealed source ineciency
default plan selection strategy ucpop  fact  using s oc f strategy
instead s oc uc f  without parameter domains oce  oce  solved generating exploring                     plans respectively  using parameter
domains plans numbered                     respectively 
initial experiments suggested us promising application computed parameter domains would nontrivial problems involved variety types
entities relationships  significant amounts goal chaining  i e   successive
action establishing preconditions next   perspective  trains world
struck us natural choice experimentation  additional advantage
design independently motivated research rochester mixed initiative
problem solving natural language interaction   refer formalization
online appendix     recall table x trains  problem extremely hard
unmodified ucpop  requiring    minutes generating million plans 
running problem parameter domains produced solution     seconds
 with      plans generated   i e       times faster 
intuitively  use parameter domains constrain planning analogous using
type constraints parameters  although parameter domains take account initial
conditions   interest see whether adding type constraints provide similar
eciency gains use parameter domains  first set experiments therefore
included t trains    typed  version trains   operators slightly changed
adding new preconditions stating types parameters involved  example 
operator uncouple augmented preconditions  engine  eng 
 car  car   problem extremely hard unmodified ucpop  exceeding
search limit           plans generated requiring      seconds 
parameter domains  solution obtained one second 
threats resolved separation recognized redundant use
parameter domains selected eliminated 
    move boxes   differs slightly move boxes problem ucpop suite  goal  in room
box  rclk   move boxes a differs slightly move boxes    initial state contains two
boxes 
    oce  directly ucpop s test suite oce  minor variant oce   oce   persons
furnished checks made them  using check printer oce briefcase
picking checks bringing home   sam   sue  given persons  oce 
added  person alan   person smith  initial conditions 

   

fiaccelerating partial order planners

problems

without domains
domains
domain
plans
cpu sec
plans
cpu sec ratio
trains 
                         
        
    
     
t trains 
           
      
       
    
     
move boxes
                       
         
    
     
move boxes  
           
      
        
    
     
move boxes  
           
     
        
    
     
move boxes a
           
     
        
    
     
t of h 
                                    
    
     
rat insulin
       
    
       
    
     
monkey test 
     
    
     
    
     
monkey test 
       
    
       
    
     
fix 
         
    
         
    
     
oce 
                                             
     
oce 
           
      
           
            
tower invert 
       
    
       
    
     
sussman anomaly
     
    
     
    
     
fixa
         
   
         
    
 
test ferry
       
    
       
    
 

table xii  plans generated visited cpu time  secs  standard ucpop
without parameter domains    result obtained sun   
lucid common lisp  others sun    allegro common lisp  
results indicate adding type constraints operator specifications
nearly effective use parameter domains boosting planning eciency 
discuss point context second set tests  below  
table xii summarizes experimental results experiments used
default ucpop search strategy  table gives number plans generated visited
planner cpu time  seconds  required solve problems    note
use parameter domains gave dramatic improvements trains domain  strips world domain  rightmost column supplies  domain ratio 
data  metric hoped would predict likely effectiveness using parameter
domains  idea parameter domains effective extent
filter many parameter bindings reached chaining back individual
preconditions operator initial state  bindings found using
variant algorithm propagating intersected domains instead propagates unions
individual domains  comparing union domains intersected domains   
    systems compiled allegro cl      settings  space     speed     safety     debug
    run sun     cpu time includes lisp garbage collection  it time given
output ucpop  
    actually  need explicitly propagate union domains  propagate  partial  bindings
one predication time  starting initial conditions  match predication possible
preconditions  adding constant arguments contains union domains matched operator

   

figerevini   schubert

trains
without domains
domains
domain
problems
plans
cpu sec
plans
cpu sec ratio
trains 
         
    
       
   
     
trains                                   
     
trains                                    
     
table xiii  plans generated visited cpu time  secs  ucpop without
parameter domains trains domain using zlifo strategy 

trains without domains
domains
domain
problems plans cpu sec plans cpu sec ratio
trains          
   
       
   
     
trains                           
     
trains                           
     
table xiv  plans generated visited cpu time  secs  ucpop without
parameter domains trains domain using lcfr strategy 
 domain ratio  provides comparison  dividing average union domain size
average intersected domain size  averages taken parameters when clauses
operators 
largest speedups  e g   trains problems  tend correlate
smallest domain ratios  smallest speedups largest domain ratio  unity  
see last rows   however  seen table problem diculty  as
measured plans cpu time  much useful domain ratio predictor
speedups expected using parameter domains  problems generate
order million plans standard ucpop tend produce speedups   orders
magnitude  whereas domain ratio problems  e g   move boxes   
better  or even worse  problems much smaller speedups  e g   move boxesa  rat insulin  monkey test   monkey test    much lower diculty problems
predicts reduced speedup  complicate matters  dicult problems give
high speedups  see t of h  especially oce    know subtleties
problem structure account unusual cases 
second round experiments  tested effectiveness parameter domain
technique combination improved search strategy  i e   s oc zlifo  addition  combined s oc lcfr  least cost aw selection   joslin   pollack        
 or when clause   find corresponding  partially bound  effects  add new effects
list predications still propagated  partially bound effect  p  x  y  new
identical similar predication  p  u  v  among previously propagated predications
among still propagated 

   

fiaccelerating partial order planners

t trains

without domains
domains
domain
problems
plans
cpu sec
plans
cpu sec ratio
t trains           
    
       
   
     
t trains           
    
         
    
     
t trains                                       
     

table xv  plans generated visited cpu time  secs  ucpop without parameter domains  typed  trains domain using zlifo strategy 

t trains

without domains
domains
domain
problems
plans
cpu sec
plans
cpu sec ratio
t trains                               
     
t trains                             
     
t trains         
    
       
    
     

table xvi  plans generated visited cpu time  secs  ucpop without
parameter domains  typed  trains domain using lcfr strategy 
test possible sensitivity parameter domains technique precise strategy
used  present set tests used search limit        plans generated 
began sampling problems ucpop test suite 
initial trials yielded results quite analogous default ucpop strategy 
obtained improvements several easier problems significant improvements
harder ones  e g   close factor   rat insulin   noteworthy members
latter category oce  oce    recall oce  shown little speedup
standard ucpop oce  unsolvable  however  view computational
expense testing zlifo lcfr  decided narrow focus
trains world  mentioned  advantages world inherent interest
relative complexity 
tables xiii xvi provide experimental results trains domain s oc 
zlifo strategy s oc lcfr strategy  case without parameter
domains 
results tables xiii xiv show using parameter domains still give
significant improvements performance  obtained use
better search strategies  example  use parameter domains provided    fold
speedup trains   s oc zlifo strategy  particular problem speedup
 on metrics  result pruning      plans  more half generated 
search   recognizing     unsafe conditions redundant  evidently 
effect pruning amplified order magnitude overall performance 
futile searches cut short  note speedups trains   
   

figerevini   schubert
roughly comparable  within factor    obtained problems previous set
comparable initial diculty  e g   see move boxes   move boxes a table xii  
points rather consistent correlation problem diculty speedups
obtainable using parameter domains  constant domain ratios compatible
less invariant speedups here  though little import  given earlier
results  s oc lcfr gains appear less  though single result showing
    fold speedup provides anecdotal evidence conclusion  trains 
trains  remained dicult solution lcfr  similar gains observed
s oc lc strategies best observed gain trains domain     fold
speedup trains   case  results confirm effectiveness parameterdomains technique 
tables xv xvi  typed  version trains  case parameter
typing gave modest improvements absence parameter domains   in contrast
results trains  default search strategy  significant deterioration
presence  know account results detail  seems
clear contrary effects involved  one hand  typing tend help
tends limit choices parameter values  sensible  ones  example  precondition
 engine  eng  satisfiable use  start   initial state thus
constrain  eng assume sensible values  hand  adding type preconditions
tend broaden search space  adding open conditions aw list 
lesson  typed  experiments appears best supply
explicit type constraints operator parameters  instead using automated method
calculating updating domains constrain parameter bindings 

   conclusions work

began exploring simple  domain independent improvements search strategies
partial order planning  described method using precomputed parameter domains prune search space  summarize conclusions techniques
point promising directions work 

    improving search

proposed improvements search strategies based one hand carefully
considered choice terms a  heuristic plan selection 
preference choosing open conditions cannot achieved achieved
one way  with default lifo prioritization open conditions   since
plan refinements corresponding uniquely achievable goals logically necessary 
termed latter strategy zero commitment strategy  one advantage technique
similar strategies incurs lower computational overhead 
experiments based modifications ucpop indicate strategies give
large improvements planning performance  especially problems hard
ucpop  and  relatives   begin with  best performance achieved
strategies plan selection goal selection used combination  practical terms 
able solve nearly every problem tried ucpop test suite fraction
second  except fixit  required      seconds   problems
   

fiaccelerating partial order planners
previously required minutes unsolvable machine  included
sucient variety problems indicate techniques broad potential utility 
further  results suggest zero commitment best supplemented lifo
strategy open conditions achievable multiple ways  rather generalization
zero commitment favoring goals fewest children  somewhat surprising result
might thought due way designer domain orders
preconditions operators  i e    natural  ordering preconditions may correlate
best planning order  giving fortuitous advantage lifo strategy relative
strategy lc   
however  preliminary experiments performed randomized preconditions
t of h  trains  indicate otherwise    randomizations preconditions
t of h   lc zlifo slowed somewhat  average factors        
          terms plans expanded  cpu time used  respectively   in cases 
s oc used plan search   still left zlifo performance advantage
factor    terms plans created    terms cpu time  trains 
performance lc greatly deteriorated     cases  by factor close    terms
plans time   zlifo actually improved marginally  left
zlifo average performance advantage lc  whereas slightly slower
unrandomized case    factor     terms plans     terms cpu time
 though values unreliable  view fact standard deviations
order means  
despite results believe satisfactory understanding dependence
aw selection strategies order operator preconditions require extensive
experimental investigation  currently undertaking work 

    using parameter domains

described implemented  tractable algorithm precomputing parameter domains
planning operators  relative given initial conditions  showed use precomputed domains planning process prune non viable actions bogus threats 
update dynamically maximum effect 
idea using precomputed parameter domains constrain planning apparently
first proposed technical report goldszmidt et al          contains essential
idea accumulating domains forward propagation initial conditions  though
report sketches single sweep propagation process initial conditions
goals  implemented rockwell planner  rnlp  handles cyclic operator graphs 
repeatedly propagating bindings quiescence  much algorithm  algorithm
deals additional complexities conditional effects equalities  and semiautomated fashion quantification  appears ecient  smith        
distinctive features work method incrementally refining domains
    suggested us david smith well mike williamson  williamson tried zlifo  
randomized versions t of h   reported large performance degradation  williamson   hanks 
       recently ran versions using implementation  obtaining far favorable results
 three five versions easier solve original version t of h   two
versions slowed zlifo factor           terms plans explored  

   

figerevini   schubert
planning  theoretical analysis algorithm  systematic experimental
tests 
another closely related study yang chan         used hand supplied
parameter domains planning much use precomputed domains  interesting
aspect work direct use sets constants variable bindings  instance 
establishing precondition  p  x  using initial state containing  p a    p b 
 p c   would bind  x fa  b  cg rather specific constant  refine
 noncommittal  bindings planning much refine variable domains 
periodically use constraint satisfaction methods check consistency current
eq neq constraints  conclude delaying variable bindings works best problems
low solution densities  while degrading performance problems high
solution densities   optimal frequency making consistency checks depends
whether dead ends tend occur high low search tree  work distinguished
method precomputing parameter domains  use specific bindings
matching initial conditions ocs  use parameter domains threat detection
resolution  handling enriched syntax ucpop operators compared
snlp operators 
judging examples experimented with  techniques well suited
nontrivial problems involve diverse types objects  relations actions  significant logical interdependencies among steps needed solve problem  used
conjunction default search strategy ucpop  method gave significant speedups
nontrivial problems  reaching speedup factor     trains transportation planning domain       hardest strips world problem tried  
combined s oc zlifo search strategies  parameter domain technique
still gave speedups factor around    trains problems  though implementation aimed ucpop style planner  essentially techniques would
applicable many planners 
found parameter domain precomputations useful debugging
aid  fact  domain precomputation initial formulation trains world
immediately revealed several errors  instance  domain  eng parameter
mv engine turned contain oranges  bananas  oj factory  indicating need
type constraint  eng   without this  transportation problems would
solvable without benefit engines trains   another immediately apparent problem
revealed parameter domains  city   city  mv engine  domain
 city  excluded elmira   city  excluded avon  obvious diagnosis
neglected assert  connected c  c    connected c  c  
track connecting two cities  furthermore  parameter domains quickly identify
unreachable operators goals cases  instance  without make oj operator 
computed domains show ld oj operator unreachable  goal
 and  oj  oj   at  oj bath    getting orange juice bath  unattainable  the
parameter domain  oj empty  
course  running planner used debugging formalization 
planning general far time consuming form preprocessing  especially
goal pose happens unachievable formalization    trace
   

fiaccelerating partial order planners
anomalous planning attempt quite hard interpret  compared listing
parameter domains  obtained fraction second 

    work

first all  additional experimentation would interest  assess
perhaps refine search strategies  experimentation might focus threathandling strategies  including best general form attenuated uc term plan
selection  best way combine threat selection open condition selection 
preference definite threats open conditions used zlifo appear
good default according experience  tileworld experiments indicated
re ordering priorities threats open conditions sometimes desirable  concerning choice uc related term inclusion heuristic plan selection 
mention brie tried using s oc uc   uc number
definite threats  obtain significant uniform improvements 
one promising direction development search strategy make
zero commitment strategy apply often finding ways identifying false options
early possible  is  possible action instance  obtained matching open
condition available operators well existing actions  easily recognizable inconsistent current plan  elimination may leave us single
remaining match hence opportunity apply zero commitment strategy 
one way implementing strategy would check once  accepting
matched action possible way attain open condition  whether temporal
constraints action force violate causal link  alternatively  force causal
link violated  case action could immediately eliminated  perhaps
leaving one  or even no  alternative  could perhaps made even effective
broadening definition threats preconditions well effects actions
threaten causal links  hence bring light inconsistencies sooner  note
precondition action inconsistent causal link  established
another action whose effects violate causal link  precondition really poses
threat outset 
two possible extensions parameter domain techniques  i  fully automated
handling universally quantified preconditions effects  disjunctions facts
preprocessing algorithm   ii   intelligent  calculation domains  applying
constraint propagation process sets ground predications matched
preconditions operator  shown yield tighter domains  though
computational expense  blum furst        recently explored similar idea  rather
computing parameter domains  directly stored sets ground atoms could
generated one operator application  starting initial state   two successive operator
applications  on  used sets atoms  and exclusivity relations among
atoms actions connecting them  guide regressive search plan 
algorithm describe allow conditional effects  though generalization
appears entirely possible  examples used tests  obtained dramatic
speedups 


   



figerevini   schubert
finally  working another preprocessing technique  namely inference
state constraints operator specifications  one useful form constraint implicational  e g    implies  on  x  y   not  clear  y      another single valuedness
conditions  e g    on  x  y  may single valued  x  y   conjecture
constraints tractably inferred used large speedups domainindependent  well founded planning 
view results presented possibilities speedups
mentioned  think plausible well founded  domain independent planners may
yet become competitive pragmatically designed planners 

acknowledgements

work amalgamates extends two conference papers improving search  schubert
  gerevini        using computed parameter domains  gerevini   schubert       
accelerate partial order planners  research supported part rome lab contract f         c      nato collaborative research grant crg       
work ag carried irst        povo  tn   italy  cs department
university rochester  rochester ny usa  helpful comments perceptive
questions marc friedman  david joslin  rao kambhampati  colm o riain  martha pollack  david smith  dan weld  mike williamson  associate editor michael wellman
anonymous reviewers gratefully acknowledged 

appendix  proofs theorems 
theorem   find parameter domains algorithm correct computing parameter

domains ucpop style sets operators  without quantification  disjunction  facts  
initial conditions   possibly  goal conditions 
proof  preliminary observation  intersected parameter domains computed iteratively algorithm eventually stabilize  since grow monotonically
finitely many constants occur initial conditions operator effects 
thus algorithm terminates 
order prove correctness need show exists valid sequence
a  a     a actions  operator instances  starting a     start  
instance operator op  bindings parameters op received instance
eventually added relevant intersected domains op  where  relevant  refers
when clauses op whose preconditions satisfied beginning   
prove induction n 
n        a     start   parameters claim trivially
true 
assume claim holds n              k  consider operator instance
   validly follow a  a     a   i e      instance operator
op whose primary preconditions  possibly along secondary ones  satisfied
end a  a     a   let p precondition  write instance   
 p c  c        p c  c      must effect     k     
n

n

n

n

n

k

k

k

k

k



   

fiaccelerating partial order planners
 p c  c      holds initial state  hence predication propagated
successfully matched p initial propagation phase find parameter domains 
     instance operator op   p c  c      corresponding
instance effect  p t  t      op   either parameter op 
equal cj  diagrammatically 


j

a       
j



     



  
j

k

k

op 

op

effect  p t  t            precond p
 p c  c      

 p c  c      

induction assumption  bindings parameters eventually added
relevant intersected domains op   implies intersected domains
op  become nonempty  effect  p t  t      eventually propagated 
variables among corresponding constant cj relevant intersected
domain  consequently  much case      effect  p t  t      successfully matched
precondition p op stage propagation  given observations 
clear          p marked  matched  op eventually 
furthermore parameters op occur p bindings resulting
unification  p c  c      added appropriate individual domains associated
p 
argument applies preconditions op satisfied instance      particular primary preconditions  since marked  matched   algorithm
compute intersected domains op parameters occur them  view
individual domain updates confirmed  since individual domains grow monotonically  intersected domains eventually contain parameter bindings     
instance  parameter  x op occurs primary precondition bound
c      shown c eventually added intersected domain
 x associated primary when clause op  parameter occur
primary preconditions op  intersected domain set outset 
implicitly contains whatever binding parameter     
similar argument made secondary when clause op whose preconditions satisfied      again  preconditions secondary clause 
well primary preconditions  marked  matched   parameter
occurring combined preconditions  intersected domain  relative secondary
clause  updated include binding      parameters op occurring
preconditions  intersected domains set initially 
implicitly contains possible binding  finally  note since intersected
domains relative primary secondary when clauses grow monotonically  augmentations intersected domains confirmed permanent   in case
t domains  remain t  
leave additional details concerned ultimate use eq preconditions
find parameter domains reader   


j

k

k

k

k

k

k

   

figerevini   schubert

theorem   algorithm find parameter domains implemented run o mn n  n  
n    time o mn   space worst case  number constants
problem specification  n combined number preconditions operators  and
goals  included   n combined number operator effects  including
p

e

e

p

p

p

e

 start   

proof  time complexity find parameter domains determined sum
    cost unifications performed      costs individual domain
updates attempted      cost intersected domain updates attempted 
estimate upper bound terms following assumptions 

 a  unification operator effect operator precondition requires constant
time 
 b  fixed upper bound number arguments predicate  in
precondition effect  have  follows o n   upper bound total
number intersected domains   
 c  individual domains intersected domains stored hash tables  indexed
constants domain   so  check whether element belongs particular
 individual intersected  domain  possibly add domain essentially
constant time  furthermore individual intersected domain  appropriate
data structures used keep track  possibly empty  set new elements
added domain last update attempt 
    particular intersected domain particular operator 
updates domain  update causes effects whenclause intersected domain belongs propagated  upper bound
number n   propagated effect may unified o n   preconditions  thus
o m  updates intersected domain may cause o mn n   unifications  hence
 b   overall number unifications caused propagation intersected domains
individual domains o mn  n    unifications add
initially performed effects  start  preconditions operators 
o mn   unifications  increase previous upper bound
number unifications  thus   a   cost unifications performed
algorithm o mn  n   
    unification potentially followed attempt update individual
domain s  relevant parameter s   however  assumption  c  number
attempts limited set new elements intersected domain s 
unifying effect  are  empty  furthermore  attempt update
individual domain performing union relevant intersected domain  
subset new elements need added  if already
there   thus  since intersected domain grows monotonically   b   c 
overall cost update attempts one particular individual domain caused
e

e

p

e

e

p

p

p

e

p











    note parameter appears precondition when clause  none effects 
intersected domain parameter propagated algorithm  hence implementing
algorithm ignore parameters 

   

fiaccelerating partial order planners
one particular effect o m   worst case one effect unify
o n   preconditions operators  yielding overall bound attempts
update individual domains o mn n   
    attempt update particular intersected domain relevant
individual domain update  relevant individual domain updated o m  times
 because domains grow monotonically   therefore  b  o mn  
attempts update one intersected domain   c  total cost attempts
o mn     checking whether new element individual domain belongs
o n   relevant individual domains takes o n   time  so  since  b 
o n   intersected domains  total cost incurred algorithm
updating intersected domains o mn n    
follows time complexity find parameter domains is 
o mn n     o mn n     o mn n     o mn n  n   n    
space complexity bound easily derived  b   fact
when clause o m  constants stored   
p

e

p

p

p

p

p

e

e

p

e

p

references

e

p

e

p

p

e

p

e

allen  j     schubert  l          trains project  tech  rep       dept  computer
science  univ  rochester  rochester  ny  slightly revised language
discourse trains project  a  ortony  j  slack  o  stock  eds    communication artificial intelligence perspective  theoretical springer verlag 
heidelberg  pp         
allen  j   schubert  l   ferguson  g   heeman  p   hwang  c   kato  t   light  m   martin 
n   miller  b   poesio  m     traum  b          trains project  case study
building conversational planning agent  experimental theoretical artificial
intelligence          
barrett  a   golden  k   penberthy  s     weld  d          ucpop user s manual  tech 
rep            dept  computer science engineering  university washington 
seattle  wa       
blum  a     furst  m          fast planning planning graph analysis  proceedings
fourteenth international joint conference artificial intelligence  ijcai     
pp            montreal  ca  morgan kaufmann 
chapman  d          planning conjunctive goals  artificial intelligence                  
currie  k     tate  a          o plan  open planning architecture  artificial intelligence         
fikes  r     nilsson  n          strips  new approach application theorem
proving problem solving  artificial intelligence             
georgeff  m     lansky  a          reactive reasoning planning  proceedings
sixth national conference american association artificial intelligence  pp 
        seattle  wa  morgan kaufmann 
   

figerevini   schubert
gerevini  a     schubert  l k          computing parameter domains aid planning 
proc   rd int  conf  artificial intelligence planning systems  aips     
pp         menlo park  ca  aaai press 
goldszmidt  m   darwiche  a   chavez  t   smith  d     white  j          decision theory
crisis management  tech  rep  rl tr         rome laboratory 
green  c          application theorem proving problem solving  proceedings
first international joint conference artificial intelligence  ijcai      pp 
        
joslin  d          personal communication 
joslin  d     pollack  m          least cost aw repair  plan refinement strategy
partial order planning  proceedings twelfth national conference
american association artificial intelligence  aaai      pp            seattle 
wa  morgan kaufmann 
kambhampati  s   knoblock  c  a     yang  q          planning refinement search 
unified framework evaluating design tradeoff partial order planning  artificial
intelligence  special issue planning scheduling           
korf  r          linear space best first search  summary results  proceedings
tenth national conference american association artificial intelligence
 aaai      pp          
mcallester  d     rosenblitt  d          systematic nonlinear planning  proceedings
ninth national conference artificial intelligence  aaai      pp         
anheim  los angeles  ca  morgan kaufmann 
nilsson  n          principles artificial intelligence  tioga pub  co   palo alto  ca 
penberthy  j     weld  d          ucpop  sound  complete  partial order planner
adl  nebel  b   rich  c     swartout  w   eds    proceedings third
international conference principles knowledge representation reasoning
 kr     pp          boston  ma  morgan kaufmann 
peot  m  a     smith  d  e          threat removal strategies partial order planning 
proceedings eleventh national conference american association
artificial intelligence  aaai      pp          washington  d c  morgan kaufmann 
schubert  l     gerevini  a          accelerating partial order planners improving
plan goal choices  proc   th ieee int  conf  tools artificial
intelligence  pp          herndon  virginia  ieee computer society press 
smith  d  e     peot  m  a          postponing threats partial order planning 
proceedings eleventh national conference american association artificial intelligence  aaai      pp          washington  d c  morgan kaufmann 
smith  d  e          personal communication 
   

fiaccelerating partial order planners
srinivasan  r     howe  a          comparison methods improving search eciency
partial order planner  proceedings fourteenth international joint conference artificial intelligence  ijcai      pp            
weld  d          introduction least commitment planning  ai magazine         
      
wilkins  d          practical planning  extending classical ai planning paradigm 
morgan kaufmann  san mateo  ca 
williamson  m     hanks  s          flaw selection strategies value directed planning 
proceedings third international conference artificial intelligence planning
systems  pp          
yang  q     chan  a y m          delaying variable binding commitments planning 
proceedings second international conference artificial intelligence planning
systems  pp          

   


