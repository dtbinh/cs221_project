journal artificial intelligence research               

submitted       published     

hierarchy tractable subsets
computing stable models
rachel ben eliyahu

rachel cs bgu ac il

mathematics computer science department
ben gurion university negev
p o b       beer sheva        israel

abstract

finding stable models knowledge base significant computational problem
artificial intelligence  task computational heart truth maintenance
systems  autoepistemic logic  default logic  unfortunately  np hard 
paper present hierarchy classes knowledge bases 
 
    following
properties  first 
  class stratified knowledge bases  second  knowledge
base
  stable models  may found time
     length knowledge base number atoms   third 
arbitrary knowledge base   find minimum belongs

time polynomialsin  size   and  last  k class knowledge bases 
case   
  k  is  every knowledge base belongs class
hierarchy 
 

k

k

lnk

     

l

n

k



k



   introduction
task computing stable models knowledge base lies heart three
fundamental systems artificial intelligence  ai   truth maintenance systems  tmss  
default logic  autoepistemic logic  yet  task intractable  elkan        kautz  
selman        marek   truszczynski         paper  introduce hierarchy
classes knowledge bases achieves task polynomial time  membership
certain class hierarchy testable polynomial time  hence  given knowledge base 
cost computing stable models bounded prior actual computation  if
algorithms hierarchy based used  
first  let us elaborate relevance computing stable models ai tasks  define
knowledge base set rules form

c  a         am  b        bn

   

c   as  b atoms propositional language  substantial efforts
give meaning  semantics  knowledge base made logic programming
community  przymusinska   przymusinski         one successful semantics
knowledge bases stable model semantics  bidoit   froidevaux        gelfond   lifschitz 
      fine         associates knowledge base  possibly empty  set
models called stable models  intuitively  stable model represents set coherent
c     


ai access foundation morgan kaufmann publishers  rights reserved 

fiben eliyahu
conclusions one might deduce knowledge base  turns stable models
play central role major deductive systems ai   

    stable models tmss

tmss  doyle        inference systems nonmonotonic reasoning default assumptions  tms manages set nodes set justifications  node
represents piece information justifications rules state dependencies
nodes  tms computes grounded set nodes assigns set
information believed true given point time  intuitively  set believed
nodes grounded satisfies rules  node believed true solely basis
circular chain justifications  elkan        pointed nodes tms
viewed propositional atoms  set justifications knowledge base 
showed task computing grounded interpretations set tms justifications corresponds exactly task computing stable models knowledge base
represented set tms justifications 

    stable models autoepistemic logic

autoepistemic logic invented moore        order formalize process
agent reasoning beliefs  language autoepistemic logic propositional
language augmented modal operator l  given theory  a set formulas 
autoepistemic logic  theory e called stable expansion iff
e    t sflf jf   e gsf lf jf    e g 
denotes logical closure   restrict subset
autoepistemic logic formula form
a             lb           lbn   c
   
c   as  b propositional atoms  call subset
class autoepistemic programs  every autoepistemic program translated
knowledge base representing formula     knowledge base rule      elkan
       shown stable model iff expansion e
set positive atoms e   thus  algorithms computing stable models
may used computing expansions autoepistemic programs  relationship
stable model semantics autoepistemic logic explored gelfond       
gelfond lifschitz              

    stable models default logic

default logic formalism developed reiter        reasoning default assumptions  default theory viewed set defaults  default defined
expression form
  fi        fin
   



   logic programming terminology  knowledge bases discussed paper called normal logic
programs 

  

fia hierarchy tractable subsets
ff    fi         fin formulas first order language  according reiter  e
extension default theory iff e coincides one minimal deductively
closed sets sentences e   satisfying condition  grounded instance
default         e    fi          fin    e     e   
consider subset default theories call default programs  default
program set defaults form

a             b         bn
   
c
c   as  b atoms propositional language 

default program associated knowledge base replacing
default form     rule     
gelfond lifschitz        shown logical closure set atoms e
extension iff e stable model   algorithms computing stable models
thus used computing extensions reiter s default theories 


paper organized follows  next section  define terminology 
section   presents two algorithms computing stable models knowledge base 
complexity first algorithms depends number atoms appearing
negatively knowledge base  complexity algorithm depends
number rules negative atoms bodies  section    present
main algorithm paper  called algorithm aas  algorithm aas works
bottom superstructure dependency graph knowledge base uses
two algorithms presented section   subroutines  section   explains aas
algorithm generalized handle knowledge bases first order language  finally 
sections      discuss related work make concluding remarks 

   preliminary definitions
recall knowledge base defined set rules form

c  a         am  b        bn

   

c   as  b propositional atoms  expression
left   called head rule  expression right   called
body rule  said appear positive rule  and  accordingly 
b said appear negative rule  rule     said c   rule
empty body called unit rule  sometimes treat truth assignment  in
words  interpretation  propositional logic set atoms   set atoms
assigned true interpretation  given interpretation set atoms a  ia
denotes projection a  given two interpretations  j   sets atoms
   note appearance e condition 

  

fiben eliyahu
b   respectively  interpretation   j defined follows 
  
p   n b
   ij  pp  
p   btn
  j  p        p  
p   b  p     j  p  

  
undefined otherwise

 p     j  p   every p   b   say j consistent 

partial interpretation truth assignment subset atoms  hence  partial
interpretation represented consistent set literals  positive literals represent
atoms true  negative literals atoms false  rest unknown 
knowledge base called horn rules horn  model theory  set
clauses  propositional logic truth assignment satisfies clauses  one
looks knowledge base theory propositional logic  horn knowledge base
unique minimal model  recall model minimal among set models iff
model m    m  m  
given knowledge base set atoms m  gelfond lifschitz defined
called gelfond lifschitz  gl  transform w r t  m  knowledge base
obtained deleting rule negative literal p body
p   deleting negative literals bodies remaining rules  note
horn knowledge base  model stable model knowledge base iff
unique minimal model  gelfond   lifschitz        
example     consider following knowledge base    used one
canonical examples throughout paper 
   
warm blooded   mammal
live land   mammal  ab 
   
female   mammal  male
   
male   mammal  female
   
mammal   dolphin
    
ab    dolphin
    
mammal   lion
    
lion  
    
  flion  mammal  warm blooded  live land  femaleg stable model     indeed 
 m  the gl transform   w r t  m 

 
 
 
 
 
 
 

warm blooded
live land
female
mammal
ab 
mammal
lion

  

mammal
mammal
mammal
dolphin
dolphin
lion

fia hierarchy tractable subsets
minimal model  m  
set atoms satisfies body rule iff atom appears positive
body atom appears negative body   set
atoms satisfies rule iff either satisfy body  satisfies body
atom appears head belongs  
proof atom sequence rules atom derived  formally 
recursively define atom p proof w r t  set atoms
knowledge base  
unit rule p     p proof w r t   
rule p  a        am  b        bn   every           n bi
  every           ai already proof w r t    p
proof w r t   
theorem      elkan        ben eliyahu   dechter        set atoms stable
model knowledge base iff
   satisfies rule  
   atom p   proof p w r t  
simple matter show following lemma true 
lemma     let knowledge base  let set atoms  define 
   s      

   si     si fp jp  a         am  b         bn  
a s belong si none b  s belong g 
s 
stable model iff    
 
observe although every stable model minimal model knowledge base
viewed propositional theory  every minimal model stable model 
example     consider knowledge base
b  
fag fbg minimal models knowledge base above  fbg stable
model knowledge base 
note knowledge base may one stable models  stable model all 
knowledge base least one stable model  say consistent 
dependency graph knowledge base directed graph atom
node positive edge directed p q iff rule q
p appears positive body  accordingly  negative edge
p q iff rule q p appears negative body  recall
source directed graph node incoming edges  sink node
outgoing edges  given directed graph g node g  subgraph rooted
subgraph g nodes path directed g 
children g nodes arc directed g 
  

fiben eliyahu

example     dependency graph   shown figure    negative edges
marked  not   children mammal lion dolphin  subgraph rooted
land subgraph include nodes lion  mammal  dolphin  ab   land 

male

warm blood
female



on land
mammal

lion



ab 
dolphin

figure    dependency graph  
knowledge base stratified iff assign atom c positive integer ic
every rule form     above  as  ia ic  
b s  ib   ic   readily demonstrated knowledge base stratified iff
dependency graph directed cycles going negative edges  well
known logic programming community stratified knowledge base unique
stable model found linear time  gelfond   lifschitz        apt  blair   
walker        

example       stratified knowledge base  following knowledge base    

stratified  we assign ab  penguin number    atoms
number    

live land
fly
bird
ab 

 
 
 
 
  

bird
bird  ab 
penguin
penguin

fia hierarchy tractable subsets
strongly connected components directed graph g make partition
set nodes that  subset partition x     
directed paths x x g  strongly connected components
identifiable linear time  tarjan        

male




female
warm blood

on land
mammal

lion



ab 
dolphin

figure    super dependency graph  
super dependency graph knowledge base   denoted g   superstructure
dependency graph   is  g directed graph built making strongly
connected component dependency graph node g   arc exists
node node v iff arc one atoms one atoms v
dependency graph   note g acyclic graph 

example     super dependency graph   shown figure    nodes

square grouped single node 

   two algorithms computing stable models
main contribution paper presentation algorithm whose eciency
depends  distance  knowledge base stratified knowledge base 
distance measured precisely section    first describe two algorithms
computing stable models  two algorithms take account level
 stratifiability  knowledge base  is  still work exponential time
stratified knowledge bases  main algorithm use two algorithms procedures 
  

fiben eliyahu
given truth assignment knowledge base  verify polynomial time whether
stable model using lemma      therefore  straightforward algorithm computing stable models simply check possible truth assignments determine whether
stable model  time complexity straightforward procedure
exponential number atoms used knowledge base  below  present two
algorithms often function eciently straightforward procedure 

    algorithm depends number negative atoms
knowledge base
algorithm all stable   figure    enables us find stable models time expo 

nential number atoms appear negative knowledge base 
algorithm follows work abductive extensions logic programming
stable models characterized terms sets hypotheses drawn additional information  eshghi   kowalski        dung        kakas   mancarella        
done making negative atoms abductible imposing appropriate denials
disjunctions integrity constraints  work eshghi kowalski         dung
        kakas mancarella        implies following 
theorem     let knowledge base  let h set atoms appear negated
  stable model iff interpretation h
   every atom p   h   p     p      
     consistent 
      m    
  unique stable model  
proof  proof follows directly definition stable models  suppose
stable model knowledge base   let h set atoms appear negative
  then  definition  stable model   note   mh   hence 
conditions theorem     hold   taking       mh   now  suppose
knowledge base           theorem      observe
  and  hence  since   stable model     stable model  
show stable model   first  note condition        thus 
satisfies rules and  atom p proof w  r  t     
proof w  r  t    so  theorem      stable model and 
definition  stable model  
theorem     implies algorithm all stable   figure     computes stable
models knowledge base   hence  following complexity analysis 
proposition     knowledge base k atoms appear negated
 k stable models found time o nl k    l size
knowledge base n number atoms used knowledge base 
proof  follows fact computing computing unique stable model
positive knowledge base o nl  
  

fia hierarchy tractable subsets

all stable   

input  knowledge base  
output  set stable models  
        
   possible interpretation set atoms appear negative  
do 
 a  compute     unique stable model  

 b    consistent  let    fm     g 
   return m 
figure    algorithm all stable 

    algorithm depends number non horn rules
algorithm all stable   figure    depends number rules

negated atoms  gets input knowledge base   and  outputs set stable
models   algorithm based upon observation stable model
built attempting possible means satisfying negated atoms bodies nonhorn rules  two procedures called all stable   unitinst  shown figure   
negunitinst  shown figure    procedure unitinst gets input knowledge base
partial interpretation m  unitinst looks recursively unit rules   unit rule
p     p assigned false m  follows cannot part model  
procedure returns false  p false m  procedure instantiates p true
interpretation deletes positive appearances p body rule 
deletes rules p rules p appears negative 
procedure negunitinst receives input knowledge base   partial interpretation
m  set atoms neg  first instantiates atom neg false updates
knowledge base ect instantiation  instantiations recorded m 
case con ict  namely  procedure tries instantiate true atom
already set false  procedure returns false  otherwise  returns true 

proposition     algorithm all stable  correct  is  stable model
knowledge base iff generated all stable    
proof  suppose stable model knowledge base   then  theorem      every
atom set true proof w  r  t    let set non horn
rules whose bodies satisfied m  clearly  point checked step  
algorithm all stable   happens  atoms proof w  r  t 
set true procedure negunitinst  as proved induction
length proof   hence  generated 
suppose generated all stable     obviously  every rule satisfied
 step   c ii   every atom set true negunitinst proof w  r  t 
  

fiben eliyahu

all stable   
input  knowledge base  
output  set stable models  
        
   let set non horn rules  
   subset   do 
 a  neg   fp jnot p body rule g 
 b              
 c  negunitinst     neg  m  
i  p m p     null  let m p      false 

ii  satisfies rules      fmg 
   endfor 
   return  
figure    algorithm all stable 
unitinst   m 
input  knowledge base partial interpretation m 
output  updates using unit rules   returns false con ict
unit rule value assigned atom m  otherwise  returns true  
   unit rules  do 
 a  let p   unit rule  
 b  m p     false  return false 
 c  m p      true 
 d  erase p body rule  
 e  erase rules p  
 f  erase rules p appears negative 
   endwhile 
   return true 
figure    procedure unitinst
  

fia hierarchy tractable subsets
negunitinst   neg  m 
input  knowledge base   set atoms neg   partial interpretation m 
output  updates assuming atoms neg false  returns false inconsistency
detected  otherwise  returns true 
   atom p neg
 a  m p      false 
 b  delete body rule occurrence p  
 c  delete rule p appears positive body 
   endfor 
   return unitinst   m  
figure    procedure negunitinst



 
 

lion dolphin ab  mammal warm b land male female


f

f







f





f

f









f

table    models generated algorithm all stable 
 as readily observable way negunitinst works   hence  theorem     
stable model  

proposition     knowledge base c non horn rules  c stable models

found time o nl c   l size knowledge base
n number atoms used knowledge base 

proof  straightforward  induction c 
example     suppose call all stable    input knowledge base 
step    set rules                subsets include rules
        considered step    negunitinst return false unitinst

detect inconsistency  subset containing rules         considered 
stable model   table   generated  subset containing rules    
    considered  stable model   table   generated 
subsets contain rules         tested step    generated
satisfy rules and  hence  appear output 
algorithms all stable  all stable  take account structure
knowledge base  example  polynomial class stratified
knowledge bases  present next algorithm exploits structure knowledge
base 
  

fiben eliyahu

   hierarchy tractable subsets based level stratifiability
knowledge base

algorithm acyclic all stable  aas  figure   exploits structure knowledge
base ected super dependency graph knowledge base  computes
stable models traversing super dependency graph bottom up  using
algorithms computing stable models presented previous section subroutines 
let knowledge base  node g  the super dependency graph
   associate     ms   subset containing rules
atoms s  set atoms subgraph g rooted s  ms set
stable models associated subset knowledge base contains rules
atoms   initially  ms empty every s  algorithm traverses g
bottom up  node s  first combines submodels children
single set models mc s    source  mc s  set f g   next 
model mc s    aas converts knowledge base sm using gl transform
transformations depend atoms m  then  finds stable models
sm combines m  set ms obtained repeating operation
mc s    aas uses procedure cartesprod  figure     receives input
several sets models returns consistent portion cartesian product  one
sets models cartesprod gets input empty set  cartesprod
output empty set models  procedure convert gets input knowledge base  
model m  set atoms s  performs following  atom p m 
positive occurrence p deleted body rule   rule  
p body rule p   m  rule deleted   p
body rule p    m  then  p    s  p deleted body 
procedure all stable called aas may one procedures previously presented
 all stable  all stable   may procedure generates stable
models 

example     suppose aas called compute stable models    suppose

algorithm traverses super dependency graph figure   order flion 
dolphin  mammal  ab   land  warm blooded  female maleg  recall nodes inside square make one node calling female male or  short  fm  
visiting nodes except last  mlion   ffliongg  mdolphin   f g 
mmammal   fflion  mammalgg  mon land   fflion  mammal  onlandgg  mwarm blooded  
fflion  mammal  warm bloodedgg  visiting node fm  step   c
mc fm     mmammal   step   d loops once    flion  mammalg  recall
fm knowledge base

female
male

  mammal  male
  mammal  female

   note difference f g  set one model   model assigns
atoms     set contains models 

  

false



fia hierarchy tractable subsets

acyclic all stable  

input  knowledge base  
output  set stable models  
   traverse g bottom up  node s  do 
 a  ms      
 b  let s         sj children s 
 c  j      mc s     f g 
else mc s     cartesprod fms         msj g  
 d    mc s    do 
i  sm    convert s   m  s  
ii     all stable sm   

iii        ms    ms cartesprod ffmg  g  
   output cartesprod fms         msk g   s         sk sinks g  
figure    algorithm acyclic all stable  aas 
cartesprod m 
input  set sets models m 
output  set models consistent portion cartesian product
sets m 
   single element fe g  return e  
        
   let     m 
      cartesprod m n fm  g  
   d  do 
 a      do 

consistent     fm   dg 
 b  endfor 
   endfor 
   return  
figure    procedure cartesprod
  

fiben eliyahu
executing step   d i  fm set

female
male

  male
  female

knowledge base two stable models  ffemaleg fmaleg  cartesian
product set flion  mammalg yields mfm   fflion  mammal  femaleg 
flion  mammal  malegg  step    cartesian product mwarm blooded   mon land 
mfm taken  thus  algorithm outputs fflion  mammal  land  warm blooded  femaleg 
flion  mammal  land  warm blooded  malegg  indeed two stable models
    note algorithm aas ecient either all stable  all stable 
knowledge base    

theorem     algorithm aas correct  is  stable model knowledge base
iff generated aas applied  
proof  let s   s        sn ordering nodes super dependency graph

algorithm executed  show induction aas  node
si  generates stable models portion knowledge base composed
rules use atoms asi  
case      case  step   d ii aas  sm   s  thus  claim follows
correctness algorithm all stable called step   d ii 
case      showing every model generated stable straightforward  induction hypothesis theorem      direction is  suppose stable model
  show generated  clearly  child si   projection
onto stable model part knowledge base uses atoms
as  induction  mc   projection onto union every
child si   must belong mc si   computed step   c  therefore  show
generated  need show m      mc stable model simc  
easily done using theorem     
analyze complexity aas  first  given knowledge base
set atoms s  define   knowledge base obtained deleting
negative occurrence atom belong body every rule 
example    fa  not b  c  not d  ag   fbg      fa  not b  c  ag 
visiting node execution aas  compute step   d ii
stable models knowledge base sm   using either all stable  all stable  
estimated time required find stable models sm shorter equal
time required find stable models     occurs number negative
atoms number rules negative atoms bodies   higher
equal number negative atoms number rules negative atoms
bodies sm   regardless is  thus    horn knowledge base 
find stable model     hence sm   polynomial time  matter is 
  

fia hierarchy tractable subsets
  positive  find stable models     hence sm   time
min ln  k   ln  c    l length     n number atoms used     c
number rules   contain negative atoms  k number atoms appear
negatively    
then  knowledge base   associate number follows  associate
number vs every node g     horn knowledge base  vs    else  vs
min  k    c   c number rules   contain negative atoms s 
k number atoms appear negatively     associate number ts
every node s  leaf node  ts   vs   children s         sj g  
ts   vs ts      tsj   define ts      tsk   s         sk sink nodes
g  
definition     knowledge base belongs
j   j  
theorem     knowledge base belongs
j j   j stable
models computed time o lnj   
proof  induction j   dependency graph super dependency graph
built time linear size knowledge base  may consider
time takes compute stable models super dependency graph given 
case j       
  means every node g    horn knowledge base 
words  stratified  therefore exactly one stable model 
n nodes graph  node  loop step   d executed
once  one model generated every node  procedure convert runs
time o ls   ls length  we assume stored array
access atom constant time   since  every node s   
horn knowledge base  sm computed time o lsn   thus  overall complexity
o ln  
case j      induction n  number nodes super dependency graph  
case n      let single node g   thus  j   vs  using algorithms
section    stable models   found time o lnvs   
vs models 
case n      assume without loss generality g single sink  to get
single sink  add program rule p   s        sk  s         sk
sinks p new atom   let c         ck children s 
child ci    ci    part knowledge base corresponds subgraph
rooted ci  must belong
ti ti j   induction n 
child node ci  stable models  ci   computed time o lnti   
 ci  ti stable models  let us observe happens aas
visiting node s  first  cartesian product models computed
child nodes taken  executed time o n t      tk   yields
t      tk models mc s    every   mc s    call convert  o ln  
compute stable models sm  o lnvs    combine
using cartesprod  o nvs     thus  overall complexity computing ms  
is  computing stable models   o lnt      tk vs     o lnj   
  

fiben eliyahu

note stratified knowledge bases belong
    knowledge
base looks stratified  ecient algorithm aas be 
given knowledge base   easy find minimum j belongs
j  
follows building g finding c k every node g polynomialtime tasks  hence 
theorem     given knowledge base   find minimum j belongs

j polynomial time 
example     nodes g  except fm  vs     vfm      thus     
    
stratified knowledge base therefore belongs
  



male


female
warm blood

on land
mammal

lion

fly




ab 
dolphin

bird

ab 

penguin



figure    super dependency graph    
next example shows step   procedure cartesprod necessary 
example     consider knowledge base   
  b
b  

c

e
f

 
 
 
 

  


b
c 
c

fia hierarchy tractable subsets

f

e

c







b


figure     super dependency graph  





c

c








b

b





   

   

figure     dependency graph     super dependency graph      
  

fiben eliyahu
super dependency graph   shown figure     run algorithm aas 
mab  the set models computed node fa  bg  set ffa   bg  f a  bgg  aas
visits nodes c d  get mc   ffa   b  cg  f a  bgg  md   ff a  b  dg  fa   bgg 
aas visits node e  cartesprod called input fmc   mdg  yielding output  
ffa   b  cg  f a  b  dgg  note cartesprod output model c
true  models fa   b  cg f a  b  dg inconsistent cartesprod
checks consistency step    visiting node f   get mf   ffa   b  c  f g  f a  bgg 
aas returns cartesprod fme  mf g   ffa   b  c  f g  f a  b  dgg 
next example demonstrates models generated nodes super dependency graph run aas may later deleted  since cannot
completed stable model whole knowledge base 

example     consider knowledge base   

b
c

  b
 
  a  c

dependency graph super dependency graph   shown figure    
run algorithm aas  mab  the set models computed node fa  bg 
set ffag  fbgg  however  fbg stable model    
despite deficiency illustrated example      algorithm aas desirable
features  first  aas enables us compute stable models modular fashion  use
g structure store stable models  knowledge base changed 
need resume computation nodes affected change  example 
suppose computing stable models knowledge base     add tos  
knowledge base   example      gives us new knowledge base          
super dependency graph new knowledge base   shown figure   
need compute stable models nodes penguin  bird  ab   y  land
combine models generated sinks  re compute
stable models nodes well 
second  using aas algorithm  always compute stable models
root node  queried atom somewhere middle
graph  often enough compute models subgraph rooted
node represents atom  example  suppose given knowledge base
  asked mammal true every stable model     run aas
nodes dolphin  lion  mammal   stop  mammal true stable
models computed node mammal  i e   models mmammal    answer
 yes   otherwise  must continue computation 
third  aas algorithm useful computing labeling tms subject
nogoods  set nodes tms declared nogood  means acceptable
labeling assign false least one node nogood set   stable models
terminology  means handling nogoods  look stable models
   logic programming terminology nogoods simply integrity constraints 

  

fia hierarchy tractable subsets
least one atom nogood false  straightforward approach would first
compute stable models choose ones comply nogood
constraints  since aas algorithm modular works bottom up 
many cases prevent generation unwanted stable models early stage 
computation  exclude submodels comply nogood
constraints erase submodels ms node super
dependency graph includes members certain nogood 

   computing stable models first order knowledge bases
section  show generalize algorithm aas find stable
models knowledge base first order language function symbols  new
algorithm called first acyclic all stable  faas  
refer knowledge base set rules form

c  a   a        am  b        bn

    

as  b s  c atoms first order language function symbols 
definitions head  body  positive negative appearances atom
propositional case  expression p x        xn   p called predicate name 
propositional case  every knowledge base associated directed graph
called dependency graph    a  predicate name node   b 
positive arc directed node p node q iff rule
p predicate name one ai q predicate name head   c 
negative arc directed node p node q iff rule
p predicate name one bi q predicate name head  super
dependency graph  g   defined analogous manner  define stratified knowledge
base knowledge base cycles negative edges
dependency graph knowledge base 
knowledge base called safe iff rules safe  rule safe iff
variables appearing head rule predicates appearing negative rule
appear positive predicates body rule  section  assume
knowledge bases safe  herbrand base knowledge base set atoms
constructed using predicate names constants knowledge base  set
ground instances rule set rules obtained consistently substituting variables
rule constants appear knowledge base possible ways 
ground instance knowledge base union ground instances rules  note
ground instance first order knowledge base viewed propositional
knowledge base 
model knowledge base subset knowledge base s herbrand base 
subset property every rule grounded knowledge base 
atoms appear positive body rule belong atoms
appear negative body rule belong   atom head
rule belongs   stable model first order knowledge base herbrand
model   stable model grounded version  
  

fiben eliyahu

first acyclic all stable  

input  first order knowledge base  
output  stable models  
   traverse g bottom up  node s  do 
 a  ms      
 b  let s         sj children s 
 c  mc s     cartesprod fms         msj g  
 d    mc s 
ms    mssall stable s sfp  jp   mg 
   output cartesprod fms         msk g   s         sk sinks g  
figure     algorithm first acyclic all stable  faas 
present faas  algorithm computes stable models first order
knowledge base  let first order knowledge base  propositional case 
node g  the super dependency graph    associate     ms  
subset containing rules predicates whose names s 
set predicate names p appear subgraph g rooted s  ms
stable models associated sub knowledge base contains rules
predicates whose names   initially  ms empty every s  algorithm faas
traverses g bottom up  node s  algorithm first combines
submodels children single set models  mc s    then  model
mc s   calls procedure finds stable models union set
unit clauses p   p   m  procedure all stable called faas
procedure computes stable models first order knowledge base 
procedure all stable computes stable models parts knowledge base 
may take advantage fractions knowledge base stratified
property simplifies computation stable models fraction 

theorem     algorithm faas correct  is  stable model knowledge base
iff one models output applying faas  

proof  proof theorem     

note knowledge base appears stratified  ecient algorithm
faas becomes 

example     consider knowledge base   
warm blooded x  
live land x  
female x  

  mammal x  
  mammal x    ab  x  
  mammal x    male x  
  

fia hierarchy tractable subsets
male x  
mammal x  
ab  x  
mammal x  
dolphin flipper 

 
 
 
 
 

mammal x    female x  
dolphin x  
dolphin x  
lion x  

  bird x  
  bird x    ab  x  
  penguin x  
  penguin x  
 
super dependency graph     g    super dependency graph
live land x  
fly  x  
bird x  
ab  x  
bird bigbird 

knowledge base    see figure     observe node mammal  example 

step   d algorithm looks stable models knowledge base     mammal
f  dolphin flipper g  mammal  fmammal x    dolphin x    mammal x    lion x  g 
  stratified knowledge base unique stable model found eciently 
hence  algorithm faas saves us ground rules knowledge base
starting calculate models  take advantage parts knowledge
base stratified 

   related work

recent years  quite algorithms developed reasoning stable models 
nonetheless  far know  work presented original sense
provides partition set knowledge bases hierarchy tractable
classes  partition based structure dependency graph  intuitively 
task computing stable models knowledge base using algorithm aas becomes
increasingly complex  distance  knowledge base stratified becomes
larger  next  summarize work seems us relevant 
algorithm aas based idea appears work lifschitz turner
        show many cases logic program divided two parts 
one part   bottom  part  refer predicates defined  top 
part  explain task computing stable models program
simplified program split parts  algorithm aas  using superstructure
dependency graph  exploits specific method splitting program 
bell et al         subrahmanian et al         implement linear integer programming techniques order compute stable models  among nonmonotonic logics   however  dicult assess merits approaches terms complexity 
ben eliyahu dechter        illustrate knowledge base translated
propositional theory model latter corresponds stable model
former  follows problem finding stable models
knowledge base corresponds problem finding models propositional
theory  satoh iwayama        provide nondeterministic procedure computing
  

fiben eliyahu
stable models logic programs integrity constraints  junker konolige       
present algorithm computing tms  labels  antoniou langetepe        introduce
method representing classes default theories normal logic programs
way sldnf resolution used compute extensions  pimentel cuadrado
       develop label propagation algorithm uses data structures called compressible
semantic trees order implement tms  algorithm based stable model semantics  algorithms developed marek truszczynski        autoepistemic
logic adopted computing stable models  procedures marek
truszczynski         antoniou langetepe         pimentel cuadrado         beneliyahu dechter         satoh iwayama         bell et al          subrahmanian
et al          junker konolige        take advantage structure
knowledge base ected dependency graph  therefore ecient
stratified knowledge bases 
sacca zaniolo        present backtracking fixpoint algorithm constructing one
stable model first order knowledge base  algorithm similar algorithm allstable  presented section   complexity worse complexity
all stable   show backtracking fixpoint algorithm modified
handle stratified knowledge bases ecient manner  algorithm needs
adjustments deal eciently knowledge bases close
stratified  leone et al         present improved backtracking fixpoint algorithm
computing one stable model datalog  program discuss improved algorithm
implemented  one procedures called improved algorithm based
backtracking fixpoint algorithm sacca zaniolo         backtracking
fixpoint algorithm  improved algorithm take advantage structure
program  i e   ecient programs close stratified 
several tractable subclasses computing extensions default theories  and  hence 
computing stable models  known  kautz   selman        papadimitriou   sideri 
      palopoli   zaniolo        dimopoulos   magirou        ben eliyahu   dechter 
       tractable subclasses characterized using graph ects
dependencies program atoms rules  algorithms presented
papers complete subclass knowledge bases  however  algorithms
computing extensions stratified default theories extensions default theories
odd cycles  in precise sense  given papadimitriou sideri       
cholewinski      a      b  
algorithms handling tms nogoods developed ai community doyle        charniak et al          but  elkan        points out 
algorithms always faithful semantics tms complexities
analyzed  dechter dechter        provide algorithms manipulating tms
represented constraint network  eciency algorithms depends
structure constraint network representing tms  structure
employ differs dependency graph knowledge base 
  

fia hierarchy tractable subsets

   conclusion
task computing stable models heart several systems central ai 
including tmss  autoepistemic logic  default logic  task shown
np hard  paper  present partition set knowledge bases classes

   
        knowledge base
k   k stable models 
may found time o lnk   l length knowledge base
n number atoms   moreover  arbitrary knowledge base   find
minimum k belongs
k time linear size   intuitively 
knowledge base stratified  ecient algorithm becomes  believe
beyond stratified knowledge bases  expressive knowledge base  i e 
rules nonstratified negation knowledge base   less likely needed 
hence  analysis quite useful  addition  show algorithm aas
several advantages dynamically changing knowledge base  provide applications
answering queries implementing tms s nogood strategies  illustrate
generalization algorithm aas class first order knowledge bases 
algorithm aas easily adjusted find one stable model knowledge
base  traversing super dependency graph  generate one model
node  arrive node cannot generate model based
computed far  backtrack recent node several models available
choose take next model yet chosen  worst case time
complexity algorithm equal worst case time complexity algorithm
finding stable models may exhaust possible ways generating
stable model finding certain knowledge base stable model
all  nevertheless  believe average case  finding one model
easier finding all  similar modification aas algorithm required
interested finding one model one particular atom gets value true 
work another attempt bridge gap declarative systems  e g  
default logic  autoepistemic logic  procedural systems  e g   atms  prolog 
nonmonotonic reasoning community  argued declarative methods
sound  impractical since computationally expensive  procedural methods ecient  dicult completely understand performance
evaluate correctness  work presented illustrates declarative
procedural approaches combined yield ecient yet formally supported
nonmonotonic system 

acknowledgments
thanks luigi palopoli useful comments earlier draft paper michelle
bonnice gadi dechter editing parts manuscript  many thanks
anonymous referees useful comments 
work done author visiting cognitive systems laboratory  computer science department  university california  los angeles  california 
usa  work partially supported nsf grant iri         air force oce
scientific research grant  f                
  

fiben eliyahu

references

antoniou  g     langetepe  e          soundness completeness logic programming
approach default logic  aaai     proceedings   th national conference
artificial intelligence  pp           aaai press  menlo park  calif 
apt  k   blair  h     walker  a          towards theory declarative knowledge 
minker  j   ed    foundations deductive databases logic programs  pp         
morgan kaufmann 
bell  c   nerode  a   ng  r     subrahmanian  v          mixed integer programming
methods computing non monotonic deductive databases  journal acm 
                  
ben eliyahu  r     dechter  r          propositional semantics disjunctive logic programs  annals mathematics artificial intelligence             short version
appears jicslp     proceedings      joint international conference
symposium logic programming 
ben eliyahu  r     dechter  r          default reasoning using classical logic  artificial
intelligence                    
bidoit  n     froidevaux  c          minimalism subsumes default logic circumscription
stratified logic programming  lics     proceedings ieee symposium
logic computer science  pp         ieee computer science press  los alamitos 
calif 
charniak  e   riesbeck  c  k     mcdermott  d  v          artificial intelligence programming  chap      lawrence erlbaum  hillsdale  nj 
cholewinski  p       a   reasoning stratified default theories  marek  w  v  
nerode  a     truszczynski  m   eds    logic programming nonmonotonic reasoning  proceedings  rd international conference  pp           lecture notes
computer science       springer verlag  berlin 
cholewinski  p       b   stratified default theories  pacholski  l     tiuryn  a   eds   
computer science logic   th workshop  csl     selected papers  pp           lecture
notes computer science       springer verlag  berlin 
dechter  r     dechter  a          structure driven algorithms truth maintenance 
artificial intelligence                 
dimopoulos  y     magirou  v          graph theoretic approach default logic  journal
information computation               
doyle  j          truth maintenance system  artificial intelligence              
dung  p  m          negation hypothesis  abductive foundation logic programming  furukawa  k   ed    iclp     proceedings  th international conference
logic programming  pp        mit press 
  

fia hierarchy tractable subsets
elkan  c          rational reconstruction nonmonotonic truth maintenance systems 
artificial intelligence              
eshghi  k     kowalski  r  a          abduction compared negation failure  levi 
g     martelli  m   eds    iclp     proceedings  th international conference
logic programming  pp           mit press 
fine  k          justification negation failure  logic  methodology philosophy
science             
gelfond  m          stratified autoepistemic theories  aaai     proceedings
 th national conference artificial intelligence  pp           morgan kaufmann 
gelfond  m     lifschitz  v          stable model semantics logic programming 
kowalski  r  a     bowen  k  a   eds    logic programming  proceedings  th
international conference  pp             mit press 
gelfond  m     lifschitz  v          classical negation logic programs disjunctive
databases  new generation computing             
junker  u     konolige  k          computing extensions autoepistemic default logics tms  aaai     proceedings  th national conference
artificial intelligence  pp           aaai press 
kakas  a  c     mancarella  p          stable theories logic programs  saraswat 
v     udea  k   eds    islp     proceedings      international symposium
logic programming  pp          mit press 
kautz  h  a     selman  b          hard problems simple default logics  artificial
intelligence              
leone  n   romeo  n   rullo  m     sacca  d          effective implementation negation
database logic query languages  atzeni  p   ed    logidata   deductive
database complex objects  pp           lecture notes computer science      
springer verlag  berlin 
lifschitz  v     turner  h          splitting logic program  van hentenryck  p   ed   
iclp     proceedings   th international conference logic programming  pp 
       mit press 
marek  v  w     truszczynski  m          nonmonotonic logic  context dependent reasoning  springer verlag  berlin 
marek  w     truszczynski  m          autoepistemic logic  journal acm     
        
moore  r  c          semantical consideration nonmonotonic logic  artificial intelligence            
palopoli  l     zaniolo  c          polynomial time computable stable models   annals
mathematics artificial intelligence  press 
  

fiben eliyahu
papadimitriou  c  h     sideri  m          default theories always extensions 
artificial intelligence              
pimentel  s  g     cuadrado  j  l          truth maintenance system based stable
models  lusk  e  l     overbeek  r  a   eds    iclp     proceedings     
north american conference logic programming  pp           mit press 
przymusinska  h     przymusinski  t          semantic issues deductive databases
logic programs  banerji  r  b   ed    formal techniques artificial intelligence 
sourcebook  pp           north holland  new york 
reiter  r          logic default reasoning  artificial intelligence             
sacca  d     zaniolo  c          stable models non determinism logic programs
negation  pods     proceedings  th acm sigact sigmod sigart
symposium principles database systems  pp           acm press 
satoh  k     iwayama  n          computing abduction using tms  furukawa  k 
 ed    iclp     proceedings  th international conference logic programming 
pp           mit press 
subrahmanian  v   nau  d     vago  c          wfs   branch bound   stable models 
ieee transactions knowledge data engineering                 
tarjan  r          depth first search linear graph algorithms  siam journal
computing             

  


