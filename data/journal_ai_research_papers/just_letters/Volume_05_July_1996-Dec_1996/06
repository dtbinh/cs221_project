journal artificial intelligence research                 

submitted       published      

muse csp  extension
constraint satisfaction problem
randall a  helzerman
mary p  harper

school electrical computer engineering
     electrical engineering building
purdue university
west lafayette             usa

helz ecn purdue edu
harper ecn purdue edu

abstract

paper describes extension constraint satisfaction problem  csp  called
muse csp  mu ltiply se gmented c onstraint atisfaction p roblem   extension
especially useful problems segment multiple sets partially shared
variables  problems arise naturally signal processing applications including computer vision  speech processing  handwriting recognition  applications 
often dicult segment data one way given low level information utilized
segmentation algorithms  muse csp used compactly represent several
similar instances constraint satisfaction problem  multiple instances csp
common variables domains constraints 
combined single instance muse csp  reducing work required apply
constraints  introduce concepts muse node consistency  muse arc consistency 
muse path consistency  demonstrate muse csp used compactly represent lexically ambiguous sentences multiple sentence hypotheses
often generated speech recognition algorithms grammar constraints
used provide parses syntactically correct sentences  algorithms muse arc
path consistency provided  finally  discuss create muse csp
set csps labeled indicate variable shared
single csp 

   introduction
paper describes extension constraint satisfaction problem  csp  called muse
csp  mu ltiply se gmented c onstraint atisfaction p roblem   extension especially
useful problems segment multiple sets partially shared variables 
first  describe constraint satisfaction problem define extension 

    constraint satisfaction problem
constraint satisfaction problems  csp  rich history artificial intelligence  davis
  rosenfeld        dechter  meiri    pearl        dechter   pearl        freuder       
      mackworth        mackworth   freuder        villain   kautz        waltz       
 for general reference  see tsang         constraint satisfaction provides convenient way
represent solve certain types problems  general  problems
solved assigning mutually compatible values predetermined number variables
c     


ai access foundation morgan kaufmann publishers  rights reserved 

fihelzerman   harper

set constraints  approach used variety disciplines including
machine vision  belief maintenance  temporal reasoning  graph theory  circuit design 
diagnostic reasoning  using csp approach  e g   figure     variables typically depicted vertices nodes  node associated finite set possible
values  constraints imposed variables depicted using arcs  arc looping
node represents unary constraint  a constraint single variable  
arc two nodes represents binary constraint  a constraint two variables  
classic example csp map coloring problem  e g   figure     color must
assigned country two neighboring countries color 
variable represents country s color  constraint arc two variables indicates
two joined countries adjacent assigned color 
formally  csp  mackworth        defined definition   

definition    constraint satisfaction problem 
n   fi  j       g set nodes  or variables   jn j   n 
l   fa  b       g set labels  jlj   l 
li   faja   l  i  a  admissibleg 
r  unary constraint   i  a  admissible r   i  a  
r  binary constraint   i  a     j  b  admissible r   i  a  j  b  
csp network contains n tuples ln satisfy r  r    since

labels associated node may incompatible labels assigned nodes 
desirable  constraints suciently tight  van beek         eliminate
many labels possible enforcing local consistency conditions globally
consistent solution extracted  dechter         node arc consistency defined
definitions      respectively  addition  may desirable eliminate many label
pairs possible using path consistency  defined definition   

definition    node consistency  instance csp said node consistent
node s domain contains labels unary constraint r  holds  i e  
 i   n    a   li   r   i  a 
definition    arc consistency  instance csp said arc consistent

every pair nodes j   element li  the domain i  least one element lj
binary constraint r  holds  i e  
 i  j   n    a   li    b   lj   r   i  a  j  b 
 red  green  blue 
different
color

 
 

 

 red  green  blue 

different
color

 
 

 

 red  green  blue 

different
color

figure    map coloring problem example csp 
   

fimuse csp  extension constraint satisfaction problem

definition    path consistency  instance csp said path consistent if 
 i  j   n      j     a   li    b   lj    k   n   k      k    j   p ath i  k  j    
 r  i a j b    c   lk   r   i  a  k  c    r   k  c  j  b   
path i  k  j   indicates path arcs length two connecting j
goes k 

node consistency easily enforced operation li   li   fxjr   i  x g  requiring
o nl  time  where n number variables l maximum domain size   arc
consistency enforced ensuring every label node supported least one
label node shares binary constraint  mackworth        mackworth
  freuder        mohr   henderson         arc consistency algorithm ac    mohr
  henderson        worst case running time  el    where e number
constraint arcs   ac    mackworth   freuder        often performs better ac  
practice  though slower running time worst case  ac    bessiere       
worst case running time ac   faster ac   ac   practice 
path consistency ensures pair labelings  i  a     j  b  allowed  i  j   arc
directly allowed arc paths j   montanari proven ensure
path consistency complete graph  suces check every arc path length two
 montanari         path consistency algorithm pc    han   lee        worstcase running time o n  l   time  where n number variables csp  

    multiply segmented constraint satisfaction problem

many types problems solved using csp less direct
fashion  problems might benefit csp approach 
dicult represent single csp  class problems paper addresses 
example  suppose map represented figure   scanned noisy computer
vision system  resulting uncertainty whether line regions    
really border artifact noise  situation would yield two csp problems
depicted figure    brute force approach would solve problems 
would reasonable scenes containing ambiguous borders  however 
number ambiguous borders increases  number csp networks would grow
combinatorially explosive fashion  case ambiguous segmentation 
ecient merge constraint networks single network would compactly
represent instances simultaneously  shown figure    notice csp
instances combined directed acyclic graph paths dag
start end correspond csps combined  paper  develop
extension csp called muse csp  mu ltiply se gmented c onstraint atisfaction
p roblem   represents multiple instances csp problem dag 
multiple  similar instances csp  separately applying constraints
instance result much duplicated work  avoid duplication 
provided way combine multiple instances csp muse csp 
   

fihelzerman   harper

 red  green  blue 

 red  green  blue 

 

 

 
different
color

 

 

 red  green  blue 

 

 
 

different
color

 

different
color

 

 
 red  green  blue 

 red  green  blue 

 

 

different
color

figure    ambiguous map yields two csp problems 

start

 red  green  blue 

different
color

different
color

 
 red  green  blue 

 
 red  green  blue 

different
color

 

 red  green 
blue 

different
color

different
color

 

 

 

 

 

end

 red  green  blue 

 red  green  blue 

 red  green  blue 

different
color

 red  green  blue 

different
color

figure    two csp problems figure   captured single instance
muse csp  directed edges form dag directed paths
dag correspond instances csps combined 

   

fimuse csp  extension constraint satisfaction problem

developed concepts muse node consistency  muse arc consistency  muse path
consistency  formally  define muse csp follows 

definition    muse csp 
n   fi  j       g set nodes  or variables   jn j   n 
 n set segments jj   s 
l   fa  b       g set labels  jlj   l 
li   faja   l  i  a  admissible least one segmentg 
r  unary constraint   i  a  admissible r   i  a  
r  binary constraint   i  a     j  b  admissible r   i  a  j  b  
segments different sets nodes representing csp instances
combined form muse csp  solution muse csp defined solution
one segments 

definition    solution muse csp  solution muse csp assignment
segment   fi          ip g     li  lip r  ix   ff ix    holds
every node ix     r  ix   ff ix   iy   ff iy    holds every pair nodes ix   iy    
ix    iy  
depending application  solution muse csp could set
consistent labels single path muse csp  single set labels
paths  or csps   compatible sets labels paths 
muse csp solved modified backtracking algorithm finds
consistent label assignment segment  however  constraints suciently
tight  search space pruned enforcing local consistency conditions  node 
arc  path consistency  gain eciency resulting enforcing local consistency
conditions backtracking  node  arc  path consistency must modified muse
csp  definitions muse csp node consistency  arc consistency  path consistency
appear definitions          respectively 

definition    muse node consistency  instance muse csp said node consistent
node s domain li contains labels unary constraint r  holds 
i e  
 i   n    a   li   r   i  a 
definition    muse arc consistency  instance muse csp said muse arc consis 

tent every label domain li least one segment whose nodes 
domains contain least one label b binary constraint r  holds  i e  

 i   n    a   li              j     j       b   lj   r   i  a  j  b 

definition    muse path consistency  instance muse csp said path consistent
if 

 i  j   n      j     a   li    b   lj         i  j      k     k      k    j   p ath i  k  j    
 r   i  a  j  b     c   lk   r   i  a  k  c    r   k  c  j  b   
   

fihelzerman   harper

a 

b 

 

 c d 

start

 

 e 

 

 e 

 d 

end

 

 a b 


e  

b
e  

c
e    

b
e    

start

end

 

 
 b 

 

 
 f 

 f 
c
   
b    


b
f    

c
f    

b

 

b
f  

f


 

figure    a  muse csp muse arc consistency achieved  b  muse csp
muse arc consistency achieved 
muse csp node consistent segments node consistent  unfortunately 
muse csp arc consistency requires attention  enforcing arc consistency
csp  label   li eliminated node whenever domain lj
labels together satisfy binary constraints  however  muse csp 
label eliminated node  must unsupported arcs every
segment appears  required definition muse arc consistency shown
definition    notice definition   reduces definition   number segments
one 
demonstrate muse arc consistency applies muse csp  consider muse
csp figure  a  notice label c   l  supported labels l 
l    receive support labels l   label considered
muse arc consistent  answer node   member paths
dag contain node   node    neither support label
c  segment nodes label supports
c  c eliminated l   c eliminated l   eliminated
l    elimination c l  causes loose support node
   since node   member every path  segment provides support a 
muse arc consistent dag depicted figure  b  note muse arc consistency
ensure individual segments arc consistent csps  example  figure
  muse arc consistent even though segments csp arc consistent 
c receives arc support  which local computation  arcs least
one paths  cannot ensure values support label
mutually consistent considering muse arc consistency alone  case  muse path
consistency together muse arc consistency would needed eliminate illegal
labels c a 
enforcing path consistency csp  r   i  a  j  b  becomes false if  third
node k  label c   lk r   i  a  k  c  r   k  c  j  b  true 
   

fimuse csp  extension constraint satisfaction problem

c
e    

b
e    

 

 c d 

start

 

 e 

end

 

 a b 

 
 f 

c
   
b    

b
f    

c
f    

figure    muse csp muse arc consistent  arc consistent
segment 
muse csp  binary constraint becomes path inconsistent one segment  could still
allowed another  therefore  definition muse path consistency modified
shown definition   
enforcement muse arc path consistency requires modification traditional
csp algorithms  algorithms described introduce several applications
muse csp proven useful 

   muse csp constraint based parsing
desirable represent muse csp directed acyclic graph  dag 
directed paths dag correspond instances csp problems  often
easy determine variables shared construct dag 
application presented section one muse csp useful  parsing
problem naturally represented dag presence ambiguity  many
cases  word multiple parts speech  convenient represent
words nodes muse csp  speech recognition systems  identification
correct words sentence improved using syntactic constraints  however  word
recognition algorithm often produces lattice word candidates  clearly  individually
parsing sentences lattice inecient 

    parsing constraint dependency grammar
maruyama developed new grammar called constraint dependency grammar  cdg 
 maruyama      a      b      c   showed cdg parsing cast
csp finite domain  constraints used rule ungrammatical sentences 
cdg four tuple  h  r  l  c i  where 
   

fihelzerman   harper

  finite set preterminal symbols  lexical categories 
r   finite set uniquely named roles  or role ids    fr          rp g 
l   finite set labels   fl           lq g 
c   finite set constraints assignment must satisfy 

sentence   w  w w       wn   string length n  word wi  
sentence s  must keep track p different roles  or variables   role variable
takes role values form  l  m   l   l   fnil             ng  role values
denoted examples label modifiee  parsing  label l indicates different
syntactic function  value role value  l  m   assigned particular
role wi  specifies position word wi modifying takes
function specified label  l  e g   subj   indicates word label
subject modifies third word sentence   sentence said
generated grammar g exists assignment maps role value
n p roles constraint set c  described next paragraph 
satisfied 
constraint set logical formula form   x    x          xa  and p  p        pm   
xi ranges role values roles word s 
subformula pi c must form   if antecedent consequent   antecedent
consequent predicates predicates joined logical connectives 
basic components used express constraints 

variables  x    x         xa  a      maruyama      a   
constants  elements subsets   l   r   fnil               ng  n corresponds
number words sentence 

functions 
 pos x  returns position word role value x 
 rid x  returns role id role value x 
 lab x  returns label role value x 
 mod x  returns position modifiee role value x 
 cat y  returns category  i e   element   word position y 
predicates            
logical connectives  and  or  not 
subformula pi called unary constraint contains one variable binary constraint contains two  cdg grammar two associated parameters  degree
arity  degree grammar g number roles  arity grammar  a 
corresponds maximum number variables subformulas c  
consider example grammar  g    defined using following four tuple 
h    fdet  noun  verbg  r    fgovernorg  l    fdet  root  subjg  c   see constraints
figure   i  g  degree one arity two  illustrate process parsing
   note     nil     nil false  nil integer  muse networks  relate position
intervals using         

   

fimuse csp  extension constraint satisfaction problem

constraint satisfaction  figure   shows steps parsing sentence dog
eats  simplify presentation example  grammar uses single role 
governor role  denoted g constraint network figure    governor
role indicates function word fills sentence governed head word 
word called head phrase forms basis phrase  e g   verb
head sentence   useful grammars  would include several needs roles
 e g  need   need   make certain head word constituents needs
complete  e g   singular count noun needs determiner complete noun phrase  
determine whether sentence  dog eats  generated grammar  cdg
parser must able assign least one role value n p roles satisfies
grammar constraints  n     sentence length  p     number roles  
values role selected finite set l  fnil         g  cdg parsing
viewed constraint satisfaction problem finite domain  therefore  constraint
satisfaction used determine possible parses sentence 
initially  word  possible role values assigned governor role 
assume word must either modify another word  other itself  modify
word  m nil   nothing gained cdg word modify itself  next unary
constraints applied role values constraint network  role value
incompatible unary constraint satisfies antecedent 
consequent  notice figure   role values associated governor role
first word  the  satisfy antecedent first unary constraint  det nil  subjnil  subj    subj    root nil  root    root   satisfy consequent 
incompatible constraint  role value violates unary constraint  node
consistency eliminates role values role never participate
parse sentence  unary constraints applied top constraint
network figure    second network produced 
next  binary constraints applied  binary constraints determine pairs role
values legally coexist  keep track pairs role values  arcs constructed connecting role roles network  arc associated arc matrix 
whose row column indices role values associated two roles connects 
entries arc matrix either    indicating two role values indexing
entry compatible     indicating role values cannot simultaneously exist   initially  entries matrix set    indicating pair role values
indexing entry initially compatible  because constraints applied  
example  single binary constraint  shown figure    applied pairs
role values indexing entries matrices  example  x det  
y root nil eats  consequent binary constraint fails  hence  role values
incompatible  indicated replacing entry     
following binary constraints  roles constraint network still contain
role values incompatible parse sentence  role values
supported binary constraints eliminated achieving arc consistency 
example  det   supported remaining role value eats thus
deleted role 
arc consistency  example sentence single parse one
value per role sentence  parse sentence consists assignment role values
   

fihelzerman   harper


det
 

dog

eats

noun
 

verb
 

g

g
 detnil  det   det  
subjnil  subj   subj  
rootnil  root   root  

g

 detnil  det   det  
subjnil  subj   subj  
rootnil  root   root  

 detnil  det   det  
subjnil  subj   subj  
rootnil  root   root  

    if     cat  pos x   det 
    if     cat  pos x   noun 
 and     lab x  det 
 and     lab x  subj 
    pos x   mod x    
    pos x   mod x    

apply unary constraints
enforce node consistency 

    if     cat  pos x   verb 
 and     lab x  root 
    mod x  nil   

det
 

dog

eats

noun
 

verb
 

g

g

g
 subj  

 det   det  

 rootnil 
rootnil

subj 
det 

 

det 

 

subj 

 

rootnil
det 

 

det 

 

 if  and     lab x  det 
    mod x   pos y   
    cat  pos y   noun  

apply binary constraints 


det
 

dog

eats

noun
 

g

verb
 

g

g
 subj  

 det   det  

 rootnil 
rootnil

subj 
det 

 

det 

 

subj 

 

rootnil
det 

 

det 

 

enforce arc consistency 


det
 

dog

eats

noun
 

verb
 

g

g

 det  

 subj  

g
 rootnil 

figure    using constraints parse sentence  dog eats 
   

fimuse csp  extension constraint satisfaction problem

roles unary binary constraints satisfied assignment 
general  one parse sentence  hence  one
assignment values roles sentence  note assignment example
sentence is 

pos word cat governor role s value
  det
det  
  dog noun
subj  
  eats verb
root nil
one possible sentence part speech words
known advance  parsing problem cast csp  however 
ambiguity present written spoken sentences handled uniformly requires use
muse csp 

    processing lexically ambiguous sentences cdg
one shortcoming maruyama s constraint based parser requires word
single part speech  however  many words english language one
lexical category  assumption captured way maruyama writes constraints
involving category information  category determined based position
word sentence  however  even simple example  word dog could
either noun verb prior propagation syntactic constraints  since parsing
used lexically disambiguate sentence  ideally  parsing algorithm
require part speech words known prior parsing 
lexically ambiguous words easily accommodated creating csp
possible combination lexical categories  however  would combinatorially explosive 
contrast  using muse csp  create separate word node legal part
speech word  sharing words ambiguous across segments  since
position uniquely define category word  must allow category information
accessed role value rather position word sentence
 i e   use  cat x  rather  cat  pos x     associate category information
role value  could instead create role values lexical category word
store values single word node  however  representation
convenient muse csp representation problem  lexically augmented
csp  one role per word  this usually case   role values
associated one lexical category one role cannot support role values associated
another lexical category another role word  additional constraints
must propagated enforce requirement  muse csp representation
suffer problem  using separate node part speech  muse csp
directly represents independence alternative lexical categories given word 
space requirements arc matrices muse representation lower
lexicalized csp arc roles different lexical categories
word muse representation  note muse arc consistency equivalent
performing arc consistency lexically augmented csp  after additional constraints
   

fihelzerman   harper

propagated    importantly  muse csp represent lattices cannot
combined single csp 
technique creating separate nodes different instances word
used handle feature analysis  like number person  parsing  harper   helzerman 
    b   since words multiple feature values  often ecient create
single node set feature values  apply syntactic constraints  split node
set nodes single feature value prior applying constraints pertaining
feature type  node splitting used support use context specific
constraints  harper   helzerman      b  

    lattice example

much motivation extending csp comes work spoken language parsing
 harper   helzerman      a  harper  jamieson  zoltowski    helzerman        zoltowski 
harper  jamieson    helzerman         output hidden markov model based
speech recognizer thought lattice word candidates  unfortunately 
lattice contains many word candidates never appear sentence covering
duration speech utterance  converting lattice word graph  many word
candidates lattice eliminated  figure   depicts word graph constructed
simple lattice  notice word tour eliminated word graph
constructed  order accommodate words occur time intervals may
overlap  word s position lattice represented tuple  b  e 
b   e  positional relations defined constraints easily modified operate
tuples  harper   helzerman      a  
construction  word graph often contains spurious sentence hypotheses
pruned using variety constraints  e g   syntactic  semantic  etc   
apply constraints individual sentences rule ungrammatical  however 
individually processing sentence hypothesis inecient since many high degree
similarity  spoken language parsing problem structured muse csp problem 
constraints used parse individual sentences would applied word graph
sentence hypotheses  eliminating consideration many hypotheses
ungrammatical 
developed muse csp constraint based parser  parsec  harper   helzerman      a      b  harper et al         zoltowski et al          capable parsing
word graphs containing multiple sentences produced speech recognition module 
developed syntactic semantic constraints parsing single sentences 
applied word graph  eliminate hypotheses syntactically semantically
incorrect  muse csp used parser thought parse forest
pruned using constraints  applying constraints wide variety knowledge
sources  parser prunes composite structure many role values associated
role  well word nodes remaining role values  several experiments
 harper et al         zoltowski et al         considered effective syntactic
   simple demonstration  consider merging nodes     figure   single node
value e f keep track fact type      respectively  circumstances 
csp arc consistency give results muse csp arc consistency  even though c appear
solutions  eliminated  note example uses one role per node 

   

fimuse csp  extension constraint satisfaction problem

tour


wreck
hard


 



nice

beach


recognizes

 

 

 

 

wreck



     

     

hard

start


     

 

     

speech

 

 



nice

     

     

 

beach
     


     

end

recognizes
     

speech
     

figure    multiple sentence hypotheses parsed simultaneously applying constraints word graph rather individual sentences extracted
lattice 
semantic constraints pruning word nodes appear sentence hypothesis 
work speech processing  muse arc consistency algorithm effective
pruning role values composite structure never appear parse
sentence  i e   individual csp   constraints usually tight enough muse
arc consistency eliminates role values participate least one parse
represented sentences 
muse csp useful way process multiple sentences arc consistency
algorithm effective eliminating role values cannot appear sentence parses 
several factors contribute effectiveness arc consistency algorithm
problem  first  syntactic constraints fairly tight constraints  second  role
values contain segmental information constrain problem  consider word
graph figure    value s       associated role marked n word
cannot support values role marked g word dogs position       
legal segment involving position        figure  mark
entries value associated one role segmentally incompatible values
another n  entries equivalent    third  many times constraints
create symmetric dependencies words sentence  example  one constraint
might indicate verb needs subject left  another subject must
governed verb right 

    demonstration utility muse csp parsing

demonstrate utility muse csp simultaneously parsing multiple csp instances 
consider problem determining strings length  n consisting a s  b s  c s
   

fihelzerman   harper

obj      obj     
s     

n

n

s     

 

 

 obj      
obj      

 rootnil 

g

start

n

g

n

n  npnil 

g
dogs
     

 s      
s      

end

 blanknil 
 subj      
subj      
subj      


     


     
 obj      
obj      

g

n  np      
np      
dog
     

obj      obj     
s     

 

 

s     

n

n

figure    parsing word graphs  values assigned roles contain segmental
information make incompatible values associated
roles  example  s       cannot support values associated
g n roles word dogs 
language bn cn   value n      problem represented
single muse csp problem shown figure    the roles role values depicted
simplify figure   devised constraints language  see figure    
eliminate role values sentences language well ungrammatical
role values sentence language  constraints applied followed
muse arc consistency lattice figure   length divisible three 
grammatical sentence remain single parse  lattices containing
sentences lengths divisible three  role values eliminated
muse arc consistency  there grammatical sentence   hence  search
required extract parse one  n     case figure    parse appears
figure     single parse result regardless n chosen  note modifiees
role values parse used ensure a  corresponding
c  b  corresponding a  c  corresponding b  figure
   examines time needed extract parse sentences language bn cn
muse csps representing strings length  n    n    containing a  b  c 
time perform muse ac   extract solution compared time extract
solution without preprocessing  time perform muse ac   extract
parse stable sentence length grows  time extract parse grows quickly
sentence lengths greater    muse arc consistency used 
previous example involves grammar one parse single
sentence lattice  however  simple matter provide similar demonstrations
   

fimuse csp  extension constraint satisfaction problem

start



















     

     

     

     

     

     

     

     

      

b

b

b

b

b

b

b

b

b

     

     

     

     

     

     

     

     

      

c

c

c

c

c

c

     

     

     

     

     

     

c

c

c

     

     

      

end

figure    single muse csp simultaneously test possible orderings a s  b s 
c s membership language anbncn   n     

 

  fa  b  cg
  fgovernorg
l    fa  b  cg
c    see below 
r 

    unary constraints
 if  and   
  
 and   
  

 cat
 rid
 lab
 mod

x 
x 
x 
x 

a 
governor  
a 
 pos x    

 if  and   
  
 and   
  

 cat
 rid
 lab
 mod

x 
x 
x 
x 

c 
governor  
c 
 pos x    

 if  and   
  
 and   
  

 cat
 rid
 lab
 mod

x 
x 
x 
x 

b 
governor  
b 
 pos x    

    binary constraints
 if  and     lab x  a 
 or     lab y  b 
    lab y  c   
    pos x   pos y   

 if  and     lab x  b 
    lab y  c  
    pos x   pos y   

 if  and   
  
  
    mod

 lab x 
 lab y 
 pos x 
x   mod

a 
a 
 pos y   
y   

 if  and   
  
  
    lab

 if  and   
  
  
    mod

 lab x 
 lab y 
 pos x 
x   mod

b 
b 
 pos y   
y   

 if  and     lab x  b 
    mod x   pos y  
    rid y  governor  
    lab y  a  

 if  and   
  
  
    mod

 lab x 
 lab y 
 pos x 
x   mod

c 
c 
 pos y   
y   

 if  and   
  
  
    lab

 lab x  a 
 mod x   pos y  
 rid y  governor  
y  c  

 lab x  c 
 mod x   pos y  
 rid y  governor  
y  b  

figure     g    h   r   l   c i accepts language bn cn   n   
   

fihelzerman   harper

pos
     
     
     
     
     
     
     
     
      

cat governor role s value



b
b
b
c
c
c

a       
a      
a      
b      
b      
b      
c      
c      
c      

figure     single parse remaining network depicted figure   applying
constraints g  enforcing muse arc consistency 

    

cpu time seconds

    

extract without muse ac 
    

    

   

extract plus muse ac 
 
 

 

 

 

  

  
  
lattice length

  

  

  

  

figure     graph depicts time extract parse language bn cn
muse csp representing sentences length  n  n varies  
   time extract parse without muse arc consistency compared
time perform muse ac   extract parse 

   

fimuse csp  extension constraint satisfaction problem

 

  fa  b  cg
  fgovernorg
l    fw   w g
c    see below 
r 

    unary constraints
 if     lab x  w  
    pos x   mod y   

 if     lab x  w  
    pos x   mod y   
    binary constraints

 if  and     lab x  w  
    lab y  w   
    pos x   pos y   
 if  and   
  
  
    mod

 lab x 
 lab y 
 pos x 
x   mod

w  
w  
 pos y   
y   

 if  and   
  
 and   
  

 lab
 mod
 lab
 cat

w  
 pos y   
w  
 cat y    

x 
x 
y 
x 

 if  and     lab x  w  
    lab y  w   
    mod x   mod y   
 if  and     lab x  w  
    lab y  w  
    pos x   pos y   
    mod x   mod y   
 if  and     lab x  w  
    mod x   pos y   
    lab y  w   

figure     g    h    r   l   c i accepts language ww 
complex cases  example  constraint grammar shown figure   
parse possible sentences given length language ww  w
fa  b  cg   consider muse csp figure     the roles role values
depicted simplify figure   applying constraints performing muse arc
consistency muse csp  precisely    strings ww 
parses compactly represented constraint network  constraints plus muse
arc consistency eliminate every value cannot appear parse  lattices containing
odd length sentences  role values remain muse arc consistency  figure    shows
time needed extract parses sentences language ww
muse csps vary length w      time perform muse ac  
extract parses grows slowly sentence length increases number parses
increases sentence length  however  grows slowly time extract
parses muse arc consistency used 
similar results obtained grammars used parse word graphs constructed spoken sentences resource management atis domains  harper
et al         zoltowski et al         harper   helzerman      a  

   muse csp arc consistency algorithm
section  introduce algorithm  muse ac    achieve muse csp arc consistency  algorithm builds upon ac   algorithm  mohr   henderson        
present algorithm first comparison purposes 
   

fihelzerman   harper

start

















     

     

     

     

     

     

     

     

b

b

b

b

b

b

b

b

     

     

     

     

     

     

     

     

c

c

c

c

c

c

     

     

     

     

     

     

c

c

     

     

end

figure     single muse csp simultaneously test possible orderings a s  b s 
c s membership language ww jwj      

    

cpu time seconds

    

    
extract without muse ac 
    

    

   
extract plus muse ac 
 
 

 

 

 
  
lattice length

  

  

  

figure     graph depicts time extract parses language ww
muse csp representing sentences length      w   fa  b  cg  
time extract parses without muse arc consistency compared
time perform muse ac   extract parses 

   

fimuse csp  extension constraint satisfaction problem

notation

meaning

ordered pair nodes 
node pairs  i  j     i  j     e    j  i    e  
e
ordered pair node label   li  
 i  a 
faja   l  i  a  permitted constraints  i e   admissible g
li
r   i  a  j  b      indicates admissibility   li b   lj given
r   i  a  j  b 
binary constraints 
counter  i  j    a  number labels lj compatible   li  
 j  b     i  a  means   li b   lj simultaneously
 i  a 
admissible  implies supports b 
 i  a      indicates label admissible  and
 i  a 
already eliminated from  node i 
queue arc support deleted 
list
 i  j  

figure     data structures notation arc consistency algorithm  ac   

    csp arc consistency  ac  
ac   builds maintains several data structures  described figure     allow
eciently achieve arc consistency csp  note modified notation
slightly eliminate subscripts  which become quite cumbersome path consistency
algorithm   figure    shows code initializing data structures  figure   
contains algorithm eliminating inconsistent labels domains  algorithm
requires  el   time  e number constraint arcs  l domain size  mohr
  henderson        
ac    label   li compatible b   lj   supports b  and vice
versa   keep track much support label has  number labels lj
compatible li counted total stored counter  i  j    a 
algorithm figure     counter  i  j    a  zero  removed li
 because cannot appear solution   ordered pair  i  a  placed list 
m i  a  set    to avoid removing element li once   algorithm
must keep track labels label supports using s i  a   set arc
label pairs  example  s i  a    f j  b    j  c g means li supports b c lj  
ever removed li   b c loose support 
preprocessing step figure     algorithm figure    loops list
becomes empty  point csp arc consistent   i  a  popped list
procedure  element  j  b  s i  a   counter  j  i   b  decremented 
counter  j  i   b  becomes zero  b would removed lj    j  b  placed list 
m j  b  set   
   

fihelzerman   harper

   list     
     n
  
  li f
  
 i  a      
  
 i  a        g
    i  j     e
  
  li f
  
total      
  
b   lj
   
r   i  a  j  b  f
   
total    total   
   
 j  b      j  b    f i  a g  g
   
total     f
   
li    li   fag 
   
list    list   f i  a g 
   
 i  a        g
   
counter  i  j    a     total  g

figure     initialization data structures ac   

   list    f
  
pop  i  a  list 
  
 j  b    s i  a  f
  
counter  j  i   b     counter  j  i   b      
  
counter  j  i   b         j  b      f
  
lj    lj   fbg 
  
list    list   f j  b g 
  
 j  b        g g g

figure     eliminating inconsistent labels domains ac   

   

fimuse csp  extension constraint satisfaction problem

next  describe muse arc consistency algorithm muse csp  called muse
ac    purposely keep notation presentation muse ac   close possible
ac   reader benefit similarity two algorithms 

    muse ac  

muse arc consistency enforced removing labels li violate conditions definition    muse ac   builds maintains several data structures  described
figure     allow eciently perform operation  many data structures
borrowed ac    others exploit dag representation muse csp
determine values incompatible segments  figure    shows
code initializing data structures  figures       contain algorithm
eliminating inconsistent labels domains 
muse ac   ac    label node compatible label b node j  
supports b  keep track much support label has  number labels lj
compatible li counted  total stored counter  i  j    a  
csp arc consistency  counter  i  j    a  zero  would immediately removed
li  would mean could never appear solution  however  muse
arc consistency  may case  even though participate
solution segments contain j   could another segment
would perfectly legal  label cannot become globally inadmissible
incompatible every segment  hence  muse csp  counter  i  j    a  zero 
algorithm simply places   i  j    a  list records fact setting m  i  j    a    
placing   i  j    a  list  algorithm indicating segments containing
j support label a 
muse ac   must keep track labels j label li supports
using s  i  j    a   set node label pairs  example  s  i  j    a    f j  b    j  c g means
li supports b c lj   ever invalid li   b c loose
support 
dag  muse ac   able use properties dag identify
local  and hence eciently computable  conditions labels become globally
inadmissible  segments defined paths muse csp start end 
value associated variable supported variables precede
follow it  way value used segment 
deleted arc consistency algorithm  addition  value variable s domain
supported constraints values associated second variable  second
variable preceded followed variables values supporting value 
solution involves path variables muse dag  value cannot
supported segment involving two variables  two ideas provide basis
remaining data structures used muse ac   
consider figure     shows nodes adjacent node dag 
every segment dag contains node represented directed path
dag going node i  either node j node k must every segment containing
i  hence  label remain li  must compatible least one label
either lj lk   also  either n must contained every segment containing
   

fihelzerman   harper

notation

meaning

 i  j  

ordered pair nodes 
node pairs  i  j   exists path directed edges g
j    i  j     e    j  i    e  
ordered pair node label   li  

e

 i  a 
  i  j    a 

ordered pair node pair  i  j   label   li  
faja   l  i  a  permitted constraints  i e   admissible g

li

   i  a  j  b 

r

counter  i  j    a 
s  i  j    a 
m  i  j    a 
list

g

next edgei
prev edgei
local prev support i  a 
local next support i  a 
prev support  i  j    a 
next support  i  j    a 

   i  a  j  b      indicates admissibility   li b   lj given
binary constraints 
number labels lj compatible   li  
 j  b      i  j    a  means   li b   lj simultaneously
admissible  implies supports b 
m  i  j    a      indicates label admissible  and
already eliminated from  segments containing j  
queue arc support deleted 
g set node pairs  i  j   exists directed
edge j  
next edgei contains node pairs  i  j   exists
directed edge  i  j     g  contains  i  end  last node
segment 
prev edgei contains node pairs  j  i  exists
directed edge  j  i    g  contains  start  i  first node
segment 
set elements  i  j    j  i    prev edgei   j    start 
must compatible least one j  s labels 
local prev support i  a  becomes empty  longer admissible 
set elements  i  j    i  j     next edgei   j    end 
must compatible least one j  s labels 
local next support i  a  becomes empty  longer admissible 
 i  k    prev support  i  j    a  implies  k  j     prev edgej  
k    start    li compatible least one j  s
one k s labels  prev support  i  j    a  becomes empty 
longer admissible segments containing j  
 i  k    next support  i  j    a  implies  j  k    next edgej  
k    end    li compatible least one j  s
one k s labels  next support  i  j    a  becomes empty 
longer admissible segments containing j  
r

figure     data structures notation muse ac   

   

fimuse csp  extension constraint satisfaction problem

n

j




k
     a     

localprevsupport i a      i n   i m  
localnextsupport i a      i j  

figure     local prev support local next support example dag  sets indicate label allowed every segment contains n  m  j  
disallowed every segment contains k  solid directed lines
members g  solid undirected lines represent members e  

i  label remain li  must compatible least one label either
ln lm  
order track dependency  two sets maintained label node i 
local next support i  a  local prev support i  a   local next support i  a  set
ordered node pairs  i  j    i  j     next edgei    i  j     e   least one
label b   lj compatible a  local prev support i  a  set ordered pairs
 i  j    j  i    prev edgei    i  j     e   least one label b   lj
compatible a  dummy ordered pairs created handle cases node
beginning end network   start  i    prev edgei    i  start  added
local prev support i  a    i  end    next edgei    i  end  added local nextsupport i  a   prevent label ruled nodes precede
follow dag  whenever one i s adjacent nodes  j   longer labels b
domain compatible a   i  j   removed local prevsupport i  a  local next support i  a   depending whether edge j
j   respectively  either local prev support i  a  local next support i  a 
becomes empty  longer part muse arc consistent instance 
eliminated li   figure     label admissible segments containing
j   segments containing k  constraints 
labels j become inconsistent i   i  j   would eliminated local nextsupport a  i   leaving empty set  case  would longer supported

segment 
algorithm utilize similar conditions nodes directly connected
next edgei prev edgei   consider figure     suppose label node
compatible label lj   incompatible labels lx ly  
reasonable eliminate segments containing j   segments
would include either node x   determine whether label admissible
set segments containing j   calculate prev support  i  j    a  nextsupport  i  j    a  sets  next support  i  j    a  includes  i  k  arcs support
   

fihelzerman   harper

z
     a     

x
j

w



figure     next edgej   f j  x    j   g  counter  i  x   a       counter  i     a      
inadmissible every segment containing j   solid directed lines members g  solid undirected lines represent members
e  
given directed edge j k   i  j   supports a  prev support  i  j    a 
includes  i  k  arcs support given directed edge k
j    i  j   supports a  note prev support  i  j    a  contain ordered pair
 i  j    i  j     prev edgej   next support  i  j    a  contain ordered pair  i  j  
 j  i    next edgej   elements included edge nodes
j sucient allow j  s labels support segment containing j   dummy
ordered pairs created handle cases node beginning end
network   start  j     prev edgej    i  start  added prev support  i  j    a  
 j  end    next edgej    i  end  added next support  i  j    a   prevent
label ruled nodes precede follow dag 
figure    shows prev support  next support  local next support  local prevsupport sets initialization algorithm creates simple example dag 
initialization step  sets contain node pairs allowed based connectivity g  later  consistency step node pairs support
associated label eliminated set 
illustrate data structures used second step muse ac   shown
figure     consider happens initially          a    list muse csp depicted
figure              a  placed list indicate label l  supported
labels associated node    value popped list  necessary
    x    s         a  decrement counter         x  one  counter         x 
becomes             x  already placed list  added future
processing  done  necessary remove          a  s uence muse
dag  handle this  examine two sets prev support         a    f              g
   

fimuse csp  extension constraint satisfaction problem

  
  
  
  
  
  
  
  
  
   
   
   
   
   
   
   
   
   
   
   
   
   
   

list     
e    f i  j  j      i  j        j   i  j   n g 
 i  j    e
  li f
s  i  j    a      
m  i  j    a       
local prev support i  a       local next support i  a      
prev support  i  j    a       next support  i  j    a       g
 i  j    e
  li f

total      

b   lj
r   i  a  j  b  f

total    total   
s  j  i   b     s  j  i   b    f i  a g  g
total   f
list    list   f  i  j    a g 
m  i  j    a        g
counter  i  j    a     total 
prev support  i  j    a     f i  x j i  x    e    x  j     prev edgej g
  f i  j  j i  j     prev edgej g
  f i  start j start  j     prev edgej g 
next support  i  j    a     f i  x j i  x    e    j  x    next edgej g
  f i  j  j j  i    next edgej g
  f i  end j j  end    next edgej g 
local prev support i  a     f i  x j i  x    e    x  i    prev edgei g
  f i  start j start  i    prev edgei g 
local next support i  a     f i  x j i  x    e    i  x    next edgei g
  f i  end j i  end    next edgei g  g
 c 

 

start

 

 

 a b 

end
 d 

prev support        a    f      g
prev support        a    f              g
prev support        b    f      g
prev support        b    f              g
prev support        c    f    start g
prev support        c    f              g
prev support        d    f    start g
prev support        d    f      g
local prev support   a    f    start g
local prev support   b    f    start g
local prev support   c    f      g
local prev support   d    f              g

next support        a    f      g
next support        a    f    end g
next support        b    f      g
next support        b    f    end g
next support        c    f              g
next support        c    f    end g
next support        d    f              g
next support        d    f      g
local next support   a    f              g
local next support   b    f              g
local next support   c    f      g
local next support   d    f    end g

figure     initialization data structures muse ac   along simple example 
   

fihelzerman   harper

   list    f
  
pop   i  j    a  list 
  
 j  b    s  i  j    a  f
  
counter  j  i   b     counter  j  i   b      
  
counter  j  i   b        m  j  i   b      f
  
list    list   f  j  i   b g 
  
m  j  i   b        g g
  
update support sets   i  j    a     see figure     g

figure     eliminating inconsistent labels domains muse ac   
update support sets    i  j    a   f
    i  x    prev support  i  j    a    x    j   x    start f
  
prev support  i  j    a     prev support  i  j    a    f i  x g  
  
next support  i  x   a     next support  i  x   a    f i  j  g 
  
next support  i  x   a      m  i  x   a      f
  
list    list   f  i  x   a g 
  
m  i  x   a        g g
    i  x    next support  i  j    a    x    j   x    end f
  
next support  i  j    a     next support  i  j    a    f i  x g 
  
prev support  i  x   a     prev support  i  x   a    f i  j  g 
   
prev support  i  x   a      m  i  x   a      f
   
list    list   f  i  x   a g 
   
m  i  x   a        g g
     j  i    prev edgei
    local prev support i  a     local prev support i  a    f i  j  g 
    local prev support i  a    f
    li    li   fag 
     i  x    local next support i  a    x    j   x    end f
   
local next support i  a     local next support i  a    f i  x g 
   
m  i  x   a      f
   
list    list   f  i  x   a g 
   
m  i  x   a        g g g
     i  j     next edgei
    local next support i  a     local next support i  a    f i  j  g 
    local next support i  a    f
    li    li   fag 
     i  x    local prev support i  a    x    j   x    start f
   
local prev support i  a     local prev support i  a    f i  x g 
   
m  i  x   a      f
   
list    list   f  i  x   a g 
   
m  i  x   a        g g g g

figure     function update support sets   i  j    a   muse ac   
   

fimuse csp  extension constraint satisfaction problem

next support         a    f    end g  note value     end  next support         a 
value        prev support         a   require action
dummy values  however  value        prev support         a  indicates       
member next support         a   since admissible               
removed next support         a   leaving empty set  note nextsupport         a  empty  assuming m         a                a  added list
processing  next         removed local next support    a   leaving set
f      g  next iteration loop          a  popped list 
prev support         a  next support         a  processed  next support         a   
prev support         a  contains dummy  requiring action  finally        
removed local next support    a   set becomes empty  longer compatible segment containing node   eliminated consideration
possible label node    eliminated node    necessary remove
support   l  labels nodes precede node    nodes x
    x    local prev support    a   since local prev support    a    f    start g 
start dummy node  work done 
contrast  consider happens initially          a    list muse csp
figure     case  prev support         a  contains        requires additional
work  whereas  next support         a  contains         indicating        must removed
prev support         a  s set  removal  prev support         a  non empty 
segment containing nodes     still supports label l   reason
two cases provide different results constraint arc nodes    
contained every segment  whereas  constraint arc nodes     found
one them 

    running time space complexity muse ac  
worst case running time routine initialize muse ac   data structures
 in figure     o n  l    n  l   n number nodes muse csp l
number labels  given number  i  j   elements e o n   
domain size o l   size counter arrays o n  l   determine
number supporters given arc label pair requires o l  work  hence  initializing
counter arrays requires o n  l   time  however  o n  l  prev support
next support sets  prev support  i  j    a  next support  i  j    a  requires
o n  time compute  time calculate prev support next support sets
o n  l   finally  time needed calculate local next support local prevsupport sets o n  l  o nl  sets o n  elements per set 
worst case running time algorithm prunes labels muse
arc consistent  in figures        operates o n  l    n  l  time  clearly
counter array contains o n  l  entries  a similar argument made array 
keep track algorithm  counter  i  j    a  l magnitude 
never become negative  maximum running time line   figure   
 given elements appear list m  o n  l   
o n  l  next support prev support lists  o n  size  maximum
running time required lines     figure    o n  l   finally  since o nl 
   

fihelzerman   harper

approach
csps
muse csp

nodes
degree
number
number
per path node splitting constraint networks nodes

n
n

kn

k
k

 

n
kn

asymptotic
time

kn n  l 
 
 kn  l     kn   l

table    comparison space time complexity muse arc consistency
muse csp arc consistency multiple csps representing node splitting
problem  e g   lexical ambiguity parsing  
local prev support local next support sets eliminate o n  elements 
maximum running time lines       figure    o n  l   hence  maximum
running time muse csp arc consistency algorithm o n  l    n  l  
space complexity muse csp ac   o n  l    n  l  arrays
counter contain o n  l  elements  o n  l  sets  containing o l 
items  o n  l  prev support next support sets  containing o n  items  o nl 
local next support local prev support sets  containing o n  items 
comparison  worst case running time space complexity csp arc consistency o n  l    assuming n  constraint arcs  note applications
l   n  worst case running times algorithms order  this
true parsing spoken language muse csp   also  representable planar
dag  in terms prev edge next edge  e   running times two
algorithms order average number values prev support
next support would constant  hand  compare muse csp
use multiple csps problems k alternative variables particular
variable csp  muse csp ac   asymptotically attractive  shown
table   

    correctness muse ac  

next prove correctness muse ac   
theorem   label eliminated li muse ac   label
unsupported arcs  i  x  every segment 

proof 
   must show label eliminated  inadmissible every segment 
label eliminated domain muse ac    see lines       figure    
local prev support set local next support set becomes empty
 see lines       figure      either case  label eliminated
make muse csp instance muse arc consistent  prove label s
local support sets become empty  label cannot participate muse arc
consistent instance muse csp  proven local next support  localprev support follows symmetry   observe   li   unsupported
   

fimuse csp  extension constraint satisfaction problem

nodes immediately follow dag  cannot participate
muse arc consistent instance muse csp  line    figure      i  j  
removed local next support i  a  set   i  j    a  must popped
list  removal  i  j   local next support i  a  indicates that 
segment containing j     li inadmissible  remains shown
  i  j    a  put list   li unsupported every segment contains
j   proven induction number iterations loop
figure    
base case  initialization routine puts   i  j    a  list   li incompatible every label lj  line    figure      therefore    li unsupported
segments containing j  
induction step  assume start kth iteration loop
  x     c  ever put list indicate c   lx inadmissible
every segment contains x   remains show kth
iteration    i  j    a  put list    li unsupported every segment
contains j   several ways new   i  j    a  put
list 
 a  labels lj compatible   li eliminated 
item could placed list either initialization  see line   
figure     previous iteration loop  see line   figure
      csp ac   algorithm  obvious that  case    li
inadmissible every segment containing j  
 b  prev support  i  j    a     see line    figure     indicating   li
incompatible nodes k  k  j     prev edgej   way
  i  j    a  placed list reason  at line     tuples
form   i  k   a   where  k  j     prev edgej   already put list 
induction hypothesis    i  k   a  items placed list
  li inadmissible segments containing k dag 
supported node immediately precedes j dag 
unsupported every segment contains j   therefore  correct
put   i  j    a  list 
 c  next support  i  j    a     see line   figure     indicating   li
incompatible nodes k  j  k    next edgej   way   i  j    a 
placed list  at line    reason tuples form
  i  k   a   where  j  k    next edgej   already put list  induction
hypothesis    i  k   a  items placed list   li inadmissible segments containing k dag  supported
node immediately follows j dag  inadmissible
every segment contains j   therefore  correct put   i  j    a  list 
 d  local next support i  a     see line    figure     indicating   li
incompatible nodes k  i  k    next edgei   way
  i  j    a  placed list  at line     reason node
follows dag supports a  pairs  i  k  legally removed
   

fihelzerman   harper





 

   

 

   

c

   

b

   

local prev support i a      i j      
local next support i a      i k      

j



k

 b     

prev support  i j  a  nonempty
 c     

 a     
c

prev support  i k  a      i k      

   

next support  i k  a  nonempty

 

b

   

next support  i j  a      i j      

 

figure       li muse ac    must preceded node j followed
node k support a 
local next support i  a  previous iterations 
segment containing supports a  follows segment containing
j supports label 
 e  local prev support i  a     see line    figure     indicating   li
incompatible nodes k  k  i    prev edgei   way
  i  j    a  placed list  at line     reason node
precedes dag supports a  pairs  i  k  legally
removed local prev support i  a  previous iterations 
segment containing supports a  follows segment containing
j supports label 
beginning  k     th iteration loop  every   x     c  list
implies c supported segment contains x   therefore 
induction  true iterations loop figure     hence 
label s local support sets become empty  label cannot participate muse arc
consistent instance muse csp 
   must show eliminated li muse arc consistency
algorithm  must muse arc consistent  muse arc consistent 
must exist least one path start end goes node
nodes n path contain least one label compatible
  li   deleted muse ac    local next support i  a    
local prev support i  a       hence  must preceded followed least
one node supports   li   otherwise  would deleted  depicted
figure     know must node j precedes that 
start  must contain least one label b supports a  nextsupport  i  j    a  prev support  i  j    a  must non empty  similarly  must
node k follows that  end  must contain least one
label c supports a  next support  i  k   a  prev support  i  k   a  must
non empty 
   

fimuse csp  extension constraint satisfaction problem

show path dag  must show path beginning
start reaches nodes along path support   li  
path beginning reaches end nodes along
path support   li   show necessity path end
nodes along path support   li given remains muse ac   
necessity path start shown similar way 
base case    li muse ac    must exist least one node
follows i  say k    i  k   a  never placed list  hence 
r   i  a  k  c      least one c   lk next support  i  k   a  prevsupport  i  k   a  must non empty 
induction step  assume path n nodes follows supports
  li  none nodes end node  implies n
nodes contains least one label compatible next support  i  n   a 
prev support  i  n   a  must non empty n nodes 
next  show path length  n      must support   li   otherwise 
label would deleted muse ac    already noted
nth node path induction step  next support  i  n   a  must
non empty  hence  must exist least one node  say n    follows nth
node path length n supports   li   n  end node 
case  n  end  way  i  n   member
next support  i  n   a    i  n    a  placed list  hasn t 
r   i  a  n   l      least one l   ln next support  i  n    a  prevsupport  i  n    a  must non empty  case   i  n   would
removed next support  i  n   a   n would longer support   li  
hence    li muse ac    must path nodes end
node n end node  r   i  a  n  l      least one l   ln
next support  i  n   a  prev support  i  n   a  must non empty  hence
muse arc consistent 
 

 

theorem  may conclude muse ac   builds largest muse arc
consistent structure  muse arc consistency takes account segments 
single csp selected muse csp muse arc consistency enforced 
csp arc consistency could eliminate additional labels 

    profile muse ac  

given fact muse ac   operates composite data structure  benefits
using algorithm high payoff individually processing csps  section     
provided several examples payoff obvious  gain insight factors
uencing effectiveness muse csp  conducted experiment
randomly generate muse csp instances two different graph topologies  tree
topology characterized two parameters  branching factor  how many nodes follow
non leaf node tree  path length  how many nodes path
root node leaf node   lattice topology characteristic muse csp
   

fihelzerman   harper

produced hidden markov model based spoken language recognition system
constraint based parser  lattices characterized length
branching factor 
experiment  examined trees path length four branching
factor two three  lattices path length four branching factor
two three  initialized variable either     labels  randomly
generated constraints network  varying probability r   i  a  j  b     
         steps       probability    instances generated  lower
probability r   i  a  j  b       tighter constraints  note probability
constraint two nodes understood probability constraint
two nodes given constraint allowed them  example  nodes
level tree topology different segments  constraints
cannot occur them 
results experiment displayed figures        four
panels figure  four curves displayed  muse ac   appears curves
displaying average number labels remaining muse ac   applied instances
muse csp probability constraint varies  curves labeled solution
indicate average number labels remaining muse ac   used
solution  csp ac associated curves display number labels remain
least one segment segment extracted muse csp csp
arc consistency applied  unused indicates difference number labels
remain muse ac   number csp arc consistent least one
segment 
topologies  probability r   i  a  j  b      low  e g       high
 e g        muse ac   tracks performance arc consistency performed
individual instances either topology  however  topology impact range
low high probabilities true  constraints randomly generated 
muse ac   performed  tree topology fewer remaining values lattice
topology csp arc consistent  results suggest muse csp ac   may
effective topologies others  however  tree topology
randomly generated constraints values two variables independent
probabilities generated  case lattice  pair variables
set randomly generated constraints  shared paths lattice 
notice increasing number values domain seems impact
tree increasing branching factor  probably branching factor
increases  number independent nodes 
experiment show problem tightly constrained  muse ac  
effectively used eliminate values unsupported constraints  clearly 
case parsing problems presented section      small set syntactic
constraints effectively eliminates values never used parse sentence 
even lattice branching factor three arbitrarily long paths 
   

fimuse csp  extension constraint satisfaction problem

a  tree branching factor    path length      labels per variable     variables 

b  tree branching factor    path length      labels per variable     variables 
 

average number role values per role  

average number role values per role  

 

   
muse ac 
 

csp ac

   

solution

 

   

   
muse ac 
 

csp ac

   
solution
 

   
unused

unused
 
 

   

   

   

   
   
   
   
probability r  i a j b   

   

   

 
 

 

c  tree branching factor    path length      labels per variable     variables 

   

   

   

   

 

average number role values per role  

 

 
muse ac 
 

csp ac
 

 
solution
 

 

 

muse ac 
csp ac

 

solution

 

 

unused
 
 

   
   
   
   
probability r  i a j b   

d  tree branching factor    path length      labels per variable     variables 

 

average number role values per role  

   

   

   

   

   
   
   
   
probability r  i a j b   

unused
   

   

 
 

 

   

   

   

   
   
   
   
probability r  i a j b   

   

   

 

figure     simulation results trees path length    branching factor  
       labels per variable 

   

fihelzerman   harper

a  lattice branching factor    path length      labels per variable    variables 

b  lattice branching factor    path length      labels per variable     variables 

 

 
muse ac 

average number role values per role  

average number role values per role  

csp ac
muse ac 

   

 
solution
   

 

   
unused

 
 

   

   

   

   
   
   
   
probability r  i a j b   

   

   

 

solution

   

 

unused
   

 
 

 

c  lattice branching factor    path length      labels per variable    variables 

   

   

   

   
   
   
   
probability r  i a j b   

   

   

 

d  lattice branching factor    path length      labels per variable     variables 

 

 
muse ac 

muse ac 

average number role values per role  

average number role values per role  

csp ac

   

csp ac

 

 
solution
 

 

 

 
csp ac

 
solution
 

 

unused

 

unused
 
 

   

   

   

   
   
   
   
probability r  i a j b   

   

   

 
 

 

   

   

   

   
   
   
   
probability r  i a j b   

   

   

 

figure     simulation results lattices path length    branching factor  
       labels per variable 

   

fimuse csp  extension constraint satisfaction problem

local next support b  b       b  e  
local next support b  b       b  c    b  e  
local next support b  b       b  c  

next support  b  c   b       b  d  
next support  b  c   b       b  f  

c
 c  

start


 a  


 d  

b

end

 b   b   b  
 e  

 f  

e

f

figure     using muse arc consistency data structures guide backtracking search 

    extracting solutions muse csp muse ac  
solutions regular csp problems typically generated using backtracking  or fancier
search algorithms  assemble set labels  one node  consistently
admissible  extracting solutions muse csps done similar way 
desirable make modifications search algorithms take advantage
extra information contained muse ac   data structures 
consider example shown figure     figure presents simple muse csp 
suppose interested solutions segment highlighted  fa  b  c 
dg  suppose one solution segment  a  a  b  b  c 
c  d  d  wish find solution depth first search 
begin assigning a  a  however  domain b  addition desired
label b   contains labels b  b   valid segments 
initially  and naively  choose b  b continue depth first search  would
waste lot time backtracking  fortunately  enforcing muse arc consistency 
muse data structures contain useful information concerning segments
labels valid  case  backtracking algorithm check local next support b 
b   determine outgoing nodes b  compatible with  since  b  c 
element local next support b  b    smart search algorithm would choose b 
label b 
however  looking local support sets might enough  search
algorithm rejected b  label b  would go consider b   local nextsupport b  b   indicates b  valid label segments contain
c  fails tell us b  valid segment examining  despite
this  search algorithm still eliminate b  looking next support  b  c   b   
indicates b  compatible segments containing node f  clearly 
type information effectively guide search solution along certain
path  improved search strategies muse csps focus future research efforts 
   

fihelzerman   harper

   muse csp path consistency algorithm
section  introduce algorithm achieve muse csp path consistency  muse
pc    builds upon pc   algorithm  han   lee        

    muse pc  

muse path consistency enforced setting r   i  a  j  b  false violates
conditions definition    muse pc   builds maintains several data structures comparable data structures defined muse ac    described figure     allow
eciently perform operation  figure    shows code initializing data structures  figures       contain algorithm eliminating muse path inconsistent
binary constraints 
muse pc   must keep track labels lk support r   i  a  j  b   keep track
much path support r   i  a  j  b  has  number labels lk satisfy
r   i  a  k  c  r   k  c  j  b  counted using counter  i  j    k  a  b   additionally 
algorithm must keep track set s  i  j    k  a  b   contains members form
 k  c  r   i  a  k  c  r   k  c  j  b  supported r   i  a  j  b   r   i  a  j  b 
ever becomes false segment containing i  j   k  r   i  a  k  c  r   k  c  j  b 
loose support  muse pc   uses local next support  local prevsupport  prev support  next support sets similar muse ac   
muse pc   able use properties dag identify local  and hence
eciently computable  conditions binary constraints fail lack path
support  consider figure     shows nodes adjacent node j
dag  every segment dag contains node j represented
directed path dag going node node j   node must precede
follow nodes j r   i  a  j  b  hold  order track dependency  two sets
maintained   i  j    a  b  tuple  local prev support  i  j    a  b  local nextsupport  i  j    a  b   note distinguish local prev support  i  j    a  b  localprev support  j  i   b  a  separately keep track elements directly preceding
directly preceding j   distinguish local next support  i  j    a  b  localnext support  j  i   b  a   sets become empty   i  j   arc
longer support r   i  a  j  b   local prev support  i  j    a  b  set ordered node pairs
 i  x   x  i    prev edgei    i  x    e   least one label   lx
compatible r   i  a  j  b   local next support  i  j    a  b  set ordered
node pairs  i  x   i  x    next edgei    i  x    e   least one label
  lx compatible r   i  a  j  b   dummy ordered pairs created
handle cases node beginning end network   start  i    prevedgei    i  start  added local prev support  i  j    a  b    i  end    next edgei  
 i  end  added local next support  i  j    a  b  
algorithm utilize similar conditions nodes may directly connected j   consider figure     suppose r   i  a  j  b  compatible
label lk   incompatible labels lx ly   r   i  a  j  b 
r   j  b  i  a  false segments containing i  j   k segments would
include either node x   determine whether constraint admissible
set segments containing i  j   k  calculate prev support  i  j    k  a  b   prev   

fimuse csp  extension constraint satisfaction problem

notation

meaning
ordered pair nodes 

 i  j  

node pairs  i  j   exists path directed edges g
j    i  j     e    j  i    e  
ordered quadruple node pair  i  j    node k  labels
  li b   lj  

e

  i  j    k  a  b 

faja   l  i  a  permitted constraints  i e   admissible g

li

   i  a  j  b      indicates admissibility   li b   lj given
binary constraints 

   i  a  j  b 

r

r

counter  i  j    k  a  b 
s  i  j    k  a  b 
m  i  j    k  a  b 
list

g

next edgei
prev edgei
local prev support  i  j    a  b 
local next support  i  j    a  b 
prev support  i  j    k  a  b 
next support  i  j    k  a  b 

number labels lk compatible r   i  a  j  b  
 k  c      i  j    k  a  b  means c   lk compatible
r   i  a  j  b  
m  i  j    k  a  b      indicates r   i  a  j  b  false paths
including i  j   k 
queue path support deleted 
g set node pairs  i  j   exists directed
edge j  
next edgei contains node pairs  i  j   exists
directed edge  i  j     g  contains  i  end  last
node segment 
prev edgei contains node pairs  j  i  exists
directed edge  j  i    g  contains  start  i  first
node segment 
set elements  i  k   k  i    prev edgei   k    start 
r   i  a  j  b  must compatible one k  s labels 
local prev support  i  j    a  b  becomes empty  r   i  a  j  b  becomes false 
set elements  i  k   i  k    next edgei   k    end 
r   i  a  j  b  must compatible one k  s labels 
local next support  i  j    a  b  becomes empty  r   i  a  j  b  becomes false 
 i  x    prev support  i  j    k  a  b  implies  x  k    prev edgek  
x    start  r   i  a  j  b  compatible least one k s
one x s labels  prev support  i  j    k  a  b  becomes empty 
r   i  a  j  b  longer true segments containing i  j   k  
 i  x    next support  i  j    k  a  b  means  k  x    next edgek  
x    end  r   i  a  j  b  compatible least one k s
one x s labels  next support  i  j    k  a  b  becomes empty 
r   i  a  j  b  longer true segments containing i  j   k  

figure     data structures notation muse pc   

   

fihelzerman   harper

l

     a      n






p

r
j

q

     b     



localprevsupport  i j   a  b      i l    i m  
localprevsupport  j i   b  a      j p    j q  
localnextsupport  i j   a  b      i n    i o  
localnextsupport  j i   b  a      j r    j s  

figure     local prev support local next support path consistency example dag  solid directed lines members g  solid undirected
line represents  i  j    j  i  members e  
support  j  i   k  b  a   next support  i  j    k  a  b   next support  j  i   k  b  a  sets  nextsupport  i  j    k  a  b  includes  i  x  arcs support r   i  a  j  b  given
directed edge k x  r   i  a  j  b       r   i  a  k  c       r   k  c  j  b       nextsupport  j  i   k  b  a  defined similarly   prev support  i  j    k  a  b  includes  i  x  arcs
support r   i  a  j  b  given directed edge x k  r   i  a  j  b      
r   i  a  k  c       r   k  c  j  b       prev support  j  i   k  b  a  defined similarly  
note prev support  i  j    k  a  b  contain ordered pair  i  k   i  k    prevedgek    i  j    j  k    prev edgek   next support  i  j    k  a  b  contain ordered
pair  i  k   k  i    next edgek  i  j    k  j     next edgek   elements included edge nodes sucient allow support  dummy
ordered pairs created handle cases node beginning end
network   start  k    prev edgek    i  start  added prev support  i  j    k  a  b  
 k  end    next edgek    i  end  added next support  i  j    k  a  b  

    running time  space complexity  correctness muse pc  
worst case running time routine initialize muse pc   data structures  in
figure     o n  l    n  l    n number nodes muse csp l
number labels  given number  i  j   elements e o n    domain size
o l   o n  l   entries counter array determine number
supporters  requiring o l  work  hence  initializing counter array requires o n  l  
time  additionally  o n  l   sets determine  o l  values 
time required initialize o n  l    determining prev support  i  j    k  a  b 
   

fimuse csp  extension constraint satisfaction problem

z

x
     c     

     a     



k
w

j      b     


figure     found next edgek   f k  x    k   g  counter  i  j    x  a  b   
   counter  i  j    y  a  b       r   i  a  j  b  ruled every segment containing i  j   k  solid directed lines members g 
solid undirected lines represent members e  

   

fihelzerman   harper

  
  
  
  
  
  
  
  
  
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   

list     
e    f i  j  j      i  j        j   i  j   n g 
 i  j    e
  li
b   lj f
local prev support  i  j    a  b       local next support  i  j    a  b      
k   n  i  k    e    j  k    e f
s  i  j    k  a  b      
m  i  j    k  a  b       
prev support  i  j    k  a  b       next support  i  j    k  a  b       g g
 i  j    e
  li
b   lj r   i  a  j  b  f
k   n  i  k    e    j  k    e f

total      

c   lk
r   i  a  k  c  r   k  c  j  b  f

total    total   
s  i  k   j  a  c     s  i  k   j  a  c    f j  b g  g
total     f
list    list   f  i  j    k  a  b g 
m  i  j    k  a  b        g
counter  i  j    k  a  b     total 
prev support  i  j    k  a  b    
f i  x j i  x    e    x   j    j  x    e      x  k    prev edgek g
  f i  k j i  k    prev edgek g
  f i  start j start  k    prev edgek g 
next support  i  j    k  a  b    
f i  x j i  x    e    x   j    j  x    e      k  x    next edgek g
  f i  k j k  i    next edgek g
  f i  end j k  end    next edgek g  g
local prev support  i  j    a  b    
f i  x j i  x    e    x   j    j  x    e      x  i    prev edge ig
  f i  start j start  i    prev edgei g 
local next support  i  j    a  b    
f i  x j i  x    e    x   j    j  x    e      i  x    next edgei g
  f i  end j i  end    next edgeig  g

figure     initialization data structures muse pc   

   

fimuse csp  extension constraint satisfaction problem

   list   
  
pop   i  j    k  a  b  list 
  
 k  c    s  i  j    k  a  b  f
  
counter  i  k   j  a  c     counter  i  k   j  a  c      
  
counter  k  i   j  c  a     counter  k  i   j  c  a      
  
counter  i  k   j  a  c        m  i  k   j  a  c      f
  
list    list   f  i  k   j  a  c     k  i   j  c  a g 
  
m  i  k   j  a  c        m  k  i   j  c  a        g g
  
update support sets   i  j    k  a  b     see figure     g

figure     eliminating inconsistent binary constraints muse pc   
update support sets    i  j    k  a  b  f
    i  x    prev support  i  j    k  a  b    x    j   x    k   x    start f
  
prev support  i  j    k  a  b     prev support  i  j    k  a  b    f i  x g 
  
next support  i  j    x  a  b     next support  i  j    x  a  b    f i  k g 
  
next support  i  j   x  a  b      m  i  j    x  a  b      f
  
list    list   f  i  j    x  a  b     j  i   x  b  a g 
  
m  i  j    x  a  b        m  j  i   x  b  a        g g
    i  x    next support  i  j    k  a  b    x    j   x    k   x    end f
  
next support  i  j    k  a  b     next support  i  j    k  a  b    f i  x g 
  
prev support  i  j    x  a  b     prev support  i  j    x  a  b    f i  k g 
   
prev support  i  j   x  a  b      m  i  j    x  a  b      f
   
list    list   f  i  j    x  a  b     j  i   x  a  b g 
   
m  i  j    x  a  b        m  j  i   x  b  a        g g
     k  i    prev edgei
    local prev support  i  j    a  b     local prev support  i  j    a  b    f i  k g 
    local prev support  i  j    a  b    f
    r   i  a  j  b        r   j  b  i  a       
     i  x    local next support  i  j    a  b    x    j   x    k   x    end f
   
local next support  i  j    a  b     local next support  i  j    a  b    f i  x g 
   
m  i  j    x  a  b      f
   
list    list   f  i  j    x  a  b     j  i   x  b  a g 
   
m  i  j    x  a  b        m  j  i   x  b  a        g g g
     i  k    next edgei
    local next support  i  j    a  b     local next support  i  j    a  b    f i  k g 
    local next support  i  j    a  b    f
    r   i  a  j  b        r   j  b  i  a       
     i  x    local prev support  i  j    a  b    x    j   x    k   x    start dof
   
local prev support  i  j    a  b     local prev support  i  j    a  b    f i  x g 
   
m  i  j    x  a  b      f
   
list    list   f  i  j    x  a  b     j  i   x  b  a g 
   
m  i  j    x  a  b        m  j  i   x  b  a        g g g g

figure     function update support sets   i  j    k  a  b   muse pc   
   

fihelzerman   harper

approach
csps
muse csp

nodes
degree
number
number
per path node splitting constraint networks nodes

n
n

kn

k
k

 

n
kn

asymptotic
time

knn  l 
 
 kn  l     kn   l 

table    comparison space time complexity muse path consistency
muse csp path consistency multiple csps representing node splitting
problem  e g   lexical ambiguity parsing  
next support  i  j    k  a  b  requires o n  time  time required calculate
prev support next support sets o n  l    finally  time needed calculate
local next support local prev support sets o n  l   o n  l   sets
o n  elements per set 
worst case running time algorithm enforces muse path consistency
 in figures        operates o n  l    n  l   time  clearly o n  l  
entries counter array keep track algorithm  counter  i  j    k  a  b 
l magnitude  never become negative  maximum running
time lines     figure     given elements  m  appear list
once  o n  l    o n  l   prev support next support lists 
o n  size  maximum running time required eliminate o n  elements
support sets o n  l    finally  since o n  l   local next support
local prev support sets eliminate o n  elements  worst case time
eliminate items local sets o n  l    hence  worst case running time
muse csp path consistency algorithm o n  l    n  l   
space complexity muse csp pc   o n  l    n  l    arrays
counter contain o n  l   elements o n  l   sets  containing
o l  items  o n  l   prev support next support sets  containing o n  items 
o n  l   local next support local prev support sets  containing o n  items 
comparison  worst case running time space complexity csp path consistency  pc    o n  l    note applications representable planar dag
l   n  worst case running times algorithms order  compare
muse csp use multiple csps problems k alternative variables
particular variable csp  muse csp path consistency asymptotically
attractive  shown table   
proof correctness muse pc   similar proof muse ac   
brie outline proof here  binary constraint looses support muse
pc    see lines       figure     local prev support set local nextsupport set becomes empty  see lines       figure     respectively   either case 
inadmissible muse path consistent instance  prove constraint s local
support sets become empty cannot participate muse path consistent
instance muse csp  proven local next support  local prev support follows
symmetry   observe r   i  a  j  b       nodes immediately
   

fimuse csp  extension constraint satisfaction problem

    f  j   j   jg
    f  j   jg

 

 

 

start

end
 

 

figure     example set csp problems would good candidate muse
csp lack node sharing 
follow  and similarly j   dag incompatible truth constraint 
cannot participate muse path consistent instance  line    figure    
 i  k  removed local next support  i  j    a  b    i  j    k  a  b 
popped list  removal  i  k  local next support  i  j    a  b  indicates
segment containing i  j   k support r   i  a  j  b   remains shown
  i  j    k  a  b  put list r   i  a  j  b  must false every segment
contains i  j   k  proven induction number iterations
loop figure     much proof muse ac     must show
r   i  a  j  b      muse pc    muse path consistent  r   i  a  j  b 
muse path consistent  must exist least one path start end
goes nodes j nodes n path contain least one label
consistent constraint  proof would similar second half proof
muse ac   correctness  this  may conclude muse pc   builds
largest muse path consistent structure 

   combining csps muse csp
problems inherent lattice structure problems solved
node splitting approach natural areas application muse csp 
exponential number csps replaced single instance muse csp  dag
representation inherent problem  section discuss dag construction
application areas would benefit muse csp approach 
obvious construct dag  set csp problems
used segments muse csp  example  figure    illustrates two instances
csp combined single muse csp  however  using muse csp
example would right choice  node sharing cannot offset cost using
extra muse ac   data structures 
multiple nodes name various csps potentially represented
single node muse csp  assume two nodes  k  k  given
name  say k  two instances csp  domain obey
constraints  i e  
   lk    lk   i e   domains equal  
   r  k   a    r  k   a  every   lk    lk   i e   unary constraints
same  
   

fihelzerman   harper

    f  j   jg
    f  j   jg
    f  j   jg

 

 
start

end

 

 

 

start

end

 

 

figure     example maximal node sharing leads spurious segments 
first dag contains two paths  f     g f g  correspond none
segments  second dag presents preferred sharing created
create dag routine 
   r  k   a  i  b    r  k   a  i  b  labels   lk    lk  b   li  
segments  i e   binary constraints same  
however  illustrated figure     much sharing common nodes introduce
additional segments appear original list csps  extra
segments cause extra work done  often desirable create dag
shares nodes without introducing extra segments  algorithm create dag  shown
figure    takes arbitrary set csp problems input  a list segments   outputs
dag representation csps shares nodes without introducing spurious
segments  create dag calls auxiliary procedure order sigma defined figure    
data structures used two routines defined figure    
hold individual segments   routine create dag uses special data
structure ordered sets supports useful operations  segment n
integer   n  node position n       always start node 
 j j      always end node   k  m  ordered subset consisting
nodes positions k m  addition  ordered set allows us insert node
immediately node j already set  node  pos  structure
name field next set field  set names nodes follow
node  pos  set segments 
create dag begins adding special purpose start end nodes segment 
calls routine order sigma shown figure    order nodes
segment  order sigma orders nodes segment ones
common tend occur earlier set  order elements  uses operator
   i e   larger than  defined nodes  note start node defined
 largest  node  end node  smallest  node  addition    j means either
appears segments j does  appear number
segments  lower ordinal number j   thus operator   induces total
ordering nodes n  
order sigma first called create dag selects largest node
smaller start node  constructs set   set segments
containing i  point  segments ordered start node first
second  calls order sigma order nodes smaller i 
recursive call done  segments considered  i e   z    note
   

fimuse csp  extension constraint satisfaction problem

notation

meaning



set node sets  node set represents csp 
node set segment   set modified include
begin end nodes create dag algorithm work
properly  note     always start node   jj     
always end node  node  pos  structure name
next set  names nodes follow node dag  
g set node pairs  i  j   exists
directed edge j dag created create dag 
n set nodes placed dag
create dag 
z set segments order respect node j
order sigma 
node j used order sigma order remaining
elements smaller node 
u set nodes already considered current call
order sigma 
r set nodes z order sigma 
node largest node smaller j r   u
 if non empty  r order sigma 
order sigma  set segments z contain node i 


g
n
z
j
u
r



figure     data structures used create dag order sigma 

   

fihelzerman   harper

create dag    f

  
  
  
  
  
  
  
  
  

   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   

add start first node end last node every segment  
order sigma   start  
pos      maximum segment length f
   copy   
    jj       pos f
 pos  name   end f
g    g   f  pos        pos  g  g
 

 

else f

edge set    f j   pos      name    pos      name  
  pos  name    pos  nameg 
next set    f pos      name j   edge setg 
     edge set 
node  pos  name n f
n    n    pos  
 pos  next    next set 
g    g   f  pos        pos  g  g
 

 

else f
node    get node n name  pos  name 
node next   next set f
g    g   f  pos        pos  g  g
else f

new node     create new node 
new node name    concatenate  pos  name     
node    get node n named new node name  if one  
node    node next   next set f
new node name    concatenate new node name     
node    get node n named new node name  if one   g
 node   null 
n    n   new node 
else new node    node 
new node next    next set 
replace  pos  name new node name  pos      next 
g    g   f  pos       new node g 
replace every occurance  pos  pos new node
segments edge set  g g g g g
eliminate start end g     g

figure     routine create dag represent  

   

fimuse csp  extension constraint satisfaction problem

order sigma  z  j   f
   u     
   z    f
  
r   
 

 

  
  
  
  
  
  
   
   
   
   
   

 z

r   u   
    largest  node r   u less j  
else
    largest  node r less j  
   fj   z     g  
z    z    
   end f
  f
put j  
u    u     g
order sigma s  i  g g g

figure     routine arrange nodes within segments convenient merging 
first iteration loop  preference select largest node
contained segments ordered recursive call order sigma 
items independent ordered segments  create spurious paths
placed early dag  however  items occur already ordered segments 
placed earlier items occur ordered segments would tend introduce
spurious paths  loop continues segments ordered  worstcase running time order sigma o n     n sum cardinalities
segments  
order sigma orders nodes segments  create dag begins construct dag  represented set nodes n set directed edges g 
dag constructed going segment beginning position
second element  the position start   loop line   looks nodes left
right order  one position time  elements segment added
g  node certain name already placed n  i e   set nodes
already dag created  adding node graph  as well directed
edge  pos       pos  g  cannot create spurious paths dag 
hand  node name  pos  already placed n  
possible current segment could add paths dag correspond
segments   avoid adding spurious segments  deal segments
one time share previous node node name
current position  basic idea add edge keep track nodes
follow node dag  this  easily determine whether
node used occurs another segment later position  node
used followed precisely set next nodes follow
node already placed graph  otherwise  second node would renamed
avoid adding spurious segments  event  create new name node 
   

fihelzerman   harper

note dag complete  eliminate start end nodes g
 and corresponding outgoing incoming edges  make g consistent use
muse arc consistency muse path consistency algorithms  running time
create dag o n     n sum cardinalities segments  
even though dags produced routine create dag nice properties 
routine probably used starting point custom combining routines
specific intended application area  believe domain specific information play important role muse combination  example domain specific
combining algorithm presented  harper et al          describes spoken language
parsing system uses muse csp  distinguishing feature application s combining algorithm instead avoiding creation extra segments  allows controlled
introduction extra segments extra segments often represent sentences
n best sentence spoken language recognition system would miss 

   conclusion

conclusion  muse csp used eciently represent several similar instances
constraint satisfaction problem simultaneously  multiple instances csp
common variables domains compatible constraints 
combined single instance muse csp  much work required enforce
node  arc  path consistency need duplicated across instances  especially
constraints suciently tight 
developed muse csp constraint based parser  parsec  harper   helzerman      a  harper et al         zoltowski et al          capable parsing word
graphs containing multiple sentence hypotheses  developed syntactic semantic
constraints parsing sentences  applied word graph  eliminate hypotheses syntactically semantically incorrect  work speech processing 
muse arc consistency algorithm effective pruning incompatible labels
individual csps represented composite structure  extracting
parses sentences remaining muse csp muse ac    usually unnecessary enforce arc consistency csp represented directed path
network tightness syntactic semantic constraints 
speech processing area segmenting signal higher level
chunks problematic  vision systems handwriting analysis systems comparable
problems  addition  problems allow parallel alternative choices type
variable  parsing lexically ambiguous sentences  excellent candidates
muse csp 
c   implementations algorithms described paper available following location  ftp   transform ecn purdue edu pub speech harper code   directory
contains readme file file called muse csp tar z 

   

fimuse csp  extension constraint satisfaction problem

acknowledgements
work supported part purdue research foundation grant
intel research council  would thank anonymous reviewers insightful
recommendations improving paper 

references

bessiere  c          arc consistency arc consistency again  artificial intelligence     
        
davis  a  l     rosenfeld  a          cooperating processes low level vision  survey 
artificial intelligence              
dechter  r          local global consistency  artificial intelligence             
dechter  r   meiri  i     pearl  j          temporal constraint networks  artificial intelligence            
dechter  r     pearl  j          network based heuristics constraint satisfaction problems  artificial intelligence           
freuder  e          partial constraint satisfaction  proceedings international joint
conference artificial intelligence  pp          
freuder  e          complexity k tree structured constraint satisfaction problems 
proceedings eighth national conference artificial intelligence  pp      
han  c     lee  c          comments mohr henderson s path consistency algorithm 
artificial intelligence              
harper  m  p     helzerman  r  a       a   extensions constraint dependency parsing
spoken language processing  computer speech language                 
harper  m  p     helzerman  r  a       b   managing multiple knowledge sources
constraint based parsing spoken language  fundamenta informaticae             
        
harper  m  p   jamieson  l  h   zoltowski  c  b     helzerman  r          semantics
constraint parsing word graphs  proceedings international conference
acoustics  speech  signal processing  pp  ii    ii    
mackworth  a  k          consistency networks relations  artificial intelligence        
       
mackworth  a  k     freuder  e          complexity polynomial networkconsistency algorithms constraint satisfaction problems  artificial intelligence     
      
   

fihelzerman   harper

maruyama  h       a   constraint dependency grammar  tech  rep   rt      ibm 
tokyo  japan 
maruyama  h       b   constraint dependency grammar weak generative capacity 
computer software 
maruyama  h       c   structural disambiguation constraint propagation 
proceedings annual meeting acl  pp        
mohr  r     henderson  t  c          arc path consistency revisited  artificial intelligence              
montanari  u          networks constraints  fundamental properties applications
picture processing  information science            
van beek  p          inherent level local consistency constraint networks 
proceedings twelfth national conference artificial intelligence  pp          
villain  m     kautz  h          constraint propagation algorithms temporal reasoning 
proceedings fifth national conference artificial intelligence  pp          
waltz  d  l          understanding line drawings scenes shadows  winston  p 
 ed    psychology computer vision  mcgraw hill  new york 
zoltowski  c  b   harper  m  p   jamieson  l  h     helzerman  r          parsec 
constraint based framework spoken language understanding  proceedings
international conference spoken language understanding  pp          

   


