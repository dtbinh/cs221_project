journal of artificial intelligence research                

submitted       published     

accelerating partial order planners  some techniques for
effective search control and pruning
alfonso gerevini

gerevini ing unibs it

lenhart schubert

schubert cs rochester edu

dipartimento di elettronica per l automazione  universita di brescia
via branze     i       brescia  italy
department of computer science  university of rochester
rochester  ny             usa

abstract

we propose some domain independent techniques for bringing well founded partialorder planners closer to practicality  the first two techniques are aimed at improving
search control while keeping overhead costs low  one is based on a simple adjustment to
the default a  heuristic used by ucpop to select plans for refinement  the other is based
on preferring  zero commitment   forced  plan refinements whenever possible  and using
lifo prioritization otherwise  a more radical technique is the use of operator parameter
domains to prune search  these domains are initially computed from the definitions of
the operators and the initial and goal conditions  using a polynomial time algorithm that
propagates sets of constants through the operator graph  starting in the initial conditions 
during planning  parameter domains can be used to prune nonviable operator instances and
to remove spurious clobbering threats  in experiments based on modifications of ucpop 
our improved plan and goal selection strategies gave speedups by factors ranging from  
to more than      for a variety of problems that are nontrivial for the unmodified version 
crucially  the hardest problems gave the greatest improvements  the pruning technique
based on parameter domains often gave speedups by an order of magnitude or more for
dicult problems  both with the default ucpop search strategy and with our improved
strategy  the lisp code for our techniques and for the test problems is provided in on line
appendices 

   introduction

we are concerned here with improving the performance of  well founded  domain independent planners   planners that permit proofs of soundness  completeness  or other desirable
theoretical properties  a state of the art example of such a planner is ucpop  barrett
et al         penberthy   weld         whose intellectual ancestry includes strips  fikes  
nilsson         tweak  chapman         and snlp  mcallester   rosenblitt         such
planners unfortunately do not perform well at present  in comparison with more practically
oriented planners such as sipe  wilkins         prs  georgeff   lansky         or o plan
 currie   tate        
however  there appear to be ample opportunities for bringing well founded planners
closer to practicality  in the following  we begin by suggesting some improvements to
search control in planning  based on more carefully formulated strategies for selecting partial
plans for refinement  and for choosing open conditions in a selected partial plan  our planc      ai access foundation and morgan kaufmann publishers  all rights reserved 

figerevini   schubert
selection strategy uses s oc   the number of steps in a plan plus the number of open
conditions still to be established   as a heuristic measure for ucpop s a  search of the
plan space   addition of an attenuated term reecting the number of threats or  unsafe
conditions  uc  such as    uc  is sometimes advantageous    our aw selection strategy 
which we term zlifo  prefers  zero commitment  plan refinements to others  and otherwise
uses a lifo  stack  discipline  zero commitment refinements are logically necessary ones 
they either eliminate a plan altogether because it contains an irremediable aw  or they add
a unique step or unique causal link  from the initial state  to establish an open condition
that cannot be established in any other way  the strategy is closely related to ones proposed
by peot   smith        and joslin   pollack        but generally appears to perform better
than either 
we describe these two classes of techniques in section   below  and in section   we
report our experimental results based on slightly modified versions of ucpop   for the
more dicult problems taken from the available ucpop test suite and elsewhere  we obtain
improvements by factors ranging from   to more than       with the hardest problems
giving the greatest improvements 
we then turn to our proposal for using computed operator parameter domains during
planning  in particular  in section   we motivate and describe a method of precomputing parameter domains based on propagating sets of constants forward from the initial
conditions   the process is iterative  but the algorithm runs within a time bound that is
polynomial in the size of the problem specification  we provide details of the algorithm 
along with theorems about its correctness and tractability  in sections         and online
appendix   
in section   we show how to use parameter domain information in a ucpop style planner  during planning  parameter domains can be used to prune operator instances whose
parameter domains are inconsistent with binding constraints  and to eliminate spurious
threats that cannot  in fact  be realized without violating domain constraints  we illustrate
the effectiveness of this technique with examples drawn from the ucpop test suite as well as
from the trains transportation planning world developed at rochester  allen   schubert 
      allen et al          in some of these tests  we apply the parameter domain information
in the context of the default ucpop search strategy  we demonstrate significant gains on
most problems  particularly the more challenging ones  e g   speedups of more than an order
of magnitude for several problems in the strips world  and a more than     fold speedup
for a trains problem  
in another set of tests in the trains world  we use our own improved search strategies
as baseline  i e   we ask whether additional speedups are obtainable by use of parameter
   the search strategy is described as  a  or ida   search in  penberthy   weld         in the code for
ucpop     it is described more generally as best first  since arbitrary ranking functions  not necessarily
corresponding to a  heuristics  may be plugged in  but with choices like s oc or s oc uc as
plan ranking heuristic  as discussed in section       it is natural to view the strategy as an a  strategy 
   while the techniques we describe are applicable to other planners  our focus is on ucpop because it is
well known and the lisp code is readily available  the system can be obtained via anonymous ftp from
cs washington edu 
   we hope that the notion of a parameter domain  as a set of admissible bindings  constants   will cause
no confusion with the notion of a planning domain  as a specified set of operators  along with constraints
on admissible initial conditions and goal conditions 

  

fiaccelerating partial order planners
domains  above those obtainable with the s oc and zlifo search strategies  our experimental results again show speedups by about a factor of    through use of parameter
domains  on top of those obtained by the improved search strategies  the combined speedup
is over       
as evidence that the effectiveness of using parameter domains in combination with our
search strategy is not dependent on some peculiarity of the latter  we also include some
results for ucpop s default strategy  joslin and pollack s  least cost aw repair   lcfr 
strategy  joslin   pollack        and for peot and smith s  least commitment   lc  open
condition selection strategy  peot   smith        in section   
in section    we state our conclusions  comment on some related work and mention
possible extensions of our techniques 

   plan selection and goal selection

we will be basing our discussion and experiments on ucpop  an algorithm exemplifying the
state of the art in well founded partial order planning  thus we begin with a sketch of this
algorithm  referring the reader to  barrett et al         penberthy   weld        for details 
in the next two subsections we then motivate and describe our improved plan selection and
goal selection strategies 

    ucpop

ucpop uses strips like operators  with positive or negative preconditions and positive or

negative effects  the initial state consists of positive predications with constant arguments
 if any   and all other ground predications are false by default  unlike strips  ucpop also
allows conditional effects  expressed by   part when clauses specifying a  possibly complex 
extra condition needed by that effect and the  possibly complex  effect itself  for instance 
an action puton  x  y  z    put  x on  y from  z   might have conditional effects stating
that when  y is not the table  it will not be clear at the end of the action  and when z is
not the table  it will be clear at the end of the action  the  u  in ucpop indicates
that universally quantified conditions and effects are permitted as well  for instance  it is
permissible to have a precondition for a pickup  x  action that says that for all  y   not
 on  y  x   holds  universal statements are handled by explicit substitution of domain
constants and need not concern us at this point 
in essence  ucpop explores a space of partially specified plans  each paired with an
agenda of goals still to be satisfied and threats still to be averted  the initial plan contains
a dummy  start  action whose effects are the given initial conditions  and a dummy
 end  action whose preconditions are the given goals  thus goals are uniformly viewed as
action preconditions  and are uniformly achieved through the effects of actions  including
the  start  action 
the plans themselves consist of a collection of steps  i e   actions obtained by instantiating the available operators   along with a set of causal links  a set of binding constraints 
and a set of ordering constraints  when an open goal  precondition  is selected from the
agenda  it is established  if possible  either by adding a step with an effect that unifies
with the goal  or by using an existing step with an effect that unifies with the goal   in
the latter case  it must be consistent with current ordering constraints to place the existing
  

figerevini   schubert
step before the goal  i e   before the step whose preconditions generated the goal   when a
new or existing step is used to establish a goal in this way  there are several side effects 
 a causal link  s   q  s   is also added  where s indicates the step  producing  the
goal condition q and s indicates the step  consuming  q  this causal link serves to
protect the intended effect of the added  or reused  step from interference by other
steps 
 binding constraints are added  corresponding to the unifier for the action effect in
question and the goal  precondition  it achieves 
 an ordering constraint is added  placing the step in question before the step whose
precondition it achieves 
 if the action in question is new  its preconditions are added to the agenda as new
goals  except that eq neq conditions are integrated into the binding constraints   see
below  
 new threats  unsafe conditions  are determined  for a new step and its causal link 
other steps threaten the causal link if they have effects unifiable with the condition
protected by the causal link  and these effects can occur temporally during the causal
link   and the effects of the new step may similarly threaten other causal links  in
either case  new threats are placed on the agenda  it is useful to distinguish definite
threats from potential threats  the former are those in which the unification that
confirmed the threat involved no new binding of variables 
binding constraints assert the identity  eq  or nonidentity  neq  of two variables or a variable
and a constant  eq constraints arise from unifying open goals with action effects  and neqconstraints arise  i  from neq preconditions of newly instantiated actions   ii  from matching
negative goals containing variables to the initial state  and  iii  from averting threats by
 separation   i e   forcing non equality of two variables or a variable and a constant that
were unified in threat detection  neq constraints may be disjunctive  but are handled simply
by generating separate plans for each disjunct 
the overall control loop of ucpop consists of selecting a plan from the current list of
plans  initially the single plan based on  start  and  end    selecting a goal or threat from
its agenda  and replacing the plan by the corresponding refined plans  if the agenda item is
a goal  the refined plans are those corresponding to all ways of establishing the goal using
a new or existing step  if the agenda item is a definite threat to a causal link  s   q  s   
then there are at most three refined plans  two of these constrain the threatening step
to be before step s  demotion  or after step s  promotion   thus averting the threat 
a third possibility arises if the effect threatening  s   q  s   is a conditional effect of the
threatening action  such a conditional threat can be averted by creating a goal denying
some precondition needed by the conditional effect 
ucpop has a  delay separation  switch   d sep   and when this is turned on  only
definite threats are dealt with  note that potential threats may become definite as a result
of added binding constraints   they may also  expire  as a result of added binding and
ordering constraints  i e   the threatening effect may no longer unify with the threatened
condition or it may be forced to occur before or after the threatened causal link  expired
p

c

p

c

p

p

c

p

  

c

c

fiaccelerating partial order planners
threats are removed from the agenda when selected   when  d sep  is off  potential threats
as well as definite ones are averted  with separation as an additional method of doing so
besides the three methods above 
inconsistencies in binding constraints and ordering constraints are detected when they
first occur  as a result of adding a new constraint  and the corresponding plans are eliminated  planning fails if no plans remain  the success condition is the creation of a plan
with consistent binding and ordering constraints and an empty agenda 
the allowance for conditional effects and universal conditions and effects causes only
minor perturbations in the operation of ucpop  for instance  conditional effects can lead
to multiple matches against operators for a given goal  each match generating different
preconditions   of course  there can be multiple matches even without conditional effects 
if some predicates occur more than once in the effects  
the key issues for us right now are the strategic ones  how plans are selected from the
current set of plans  discussed in section       and how goals are selected for a given plan
 discussed in section      

    the trouble with counting unsafe conditions

the choice of the next plan to refine in the ucpop system is based on an a  best first
search  recall that a  uses a heuristic estimate f  p  of overall solution cost consisting of
a part g  p    cost of the current partial solution  plan  p and a part h p    estimate of
the additional cost of the best complete solution that extends p  in the current context it
is helpful to think of f  p  as a measure of plan complexity  i e    good  plans are simple
 low complexity  plans 
there are two points of which the reader should be reminded  first  in order for a 
to guarantee discovery of an optimal plan  i e   the  admissibility  condition   h p  should
not overestimate the remaining solution cost  nilsson         second  if the aim is not
necessarily to find an optimal solution but to find a satisfactory solution quickly  then f  p 
can be augmented to include a term that estimates the remaining cost of finding a solution 
one common way of doing that is to use a term proportional to h p  for this as well  i e  
we emphasize the h component of f relative to the g  component  this is reasonable to the
extent that the plans that are most nearly complete  indicated by a low h value  are likely
to take the least effort to complete  thus we will prefer to pursue a plan p  that seems closer
to being complete to a plan p further from completion  even though the overall complexity
estimate for p  may be greater than for p  nilsson         pages         alternatively  we
could add a heuristic estimate of the remaining cost of finding a solution to f  p  that is
more or less independent of the estimate h p  
with these considerations in mind  we now evaluate the advisability of including the
various terms in ucpop s function for guiding its a  search  namely
s  oc  cl  and uc 
where s is the number of steps in the partial plan  oc is the number of open conditions
 unsatisfied goals and preconditions   cl is the number of causal links  and uc is the
number of unsafe conditions  the number of pairs of steps and causal links where the step
  

figerevini   schubert
threatens the causal link   the default combination used by ucpop is s oc uc   this
becomes s oc uc f if special open conditions called  facts  are present  these are
conditions that are not state dependent  e g   a numerical relation like  add one  x  y   or
a geometrical one like  loc in room  x  y  room   and are established by lisp functions
 barrett et al          since few of our test problems involved facts  we will not discuss the
f term further except to say that we followed the ucpop default strategy of including this
term where it is relevant  see the tileworld problems in section     and also some remarks
in section     in connection with the parameter domain experiments  
      s  the number of steps currently in the plan

this can naturally be viewed as comprising g  p   the plan complexity so far  intuitively  a
plan is complex to the extent that it contains many steps  while in some domains we might
want to make distinctions among the costs of different kinds of steps  a simple step count
seems like a reasonable generic complexity measure 
      oc  the number of open conditions

this can be viewed as playing the role of h p   since each remaining open condition must be
established by some step  the catch is that it may be possible to use existing steps in the
plan  including  start   i e   the initial conditions  to establish remaining open conditions 
thus oc can overestimate the number of steps still to be added  forfeiting admissibility 
despite this criticism  several considerations favor retention of the oc term  first  a
better estimator of residual plan complexity seems hard to come by  perhaps one could
modify oc by discounting open conditions that are matched by existing actions  but this
presumes that all such open conditions can actually be achieved by action re use  which is
improbable if there are remaining threats  or remaining goals requiring new steps   second 
the possibility that oc will overestimate the residual plan complexity will rarely be actualized  since typically further steps still need to be added to achieve some of the goals  and
those steps will typically introduce further open conditions again requiring new steps  finally  to the extent that oc does at times overestimate the residual plan complexity  it can
be viewed as emphasizing the the h p  term of f  p   thus promoting faster problem solving
as explained above 
      cl  the number of causal links

one might motivate the inclusion of this term by arguing that numerous causal links are
indicative of a complex plan  as such  cl appears to be an alternative to step counting 
   this is in no way the  recommended  strategy  the ucpop implementation makes available various
options for controlling search  to be used at the discretion of experimenters  our present work has
prompted the incorporation of our particular strategies as an option in ucpop     
   note that threats and remaining goals impose constraints that may not be consistent with seemingly
possible instances of action re use  this is clear enough for threats  which often imply temporal ordering
constraints inconsistent with re use of an action  it is also fairly clear for remaining goals  for instance 
in towers of hanoi the small disk d  is initially on the medium disk d   which in turn is on the big disk
d   and d  is on peg p   the goal is to move the tower to the third peg p   so it seems to ucpop initially
as if  on d  d   and  on d  d   could be achieved by  re use  of  start   however  the third goal  on
d  p   implies that various actions must be added to the plan which are inconsistent with those two
seemingly possible instances of action re use 

   

fiaccelerating partial order planners
however  note that cl is in general larger than s  since every step of a plan establishes
at least one open condition and thus introduces at least one causal link  the larger cl is
relative to s  the more subgoals are achieved by action re use  hence  if we use cl instead
of  or in addition to  s in the g  p  term  we would in effect be saying that achieving multiple
subgoals with a single step is undesirable  we would tend to search for ways of achieving
multiple goals with multiple steps  even when they can be achieved with a single step  this
is clearly not a good idea  and justifies the exclusion of cl from f  p  
      uc  the number of unsafe conditions

we note first of all that this is clearly not a g  measure  while the number of threats will
tend to increase if we establish more and more subgoals without curtailing threats  threats
as such are not elements of the plan being constructed and so do not contribute to its
complexity  in fact  when the plan is done all threats will be gone 
can uc then be viewed as an h measure  one argument of sorts for the armative is
the following  not all partial plans are expandable into complete plans  and a high value of
uc makes it more likely that the partial plan contains irresolvable conicts  if we regard
impossible plans as having infinite cost  then inclusion of a term increasing with uc as part
of the h measure is reasonable  this carries a serious risk  though  since in the case where
the partial plan does have a consistent completion  despite a high uc count   inclusion of
such a term can greatly overestimate the residual plan complexity 
another possible armative argument is that conditional threats are sometimes resolved
by  confrontation   which introduces a new goal denying a condition required for the threatening conditional effect  this new goal may in turn require new steps for its achievement 
adding to the plan complexity  however  this link to complexity is very tenuous  in the first
place  many of the ucpop test domains involve no conditional effects  and threat removal
by promotion  demotion or separation adds no steps  even when conditional effects are
present  many unconditional as well as conditional threats are averted by these methods 
furthermore  uc could swamp all other terms since threats may appear and expire in
groups of size o n   where n is the number of steps in the plan  for instance  consider
a partial plan that involves moves by a robot r to locations l        ln  so that there
are n causal links labeled  at r l          at r ln   if a new move to location l is
now added  initially with an indefinite point of departure  x  this produces effects  at
r l  and  not  at r  x    the latter can threaten all of the above n causal links  at
least if the new move is at first temporally unordered relative to the n existing moves  if
this new action subsequently happens to be demoted so as to precede the first move  or
promoted so as to follow the last   or if  x becomes bound to a constant distinct from
l        ln  all n threats expire  keeping in mind that different steps in a plan may
have similar effects  we can see that half of the steps could threaten the causal links of the
others  in such a case we could have o n    unsafe conditions  destined to expire as a result
of o n  promotions demotions  in fact even a single new binding constraint may cause
o n    threats to expire  for instance  if there are n   effects  not  p  x   threatening
n   causal links labeled  p  y   then if binding constraint  neq  x  y  is added  all n    
threats expire  recall that when expired threats are selected from the agenda by ucpop 
they are recognized as such and discarded without further action 
   

figerevini   schubert
our conclusion is that it would be a mistake to include uc in full in a general h measure 
though some increasing function of uc that remains small enough not to mask oc may be
worth including in h 
finally  can uc be regarded as a measure of the remaining cost of finding a solution 
here  similar arguments to those above apply  on the armative side  we can argue that
a high value of uc indicates that we may be facing a combinatorially explosive  timeconsuming search for a set of promotions and demotions that produce a conict free step
ordering  in other words  a high value of uc may indicate a high residual problem solving
cost   and at the end of such a search  we may still lack a solution  if no viable step
ordering exists   on the other hand  we have already noted that unsafe conditions include
many possible conicts which may expire as a result of subsequent partial ordering choices
and variable binding choices not specifically aimed at removing these conicts  so counting
unsafe conditions can arbitrarily overestimate the number of genuine refinement steps  and
hence the problem solving effort  still needed to complete the plan 
so uc is scarcely more trustworthy as a measure of residual planning cost than as a
measure of residual plan cost 
thus we conclude that the most promising general heuristic measure for plan selection is
s oc  possibly augmented with an attenuated form of the uc term that will not dominate
the s oc component   for instance  one might add a small fraction of the term  such as
uc     or more subtly   to avoid swamping by a quadratic component   a term proportional
to uc    
 

    the goal selection strategy

an important opportunity for improving planning performance independently of the domain
lies in identifying forced refinements  i e   refinements that can be made deterministically 
specifically  in considering possible refinements of a given partial plan  it makes sense to
give top priority to open conditions that cannot be achieved  and then preferring open
conditions that can be achieved in only one way   either through addition of an action not
yet in the plan  or through a unique match against the initial conditions 
the argument for giving top priority to unachievable goals is just that a plan containing
such goals can be eliminated at once  thus we prevent allocation of effort to the refinement
of doomed plans  and to the generation and refinement of their doomed successor plans 
the argument for preferring open conditions that can be achieved in only one way
is equally apparent  since every open condition must eventually be established by some
action  it follows that if this action is unique  it must be part of every possible completion
of the partial plan under consideration  so  adding the action is a  zero commitment 
refinement  involving no choices or guesswork  at the same time  adding any refinement in
general narrows down the search space by adding binding constraints  ordering constraints
and threats  which constrain both existing steps and subsequently added steps  for unique
refinements this narrowing down is monotonic  never needing revocation  for example 
suppose some refinement happens to add constraints that eliminate a certain action instance
a as a possible way of achieving a certain open condition c   if the refinement is unique 
then we are assured that no completion of the plan contains a as a way of establishing c  
if it is not unique  we have no such assurance  since some alternative refinement may be
   

fiaccelerating partial order planners
compatible with the use of a to achieve c   in short  the zero commitment strategy cuts
down the search space without loss of access to viable solutions 
peot and smith        studied the strategy of preferring forced threats to unforced
threats  and also used a  least commitment   lc  strategy for handling open conditions 
least commitment always selects an open condition which generates the fewest refined
plans  thus it entails the priorities for unachievable and uniquely achievable goals above
 while also entailing a certain prioritization of nonuniquely achievable goals   joslin and
pollack        studied the uniform application of such a strategy to both threats and open
conditions in ucpop  terming this strategy  least cost aw repair   lcfr   combining this
with ucpop s default plan selection strategy  they obtained significant search reductions
 though less significant running time reductions  mainly for implementation reasons  but
also because of the intrinsic overhead of computing the  repair costs   for a majority of the
problems in the ucpop test suite 
joslin   pollack        and subsequently srinivasan   howe        proposed some
variants of lcfr designed to reduce the overhead incurred by lcfr for aw selection 
these strategies employ various assumptions about the aw repair costs  allowing the more
arduous forms of cost estimation  requiring look ahead generation of plans  to be confined
to a subset of the aws in the plan  while for the rest an approximation is used that does
not significantly increase the overhead  both teams obtained quite significant reductions
in overhead costs in many cases  e g   by factors ranging from about   to about    for the
more dicult problems  however  overall performance was sometimes adversely affected 
joslin and pollack found that their variant  qlcfr  solved fewer problems than lcfr 
because of an increase in the number of plans generated in some cases  each of srinivasan  
howe s four strategies did slightly better than lcfr in some of their    problem domains
but significantly worse in others  in terms of plans examined during the search  their best
overall strategy  which uses similar action instances for similar aws  did slightly better on
  of the domains  slightly worse on    and significantly worse on    and in those cases the
number of plans examined was also more than a factor of    above that of default ucpop  
in the unmodified form of ucpop  goals are selected from the agenda according to a
lifo  last in first out  i e   stack  discipline  based on experience with search processes
in ai in general  such a strategy has much to recommend it  as a simple default  in the
first place  its overhead cost is low compared to strategies that use heuristic evaluation or
lookahead to prioritize goals  as well  it will tend to maintain focus on the achievement of
a particular higher level goal by regression   very much as in prolog goal chaining   rather
than attempting to achieve multiple goals in breadth first fashion 
maintaining focus on a single goal should be advantageous at least when some of the
goals to be achieved are independent  for instance  suppose that two goals g  and g  can
both be achieved in various ways  but choosing a particular method of achieving g  does
not rule out any of the methods of achieving g   then if we maintain focus on g  until
it is solved  before attempting g   the total cost of solving both goals will just be the sum
of the costs of solving them individually  but if we switch back and forth  and solutions
of both goals involve searches that encounter many dead ends  the combined cost can be
much larger  this is because we will tend to search any unsolvable subtree of the g  search
tree repeatedly  in combination with various alternatives in the g  search tree  and vice
versa   this argument should still have some validity even if g  and g  are not entirely
   

figerevini   schubert
independent  i e   as long as g  gives rise to subproblems that tend to fail in the same
way regardless of choices made in the attempt to solve g   or vice versa   then shifting
attention between g  and g  will tend to generate a set of partial plans that unnecessarily
 cross multiplies  alternatives 
we have therefore chosen to stay with ucpop s lifo strategy whenever there are no
zero commitment choices  this has led to very substantial improvements over lcfr in our
experiments 
thus our strategy  which we term zlifo   zero commitment last in first out    chooses
the next aw according to the following preferences 
   a definite threat   d sep  is turned on   using lifo to pick among these 
   an open condition that cannot be established in any way 
   an open condition that can be resolved in only one way  preferring open conditions
that can be established by introducing a new action to those that can be established
by using  start   
   an open condition  using lifo to pick among these 
hence the overhead incurred by zlifo for aw selection is limited to the open conditions  and is lower for these than the overhead incurred by lcfr  furthermore  it can
also be significantly lower in practice than the overhead incurred by lc  because testing
whether an oc is not a zero commitment choice  i e   whether it can be established in more
than one way  is less expensive than computing the total number of ways to achieve it 
in online appendix   we give the pseudocode of zlifo for the selection of the open
condition  preferences       very recently this implementation has also been packaged into
ucpop      a new version of ucpop which is available by anonymous ftp to cs washington edu 

   experiments using ucpop

in order to test our ideas we modified version     of ucpop  barrett et al          replacing its default plan selection strategy  s oc uc  and goal selection strategy  lifo  to
incorporate strategies discussed in the previous sections 
we tested the modified planner on several problems in the ucpop suite  emphasizing
those that had proved most challenging for previous strategies  on some artificial problems
due to kambhampati et al          in the trains transportation domain developed in
rochester  allen   schubert        allen et al          and in joslin   pollack s tileworld
domain  joslin   pollack         we briey describe the test problems and the platforms
and parameter settings we used  and then present the experimental results for our improved
search strategies 
      and    are zero commitment choices  in our experiments  which are described in the next section  the
sub preference in    gave improvements in the context of russell s tire changing domain  in particular
with fix    without significant deterioration of performance in the other domains 

   

fiaccelerating partial order planners

    test problems and experimental settings

the ucpop problems include towers of hanoi  t of h   fixa  fix   fixit  tower invert  
test ferry  and sussman anomaly  in the case of t of h  we added a   operator version to
the ucpop single operator version  since t of h is a particularly hard problem for ucpop
and its diculty has long been known to be sensitive to the formalization  e g    green 
        fixa is a problem from dan weld s  fridge domain   in which the compressor
in the fridge is to be exchanged  requiring unscrewing several screws  stopping the fridge 
removing the backplane  and making the exchange  fix  is from stuart russell s  at tire
domain   where a new wheel is to be mounted and lowered to the ground  the old wheel has
been jacked up already and the nuts loosened   this requires unscrewing the nuts holding
the old wheel  removing the wheel  putting on the new wheel  screwing on the nuts  jacking
down the hub  and tightening the nuts  fixit is more complicated  as the wheel is not yet
jacked up initially and the nuts not yet loosened  the spare tire needs to be inated  and
the jack  wrench and pump all need to be taken out of the trunk and stowed again at the
end  tower invert  is a problem in the blocks world  requiring the topmost block in a stack
of four blocks to be made bottom most  test ferry is a simple problem requiring two cars
to be moved from a to b using a one car ferry  by boarding  sailing  and unboarding for
each car 
the artificial problems correspond to two parameter settings for art        one
of the two artificial domains that served as a testbed for kambhampati et al  s extensive
study of the behavior of various planning strategies as a function of problem parameters
 kambhampati et al          art      provides two layers of    operators each 
where those in layer   achieve the preconditions of those in layer    and each operator in
layer   achieves one of the    goals  however  some operators in each layer can establish
or clobber the preconditions of their neighbors  and this can force operators to be used in
a certain order 
the version of the trains domain that we encoded involves four cities  avon  bath 
corning  dansville  connected by four tracks in a diamond pattern  with a fifth city  elmira 
connected to corning by a fifth track  the available resources  which are located at various
cities  consist of a banana warehouse  an orange warehouse  an orange juice factory  three
train engines  not coupled to any cars     boxcars  suitable for transporting oranges or
bananas   and a tanker car  suitable for transporting orange juice   goals are typically to
deliver oranges  bananas  or orange juice to some city  requiring engine car coupling  car
loading and unloading  engine driving  and possibly oj manufacture 
the tileworld domain consists of a grid on which holes and tiles are scattered  a given
tile may or may not fit into a particular hole  the goals are to fill one or more holes by
using three possible actions  picking up a tile  going to an x y location on the grid  and
dropping a tile into a hole  the agent can carry at most four tiles at a time 
formalizations of these domains in terms of ucpop s language are provided in online
appendix    the experiments for all problems except fixit  the trains problems and the
tileworld problems were conducted on a sun    using lucid common lisp        while
the rest  tables x xi in the next subsection  were conducted on a sun    using allegro
common lisp      judging from some repeated experiments  we do not think that the
est

est

clob

   

clob

figerevini   schubert

goal selection plan selection cpu sec
lifo
lifo
zlifo
zlifo

s oc uc
s oc
s oc uc
s oc

      
    
    
    

plans

               
       
         
       

table i  performance of plan goal selection strategies on t of h 
differences in the platforms significantly impact performance improvements   among the
search control functions provided by ucpop  we used the default bestf search when the
problem was solvable within the search limit of        plans generated  while we used the
function id bf search  an implementation of the linear space best first search algorithm
given by korf         when this limit was exceeded   in all of the experiments the delayseparation switch   d sep   was on  except for those using the lcfr strategy 

    experimental results for zlifo and s oc

tables i xi show the cpu time  seconds  and the number of plans created explored by
ucpop on twelve problems in the domains described above  towers of hanoi with three
disks and either one operator  t of h   or three operators  t of h    the fridge domain
 fixa   the tire changing domain  fix  and fixit   the blocks world  tower invert  and
sussman anomaly   the ferry domain  test ferry   the artificial domain art     
 specifically  art     and art       the trains domain  trains   trains  and trains  
and the tileworld domain  tw         tw     both the number of plans created explored and
the cpu time are important performance measures  the number of plans  which indicates
search space size  is a more stable measure in the sense that it depends only on the search
algorithm  not the implementation   but the time is still of interest since an improvement
in search may have been purchased at the price of a more time consuming evaluation of
alternatives  it turns out that we do pay some price in overhead when we substitute our
strategies for the defaults  factors ranging from about     to      and rarely higher  per plan
created   this may be due to slightly greater inherent complexity of zlifo versus lifo 
but we think the differences could be reduced by substituting modified data structures for
those of ucpop   we were committed to not altering these 
tables i and ii show that for the t of h the plan selection strategy s oc gives dramatic
improvements over the default s oc uc strategy   in these tests the default lifo goal
selection strategy was used   in fact  ucpop solved t of h  in      seconds using s oc
versus       seconds using s oc uc  t of h  proved harder to solve than t of h   reest

clob

   the differences were the result of what was available at different times and locales over the course of
nearly two years of experimentation 
   this choice was motivated by the observation that when the problem is relatively easy to solve
bestf search appears to be more ecient than id bf search  while for hard problems it can be very
inecient because of the considerable amount of space used at run time and the cpu time spent on
garbage collection  which in some cases made lisp crash  reporting an internal error 
   it is also worth noting that the number of plans created implicitly takes into account plan size  since
addition of a step to a plan is counted as creation of a new plan in ucpop 

   

fiaccelerating partial order planners

goal selection plan selection cpu sec plans
lifo
s oc uc
               
lifo
zlifo
zlifo

s oc
s oc uc
s oc

    

     
    

         
         
       

table ii  performance of plan goal selection strategies on t of h 

goal selection plan selection cpu sec
lifo
lifo
zlifo
zlifo

s oc uc
s oc
s oc uc
s oc

    
    
    
    

plans

         
         
     
     

table iii  performance of plan goal selection strategies on fixa
quiring     seconds using s oc and an unknown time in excess of     cpu seconds using
s oc uc 
our zlifo goal selection strategy can significantly accelerate planning compared with
the simple lifo strategy  in particular  when zlifo was combined with the s oc planselection strategy in solving t of h  it further reduced the number of plans generated by a
factor of   in t of h  and by a factor of   in t of h   the overall performance improvement
for t of h  was thus a factor of     in terms of plans created and factor of     in terms of
cpu time  from       to      seconds  
tables iii viii provide data for problems that are easier than t of h  but still challenging to ucpop operating with its default strategy  namely fixa  table iii   fix   table iv  
tower invert   table v   test ferry  table vi  and the artificial domain art     
with       and        table vii  and with       and        table vii  
the results show that the combination of s oc and zlifo substantially improves the
performance of ucpop in comparison with its performance using s oc uc and lifo 
the number of plans generated dropped by a factor of    for fixa  by a factor of     for
est

est

clob

est

goal selection plan selection cpu sec
lifo
lifo
zlifo
zlifo

s oc uc
s oc
s oc uc
s oc

    
    
    
    

clob

plans

         
       
       
       

table iv  performance of plan goal selection strategies on fix 

   

clob

figerevini   schubert

goal selection plan selection cpu sec plans
lifo
lifo
zlifo
zlifo

s oc uc
s oc
s oc uc
s oc

    
    
    
    

       
       
       
      

table v  performance of plan goal selection strategies on tower invert 

goal selection plan selection cpu sec plans
lifo
lifo
zlifo
zlifo

s oc uc
s oc
s oc uc
s oc

    
    
    
    

       
       
      
      

table vi  performance of plan goal selection strategies on test ferry

goal selection plan selection cpu sec
lifo
lifo
zlifo
zlifo

s oc uc
s oc
s oc uc
s oc

   
    
    
    

plans

       
        
     
     

table vii  performance of plan goal selection strategies on art     
and        averaged over     problems 
est

clob

with      
est

clob

goal selection plan selection cpu sec
lifo
lifo
zlifo
zlifo

s oc uc
s oc
s oc uc
s oc

    
    
    
    

plans

       
         
     
     

table viii  performance of plan goal selection strategies on art     
and        averaged over     problems 
est

clob

with      

clob

goal selection plan selection cpu sec plans
lifo
lifo
zlifo
zlifo

s oc uc
s oc
s oc uc
s oc

    
    
    
    

     
     
     
     

table ix  performance of plan goal selection strategies on sussman anomaly
   

est

fiaccelerating partial order planners

    

fixit
trains 
 

t of h   

performance
improvement

 

   

 
art       fixa
  search space reduction
art        
  fix 
speedup
tower invert 
test ferry
sussman anomaly
 
 e   
   
    
              e   
problem size

  
 
  

figure    performance improvement due to zlifo and s oc  relative to the number of
plans generated by lifo and s oc uc  log log scale   the improvements for
the problems that ucpop was unable to solve even with a very high search limit
 trains   trains   and t of h   are not included 
fix   by a factor of     for tower invert   by a factor of     for test ferry  by a factor of  
for art      and by a factor of    for art     
concerning art        note that the performance we obtained with unenhanced
ucpop      plans generated for art     and     for art      was much the same as
 just marginally better than  reported by kambhampati et al         for the best planners
considered there             plans generated for art      and           for art      
this is to be expected  since ucpop is a generalization of the earlier partial order planners 
relative to standard ucpop and its predecessors  our  accelerated  planner is thus an order
of magnitude faster  interestingly  the entire improvement here can be ascribed to zlifo
 rather than s oc plan selection  which is actually a little worse than s oc uc   this
is probably due to the unusual arrangement of operators in art      into a  clobbering chain   a     clobbers a         s preconditions       a    clobbers a    s preconditions 
similarly for a      which makes immediate attention to new unsafe conditions an unusually
good strategy 
in experimenting with various combinatorially trivial problems that unmodified ucpop
handles with ease  we found that the s oc and zlifo strategy is neither beneficial nor
harmful in general  there may be a slight improvement or a slight degradation in performance  results for the sussman anomaly in table ix provide an illustrative example 
we summarize the results of tables i x in figure    showing the performance improvements obtained with the combined zlifo goal selection strategy and s oc plan selection
est

clob

est

n

 

n

 

 

i 

   

clob
 

figerevini   schubert

zlifo  
s oc
lc  
s oc
lcfr  
s oc
lifo  
s oc uc

trains 

trains 

trains 

fixit

plans
         
                           
         
time
    
    
     
    
plans
       
                             
             
time
   
     
      
     
plans
        
          
          
               
time
     
       
     
       
plans                               
                               
time
       
        
      
        

table x  performance of the plan selection strategy s oc in combination with the goal
selection strategies zlifo  lcfr and lc in solving problems which are very
hard for the default strategies of ucpop  s oc uc lifo    the cpu seconds
do not include lisp garbage collection  the number of plans generated for lcfr
does not include those created in order to estimate the repair cost of the aws  

problem
zlifo 
lcfr
name cpu time plans cpu time plans
tw  
tw  
tw  
tw  
tw  
tw  

    
    
    
    
     
     

     
     
      
       
       
       

    
    
    
     
     
     

     
     
      
       
       
       

table xi  performance of ucpop in the tileworld domain using zlifo  and lcfr for
goal selection  and s oc f    uc for plan selection
strategy as a function of problem diculty  as indicated by the number of plans generated
by the default lifo plus s oc uc strategy   the trend toward greater speedups for
more complex problems  though somewhat dependent on problem type  is quite apparent
from the log log plot 
for direct comparison with joslin and pollack s lcfr strategy and peot and smith s
lc strategy  we implemented their strategies and applied them to several problems  they
did very well  sometimes better than zlifo  for problems on the lower end of the diculty
spectrum  but poorly for harder problems   for all the problems we ran  lc with the
 d sep  switch on performed better than lcfr in terms of plans explored and cpu
time required   for t of h  lcfr in combination both with the default s oc uc plan
selection strategy  and with our s oc plan strategy did not find a solution within a search
limit of         plans generated  cf      for zlifo with s oc  and     for zlifo with
s oc uc   requiring an unknown cpu time in excess of      seconds with s oc uc 
   

fiaccelerating partial order planners
and in excess of      seconds with s oc  cf       seconds for zlifo with s oc    
lc performed much better than lcfr but still considerably worse than zlifo  solving
t of h  by generating exploring           plans with s oc and           plans with
s oc uc  and requiring      cpu secs  and       cpu secs  respectively  for t ofh   lc found a solution by generating exploring               plans with s oc uc
and               plans with s oc  requiring        cpu secs  and       cpu secs 
respectively 
table x shows the results for the plan strategy s oc  with the goal strategies zlifo 
lcfr and lc  applied to three problems  trains   trains  and fixit   as shown by the data
in the table these are very hard for the default strategies of ucpop  lifo   s oc uc  
but become relatively easy when s oc is used in combination either with zlifo  lcfr
or lc  while lcfr and lc did slightly better than zlifo for trains   the easiest of
these problems   they performed quite poorly for fixit  trains  and trains   the hardest
problems  compared to zlifo 
joslin and pollack        tested their lcfr strategy on six problems in the tileworld
 tw         tw     five of which are very hard for default ucpop  but easy for ucpop using
lcfr    we tested our zlifo strategy in the tileworld using the same six problems 
zlifo did well for tw      but for tw   and tw   its performance dropped well below that
of lcfr  this raised the question whether for these particular problems it is crucial to
minimize  repair cost  in aw selection uniformly  rather than just in certain special cases
 zlifo does minimize the repair cost when no threat is on the aw list  and at least one zerocommitment open condition is present   however  further experiments aimed at answering
this question suggested that the poor choices made by zlifo for some tileworld problems
were not due to selection of  high cost  over  low cost  aws  instead two factors appear be
crucial for improving zlifo   a  emphasizing zero commitment open conditions by giving
them higher priority than threats   b  when there are no zero commitment open conditions 
resolving threats as soon as they enter the agenda   we realized the relevance of  b  by
observing that the performance of a modified versions of lcfr  where the  d sep  switch
is implicitly forced on  dramatically degraded for tw   in a slightly different formulation of
the tileworld  
we extended our zlifo strategy to include  a  and  b   and we briey tested the
resulting variant of zlifo  zlifo    table xi shows the results for zlifo  together with
the plan selection strategy s oc    uc f  where as discussed in section     we included
an attenuated form of the uc term  uc      and an f term equal to the number of facts
since tileworld uses facts to track the number of tiles carried by the agent    zlifo 
    this was with  d sep  turned off  which is the implicit setting in lcfr  joslin         in our experiments
we also tested a variant of lcfr  where the switch is forced to be on  the resulting goal strategy in
combination with our plan strategy s oc performed significantly better for t of h   solving the problem
generating exploring           plans  and using        cpu seconds  note also that a comparison of
our implementation of lcfr and joslin   pollack s implementation used for the experiments discussed
in  joslin   pollack        showed that our implementation is considerably faster  joslin        
    in their experiments tw    the easiest among tw      was not solved by ucpop even when allowed to run
for over eight hours  on the other hand  ucpop using lcfr solves tw    the hardest problem  without
ever reaching a dead end node in the search tree 
    in the zlifo  experiments the refined plans generated by resolving a threat were added to the aw list
in the following order  first the plan generated by promotion  then the plan generated by demotion  and
finally the plan generated by confrontation or separation 

   

figerevini   schubert
performed very eciently for all six tileworld problems  in fact a little better than lcfr 
note that for these problems zlifo  is more ecient than lcfr in terms of the cpu time 
even though the number of plans generated explored by the two strategies is approximately
the same  this is because the overhead of selecting the next aw to be handled is higher
in lcfr than in zlifo   and zlifo   in fact  while lcfr needs to compute the  repair
cost  of each aw  including the threats  in the current plan  zlifo   zlifo  only needs to
check for the presence of zero commitment open conditions  without processing the threats 
additional experiments indicated that the average performance of zlifo  is comparable
to that of zlifo for most of the other problems we used in our experiments  in terms of
plans created explored  however  the cpu time tends to increase since the overhead of
computing the goal selection function is higher for zlifo  than for zlifo  because of the
extra agenda management costs  because of this overhead  we do not regard zlifo  as
generally preferable to zlifo  however  the tileworld experiments underscored for us that
in some worlds refinements of zlifo are advantageous 
finally  another possible variant of zlifo  which was suggested to us by david smith 
is based on the following preferences of the next aw to be handled   i  a threat that cannot
be resolved   ii  an open condition that cannot be established   iii  a threat that has only
one possible resolution   iv  an open condition that can only be established in one way   v 
other threats   vi  other open conditions  using lifo to pick among these   we observe
that while this strategy could give further savings in terms of plans created explored  it
also imposes an additional overhead with respect to both zlifo and zlifo  which could
degrade performance in terms of cpu time 

   precomputing parameter domains

even with the speedups obtained through improved search  a ucpop like algorithm remains
severely limited in the complexity of problems it can solve  we believe that significant
further progress requires fuller use of global properties of the search space  as determined by
the structure of the operators  initial conditions  and goals  one way to do that would be
through a more in depth analysis of alternatives during the search  but this can lead to high
overhead costs  another is to precompute constraints on the search space  and to use these
during planning to prune the search  the parameter domain method we now motivate and
describe is of the latter type 

    how can parameter domains help 

in our previous experimentation with ucpop strategies  we found that ucpop goal regression often hypothesized steps that were doomed to be abandoned eventually  because they
stipulated impossible parameter bindings  a clear example of this occurred in the molgen
domain  as encoded in the ucpop test suite  the goal of the  rat insulin  test problem is
 and  bacterium  b   molecule  m 
 contains ig  m   contains  m  b   pure  b  

 

where  b and  m are existentially quantified variables  what this means is that we wish
to create a purified bacterial culture  b  where  b contains a molecule  m  necessarily an
   

fiaccelerating partial order planners
exosome  it turns out   and this molecule in turn contains the insulin gene  ig  we are
using the abbreviations ig  ee  je  l for insulin gene  e coli exosome  junk exosome 
and linker  and e  j  a  for e coli  junk  and antibiotic    roughly speaking  the solution
involves processing the initially given mrna form of the insulin gene so as to produce a
form of insulin dna that can be spliced into the e coli exosome  using a ligate operator 
in turn  the exosome is inserted into the e coli bacterium using a transform operator  and
the bacterial culture is then purified using a screen operator  with antibiotic     the junk
bacterium and exosome merely serve to complicate the task   they are nearly  but not quite 
substitutable for the e coli bacterium and exosome  the junk exosome  unlike e coli exosome 
is not resistant to antibiotic    violating a precondition of screen  
now  in the initial regression the goals  bacterium  b  and  molecule  m  can be
established only with the  start  operator  i e   with the initial conditions  and thus will
not be instantiated to bizarre values   the initial conditions supply e and j as the only
instances of bacterium  and ig  ee  je  and l as the only instances of molecule   on
the other hand  the remaining goals turn out to match the effects of various instances of
the ligate  transform  and screen operators of molgen  as follows 
 contains ig  m    ligate ig  m    transform ig  m 
 contains  m  b    ligate  m  b   transform  m  b 
 pure  b  
 screen  b  y  z 

 

ucpop will happily regress on these actions  yet two of them 

 transform ig  m  and
are doomed to fail  perhaps after a great deal of effort has been expended
on trying to satisfy their preconditions  in particular  examination of the constants that can
 ow into  the transform operator from the initial conditions and other molgen operators
shows that its first argument is restricted to domain fee  jeg  i e   it must be one of
the given exosomes  and the second is restricted to fe  jg  i e   it must be one of the
given bacteria  consequently the instance  transform ig  m  is unrealizable  as its first
argument ig is not in fee  jeg   note that distinct constants denote distinct entities
according to the unique names assumption made by ucpop   the  ligate  m  b  action
is doomed for slightly more subtle reasons  it is the result of a match between  contains  m
 b  and a  when clause   conditional effect  of the ligate operator  whose preconditions
can be reached only if the second parameter  b lies in the set of molecules fig  je  eeg 
yet  b is also restricted to the set of bacteria fe  jg  as a result of the goal condition
 bacterium  b   the fact that these sets are disjoint should allow us to eliminate the
 transform ig  m  action 
note that elimination of action candidates as above increases the number of zero commitment plan refinements that can be made  in the example  we are left with exactly one
action for each of the three goals  and so the zlifo and lcfr strategies will prefer to
regress on these goals rather than regressing on  bacterium  b  and  molecule  m   
which would prematurely make arbitrary choices of  b and  m from the initial state 
 ligate  m  b  

    description of the algorithm

in any completed plan  each precondition of each action must be instantiated by an effect
of some earlier action  so the values of the parameters of the action can only be values that
   

figerevini   schubert
can be  produced  by earlier actions  starting with the initial action   start   moreover 
suppose that a parameter x of a certain action occurs in each of preconditions p        pk 
then a constant c is a possible value of x only if earlier actions can instantiate x to c in
each of p        pk 
our algorithm find parameter domains is based on these observations  beginning in
the initial state  it propagates positive atomic predications to all possible operator preconditions  for a propagated ground atom  if the atom matches an operator precondition 
the algorithm adds the constants in that ground atom to the individual domains of the
parameters they were unified with  these individual domains are particular to specific preconditions  for instance  the individual domain of  x for an operator with preconditions
 on  x  y    clear  x  will in general be distinct for these two preconditions 
as soon as we have nonempty individual domains for all parameters in all preconditions
of an operator  we form the intersection of the individual domains of each parameter of
the operator  for example  if  on  x  y  has  so far  been matched by  on a b  and
 on b c   and  clear  x  has  so far  been matched by  clear a  and  clear table  
then the individual domain of x will be fa bg in the first precondition and fa tableg
in the second  thus  assuming there are no other preconditions  the intersected domain
of  x will be fag at this point  if later  clear b  is also matched against  clear  x  
the intersected domain of  x will grow to fa bg  when both  x and  y have nonempty
intersected domains  the effects  postconditions  of the operator can in turn be propagated 
with  x and  y  bound  to their intersected domains 
the propagated effects are again matched against all possible operator preconditions 
and when a variable  bound  to an intersected domain is successfully unified with a variable in a precondition  it passes its intersected domain to the individual domain of that
precondition variable  via a union operation   this can again lead to growth of the intersected domains of the operator whose precondition was matched  the effects of that operator
may then be propagated  and so on  the individual domains and intersected domains grow
monotonically during the propagation process  and in the end represent the desired parameter domains of the operators 
we illustrate this process through an example  consider the simple planning problem
depicted in figure   where an  operator graph   smith   peot        is used to describe the
logical dependencies among the operators  while the iterative computation of the parameter
domains is graphically illustrated with a  domain propagation graph  below the operator
graph 
the initial conditions  p a  and  p b  unify with the precondition  p  x  of op   so 
the individual domain of  x relative to the precondition p of op  is fa bg  on the other
hand  the precondition  q  x  of op  cannot be satisfied by the initial state  and so the
individual domain of  x relative to q is initially the empty set  hence the intersected domain
of  x for op  is also the empty set 
for op  we have a different situation  since here we have only one precondition and it
can be established by the initial state  therefore  the individual domain of  y relative to
precondition r of op  is the set of constants fb cg  and the intersected domain of  y for
op  is the same set  because r is the only precondition of op  involving  y   since the
intersected domain of  y has been enlarged  initially it was empty   it is propagated to the
individual domains of the other operators through the effect  q  y  of op   in particular 
   

fiaccelerating partial order planners

 p  x 

indicates bundle of edges
op 

 q  x 
 t b 

 start 
 r  y 

 end 

op 
init state   p a   p b   r b   r c   s c 
 s  z 

op  

preconds   p  x   q  x 

goal   t b 

op 
op  

preconds   r  y 

op  

preconds   s  z 
effects   t  z 

effects   q  y 

effects   s  x 

 p a 
 p  x 
 q  x 

id  x   b 

id  x    
op 

 p b 

 q  x 

op 
id p  x   a b 
id q  x   b c 

id p  x   a b 
id q  x    
 q  y 
id  y   b c 

 r b 
 r  y 
 r c 

 s  x 

op 
id r  y   b c 

id  z   a 
s a 

 s  z 

id  z   a b 

op 

 s  z 

id s  z   a 

op 
id s  z   a b 

figure    operator and domain propagation graphs for a simple planning problem 
id  x p  indicates the individual domain of the parameter  x relative to precondition p  id  x  indicates the intersected domain of the parameter  x  final
intersected domains are indicated using bold fonts 
matches the precondition  q  x  of op   so  the individual domain of  x relative
to precondition q of op  is updated by adding the constants of the intersected domain of  y
to it  thus the intersected domain of  x is enlarged to fbg  and can be propagated through
the effect  s  x  of op  
similarly  the propagation of  s  x  will enlarge the individual domain of  z for op  
and also the intersected domain  to the set fa bg  therefore  the final intersected domains
are  fbg for  x in op   fb cg for  y in op   fa bg for  z in op  
before presenting the algorithm a little more formally  we note that the parameter domains will sometimes be  too large   including values that would be found to be impossible
 q  y 

   

figerevini   schubert
if a more detailed state space exploration were conducted  however  all that is required
for soundness in our use of the domains is that they not be  too small   i e   that they
contain all parameter values that can actually occur in the problem under consideration  
of course  to be of practical use the parameter domains of an operator should exclude
some of the constants occurring in the problem specification  particularly those for which
it is intuitively obvious that they are of the wrong sort to fill particular argument slots of
the operator  this has turned out to be the case for all problem domains we have so far
experimented with 
the preceding sketch of our method is an oversimplification since preconditions and
effects of ucpop operators may be particular to a when clause  in this case we compute
individual domains and intersected domains separately for each when clause  for example 
consider the following schematic representation of an operator 
 define  operator op  
 parameters   x  y 
 precondition  and p  p  
 effect  and e  e 
 when     
 when         

pe
p e

where all conditions starting with p or e denote atomic formulas that may involve  x and  y 
we can think of this operator as consisting of a primary when clause whose preconditions
p  and p  must always be satisfied and whose effects e  and e  are always asserted  and
two secondary when clauses whose respective preconditions p   and p   may or may not
be satisfied  and when they are  the corresponding effects e   and e   are asserted  here
our algorithm would maintain individual domains for  x and  y for each of preconditions
p   p   p     and p    and it would maintain intersected domains for  x and  y for the
primary when clause and each of the two secondary clauses  the intersected domains for
the secondary clauses would be based on the individual domains of  x and  y not only
relative to p   and p    but also on those relative to p  and p   since  as noted  the primary
preconditions must hold for the operator to have any of its effects  including conditional
effects 
some further complications arise when ucpop operators contain universally quantified preconditions or effects  disjunctive preconditions  or facts  mentioned in section      
rather than dealing with these complications directly  we will assume that no such operators occur in the input to the algorithm  later we describe a semi automated way of
handling operators containing the additional constructs 
the algorithm is outlined below  a more detailed description is given in online appendix     w is a list of  names of  when clauses whose effects are to be propagated 
individual parameter domains are initially nil  and intersected parameter domains are initially either nil or t  where t is the universal domain   the intersected domain of a
parameter  relative to a given when clause  is t just in case the parameter occurs neither
in the preconditions of the when clause nor in the primary preconditions   in such a case
the successful instantiation of the when clause is clearly independent of the choice of value
for the parameter in question   unification in step   a  is as usual  except that when an
effect variable v is unified with a constant c in a precondition  the unification succeeds 
   

fiaccelerating partial order planners
with unifier v   c  just in case c is an element of the intersected domain of v  for the relevant when clause   the given inits  initial conditions  and goals  which may be omitted 
i e   nil  are treated as an operator  start  with no preconditions and an operator  end 
with no effects  variables in goals are treated like operator parameters  we use the terms
 parameters  and  variables  interchangeably here 
algorithm  find parameter domains operators inits goals 
   initialize w to the initial conditions  so that it contains just the  primary  when clause
of  start  
   repeat steps  a c  until w   nil 
 a  unify the positive effects of all when clauses in w with all possible operator
preconditions  and mark the preconditions successfully matched in this way as
 matched    this marking is permanent   augment the individual domain of
each matched precondition variable with a certain set c of constants  defined as
follows  if the precondition variable was unified with a constant c  then c   fcg 
if it was unified with an effect variable  then c is the intersected domain of that
effect variable  relative to the when clause to which the effect belongs  
 b  mark those when clauses as  propagation candidates  that have all their preconditions  including corresponding primary preconditions  marked as  matched 
and that involve at least one variable for which some relevant individual domain
was augmented in step  a  
 c  reset w to nil  for all when clauses that are propagation candidates  compute
new intersected domains for their variables  if an intersected domain of a whenclause is thereby enlarged  and all intersected domains for the when clause are
now nonempty  then add the when clause to w 
   further restrict intersected domains using equative preconditions of form  eq u v  
i e   form a common intersected domain if both u and v are variables  if u is a
constant and v is a variable  reduce the intersected domain of v by intersecting it
with fug  similarly if u is a variable and v is a constant  if the equation belongs to a
primary when clause  use it to reduce the intersected domains of u and v  whichever
are variables  in the secondary clauses as well 
   return the intersected domains as the parameter domains  producing a sequence of
lists with each list of form
 op  x  a  b  c        x  a  b  c            
where each operator op appears at least once  if op has k conditional effects  there
will be k     successive lists headed by op  where the first provides the parameter
domains for the primary effects of op and the rest provide the parameter domains for
the conditional effects  in the order of appearance in the ucpop definition of op  
note that we do not match or propagate negative conditions  the problem with negative
conditions is that a very large number of them may be implicit in the initial conditions  given
   

figerevini   schubert
the use of the closed world assumption in ucpop  for instance  in a world of n blocks 
with at most o n  on relations  assuming that a block can be on only one other block   we
necessarily have o n    implicit  not  on       relations  in fact  the individual variable
domains of negative preconditions or goals can really be infinitely large  for instance  given
an empty initial state and a  paint red  x  operation with precondition  not  red  x  
and effect  red  x   we can achieve  red c  for infinitely many constants c  perhaps
negative conditions could be effectively dealt with by maintaining anti domains for them 
but we have not explored this since in practice ignoring negative conditions seems to cause
only minimal  domain bloating    we have proved that no actual domain elements can be
lost through neglect of some preconditions  
our use of eq conditions could be refined by making use of them during the propagation
process  and neq conditions could also be used  however  doing so would probably have
marginal impact 
as a final comment  we note that the output format specified in step   of the algorithm
is actually generalized in our implementation so as to report inaccessible preconditions
and goals  these inaccessible conditions are simply appended to the list of parameter
domains for the appropriate when clause of the appropriate operator  for instance  if the
preconditions  oj  oj  and  at  oj  city  in the ld oj   load orange juice   operator
of the trains world  see online appendix    are unreachable  say  because no oranges for
producing orange juice have been provided   the parameter domain list for the  unique 
when clause of ld oj will have the appearance
 ld oj   oj        car        city       oj  oj   at  oj  city   
this feature turns out to be very useful for debugging operator specifications and detecting
unreachable goals 

    correctness and tractability

in keeping with the remarks in the previous section  we will call an algorithm for computing
parameter domains correct if the domains it computes subsume all possible parameter values
that can actually occur  in a given primary or secondary when clause  if we consider all
possible sequences of operator applications starting at the given initial state 
the point is that this property will maintain the soundness of a planning algorithm that
uses the precomputed parameter domains to prune impossible actions  as well as spurious
threats  from a partially constructed plan  we assert the following 

theorem   the find parameter domains algorithm is correct for computing parameter

domains of ucpop style sets of operators  without quantification  disjunction  or facts  
initial conditions  and  possibly  goal conditions 
the proof is given in appendix a  a preliminary step is to establish termination  using the
monotonic growth of domains and the finiteness of the set of constants involved  correctness
is then established by showing that if there exists a valid sequence a  a     a of actions
 operator instances  starting with a     start   and if a is an instance of the operator
op  then the bindings that the parameters of op received in instance a are eventually added
to the relevant intersected domains of op  where  relevant  refers to the when clauses of op
whose preconditions are satisfied at the beginning of a    this is proved by induction on n 
n

n

n

n

   

fiaccelerating partial order planners
we now indicate how we can deal with universally quantified preconditions and effects 
disjunctive preconditions  and facts  we make some simple changes to operator definitions
by hand in preparation for parameter domain precomputation  and then use the domains
computed by find parameter domains  together with the original operators  in running
the planner  the steps for preparing an operator for parameter domain precomputation are
as follows 
 delete disjunctive preconditions  fact preconditions    and universally quantified preconditions  this includes universally quantified goals  it would also include universally
quantified sentences embedded within the antecedents of when clauses  e g   in the
manner   when   forall   x        though these do not occur in any problem
domains we have seen  
 drop universal quantifiers occurring positively in operator effects  i e   occurring at
the top level or embedded by one or more  and s  for example  an effect
  and  at robot  to 
  not  at robot  from  
  forall   x 
  when   and  grasping  x   object  x  
  and  at  x  to    not  at  x  from       

would become

  and  at robot  to 
  not  at robot  from  
  when   and  grasping  x   object  x  
  and  at  x  to    not  at  x  from       

note that the universally quantified variable should be renamed  if necessary  to be
distinct from all other such variables and from all operator parameters 
in the example above the universally quantified variable is unrestricted  when the
quantified variable includes a type restriction  as in   forall  object  x     then
this type restriction needs to become an antecedent of the matrix sentence   in
the example at hand   should be rewritten as the equivalent of   when  object  x 
   since  is often a when clause  this can be done by adding  object  x  as a
conjunct to the antecedent of the when clause  in some cases  is a conjunction of
when clauses  and in such a case the quantifier restriction can be added into each
when clause antecedent 
 drop existential quantifiers in preconditions and goals  adding any restrictions on the
quantified variables as conjuncts to the matrix sentence  for example  the goal
  exists  bacterium  y 
  exists  molecule  x 
  and  contains ig  x 
 contains  x  y 
 pure  y     

    e g   in the strips world we would drop  fact
the given coordinates lie in the given room 

 loc in room  x  y  room   

   

which checks whether

figerevini   schubert
becomes
  and  bacterium  y   molecule  x   contains ig  x 
 contains  x  y   pure  y   

 actually  the  and is dropped as well  when supplying goals to find parameterdomains  
with these reductions  find parameter domains will then compute correct parameter
domains for the operators and goals  to see this  note first of all that dropping preconditions  in the initial step above  will not forfeit correctness  since doing so can only
weaken the constraints on admissible parameter values  and thus can only add constants
to the domains  the effect of dropping a universal quantifier  from the perspective of
find parameter domains  is to introduce a new parameter in place of the universal variable   the operator normalization subroutine detects variables in operator preconditions
and effects that are not listed as parameters  and treats them as additional parameters  
while this is of course a drastic change in the meaning of the operator  it preserves correctness of the parameter domain calculation  this is because the domain of the new parameter
will certainly contain all constants  and hence  under the closed world assumption  all objects  over which the quantified variable ranges  for example  if  x is treated as a parameter
rather than a universally quantified variable in the conditional effect
  forall   x    when  object  x   in  x box    
then the domain of  x for the when clause will consist of everything that can be an object  in
any state where the operator can be applied  thus the effect  in  x box  will also be propagated for all such objects  as is required  finally  the elimination of existential quantifiers
from preconditions and goals can be seen to preserve the meaning of those preconditions
and goals  and hence preserves the correctness of the parameter domain calculation 
next we formally state our tractability claim for the algorithm  as follows  with some
tacit assumptions  mentioned in the proof  
theorem   algorithm find parameter domains can be implemented to run in o mn n  n  
n    time and o mn   space in the worst case  where m is the number of constants in the
problem specification  n is the combined number of preconditions for all operators  and
goals  if included   and n is the combined number of operator effects  including those of
 start   
again the proof is in appendix a  the time complexity of find parameter domains is
determined as the sum of     the cost of all the unifications performed      the costs of all
the individual domain updates attempted  and     the cost of all the intersected domain
updates attempted  the space complexity bound is easily derived by assuming that there
is a fixed upper bound on the number of arguments that a predicate  in a precondition or
effect  can have  and from the fact that for each when clause at most o m  constants are
stored 
by adding some additional data structures in find parameter domains we can obtain
a version of the algorithm whose worst case time complexity is slightly improved  in fact 
in step    c  instead of propagating all of the effects of a when clause with an enlarged
p

e

p

p

e

   

e

p

fiaccelerating partial order planners
intersected domain  i e   adding such a when clause to the list w   it is sucient to propagate
just those effects of the when clause that involve an enlarged intersected domain  this could
be done by setting up for each when clause a table that maps each parameter to a list of
effects  of that when clause  involving that parameter 
in the improved algorithm we use w to store the list of effects  instead of the list of whenclauses  that will be propagated in the next cycle of the algorithm  and steps    and   of
find parameter domains are modified in the following way 
    initialize w to the list of the effects of  start  
    repeat steps  a c  until w   nil 
 a   unify the positive effects in w with all possible operator preconditions  and mark
the preconditions successfully matched in this way as  matched     
 
 b   same as    b  
 c   reset w to nil  for all when clauses that are propagation candidates  compute new intersected domains for their variables  if an intersected domain of a
when clause is thereby enlarged  and all intersected domains for the when clause
are now nonempty  then add to w the subset of the effects of the when clause
involving at least one parameter whose intersected domain is enlarged 
note that the worst case time complexity of the revised algorithm is improved  because now
each effect of each when clause is propagated at most o m  times  this decreases the upper
bound on the number of unifications performed  reducing the complexity estimated in step
    of the proof of theorem   to o mn n    hence we have proved the following corollary 
e

p

corollary   there exists an improved version of find parameter domains that can be
implemented to run in o mn  n   time in the worst case 
p

e

   using parameter domains for accelerating a planner

we have already used the example of molgen to motivate the use of precomputed parameter
domains in planning  showing how such domains may allow us to prune non viable actions
from a partial plan 
more fundamentally  they can be used each time the planner needs to unify two predications involving a parameter  either during goal regression or during threat detection   in
either case  one predication is a  sub goal and the other is an effect of an action or an
initial condition   if the unifier is inconsistent with a parameter domain  it should count
as a failure even if it is consistent with other binding constraints in the current  partial 
plan  and if there is no inconsistency  we can use the unifier to intersect and thus refine
the domains of parameters equated by the unifier 
for example  suppose that g    at  x  y  is a precondition of a step in the current
plan  and that e    at  w  z  is an effect of another  possibly new  step  where  x   y 
 w and  z are parameters  or  in the case of  w and  z  existentially quantified variables 
which have no binding constraints associated with them in the current plan  assume also
that the domains of the parameters are 
   

figerevini   schubert
 x    agent   agent   agent  
 w    agent   agent  

 y    city   city  
 z    city   city  

the unification of g and e gives the binding constraints f x    w   y    zg  which are
not viable because the parameter domains of  y and of  z have an empty intersection 
on the other hand  if the domain of  z had been fcity   city   city g  then the unification of g and e would have been judged viable  and the domains of the parameters would
have been refined to 
 x    agent   agent  
 w    agent   agent  

 y    city  
 z    city  

thus parameter domains can be incrementally refined as the planning search progresses 
and the narrower they become  the more often they lead to pruning 

    incorporating parameter domains into ucpop

the preceding consistency checks and domain refinements can be used in a partial order 
causal link planner like ucpop as follows  given a goal  open condition  g selected by
ucpop as the next aw to be repaired  we can
    restrict the set of new operator instances that ucpop would use for establishing g  an
instance of an operator with effect e  matching g  is disallowed if the precomputed
parameter domains relevant to e are incompatible with the current parameter domains or binding constraints relevant to g   note that the current parameter domains
associated with g may be refinements of the initial domains  
    restrict the set of existing steps that ucpop would reuse for establishing g  reusing a
step with effect e  matching g  is disallowed if the current parameter domains relevant
to e are incompatible with the current parameter domains or binding constraints
relevant to g 
moreover  given a potential threat by an effect q against a protected condition p  inspection
of the relevant parameter domains may reveal that the threat is actually spurious  this
happens if the unifier of p and q violates the  possibly refined  domain constraints of a
parameter in p or q  thus we can often
    reduce the number of threats that are generated by the planner when a new causal
link is introduced into the plan  this happens when an open condition is established
either by reusing a step or by introducing a new one  
    recognize that a threat on the list of the aws to be processed is redundant  allowing
its elimination   note that since parameter domains are incrementally refined during
planning  even if we use     during the generation of the threats  it is still possible for
a threat to becomes spurious after it has been added to the aw list  
these four uses of parameter domains cut down the search space without loss of viable
solutions  since the options that are eliminated cannot lead to a correct  complete plan 
   

fiaccelerating partial order planners
note that     and     can be useful even when the planner only deals with definite
threats  i e    d sep  switch is turned on  for at least three reasons  first  determining
that a threat is not a definite threat when  d sep  is on incurs an overhead cost  so 
earlier elimination of a spurious threat could lead to considerable savings if the threat is
delayed many times during the search  the second reason relates to the plan selection
strategies adopted  if one uses a function that includes an  attenuated  term corresponding
to the number of threats currently on the aw list  then eliminating spurious threats in
advance can give a more accurate measure of the  badness  of a plan  finally  parameter
domains could be used in threat processing so as to prune the search even when  dsep  is
on  in particular  suppose that we modify the notion of a definite threat  when we have
parameter domains  so that e g    p  x  and  not  p  y   comprise a definite threat if
the parameter domains associated with  x and  y are both c  so in that case  even with
d sep  on  we may discover early that a threat has become definite   in which case it might
also be a forced threat  i e   the choice between promotion and demotion may be dictated
by ordering constraints  and that can prune the search space  however  in our current
implementation we do not exploit this third point 
we have incorporated these techniques into ucpop  version       along with our earlier
improvements to the plan and goal selection strategies  parameter domains are handled
through an extension of the  varset  data structure  weld        to include the domains
of the variables  parameters   and by extending the unification process to implement the
filtering discussed above    we now describe our experiments with this enhanced system 

    experimental results using parameter domains

our main goal here is to show that while the overhead determined by computing the parameter domains is not significant  both at preprocessing time and at planning time   exploitation of the parameter domains during planning can significantly prune the search  in the
experiments we used the version of find parameter domains which is described in section
    and in online appendix    note that for domains more complex than the ones we have
considered it might be worthwhile to use the improved version of the algorithm discussed in
section       however  it remains to be seen whether problems significantly more complex
than those we consider here can be solved by any ucpop style planner  
the cpu times needed by our implementation of find parameter domains are negligible for the problems we have looked at  they were    msec or less for many problems
in the ucpop test suite  when running compiled allegro cl     on a sun         msec for
two problems  fixa from the fridge repair domain and fixit from the at tire domain   and
  msec on the trains world problems described below 
in our first set of tests  we relied on the search strategy used as default in ucpop  the
function used for a  plan selection was thus s oc uc f  allowing for problems that
involve  facts    and the goals were selected from the agenda according to a pure lifo
discipline   
    in the current implementation new threats are filtered only when the protected condition is established
by a step already in the plan 
    in all experiments the  d sep  switch was on  the default delay separation strategy for selecting unsafe
conditions was slightly modified in the version of ucpop using parameter domains  in particular  the

   

figerevini   schubert
we began by experimenting with a variety of problems from ucpop s test suite  comparing performance with and without the use of parameter domains  while relatively easy
problems such as sussman anomaly  fixa  test ferry  and tower invert  showed no improvement through the use of parameter domains  most problems   particularly the harder
ones   were solved more easily with parameter domains  for example  the rat insulin
problem from the molgen domain was solved nearly twice as fast  and some strips world
problems  move boxes and variants    and towers of hanoi  t of h   were solved about
   times as fast  note that the strips world problems involve both facts and universally
quantified conditional effects  two problems from the oce world  oce  and oce  
which we knew to be readily solvable with our improved search strategy  remained dicult  in the case of oce   unsolvable  with the default ucpop strategy  despite the use
of parameter domains    further experiments revealed that the source of this ineciency
was the default plan selection strategy of ucpop  in fact  using our s oc f strategy
instead of s oc uc f  without parameter domains oce  and oce  were solved generating exploring           and           plans respectively  while using the parameter
domains the plans numbered           and           respectively 
these initial experiments suggested to us that the most promising application of computed parameter domains would be for nontrivial problems that involved a variety of types of
entities and relationships  and significant amounts of goal chaining  i e   with each successive
action establishing preconditions for the next   from this perspective  the trains world
struck us as a natural choice for further experimentation  with the additional advantage
that its design was independently motivated by research at rochester into mixed initiative
problem solving through natural language interaction   refer again to the formalization in
online appendix     recall from table x that the trains  problem was extremely hard for
unmodified ucpop  requiring about    minutes and generating over a million plans 
running the same problem with parameter domains produced a solution in     seconds
 with      plans generated   i e       times faster 
intuitively  the use of parameter domains to constrain planning is analogous to using
type constraints on the parameters  although parameter domains also take account of initial
conditions   so it is of interest to see whether adding type constraints can provide similar
eciency gains as the use of parameter domains  our first set of experiments therefore
included t trains   a  typed  version of trains   the operators have been slightly changed
by adding new preconditions stating the types of the parameters involved  for example 
the operator uncouple has been augmented with the preconditions  engine  eng  and
 car  car   this problem was also extremely hard for the unmodified ucpop  exceeding
the search limit of           plans generated and requiring more than      seconds  with
parameter domains  the solution was obtained in one second 
threats that can be resolved by separation and which are recognized to be redundant through the use of
parameter domains were selected to be eliminated 
    move boxes   differs slightly from the move boxes problem in the ucpop suite  in that its goal is  in room
box  rclk   move boxes a differs slightly from the move boxes    in that its initial state contains two
boxes 
    oce  is directly from ucpop s test suite and oce  is minor variant of oce   in oce   all persons
are to be furnished with checks made out to them  using a check printer at the oce and a briefcase for
picking up the checks and bringing them home   sam  and  sue  are the given persons  and in oce 
we have added  person alan  and  person smith  in the initial conditions 

   

fiaccelerating partial order planners

problems

without domains
with domains
domain
plans
cpu sec
plans
cpu sec ratio
trains 
                         
        
    
     
t trains 
           
      
       
    
     
move boxes
                       
         
    
     
move boxes  
           
      
        
    
     
move boxes  
           
     
        
    
     
move boxes a
           
     
        
    
     
t of h 
                                    
    
     
rat insulin
       
    
       
    
     
monkey test 
     
    
     
    
     
monkey test 
       
    
       
    
     
fix 
         
    
         
    
     
oce 
                                             
     
oce 
           
      
           
            
tower invert 
       
    
       
    
     
sussman anomaly
     
    
     
    
     
fixa
         
   
         
    
 
test ferry
       
    
       
    
 

table xii  plans generated visited and cpu time  secs  for standard ucpop with and
without parameter domains    this result was obtained on a sun    with
lucid common lisp  the others on a sun    with allegro common lisp  
these results indicate that adding type constraints to operator specifications is not
nearly as effective as the use of parameter domains in boosting planning eciency  we
discuss this point further in the context of the second set of tests  below  
table xii summarizes the experimental results for all of the experiments that used the
default ucpop search strategy  the table gives the number of plans generated visited by
the planner and the cpu time  seconds  required to solve the problems    note that the
use of the parameter domains gave very dramatic improvements not only in the trains domain  but also in the strips world domain  the rightmost column supplies  domain ratio 
data  as a metric that we hoped would predict the likely effectiveness of using parameter
domains  the idea is that parameter domains should be effective to the extent that they
filter out many parameter bindings that can be reached by chaining back from individual
preconditions of an operator to the initial state  these bindings can be found by using a
variant of the algorithm for propagating intersected domains that instead propagates unions
of individual domains  and comparing these union domains to the intersected domains   
    the systems were compiled under allegro cl      with settings  space     speed     safety     debug
    and run on a sun     the cpu time includes the lisp garbage collection  it is the time given in the
output by ucpop  
    actually  we do not need to explicitly propagate union domains  but can propagate  partial  bindings for
one predication at a time  starting with the initial conditions  we match the predication to all possible
preconditions  adding the constant arguments it contains to the union domains of the matched operator

   

figerevini   schubert

trains
without domains
with domains
domain
problems
plans
cpu sec
plans
cpu sec ratio
trains 
         
    
       
   
     
trains                                   
     
trains                                    
     
table xiii  plans generated visited and cpu time  secs  for ucpop with and without
parameter domains in the trains domain using the zlifo strategy 

trains without domains
with domains
domain
problems plans cpu sec plans cpu sec ratio
trains          
   
       
   
     
trains                           
     
trains                           
     
table xiv  plans generated visited and cpu time  secs  for ucpop with and without
parameter domains in the trains domain using the lcfr strategy 
the  domain ratio  provides this comparison  dividing the average union domain size by the
average intersected domain size  with averages taken over all parameters of all when clauses
of all operators 
the largest speedups  e g   for the trains problems  do tend to correlate with the
smallest domain ratios  and the smallest speedups with the largest domain ratio  unity  
see the last few rows   however  it can be seen from the table that the problem diculty  as
measured by plans or cpu time  is much more useful than the domain ratio as a predictor
of speedups to be expected when using parameter domains  problems that generate on the
order of a million plans or more with standard ucpop tend to produce speedups by   orders
of magnitude  whereas the domain ratio for some of these problems  e g   move boxes    is
no better  or even worse  than for problems with much smaller speedups  e g   move boxesa  rat insulin  monkey test   monkey test    the much lower diculty of these problems
predicts their reduced speedup  but to complicate matters  not all dicult problems give
high speedups  see t of h  and especially oce    we do not know what subtleties of
problem structure account for these unusual cases 
in our second round of experiments  we tested the effectiveness of the parameter domain
technique in combination with our improved search strategy  i e   s oc zlifo  in addition  we combined s oc with lcfr  least cost aw selection   joslin   pollack         so
 or when clause   we then find corresponding  partially bound  effects  and add any new effects to the
list of predications still to be propagated  a partially bound effect such as  p a  x  y  is new if there
is no identical or similar predication such as  p a  u  v  among the previously propagated predications
or among those still to be propagated 

   

fiaccelerating partial order planners

t trains

without domains
with domains
domain
problems
plans
cpu sec
plans
cpu sec ratio
t trains           
    
       
   
     
t trains           
    
         
    
     
t trains                                       
     

table xv  plans generated visited and cpu time  secs  for ucpop with and without parameter domains in the  typed  trains domain using the zlifo strategy 

t trains

without domains
with domains
domain
problems
plans
cpu sec
plans
cpu sec ratio
t trains                               
     
t trains                             
     
t trains         
    
       
    
     

table xvi  plans generated visited and cpu time  secs  for ucpop with and without
parameter domains in the  typed  trains domain using the lcfr strategy 
as to test for possible sensitivity of the parameter domains technique to the precise strategy
used  for the present set of tests we used a search limit of        plans generated 
once again we began by sampling some problems from the ucpop test suite  and these
initial trials yielded results quite analogous to those for the default ucpop strategy  we
obtained no improvements for several easier problems and significant improvements for
harder ones  e g   again close to a factor of   for rat insulin   noteworthy members of the
latter category were oce  and oce    recall that oce  had shown little speedup with
standard ucpop and oce  had been unsolvable  however  in view of the computational
expense of testing both zlifo and lcfr  we then decided to narrow our focus to the
trains world  as mentioned  the advantages of this world are its inherent interest and
relative complexity 
tables xiii xvi provide experimental results for the trains domain with the s oc 
zlifo strategy and the s oc lcfr strategy  in each case with and without parameter
domains 
the results in tables xiii and xiv show that using parameter domains can still give very
significant improvements in performance  over and above those obtained through the use
of better search strategies  for example  the use of parameter domains provided an    fold
speedup for trains   for the s oc zlifo strategy  in this particular problem the speedup
 on all metrics  was the result of pruning      plans  more than half of those generated 
during the search   and recognizing     unsafe conditions as redundant  evidently  the
effect of this pruning is amplified by an order of magnitude in the overall performance 
because of the futile searches that are cut short  note that the speedups for trains    are
   

figerevini   schubert
roughly comparable  within a factor of    to those obtained for problems in the previous set
with comparable initial diculty  e g   see move boxes   and move boxes a in table xii  
this again points to a rather consistent correlation between problem diculty and speedups
obtainable using parameter domains  the constant domain ratios are also compatible with
the more or less invariant speedups here  though this is of little import  given the earlier
results  for s oc lcfr the gains appear to be less  though the single result showing
a     fold speedup provides only anecdotal evidence for such a conclusion  trains  and
trains  remained too dicult for solution by lcfr  similar gains were observed for the
s oc lc strategies where the best observed gain in the trains domain was a     fold
speedup for trains   in any case  all results confirm the effectiveness of the parameterdomains technique 
tables xv and xvi are again for the  typed  version of trains  in this case parameter
typing gave modest improvements in the absence of parameter domains  and  in contrast
with the results for trains  under the default search strategy  significant deterioration in
their presence  while we do not know how to account for these results in detail  it seems
clear that contrary effects are involved  on the one hand  typing does tend to help in that
it tends to limit choices of parameter values to  sensible  ones  for example  a precondition
 engine  eng  will be satisfiable only through use of  start   and the initial state will thus
constrain  eng to assume sensible values  on the other hand  adding type preconditions
will tend to broaden the search space  by adding further open conditions to the aw list 
the lesson from the  typed  experiments appears to be that it is best not to supply
explicit type constraints on operator parameters  instead using our automated method of
calculating and updating domains to constrain parameter bindings 

   conclusions and further work

we began by exploring some simple  domain independent improvements to search strategies
in partial order planning  and then described a method of using precomputed parameter domains to prune the search space  we now summarize our conclusions about these techniques
and then point to promising directions for further work 

    improving search

our proposed improvements to search strategies were based on the one hand on a carefully
considered choice of terms in the a  heuristic for plan selection  and on the other on a
preference for choosing open conditions that cannot be achieved at all or can be achieved
in only one way  with a default lifo prioritization of other open conditions   since the
plan refinements corresponding to uniquely achievable goals are logically necessary  we have
termed the latter strategy a zero commitment strategy  one advantage of this technique
over other similar strategies is that it incurs a lower computational overhead 
our experiments based on modifications of ucpop indicate that our strategies can give
large improvements in planning performance  especially for problems that are hard for
ucpop  and its  relatives   to begin with  the best performance was achieved when our
strategies for plan selection and goal selection were used in combination  in practical terms 
we were able to solve nearly every problem we tried from the ucpop test suite in a fraction
of a second  except for fixit  which required      seconds   where some of these problems
   

fiaccelerating partial order planners
previously required minutes or were unsolvable on the same machine  this included a
sucient variety of problems to indicate that our techniques are of broad potential utility 
further  our results suggest that zero commitment is best supplemented with a lifo
strategy for open conditions achievable in multiple ways  rather than a generalization of
zero commitment favoring goals with the fewest children  this somewhat surprising result
might be thought to be due to the way in which the designer of a domain orders the
preconditions of operators  i e   the  natural  ordering of preconditions may correlate with
the best planning order  giving a fortuitous advantage to a lifo strategy relative to a
strategy like lc   
however  some preliminary experiments we performed with randomized preconditions
for t of h  and trains  indicate otherwise  in   randomizations of the preconditions of
t of h   both lc and zlifo were slowed down somewhat  by average factors of        
and           in terms of plans expanded  cpu time used  respectively   in both cases 
s oc was used for plan search   this still left zlifo with a performance advantage of
a factor of    in terms of plans created and    in terms of cpu time  for trains  the
performance of lc greatly deteriorated in   out of   cases  by a factor close to    in terms
of both plans and time   while that of zlifo actually improved marginally  this now left
zlifo with an average performance advantage over lc  whereas it had been slightly slower
in the unrandomized case    a factor of     in terms of plans and     in terms of cpu time
 though these values are very unreliable  in view of the fact that the standard deviations
are of the same order as the means  
despite these results we believe that a satisfactory understanding of the dependence of
aw selection strategies on the order of operator preconditions will require a more extensive
experimental investigation  we are currently undertaking this work 

    using parameter domains

we described an implemented  tractable algorithm for precomputing parameter domains of
planning operators  relative to given initial conditions  we showed how to use the precomputed domains during the planning process to prune non viable actions and bogus threats 
and how to update them dynamically for maximum effect 
the idea of using precomputed parameter domains to constrain planning was apparently
first proposed in a technical report by goldszmidt et al          this contains the essential
idea of accumulating domains by forward propagation from the initial conditions  though
the report only sketches a single sweep propagation process from the initial conditions
to the goals  the implemented rockwell planner  rnlp  handles cyclic operator graphs 
repeatedly propagating bindings until quiescence  much as in our algorithm  our algorithm
deals with the additional complexities of conditional effects and equalities  and in semiautomated fashion with quantification  and appears to be more ecient  smith        
other distinctive features of our work are the method of incrementally refining domains
    this was suggested to us by david smith as well as mike williamson  williamson tried zlifo with  
randomized versions of t of h   and reported a large performance degradation  williamson   hanks 
       we recently ran these versions using our implementation  obtaining far more favorable results
 three of the five versions were easier to solve than the original version of t of h   while the other two
versions slowed down zlifo by a factor of      and      in terms of plans explored  

   

figerevini   schubert
during planning  the theoretical analysis of our algorithm  and the systematic experimental
tests 
another closely related study is that of yang and chan         who used hand supplied
parameter domains in planning much as we use precomputed domains  an interesting
aspect of their work is the direct use of sets of constants as variable bindings  for instance 
in establishing a precondition  p  x  using an initial state containing  p a    p b  and
 p c   they would bind  x to fa  b  cg rather than to a specific constant  they refine
these  noncommittal  bindings during planning much as we refine variable domains  and
periodically use constraint satisfaction methods to check their consistency with current
eq neq constraints  they conclude that delaying variable bindings works best for problems
with low solution densities  while degrading performance for some problems with high
solution densities   and that the optimal frequency of making consistency checks depends on
whether dead ends tend to occur high or low in the search tree  our work is distinguished
from theirs by our method of precomputing parameter domains  our use of specific bindings
when matching initial conditions to ocs  our use of parameter domains in threat detection
and resolution  and our handling of the enriched syntax of ucpop operators as compared
snlp operators 
judging from the examples we have experimented with  our techniques are well suited
to nontrivial problems that involve diverse types of objects  relations and actions  and significant logical interdependencies among the steps needed to solve a problem  when used in
conjunction with the default search strategy of ucpop  our method gave significant speedups
for nontrivial problems  reaching a speedup factor of     in the trains transportation planning domain  and more than      for the hardest strips world problem we tried   when
combined with our s oc and zlifo search strategies  the parameter domain technique
still gave speedups by a factor of around    for some trains problems  though our implementation is aimed at a ucpop style planner  essentially the same techniques would be
applicable to many other planners 
we also found the parameter domain precomputations to be a very useful debugging
aid  in fact  the domain precomputation for our initial formulation of the trains world
immediately revealed several errors  for instance  the domain of the  eng parameter of
mv engine turned out to contain oranges  bananas  and an oj factory  indicating the need
for a type constraint on  eng   without this  transportation problems would have been
solvable without the benefit of engines and trains   another immediately apparent problem
was revealed by the parameter domains for  city  and  city  in mv engine  the domain
for  city  excluded elmira  and that for  city  excluded avon  the obvious diagnosis
was that we had neglected to assert both  connected c  c   and  connected c  c   for
each track connecting two cities  furthermore  the parameter domains can quickly identify
unreachable operators and goals in some cases  for instance  without the make oj operator 
the computed domains show that the ld oj operator is unreachable  and that a goal like
 and  oj  oj   at  oj bath    getting some orange juice to bath  is unattainable  the
parameter domain for  oj will be empty  
of course  running the planner itself can also be used for debugging a formalization  but
planning is in general far more time consuming than our form of preprocessing  especially
if the goal we pose happens to be unachievable in the formalization    and the trace of
   

fiaccelerating partial order planners
an anomalous planning attempt can be quite hard to interpret  compared to a listing of
parameter domains  obtained in a fraction of a second 

    further work

first of all  some additional experimentation would be of interest  to further assess and
perhaps refine our search strategies  some of this experimentation might focus on threathandling strategies  including the best general form of an attenuated uc term in plan
selection  and the best way to combine threat selection with open condition selection  the
preference for definite threats over open conditions used by zlifo does appear to be a
good default according to our experience  but the tileworld experiments indicated that a
re ordering of priorities between threats and open conditions is sometimes desirable  concerning the choice of a uc related term for inclusion in the heuristic for plan selection  we
should mention that we have briey tried using s oc uc   where uc is the number of
definite threats  but did not obtain significant uniform improvements 
one promising direction for further development of our search strategy is to make the
zero commitment strategy apply more often by finding ways of identifying false options as
early as possible  that is  if a possible action instance  obtained by matching an open
condition against available operators as well as against existing actions  is easily recognizable as inconsistent with the current plan  then its elimination may leave us with a single
remaining match and hence an opportunity to apply the zero commitment strategy 
one way of implementing this strategy would be to check at once  before accepting
a matched action as a possible way to attain an open condition  whether the temporal
constraints on that action force it to violate a causal link  or alternatively  force its causal
link to be violated  in that case the action could immediately be eliminated  perhaps
leaving only one  or even no  alternative  this could perhaps be made even more effective
by broadening the definition of threats so that preconditions as well as effects of actions
can threaten causal links  and hence bring to light inconsistencies sooner  note that if a
precondition of an action is inconsistent with a causal link  it will have to be established
with another action whose effects violate the causal link  so the precondition really poses a
threat from the outset 
two possible extensions to our parameter domain techniques are  i  fully automated
handling of universally quantified preconditions and effects  disjunctions and facts in the
preprocessing algorithm  and  ii  more  intelligent  calculation of domains  by applying a
constraint propagation process to the sets of ground predications that have been matched to
the preconditions of an operator  this can be shown to yield tighter domains  though at some
computational expense  blum and furst        recently explored a similar idea  but rather
than computing parameter domains  they directly stored sets of ground atoms that could be
generated by one operator application  starting in the initial state   two successive operator
applications  and so on  and then used these sets of atoms  and exclusivity relations among
the atoms and the actions connecting them  to guide the regressive search for a plan  the
algorithm they describe does not allow for conditional effects  though this generalization
appears entirely possible  for the examples used in their tests  they obtained dramatic
speedups 
d

   

d

figerevini   schubert
finally  we are also working on another preprocessing technique  namely the inference
of state constraints from operator specifications  one useful form of constraint is implicational  e g    implies  on  x  y   not  clear  y      and another is single valuedness
conditions  e g    on  x  y  may be single valued in both  x and  y   we conjecture that
such constraints can be tractably inferred and used for further large speedups in domainindependent  well founded planning 
in view of the results we have presented and the possibilities for further speedups we
have mentioned  we think it plausible that well founded  domain independent planners may
yet become competitive with more pragmatically designed planners 

acknowledgements

this work amalgamates and extends two conference papers on improving search  schubert
  gerevini        and using computed parameter domains  gerevini   schubert        to
accelerate partial order planners  the research was supported in part by rome lab contract f         c      and nato collaborative research grant crg        some of the
work by ag was carried out at irst        povo  tn   italy  and at the cs department
of the university of rochester  rochester ny usa  the helpful comments and perceptive
questions of marc friedman  david joslin  rao kambhampati  colm o riain  martha pollack  david smith  dan weld  mike williamson  and of associate editor michael wellman
and the anonymous reviewers are gratefully acknowledged 

appendix a  proofs of the theorems 
theorem   the find parameter domains algorithm is correct for computing parameter

domains of ucpop style sets of operators  without quantification  disjunction  or facts  
initial conditions  and  possibly  goal conditions 
proof  as a preliminary observation  the intersected parameter domains computed iteratively by the algorithm eventually stabilize  since they grow monotonically and there
are only finitely many constants that occur in the initial conditions and in operator effects 
thus the algorithm terminates 
in order to prove correctness we need to show that if there exists a valid sequence
a  a     a of actions  operator instances  starting with a     start   and if a is an
instance of the operator op  then the bindings that the parameters of op received in instance
a are eventually added to the relevant intersected domains of op  where  relevant  refers
to the when clauses of op whose preconditions are satisfied at the beginning of a    we
prove this by induction on n 
if n      then a   a     start   so there are no parameters and the claim is trivially
true 
now assume that the claim holds for n              k  then consider any operator instance
a    that can validly follow a  a     a   i e   such that a    is an instance of an operator
op whose primary preconditions  possibly along with some secondary ones  are satisfied at
the end of a  a     a   let p be such a precondition  and write its instance in a    as
 p c  c       then  p c  c      must be an effect of some a   where    i  k  if i    
n

n

n

n

n

k

k

k

k

k

i

   

fiaccelerating partial order planners
then  p c  c      holds in the initial state  and hence this predication is propagated and
successfully matched to p in the initial propagation phase of find parameter domains  if
i      then a is an instance of some operator op  and  p c  c      is the corresponding
instance of some effect  p t  t      of op   where each t is either a parameter of op  or is
equal to cj  diagrammatically 
i

j

a        a
j

i

     

a

a   
j

k

k

op 

op

effect  p t  t            precond p
 p c  c      

 p c  c      

by the induction assumption  the bindings of the parameters in a are eventually added
to the relevant intersected domains of op   this also implies that the intersected domains
of op  become nonempty  and so the effect  p t  t      is eventually propagated  where
any variables among the t have the corresponding constant cj in the relevant intersected
domain  consequently  much as in the case i      effect  p t  t      is successfully matched
to precondition p of op at some stage of the propagation  given these observations  it is
clear that for both i     and i      p will be marked  matched  in op eventually  and
furthermore any parameters of op that occur in p will have the bindings resulting from
the unification with  p c  c      added to the appropriate individual domains associated
with p 
this argument applies to all preconditions of op satisfied in its instance a      in particular to all the primary preconditions  since these are all marked  matched   the algorithm
will compute intersected domains for all op parameters that occur in them  in view of the
individual domain updates just confirmed  and since individual domains grow monotonically  these intersected domains will eventually contain the parameter bindings of a     
for instance  if a parameter  x of op occurs in a primary precondition and is bound to
c in a      we have shown that c will eventually be added to the intersected domain of
 x associated with the primary when clause of op  if a parameter does not occur in the
primary preconditions of op  then its intersected domain is set to t at the outset  and this
implicitly contains whatever binding the parameter has in a     
a very similar argument can be made for any secondary when clause of op whose preconditions are also satisfied for a      again  all preconditions of the secondary clause 
as well as the primary preconditions  will be marked  matched   and so for any parameter
occurring in these combined preconditions  its intersected domain  relative to the secondary
clause  will be updated to include its binding in a      for parameters of op not occurring
in any of these preconditions  the intersected domains will again be set to t initially  and
this implicitly contains any possible binding  finally  we note that since the intersected
domains relative to both primary and secondary when clauses grow monotonically  the augmentations of intersected domains we have just confirmed is permanent   in the case of
t domains  these remain t  
we leave some additional details concerned with the ultimate use of eq preconditions in
find parameter domains to the reader   
i

j

k

k

k

k

k

k

   

figerevini   schubert

theorem   algorithm find parameter domains can be implemented to run in o mn n  n  
n    time and o mn   space in the worst case  where m is the number of constants in the
problem specification  n is the combined number of preconditions for all operators  and
goals  if included   and n is the combined number of operator effects  including those of
p

e

e

p

p

p

e

 start   

proof  the time complexity of find parameter domains can be determined as the sum
of     the cost of all the unifications performed      the costs of all the individual domain
updates attempted  and     the cost of all the intersected domain updates attempted  we
estimate an upper bound for each of these terms under the following assumptions 

 a  the unification of any operator effect with any operator precondition requires constant
time 
 b  there is a fixed upper bound on the number of arguments that a predicate  in a
precondition or effect  can have  it follows that o n   is an upper bound on the total
number of intersected domains   
 c  individual domains and intersected domains are stored in hash tables  indexed by the
constants in the domain   so  we can check whether an element belongs to a particular
 individual or intersected  domain  and possibly add it to that domain essentially in
constant time  furthermore for each individual and intersected domain  appropriate
data structures are used to keep track of the  possibly empty  set of new elements
that have been added to the domain in the last update attempt 
    for any particular intersected domain of any particular operator  there can be at
most m updates of this domain  each such update causes all of the effects of the whenclause to which the intersected domain belongs to be propagated  an upper bound on this
number is n   each propagated effect may then be unified with o n   preconditions  thus
the o m  updates of an intersected domain may cause o mn n   unifications  hence from
 b   the overall number of unifications caused by the propagation of intersected domains
to individual domains is o mn  n    to these unifications we have to add those which are
initially performed between the effects of  start  and the preconditions of the operators 
there are o mn   such unifications  and so they do not increase the previous upper bound
on the number of unifications  thus  from  a   the cost of all of the unifications performed
by the algorithm is o mn  n   
    each unification is potentially followed by an attempt to update the individual
domain s  of the relevant parameter s   however  with assumption  c  the number of such
attempts is limited to those where the set of new elements in the intersected domain s 
of the unifying effect is  are  not empty  furthermore  when we attempt to update an
individual domain d by performing the union of a relevant intersected domain d and d  
only the subset of the new elements of d need to be added to d  if they are not already
there   thus  since any intersected domain grows monotonically  from  b  and  c  we have
that the overall cost of all the update attempts for one particular individual domain caused
e

e

p

e

e

p

p

p

e

p

i

i

i

i

i

    note that if a parameter appears in a precondition of a when clause  but in none of its effects  then the
intersected domain of the parameter will not be propagated by the algorithm  hence in implementing
the algorithm we can ignore such parameters 

   

fiaccelerating partial order planners
by one particular effect is o m   but in the worst case one effect can unify with all the
o n   preconditions of all the operators  yielding an overall bound on all of the attempts
to update the individual domains of o mn n   
    there can be an attempt to update a particular intersected domain for each relevant
individual domain update  and each relevant individual domain can be updated o m  times
 because the domains grow monotonically   therefore from  b  there are at most o mn  
attempts to update one intersected domain  by  c  the total cost of these attempts is
o mn     because checking whether a new element of an individual domain belongs to all
the other o n   relevant individual domains takes o n   time  so  since from  b  there
are no more than o n   intersected domains  the total cost incurred by the algorithm for
updating all of the intersected domains is o mn n    
it follows that the time complexity of find parameter domains is 
o mn n     o mn n     o mn n     o mn n  n   n    
the space complexity bound is easily derived from  b   and from the fact that for each
when clause at most o m  constants are stored   
p

e

p

p

p

p

p

e

e

p

e

p

references

e

p

e

p

p

e

p

e

allen  j     schubert  l          the trains project  tech  rep       dept  of computer
science  univ  of rochester  rochester  ny  also slightly revised as language and
discourse in the trains project  in a  ortony  j  slack  and o  stock  eds    communication from an artificial intelligence perspective  theoretical springer verlag 
heidelberg  pp         
allen  j   schubert  l   ferguson  g   heeman  p   hwang  c   kato  t   light  m   martin 
n   miller  b   poesio  m     traum  b          the trains project  a case study
in building a conversational planning agent  experimental and theoretical artificial
intelligence          
barrett  a   golden  k   penberthy  s     weld  d          ucpop user s manual  tech 
rep            dept  of computer science and engineering  university of washington 
seattle  wa       
blum  a     furst  m          fast planning through planning graph analysis  in proceedings
of the fourteenth international joint conference on artificial intelligence  ijcai     
pp            montreal  ca  morgan kaufmann 
chapman  d          planning for conjunctive goals  artificial intelligence                  
currie  k     tate  a          o plan  the open planning architecture  artificial intelligence         
fikes  r     nilsson  n          strips  a new approach to the application of theorem
proving to problem solving  artificial intelligence             
georgeff  m     lansky  a          reactive reasoning and planning  in proceedings of the
sixth national conference of the american association for artificial intelligence  pp 
        seattle  wa  morgan kaufmann 
   

figerevini   schubert
gerevini  a     schubert  l k          computing parameter domains as an aid to planning 
in proc  of the  rd int  conf  on artificial intelligence planning systems  aips     
pp         menlo park  ca  the aaai press 
goldszmidt  m   darwiche  a   chavez  t   smith  d     white  j          decision theory
for crisis management  tech  rep  rl tr         rome laboratory 
green  c          application of theorem proving to problem solving  in proceedings of
the first international joint conference on artificial intelligence  ijcai      pp 
        
joslin  d          personal communication 
joslin  d     pollack  m          least cost aw repair  a plan refinement strategy for
partial order planning  in proceedings of the twelfth national conference of the
american association for artificial intelligence  aaai      pp            seattle 
wa  morgan kaufmann 
kambhampati  s   knoblock  c  a     yang  q          planning as refinement search  a
unified framework for evaluating design tradeoff in partial order planning  artificial
intelligence  special issue on planning and scheduling           
korf  r          linear space best first search  summary of results  in proceedings of
the tenth national conference of the american association for artificial intelligence
 aaai      pp          
mcallester  d     rosenblitt  d          systematic nonlinear planning  in proceedings
of the ninth national conference on artificial intelligence  aaai      pp         
anheim  los angeles  ca  morgan kaufmann 
nilsson  n          principles of artificial intelligence  tioga pub  co   palo alto  ca 
penberthy  j     weld  d          ucpop  a sound  complete  partial order planner
for adl  in nebel  b   rich  c     swartout  w   eds    proceedings of the third
international conference on principles of knowledge representation and reasoning
 kr     pp          boston  ma  morgan kaufmann 
peot  m  a     smith  d  e          threat removal strategies for partial order planning 
in proceedings of the eleventh national conference of the american association for
artificial intelligence  aaai      pp          washington  d c  morgan kaufmann 
schubert  l     gerevini  a          accelerating partial order planners by improving
plan and goal choices  in proc  of the  th ieee int  conf  on tools with artificial
intelligence  pp          herndon  virginia  ieee computer society press 
smith  d  e     peot  m  a          postponing threats in partial order planning  in
proceedings of the eleventh national conference of the american association for artificial intelligence  aaai      pp          washington  d c  morgan kaufmann 
smith  d  e          personal communication 
   

fiaccelerating partial order planners
srinivasan  r     howe  a          comparison of methods for improving search eciency
in a partial order planner  in proceedings of the fourteenth international joint conference on artificial intelligence  ijcai      pp            
weld  d          an introduction to least commitment planning  ai magazine         
      
wilkins  d          practical planning  extending the classical ai planning paradigm 
morgan kaufmann  san mateo  ca 
williamson  m     hanks  s          flaw selection strategies for value directed planning  in
proceedings of the third international conference on artificial intelligence planning
systems  pp          
yang  q     chan  a y m          delaying variable binding commitments in planning  in
proceedings of the second international conference on artificial intelligence planning
systems  pp          

   

fi