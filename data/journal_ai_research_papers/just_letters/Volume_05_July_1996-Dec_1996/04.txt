journal of artificial intelligence research                 

submitted       published      

learning first order definitions of functions
j  r  quinlan

quinlan cs su oz au

basser department of computer science
university of sydney
sydney      australia

abstract

first order learning involves finding a clause form definition of a relation from examples
of the relation and relevant background information  in this paper  a particular first order
learning system is modified to customize it for finding definitions of functional relations 
this restriction leads to faster learning times and  in some cases  to definitions that have
higher predictive accuracy  other first order learning systems might benefit from similar
specialization 

   introduction
empirical learning is the subfield of ai that develops algorithms for constructing theories
from data  most classification research in this area has used the attribute value formalism 
in which data are represented as vectors of values of a fixed set of attributes and are labelled
with one of a small number of discrete classes  a learning system then develops a mapping
from attribute values to classes that can be used to classify unseen data 
despite the well documented successes of algorithms developed for this paradigm  e g  
michie  spiegelhalter  and taylor        langley and simon         there are potential
applications of learning that do not fit within it  data may concern objects or observations
with arbitrarily complex structure that cannot be captured by the values of a predetermined
set of attributes  similarly  the propositional theory language employed by attribute value
learners may be inadequate to express patterns in such structured data  instead  it may
be necessary to describe learning input by relations  where a relation is just a set of tuples
of constants  and to represent what is learned in a first order language  four examples of
practical learning tasks of this kind are 

 speeding up logic programs  zelle and mooney         the idea here is to learn a

guard for each nondeterministic clause that inhibits its execution unless it will lead
to a solution  input to the learner consists of a prolog program and one or more
execution traces  in one example dolphin  the system cited above  transformed a
program from complexity o n   to o n    

 learning search control heuristics  leckie and zukerman         formulation of pref 

erence criteria that improve eciency in planning applications has a similar avor 
one task investigated here is the familiar  blocks world  in which varying numbers of
blocks must be rearranged by a robot manipulator  each input to learning concerns
a particular situation during search and includes a complete description of the current planning state and goals  as the amount of this information increases with the

c      ai access foundation and morgan kaufmann publishers  all rights reserved 

fiquinlan

number of blocks and their inter relationships  it cannot be encoded as a fixed set of
values 
 recovering software specifications  cohen        describes an application based on a
software system consisting of over a million lines of c code  part of the system implements virtual relations that compute projections and joins of the underlying base
relations  and the goal is to reconstruct their definitions  input to learning consists of
queries  their responses  and traces showing the base relations accessed while answering the queries  the output is a logical description of the virtual relation  since this
involves quantified variables  it lies beyond the scope of propositional attribute value
languages 
 learning properties of organic molecules  muggleton  king  and sternberg       
srinivasan  muggleton  sternberg  and king         the approach to learning in
these papers is based on representing the structure of the molecules themselves in
addition to properties of molecules and molecule segments  the latter paper notes
the discovery of a useful indicator of mutagenicity expressed in terms of this structure 
the development of learning methods based on this more powerful relational formalism
is sometimes called inductive logic programming  muggleton        lavrac and dzeroski 
      de raedt         input typically consists of tuples that belong  or do not belong 
to a target relation  together with relevant information expressed as a set of background
relations  the learning task is then to formulate a definition of the target relation in terms
of itself and the background relations 
this relational learning task is described in more detail in the following section  several
algorithms for relational learning have been developed recently  and section   introduces
one such system called foil  quinlan         while foil can be used with relations of
any kind  one particularly common use of relations is to represent functions  changes to
foil that in effect customize it for learning functional relations are outlined in section   
several comparative studies  presented in section    show that this specialization leads to
much shorter learning times and  in some cases  to more accurate definitions  related work
on learning functional relations is discussed in section    and the paper ends with some
conclusions from this study and directions for further development 

   relational learning

an n ary relation re consists of a set of n tuples of ground terms  here constants   all
constants in the ith position of the tuples belong to some type  where types may be differentiated or all constants may be taken to belong to a single universal type 
as an alternative to this extensional definition as a  possibly infinite  set  a relation can
be specified intensionally via an n argument predicate ri defined by a prolog program  if

hc    c       cn i   re if and only if ri  c    c         cn   is true
for any constants fci g  then the intensional and extensional definitions are equivalent  for
convenience  the subscripts of re and ri will be omitted and r will be used to denote
either the set of tuples or the predicate 
   

filearning first order definitions of functions

input to a relational learning task consists of extensional information about a target
relation r and extensional or intensional definitions of a collection of background relations 
examples of tuples known to belong to the target relation are provided and  in most cases 
so are examples of tuples known not to belong to r  the goal is to learn a prolog program
for r that covers all tuples known to belong to r but no tuples known not to belong to r
or  in other words  a program that agrees with the extensional information provided about
r 
many relations of interest are infinite  an alternative to selecting examples that belong
or do not belong to r is to define a finite vocabulary v and to specify relations with respect
to this vocabulary  that is  r is represented as the finite set of tuples  all constants in
which belong to v   since this specification of r is complete over the vocabulary  the tuples
that do not belong to r can be inferred by the closed world assumption as the complement
of the tuples in r 
a function f  x    x         xk   of k arguments can be represented by a k   ary relation
f  x    x         xk   xk     where  for each tuple in f   the value of the last argument is the
result of applying f to the first k arguments   rouveirol        proves that this attening
can be used to remove all non constant function symbols from any first order language  
such functional relations have an additional property that for any constants fc    c        ck g
there is exactly one value of ck   such that hc    c         ck   i belongs to f  
as an example  consider the three argument predicate append a b c  whose meaning is
that the result of appending list a to list b is list c   the corresponding relation append is
infinite  but a restricted vocabulary can be defined as all at lists containing only elements
from f     g whose length is less than or equal to    there are    such lists
                                                 

and          tuples of lists  with respect to this vocabulary  append consists of     of these
  tuples  viz  

h           i  h           i       h                 i       h                   i 
there is also a background relation components  where components a b c  means that list
a has head b and tail c  the goal is then to learn an intensional definition of append given
the background relation components  a suitable result might be expressed as
append     a a  
append a b c     components a d e   append e b f   components c d f  

which is recognizable as a prolog definition of append 
   in prolog  append can be invoked with any combination of its arguments bound so as to find possible
values for the unbound arguments  here and in section      however  append is treated as a function
from the first two arguments to the third 

   

fiquinlan

initialization 
definition    null program
remaining    all tuples belonging to target relation r
while remaining is not empty
   grow a new clause   
clause    r a  b        while clause covers tuples known not to belong to r
   specialize clause   
find appropriate literal s  l
add l to body of clause
remove from remaining tuples in r covered by clause
add clause to definition
figure    outline of foil

   description of foil

in common with many first order learning systems  foil requires that the background relations are also defined extensionally by sets of tuples of constants   although the intensional
definition is learned from a particular set of examples  it is intended to be executable as a
prolog program in which the background relations may also be specified intensionally by
definitions rather than by sets of ground tuples  for instance  although the append definition
above might have been learned from particular examples of lists  it will correctly append
arbitrary lists  provided that components is specified by a suitable clausal definition   the
applicability of learned definitions to unseen examples cannot be guaranteed  however  bell
and weber        call this the open domain assumption  
the language in which foil expresses theories is a restricted form of prolog that omits
cuts  fail  disjunctive goals  and functions other than constants  but allows negated literals
not l        this is essentially the datalog language specified by ullman         except that
there is no requirement that all variables in a negated literal appear also in the head or in
another unnegated literal  foil interprets not using negation as failure  bratko        

    broad brush overview
as outlined in figure    foil uses the separate and conquer method  iteratively learning
a clause and removing the tuples in the target relation r covered by the clause until none
remain  a clause is grown by repeated specialization  starting with the most general clause
   prominent exceptions include focl  pazzani and kibler         filp  bergadano and gunetti        
and foidl  mooney and califf         that allow background relations to be defined extensionally  and
progol  muggleton         in which information about all relations can be in non ground form 

   

filearning first order definitions of functions

head and adding literals to the body until the clause does not cover any tuples known not
to belong to r 
literals that can appear in the body of a clause are restricted by the requirement that
programs be function free  other than for constants appearing in equalities  the possible
literal forms that foil considers are 

 q x    x         xk   and not  q x    x         xk     where q is a relation and the xi s de 

note known variables that have been bound earlier in the clause or new variables  at
least one variable must have been bound earlier in the partial clause  either by the
head or a literal in the body 

 xi  xj and xi   xj   for known variables xi and xj of the same type 
 xi  c and xi  c  where xi is a known variable and c is a constant of the appropriate

type  only constants that have been designated as suitable to appear in a definition
are considered   a reasonable definition for append might reference the null list     but
not an arbitrary list such as       

 xi  xj   xi   xj   xi  t  and xi   t  where xi and xj are known variables with
numeric values and t is a threshold chosen by foil 

if the learned definition must be pure prolog  negated literal forms not  q       and xi      
can be excluded by an option 
clause construction is guided by different possible bindings of the variables in the partial
clause that satisfy the clause body  if the clause contains k variables  a binding is a k tuple
of constants that specifies a value for all variables in sequence  each possible binding is
labelled  or   according to whether the tuple of values for the variables in the clause head
does or does not belong in the target relation 
as an illustration  consider the tiny task of constructing a definition of plus a b c  
meaning a b   c  using the background relation dec a b   denoting b   a    the
vocabulary is restricted to just the integers       and    so that plus consists of the tuples

h     i  h     i  h     i  h     i  h     i  h     i
and dec contains only h   i and h   i 
the initial clause consists of the head
plus a b c    

in which each variable is unique  the labelled bindings corresponding to this initial partial
clause are just the tuples that belong  or do not belong  to the target relation  i e  

h     i 
h     i  
h     i  
h     i  
h     i  

h     i 
h     i  
h     i  
h     i  
h     i  

h     i 
h     i  
h     i  
h     i  
h     i  

h     i 
h     i  
h     i  
h     i  

   

h     i 
h     i  
h     i  
h     i  

h     i 
h     i  
h     i  
h     i  

 

fiquinlan

foil repeatedly tries to construct a clause that covers some tuples in the target relation

r but no tuples that are definitely not in r  this can be restated as finding a clause that

has some  bindings but no   bindings  so one reason for adding a literal to the clause is
to move in this direction by increasing the relative proportion of  bindings  such gainful
literals are evaluated using an information based heuristic  let the number of  and  
bindings of a partial clause be n and n  respectively  the average information provided
by the discovery that one of the bindings has label  is
  
n

 
i  n   n       log  n   n  bits 
if a literal l is added  some of these bindings may be excluded and each of the rest will give
rise to one or more bindings for the new partial clause  suppose that k of the n bindings
are not excluded by l  and that the numbers of bindings of the new partial clause are m
and m  respectively  if l is chosen so as to increase the proportion of  bindings  the total
information gained by adding l is then

k   i  n  n     i  m   m     bits 
consider the result of specializing the above clause by the addition of the literal a   
all but nine of the bindings are eliminated because the corresponding values of the variables
do not satisfy the new partial clause  the bindings are reduced to

h     i  h     i  h     i 
h     i   h     i   h     i   h     i   h     i   h     i  
in which the proportion of  bindings has increased from      to      the information
gained by adding this literal is therefore     i           i         or about   bits  adding the
further literal b c excludes all the   bindings  giving a complete first clause
plus a b c     a    b c 

or  as it would be more commonly written 
plus   b b  

this clause covers three tuples of plus which are then removed from the set of tuples to be
covered by subsequent clauses  at the commencement of the search for the second clause 
the head is again plus a b c  and the bindings are now

h     i 
h     i  
h     i  
h     i  
h     i  

h     i 
h     i  
h     i  
h     i  
h     i  

h     i 
h     i   h     i   h     i   h     i  
h     i   h     i   h     i   h     i  
h     i   h     i   h     i   h     i  
h     i  
 

the above literals were added to the body of the first clause because they gain information  a quite different justification for adding a literal is to introduce new variables that
may be needed in the final clause  determinate literals are based on an idea introduced
   

filearning first order definitions of functions

by golem  muggleton and feng         a determinate literal is one that introduces new
variables so that the new partial clause has exactly one binding for each  binding in the
current clause  and at most one binding for each   binding  determinate literals are useful because they introduce new variables  but neither reduce the potential coverage of the
clause nor increase the number of bindings 
now that the  bindings do not include any with a    the literal dec a d  is determinate
because  for each value of a  there is one value of d that satisfies the literal  similarly  since
the  bindings contain none with c    the literal dec c e  is also determinate 
in figure    the literals l added by foil at each step are

 the literal with greatest gain  if this gain is near the maximum possible
 namely n  i  n   n       otherwise
 all determinate literals found  otherwise
 the literal with highest positive gain  otherwise
 the first literal investigated that introduces a new variable 
at the start of the second clause  no literal has near maximum gain and so all determinate
literals are added to the clause body  the partial clause
plus a b c     dec a d   dec c e  

has five variables and the bindings that satisfy it are

h         i  h         i  h         i 
h         i   h         i   h         i   h         i   h         i  
the literal plus b d e   which uses these newly introduced variables  is now satisfied by all
three  bindings but none of the   bindings  giving a complete second clause
plus a b c     dec a d   dec c e   plus b d e  

all tuples in plus are covered by one or other of these clauses  so they constitute a complete
intensional definition of the target relation 

    details omitted
foil is a good deal more complex than this overview would suggest  since they are not

important for this paper  matters such as the following are not discussed here  but are
covered in  quinlan and cameron jones              

 recursive soundness  if the goal is to be able to execute the learned definitions as

ordinary prolog programs  it is important that they terminate  foil has an elaborate
mechanism to ensure that any recursive literal  such as plus b d e  above  that is
added to a clause body will not cause problems in this respect  at least for ground
queries 
   

fiquinlan

 pruning  in practical applications with numerous background relations  the number

of possible literals l that could be added at each step grows exponentially with the
number of variables in the partial clause  foil employs some further heuristics to limit
this space  such as golem s bound on the depth of a variable  muggleton and feng 
       more importantly  some regions of the literal space can be pruned without
examination because they can be shown to contain neither determinate literals  nor
literals with higher gain than the best gainful literal found so far 
 more complete search  as presented above  foil is a straightforward greedy hillclimbing algorithm  in fact  because foil can sometimes reach an impasse in its
search for a clause  it contains a limited non chronological backtracking facility to
allow it to recover from such situations 
 simplifying definitions  the addition to the partial clause of all determinate literals
found may seem excessive  however  as a clause is completed  foil examines each
literal in the clause body to see whether it could be discarded without causing the
simpler clause to match tuples not in the target relation r  similarly  when the
definition is complete  each clause is checked to see whether it could be omitted
without leaving any tuples in r uncovered  there are also heuristics that aim to
make clauses more understandable by substituting simpler literals  such as variable
equalities  for literals based on more complex relations 
 recognizing boundaries of closed worlds  some literals that appear to discriminate 
from   bindings do so only as a consequence of boundary effects attributable to a
limited vocabulary   when a definition including such literals is executed with larger
vocabularies  the open domain assumption mentioned above may be violated  foil
contains an optional mechanism for describing when literals might be satisfied by
bindings outside the closed world  allowing some literals with unpredictable behavior
to be excluded 
quinlan        and quinlan and cameron jones        summarize several applications
successfully addressed by foil  some of which are also discussed in section   

   learning functional relations
the learning approach used by foil makes no assumptions about the form of the target

relation r  however  as with append and plus above  the relation is often used to represent a
function   in any tuple of constants that satisfies r  the last constant is uniquely determined
by the others  bergadano and gunetti        show that this property can be exploited to
make the learning task more tractable 

    functional relations and foil
although foil can learn definitions for functional relations  it is handicapped in two ways 
 ground queries  foil s approach to recursive soundness assumes that only ground
queries will be made of the learned definition  that is  a definition of r x    x         xn  

   an example of this arises in section     

   

filearning first order definitions of functions

will be used to provide true false answers to queries of the form r c    c         cn    where
the ci  s are constants  if r is a functional relation  however  a more sensible query
would seem to be r c    c         cn     x    to determine the value of the function for
specified ground arguments  in the case of plus  for instance  we would not expect to ask plus           is           but rather plus     x     what is        
r c    c         cn     x    will be called the standard query for functional relations 
 negative examples  foil needs both tuples that belong to the target relation and at
least some that do not  in common with other ilp systems such as golem  muggleton
and feng         the latter are used to detect when a partial clause is still too general 
these can be specified to foil directly or  more commonly  are derived under the
closed world assumption that  with respect to the vocabulary  all tuples in r have
been given  this second mechanism can often lead to very large collections of tuples
not in r  there were nearly        of them in the append illustration earlier  every
tuple not belonging to r results in a binding at the start of each clause  so there can
be uncomfortably many bindings that must be maintained and tested at each stage
of clause development   however  functional relations do not need explicit counterexamples  even when the set of tuples belonging to r is not complete with respect to
some vocabulary   knowing that hc    c         cn i belongs to r implies that there is no
other constant c n such that hc    c         c n i is in r 
these problematic aspects of foil vis a vis functional relations suggest modifications to
address them  the alterations lead to a new system  ffoil  that is still close in spirit to its
progenitor 

    description of ffoil

since the last argument of a functional relation has a special role  it will be referred to as
the output argument of the relation  similarly  the variable corresponding to this argument
in the head of a clause is called the output variable 
the most fundamental change in ffoil concerns the bindings of partial clauses and the
way that they are labelled  a new constant   is introduced to indicate an undetermined
value of the output variable in a binding  bindings will be labelled according to the value
of the output variable  namely  if this value is correct  given the value of the earlier
constants     if the value is incorrect  and fi if the value is undetermined 
the outline of ffoil  figure    is very similar to figure    the only differences being
those highlighted  at the start of each clause there is one binding for every remaining tuple
in the target relation  the output variable has the value   in these bindings and this value
is changed only when some subsequent literal assigns a value to the variable  in the small
plus example of section      the initial bindings for the first clause are
h     i fi h     i fi h     i fi h     i fi h     i fi h     i fi
like its ancestor  ffoil also assesses potential literals for adding to the clause body as
gainful or determinate  although both concepts must be adjusted to accommodate the new
label fi  suppose that there are r distinct constants in the range of the target function 
   for this reason  foil includes an option to sample the   bindings instead of using all of them 

   

fiquinlan

initialization 
definition    null program
remaining    all tuples belonging to target relation r
while remaining is not empty
   grow a new clause   
clause    r a  b        while clause has   or fi bindings
   specialize clause   
find appropriate literal s  l
add l to body of clause
remove from remaining tuples in r covered by clause
add clause to definition
simplify final definition
add default clause
figure    outline of ffoil

each fi binding can be converted to a  binding only by changing   to the correct value
of the function  and to a   binding by changing   to any of the r     incorrect values  in
computing information gain  ffoil thus counts each fi binding as    binding and r      
bindings  a determinate literal is now one that introduces one or more variables so that  in
the new partial clause  there is exactly one binding for each current  or fi binding and at
most one binding for each current   binding  ffoil uses the same preference criterion for
adding literals l  a literal with near maximum gain  then all determinate literals  then the
most gainful literal  and finally a non determinate literal that introduces a new variable 
the first literal chosen by foil in section     was a   since this increases the concentration of  bindings from   in    to   in    with a corresponding information gain   from
ffoil s perspective  however  this literal simply reduces six fi bindings to three and so gives
no gain  as the range of plus is the set f     g  r      and so the putative concentration of
 bindings would alter from   in    to   in    the literal a c  on the other hand  causes
the value of the output variable to be determined and results in the bindings

h     i  h     i  h     i 
h     i   h     i   h     i    
this corresponds to an increase in concentration of  bindings from a notional   in    to

  in    with an information gain of about   bits  once this literal has been added to the
clause body  ffoil finds that a further literal b   eliminates all   bindings  giving the
   

filearning first order definitions of functions

complete clause
plus a b c     a c  b   

the remaining tuples of plus give the bindings

h     i fi h     i fi h     i fi
at the start of the second clause  the literals dec b d  and dec e a  are both determinate
and  when they are added to the clause  the bindings become

h         i fi h         i fi h         i fi
in which the output variable is still undetermined  if the partial clause is further specialized
by adding the literal plus e d c   the new bindings

h         i  h         i  h         i 
give the correct value for c in each case  since there are no fi or   bindings  this clause is

also complete 
one important consequence of the new way that bindings are initialized at the start of
each clause is easily overlooked  with foil  there is one   binding for each tuple that does
not belong in r  since each clause excludes all   bindings  it discriminates some tuples in
r from all tuples not in r  this is the reason that the learned clauses can be regarded as
a set and can be executed in any order without changing the set of answers to a query  in
ffoil  however  the initial bindings concern only the remaining tuples in r  so a learned
clause depends on the context established by earlier clauses  for example  suppose a target
relation s and a background relation t are defined as
s   fhv  i  hw  i  hx  i  hy  i  hz  ig
t   fhvi  hwi  hxig  

the first clause learned by ffoil might be
s a       t a  

and the remaining bindings fhy  i  hz  ig could then be covered by the clause
s a    

the latter clause is clearly correct only for standard queries that are not covered by the
first clause  as this example illustrates  the learned clauses must be interpreted in the order
in which they were learned  and each clause must be ended with a cut     to protect later
clauses from giving possibly incorrect answers to a query  since the target relation r is
functional  so that there is only one correct response to a standard query as defined above 
this use of cuts is safe in that it cannot rule out a correct answer 
both foil and ffoil tend to give up too easily when learning definitions to explain noisy
data  this can result in over specialized clauses that cover the target relation only partially 
on tasks for which the definition learned by ffoil is incomplete  a final global simplification
   

fiquinlan

phase is invoked  clauses in the definition are generalized by removing literals so long as the
total number of errors on the target relation does not increase  in this way  the accuracy of
individual clauses is balanced against the accuracy of the definition as a whole  simplifying
a clause by removing a literal may increase the number of errors made by the clause  but
this can be offset by a reduction in the number of uncovered bindings and a consequently
lower global error rate  when all clauses have been simplified as much as possible  entire
clauses that contribute nothing to the accuracy of the definition are removed 
in the final step of figure    the target relation is assumed to represent a total function 
with the consequence that a response must always be returned for a standard query  as a
safeguard  ffoil adds a default clause

r x    x         xn     c  
where c is the most common value of the function   the most common value of the output
argument of plus is    so the complete definition for this example  in normal prolog notation 
becomes
plus a   a       
plus a b c     dec b d   dec e a   plus e d c     
plus a b    

    advantages and disadvantages of ffoil

although the definitions for plus in sections     and     are superficially similar  there are
considerable differences in the learning processes by which they were constructed and in
their operational characteristics when used 

 ffoil generally needs to maintain fewer bindings and so learns more quickly  whereas

foil keeps up to    bindings while learning a definition of plus  ffoil never uses more
than   

 the output variable is guaranteed to be bound in every clause learned by ffoil  this
is not necessarily the case with foil  since there is no requirement that every variable
appearing in the head must also appear in the clause body 

 definitions found by ffoil often execute more eciently than their foil counterparts 

firstly  ffoil definitions  through the use of cuts  exploit the fact that there cannot be
more than one correct answer to a standard query  secondly  clause bodies constructed
by ffoil tend not to use the output variable until it has been bound  so there is less
backtracking during evaluation  as an illustration  the foil definition of section
    evaluates    goals in answering the query plus     x    many more than the six
evaluations needed by the ffoil definition for the same query 

there are also entries on the other side of the ledger 
   no default clause is added if each value of the function occurs only once 

   

filearning first order definitions of functions

task

bkgd
relns

append
last element
reverse
left shift
translate

 
 
  
  
  

length  
bindings
time



 

foil ffoil

          
   
  
  
   
       
   
       
   
             

length  
bindings
time



 

foil ffoil

                     
       
    
   
                     
                    
                     

    
   
   
   
    

table    results on tasks from  bratko        

 foil is applicable to more learning tasks that ffoil  which is limited to learning
definitions of functional relations 

 the implementation of ffoil is more complex than that of foil  for example  many of

the heuristics for pruning the literal search space and for checking recursive soundness
require special cases for the constant   and for fi bindings 

   empirical trials

in this section the performance of ffoil on a variety of learning tasks is summarized and
compared with that of foil  release       since the systems are similar in most respects 
this comparison highlights the consequences of restricting the target relation to a function 
times are for a dec axp          workstation  the learned definitions from the first
three subsections may be found in the appendix 

    small list manipulation programs

quinlan and cameron jones        report the results of applying foil to    tasks taken
from bratko s        well known prolog text  the list processing examples and exercises
of chapter   are attempted in sequence  where the background information for each task
includes all previously encountered relations  even though most of them are irrelevant to
the task at hand   two different vocabularies are used  all    lists of length up to   on
three elements and all     lists of length up to   on four elements 
table   describes the five functional relations in this set and presents the performance
of foil and ffoil on them  all the learned definitions are correct for arbitrary lists  with
one exception   foil s definition of reverse learned from the larger vocabulary includes the
clause
reverse a a     append a a c   del d e c  

that exploits the bounded length of lists   the times reveal a considerable advantage to
   if c is twice the length of a and e is one element longer than c while still having length     then the
length of a must be   or    in that case a is its own reverse 

   

fiquinlan

task
foil ffoil
quicksort
   
   
bubblesort    
   
table    times  sec  for learning to sort 

     
   
   
golem    
progol     

ffoil
foil

time  secs 
ratio to      
           
                 
     
   
   
        
   
    
   
    
              
     
    
    
                   
                                      

table    comparative times for quicksort task 

ffoil in all tasks except the second  in fact  for the first and last task with the larger
vocabulary  these times understate ffoil s advantage  the total number of bindings for
append is        or about    million  so a foil option was used to sample only    of the
  bindings to prevent foil exceeding available memory  had it been possible to run foil

with all bindings  the time required to learn the definition would have been considerably
longer  similarly  foil exhausted available memory on the translation task when all        
possible bindings were used  so the above results were obtained using a sample of     of
the   bindings 

    learning quicksort and bubblesort
these tasks concern learning how to sort lists from examples of sorted lists  in the first 
the target relation qsort a b  means that b is the sorted form of a  three background
relations are provided  components and append as before  and partition a b c d   meaning
that partitioning list b on value a gives the list c of elements less than a and list d of
elements greater than a  in the second task  the only background relations for learning
bsort a b  are components and lt a b   meaning a b  the vocabulary used for both tasks
is all lists of length up to   with non repeated elements drawn from f       g  there are
thus     and        bindings for each task 
both foil and ffoil learn the  standard  definition of quicksort  times shown in table
  are comparable  mainly because ffoil learns a superuous over specialized clause that is
later discarded in favor of the more general recursive clause  the outcome for bubblesort
is quite different   ffoil learns twenty times faster than foil but its definition is more
verbose 
the quicksort task provides an opportunity to compare ffoil with two other wellknown relational learning systems  like ffoil and foil  both golem  muggleton and
   

filearning first order definitions of functions

task
foil ffoil
ackermann s function
    
   
greatest common divisor      
   
table    times  sec  for arithmetic functions 

feng        and progol  release       muggleton        are implemented in c  so that
timing comparisons are meaningful  furthermore  both systems include quicksort among
their demonstration learning tasks  so it is reasonable to assume that the parameters that
control these systems have been set to appropriate values 
the four learning systems are evaluated using four sets of training examples  obtained
by varying the maximum length s of the lists and the size a of the alphabet of nonrepeating elements that can appear in the lists  as in  quinlan         denoting each set
by a pair  s  a   the four datasets are                      and        the total numbers of
possible bindings for these tasks                   and        respectively  span two orders
of magnitude  table   summarizes the execution times  required by the systems on these
datasets  neither golem nor progol completed the last task  golem exhausted the available
swap space of   mb  and progol was terminated after using nearly a day of cpu time  the
table also shows the ratio of the execution time of the latter three to the simplest dataset
       the growth in ffoil s execution time is far slower than that of the other systems 
primarily because ffoil needs only the  tuples while the others use both  and   tuples 
golem s execution time seems to grow slightly slower than foil s  while progol s growth
rate is much higher 

    arithmetic functions

the systems have been also used to learn definitions of complex functions from arithmetic 
ackermann s function
 
 
if m    
  n  
f  m  n      f  m        
if n    
  f  m      f  m  n       otherwise
provides a testing example for recursion control  the background relation succ a b  represents b a    finding the greatest common divisor of two numbers is another interesting
task  the background relation is plus  for these tasks the vocabulary consists of the integers
  to    and   to    respectively  giving    tuples in ackermann a b c  such that a  b and
c are all less than or equal to     and     tuples in gcd a b c  
as shown in table    ffoil is about    times faster than foil when learning a definition
for ackermann and about     times faster for gcd  this is due solely to ffoil s smaller
numbers of bindings  in gcd  for example  foil starts with     or       bindings whereas
ffoil never uses more than     bindings 
   diculties were experienced running golem on an axp           so all times in this table are for a
decstation          

   

fiquinlan

both foil and ffoil learn exactly the same program for ackermann s function that
mirrors the definition above  in the case of gcd  however  the definitions highlight the
potential simplification achievable with ordered clauses  the definition found by foil is
gcd a a a  
gcd a b c     plus b d a   gcd b a c  
gcd a b c     plus a d b   gcd a d c  

while that learned by ffoil  omitting the default clause  is
gcd a a a       
gcd a b c     plus a d b   gcd a d c     
gcd a b c     gcd b a c     

the last clause exploits the fact that all cases in which a is less than or equal to b have
been filtered out by the first two clauses 

    finding the past tense of english verbs
the previous examples have all concerned tasks for which a compact  correct definition
is known to exist  this application  learning how to change an english verb in phonetic
notation from present to past tense  has more of a real world avor in that any totally correct
definition would be extremely complex  a considerable literature has built up around this
task  starting in the connectionist community  moving to symbolic learning through the
work of ling         then to relational learning  quinlan        mooney and califf        
quinlan        proposes representing this task as a relation past a b c   interpreted as
the past tense of verb a is formed by stripping off the ending b and then adding string c  the
single background relation split a b c  shows all ways in which word a can be split into two
non empty substrings b and c  following the experiment reported in  ling         a corpus
of      verbs is used to generate ten randomly selected learning tasks  each containing    
verbs from which a definition is learned and     different verbs used to test the definition 
a prolog interpreter is used to evaluate the definitions learned by foil  each unseen word
w being mapped to a test query past w x y    the result of this query is judged correct
only when both x and y are bound to the proper strings  if there are multiple responses to
the query  only the first is used   this disadvantages foil somewhat  since the system does
not attempt to reorder learned clauses for maximum accuracy on single response queries 
the average accuracy of the definitions found by foil is       
to apply ffoil to this task  the relation past a b c  must be factored into two functional
relations delete a b  and add a c  since ffoil can currently learn only functions with a
single output variable  the same training and test sets of verbs are used  each giving rise
to two separate learning tasks  and a test is judged correct only when both delete and add
give the correct results for the unseen verb  the definitions learned by ffoil have a higher
average accuracy of        on the ten trials  ffoil outperforms foil on nine and is inferior
on one  so the difference is significant at about the    level using a one tailed sign test  the
average time required by ffoil to learn a pair of definitions  approximately     minutes  is
somewhat less than the time taken by foil to learn a single definition 
   

filearning first order definitions of functions

object edges
a
b
c
d
e
total

  
  
  
  
  
   

correct

time  sec 

foil ffoil mfoil golem fors foil ffoil

  
  
  
  
  
   
 
  
  
 
  
   
 
  
 
 
 
   
  
  
 
  
  
   
  
  
  
  
  
   
  
   
  
  
       
                             

   
    
   
    
   
    

table    cross validation results for finite element mesh data 

    finite element mesh design
this application  first discussed by dolsak and muggleton         concerns the division of
an object into an appropriate number of regions for finite element simulation  each edge in
the object is cut into a number of intervals and the task is to learn to determine a suitable
number   too fine a division requires excessive computation in the simulation  while too
coarse a partitioning results in a poor approximation of the object s true behavior 
the data concern five objects with a total of     edges  the target relation mesh a b 
specifies for each edge a the number of intervals b recommended by an expert  ranging from
  to     thirty background relations describe properties of each edge  such as its shape and
its topological relationship to other edges in the object  five trials are conducted  in each
of which all information about one object is withheld  a definition learned from the edges
in the remaining objects  and this definition tested on the edges in the omitted object 
table   shows  for each trial  the number of edges on which the definitions learned by
foil and ffoil predict the number of intervals specified by the expert  table   also shows
published results on the mesh task for three other relational learning systems  the numbers
of edges for which mfoil and golem predict the correct number of intervals are taken from
 lavrac and dzeroski         these are both general relational learning systems like foil 
but fors  karalic         like ffoil  is specialized for learning functional relations of this
kind  since the general relational learning systems could return multiple answers to the
query mesh e x   for edge e  only the first answer is used  this puts them at a disadvantage
with respect to foil and fors and accounts at least in part for their lower accuracy  using
a one tailed sign test at the    level  ffoil s accuracy is significantly higher than that
achieved by foil and golem  but no other differences are significant 
the time required by ffoil for this domain is approximately three times that used by
foil  this turnabout is caused by ffoil s global pruning phase  which requires many literal
eliminations in order to maximize overall accuracy on the training data  in one ply of the
cross validation  for instance  the initial definition  consisting of    clauses containing   
body literals  fails to cover     of the     given tuples in the target relation mesh  after
global pruning  however  the final definition has just   clauses with    body literals  and
makes     errors on the training data 
   

fiquinlan

   related research

mooney and califf s        recent system foidl has had a strong inuence on the development of ffoil  three features that together distinguish foidl from earlier systems like
foil are 

 following the example of focl  pazzani and kibler         background relations

are defined intensionally by programs rather than extensionally as tuple sets  this
eliminates a problem in some applications for which a complete extensional definition
of the background relations would be impossibly large 

 examples of tuples that do not belong to the target relation are not needed  instead 
each argument of the target relation has a mode as above and foidl assumes output
completeness  i e   the tuples in the relation show all valid outputs for any inputs that
appear 

 the learned definition is ordered and every clause ends with a cut 
output completeness is a weaker restriction than functionality since there may be several
correct answers to a standard query r c    c         cn     x     however  the fact that each
clause ends with a cut reduces this exibility somewhat  since all answers to a query must
be generated by a single clause 
although foidl and ffoil both learn ordered clauses with cuts  they do so in very
different ways  ffoil learns a clause  then a sequence of clauses to cover the remaining
tuples  so that the first clause in the definition is the first clause learned  foidl instead
follows webb and brkic        in learning the last clause first  then prepending a sequence
of clauses to filter out all exceptions to the learned clause  this strategy has the advantage
that general rules can be learned first and still act as defaults to clauses that cover more
specialized situations 
the principal differences between foidl and ffoil are thus the use of intensional versus
extensional background knowledge and the order in which clauses are learned  there are
other subsidiary differences   for example  foidl never manipulates   bindings explicitly
but estimates their number syntactically  however  in many ways ffoil may be viewed as
an intermediate system lying mid way between foil and foidl 
foidl was motivated by the past tense task described in section      and performs
extremely well on it  the formulation of the task for foidl uses the relation past a b 
to indicate that b is the past tense of verb a  together with the intensional background
relation split s h t  to denote all possible ways of dividing string s into substrings h and
t  definitions learned by foidl are compact and intelligible  and have a slightly higher
accuracy         than ffoil s using the same ten sets of training and test examples  it
will be interesting to see how the systems compare in other applications 
bergadano and gunetti        first pointed out the advantages for learning systems of
restricting relations to functions  their filp system assumes that all relations  both target
and background  are functional  although they allow functions with multiple outputs  this
assumption greatly reduces the number of literals considered when specializing a clause 
leading to shorter learning times   on the other hand  many of the tasks discussed in the
previous section involve non functional background relations and so would not satisfy filp s
   

filearning first order definitions of functions

functionality assumption   in theory  filp also requires an oracle to answer non ground
queries regarding unspecified tuples in the target and background relations  although this
would not be required if all relevant tuples were provided initially  filp guarantees that the
learned definition is completely consistent with the given examples  and so is inappropriate
for noisy domains such as those discussed in sections     and     
in contrast to ffoil and foidl  the definitions learned by filp consist of unordered
sets of clauses  despite the fact that the target relation is known to be functional  this
prevents a clause from exploiting the context established by earlier clauses  in the gcd task
 section       a definition learned by filp would require the bodies of both the second and
third clauses to include a literal plus               in domains such as the past tense task  the
complexity of definitions learned by ffoil and foidl would be greatly increased if they
were constrained to unordered clauses 

   conclusion
in this study  a mature relational learning system has been modified to customize it for
functional relations  the fact that the specialized ffoil performs so much better than
the more general foil on relations of this kind lends support to bergadano and gunetti s
       thesis that functional relations are easier to learn  it is interesting to speculate that
a similar improvement might well be obtainable by customizing other general first order
systems such as progol  muggleton        for learning functional relations 
results from the quicksort experiments suggest that ffoil scales better than general
first order systems when learning functional relations  and those from the past tense and
mesh design experiments demonstrate its effectiveness in noisy domains 
nevertheless  it is hoped to improve ffoil in several ways  the system should be
extended to multifunctions with more than one output variable  as permitted by both
filp and foidl  secondly  many real world tasks such as those of sections     and    
result in definitions in which the output variable is usually bound by being equated to a
constant rather than by appearing in a body literal  in such applications  ffoil is heavily
biased towards constructing the next clause to cover the most frequent function value in
the remaining tuples  as this binding tends to have the highest gain  by the time that the
clause has been specialized to exclude exceptions  however  it can end up covering just a
few tuples of the relation  if a few special cases could be filtered out first  clauses like this
would be simpler and would cover more tuples of the target relation  a better learning
strategy in these situations would seem to be to grow a new clause for every function value
in the uncovered tuples  then retain the one with greatest coverage and discard the rest 
this would involve an increase in computation but should lead to better  more concise
definitions 
although the conceptual changes in moving from foil to ffoil are relatively slight 
their effects at the code level are substantial  with only three of the    files that make up
foil escaping modification   as a result it has been decided to preserve them as separate
systems  rather than incorporating ffoil as an option in foil  both are available  for
academic research purposes  by anonymous ftp from ftp cs su oz au  directory pub  file names
foil  sh and ffoil  sh 
   

fiquinlan

acknowledgements
this research was made possible by a grant from the australian research council  thanks
to william cohen  ray mooney  michael pazzani  and the anonymous reviewers for comments that helped to improve this paper 

appendix  learned definitions
the definition learned by foil appears on the left and that by ffoil on the right  as the
latter s default clauses are irrelevant for these tasks  they are omitted 

list processing functions  section     
 a  using lists of length   
append     b b  
append a b c     components a d e  
components c d f   append e b f  
last a b     components a b      
last a b     components a c d   last d b  
reverse a a     append a c d  
components d e a  
reverse a b     last a c   last b d  
components a d e  
components b c f   reverse e g  
del d b g  
shift a b     components a c d   del c b d  
append d e b  
translate          
translate a b     components a c d  
components b e f   translate d f  
means c e  

append     b b       
append a b c     components a d e  
append e b f   components c d f     
last a b     components a c d   last d b     
last a b     member b a     
reverse a a     append a c d  
components d e a     
reverse a b     components a c d  
reverse d e   append f d a  
append e f b  

append     b b  
append a b c     components a d e  
components c d f   append e b f  
last a b     components a b      
last a b     components a c d   last d b  
reverse a a     append a a c   del d e c  
reverse a b     components a c d  
reverse d e   append f d a  
append e f b  

append     b b       
append a b c     components a d e  
append e b f   components c d f     
last a b     components a c d   last d b     
last a b     member b a     
reverse a a     append a c d  
components d e a     
reverse a b     components a c d  
reverse d e   append f d a  
append e f b  
shift a b     components a c d  
append e d a   append d e b  

shift a b     components a c d  
append e d a   append d e b  
translate               
translate a b     components a c d  
translate d e   means c f  
components b f e  

 b  using lists of length   

shift a b     components a c d   del c b d  
append d e b  

   

filearning first order definitions of functions

translate          
translate a b     components a c d  
components b e f   translate d f  
means c e  

translate               
translate a b     components a c d  
translate d e   means c f  
components b f e  

quicksort and bubblesort  section     
qsort          
qsort a b     components a c d  
partition c d e f   qsort e g  
qsort f h   components i c h  
append g i b  
bsort          
bsort a a     components a c      
bsort a b     components a c d  
components b c e   bsort d e  
components e f g   lt c f  
bsort a b     components a c d  
components b e f   bsort d g  
components g e h   lt e c  
components i c h   bsort i f  

qsort               
qsort a b     components a c d  
partition c d e f   qsort e g  
qsort f h   components i c h  
append g i b     
bsort               
bsort a a     components a c         
bsort a b     components a c d   bsort d e  
components e f g  
components b c e   lt c f     
bsort a b     components a c d   bsort d e  
components e f g  
components d h i  
components j c i   bsort j k  
components b f k     
bsort a b     components a c d   bsort d e  
components f c e   bsort f b     

arithmetic functions  section     
ackermann   b c     succ b c  
ackermann a   c     succ d a  
ackermann d   c  
ackermann a b c     succ d a   succ e b  
ackermann a e f  
ackermann d f c  
gcd a a a  
gcd a b c     plus b d a   gcd b a c  
gcd a b c     plus a d b   gcd a d c  

ackermann   b c     succ b c     
ackermann a   c     succ   d   succ e a  
ackermann e d c     
ackermann a b c     succ d a   succ e b  
ackermann a e f  
ackermann d f c     
gcd a a a       
gcd a b c     plus a d b   gcd a d c     
gcd a b c     gcd b a c     

references

bell  s     weber  s          on the close logical relationship between foil and the frameworks of helft and plotkin  in proceedings third international workshop on inductive
logic programming  bled  slovenia  pp          
bergadano  f     gunetti  d          an interactive system to learn functional logic programs  in proceedings thirteenth international joint conference on artificial intelligence  chambery  france  pp             san francisco  morgan kaufmann 
bratko  i          prolog programming for artificial intelligence   nd edition   wokingham 
uk  addison wesley 
   

fiquinlan

cameron jones  r  m     quinlan  j  r          ecient top down induction of logic
programs  sigart           
de raedt  l   ed            advances in inductive logic programming  amsterdam  ios
press 
dolsak  b     muggleton  s          the application of inductive logic programming to
finite element mesh design  in muggleton  s   ed    inductive logic programming  pp 
         london  academic press 
karalic  a          first order regression  ph d  thesis  faculty of electrical engineering
and computer science  university of ljubljana  slovenia 
langley  p     simon  h  a          applications of machine learning and rule induction 
communications of the acm                 
lavrac  n     dzeroski  s          inductive logic programming  london  ellis horwood 
ling  c  x          learning the past tense of english verbs  the symbolic pattern associator
versus connectionist models  journal of artificial intelligence research             
michie  d   spiegelhalter  d  j     taylor  c  c   eds            machine learning  neural
and statistical classification  hertfordshire  uk  ellis horwood 
mooney  r  j     califf  m  e          induction of first order decision lists  results on
learning the past tense of english verbs  journal of artificial intelligence research    
     
muggleton  s   ed            inductive logic programming  london  academic press 
muggleton  s          inverse entailment and progol  new generation computing     
        
muggleton  s     feng  c          ecient induction of logic programs  in muggleton  s 
 ed    inductive logic programming  pp           london  academic press 
muggleton  s   king  r  d     sternberg  m  j          protein secondary structure prediction using logic based machine learning  protein engineering             
pazzani  m  j     kibler  d          the utility of knowledge in inductive learning  machine
learning           
quinlan  j  r          learning logical definitions from relations  machine learning    
        
quinlan  j  r          determinate literals in inductive logic programming  in proceedings
twelfth international joint conference on artificial intelligence  sydney  pp          
san francisco  morgan kaufmann 
quinlan  j  r          past tenses of verbs and first order learning  in proceedings ai   
seventh australian joint conference on artificial intelligence  armidale  australia 
pp         singapore  world scientific 
   

filearning first order definitions of functions

quinlan  j  r     cameron jones  r  m          foil  a midterm report  in proceedings european conference on machine learning  vienna  pp        berlin  springer verlag 
quinlan  j  r     cameron jones  r  m          induction of logic programs  foil and
related systems  new generation computing              
rouveirol  c          flattening and saturation  two representation changes for generalization  machine learning              
srinivasan  a   muggleton  s  h   sternberg  m  j  e     king  r  d          theories for
mutagenicity  a study in first order and feature based induction  artificial intelligence              
ullman  j  d          principles of database and knowledge base systems  rockville  md 
computer science press 
webb  g  i     brkic  n          learning decision lists by prepending inferred rules  in proceedings australian workshop on machine learning and hybrid systems  melbourne 
australia  pp       
zelle  j  m     mooney  r  j          combining foil and ebg to speed up logic programs 
in proceedings thirteenth international joint conference on artificial intelligence 
chambery  france  pp             san francisco  morgan kaufmann 

   

fi