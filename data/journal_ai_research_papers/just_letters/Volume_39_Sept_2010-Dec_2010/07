journal artificial intelligence research                  

submitted        published      

theta   any angle path planning grids
kenny daniel
alex nash
sven koenig

kfdaniel   usc   edu
anash   usc   edu
skoenig   usc   edu

computer science department
university southern california
los angeles  california             usa

ariel felner

felner   bgu   ac   il

department information systems engineering
ben gurion university negev
beer sheva         israel

abstract
grids blocked unblocked cells often used represent terrain robotics video
games  however  paths formed grid edges longer true shortest paths terrain
since headings artificially constrained  present two new correct complete anyangle path planning algorithms avoid shortcoming  basic theta  angle propagation
theta  variants a  propagate information along grid edges without constraining
paths grid edges  basic theta  simple understand implement  fast finds short paths 
however  guaranteed find true shortest paths  angle propagation theta  achieves
better worst case complexity per vertex expansion basic theta  propagating angle ranges
expands vertices  complex  fast finds slightly longer paths 
refer basic theta  angle propagation theta  collectively theta   theta  unique
properties  analyze detail  show experimentally finds shorter paths
a  post smoothed paths field d   the version a  know
propagates information along grid edges without constraining paths grid edges  runtime
comparable a  grids  finally  extend theta  grids contain unblocked cells
non uniform traversal costs introduce variants theta  provide different tradeoffs
path length runtime 

   introduction
article  study path planning robotics video games  choset  lynch  hutchinson 
kantor  burgard  kavraki    thrun        deloura        patel        murphy        rabin        
two dimensional continuous terrain discretized grid blocked unblocked
cells  objective find short unblocked path given start vertex given goal vertex
 both corners cells   a  finds grid paths  that is  paths constrained grid edges  quickly 
grid paths often true shortest paths  that is  shortest paths terrain  since potential
headings artificially constrained multiples    degrees  shown figure   a   yap        
shortcoming led introduction call any angle path planning  nash  daniel 
koenig    felner        ferguson   stentz         any angle path planning algorithms find paths
c
    
ai access foundation  rights reserved 

fidaniel   nash   koenig     f elner



 

 

 

 

 



start

b

c

 

 

 

 

 

start

b

c

goal
 a  grid path

goal
 b  true shortest path

figure    grid path versus true shortest path
without constraining headings paths  shown figure   b   present two new
correct complete any angle path planning algorithms  basic theta  angle propagation
theta  variants a  propagate information along grid edges  to achieve short
runtime  without constraining paths grid edges  to find any angle paths   unlike a  visibility
graphs  guaranteed find true shortest paths  asterisk names thus
denote optimality rather similarity a   basic theta  simple understand
implement  fast finds short paths  angle propagation theta  achieves worst case complexity
per vertex expansion constant rather linear number cells  like basic
theta   propagating angle ranges expands vertices  complex  fast
finds slightly longer paths  refer basic theta  angle propagation theta  collectively
theta   theta  unique properties  analyze detail  show experimentally
finds shorter paths a  post smoothed paths field d   the version
a  know propagates information along grid edges without constraining paths grid
edges  runtime comparable a  grids  finally  extend theta  grids
contain unblocked cells non uniform traversal costs introduce variants theta 
provide different tradeoffs path length runtime 

   path planning problem notation
section  describe path planning problem study article  namely path
planning eight neighbor grids blocked unblocked cells uniform size  cells labeled
either blocked  grey  unblocked  white   use corners cells  rather centers 
vertices  set vertices  path planning problem find unblocked path
given start vertex sstart given goal vertex sgoal  
path unblocked iff vertex path line of sight successor path  vertex
line of sight vertex   written lineofsight s     iff straight line vertex
vertex neither passes interior blocked cells passes blocked cells
share edge  pseudocode implementing line of sight function given appendix a 
simplicity  allow straight line pass diagonally touching blocked cells 
c s    length straight line vertex vertex   nghbrsvis  s  set visible
neighbors vertex eight compass directions  neighbors vertex
   

fit heta    ny a ngle path p lanning



g rids

line of sight vertex s  figure   shows example visible neighbors vertex b 
vertices a   a   a   b   b   c  c  

   existing terrain discretizations
continuous terrain needs discretized path planning  section  compare grids
existing terrain discretizations  use grids discretize terrain since widely used
robotics video games  deloura        murphy        rabin        several desirable
properties 
grids simple data structures allow simple path planning algorithms 
terrain easily discretized grid laying grid terrain labeling
cells partially completely obstructed blocked 
grids provide comprehensive picture traversable surfaces continuous terrain 
essential path planning algorithm used dynamic environment
must interact navigation planner  example robot video game character
encounters temporary blockage path  easily determine whether best
divert left  unblocked  right  blocked   tozour        
cells store information addition traversability  amount gold
hidden region terrain corresponds cell rendering region
displaying terrain 
information stored cells accessed quickly since grids random access data
structures 
precision path navigation planning improved simply increasing grid
resolution 
list alternative terrain discretizations  assuming simplicity obstacles
terrain polygonal 
voronoi graphs  aurenhammer        discretize terrain biasing paths away
blocked polygons  resulting paths thus much longer true shortest paths 
discretization work mitchell papadimitriou        partitions terrain
regions linear hyperbolic edges  allows one find true shortest paths
time space complexity o m       number corners blocked polygons 
thus  runtime path planning grow superlinearly number corners blocked
polygons 
framed quadtrees  yahja  stentz  singh    brumitt        recursively subdivide terrain
four equally sized cells cells completely obstructed  completely unobstructed
sufficiently small size  resulting paths unnecessary heading changes  that is 
heading changes occur free space rather corners blocked polygons  
   

fidaniel   nash   koenig     f elner

  main  
 
g sstart        
 
parent sstart      sstart  
 
open     
 
open insert sstart   g sstart     h sstart    
 
closed     
 
open   
 
   open pop   
  sgoal
 
  
return path found 
  
  
  
  
  
  
  
  
  

closed    closed  s  
   following line executed ap theta  
 updatebounds s   
foreach nghbrsvis  s 
  closed
  open
g s       
parent s      n u ll 

   

updatevertex s    

  
return path found 
   end
   updatevertex s s 
  
g s    c s      g s  
  
g s      g s    c s    
  
parent s      s 
  
open
  
open remove s   
  

open insert s   g s     h s    

   end

algorithm    a 

probabilistic roadmaps  kavraki  svestka  latombe    overmars        rapidly exploring
random trees  lavalle   kuffner        place vertices randomly  in addition start
goal vertex   two vertices connected via straight line iff line of sight 
random placement vertices needs tuned carefully since influences runtime
path planning  likelihood finding path length path 
visibility graphs  lee        lozano perez   wesley        use corners blocked
polygon vertices  in addition start goal vertex   two vertices connected via
straight line iff line of sight  allows one find true shortest paths 
runtime path planning grow superlinearly number vertices since number
edges grow quadratically number vertices 

   existing path planning algorithms
section  describe existing path planning algorithms  variants a 
 hart  nilsson    raphael         a  popular path planning algorithm robotics video
games  algorithm   shows pseudocode a   line    ignored  a  maintains three
values every vertex s 
   

fit heta    ny a ngle path p lanning



g rids

g value g s  length shortest path start vertex vertex found
far thus estimate start distance vertex s 
user provided h value h s  estimate goal distance vertex s  a  uses
h value calculate f value focus a  search  f value f  s    g s    h s 
estimate length shortest path start vertex via vertex goal vertex 
parent parent s  used extract path start vertex goal vertex a 
terminates 
a  maintains two global data structures 
open list priority queue contains vertices a  considers expansion 
pseudocode  open insert s  x  inserts vertex key x priority queue open 
open remove s  removes vertex priority queue open  open pop   removes
vertex smallest key priority queue open returns it 
closed list set contains vertices a  already expanded  ensures
a  expands every vertex once 
a  sets g value every vertex infinity parent every vertex null
encounters vertex first time  lines         sets g value start vertex zero
parent start vertex start vertex  lines       sets open closed
lists empty list inserts start vertex open list f value key
       a  repeatedly executes following procedure  open list empty  reports
path  line      otherwise  identifies vertex smallest f value
open list  line     vertex goal vertex  a  reports found path  line     
path extraction  not shown pseudocode  follows parents goal vertex start
vertex retrieve path start vertex goal vertex reverse  otherwise  a  removes
vertex open list  line    expands inserting vertex closed list  line
    generating unexpanded visible neighbors  follows  a  checks whether
g value vertex plus length straight line vertex vertex smaller
g value vertex  line      so  sets g value vertex g value vertex
plus length straight line vertex vertex   sets parent vertex vertex
finally inserts vertex open list f value key or  already
open list  sets key f value  lines         repeats procedure 
summarize  a  updates g value parent unexpanded visible neighbor
vertex procedure updatevertex  considers path start vertex vertex    g s  
vertex vertex straight line    c s      resulting length g s    c s   
 line      a  updates g value parent vertex considered path shorter
shortest path start vertex vertex found far    g s    
describe several existing path planning algorithms versions a 
trade two conflicting criteria  namely runtime path length  shown figure   
introduce order decreasing path lengths 
   

fidaniel   nash   koenig     f elner

  

 

runtime

a 
a  ps
fd 

   

visibility graphs
basic theta 

    

     
 

    

    

    

    

    

    

path length   length true shortest path

figure    runtime versus path length  relative length true shortest path  random    
    grids    percent blocked cells

   postsmoothpath  s            sn   
  
k      
  
tk    s   
  
foreach            n  
  
lineofsight tk   si    
  
k    k     
  
tk    si  
  
k    k     
  
tk    sn  
  
return  t            tk   
   end

algorithm    post smoothing

    a  grids
one run a  grids  is  graphs given grid vertices edges  resulting
paths artificially constrained formed edges grid  seen figure
  a   result paths found a  grids equivalent true shortest paths
unrealistic looking since either deviate substantially true shortest paths
many heading changes  provides motivation smoothing them  use octile
distances  computed using algorithm    h values experiments 
   

fit heta    ny a ngle path p lanning

 

 

 

 

 





g rids

 
goal
true shortest path

b
shortest grid path
a  ps path

c

start

figure    a  ps path versus true shortest path

    a  post smoothed paths  a  ps 
one run a  post smoothed paths  a  ps   thorpe         a  ps runs a  grids
smoothes resulting path post processing step  often shortens increase
runtime  algorithm   shows pseudocode simple smoothing algorithm a  ps uses
experiments  botea  muller    schaeffer         provides good tradeoff
runtime path length  assume a  grids finds path  s    s            sn   s    sstart
sn   sgoal   a  ps uses first vertex path current vertex  checks whether
current vertex s  line of sight successor s  successor path  so  a 
ps removes intermediate vertex s  path  thus shortening it  a  ps repeats
procedure checking whether current vertex s  line of sight successor s 
successor path  on  soon current vertex line of sight
successor successor path  a  ps advances current vertex repeats procedure
reaches end path  use straight line distances h s    c s  sgoal   h values
experiments 
a  ps typically finds shorter paths a  grids  guaranteed find true shortest paths 
figure   shows example  assume a  ps finds dotted blue path  one many
shortest grid paths  smoothes path solid blue path  true shortest
path  dashed red path  moves  rather below  blocked cell b  b  c  c 
true shortest path  a  ps guaranteed find true shortest paths considers grid
paths a  search thus cannot make informed decisions regarding paths
a  search  motivates interleaving searching smoothing  fact  theta  similar
a  ps except interleaves searching smoothing 
    field d   fd  
one run field d   ferguson   stentz         fd    fd  propagates information along grid
edges without constraining paths grid edges  fd  designed use d  lite  koenig  
likhachev        fast replanning  by reusing information previous a  search speed
next one  searches goal vertex start vertex  version fd  uses
a  searches start vertex goal vertex  path planning algorithms
article  allows us compare fairly  except replanning abilities   theta 
currently process extended fast replanning nash  koenig    likhachev        
   

fidaniel   nash   koenig     f elner

 

b

 

 

 

    

    

    

    

    

    

 

sgoal
    



c



    

x

sstart
    

    

    

    

    

    

    

    

field d  path
figure    fd  path

figure    screenshot fd  path versus true shortest path
fd  updates g value parent unexpanded visible neighbor vertex s 
considers paths start vertex point x  not necessarily vertex  perimeter
vertex    g x   line of sight vertex   perimeter formed connecting
neighbors vertex   point x vertex straight line    c x      resulting
length g x    c x     fd  updates g value parent vertex considered
path shorter shortest path start vertex vertex found far    g s     use
straight line distances h s    c s  sgoal   h values experiments 
figure   shows example  perimeter vertex   b  formed connecting
neighbors vertex b   shown bold  consider point x perimeter  fd  know
g value point x since stores g values vertices  calculates g value using
linear interpolation g values two vertices perimeter adjacent
point x  thus  linearly interpolates g b          g c           resulting
g x                                 since           distances point x
vertices b  c   respectively  calculated g value point x different true start
distance          even though g values vertices b  c  equal true start
distances  reason mistake simple  exist true shortest paths start vertex
either vertex c  vertex b  goal vertex  thus  linear interpolation assumption
predicts must exist short path start vertex point along
edge connects vertices b  c  goal vertex  however  case since
   

fit heta    ny a ngle path p lanning



 

 

 

 



g rids

 

start

b

c

goal
true shortest path
 a  simple visibility graph

 b  terrain resulting complex visibility graph

figure    visibility graphs
paths need circumnavigate blocked cell b  b  c  c   makes longer expected 
result miscalculating g value point x  fd  sets parent vertex b  point x 
resulting path unnecessary heading change point x longer even
shortest grid path 
authors fd  recognize paths found fd  frequently unnecessary heading
changes suggest use one step look ahead algorithm path extraction  ferguson  
stentz         fd  uses experiments  one step look ahead algorithm allows fd 
avoid unnecessary heading changes  one figure    eliminate
them  figure   shows example fd  path red corresponding true shortest
path blue  fd  path still many unnecessary heading changes 
    a  visibility graphs
one run a  visibility graphs  visibility graph grid blocked unblocked
cells contains start vertex  goal vertex corners blocked cells  lozano perez  
wesley         use straight line distances h s    c s  sgoal   h values experiments 
a  visibility graphs finds true shortest paths  shown figure   a   true shortest paths
heading changes corners blocked cells  paths found a  grids  a  ps
fd  unnecessary heading changes  hand  a  visibility graphs
slow  propagates information along visibility graph edges  whose number grow quadratically
number cells  a  grids  a  ps fd  propagate information along grid edges 
whose number grows linearly number cells  one constructed visibility graphs
a  search  one would need perform line of sight check every pair corners
blocked cells determine whether visibility graph edge them 
requires least       line of sight checks room figure   b   tozour        
number line of sight checks performed a  visibility graphs reduced constructing
   

fidaniel   nash   koenig     f elner

   updatevertex s s 
  
lineofsight parent s    
  
   path     
  
g parent s     c parent s       g s  
  
g s      g parent s     c parent s     
  
parent s      parent s  
  
open
  
open remove s   
open insert s   g s     h s    

  
  
  
  
  
  
  
  
  

else
   path     
g s    c s      g s  
g s      g s    c s    
parent s      s 
open
open remove s   
open insert s   g s     h s    

   end

algorithm    basic theta 

visibility graphs a  search  expands vertex  performs line of sight checks
expanded vertex corners blocked cells  and goal vertex  
significantly reduce number line of sight checks performed environments 
simple outdoor terrain  fails others  cluttered indoor terrain 
complex optimizations  reduced visibility graphs reduce number line ofsight checks  sufficiently speed a  visibility graphs  liu   arimoto        

   basic theta 
section  introduce theta   nash et al          version a  any angle path
planning propagates information along grid edges without constraining paths grid edges 
combines ideas behind a  visibility graphs  where heading changes occur
corners blocked cells  a  grids  where number edges grows linearly
number cells   paths slightly longer true shortest paths  as found a 
visibility graphs   yet slightly slower a  grids  shown figure    key
difference theta  a  grids parent vertex vertex
using theta   parent vertex neighbor vertex using a  
first introduce basic theta   simple version theta  
algorithm   shows pseudocode basic theta   procedure main identical a 
algorithm   thus shown  line    ignored  use straight line distances
h s    c s  sgoal   h values experiments 
    operation basic theta 
basic theta  simple  identical a  except that  updates g value parent
unexpanded visible neighbor vertex procedure updatevertex  considers two paths
   

fit heta    ny a ngle path p lanning

 

 

 

 



 

sgoal



b



c

path  

g rids

 

 

 



sstart

b

c

 



path  

sstart





sgoal

path  

 a  path   unblocked

 

path  

 b  path   blocked

figure    paths     considered basic theta 

instead one path considered a   figure   a  shows example  basic theta 
expanding vertex b  parent a  needs update g value parent unexpanded
visible neighbor c   basic theta  considers two paths 

path    basic theta  considers path start vertex vertex    g s  
vertex vertex straight line    c s      resulting length g s    c s     line
     path   path considered a   corresponds dashed red path  a   b   c  
figure   a   
path    basic theta  considers path start vertex parent vertex   
g parent s    parent vertex vertex straight line    c parent s      
resulting length g parent s     c parent s      line      path   considered
a  allows basic theta  construct any angle paths  corresponds solid blue
path  a   c   figure   a  

path   longer path   due triangle inequality  triangle inequality states
length side triangle longer sum lengths two sides 
applies since path   consists path start vertex parent vertex s 
straight line parent vertex vertex  line a  straight line vertex
vertex  line b   path   consists path start vertex parent vertex
straight line parent vertex vertex  line c  lines a  b c form
triangle  path   guaranteed unblocked path   not  thus  basic theta  chooses path
  path   vertex line of sight parent vertex path   thus unblocked 
figure   a  shows example  otherwise  basic theta  chooses path   path    figure   b 
shows example  basic theta  updates g value parent vertex chosen path
shorter shortest path start vertex vertex found far    g s     use
straight line distances h s    c s  sgoal   h values experiments 
   

fidaniel   nash   koenig     f elner

 

 

 

 

 

 



    

    

    

a 

sstart

a 

b

    

    

    

a 

a 

a 

c

sgoal

 

 

b

c

a 

sgoal

 

    

a 

sstart

a 

    

    

    

    

b 

a 

a 

a 

    

    

    

a 

a 

a 

 b 

 

 

    

    

    

    

    

b 

b 

a 

sstart

a 

b

    

    

    

    

    

b 

b 

a 

a 

a 

    

    

    

    

b 

a 

a 

a 

sgoal

 

 



c

 

    

 a 
 

 
    



 

 

 

 



    

    

    

    

    

b 

b 

a 

sstart

a 

b

    

    

    

    

    

b 

b 

a 

a 

a 

c

    

    

    

    

b 

a 

a 

a 

sgoal

 c 

 d 

figure    example trace basic theta 

    example trace basic theta 
figure   shows example trace basic theta   vertices labeled g values
parents  arrows point parents  red circles indicate vertices expanded 
blue arrows indicate vertices generated current expansion  first  basic theta 
expands start vertex a  parent a   shown figure   a   sets parent unexpanded
visible neighbors vertex a  vertex a   a  would do  second  basic theta  expands
vertex b  parent a   shown figure   b   vertex b  unexpanded visible neighbor
vertex b  line of sight vertex a   basic theta  thus updates according
path   sets parent vertex b   hand  vertices c   c  c  unexpanded
visible neighbors vertex b  line of sight vertex a   basic theta  thus updates
according path   sets parents vertex a    the g values parents
unexpanded visible neighbors vertex b  updated   third  basic theta  expands vertex
b  parent b   shown figure   c   vertices a  a  unexpanded visible neighbors
vertex b  line of sight vertex b   basic theta  thus updates according
path   sets parents vertex b   hand  vertices b  c  unexpanded
visible neighbors vertex b  line of sight vertex b   basic theta  thus updates
according path   sets parents vertex b   fourth  basic theta  expands goal
vertex c  parent b  terminates  shown figure   d   path extraction follows
parents goal vertex c  start vertex a  retrieve true shortest path  a   b   c  
start vertex goal vertex reverse 
   

fit heta    ny a ngle path p lanning



g rids

    properties basic theta 
discuss properties basic theta  
      c orrectness



c ompleteness

basic theta  correct  that is  finds unblocked paths start vertex goal vertex 
complete  that is  finds path start vertex goal vertex one exists   use
following lemmata proof 
lemma    exists unblocked path two vertices exists unblocked
grid path two vertices 
proof  unblocked path two vertices exists iff unblocked any angle path  s            sn  
exists two vertices  consider path segment sk sk   any angle path 
path segment horizontal vertical  consider unblocked grid path vertex sk
vertex sk   coincides path segment  otherwise  consider sequence  b            bm  
unblocked cells whose interior path segment passes through  two consecutive cells
bj bj   share least one vertex sj   since cells either share edge diagonally
touching   if share one vertex  pick one arbitrarily   consider grid path  s   
sk   s            sm   sm     sk      grid path vertex sk vertex sk   unblocked since
two consecutive vertices corners unblocked cell thus visible neighbors 
repeat procedure every path segment any angle path concatenate resulting
grid paths unblocked grid path vertex s  vertex sn    if several consecutive vertices
grid path identical  one removed  
lemma    point execution basic theta   following parents vertex
open closed lists start vertex retrieves unblocked path start vertex
vertex reverse 
proof  prove induction lemma holds parent vertex union
open closed lists union open closed lists  statement holds
initially start vertex vertex union open closed lists
parent  show statement continues hold whenever vertex changes either
parent membership union open closed lists  vertex member
union open closed lists  continues member  vertex become member
union open closed lists basic theta  expands vertex updates
g value parent unexpanded visible neighbor vertex procedure updatevertex 
vertex thus closed list  parent union open closed lists according
induction assumption  thus  following parents vertex  or parent  start
vertex retrieves unblocked path start vertex vertex  or parent  respectively 
reverse according induction assumption  basic theta  updates vertex according path
   statement continues hold since vertices visible neighbors path
segment vertex vertex thus unblocked  basic theta  updates vertex according
path    statement continues hold since basic theta  explicitly checks path
   

fidaniel   nash   koenig     f elner

segment parent vertex vertex unblocked  ways
parent vertex change 
theorem    basic theta  terminates path extraction retrieves unblocked path start
vertex goal vertex path exists  otherwise  basic theta  terminates reports
unblocked path exists 
proof  following properties together prove theorem  proofs utilize fact basic
theta  terminates iff open empty expands goal vertex  start vertex initially
open list  vertex initially neither open closed lists  vertex neither
open closed lists inserted open list  vertex open list removed
open list inserted closed list  vertex closed list remains closed list 
property    basic theta  terminates  expands one vertex open list
iteration  process  removes vertex open list never insert
open list again  since number vertices finite  open list eventually becomes
empty basic theta  terminate terminated earlier already 
property    basic theta  terminates open list empty 
exist unblocked path start vertex goal vertex  prove contrapositive 
assume exists unblocked path start vertex goal vertex  prove
contradiction basic theta  terminate open list empty 
thus  assume basic theta  terminates open list empty  then 
exists unblocked grid path  s    sstart           sn   sgoal   start vertex goal
vertex according lemma    choose vertex si first vertex grid path
closed list basic theta  terminates  goal vertex closed list
basic theta  terminates since basic theta  would otherwise terminated
expanded goal vertex  thus  vertex si exists  vertex si start vertex since start
vertex would otherwise open list basic theta  could terminated
open list empty  thus  vertex si predecessor grid path  predecessor
closed list basic theta  terminates since vertex si first vertex grid
path closed list basic theta  terminates  basic theta  expanded
predecessor  added vertex si open list  thus  vertex si still open list
basic theta  terminates  basic theta  could terminated open
list empty  contradiction 
property    basic theta  terminates expands goal vertex  path extraction
retrieves unblocked path start vertex goal vertex following
parents goal vertex start vertex retrieves unblocked path start
vertex goal vertex reverse according lemma   

   

fit heta    ny a ngle path p lanning



 

 

 

 

 



g rids

 

 

 

 

  

 

 

 

 

  

b

c



e

start

 a 


 

 

 

 

 

b

c



e

start

 b 

true shortest path

basic theta  path

figure    basic theta  paths versus true shortest paths

      ptimality
basic theta  optimal  that is  guaranteed find true shortest paths 
parent vertex either visible neighbor vertex parent visible neighbor 
always case true shortest paths  figure   a  shows example dashed
red path  e   b   true shortest path start vertex e  vertex b  since vertex e  lineof sight vertex b   however  vertex e  neither visible neighbor parent visible
neighbor vertex b  since vertex e  line of sight vertices  highlighted
red   thus  basic theta  cannot set parent vertex b  vertex e  find true
shortest path vertex e  vertex b   similarly  figure   b  shows example
dashed red path  e   d   c    true shortest path vertex e  vertex c    however  vertex
d  neither visible neighbor parent visible neighbor vertex c   since start vertex
e  either line of sight basic theta  found paths vertex e 
   

fidaniel   nash   koenig     f elner



  sstart

 

 

 

 

 

b

c

f     


f     

true shortest path

sgoal
f     

basic theta  path

figure     heading changes basic theta 

contain vertex d   fact  truly shortest paths vertex e  visible neighbors vertex
c   vertex e  line of sight move  rather below  blocked cell c c  d  d   thus  basic theta  cannot set parent vertex c   vertex d  thus
find true shortest path vertex e  vertex c    solid blue path vertex e  vertex
b  figure   a  solid blue path vertex e  vertex c   figure   b  less
factor       longer true shortest paths 
      h eading c hanges
basic theta  takes advantage fact true shortest paths heading changes
corners blocked cells  however  paths found basic theta  occasionally
unnecessary heading changes  figure    shows example basic theta  finds solid blue
path  a   d   d   vertex a  vertex d   reason mistake simple  assume
open list contains vertices c  d   f value vertex c  f  c     g c    
h c                        parent vertex c   f value vertex d  f  d    
                   parent vertex a   thus basic theta  expands vertex d 
vertex c   since f value smaller   basic theta  expands vertex d  parent a  
generates vertex d   vertex d  unexpanded visible neighbor vertex d 
line of sight vertex a   basic theta  thus updates according path    sets f value
f  d                         sets parent vertex d  inserts open list  thus
basic theta  expands goal vertex d  vertex c   since f value smaller  terminates 
path extraction follows parents goal vertex d  start vertex a  retrieve solid
blue path  a   d   d    thus  basic theta  never expands vertex c   would resulted
setting parent vertex d  vertex c  according path   path extraction retrieving
dashed red path  a   c   d   true shortest path  solid blue path vertex a 
vertex d  figure    less factor       longer true shortest path 
   

fit heta    ny a ngle path p lanning



g rids

   updatevertex s s 
  
   sstart lb s   s  parent s     ub s 
  
   path     
  
g parent s     c parent s       g s  
  
g s      g parent s     c parent s     
  
parent s      parent s  
  
open
  
open remove s   
open insert s   g s     h s    

  
  
  
  
  
  
  
  
  

else
   path     
g s    c s      g s  
g s      g s    c s    
parent s      s 
open
open remove s   
open insert s   g s     h s    

   end
   updatebounds s 
  
lb s       ub s      
  
   sstart
  
foreach blocked cell b adjacent
  
corners b    parent s     s  parent s        
  
  s  parent s         c parent s     c parent s   s  
  
lb s      
  
  
  
  
  
  
  
  
  
  
  
  
  
  

corners b    parent s     s  parent s        
  s  parent s         c parent s     c parent s   s  
ub s      
foreach nghbrsvis  s 
closed parent s    parent s      sstart
lb s      s  parent s      
lb s     max lb s   lb s      s  parent s      
ub s      s  parent s      
ub s     min ub s   ub s      s  parent s      
c parent s       c parent s   s  parent s      s   closed parent s     parent s   

 s  parent s        
lb s     max lb s    s  parent s      
 s  parent s        
ub s     min ub s    s  parent s      

   end

algorithm    ap theta 

   angle propagation theta   ap theta  
runtime basic theta  per vertex expansion  that is  runtime consumed generation unexpanded visible neighbors expanding vertex  linear number
cells since runtime line of sight check linear number cells 
section  introduce angle propagation theta   ap theta    reduces runtime basic
   

fidaniel   nash   koenig     f elner



 

 

b

 

 



 

 

 



 

c



e



f

figure     region points line of sight vertex
theta  per vertex expansion linear constant   key difference ap theta 
basic theta  ap theta  propagates angle ranges uses determine whether
two vertices line of sight 
light source vertex light cannot pass blocked cells  cells
shadows line of sight vertex cells line of sight vertex 
contiguous region points line of sight vertex characterized two
rays emanating vertex thus angle range defined two angle bounds  figure
   shows example points within red angle range defined two angle bounds
    line of sight vertex s  ap theta  calculates angle range vertex
expands vertex propagates along grid edges  resulting constant runtime per
vertex expansion since angle ranges propagated constant time line of sight
checks performed constant time well 
algorithm   shows pseudocode ap theta   procedure main identical a 
algorithm   thus shown  line    executed  use straight line distances
h s    c s  sgoal   h values experiments 
    definition angle ranges
discuss key concept angle range  ap theta  maintains two additional values
every vertex s  namely lower angle bound lb s  vertex upper angle bound ub s 
vertex s  together form angle range  lb s   ub s   vertex s  angle bounds correspond
headings rays  measured degrees  originate parent vertex s  heading
ray parent vertex vertex zero degrees  visible neighbor vertex
guaranteed line of sight parent vertex  but necessarily if  heading
ray parent vertex visible neighbor vertex contained angle
   ap theta  provides significant improvement worst case complexity basic theta   experimental results section   show slower finds slightly longer paths basic theta  

   

fit heta    ny a ngle path p lanning

 

 

 

 





g rids

 

sstart
lb

b

  o


  
c

sgoal



ub

figure     angle range ap theta 
range vertex s  figure    shows example vertex c  parent a  angle range
          thus  visible neighbors vertex c  red region guaranteed line ofsight parent vertex c   example  vertex c  guaranteed line of sight
parent vertex c  vertex b  not  ap theta  therefore assumes vertex b 
line of sight parent vertex c  
define concept angle range formally   s  p              gives
ap theta  name  angle  measured degrees  ray vertex p vertex
ray vertex p vertex   positive ray vertex p vertex clockwise
ray vertex p vertex   zero ray vertex p vertex heading
ray vertex p vertex   negative ray vertex p vertex counterclockwise
ray vertex p vertex   figure    shows example  c   a   c       
 c   a   b         visible neighbor vertex guaranteed line of sight
parent vertex  but necessarily if  lb s   s  parent s     ub s   visibility
property  
    update angle ranges
discuss ap theta  calculates angle range vertex expands vertex 
calculation complicated fact ap theta  guaranteed sufficient
information determine angle range exactly since order vertex expansions depends
variety factors  h values  case  ap theta  constrain angle range
necessary guarantee visibility property holds finds unblocked paths 
ap theta  expands vertex s  sets angle range vertex initially       meaning
visible neighbors vertex guaranteed line of sight parent vertex 
constrains angle range vertex start vertex 
ap theta  constrains angle range vertex based blocked cell b adjacent
vertex  that is  vertex corner b  written corners b   provided least one
two conditions satisfied 
case    every corner blocked cell b satisfies least one following conditions 
parent s   
   

fidaniel   nash   koenig     f elner

 s  parent s        
 s  parent s         c parent s     c parent s   s  
ap theta  assumes vertex line of sight parent vertex
ray parent vertex vertex counterclockwise ray
parent vertex vertex   is   s  parent s          ap theta  therefore sets
lower angle bound vertex  s  parent s   s       line     
case    every corner blocked cell b satisfies least one following conditions 
parent s   
 s  parent s        
 s  parent s         c parent s     c parent s   s  
ap theta  assumes vertex line of sight parent vertex
ray parent vertex vertex clockwise ray parent
vertex vertex   is   s  parent s          ap theta  therefore sets upper
angle bound vertex  s  parent s   s       line     
ap theta  constrains angle range vertex based visible neighbor vertex
provided least one two conditions satisfied 
case    vertex satisfies following conditions 
closed

parent s    parent s  
   sstart  
ap theta  constrains angle range vertex intersecting angle range
vertex  lines         that  first shifts angle range vertex
 s  parent s     degrees take account angle range vertex calibrated
heading ray joint parent vertices vertex zero
degrees  angle range vertex calibrated heading ray
joint parent vertices vertex zero degrees  lines       ensure
lower angle bound always remains non positive upper angle bound always remains
non negative  respectively  fact lower angle bounds non positive  and
upper angle bounds non negative  intuitive vertex assigned parent vertex p
angle ray vertex p vertex included angle range
vertex s 
case    vertex satisfies following conditions 
c parent s       c parent s   s 
parent s    
   

fit heta    ny a ngle path p lanning



g rids

  closed parent s     parent s   
ap theta  insufficient information vertex   ap theta  therefore cannot
determine angle range vertex exactly makes conservative assumption
vertex barely line of sight parent vertex  lines        
visibility property holds ap theta  updated angle range vertex procedure
updatebounds  thus  ap theta  checks whether visible neighbor vertex
line of sight parent vertex s  checks whether lb s   s  parent s    
ub s   line     true instead whether lineofsight parent s      line     true  
differences ap theta  basic theta  
figure    a  shows example ap theta  calculates angle range vertex a   sets
angle range       figure    b  shows example ap theta  calculates angle
range vertex b   sets angle range initially       sets lower angle bound
  degrees according case   based blocked cell a  a  b  b   line      sets
upper angle bound    degrees according case   based vertex b   unexpanded
thus closed list  line      figure    c  shows example ap theta  calculates
angle range vertex b   sets angle range initially       sets lower
angle bound   degrees according case   based blocked cell a  a  b  b   line     
assume vertex c  goal vertex  figure    d  shows example ap theta 
calculates angle range vertex c   sets angle range initially       sets
lower angle bound     degrees according case   based vertex b   line     upper
angle bound    degrees according case   based vertex c   unexpanded thus
closed list  line     
    example trace ap theta 
figure    shows example trace ap theta  using path planning problem figure   
labels vertices include angle ranges 
    properties ap theta 
discuss properties ap theta   ap theta  operates way basic theta 
thus similar properties basic theta   example  ap theta  correct complete 
guaranteed find true shortest paths  paths occasionally unnecessary heading
changes 
ap theta  sometimes constrains angle ranges necessary guarantee finds
unblocked paths  means line of sight checks sometimes fail incorrectly case
update vertices according path   rather path    ap theta  still complete since
finds unblocked grid path line of sight checks fail  always exists unblocked
grid path exists unblocked any angle path  however  paths found ap theta 
longer found basic theta   figure    shows example  ap theta  expands
vertex c  parent b  calculates angle range vertex c   vertex c  unexpanded
thus closed list  means ap theta  insufficient information vertex
   

fidaniel   nash   koenig     f elner

 

 

 

 

 

    

    

    

a 

sstart

a 

 

 

    
a 

 

 
 

   

 



b

    

    

    

a 

a 

a 

c

    

    

    

    

b 

a 
      

a 

a 

c

    

    

    

a 

a 

a 

 

 b 

 

    

    

b 

b 

 

 

 

    

    
a 

    
a 

sstart

 

 

    

    

b 

b 

 
    
a 

 

    

b 

b 
     

c

    

    

b 

a 

    
a 
      

    
a 

    
a 

    
a 

b

    
a 

    

    

b 

b 
     

    

    

b 
       

a 

 

    

 

b

 

    

sstart

    
a 

     

 
 

   



 
 

 

    
a 

sstart
     

b

 a 


 

    
 
 

 


c

 c 

    
a 
      

    
a 

    
a 

    
a 

    
a 

 d 

figure     example trace ap theta 
 

 

 

 

 

 




b

c



start

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

sgoal

basic theta  path

ap theta  path

figure     basic theta  path versus ap theta  path
c  because  example  know whether cell c  c  d  d  unblocked  ap
theta  therefore cannot determine angle range vertex c  exactly makes conservative
assumption vertex c  barely line of sight vertex b  sets lower angle bound
vertex c  according case   based vertex c   uses resulting angle range
determine unexpanded visible neighbor d  vertex c  guaranteed line ofsight vertex b   however  vertex d  line of sight vertex b  cell c  c  d  d 
   

fit heta    ny a ngle path p lanning



g rids

figure     map baldurs gate ii
unblocked  ap theta  eventually finds solid blue path  b   c   d   start vertex b 
vertex d   basic theta  finds dashed red path  b   d    true shortest path 
correctness completeness proof basic theta  needs get changed slightly ap theta 
since ap theta  performs line of sight checks differently 
theorem    ap theta  terminates path extraction retrieves unblocked path start
vertex goal vertex path exists  otherwise  ap theta  terminates reports
unblocked path exists 
proof  proof similar proof theorem   since ap theta  uses angle ranges
determine whether path   blocked determine whether path   blocked 
property needs proved differently two vertices indeed line of sight
 but necessarily if  line of sight check ap theta  succeeds  see appendix b 

   experimental results
section  compare basic theta  ap theta  a  grids  a  ps  fd  a 
visibility graphs respect path length  number vertex expansions  runtime  measured
seconds  number heading changes 
compare path planning algorithms                 grids different percentages randomly blocked cells  random grids  scaled maps real time strategy
game baldurs gate ii  game maps   figure     bulitko  sturtevant    kazakevich        shows
example game map  start goal vertices south west corners cells  random
grids  start vertex south west cell  goal vertex cell randomly chosen
column cells furthest east  cells blocked randomly one unit border unblocked
cells guarantees path start vertex goal vertex  game maps  start
goal vertices randomly chosen corners unblocked cells  average    
random         grids      random         grids     game maps 
   

fidaniel   nash   koenig     f elner

      

      

fd 
game maps
random grids   
random grids   
random grids    
random grids    
random grids    
game maps
random grids   
random grids   
random grids    
random grids    
random grids    

     
      
      
      
      
      
      
      
      
      
      
      

basic theta  ap theta  a  visibility graphs a  grids
 true shortest path 
     
     
     
     
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
n a
      
      
      
n a
      
      
      
n a
      
      
      
n a
      
      
      
n a
      
      
      
n a
      

a  ps
     
      
      
      
      
      
      
      
      
      
      
      

table    path length

      

      

fd 
game maps
random grids   
random grids   
random grids    
random grids    
random grids    
game maps
random grids   
random grids   
random grids    
random grids    
random grids    

      
      
      
      
      
      
      
      
      
      
      
      

basic theta  ap theta  a  visibility graphs a  grids
 true shortest path 
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
n a
      
      
      
n a
      
      
      
n a
      
      
      
n a
      
      
      
n a
      
      
      
n a
      

a  ps
      
      
      
      
      
      
      
      
      
      
      
      

table    runtime

      

      

fd 
game maps
random grids   
random grids   
random grids    
random grids    
random grids    
game maps
random grids   
random grids   
random grids    
random grids    
random grids    

      
      
      
      
       
       
       
        
        
        
        
        

basic theta  ap theta  a  visibility graphs a  grids
 true shortest path 
      
      
     
      
      
      
    
     
      
      
     
      
      
      
      
      
      
      
      
      
       
       
      
      
       
       
n a
       
       
      
n a
      
       
       
n a
      
        
        
n a
       
        
        
n a
       
        
        
n a
        

a  ps
      
       
       
       
       
       
       
        
        
        
        
        

table    number vertex expansions

path planning algorithms implemented c  executed     ghz core   duo  
gbyte ram  implementations optimized possibly improved 
   

fit heta    ny a ngle path p lanning

      

      

fd 
game maps
random grids   
random grids   
random grids    
random grids    
random grids    
game maps
random grids   
random grids   
random grids    
random grids    
random grids    

     
      
      
      
     
     
      
      
      
      
      
      

g rids



basic theta  ap theta  a  visibility graphs a  grids
 true shortest paths 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
     
     
     
     
     
     
     
     
     
    
    
n a
     
    
    
n a
    
     
     
n a
     
     
     
n a
     
     
     
n a
     
     
      
n a
      

a  ps
    
    
    
    
     
     
    
    
     
     
     
     

   

   

   

   

   

   

   

   

   

   

runtime

path length

table    number heading changes

   

   

   

   

   

   

   

   

   

 
 

 

  

  

  

 

 

  

  blocked
fd 

basic theta 

  

  

  blocked

ap theta 

a  ps

fd 

basic theta 

 a  path length

ap theta 

a  ps

a 

 b  runtime

     

   

   

number heading changes

     

vertex expansions

     

     

     

   

   

   

   

   
     
   

 

 
 

 

  

  

  

 

 

  blocked
fd 

basic theta 

  

  

  

  blocked

ap theta 

a  ps

a 

fd 

 c  number vertex expansions

basic theta 

ap theta 

a  ps

a 

 d  number heading changes

figure     random         grids

   

fidaniel   nash   koenig     f elner

   h s 
x     s x  sgoal   x  
   
    s y  sgoal   y  
   

   
largest    max x     
   
smallest    min x     

   
return   smallest    largest smallest  
    end

algorithm    calculation octile distances

a  grids  a  ps  fd  a  visibility graphs break ties among vertices fvalue open list favor vertices larger g values  when decide vertex
expand next  since tie breaking scheme typically results fewer vertex expansions thus
shorter runtimes a   care must thus taken calculating g values  h values fvalues precisely  numerical precision
floating point numbers improved a 
grids representing form    n integers n  basic theta  ap
theta  break ties favor vertices smaller g values reasons explained section   
use path planning algorithms consistent h values since consistent h values result
short paths a   consistent h values satisfy triangle inequality  is  h value
goal vertex zero h value potential non goal parent vertex greater
distance potential non goal parent vertex vertex plus h value
vertex  hart et al         pearl         consistent h values lower bounds corresponding
goal distances vertices  increasing consistent h values typically decreases number vertex
expansions a  thus runtime a   thus use path planning algorithms
largest consistent h values easy calculate  basic theta   ap theta   fd 
a  visibility graphs  goal distances vertices equal true goal distances 
is  goal distances grids paths constrained grid edges  therefore use
path planning algorithms straight line distances h s    c s  sgoal   h values
experiments  straight line distances goal distances grids without blocked cells
paths constrained grid edges  a  grids a  ps  goal distances vertices
equal goal distances grids paths constrained grid edges  could therefore
use larger octile distances h values experiments  octile distances
goal distances grids without blocked cells paths constrained grid edges  algorithm
  shows calculate octile distance given vertex s  s x s y x
coordinates vertex s  respectively  indeed use a  grids octile distances a 
ps straight line distances since smoothing typically able shorten resulting
paths much increase number vertex expansions thus runtime  grids without
blocked cells provide example  octile
distances h values  a  grids finds paths
diagonal movements  whose lengths    precede horizontal vertical movements
 whose lengths    paths largest number diagonal movements
longest ones among paths number movements due tie breaking scheme
used  hand  straight line distances h values  a  grids finds paths
interleave diagonal movements horizontal vertical movements  which means
likely lots opportunities smooth paths even grids blocked
cells  closer straight line start goal vertices  which means
likely paths closer true shortest paths even grids blocked cells  
   

fit heta    ny a ngle path p lanning



g rids

figure     true shortest paths found fd   left   a  ps  middle  basic theta   right 
h values vertices closer straight line typically smaller h values
vertices farther away straight line 
tables     report experimental results  runtime a  visibility graphs  which finds
true shortest paths  long         grids thus omitted  figure    visualizes
experimental results random         grids  path length a  grids much larger
path lengths path planning algorithms thus omitted 
make following observations path lengths 
path planning algorithms order increasing path lengths tend be  a  visibility
graphs  which finds true shortest paths   basic theta   ap theta   fd   a  ps a 
grids  random         grids    percent blocked cells  basic theta  finds shorter
paths ap theta     percent time  shorter paths fd     percent time 
shorter paths a  ps    percent time shorter paths a  grids    percent
time 
paths found basic theta  ap theta  almost short true shortest paths even
though ap theta  sometimes constrains angle ranges necessary  example 
average less factor       longer true shortest paths        
grids 
basic theta  finds true shortest paths often fd  a  ps  figure    shows
example light green vertex center start vertex red  green
blue vertices represent goal vertices fd   a  ps basic theta  find true shortest
paths  respectively 
make following observations runtimes  path planning algorithms order
increasing runtimes tend be  a  grids  basic theta   ap theta   a  ps  fd  a 
visibility graphs 
make following observations numbers vertex expansions  path planning
algorithms order increasing numbers vertex expansions tend be  a  visibility graphs 
a  grids  ap theta   basic theta   fd  a  ps   the number vertex expansions a 
grids a  ps different use different h values  
   

fidaniel   nash   koenig     f elner

runtime
runtime per vertex expansion

fd 
    
        

basic theta 
    
        

ap theta 
    
        

a  ps
    
        

table    path planning algorithms without post processing steps random         grids
   percent blocked cells

finally  make following observations number heading changes  pathplanning algorithms order increasing numbers heading changes tend be  a  ps  a 
visibility graphs  basic theta   ap theta   a  grids fd  
exceptions trends reported above  therefore perform paired t tests 
show confidence level        basic theta  indeed finds shorter paths ap theta  
a  ps fd  basic theta  indeed shorter runtime ap theta   a  ps
fd  
summarize  a  visibility graphs finds true shortest paths slow  hand  a 
grids finds long paths fast  any angle path planning lies two extremes 
basic theta  dominates ap theta   a  ps fd  terms tradeoff runtime
path length  finds paths almost short true shortest paths almost fast
a  grids  simpler implement ap theta   therefore  build basic theta 
remainder article  although report experimental results ap theta 
well  however  ap theta  reduces runtime basic theta  per vertex expansion linear
constant  currently unknown whether constant time line of sight checks devised
make ap theta  faster basic theta   interesting area future research since
ap theta  potentially first step toward significantly reducing runtime any angle path
planning via sophisticated line of sight checks 

   extensions theta 
section  extend basic theta  find paths given start vertex vertices
find paths grids contain unblocked cells non uniform traversal costs 
    single source paths
far  basic theta  found paths given start vertex given goal vertex  discuss
version basic theta  finds single source paths  that is  paths given start vertex
vertices  terminating open list empty instead either open list
empty expands goal vertex 
finding single source paths requires path planning algorithms expand number
vertices  minimizes influence h values runtime thus results clean
comparison since h values sometimes chosen trade runtime path length 
runtimes a  ps fd  effected basic theta  ap theta 
finding single source paths since require post smoothing path extraction steps
   

fit heta    ny a ngle path p lanning



 

 

 

 

 



g rids

 
i 

i 
i 

b

i 
i 
i 

c

i 

basic theta  path non uniform traversal costs

figure     basic theta  grids contain unblocked cells non uniform traversal costs

 a  small contiguous regions uniform traversal costs
path cost
runtime

a  grids
       
     

fd 
       
     

basic theta 
       
     

 b  large contiguous regions uniform traversal costs
path cost
runtime

a  grids
       
    

fd 
       
    

basic theta 
       
    

table    path planning algorithms random           grids non uniform traversal costs

path  thus need post process many paths  table   reports runtimes path planning
algorithms without post processing steps  runtime basic theta  per vertex expansion
similar a  ps shorter either ap theta  fd  later two
algorithms require floating point operations 
    non uniform traversal costs
far  basic theta  found paths grids contain unblocked cells uniform traversal
costs  case  true shortest paths heading changes corners blocked cells
triangle inequality holds  means path   longer path    discuss
version basic theta  finds paths grids contain unblocked cells non uniform
traversal costs computing comparing path lengths  which path costs  appropriately 
case  true shortest paths heading changes boundaries unblocked
cells different traversal costs triangle inequality longer guaranteed hold 
means path   costly path    thus  basic theta  longer unconditionally
chooses path   path   path   unblocked  line     chooses path smaller
cost  uses standard cohen sutherland clipping algorithm computer graphics  foley  van
dam  feiner    hughes        calculate cost path   line of sight check  figure
   shows example path segment c a  vertex c  vertex a   straight line
split line segments points intersects cell boundaries  cost path
segment sum costs line segments ii ii     cost line segment
product length traversal cost corresponding unblocked cell 
found changing test line    algorithm   strictly less less
equal slightly reduces runtime basic theta   result fact faster
compute cost path segment corresponds path   path   since tends consist
fewer line segments 
   

fidaniel   nash   koenig     f elner



 

 

 

 

 



goal

 

 

 

 

 

goal
h      

h      
b

b

g      
g      
c

c

start

start

 a 

 b 

figure     non monotonicity f values basic theta 

compare basic theta  a  grids fd  respect path cost runtime
 measured seconds  since a  easily adapted grids contain unblocked cells
non uniform traversal costs fd  designed case  compare path planning
algorithms           grids  cell assigned integer traversal cost     
 corresponding unblocked cell  infinity  corresponding blocked cell   similar
technique used work ferguson stentz          path lies boundary
two cells different traversal costs  use smaller traversal cost two cells 
start goal vertices south west corners cells  start vertex south west cell 
goal vertex cell randomly chosen column cells furthest east  average
    random grids  table    a  reports results every traversal cost chosen uniform
probability  resulting small contiguous regions uniform traversal costs  path cost
runtime fd  smaller basic theta   path cost a  grids
  percent larger fd  although runtime much smaller fd   thus 
any angle planning large advantage a  grids  table   b  reports results
traversal cost one chosen probability    percent traversal costs chosen
uniform probability  resulting large contiguous regions uniform traversal costs  path
cost basic theta  smaller fd  runtime
fd   paths found fd  tend many unnecessary heading changes regions
traversal costs basic theta   outweighs paths found basic
theta  necessary heading changes boundary two cells different
traversal costs  path cost a  grids   percent larger basic theta  
thus  any angle planning larger advantage a  grids 

   trading runtime path length  exploiting h values
strategies trading runtime path length a  grids basic theta  share 
however  behavior different even though two algorithms similar
pseudocode  section  develop versions basic theta  might able find shorter
paths increase runtime  including versions use weighted h values weights less
one  break ties among vertices f value open list favor vertices
smaller g values  when decide vertex expand next  re expand vertices whose
f values decreased 
   

fit heta    ny a ngle path p lanning



g rids

use path planning algorithms consistent h values  a  grids following
properties  pearl         f value expanded vertex larger f value
unexpanded visible neighbors updating according path    implies
f value vertex expanded vertex larger f value
vertex  consequently  point time search vertex expanded 
following parents expanded vertex start vertex retrieves shortest path
start vertex expanded vertex reverse  implies a  cannot find shorter paths
expanding vertices once  basic theta  different properties  f value
expanded vertex larger f value one unexpanded visible neighbors
updating according path    implies f value vertex expanded
vertex larger f value vertex  consequently 
point time search vertex expanded  following parents
expanded vertex start vertex guaranteed retrieve shortest path start vertex
vertex reverse  implies basic theta  might find shorter paths expanding
vertices once  figure    shows example  basic theta  expands start vertex c 
parent c   generates vertex b   vertex b  unexpanded visible neighbor vertex c 
line of sight vertex c   basic theta  thus updates according path    which
path   case   sets f value f  b                         sets parent vertex
c  inserts open list  figure    a    basic theta  later expands vertex b 
parent c   generates vertex b   vertex b  unexpanded visible neighbor vertex b 
line of sight vertex c   basic theta  thus updates according path    sets f value
f  b                         sets parent vertex c  inserts open list  figure
   b    thus  f value expanded vertex b  indeed larger f value unexpanded
visible neighbor b  updating according path   increase g value vertex
b  vertex b           less decrease h value vertex b  vertex b           
basic theta  later expands vertex b   f value vertex b           expanded
vertex b  indeed larger f value vertex b           
properties suggest basic theta  might able find shorter paths increase
runtime re expanding vertices expanding additional vertices  for example using weighted
h values weights less one  a  cannot  time  standard optimizations
a  decrease runtime might able decrease runtime basic theta   such
breaking ties among vertices f value open list favor vertices larger
g values   section investigate tradeoffs 
    weighted h values
far  basic theta  used consistent h values h s   a  consistent h values finds paths
length matter small large h values are  decreasing consistent h values typically
increases number vertex expansions a   therefore discuss version basic
theta  might able find shorter paths increase runtime using weighted h values
weights less one  version basic theta  uses h values h s    w c s  sgoal  
given weight   w     thus similar weighted a   pohl         except weighted
a  typically uses weights greater one  figure    a  shows example resulting effect
number vertex expansions path length  green vertex north east start

   

fidaniel   nash   koenig     f elner

 a  expanded vertices basic theta  different weights
     

      

     
      
     

path length

      

     

      
     

vertex expansions

   

     
     
     

   

 
 

    

   

    

   

    

   

    

 

w
basic theta  path length

ap theta  path length

basic theta  vertex expansions

ap theta  vertex expansions

 b  random         grids    percent blocked cells

figure     weighted h values

vertex  red vertex south west goal vertex  basic theta  weight       as
used far  expands orange vertices finds red path  basic theta  weight     
expands blue vertices finds blue path  thus  basic theta  expands vertices
   

fit heta    ny a ngle path p lanning

path length
number vertex expansions
runtime

smaller g values
basic theta  ap theta 
      
      
        
        
      
      



g rids

larger g values
basic theta  ap theta 
      
      
        
        
      
      

table    random         grids    percent blocked cells


weight      weight      resulting path shorter since passes vertices
expanded weight      weight      
figure    b  reports effect different weights path length number vertex expansions basic theta  ap theta  random         grids    percent blocked cells 
 the graphs number vertex expansions basic theta  ap theta  nearly coincide  
decreasing weight decreases path length increase number vertex expansions
thus runtime  path length decreases ap theta  basic theta  since ap
theta  constrain angle ranges necessary thus benefits two ways expanding vertices  however  neither basic theta  ap theta  guaranteed find true
shortest paths even weights zero 
    tie breaking
far  basic theta  broken ties among vertices open list f value favor
vertices larger g values  when decides vertex expand next   a  consistent
h values finds paths length matter tie breaking scheme uses  breaking ties
favor vertices smaller g values typically increases number vertex expansions
thus runtime  therefore discuss version basic theta  might able find shorter
paths increase runtime breaking ties favor vertices smaller g values  figure   
shows example resulting effect path length  vertices c  b  f value
vertex b  larger g value since f  c                      f  b                   
basic theta  breaks ties favor vertices larger g values  expands vertex b 
parent e  vertex c  parent c  eventually expands goal vertex parent b 
terminates  path extraction follows parents goal vertex b  start vertex e 
retrieve dashed red path  e   b   b    however  basic theta  breaks ties favor vertices
smaller g values  expands vertex c  parent c  vertex b  parent e 
eventually expands goal vertex parent c  terminates  path extraction follows
parents goal vertex b  start vertex e  retrieve shorter solid blue path  e   c  
b   
table   reports effect tie breaking scheme path length  number vertex expansions
runtime basic theta  ap theta  random         grids    percent blocked
cells  breaking ties favor vertices smaller g values neither changes path length 
number vertex expansions runtime significantly  effect tie breaking scheme
small since fewer vertices f value basic theta  ap theta  a 
grids number possible g values h values larger any angle path planning 
   

fidaniel   nash   koenig     f elner



 

 

 

b

 

 

goal

c



e

start

basic theta  path  larger g values 

basic theta  path  smaller g values 

figure     basic theta  paths different tie breaking schemes

path length
number vertex expansions
runtime

basic theta  without vertex re expansions
      
        
      

basic theta  vertex re expansions
      
        
      

table    random         grids    percent blocked cells

second method breaking ties effect path length  far  basic theta 
chosen path   path   unexpanded visible neighbor vertex line of sight
parent vertex  however  choose path   path   paths equally long 
increases runtime due additional comparison  figure    shows example
resulting effect path length  assume basic theta  expands vertex b  vertex c  
basic theta  chooses path   path   expands vertex b  parent e  eventually
expands goal vertex b  parent b  terminates  path extraction follows parents
goal vertex b  start vertex e  retrieve dashed red path  e   b   b    however 
basic theta  chooses path   path   expands vertex b  parent c  eventually
expands goal vertex b  parent c  terminates  path extraction follows parents
goal vertex b  start vertex e  retrieve shorter solid blue path  e   c   b   
    re expanding vertices
far  basic theta  used closed list ensure expands vertex once  a 
consistent h values re expand vertices whether uses closed list since
cannot find shorter path start vertex vertex expanding vertex 
hand  basic theta  re expand vertices use closed list since find shorter
path start vertex vertex expanding vertex  re inserts vertex
   

fit heta    ny a ngle path p lanning



 

 

 

 

 

 



 

g rids

 

b

 

goal

c



e

start

basic theta  path

basic theta  path vertex re expansions

figure     basic theta  paths without vertex re expansions
open list eventually re expands it   figure    shows example effect vertex
re expansions path length  basic theta  without vertex re expansions eventually expands vertex
c  parent d   vertex c  unexpanded visible neighbor vertex c  line of sight
vertex d   basic theta  without vertex re expansions thus updates according path  
sets parent vertex d   termination  path extraction follows parents goal vertex
b  start vertex e  retrieve dashed red path  e   d   c   b    however  basic theta 
vertex re expansions eventually expands vertex c  parent d  later re expands vertex c 
parent e   vertex c  visible neighbor vertex c  line of sight vertex e  
basic theta  vertex re expansions thus updates according path   sets parent
vertex e   termination  path extraction follows parents goal vertex b  start vertex
e  retrieve shorter solid blue path  e   c   b   
theorem    basic theta  vertex re expansions terminates path extraction returns
unblocked path start vertex goal vertex path exists  otherwise  basic
theta  vertex re expansions terminates reports unblocked path exists 

proof  proof similar proof theorem    property needs proved
differently basic theta  vertex re expansions terminates since longer true
never insert vertex open list removed vertex open list 
however  since number vertices finite  finite number acyclic paths
start vertex vertex  therefore  number possible g values finite  therefore  basic
theta  vertex re expansions reduce g value vertex finite number times
thus inserts vertex open list finite number times  thus  open list eventually
becomes empty basic theta  terminate terminated earlier already 
   basic theta  vertex re expansions could delay expansion goal vertex  for example  increasing
f value artificially  re expand vertices terminates version basic theta 
vertex re expansions that 

   

fidaniel   nash   koenig     f elner

table   reports effect vertex re expansions path length  number vertex expansions
runtime basic theta  random         grids    percent blocked cells  vertex
re expansions decrease path length slightly increase number vertex expansions
thus runtime 

    trading runtime path length  approaches
additional strategies trading runtime path length specific basic
theta   section  develop versions basic theta  might able find shorter
paths increase runtime examining paths  including versions check line ofsight parent parent  use key vertices identify promising parents increase
number visible neighbors thus number potential parents updating vertices
according path   
     three paths
far  basic theta  considered two paths  namely paths      updates gvalue parent unexpanded visible neighbor vertex s  discuss version
basic theta  considers third path  namely path start vertex parent
parent vertex    g parent parent s     vertex straight line   
c parent parent s        resulting length g parent parent s      c parent parent s      
version basic theta  might able find shorter paths increase runtime since
third path longer path   due triangle inequality  however  experimental results
 not reported here  show third path decrease path length significantly
original version basic theta  already determines parent parent vertex
line of sight vertex shares parent vertex s  thus  unlikely
parent parent vertex line of sight vertex thus third path
unblocked 
     key vertices
far  basic theta  considered two paths  namely paths      updates g value
parent unexpanded visible neighbor vertex s  parent vertex either
visible neighbor vertex parent visible neighbor  always case
true shortest paths  discuss version basic theta  considers additional paths 
namely paths start vertex cached key vertices vertex straight
line  version basic theta  might able find shorter paths increase runtime
due fact parent vertex one key vertices  however 
experimental results  not reported here  show key vertices decrease path length slightly
larger increase runtime due overhead select key vertices  maintain
consider larger number paths 

   

fit heta    ny a ngle path p lanning

 a  branching factor  

 b  branching factor  



g rids

 c  branching factor   

figure     grids different branching factors

   

   
     

   

   

   

   
   

     

runtime

path length

     

   
   

     
   

   

     
   

 
 

basic theta 

  

branching factor
path length

runtime

figure     basic theta  random         grids    percent blocked cells

     larger branching factors
far  basic theta  operated eight neighbor grids  discuss version basic theta 
operates grids different numbers neighbors thus different branching factors 
figure    shows neighbors center vertex branching factors         respectively 
version basic theta  might able find shorter paths increase runtime since
larger branching factors increase number visible neighbors vertices thus number
potential parents updating according path    figure    reports effect larger
branching factors path length runtime basic theta  random         grids
   percent blocked cells  larger branching factors indeed decrease path length increase
runtime 
   

fidaniel   nash   koenig     f elner

    conclusions
any angle path planning algorithms find paths without artificially constraining headings
paths  presented two new correct complete any angle path planning algorithms  basic
theta  angle propagation theta   ap theta   variants a  propagate information along grid edges  to achieve short runtime  without constraining paths grid edges  to find
any angle paths   basic theta  simple understand implement  fast finds short paths 
however  guaranteed find true shortest paths  ap theta  achieves worst case complexity per vertex expansion constant  like a  grids  rather linear number
cells  like basic theta   propagating angle ranges expands vertices  however 
ap theta  complex basic theta   fast finds slightly longer paths 
proved correctness completeness basic theta  ap theta  compared
three existing any angle path planning algorithms  namely a  post smoothed
paths  a  ps   a  visibility graphs field d   fd    version a  know
propagates information along grid edges without constraining paths grid edges  basic
theta  ap theta   unlike a  ps  consider paths constrained grid edges
search thus make informed decisions regarding paths search  basic theta 
ap theta   unlike fd   take advantage fact true shortest paths heading changes
corners blocked cells 
a  visibility graphs finds true shortest paths slow  hand  a  grids finds
long paths fast  any angle path planning lies two extremes  basic theta 
dominates ap theta   a  ps fd  terms tradeoffs runtime path length 
finds paths almost short true shortest paths almost fast a  grids 
extended basic theta  find paths given start vertex vertices find
paths grids contain cells non uniform traversal costs  f value expanded vertex
basic theta   unlike a  grids  consistent h values larger f value one
unexpanded visible neighbors  means basic theta  might able find
shorter paths increase runtime re expanding vertices expanding additional vertices 
thus developed versions basic theta  use weighted h values weights less one 
break ties among vertices f value open list favor vertices smaller
g values  when decide vertex expand next   re expand vertices whose f values
decreased  check line of sight parent parent  use key vertices identify
promising parents increase number visible neighbors 
future  intend develop worst case bound path lengths basic theta  ap
theta   better understand properties investigate faster versions ap theta 
perform line of sight checks constant time 

appendix a  checking line of sight
appendix  explain perform line of sight checks fast  simplicity  allow
straight lines pass diagonally touching blocked cells  performing line of sight check
similar determining points plot raster display drawing straight line two points  plotted points correspond cells straight line passes through 
   

fit heta    ny a ngle path p lanning



g rids

    lineofsight s  s 
   
x     s x 
   
y     s y 
   
x      x 
   
y      y 
   
dy    y  y   
   
dx    x  x   
   
f      
   
dy    
   
dy    dy  
   
sy      
   
   

else

   
   
   

dx    
dx    dx  
sx      

   
   

else

   
   
   
   
   
   

dx dy
x     x 
f    f   dy  
f dx
grid x      sx        y      sy       
return false 

sy      

sx      

y     y    sy  
f    f dx  

   
   
   
   

f      grid x      sx        y      sy       
return false 

   
   

dy     grid x      sx        y    grid x      sx        y    
return false 

   

x     x    sx  

   
   
   
   
   
   

else
y     y 
f    f   dx  
f dy
grid x      sx        y      sy       
return false 
x     x    sx  
f    f dy  

   
   
   
   

f      grid x      sx        y      sy       
return false 

   
   

dx     grid x    y      sy        grid x     y      sy       
return false 

   

y     y    sy  

   
return true 
    end

algorithm    line of sight algorithm

thus  two vertices line of sight iff none plotted points correspond blocked cells 
allows basic theta  perform line of sight checks standard bresenham line drawing
algorithm computer graphics  bresenham         uses fast logical integer operations rather floating point operations  algorithm   shows resulting line of sight algorithm 
   

fidaniel   nash   koenig     f elner

ii

yaxis



p
b 

xaxis

b 

b 
b 

b 

b 
b 

b 

b 
b 



iii

b   

upper boundary

iv
lower boundary

figure     parent  blocked cell boundary vertices
s x s y x coordinates vertex s  respectively  grid represents grid
grid x  y  true iff corresponding cell blocked 

appendix b  ap theta  returns unblocked paths
appendix  prove ap theta  never returns blocked path 
theorem    ap theta  never returns blocked path 
proof  define path blocked iff least one vertex path line of sight
successor path  thus  path blocked iff least one path segments passes
interior blocked cell passes two blocked cells share edge 
first prove ap theta  never returns path path segment passes
interior blocked cell  prove contradiction ap theta  cannot assign parent p
vertex path segment parent p vertex passes interior
blocked cell b  assume otherwise  simplify proof  translate rotate grid
blocked cell b immediately south west origin b  grid parent p quadrant
ii  shown figure     define quadrant vertex follows  s x s y
x coordinates vertex s  respectively 
quadrant north east quadrant  excluding x axis  given s x   s y     
quadrant ii north west quadrant  excluding y axis  given s x     s y   
quadrant iii south west quadrant  excluding x axis  given s x   s y     
   

fit heta    ny a ngle path p lanning

northwest s 
west s 
southwest s 

north s 


south s 



g rids

northeast s 
east s 
southeast s 

figure     neighbors vertex
quadrant iv south east quadrant  excluding y axis including origin b    given
s x     s y   s x     s y     
refer neighbors vertex east s   northeast s   north s   northwest s   west s  
southwest s   south s   southeast s   shown figure    
assume light source vertex p light cannot pass blocked cell b 
creates shadow  vertex shadow iff straight line parent p vertex
passes interior blocked cell b  distinguish two parts perimeter
shadow  namely upper lower boundary  shown figure     define boundary vertex
vertex shadow least one neighbor  although necessarily visible
neighbor  shadow  origin b  shadow neighbor south b   
shadow  thus  origin b  boundary vertex  consider upper boundary without
loss generality  then  boundary vertex  to precise  upper boundary vertex  vertex
 s  p  b       that is  upper boundary thus outside shadow 
least one neighbor  s   p  b         that is  upper boundary thus inside
shadow   easy see boundary vertices quadrant iv form infinite
boundary path  b    b           starts origin b  repeatedly moves either south east 
is  bi     south bi   bi     east bi   
define vertex sufficiently constrained iff  s  p  b    lb s  parent p 
vertex sufficiently constrained  remains sufficiently constrained since operation ap
theta  decrease lower angle bound lb s   prove following every boundary
vertex sufficiently constrained time expanded expanded parent p  consider
vertex upper boundary  that is   s  p  b        thus  b    p  s      
visible neighbor boundary vertex bi   vertex cannot updated according path  
assigned parent p time parent p expanded since straight line parent p
vertex passes interior blocked cell therefore visible neighbors 
cannot updated according path   assigned parent p time boundary
vertex bi expanded parent p boundary vertex bi sufficiently constrained
time thus  bi   p  b    lb bi    implies  bi   p  s     bi   p  b       b    p  s   
 bi   p  b    lb bi   condition line    remains unsatisfied  consequently  vertex
shadow parent p 
prove induction order vertex expansions every boundary vertex
sufficiently constrained time expanded expanded parent p  assume
boundary vertex b  expanded parent p  then  condition line    satisfied
   

fidaniel   nash   koenig     f elner

line    executed blocked cell b time boundary vertex b  expanded parent p 
boundary vertex b  sufficiently constrained afterwards since lower angle bound set zero 
assume boundary vertex bi     expanded parent p  then  boundary vertex bi
cannot identical parent p  since different quadrants  start vertex  since
start vertex parent p   boundary vertex bi cannot updated according path
  assigned parent p time parent p expanded since p x      bi   x    
thus neighbors  consequently  boundary vertex bi must updated according
path   assigned parent p time one visible neighbors x expanded
parent p  vertex x must upper boundary  that is   x  p  b       cannot
identical parent p  since different quadrants   distinguish two cases 
assume vertex x boundary vertex  sufficiently constrained time expanded parent p according induction assumption  that is   x  p  b    lb x  
since expanded boundary vertex bi   boundary vertex bi updated according
path   time vertex x expanded parent p  thus  condition line
   satisfied time  that is  lb x   x  p  bi    thus lb x     bi   p  x   
lb x   x  p  bi      then  conditions lines       satisfied
line    executed   x time boundary vertex bi expanded parent
p  boundary vertex bi sufficiently constrained afterwards since lower angle bound
set max lb bi    lb x     bi   p  x    bi   p  b       bi   p  x     x  p  b   
lb x     bi   p  x  max lb bi    lb x     bi   p  x   
assume vertex x boundary vertex 
lemma    assume vertex boundary vertex bi visible neighbors  c p  bi    
c p  s   s  p  bi        assume boundary vertex bi sufficiently constrained
time vertex expanded parent p boundary vertex bi expanded parent
p time  then  vertex sufficiently constrained time expanded
expanded parent p 
proof  assume vertex expanded parent p  then   s  p  b       s  p  bi    
 bi   p  b        since  s  p  bi        bi   p  b       distinguish two cases 
assume boundary vertex bi expanded vertex expanded
parent parent p  then  conditions lines       satisfied
line    executed   bi time vertex expanded parent
p  vertex sufficiently constrained afterwards since lower angle bound set
max lb s    s  p  bi     s  p  b       s  p  bi      bi   p  b     s  p  bi  
max lb s    s  p  bi    
assume boundary vertex bi expanded parent p vertex expanded
parent p  boundary vertex bi sufficiently constrained time vertex
expanded parent p according premise  that is   bi   p  b    lb bi     furthermore  lb bi      since operation ap theta  make lower angle bound
positive  thus lb bi      s  p  bi      then  conditions lines      
satisfied line    executed   bi time vertex expanded
parent p  vertex sufficiently constrained afterwards since lower angle bound
   

fit heta    ny a ngle path p lanning



g rids

set max lb s   lb bi      s  p  bi     s  p  b       s  p  bi      bi   p  b   
lb bi      s  p  bi   max lb s   lb bi      s  p  bi    

boundary vertex bi either immediately south east boundary vertex bi  since
boundary path moves south east  distinguish three subcases 
assume parent p x axis quadrant ii  then  boundary path
along x axis  vertices west bi   east bi   boundary vertices  vertices
southwest bi    south bi    southeast bi   upper boundary  thus 
vertex x identical one vertices northwest bi    north bi   northeast bi   
cases  boundary vertex bj immediately south vertex x  vertices x
bj visible neighbors  would blocked cells immediately southwest south east vertex x vertices x bi could thus visible neighbors 
thus  vertices x bj visible neighbors  furthermore  boundary vertex bj immediately south vertex x thus c p  bj     c p  x   x  p  bj        finally 
boundary vertex bj sufficiently constrained according induction assumption
time boundary vertex bi expanded parent p boundary vertex bj
expanded parent p time  thus  vertex x sufficiently constrained time
expanded parent p according lemma    that is   x  p  b    lb x    consequently  conditions lines       satisfied  for reason given before 
line    executed   x time boundary vertex bi expanded parent
p  boundary vertex bi sufficiently constrained afterwards since lower angle bound
set max lb bi    lb x     bi   p  x    bi   p  b       bi   p  x     x  p  b   
lb x     bi   p  x  max lb bi    lb x     bi   p  x   
assume parent p x axis quadrant ii boundary vertex
bi immediately east boundary vertex bi  thus c p  bi      c p  bi  
 bi   p  bi         furthermore  boundary vertex bi  sufficiently constrained according induction assumption time boundary vertex bi expanded
parent p boundary vertex bi  expanded parent p time  boundary vertices bi  bi visible neighbors  boundary vertex bi sufficiently
constrained time expanded parent p according lemma    boundary
vertices bi  bi visible neighbors  must blocked cells immediately north west south west boundary vertex bi   then  line    satisfied
line    executed blocked cell immediately south west boundary vertex bi
time boundary vertex bi expanded parent p  boundary vertex bi sufficiently
constrained afterwards since lower angle bound set zero 
assume parent p x axis quadrant ii boundary vertex bi
immediately south boundary vertex bi   
lemma    assume vertex quadrant iv upper boundary 
then  vertex boundary vertex iff vertex immediately south west vertex
upper boundary 
   

fidaniel   nash   koenig     f elner

proof  vertex immediately south west vertex upper boundary 
vertex boundary vertex definition  hand  vertex
upper boundary  that is   s   p  b        vertex boundary
vertex every neighbor upper boundary  neighbors
vertex
east s   northeast s   north s   northwest s  
west s   southwest s   south s  southeast s  
or  equivalently 
east east north s      east east north north s       east north north s     
north north s     north s      east s   east east s    
thus  every neighbor vertex reached vertex repeatedly moving either north east thus  s   p       consequently   s   p  b     
 s   p       s   p  b      thus every neighbor vertex
upper boundary 
distinguish two subcases 
assume boundary vertex bi   immediately east boundary vertex
bi   vertices north bi   east bi   boundary vertices  vertices west bi   
southwest bi   south bi   south west boundary vertices bi    bi bi    
respectively  thus upper boundary according lemma    vertices
northwest bi   southeast bi   either boundary vertices south west
boundary vertices bi  bi     respectively  upper boundary
according lemma    thus  vertex x identical vertex northwest bi   
assume boundary vertex bi   immediately south boundary vertex bi  
vertices north bi   south bi   boundary vertices  vertices west bi  
southwest bi   south west boundary vertices bi  bi   respectively 
thus upper boundary according lemma    vertex northwest bi  
either boundary vertex south west boundary vertex bi 
upper boundary according lemma    thus  vertex x identical one vertices
northeast bi    east bi   southeast bi   
cases  vertex x immediately east boundary vertex bj thus c p  bj    
c p  x   x  p  bj        vertices x bj visible neighbors 
would blocked cells immediately north west south west vertex x vertices
x bi could visible neighbors  thus  vertices x bj visible neighbors 
furthermore  boundary vertex bj sufficiently constrained according induction
assumption time boundary vertex bi expanded parent p boundary vertex bj expanded parent p time  thus  vertex x sufficiently
constrained time expanded parent p according lemma    that is 
 x  p  b    lb x    consequently  conditions lines       satisfied  for
reason given before  line    executed   x time boundary vertex
bi expanded parent p  boundary vertex bi sufficiently constrained afterwards
since lower angle bound set max lb bi    lb x     bi   p  x    bi   p  b     
 bi   p  x     x  p  b    lb x     bi   p  x  max lb bi    lb x     bi   p  x   
   

fit heta    ny a ngle path p lanning



g rids

concludes proof every boundary vertex sufficiently constrained time
expanded expanded parent p thus proof ap theta  never returns path
path segment passes interior blocked cell 
prove ap theta  never returns path path segment passes two
blocked cells share edge  prove contradiction ap theta  cannot assign
parent p vertex path segment parent p vertex passes two
blocked cells share edge  assume otherwise consider first time ap theta  assigns
parent p vertex path segment parent p vertex passes
two blocked cells share edge  path segment must either horizontal vertical  vertex
cannot updated according path   assigned parent p time parent p
expanded since straight line parent p vertex passes interior
blocked cell therefore visible neighbors  cannot updated according
path   assigned parent p time visible neighbor expanded parent p
since either a  neighbor would colinear vertices p straight line
parent p vertex would thus pass interior blocked cell b  neighbor would
colinear vertices p straight line parent p vertex would pass
two blocked cells share edge  contradiction assumption  concludes
proof ap theta  never returns path path segment passes two blocked
cells share edge 
thus  ap theta  never returns blocked path 

appendix c  acknowledgments
article extension earlier publication  nash et al         contains additional
expositions  examples proofs  thank vadim bulitko university alberta
making maps real time game baldurs gate ii available us  research done
ariel felner spent sabbatical university southern california  visiting sven koenig 
research partly supported u s  army research laboratory  arl  u s 
army research office  aro  award sven koenig grant w   nf            office
naval research  onr  award sven koenig grant n                 national
science foundation  nsf  award sven koenig grant         israeli science
foundation  isf  award ariel felner grants                alex nash funded
northrop grumman corporation  views conclusions contained document
authors interpreted representing official policies  either
expressed implied  sponsoring organizations  agencies  companies u s  government 

references
aurenhammer  f          voronoi diagramsa survey fundamental geometric data structure 
acm computing surveys                
botea  a   muller  m     schaeffer  j          near optimal hierarchical path finding  journal
game development            
   

fidaniel   nash   koenig     f elner

bresenham  j          algorithm computer control digital plotter  ibm systems journal 
           
bulitko  v   sturtevant  n     kazakevich  m          speeding learning real time search via
automatic state abstraction  proceedings aaai conference artificial intelligence 
pp           
choset  h   lynch  k   hutchinson  s   kantor  g   burgard  w   kavraki  l     thrun  s         
principles robot motion  theory  algorithms  implementations  mit press 
deloura  m          game programming gems  charles river media 
ferguson  d     stentz  a          using interpolation improve path planning  field d 
algorithm  journal field robotics               
foley  j   van dam  a   feiner  s     hughes  j          computer graphics  principles practice  addison wesley 
hart  p   nilsson  n     raphael  b          formal basis heuristic determination
minimum cost paths  ieee transactions systems science cybernetics  scc      
       
kavraki  l   svestka  p   latombe  j     overmars  m          probabilistic roadmaps path
planning high dimensional configuration spaces  ieee transactions robotics automation                
koenig  s     likhachev  m          d  lite  proceedings aaai conference artificial
intelligence  pp         
lavalle  s     kuffner  j          rapidly exploring random trees  progress prospects 
donald  b   lynch  k     rus  d   eds    algorithmic computational robotics  new
directions  pp          k peters 
lee  d  t          proximity reachability plane  ph d  thesis  university illinois
urbana champaign 
liu  y  h     arimoto  s          path planning using tangent graph mobile robots among
polygonal curved obstacles  international journal robotics research                
lozano perez  t     wesley  m          algorithm planning collision free paths among
polyhedral obstacles  communication acm             
mitchell  j     papadimitriou  c          weighted region problem  finding shortest paths
weighted planar subdivision  journal acm              
murphy  r          introduction ai robotics  mit press 
nash  a   daniel  k   koenig  s     felner  a          theta   any angle path planning grids 
proceedings aaai conference artificial intelligence  pp           
nash  a   koenig  s     likhachev  m          incremental phi   incremental any angle path planning grids  proceedings international joint conference aritificial intelligence 
pp           
patel  a         
amits game programming information 
available online
http   theory stanford edu amitp gameprogramming maprepresentations html 
   

fit heta    ny a ngle path p lanning



g rids

pearl  j          heuristics  intelligent search strategies computer problem solving  addisonwesley 
pohl  i          avoidance  relative  catastrophe  heuristic competence  genuine dynamic
weighting computational issues heuristic problem solving  proceedings international joint conference artificial intelligence  pp       
rabin  s          ai game programming wisdom  charles river media 
rabin  s          ai game programming wisdom    charles river media 
thorpe  c          path relaxation  path planning mobile robot  proceedings aaai
conference artificial intelligence  pp         
tozour  p          search space representations  rabin  s   ed    ai game programming wisdom
   pp         charles river media 
yahja  a   stentz  a   singh  s     brumitt  b          framed quadtree path planning mobile
robots operating sparse environments  proceedings international conference
robotics automation  pp         
yap  p          grid based path finding  proceedings canadian conference artificial
intelligence  pp       

   


