journal of artificial intelligence research                  

submitted        published      

theta   any angle path planning on grids
kenny daniel
alex nash
sven koenig

kfdaniel   usc   edu
anash   usc   edu
skoenig   usc   edu

computer science department
university of southern california
los angeles  california             usa

ariel felner

felner   bgu   ac   il

department of information systems engineering
ben gurion university of the negev
beer sheva         israel

abstract
grids with blocked and unblocked cells are often used to represent terrain in robotics and video
games  however  paths formed by grid edges can be longer than true shortest paths in the terrain
since their headings are artificially constrained  we present two new correct and complete anyangle path planning algorithms that avoid this shortcoming  basic theta  and angle propagation
theta  are both variants of a  that propagate information along grid edges without constraining
paths to grid edges  basic theta  is simple to understand and implement  fast and finds short paths 
however  it is not guaranteed to find true shortest paths  angle propagation theta  achieves a
better worst case complexity per vertex expansion than basic theta  by propagating angle ranges
when it expands vertices  but is more complex  not as fast and finds slightly longer paths  we
refer to basic theta  and angle propagation theta  collectively as theta   theta  has unique
properties  which we analyze in detail  we show experimentally that it finds shorter paths than
both a  with post smoothed paths and field d   the only other version of a  we know of that
propagates information along grid edges without constraining paths to grid edges  with a runtime
comparable to that of a  on grids  finally  we extend theta  to grids that contain unblocked cells
with non uniform traversal costs and introduce variants of theta  which provide different tradeoffs
between path length and runtime 

   introduction
in this article  we study path planning for robotics and video games  choset  lynch  hutchinson 
kantor  burgard  kavraki    thrun        deloura        patel        murphy        rabin        
where a two dimensional continuous terrain is discretized into a grid with blocked and unblocked
cells  our objective is to find a short unblocked path from a given start vertex to a given goal vertex
 both at the corners of cells   a  finds grid paths  that is  paths constrained to grid edges  quickly  but
grid paths are often not true shortest paths  that is  shortest paths in the terrain  since their potential
headings are artificially constrained to multiples of    degrees  as shown in figure   a   yap        
this shortcoming led to the introduction of what we call any angle path planning  nash  daniel 
koenig    felner        ferguson   stentz         any angle path planning algorithms find paths
c
    
ai access foundation  all rights reserved 

fidaniel   nash   koenig     f elner

a

 

 

 

 

 

a

s start

b

c

 

 

 

 

 

s start

b

c

s goal
 a  grid path

s goal
 b  true shortest path

figure    grid path versus true shortest path
without constraining the headings of the paths  as shown in figure   b   we present two new
correct and complete any angle path planning algorithms  basic theta  and angle propagation
theta  are both variants of a  that propagate information along grid edges  to achieve a short
runtime  without constraining paths to grid edges  to find any angle paths   unlike a  on visibility
graphs  they are not guaranteed to find true shortest paths  the asterisk in their names thus does not
denote their optimality but rather their similarity to a   basic theta  is simple to understand and
implement  fast and finds short paths  angle propagation theta  achieves a worst case complexity
per vertex expansion that is constant rather than linear in the number of cells  like that of basic
theta   by propagating angle ranges when it expands vertices  but is more complex  is not as fast
and finds slightly longer paths  we refer to basic theta  and angle propagation theta  collectively
as theta   theta  has unique properties  which we analyze in detail  we show experimentally that
it finds shorter paths than both a  with post smoothed paths and field d   the only other version
of a  we know of that propagates information along grid edges without constraining paths to grid
edges  with a runtime comparable to that of a  on grids  finally  we extend theta  to grids that
contain unblocked cells with non uniform traversal costs and introduce variants of theta  which
provide different tradeoffs between path length and runtime 

   path planning problem and notation
in this section  we describe the path planning problem that we study in this article  namely path
planning on eight neighbor grids with blocked and unblocked cells of uniform size  cells are labeled
as either blocked  grey  or unblocked  white   we use the corners of cells  rather than their centers 
as vertices  s is the set of all vertices  the path planning problem is to find an unblocked path from
a given start vertex sstart to a given goal vertex sgoal  
a path is unblocked iff each vertex on the path has line of sight to its successor on the path  vertex
s has line of sight to vertex s   written as lineofsight s  s    iff the straight line from vertex s to
vertex s neither passes through the interior of blocked cells nor passes between blocked cells that
share an edge  pseudocode for implementing the line of sight function is given in appendix a  for
simplicity  we allow a straight line to pass between diagonally touching blocked cells 
c s  s   is the length of the straight line from vertex s to vertex s   nghbrsvis  s  is the set of visible
neighbors of vertex s in the eight compass directions  that is those neighbors of vertex s that have
   

fit heta    a ny a ngle path p lanning

on

g rids

line of sight to vertex s  figure   shows an example where the visible neighbors of vertex b  are
vertices a   a   a   b   b   c  and c  

   existing terrain discretizations
continuous terrain needs to be discretized for path planning  in this section  we compare grids to
other existing terrain discretizations  we use grids to discretize terrain since they are widely used in
robotics and video games  deloura        murphy        rabin        and have several desirable
properties 
 grids are simple data structures and allow for simple path planning algorithms 
 terrain can easily be discretized into a grid by laying the grid over the terrain and labeling all
cells that are partially or completely obstructed as blocked 
 grids provide a comprehensive picture of all the traversable surfaces in the continuous terrain 
this is essential when the path planning algorithm is used in a dynamic environment and
must interact with a navigation planner  for example if a robot or video game character
encounters a temporary blockage to its path  it can easily determine whether it is best to
divert left  unblocked  or right  blocked   tozour        
 cells can store information in addition to their traversability  such as the amount of gold
hidden in the region of the terrain that corresponds to the cell or a rendering of the region
when displaying the terrain 
 the information stored in cells can be accessed quickly since grids are random access data
structures 
 the precision of path and navigation planning can be improved by simply increasing the grid
resolution 
we now list some alternative terrain discretizations  assuming for simplicity that the obstacles in the
terrain are polygonal 
 voronoi graphs  aurenhammer        discretize the terrain by biasing paths away from
blocked polygons  the resulting paths can thus be much longer than true shortest paths 
 the discretization in the work of mitchell and papadimitriou        partitions the terrain into
regions with linear and hyperbolic edges  which allows one to find true shortest paths with
time and space complexity o m       where m is the number of corners of blocked polygons 
thus  the runtime of path planning can grow superlinearly in the number of corners of blocked
polygons 
 framed quadtrees  yahja  stentz  singh    brumitt        recursively subdivide terrain into
four equally sized cells until all cells are completely obstructed  completely unobstructed or
of sufficiently small size  the resulting paths can have unnecessary heading changes  that is 
heading changes that occur in free space rather than the corners of blocked polygons  
   

fidaniel   nash   koenig     f elner

  main  
 
g sstart        
 
parent sstart      sstart  
 
open     
 
open insert sstart   g sstart     h sstart    
 
closed     
 
while open     do
 
s    open pop   
if s   sgoal then
 
  
return path found 
  
  
  
  
  
  
  
  
  

closed    closed   s  
   the following line is executed only by ap theta  
 updatebounds s   
foreach s  nghbrsvis  s  do
if s   closed then
if s   open then
g s       
parent s      n u ll 

   

updatevertex s  s   

  
return no path found 
   end
   updatevertex s s 
  
if g s    c s  s     g s   then
  
g s      g s    c s  s   
  
parent s      s 
  
if s  open then
  
open remove s   
  

open insert s   g s     h s    

   end

algorithm    a 

 probabilistic roadmaps  kavraki  svestka  latombe    overmars        or rapidly exploring
random trees  lavalle   kuffner        place vertices randomly  in addition to the start and
goal vertex   two vertices are connected via a straight line iff they have line of sight  the
random placement of vertices needs to be tuned carefully since it influences the runtime of
path planning  the likelihood of finding a path and the length of the path 
 visibility graphs  lee        lozano perez   wesley        use the corners of each blocked
polygon as vertices  in addition to the start and goal vertex   two vertices are connected via
a straight line iff they have line of sight  which allows one to find true shortest paths  the
runtime of path planning can grow superlinearly in the number of vertices since the number
of edges can grow quadratically in the number of vertices 

   existing path planning algorithms
in this section  we describe some existing path planning algorithms  all of which are variants of a 
 hart  nilsson    raphael         a  is a popular path planning algorithm in robotics and video
games  algorithm   shows the pseudocode of a   line    is to be ignored  a  maintains three
values for every vertex s 
   

fit heta    a ny a ngle path p lanning

on

g rids

 the g value g s  is the length of the shortest path from the start vertex to vertex s found so
far and thus is an estimate of the start distance of vertex s 
 the user provided h value h s  is an estimate of the goal distance of vertex s  a  uses the
h value to calculate an f value to focus the a  search  the f value f  s    g s    h s  is an
estimate of the length of a shortest path from the start vertex via vertex s to the goal vertex 
 the parent parent s  is used to extract a path from the start vertex to the goal vertex after a 
terminates 
a  also maintains two global data structures 
 the open list is a priority queue that contains the vertices that a  considers for expansion 
in the pseudocode  open insert s  x  inserts vertex s with key x into the priority queue open 
open remove s  removes vertex s from the priority queue open  and open pop   removes a
vertex with the smallest key from the priority queue open and returns it 
 the closed list is a set that contains the vertices that a  has already expanded  it ensures that
a  expands every vertex at most once 
a  sets the g value of every vertex to infinity and the parent of every vertex to null when it
encounters the vertex for the first time  lines         it sets the g value of the start vertex to zero
and the parent of the start vertex to the start vertex itself  lines       it sets the open and closed
lists to the empty list and then inserts the start vertex into the open list with the f value as its key
       a  then repeatedly executes the following procedure  if the open list is empty  then it reports
that there is no path  line      otherwise  it identifies a vertex s with the smallest f value in the
open list  line     if this vertex is the goal vertex  then a  reports that it has found a path  line     
path extraction  not shown in the pseudocode  follows the parents from the goal vertex to the start
vertex to retrieve a path from the start vertex to the goal vertex in reverse  otherwise  a  removes
the vertex from the open list  line    and expands it by inserting the vertex into the closed list  line
    and then generating each of its unexpanded visible neighbors  as follows  a  checks whether
the g value of vertex s plus the length of the straight line from vertex s to vertex s is smaller than
the g value of vertex s  line      if so  then it sets the g value of vertex s to the g value of vertex
s plus the length of the straight line from vertex s to vertex s   sets the parent of vertex s to vertex
s and finally inserts vertex s into the open list with the f value as its key or  if it was already in the
open list  sets its key to the f value  lines         it then repeats this procedure 
to summarize  when a  updates the g value and parent of an unexpanded visible neighbor s of
vertex s in procedure updatevertex  it considers the path from the start vertex to vertex s    g s  
and from vertex s to vertex s in a straight line    c s  s     resulting in a length of g s    c s  s  
 line      a  updates the g value and parent of vertex s if the considered path is shorter than the
shortest path from the start vertex to vertex s found so far    g s    
we now describe several existing path planning algorithms that are versions of a  and how they
trade off between two conflicting criteria  namely runtime and path length  as shown in figure   
we introduce them in order of decreasing path lengths 
   

fidaniel   nash   koenig     f elner

  

 

runtime

a 
a  ps
fd 

   

visibility graphs
basic theta 

    

     
 

    

    

    

    

    

    

path length   length of true shortest path

figure    runtime versus path length  relative to the length of true shortest path  on random     
    grids with    percent blocked cells

   postsmoothpath  s            sn   
  
k      
  
tk    s   
  
foreach i            n    do
  
if not lineofsight tk   si     then
  
k    k     
  
tk    si  
  
k    k     
  
tk    sn  
  
return  t            tk   
   end

algorithm    post smoothing

    a  on grids
one can run a  on grids  that is  on the graphs given by the grid vertices and edges  the resulting
paths are artificially constrained to be formed by the edges of the grid  which can be seen in figure
  a   as a result the paths found by a  on grids are not equivalent to the true shortest paths and
are unrealistic looking since they either deviate substantially from the true shortest paths or have
many more heading changes  which provides the motivation for smoothing them  we use the octile
distances  which can be computed using algorithm    as h values in the experiments 
   

fit heta    a ny a ngle path p lanning

 

 

 

 

 

a

on

g rids

 
s goal
true shortest path

b
shortest grid path
a  ps path

c

s start

figure    a  ps path versus true shortest path

    a  with post smoothed paths  a  ps 
one can run a  with post smoothed paths  a  ps   thorpe         a  ps runs a  on grids and
then smoothes the resulting path in a post processing step  which often shortens it at an increase in
runtime  algorithm   shows the pseudocode of the simple smoothing algorithm that a  ps uses
in our experiments  botea  muller    schaeffer         which provides a good tradeoff between
runtime and path length  assume that a  on grids finds the path  s    s            sn   with s    sstart
and sn   sgoal   a  ps uses the first vertex on the path as the current vertex  it then checks whether
the current vertex s  has line of sight to the successor s  of its successor on the path  if so  a 
ps removes the intermediate vertex s  from the path  thus shortening it  a  ps then repeats this
procedure by checking again whether the current vertex s  has line of sight to the successor s  of
its successor on the path  and so on  as soon as the current vertex does not have line of sight to the
successor of its successor on the path  a  ps advances the current vertex and repeats this procedure
until it reaches the end of the path  we use the straight line distances h s    c s  sgoal   as h values
in the experiments 
a  ps typically finds shorter paths than a  on grids  but is not guaranteed to find true shortest paths 
figure   shows an example  assume that a  ps finds the dotted blue path  which is one of many
shortest grid paths  it then smoothes this path to the solid blue path  which is not a true shortest
path  the dashed red path  which moves above  rather than below  blocked cell b  b  c  c  is a
true shortest path  a  ps is not guaranteed to find true shortest paths because it only considers grid
paths during the a  search and thus cannot make informed decisions regarding other paths during
the a  search  which motivates interleaving searching and smoothing  in fact  theta  is similar to
a  ps except that it interleaves searching and smoothing 
    field d   fd  
one can run field d   ferguson   stentz         fd    fd  propagates information along grid
edges without constraining the paths to grid edges  fd  was designed to use d  lite  koenig  
likhachev        for fast replanning  by reusing information from the previous a  search to speed
up the next one  and searches from the goal vertex to the start vertex  our version of fd  uses
a  and searches from the start vertex to the goal vertex  like all other path planning algorithms in
this article  which allows us to compare them fairly  except for their replanning abilities   theta  is
currently in the process of being extended for fast replanning in nash  koenig    likhachev        
   

fidaniel   nash   koenig     f elner

 

b

 

 

 

    

    

    

    

    

    

 

sgoal
    

a

c

d

    

x

sstart
    

    

    

    

    

    

    

    

field d  path
figure    fd  path

figure    screenshot of fd  path versus true shortest path
when fd  updates the g value and parent of an unexpanded visible neighbor s of vertex s  it
considers all paths from the start vertex to any point x  not necessarily a vertex  on the perimeter of
vertex s    g x   that has line of sight to vertex s   where the perimeter is formed by connecting
all the neighbors of vertex s   and from point x to vertex s in a straight line    c x  s     resulting
in a length of g x    c x  s    fd  updates the g value and parent of vertex s if the considered
path is shorter than the shortest path from the start vertex to vertex s found so far    g s     we use
the straight line distances h s    c s  sgoal   as h values in the experiments 
figure   shows an example  the perimeter of vertex s   b  is formed by connecting all of the
neighbors of vertex b   as shown in bold  consider point x on the perimeter  fd  does not know
the g value of point x since it only stores g values for vertices  it calculates the g value using
linear interpolation between the g values of the two vertices on the perimeter that are adjacent to
the point x  thus  it linearly interpolates between g b          and g c           resulting in
g x                                   since      and      are the distances from point x to
vertices b  and c   respectively  the calculated g value of point x is different from its true start
distance          even though the g values of vertices b  and c  are both equal to their true start
distances  the reason for this mistake is simple  there exist true shortest paths from the start vertex
through either vertex c  or vertex b  to the goal vertex  thus  the linear interpolation assumption
predicts that there must also exist a short path from the start vertex through any point along the
edge that connects vertices b  and c  to the goal vertex  however  this is not the case since these
   

fit heta    a ny a ngle path p lanning

a

 

 

 

 

on

g rids

 

s start

b

c

s goal
true shortest path
 a  simple visibility graph

 b  terrain resulting in a more complex visibility graph

figure    visibility graphs
paths need to circumnavigate blocked cell b  b  c  c   which makes them longer than expected 
as a result of miscalculating the g value of point x  fd  sets the parent of vertex b  to point x 
resulting in a path that has an unnecessary heading change at point x and is longer than even a
shortest grid path 
the authors of fd  recognize that the paths found by fd  frequently have unnecessary heading
changes and suggest to use a one step look ahead algorithm during path extraction  ferguson  
stentz         which fd  uses in our experiments  this one step look ahead algorithm allows fd 
to avoid some of the unnecessary heading changes  like the one in figure    but does not eliminate
all of them  figure   shows an example of an fd  path in red and the corresponding true shortest
path in blue  the fd  path still has many unnecessary heading changes 
    a  on visibility graphs
one can run a  on visibility graphs  the visibility graph of a grid with blocked and unblocked
cells contains the start vertex  the goal vertex and the corners of all blocked cells  lozano perez  
wesley         we use the straight line distances h s    c s  sgoal   as h values in the experiments 
a  on visibility graphs finds true shortest paths  as shown in figure   a   true shortest paths have
heading changes only at the corners of blocked cells  while the paths found by a  on grids  a  ps
and fd  can have unnecessary heading changes  on the other hand  a  on visibility graphs can be
slow  it propagates information along visibility graph edges  whose number can grow quadratically
in the number of cells  while a  on grids  a  ps and fd  propagate information along grid edges 
whose number grows only linearly in the number of cells  if one constructed the visibility graphs
before the a  search  one would need to perform a line of sight check for every pair of corners of
blocked cells to determine whether or not there should be a visibility graph edge between them 
which requires at least       line of sight checks for the room in figure   b   tozour         the
number of line of sight checks performed by a  on visibility graphs can be reduced by constructing
   

fidaniel   nash   koenig     f elner

   updatevertex s s 
  
if lineofsight parent s   s   then
  
   path     
  
if g parent s     c parent s   s     g s   then
  
g s      g parent s     c parent s   s   
  
parent s      parent s  
  
if s  open then
  
open remove s   
open insert s   g s     h s    

  
  
  
  
  
  
  
  
  

else
   path     
if g s    c s  s     g s   then
g s      g s    c s  s   
parent s      s 
if s  open then
open remove s   
open insert s   g s     h s    

   end

algorithm    basic theta 

the visibility graphs during the a  search  when it expands a vertex  it performs line of sight checks
between the expanded vertex and the corners of all blocked cells  and the goal vertex   while
this can significantly reduce the number of line of sight checks performed in some environments 
such as simple outdoor terrain  it fails to do so in others  such as cluttered indoor terrain  more
complex optimizations  such as reduced visibility graphs can further reduce the number of line ofsight checks  but do not sufficiently speed up a  on visibility graphs  liu   arimoto        

   basic theta 
in this section  we introduce theta   nash et al          our version of a  for any angle path
planning that propagates information along grid edges without constraining the paths to grid edges 
it combines the ideas behind a  on visibility graphs  where heading changes occur only at the
corners of blocked cells  and a  on grids  where the number of edges grows only linearly in the
number of cells   its paths are only slightly longer than true shortest paths  as found by a  on
visibility graphs   yet is only slightly slower than a  on grids  as shown in figure    the key
difference between theta  and a  on grids is that the parent of a vertex can be any vertex when
using theta   while the parent of a vertex has to be a neighbor of the vertex when using a   we
first introduce basic theta   a simple version of theta  
algorithm   shows the pseudocode of basic theta   procedure main is identical to that of a  in
algorithm   and thus is not shown  line    is to be ignored  we use the straight line distances
h s    c s  sgoal   as h values in the experiments 
    operation of basic theta 
basic theta  is simple  it is identical to a  except that  when it updates the g value and parent of
an unexpanded visible neighbor s of vertex s in procedure updatevertex  it considers two paths
   

fit heta    a ny a ngle path p lanning

 

 

 

 

a

 

sgoal

s

b

s

c

path  

g rids

 

 

 

a

sstart

b

c

 

on

path  

sstart

s

s

sgoal

path  

 a  path   is unblocked

 

path  

 b  path   is blocked

figure    paths   and   considered by basic theta 

instead of only the one path considered by a   figure   a  shows an example  basic theta  is
expanding vertex b  with parent a  and needs to update the g value and parent of unexpanded
visible neighbor c   basic theta  considers two paths 

 path    basic theta  considers the path from the start vertex to vertex s    g s   and from
vertex s to vertex s in a straight line    c s  s     resulting in a length of g s    c s  s    line
     path   is the path considered by a   it corresponds to the dashed red path  a   b   c  
in figure   a   
 path    basic theta  also considers the path from the start vertex to the parent of vertex s   
g parent s    and from the parent of vertex s to vertex s in a straight line    c parent s   s    
resulting in a length of g parent s     c parent s   s    line      path   is not considered
by a  and allows basic theta  to construct any angle paths  it corresponds to the solid blue
path  a   c   in figure   a  

path   is no longer than path   due to the triangle inequality  the triangle inequality states that
the length of any side of a triangle is no longer than the sum of the lengths of the other two sides 
it applies here since path   consists of the path from the start vertex to the parent of vertex s  the
straight line from the parent of vertex s to vertex s  line a  and the straight line from vertex s to
vertex s  line b   path   consists of the same path from the start vertex to the parent of vertex s
and the straight line from the parent of vertex s to vertex s  line c  and lines a  b and c form a
triangle  path   is guaranteed to be unblocked but path   is not  thus  basic theta  chooses path
  over path   if vertex s has line of sight to the parent of vertex s and path   is thus unblocked 
figure   a  shows an example  otherwise  basic theta  chooses path   over path    figure   b 
shows an example  basic theta  updates the g value and parent of vertex s if the chosen path is
shorter than the shortest path from the start vertex to vertex s found so far    g s     we use the
straight line distances h s    c s  sgoal   as h values in the experiments 
   

fidaniel   nash   koenig     f elner

 

 

 

 

 

 

a

    

    

    

a 

sstart

a 

b

    

    

    

a 

a 

a 

c

sgoal

 

 

b

c

a 

sgoal

 

    

a 

sstart

a 

    

    

    

    

b 

a 

a 

a 

    

    

    

a 

a 

a 

 b 

 

 

    

    

    

    

    

b 

b 

a 

sstart

a 

b

    

    

    

    

    

b 

b 

a 

a 

a 

    

    

    

    

b 

a 

a 

a 

sgoal

 

 

a

c

 

    

 a 
 

 
    

a

 

 

 

 

a

    

    

    

    

    

b 

b 

a 

sstart

a 

b

    

    

    

    

    

b 

b 

a 

a 

a 

c

    

    

    

    

b 

a 

a 

a 

sgoal

 c 

 d 

figure    example trace of basic theta 

    example trace of basic theta 
figure   shows an example trace of basic theta   the vertices are labeled with their g values and
parents  the arrows point to their parents  red circles indicate vertices that are being expanded  and
blue arrows indicate vertices that are generated during the current expansion  first  basic theta 
expands start vertex a  with parent a   as shown in figure   a   it sets the parent of the unexpanded
visible neighbors of vertex a  to vertex a   just like a  would do  second  basic theta  expands
vertex b  with parent a   as shown in figure   b   vertex b  is an unexpanded visible neighbor of
vertex b  that does not have line of sight to vertex a   basic theta  thus updates it according to
path   and sets its parent to vertex b   on the other hand  vertices c   c  and c  are unexpanded
visible neighbors of vertex b  that have line of sight to vertex a   basic theta  thus updates them
according to path   and sets their parents to vertex a    the g values and parents of the other
unexpanded visible neighbors of vertex b  are not updated   third  basic theta  expands vertex
b  with parent b   as shown in figure   c   vertices a  and a  are unexpanded visible neighbors
of vertex b  that do not have line of sight to vertex b   basic theta  thus updates them according
to path   and sets their parents to vertex b   on the other hand  vertices b  and c  are unexpanded
visible neighbors of vertex b  that do have line of sight to vertex b   basic theta  thus updates
them according to path   and sets their parents to vertex b   fourth  basic theta  expands goal
vertex c  with parent b  and terminates  as shown in figure   d   path extraction then follows the
parents from goal vertex c  to start vertex a  to retrieve the true shortest path  a   b   c   from
the start vertex to the goal vertex in reverse 
   

fit heta    a ny a ngle path p lanning

on

g rids

    properties of basic theta 
we now discuss the properties of basic theta  
      c orrectness

and

c ompleteness

basic theta  is correct  that is  finds only unblocked paths from the start vertex to the goal vertex 
and complete  that is  finds a path from the start vertex to the goal vertex if one exists   we use the
following lemmata in the proof 
lemma    if there exists an unblocked path between two vertices then there also exists an unblocked
grid path between the same two vertices 
proof  an unblocked path between two vertices exists iff an unblocked any angle path  s            sn  
exists between the same two vertices  consider any path segment sk sk   of this any angle path  if
the path segment is horizontal or vertical  then consider the unblocked grid path from vertex sk to
vertex sk   that coincides with the path segment  otherwise  consider the sequence  b            bm  
of unblocked cells whose interior the path segment passes through  any two consecutive cells
bj and bj   share at least one vertex sj   since the cells either share an edge or are diagonally
touching   if they share more than one vertex  pick one arbitrarily   consider the grid path  s   
sk   s            sm   sm     sk      this grid path from vertex sk to vertex sk   is unblocked since any
two consecutive vertices on it are corners of the same unblocked cell and are thus visible neighbors 
repeat this procedure for every path segment of the any angle path and concatenate the resulting
grid paths to an unblocked grid path from vertex s  to vertex sn    if several consecutive vertices on
the grid path are identical  then all of them but one can be removed  
lemma    at any point during the execution of basic theta   following the parents from any vertex
in the open or closed lists to the start vertex retrieves an unblocked path from the start vertex to this
vertex in reverse 
proof  we prove by induction that the lemma holds and that the parent of any vertex in the union
of the open or closed lists itself is in the union of the open or closed lists  this statement holds
initially because the start vertex is the only vertex in the union of the open or closed lists and it is
its own parent  we now show that the statement continues to hold whenever a vertex changes either
its parent or its membership in the union of the open or closed lists  once a vertex is a member of
the union of the open or closed lists  it continues to be a member  a vertex can become a member
in the union of the open or closed lists only when basic theta  expands some vertex s and updates
the g value and parent of an unexpanded visible neighbor s of vertex s in procedure updatevertex 
vertex s is thus in the closed list  and its parent is in the union of the open or closed lists according
to the induction assumption  thus  following the parents from vertex s  or its parent  to the start
vertex retrieves an unblocked path from the start vertex to vertex s  or its parent  respectively  in
reverse according to the induction assumption  if basic theta  updates vertex s according to path
   then the statement continues to hold since vertices s and s are visible neighbors and the path
segment from vertex s to vertex s is thus unblocked  if basic theta  updates vertex s according
to path    then the statement continues to hold since basic theta  explicitly checks that the path
   

fidaniel   nash   koenig     f elner

segment from the parent of vertex s to vertex s is unblocked  there are no other ways in which the
parent of a vertex can change 
theorem    basic theta  terminates and path extraction retrieves an unblocked path from the start
vertex to the goal vertex if such a path exists  otherwise  basic theta  terminates and reports that
no unblocked path exists 
proof  the following properties together prove the theorem  their proofs utilize the fact that basic
theta  terminates iff the open is empty or it expands the goal vertex  the start vertex is initially in
the open list  any other vertex is initially neither in the open nor closed lists  a vertex neither in the
open nor closed lists can be inserted into the open list  a vertex in the open list can be removed from
the open list and be inserted into the closed list  a vertex in the closed list remains in the closed list 
 property    basic theta  terminates  it expands one vertex in the open list during each
iteration  in the process  it removes the vertex from the open list and can then never insert it
into the open list again  since the number of vertices is finite  the open list eventually becomes
empty and basic theta  has to terminate if it has not terminated earlier already 
 property    if basic theta  terminates because its open list is empty  then there does not
exist an unblocked path from the start vertex to the goal vertex  we prove the contrapositive 
assume that there exists an unblocked path from the start vertex to the goal vertex  we prove
by contradiction that basic theta  then does not terminate because its open list is empty 
thus  assume also that basic theta  terminates because its open list is empty  then  there
exists an unblocked grid path  s    sstart           sn   sgoal   from the start vertex to the goal
vertex according to lemma    choose vertex si to be the first vertex on the grid path that is
not in the closed list when basic theta  terminates  the goal vertex is not in the closed list
when basic theta  terminates since basic theta  would otherwise have terminated when it
expanded the goal vertex  thus  vertex si exists  vertex si is not the start vertex since the start
vertex would otherwise be in the open list and basic theta  could not have terminated because
its open list is empty  thus  vertex si has a predecessor on the grid path  this predecessor is
in the closed list when basic theta  terminates since vertex si is the first vertex on the grid
path that is not in the closed list when basic theta  terminates  when basic theta  expanded
the predecessor  it added vertex si to the open list  thus  vertex si is still in the open list when
basic theta  terminates  but then basic theta  could not have terminated because its open
list is empty  which is a contradiction 
 property    if basic theta  terminates because it expands the goal vertex  then path extraction
retrieves an unblocked path from the start vertex to the goal vertex because following the
parents from the goal vertex to the start vertex retrieves an unblocked path from the start
vertex to the goal vertex in reverse according to lemma   

   

fit heta    a ny a ngle path p lanning

a

 

 

 

 

 

on

g rids

 

 

 

 

  

 

 

 

 

  

b

c

d

e

s start

 a 
a

 

 

 

 

 

b

c

d

e

s start

 b 

true shortest path

basic theta  path

figure    basic theta  paths versus true shortest paths

      o ptimality
basic theta  is not optimal  that is  it is not guaranteed to find true shortest paths  because the
parent of a vertex has to be either a visible neighbor of the vertex or the parent of a visible neighbor 
which is not always the case for true shortest paths  figure   a  shows an example where the dashed
red path  e   b   is a true shortest path from start vertex e  to vertex b  since vertex e  has lineof sight to vertex b   however  vertex e  is neither a visible neighbor nor the parent of a visible
neighbor of vertex b  since vertex e  does not have line of sight to these vertices  highlighted in
red   thus  basic theta  cannot set the parent of vertex b  to vertex e  and does not find a true
shortest path from vertex e  to vertex b   similarly  figure   b  shows an example where the
dashed red path  e   d   c    is a true shortest path from vertex e  to vertex c    however  vertex
d  is neither a visible neighbor nor the parent of a visible neighbor of vertex c   since start vertex
e  either has line of sight to them or basic theta  found paths from vertex e  to them that do not
   

fidaniel   nash   koenig     f elner

a

  sstart

 

 

 

 

 

b

c

f     

d
f     

true shortest path

sgoal
f     

basic theta  path

figure     heading changes of basic theta 

contain vertex d   in fact  the truly shortest paths from vertex e  to all visible neighbors of vertex
c   that vertex e  does not have line of sight to move above  rather than below  blocked cell c c  d  d   thus  basic theta  cannot set the parent of vertex c   to vertex d  and thus does not
find a true shortest path from vertex e  to vertex c    the solid blue path from vertex e  to vertex
b  in figure   a  and the solid blue path from vertex e  to vertex c   in figure   b  are less than
a factor of       longer than the true shortest paths 
      h eading c hanges
basic theta  takes advantage of the fact that true shortest paths have heading changes only at
the corners of blocked cells  however  the paths found by basic theta  can occasionally have
unnecessary heading changes  figure    shows an example where basic theta  finds the solid blue
path  a   d   d   from vertex a  to vertex d   the reason for this mistake is simple  assume
that the open list contains both vertices c  and d   the f value of vertex c  is f  c     g c    
h c                        and its parent is vertex c   the f value of vertex d  is f  d    
                   and its parent is vertex a   thus basic theta  expands vertex d  before
vertex c   since its f value is smaller   when basic theta  expands vertex d  with parent a  
it generates vertex d   vertex d  is an unexpanded visible neighbor of vertex d  that does not
have line of sight to vertex a   basic theta  thus updates it according to path    sets its f value to
f  d                         sets its parent to vertex d  and inserts it into the open list  thus
basic theta  expands goal vertex d  before vertex c   since its f value is smaller  and terminates 
path extraction then follows the parents from goal vertex d  to start vertex a  to retrieve the solid
blue path  a   d   d    thus  basic theta  never expands vertex c   which would have resulted in
it setting the parent of vertex d  to vertex c  according to path   and path extraction retrieving the
dashed red path  a   c   d   which is the true shortest path  the solid blue path from vertex a  to
vertex d  in figure    is less than a factor of       longer than true shortest path 
   

fit heta    a ny a ngle path p lanning

on

g rids

   updatevertex s s 
  
if s    sstart and lb s    s  parent s   s    ub s  then
  
   path     
  
if g parent s     c parent s   s     g s   then
  
g s      g parent s     c parent s   s   
  
parent s      parent s  
  
if s  open then
  
open remove s   
open insert s   g s     h s    

  
  
  
  
  
  
  
  
  

else
   path     
if g s    c s  s     g s   then
g s      g s    c s  s   
parent s      s 
if s  open then
open remove s   
open insert s   g s     h s    

   end
   updatebounds s 
  
lb s       ub s      
  
if s    sstart then
  
foreach blocked cell b adjacent to s do
  
if s  corners b    parent s    s or  s  parent s   s       or
  
  s  parent s   s       and c parent s   s    c parent s   s   then
  
lb s      
  
  
  
  
  
  
  
  
  
  
  
  
  
  

if s  corners b    parent s    s or  s  parent s   s       or
  s  parent s   s       and c parent s   s    c parent s   s   then
ub s      
foreach s  nghbrsvis  s  do
if s  closed and parent s    parent s   and s    sstart then
if lb s      s  parent s   s      then
lb s     max lb s   lb s      s  parent s   s    
if ub s      s  parent s   s      then
ub s     min ub s   ub s      s  parent s   s    
if c parent s   s     c parent s   s  and parent s     s and  s   closed or parent s     parent s   
then
if  s  parent s   s       then
lb s     max lb s    s  parent s   s    
if  s  parent s   s       then
ub s     min ub s    s  parent s   s    

   end

algorithm    ap theta 

   angle propagation theta   ap theta  
the runtime of basic theta  per vertex expansion  that is  the runtime consumed during the generation of the unexpanded visible neighbors when expanding a vertex  can be linear in the number
of cells since the runtime of each line of sight check can be linear in the number of cells  in this
section  we introduce angle propagation theta   ap theta    which reduces the runtime of basic
   

fidaniel   nash   koenig     f elner

a

 

 

b

 

 

o

 

 

 

o

 

c

d

e

s

f

figure     region of points with line of sight to vertex s
theta  per vertex expansion from linear to constant   the key difference between ap theta  and
basic theta  is that ap theta  propagates angle ranges and uses them to determine whether or not
two vertices have line of sight 
if there is a light source at a vertex and light cannot pass through blocked cells  then cells in the
shadows do not have line of sight to the vertex while all other cells have line of sight to the vertex 
each contiguous region of points that have line of sight to the vertex can be characterized by two
rays emanating from the vertex and thus by an angle range defined by two angle bounds  figure
   shows an example where all points within the red angle range defined by the two angle bounds
  and   have line of sight to vertex s  ap theta  calculates the angle range of a vertex when
it expands the vertex and then propagates it along grid edges  resulting in a constant runtime per
vertex expansion since the angle ranges can be propagated in constant time and the line of sight
checks can be performed in constant time as well 
algorithm   shows the pseudocode of ap theta   procedure main is identical to that of a  in
algorithm   and thus is not shown  line    is to be executed  we use the straight line distances
h s    c s  sgoal   as h values in the experiments 
    definition of angle ranges
we now discuss the key concept of an angle range  ap theta  maintains two additional values for
every vertex s  namely a lower angle bound lb s  of vertex s and an upper angle bound ub s  of
vertex s  that together form the angle range  lb s   ub s   of vertex s  the angle bounds correspond
to headings of rays  measured in degrees  that originate at the parent of vertex s  the heading of
the ray from the parent of vertex s to vertex s is zero degrees  a visible neighbor of vertex s is
guaranteed to have line of sight to the parent of vertex s if  but not necessarily only if  the heading
of the ray from the parent of vertex s to the visible neighbor of vertex s is contained in the angle
   while ap theta  provides a significant improvement in the worst case complexity over basic theta   our experimental results in section   show that it is slower and finds slightly longer paths than basic theta  

   

fit heta    a ny a ngle path p lanning

 

 

 

 

a

on

g rids

 

sstart
lb

b

  o
o

  
c

sgoal

s

ub

figure     angle range of ap theta 
range of vertex s  figure    shows an example where vertex c  with parent a  has angle range
          thus  all visible neighbors of vertex c  in the red region are guaranteed to have line ofsight to the parent of vertex c   for example  vertex c  is guaranteed to have line of sight to the
parent of vertex c  but vertex b  is not  ap theta  therefore assumes that vertex b  does not have
line of sight to the parent of vertex c  
we now define the concept of an angle range more formally   s  p  s              which gives
ap theta  its name  is the angle  measured in degrees  between the ray from vertex p to vertex s and
the ray from vertex p to vertex s   it is positive if the ray from vertex p to vertex s is clockwise from
the ray from vertex p to vertex s   zero if the ray from vertex p to vertex s has the same heading as the
ray from vertex p to vertex s   and negative if the ray from vertex p to vertex s is counterclockwise
from the ray from vertex p to vertex s   figure    shows an example where  c   a   c       
and  c   a   b         a visible neighbor s of vertex s is guaranteed to have line of sight to
the parent of vertex s if  but not necessarily only if  lb s    s  parent s   s    ub s   visibility
property  
    update of angle ranges
we now discuss how ap theta  calculates the angle range of a vertex when it expands the vertex 
this calculation is complicated by the fact that ap theta  is not guaranteed to have sufficient
information to determine the angle range exactly since the order of vertex expansions depends on a
variety of factors  such as the h values  in this case  ap theta  can constrain the angle range more
than necessary to guarantee that the visibility property holds and that it finds unblocked paths 
when ap theta  expands vertex s  it sets the angle range of vertex s initially to       meaning
that all visible neighbors of the vertex are guaranteed to have line of sight to the parent of the vertex 
it then constrains the angle range more and more if vertex s is not the start vertex 
ap theta  constrains the angle range of vertex s based on each blocked cell b that is adjacent to
vertex s  that is  that vertex s is a corner of b  written as s  corners b   provided that at least one
of two conditions is satisfied 
 case    if every corner s of blocked cell b satisfies at least one of the following conditions 
 parent s    s or
   

fidaniel   nash   koenig     f elner

  s  parent s   s       or
  s  parent s   s       and c parent s   s    c parent s   s  
then ap theta  assumes that a vertex s does not have line of sight to the parent of vertex s
if the ray from the parent of vertex s to vertex s is counterclockwise from the ray from the
parent of vertex s to vertex s   that is  if  s  parent s   s        ap theta  therefore sets
the lower angle bound of vertex s to  s  parent s   s       line     
 case    if every corner s of blocked cell b satisfies at least one of the following conditions 
 parent s    s or
  s  parent s   s       or
  s  parent s   s       and c parent s   s    c parent s   s  
then ap theta  assumes that a vertex s does not have line of sight to the parent of vertex s
if the ray from the parent of vertex s to vertex s is clockwise from the ray from the parent of
vertex s to vertex s   that is  if  s  parent s   s        ap theta  therefore sets the upper
angle bound of vertex s to  s  parent s   s       line     
ap theta  also constrains the angle range of vertex s based on each visible neighbor s of vertex s
provided that at least one of two conditions is satisfied 
 case    if vertex s satisfies all of the following conditions 
 s  closed and

 parent s    parent s   and
 s    sstart  
then ap theta  constrains the angle range of vertex s by intersecting it with the angle range
of vertex s  lines    and      to do that  it first shifts the angle range of vertex s by
 s  parent s   s   degrees to take into account that the angle range of vertex s is calibrated
so that the heading of the ray from the joint parent of vertices s and s to vertex s is zero
degrees  while the angle range of vertex s is calibrated so that the heading of the ray from the
joint parent of vertices s and s to vertex s is zero degrees  lines    and    ensure that the
lower angle bound always remains non positive and the upper angle bound always remains
non negative  respectively  the fact that lower angle bounds should be non positive  and
upper angle bounds non negative  is intuitive in that if a vertex s is assigned parent vertex p
then the angle of the ray from vertex p to vertex s should be included in the angle range of
vertex s 
 case    if vertex s satisfies all of the following conditions 
 c parent s   s     c parent s   s  and
 parent s     s and
   

fit heta    a ny a ngle path p lanning

on

g rids

 s   closed or parent s     parent s   
then ap theta  has insufficient information about vertex s   ap theta  therefore cannot
determine the angle range of vertex s exactly and makes the conservative assumption that
vertex s barely has line of sight to the parent of vertex s  lines    and     
the visibility property holds after ap theta  has updated the angle range of vertex s in procedure
updatebounds  thus  when ap theta  checks whether or not a visible neighbor s of vertex s has
line of sight to the parent of vertex s  it now checks whether or not lb s    s  parent s   s   
ub s   line     is true instead of whether or not lineofsight parent s   s    line     is true   these
are the only differences between ap theta  and basic theta  
figure    a  shows an example where ap theta  calculates the angle range of vertex a   it sets
the angle range to       figure    b  shows an example where ap theta  calculates the angle
range of vertex b   it sets the angle range initially to       it then sets the lower angle bound
to   degrees according to case   based on the blocked cell a  a  b  b   line      it sets the
upper angle bound to    degrees according to case   based on vertex b   which is unexpanded and
thus not in the closed list  line      figure    c  shows an example where ap theta  calculates
the angle range of vertex b   it sets the angle range initially to       it then sets the lower
angle bound to   degrees according to case   based on the blocked cell a  a  b  b   line     
assume that vertex c  is not the goal vertex  figure    d  then shows an example where ap theta 
calculates the angle range of vertex c   it sets the angle range initially to       it then sets the
lower angle bound to     degrees according to case   based on vertex b   line     and the upper
angle bound to    degrees according to case   based on vertex c   which is unexpanded and thus
not in the closed list  line     
    example trace of ap theta 
figure    shows an example trace of ap theta  using the path planning problem from figure   
the labels of the vertices now include the angle ranges 
    properties of ap theta 
we now discuss the properties of ap theta   ap theta  operates in the same way as basic theta 
and thus has similar properties as basic theta   for example  ap theta  is correct and complete  it
is not guaranteed to find true shortest paths  and its paths can occasionally have unnecessary heading
changes 
ap theta  sometimes constrains the angle ranges more than necessary to guarantee that it finds
unblocked paths  which means that its line of sight checks sometimes fail incorrectly in which case
it has to update vertices according to path   rather than path    ap theta  is still complete since
it finds an unblocked grid path if all line of sight checks fail  and there always exists an unblocked
grid path if there exists an unblocked any angle path  however  the paths found by ap theta  can be
longer than those found by basic theta   figure    shows an example  when ap theta  expands
vertex c  with parent b  and calculates the angle range of vertex c   vertex c  is unexpanded and
thus not in the closed list  this means that ap theta  has insufficient information about vertex
   

fidaniel   nash   koenig     f elner

 

 

 

 

 

    

    

    

a 

sstart

a 

 

 

    
a 

 

 
 

   

 

a

b

    

    

    

a 

a 

a 

c

    

    

    

    

b 

a 
      

a 

a 

c

    

    

    

a 

a 

a 

 

 b 

 

    

    

b 

b 

 

 

 

    

    
a 

    
a 

sstart

 

 

    

    

b 

b 

 
    
a 

 

    

b 

b 
     

c

    

    

b 

a 

    
a 
      

    
a 

    
a 

    
a 

b

    
a 

    

    

b 

b 
     

    

    

b 
       

a 

 

    

 

b

 

    

sstart

    
a 

     

 
 

   

a

 
 

 

    
a 

sstart
     

b

 a 
a

 

    
 
 

 
a

c

 c 

    
a 
      

    
a 

    
a 

    
a 

    
a 

 d 

figure     example trace of ap theta 
 

 

 

 

 

 

a

s
b

c

d

start

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

sgoal

basic theta  path

ap theta  path

figure     basic theta  path versus ap theta  path
c  because  for example  it does not know whether or not cell c  c  d  d  is unblocked  ap
theta  therefore cannot determine the angle range of vertex c  exactly and makes the conservative
assumption that vertex c  barely has line of sight to vertex b  and sets the lower angle bound
of vertex c  according to case   based on vertex c   it then uses the resulting angle range to
determine that the unexpanded visible neighbor d  of vertex c  is not guaranteed to have line ofsight to vertex b   however  vertex d  does have line of sight to vertex b  if cell c  c  d  d 
   

fit heta    a ny a ngle path p lanning

on

g rids

figure     map of baldurs gate ii
is unblocked  ap theta  eventually finds the solid blue path  b   c   d   from start vertex b  to
vertex d   while basic theta  finds the dashed red path  b   d    which is the true shortest path 
the correctness and completeness proof of basic theta  needs to get changed slightly for ap theta 
since ap theta  performs its line of sight checks differently 
theorem    ap theta  terminates and path extraction retrieves an unblocked path from the start
vertex to the goal vertex if such a path exists  otherwise  ap theta  terminates and reports that no
unblocked path exists 
proof  the proof is similar to the proof of theorem   since ap theta  uses the angle ranges only
to determine whether or not path   is blocked but not to determine whether or not path   is blocked 
the only property that needs to be proved differently is that two vertices indeed have line of sight
if  but not necessarily only if  the line of sight check of ap theta  succeeds  see appendix b 

   experimental results
in this section  we compare basic theta  and ap theta  to a  on grids  a  ps  fd  and a  on
visibility graphs with respect to their path length  number of vertex expansions  runtime  measured
in seconds  and number of heading changes 
we compare these path planning algorithms on          and          grids with different percentages of randomly blocked cells  random grids  and scaled maps from the real time strategy
game baldurs gate ii  game maps   figure     bulitko  sturtevant    kazakevich        shows an
example of a game map  the start and goal vertices are the south west corners of cells  for random
grids  the start vertex is in the south west cell  the goal vertex is in a cell randomly chosen from
the column of cells furthest east  cells are blocked randomly but a one unit border of unblocked
cells guarantees that there is path from the start vertex to the goal vertex  for game maps  the start
and goal vertices are randomly chosen from the corners of unblocked cells  we average over    
random          grids      random          grids and     game maps 
   

fidaniel   nash   koenig     f elner

      

      

fd 
game maps
random grids   
random grids   
random grids    
random grids    
random grids    
game maps
random grids   
random grids   
random grids    
random grids    
random grids    

     
      
      
      
      
      
      
      
      
      
      
      

basic theta  ap theta  a  on visibility graphs a  on grids
 true shortest path 
     
     
     
     
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
n a
      
      
      
n a
      
      
      
n a
      
      
      
n a
      
      
      
n a
      
      
      
n a
      

a  ps
     
      
      
      
      
      
      
      
      
      
      
      

table    path length

      

      

fd 
game maps
random grids   
random grids   
random grids    
random grids    
random grids    
game maps
random grids   
random grids   
random grids    
random grids    
random grids    

      
      
      
      
      
      
      
      
      
      
      
      

basic theta  ap theta  a  on visibility graphs a  on grids
 true shortest path 
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
n a
      
      
      
n a
      
      
      
n a
      
      
      
n a
      
      
      
n a
      
      
      
n a
      

a  ps
      
      
      
      
      
      
      
      
      
      
      
      

table    runtime

      

      

fd 
game maps
random grids   
random grids   
random grids    
random grids    
random grids    
game maps
random grids   
random grids   
random grids    
random grids    
random grids    

      
      
      
      
       
       
       
        
        
        
        
        

basic theta  ap theta  a  on visibility graphs a  on grids
 true shortest path 
      
      
     
      
      
      
    
     
      
      
     
      
      
      
      
      
      
      
      
      
       
       
      
      
       
       
n a
       
       
      
n a
      
       
       
n a
      
        
        
n a
       
        
        
n a
       
        
        
n a
        

a  ps
      
       
       
       
       
       
       
        
        
        
        
        

table    number of vertex expansions

all path planning algorithms are implemented in c  and executed on a     ghz core   duo with  
gbyte of ram  our implementations are not optimized and can possibly be improved 
   

fit heta    a ny a ngle path p lanning

      

      

fd 
game maps
random grids   
random grids   
random grids    
random grids    
random grids    
game maps
random grids   
random grids   
random grids    
random grids    
random grids    

     
      
      
      
     
     
      
      
      
      
      
      

g rids

on

basic theta  ap theta  a  on visibility graphs a  on grids
 true shortest paths 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
     
     
     
     
     
     
     
     
     
    
    
n a
     
    
    
n a
    
     
     
n a
     
     
     
n a
     
     
     
n a
     
     
      
n a
      

a  ps
    
    
    
    
     
     
    
    
     
     
     
     

   

   

   

   

   

   

   

   

   

   

runtime

path length

table    number of heading changes

   

   

   

   

   

   

   

   

   

 
 

 

  

  

  

 

 

  

  blocked
fd 

basic theta 

  

  

  blocked

ap theta 

a  ps

fd 

basic theta 

 a  path length

ap theta 

a  ps

a 

 b  runtime

     

   

   

number of heading changes

     

vertex expansions

     

     

     

   

   

   

   

   
     
   

 

 
 

 

  

  

  

 

 

  blocked
fd 

basic theta 

  

  

  

  blocked

ap theta 

a  ps

a 

fd 

 c  number of vertex expansions

basic theta 

ap theta 

a  ps

a 

 d  number of heading changes

figure     random          grids

   

fidaniel   nash   koenig     f elner

   h s 
x     s x   sgoal   x  
   
y     s y   sgoal   y  
   

   
largest    max x   y   
   
smallest    min x   y   

   
return    smallest    largest  smallest  
    end

algorithm    calculation of octile distances

a  on grids  a  ps  fd  and a  on visibility graphs break ties among vertices with the same fvalue in the open list in favor of vertices with larger g values  when they decide which vertex to
expand next  since this tie breaking scheme typically results in fewer vertex expansions and thus
shorter runtimes for a   care must thus be taken when calculating the g values  h values and fvalues precisely  the numerical precision of these
 floating point numbers can be improved for a 
on grids by representing them in the form m    n for integers m and n  basic theta  and ap
theta  break ties in favor of vertices with smaller g values for the reasons explained in section   
we use all path planning algorithms with consistent h values since consistent h values result in
short paths for a   consistent h values satisfy the triangle inequality  that is  the h value of the
goal vertex is zero and the h value of any potential non goal parent of any vertex is no greater than
the distance from the potential non goal parent of the vertex to the vertex plus the h value of the
vertex  hart et al         pearl         consistent h values are lower bounds on the corresponding
goal distances of vertices  increasing consistent h values typically decreases the number of vertex
expansions for a  and thus also the runtime of a   we thus use all path planning algorithms with
the largest consistent h values that are easy to calculate  for basic theta   ap theta   fd  and
a  on visibility graphs  the goal distances of vertices can be equal to the true goal distances  that
is  the goal distances on grids if the paths are not constrained to grid edges  we therefore use
these path planning algorithms with the straight line distances h s    c s  sgoal   as h values in our
experiments  the straight line distances are the goal distances on grids without blocked cells if the
paths are not constrained to grid edges  for a  on grids and a  ps  the goal distances of vertices
are equal to the goal distances on grids if the paths are constrained to grid edges  we could therefore
use them with the larger octile distances as h values in our experiments  the octile distances are the
goal distances on grids without blocked cells if the paths are constrained to grid edges  algorithm
  shows how to calculate the octile distance of a given vertex s  where s x and s y are the x and y
coordinates of vertex s  respectively  we indeed use a  on grids with the octile distances but a 
ps with the straight line distances since smoothing is then typically able to shorten the resulting
paths much more at an increase in the number of vertex expansions and thus runtime  grids without
blocked cells provide an example  with the octile 
distances as h values  a  on grids finds paths in
which all diagonal movements  whose lengths are    precede all horizontal or vertical movements
 whose lengths are    because the paths with the largest number of diagonal movements are the
longest ones among all paths with the same number of movements due to the tie breaking scheme
used  on the other hand  with the straight line distances as h values  a  on grids finds paths that
interleave the diagonal movements with the horizontal and vertical movements  which means that
it is likely that there are lots of opportunities to smooth the paths even for grids with some blocked
cells  and that are closer to the straight line between the start and goal vertices  which means that
it is likely that the paths are closer to true shortest paths even for grids with some blocked cells  
   

fit heta    a ny a ngle path p lanning

on

g rids

figure     true shortest paths found by fd   left   a  ps  middle  and basic theta   right 
because the h values of vertices closer to the straight line are typically smaller than the h values of
vertices farther away from the straight line 
tables     report our experimental results  the runtime of a  on visibility graphs  which finds
true shortest paths  is too long on          grids and thus is omitted  figure    visualizes the
experimental results on random          grids  the path length of a  on grids is much larger than
the path lengths of the other path planning algorithms and thus is omitted 
we make the following observations about the path lengths 
 the path planning algorithms in order of increasing path lengths tend to be  a  on visibility
graphs  which finds true shortest paths   basic theta   ap theta   fd   a  ps and a  on
grids  on random          grids with    percent blocked cells  basic theta  finds shorter
paths than ap theta     percent of the time  shorter paths than fd     percent of the time 
shorter paths than a  ps    percent of the time and shorter paths than a  on grids    percent
of the time 
 the paths found by basic theta  and ap theta  are almost as short as true shortest paths even
though ap theta  sometimes constrains the angle ranges more than necessary  for example 
they are on average less than a factor of       longer than true shortest paths on         
grids 
 basic theta  finds true shortest paths more often than fd  and a  ps  figure    shows an
example where the light green vertex in the center is the start vertex and the red  green and
blue vertices represent goal vertices to which fd   a  ps and basic theta  find true shortest
paths  respectively 
we make the following observations about the runtimes  the path planning algorithms in order of
increasing runtimes tend to be  a  on grids  basic theta   ap theta   a  ps  fd  and a  on
visibility graphs 
we make the following observations about the numbers of vertex expansions  the path planning
algorithms in order of increasing numbers of vertex expansions tend to be  a  on visibility graphs 
a  on grids  ap theta   basic theta   fd  and a  ps   the number of vertex expansions of a 
on grids and a  ps are different because we use them with different h values  
   

fidaniel   nash   koenig     f elner

runtime
runtime per vertex expansion

fd 
    
        

basic theta 
    
        

ap theta 
    
        

a  ps
    
        

table    path planning algorithms without post processing steps on random          grids with
   percent blocked cells

finally  we make the following observations about the number of heading changes  the pathplanning algorithms in order of increasing numbers of heading changes tend to be  a  ps  a  on
visibility graphs  basic theta   ap theta   a  on grids and fd  
there are some exceptions to the trends reported above  we therefore perform paired t tests  they
show with confidence level         that basic theta  indeed finds shorter paths than ap theta  
a  ps and fd  and that basic theta  indeed has a shorter runtime than ap theta   a  ps and
fd  
to summarize  a  on visibility graphs finds true shortest paths but is slow  on the other hand  a 
on grids finds long paths but is fast  any angle path planning lies between these two extremes 
basic theta  dominates ap theta   a  ps and fd  in terms of the tradeoff between runtime and
path length  it finds paths that are almost as short as true shortest paths and is almost as fast as
a  on grids  it is also simpler to implement than ap theta   therefore  we build on basic theta 
for the remainder of this article  although we report some experimental results for ap theta  as
well  however  ap theta  reduces the runtime of basic theta  per vertex expansion from linear to
constant  it is currently unknown whether or not constant time line of sight checks can be devised
that make ap theta  faster than basic theta   this is an interesting area of future research since
ap theta  is potentially a first step toward significantly reducing the runtime of any angle path
planning via more sophisticated line of sight checks 

   extensions of theta 
in this section  we extend basic theta  to find paths from a given start vertex to all other vertices
and to find paths on grids that contain unblocked cells with non uniform traversal costs 
    single source paths
so far  basic theta  has found paths from a given start vertex to a given goal vertex  we now discuss
a version of basic theta  that finds single source paths  that is  paths from a given start vertex to all
other vertices  by terminating only when the open list is empty instead of when either the open list
is empty or it expands the goal vertex 
finding single source paths requires all path planning algorithms to expand the same number of
vertices  which minimizes the influence of the h values on the runtime and thus results in a clean
comparison since the h values sometimes are chosen to trade off between runtime and path length 
the runtimes of a  ps and fd  are effected more than those of basic theta  and ap theta 
when finding single source paths since they require post smoothing or path extraction steps for each
   

fit heta    a ny a ngle path p lanning

a

 

 

 

 

 

on

g rids

 
i 

i 
i 

b

i 
i 
i 

c

i 

basic theta  path with non uniform traversal costs

figure     basic theta  on grids that contain unblocked cells with non uniform traversal costs

 a  small contiguous regions of uniform traversal costs
path cost
runtime

a  on grids
       
     

fd 
       
     

basic theta 
       
     

 b  large contiguous regions of uniform traversal costs
path cost
runtime

a  on grids
       
    

fd 
       
    

basic theta 
       
    

table    path planning algorithms on random            grids with non uniform traversal costs

path  and thus need to post process many paths  table   reports the runtimes of the path planning
algorithms without these post processing steps  the runtime of basic theta  per vertex expansion
is similar to that of a  ps and shorter than that of either ap theta  and fd  because the later two
algorithms require more floating point operations 
    non uniform traversal costs
so far  basic theta  has found paths on grids that contain unblocked cells with uniform traversal
costs  in this case  true shortest paths have heading changes only at the corners of blocked cells and
the triangle inequality holds  which means that path   is no longer than path    we now discuss
a version of basic theta  that finds paths on grids that contain unblocked cells with non uniform
traversal costs by computing and comparing path lengths  which are now path costs  appropriately 
in this case  true shortest paths can also have heading changes at the boundaries between unblocked
cells with different traversal costs and the triangle inequality is no longer guaranteed to hold  which
means that path   can be more costly than path    thus  basic theta  no longer unconditionally
chooses path   over path   if path   is unblocked  line     but chooses the path with the smaller
cost  it uses the standard cohen sutherland clipping algorithm from computer graphics  foley  van
dam  feiner    hughes        to calculate the cost of path   during the line of sight check  figure
   shows an example for the path segment c a  from vertex c  to vertex a   this straight line is
split into line segments at the points where it intersects with cell boundaries  the cost of the path
segment is the sum of the costs of its line segments ii ii     and the cost of each line segment is the
product of its length and the traversal cost of the corresponding unblocked cell 
we found that changing the test on line    in algorithm   from strictly less than to less than or
equal to slightly reduces the runtime of basic theta   this is a result of the fact that it is faster to
compute the cost of a path segment that corresponds to path   than path   since it tends to consist
of fewer line segments 
   

fidaniel   nash   koenig     f elner

a

 

 

 

 

 

a

s goal

 

 

 

 

 

s goal
h      

h      
b

b

g      
g      
c

c

s start

s start

 a 

 b 

figure     non monotonicity of f values of basic theta 

we compare basic theta  to a  on grids and fd  with respect to their path cost and runtime
 measured in seconds  since a  can easily be adapted to grids that contain unblocked cells with
non uniform traversal costs and fd  was designed for this case  we compare these path planning
algorithms on            grids  where each cell is assigned an integer traversal cost from   to   
 corresponding to an unblocked cell  and infinity  corresponding to a blocked cell   similar to the
technique used in the work of ferguson and stentz          if a path lies on the boundary between
two cells with different traversal costs  then we use the smaller traversal cost of the two cells  the
start and goal vertices are the south west corners of cells  the start vertex is in the south west cell 
the goal vertex is in a cell randomly chosen from the column of cells furthest east  we average
over     random grids  table    a  reports our results if every traversal cost is chosen with uniform
probability  resulting in small contiguous regions of uniform traversal costs  the path cost and
runtime of fd  are both smaller than those of basic theta   the path cost of a  on grids is only
about   percent larger than that of fd  although its runtime is much smaller than that of fd   thus 
any angle planning does not have a large advantage over a  on grids  table   b  reports our results
if traversal cost one is chosen with probability    percent and all other traversal costs are chosen
with uniform probability  resulting in large contiguous regions of uniform traversal costs  the path
cost of basic theta  is now smaller than that of fd  and its runtime is about the same as that of
fd   the paths found by fd  tend to have many more unnecessary heading changes in regions
with the same traversal costs than those of basic theta   which outweighs the paths found by basic
theta  not having necessary heading changes on the boundary between two cells with different
traversal costs  the path cost of a  on grids is more than   percent larger than that of basic theta  
thus  any angle planning now has a larger advantage over a  on grids 

   trading off runtime and path length  exploiting h values
there are strategies for trading off runtime and path length that a  on grids and basic theta  share 
however  their behavior can be very different even though the two algorithms have very similar
pseudocode  in this section  we develop versions of basic theta  that might be able to find shorter
paths at an increase in runtime  including versions that use weighted h values with weights less than
one  that break ties among vertices with the same f value in the open list in favor of vertices with
smaller g values  when they decide which vertex to expand next  and that re expand vertices whose
f values have decreased 
   

fit heta    a ny a ngle path p lanning

on

g rids

we use all path planning algorithms with consistent h values  a  on grids then has the following
properties  pearl         the f value of any expanded vertex is no larger than the f value of any of
its unexpanded visible neighbors after updating them according to path    which implies that the
f value of any vertex that is expanded before some other vertex is no larger than the f value of this
other vertex  consequently  at any point in time during a search once a vertex has been expanded 
following the parents from the expanded vertex to the start vertex retrieves a shortest path from
the start vertex to the expanded vertex in reverse  which implies that a  cannot find shorter paths
by expanding vertices more than once  basic theta  has different properties  the f value of an
expanded vertex can be larger than the f value of one or more of its unexpanded visible neighbors
after updating them according to path    which implies that the f value of a vertex that is expanded
before some other vertex can be larger than the f value of this other vertex  consequently  at any
point in time during a search once a vertex has been expanded  following the parents from the
expanded vertex to the start vertex is not guaranteed to retrieve a shortest path from the start vertex
to the vertex in reverse  which implies that basic theta  might find shorter paths by expanding
vertices more than once  figure    shows an example  when basic theta  expands start vertex c 
with parent c   it generates vertex b   vertex b  is an unexpanded visible neighbor of vertex c 
that has line of sight to vertex c   basic theta  thus updates it according to path    which is the
same as path   in this case   sets its f value to f  b                         sets its parent to vertex
c  and inserts it into the open list  figure    a    when basic theta  later expands vertex b  with
parent c   it generates vertex b   vertex b  is an unexpanded visible neighbor of vertex b  that
has line of sight to vertex c   basic theta  thus updates it according to path    sets its f value to
f  b                         sets its parent to vertex c  and inserts it into the open list  figure
   b    thus  the f value of expanded vertex b  is indeed larger than the f value of its unexpanded
visible neighbor b  after updating it according to path   because the increase in g value from vertex
b  to vertex b           is less than the decrease in h value from vertex b  to vertex b           
when basic theta  later expands vertex b   the f value of vertex b           that is expanded
before vertex b  is indeed larger than the f value of vertex b           
these properties suggest that basic theta  might be able to find shorter paths at an increase in
runtime by re expanding vertices or expanding additional vertices  for example by using weighted
h values with weights less than one  while a  cannot  at the same time  standard optimizations of
a  that decrease its runtime might also be able to decrease the runtime of basic theta   such as
breaking ties among vertices with the same f value in the open list in favor of vertices with larger
g values   in this section we investigate these tradeoffs 
    weighted h values
so far  basic theta  has used consistent h values h s   a  with consistent h values finds paths of the
same length no matter how small or large the h values are  decreasing consistent h values typically
increases the number of vertex expansions for a   we therefore now discuss a version of basic
theta  that might be able to find shorter paths at an increase in runtime by using weighted h values
with weights less than one  this version of basic theta  uses the h values h s    w  c s  sgoal  
for a given weight    w     and thus is similar to weighted a   pohl         except that weighted
a  typically uses weights greater than one  figure    a  shows an example of the resulting effect
on the number of vertex expansions and path length  the green vertex in the north east is the start

   

fidaniel   nash   koenig     f elner

 a  expanded vertices by basic theta  with different weights
     

      

     
      
     

path length

      

     

      
     

vertex expansions

   

     
     
     

   

 
 

    

   

    

   

    

   

    

 

w
basic theta  path length

ap theta  path length

basic theta  vertex expansions

ap theta  vertex expansions

 b  random          grids with    percent blocked cells

figure     weighted h values

vertex  and the red vertex in the south west is the goal vertex  basic theta  with weight       as
used so far  expands the orange vertices and finds the red path  basic theta  with weight     
expands the blue vertices and finds the blue path  thus  basic theta  expands more vertices with
   

fit heta    a ny a ngle path p lanning

path length
number of vertex expansions
runtime

smaller g values
basic theta  ap theta 
      
      
        
        
      
      

on

g rids

larger g values
basic theta  ap theta 
      
      
        
        
      
      

table    random          grids with    percent blocked cells


weight      than with weight      and the resulting path is shorter since it passes through vertices
that are expanded with weight      but not with weight      
figure    b  reports the effect of different weights on the path length and number of vertex expansions of basic theta  and ap theta  on random          grids with    percent blocked cells 
 the graphs of the number of vertex expansions of basic theta  and ap theta  nearly coincide  
decreasing the weight decreases the path length at an increase in the number of vertex expansions
and thus the runtime  the path length decreases more for ap theta  than basic theta  since ap
theta  can constrain the angle ranges more than necessary and thus benefits in two ways from expanding more vertices  however  neither basic theta  nor ap theta  are guaranteed to find true
shortest paths even if their weights are zero 
    tie breaking
so far  basic theta  has broken ties among vertices in the open list with the same f value in favor
of vertices with larger g values  when it decides which vertex to expand next   a  with consistent
h values finds paths of the same length no matter which tie breaking scheme it uses  breaking ties
in favor of vertices with smaller g values typically increases the number of vertex expansions and
thus the runtime  we therefore discuss a version of basic theta  that might be able to find shorter
paths at an increase in runtime by breaking ties in favor of vertices with smaller g values  figure   
shows an example of the resulting effect on path length  vertices c  and b  have the same f value
but vertex b  has a larger g value since f  c                      and f  b                   
if basic theta  breaks ties in favor of vertices with larger g values  then it expands vertex b  with
parent e  before vertex c  with parent c  and eventually expands the goal vertex with parent b 
and terminates  path extraction then follows the parents from goal vertex b  to start vertex e  to
retrieve the dashed red path  e   b   b    however  if basic theta  breaks ties in favor of vertices
with smaller g values  then it expands vertex c  with parent c  before vertex b  with parent e 
and eventually expands the goal vertex with parent c  and terminates  path extraction then follows
the parents from goal vertex b  to start vertex e  to retrieve the shorter solid blue path  e   c  
b   
table   reports the effect of the tie breaking scheme on the path length  number of vertex expansions
and runtime of basic theta  and ap theta  on random          grids with    percent blocked
cells  breaking ties in favor of vertices with smaller g values neither changes the path length 
number of vertex expansions nor runtime significantly  the effect of the tie breaking scheme is
small since fewer vertices have the same f value for basic theta  and ap theta  than for a  on
grids because the number of possible g values and h values is larger for any angle path planning 
   

fidaniel   nash   koenig     f elner

a

 

 

 

b

 

 

s goal

c

d

e

s start

basic theta  path  larger g values 

basic theta  path  smaller g values 

figure     basic theta  paths for different tie breaking schemes

path length
number of vertex expansions
runtime

basic theta  without vertex re expansions
      
        
      

basic theta  with vertex re expansions
      
        
      

table    random          grids with    percent blocked cells

there is also a second method in which breaking ties can effect path length  so far  basic theta 
has chosen path   over path   if an unexpanded visible neighbor of a vertex has line of sight to
the parent of the vertex  however  it can choose path   over path   if both paths are equally long 
which increases the runtime due to the additional comparison  figure    shows an example of the
resulting effect on path length  assume that basic theta  expands vertex b  before vertex c   if
basic theta  chooses path   over path   then it expands vertex b  with parent e  and eventually
expands the goal vertex b  with parent b  and terminates  path extraction then follows the parents
from goal vertex b  to start vertex e  to retrieve the dashed red path  e   b   b    however  if
basic theta  chooses path   over path   then it expands vertex b  with parent c  and eventually
expands goal vertex b  with parent c  and terminates  path extraction then follows the parents
from goal vertex b  to start vertex e  to retrieve the shorter solid blue path  e   c   b   
    re expanding vertices
so far  basic theta  has used a closed list to ensure that it expands each vertex at most once  a 
with consistent h values does not re expand vertices whether or not it uses a closed list since it
cannot find a shorter path from the start vertex to a vertex after expanding that vertex  on the other
hand  basic theta  can re expand vertices if it does not use a closed list since it can find a shorter
path from the start vertex to a vertex after expanding the vertex  it then re inserts the vertex into
   

fit heta    a ny a ngle path p lanning

a

 

 

 

 

 

 

on

 

g rids

 

b

 

s goal

c

d

e

s start

basic theta  path

basic theta  path with vertex re expansions

figure     basic theta  paths with and without vertex re expansions
the open list and eventually re expands it   figure    shows an example of the effect of vertex
re expansions on path length  basic theta  without vertex re expansions eventually expands vertex
c  with parent d   vertex c  is an unexpanded visible neighbor of vertex c  that has line of sight
to vertex d   basic theta  without vertex re expansions thus updates it according to path   and
sets its parent to vertex d   after termination  path extraction follows the parents from goal vertex
b  to start vertex e  to retrieve the dashed red path  e   d   c   b    however  basic theta  with
vertex re expansions eventually expands vertex c  with parent d  and later re expands vertex c 
with parent e   vertex c  is a visible neighbor of vertex c  that has line of sight to vertex e  
basic theta  with vertex re expansions thus updates it according to path   and sets its parent to
vertex e   after termination  path extraction follows the parents from goal vertex b  to start vertex
e  to retrieve the shorter solid blue path  e   c   b   
theorem    basic theta  with vertex re expansions terminates and path extraction returns an
unblocked path from the start vertex to the goal vertex if such a path exists  otherwise  basic
theta  with vertex re expansions terminates and reports that no unblocked path exists 

proof  the proof is similar to the proof of theorem    the only property that needs to be proved
differently is that basic theta  with vertex re expansions terminates since it is no longer true that it
can never insert a vertex into the open list again once it has removed the vertex from the open list 
however  since the number of vertices is finite  there are only a finite number of acyclic paths from
the start vertex to each vertex  therefore  the number of possible g values is finite  therefore  basic
theta  with vertex re expansions can reduce the g value of each vertex only a finite number of times
and thus inserts each vertex into the open list a finite number of times  thus  the open list eventually
becomes empty and basic theta  has to terminate if it has not terminated earlier already 
   basic theta  with vertex re expansions could also delay the expansion of the goal vertex  for example  by increasing
its f value artificially  so that it can re expand more vertices before it terminates but our version of basic theta  with
vertex re expansions does not do that 

   

fidaniel   nash   koenig     f elner

table   reports the effect of vertex re expansions on the path length  number of vertex expansions
and runtime of basic theta  on random          grids with    percent blocked cells  vertex
re expansions decrease the path length slightly at an increase in the number of vertex expansions
and thus the runtime 

    trading off runtime and path length  other approaches
there are additional strategies for trading off runtime and path length that are specific to basic
theta   in this section  we develop versions of basic theta  that might be able to find shorter
paths at an increase in runtime by examining more paths  including versions that check for line ofsight to the parent of a parent  that use key vertices to identify promising parents and that increase
the number of visible neighbors and thus the number of potential parents when updating vertices
according to path   
     three paths
so far  basic theta  has considered two paths  namely paths   and    when it updates the gvalue and parent of an unexpanded visible neighbor s of vertex s  we now discuss a version
of basic theta  that considers a third path  namely the path from the start vertex to the parent
of the parent of vertex s    g parent parent s     and from it to vertex s in a straight line   
c parent parent s    s     resulting in a length of g parent parent s      c parent parent s    s   
this version of basic theta  might be able to find shorter paths at an increase in runtime since the
third path is no longer than path   due to the triangle inequality  however  our experimental results
 not reported here  show that the third path does not decrease the path length significantly because
the original version of basic theta  already determines that the parent of the parent of vertex s does
not have line of sight to some vertex that shares its parent with vertex s  thus  it is very unlikely
that the parent of the parent of vertex s has line of sight to vertex s and thus that the third path is
unblocked 
     key vertices
so far  basic theta  has considered two paths  namely paths   and    when it updates the g value
and parent of an unexpanded visible neighbor s of vertex s  the parent of a vertex then is either
a visible neighbor of the vertex or the parent of a visible neighbor  which is not always the case
for true shortest paths  we now discuss a version of basic theta  that considers additional paths 
namely the paths from the start vertex to cached key vertices and from them to vertex s in a straight
line  this version of basic theta  might be able to find shorter paths at an increase in runtime
due to the fact that the parent of a vertex can now also be one of the key vertices  however  our
experimental results  not reported here  show that key vertices decrease the path length only slightly
at a larger increase in runtime due to the overhead of having to select key vertices  maintain them
and consider a larger number of paths 

   

fit heta    a ny a ngle path p lanning

 a  branching factor  

 b  branching factor  

on

g rids

 c  branching factor   

figure     grids with different branching factors

   

   
     

   

   

   

   
   

     

runtime

path length

     

   
   

     
   

   

     
   

 
 

basic theta 

  

branching factor
path length

runtime

figure     basic theta  on random          grids with    percent blocked cells

     larger branching factors
so far  basic theta  has operated on eight neighbor grids  we now discuss a version of basic theta 
that operates on grids with different numbers of neighbors and thus different branching factors 
figure    shows the neighbors of the center vertex for branching factors      and    respectively 
this version of basic theta  might be able to find shorter paths at an increase in runtime since
larger branching factors increase the number of visible neighbors of vertices and thus their number
of potential parents when updating them according to path    figure    reports the effect of larger
branching factors on the path length and runtime of basic theta  on random          grids with
   percent blocked cells  larger branching factors indeed decrease the path length at an increase in
runtime 
   

fidaniel   nash   koenig     f elner

    conclusions
any angle path planning algorithms find paths without artificially constraining the headings of the
paths  we presented two new correct and complete any angle path planning algorithms  basic
theta  and angle propagation theta   ap theta   are both variants of a  that propagate information along grid edges  to achieve a short runtime  without constraining paths to grid edges  to find
any angle paths   basic theta  is simple to understand and implement  fast and finds short paths 
however  it is not guaranteed to find true shortest paths  ap theta  achieves a worst case complexity per vertex expansion that is constant  like that of a  on grids  rather than linear in the number
of cells  like that of basic theta   by propagating angle ranges when it expands vertices  however 
ap theta  is more complex than basic theta   is not as fast and finds slightly longer paths 
we proved the correctness and completeness of basic theta  and ap theta  and then compared
them against three existing any angle path planning algorithms  namely a  with post smoothed
paths  a  ps   a  on visibility graphs and field d   fd    the only other version of a  we know
of that propagates information along grid edges without constraining the paths to grid edges  basic
theta  and ap theta   unlike a  ps  consider paths not constrained to grid edges during their
search and thus can make informed decisions regarding these paths during the search  basic theta 
and ap theta   unlike fd   take advantage of the fact that true shortest paths have heading changes
only at the corners of blocked cells 
a  on visibility graphs finds true shortest paths but is slow  on the other hand  a  on grids finds
long paths but is fast  any angle path planning lies between these two extremes  basic theta 
dominates ap theta   a  ps and fd  in terms of their tradeoffs between runtime and path length 
it finds paths that are almost as short as true shortest paths and is almost as fast as a  on grids 
we extended basic theta  to find paths from a given start vertex to all other vertices and to find
paths on grids that contain cells with non uniform traversal costs  the f value of an expanded vertex
of basic theta   unlike a  on grids  with consistent h values can be larger than the f value of one
or more of its unexpanded visible neighbors  which means that basic theta  might be able to find
shorter paths at an increase in runtime by re expanding vertices or expanding additional vertices 
we thus developed versions of basic theta  that use weighted h values with weights less than one 
that break ties among vertices with the same f value in the open list in favor of vertices with smaller
g values  when they decide which vertex to expand next   that re expand vertices whose f values
have decreased  that check for line of sight to the parent of a parent  that use key vertices to identify
promising parents and that increase the number of visible neighbors 
in the future  we intend to develop a worst case bound on the path lengths of basic theta  and ap
theta   to better understand their properties and to investigate faster versions of ap theta  that
perform line of sight checks in constant time 

appendix a  checking line of sight
in this appendix  we explain how to perform line of sight checks fast  for simplicity  we allow
straight lines to pass between diagonally touching blocked cells  performing a line of sight check
is similar to determining which points to plot on a raster display when drawing a straight line between two points  the plotted points correspond to the cells that the straight line passes through 
   

fit heta    a ny a ngle path p lanning

on

g rids

    lineofsight s  s 
   
x     s x 
   
y     s y 
   
x     s  x 
   
y     s  y 
   
dy    y   y   
   
dx    x   x   
   
f      
   
if dy     then
   
dy    dy  
   
sy      
   
   

else

   
   
   

if dx     then
dx    dx  
sx      

   
   

else

   
   
   
   
   
   

if dx  dy then
while x     x  do
f    f   dy  
if f  dx then
if grid x      sx         y      sy         then
return false 

sy      

sx      

y     y    sy  
f    f  dx  

   
   
   
   

if f      an d grid x      sx         y      sy         then
return false 

   
   

if dy     an d grid x      sx         y    an d grid x      sx         y      then
return false 

   

x     x    sx  

   
   
   
   
   
   

else
while y     y  do
f    f   dx  
if f  dy then
if grid x      sx         y      sy         then
return false 
x     x    sx  
f    f  dy  

   
   
   
   

if f      an d grid x      sx         y      sy         then
return false 

   
   

if dx     an d grid x    y      sy         an d grid x      y      sy         then
return false 

   

y     y    sy  

   
return true 
    end

algorithm    line of sight algorithm

thus  two vertices have line of sight iff none of the plotted points correspond to blocked cells  this
allows basic theta  to perform its line of sight checks with the standard bresenham line drawing
algorithm from computer graphics  bresenham         that uses only fast logical and integer operations rather than floating point operations  algorithm   shows the resulting line of sight algorithm 
   

fidaniel   nash   koenig     f elner

ii

yaxis

i

p
b 

xaxis

b 

b 
b 

b 

b 
b 

b 

b 
b 

s

iii

b   

upper boundary

iv
lower boundary

figure     parent  blocked cell and boundary vertices
where s x and s y are the x and y coordinates of vertex s  respectively  grid represents the grid and
grid x  y  is true iff the corresponding cell is blocked 

appendix b  ap theta  returns unblocked paths
in this appendix  we prove that ap theta  never returns a blocked path 
theorem    ap theta  never returns a blocked path 
proof  we define a path to be blocked iff at least one vertex on the path does not have line of sight
to its successor on the path  thus  a path is blocked iff at least one of its path segments passes
through the interior of a blocked cell or passes between two blocked cells that share an edge 
we first prove that ap theta  never returns a path with a path segment that passes through the
interior of a blocked cell  we prove by contradiction that ap theta  cannot assign some parent p
to some vertex s such that the path segment from parent p to vertex s passes through the interior of
some blocked cell b  assume otherwise  to simplify the proof  we translate and rotate the grid such
that blocked cell b is immediately south west of the origin b  of the grid and parent p is in quadrant
ii  as shown in figure     we define the quadrant of a vertex s as follows  where s x and s y are the
x and y coordinates of vertex s  respectively 
 quadrant i is the north east quadrant  excluding the x axis  given by s x    and s y     
 quadrant ii is the north west quadrant  excluding the y axis  given by s x     and s y    
 quadrant iii is the south west quadrant  excluding the x axis  given by s x    and s y     
   

fit heta    a ny a ngle path p lanning

northwest s 
west s 
southwest s 

north s 
s

south s 

on

g rids

northeast s 
east s 
southeast s 

figure     neighbors of vertex s
 quadrant iv is the south east quadrant  excluding the y axis but including the origin b    given
by s x     and s y    or s x     and s y     
we refer to the neighbors of vertex s as east s   northeast s   north s   northwest s   west s  
southwest s   south s   southeast s   as shown in figure    
assume that there is a light source at vertex p and that light cannot pass through blocked cell b 
which creates a shadow  a vertex s is in the shadow iff the straight line from parent p to vertex
s passes through the interior of blocked cell b  we distinguish two parts of the perimeter of this
shadow  namely the upper and lower boundary  as shown in figure     we define a boundary vertex
to be any vertex not in the shadow that has at least one neighbor  although not necessarily a visible
neighbor  in the shadow  the origin b  is not in the shadow but its neighbor south b    is in the
shadow  thus  the origin b  is a boundary vertex  we consider only the upper boundary without
loss of generality  then  a boundary vertex  to be precise  an upper boundary vertex  is any vertex
s with  s  p  b        that is  on or above the upper boundary and thus outside of the shadow  that
has at least one neighbor s with  s   p  b         that is  below the upper boundary and thus inside
of the shadow   it is easy to see that all boundary vertices are in quadrant iv and form an infinite
boundary path  b    b           that starts at the origin b  and repeatedly moves either south or east  that
is  bi     south bi   or bi     east bi   
we define a vertex s to be sufficiently constrained iff  s  p  b     lb s  for its parent p  once
vertex s is sufficiently constrained  it remains sufficiently constrained since no operation of ap
theta  can decrease its lower angle bound lb s   we prove in the following that every boundary
vertex is sufficiently constrained at the time it is expanded if it is expanded with parent p  consider
any vertex s below the upper boundary  that is   s  p  b        and thus  b    p  s       that is a
visible neighbor of some boundary vertex bi   vertex s cannot have been updated according to path  
and been assigned parent p at the time its parent p was expanded since the straight line from parent p
to vertex s passes through the interior of a blocked cell and they are therefore not visible neighbors 
it cannot have been updated according to path   and been assigned parent p at the time boundary
vertex bi was expanded with parent p because boundary vertex bi is sufficiently constrained at that
time and thus  bi   p  b     lb bi    which implies that  bi   p  s     bi   p  b       b    p  s   
 bi   p  b     lb bi   and the condition on line    remains unsatisfied  consequently  no vertex in
the shadow can have parent p 
we now prove by induction on the order of the vertex expansions that every boundary vertex is
sufficiently constrained at the time it is expanded if it is expanded with parent p  assume that
boundary vertex b  is expanded with parent p  then  the condition on line    is satisfied and
   

fidaniel   nash   koenig     f elner

line    is executed for blocked cell b at the time boundary vertex b  is expanded with parent p 
boundary vertex b  is sufficiently constrained afterwards since its lower angle bound is set to zero 
now assume that boundary vertex bi with i     is expanded with parent p  then  boundary vertex bi
cannot be identical to parent p  since they are in different quadrants  nor to the start vertex  since the
start vertex does not have parent p   boundary vertex bi cannot have been updated according to path
  and been assigned parent p at the time its parent p was expanded since p x     and  bi   x     and
they are thus not neighbors  consequently  boundary vertex bi must have been updated according
to path   and been assigned parent p at the time one of its visible neighbors x was expanded with
parent p  vertex x must be on or above the upper boundary  that is   x  p  b        and cannot be
identical to parent p  since they are in different quadrants   we distinguish two cases 
 assume that vertex x is a boundary vertex  it is sufficiently constrained at the time it is expanded with parent p according to the induction assumption  that is   x  p  b     lb x  
since it is expanded before boundary vertex bi   boundary vertex bi was updated according
to path   at the time vertex x was expanded with parent p  thus  the condition on line
   is satisfied at that time  that is  lb x    x  p  bi    and thus lb x     bi   p  x   
lb x    x  p  bi       then  the conditions on lines    and    are satisfied and
line    is executed with s   x at the time boundary vertex bi is expanded with parent
p  boundary vertex bi is sufficiently constrained afterwards since its lower angle bound
is set to max lb bi    lb x     bi   p  x   and  bi   p  b       bi   p  x     x  p  b    
lb x     bi   p  x   max lb bi    lb x     bi   p  x   
 assume that vertex x is not a boundary vertex 
lemma    assume that a vertex s and a boundary vertex bi are visible neighbors  c p  bi    
c p  s  and  s  p  bi        assume that boundary vertex bi is sufficiently constrained at the
time vertex s is expanded with parent p if boundary vertex bi has been expanded with parent
p at that time  then  vertex s is sufficiently constrained at the time it is expanded if it is
expanded with parent p 
proof  assume that vertex s is expanded with parent p  then   s  p  b       s  p  bi    
 bi   p  b        since  s  p  bi       and  bi   p  b        we distinguish two cases 
 assume that boundary vertex bi is not expanded before vertex s or is expanded with
a parent other than parent p  then  the conditions on lines    and    are satisfied
and line    is executed with s   bi at the time vertex s is expanded with parent
p  vertex s is sufficiently constrained afterwards since its lower angle bound is set to
max lb s    s  p  bi    and  s  p  b       s  p  bi      bi   p  b      s  p  bi   
max lb s    s  p  bi    
 assume that boundary vertex bi is expanded with parent p before vertex s is expanded
with parent p  boundary vertex bi is sufficiently constrained at the time vertex s is
expanded with parent p according to the premise  that is   bi   p  b     lb bi     furthermore  lb bi       since no operation of ap theta  can make the lower angle bound
positive  and thus lb bi      s  p  bi       then  the conditions on lines    and   
are satisfied and line    is executed with s   bi at the time vertex s is expanded with
parent p  vertex s is sufficiently constrained afterwards since its lower angle bound is
   

fit heta    a ny a ngle path p lanning

on

g rids

set to max lb s   lb bi      s  p  bi    and  s  p  b       s  p  bi      bi   p  b    
lb bi      s  p  bi    max lb s   lb bi      s  p  bi    

boundary vertex bi is either immediately south or east of boundary vertex bi  since the
boundary path moves only south or east  we distinguish three subcases 
 assume that parent p is on the x axis in quadrant ii  then  the boundary path is
along the x axis  vertices west bi   and east bi   are boundary vertices  and vertices
southwest bi    south bi    and southeast bi   are below the upper boundary  thus 
vertex x is identical to one of vertices northwest bi    north bi   or northeast bi    in
all cases  there is a boundary vertex bj immediately south of vertex x  if vertices x
and bj were not visible neighbors  then there would be blocked cells immediately southwest and south east of vertex x and vertices x and bi could thus not be visible neighbors 
thus  vertices x and bj are visible neighbors  furthermore  boundary vertex bj is immediately south of vertex x and thus c p  bj     c p  x  and  x  p  bj        finally 
boundary vertex bj is sufficiently constrained according to the induction assumption at
the time boundary vertex bi is expanded with parent p if boundary vertex bj has been
expanded with parent p at that time  thus  vertex x is sufficiently constrained at the time
it is expanded with parent p according to lemma    that is   x  p  b     lb x    consequently  the conditions on lines    and    are satisfied  for the reason given before  and
line    is executed with s   x at the time boundary vertex bi is expanded with parent
p  boundary vertex bi is sufficiently constrained afterwards since its lower angle bound
is set to max lb bi    lb x     bi   p  x   and  bi   p  b       bi   p  x     x  p  b    
lb x     bi   p  x   max lb bi    lb x     bi   p  x   
 assume that parent p is not on the x axis in quadrant ii and that boundary vertex
bi is immediately east of boundary vertex bi  and thus c p  bi      c p  bi   and
 bi   p  bi         furthermore  boundary vertex bi  is sufficiently constrained according to the induction assumption at the time boundary vertex bi is expanded with
parent p if boundary vertex bi  has been expanded with parent p at that time  if boundary vertices bi  and bi are visible neighbors  then boundary vertex bi is sufficiently
constrained at the time it is expanded with parent p according to lemma    if boundary
vertices bi  and bi are not visible neighbors  then there must be blocked cells immediately north west and south west of boundary vertex bi   then  line    is satisfied and
line    is executed for the blocked cell immediately south west of boundary vertex bi at
the time boundary vertex bi is expanded with parent p  boundary vertex bi is sufficiently
constrained afterwards since its lower angle bound is set to zero 
 assume that parent p is not on the x axis in quadrant ii and that boundary vertex bi is
immediately south of boundary vertex bi   
lemma    assume that a vertex s in quadrant iv is on or above the upper boundary 
then  vertex s is a boundary vertex iff the vertex immediately south west of vertex s is
below the upper boundary 
   

fidaniel   nash   koenig     f elner

proof  if the vertex s immediately south west of vertex s is below the upper boundary 
then vertex s is a boundary vertex by definition  on the other hand  if vertex s is on
or above the upper boundary  that is   s   p  b         then vertex s is not a boundary
vertex because every neighbor of it is on or above the upper boundary  the neighbors
of vertex s are
east s   northeast s   north s   northwest s  
west s   southwest s   south s  and southeast s  
or  equivalently 
east east north s      east east north north s       east north north s     
north north s     north s    s   east s   and east east s    
thus  every neighbor s of vertex s can be reached from vertex s by repeatedly moving either north or east and thus  s   p  s       consequently   s   p  b     
 s   p  s      s   p  b       and thus every neighbor s of vertex s is on or above the
upper boundary 
we distinguish two subcases 
 assume that boundary vertex bi   is immediately east of boundary vertex
bi   vertices north bi   and east bi   are boundary vertices  vertices west bi   
southwest bi   and south bi   are south west of boundary vertices bi    bi and bi    
respectively  and thus below the upper boundary according to lemma    vertices
northwest bi   and southeast bi   are either boundary vertices or south west of
boundary vertices bi  and bi     respectively  and then below the upper boundary
according to lemma    thus  vertex x is identical to vertex northwest bi   
 assume that boundary vertex bi   is immediately south of boundary vertex bi  
vertices north bi   and south bi   are boundary vertices  vertices west bi   and
southwest bi   are south west of boundary vertices bi  and bi   respectively  and
thus below the upper boundary according to lemma    vertex northwest bi   is
either a boundary vertex or south west of boundary vertex bi  and then below the
upper boundary according to lemma    thus  vertex x is identical to one of vertices
northeast bi    east bi   or southeast bi   
in all cases  vertex x is immediately east of some boundary vertex bj and thus c p  bj    
c p  x  and  x  p  bj        if vertices x and bj were not visible neighbors  then there
would be blocked cells immediately north west and south west of vertex x and vertices
x and bi could not be visible neighbors  thus  vertices x and bj are visible neighbors 
furthermore  boundary vertex bj is sufficiently constrained according to the induction
assumption at the time boundary vertex bi is expanded with parent p if boundary vertex bj has been expanded with parent p at that time  thus  vertex x is sufficiently
constrained at the time it is expanded with parent p according to lemma    that is 
 x  p  b     lb x    consequently  the conditions on lines    and    are satisfied  for
the reason given before  and line    is executed with s   x at the time boundary vertex
bi is expanded with parent p  boundary vertex bi is sufficiently constrained afterwards
since its lower angle bound is set to max lb bi    lb x     bi   p  x   and  bi   p  b     
 bi   p  x     x  p  b     lb x     bi   p  x   max lb bi    lb x     bi   p  x   
   

fit heta    a ny a ngle path p lanning

on

g rids

this concludes the proof that every boundary vertex is sufficiently constrained at the time it is
expanded if it is expanded with parent p and thus also the proof that ap theta  never returns a path
with a path segment that passes through the interior of a blocked cell 
we now prove that ap theta  never returns a path with a path segment that passes between two
blocked cells that share an edge  we prove by contradiction that ap theta  cannot assign some
parent p to some vertex s such that the path segment from parent p to vertex s passes between two
blocked cells that share an edge  assume otherwise and consider the first time ap theta  assigns
some parent p to some vertex s such that the path segment from parent p to vertex s passes between
two blocked cells that share an edge  the path segment must be either horizontal or vertical  vertex
s cannot have been updated according to path   and been assigned parent p at the time its parent p
was expanded since then the straight line from parent p to vertex s passes through the interior of a
blocked cell and they are therefore not visible neighbors  it cannot have been updated according to
path   and been assigned parent p at the time some visible neighbor s was expanded with parent p
since then either a  neighbor s would not be colinear with vertices p and s and the straight line from
parent p to vertex s would thus pass through the interior of a blocked cell or b  neighbor s would
be colinear with vertices p and s and the straight line from parent p to vertex s would pass between
two blocked cells that share an edge  which is a contradiction of the assumption  this concludes
the proof that ap theta  never returns a path with a path segment that passes between two blocked
cells that share an edge 
thus  ap theta  never returns a blocked path 

appendix c  acknowledgments
this article is an extension of an earlier publication  nash et al         and contains additional
expositions  examples and proofs  we thank vadim bulitko from the university of alberta for
making maps from the real time game baldurs gate ii available to us  our research was done while
ariel felner spent his sabbatical at the university of southern california  visiting sven koenig 
this research has been partly supported by a u s  army research laboratory  arl  and u s 
army research office  aro  award to sven koenig under grant w   nf            by a office
of naval research  onr  award to sven koenig under grant n                 by a national
science foundation  nsf  award to sven koenig under grant         and by an israeli science
foundation  isf  award to ariel felner under grants        and         alex nash was funded
by the northrop grumman corporation  the views and conclusions contained in this document
are those of the authors and should not be interpreted as representing the official policies  either
expressed or implied  of the sponsoring organizations  agencies  companies or the u s  government 

references
aurenhammer  f          voronoi diagramsa survey of a fundamental geometric data structure 
acm computing surveys                
botea  a   muller  m     schaeffer  j          near optimal hierarchical path finding  journal of
game development            
   

fidaniel   nash   koenig     f elner

bresenham  j          algorithm for computer control of a digital plotter  ibm systems journal 
           
bulitko  v   sturtevant  n     kazakevich  m          speeding up learning in real time search via
automatic state abstraction  in proceedings of the aaai conference on artificial intelligence 
pp           
choset  h   lynch  k   hutchinson  s   kantor  g   burgard  w   kavraki  l     thrun  s         
principles of robot motion  theory  algorithms  and implementations  mit press 
deloura  m          game programming gems  charles river media 
ferguson  d     stentz  a          using interpolation to improve path planning  the field d 
algorithm  journal of field robotics               
foley  j   van dam  a   feiner  s     hughes  j          computer graphics  principles and practice  addison wesley 
hart  p   nilsson  n     raphael  b          a formal basis for the heuristic determination of
minimum cost paths  ieee transactions on systems science and cybernetics  scc      
       
kavraki  l   svestka  p   latombe  j     overmars  m          probabilistic roadmaps for path
planning in high dimensional configuration spaces  ieee transactions on robotics and automation                
koenig  s     likhachev  m          d  lite  in proceedings of the aaai conference on artificial
intelligence  pp         
lavalle  s     kuffner  j          rapidly exploring random trees  progress and prospects  in
donald  b   lynch  k     rus  d   eds    algorithmic and computational robotics  new
directions  pp          a k peters 
lee  d  t          proximity and reachability in the plane  ph d  thesis  university of illinois at
urbana champaign 
liu  y  h     arimoto  s          path planning using a tangent graph for mobile robots among
polygonal and curved obstacles  international journal robotics research                
lozano perez  t     wesley  m          an algorithm for planning collision free paths among
polyhedral obstacles  communication of the acm             
mitchell  j     papadimitriou  c          the weighted region problem  finding shortest paths
through a weighted planar subdivision  journal of the acm              
murphy  r          introduction to ai robotics  mit press 
nash  a   daniel  k   koenig  s     felner  a          theta   any angle path planning on grids 
in proceedings of the aaai conference on artificial intelligence  pp           
nash  a   koenig  s     likhachev  m          incremental phi   incremental any angle path planning on grids  in proceedings of the international joint conference on aritificial intelligence 
pp           
patel  a         
amits game programming information 
available online at
http   theory stanford edu amitp gameprogramming maprepresentations html 
   

fit heta    a ny a ngle path p lanning

on

g rids

pearl  j          heuristics  intelligent search strategies for computer problem solving  addisonwesley 
pohl  i          the avoidance of  relative  catastrophe  heuristic competence  genuine dynamic
weighting and computational issues in heuristic problem solving  in proceedings of the international joint conference on artificial intelligence  pp       
rabin  s          ai game programming wisdom  charles river media 
rabin  s          ai game programming wisdom    charles river media 
thorpe  c          path relaxation  path planning for a mobile robot  in proceedings of the aaai
conference on artificial intelligence  pp         
tozour  p          search space representations  in rabin  s   ed    ai game programming wisdom
   pp         charles river media 
yahja  a   stentz  a   singh  s     brumitt  b          framed quadtree path planning for mobile
robots operating in sparse environments  in proceedings of the international conference on
robotics and automation  pp         
yap  p          grid based path finding  in proceedings of the canadian conference on artificial
intelligence  pp       

   

fi