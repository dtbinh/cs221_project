journal artificial intelligence research                  

submitted        published      

compiling causal theories successor state axioms
strips like systems
fangzhen lin

flin cs ust hk

department computer science
hong kong university science technology
clear water bay  kowloon  hong kong

abstract
describe system specifying effects actions  unlike commonly
used ai planning  system uses action description language allows one
specify effects actions using domain rules  state constraints
entail new action effects old ones  declaratively  action domain language
corresponds nonmonotonic causal theory situation calculus  procedurally 
action domain compiled set logical theories  one action domain 
fully instantiated successor state like axioms strips like systems
generated  expect system useful tool knowledge engineers writing action
specifications classical ai planning systems  golog systems  systems
formal specifications actions needed 

   introduction
describe system generating action effect specifications set domain rules
direct action effect axioms  among things  expect system useful
tool knowledge engineers writing action specifications classical ai planning systems 
golog systems  levesque et al          systems formal specifications
actions needed 
motivate  consider language used strips  fikes   nilsson        describing effects actions  briefly speaking  action described language
first order formula  called precondition describes condition
action executable  add list enumerates propositions action make
true successfully executed situation  delete list enumerates propositions action make false successfully executed situation 
original strips allowed precondition elements two lists complex
formulas  strips actions refer whose precondition given conjunction atomic formulas whose add delete lists lists atomic formulas 
widely acknowledged language inadequate describing actions
real world  one limitations  one address paper 
language  one enumerate possible effects action  difficult impossible
task complex domains  example  given large c program  hard figure
effects changing value pointer values pointers program 
however  underlying principle simple  value pointer changes 
values pointers point memory location change well  put
another way  direct effect action changing value pointer x
c
    
ai access foundation morgan kaufmann publishers  rights reserved 

filin

value pointer x  indirect side effects action derived
constraint says two pointers point common location 
values must same 
idea specifying effects actions using domain constraints engineering
first principle  many advantages  first all  constraints action independent  work actions  secondly  effects actions derived domain
constraints agree ones expectation  good indication one
axiomatized domain correctly  finally  domain constraints used purposes well  instance  used check consistency initial situation
database  general  set sentences violates domain constraint  know
legal situation satisfy set sentences  idea used planning
prune impossible states  recently  even efforts reverse engineering
domain constraints strips like systems speed planners  e g  zhang   foo 
      gerevini   schubert        fox   long        others  
appealing use domain constraints derive indirect effects actions 
making idea work formally turned challenge  problem commonly
known ramification problem  various proposals made solve it 
recently  however  proposals best theoretical interest
high computational complexity  situation since changed substantially due
use causality representing domain constraints  lin              mccain   turner 
            thielscher              baral        lifschitz        others  
describe paper implemented system builds recent work causalitybased approaches ramification problem  specifically  system takes input
action domain description actions described precondition axioms
direct effect axioms  domain constraints represented call domain rules 
system returns output complete action specification strips like format
set fully instantiated successor state axioms  reiter        
paper organized follows  begin introducing action description language  propose procedure compile action domain specified language
complete set successor state axioms strips like description
extracted  show soundness procedure respect translation
action domain descriptions situation calculus causal theories lin         next
describe implementation procedure  present experimental results 
one see  one limitations system essentially propositional 
effect axioms domain rules variables  need fully instantiated
compilation process  partially overcome limitation  show results
allow one generalize propositional output first order case certain classes
action domain descriptions  discuss related work  conclude paper
pointers future work 

   action description language
assume first order language equality  shall call predicates whose extensions may changed actions fluents  whose extensions changed
actions static relations  call unary static relations types  fluent atoms
   

fifrom causal theories strips like systems

mean atomic formulas formed fluents  equality atom one form u   v 
u v variables constants  inequality constraint one form
u    v  actions represented functions  assumed functions
positive arities language 
action description language includes following components 
    type definitions
type definition specified expressions following form 
domain p   a            
p type  a         constants  intuitive meaning expression
domain  extension  type p set  a            instance  blocks
world  may type called block  have  say  five blocks named numerically 
domain block                    logistics domain  may type called loc
locations  have  say    locations l    l    l    domain loc   l    l    l     
    primitive fluent definitions
primitive fluents defined expressions following form 
fluent f  x         xn    p   x    pn  xn   e  em   
f n ary fluent  pi     n  type  ei     m 
inequality constraint form xj    xk     j   k n  intuitive meaning
expression f  x         xn   legal fluent atom second argument true 
instance  blocks world  given type definition domain block             
following fluent specification 
fluent on x  y   block x  block y  x    y 
would generate following six legal fluent atoms 
on        on        on        on        on        on       
clearly  exactly one fluent definition fluent 
    complex fluent definitions
given set primitive fluents  one may want define new ones  instance 
blocks world  given primitive fluent on  define clear terms as 
 x clear x   y on y  x  
specify complex fluents clear  first define fluent formulas follows 
t    t  fluent formula  t  t  terms  i e  either constant
domain type variable 
f  t         tn   fluent formula  t         tn terms  f either n ary
primitive fluent  complex fluent  static relation 
   

filin

  fluent formula                 
fluent formulas 
fluent formula  x variable  p type   x  p   for x type p 
holds   x  p   for x type p  holds  fluent formulas  notice
require types finite domains  quantifications really shorthands 
domain p  a             x  p  stands
 x a     x an   
 x  p  stands
 x a     x an   
complex fluent specified language pair expressions following
form 
complex f  x         xn    p   x    pn  xn   e  em   
defined f  x         xn      
pi ei primitive fluent definitions  fluent formula
mention complex fluents whose free variables among x         xn  
first expression specifies syntax second semantics complex fluent 
instance  complex fluent clear blocks world specified as 
complex clear x   block x   
defined clear x    y  block on y  x   
mentioned above  quantifiers shorthands type must
finite domain  instance  given following specification 
domain block             
fluent on x  y   block x  block y  
fluent definition clear expanded to 
defined clear      on       on       on         
defined clear      on       on       on         
defined clear      on       on       on         
    static relation definitions
mentioned  static relation one changed action domain 
instance  robot navigation domain  may proposition connected d  r   r  
meaning door connects rooms r  r   truth value proposition cannot
changed navigating robot rolls room room 
language  static relation defined expression following form 
static g x         xn    p   x    pn  xn   e  em   
g n ary predicate  pi ei primitive fluent definitions 
meaning expression similar fluent definition  exactly
one definition static relation 
   

fifrom causal theories strips like systems

    domain axioms
domain axioms constraints static relations  instance  static proposition
connected d  r   r    may want impose following constraint  connected d  r   r  
connected d  r   r    language  domain axioms specified expressions
form 
axiom   
fluent formula mention fluents  i e  mentions static
relations equality  instance  constraint connected written as 
axiom  d  door  r    room  r    room connected d  r    r   
connected d  r    r     
door room types 
    action definitions
actions defined expressions following form 
action a x         xn    p   x    pn  xn   e  em   
n ary action  pi ei primitive fluent definitions 
instance  blocks world  given type definition domain block             
following action specification 
action stack x  y   block x  block y  x    y 
would generate following six action instances 
stack        stack        stack        stack        stack        stack       
exactly one action definition action 
    action precondition definitions
action precondition definitions specified expressions following form 
p recond a x         xn      
n ary action  fluent formula whose free variables among x         xn  
exactly one precondition definition action  instance 
blocks world  may have 
p recond stack x  y   clear x  clear y  ontable x   
says action stack x  y  executable situation  clear x   clear y  
ontable x  must true it 
   

filin

    action effect specifications
action effects specified expressions following form 
effect a x         xn      f  y         yk    
form 
effect a x         xn      f  y         yk    
fluent formula  f primitive fluent  intuitive meaning
expressions true initial situation  action a x         xn   cause
f  y         yk   true  false   instance  blocks world  action stack x  y  causes
x y 
effect stack x  y   true  on x  y   
example context dependent effect  consider action drop x  breaks object
fragile 
effect drop x   f ragile x   broken x   
notice fluent formula action effect specifications variables x         xn   y         yk   informally  variables supposed
universally quantified  precisely  expressions instantiated  one
substitute objects variables  provided resulting formulas well formed 
instance  given action effect specification effect move x   g x    q x    x     f  y   
one instantiate to  effect move a   g b  q b  c   f  d    long move a  legal
action  according action definition move  g b   q b  c   f  d  legal
fluent atoms  according fluent definitions g  q  f   
    domain rules
domain rules specified expressions following form 
causes   f  x         xn    
following form 
causes   f  x         xn    
fluent formula  f primitive fluent  action effect specifications 
variables x         xn   intuitive meaning domain rule
situation  holds  fluent atom f  x         xn   caused
true  domain rule stronger material implication  formal semantics given
mapping causal rule lin         see section     thus name causes 
instance  blocks world  block one block 
causes on x  y     z  on x  z   
logistics domain  one may want say package inside truck
location l  package location l well 
causes in x  y  at y  l   at x  l   
   

fifrom causal theories strips like systems

     action domain descriptions
following definition sums action description language 
definition   action domain description set type definitions  primitive fluent
definitions  complex fluent definitions  static proposition definitions  domain axioms  action
definitions  action precondition definitions  action effect specifications  domain rules 
example   following action domain description defines blocks world three
blocks 
domain block             
fluent on x  y   block x  block y   
fluent ontable x   block x   
complex clear x   block x   
defined clear x    y  block on y  x   
causes on x  y  x    z  on z  y   
causes on x  y     z  on x  z   
causes on x  y   ontable x   
causes ontable x   on x  y   
action stack x  y   block x  block y  x    y  
p recond stack x  y   ontable x  clear x  clear y   
effect stack x  y   true  on x  y   
action unstack x  y   block x  block y  x    y  
p recond unstack x  y   clear x  on x  y   
effect unstack x  y   true  ontable x   
action move x  y  z   block x  block y  block z  x    x    z    z  
p recond move x  y  z   on x  y  clear x  clear z   
effect move x  y  z   true  on x  z   

   procedural semantics
given action domain description d  use following procedure called ccp  causal
completion procedure  generate complete action effect specification 
   use primitive complex fluent definitions generate legal fluent atoms 
following let f set fluent atoms generated 
   use action definitions generate legal action instances  action
instance following 
   

filin

     primitive fluent atom f f  collect ground instances  positive
effects 
effect a      f      effect a  n   f   
ground instances negative effects 
effect a      f      effect a    f   
ground instances positive domain rules 
causes      f      causes  k   f   
ground instances negative domain rules 
causes      f      causes  l   f   
generate following pseudo successor state axiom 
succ f   init     init n   succ      succ  l  
init f    init     init m  
succ      succ  k    

   

fluent formula   init   formula obtained replacing every fluent atom f init f    similarly succ   formula
obtained replacing every fluent atom f succ f    intuitively 
init f   means f true initial situation  succ f   f true
successor situation performing action initial situation 
     let succ set pseudo successor state axioms  one primitive
fluent f   generated last step  succ  following set axioms 
succ     succ f   succ     defined f    complex fluent definition  
init following set axioms 
init       axiom   domain axiom 
 init   init f     causes   f   domain rule 
 init   init f     causes   f   domain rule 
 init f   init     defined f    complex fluent definition 
 init a     p recond a    precondition definition a  
fluent atom f   formula f
init succ succ     succ f   f  
f mention propositions form succ f    output
axiom
succ f   f  
   generating ground instances  shorthands  x  p  expanded  see definition fluent
formulas last section 

   

fifrom causal theories strips like systems

otherwise  action effect f indeterminate  case  output two
axioms 
succ f   f  
f succ f   
f strongest formula satisfying first implication  f weakest
formula satisfying second implication  following  explicit
action computing effects  write axioms
succa   inita   succ a  
conceptually  step     procedure significant  next section 
shall prove step provably correct translation situation calculus
causal theories lin         computationally  step     expensive  shall
describe strategies system uses implement section   
procedure work properly  action domain description satisfy
following conditions 
   require fluent atoms init  succ  succ  among generated
step    would rule cases
fluent on x  y   block x  block y  x    y 
together defined clear x    y  block on y  x    latter would generate
fluent atoms form on x  x  ruled fluent definition on 
one could either drop inequality constraint definition change
complex fluent definition defined clear x    y  block  on y  x  x    y   
could built test procedure reject action domain
description incoherent fluent definitions this  one easy way making sure
happen use inequality constraints definition fluents 
   mentioned above  action exactly one action precondition captures exactly conditions action executable 
action precondition given explicitly this  one needs careful
writing action effect axioms domain rules contradictory effects
would generated  instance  given p recond a  true   action effect axioms
effect a  true  f   effect a  true  f   clearly realizable simultaneously 
similarly  causes true  f   given domain rule  one write
effect axiom effect a  true  f    insisted always executable 
could simply conclude executable effect axioms contradiction effect axioms contradict domain rules  remains future
work extend procedure allow automatic generation implicitly
given action preconditions  now  shall assume given action domain
specification consistent sense action instance generated
step    following theory
init succ succ   init   succ f    
effect a    f   ground instance effect axiom 
   

filin

consistent 
   related point  procedure assumes information initial situation
given init  particular  action effect axioms entail information initial situation  instance  given causes q  p   effect a  true  p  
p recond a  true   must initial situation  q cannot true 
otherwise  persist next situation  causing p false  contradicts action effect  formally  means given set atoms
form init f    f primitive fluent atom  init consistent 
succsucc  consistent    complement i  following
set 
 init f     init f    
f primitive fluent atom generated step   
notice similar reason  reiter needed called consistency assumption order completion procedure sound complete generating
successor state axioms  reiter        
action domain descriptions clearly targeted specifying deterministic actions 
indeterminate effects sometimes arise cyclic domain rules  instance 
consider following action domain description 
causes p  p  
p recond a  true 
action a  init tautology  succ  empty  succ consists following pseudosuccessor state axiom p 
succ p  succ p  init p  
equivalent init p  succ p   initially p true  performed 
know p continue true  p initially false  performed 
know p true not 
example   consider blocks world description example    set fluent atoms
generated step   is 
f    on        on        on        on        on        on       
on        on        on        clear     clear     clear    
ontable     ontable     ontable     
step   generates following action instances 
stack        stack        stack        stack        stack        stack       
unstack        unstack        unstack        unstack        unstack       
unstack        move           move           move           move          
move           move         
   

fifrom causal theories strips like systems

action instances  need go steps          instance 
stack        one effect axiom on       
effect stack        true  on        
following causal rules on       
causes on        on        
causes on        on        
causes on        on        
causes on        on        
causes ontable     on        
therefore step     generates following pseudo successor state axiom on       
succ on        true
init on         succ on        succ on       
succ on        succ on       succ ontable      
similarly generate following pseudo successor state axioms primitive
fluent atoms 
succ on        init on         succ on        succ on       
succ on        succ on       succ ontable      
succ on        init on         succ on        succ on       
succ on        succ on        succ ontable      
succ on        init on         succ on        succ on       
succ on        succ on        succ ontable      
succ on        init on         succ on        succ on       
succ on       succ on        succ ontable      
succ on        init on         succ on        succ on       
succ on       succ on        succ ontable      
succ on        init on         succ on        succ on       
succ on       succ on        succ ontable      
succ on        init on         succ on        succ on       
succ on       succ on        succ ontable      
succ on        init on         succ on        succ on       
succ on       succ on        succ ontable      
succ ontable    
init ontable      succ on        succ on        succ on         
succ ontable    
init ontable      succ on        succ on        succ on         
   

filin

succ ontable    
init ontable      succ on        succ on        succ on         
complex fluent clear  definition yields following axioms 
succ clear     succ on        succ on        succ on        
succ clear     succ on        succ on        succ on        
succ clear     succ on        succ on        succ on        
solve pseudo successor state axioms generate following successor state axioms 
succ on        f alse
succ on        f alse
succ on        f alse
succ on        f alse
succ on        init on       
succ ontable     init ontable    
succ clear     init clear    
succ clear     init clear    

succ on        true
succ on        f alse
succ on        init on       
succ on        f alse
succ ontable     f alse
succ ontable     init ontable    
succ clear     f alse

set fully instantiated successor state axioms  generate
strips like descriptions following 
stack      
preconditions 
add list 
delete list 
cond  effects 
indet  effects 

ontable     clear     clear    
on       
ontable     clear    
none 
none 

stack      
preconditions 
add list 
delete list 
cond  effects 
indet  effects 

ontable     clear     clear    
on      
ontable     clear    
none 
none 

   

fifrom causal theories strips like systems

following remarks 
although generate axiom succ on        f alse stack        put
on       delete list  deduce init on        f alse
init well  fluent atom put add delete list action
fluent atoms truth value definitely changed action  see section  
details strips like description generated successor state
axioms 
one see  ccp procedure crucially depends fact type
finite domain reasoning done propositional logic 
limitation current system  limitation bad one might think 
first all  typical planning problems assume finite domains  changing
domain type action description easy   one needs change
corresponding type definition  significantly  generic action domain description
often obtained one assumes finite domain  blocks world
example  numbers         generic names  replaced
parameters  instance  replace   x   stripslike description stack        get strips like description stack x  y 
works x y  found strategy often works
planning domains 

   formal semantics
formal semantics action domain description defined translating
situation calculus causal theory lin         shall show procedure ccp given
sound semantics 
section mainly interested nonmonotonic action theories 
interested using action description language describing action
domains  section safely skipped 
first briefly review language situation calculus 
    situation calculus
language situation calculus many sorted first order language  assume
following sorts  situation situations  action actions  fluent propositional fluents 
truth value truth values true f alse  object everything else 
use following domain independent predicates functions 
binary function   action situation s  do a  s  situation
resulting performing s 
binary predicate h   p situation s  h p  s  true p holds s 
binary predicate p oss   action situation s  p oss a  s  true
possible  executable  s 
ternary predicate caused   fluent atom p  truth value v  situation
s  caused p  v  s  true fluent atom p caused  by something unspecified 
truth value v situation s 
   

filin

last section  introduced fluent formulas  extend h formulas 
fluent formula situation s  h   s  defined follows 
h t    t    s  t    t   
p static proposition  h p  s  p  
inductively  h   s  h   s   h      s  h   s  h     s   similarly
connectives 
inductively  h  x  p   s  x  p x  h   s   h  x  p   s  x  p x 
h   s   
according definition  h   s  expanded situation calculus formula
h applied fluents 
    translation situation calculus
given first order language l writing action domain descriptions  assume
corresponding language l  situation calculus constants l
constants sort object l    types l types  unary predicates  l   
static relations predicates arities l    fluents l functions
sort f luent l    actions l functions sort action l   
conventions  following translation map action domain description situation
calculus theory 
let action domain description  translation situation calculus
theory defined follows 
type definition domain p   a         ak    translated to 
 x  p x   x   a  x   ak   
a     a        ak  
primitive fluent definition
fluent f  x         xn    p   x    pn  xn   e  em  
translated
 x         xn   fluent f  x         xn    p   x    pn  xn   e  em  
complex fluent definition
complex f  x         xn    p   x    pn  x  e  em   
defined f  x         xn      
translated
 x         xn   fluent f  x         xn    p   x    pn  x  e  em  
 x         xn   s  fluent f  x         xn     h f  x         xn    s  h   s   
   

fifrom causal theories strips like systems

domain axiom static propositions 
axiom  
translated quantifiers treated shorthands 
 x  p    x p x   
 x  p    x p x   
action definition
action a x         xn    p   x    pn  xn   e  em  
translated
 x         xn   action a x         xn    p   x    pn  xn   e  em  
assume domain description one action definition
action 
action precondition axiom
p recond a x         xn     
translated
  s  action a x         xn     p oss a x         xn    s  h   s   
  
  list free variables a x         xn     mentioned earlier
one limitations current system action preconditions
given explicitly  reflected translation 
action effect axiom 
effect a x         xn      f  y         yk    
translated
  s  action a x         xn    fluent f  y         yk    p oss a x         xn    s 
  
 h   s  caused f  y         yk    true  do a x         xn    s    
  list free variables a x         xn    f  y         yk     
similarly  effect axiom
effect a x         xn      f  y         yk    
translated
  s  action a x         xn    fluent f  y         yk    p oss a x         xn    s 
  
 h   s  caused f  y         yk    f alse  do a x         xn    s    
   

filin

domain rule form
causes   f  x         xn   
translated
 
   fluent f
 x         xn     s  h   s  caused f  x         xn    true  s   
  list free variables f  x         xn     similarly  domain rule
form
causes   f  x         xn   
translated
 
   fluent f
 x         xn     s  h   s  caused f  x         xn    f alse  s   
given action domain description d  let translation situation
calculus  semantics determined completion comp t   defined
set following sentences 
   circumscription caused predicates fixed 
   following basic axioms caused says fluent atom caused
true  false   true  false  
caused p  true  s  holds p  s  

   

caused p  f alse  s  holds p  s  

   

   truth values  following unique names domain closure axiom 
true    f alse  v  v   true v   f alse  

   

   unique names assumptions fluents actions  specifically  f        fn
fluents  have 
  x     fj   y    j different 
  x      y    x    y  
similarly actions 
   primitive fluent atom f   following generic successor state axiom 
a  s p oss a  s  h f  do a  s  

   

 caused f  true  do a  s   h f  s  caused f  f alse  do a  s    
   foundational axioms  lin   reiter      b  discrete situation calculus 
axioms characterize structure space situations  purpose
paper  enough mention include following unique names
axioms situations 
   do a  s  
do a  s    do a    s     a   a    s    
   

fifrom causal theories strips like systems

following theorem shows procedural semantics given previous section
sound respect semantics given here 
theorem   let action domain description  translation situation
calculus  let ground action instance  situation variable   s  situation
calculus formula satisfies following two conditions     contains two
situation terms do a  s       mention predicate h 
equality  static relations  let obtained replacing h f  s 
init f    h f  do a  s   succ f   
comp t      s p oss a  s   s 

   

init succ succ      

   


init  succ  succ  sets axioms generated according procedure section  
proof  suppose situation model comp t    p oss a  s    construct
ms a follows 
domain ms a object domain  
interpretations non situational function predicate symbols ms a
 
fluent atom f   ms a    init f   iff    h f  s  ms a    succ f   iff
   h f  do a  s   
clearly      s  iff ms a      show ms a model left hand
side      this  see          
notice first ground fluent atom f generated procedure ccp iff fluent f  
true   notice fluent atoms init succ succ  must generated
procedure 
show first ms a model init 
   axiom   domain axiom    thus satisfies   since
fluent symbols it  ms a satisfies too 
   causes   f  x         xn    domain rule 
 
   fluent f
 x         xn     s  h   s  caused f  x         xn    true  s  
  thus satisfies
 
   fluent f
 x         xn     s  h   s  h f  x         xn    s   
thus init      init f   corresponding formula init    f
ground instantiation f  x         xn    respectively  fluent f   must
true  otherwise formula would init   satisfies
h      s  h f  s   construction ms a   satisfies init      init f   
case causes   f   similar 
   

filin

   suppose defined f    instantiation complex fluent definition
f init  init  fluent f   must true  thus must satisfy
h f  s  h   s   construction ms a   satisfies init f   init   s  
   suppose p recond a    precondition axiom a  since satisfies p oss a  s 
action a   because one action instances generated procedure  
thus satisfies h a   s   ms a satisfies init a   
show ms a model succ  is  primitive fluent atom f
generated procedure step    pseudo successor state axiom     holds  referring
notation axiom  need show satisfies following formula 
h f  do a  s   h     s  h n   s 
h      do a  s   h  l   do a  s  
h f  s   h     s  h m   s 
h      do a  s   h  k   do a  s    
first all  instantiating generic successor state axiom     s  get 
p oss a  s  h f  do a  s  
 caused f  true  do a  s   h f  s  caused f  f alse  do a  s    
since model p oss a  s  
h f  do a  s  

   

 caused f  true  do a  s   h f  s  caused f  f alse  do a  s    
consider circumscription caused predicates fixed  notice
axioms caused form w caused x  y  z   w formula
mention caused  therefore circumscription caused equivalent
predicate completion caused  suppose f f  t   axioms
caused f  x   v  s  follows 
w  caused f  x   v  s     wi caused f  x   v  s  
unique names axioms fluents  result predicate completion
caused entail 
caused f  x   v  s  w  wi  
w       wi action effect axioms domain rules f   way
    generated  noting action a   fluent f    p oss a  s  true  one
see equivalence instantiated replacing x  true v 
s  get
caused f  true  do a  s   h     s  h n   s 
h      do a  s   h  l   do a  s   
   

fifrom causal theories strips like systems

similarly  following axiom caused f  f alse  do a  s   
caused f  f alse  do a  s   h     s  h m   s 
h      do a  s   h  k   do a  s   
two axioms      get 
h f  do a  s   h     s  h n   s 
h      do a  s   h  l   do a  s  
h f  s   h     s  h m   s 
h      do a  s   h  k   do a  s    
since model comp t    satisfies formula  construction
ms a   satisfies pseudo successor state axiom     
finally  fact ms a model succ  apparent 
 
general      imply      several reasons 
mentioned procedure ccp  assume information
initial situation given init 
procedure works actions one time  situation calculus theory
captures effects actions single theory  possible bad specification action causes entire theory become inconsistent  instance 
causes true  p   p recond a  true   effect a  f alse  p   corresponding situation calculus theory inconsistent action a 
procedure  generate inconsistent theory a 

   implementation
except step      procedure ccp section   straightforward implement 
section describes strategy system uses implementing step      main
idea comes work lin      a  strongest necessary weakest sufficient
conditions 
given propositional theory   proposition q  set b propositions  formula
said sufficient condition q b consists propositions b
   q  said weakest sufficient condition sufficient
condition            similarly  formula said necessary
condition q b consists propositions b    q   said
strongest necessary condition necessary condition    
      
easy see weakest sufficient condition strongest necessary condition unique logical equivalence background theory  shown  lin 
    a  two notions closely related  computed using technique
forgetting  lin   reiter      a   particular  action theories  effective strategy first compute strongest necessary condition  add background theory 
   

filin

compute weakest sufficient condition new theory  strategy
justified following proposition lin      a  
proposition   let theory  q proposition  b set propositions 
necessary condition q b   weakest sufficient condition q b
    weakest sufficient condition q b  
describe strategy implementing step     procedure ccp 
following  given action instance a  step      let succ set pseudosuccessor state axioms primitive fluent atoms  succ  set pseudo successor state
axioms complex fluent atoms  init set initial situation axioms derived
action precondition axiom a  domain axioms  domain rules  complex fluent
definitions  following  succ proposition one form succ f   
init proposition one form init f   
   transform init clausal form derive set unit clauses u nit 
   use u nit simplify axioms succ resulting axiom it 
succ f   f  

   

f mention succ propositions  delete succ  output
replace succ f   rest axioms f  
   fluent atom f whose pseudo successor state axiom     succ  f
form init f        a candidate frame axiom   check see succ f  
derived succ  u nit  init f   unit resolution  so  delete succ 
output succ f   init f    replace succ f   succ init f   
   fluent atom f whose pseudo successor state axiom     succ  compute
strongest necessary condition f succ f   init propositions
theory init succ  weakest sufficient condition f succ f   initpropositions theory  f   init succ  f tautology  delete
    succ  output succ f   f   replace succ f   succ f  
tautology  output succ f   f f f succ f    delete    
succ  correctness step follows proposition   
   previous steps solve equations succ  generate appropriate output
primitive fluent atoms  complex fluent atom f  
defined f    
every primitive fluent atom successor state axiom  following 
 a  primitive fluent atoms changed action  complex
fluent atom changed action either  output succ f   init f   
 b  otherwise  output succ f     obtained succ   replacing
every succ proposition right side successor state axiom 
   

fifrom causal theories strips like systems

otherwise  primitive fluent atoms successor state
axiom  means action may indeterminate effect them 
action may indeterminate effect f well  compute strongest necessary weakest sufficient conditions succ f   init succ succ 
last step  output them 
   step try generate strips like description action instance
based results steps      fluent atom f   according one
following cases 
 a  successor state axiom succ f   true  put f add list unless
init f   entailed init 
 b  successor state axiom succ f   f alse  put f delete list
unless init f   entailed init 
 c  successor state axiom succ f     true  f alse 
init f    put f conditional effect list output successor state
axiom 
 d  f successor state axiom  put list indeterminate
effects 
clearly  f put lists  truth value affected a 
steps     procedure bottleneck worst case  computing
strongest necessary condition proposition conp hard  however 
experience action context free effect fluent atom f   successor
state axiom computed without going step   
implemented procedure ccp using strategy swi prolog         
url system follows 
http   www cs ust hk  flin ccp html
using system  encoded action description language many planning
domains come original release pddl  mcdermott         compiled
strips like specifications  encodings domains results returned
system included online appendix  following  illustrate
interesting features system using following two domains  blocks world
monkey bananas domain 
    blocks world
used blocks world running example  shall give alternative specification domain using following better known set actions  stack 
unstack  pickup  putdown  shall use domain show changing slightly
precondition one actions result different action specification 
   swi prolog developed jan wielemaker university amsterdam

   

filin

begin description corresponds standard strips encoding
domain 
fluent on x  y   block x  block y   
fluent ontable x   block x   
fluent holding x   block x   
complex clear x   block x  
defined clear x     y  block on y  x   holding x   
complex handempty  true  
defined handempty   x  block holding x   
causes on x  y  x    z  on z  y   
causes on x  y     z  on x  z   
causes on x  y   ontable x   
causes ontable x   on x  y   
causes on x  y   holding x   
causes on x  y   holding y   
causes holding x   ontable x   
causes holding x   on x  y   
causes holding x   on y  x   
causes holding x     x  holding y   
action stack x  y   block x  block y  x    y  
p recond stack x  y   holding x  clear y   
effect stack x  y   true  on x  y   
action unstack x  y   block x  block y  x    y  
p recond unstack x  y   clear x  on x  y  handempty  
effect unstack x  y   true  holding x   
action putdown x   block x   
p recond putdown x   holding x   
effect putdown x   true  ontable x   
action pickup x   block x   
p recond pickup x   handempty ontable x  clear x   
effect pickup x   true  holding x   
notice compared description example    two fluents  holding
handempty here  thus domain rules them  definition
clear changed take account block held  considered
clear 
   

fifrom causal theories strips like systems

assuming domain three blocks domain block              system
generate    fluent atoms     action instances  action instance  returns
complete set successor state axioms strips like representation  total
computation time actions    k inferences     seconds   pure strips
domain  i e  actions context free  type domains  mentioned earlier 
step   implementation procedure needed  step   easy 
results expected  instance  action pickup     strips like representation returned system looks following  track   track     stripslike representation looks like 
pickup    
preconditions  clear     handempty  ontable   
add list  holding   
delete list  ontable     clear     handempty
conditional effects 
indeterminate effects 
complete output given online appendix  let us consider happen
drop ontable x  precondition pickup x  
p recond pickup x   handempty clear x   
means long block clear  picked up  new precondition 
system returns following strips like representation action pickup    
pickup    
preconditions  clear     handempty
add list  holding   
delete list  clear     handempty  on        on        ontable   
conditional effects 
succ clear           init on         init on        
succ clear           init on         init on        
indeterminate effects 
  negation     disjunction  adl like description action
would something following 
pickup x  
preconditions  clear x   handempty
add list  holding x  
clear y  on x y 
delete list  clear x   handempty 
on x y  on x y 
ontable x  ontable x 
   times paper refer cpu times pentium iii  ghz machine    mb ram running
swi prolog       linux  number inferences one reported swi prolog 
roughly corresponds number resolution steps carried prolog interpreter 
machine independent 

   

filin

    monkey bananas domain
domain adapted mcdermotts pddl library planning domains 
attributes university washingtons ucpop collection action domains 
turn attributes prodigy  action effects generated system
context dependent  context free systems  shall elaborate
difference later 
domain  two types  loc locations  we assume three locations
here   object things monkey  banana  box  etc  
domain loc             
domain object   monkey  box  banana  knif e  glass  f ountain   
following fluent definitions 
fluent onf loor  
fluent at m  x   object m   loc x   
fluent hasknif e  
fluent onbox x   loc x   
fluent hasbanana  
fluent haswater  
fluent hasglass  
following domain rules fluents 
causes onbox x   at monkey  x   

    

causes onbox x   at box  x   

    

causes onbox x   onf loor  

    

causes onf loor  onbox x   

    

causes at m  x  x    y  at m     

    

causes hasglass at monkey  x   at glass  x   

    

causes hasknif e at monkey  x   at knif e  x   

    

causes hasbanana at monkey  x   at banana  x   

    

following action definitions along respective preconditions effect
axioms 
goto x  y    monkey goes x y 
action goto x     loc x  loc y   x      
p recond goto x     at monkey    onf loor  
effect goto x     true  at monkey  x   
   

fifrom causal theories strips like systems

climb x    monkey climbs onto box location x 
action climb x   loc x   
p recond climb x   at box  x  onf loor at monkey  x   
effect climb x   true  onbox x   
pushbox x      monkey pushes box x 
action pushbox x     loc x  loc y   x      
p recond pushbox x     at monkey    at box     onf loor  
effect pushbox x     true  at monkey  x   
effect pushbox x     true  at box  x   
getknif e x    get knife location x 
action getknif e x   loc x   
p recond getknif e x   at knif e  x  at monkey  x  hasknif e  
effect getknif e x   true  hasknif e  
getbanana x    grab banana loc x  provided monkey box 
action getbanana x   loc x   
p recond getbanana x   onbox x  at banana  x  hasbanana  
effect getbanana x   true  hasbanana  
pickglass x    pick glass loc x 
action pickglass x   loc x   
p recond pickglass x   at glass  x  at monkey  x  hasglass  
effect pickglass x   true  hasglass  
getwater x    get water fountain loc x  provided monkey box 
glass hand 
action getwater x   loc x   
p recond getwater x   at f ountain  x  onbox x  hasglass haswater  
effect getwater x   true  haswater  
domain    actions    fluent atoms  again  action  system
generates complete set fully instantiated successor state axioms stripslike representation  instance  action goto        following strips like
representation generated system 
   

filin

action goto      
preconditions  at monkey      onfloor
add list  at monkey    
delete list  at monkey    
conditional effects 
succ at banana          init hasbanana     init at banana     
succ at knife          init hasknife     init at knife     
succ at glass          init hasglass     init at glass     
succ at banana            init hasbanana    init at banana     
succ at knife            init hasknife    init at knife     
succ at glass            init hasglass    init at glass     
total running time actions   seconds performing    million inferences 
   percent time spent step    i e  computing strongest necessary
weakest sufficient conditions fluent atoms given action contextdependent effects  instance  action goto       above  majority time spent
generating   conditional effects 
action  actually actions domain  could use adl like
description  pednault        conditional effects 
add list  at banana    hasbanana
at knife    hasknife
at glass    hasglass
delete list  at banana    hasbanana
at knife    hasknife
at glass    hasglass
however  clear whether always done general case 
mentioned earlier specifications domain given mcdermotts collection well others context free  instance  following specification
action goto pddl mcdermotts collection 
  action go to
 parameters   x  y 
 precondition  and  location  x   location  y 
 not     y  x    on floor   at monkey  y  
 effect  and  at monkey  x   not  at monkey  y    
corresponds context free action change fluent except at 
clear design action take account domain rules             
specification  initially banana location    goal banana
location   would achievable 
   

fifrom causal theories strips like systems

    summary
domains experimented including scheduling domain includes
pednaults dictionary paycheck domain special case  rocket domain  sri
robot domain  machine shop assembling domain  ferry domain  grid domain 
sokoban domain  gear domain  included online appendix 
summarize common features domains 
domains tried  quite straightforward decide effects
action encoded direct effects  those given predicate effect 
effects indirect effects  those derived domain rules  
common domain rules functional dependency constraints  instance 
blocks world  fluent atom on x  y  functional arguments 
monkey banana domain  fluent atom at object  loc  functional
second argument  each object one location   makes sense
would special shorthand domain rules  perhaps special
procedure handling well  significantly  given prevalence
functional dependency constraints action domains  worthwhile
investigate possibility general purpose planner making good use
constraints 
mentioned earlier  system propositional  generated successor state
axioms strips like systems fully instantiated  however  often easy
user generalize propositional specifications first order ones 
shall investigate generality observation next 

   generalizing propositional strips like systems ones
parameters
mentioned  many action domain descriptions  successor state axioms
strips like systems generated specific domain generalized arbitrary ones 
precisely  let domain description 
domain p    dp       domain pk   dpk  
type specification  suppose action inita succa     
suppose d  another domain description except different
type specification 
domain p    dp         domain pk   dp  k   
question interested this  given one to one mapping type
specification d    inita  succa       true d    a   resp     
result replacing objects  resp    according mapping 
instance  true blocks world  generalize results
domain description example   follows  shown  action stack       
succ on        succ on        true  change type specification
domain block   a  b  c  d  e    map   a    c    e  new domain
   

filin

specification  action stack a  c   succ on a  c   succ on a  e  
true  furthermore  changing mapping    see x different
c  the mapping needs one to one   succ on a  x   true 
obviously  expected blocks world  proceed show
general classes domain descriptions  well  first make precise
mapping one type specification another 
definition   given two type specifications o 
domain p    dp       domain pk   dpk   
o   
domain p    dp         domain pk   dp  k   
embedding o  one to one mapping dp  dpk dp    dp  k
  k  dpi   f  a  dp   
clearly  embedding o    type p  size domain
p o  must least size domain p o  given embedding
  expression  actions  propositions  formulas  action domain description
type specification mapped    language d    one simply
replaces object  a   d  differs uses o 
type specification  notice objects  those domain type 
replaced  constants may occur effect axioms domain rules 
definition   action domain description belongs simple i class mention
function positive arity  mention complex fluents except complex fluent
definitions  satisfies following conditions 
   p recond a    action precondition definition  form
 x  p     y  q w   w fluent formula quantifiers 
   effect a    f   effect a    f   action effect axiom 
quantifiers  variables f among a  is  one
cannot something
effect explodeat x   nearby y  x   dead y   
   causes   f   causes   f   domain rule  quantifiers  variables must f  
theorem   let simple i action domain description  action instance
d  let d  except type specification  formula
mention complex fluent quantifiers  embedding
type specification d    inita succa    d 
init  a  succ  a        d   
   

fifrom causal theories strips like systems

proof  suppose init  a  succ  a        true  m  truth assignment
language d  satisfies init  a  succ  a      construct truth
assignment m  language follows  proposition p language
mention complex fluent  m     p iff m      p    p really either
static proposition  succ f   or init f    f primitive fluent atom   truth
values complex fluent atoms m  defined according definitions  clearly 
m       need show m  satisfies inita succa   inita  
three cases 
   m     init f   init   defined f    complex fluent definition 
follows construction m   
   m     init a   p recond a    precondition definition a 
assumption  form  x  p     y  q  w   w formula without
quantifiers  without loss generality  let us assume  x  p w   formula
equivalent
 
w  x a 
adp

d  dp domain type p d  m      x  p w iff
m    

 

w  x a 

adp

iff
m    

 

w  x   a   

adp

true since m      x  p w  
   formulas inita mention complex fluents quantifiers 
true m  corresponding ones true m   
succa   suppose f primitive fluent atom  pseudo successor state axiom f
constructed according procedure ccp given section   follows 
succ f   init     init n   succ      succ  l  
init f    init     init m   succ      succ  k    
following properties d 
effect axiom effect a    f   effect a    f   property
quantifier  variables f  
domain rule form causes   f   causes   f   property
quantifier  variables f  
pseudo successor state axiom  succ f    d   f    thus m     f
since m      f    proves m  model succa   thus theorem 
 

   

filin

however  examples paper belong simple i
class  two reasons  action preconditions  blocks world  mention
complex fluents  negative domain rules causes   f   may
variables f   first problem problem principle complex fluents
replaced definitions  second problem serious  leads
new type simple action theories 
definition   action domain description belongs simple ii class mention
function positive arity  mention complex fluents except complex fluent
definitions  satisfies following conditions 
   p recond a    action precondition definition  form
 x  p     y  q w   w fluent formula quantifiers 
   effect a    f   effect a    f   action effect axiom 
quantifiers  variables f among a 
   positive domain rules form causes   f   
   causes   f   domain rule  must form        
formula mention fluents   fluent atom  notice
restriction variables    
simple ii class action domain descriptions seem limited
positive domain rules  negative domain rules allowed binary  nevertheless 
still capture many context free action domains  instance  blocks world
meet and pass domains paper belong class  blocks world  notice
uses complex fluent clear action precondition definitions 
p recond stack x  y   ontable x  clear x  clear y    definitions reformulated
follows using clears definition 
p recond stack x  y  
ontable x   x    block  y    block  on x    x  on y    y    
satisfy condition p recond definition simple ii
action domain descriptions  verified formally  seems
context free action domains mcdermotts pddl library action domains  including
logistics domain  belong simple ii class 
theorem   let simple ii action domain description  action instance
d  let d  except type specification  formula
mention complex fluent quantifiers  embedding
type specification d    inita succa   
init  a  succ  a        d   
proof  suppose init  a  succ  a        true  m  truth assignment
language d  satisfies init  a  succ  a      construct truth
   

fifrom causal theories strips like systems

assignment m  language follows  proposition p language
mention complex fluent  m     p iff m      p    p really either
static proposition  succ f   or init f    f primitive fluent atom   truth
values complex fluent atoms m  defined according definitions  clearly 
m       need show m  satisfies inita succa   inita  
three cases 
   m     init f   init   defined f    complex fluent definition 
follows construction m   
   m     init a   p recond a    precondition definition a 
assumption  form  x  p     y  q  w   w formula without
quantifiers  without loss generality  let us assume  x  p   w  
formula equivalent
w  x a     w  x a n   
d  m      x  p   w iff
m     w  x a     w  x a n   
iff
m     w  x   a      w  x   a n     
true since m      x  p   w  
   formulas inita mention complex fluents quantifiers 
true m  corresponding ones true m   
succa   suppose f primitive fluent atom  since positive domain rule
form causes   f    pseudo successor state axiom f constructed according
procedure ccp given section   must following form 
succ f   init     init n  
init f    init     init m   succ      succ  k    
  k  causes  i   f   instance domain rule d 
d    effect axiom effect   f   effect   f   property
quantifier  variables f   pseudo successor
state axiom  succ f    d  must form 
succ   f    init        init   n   
init   f     init        init   m   
succ        



succ    k   

    

succ    

disjunction disjunct must causes    f   
instance d  fluent atom contains object  a   f   
two cases 
   

filin

suppose m     succ f    m     succ   f     since m  model succ  a   
m  satisfies axiom succ   f     therefore m  satisfies following
formula 
init        init   n   
init   f     init        init   m   
succ         succ    k     
since formula mention complex fluents quantifiers 
m  satisfies corresponding formula 
init     init n  

    

init f    init     init m  

succ     



succ  k    

right side equivalence pseudo successor state axiom
succ f   succa  
suppose m  satisfies       well show m  satisfies right side      
thus m     succ   f    m     succ f    two cases 
m  satisfies following formula 
init     init n   

    

case  since formula mention complex fluents
quantifier  m  satisfies following corresponding formula 
init        init   n    

    

thus m  satisfies right side      
m  satisfy      satisfies following formula 
init f    init     init m   succ      succ  k    
thus m  satisfies following formula 
init   f     init        init   m   
succ         succ    k     
show right side equivalence      satisfied m   
need show m     succ    recall disjunction
disjunct must correspond domain rule form causes    f    
form   g   mention fluents  g
fluent atom mentions object occur  a   note
init   init   f    axiom succ  a    satisfied m    thus
m     init    means either   init g  false m     
false  succ   false since succ         suppose
init g  false m    notice since positive domain rules 
   

fifrom causal theories strips like systems

g object  a   f    pseudo successor state axiom
g succ  a  must form succ g  init g    therefore
m     init g  get m     succ    since disjunct  
proved m     succ    therefore m     succ   f     thus m     succ f   
 

   related work
planning  closely related work causal reasoning module wilkinss sipe
system  wilkins         wilkins writes  page     wilkins         use strips
assumptions made operators unacceptably difficult describe previous classical
planners    one primary reasons effects action must explicitly stated    deductive causal theories one important mechanisms used
sipe alleviate problems operator representation caused strips assumption  certainly one motivations system well  sipe  domain rules
triggers  preconditions  conditions  effects  informally  triggers become
true new situation  sipe would check sequence see preconditions
true old situation  conditions true new situation 
conditions true  deduce effects  instance  sipe causal rule
on x  y  blocks world would look like 
causal rule  not on
arguments  x  y  z 
trigger  on x y  
precondition  on x z  
effects  on x z  
comparison  domain rules much simpler  instance  corresponding rule
sipe rule simply  causes on x  y     z  on x  z    need
procedural directives triggers  large degree  see system rational
reconstruction causal reasoning module sipe  shown theorem   
procedure used system sound translation causal theories
situation calculus  wilkins gave translation causal rules formulas
situation calculus  specify underlying logic reason formulas 
fact  shown lin         translations would work 
familiar pddl  original version mcdermott aips   
planning competition committee allows domain axioms stratified theories  according
manual pddl      mcdermott         axioms logical formulas assert
relationships among propositions hold within situation  format writing
axioms pddl follows 
  axiom
 vars   x  y     
 context w
 implies p 
   

filin

w formula p literal  axioms treated directionally  w p  
following rule intention using axioms according manual 
rule action definitions allowed effects mention
predicates occur  implies field axiom  intention
action definitions mention primitive predicates on  changes
truth value derived predicates occur axioms  without
axioms  action definitions describe changes predicates
might affected action  leads complex software engineering
 or domain engineering  problem 
clear quotation axioms pddl intended defining derived
predicates  similar complex fluent definitions  new versions pddl
extended original version allowing actions durations continuous changes 
considered using axioms derive changes primitive predicates
done domain rules 
action domain description language  different syntax
strongly influenced prolog syntax  shares much ideas behind action languages
 gelfond   lifschitz         however  unlike action languages  provide facilities expressing truth value fluent atom particular situation initial
situation  rather  aimed specifying generic effects actions  hand 
facilities specifying types static relations  importantly  date  action
languages either implemented directly mapped nonmonotonic logic programming
system rather compilation monotonic system action effects given
explicitly  done here  instance  new sat based planning method would
implemented  e g  mccain   turner        action languages  comparison 
action domain description compiled strips like description  existing planning
systems blackbox  selman   kautz        system r  lin      b  directly
called 

   concluding remarks
described system generating effects actions direct action effect
axioms domain rules  among things  shown soundness procedure used system tested successfully many benchmark action domains used
current ai planners  future work  considering generalize simple
action theories section   include context dependent action domain descriptions
monkey bananas domain 

acknowledgments
extended abstract part paper appeared proceedings aaai       would
thank anonymous reviewers jair aaai     well associate
editor charge paper jair insightful comments earlier versions
paper  work supported part research grants council hong kong
competitive earmarked research grant hkust       e 
   

fifrom causal theories strips like systems

references
baral  c          reasoning actions  nondeterministic effects  constraints  qualification  proceedings fourteenth international joint conference artificial
intelligence  ijcai     ijcai inc  distributed morgan kaufmann  san mateo 
ca   pp           
fikes  r  e     nilsson  n  j          strips  new approach theorem proving
problem solving  artificial intelligence            
fox  m     long  d          automatic inference state invariants tim  journal
artificial intelligence research            
gelfond  m     lifschitz  v          action languages  electronic transactions artificial
intelligence  http   www ep liu se ea cis  vol    nr     
gerevini  a     schubert  l          inferring state constraints domain independent
planning  proceedings   th national conference artificial intelligence
 aaai     aaai press  menlo park  ca 
levesque  h   reiter  r   lesperance  y   lin  f     scherl  r          golog  logic
programming language dynamic domains  journal logic programming  special
issue reasoning action change           
lifschitz  v          logic causal explanation  artificial intelligence             
lin  f          embracing causality specifying indirect effects actions  proceedings fourteenth international joint conference artificial intelligence
 ijcai     ijcai inc  distributed morgan kaufmann  san mateo  ca   pp      
     
lin  f          embracing causality specifying indeterminate effects actions 
proceedings   th national conference artificial intelligence  aaai    
aaai press  menlo park  ca   pp         
lin  f       a   strongest necessary weakest sufficient conditions  artificial intelligence                   
lin  f       b   planner called r  ai magazine              
lin  f     reiter  r       a   forget it   greiner  r     subramanian  d   eds   
working notes aaai fall symposium relevance  pp          american association artificial intelligence  menlo park  ca  available
http   www cs toronto edu cogrobo forgetting ps z 
lin  f     reiter  r       b   state constraints revisited  journal logic computation 
special issue actions processes               
mccain  n     turner  h          causal theory ramifications qualifications 
proceedings fourteenth international joint conference artificial intelligence
 ijcai     ijcai inc  distributed morgan kaufmann  san mateo  ca   pp      
     
mccain  n     turner  h          causal theories action change  proceedings
  th national conference artificial intelligence  aaai     aaai press 
menlo park  ca   pp         
   

filin

mccain  n     turner  h          satisfiability planning causal theories  proceedings
sixth international conference principles knowledge representation
reasoning  kr     pp         
mcdermott  d          pddl planning domain definition language  tech  rep  tr       dcs tr       yale center computational vision control 
pednault  e  p          adl  exploring middle ground strips situation calculus  proceedings first international conference principles
knowledge representation reasoning  kr     pp          morgan kaufmann
publishers  inc 
reiter  r          frame problem situation calculus  simple solution  sometimes  completeness result goal regression  lifschitz  v   ed    artificial
intelligence mathematical theory computation  papers honor john mccarthy  pp          academic press  san diego  ca 
selman  b     kautz  h          unifying sat based graph based planning  proceedings sixteenth international joint conference artificial intelligence  ijcai
     ijcai inc  distributed morgan kaufmann  san mateo  ca   pp         
thielscher  m          computing ramification post processing  proceedings
fourteenth international joint conference artificial intelligence  ijcai     ijcai inc  distributed morgan kaufmann  san mateo  ca   pp           
thielscher  m          ramification causality  artificial intelligence             
wilkins  d          practical planning  extending classical ai planning paradigm  morgan kaufmann  san mateo  ca 
zhang  y     foo  n          deriving invariants constraints action theories 
fundamenta informaticae                

   


