journal artificial intelligence research                  

submitted        published      

architectural approach
ensuring consistency hierarchical execution
robert e  wray

wrayre acm org

soar technology  inc        green court  suite    
ann arbor  mi       usa

john e  laird

laird umich edu

university michigan       beal avenue
ann arbor  mi       usa

abstract
hierarchical task decomposition method used many agent systems organize
agent knowledge  work shows combination hierarchy persistent
assertions knowledge lead difficulty maintaining logical consistency asserted
knowledge  explore problematic consequences persistent assumptions
reasoning process introduce novel potential solutions  implemented one
possible solutions  dynamic hierarchical justification  effectiveness demonstrated
empirical analysis 

   introduction
process executing task dividing series hierarchically organized subtasks called hierarchical task decomposition  hierarchical task decomposition
used large number agent systems  including adaptive intelligent systems architecture  hayes roth         atlantis  gat      a   cypress  wilkins et al         
entropy reduction engine  bresina  drummond    kedar         procedural reasoning system  georgeff   lansky         raps  firby         soar  laird  newell   
rosenbloom        laird   rosenbloom         theo  mitchell        mitchell et al  
       cornerstone belief desire intention based agent implementations  rao  
georgeff        wooldridge         hierarchical task decomposition helps agents
knowledge developer agent manage environmental complexity  example 
agent may consider high level tasks find power source fly miami
independent low level subtasks go east    meters turn heading     
low level tasks chosen dynamically based currently active high level
tasks current situation  thus high level task progressively decomposed
smaller subtasks  division labor simplifies design agents  thus reducing
cost  additional advantages hierarchical task decomposition include knowledge sharing
 a low level subtask invoked many different high level procedures   modularity
 the decomposition helps insulate subtasks interaction knowledge 
naturalness representation  simon        
without careful design  difficult ensure consistent reasoning agents employing hierarchical task decompositions  consistency  mean reasoning
lead set assertions contains contradiction  ensuring consistency becomes
c      ai access foundation morgan kaufmann publishers  rights reserved 

fiwray   laird

much difficult solve thus costly complexity agents
knowledge grows  although problem solved careful design agent
knowledge  approach requires understanding possible interactions
hierarchy  thus  correctness solution depends skill vigilance
knowledge engineer  bias seek solutions operation agents primitive memories processes structured ensure inconsistencies arise  thus 
prefer architectural solutions knowledge based ones  architectural solutions
guarantee consistency tasks domains  reducing brittleness due omissions
task knowledge  further  developing architectural solution may costly 
less costly repeatedly developing knowledge based solutions different domains 
following sections describe inconsistency problem introduce space
solutions problem  including two novel solutions  theoretical
empirical analysis  one new solutions  dynamic hierarchical justification  shown
provide efficient architectural solution problem ensuring reasoning consistency
hierarchical execution 

   maintaining reasoning consistency hierarchical agents
section describes inconsistency problem greater detail  review methods
ensuring consistency non hierarchical systems discuss limitations
approaches hierarchical systems 
    consistency non hierarchical systems
truth maintenance systems  tmss  often used maintain consistency non hierarchical systems  doyle        mcdermott        forbus   dekleer         inference engine
uses domain knowledge create two different kinds assertions knowledge agents
knowledge base  assumptions entailments  inference engine enables assumptions
decided treat true  without requiring assertion justified  agents often treat environmental percepts assumptions unquestioned beliefs
 shoham         entailments justified assertions  data structure  justification 
captures reasons asserting entailment  reasons longer hold  the
entailment longer justified   tms retracts set asserted beliefs  thus 
tms automatically manages assertion retraction entailments agents
situation changes  ensuring entailments consistent external environment
enabled assumptions 
careful construction domain knowledge required ensure enabled
assumptions contradictory  example  assumption inconsistent
current input  agent must domain knowledge recognizes situation
removes assumption  thus  agent utilizes tms  problem maintaining
consistency reasoning largely one managing assumptions agents domain
knowledge 
assumptions often reflect hypothetical reasoning world  hence assumptions   however  assumptions used represent persistent feature  although
researchers explored structuring external environment provide persistent memory  agre   horswill         internal  persistent memory usually necessary agent
   

fiensuring consistency hierarchical execution

assumptions
entailments
assumptions
entailments
assumptions

inference
engine

entailments
assumptions

tms

entailments
assumptions
entailments
assumptions
entailments
assumptions
entailments

memory
hierarchy maintenance

figure    hierarchical agent 
domains  example  persistence required hypothetical reasoning  nonmonotonic
revisions assertions  such counting   remembering 
    truth maintenance hierarchical agents
tms agent framework introduced extended hierarchical agent architectures  agent  inference engine tms less identical
non hierarchical agent  agent initiates new subtask via dynamic hierarchical
task decomposition  creates new database contain assumptions entailments specific subtask  decomposition result stack subtasks 
containing entailments assumptions specific subtask  shown figure   
consider creation deletion distinct databases assertions sine qua non
hierarchical architecture  architecture decomposes task identifying
relevant subtasks  dynamically organizing memory according current
decomposition 
new system component  hierarchy maintenance  responsible creating
destroying subtask databases subtasks begin terminate  subtask
achieved  or determined longer worth pursuing   hierarchy maintenance responds
immediately removing assertions associated subtask  function
central importance hierarchical architectures allows agent automatically
retract assertions associated terminated subtask  requiring agent knowledge
clean remove individual assertions associated terminated subtask 
hierarchy maintenance component efficiently remove assertions
 conceptually  located distinct unit  subtask database 
   

fiwray   laird

subtask 

a  
e  

a  

a  
a  

a  

subtask 
e  
e  
e  
e  
e  
e  
e  
a  
e  a   a  
a  
a  

e  

e  

 a    a    e    e   
psfrag replacements

subtask 

a  

e  

a  
a  

e  

e  

 a    a    e   

hierarchy maintenance

figure    example hierarchy maintenance  assumptions  a  entailments  e 
asserted within subtasks 

agents hierarchy maintenance function employed help maintain consistency  illustrated notionally figure    agent architecture identifies assertions
higher levels hierarchy led new subtask  assertions together
form subtask support set  figure    assertions      a     e     e   form support
set subtask  a     a     e   support subtask    support sets  effect  form
justifications subtasks hierarchy  assertion support set removed
 e g   a      agent responds removing subtask  subtask      hierarchical architectures use architectural processes create destroy subtask databases 
example illustrates architectural hierarchical maintenance function realized
via process similar justification truth maintenance 
within specific subtask  reason maintenance go before  however  hierarchical structure adds complication maintenance logical consistency  assumptions
level hierarchy dependent entailments assumptions higher
levels hierarchy   dependence relationship suggested figure   curved
lines extending one subtask one it  higher levels hierarchy form
context reasoning local subtask 
execution agents embedded dynamic domains  hierarchical context may
change almost time  changing context problematic entailments 
   assumptions lower level subtask always least indirectly dependent higher level assertions  observation exploited section     

   

fiensuring consistency hierarchical execution

tms readily determine dependent context changes retract affected entailments 
however  changes higher levels hierarchy  such deriving inputs 
may invalidate assumptions lower levels  without additional architectural
mechanisms  domain knowledge required ensure consistency among assumptions
hierarchical context non hierarchical systems  domain knowledge ensuring consistency assumptions complicated necessity spanning multiple
 possibly many  subtasks  refer knowledge across level consistency knowledge  described detail below  identifying creating across level consistency
knowledge tedious  costly  often incomplete process  across level knowledge must
explicitly consider interactions different subtasks  in different levels hierarchy   rather focus solely local subtask  compromising benefit
hierarchical decomposition 
continuing  note hierarchical architectures contrasted
hierarchical task network  htn  planners  sacerdoti        erol  hendler    nau       
execution oriented systems use htn representations  decaf  graham
  decker        retsina  sycara  decker  pannu  williamson    zeng        
planning problem htn planner represented initial task network
consist primitive non primitive tasks  planner uses operators find plan
solve tasks  methods allow planner match non primitive tasks
task networks describe accomplish task  thus  methods enable hierarchical
decomposition planning problem family connected task networks 
main difference htn systems hierarchical architectures
planner represents plan single global state  is  methods represent decomposition steps  hierarchical structure evolving plan represented blackboardlike database reflect structure decomposition  following
sections discuss problems especially solutions depend hierarchical organization asserted knowledge execution  addition hierarchical task decomposition encoded agents task knowledge  thus  following generally
applicable htn based execution systems  however  htn systems need address
inconsistency problem  section       examines consequences global state respect
inconsistency arising persistence hierarchy 
    failing respond relevant changes hierarchical context
mentioned introduction  agent fails respond relevant change
hierarchical context leaves now inconsistent assumption enabled  resulting
behavior become irrational  is  consistent knowledge  section
explores irrational behavior arise several illustrative examples 
      blocks world
use variant blocks world illustrate inconsistency problem domain
familiar readers  domain execution domain rather planning
domain  call dynamic blocks world reflect difference static
blocks world used planning  assume agent knowledge build ordered
   

fiwray   laird

goal                 table 
agent memory
put on table   
put on table   
put down   

agent memory
put on table   
put on table   
put down   

agent memory
put on table   
put on table   
put down   

empty
space

empty
space

empty
space

 
 
 

 
 
 

actual world state

 

 
 

time

 

 
 
 

ent
l ev  

n
r
exte ks
c
kno

actual world state

time

 
   

   

actual world state

figure    failing respond relevant changes hierarchical context dynamic
blocks world 

tower    on   on    without resorting planning uses hierarchical task decomposition
determine actions take builds tower 
figure    agent placing block   table  order reach block  
begin goal tower  put down subtask finds empty location table 
agent places empty assertion memory associated put down subtask 
figure  space immediately left gripper chosen  whether
space empty may directly observable may need inferred number
facts domain stored assumption memory  assume empty
assertion assumption  now  assume block   suddenly placed underneath block   
result inconsistency assumption  the location good place put
block    hierarchical context  the location longer good place put
block table  
agent fails recognize block   moved  attempt put block  
location occupied block    behavior irrational  consistent
agents goals knowledge  assuming agent knowledge indicates
blocks placed positions already occupied blocks   inconsistency arises agent failed recognize previously derived assumption
 empty  longer true current situation 
although example may appear contrived  specific situation arose experimental system developed explore architecture learning issues  course  possible
simple domain reformulate task problem occur 
reformulation task via changes additions knowledge exactly solution
wish avoid  is  desire architecture guarantee consistency
hierarchical context local assumptions architecture provides priori
constraints  guidance  knowledge development process increased robustness
execution  via consistency   conclusion returns example describe
   

fiensuring consistency hierarchical execution

patrol
intercept
attack defensive 
achieveproximity
turntoheading

figure    decomposition behavior subtasks 
architectural solution inconsistency problem solves particular problem without
requiring reformulation agents task knowledge 
      tacair soar
tacair soar agents pilot virtual military aircraft complex  real time computer simulation tactical combat  tambe et al         jones et al          tacair soar domain
indirectly accessible  each agent uses simulated aircraft sensor models perceive
pilot real aircraft would sense   nondeterministic  from point view
agent  behavior agents cannot strictly predicted anticipated   nonepisodic  the decisions agent makes early simulation impact later options
capabilities   dynamic  the world changes real time agent reasoning  
continuous  individual inputs continuous values   domains characteristics
difficult ones create apply agents  russell   norvig        
domain knowledge tacair soar agents organized     subtasks 
execution  resulting hierarchical task decomposition sometimes reaches depths greater
   subtasks  agent one several different mission roles  among
flying patrol mission  acting partner wing agents lead 
consider pair planes patrol  given specific instructions
engaging enemy aircraft  enemy aircraft enter patrol area  lead agent decides
intercept aircraft  lead decomposes intercept series situationdependent subtasks  may decomposed  example  figure  
shows complex task intercepting enemy aircraft decomposed
decision turn agents aircraft specific heading  agent turns heading
order get close enough enemy agent  via achieve proximity  launch
attack 
assume three different kinds attack chosen intercept  first tactic
 scare  engage attempt scare away enemy planes without using deadly force 
tactic selected rules engagement specify deadly force
used  regardless number aircraft area  one remaining two tactics
chosen deadly force allowed  offensive attack appropriate friendly
patrol
intercept
count  enemy 

patrol
intercept
count friendly 

patrol
intercept
attack defensive 
achieveproximity
turntoheading

figure    trace behavior leading intercept tactic tacair soar 
   

fiwray   laird

figure    inconsistency due persistence 

planes outnumber equal enemy planes  defensive attack used enemy planes
outnumber friendly planes 
choosing offensive defensive attack requires counting current aircraft
area  figure   shows evolution executing example decomposition 
agent must count relevant enemy friendly planes  determining planes side
relevance count often requires remembering sufficiently complex entailment count possible  instance  non combatant aircraft
counted  requiring reasoning type aircraft  agent determines
enemy planes outnumber friendly ones  agent selects defensive attack  leading
decomposition 
happens enemy plane flees  thus reducing actual count relevant enemy planes one  count maintained agent invalid  standard tms
mechanisms insufficient count asserted assumption  actual
number enemy friendly planes equal  agent switch tactic offensive attack  continuing defensive attack consistent agents
knowledge  additionally  friendly agents participating attack may base
behavior expectation agent pursuing offensive attack  thus agent
needs recognize inconsistency remove current count 
figure   presents conceptual illustration problem  assumptions represented
squares  entailments circles  horizontal line represents hierarchical relationship
assertions  i e   assumptions entailments  hierarchical context  above
line  assertions local subtask  below line   arrowed lines represent
dependence creation assertion  previous examples  reasoning
subtask may require persistence  leading creation assumption
assumption    however  persistent assertion may still depend assertions 
work focuses dependent assertions higher level context  a  b  c  d 
e  figure 
suppose world changes e  retracted memory e  asserted 
assumption   remains memory  e   would lead    e g   could lead
new assumption    shown     longer justified may consistent
higher level context  whether potential inconsistency among assertions
leads inconsistent behavior depends use assumption   later reasoning 
   

fiensuring consistency hierarchical execution

   solutions
goal develop architectural solutions allow agent support persistent
assumptions simultaneously avoid inconsistencies across hierarchical context
lead irrational behavior  introducing two new architectural solutions  however 
examine knowledge based approaches consequences order provide
rationale architectural approach 
    knowledge based solutions
inconsistency avoided hierarchical agents creating domain knowledge
recognizes potential inconsistencies responds removing assumptions  many planning agent systems use explicit domain knowledge represent knowledge
interactions among assertions world  example  entropy reduction engine
 ere   bresina et al         one agent system relies knowledge based assumption consistency  kbac   ere requires domain constraints  knowledge describes
physics task domain  domain constraints identify impossible conditions 
instance  domain constraint would indicate robot cannot occupy two different
physical locations simultaneously 
ere  domain constraints specifically used maintain consistency current
world model state execution  bresina et al         pp        however  many
architectures use kbac well  perhaps conjunction methods   kbac
knowledge viewed simply domain knowledge must added system
achieve consistent behavior 
kbac always necessary maintain consistency among assumptions within
level hierarchy  however  order guarantee consistency assumptions distributed throughout hierarchy  possible interactions leading inconsistency must
identified throughout hierarchy  knowledge engineering problem add significant cost agent development  knowledge designer must specify conditions
assumption asserted conditions must
removed  tacair soar interception example  enemy plane flees  agent
requires knowledge disables assumptions depend upon number enemy
airplanes  similarly  dynamic blocks world  agent must knowledge
recognizes situation  subtask  cause disabling empty 
cases  kbac knowledge crosses levels hierarchy  complete kbac solution
requires agents knowledge capture potential dependencies assumptions
local subtask higher levels hierarchy 
although possible encode complete across level consistency knowledge
simple domains  experience tacair soar complex agent systems convinced
us kbac requires significant investments time energy  further 
often possible enumerate conditions assumption must removed 
agents brittle  failing difficult to understand  difficult to duplicate ways 
insufficiency knowledge based solutions led us consider architectural solutions
problem  architectural solutions eliminate need domain knowledge encoded
address inconsistency hierarchical context assumptions within
subtask  thus  cost developing individual agents reduced  addition
   

fiwray   laird

generality  definition  architectural solutions complete  thus able
guarantee consistency hierarchical context assumptions within subtask 
times  agent task  completeness improve robustness agent
systems  especially situations explicitly anticipated designers 
    assumption justification
one potential architectural solution inconsistency problem justify assumption hierarchy respect assertions higher levels hierarchy  assumption
justification extension truth maintenance approaches consistency outlined
previously  assumption hierarchy treated entailment
respect dependent assertions higher hierarchy  new data structure  assumption justification  created captures reasons hierarchical context
particular assumption  locally  assumption treated exactly assumption
non hierarchical system  however  assumption justification longer supported
 indicating change dependent hierarchical context   architecture retracts
assumption 
refer figure    agent asserts      architecture builds assumption justification assumption includes    a     agent retracts
a     assumption justification    longer supported architecture
retracts a     architecture ensures reasoning consistency across hierarchy levels
assumption persists longer context assertions led creation 
assumption justification solves inconsistency problem dependencies
hierarchical context captured justification  within subtask  domain knowledge still required ensure consistency among enabled assumptions subtask 
however  across level consistency knowledge needed  assumption justification still
supports local nonmonotonic hypothetical reasoning  thus  assumption justification
appears meet functional evaluation criteria  however  order assess impact
performance  implementation details must considered 
      implementing assumption justification
creating assumption justifications requires computing context dependencies assumption  similar computation justifications entailments    figure   outlines
procedure computing assumption justification data structure  procedure
invoked assertion created  procedure creates assumption justifications
every assertion local subtask  is  entailments well assumptions  approach allows architecture cache context dependencies local assertion 
advantage caching architecture simply concatenate assumption
justifications local assertions contributing directly creation assumption
   assumption justification procedure  presented  requires inference engine record justification every assertion course processing  soar  architecture assumption
justification implemented  calculations available production rule matcher
assumptions entailments  however  justification calculations assumptions may supported
architectures  requiring modifications underlying inference engine  laird rosenbloom
       soar users manual  laird  congdon    coulter        describe specific mechanisms
justification creation soar 

   

fiensuring consistency hierarchical execution

proc create new assertion       
assumption justification computed new assertion
created  thus  assumption justifications computed
assumptions entailments 
   
ajust create justif ication       
justifications created via well known  textbook algorithms
 e g   forbus   dekleer        russell   norvig       
aaj make assumption justif ication f assertion a 
   
end
proc make assumption justif ication f assertion assertion a 
aj nil
assertion j ajust   justification

 
 level j  closer root level a  
aj append j  aj   add j assumption justification 

 
else
 j level 
aj concatenate jaj   aj   add assumption justification j
assumption justification a 
return aj  list assertions comprising assumption justification
end
proc level assertion a 
return subtask level associated assertion
figure    procedure building assumption justifications 
 in
    chose caching option computing assumption justifications ondemand implementation would  assumption created  recursively follow
local dependencies context dependencies determined  advantage
caching implementation context dependencies assertion must computed once  even local assertion contributes creation multiple local
assumptions 
procedure creates assumption justification loops assertions
justification new assertion a  assertions justification either context
local assertions  context assertions 
   added assumption justification directly 
however  local assertions added assumption justification
assumption justification include context dependencies  example  architecture retract local assertion reasons change hierarchical
context  e g   non monotonic reasoning step change enabled assumptions
subtask  cases  agent necessarily retract dependent assumptions 
assumption justifications local assertions justification already
computed  i e   cached  described above   assumption justification
   

fiwray   laird

b c e

b c e

psfrag replacements

 a 

  

 b 

 

figure    technical problems assumption justification   a   assumption replaces
another assumption nonmonotonically   b   multiple assumption justifications
assumption must supported 

local assertion j simply added assumption justification a 
  
on demand implementation  procedure would recur local assertions 
context dependencies local assertions contributing identified 
worst case computational complexity algorithm polynomial number
assertions subtask  addition higher level assertion done constanttime  a single pointer reference   however 
  must uniquely add context assertions
assumption justification local assertion   n    local assumption
justifications whenever nth assertion created  thus  concatenation needs
performed  n   times call assumption justification procedure 
limit provides upper bound o n  complexity assumption justification
procedure  worst case cost building individual assumption justification linear
number assertions  n  level  however  architecture executes assumption
justification procedure every assertion level  thus  worst case cost building
justifications particular level o               n  o n     
non monotonic changes complicate implementation  architecture must disable
replaced assumption  rather delete it  initial assumption may need
restored  example  figure    a   assume assertion e leads
assertion   local subtask retraction    i e     revision    
agent retracts e  assumption justification retract    desired  must
re enable    thus  assumption   must remain available memory  although disabled 
figure    b  illustrates second problem  assumption multiple assumption justifications  justifications change reasoning progresses  assumption  
initially depends assertions a  b  c higher levels  assume later
processing  agent removes a  normally would result retraction   
however  meantime  context changed   justified  c 
d  e   agent removes a  architecture immediately retract  
must determine   justified sources 
implementation assumption justification soar completed members
soar research group university michigan  experiments using air soar  flight
simulator domain  pearson et al          showed overhead maintaining prior
assumptions level produced significant negative impact agent performance 
domain  assumption justification incurred significant computational cost  requiring
   

fiensuring consistency hierarchical execution

least      time original air soar agent  further  number assumption
justifications maintained within level continued grow execution  reasons
explained above  subtasks required minutes execute aircraft performed
maneuver  leading large  and problematic  increases amount memory required 
thus  assumption justification failed meet efficiency requirements theoretical
empirical grounds  although limitations assumption justification might improved developing solutions technical problems  abandoned exploration
approach strongly discouraging results 
    dynamic hierarchical justification
figure   introduced notion support set subtasks  procedural reasoning
system  prs   georgeff   lansky        soar  laird et al         use architectural
mechanisms retract complete levels subtask hierarchy support set longer
holds  section  consider solution leverages hierarchy maintenance
function ensure consistency assumptions higher level context 
significant disadvantage support set existing systems fixed 
soar  support set computed initiation subtask updated
reflect reasoning occurs within subtask  example  figure    suppose
assumption a   depends assumptions a   a    represented dashed  arrowed
lines   support set include      assertion may even present
subtask  created  local assumption depends assertion
support set  change assertion directly lead retraction
assumption  or subtask   thus  approaches using fixed hierarchical justification
 fhj  still require knowledge based solutions consistency  fhj discussed
section       
propose novel solution  dynamic hierarchical justification  dhj   similar
fixed hierarchical justification  dynamically updates support set reasoning
progresses  assumption justifications individual assumptions unnecessary  however 
one consequence simplification subtask  and assertions within it 
retracted dependent context changes  refer figure    dhj agent
asserts a   figure    architecture updates support set subtask   include a    
assumption a   already member support set need added again 
member support set subtask   changes  architecture retracts entire
subtask  thus dynamic hierarchical justification enforces reasoning consistency across
hierarchy subtask persists long dependent context assertions 
      implementing dynamic hierarchical justification
figure   outlines procedure computing support set dhj  assumption
justification  architecture directly add context assertions support set
  
architecture computes dependencies local assertion
   assertion
marked inspected
   inspected assertions simply ignored
future
   architecture already added assertions dependencies
support set  architecture ignore dependent  local assumptions
 
dependencies assumptions already added support set 
   

fiwray   laird

proc create new assertion       
whenever new assumption asserted  support set updated
include additional context dependencies 
   
ajust create justif ication       
assumption
subtask asserted
ssupport set append ssupport set   add dependencies support set a  
   
end
proc add dependencies support set assertion a 
assertion j ajust   justification

 
 level j  closer root level a  
append j  s   append context dependency support set 

 


 

 

elseif  level j  level a 
j assumption
j previously inspected  
append s  add dependencies support set j  
 compute support set dependencies j add s 
jinspected true
 js context dependencies added support set 

return s  list new dependencies support set
end
proc level assertion a 
return subtask level associated assertion
figure    procedure dynamic hierarchical justification 
dhj needs inspect local assertion once  context dependencies
computed on demand  rather cached assumption justification  condition
 
true whenever local entailment whose context dependencies yet
computed  dependencies determined calling add dependencies support set
recursively  recursive instantiations add dependencies support set receive local
assertion justification uninspected entailment  j  return list comprising
context dependencies j  return value appended support set
prior instantiation add dependencies support set 
recursive call add dependencies support set
  non constant time
operation procedure  must made assertion j thus
worst case complexity compute dependencies linear number assertions
level  assumption justification  however  dhj requires single inspection
individual assertion  rather repeated inspections new assumption as   

fiensuring consistency hierarchical execution

sumption justification  thus architecture needs call add dependencies support set n times subtask consisting n assertions  worst case cost
updating support set level remains o n   reduction complexity potentially makes dynamic hierarchical justification efficient solution assumption
justification  especially number local assertions increases 
additionally  two technical problems outlined assumption justification
impact dhj  dhj never needs restore previous assumption  dependency
changes  architecture retracts entire level  thus  dhj immediately delete
replaced assumptions memory  dhj collects dependencies assumptions 
need switch one justification another  figure    b   dependencies
a  b  c  d  e added support set  simplifications make
support set overly specific reduce memory computation overhead required
dynamic hierarchical justification 
dhj retractions sometimes followed regeneration subtask
re assertion reasoning retracted  example  enemy plane fled
described tacair soar scenario  dhj would retract entire level associated
counting subtask  count would need re started beginning 
section       examines potential problems introduced interruption regeneration 
cost incurred regeneration previously derived assertions primary
drawback dynamic hierarchical justification 
    implications dynamic hierarchical justification
dynamic hierarchical justification solves specific problem maintaining reasoning
consistency hierarchy  guaranteeing consistency utilizing efficient algorithm 
heuristic dhj employs assumes assumptions closely associated
subtasks retracting subtasks nearly equivalent retracting individual assumptions 
section explores implications heuristic  focusing task decompositions 
impact agents ability use persistent assumptions  feasibility interrupting
agent  with subtask retraction  midst reasoning 
      influence task decomposition
agents reasoning viewed knowledge search  newell         perspective  inconsistency problem failure backtrack knowledge search  world
changes  leading changes agent hierarchy  agent must retract
knowledge previously asserted  backtrack knowledge state consistent
world state   solution described terms way achieves  or
avoids  backtracking knowledge search  instance  kbac leads knowledge based
backtracking  kbac knowledge tells agent correct assumptions
given current situation 
   obviously  world state usually different agents initial state often impossible
return prior state execution system  use backtrack section refer
retraction asserted execution knowledge remaining asserted knowledge consistent
currently perceived world state 

   

fiwray   laird

b c e f g h

 a 

 

b c e
 b 

 

 

 

figure     examples  a  disjoint dependencies  b  intersecting assumption dependencies 

assumption justification form dependency directed backtracking  stallman  
sussman         dependency directed backtracking  regardless chronological order
architecture makes assertions  architecture identify retract
assertions contributed failure search retain assertions  assumption justification  architecture retracts assumptions directly affected
change context  assumptions created later processing  dependent
change  unaffected  consider examples figure      a   assumptions
    depend upon disjoint sets assertions  assumption justification  removal assertion  s assumption justification result retraction     
unchanged  even architecture asserted     
dynamic hierarchical justification similar backjumping  gaschnig         backjumping heuristically determines state current search backtrack
backjump  heuristics used backjumping based syntactic features
problem  instance  constraint satisfaction problems  backjumping algorithm
identifies variable assignments related variable assignments via constraints specified problem definition  violation discovered  algorithm
backtracks recent  related variable  dechter         intervening variable assignments discarded  dhj  assertion hierarchy changes  system
backjumps knowledge search highest subtask hierarchy dependent
change  figure     a  dependent assertions collected support set
subtask  higher level assertions change  entire subtask removed 
using dhj  backjumping  previous knowledge search may need
repeated backtracking  assume removal subtask figure     a 
due change a  similar subtask reinitiated  assumption   may need
regenerated  regeneration unnecessary   need retracted
avoid inconsistency  dynamic hierarchical justification  agent retracts
reasoning dependent subtask  and lower levels hierarchy   assertions
dependent change context removed  thus  backjumping  dhj
uses syntactic feature reasoning  decomposition subtasks  choose backtracking
point backtracking always conservative possible 
although subtask decomposition syntactic feature knowledge search 
strongly principled one  reflecting semantic analysis task knowledge designer  hierarchical task decomposition based premise tasks broken
discrete units little interaction units  nearly decom   

fiensuring consistency hierarchical execution

posable  simon         thus  goal hierarchical decomposition separate mostly
independent subtasks one another  consequence separation dependencies higher levels limited much possible  interaction subtasks
minimized  dependencies among assertions particular subtask
shared  otherwise  subtask could subdivided two independent subtasks  
course  often possible decompose given task many different ways 
cases domain imposes minimal constraint knowledge engineer significant
latitude crafting task decomposition 
situation illustrated figure      b  would complete decomposition
task knowledge engineer  a   assuming two alternatives represent
decomposition task   b   number dependent assertions necessarily grow function number assumptions local level   a 
does  further   a   two independent assumptions pursued  assumptions
could potentially inferred separate subtasks alternate decomposition   b  
hand  assumptions subtask closely tied together terms
dependencies thus better asserted within subtask  dependencies assumptions     considerable overlap  b   assumption justification
pays high overhead cost track individual assumptions  most  everything
local subtask would removed simultaneously assertions b  c  changed  dhj incurs overhead  dhj better choice intersection
assumption dependencies high  task knowledge structured situation
 b   rather  a  would lead unnecessary retractions   b  appears
better reflect well decomposed tasks  dynamic hierarchical justification constrain
knowledge development process improve resulting decompositions  consequently 
nearly decomposed tasks allow dhj avoid unnecessary regenerations
avoiding processing overhead assumption justification 
      limiting persistence dhj
dhj limits persistence subtasks  resulting assumptions persistent
assumptions typical truth maintenance systems  section explores consequences
limitations determine dhj architectures   still provide persistence
necessary agent execution  section      
dhj retract subtask potential inconsistency could impact hypothetical
recursive reasoning counting  consider aircraft classification counting example 
perhaps aircrafts altitude contributes hypothetical classification aircraft
 e g   particular altitude speed combinations might suggest reconnaissance aircraft  
agent would create assumptions locally depend aircrafts altitude 
altitude  or altitude boundary  changes  assumption retracted 
retraction required avoid inconsistency  contacts altitude longer suggests
reconnaissance aircraft  assumption depended assertion
removed  dhj captures dependencies performs retraction  agent
   clarity  assumption justification already eliminated candidate solution 
following discussion focuses exclusively dhj  however  assumption justification limits persistence
similarly 

   

fiwray   laird

opportunity reconsider classification aircraft  pursue tasks
classification longer important 
dhj retract subtask assumption created local subtask
purpose remembering input  or elaboration input   example  agent
needed remember particular aircrafts altitude particular point time 
assumption cannot stored local subtask  dhj limits persistence way
remembering within local subtask generally impossible 
order remember previous situations  assumptions asserted root task 
assumption asserted level never retracted higher level
dependencies  assuming percepts associated top level higher input
level  theo  mitchell et al          primary drawback requirement
remembering remembered items longer local subtask created them 
requiring additional domain knowledge manage remembered assumptions  however 
remembering already requires domain knowledge  possible remember assertion
regardless dependencies able retract architecturally 
examples show dynamic hierarchical justification still allows forms
persistence  trades capturing dependencies nonmonotonic assumptions local subtasks remembering assumptions root task  dependencies captured 
dhj forces remembered items root task  suggests fundamental aspect root task managing remembered assumptions  view
requirement positive consequence dhj  forces knowledge engineers
better recognize reasons creating assumption  e g   remembering vs  hypothetical  circumscribes remembering develop adopt functional
temporal theories manage assumptions created remembering  e g   allen       
altmann   gray        
      recovery interruption dhj
dynamic hierarchical justification makes agent reactive environment  ensuring relevant changes environment lead retraction dependent
subtasks  dhj imposes automatic interruption agent subtask retraction 
without evaluating state system first  although automatic interruption increases
reactivity system  lead difficulties way override it 
section examine two cases uncontrolled interruption cause problems 
problems arise dhj biases system reactive  is  respond automatically changes environment without deliberation  however  cases 
additional agent knowledge overcome bias make system deliberate
avoid uncontrolled interruption 
first problem arises sequence actions must completed
without interruption order subgoal achieved  processing interrupted 
possible  dynamics world  task cannot resumed 
example  imagine aircraft nearing point launch missile target 
task interrupted resumed  aircrafts position may changed
enough  relative target  additional steering commands necessary
   

fiensuring consistency hierarchical execution

missile launched  case  may preferable interrupt original
launch sequence begun 
consider two possible approaches achieving capability dynamic hierarchical
justification architectures  first move processing root task 
root task interrupted  processing interrupted  however 
approach greatly restricts task hierarchically decomposed thus
considered last resort  second approach add new reasoning task
freezes external situation respect additional reasoning subtask 
new processing initiates execution subtask creates persistent structures
root task  persistent structures represent deliberate commitment
interrupted  remaining processing subtask accesses structures
execution task  thus  persistent  even changes
surrounding situation would interrupted subtask  processing
insensitive changes interruption prevented  approach requires
additional reasoning recognize completion uninterruptible behavior remove
persistent structures built initial subtask  reasoning reflects deliberate act 
signaling commitment longer holds  abstract  together additions
provide mechanism overcoming automatic interruption  disadvantage
approach that  part system design  subgoals cannot interrupted
must identified beforehand  subtasks  additional agent knowledge must
implemented create remove encapsulations dynamic data 
critical problem dhj wesson oil problem  someone cooking
dinner higher priority activity suddenly occurs  a hurt child   cook turn
stove  a cleanup procedure  leaving hospital  gat      b   problem
occurs change hierarchical context level far terminal
level hierarchy  situation  similar tasks may resumed initiated
following interruption  agent must therefore recognize whether cleanup
external and or internal states necessary  and  so  perform cleanup  even
dhj  agent still behave appropriately right knowledge  particular 
agent must able recognize partially completed tasks  like cooking dinner 
able select cleanup actions specific task state  like turning stove burner  
dhj requires remembered assumptions asserted root level
hierarchy  recognition task internal state available  need try reconstruct
state external environment alone  however  require analysis
task domain s  knowledge engineer interruptible activity requiring
cleanup include triggering assertions cleanup root task 
work prompted desire architectural solutions inconsistency  yet
maintaining consistency efficiently lead interruptions  which  dhj  requires
knowledge based solutions problems arising automatic interruption    however 
requirements imposed dhj positive consequences  subtask retractions
observed recovery development process help define must remembered
root task cleanup  significantly different laborious process debugging
   dynamic hierarchical justification could used trigger meta level deliberation rather
immediate subtask retraction  would possibly provide architectural solution question
deliberate potential inconsistency intention reconsideration  see section      

   

fiwray   laird

agent programs failing due inconsistency  theory  dynamic hierarchical
justification imposes requirements handling interruptions pose serious questions
overall utility  practice  found addressing questions
problem variety recent agent implementations using soar dhj architecture  e g  
laird        wray et al         

   empirical evaluation dynamic hierarchical justification
architectural mechanisms dhj must efficient  demonstrated
algorithm efficient  question impact overall behavior generation
capability agent remains open question due interruption regeneration  given
complexity agent based systems domains applied 
analytical evaluations must extremely narrow scope  even require specialized
techniques  wooldridge         section instead pursues empirical evaluation
dynamic hierarchical justification  focusing efficiency responsiveness two domains
extremes continua agent domain characteristics  architectural
solution inconsistency motivated cost  and incompleteness  knowledgebased solutions  knowledge development costs estimated 
    methodological issues
dynamic hierarchical justification general solution  applicable wide range agent
tasks  order evaluate solution  number methodological issues must
addressed  following describes three important issues choices made
evaluation 
      relative vs  absolute evaluation
constitutes good poor cost performance evaluations  general 
absolute evaluation performance cost difficult task itself  addition
agents knowledge architecture  determines overall cost performance results 
circumvent problem making relative comparisons agents using
original  fixed hierarchical justification soar architecture  fhj agents  new agents
 dhj agents   fhj agents provide cost performance benchmarks  obviating
need absolute evaluations 
      addressing multiple degrees freedom agent design
even architecture task fixed  many different functional agents developed  one know comparative results valid general experimenter
control benchmarks new agents 
dhj agents compared agents previously implemented others  systems
provide good performance targets  optimized performance 
minimize bias  developed independently 
fhj systems used fixed benchmarks  modified  dhj agents use
identical task decompositions employed fhj agents initial knowledge
base  observed opportunities improve performance dhj agents modifying
   

fiensuring consistency hierarchical execution

either task decomposition re designing significant portions agent knowledge
base  however  agent knowledge modified necessary correct behavior 
order ensure dhj agents remained tightly constrained fhj counterparts 
thus limiting bias evaluation 
      choice representative tasks
evaluation limited execution agents dynamic blocks world
reduced knowledge version tacair soar  micro tacair soar   choice
tasks domains considerable drawback benchmarks  hanks  pollack    cohen         although choices motivated primarily availability domains
pre existing fhj agents  two domains represent opposite extremes many
domain characteristics  micro tacair soar  tacair soar  inaccessible  nondeterministic  dynamic  continuous  dynamic blocks world simulator used
experiments accessible  deterministic  static discrete  primary motivation
using dynamic blocks world  less representative typical agent tasks
micro tacair soar  assess cost employing dhj domain priori
appears would useful  although section   suggests dhj prove useful even
relatively static domains   thus  dynamic blocks world provide baseline
actual cost deploying algorithm  even though little benefit expected
deployment domain 
    evaluation hypotheses
although specific expectations differ different domains  differences dimensions
knowledge cost performance anticipated comparing dhj agents
baseline agents  following discusses expectations metric s  used
dimension 
      knowledge engineering cost
knowledge engineering effort dhj agents decrease comparison previously
developed agents  knowledge soar represented production rules  production
represents single  independent knowledge unit  assume addition productions represents increase cost measure knowledge cost counting number
productions type agent  number productions  course  provides
coarse metric cost complexity individual productions varies significantly 
however  productions removed dhj agents often difficult
ones create  therefore  difference number productions probably conservative
metric knowledge cost dhj 
      performance  efficiency responsiveness
general  overall performance change little dhj agents  compared fhj
counterparts  although dynamic hierarchical justification add new architectural
mechanism  algorithm efficient contribute significant differences performance  further  less domain knowledge need asserted
   

fiwray   laird

across level consistency knowledge incorporated architecture  thus  applying across level kbac knowledge represented significant expense overall cost
executing task  dhj agents might perform better fhj agents 
two specific exceptions expectation  first  domains consistency knowledge  mostly  unnecessary task performance  fhj agents may perform
better dhj agents  example  dynamic blocks world requires little consistency knowledge dhj architecture still update support set  even though
inconsistency causing context changes arise 
second  regeneration problematic  overall performance suffer  dhj  whenever
dependent context changes  subtask retracted  change lead
different choice subtask  subtask necessarily regenerated  thus 
dhj  subtask regeneration occur  and  regeneration significant  performance
degradation result 
cpu execution time provides simple  single dimension gross performance  cpu
time reported individual experiments reflects time agent spends reasoning
initiating actions rather time takes execute actions environment 
decisions  soar  subtasks correspond selection operators subgoals
implementing operators  selection operator called decision  soar
selects operator  tries apply operator  soar reaches impasse cannot
apply newly selected operator  non primitive operators lead generation
subgoal subsequent decision  example  soar selects put down operator
one decision creates subgoal implement put down subsequent decision 
together  two steps constitute notion subtask soar 
number decisions thus used indication number subtasks
undertaken task  fhj  subtask generally never interrupted terminated
 either successfully unsuccessfully   dhj  subtasks interrupted whenever
dependent change occurs  thus  decisions increase dhj agents subtasks
interrupted re started  further  decisions increase substantially  suggesting
significant regeneration   overall performance degrade 
production firings  production rule fires conditions match result
applied current situation  production firings decrease dhj two reasons 
first  across level consistency knowledge previously used fhj agents
longer necessary  or represented   therefore  knowledge accessed  second 
reasoning occurred inconsistency arose fhj agents interrupted
eliminated  however  production firings increase significant regeneration necessary 
    empirical evaluation blocks world
agents dynamic blocks world domain execution knowledge transform
initial configuration three blocks ordered tower using simulated gripper arm 
table simulation width nine blocks  agents task goal always
build   on   on   tower  agent built tower resulting     unique 
non goal  initial configurations blocks  table   summarizes results tasks 
expected  total knowledge decreased  overall performance improved  decisions increased 
expected  number rule firings increased well  anticipated 
   

fiensuring consistency hierarchical execution

rules
decision avg 
avg  rule firings
avg  cpu time  ms 

fhj
x
s d 
   

    
    
           
           

dhj
x
s d 
   

     
    
           
           

table    summary knowledge performance data blocks world  agents
performed tower building task     configurations  task order
randomly determined 

      knowledge differences
total knowledge decreased    dhj agent  small reduction consistent
expectation  aggregate comparison misleading knowledge
added     productions  deleted      
removing consistency knowledge  soar  subtask operator subgoal
terminated separately  soar monitors impasse causing assertions determine subgoal
 such subtask goal  removed via fhj  however  removal subtask
operator requires knowledge  original  fhj architecture treats initiation
operator persistent assumption requires knowledge recognize selected
operator interrupted terminated  knowledge categorized consistency knowledge determines time subtask terminated 
even initiating conditions subtask longer hold 
dhj  effects operators persistent  assertions entailments
situation  thus  initiation subtask treated entailment
subtask remains selected long initiation conditions subtask hold 
change removes need knowledge terminate subtask  subtask
initiation conditions longer true  subtask automatically retracted  thus 
termination knowledge removed subtask operators 
filling gaps domain knowledge  persistence subtasks original architecture allows fhj agents ignore large parts state space domain knowledge 
example  knowledge initiates stack put on table subtasks assumes
gripper currently holding block  tasks executed  gripper 
course  grasp individual blocks  conditions initiating stack put on table
holding block ignored original domain knowledge 
dhj agent requires knowledge determine subtasks choose
holding blocks  subtasks interrupted agent still holds block 
   productions necessary  primarily stack put on table operators 
important note knowledge necessary domain knowledge  fhj agents could
solve problem began task holding block lacked
domain knowledge states  additions thus positive consequence
dhj  architectures enforcement consistency revealed gaps domain knowledge 
   

fiwray   laird

      performance differences
somewhat surprisingly  overall performance dhj agents  measured cpu time  improves slightly comparison fhj agents  even though decisions production
firings increase  soar specific performance metrics considered individually
below  overall performance improvement considered 
decisions  fhj agents  average  made considerably fewer decisions dhj agents 
difference consistent across every task  additional decisions result
removal subsequent regeneration subtasks  example  agent picks
block pursuit stack task  selection stack task must regenerated 
knowledge dhj agents could modified avoid testing specific configurations
blocks thus avoid many regenerations 
production firings  number production firings increased blocks world 
increase production firings attributed knowledge added system
regeneration subtasks made additions necessary  relative increase
number production firings       much smaller increase decisions       
smaller difference attributed productions removed  and thus
fire  
cpu time  generally  production firings increase soar  increase cpu
time expected  however  cpu time dhj decreased slightly comparison fhj
even though production firings increased  explain result  additional aspects
soars processing must considered 
match cost production constant grows linearly number
tokens  partial instantiations production  tambe         token indicates
conditions production matched variable bindings conditions 
thus  token represents node search agents memory matching
instantiation s  production  specific productions conditions are 
constrained search memory  thus costs less generate instantiation 
new productions added dhj blocks world agent specific
agents memory  i e   external internal state  productions removed 
further  simply fewer total productions reduce amount total search
memory   informal inspection match time tokens several fhj
dhj runs showed number tokens decreased dhj         reduction
token activity primary source improvement dynamic blocks world dhj
agent cpu time  improvement  course  general result provides
guarantee task domain cost matching increase rather
decrease 

   rete algorithm  forgy        shares condition elements across different productions  thus 
removal productions decreases total search removed productions contain condition elements
appearing remaining productions  perform exhaustive analysis condition
elements determine removed productions reduce number unique condition elements
rete network 

   

fiensuring consistency hierarchical execution

    empirical evaluation tacair soar
converting tacair soar dhj architecture would expensive  requiring many
months effort  dhj agents instead developed research instruction version
tacair soar  micro tacair soar  tas   tas agents use tacair soar simulation
environment  modsaf  interface knowledge fly missions  resulting order magnitude decrease number productions agents  however 
tas uses tactics doctrine missions tacair soar 
tas  team two agents  lead wing  fly patrol mission described
previously  engage hostile aircraft headed toward within
specific range  lead agents primary role fly patrol route intercept
enemy planes  wings responsibility fly formation lead 
total knowledge significantly reduced  converting tas dhj agents relatively
inexpensive  however  results representative tacair soar tas
retains complexity dynamics tacair soar 
patrol mission clearly defined task termination condition dynamic
blocks world  address problem  agent simulation executes ten
minutes simulator time  time  agent opportunity take off 
fly formation partner patrol  intercept one enemy agent  return patrol
intercept  actual tacair soar scenario  activities would normally
separated much larger time scales  however  agent spends much time
patrol mission simply monitoring situation  waiting   rather taking new actions 
ten minutes simulated time proved brief enough overall behavior
dominated wait states  providing time natural flow events 
running fixed period time  increase number decisions
attributed regeneration simply improvement decision cycle time  avoid
potential confusion running simulator constant cycle time  mode 
simulator update represents    milliseconds simulated time  agent
runs fixed period time fixed updates  fhj dhj agent execute
number decisions  problems due regeneration apparent
number rule firings degradation responsiveness  additionally  general results
change significantly scenarios executed real time mode normally
used tacair soar agents  fixed cycle simply eliminates variability 
although patrol scenario designed minimize variation run run 
tas simulator inherently stochastic specific actions taken agent
time course actions varies task repeated  control variation  scenario run lead wing agents approximately    times  logging
data collection significantly impacted cpu time performance statistics 
order control effect  actually ran scenario    times  randomly choosing
one agent  lead wing  perform logging functions  and discarding performance measures   agent performed logging functions  data logging agents used
create figure    performance measures logging agents recorded
conclusion scenario summarized table   
   

fiwray   laird

lead agent
rules
number runs  n 
decisions
outputs
rule firings
cpu time  msec 

fhj
   
  
x s d 
    
   
          
        
        

x
    
     
    
    

dhj
   
  
s d 
   
    
    
   

wing agent
fhj
dhj
   
   
  
  
x s d 
x s d 
    
   
    
   
         
        
         
        
         
        

table    summary tas run data 
      improving task decompositions
tacair soar dhj agents required extensive knowledge revision  revision
unexpected  instance  unlike dynamic blocks world  tas agents remember many
percepts  last known location enemy aircraft  previously described 
assertions remembering must located root level hierarchy  thus
requiring knowledge revision  however  problems discovered 
cases  fhj agents took advantage inconsistency asserted knowledge  words 
fhj agent allowed inconsistency assertions actually depended
inconsistencies apply new knowledge  two major categories knowledge 
within level consistency knowledge recognized specific inconsistencies  e g   retraction
proposal subtask  trigger actions clean subtask
state  complex subtasks allowed non interruptible execution complex procedure
regardless continuing acceptability subtask  cases  agent knowledge
modified remove dependence inconsistency  appendix provides
explanation original knowledge subsequent changes  section       summarizes
changes quantitatively 
      results
table   lists average data fhj dhj lead wing agents patrol intercept
scenario modifications dhj agents knowledge base completed 
results domain consistent expectations  total knowledge decreases  rule
firings decrease performance improves  substantially dhj wing agent 
following sections explore results greater detail 
      knowledge differences
table   quantifies changes soar production rules described above    modifications include deletions  additions changes  rule considered changed
conditions changed slightly  made type computation
subtask  example  changed within level consistency knowledge refers
   dhj agent data generated knowledge base included changes accommodate
learning  wray        changes included table completeness  presence
rules knowledge base negligible impact performance data reported here 

   

fiacross level
consistency

remembering

within level
consistency

complex
subtasks

learning

miscellaneous

ensuring consistency hierarchical execution

  
 

  
  

 
 

  
  

 
 

 
 

 

  

 

 

  

 

fhj agent 
deletions 
additions 
dhj agent 
additional changes 

totals
   
     
  
   
  

table    quantitative summary changes production rules fhj agent knowledge
base dhj agents 

entailed structure rather one created assumption  structure
located subtask  somewhat restrictive definition change inflates
addition deletion accounting  many cases production deleted immediately added different subtask  example  productions manipulate
motor commands moved local subtasks highest subtask  almost
additions deletions remembering category attributed move 
required synthesis new production knowledge 
total knowledge required dhj agents decreased  approximately    reduction achieved making type modification     fhj agent
rules  may seem modest gain  given conversion cost  however  cost
artifact chosen methodology  dhj agents constructed domain
without previously existing fhj agents  least    decrease total knowledge would
expected  result thus suggests reduction cost agent design 
high conversion cost suggest converting much larger system  tacair soar 
would probably costly  hand  modifications made evident
identifiable regenerations architecture  thus      total changes made fhj
knowledge base much easier make constructing similar number rules 
      performance differences
performance results table   show  dhj agents improved performance relative
fhj peers  however  improvements lead wing agents substantially
different  differences tasks lead wing pilots led differences relative
improvements 
lead wing agents  lead wing agent share knowledge base
perform different tasks tas scenario    differences lead differences
   agents share knowledge base dynamically swap roles execution 
instance  lead exhausts long range missiles  order wing take lead role 
take role wing itself 

   

fiwray   laird

    

dhj lead
dhj wing
fhj lead
fhj wing

cumulative outputs

    

    

   
intercept

launch missile

patrol turns

resume patrol
 
 

   

   

   

   

   

   

time  sec 

figure     cumulative outputs course one ten minute scenario dhj  black 
fhj  gray  agents  cumulative outputs lead agents represented
solid lines  wing agents dashed lines 

absolute performance  recall leads primary responsibility fly patrol route
intercept enemy aircraft  hand  wings primary mission role follow
lead  different tasks require different responses agents 
agents overall reasoning activity often correlated output activity 
is  commands sends external environment take action it  figure   
summarizes output activity two pairs lead wing agents  fhj   dhj 
course ten minute scenario  output activity leads mostly concentrated
places course scenario  take off  intercept  launch missile 
resuming patrol following intercept   wings concentrated output
activity occurs leads turn new leg patrol wings must follow
lead     degree turn  remainder section  focus dhj
agents contrast lead wing agent behavior  discussion performance metrics
examine differences fhj dhj leads wings 
lead actually spends scenario waiting  short bursts reasoning
output activity occurring tactically important junctures scenario  patrol 
lead flies straight makes decision turn reaches end patrol
leg  lead monitors environment searches enemy planes  search
   

fiensuring consistency hierarchical execution

 mostly  passive  agents radar notifies agent new entities detected 
detecting classifying enemy plane potential threat  lead commits
intercept  lead immediately makes number course  speed  altitude adjustments 
based tactical situation  actions evident figure pulse labeled
intercept  lead spends time intercept closing distance
aircraft get within weapon range  maneuver little thus
requiring actions environment  thus relatively flat slope following intercept  
agent reaches missile range enemy plane  lead executes number
actions quickly  lead steers plane launch window missile  pushes
fire button  waits missile clear  determines course maintain
radar contact missile flies target  at launch missile   intercept
completed  lead resumes patrol task  again  issues large number output
commands short period time  examples show leads reasoning focuses
primarily reacting discrete changes tactical situation  patrol leg ended  enemy
range  etc   behavior generally requires little continuous adjustment 
execution wings follow leader task  hand  requires reaction
continuous change leads position order maintain formation  position corrections
require observing leads position  recognizing undesired separation formation 
responding adjusting speed  course  altitude  etc  wing following
lead throughout scenario  executing position maintenance knowledge almost
constantly  lead flying straight level  patrol leg  wings task
require generation many outputs  figure     periods little activity
evident periodic flat segments wings cumulative outputs  lead
begins maneuver  e g   turn   wing must maintain formation throughout
maneuver  turn wing generates many motor commands follows lead 
turn takes seconds complete  outputs increase gradually
course turn  seen figure  thus  wing periodically encounters
dynamic situation requires significant reasoning motor responses  further 
response change discrete  lead  occurs continuously
course leads maneuver 
differences tasks two agents account relatively large absolute
differences performance metrics lead wing agents  wings
adjusting positions relative leads  issue many output commands
leads  requires many inferences determine commands
be 
decisions  differences decisions lead wing due artifact
data collection  lead agents ran extra second wings halted order
initiate data collection 
production firings  lead wing agents  production firings decrease  however  wings production firings decrease      lead  decrease
     one reason large improvement dhj wing due elimination
redundant output commands fhj agents  fhj wing sometimes issues
motor command once  reason duplication specific motor command computed locally  thus available subtasks  cases 
two subtasks may issue motor command  command stored locally 
   

fiwray   laird

command may issued agent cannot recognize command
already issued another subtask  motor commands remembered
top subtask dhj agents  inspected subtasks  dhj wing thus
never issues redundant motor command  large relative decrease outputs
wing agent fhj dhj  figure     attributed improvement  production firings decrease decrease output activity reasoning activity
wing concerns reacting leads maneuvers 
contrast wing  leads average number outputs actually increases  regeneration source additional outputs  situations  dhj agents
subtask adjusting heading  speed altitude get updated repeatedly highly
dynamic situation  e g   hard turn   fhj agent uses subtask knowledge decide
current output command needs updated  however  dhj  subtask may
retracted due dependence changing value  e g   current heading   subtask regenerated following retraction  lead may generate slightly different motor
command  example  lead might decide turn heading      instead       
decision causes generation new output command would
re issued fhj agents accounts small increase outputs  suggests
without self imposed constraint methodology  knowledge base could
modified avoid regeneration decrease production firings 
although large magnitude improvement wing primarily due remembering motor commands  agents needed less consistency knowledge thus
accessed less knowledge performing task  agents perform tasks
using less knowledge 
cpu time  cpu time decreases dhj lead wing agents  improvement
lead       half improvement wing        differences due
primarily decrease production firings  fewer production firings thus
fewer instantiations generate  leading improvements cpu time  match time
improved  contributing overall performance improvement    larger improvements
cpu time compared production firings improvements      vs      lead 
    vs      wing  might attributable decreases number rule
firings match time  again  results offer guarantee match time always
decrease dhj  important note  however  two different domains dhj
reduces total knowledge constrains remaining knowledge  architecture
leveraged small differences improved overall performance 
      differences responsiveness
cpu time decreases dhj agents  responsiveness generally improve 
however  agent knowledge split several different subtasks 
actions may initiated quickly would initiated fhj agent 
section  explore differences responsiveness one situations 
   dynamic blocks world  trends based observations data  rather
significant analysis  particular  tas  data number tokens generated collected 
results reported consistent expectation token activity falls dhj agents 
compared fhj agents 

   

fiensuring consistency hierarchical execution

fhj
dhj

avg  in range time
 sec 
       
       

avg  launch time
 sec 
       
       

reaction time
 sec 
    
    

n
  
  

table    comparison average reaction times launching missile tas 
enemy plane comes range  agent executes series actions  leading
firing missile  reaction time difference time enemy
agent comes range time agent actually pushes fire button launch
missile  reaction time one measure agents responsiveness  table   shows 
fhj agent able launch missile quarter second  however 
dhj agent three and a half times slower fhj agent launching
missile  taking almost full second  average 
split subtasks  regeneration  subtask selection contribute increase
reaction time  splitting subtask n steps  may executed
single decision previously  may take n decisions dhj agent  actions
necessary launching missile one would expect increase of  most 
hundred milliseconds change  however  dividing subtasks separate steps 
sequential series actions interrupted  particular  number regenerations
occur launch missile subtask agent prepares fire missile highly
dynamic situation  agent sometimes chooses undertake similar action
situation changed enough slightly different action might necessary  described
above  result dhj agents taking accurate aim fhj agents 
responding quickly dynamics environment  aiming 
however takes time  although increase time tactically significant  i e  
enemy planes escaping previously hit fhj agents  
additional re engineering knowledge would improve reaction time  e g  
described section         however  decreases responsiveness difficult avoid 
general  dynamic hierarchical justification requires subtasks different dependencies initiated terminated separately  risk unnecessary regeneration  however 
splitting complex tasks separate subtasks  individual actions delayed subtasks separate procedures  selection particular
subtask series postponed additional subtask choices available 
    summary empirical evaluations
figure    summarizes results dynamic blocks world tas  domains 
dhj agents require fewer total productions  suggesting decrease knowledge cost  performance roughly dynamic blocks world lead agents tas 
dhj wing agents show much greater improvement overall performance  due
dhj changes knowledge  results suggest dynamic hierarchical
justification expected reduce engineering effort degrade performance
variety domains  simple complex  however  response time situations may
decrease 
   

fiwray   laird

   
   

productions

   
   
   
fhj lead
fhj wing
fhj dbw

   

dhj lead
dhj wing
dhj dbw

 
 

 

 

 

 

  

  

  

  

  

cpu time  sec 

figure     mean cpu time vs  knowledge productions fhj  black  dhj  gray 
agents dynamic blocks world tas  graph includes actual
distribution cpu time agent well mean agent 
means dynamic blocks world agents illustrated squares  tas
lead agents triangles  tas wing agents diamonds 

   discussion
solutions kbac new solutions introduced developed
inconsistency problem  wray         briefly introduce additional solutions 
consider relationship dynamic hierarchical justification intention reconsideration belief desire intention agents belief revision 
    solutions inconsistency across hierarchy
section  review existing architectural solutions problem inconsistency arising persistence hierarchy assertions 
      limiting persistence
one obvious approach eliminating inconsistency arising persistence disallow
persistent assumptions altogether  approach adopted theo  mitchell et al  
       reasoning theo entailed sensors  perceptual inputs unjustified 
theo cannot reason non monotonically particular world state  world
change non monotonically  thus  theo cannot generally remember previous inputs 
   

fiensuring consistency hierarchical execution

another possible limitation would restrict assumptions single memory
 global state   or  equivalently  allow assumptions root level hierarchy
hierarchical architecture  solution ensures hierarchical context always
consistent  all assertions within associated subtask entailments  allows
persistence  htn execution systems retsina decaf  mentioned
previously  global state  obviously suffer inconsistency
hierarchy  however  interactions persistent assertions new information
derived sensors problem systems global state 
retsina recently adopted rationale based monitoring  veloso  pollack    cox 
      identify environmental changes could impact currently executing task network  paolucci et al          rationale based monitoring uses structure plan knowledge  in case  plan operators  including task networks  alleviate inconsistency  monitors relevant world features created dynamically planning progresses identifying
pre conditions operators instantiating via straightforward taxonomy monitor types  e g   monitor quantified conditions   collection monitors form plan
rationale  reasons support planners decisions  veloso et al          plan rationales
thus similar justifications used truth maintenance  monitors activated
pre condition element world changes  inform planner
change  planner deliberate whether change impact
plan construction and  so  consider appropriate repairs 
rationale based monitoring similar dynamic hierarchical justification  especially
leverage structures  different  underlying task representations provide consistency  however  two important differences  first 
dhj identifies specific subtask impacted change  require deliberation
determine impact change  immediate return consistent knowledge state
possible  monitor activated rationale based monitoring  planner must
first determine plan affected  require deliberation  second 
monitors trigger deliberation  rather automatically retracting reasoning 
agent using rationale based monitoring determine plan repaired
how  dhj  as implemented  offer flexibility  retraction automatic  automatic retraction assumes cost retrieving  or regenerating  pre existing plan knowledge
less costly deliberation determine if how plan revised  plan
modification expensive plan generation  nebel   koehler         assumption reasonable  however  invoking deliberate revision process could circumvent
potential problems arising recovery interruption  section        
      fixed hierarchical justification
mentioned previously  pre dhj version soar procedural reasoning
system  prs   georgeff   lansky        use fixed hierarchical justification retract
complete levels hierarchy support set longer holds  prs  support
set consists set context elements must hold execution subtask 
elements defined knowledge engineer  fixed hierarchical justification offers
complete solution inconsistency problem context references within reasoning
subtask limited support set  approach guarantees consistency  however 
   

fiwray   laird

requires knowledge designer identify potentially relevant features used
reasoning within subtask  additionally  resulting system may overly sensitive
features support set features rarely impact reasoning  leading
unnecessary regeneration 
fixed hierarchical justification requires less explicit consistency knowledge knowledgebased solutions  however  kbac knowledge still required access whole task hierarchy possible  thus  agents ability make subtask specific reactions unexpected
changes environment limited knowledge designers ability anticipate
explicitly encode consequences changes 
    intention reconsideration
belief desire intention  bdi  model agency  intention represents commitment
achieving goal  rao   georgeff        wooldridge         intention thus similar
instantiation subtask hierarchical architecture 
dynamic hierarchical justification viewed partial implementation intention reconsideration  schut   wooldridge               intention reconsideration
process determining agent abandon intentions  due goal achievement  recognition failure  recognition intention longer desired  
dynamic hierarchical justification partial implementation intention reconsideration able capture syntactic features problem solving  i e  
identification dependencies via support set  determine reconsider
intention  situations require deliberation determine intention
abandoned captured dhj    schut   wooldridge        describe initial attempt allow run time determination reconsideration policies  optimal policy
would maximize likelihood deliberate intention reconsideration actually leads
abandoning intention  i e   agent reconsiders reconsideration necessary  
contrast  dynamic hierarchical justification offers low cost  always available  domain general process abandoning intentions  cannot automatically identify reconsiderations
requiring semantic analysis problem state 
bdi models  agents choose execute current action plans without
reconsidering current intentions first  kinny georgeff        showed that 
static domains  bold agents never reconsider intentions perform effectively
cautious agents always reconsider executing plan step  opposite
true highly dynamic domains  cautious agents perform bold ones  soar
prs described cautious via fixed hierarchical justification  is 
plan step  architectures determine elements support set remain asserted
executing step  fhj approaches are  effect  bold appear 
reconsider intentions assertions changed dependent
context  support set  dynamic hierarchical justification provides
cautious agents  ensures agents reconsideration function takes
account context dependencies subtask reasoning  perspective intention
    dhj preclude deliberate reconsideration  however  soar  as testbed exploration
dhj  provide architectural solution deliberate reconsideration  thus  situations
addressed knowledge deliberative processes architecture 

   

fiensuring consistency hierarchical execution

reconsideration  problems introduced dynamic domains prompted us explore
cautious solutions 
results empirical analysis somewhat consistent kinny  
georgeff  cautious dhj agents performed better less cautious fhj agents
highly dynamic tacair soar domain  dynamic blocks world  performance
differences equivocal  comparison fhj number new intentions
increased dynamic hierarchical justification  measured soar decisions  
slight overall performance improvement dhj  due improvements
match time productions  soar specific measure likely generalize
systems  results suggest dhj possibly overly cautious static
domains  however  dynamic hierarchical justification present significant
performance cost unexpectedly played constructive role agent execution even
static domain  dhj seems warranted static dynamic domains 
    belief revision
belief revision refers process changing beliefs accommodate newly acquired
information  inconsistency problem example need revision asserted
beliefs  change hierarchical context  deriving ultimately perceived changes
world  leads situation currently asserted assumption would  necessarily  regenerated re derived  theories belief revision identify functions
used update belief set remains consistent 
best known theory belief revision agm theory  alchourron  gardenfors 
  makinson        gardenfors               agm coherence theory  meaning
changes beliefs determined based mutual coherence one another  approach contrasts foundations approach  justifications  reasons  determine
when how revise belief set  obviously  dynamic hierarchical justification extension foundations approach belief revision  however  foundations
coherence approaches reconciled  doyle         section explore repercussions dynamic hierarchical justification context agm theory belief
revision 
agm theory  new sentence presented database sentences representing
current knowledge state  agent faced task revising knowledge base
via one three processes  expansion  adding sentences knowledge base   contraction
 removing sentences knowledge base  revision  a combination expansions
contractions   agm theory emphasizes making minimal changes knowledge base
epistemic entrenchment  notion usefulness sentence within database 
agm theory prefers sentences high epistemic entrenchment  relative
sentences  retained revision 
comparing dynamic hierarchical justification assumption justification suggests
sometimes cheaper remove subtask  and asserted beliefs associated
subtask  compute minimal revision assumption justification 
context belief revision  result surprising  since shown
computing minimal revision knowledge base computationally harder
deduction  eiter   gottlob         theoretical result led applications
   

fiwray   laird

compute belief updates via incremental derivations belief state  rather via belief
revision  kurien   nayak        
power heuristic approach used dhj analytic solution follows
characteristics outlined section        hierarchical structure organization
agent assertions efficiency underlying reasoning system regenerate
unnecessarily removed assertions  assumptions  persistent beliefs  associated particular subtasks hierarchical architectures  change perception  an epistemic input 
leads revision  rather determining minimal revision  dhj uses heuristic
that  context  says persistent beliefs subtask similar epistemic entrenchment subtask intention itself  cases  heuristic incorrect 
leading regeneration  but  correct  provides much simpler mechanism revision  gardenfors        anticipates conclusions  suggesting systems possessing
additional internal structure  as compared relatively unstructured belief sets
agm theory  may provide additional constraints orderings epistemic entrenchment 

   conclusion
empirical results dynamic blocks world tas domains consistent expectations  knowledge engineering cost decreased overall performance
dhj roughly  or slightly improved  comparison independently developed
fhj benchmarks  development cost decreases designer freed task
creating across level consistency knowledge  one drawback dhj responsiveness
degrade regeneration occurs 
dhj incorporated currently released version soar  soar   
  years experience users confirms development cost decreases 
partly true developers need deeper understanding architecture realize
benefit  however  dhj removes need encoding across level consistency
knowledge  proven difficult understand encode many systems  dhj
makes understanding role assumptions soar systems straightforward  imposing design development constraints  instance  knowledge designer must
think why  when  persistence used agent  knowledge designer determines functional role persistent assumption  dhj guides
development knowledge necessary assumption  nonmonotonic hypothetical assumption  knowledge must created looks outside subtask
order ensure consistency  i e   across level knowledge necessary   assumptions
remembering must asserted root level hierarchy  knowledge must
created manage remembered assumption  functions root task include
monitoring  updating  removing remembered assumptions  we developing domaingeneral methods managing remembered assumptions reduce cost   thus 
dhj increase complexity architecture  makes design decisions
explicit manageable previous kbac approaches 
regeneration  seemingly one drawbacks dhj  contributes decreased
knowledge development costs  regeneration serves debugging tool  allowing immediate
localization problem areas domain knowledge  and specific decomposition  
debugging aid contrasts previous knowledge development inconsistency
   

fiensuring consistency hierarchical execution

often became evident irrational behavior  making often difficult determine
actual source problem  thus  addition reducing total knowledge necessary
task  dynamic hierarchical justification might reduce cost per knowledge
unit creating agent knowledge localizing problems via regeneration  however 
case domain cannot decomposed nearly decomposable subunits 
regeneration could debilitating 
another positive consequence dhj agent may behave robustly novel
situations anticipated knowledge engineer  example  simple experiment 
fhj dhj dynamic blocks world agents placed situation described
figure    fhj agent fails block moves lacks knowledge recognize
moving blocks  knowledge designer assumed static domain  knowledge 
however  dhj agent responds situation gracefully  specific situation
figure    dhj agent immediately retracts put on table    subtask 
block   table  thus selection subtask longer consistent
current situation  agent chooses stack      decomposes subtask
actions put block   block    new block  e g   block    placed
empty space block    architecture responds retracting subtask goal
put down     i e   subtask contains empty assumption   begins search
empty spaces order continue attempt put block   table 
architecture  rather agent knowledge  ensures consistency across hierarchy  dhj
agents less brittle situations explicitly anticipated agent design 
dhj provides solution problem learning rules non contemporaneous
constraints  wray  laird    jones         non contemporaneous constraints arise
temporally distinct assertions  e g   red light  green light  collected single learned
rule via knowledge compilation  rule non contemporaneous constraints lead
inappropriate behavior rather never apply  problem makes difficult
use straightforward explanation based learning approaches operationalize agent execution
knowledge  non contemporaneous constraints arise architecture creates persistent
assumptions become inconsistent hierarchical context  wray et al         
dhj never allows inconsistency  solves non contemporaneous problem 
instance  agents dynamic blocks world tas able learn
unproblematically new architecture  no little knowledge re design  wray       
provides additional details empirical assessment learning 
dynamic hierarchical justification operates higher level granularity assumption justification knowledge based solution methods  trading fine grained consistency lower computational cost  higher level abstraction introduce additional cost execution  particular  necessary regeneration led redundancy
knowledge search dynamic blocks world tas agents  although overall efficiency improved  improvement due improvements average
match cost productions  cannot guaranteed domains architectures  further  dynamic hierarchical justification requires complex subtasks
split distinct subtasks  requirement improves knowledge decomposition
reduces regeneration performance reduce responsiveness  however 
straightforward compilation reasoning subtasks dhj enables  reduction
responsiveness overcome learning  wray        
   

fiwray   laird

although implementation evaluation dhj limited soar  attempted
reduce specificity results soar two ways  first  identified problems across level consistency knowledge introduces knowledge based approaches 
expensive develop  degrades modularity simplicity hierarchical representation  robust knowledge designers imagination  agents
developed sufficiently complex domains  expense creating knowledge grow
prohibitive  cost may lead additional researchers consider architectural assurances
consistency  second  dynamic hierarchical justification gains power via structure
hierarchically decomposed tasks  although specific implementations may differ
agent architectures  heuristic simplifications employed dhj transfer
architecture utilizing hierarchical organization memory task decomposition  dynamic hierarchical justification efficient  architectural solution ensures reasoning
consistency across hierarchy agents employing hierarchical task decompositions 
solution allows agents act reliably complex  dynamic environments
fully realizing low cost agent development via hierarchical task decomposition 

acknowledgments
work would possible without contributed directly
development evaluation dynamic hierarchical justification  scott huffman  john
laird mark portelli implemented assumption justification soar  ron chong implemented precursor dhj  randy jones  john laird  frank koss developed tacairsoar  sayan bhattacharyya  randy jones  doug pearson  peter wiemer hastings 
members soar group university michigan contributed development dynamic blocks world simulator  anonymous reviewers provided valuable 
constructive comments earlier versions manuscript  work supported
part university michigan rackham graduate school pre doctoral fellowship  contract n         k      advanced systems technology office darpa
nrl  contract n    i    c      advanced systems technology office
darpa naval command ocean surveillance center  rdt e division  portions work presented    th national conference artificial intelligence
madison  wisconsin 

appendix a  improving task decompositions
appendix describes detail changes made tas agent knowledge
dhj 
remembering  figure   showed agent computing new heading subtask
achieve proximity subtask  calculation usually depends upon current heading 
agent generates command turn  heading changes soon thereafter 
situation  dhj agent must remember already made decision turn
new heading placing assumption reflects new heading top level 
places assumption local level  new current heading trigger
removal turn to heading regeneration subtask  if agent determines
still needs turn new heading  
   

fiensuring consistency hierarchical execution

fhj agents  output commands  such turn specific heading 
asserted assumptions local subtask  dhj agents knowledge changed
issue output commands directly output interface  which  soar  always part
highest subtask hierarchy   unnecessary regeneration occurs
agent remembers motor commands generates new one different
output necessary  change  course  requires consistency knowledge
motor commands unjustified thus must explicitly removed  true
remembered knowledge dhj 
within level consistency knowledge  dynamic hierarchical justification  solutions across level consistency problem  still requires consistency knowledge within
individual subtask  knowledge fhj agents used remove intermediate results execution subtask  clean knowledge allows agent
remove local assertions contributed terminating subtask thus avoid
 mis use assertions later reasoning 
example  consider achieve proximity subtask  subtask used
number different situations agent needs get closer another agent 
wing strays far lead  may invoke achieve proximity get back
formation lead  lead uses achieve proximity get close enough enemy
aircraft launch missile  subtask requires many local computations agent
reasons heading take get closer another aircraft  specific
computation depends information available aircraft 
wing pursuing lead  may know leads heading thus calculate collision
course maximize rate convergence  sometimes agents heading
available  case  agent simply moves toward current location agent 
local computations stored local subtask  achieve proximity
terminated fhj agent  agent removes local structure  removing structure
important interrupts entailment local structure  e g   calculation
current collision course  guarantees agent decides achieve proximity
different aircraft  supporting data structures properly initialized  knowledge
thus maintains consistency local subtask removing local structure
achieve proximity subtask longer selected 
fhj agent could recognize going remove subtask  termination
conditions fhj agents acted signal within level consistency knowledge 
knowledge removes local structure achieve proximity summarized as 
achieve proximity operator selected  initiation conditions longer hold 
remove local achieve proximity data structure  thus  fhj agent uses
recognition inconsistency assertions trigger activation within level
consistency knowledge 
subtasks initiating conditions longer supported dhj agents 
selected subtask removed immediately  thus  dhj agent never opportunity
apply fhj agents within level consistency knowledge  failure utilize
knowledge led number problems  including regenerations expected 
solve problem  local subtask data structure created entailment
initiation conditions subtask itself  subtask initiation conditions
longer held  subtask selection local structure immediately removed
   

fiwray   laird

architecture  requiring additional knowledge  thus  change obviated need
within level consistency knowledge  however  local data structure may need
regenerated subtask temporarily displaced  instance  fhj within level
consistency knowledge could determine conditions local structure
removed  dhj solution lost flexibility 
subtasks complex actions  fhj agents execute number actions rapid
succession  regardless inconsistency local assertions  single subtask operator
initiated situation representing conditions apply first
action sequence  terminated last step sequence applied 
intermediate step invalidates initiation conditions  subtask still executes
actions 
consider process launching missile  actual missile launch requires
push button  assuming previous steps selecting target
appropriate missile accomplished beforehand  pushing fire button 
pilot must fly straight level seconds missile rockets ignite launch
missile flight  missile cleared aircraft  agent supports
missile keeping radar contact target  fhj agents  push fire button
subtask includes act pushing fire button counting missile clears
aircraft  tasks different mutually exclusive dependencies  initiation
condition push fire button requires missile already launched  however 
subsequent counting requires monitoring newly launched missile 
dhj agents using fhj knowledge base always remove push fire button subtask soon missile perceived air  interrupting complete procedure 
regeneration push fire button subtask occurs agent never waits
missile clear thus never realizes missile launched needs supported 
dhj agent unsuccessfully fires available missiles enemy plane 
pushing fire button waiting missile clear independent tasks
happen arise serial order domain  enforced independence
creating new subtask  wait for missile to clear  depends
newly launched missile air  dhj agent pushes fire button  selects
wait for missile to clear count seconds taking action 
supports missile clears successfully 
solution reduces regeneration improves behavior quality
non trivial cost  whenever subtask split  effects subtask actions longer occur
rapid succession within decision  instead  effect first subtask occurs one
decision  effect second subtask second decision  etc  thus  solution
compromise responsiveness 

references
agre  p  e     horswill  i          lifeworld analysis  journal artificial intelligence
research            
alchourron  c  e   gardenfors  p     makinson  d          logic theory change 
partial meet contraction revision functions  journal symbolic logic         
       
   

fiensuring consistency hierarchical execution

allen  j  f          time time again  international journal intelligent systems 
              
altmann  e  m     gray  w  d          forgetting remember  functional relationship
decay interference  psychological science           
bresina  j   drummond  m     kedar  s          reactive  integrated systems pose new
problems machine learning  minton  s   ed    machine learning methods
planning  pp          morgan kaufmann  san francisco  ca 
dechter  r          enhancement schemes constraint processing  backjumping  learning
cutset decomposition  artificial intelligence             
doyle  j          truth maintenance system  artificial intelligence             
doyle  j          reason maintenance belief revision  gardenfors  p   ed    belief
revision  pp        cambridge university press  cambridge  uk 
eiter  t     gottlob  g          complexity propositional knowledge base revision 
updates  counterfactuals  artificial intelligence             
erol  k   hendler  j     nau  d  s          htn planning  complexity expressivity 
proceedings   th national conference artificial intelligence  pp           
firby  r  j          investigation reactive planning complex domains  proceedings  th national conference artificial intelligence  pp         
forbus  k  d     dekleer  j          building problem solvers  mit press  cambridge 
ma 
forgy  c  l          efficient implementation production systems  ph d  thesis 
computer science department  carnegie mellon university 
gardenfors  p          knowledge flux  modeling dynamics epistemic states 
mit press  cambridge  ma 
gardenfors  p          belief revision  pettorossi  a   ed    meta programming logic 
springer verlag  berlin  germany 
gaschnig  j          performance measurement analysis certain search algorithms 
tech  rep  cmu cs         computer science department  carnegie mellon university  pittsburgh  pennsylvania 
gat  e       a   integrating planning reacting heterogeneous asynchronous architecture mobile robots  sigart bulletin          
gat  e       b   reliable  goal directed control autonomous mobile robots  ph d 
thesis  virginia polytechnic institute state university  blacksburg  va 
georgeff  m     lansky  a  l          reactive reasoning planning  proceedings
 th national conference artificial intelligence  pp         
graham  j     decker  k          towards distributed  environment centered agent framework  wooldridge  m     lesperance  y   eds    lecture notes artificial intelligence  agent theories  architectures  languages vi  atal      springer verlag 
berlin 
   

fiwray   laird

hanks  s   pollack  m     cohen  p  r          benchmarks  test beds  controlled experimentation design agent architectures  ai magazine           
hayes roth  b          architecture adaptive intelligent systems  workshop
innovative approaches planning  scheduling control  pp         
jones  r  m   laird  j  e   neilsen  p  e   coulter  k  j   kenny  p     koss  f  v         
automated intelligent pilots combat flight simulation  ai magazine               
kinny  d     georgeff  m          commitment effectiveness situated agents 
proceedings   th international joint conference artificial intelligence  pp 
     
kurien  j     nayak  p  p          back future consistency based trajectory
tracking  proceedings   th national conference artificial intelligence 
pp         
laird  j  e          knows going do  adding anticipation quakebot 
proceedings  th international conference autonomous agents  pp     
    
laird  j  e   congdon  c  b     coulter  k  j          soar users manual version     
manual  department electrical engineering computer science  university
michigan  http   ai eecs umiuch edu soar docs html 
laird  j  e   newell  a     rosenbloom  p  s          soar  architecture general
intelligence  artificial intelligence          
laird  j  e     rosenbloom  p  s          integrating execution  planning  learning
soar external environments  proceedings   th national conference
artificial intelligence  pp           
laird  j  e     rosenbloom  p  s          evolution soar cognitive architecture 
steier  d     mitchell  t   eds    mind matters  contributions cognitive
computer science honor allen newell  lawrence erlbaum associates  hillsdale 
nj 
mcdermott  d          general framework reason maintenance  artificial intelligence 
           
mitchell  t  m   allen  j   chalasani  p   cheng  j   etzioni  o   ringuette  m     schlimmer 
j  c          theo  framework self improving systems  vanlehn  k   ed   
architectures intelligence  chap      pp          lawrence erlbaum associates 
hillsdale  nj 
mitchell  t  m          becoming increasingly reactive  proceedings   th national
conference artificial intelligence  pp           
nebel  b     koehler  j          plan reuse versus plan generation  theoretical
empirical analysis  artificial intelligence             
newell  a          unified theories cognition  harvard university press  cambridge 
ma 
   

fiensuring consistency hierarchical execution

paolucci  m   shehory  o   sycara  k  p   kalp  d     pannu  a          planning component retsina agents  wooldridge  m     lesperance  y   eds    lecture notes
artificial intelligence  agent theories  architectures  languages vi  atal     pp          berlin  springer verlag 
pearson  d  j   huffman  s  b   willis  m  b   laird  j  e     jones  r  m         
symbolic solution intelligent real time control  robotics autonomous systems 
           
rao  a  s     georgeff  m  p          modeling rational agents within bdi architecture 
proceedings  nd international conference principles knowledge representation reasoning  pp         
russell  s     norvig  p          artificial intelligence  modern approach  prentice hall 
upper saddle river  nj 
sacerdoti  e  d          nonlinear nature plans  proceedings   th international joint conference artificial intelligence  pp         
schut  m     wooldridge  m          intention reconsideration complex environments 
proceedings  th international conference autonomous agents  pp         
schut  m     wooldridge  m          principles intention reconsideration  proceedings
 th international conference autonomous agents  pp         
shoham  y          agent oriented programming  artificial intelligence               
simon  h  a          sciences artificial  mit press  cambridge  ma 
stallman  r  m     sussman  g  j          forward reasoning dependency directed
backtracking system computer aided circuit analysis  artificial intelligence 
              
sycara  k   decker  k   pannu  a   williamson  m     zeng  d          distributed intelligent agents  ieee expert               
tambe  m          eliminating combinatorics production match  ph d  thesis 
carnegie mellon university   also published technical report cmu cs        
computer science department  carnegie mellon university   
tambe  m   johnson  w  l   jones  r  m   koss  f   laird  j  e   rosenbloom  p  s    
schwamb  k          intelligent agents interactive simulation environments  ai
magazine               
veloso  m  m   pollack  m  e     cox  m  t          rationale based monitoring planning dynamic environments  proceedings   th international conference
artificial intelligence planning systems  pp         
wilkins  d  e   myers  k  l   lowrance  j  d     wesley  l  p          planning reacting
uncertain dynamic environments  journal experimental theoretical
artificial intelligence                
wooldridge  m          reasoning rational agents  mit press  cambridge  ma 
wray  r  e          ensuring reasoning consistency hierarchical architectures  ph d 
thesis  university michigan  published university michigan technical
report cse tr        
   

fiwray   laird

wray  r  e     laird  j          maintaining consistency hierarchical reasoning 
proceedings   th national conference artificial intelligence  pp         
wray  r  e   laird  j     jones  r  m          compilation non contemporaneous constraints  proceedings   th national conference artificial intelligence  pp 
       
wray  r  e   laird  j  e   nuxoll  a     jones  r  m          intelligent opponents virtual
reality trainers  proceedings interservice industry training  simulation
education conference  i itsec       

   


