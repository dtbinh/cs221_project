journal of artificial intelligence research                  

submitted        published      

compiling causal theories to successor state axioms and
strips like systems
fangzhen lin

flin cs ust hk

department of computer science
the hong kong university of science and technology
clear water bay  kowloon  hong kong

abstract
we describe a system for specifying the effects of actions  unlike those commonly
used in ai planning  our system uses an action description language that allows one to
specify the effects of actions using domain rules  which are state constraints that can
entail new action effects from old ones  declaratively  an action domain in our language
corresponds to a nonmonotonic causal theory in the situation calculus  procedurally  such
an action domain is compiled into a set of logical theories  one for each action in the domain 
from which fully instantiated successor state like axioms and strips like systems are then
generated  we expect the system to be a useful tool for knowledge engineers writing action
specifications for classical ai planning systems  golog systems  and other systems where
formal specifications of actions are needed 

   introduction
we describe a system for generating action effect specifications from a set of domain rules
and direct action effect axioms  among other things  we expect the system to be a useful
tool for knowledge engineers writing action specifications for classical ai planning systems 
golog systems  levesque et al          and other systems where formal specifications of
actions are needed 
to motivate  consider the language used by strips  fikes   nilsson        for describing the effects of actions  briefly speaking  an action is described in this language by
a first order formula  called its precondition that describes the condition under which the
action is executable  an add list that enumerates the propositions that the action will make
true when successfully executed in a situation  and a delete list that enumerates the propositions that the action will make false when successfully executed in a situation  while the
original strips allowed the precondition and the elements of the two lists to be complex
formulas  strips actions now refer only to those whose precondition is given by a conjunction of atomic formulas and whose add and delete lists are lists of atomic formulas 
it is widely acknowledged that this language is inadequate for describing actions in the
real world  one of the limitations  the one that we address in this paper  is that with the
language  one has to enumerate all possible effects of an action  a difficult if not impossible
task for complex domains  for example  given a large c program  it is hard to figure out the
effects of changing the value of a pointer on the values of all other pointers in the program 
however  the underlying principle is very simple  when the value of a pointer changes  the
values of all other pointers that point to the same memory location change as well  put
another way  the direct effect of the action of changing the value of a pointer to x is that the
c
    
ai access foundation and morgan kaufmann publishers  all rights reserved 

filin

value of the pointer will be x  the indirect or side effects of this action are those derived
from the constraint which says that if two pointers point to a common location  then their
values must be the same 
this idea of specifying the effects of actions using domain constraints is like engineering
from first principle  and has many advantages  first of all  constraints are action independent  and work on all actions  secondly  if the effects of actions derived from domain
constraints agree with ones expectation  then this will be a good indication that one has
axiomatized the domain correctly  finally  domain constraints can be used for other purposes as well  for instance  they can be used to check the consistency of the initial situation
database  in general  when a set of sentences violates a domain constraint  we know that no
legal situation can satisfy this set of sentences  this idea can and has been used in planning
to prune impossible states  recently  there have even been efforts at reverse engineering
domain constraints from strips like systems to speed up planners  e g  zhang   foo 
      gerevini   schubert        fox   long        and others  
while it is appealing to use domain constraints to derive the indirect effects of actions 
making the idea work formally turned out to be a challenge  the problem is commonly
known as the ramification problem  and various proposals have been made to solve it  until
recently  however  these proposals were at best of theoretical interest only because of their
high computational complexity  the situation has since changed substantially due to the
use of causality in representing domain constraints  lin              mccain   turner 
            thielscher              baral        lifschitz        and others   what we will
describe in this paper is an implemented system that builds on this recent work on causalitybased approaches to the ramification problem  specifically  our system takes as input an
action domain description where actions are described by their precondition axioms and
direct effect axioms  and domain constraints are represented by what we call domain rules 
the system returns as output a complete action specification both in strips like format
and as a set of fully instantiated successor state axioms  reiter        
this paper is organized as follows  we begin by introducing our action description language  we then propose a procedure to compile an action domain specified in this language
into a complete set of successor state axioms from which a strips like description is then
extracted  we then show the soundness of this procedure with respect to a translation from
action domain descriptions to situation calculus causal theories of lin         we next
describe an implementation of this procedure  and present some experimental results  as
one will see  one of the limitations of our system is that it is essentially propositional  while
effect axioms and domain rules can have variables  they need to be fully instantiated during
the compilation process  to partially overcome this limitation  we show some results that
allow one to generalize the propositional output to the first order case for certain classes of
action domain descriptions  we then discuss some related work  and conclude this paper
with some pointers for future work 

   an action description language
we assume a first order language with equality  we shall call those predicates whose extensions may be changed by actions fluents  and those whose extensions are not changed by
any actions static relations  we also call unary static relations types  by fluent atoms we
   

fifrom causal theories to strips like systems

mean those atomic formulas formed by fluents  an equality atom is one of the form u   v 
where u and v are variables or constants  and an inequality constraint is one of the form
u    v  actions are represented by functions  and they are assumed to be the only functions
with positive arities in the language 
our action description language includes the following components 
    type definitions
a type definition is specified by expressions of the following form 
domain p   a         an    
where p is a type  and a         an are constants  the intuitive meaning of this expression is
that the domain  extension  of the type p is the set  a         an    for instance  in the blocks
world  we may have a type called block  and have  say  five blocks named numerically 
domain block                    in a logistics domain  we may have a type called loc for
locations  and have  say    locations l    l    and l    domain loc   l    l    l     
    primitive fluent definitions
primitive fluents are defined by expressions of the following form 
fluent f  x         xn    p   x         pn  xn    e       em   
where f is an n ary fluent  each pi      i  n  a type  and each ei      i  m  an
inequality constraint of the form xj    xk   for some    j   k  n  the intuitive meaning
of this expression is that f  x         xn   is a legal fluent atom if the second argument is true 
for instance  in the blocks world  given the type definition domain block              the
following fluent specification 
fluent on x  y   block x   block y   x    y 
would generate the following six legal fluent atoms 
on        on        on        on        on        on       
clearly  there should be exactly one fluent definition for each fluent 
    complex fluent definitions
given a set of primitive fluents  one may want to define some new ones  for instance 
in the blocks world  given the primitive fluent on  we can define clear in terms of on as 
 x clear x    y on y  x  
to specify complex fluents like clear  we first define fluent formulas as follows 
 t    t  is a fluent formula  where t  and t  are terms  i e  either a constant in the
domain of a type or a variable 
 f  t         tn   is a fluent formula  where t         tn are terms  and f is either an n ary
primitive fluent  a complex fluent  or a static relation 
   

filin

 if  and   are fluent formula  then                     and     are also
fluent formulas 
 if  is a fluent formula  x a variable  and p a type  then  x  p   for all x of type p 
 holds  and  x  p   for some x of type p   holds  are fluent formulas  notice that
we require types to have finite domains  so these quantifications are really shorthands 
if the domain of p is  a         an    then  x  p  stands for
 x a          x an   
and  x  p  stands for
 x a          x an   
a complex fluent is then specified in our language by a pair of expressions of the following
form 
complex f  x         xn    p   x         pn  xn    e      em   
defined f  x         xn      
where pi s and ei s are the same as in primitive fluent definitions  and  a fluent formula
that does not mention any complex fluents and whose free variables are among x         xn  
the first expression specifies the syntax and the second the semantics of the complex fluent 
for instance  the complex fluent clear in the blocks world can be specified as 
complex clear x   block x   
defined clear x    y  block on y  x   
as we mentioned above  quantifiers here are just shorthands because each type must have
a finite domain  for instance  given the following specification 
domain block             
fluent on x  y   block x   block y  
the above fluent definition for clear will be expanded to 
defined clear      on        on        on         
defined clear      on        on        on         
defined clear      on        on        on         
    static relation definitions
as we mentioned  a static relation is one that is not changed by any action in the domain 
for instance  in the robot navigation domain  we may have a proposition connected d  r   r  
meaning that door d connects rooms r  and r   the truth value of this proposition cannot
be changed by the navigating robot that just rolls from room to room 
in our language  a static relation is defined by an expression of the following form 
static g x         xn    p   x         pn  xn    e       em   
where g is an n ary predicate  and pi s and ei s are the same as in primitive fluent definitions 
the meaning of this expression is similar to a fluent definition  and there should be exactly
one definition for each static relation 
   

fifrom causal theories to strips like systems

    domain axioms
domain axioms are constraints on static relations  for instance  for the static proposition
connected d  r   r    we may want to impose the following constraint  connected d  r   r   
connected d  r   r    in our language  domain axioms are specified by expressions of the
form 
axiom   
where  is a fluent formula that does not mention any fluents  i e  it mentions only static
relations and equality  for instance  the above constraint on connected is written as 
axiom  d  door  r    room  r    room connected d  r    r    
connected d  r    r     
where door and room are types 
    action definitions
actions are defined by expressions of the following form 
action a x         xn    p   x         pn  xn    e       em   
where a is an n ary action  and pi s and ei s are the same as in primitive fluent definitions 
for instance  in the blocks world  given the type definition domain block              the
following action specification 
action stack x  y   block x   block y   x    y 
would generate the following six action instances 
stack        stack        stack        stack        stack        stack       
there should be exactly one action definition for each action 
    action precondition definitions
action precondition definitions are specified by expressions of the following form 
p recond a x         xn      
where a is an n ary action   is a fluent formula whose free variables are among x         xn  
there should be exactly one precondition definition for each action  for instance  in the
blocks world  we may have 
p recond stack x  y   clear x   clear y   ontable x   
which says that for the action stack x  y  to be executable in a situation  clear x   clear y  
and ontable x  must be true in it 
   

filin

    action effect specifications
action effects are specified by expressions of the following form 
effect a x         xn      f  y         yk    
or of the form 
effect a x         xn      f  y         yk    
where  is a fluent formula  and f a primitive fluent  the intuitive meaning of these
expressions is that if  is true in the initial situation  then action a x         xn   will cause
f  y         yk   to be true  false   for instance  in the blocks world  action stack x  y  causes
x to be on y 
effect stack x  y   true  on x  y   
for an example of a context dependent effect  consider action drop x  that breaks an object
only if it is fragile 
effect drop x   f ragile x   broken x   
notice here that the fluent formula  in the action effect specifications can have variables that are not in x         xn   y         yk   informally  all the variables are supposed to be
universally quantified  more precisely  when these expressions are instantiated  one can
substitute any objects for these variables  provided the resulting formulas are well formed 
for instance  given the action effect specification effect move x   g x     q x    x     f  y   
one can instantiate it to  effect move a   g b   q b  c   f  d    as long as move a  is a legal
action  according to the action definition for move  and g b   q b  c   and f  d  are legal
fluent atoms  according to the fluent definitions for g  q  and f   
    domain rules
domain rules are specified by expressions of the following form 
causes   f  x         xn    
or of the following form 
causes   f  x         xn    
where  is a fluent formula  and f a primitive fluent  like action effect specifications  
here can have variables that are not in x         xn   the intuitive meaning of a domain rule
is that in any situation  if  holds  then the fluent atom f  x         xn   will be caused to be
true  a domain rule is stronger than material implication  its formal semantics is given
by mapping it to a causal rule of lin         see section     thus the name causes  for
instance  in the blocks world  a block can be on only one other block 
causes on x  y   y    z  on x  z   
in a logistics domain  one may want to say that if a package is inside a truck which is at
location l  then the package is at location l as well 
causes in x  y   at y  l   at x  l   
   

fifrom causal theories to strips like systems

     action domain descriptions
the following definition sums up our action description language 
definition   an action domain description is a set of type definitions  primitive fluent
definitions  complex fluent definitions  static proposition definitions  domain axioms  action
definitions  action precondition definitions  action effect specifications  and domain rules 
example   the following action domain description defines a blocks world with three
blocks 
domain block             
fluent on x  y   block x   block y   
fluent ontable x   block x   
complex clear x   block x   
defined clear x    y  block on y  x   
causes on x  y   x    z  on z  y   
causes on x  y   y    z  on x  z   
causes on x  y   ontable x   
causes ontable x   on x  y   
action stack x  y   block x   block y   x    y  
p recond stack x  y   ontable x   clear x   clear y   
effect stack x  y   true  on x  y   
action unstack x  y   block x   block y   x    y  
p recond unstack x  y   clear x   on x  y   
effect unstack x  y   true  ontable x   
action move x  y  z   block x   block y   block z   x    y  x    z  y    z  
p recond move x  y  z   on x  y   clear x   clear z   
effect move x  y  z   true  on x  z   

   a procedural semantics
given an action domain description d  we use the following procedure called ccp  causal
completion procedure  to generate a complete action effect specification 
   use primitive and complex fluent definitions to generate all legal fluent atoms  in the
following let f be the set of fluent atoms so generated 
   use action definitions to generate all legal action instances  and for each such action
instance a do the following 
   

filin

     for each primitive fluent atom f  f  collect all ground instances  of as positive
effects 
effect a      f         effect a  n   f   
all ground instances of as negative effects 
effect a      f         effect a  m   f   
all ground instances of positive domain rules 
causes      f         causes  k   f   
all ground instances of negative domain rules 
causes      f         causes  l   f   
and generate the following pseudo successor state axiom 
succ f    init          init n    succ           succ  l   
init f     init          init m   
succ           succ  k    

   

where for any fluent formula   init   is the formula obtained from  by replacing every fluent atom f in  by init f    and similarly succ   is the formula
obtained from  by replacing every fluent atom f in  by succ f    intuitively 
init f   means that f is true in the initial situation  and succ f   that f is true
in the successor situation of performing action a in the initial situation 
     let succ be the set of pseudo successor state axioms  one for each primitive
fluent f   generated by the last step  succ  the following set of axioms 
succ     succ f    succ     defined f    is a complex fluent definition  
and init the following set of axioms 
init       axiom   is a domain axiom  
 init    init f     causes   f   is a domain rule  
 init    init f     causes   f   is a domain rule  
 init f    init     defined f    is a complex fluent definition  
 init a     p recond a  a   is the precondition definition for a  
for each fluent atom f   if there is a formula f such that
init  succ  succ     succ f    f  
and f does not mention propositions of the form succ f    then output the
axiom
succ f    f  
   when generating ground instances  all shorthands like  x  p  are expanded  see the definition of fluent
formulas in the last section 

   

fifrom causal theories to strips like systems

otherwise  the action as effect on f is indeterminate  in this case  output two
axioms 
succ f    f  
f  succ f   
where f is a strongest formula satisfying the first implication  and f a weakest
formula satisfying the second implication  in the following  to be explicit about
the action a for which we are computing its effects  we will write the axioms as
succa   inita   and succ a  
conceptually  step     in the above procedure is most significant  in the next section 
we shall prove that this step is provably correct under a translation to the situation calculus
causal theories of lin         computationally  step     is the most expensive  we shall
describe the strategies that our system uses to implement it in section   
for this procedure to work properly  the action domain description should satisfy the
following conditions 
   we require that all fluent atoms in init  succ  and succ  be among those generated
in step    this would rule out cases like
fluent on x  y   block x   block y   x    y 
together with defined clear x    y  block on y  x    as the latter would generate
fluent atoms of the form on x  x  which are ruled out by the fluent definition for on 
here one could either drop the inequality constraint in the definition of on or change
the complex fluent definition into defined clear x    y  block  on y  x   x    y   
we could have built in a test in our procedure above to reject an action domain
description with incoherent fluent definitions like this  one easy way of making sure
this does not happen is not to use inequality constraints in the definition of fluents 
   as we mentioned above  for each action there should be exactly one action precondition that captures exactly the conditions under which the action is executable 
when the action precondition is given explicitly like this  one needs to be careful
in writing action effect axioms and domain rules so that no contradictory effects
would be generated  for instance  given p recond a  true   the action effect axioms
effect a  true  f   and effect a  true  f   are clearly not realizable simultaneously 
similarly  if causes true  f   is given as a domain rule  then one should not write the
effect axiom effect a  true  f    had we not insisted that a be always executable  we
could simply conclude that a is not executable when its effect axioms are in contradiction or when some of its effect axioms contradict domain rules  it remains future
work to extend our procedure to allow for automatic generation of these implicitly
given action preconditions  for now  we shall assume that the given action domain
specification is consistent in the sense that for each action instance a generated in
step    the following theory
init  succ  succ    init    succ f    
effect a    f   is a ground instance of effect axiom 
   

filin

is consistent 
   on a related point  our procedure assumes that information about the initial situation
is given by init  in particular  action effect axioms should not entail any information about the initial situation  for instance  given causes q  p   effect a  true  p  
and p recond a  true   it must be that in the initial situation  q cannot be true  for
otherwise  it will persist into the next situation  causing p to be false  which contradicts the action effect  formally  this means that given any set i of atoms of the
form init f    where f is a primitive fluent atom  if i  i   init is consistent  then
i i  succsucc  is also consistent  where i    the complement of i  is the following
set 
 init f     init f     i and
f is a primitive fluent atom generated by step   
notice that for a similar reason  reiter needed what he called the consistency assumption in order for his completion procedure to be sound and complete for generating
successor state axioms  reiter        
while our action domain descriptions are clearly targeted at specifying deterministic actions 
some indeterminate effects can sometimes arise from cyclic domain rules  for instance 
consider the following action domain description 
causes p  p  
p recond a  true 
for action a  init is a tautology  succ  is empty  and succ consists of the following pseudosuccessor state axiom for p 
succ p   succ p   init p  
which is equivalent to init p   succ p   so if initially p is true  then after a is performed 
we know that p will continue to be true  but if p is initially false  then after a is performed 
we do not know if p is true or not 
example   consider the blocks world description in example    the set of fluent atoms
generated by step   is 
f    on        on        on        on        on        on       
on        on        on        clear     clear     clear    
ontable     ontable     ontable     
step   generates the following action instances 
stack        stack        stack        stack        stack        stack       
unstack        unstack        unstack        unstack        unstack       
unstack        move           move           move           move          
move           move         
   

fifrom causal theories to strips like systems

for each of these action instances  we need to go through steps     and      for instance 
for stack        there is only one effect axiom about on       
effect stack        true  on        
and the following causal rules about on       
causes on        on        
causes on        on        
causes on        on        
causes on        on        
causes ontable     on        
therefore step     generates the following pseudo successor state axiom for on       
succ on         true 
init on          succ on         succ on        
succ on         succ on        succ ontable      
we can similarly generate the following pseudo successor state axioms for the other primitive
fluent atoms 
succ on         init on          succ on         succ on        
succ on         succ on        succ ontable      
succ on         init on          succ on         succ on        
succ on         succ on         succ ontable      
succ on         init on          succ on         succ on        
succ on         succ on         succ ontable      
succ on         init on          succ on         succ on        
succ on        succ on         succ ontable      
succ on         init on          succ on         succ on        
succ on        succ on         succ ontable      
succ on         init on          succ on         succ on        
succ on        succ on         succ ontable      
succ on         init on          succ on         succ on        
succ on        succ on         succ ontable      
succ on         init on          succ on         succ on        
succ on        succ on         succ ontable      
succ ontable     
init ontable       succ on         succ on         succ on         
succ ontable     
init ontable       succ on         succ on         succ on         
   

filin

succ ontable     
init ontable       succ on         succ on         succ on         
for the complex fluent clear  its definition yields the following axioms 
succ clear      succ on         succ on         succ on        
succ clear      succ on         succ on         succ on        
succ clear      succ on         succ on         succ on        
we can then solve these pseudo successor state axioms and generate the following successor state axioms 
succ on         f alse
succ on         f alse
succ on         f alse
succ on         f alse
succ on         init on       
succ ontable      init ontable    
succ clear      init clear    
succ clear      init clear    

succ on         true
succ on         f alse
succ on         init on       
succ on         f alse
succ ontable      f alse
succ ontable      init ontable    
succ clear      f alse

once we have a set of these fully instantiated successor state axioms  we then generate
strips like descriptions like the following 
stack      
preconditions 
add list 
delete list 
cond  effects 
indet  effects 

ontable     clear     clear    
on       
ontable     clear    
none 
none 

stack      
preconditions 
add list 
delete list 
cond  effects 
indet  effects 

ontable     clear     clear    
on      
ontable     clear    
none 
none 

   

fifrom causal theories to strips like systems

we have the following remarks 
 although we generate the axiom succ on         f alse for stack        we do not put
on       into its delete list  this is because we can deduce init on         f alse from
init as well  a fluent atom is put into the add or the delete list of an action only if
this fluent atoms truth value is definitely changed by the action  see section   for
more details about how a strips like description is generated from successor state
axioms 
 as one can see  our ccp procedure crucially depends on the fact that each type has
a finite domain so that all reasoning can be done in propositional logic  this is a
limitation of our current system  and this limitation is not as bad as one might think 
first of all  typical planning problems all assume finite domains  and changing the
domain of a type in an action description is easy   all one needs to do is to change the
corresponding type definition  more significantly  a generic action domain description
can often be obtained from one that assumes a finite domain  in our blocks world
example  the numbers       and   are generic names  and can be replaced by
parameters  for instance  if we replace   by x and   by y in the above stripslike description of stack        we will get a strips like description for stack x  y 
that works for any x and y  we have found that this is a strategy that often works in
planning domains 

   formal semantics
the formal semantics of an action domain description is defined by translating it into a
situation calculus causal theory of lin         we shall show that the procedure ccp given
above is sound under this semantics 
this section is mainly for those who are interested in nonmonotonic action theories  for
those who are interested only in using our action description language for describing action
domains  this section can be safely skipped 
we first briefly review the language of the situation calculus 
    situation calculus
the language of the situation calculus is a many sorted first order language  we assume the
following sorts  situation for situations  action for actions  fluent for propositional fluents 
truth value for truth values true and f alse  and object for everything else 
we use the following domain independent predicates and functions 
 binary function do   for any action a and any situation s  do a  s  is the situation
resulting from performing a in s 
 binary predicate h   for any p and any situation s  h p  s  is true if p holds in s 
 binary predicate p oss   for any action a and any situation s  p oss a  s  is true if a is
possible  executable  in s 
 ternary predicate caused   for any fluent atom p  any truth value v  and any situation
s  caused p  v  s  is true if the fluent atom p is caused  by something unspecified  to
have the truth value v in the situation s 
   

filin

in the last section  we introduced fluent formulas  we now extend h to these formulas 
for any fluent formula  and situation s  h   s  is defined as follows 
 h t    t    s  is t    t   
 if p is a static proposition  then h p  s  is p  
 inductively  h   s  is h   s   h       s  is h   s   h     s   and similarly for
other connectives 
 inductively  h  x  p   s  is x  p x   h   s   and h  x  p   s  is x  p x  
h   s   
according to this definition  h   s  will be expanded to a situation calculus formula where
h is applied to fluents 
    a translation to the situation calculus
given a first order language l for writing action domain descriptions  we assume that there
will be a corresponding language l  for the situation calculus such that constants in l
will be constants of sort object in l    types in l will be types  unary predicates  in l   
static relations will be predicates of the same arities in l    fluents in l will be functions
of sort f luent in l    and actions in l will be functions of sort action in l    under these
conventions  the following translation will map an action domain description to a situation
calculus theory 
let d be an action domain description  the translation of d into a situation calculus
theory is defined as follows 
 a type definition domain p   a         ak    is translated to 
 x  p x    x   a       x   ak   
a     a           ak  
 a primitive fluent definition
fluent f  x         xn    p   x         pn  xn    e       em  
is translated to
 x         xn   fluent f  x         xn     p   x         pn  xn    e       em  
 a complex fluent definition
complex f  x         xn    p   x         pn  x   e      em   
defined f  x         xn      
is translated to
 x         xn   fluent f  x         xn     p   x         pn  x   e      em  
 x         xn   s  fluent f  x         xn      h f  x         xn    s   h   s   
   

fifrom causal theories to strips like systems

 a domain axiom about static propositions 
axiom  
is translated to  with quantifiers in it treated as shorthands 
 x  p    x p x    
 x  p    x p x    
 an action definition
action a x         xn    p   x         pn  xn    e       em  
is translated to
 x         xn   action a x         xn     p   x         pn  xn    e       em  
we assume here that the domain description has only one action definition for each
action 
 an action precondition axiom
p recond a x         xn     
is translated to
  s  action a x         xn      p oss a x         xn    s   h   s   
  
where   is the list of all free variables in a x         xn   and   we mentioned earlier
that one of the limitations of our current system is that action preconditions have to
be given explicitly  this is reflected in the above translation 
 an action effect axiom 
effect a x         xn      f  y         yk    
is translated to
  s  action a x         xn     fluent f  y         yk     p oss a x         xn    s  
  
 h   s   caused f  y         yk    true  do a x         xn    s    
where   is the list of all free variables in a x         xn    f  y         yk    and  
similarly  an effect axiom
effect a x         xn      f  y         yk    
is translated to
  s  action a x         xn     fluent f  y         yk     p oss a x         xn    s  
  
 h   s   caused f  y         yk    f alse  do a x         xn    s    
   

filin

 a domain rule of the form
causes   f  x         xn   
is translated to
 
   fluent f
 x         xn      s  h   s   caused f  x         xn    true  s   
where   is the list of all free variables in f  x         xn   and   similarly  a domain rule
of the form
causes   f  x         xn   
is translated to
 
   fluent f
 x         xn      s  h   s   caused f  x         xn    f alse  s   
now given an action domain description d  let t be its translation in the situation
calculus  the semantics of t is then determined by its completion comp t   that is defined
as the set of following sentences 
   the circumscription of caused in t with all other predicates fixed 
   the following basic axioms about caused that says that if a fluent atom is caused to
be true  false   then it is true  false  
caused p  true  s   holds p  s  

   

caused p  f alse  s   holds p  s  

   

   for the truth values  the following unique names and domain closure axiom 
true    f alse   v  v   true  v   f alse  

   

   the unique names assumptions for fluents and actions  specifically  if f        fn are
all the fluents  then we have 
fi   x     fj   y    i and j are different 
fi   x    fi   y     x    y  
similarly for actions 
   for each primitive fluent atom f   the following generic successor state axiom 
a  s p oss a  s   h f  do a  s   

   

 caused f  true  do a  s    h f  s   caused f  f alse  do a  s    
   the foundational axioms  lin   reiter      b  for the discrete situation calculus 
these axioms characterize the structure of the space of situations  for the purpose
of this paper  it is enough to mention that they include the following unique names
axioms for situations 
s    do a  s  
do a  s    do a    s      a   a   s   s    
   

fifrom causal theories to strips like systems

the following theorem shows that the procedural semantics given in the previous section
is sound with respect to the semantics given here 
theorem   let d be an action domain description  and t its translation in the situation
calculus  let a be any ground action instance  s a situation variable  and  s  a situation
calculus formula that satisfies the following two conditions     it contains at most the two
situation terms s and do a  s   and     it does not mention any predicate other than h 
equality  and static relations  let  be obtained from  by replacing each h f  s  in it by
init f    and each h f  do a  s   in it by succ f    then
comp t      s p oss a  s    s 

   

init  succ  succ      

   

if
where init  succ  and succ  are the sets of axioms generated for a according to the procedure in section  
proof  suppose s is a situation and m is a model of comp t     p oss a  s    construct
ms a as follows 
 the domain of ms a is the object domain of m  
 the interpretations of non situational function and predicate symbols in ms a are the
same as those in m  
 for any fluent atom f   ms a    init f   iff m    h f  s  and ms a    succ f   iff
m    h f  do a  s   
clearly  m     s  iff ms a      we show below that ms a is a model of the left hand
side of      from this  we see that if      then     
notice first that a ground fluent atom f is generated by the procedure ccp iff fluent f  
is true in m   notice also that all fluent atoms in init  succ  succ  must be generated by
the procedure 
we show first that ms a is a model of init 
   if axiom   is a domain axiom  then  is in t   thus m satisfies   since  has no
fluent symbols in it  ms a satisfies it too 
   if causes   f  x         xn    is a domain rule  then
 
   fluent f
 x         xn      s  h   s   caused f  x         xn    true  s  
is in t   thus m satisfies
 
   fluent f
 x         xn      s  h   s   h f  x         xn    s   
thus if init       init f   is a corresponding formula in init  where    and f is
some ground instantiation of  and f  x         xn    respectively  then fluent f   must
be true in m  otherwise the above formula would not be in init   so m satisfies
h      s   h f  s   by the construction of ms a   it satisfies init       init f    the
case for causes   f   is similar 
   

filin

   suppose defined f    is an instantiation of a complex fluent definition such that
f   is in init  for it to be in init  fluent f   must be true  thus m must satisfy
h f  s   h   s   by the construction of ms a   it satisfies init f    init   s  
   suppose p recond a  a   is the precondition axiom for a  since m satisfies p oss a  s 
and action a   because a is one of the action instances generated by the procedure  
thus m satisfies h a   s   so ms a satisfies init a   
we now show that ms a is a model of succ  that is  for each primitive fluent atom f
generated by the procedure in step    the pseudo successor state axiom     holds  referring
to the notation in the axiom  we need to show that m satisfies the following formula 
h f  do a  s    h     s       h n   s  
h      do a  s        h  l   do a  s   
h f  s    h     s       h m   s  
h      do a  s        h  k   do a  s    
first of all  instantiating the generic successor state axiom     over a and s  we get 
p oss a  s   h f  do a  s   
 caused f  true  do a  s    h f  s   caused f  f alse  do a  s    
since m is a model of p oss a  s   we have
h f  do a  s   

   

 caused f  true  do a  s    h f  s   caused f  f alse  do a  s    
now consider the circumscription of caused in t with all other predicates fixed  notice that
all axioms about caused in t have the form w  caused x  y  z   where w is a formula
that does not mention caused  therefore the circumscription of caused is equivalent to
the predicate completion of caused  suppose f is f  t   and that all of the axioms about
caused f  x   v  s  in t are as follows 
w   caused f  x   v  s        wi  caused f  x   v  s  
because of the unique names axioms about fluents  the result of predicate completion on
caused will entail 
caused f  x   v  s   w       wi  
now w       wi are from action effect axioms and domain rules about f   by the way that
    is generated  and noting that action a   fluent f    and p oss a  s  are true  one can
see that when the above equivalence is instantiated by replacing t for x  true for v  and s
for s  we will get
caused f  true  do a  s    h     s       h n   s  
h      do a  s        h  l   do a  s   
   

fifrom causal theories to strips like systems

similarly  we have the following axiom about caused f  f alse  do a  s   
caused f  f alse  do a  s    h     s       h m   s  
h      do a  s        h  k   do a  s   
from these two axioms and      we get 
h f  do a  s    h     s       h n   s  
h      do a  s        h  l   do a  s   
h f  s    h     s       h m   s  
h      do a  s        h  k   do a  s    
since m is a model of comp t    m satisfies the above formula  by the construction of
ms a   it satisfies the pseudo successor state axiom     
finally  the fact that ms a is a model of succ  should be apparent 
 
in general      does not imply      there are several reasons 
 as we mentioned after the procedure ccp  we assume that all information about the
initial situation is given by init 
 our procedure works on actions one at a time  the situation calculus theory t
captures the effects of all actions in a single theory  so it is possible that a bad specification of an action causes the entire theory to become inconsistent  for instance 
if we have causes true  p   p recond a  true   and effect a  f alse  p   then the corresponding situation calculus theory will be inconsistent because of action a  but for
our procedure  it will generate an inconsistent theory only on a 

   an implementation
except for step      the procedure ccp in section   is straightforward to implement  this
section describes the strategy that our system uses for implementing step      the main
idea comes from the work of lin      a  on strongest necessary and weakest sufficient
conditions 
given a propositional theory t   a proposition q  and a set b of propositions  a formula
 is said to be a sufficient condition of q on b under t if  consists of propositions in b
and t      q  it is said to be the weakest sufficient condition if for any such sufficient
condition     we have that t         similarly  a formula  is said to be a necessary
condition of q on b under t if  consists of propositions in b and t    q    it is said
to be the strongest necessary condition if for any such necessary condition     we have that
t         
it is easy to see that the weakest sufficient condition and the strongest necessary condition are unique up to logical equivalence under the background theory  it was shown  lin 
    a  that these two notions are closely related  and can be computed using the technique
of forgetting  lin   reiter      a   in particular  for action theories  an effective strategy is to first compute the strongest necessary condition  add it to the background theory 
   

filin

and then compute the weakest sufficient condition under the new theory  this strategy is
justified by the following proposition lin      a  
proposition   let t be a theory  q a proposition  and b a set of propositions  if  is a
necessary condition of q on b under t   and  the weakest sufficient condition of q on b
under t      then    is the weakest sufficient condition of q on b under t  
we can now describe our strategy for implementing step     of the procedure ccp  in
the following  given an action instance a  as in step      let succ be the set of pseudosuccessor state axioms for primitive fluent atoms  succ  the set of pseudo successor state
axioms for complex fluent atoms  and init the set of initial situation axioms derived from
the action precondition axiom for a  domain axioms  domain rules  and complex fluent
definitions  also in the following  a succ proposition is one of the form succ f    and an
init proposition is one of the form init f   
   transform init into a clausal form and derive from it a set of unit clauses u nit 
   use u nit to simplify the axioms in succ and for each resulting axiom in it 
succ f    f  

   

if f does not mention succ propositions  then delete it from succ  output it and
replace succ f   in the rest of the axioms by f  
   for each fluent atom f whose pseudo successor state axiom     is in succ  if f has
the form init f         a candidate of a frame axiom   then check to see if succ f   can
be derived from succ  u nit  and init f   by unit resolution  if so  delete it from succ 
output succ f    init f    and replace succ f   in succ by init f   
   for each fluent atom f whose pseudo successor state axiom     is in succ  compute
the strongest necessary condition f of succ f   on the init propositions under the
theory init  succ  and the weakest sufficient condition f of succ f   on the initpropositions under the theory  f    init  succ  if f is a tautology  then delete
    from succ  output succ f    f   and replace succ f   in succ by f   if  is not
a tautology  then output succ f    f and f  f  succ f    but do not delete    
from succ  the correctness of this step follows from proposition   
   the previous steps solve the equations in succ  and generate appropriate output for
primitive fluent atoms  for each complex fluent atom f  
defined f    
if every primitive fluent atom in  has a successor state axiom  then do the following 
 a  if no primitive fluent atoms in  are changed by the action  then this complex
fluent atom is not changed by the action either  so output succ f    init f   
 b  otherwise  output succ f      where  is obtained from succ   by replacing
every succ proposition in it by the right side of its successor state axiom 
   

fifrom causal theories to strips like systems

otherwise  if some of the primitive fluent atoms in  do not have a successor state
axiom  which means the action may have an indeterminate effect on them  then this
action may have an indeterminate effect on f as well  compute the strongest necessary and weakest sufficient conditions of succ f   under init  succ  succ  as in the
last step  and output them 
   this step will try to generate a strips like description for the action instance a
based on the results of steps   and    for each fluent atom f   do according to one of
the following cases 
 a  if its successor state axiom is succ f    true  then put f into the add list unless
init f   is entailed by init 
 b  if its successor state axiom is succ f    f alse  then put f into the delete list
unless init f   is entailed by init 
 c  if its successor state axiom is succ f      and  is not the same as true  f alse 
or init f    then put f in the conditional effect list and output its successor state
axiom 
 d  if f does not have a successor state axiom  then put it in the list of indeterminate
effects 
clearly  if f is not put into any of the lists  then its truth value is not affected by a 
steps   and   of the above procedure are the bottleneck as in the worst case  computing
the strongest necessary condition of a proposition is conp hard  however  it has been our
experience that if action a has a context free effect on fluent atom f   then its successor
state axiom can be computed without going through step   
we have implemented the procedure ccp using the above strategy in swi prolog         
the url for this system is as follows 
http   www cs ust hk  flin ccp html
using the system  we have encoded in our action description language many of the planning
domains that come with the original release of pddl  mcdermott         and compiled
them to strips like specifications  our encodings of the domains and the results returned
by the system are included in the online appendix  in the following  we illustrate some
interesting features of our system using the following two domains  the blocks world and
the monkey and bananas domain 
    the blocks world
we have used the blocks world as the running example  here we shall give an alternative specification of the domain using the following better known set of actions  stack 
unstack  pickup  and putdown  we shall use this domain to show that changing slightly
the precondition of one of the actions can result in a very different action specification 
   swi prolog is developed by jan wielemaker at university of amsterdam

   

filin

we begin with a description that corresponds to the standard strips encoding of the
domain 
fluent on x  y   block x   block y   
fluent ontable x   block x   
fluent holding x   block x   
complex clear x   block x  
defined clear x     y  block on y  x    holding x   
complex handempty  true  
defined handempty   x  block holding x   
causes on x  y   x    z  on z  y   
causes on x  y   y    z  on x  z   
causes on x  y   ontable x   
causes ontable x   on x  y   
causes on x  y   holding x   
causes on x  y   holding y   
causes holding x   ontable x   
causes holding x   on x  y   
causes holding x   on y  x   
causes holding x   y    x  holding y   
action stack x  y   block x   block y   x    y  
p recond stack x  y   holding x   clear y   
effect stack x  y   true  on x  y   
action unstack x  y   block x   block y   x    y  
p recond unstack x  y   clear x   on x  y   handempty  
effect unstack x  y   true  holding x   
action putdown x   block x   
p recond putdown x   holding x   
effect putdown x   true  ontable x   
action pickup x   block x   
p recond pickup x   handempty  ontable x   clear x   
effect pickup x   true  holding x   
notice that compared to the description in example    there are two more fluents  holding
and handempty here  thus we have a few more domain rules about them  and the definition
of clear is changed to take into account that when a block is held  it is not considered to
be clear 
   

fifrom causal theories to strips like systems

now assuming a domain with three blocks domain block              our system will
generate    fluent atoms  and    action instances  for each action instance  it returns
both a complete set of successor state axioms and a strips like representation  the total
computation time for all actions is    k inferences and     seconds   this is a pure strips
domain  i e  all actions are context free  for this type of domains  as we mentioned earlier 
step   in our implementation procedure is not needed  and step   is easy 
the results are as expected  for instance  for action pickup     the strips like representation returned by the system looks like the following  track   to track     the stripslike representation looks like 
pickup    
preconditions  clear     handempty  ontable   
add list  holding   
delete list  ontable     clear     handempty
conditional effects 
indeterminate effects 
the complete output is given in the online appendix  now let us consider what happen
if we drop ontable x  from the precondition of pickup x  
p recond pickup x   handempty  clear x   
this means that as long as a block is clear  it can be picked up  with this new precondition 
our system returns the following strips like representation for action pickup    
pickup    
preconditions  clear     handempty
add list  holding   
delete list  clear     handempty  on        on        ontable   
conditional effects 
succ clear           init on         init on        
succ clear           init on         init on        
indeterminate effects 
here   is negation  and    is disjunction  an adl like description for this action
would be something like the following 
pickup x  
preconditions  clear x   handempty
add list  holding x  
clear y  when on x y 
delete list  clear x   handempty 
on x y  when on x y 
ontable x  when ontable x 
   all times in this paper refer to cpu times on a pentium iii  ghz machine with    mb ram running
swi prolog       under linux  the number of inferences is the one reported by swi prolog  and
roughly corresponds to the number of resolution steps carried out by the prolog interpreter  and is
machine independent 

   

filin

    the monkey and bananas domain
this domain is again adapted from mcdermotts pddl library of planning domains  which
attributes it to the university of washingtons ucpop collection of action domains  which
in turn attributes it to prodigy  while some of the action effects generated by our system
are context dependent  they are all context free in the other systems  we shall elaborate
on this difference later 
in this domain  there are two types  loc for locations  we assume there are three locations
here   and object for things like monkey  banana  box  etc  
domain loc             
domain object   monkey  box  banana  knif e  glass  f ountain   
the following are fluent definitions 
fluent onf loor  
fluent at m  x   object m    loc x   
fluent hasknif e  
fluent onbox x   loc x   
fluent hasbanana  
fluent haswater  
fluent hasglass  
the following are domain rules about these fluents 
causes onbox x   at monkey  x   

    

causes onbox x   at box  x   

    

causes onbox x   onf loor  

    

causes onf loor  onbox x   

    

causes at m  x   x    y  at m  y    

    

causes hasglass  at monkey  x   at glass  x   

    

causes hasknif e  at monkey  x   at knif e  x   

    

causes hasbanana  at monkey  x   at banana  x   

    

the following are action definitions along with their respective preconditions and effect
axioms 
 goto x  y    the monkey goes to x from y 
action goto x  y    loc x   loc y    x    y   
p recond goto x  y    at monkey  y    onf loor  
effect goto x  y    true  at monkey  x   
   

fifrom causal theories to strips like systems

 climb x    the monkey climbs onto the box at location x 
action climb x   loc x   
p recond climb x   at box  x   onf loor  at monkey  x   
effect climb x   true  onbox x   
 pushbox x  y     the monkey pushes the box from y to x 
action pushbox x  y    loc x   loc y    x    y   
p recond pushbox x  y    at monkey  y    at box  y     onf loor  
effect pushbox x  y    true  at monkey  x   
effect pushbox x  y    true  at box  x   
 getknif e x    get knife at location x 
action getknif e x   loc x   
p recond getknif e x   at knif e  x   at monkey  x   hasknif e  
effect getknif e x   true  hasknif e  
 getbanana x    grab banana at loc x  provided the monkey is on the box 
action getbanana x   loc x   
p recond getbanana x   onbox x   at banana  x   hasbanana  
effect getbanana x   true  hasbanana  
 pickglass x    pick up glass at loc x 
action pickglass x   loc x   
p recond pickglass x   at glass  x   at monkey  x   hasglass  
effect pickglass x   true  hasglass  
 getwater x    get water from fountain at loc x  provided the monkey is on the box 
and has a glass in hand 
action getwater x   loc x   
p recond getwater x   at f ountain  x   onbox x   hasglass  haswater  
effect getwater x   true  haswater  
this domain has    actions and    fluent atoms  again  for each action  our system
generates both a complete set of fully instantiated successor state axioms and a stripslike representation  for instance  for action goto        the following is the strips like
representation generated by the system 
   

filin

action goto      
preconditions  at monkey      onfloor
add list  at monkey    
delete list  at monkey    
conditional effects 
succ at banana          init hasbanana     init at banana     
succ at knife          init hasknife     init at knife     
succ at glass          init hasglass     init at glass     
succ at banana            init hasbanana    init at banana     
succ at knife            init hasknife    init at knife     
succ at glass            init hasglass    init at glass     
the total running time for all actions is   seconds while performing    million inferences 
about    percent of time is spent on step    i e  on computing the strongest necessary
and weakest sufficient conditions of fluent atoms on which the given action has contextdependent effects  for instance  for action goto       above  the majority of time was spent
on generating the above   conditional effects 
for this action  actually for all the actions in this domain  we could use an adl like
description  pednault        for conditional effects 
add list  at banana    when hasbanana
at knife    when hasknife
at glass    when hasglass
delete list  at banana    when hasbanana
at knife    when hasknife
at glass    when hasglass
however  it is not clear whether this can always be done in the general case 
we mentioned earlier that the specifications for this domain given in mcdermotts collection as well as others are all context free  for instance  the following is a specification
for action goto in pddl in mcdermotts collection 
  action go to
 parameters   x  y 
 precondition  and  location  x   location  y 
 not     y  x    on floor   at monkey  y  
 effect  and  at monkey  x   not  at monkey  y    
this corresponds to a context free action that does not change any other fluent except at 
it is clear that the design of this action does not take into account domain rules             
with this specification  if initially banana is at location    then the goal of having banana
at location   would not be achievable 
   

fifrom causal theories to strips like systems

    summary
the other domains that we have experimented including a scheduling domain that includes
pednaults dictionary and paycheck domain as a special case  the rocket domain  the sri
robot domain  the machine shop assembling domain  the ferry domain  the grid domain 
the sokoban domain  and the gear domain  they are all included in the online appendix 
we summarize below some of the common features of these domains 
 in all the domains that we tried  it is quite straightforward to decide what effects of
an action should be encoded as direct effects  those given by the predicate effect  and
what effects as indirect effects  those derived from domain rules  
 the most common domain rules are functional dependency constraints  for instance 
in the blocks world  the fluent atom on x  y  is functional on both arguments  in
the monkey and banana domain  the fluent atom at object  loc  is functional on the
second argument  each object can be at only one location   it makes sense then that
we would have a special shorthand for these domain rules  and perhaps a special
procedure for handling them as well  but more significantly  given the prevalence
of these functional dependency constraints in action domains  it is worthwhile to
investigate the possibility of a general purpose planner making good use of these
constraints 
 as we mentioned earlier  our system is propositional  the generated successor state
axioms and strips like systems are all fully instantiated  however  it is often easy
for the user to generalize these propositional specifications to first order ones  we
shall investigate the generality of this observation next 

   generalizing propositional strips like systems to ones with
parameters
as we mentioned  for many action domain descriptions  the successor state axioms and
strips like systems generated for a specific domain can be generalized to arbitrary ones 
more precisely  let d be a domain description  and
domain p    dp          domain pk   dpk  
its type specification  suppose in d for action a we have that inita  succa      now
suppose d  is another domain description that is just like d except that it has a different
type specification 
domain p    dp            domain pk   dp  k   
the question that we are interested in is this  given any one to one mapping from the type
specification of d to that of d    will inita   succa       be true in d    here a   resp     
is the result of replacing all objects in a  resp    according to the mapping 
for instance  if the above is true for the blocks world  then we can generalize the results
for the domain description in example   as follows  as we have shown  for action stack       
both succ on        and succ on        are true  now if we change the type specification
to domain block   a  b  c  d  e    and if we map   to a    to c  and   to e  in the new domain
   

filin

specification  we will have that for action stack a  c   succ on a  c   and succ on a  e   are
true  furthermore  by changing the mapping for    we see that for any x that is different
from a and c  the mapping needs to be one to one   succ on a  x   is true 
obviously  this is to be expected of the blocks world  we now proceed to show that for
some general classes of domain descriptions  we can do this as well  we first make precise
the mapping from one type specification to another 
definition   given two type specifications o 
domain p    dp          domain pk   dpk   
and o   
domain p    dp            domain pk   dp  k   
an embedding from o to o  is a one to one mapping  from dp    dpk to dp      dp  k
such that for any    i  k  and any a  dpi   f  a   dp  i  
clearly  if there is an embedding of o to o    then for each type p  the size of the domain
for p in o  must be at least the size of the domain for p in o  given such an embedding
   any expression   actions  propositions  formulas  in an action domain description d
with o as its type specification can be mapped to     in the language of d    one simply
replaces each object a in  by   a   where d  differs from d only in that it uses o  as its
type specification  notice that only objects  those in the domain of some type  are to be
replaced  not constants that may occur in the effect axioms or domain rules 
definition   an action domain description belongs to simple i class if it does not mention
any function of positive arity  does not mention any complex fluents except in complex fluent
definitions  and satisfies the following conditions 
   if p recond a  a   is an action precondition definition  then a has the form
 x  p     y  q w   where w is a fluent formula that does not have any quantifiers 
   if effect a    f   or effect a    f   is an action effect axiom  then  does not have
any quantifiers  and the variables in  and f are among those in a  that is  one
cannot have something like
effect explodeat x   nearby y  x   dead y   
   if causes   f   or causes   f   is a domain rule  then  does not have any quantifiers  and all the variables in  must be in f  
theorem   let d be a simple i action domain description  and a an action instance in
d  let d  be just like d except for the type specification  then for any formula  that
does not mention any complex fluent and has no quantifiers  and any embedding  from
the type specification of d to that of d    we have that if inita  succa     in d  then
init  a   succ  a         in d   
   

fifrom causal theories to strips like systems

proof  suppose init  a   succ  a         is not true  and that m  is a truth assignment
in the language of d  that satisfies init  a   succ  a  and      now construct a truth
assignment m  in the language of d as follows  for any proposition p in the language of
d that does not mention any complex fluent  m     p iff m       p    p is really either
a static proposition  succ f   or init f    where f is a primitive fluent atom   the truth
values of complex fluent atoms in m  are defined according to their definitions  clearly 
m       we now need to show that m  also satisfies inita and succa   for inita   there
are three cases 
   m     init f    init   when defined f    is a complex fluent definition  this
follows from the construction of m   
   m     init a   when p recond a  a   is the precondition definition for a  by our
assumption  a has the form  x  p     y  q  w   where w is a formula without any
quantifiers  without loss of generality  let us assume it is  x  p w   then this formula
is equivalent to
 
w  x a 
adp

under d  where dp is the domain of type p in d  so m      x  p w iff
m    

 

w  x a 

adp

iff
m    

 

w  x   a   

adp

which is true since m      x  p w  
   all other formulas in inita do not mention complex fluents and have no quantifiers 
they are true in m  because the corresponding ones are true in m   
for succa   suppose f is a primitive fluent atom  and its pseudo successor state axiom f
as constructed according to the procedure ccp given in section   is as follows 
succ f    init          init n    succ           succ  l   
init f     init          init m    succ           succ  k    
because of the following properties about d 
 each effect axiom effect a    f   or effect a    f   has the property that  has no
quantifier  and that the variables in  are also in f  
 each domain rule of the form causes   f   or causes   f   has the property that
 has no quantifier  and that the variables in  are also in f  
so the pseudo successor state axiom for   succ f    under d  is just   f    thus m     f
since m       f    this proves that m  is a model of succa   thus the theorem 
 

   

filin

however  most of the examples that we have in the paper do not belong to this simple i
class  for two reasons  action preconditions  like those in the blocks world  can mention
complex fluents  and some of the negative domain rules causes   f   may have some
variables not in f   the first problem is not a problem in principle as complex fluents can
be replaced by their definitions  the second problem is more serious  and that leads to a
new type of simple action theories 
definition   an action domain description belongs to simple ii class if it does not mention
any function of positive arity  does not mention any complex fluents except in complex fluent
definitions  and satisfies the following conditions 
   if p recond a  a   is an action precondition definition  then a has the form
 x  p     y  q w   where w is a fluent formula that does not have any quantifiers 
   if effect a    f   or effect a    f   is an action effect axiom  then  does not have
any quantifiers  and the variables in  and f are among those in a 
   there are no positive domain rules of the form causes   f   
   if causes   f   is a domain rule  then  must be of the form        where   is
any formula that does not mention any fluents and   is a fluent atom  notice that
there is no restriction on variables in    
simple ii class action domain descriptions seem to be very limited in that there can be no
positive domain rules  and the only negative domain rules allowed are binary  nevertheless 
they still capture many context free action domains  for instance  both the blocks world
and meet and pass domains in this paper belong to this class  for the blocks world  notice
that while it uses the complex fluent clear in some of its action precondition definitions  as in
p recond stack x  y   ontable x   clear x   clear y    these definitions can be reformulated
as follows using clears definition 
p recond stack x  y  
ontable x    x    block  y    block  on x    x   on y    y    
this will then satisfy the condition about p recond in the above definition of simple ii
action domain descriptions  while we have not verified it formally  it seems that all the
context free action domains in mcdermotts pddl library of action domains  including the
logistics domain  belong to the simple ii class 
theorem   let d be a simple ii action domain description  and a an action instance in
d  let d  be just like d except for the type specification  then for any formula  that
does not mention any complex fluent and has no quantifiers  and any embedding  from
the type specification of d to that of d    we have that if inita  succa     in d then
init  a   succ  a         in d   
proof  suppose init  a   succ  a         is not true  and that m  is a truth assignment
in the language of d  that satisfies init  a   succ  a  and      now construct a truth
   

fifrom causal theories to strips like systems

assignment m  in the language of d as follows  for any proposition p in the language of
d that does not mention any complex fluent  m     p iff m       p    p is really either
a static proposition  succ f   or init f    where f is a primitive fluent atom   the truth
values of complex fluent atoms in m  are defined according to their definitions  clearly 
m       we now need to show that m  also satisfies inita and succa   for inita   there
are three cases 
   m     init f    init   when defined f    is a complex fluent definition  this
follows from the construction of m   
   m     init a   when p recond a  a   is the precondition definition for a  by our
assumption  a has the form  x  p     y  q  w   where w is a formula without any
quantifiers  without loss of generality  let us assume it is  x  p   w   then this
formula is equivalent to
w  x a          w  x a n   
under d  so m      x  p   w iff
m     w  x a          w  x a n   
iff
m     w  x   a           w  x   a n     
which is true since m      x  p   w  
   all other formulas in inita do not mention complex fluents and have no quantifiers 
they are true in m  because the corresponding ones are true in m   
for succa   suppose f is a primitive fluent atom  since there is no positive domain rule of
the form causes   f    the pseudo successor state axiom for f as constructed according to
the procedure ccp given in section   must be of the following form 
succ f    init          init n   
init f     init          init m    succ           succ  k    
where for each    i  k  causes  i   f   is an instance of a domain rule in d 
because in d and d    each effect axiom effect   f   or effect   f   has the property
that  has no quantifier  and that the variables in  are also in f   the pseudo successor
state axiom for   succ f    under d  must have the form 
succ   f     init             init   n    
init   f      init             init   m    
succ        

  

succ    k   

    

 succ    

where  is a disjunction such that each disjunct  must be such that causes     f    is
an instance in d  and that the fluent atom in  contains an object not in   a  and   f   
there are two cases 
   

filin

 suppose m     succ f    then m     succ   f     since m  is a model of succ  a   
m  satisfies the above axiom about succ   f     therefore m  satisfies the following
formula 
init             init   n    
init   f      init             init   m    
succ              succ    k     
since the above formula does not mention any complex fluents and has no quantifiers 
m  satisfies the corresponding formula 
init          init n   

    

init f     init          init m   

succ     

  

succ  k    

which is the right side of the equivalence of the pseudo successor state axiom for
succ f   in succa  
 now suppose m  satisfies       well show that m  satisfies the right side of      
thus m     succ   f    so m     succ f    there are two cases 
 m  satisfies the following formula 
init          init n   

    

in this case  since the above formula does not mention any complex fluents and
has no quantifier  m  satisfies the following corresponding formula 
init             init   n    

    

thus m  satisfies the right side of      
 m  does not satisfy      but satisfies the following formula 
init f     init          init m    succ           succ  k    
thus m  satisfies the following formula 
init   f      init             init   m    
succ              succ    k     
so to show that the right side of the equivalence of      is satisfied by m    we
need to show that m     succ    recall that  is a disjunction such that each
disjunct  must correspond to a domain rule of the form causes     f     and
that  is of the form    g such that   does not mention fluents  and g is
a fluent atom that mentions an object that does not occur in   a   note that
init    init   f    is an axiom in succ  a    which is satisfied by m    thus
m     init    this means that either   or init g  is false in m    if  
is false  then succ   is false since succ     is the same as     suppose that
init g  is false in m    notice that since there are no positive domain rules  and
   

fifrom causal theories to strips like systems

that g has an object not in   a  and   f    the pseudo successor state axiom
for g in succ  a  must be of the form succ g   init g     therefore from
m     init g  we get m     succ    since  is any disjunct of   we have
proved that m     succ    therefore m     succ   f     thus m     succ f   
 

   related work
in planning  the most closely related work is the causal reasoning module in wilkinss sipe
system  wilkins         wilkins writes  page     wilkins         use of the strips
assumptions has made operators unacceptably difficult to describe in previous classical
planners    one of the primary reasons for this is that all effects of an action must be explicitly stated    deductive causal theories are one of the most important mechanisms used
by sipe to alleviate problems in operator representation caused by the strips assumption  this is certainly one of the motivations for our system as well  in sipe  domain rules
have triggers  preconditions  conditions  and effects  informally  when the triggers become
true in the new situation  sipe would then check in sequence to see if the preconditions
were true in the old situation  and the conditions are true in the new situation  if all these
conditions are true  it will then deduce the effects  for instance  a sipe causal rule for
on x  y  in the blocks world would look like 
causal rule  not on
arguments  x  y  z 
trigger  on x y  
precondition  on x z  
effects  not on x z  
in comparison  our domain rules are much simpler  for instance  our corresponding rule
for the above sipe rule is simply  causes on x  y   y    z  on x  z    we do not need
procedural directives like triggers  to a large degree  we can see our system as a rational
reconstruction of the causal reasoning module in sipe  as we have shown in theorem   
the procedure used by our system is sound under a translation to causal theories in the
situation calculus  while wilkins also gave a translation of his causal rules to formulas in
the situation calculus  he did not specify an underlying logic to reason about such formulas 
in fact  as shown by lin         such translations would not work 
for those familiar with pddl  the original version by mcdermott and the aips   
planning competition committee allows domain axioms over stratified theories  according
to the manual of pddl      mcdermott         axioms are logical formulas that assert
relationships among propositions that hold within a situation  the format for writing
axioms in pddl is as follows 
  axiom
 vars   x  y     
 context w
 implies p 
   

filin

where w is a formula and p a literal  axioms are treated directionally  from w to p   the
following is the rule and intention for using the axioms according to the manual 
the rule is that action definitions are not allowed to have effects that mention
predicates that occur in the  implies field of an axiom  the intention is that
action definitions mention primitive predicates like on  and that all changes in
truth value of derived predicates like above occur through axioms  without
axioms  the action definitions will have to describe changes in all predicates that
might be affected by an action  which leads to a complex software engineering
 or domain engineering  problem 
it is clear from this quotation that axioms in pddl are intended for defining derived
predicates  they are similar to our complex fluent definitions  new versions of pddl have
extended the original version by allowing actions with durations and continuous changes 
they have not considered using axioms to derive changes to primitive predicates like what
we have done here with domain rules 
our action domain description language  while having a very different syntax that is
strongly influenced by prolog syntax  shares much of the same ideas behind action languages
 gelfond   lifschitz         however  unlike action languages  ours does not provide facilities for expressing the truth value of a fluent atom in a particular situation like the initial
situation  rather  it is aimed at specifying the generic effects of actions  on the other hand 
it has facilities for specifying types and static relations  most importantly  to date  action
languages are either implemented directly or mapped to a nonmonotonic logic programming
system rather than by compilation into a monotonic system where action effects are given
explicitly  as is done here  for instance  a new sat based planning method would have to
be implemented  e g  mccain   turner        for action languages  in comparison  once
an action domain description is compiled to a strips like description  existing planning
systems such as blackbox  selman   kautz        or system r  lin      b  can be directly
called 

   concluding remarks
we have described a system for generating the effects of actions from direct action effect
axioms and domain rules  among other things  we have shown the soundness of the procedure used by the system and tested it successfully in many benchmark action domains used
by current ai planners  for future work  we are considering how to generalize the simple
action theories in section   to include context dependent action domain descriptions like
the monkey and bananas domain 

acknowledgments
an extended abstract of part of this paper appeared in proceedings of aaai       i would
like to thank the anonymous reviewers for both jair and aaai     as well as the associate
editor in charge of this paper for jair for their insightful comments on earlier versions of
this paper  this work was supported in part by the research grants council of hong kong
under competitive earmarked research grant hkust       e 
   

fifrom causal theories to strips like systems

references
baral  c          reasoning about actions  nondeterministic effects  constraints  and qualification  in proceedings of the fourteenth international joint conference on artificial
intelligence  ijcai     ijcai inc  distributed by morgan kaufmann  san mateo 
ca   pp           
fikes  r  e     nilsson  n  j          strips  a new approach to theorem proving in
problem solving  artificial intelligence            
fox  m     long  d          the automatic inference of state invariants in tim  journal
of artificial intelligence research            
gelfond  m     lifschitz  v          action languages  electronic transactions on artificial
intelligence  http   www ep liu se ea cis  vol    nr     
gerevini  a     schubert  l          inferring state constraints for domain independent
planning  in proceedings of the   th national conference on artificial intelligence
 aaai     aaai press  menlo park  ca 
levesque  h   reiter  r   lesperance  y   lin  f     scherl  r          golog  a logic
programming language for dynamic domains  journal of logic programming  special
issue on reasoning about action and change           
lifschitz  v          on the logic of causal explanation  artificial intelligence             
lin  f          embracing causality in specifying the indirect effects of actions  in proceedings of the fourteenth international joint conference on artificial intelligence
 ijcai     ijcai inc  distributed by morgan kaufmann  san mateo  ca   pp      
     
lin  f          embracing causality in specifying the indeterminate effects of actions  in
proceedings of the   th national conference on artificial intelligence  aaai    
aaai press  menlo park  ca   pp         
lin  f       a   on strongest necessary and weakest sufficient conditions  artificial intelligence                   
lin  f       b   a planner called r  ai magazine              
lin  f     reiter  r       a   forget it   in greiner  r     subramanian  d   eds   
working notes of aaai fall symposium on relevance  pp          the american association for artificial intelligence  menlo park  ca  also available at
http   www cs toronto edu cogrobo forgetting ps z 
lin  f     reiter  r       b   state constraints revisited  journal of logic and computation 
special issue on actions and processes               
mccain  n     turner  h          a causal theory of ramifications and qualifications  in
proceedings of the fourteenth international joint conference on artificial intelligence
 ijcai     ijcai inc  distributed by morgan kaufmann  san mateo  ca   pp      
     
mccain  n     turner  h          causal theories of action and change  in proceedings
of the   th national conference on artificial intelligence  aaai     aaai press 
menlo park  ca   pp         
   

filin

mccain  n     turner  h          satisfiability planning with causal theories  in proceedings
of the sixth international conference on principles of knowledge representation and
reasoning  kr     pp         
mcdermott  d          pddl  the planning domain definition language  tech  rep  tr       dcs tr       yale center for computational vision and control 
pednault  e  p          adl  exploring the middle ground between strips and the situation calculus  in proceedings of the first international conference on principles of
knowledge representation and reasoning  kr     pp          morgan kaufmann
publishers  inc 
reiter  r          the frame problem in the situation calculus  a simple solution  sometimes  and a completeness result for goal regression  in lifschitz  v   ed    artificial
intelligence and mathematical theory of computation  papers in honor of john mccarthy  pp          academic press  san diego  ca 
selman  b     kautz  h          unifying sat based and graph based planning  in proceedings of the sixteenth international joint conference on artificial intelligence  ijcai
     ijcai inc  distributed by morgan kaufmann  san mateo  ca   pp         
thielscher  m          computing ramification by post processing  in proceedings of the
fourteenth international joint conference on artificial intelligence  ijcai     ijcai inc  distributed by morgan kaufmann  san mateo  ca   pp           
thielscher  m          ramification and causality  artificial intelligence             
wilkins  d          practical planning  extending the classical ai planning paradigm  morgan kaufmann  san mateo  ca 
zhang  y     foo  n          deriving invariants and constraints from action theories 
fundamenta informaticae                

   

fi