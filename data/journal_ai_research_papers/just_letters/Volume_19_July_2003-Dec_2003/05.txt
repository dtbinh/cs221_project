journal of artificial intelligence research                  

submitted        published      

altaltp   online parallelization of plans with
heuristic state search
romeo sanchez nigenda
subbarao kambhampati

rsanchez asu edu
rao asu edu

department of computer science and engineering 
arizona state university  tempe az           

abstract
despite their near dominance  heuristic state search planners still lag behind disjunctive
planners in the generation of parallel plans in classical planning  the reason is that directly
searching for parallel solutions in state space planners would require the planners to branch
on all possible subsets of parallel actions  thus increasing the branching factor exponentially 
we present a variant of our heuristic state search planner altalt called altaltp which
generates parallel plans by using greedy online parallelization of partial plans  the greedy
approach is significantly informed by the use of novel distance heuristics that altaltp
derives from a graphplan style planning graph for the problem  while this approach is
not guaranteed to provide optimal parallel plans  empirical results show that altaltp is
capable of generating good quality parallel plans at a fraction of the cost incurred by the
disjunctive planners 

   introduction
heuristic state space search planning has proved to be one of the most efficient planning
frameworks for solving large deterministic planning problems  bonet  loerincs    geffner 
      bonet   geffner        bacchus         despite its near dominance  its one achilles
heel remains generation of parallel plans  haslum   geffner         parallel plans allow
concurrent execution of multiple actions in each time step  such concurrency is likely
to be more important as we progress to temporal domains  while disjunctive planners
such as graphplan  blum   furst        satplan  kautz   selman        and gpcsp  do   kambhampati        seem to have no trouble generating such parallel plans 
planners that search in the space of states are overwhelmed by this task  the main reason
is that straightforward methods for generation of parallel plans would involve progression
or regression over sets of actions  this increases the branching factor of the search space
exponentially  given n actions  the branching factor of a simple progression or regression
search is bounded by n  while that of progression or regression search for parallel plans will
be bounded by  n  
the inability of state search planners in producing parallel plans has been noted in the
literature previously  past attempts to overcome this limitation have not been very successful  indeed  haslum and geffner        consider the problem of generating parallel
plans using a regression search in the space of states  they note that the resulting planner  hsp p  scales significantly worse than graphplan  they present tp  in  haslum  
geffner         which in addition to being aimed at actions with durations  also improves
c
    
ai access foundation  all rights reserved 

fisanchez   kambhampati

the branching scheme of hsp p  by making it incremental along the lines of graphplan 
empirical studies reported by haslum and geffner         however indicate that even this
new approach  unfortunately  scales quite poorly compared to graphplan variants  informally  this achilles heel of heuristic state search planners has been interpreted as a sort of
last stand of the disjunctive planners  only they are capable of generating parallel plans
efficiently 
given that the only way of efficiently generating optimal parallel plans involves using
disjunctive planners  we might want to consider ways of generating near optimal parallel
plans using state search planners  one obvious approach is to post process the sequential
plans generated by the state search planners to make them parallel  while this can easily
be done   using approaches such as those explored by backstrom         one drawback
is that such approaches are limited to transforming the sequential plan given as input 
parallelization of sequential plans often results in plans that are not close to optimal parallel
plans  
an alternative  that we explore in this paper  involves incremental online parallelization 
specifically  our planner altaltp   which is a variant of the altalt planner  sanchez  nguyen 
  kambhampati        nguyen  kambhampati    sanchez         starts its search in the
space of regression over single actions  once the most promising single action to regress
is selected  altaltp then attempts to parallelize  fatten  the selected search branch with
other independent actions  this parallelization is done in a greedy incremental fashion actions are considered for addition to the current search branch based on the heuristic cost
of the subgoals they promise to achieve  the parallelization continues to the next step
only if the state resulting from the addition of the new action has a better heuristic cost 
the sub optimality introduced by the greedy nature of the parallelization is offset to some
extent by a plan compression procedure called pushup that tries to rearrange the evolving
parallel plans by pushing up actions to higher levels in the search branch  i e  later stages
of execution  in the plan 
despite the seeming simplicity of our approach  it has proven to be quite robust in
practice  in fact  our experimental comparison with five competing planners   stan  long
  fox         lpg  gerevini   serina         blackbox  kautz   selman         sapa  do
  kambhampati        and tp   haslum   geffner          shows that altaltp is a viable
and scalable alternative for generating parallel plans in several domains  for many problems 
altaltp is able to generate parallel plans that are close to optimal in makespan  it also
seems to retain the efficiency advantages of heuristic state search over disjunctive planners 
producing plans in a fraction of the time taken by the disjunctive planners in many cases 
altaltp has also been found to be superior to post processing approaches  specifically 
we compared altaltp to an approach that involves post processing the sequential plans
generated by altalt using the techniques from backstrom         we found that altaltp is
able to generate shorter parallel plans in many cases  finally  we show that altaltp incurs
very little additional overhead compared to altalt 
in the rest of this paper  we discuss the implementation and evaluation of our approach
to generate parallel plans with altaltp   section   starts by providing a review of the
altalt planning system  on which altaltp is based  section   describes the generation of
   we will empirically demonstrate this later  curious readers may refer to the plots in figure    

   

fionline parallelization of plans with heuristic state search

action templates

serial planning
graph

graphplan
plan extension phase
 based on stan 

problem spec
 init  goal state 

extraction of
heuristics

actions in the
last level

altalt

heuristics

regression planner
 based on hsp r 

solution plan

figure    architecture of altalt
parallel plans in altaltp   section   presents extensive empirical evaluation of altaltp   the
evaluation includes both comparison and ablation studies  finally  section   discusses some
related work in classical as well as metric temporal planning  section   summarizes our
contributions 

   altalt background architecture and heuristics
the altalt planning system is based on a combination of graphplan  blum   furst       
long   fox        kautz   selman        and heuristic state space search  bonet et al  
      bonet   geffner        mcdermott        technology  altalt extracts powerful
heuristics from a planning graph data structure to guide a regression search in the space of
states  the high level architecture of altalt is shown in figure    the problem specification
and the action template description are first fed to a graphplan style planner  in our case 
stan from long   fox         which constructs a planning graph for that problem in
polynomial time  we assume the reader is familiar with the graphplan algorithm of blum
  furst         this planning graph structure is then fed to a heuristic extractor module
that is capable of extracting a variety of effective heuristics  nguyen   kambhampati 
      nguyen et al          these heuristics  along with the problem specification  and the
set of ground actions in the final action level of the planning graph structure are fed to a
regression state search planner 
to explain the operation of altalt at a more detailed level  we need to provide some
further background on its various components  we shall start with the regression search
module  regression search is a process of searching in the space of potential plan suffixes  the suffixes are generated by starting with the goal state and regressing it over
the set of relevant action instances from the domain  the resulting states are then  nondeterministically  regressed again over relevant action instances  and this process is repeated
until we reach a state  set of subgoals  which is satisfied by the initial state  a state s in our
framework is a set of  conjunction of  literals that can be seen as subgoals that need to be
made true on the way to achieving the top level goals  an action instance a is considered
relevant to a state s if the effects of a give at least one element of s and do not delete
   

fisanchez   kambhampati

any element of s  the result of regressing s over a is then  s ef f  a    prec a    which is
essentially the set of goals that still need to be achieved before the application of a  such
that everything in s would have been achieved once a is applied  for each relevant action
a  a separate search branch is generated  with the result of regressing s over that action as
the new fringe in that branch  search terminates with success at a node if every literal in
the state corresponding to that node is present in the initial state of the problem 
the crux of controlling the regression search involves providing a heuristic function that
can estimate the relative goodness of the states on the fringe of the current search tree and
guide the search in the most promising directions  the heuristic function needs to evaluate
the cost of achieving the set s of subgoals  comprising a regressed state  from the initial
state  in other words  the heuristic computes the length of the plan needed to achieve the
subgoals from the initial state  we now discuss how such a heuristic can be computed from
the planning graph  which  provides optimistic reachability estimates 
normally  the planning graph data structure supports parallel plans   i e   plans where
at each step more than one action may be executed simultaneously  since we want the planning graph to provide heuristics to the regression search module of altalt  which generates
sequential solutions  we first make a modification to the algorithm so that it generates a
serial planning graph  a serial planning graph is a planning graph in which  in addition
to the normal mutex relations  every pair of non noop actions at the same level are marked
mutex  these additional action mutexes propagate to give additional propositional mutexes  finally  a planning graph is said to level off when there is no change in the action 
proposition and mutex lists between two consecutive levels 
we will assume for now that given a problem  the graphplan module of altalt is used
to generate and expand a serial planning graph until it levels off  as discussed by sanchez
et al          we can relax the requirement of growing the planning graph to level off  if we
can tolerate a graded loss of informedness of heuristics derived from the planning graph 
we will start with the notion of level of a set of propositions 
definition    level  given a set s of propositions  lev s  is the index of the first level
in the leveled serial planning graph in which all propositions in s appear and are non mutex
with one another  if s is a singleton  then lev s  is just the index of the first level where
the singleton element occurs  if no such level exists  then lev s     if the planning graph
has been grown to level off 
the intuition behind this definition is that the level of a literal p in the serial planning
graph provides a lower bound on the length of the plan  which  for a serial planning graph 
is equal to the number of actions in the plan  to achieve p from the initial state  using this
insight  a simple way of estimating the cost of a set of subgoals will be to sum their levels 
heuristic    sum heuristic  hsum  s    

p

ps

lev  p  

the sum heuristic is very similar to the greedy regression heuristic used in unpop  mcdermott        and the heuristic used in the hsp planner  bonet et al          its main
limitation is that the heuristic makes the implicit assumption that all the subgoals  elements
of s  are independent  the hsum heuristic is neither admissible nor particularly informed
as it ignores the interactions between the subgoals  to develop more effective heuristics 
   

fionline parallelization of plans with heuristic state search

we need to consider both positive and negative interactions among subgoals in a limited
fashion 
in  nguyen et al          we discuss a variety of ways of using the planning graph to
incorporate negative and positive interactions into the heuristic estimate  and discuss their
relative tradeoffs  one of the best heuristics according to that analysis was a heuristic called
hadjsum m   we adopted this heuristic as the default heuristic in altalt  the basic idea
of hadjsum m is to adjust the sum heuristic to take positive and negative interactions into
account  this heuristic approximates the cost of achieving the subgoals in some set s as the
sum of the cost of achieving s  while considering positive interactions and ignoring negative
interactions  plus a penalty for ignoring the negative interactions  the first component
rp  s  can be computed as the length of a relaxed plan for supporting s  which is
extracted by ignoring all the mutex relations  to approximate the penalty induced by the
negative interactions alone  we proceed with the following argument  consider any pair of
subgoals p  q  s  if there are no negative interactions between p and q  then lev  p  q   
the level at which p and q are present together  is exactly the maximum of lev p  and lev q  
the degree of negative interaction between p and q can thus be quantified by 
 p  q    lev  p  q    max  lev p   lev q  
we now want to use the    values to characterize the amount of negative interactions
present among the subgoals of a given set s  if all subgoals in s are pair wise independent 
clearly  all  values will be zero  otherwise each pair of subgoals in s will have a different
value  the largest such  value among any pair of subgoals in s is used as a measure of the
negative interactions present in s in the heuristic hadjsum m   in summary  we have
heuristic    adjusted  m  hadjsum m  s     length rp  s     maxp qs  p  q 
the analysis by nguyen et al         shows that this is one of the more robust heuristics
in terms of both solution time and quality  this is thus the default heuristic used in altalt
 as well as altaltp   see below  

   generation of parallel plans using altaltp
the obvious way to make altalt produce parallel plans would involve regressing over subsets
of  non interfering  actions  unfortunately  this increases the branching factor exponentially
and is infeasible in practice  instead  altaltp uses a greedy depth first approach that makes
use of its heuristics to regress single actions  and incrementally parallelizes the partial plan
at each step  rearranging the partial plan later if necessary 
the high level architecture of altaltp is shown in figure    notice that the heuristic
extraction phase of altaltp is very similar to that of altalt  but with one important modification  in contrast to altalt which uses a serial planning graph as the basis for its
heuristic  see section     altaltp uses the standard parallel planning graph  this makes
sense given that altaltp is interested in parallel plans while altalt was aimed at generating
sequential plans  the regression state search engine for altaltp is also different from the
search module in altalt  altaltp augments the search engine of altalt with    a fattening
step and    a plan compression procedure  pushup   the details of these procedures are
discussed below 
   

fisanchez   kambhampati

action templates

parallel
planning
graph

graphplan
plan extension phase
 based on stan 

extraction of
heuristics

actions in the
last level

altaltp

heuristics

problem spec
 init  goal state 

node
expansion
 fattening 

node ordering
and selection

plan
compression
algorithm
 pushup 

solution plan

figure    architecture of altaltp

s

a  a    a        a p     a m  

a 

a 

s 

s 

ap
    

am
sp

figure    altaltp notation

   

    

sm

fionline parallelization of plans with heuristic state search

parexpand s 
a  get set of applicable actions for current state s
forall ai  a
si  regress s ai  
children s   children s    si
sp  the state among children s  with minimum
hadjsum m value
ap  the action that regresses to sp from s
   fattening process
o    ap  
forall g  s ranked in the decreasing order of level g 
find an action ag  a supporting g such that ag   o and
ai is pairwise independent with each action in o 
if there are multiple such actions  pick the one which has
minimum hadjsum  regress s  o   ag    among all ag  a
if hadjsum m  s  o   ai     hadjsum m  s  o 
o  o   ag
spar  regress s  o 
children s   children s    spar
return children
end 
figure    node expansion procedure
the general idea in altaltp is to select a fringe action ap from among those actions a
used to regress a particular state s during any stage of the search  see figure     then 
the pivot branch given by the action ap is fattened by adding more actions from a 
generating a new state that is a consequence of regression over multiple parallel actions 
the candidate actions used for fattening the pivot branch must  a  come from the sibling
branches of the pivot branch and  b  be pairwise independent with all the other actions
currently in the pivot branch  we use the standard definition of action independence  two
actions a  and a  are considered independent if the state s  resulting after regressing both
actions simultaneously is the same as that obtained by applying a  and a  sequentially with
any of their possible linearizations  a sufficient condition for this is that the preconditions
and effects of the actions do not interfere 
   prec a       ef f  a         prec a       ef f  a         
where  l  refers to the non negated versions of the literals in the set l  we now discuss
the details of how the pivot branch is selected in the first place  and how the branch is
incrementally fattened 
selecting the pivot branch  figure   shows the procedure used to select and parallelize
the pivot branch  the procedure first identifies the set of regressable actions a for the
current node s  and regresses each of them  computing the new children states  next  the
action leading to the child state with the lowest heuristic cost among the new children is
selected as the pivot action ap   and the corresponding branch becomes the pivot branch 
   

fisanchez   kambhampati

s
at pack  asu 
at pack  asu 
at pack  asu 
at pack   home 

h   
am  unload pack  airp  home 

ap  unload pack  airp  asu 

a   unload pack  airp  asu 

sp
h   
pivot
unload pack  airp  asu 
unload pack  airp  asu 
unload pack  airp  asu 
unload pack  airp  asu 
unload pack  airp  home 

s 
h   

   

sm
h   

possible pairwise
independent actions

figure    after the regression of a state  we can identify the p ivot and the related set of
pairwise independent actions 

the heuristic cost of the states is computed with the hadjsum m heuristic from altalt 
based on a parallel planning graph  specifically  in the context of the discussion of the
hadjsum m heuristic at the end of section    we compute the  p  q  values  which in turn
depend on the level p   level q  and level p  q  in terms of the levels in the parallel planning
graph rather than the serial planning graph  it is easy to show that the level of a set of
conditions on the parallel planning graph will be less than or equal to the level on the serial
planning graph  the length of the relaxed plan is still computed in terms of number of
actions  we show later  see figure    a   that this change does improve the quality of the
parallel plans produced by altaltp  
the search algorithm used in altaltp is similar to that used in hspr  bonet   geffner 
        it is a hybrid between greedy depth first and a weighted a  search  it goes depthfirst as long as the heuristic cost of any of the children states is lower than that of the
current state  otherwise  the algorithm resorts to a weighted a  search to select the next
node to expand  in this latter case  the evaluation function used to rank the nodes is
f  s    g s    w  h s  where g s  is the length of the current partial plan in terms of
number of steps  h s  is our estimated cost given by the heuristic function  e g  hadjsum m   
and w is the weight given to the heuristic function  w is set to   based on our empirical
experience  
breaking ties  in case of a tie in selecting the pivot branch  i e   more than one branch
leads to a state with the lowest heuristic cost  we break the tie by choosing the action that
   for the role of w in best first search see  korf        

   

fionline parallelization of plans with heuristic state search

supports subgoals that are harder to achieve  here  the hardness of a literal l is measured
in terms of the level in the planning graph at which l first appears  the standard rationale
for this decision  c f  kambhampati   sanchez        is that we want to fail faster by
considering the most difficult subgoals first  we have an additional justification in our case 
we also know that a subgoal with a higher level value requires more steps and actions for
its achievement because it appeared later into the planning graph  so  by supporting it
first  we may be able to achieve other easier subgoals along the way and thereby reduce the
number of parallel steps in our partial plan 
fattening the pivot branch  next the procedure needs to decide which subset o  a
of the sibling actions of the pivot action ap will be used to fatten the pivot branch  the
obvious first idea would be to fatten the pivot branch maximally by adding all pairwise
independent actions found during that search stage  the problem with this idea is that
it may add redundant and heuristically inferior actions to the branch  and satisfying their
preconditions may lead to an increase of the number of parallel steps 
so  in order to avoid fattening the pivot branch with such irrelevant actions  before
adding any action a to o  we require that the heuristic cost of the state s  that results
from regressing s over o   a be strictly lower than that of s  this is in addition to the
requirement that a be pairwise independent with the current set of actions in o  this
simple check also ensures that we do not add more than one action for supporting the same
set of subgoals in s 
the overall procedure for fattening the pivot branch thus involves picking the next
hardest subgoal g in s  with hardness measured in terms of the level of the subgoal in the
planning graph   and finding the action ag  a achieving g  which is pair wise independent
of all actions in o and which  when added to o and used to regress s  leads to a state s 
with the lowest heuristic cost  which in consequence should be lower than the cost of s 
once found  ag is then added to o  and the procedure is repeated  if there is more than one
action that can be ag   then we break ties by considering the degree of overlap between the
preconditions of action ag and the set of actions currently in o  the degree of precondition
overlap between a and o is defined as  prec a    oo prec o     the action a with higher
degree of overlap is preferred as this will reduce the amount of additional work we will need
to do to establish its preconditions  notice that because of the fattening process  a search
node may have multiple actions leading to it from its parent  and multiple actions leading
from it to each of its children 
example  figure   illustrates the use of this node expansion procedure for a problem
from the logistics domain  bacchus         in this example we have four packages pack  
pack   pack  and pack   our goal is to place the first three of them at asu and the
remaining one at home  there are two planes airp  and airp  to carry out the plans  the
figure shows the first level of the search after s has been regressed  it also shows the pivot
action ap given by unload pack  airp  asu   and a candidate set of pairwise independent
actions with respect to ap   finally  we can see in figure   the generation of the parallel
branch  notice that each node can be seen as a partial regressed plan  as described in the
paragraphs above  only actions regressing to lower heuristic estimates are considered in apar
to fatten the pivot branch  notice that the action unload pack  airp  home  has been
discarded because it leads to a state with higher cost  even though it is not inconsistent
   

fisanchez   kambhampati

s
at pack  asu 
at pack  asu 
at pack  asu 
at pack   home 
apar  unload pack  airp  asu 
unload pack  airp  asu 
unload pack  airp  asu 

h   
am  unload pack  airp  home 

a   unload pack  airp  asu 
ap  unload pack  airp  asu 

spar
h   

sp

s 
h   

h   
pivot

   

sm
h   

o
unload pack  airp  asu 
unload pack  airp  asu 
unload pack  airp  asu 
unload pack  airp  asu 
unload pack  airp  asu 
unload pack  airp  home 

figure    spar is the result of incrementally fattening the p ivot branch with the pairwise
independent actions in o

with the rest of the actions chosen to fatten the pivot branch  furthermore  we can also
see that we have preferred actions using the plane airp   since they overlap more with the
pivot action ap  
offsetting the greediness of fattening  the fattening procedure is greedy  since it
insists that the state resulting after fattening have a strictly better heuristic value  while
useful in avoiding the addition of irrelevant actions to the plan  this procedure can also
sometimes preclude actions that are ultimately relevant but were discarded because the
heuristic is not perfect  these actions may then become part of the plan at later stages
during search  i e   earlier parts of the execution of the eventual solution plan  since we are
searching in the space of plan suffixes   when this happens  the length of the parallel plan
is likely to be greater  since more steps that may be needed to support the preconditions
of such actions would be forced to come at even later stages of search  earlier parts of the
plan   had the action been allowed into the partial plan earlier in the search  i e   closer to
the end of the eventual solution plan   its preconditions could probably have been achieved
in parallel to the other subgoals in the plan  thus improving the number of steps 
in order to offset this negative effect of greediness  altaltp re arranges the partial plan
to promote such actions higher up the search branch  i e   later parts of the execution of
the eventual solution plan   specifically  before expanding a given node s  altaltp checks
to see if any of the actions in as leading to s from its parent node  i e   figure   shows
that apar leads to spar   can be pushed up to higher levels in the search branch  this online
   

fionline parallelization of plans with heuristic state search

pushup s 
as  get actions leading to s
forall a  as
x 
sx  get parent node of s
    getting highest ancestor for each action
loop
ax  get actions leading to sx
if  parallel a  ax   
x  x  
sx  get parent node of sx 
else
aj  get action conflicting with a from ax
if  secondary optimizations 
remove a and aj from branch
include anew if necessary
else
ax   ax    a
as  as  a
break
end loop
   adjusting the partial plan
sx  get highest ancestor x in history
createn ewbranchf rom sx  
while x    
snew  regress sx with ax 
sx  snew
x  x 
end 

figure    pushup procedure

re arrangement of the plan is done by the pushup procedure  which is shown in figure   
the pushup procedure is called each time before a node gets expanded  and it will try to
compress the partial plan  for each of the actions a  as we find the highest ancestor node
sx of s in the search branch to which the action can be applied  i e   it gives some literal in
sx without deleting any other literals in sx   and it is pairwise independent of all the actions
ax currently leading out of sx   in other words the condition parallel a  ax   is satisfied  
once sx is found  a is then removed from the set of actions as leading to s and introduced
into the set of actions leading out of sx  to its child in the current search branch   next  the
states in the search branch below sx are adjusted to reflect this change  the adjustment
involves recomputing the regressions of all the search nodes below sx   at first glance  this
might seem like a transformation of questionable utility since the preconditions of a  and
their regressions  just become part of the descendants of sx   and this does not necessarily
reduce the length of the plan  we however expect a length reduction because actions
supporting the preconditions of a will get pushed up eventually during later expansions 
   

fisanchez   kambhampati

s
at pack  asu 
at pack  asu 
at pack  asu 
at pack   home 
unload pack  airp  asu 
unload pack  airp  asu 
unload pack  airp  asu 

h   
unload pack  airp  home 

unload pack  airp  asu 
unload pack  airp  asu 

spar

sp

h   

   

s 

h   

h   

sm
h   

unload pack  airp  home 
fly airp  locx asu 
spar

sp

   

sm

h   
pivot

unload pack  airp  home 
fly airp  locx asu 

h   

h   

 a  finding the highest ancestor node to which an action can be
pushed up 
s

unload pack  airp  asu 
unload pack  airp  asu 
unload pack  airp  asu 
unload pack  airp  home 

at pack  asu 
at pack  asu 
at pack  asu 
at pack   home 

h   
unload pack  airp  home 

unload pack  airp  asu 
unload pack  airp  asu 
unload pack  airp  asu 

unload pack  airp  asu 

unload pack  airp  asu 
spar

snew

sp

h   

s 

h   

sm

h   

fly airp  locx asu 

fly airp  locx asu 

   

snew

spar

sp

h   

fly airp  locx asu 
unload pack  airp  home 

h   
pivot

h   

unload pack  airp  home 

   

sm
h   

h   

 b  the pushup procedure generates a new search branch 

figure    rearranging of the partial plan
   

fionline parallelization of plans with heuristic state search

rather than doctor the existing branch  in the current implementation  we just add a
new branch below sx that reflects the changes made by the pushup procedure   the new
branch then becomes the active search branch  and its leaf node is expanded next 
aggressive variation of pushup  the pushup procedure  as described above  is not
expensive as it only affects the current search branch  and the only operations involved are
recomputing the regressions in the branch  of course  it is possible to be more aggressive
in manipulating the search branch  for example  after applying an action a to its ancestor
sx the set of literals in the child state  say snew changes  and thus additional actions may
become relevant for expanding snew   in principle  we could re expand snew in light of the
new information  we decided not to go with the re expansion option  as it typically does
not seem to be worth the cost  in section      we do compare our default version of pushup
procedure with a variant that re expands all nodes in the search branch  and the results of
those studies support our decision to avoid re expansion  finally  although we introduced
the pushup procedure as an add on to the fattening step  it can also be used independent of
the latter  in which case the net effect would be an incremental parallelization of a sequential
plan 
example  in figure   a   we have two actions leading to the node spar  at depth two  
these two actions are unload pack  airp  home  and fly airp  locx asu   so  before
expanding spar we check if any of the two actions leading to it can be pushed up  while the
second action is not pushable since it interacts with the actions in its ancestor node  the first
one is  we find the highest ancestor in the partial plan that interacts with our pushable
action  in our example the root node is such an ancestor  so  we insert our pushable
action unload pack  airp  home  directly below the root node  we then re adjust the
state spar to snew at depth    as shown in figure   b   adding a new branch  and reflecting
the changes in the states below  notice that the action unload pack  airp  home  was
initially discarded by the greediness of the fattening procedure  see figure     but we have
offset this negative effect with our plan compression algorithm  we can see also that we
have not re expanded the state snew at depth    we have only made the adjustments to the
partial plan using the actions already presented in the search trace  

   evaluating the performance of altaltp
we implemented altaltp on top of altalt  we have tested our implementation on a suite
of problems that were used in the      and      aips competition  bacchus        long
  fox         as well as other benchmark problems  mcdermott         our experiments
are broadly divided into three sets  each aimed at comparing the performance of altaltp
under different scenarios 
   comparing the performance of altaltp to other planning systems capable of producing
parallel plans 
   because of the way our data structures are set up  adding the new branch turns out to be a more robust
option than manipulating the existing search branch 
   instead  the aggressive pushup modification would expand snew at depth    generating similar states to
those generated by the expansion of spar at the same depth 

   

fisanchez   kambhampati

  

  

  

  

gripper aips   

altalt p
stan
tp 
blackbox
lpg  nd

elevator aips   
altalt p
stan

  

blackbox
lpg  nd

  

  

steps

  

steps

  

  

  
  

  

 

  

 

 
 

 

 

 

 

problems

 

 

 

 

 

 

 

 

                                                           

problems

 b 

 a 

figure    performance on the gripper  aips     and the elevator  aips     domains 
  

    

altalt p
stan
blackbox

  

    

    

steps

 

time

   

 

   

 
   

 
   

 

 

 

 

                                                                

 

problems

 

 

                                                              

problems

 b 

 a 

figure     performance on the schedule domain  aips    
   comparing our incremental parallelization technique to altalt   post processing 
   ablation studies to analyze the effect of the different parts of the altaltp approach
on its overall performance 
our experiments were all done on a sun blade     workstation  running sunos    
with  gb ram  unless noted otherwise  altaltp was run with the hadjsum m heuristic
   

fionline parallelization of plans with heuristic state search

  

   

altalt p
stan
tp 
blackbox
lpg  nd

  

  

   
   

  

time

steps

  

   

   

  

   

  

   

  

   
  

  

 

 
 

 

 

 

 

                                                                               

 

 

                                                     

problems

problems

 a 

 b 

figure     performance on the logistics domain aips    

  

   

altalt p
stan
tp 
blackbox
lpg  nd
sapa

  

  

   

   

   

time

steps

   

  

  

   

  
   

 
   

 
 

 

 

 

 

 

 

 

 

  

  

  

  

  

 

  

 

problems

 

 

 

 a 

 

 

 

 

 

problems

  

  

  

  

  

  

 b 

figure     performance on the driverlog domain aips    
described in section   of this paper  and with a parallel planning graph grown until the first
level where the top level goals are present without being mutex  all times are in seconds 
    comparing altaltp with competing approaches
in the first set of experiments we have compared the performance of our planner with
the results obtained by running stan  long   fox         blackbox  kautz   selman 
   

fisanchez   kambhampati

       tp   haslum   geffner         lpg  gerevini   serina        and sapa  do  
kambhampati         unless noted otherwise  every planner has been run with its default
settings  some of the planners could not be run in some domains due to parsing problems
or memory allocation errors  in such cases  we just omit that planner from consideration
for those particular domains 
      planners used in the comparison studies
stan is a disjunctive planner  which is an optimized version of the graphplan algorithm
that reasons with invariants and symmetries to reduce the size of the search space  blackbox
is also based on the graphplan algorithm but it works by converting planning problems
specified in strips  fikes   nilsson        notation into boolean satisfiability problems
and solving it using a sat solver  the version we used defaults to satz    lpg  gerevini
  serina        was judged the best performing planner at the  rd international planning
competition  long   fox         and it is a planner based on planning graphs and local
search inspired by the walksat approach  lpg was run with its default heuristics and
settings  since lpg employs an iterative improvement algorithm  the quality of the plans
produced by it can be improved by running it for multiple iterations  thus increasing the
running time   to make the comparisons meaningful  we decided to run lpg for two
iterations  n     since beyond that  the running time of lpg was generally worse than
that of altaltp   finally  we have also chosen two metric temporal planners  which are able
to represent parallel plans because of their representation of time and durative actions 
tp   haslum   geffner        is a temporal planner based on hsp p  haslum   geffner 
       which is an optimal parallel state space planner with an ida  search algorithm 
the last planner in our list is sapa  do   kambhampati         sapa is a powerful
domain independent heuristic forward chaining planner for metric temporal domains that
employs distance based heuristics  kambhampati   sanchez        to control its search 
      comparison results in different domains
we have run the planners in the gripper domain from the international planning and
scheduling competition from       mcdermott         as well as three different domains
 logistics  scheduling  and elevator miconic strips  from       bacchus         and three
more from the      competition  long   fox          driverlog  zenotravel  and satellite 
in cases where there were multiple versions of a domain  we used the strips untyped
versions     we discuss the results of each of the domains below 
gripper  in figure   a   we compare the performance of altaltp on the gripper domain  mcdermott        to the rest of the planners excluding sapa  the plot shows the
results in terms of number of  parallel  steps  we can see that for even this simplistic domain  altaltp and lpg are the only planners capable of scaling up and generating parallel
   we have not chosen ipp  koehler         which is also an optimized graphplan planning system because
results reported by haslum and geffner        show that it is already less efficient than stan 
   since sapa does not read the strips file format  we have run the sapa planner on equivalent problems
with unit duration actions from long and fox        

   

fionline parallelization of plans with heuristic state search

    

  

altalt p
stan
lpg  nd
sapa

  

    
    

  
    

  

    

steps

time

  

  

    
    
    

  
    

 

   
 

 
 

 

 

 

 

 

 

 

 

  

  

  

  

  

 

  

problems

 

 

 

 

 

 

 

 

  

  

  

  

  

  

problems

 b 

 a 

figure     performance on the zenotravel domain  aips    
plans  none of the other approaches is able to solve more than four problems   altaltp is
able to scale up without any difficulty to problems involving    balls  furthermore  altaltp
returns better plans than lpg 
elevator  in figure   b   we compare altaltp to stan  blackbox and lpg in the elevator
domain  miconic strips   bacchus          altaltp approached the quality of the solutions
produced by the optimal approaches  e g  blackbox and stan   notice that blackbox can
only solve around half of the problems solved by altaltp in this domain 
scheduling  results from the scheduling domain are shown in figure     only blackbox
and stan are considered for comparison   altaltp seems to reasonably approximate the
optimal parallel plans for many problems  around    of them   but does produce significantly
suboptimal plans for some  however  it is again able to solve more problems than the other
two approaches and in a fraction of the time 
logistics  the plots corresponding to the logistics domain from bacchus        are shown
in figure       for some of the most difficult problems altaltp outputs lower quality
solutions than the optimal approaches  however  only altaltp and lpg are able to scale
up to more complex problems  and we can easily see that altaltp provides better quality
solutions than lpg  altaltp also seems to be more efficient than any of the other approaches 
   although stan is supposed to be able to generate optimal step length plans  in a handful of cases it
seems to have produced nonoptimal solutions for the gripper domain  we have no explanation for this
behavior  but have informed the authors of the code 
   we did not include the traces from tp  because the pre processor of the planner was not able to read
the domain 
   the tp  pre processor cannot read this domain  lpg runs out of memory  and sapa has parsing
problems 
    only sapa is excluded due to parsing problems 

   

fisanchez   kambhampati

    

  

altalt p
stan
tp 
blackbox

  

    
    

lpg  nd
sapa

  

    
    

steps

time

  

    
    

  
    
    

  

   

 

 

 

 

 

 

 

 

 

 

 

                             

 

 

 

 

 

 

 

 

 

  

  

  

  

  

  

  

  

  

  

problems

problems

 b 

 a 

figure     performance on the satellite domain aips    
the lpg solutions for problems    to    are obtained doing only one iteration  since lpg
was not able to complete the second iteration in a reasonable amount of time  this explains
the low time taken for lpg  and the lower quality of its solutions 
driverlog  we see in figure    a  that altaltp does reasonably well in terms of quality
with respect to the other approaches in the driverlog domain  every planner is considered
this time  altaltp is one of the two planners able to scale up  figure    b  shows also that
altaltp is more efficient than any of the other planners 
zeno travel  only altaltp   sapa  and lpg are able to solve most of the problems in this
domain    altaltp solves them very efficiently  figure    b   providing very good solution
quality  figure    a   compared to the temporal metric planners 
satellite  the results from the satellite domain are shown in figure     although every
planner is considered  only altaltp   sapa  and lpg can solve most of the problems  sapa
solves all problems but produces lower quality solutions for many of them  altaltp produces
better solution quality than sapa  and is also more efficient  however  altaltp produces
lower quality solutions than lpg in four problems  lpg cannot solve one of the problems
and produces lower quality solutions in   of them 
summary  in summary  we note that altaltp is significantly superior in the elevator and
gripper domains  it also performs very well in the driverlog  zenotravel  and satellite
domains from the      competition  long   fox         the performance of all planners
is similar in the schedule domain  in the logistics domain  the quality of altaltp plans
are second only to those of blackbox for the problems that this optimal planner can solve 
however  it scales up along with lpg to bigger size problems  returning very good step    blackbox and tp  are not able to parse this domain 

   

fionline parallelization of plans with heuristic state search

   

   

altalt postproc
altalt p
altalt

   

   

   
   

   

time

steps

   
   

   
   
   

  

   
 

 

 

 

                                                       

 

 

 

                                                     

problems

problems

 a 

 b 

figure     altalt and post processing vs  altaltp  logistics domain 

   

  

altalt
altalt postproc
altalt p

  

   
   
   

time

  

steps

  

   
   
   

  

   
  
  
 

 
 

 

 

 

 

 

 

 

problems

 

  

  

  

  

  

 

  

 

 

 

 

 

 

 

 

  

  

  

  

  

  

problems

 a 

 b 

figure     altalt and post processing vs  altaltp  zenotravel domain 

length quality plans  tp   the only other heuristic state search regression planner capable
of producing parallel plans is not able to scale up in most of the domains  sapa  a heuristic
search progression planner  while competitive  is still outperformed by altaltp in planning
time and solution quality 
   

fisanchez   kambhampati

solution  solution found  length     
time    load truck obj   tru  pos   level   
time    load truck obj   tru  pos   level   
time    load truck obj   tru  pos   level   
time    drive truck tru  pos  apt  cit   level   
time    unload truck obj   tru  apt   level   
time    fly airplane apn  apt  apt   level   
time    unload truck obj   tru  apt   level   
time    load airplane obj   apn  apt   level   
time    load airplane obj   apn  apt   level   
time    load truck obj   tru  pos   level   
time    fly airplane apn  apt  apt   level   
time    drive truck tru  pos  apt  cit   level   
time    unload airplane obj   apn  apt   level   
time    load truck obj   tru  apt   level   
time    unload truck obj   tru  apt   level   
time    drive truck tru  apt  pos  cit   level   
time    unload airplane obj   apn  apt   level   
time    unload truck obj   tru  apt   level   
time    unload truck obj   tru  pos   level   
total number of actions in plan    

post processed plan    
time      load truck obj   tru  pos  
time      load truck obj   tru  pos  
time      load truck obj   tru  pos  
time      fly airplane apn  apt  apt  
time      load truck obj   tru  pos  
time      drive truck tru  pos  apt  cit  
time      drive truck tru  pos  apt  cit  
time      unload truck obj   tru  apt  
time      unload truck obj   tru  apt  
time      unload truck obj   tru  apt  
time      unload truck obj   tru  apt  
time      load airplane obj   apn  apt  
time      load airplane obj   apn  apt  
time      fly airplane apn  apt  apt  
time      unload airplane obj   apn  apt  
time      unload airplane obj   apn  apt  
time      load truck obj   tru  apt  
time      drive truck tru  apt  pos  cit  
time      unload truck obj   tru  pos  
end of post processing  actions     length   

 a  altaltp solution

 b  altaltp plus post processing

figure     plots showing that altaltp solutions cannot be improved anymore by postprocessing 

    comparison to post processing approaches
as we mentioned earlier  see section     one way of producing parallel plans that has been
studied previously in the literature is to post process sequential plans  backstrom         to
compare online parallelization to post processing  we have implemented backstrom       s
minimal de ordering algorithm  and used it to post process the sequential plans produced
by altalt  running with its default heuristic hadjsum m using a serial planning graph   in
this section we will compare our online parallelization procedure to this offline method 
the first set of experiments is on the logistics domain  bacchus         the results are
shown in figure     as expected  the original altalt has the longest plans since it allows
only one action per time step  the plot shows that post processing techniques do help in
reducing the makespan of the plans generated by altalt  however  we also notice that
altaltp outputs plans with better makespan than either altalt or altalt followed by postprocessing  this shows that online parallelization is a better approach than post processing
sequential plans  moreover  the plot in figure    b  shows that the time taken by altaltp
is largely comparable to that taken by the other two approaches  in fact  there is not much
additional cost overhead in our procedure 
figure    repeats these experiments in the zenotravel domain  long   fox         once
again  we see that altaltp produces better makespan than post processing the sequential
plans of altalt  notice that this time  altalt plus post processing is clearly less efficient
   

fionline parallelization of plans with heuristic state search

   

logistics aips   

   

altalt p
altalt p nopush
altalt p agr

   

logistics aips   

   

   

time

steps

   

  

   

  
   

  
   

  

 

 

 

 

 

                                                                                       

                                                     

problems

problems

 a 

   

 b 

satellite aips   

   

satellite aips   

  

altalt p
altalt nopush
altalt p agr

  

   

  

   

time

steps

  

  
  

   

  
  

  

  
 

 

 

 

 

 

 

 

 

 

                                  

problems

 

 

 

 

 

 

 

 

 

  

  

  

  

  

  

  

  

  

  

  

problems

 c 

 d 

figure     analyzing the effect of the pushup procedure

than either of the other two approaches  in summary  the results of this section demonstrate
that altaltp is superior to altalt plus post processing 
one might wonder if the plans generated by altaltp can also benefit from the postprocessing phase  we have investigated this issue and found that the specific post processing
routines that we used do not produce any further improvements  the main reason for
this behavior is that the pushup procedure already tries to exploit any opportunity for
shortening the plan length by promoting actions up in the partial plan  as an illustrative
example  we show  in figure     the parallel plan output by altaltp for a problem from the
logistics domain  logistics     from bacchus         and the result of post processing
   

fisanchez   kambhampati

  

   

logistics aips   

blocksworld aips   

serial pg
parallel pg

  

   

  

altalt p
altalt

   

  

time

steps

  

  

  

  
  

  
  

  

 

 
 

 

 

                                                     

 

 

 

 

 

  

  

problems

  

  

  

  

problems

  

  

  

  

  

  

  

 b  solving a serial domain

 a  utility of using parallel planning graphs

figure     plots showing the utility of using parallel planning graphs in computing the
heuristics  and characterizing the overhead incurred by altaltp in serial domains 

this solution  although the two solutions differ in terms of step contents  we notice that
they have the same step length  the difference in step contents can be explained by the fact
that the de ordering algorithm relaxes the ordering relations in the plan  allowing for some
actions to come earlier  while pushup always moves actions towards the end of the plan 
we have run more comprehensive studies in three different domains  logistics  satellite and
zenotravel   and found that in no case is the step length of a plan produced by altaltp
improved by the post processing routine  we omit the comparison plots since they essentially
show the curves corresponding to altaltp and altaltp with post processing coincident    
    ablation studies
this section attempts to analyze the impact of the different parts of altaltp on its performance 
utility of the pushup procedure  figure    shows the effects of running altaltp with
and without the pushup procedure  but with the fattening procedure   as well as running
it with a more aggressive version of pushup  which as described in section    re expands all
the nodes in the search branch  after an action has been pushed up  we can see that running
altaltp with the pushup and fattening procedures is better than just the latter  comparison
of results in figure    a  and figure    a  shows that even just the fattening procedure
performs better than the original altalt  in figure    b  we can see that although the
pushup procedure does not add much overhead  the aggressive version of pushup does get
quite expensive  we also notice that only around    problems are solved within time limits
    we also verified this with at least one problem in all the other domains 

   

fionline parallelization of plans with heuristic state search

with aggressive pushup  the plots in figure    c  and figure    d  show the results of the
same experiments in the satellite domain  we see that the situation is quite similar in this
domain  we can conclude then that the pushup procedure  used to offset the greediness of
the algorithm  achieves its purpose 
utility of basing heuristics on parallel planning graphs  we can see in figure    a  that using parallel planning graph as the basis for deriving heuristic estimates
in altaltp is a winning idea  the serial planning graph overestimates the heuristic values
in terms of steps  producing somewhat longer parallel solutions  the fact that the version
using serial planning graph runs out of time in many problems also demonstrates that the
running times are also improved by the use of parallel planning graphs 
comparison to altalt  one final concern would be how much of an extra computational
hit is taken by the altaltp algorithm in serial domains  e g  blocks world from bacchus 
       we expect it to be negligible and to confirm our intuitions  we ran altaltp on a set
of problems from the sequential blocks world domain  we see from the plot    b  that the
time performance between altalt and altaltp are equivalent for almost all of the problems 

   related work
the idea of partial exploration of parallelizable sets of actions is not new  kabanza       
godefroid   kabanza        do   kambhampati         it has been studied in the area
of concurrent and reactive planning  where one of the main goals is to approximate optimal
parallelism  however  most of the research there has been focused on forward chaining
planners  kabanza         where the state of the world is completely known  it has been
implied that backward search methods are not suitable for this kind of analysis  godefroid
  kabanza        because the search nodes correspond to partial states  we have shown
that backward search methods can also be used to approximate parallel plans in the context
of classical planning 
optimization of plans according to different criteria  e g  execution time  quality  etc 
has also been done as a post processing step  the post processing computation of a given
plan to maximize its parallelism has been discussed by backstrom         reordering and
de ordering techniques are used to maximize the parallelism of the plan  in de ordering
techniques ordering relations can only be removed  not added  in reordering  arbitrary
modifications to the plan are allowed  in the general case this problem is np hard and
it is difficult to approximate  backstrom         furthermore  as discussed in section  
and    post processing techniques are just concerned with modifying the order between the
existing actions of a given plan  our approach not only considers modifying such orderings
but also inserting new actions online which can minimize the possible number of parallel
steps of the overall problem 
we have already discussed graphplan based planners  long   fox        kautz  
selman         which return optimal plans based on the number of time steps  graphplan
uses ida  to include the greatest number of parallel actions at each time step of the
search  however  this iterative procedure is very time consuming and it does not provide
any guarantee on the number of actions in its final plans  there have been a few attempts
to minimize the number of actions in these planners  huang  selman    kautz        by
   

fisanchez   kambhampati

using some domain control knowledge based on the generation of rules for each specific
planning domain  the graphplan algorithm tries to maximize its parallelism by satisfying
most of the subgoals at each time step  if the search fails then it backtracks and reduces
the set of parallel actions being considered one level before  altaltp does the opposite  it
tries to guess initial parallel nodes given the heuristics  and iteratively adds more actions
to these nodes as possible with the pushup procedure later during search 
more recently  there has been some work on generalizing forward state search to handle action concurrency in metric temporal domains  of particular relevance to this work
are the temporal tlplan  bacchus   ady        and sapa  do   kambhampati        
both these planners are designed specifically for handling metric temporal domains  and use
similar search strategies  the main difference between them being that temporal tlplan
depends on hand coded search control knowledge to guide its search  while sapa  like
altaltp   uses heuristics derived from  temporal  planning graphs  as such  both these
planners can be co opted to produce parallel plans in classical domains  both these planners do a forward chaining search  and like altaltp   both of them achieve concurrency
incrementally  without projecting sets of actions  in the following way  normal forward
search planners start with the initial state s    corresponding to time t    consider all actions
that apply to s    and choose one  say a  apply it to s    getting s    they simultaneously
progress the system clock from t  to t    in order to allow for concurrency  the planners
by bacchus and ady         and do and kambhampati        essentially decouple the
action application and clock progression  at every point in the search  there is a nondeterministic choice   between progressing the clock  or applying  additional  actions at the
current time point  from the point of view of these planners  altaltp can be seen as providing heuristic guidance for this non deterministic choice  modulo the difference that altaltp
does regression search   the results of empirical comparisons between altaltp and sapa 
which show that altaltp outperforms sapa  suggest that the heuristic strategies employed
in altaltp including the incremental fattening  and the pushup procedure  can be gainfully
adapted to these planners to increase the concurrency in the solution plans  finally  hsp  
and tp   its extension to temporal domains  are both heuristic state search planners using
regression that are capable of producing parallel plans  haslum   geffner         tp  can
be seen as the regression version of the approach used in sapa and temporal tlplan  our
experiments however demonstrate that neither of these planners scales well in comparison
to altaltp  
the pushup procedure can be seen as a plan compression procedure  as such  it is similar
to other plan compression procedures such as double back optimization  crawford        
one difference is that double back is used in the context of a local search  while pushup
is used in the context of a systematic search  double back could be also applied to any
finished plan or schedule  but as any other post processing approach its outcome would
depend highly on the plan given as input 

   concluding remarks
motivated by the acknowledged inability of heuristic search planners to generate parallel
plans  we have developed and presented an approach to generate parallel plans in the
context of altalt  a heuristic state space planner  this is a challenging problem because of
   

fionline parallelization of plans with heuristic state search

the exponential branching factor incurred by naive methods  our approach tries to avoid
the branching factor blow up by greedy and online parallelization of the evolving partial
plans  a plan compression procedure called pushup is used to offset the ill effects of the
greedy search  our empirical results show that in comparison to other planners capable of
producing parallel plans  altaltp is able to provide reasonable quality parallel plans in a
fraction of the time of competing approaches  our approach also seems to provide better
quality plans than can be achieved by post processing sequential plans  our results show
that altaltp provides an attractive tradeoff between quality and efficiency in the generation
of parallel plans  in the future  we plan to adapt the altaltp approach to metric temporal
domains  where the need for concurrency is more pressing  one idea is to adapt some of
the sources of strength in altaltp to sapa  a metric temporal planner being developed in
our group  do   kambhampati        

acknowledgments
we thank minh b  do and xuanlong nguyen for helpful discussions and feedback  we also
thank david smith and the jair reviewers for many constructive comments  this research
is supported in part by the nasa grants nag       and ncc       and the nsf grant
iri         

references
bacchus  f          the aips   planning competition  ai magazine               
bacchus  f     ady  m          planning with resources and concurrency  a forward
chaining approach  in proceedings of ijcai     pp         
backstrom  c          computational aspects of reordering plans  journal of artificial
intelligence research           
blum  a     furst  m          fast planning through planning graph analysis  artificial
intelligence             
bonet  b     geffner  h          planning as heuristic search  new results  in proceedings
of ecp    
bonet  b   loerincs  g     geffner  h          a robust and fast action selection mechanism
for planning  in proceedings of aaai     pp          aaai press 
crawford  j          an approach to resource constrained project scheduling  in proceedings
of the      artificial intelligence and manufacturing research planning workshop 
aaai press 
do  m  b     kambhampati  s          solving planning graph by compiling it into a csp 
in proceedings of aips     pp       
do  m  b     kambhampati  s          sapa  a domain independent heuristic metric
temporal planner  in proceedings of ecp    
   

fisanchez   kambhampati

fikes  r     nilsson  n          strips  a new approach to the application of theorem
proving to problem solving  artificial intelligence                  
gerevini  a     serina  i          lpg  a planner based on local search for planning graphs 
in proceedings of aips     aaai press 
godefroid  p     kabanza  f          an efficient reactive planner for synthesizing reactive
plans  in proceedings of aaai     vol     pp          aaai press mit press 
haslum  p     geffner  h          admissible heuristics for optimal planning  in proceedings
of aips     pp         
haslum  p     geffner  h          heuristic planning with time and resources  in proceedings
of ecp     springer 
huang  y   selman  b     kautz  h          control knowledge in planning  benefits and
tradeoffs  in proceedings of aaai iaai     pp         
kabanza  f          planning and verifying reactive plans  position paper   in proceedings
of aaai    workshop on immobots  theories of action  planning and control 
kambhampati  s     sanchez  r          distance based goal ordering heuristics for graphplan  in proceedings of aips     pp         
kautz  h     selman  b          pushing the envelope  planning  propositional logic  and
stochastic search  in proceedings of aaai     pp            aaai press 
kautz  h     selman  b          blackbox  unifying sat based and graph based planning 
in proceedings of ijcai    
koehler  j          rifo within ipp  tech  rep       university of freiburg 
korf  r          linear space best first search  artificial intelligence           
long  d     fox  m          efficient implementation of the plan graph in stan  journal
of artificial intelligence research            
long  d     fox  m          the  rd international planning competition  results and
analysis  to appear in jair 
mcdermott  d          using regression match graphs to control search in planning  artificial intelligence                    
mcdermott  d          the      ai planning systems competition  ai magazine         
     
nguyen  x     kambhampati  s          extracting effective and admissible heuristics from
the planning graph  in proceedings of aaai iaai     pp         
nguyen  x   kambhampati  s     sanchez  r          planning graph as the basis for deriving heuristics for plan synthesis by state space and csp search  artificial intelligence 
                 
   

fionline parallelization of plans with heuristic state search

sanchez  r   nguyen  x     kambhampati  s          altalt  combining the advantages of
graphplan and heuristics state search  in proceedings of kbcs     bombay  india 

   

fi