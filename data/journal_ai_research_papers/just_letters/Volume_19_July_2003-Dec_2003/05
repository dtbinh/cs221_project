journal artificial intelligence research                  

submitted        published      

altaltp   online parallelization plans
heuristic state search
romeo sanchez nigenda
subbarao kambhampati

rsanchez asu edu
rao asu edu

department computer science engineering 
arizona state university  tempe az           

abstract
despite near dominance  heuristic state search planners still lag behind disjunctive
planners generation parallel plans classical planning  reason directly
searching parallel solutions state space planners would require planners branch
possible subsets parallel actions  thus increasing branching factor exponentially 
present variant heuristic state search planner altalt called altaltp
generates parallel plans using greedy online parallelization partial plans  greedy
approach significantly informed use novel distance heuristics altaltp
derives graphplan style planning graph problem  approach
guaranteed provide optimal parallel plans  empirical results show altaltp
capable generating good quality parallel plans fraction cost incurred
disjunctive planners 

   introduction
heuristic state space search planning proved one efficient planning
frameworks solving large deterministic planning problems  bonet  loerincs    geffner 
      bonet   geffner        bacchus         despite near dominance  one achilles
heel remains generation parallel plans  haslum   geffner         parallel plans allow
concurrent execution multiple actions time step  concurrency likely
important progress temporal domains  disjunctive planners
graphplan  blum   furst        satplan  kautz   selman        gpcsp  do   kambhampati        seem trouble generating parallel plans 
planners search space states overwhelmed task  main reason
straightforward methods generation parallel plans would involve progression
regression sets actions  increases branching factor search space
exponentially  given n actions  branching factor simple progression regression
search bounded n  progression regression search parallel plans
bounded  n  
inability state search planners producing parallel plans noted
literature previously  past attempts overcome limitation successful  indeed  haslum geffner        consider problem generating parallel
plans using regression search space states  note resulting planner  hsp p  scales significantly worse graphplan  present tp   haslum  
geffner         addition aimed actions durations  improves
c
    
ai access foundation  rights reserved 

fisanchez   kambhampati

branching scheme hsp p  making incremental along lines graphplan 
empirical studies reported haslum geffner         however indicate even
new approach  unfortunately  scales quite poorly compared graphplan variants  informally  achilles heel heuristic state search planners interpreted sort
last stand disjunctive planners capable generating parallel plans
efficiently 
given way efficiently generating optimal parallel plans involves using
disjunctive planners  might want consider ways generating near optimal parallel
plans using state search planners  one obvious approach post process sequential
plans generated state search planners make parallel  easily
done   using approaches explored backstrom         one drawback
approaches limited transforming sequential plan given input 
parallelization sequential plans often results plans close optimal parallel
plans  
alternative  explore paper  involves incremental online parallelization 
specifically  planner altaltp   variant altalt planner  sanchez  nguyen 
  kambhampati        nguyen  kambhampati    sanchez         starts search
space regression single actions  promising single action regress
selected  altaltp attempts parallelize  fatten  selected search branch
independent actions  parallelization done greedy incremental fashion actions considered addition current search branch based heuristic cost
subgoals promise achieve  parallelization continues next step
state resulting addition new action better heuristic cost 
sub optimality introduced greedy nature parallelization offset
extent plan compression procedure called pushup tries rearrange evolving
parallel plans pushing actions higher levels search branch  i e  later stages
execution  plan 
despite seeming simplicity approach  proven quite robust
practice  fact  experimental comparison five competing planners   stan  long
  fox         lpg  gerevini   serina         blackbox  kautz   selman         sapa  do
  kambhampati        tp   haslum   geffner          shows altaltp viable
scalable alternative generating parallel plans several domains  many problems 
altaltp able generate parallel plans close optimal makespan 
seems retain efficiency advantages heuristic state search disjunctive planners 
producing plans fraction time taken disjunctive planners many cases 
altaltp found superior post processing approaches  specifically 
compared altaltp approach involves post processing sequential plans
generated altalt using techniques backstrom         found altaltp
able generate shorter parallel plans many cases  finally  show altaltp incurs
little additional overhead compared altalt 
rest paper  discuss implementation evaluation approach
generate parallel plans altaltp   section   starts providing review
altalt planning system  altaltp based  section   describes generation
   empirically demonstrate later  curious readers may refer plots figure    

   

fionline parallelization plans heuristic state search

action templates

serial planning
graph

graphplan
plan extension phase
 based stan 

problem spec
 init  goal state 

extraction
heuristics

actions
last level

altalt

heuristics

regression planner
 based hsp r 

solution plan

figure    architecture altalt
parallel plans altaltp   section   presents extensive empirical evaluation altaltp  
evaluation includes comparison ablation studies  finally  section   discusses
related work classical well metric temporal planning  section   summarizes
contributions 

   altalt background architecture heuristics
altalt planning system based combination graphplan  blum   furst       
long   fox        kautz   selman        heuristic state space search  bonet et al  
      bonet   geffner        mcdermott        technology  altalt extracts powerful
heuristics planning graph data structure guide regression search space
states  high level architecture altalt shown figure    problem specification
action template description first fed graphplan style planner  in case 
stan long   fox         constructs planning graph problem
polynomial time  we assume reader familiar graphplan algorithm blum
  furst         planning graph structure fed heuristic extractor module
capable extracting variety effective heuristics  nguyen   kambhampati 
      nguyen et al          heuristics  along problem specification 
set ground actions final action level planning graph structure fed
regression state search planner 
explain operation altalt detailed level  need provide
background various components  shall start regression search
module  regression search process searching space potential plan suffixes  suffixes generated starting goal state regressing
set relevant action instances domain  resulting states  nondeterministically  regressed relevant action instances  process repeated
reach state  set subgoals  satisfied initial state  state
framework set  conjunction of  literals seen subgoals need
made true way achieving top level goals  action instance considered
relevant state effects give least one element delete
   

fisanchez   kambhampati

element s  result regressing  s ef f  a   prec a   
essentially set goals still need achieved application a 
everything would achieved applied  relevant action
a  separate search branch generated  result regressing action
new fringe branch  search terminates success node every literal
state corresponding node present initial state problem 
crux controlling regression search involves providing heuristic function
estimate relative goodness states fringe current search tree
guide search promising directions  heuristic function needs evaluate
cost achieving set subgoals  comprising regressed state  initial
state  words  heuristic computes length plan needed achieve
subgoals initial state  discuss heuristic computed
planning graph  which  provides optimistic reachability estimates 
normally  planning graph data structure supports parallel plans   i e   plans
step one action may executed simultaneously  since want planning graph provide heuristics regression search module altalt  generates
sequential solutions  first make modification algorithm generates
serial planning graph  serial planning graph planning graph which  addition
normal mutex relations  every pair non noop actions level marked
mutex  additional action mutexes propagate give additional propositional mutexes  finally  planning graph said level change action 
proposition mutex lists two consecutive levels 
assume given problem  graphplan module altalt used
generate expand serial planning graph levels off  discussed sanchez
et al          relax requirement growing planning graph level off 
tolerate graded loss informedness heuristics derived planning graph 
start notion level set propositions 
definition    level  given set propositions  lev s  index first level
leveled serial planning graph propositions appear non mutex
one another  singleton  lev s  index first level
singleton element occurs  level exists  lev s    planning graph
grown level off 
intuition behind definition level literal p serial planning
graph provides lower bound length plan  which  serial planning graph 
equal number actions plan  achieve p initial state  using
insight  simple way estimating cost set subgoals sum levels 
heuristic    sum heuristic  hsum  s    

p

ps

lev  p  

sum heuristic similar greedy regression heuristic used unpop  mcdermott        heuristic used hsp planner  bonet et al          main
limitation heuristic makes implicit assumption subgoals  elements
s  independent  hsum heuristic neither admissible particularly informed
ignores interactions subgoals  develop effective heuristics 
   

fionline parallelization plans heuristic state search

need consider positive negative interactions among subgoals limited
fashion 
 nguyen et al          discuss variety ways using planning graph
incorporate negative positive interactions heuristic estimate  discuss
relative tradeoffs  one best heuristics according analysis heuristic called
hadjsum m   adopted heuristic default heuristic altalt  basic idea
hadjsum m adjust sum heuristic take positive negative interactions
account  heuristic approximates cost achieving subgoals set
sum cost achieving s  considering positive interactions ignoring negative
interactions  plus penalty ignoring negative interactions  first component
rp  s  computed length relaxed plan supporting s 
extracted ignoring mutex relations  approximate penalty induced
negative interactions alone  proceed following argument  consider pair
subgoals p  q s  negative interactions p q  lev  p  q   
level p q present together  exactly maximum lev p  lev q  
degree negative interaction p q thus quantified by 
 p  q    lev  p  q   max  lev p   lev q  
want use   values characterize amount negative interactions
present among subgoals given set s  subgoals pair wise independent 
clearly  values zero  otherwise pair subgoals different
value  largest value among pair subgoals used measure
negative interactions present heuristic hadjsum m   summary 
heuristic    adjusted  m  hadjsum m  s     length rp  s     maxp qs  p  q 
analysis nguyen et al         shows one robust heuristics
terms solution time quality  thus default heuristic used altalt
 as well altaltp   see below  

   generation parallel plans using altaltp
obvious way make altalt produce parallel plans would involve regressing subsets
 non interfering  actions  unfortunately  increases branching factor exponentially
infeasible practice  instead  altaltp uses greedy depth first approach makes
use heuristics regress single actions  incrementally parallelizes partial plan
step  rearranging partial plan later necessary 
high level architecture altaltp shown figure    notice heuristic
extraction phase altaltp similar altalt  one important modification  contrast altalt uses serial planning graph basis
heuristic  see section     altaltp uses standard parallel planning graph  makes
sense given altaltp interested parallel plans altalt aimed generating
sequential plans  regression state search engine altaltp different
search module altalt  altaltp augments search engine altalt    fattening
step    plan compression procedure  pushup   details procedures
discussed below 
   

fisanchez   kambhampati

action templates

parallel
planning
graph

graphplan
plan extension phase
 based stan 

extraction
heuristics

actions
last level

altaltp

heuristics

problem spec
 init  goal state 

node
expansion
 fattening 

node ordering
selection

plan
compression
algorithm
 pushup 

solution plan

figure    architecture altaltp



a  a    a        a p     a  

a 

a 

s 

s 

ap
    


sp

figure    altaltp notation

   

    

sm

fionline parallelization plans heuristic state search

parexpand s 
get set applicable actions current state
forall ai
si regress s ai  
children s  children s    si
sp state among children s  minimum
hadjsum m value
ap action regresses sp
   fattening process
  ap  
forall g ranked decreasing order level g 
find action ag supporting g ag  
ai pairwise independent action o 
multiple actions  pick one
minimum hadjsum  regress s    ag    among ag
hadjsum m  s    ai     hadjsum m  s  o 
  ag
spar regress s  o 
children s  children s    spar
return children
end 
figure    node expansion procedure
general idea altaltp select fringe action ap among actions
used regress particular state stage search  see figure     then 
pivot branch given action ap fattened adding actions a 
generating new state consequence regression multiple parallel actions 
candidate actions used fattening pivot branch must  a  come sibling
branches pivot branch  b  pairwise independent actions
currently pivot branch  use standard definition action independence  two
actions a  a  considered independent state resulting regressing
actions simultaneously obtained applying a  a  sequentially
possible linearizations  sufficient condition preconditions
effects actions interfere 
   prec a      ef f  a        prec a      ef f  a        
 l  refers non negated versions literals set l  discuss
details pivot branch selected first place  branch
incrementally fattened 
selecting pivot branch  figure   shows procedure used select parallelize
pivot branch  procedure first identifies set regressable actions
current node s  regresses them  computing new children states  next 
action leading child state lowest heuristic cost among new children
selected pivot action ap   corresponding branch becomes pivot branch 
   

fisanchez   kambhampati


at pack  asu 
at pack  asu 
at pack  asu 
at pack   home 

h   
am  unload pack  airp  home 

ap  unload pack  airp  asu 

a   unload pack  airp  asu 

sp
h   
pivot
unload pack  airp  asu 
unload pack  airp  asu 
unload pack  airp  asu 
unload pack  airp  asu 
unload pack  airp  home 

s 
h   

   

sm
h   

possible pairwise
independent actions

figure    regression state  identify p ivot related set
pairwise independent actions 

heuristic cost states computed hadjsum m heuristic altalt 
based parallel planning graph  specifically  context discussion
hadjsum m heuristic end section    compute  p  q  values  turn
depend level p   level q  level p  q  terms levels parallel planning
graph rather serial planning graph  easy show level set
conditions parallel planning graph less equal level serial
planning graph  length relaxed plan still computed terms number
actions  show later  see figure    a   change improve quality
parallel plans produced altaltp  
search algorithm used altaltp similar used hspr  bonet   geffner 
        hybrid greedy depth first weighted a  search  goes depthfirst long heuristic cost children states lower
current state  otherwise  algorithm resorts weighted a  search select next
node expand  latter case  evaluation function used rank nodes
f  s    g s    w h s  g s  length current partial plan terms
number steps  h s  estimated cost given heuristic function  e g  hadjsum m   
w weight given heuristic function  w set   based empirical
experience  
breaking ties  case tie selecting pivot branch  i e   one branch
leads state lowest heuristic cost  break tie choosing action
   role w best first search see  korf        

   

fionline parallelization plans heuristic state search

supports subgoals harder achieve  here  hardness literal l measured
terms level planning graph l first appears  standard rationale
decision  c f  kambhampati   sanchez        want fail faster
considering difficult subgoals first  additional justification case 
know subgoal higher level value requires steps actions
achievement appeared later planning graph  so  supporting
first  may able achieve easier subgoals along way thereby reduce
number parallel steps partial plan 
fattening pivot branch  next procedure needs decide subset
sibling actions pivot action ap used fatten pivot branch 
obvious first idea would fatten pivot branch maximally adding pairwise
independent actions found search stage  problem idea
may add redundant heuristically inferior actions branch  satisfying
preconditions may lead increase number parallel steps 
so  order avoid fattening pivot branch irrelevant actions 
adding action o  require heuristic cost state results
regressing   strictly lower s  addition
requirement pairwise independent current set actions o 
simple check ensures add one action supporting
set subgoals s 
overall procedure fattening pivot branch thus involves picking next
hardest subgoal g  with hardness measured terms level subgoal
planning graph   finding action ag achieving g  pair wise independent
actions which  added used regress s  leads state
lowest heuristic cost  consequence lower cost s 
found  ag added o  procedure repeated  one
action ag   break ties considering degree overlap
preconditions action ag set actions currently o  degree precondition
overlap defined  prec a   oo prec o     action higher
degree overlap preferred reduce amount additional work need
establish preconditions  notice fattening process  search
node may multiple actions leading parent  multiple actions leading
children 
example  figure   illustrates use node expansion procedure problem
logistics domain  bacchus         example four packages pack  
pack   pack  pack   goal place first three asu
remaining one home  two planes airp  airp  carry plans 
figure shows first level search regressed  shows pivot
action ap given unload pack  airp  asu   candidate set pairwise independent
actions respect ap   finally  see figure   generation parallel
branch  notice node seen partial regressed plan  described
paragraphs above  actions regressing lower heuristic estimates considered apar
fatten pivot branch  notice action unload pack  airp  home 
discarded leads state higher cost  even though inconsistent
   

fisanchez   kambhampati


at pack  asu 
at pack  asu 
at pack  asu 
at pack   home 
apar  unload pack  airp  asu 
unload pack  airp  asu 
unload pack  airp  asu 

h   
am  unload pack  airp  home 

a   unload pack  airp  asu 
ap  unload pack  airp  asu 

spar
h   

sp

s 
h   

h   
pivot

   

sm
h   


unload pack  airp  asu 
unload pack  airp  asu 
unload pack  airp  asu 
unload pack  airp  asu 
unload pack  airp  asu 
unload pack  airp  home 

figure    spar result incrementally fattening p ivot branch pairwise
independent actions

rest actions chosen fatten pivot branch  furthermore 
see preferred actions using plane airp   since overlap
pivot action ap  
offsetting greediness fattening  fattening procedure greedy  since
insists state resulting fattening strictly better heuristic value 
useful avoiding addition irrelevant actions plan  procedure
sometimes preclude actions ultimately relevant discarded
heuristic perfect  actions may become part plan later stages
search  i e   earlier parts execution eventual solution plan  since
searching space plan suffixes   happens  length parallel plan
likely greater  since steps may needed support preconditions
actions would forced come even later stages search  earlier parts
plan   action allowed partial plan earlier search  i e   closer
end eventual solution plan   preconditions could probably achieved
parallel subgoals plan  thus improving number steps 
order offset negative effect greediness  altaltp re arranges partial plan
promote actions higher search branch  i e   later parts execution
eventual solution plan   specifically  expanding given node s  altaltp checks
see actions leading parent node  i e   figure   shows
apar leads spar   pushed higher levels search branch  online
   

fionline parallelization plans heuristic state search

pushup s 
get actions leading
forall
x 
sx get parent node
    getting highest ancestor action
loop
ax get actions leading sx
 parallel a  ax   
x x  
sx get parent node sx 
else
aj get action conflicting ax
 secondary optimizations 
remove aj branch
include anew necessary
else
ax  ax   

break
end loop
   adjusting partial plan
sx get highest ancestor x history
createn ewbranchf rom sx  
x    
snew regress sx ax 
sx snew
x x 
end 

figure    pushup procedure

re arrangement plan done pushup procedure  shown figure   
pushup procedure called time node gets expanded  try
compress partial plan  actions find highest ancestor node
sx search branch action applied  i e   gives literal
sx without deleting literals sx   pairwise independent actions
ax currently leading sx   words condition parallel a  ax   satisfied  
sx found  removed set actions leading introduced
set actions leading sx  to child current search branch   next 
states search branch sx adjusted reflect change  adjustment
involves recomputing regressions search nodes sx   first glance 
might seem transformation questionable utility since preconditions  and
regressions  become part descendants sx   necessarily
reduce length plan  however expect length reduction actions
supporting preconditions get pushed eventually later expansions 
   

fisanchez   kambhampati


at pack  asu 
at pack  asu 
at pack  asu 
at pack   home 
unload pack  airp  asu 
unload pack  airp  asu 
unload pack  airp  asu 

h   
unload pack  airp  home 

unload pack  airp  asu 
unload pack  airp  asu 

spar

sp

h   

   

s 

h   

h   

sm
h   

unload pack  airp  home 
fly airp  locx asu 
spar

sp

   

sm

h   
pivot

unload pack  airp  home 
fly airp  locx asu 

h   

h   

 a  finding highest ancestor node action
pushed up 


unload pack  airp  asu 
unload pack  airp  asu 
unload pack  airp  asu 
unload pack  airp  home 

at pack  asu 
at pack  asu 
at pack  asu 
at pack   home 

h   
unload pack  airp  home 

unload pack  airp  asu 
unload pack  airp  asu 
unload pack  airp  asu 

unload pack  airp  asu 

unload pack  airp  asu 
spar

snew

sp

h   

s 

h   

sm

h   

fly airp  locx asu 

fly airp  locx asu 

   

snew

spar

sp

h   

fly airp  locx asu 
unload pack  airp  home 

h   
pivot

h   

unload pack  airp  home 

   

sm
h   

h   

 b  pushup procedure generates new search branch 

figure    rearranging partial plan
   

fionline parallelization plans heuristic state search

rather doctor existing branch  current implementation  add
new branch sx reflects changes made pushup procedure   new
branch becomes active search branch  leaf node expanded next 
aggressive variation pushup  pushup procedure  described above 
expensive affects current search branch  operations involved
recomputing regressions branch  course  possible aggressive
manipulating search branch  example  applying action ancestor
sx set literals child state  say snew changes  thus additional actions may
become relevant expanding snew   principle  could re expand snew light
new information  decided go re expansion option  typically
seem worth cost  section      compare default version pushup
procedure variant re expands nodes search branch  results
studies support decision avoid re expansion  finally  although introduced
pushup procedure add on fattening step  used independent
latter  case net effect would incremental parallelization sequential
plan 
example  figure   a   two actions leading node spar  at depth two  
two actions unload pack  airp  home  fly airp  locx asu   so 
expanding spar check two actions leading pushed up 
second action pushable since interacts actions ancestor node  first
one is  find highest ancestor partial plan interacts pushable
action  example root node ancestor  so  insert pushable
action unload pack  airp  home  directly root node  re adjust
state spar snew depth    shown figure   b   adding new branch  reflecting
changes states below  notice action unload pack  airp  home 
initially discarded greediness fattening procedure  see figure    
offset negative effect plan compression algorithm  see
re expanded state snew depth    made adjustments
partial plan using actions already presented search trace  

   evaluating performance altaltp
implemented altaltp top altalt  tested implementation suite
problems used           aips competition  bacchus        long
  fox         well benchmark problems  mcdermott         experiments
broadly divided three sets  aimed comparing performance altaltp
different scenarios 
   comparing performance altaltp planning systems capable producing
parallel plans 
   way data structures set up  adding new branch turns robust
option manipulating existing search branch 
   instead  aggressive pushup modification would expand snew depth    generating similar states
generated expansion spar depth 

   

fisanchez   kambhampati

  

  

  

  

gripper aips   

altalt p
stan
tp 
blackbox
lpg  nd

elevator aips   
altalt p
stan

  

blackbox
lpg  nd

  

  

steps

  

steps

  

  

  
  

  

 

  

 

 
 

 

 

 

 

problems

 

 

 

 

 

 

 

 

                                                           

problems

 b 

 a 

figure    performance gripper  aips     elevator  aips     domains 
  

    

altalt p
stan
blackbox

  

    

    

steps

 

time

   

 

   

 
   

 
   

 

 

 

 

                                                                

 

problems

 

 

                                                              

problems

 b 

 a 

figure     performance schedule domain  aips    
   comparing incremental parallelization technique altalt   post processing 
   ablation studies analyze effect different parts altaltp approach
overall performance 
experiments done sun blade     workstation  running sunos    
 gb ram  unless noted otherwise  altaltp run hadjsum m heuristic
   

fionline parallelization plans heuristic state search

  

   

altalt p
stan
tp 
blackbox
lpg  nd

  

  

   
   

  

time

steps

  

   

   

  

   

  

   

  

   
  

  

 

 
 

 

 

 

 

                                                                               

 

 

                                                     

problems

problems

 a 

 b 

figure     performance logistics domain aips    

  

   

altalt p
stan
tp 
blackbox
lpg  nd
sapa

  

  

   

   

   

time

steps

   

  

  

   

  
   

 
   

 
 

 

 

 

 

 

 

 

 

  

  

  

  

  

 

  

 

problems

 

 

 

 a 

 

 

 

 

 

problems

  

  

  

  

  

  

 b 

figure     performance driverlog domain aips    
described section   paper  parallel planning graph grown first
level top level goals present without mutex  times seconds 
    comparing altaltp competing approaches
first set experiments compared performance planner
results obtained running stan  long   fox         blackbox  kautz   selman 
   

fisanchez   kambhampati

       tp   haslum   geffner         lpg  gerevini   serina        sapa  do  
kambhampati         unless noted otherwise  every planner run default
settings  planners could run domains due parsing problems
memory allocation errors  cases  omit planner consideration
particular domains 
      planners used comparison studies
stan disjunctive planner  optimized version graphplan algorithm
reasons invariants symmetries reduce size search space  blackbox
based graphplan algorithm works converting planning problems
specified strips  fikes   nilsson        notation boolean satisfiability problems
solving using sat solver  the version used defaults satz    lpg  gerevini
  serina        judged best performing planner  rd international planning
competition  long   fox         planner based planning graphs local
search inspired walksat approach  lpg run default heuristics
settings  since lpg employs iterative improvement algorithm  quality plans
produced improved running multiple iterations  thus increasing
running time   make comparisons meaningful  decided run lpg two
iterations  n     since beyond that  running time lpg generally worse
altaltp   finally  chosen two metric temporal planners  able
represent parallel plans representation time durative actions 
tp   haslum   geffner        temporal planner based hsp p  haslum   geffner 
       optimal parallel state space planner ida  search algorithm 
last planner list sapa  do   kambhampati         sapa powerful
domain independent heuristic forward chaining planner metric temporal domains
employs distance based heuristics  kambhampati   sanchez        control search 
      comparison results different domains
run planners gripper domain international planning
scheduling competition       mcdermott         well three different domains
 logistics  scheduling  elevator miconic strips        bacchus         three
     competition  long   fox          driverlog  zenotravel  satellite 
cases multiple versions domain  used strips untyped
versions     discuss results domains below 
gripper  figure   a   compare performance altaltp gripper domain  mcdermott        rest planners excluding sapa  plot shows
results terms number  parallel  steps  see even simplistic domain  altaltp lpg planners capable scaling generating parallel
   chosen ipp  koehler         optimized graphplan planning system
results reported haslum geffner        show already less efficient stan 
   since sapa read strips file format  run sapa planner equivalent problems
unit duration actions long fox        

   

fionline parallelization plans heuristic state search

    

  

altalt p
stan
lpg  nd
sapa

  

    
    

  
    

  

    

steps

time

  

  

    
    
    

  
    

 

   
 

 
 

 

 

 

 

 

 

 

 

  

  

  

  

  

 

  

problems

 

 

 

 

 

 

 

 

  

  

  

  

  

  

problems

 b 

 a 

figure     performance zenotravel domain  aips    
plans  none approaches able solve four problems   altaltp
able scale without difficulty problems involving    balls  furthermore  altaltp
returns better plans lpg 
elevator  figure   b   compare altaltp stan  blackbox lpg elevator
domain  miconic strips   bacchus          altaltp approached quality solutions
produced optimal approaches  e g  blackbox stan   notice blackbox
solve around half problems solved altaltp domain 
scheduling  results scheduling domain shown figure     blackbox
stan considered comparison   altaltp seems reasonably approximate
optimal parallel plans many problems  around    them   produce significantly
suboptimal plans some  however  able solve problems
two approaches fraction time 
logistics  plots corresponding logistics domain bacchus        shown
figure       difficult problems altaltp outputs lower quality
solutions optimal approaches  however  altaltp lpg able scale
complex problems  easily see altaltp provides better quality
solutions lpg  altaltp seems efficient approaches 
   although stan supposed able generate optimal step length plans  handful cases
seems produced nonoptimal solutions gripper domain  explanation
behavior  informed authors code 
   include traces tp  pre processor planner able read
domain 
   tp  pre processor cannot read domain  lpg runs memory  sapa parsing
problems 
    sapa excluded due parsing problems 

   

fisanchez   kambhampati

    

  

altalt p
stan
tp 
blackbox

  

    
    

lpg  nd
sapa

  

    
    

steps

time

  

    
    

  
    
    

  

   

 

 

 

 

 

 

 

 

 

 

 

                             

 

 

 

 

 

 

 

 

 

  

  

  

  

  

  

  

  

  

  

problems

problems

 b 

 a 

figure     performance satellite domain aips    
lpg solutions problems       obtained one iteration  since lpg
able complete second iteration reasonable amount time  explains
low time taken lpg  lower quality solutions 
driverlog  see figure    a  altaltp reasonably well terms quality
respect approaches driverlog domain  every planner considered
time  altaltp one two planners able scale up  figure    b  shows
altaltp efficient planners 
zeno travel  altaltp   sapa  lpg able solve problems
domain    altaltp solves efficiently  figure    b   providing good solution
quality  figure    a   compared temporal metric planners 
satellite  results satellite domain shown figure     although every
planner considered  altaltp   sapa  lpg solve problems  sapa
solves problems produces lower quality solutions many them  altaltp produces
better solution quality sapa  efficient  however  altaltp produces
lower quality solutions lpg four problems  lpg cannot solve one problems
produces lower quality solutions   them 
summary  summary  note altaltp significantly superior elevator
gripper domains  performs well driverlog  zenotravel  satellite
domains      competition  long   fox         performance planners
similar schedule domain  logistics domain  quality altaltp plans
second blackbox problems optimal planner solve 
however  scales along lpg bigger size problems  returning good step    blackbox tp  able parse domain 

   

fionline parallelization plans heuristic state search

   

   

altalt postproc
altalt p
altalt

   

   

   
   

   

time

steps

   
   

   
   
   

  

   
 

 

 

 

                                                       

 

 

 

                                                     

problems

problems

 a 

 b 

figure     altalt post processing vs  altaltp  logistics domain 

   

  

altalt
altalt postproc
altalt p

  

   
   
   

time

  

steps

  

   
   
   

  

   
  
  
 

 
 

 

 

 

 

 

 

 

problems

 

  

  

  

  

  

 

  

 

 

 

 

 

 

 

 

  

  

  

  

  

  

problems

 a 

 b 

figure     altalt post processing vs  altaltp  zenotravel domain 

length quality plans  tp   heuristic state search regression planner capable
producing parallel plans able scale domains  sapa  heuristic
search progression planner  competitive  still outperformed altaltp planning
time solution quality 
   

fisanchez   kambhampati

solution  solution found  length     
time    load truck obj   tru  pos   level   
time    load truck obj   tru  pos   level   
time    load truck obj   tru  pos   level   
time    drive truck tru  pos  apt  cit   level   
time    unload truck obj   tru  apt   level   
time    fly airplane apn  apt  apt   level   
time    unload truck obj   tru  apt   level   
time    load airplane obj   apn  apt   level   
time    load airplane obj   apn  apt   level   
time    load truck obj   tru  pos   level   
time    fly airplane apn  apt  apt   level   
time    drive truck tru  pos  apt  cit   level   
time    unload airplane obj   apn  apt   level   
time    load truck obj   tru  apt   level   
time    unload truck obj   tru  apt   level   
time    drive truck tru  apt  pos  cit   level   
time    unload airplane obj   apn  apt   level   
time    unload truck obj   tru  apt   level   
time    unload truck obj   tru  pos   level   
total number actions plan    

post processed plan    
time      load truck obj   tru  pos  
time      load truck obj   tru  pos  
time      load truck obj   tru  pos  
time      fly airplane apn  apt  apt  
time      load truck obj   tru  pos  
time      drive truck tru  pos  apt  cit  
time      drive truck tru  pos  apt  cit  
time      unload truck obj   tru  apt  
time      unload truck obj   tru  apt  
time      unload truck obj   tru  apt  
time      unload truck obj   tru  apt  
time      load airplane obj   apn  apt  
time      load airplane obj   apn  apt  
time      fly airplane apn  apt  apt  
time      unload airplane obj   apn  apt  
time      unload airplane obj   apn  apt  
time      load truck obj   tru  apt  
time      drive truck tru  apt  pos  cit  
time      unload truck obj   tru  pos  
end post processing  actions     length   

 a  altaltp solution

 b  altaltp plus post processing

figure     plots showing altaltp solutions cannot improved anymore postprocessing 

    comparison post processing approaches
mentioned earlier  see section     one way producing parallel plans
studied previously literature post process sequential plans  backstrom        
compare online parallelization post processing  implemented backstrom       s
minimal de ordering algorithm  used post process sequential plans produced
altalt  running default heuristic hadjsum m using serial planning graph  
section compare online parallelization procedure offline method 
first set experiments logistics domain  bacchus         results
shown figure     expected  original altalt longest plans since allows
one action per time step  plot shows post processing techniques help
reducing makespan plans generated altalt  however  notice
altaltp outputs plans better makespan either altalt altalt followed postprocessing  shows online parallelization better approach post processing
sequential plans  moreover  plot figure    b  shows time taken altaltp
largely comparable taken two approaches  fact  much
additional cost overhead procedure 
figure    repeats experiments zenotravel domain  long   fox        
again  see altaltp produces better makespan post processing sequential
plans altalt  notice time  altalt plus post processing clearly less efficient
   

fionline parallelization plans heuristic state search

   

logistics aips   

   

altalt p
altalt p nopush
altalt p agr

   

logistics aips   

   

   

time

steps

   

  

   

  
   

  
   

  

 

 

 

 

 

                                                                                       

                                                     

problems

problems

 a 

   

 b 

satellite aips   

   

satellite aips   

  

altalt p
altalt nopush
altalt p agr

  

   

  

   

time

steps

  

  
  

   

  
  

  

  
 

 

 

 

 

 

 

 

 

 

                                  

problems

 

 

 

 

 

 

 

 

 

  

  

  

  

  

  

  

  

  

  

  

problems

 c 

 d 

figure     analyzing effect pushup procedure

either two approaches  summary  results section demonstrate
altaltp superior altalt plus post processing 
one might wonder plans generated altaltp benefit postprocessing phase  investigated issue found specific post processing
routines used produce improvements  main reason
behavior pushup procedure already tries exploit opportunity
shortening plan length promoting actions partial plan  illustrative
example  show  figure     parallel plan output altaltp problem
logistics domain  logistics     bacchus         result post processing
   

fisanchez   kambhampati

  

   

logistics aips   

blocksworld aips   

serial pg
parallel pg

  

   

  

altalt p
altalt

   

  

time

steps

  

  

  

  
  

  
  

  

 

 
 

 

 

                                                     

 

 

 

 

 

  

  

problems

  

  

  

  

problems

  

  

  

  

  

  

  

 b  solving serial domain

 a  utility using parallel planning graphs

figure     plots showing utility using parallel planning graphs computing
heuristics  characterizing overhead incurred altaltp serial domains 

solution  although two solutions differ terms step contents  notice
step length  difference step contents explained fact
de ordering algorithm relaxes ordering relations plan  allowing
actions come earlier  pushup always moves actions towards end plan 
run comprehensive studies three different domains  logistics  satellite
zenotravel   found case step length plan produced altaltp
improved post processing routine  we omit comparison plots since essentially
show curves corresponding altaltp altaltp post processing coincident    
    ablation studies
section attempts analyze impact different parts altaltp performance 
utility pushup procedure  figure    shows effects running altaltp
without pushup procedure  but fattening procedure   well running
aggressive version pushup  described section    re expands
nodes search branch  action pushed up  see running
altaltp pushup fattening procedures better latter  comparison
results figure    a  figure    a  shows even fattening procedure
performs better original altalt  figure    b  see although
pushup procedure add much overhead  aggressive version pushup get
quite expensive  notice around    problems solved within time limits
    verified least one problem domains 

   

fionline parallelization plans heuristic state search

aggressive pushup  plots figure    c  figure    d  show results
experiments satellite domain  see situation quite similar
domain  conclude pushup procedure  used offset greediness
algorithm  achieves purpose 
utility basing heuristics parallel planning graphs  see figure    a  using parallel planning graph basis deriving heuristic estimates
altaltp winning idea  serial planning graph overestimates heuristic values
terms steps  producing somewhat longer parallel solutions  fact version
using serial planning graph runs time many problems demonstrates
running times improved use parallel planning graphs 
comparison altalt  one final concern would much extra computational
hit taken altaltp algorithm serial domains  e g  blocks world bacchus 
       expect negligible confirm intuitions  ran altaltp set
problems sequential blocks world domain  see plot    b 
time performance altalt altaltp equivalent almost problems 

   related work
idea partial exploration parallelizable sets actions new  kabanza       
godefroid   kabanza          kambhampati         studied area
concurrent reactive planning  one main goals approximate optimal
parallelism  however  research focused forward chaining
planners  kabanza         state world completely known 
implied backward search methods suitable kind analysis  godefroid
  kabanza        search nodes correspond partial states  shown
backward search methods used approximate parallel plans context
classical planning 
optimization plans according different criteria  e g  execution time  quality  etc 
done post processing step  post processing computation given
plan maximize parallelism discussed backstrom         reordering
de ordering techniques used maximize parallelism plan  de ordering
techniques ordering relations removed  added  reordering  arbitrary
modifications plan allowed  general case problem np hard
difficult approximate  backstrom         furthermore  discussed section  
   post processing techniques concerned modifying order
existing actions given plan  approach considers modifying orderings
inserting new actions online minimize possible number parallel
steps overall problem 
already discussed graphplan based planners  long   fox        kautz  
selman         return optimal plans based number time steps  graphplan
uses ida  include greatest number parallel actions time step
search  however  iterative procedure time consuming provide
guarantee number actions final plans  attempts
minimize number actions planners  huang  selman    kautz       
   

fisanchez   kambhampati

using domain control knowledge based generation rules specific
planning domain  graphplan algorithm tries maximize parallelism satisfying
subgoals time step  search fails backtracks reduces
set parallel actions considered one level before  altaltp opposite 
tries guess initial parallel nodes given heuristics  iteratively adds actions
nodes possible pushup procedure later search 
recently  work generalizing forward state search handle action concurrency metric temporal domains  particular relevance work
temporal tlplan  bacchus   ady        sapa  do   kambhampati        
planners designed specifically handling metric temporal domains  use
similar search strategies  main difference temporal tlplan
depends hand coded search control knowledge guide search  sapa  like
altaltp   uses heuristics derived  temporal  planning graphs  such 
planners co opted produce parallel plans classical domains  planners forward chaining search  altaltp   achieve concurrency
incrementally  without projecting sets actions  following way  normal forward
search planners start initial state s    corresponding time t    consider actions
apply s    choose one  say a  apply s    getting s    simultaneously
progress system clock t  t    order allow concurrency  planners
bacchus ady         kambhampati        essentially decouple
action application clock progression  every point search  nondeterministic choice   progressing clock  applying  additional  actions
current time point  point view planners  altaltp seen providing heuristic guidance non deterministic choice  modulo difference altaltp
regression search   results empirical comparisons altaltp sapa 
show altaltp outperforms sapa  suggest heuristic strategies employed
altaltp including incremental fattening  pushup procedure  gainfully
adapted planners increase concurrency solution plans  finally  hsp  
tp   extension temporal domains  heuristic state search planners using
regression capable producing parallel plans  haslum   geffner         tp 
seen regression version approach used sapa temporal tlplan 
experiments however demonstrate neither planners scales well comparison
altaltp  
pushup procedure seen plan compression procedure  such  similar
plan compression procedures double back optimization  crawford        
one difference double back used context local search  pushup
used context systematic search  double back could applied
finished plan schedule  post processing approach outcome would
depend highly plan given input 

   concluding remarks
motivated acknowledged inability heuristic search planners generate parallel
plans  developed presented approach generate parallel plans
context altalt  heuristic state space planner  challenging problem
   

fionline parallelization plans heuristic state search

exponential branching factor incurred naive methods  approach tries avoid
branching factor blow greedy online parallelization evolving partial
plans  plan compression procedure called pushup used offset ill effects
greedy search  empirical results show comparison planners capable
producing parallel plans  altaltp able provide reasonable quality parallel plans
fraction time competing approaches  approach seems provide better
quality plans achieved post processing sequential plans  results show
altaltp provides attractive tradeoff quality efficiency generation
parallel plans  future  plan adapt altaltp approach metric temporal
domains  need concurrency pressing  one idea adapt
sources strength altaltp sapa  metric temporal planner developed
group  do   kambhampati        

acknowledgments
thank minh b  xuanlong nguyen helpful discussions feedback 
thank david smith jair reviewers many constructive comments  research
supported part nasa grants nag       ncc       nsf grant
iri         

references
bacchus  f          aips   planning competition  ai magazine               
bacchus  f     ady  m          planning resources concurrency  forward
chaining approach  proceedings ijcai     pp         
backstrom  c          computational aspects reordering plans  journal artificial
intelligence research           
blum  a     furst  m          fast planning planning graph analysis  artificial
intelligence             
bonet  b     geffner  h          planning heuristic search  new results  proceedings
ecp    
bonet  b   loerincs  g     geffner  h          robust fast action selection mechanism
planning  proceedings aaai     pp          aaai press 
crawford  j          approach resource constrained project scheduling  proceedings
     artificial intelligence manufacturing research planning workshop 
aaai press 
do  m  b     kambhampati  s          solving planning graph compiling csp 
proceedings aips     pp       
do  m  b     kambhampati  s          sapa  domain independent heuristic metric
temporal planner  proceedings ecp    
   

fisanchez   kambhampati

fikes  r     nilsson  n          strips  new approach application theorem
proving problem solving  artificial intelligence                  
gerevini  a     serina  i          lpg  planner based local search planning graphs 
proceedings aips     aaai press 
godefroid  p     kabanza  f          efficient reactive planner synthesizing reactive
plans  proceedings aaai     vol     pp          aaai press mit press 
haslum  p     geffner  h          admissible heuristics optimal planning  proceedings
aips     pp         
haslum  p     geffner  h          heuristic planning time resources  proceedings
ecp     springer 
huang  y   selman  b     kautz  h          control knowledge planning  benefits
tradeoffs  proceedings aaai iaai     pp         
kabanza  f          planning verifying reactive plans  position paper   proceedings
aaai    workshop immobots  theories action  planning control 
kambhampati  s     sanchez  r          distance based goal ordering heuristics graphplan  proceedings aips     pp         
kautz  h     selman  b          pushing envelope  planning  propositional logic 
stochastic search  proceedings aaai     pp            aaai press 
kautz  h     selman  b          blackbox  unifying sat based graph based planning 
proceedings ijcai    
koehler  j          rifo within ipp  tech  rep       university freiburg 
korf  r          linear space best first search  artificial intelligence           
long  d     fox  m          efficient implementation plan graph stan  journal
artificial intelligence research            
long  d     fox  m           rd international planning competition  results
analysis  appear jair 
mcdermott  d          using regression match graphs control search planning  artificial intelligence                    
mcdermott  d               ai planning systems competition  ai magazine         
     
nguyen  x     kambhampati  s          extracting effective admissible heuristics
planning graph  proceedings aaai iaai     pp         
nguyen  x   kambhampati  s     sanchez  r          planning graph basis deriving heuristics plan synthesis state space csp search  artificial intelligence 
                 
   

fionline parallelization plans heuristic state search

sanchez  r   nguyen  x     kambhampati  s          altalt  combining advantages
graphplan heuristics state search  proceedings kbcs     bombay  india 

   


