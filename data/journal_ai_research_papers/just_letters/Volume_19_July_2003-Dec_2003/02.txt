journal of artificial intelligence research                

submitted        published      

answer set planning under action costs
thomas eiter
wolfgang faber

eiter   kr   tuwien   ac   at
faber   kr   tuwien   ac   at

institut fur informationssysteme  tu wien
favoritenstr        a      wien  austria

nicola leone

leone   unical   it

department of mathematics  university of calabria
i       rende  cs   italy

gerald pfeifer
axel polleres

pfeifer   dbai   tuwien   ac   at
polleres   kr   tuwien   ac   at

institut fur informationssysteme  tu wien
favoritenstr        a      wien  austria

abstract
recently  planning based on answer set programming has been proposed as an approach towards realizing declarative planning systems  in this paper  we present the language k c   which
extends the declarative planning language k by action costs  k c provides the notion of admissible and optimal plans  which are plans whose overall action costs are within a given limit resp 
minimum over all plans  i e   cheapest plans   as we demonstrate  this novel language allows for
expressing some nontrivial planning tasks in a declarative way  furthermore  it can be utilized for
representing planning problems under other optimality criteria  such as computing shortest plans
 with the least number of steps   and refinement combinations of cheapest and fastest plans  we
study complexity aspects of the language k c and provide a transformation to logic programs  such
that planning problems are solved via answer set programming  furthermore  we report experimental results on selected problems  our experience is encouraging that answer set planning may
be a valuable approach to expressive planning systems in which intricate planning problems can be
naturally specified and solved 

   introduction
recently  several declarative planning languages and formalisms have been introduced  which allow
for an intuitive encoding of complex planning problems involving ramifications  incomplete information  non deterministic action effects  or parallel actions  see e g   giunchiglia   lifschitz       
lifschitz      b  lifschitz   turner        mccain   turner        giunchiglia        cimatti  
roveri        eiter et al       b      b  
while these systems are designed to generate any plans that accomplish the planning goals  in
practice one is often interested in particular plans that are optimal with respect to some objective
function by which the quality  or the cost  of a plan is measured  a common and simple objective
function is the length of the plan  i e   the number of time steps to achieve the goal  many systems
are tailored to compute shortest plans  for example  cmbp  cimatti   roveri        and gpt
 bonet   geffner        compute shortest plans in which each step consists of a single action 
while the graphplan algorithm  blum   furst        and descendants  smith   weld        weld 
c
    
ai access foundation and morgan kaufmann publishers  all rights reserved 

fie iter   faber   l eone   p feifer   p olleres

anderson    smith        compute shortest plans where in each step actions might be executed in
parallel 
however  there are other  equally important objective functions to consider  in particular  if
executing actions causes some cost  we may desire a plan which minimizes the overall cost of the
actions 
in answer set planning  subrahmanian   zaniolo        dimopoulos  nebel    koehler       
niemela        lifschitz      b   a recent declarative approach to planning where plans are encoded by the answer sets of a logic program  the issue of optimal plans under an objective value
function has not been addressed in detail so far  see section   for more details   in this paper  we
address this issue and present an extension of the planning language k  eiter et al       b      b  
where the user may associate costs with actions  which are then taken into account in the planning
process  the main contributions of our work are as follows 
 we define syntax and semantics of the planning language kc   which modularly extends the
language k  costs are associated to an action by extending the action declarations with an
optional cost construct which describes the cost of executing the respective action 
the action costs can be static or dynamic  as they may depend on the current stage of the plan
when an action is considered for execution  dynamic action costs are important and have
natural applications  as we show on a simple variant of the well known traveling salesperson
problem  which is cumbersome to model and solve in other  similar languages 
 we analyze the computational complexity of planning in the language k c   and provide completeness results for major planning tasks in the propositional setting  which locate them in
suitable slots of the polynomial hierarchy and in classes derived from it  these results provide insight into the intrinsic computational difficulties of the respective planning problems 
and give a handle for efficient transformations from optimal planning to knowledge representation formalisms  in particular to logic programs 
 we show  in awareness of the results of the complexity analysis  how planning with action
costs can be implemented by a transformation to answer set programming  as done in a system prototype that we have developed  the prototype  ready for experiments  is available at
http   www dlvsystem com k  
 finally  we present some applications which show that our extended language is capable
of easily modeling optimal planning under various criteria  computing     cheapest plans
 which minimize overall action costs       shortest plans  with the least number of steps  
and  refinement combinations of these  viz      shortest plans among the cheapest  and    
cheapest plans among the shortest  notice that  to our knowledge  task     has not been
addressed in other works so far 
the extension of k by action costs provides a flexible and expressive tool for representing
various problems  moreover  since ks semantics builds on states of knowledge rather than on
states of the world  we can deal with both incomplete knowledge and plan quality  which is  to the
best of our knowledge  completely novel 
our experience is encouraging that answer set planning  based on powerful logic programming
engines  allows for the development of declarative planning systems in which intricate planning
  

fia nswer s et p lanning u nder action c osts

tasks can be specified and solved  this work complements and extends the preliminary results
presented in our previous work  eiter et al       a  
the remainder of this paper is organized as follows  in the next section  we briefly review
the language k by informally presenting its main constituents and features on a simple planning
example  after that  we define in section   the extension of k by action costs  and consider some
first examples for the usage of kc   section   is devoted to the analysis of complexity issues  in
section    we consider applications of k c   we show that various types of particular optimization
problems can be expressed in k c   and also consider some practical examples  in section    we
present a transformation of k c into answer set programming  and in section    we report about a
prototype implementation and experiments  after a discussion of related work in section    we
conclude the paper with an outlook on ongoing and future work 

   short review of language k
in this section  we give a brief informal overview of the language k  and refer to  eiter et al       b 
and to the appendix for formal details  we assume that the reader is familiar with the basic ideas
of planning and action languages  in particular with the notions of actions  fluents  goals and plans 
for illustration  we shall use the following planning problem as a running example 
problem    bridge crossing problem  four persons want to cross a river at night over a plank
bridge  which can only hold up to two persons at a time  they have a lamp  which must be used
when crossing  as it is pitch dark and some planks are missing  someone must bring the lamp back
to the others  no tricks  like throwing the lamp or halfway crosses  etc   are allowed 
fluents and states  a state in k is characterized by the truth values of fluents  describing relevant
properties of the domain of discourse  a fluent may be true  false  or unknown in a state  that is 
states in k are states of knowledge  as opposed to states of the world where each fluent is either true
or false  which can be easily enforced in k  if desired   formally  a state is any consistent set s of
 possibly negated  legal fluent instances 
an action is applicable only if some precondition  a list of literals over some fluents  holds in
the current state  its execution may cause a modification of truth values of some fluents 
background knowledge  static knowledge which is invariant over time in a k planning domain
is specified in a normal  disjunction free  datalog program  that has a single answer set and can
be viewed as a set of facts  for our example  the background knowledge specifies the four persons 
person joe   person jack   person william   person averell  

type declarations  each fluent or action must have a declaration where the ranges of its arguments are specified  for instance 
crosstogether x  y  requires person x   person y   x   y   

specifies the arguments of the action crosstogether  where two persons cross the bridge together 
while
across x  requires person x  
     here is used instead of inequality to avoid symmetric rules 

  

fie iter   faber   l eone   p feifer   p olleres

specifies a fluent describing that a specific person is on the other side of the river  here the literals
after requires must be classical literals of the static background knowledge  like person x  and
person y    or literals of built in predicates  such as x   y   our implementation of k  the dlv k system  eiter  faber  leone  pfeifer    polleres      a   currently supports the built in predicates
a   b  a    b  a    b with the obvious meaning of less than  less or equal and inequality for
strings and numbers  the arithmetic built ins a   b   c and a   b  c which stand for integer
addition and multiplication  and the predicate  int x  which enumerates all integers  up to a
user defined limit  
causation rules  causation rules  rules for brevity  are syntactically similar to rules of the
action language c  giunchiglia   lifschitz        lifschitz      a  lifschitz   turner        and
are of the basic form 
caused f if b after a 

where a is a conjunction of fluent and action literals  possibly including default negation  b is a
conjunction of fluent literals  again possibly including default negation  and f is a fluent literal 
informally  such a rule reads  if b is known to be true in the current state and a is known to be true
in the previous state  then f is known to be true in the current state as well  both the if part and
the after part are allowed to be empty  which means that they are true   a causation rule is called
dynamic  if its after part is not empty  and is called static otherwise 
causation rules are used to express effects of actions or ramifications  for example 
caused across x  after cross x    across x  
caused  across x  after cross x   across x  

describe the effects of a single person crossing the bridge in either direction 
initial state constraints  static rules can apply to all states or only to the initial states  which
may not be unique   this is expressed by the keywords always   and initially   preceding
sequences of rules where the latter describes initial state constraints that must be satisfied only in
the initial state  for example 
initially   caused  across x  

enforces the fluent across to be false in the initial state for any x satisfying the declaration of the
fluent across  i e   for all persons  the rule is irrelevant for all subsequent states 
executability of actions 

this is expressed in k explicitly  for instance 

executable crosstogether x  y  if haslamp x  
executable crosstogether x  y  if haslamp y  

declares that two persons can jointly cross the bridge if one of them has a lamp  the same action
may have multiple executability statements  a statement
executable cross x  

with empty body says that cross is always executable  provided that the type restrictions on x are
respected  dually 
nonexecutable a if b 

prohibits the execution of action a if condition b is satisfied  for example 
nonexecutable crosstogether x  y  if differentsides x  y  

  

fia nswer s et p lanning u nder action c osts

says that persons x and y can not cross the bridge together if they are on different sides of the bridge 
in case of conflicts  nonexecutable a overrides executable a 
default and strong negation  k supports strong negation    also written as     note  however  that for a fluent f  in a state neither f nor  f needs to hold  in this case the knowledge about
f is incomplete  in addition  weak negation  not   interpreted like default negation in answer set
semantics  gelfond   lifschitz         is permitted in rule bodies  this allows for natural modeling of inertia and default properties  as well as dealing with incomplete knowledge in general  for
example 
caused haslamp joe  if not haslamp jack   not haslamp william   not haslamp averell  

expresses the conclusion that by default  joe has the lamp  whenever it is not evident that any of the
other persons has it 
macros 

k provides a number of macros as syntactic sugar  for example 

inertial across x  

informally states that across x  holds in the current state  if across x  held at the previous state 
unless  across x  is explicitly known to hold  this macro expands to the rule
caused across x  if not  across x  after across x  

moreover  we can totalize the knowledge of a fluent by declaring total f  which is a shortcut for
caused f if not  f 

caused  f if not f 

the intuitive meaning of these rules is that unless a truth value for f can be derived  the cases where
f resp   f is true will both be considered 
planning domains and problems  in k  a planning domain pd   h  hd  rii has a background
knowledge   action and fluent declarations d  and rules and executability conditions r  a planning
problem p   hpd  qi has a planning domain pd and a query
q   g            gm   not gm             not gn    l 
where g            gn are ground fluents and l    is the plan length  for instance  the goal query
across joe   across jack   across william   across averell      

asks for plans which bring all four persons across in   steps 
plans are defined using a transition based semantics  where the execution of a set of actions
transforms a current state into a new state  an  optimistic  plan for p is a sequence p   ha             al i
of sets of action instances a    a            al in a trajectory t   hhs    a    s  i  hs    a    s  i         
hsl    al   sl ii from a legal initial state s  to state sl in which all literals of the goal are true  that
is  starting in s    the legal transition t    hs    a    s  i  modeling the execution of the actions in a  
 which must be executable   transforms s   into the state s    this is then followed by legal transitions
ti   hsi    ai   si i  for i                 l  cf  appendix for details   a plan is sequential  if  a i     
for all i              l  i e   each step consists of at most one action  such plans can be enforced by
including the keyword noconcurrency 
besides optimistic plans  in k we also support stronger secure  or conformant  plans  a secure
plan must be guaranteed to work out under all circumstances  eiter et al       b   regardless of
incomplete information about the initial state and possible nondeterminism in the action effects 
  

fie iter   faber   l eone   p feifer   p olleres

for better readability  in the following we will not always describe k planning problems p
strictly in terms of sets of declarations  rules and executability conditions  but optionally use the
more compact representation of k programs of the following general form 
fluents  
actions  
initially  
always  
goal  

fd
ad
ir
cr
q

where the  optional  sections fluents through always consist of lists of fluent declarations f d  
action declarations ad   initial state constraints ir and executability conditions and causation rules
cr   respectively  together with the background knowledge  and the goal query q  they specify
a k planning problem p   hh  hd  rii  qi  where d is given by f d plus ad and r by ir plus
cr    
    solving the bridge crossing problem
using the above constructs  a k encoding of the bridge crossing problem  assuming that joe
initially carries the lamp  is shown in figure    there are simple five step plans  l       in which
joe always carries the lamp and brings all others across  one of them is 
p   h  crosstogether joe  jack     cross joe     crosstogether joe  william   
 cross joe     crosstogether joe  averell   i

   actions with costs
using the language k and the system prototype  dlv k   we can already express and solve some
involved planning tasks  cf   eiter et al       b   however  k and dlv k alone offer no means
for finding optimal plans under an objective cost function  in general  different criteria of plan
optimality can be relevant  such as optimality wrt  action costs as shown in the next example  which
is a slight elaboration of the bridge crossing problem  and a well known brain teasing riddle 
problem    quick bridge crossing problem  the persons in the bridge crossing scenario need
different times to cross the bridge  namely          and    minutes  respectively  walking in two
implies moving at the slower rate of both  is it possible that all four persons get across within   
minutes 
on first thought this is infeasible  since the seemingly optimal plan where joe  who is the fastest 
keeps the lamp and leads all the others across takes    minutes altogether  surprisingly  as we will
see  the optimal solution indeed only takes    minutes 
in order to allow for an elegant and convenient encoding of such optimization problems  we
extend k to the language k c in which one can assign costs to actions 
    syntax of kc
let  act    f l   and  var denote  finite  sets of action names  fluent names and variable symbols 
furthermore  let lact   lf l   and ltyp denote the sets of action  fluent  and type literals  respectively 
   this is also the format of the input files of our system prototype  which will be presented in section   

  

fia nswer s et p lanning u nder action c osts

actions  

cross x  requires person x  
crosstogether x  y  requires person x   person y   x   y 
takelamp x  requires person x  

fluents  

across x  requires person x  
differentsides x  y  requires person x   person y  
haslamp x  requires person x  

initially    across x   haslamp joe  
always  

executable crosstogether x  y  if haslamp x  
executable crosstogether x  y  if haslamp y  
nonexecutable crosstogether x  y  if differentsides x  y  
executable cross x  if haslamp x  
executable takelamp x  
nonexecutable takelamp x  if haslamp y   differentsides x  y  
caused
caused
caused
caused

across x  after crosstogether x  y  
across y  after crosstogether x  y  
 across x  after crosstogether x  y  
 across y  after crosstogether x  y  

 across x  
 across y  
across x  
across y  

caused across x  after cross x    across x  
caused  across x  after cross x   across x  
caused haslamp x  after takelamp x  
caused  haslamp x  after takelamp y   x    y  haslamp x  
caused differentsides x  y  if across x    across y  
caused differentsides x  y  if  across x   across y  
inertial across x  
inertial  across x  
inertial haslamp x  
noconcurrency 
goal  

across joe   across jack   across william   across averell    l 

figure    k encoding of the bridge crossing problem
formed from the action names  fluent names  and predicates in the background knowledge  including
built in predicates   respectively  using terms from a nonempty  finite  set of constants con  
kc extends action declarations as in k with costs as follows 
definition     an action declaration d in k c is of the form 
p x            xn   requires t            tm costs c where c            ck  

   

where     p   act has arity n         x            xn   var       t            tm   c            ck are from
ltyp such that every xi occurs in t            tm       c is either an integer constant  a variable from the
set of all variables occurring in t            tm   c            ck  denoted by  var  d    or the distinguished
variable time       var  d    var   time   and     time does not occur in t           tm  
  

fie iter   faber   l eone   p feifer   p olleres

if m      the keyword requires is omitted  if k      the keyword where is omitted and
costs c is optional  here      and     state that parameters to an action must be variables  and
not fixed values  informally      means that all parameters of an action must be typed in the
requires part  condition     asserts that the cost is locally defined or given by the stage of the
plan  which is referenced through the global variable time  conditions     and     ensure that all
variables are known and that type information of action parameters is static  i e   does not depend
on time 
planning domains and planning problems in k c are defined as in k 
for example  in the elaborated bridge crossing problem  the declaration of cross x  can be
extended as follows  suppose a predicate walk person  minutes  in the background knowledge
indicates that person takes minutes to cross  then  we may simply declare
cross x  requires person x  costs wx where walk x  wx  

    semantics of kc
semantically  kc extends k by the cost values of actions at points in time  in any plan p  
ha            al i  at step    i  l  the actions in ai are executed to reach time point i 
a ground action p x            xn   is a legal action instance of an action declaration d wrt  a k c
planning domain pd   h  hd  rii  if there exists some ground substitution  for  var  d  
 time  such that xi    xi   for    i  n and  t            tm    m   where m is the unique answer
set of the background knowledge   any such  is called a witness substitution for p x             xn   
informally  an action instance is legal  if it satisfies the respective typing requirements  action costs
are now formalized as follows 
definition     let a   p x            xn   be a legal action instance of a declaration d of the form    
and let  be a witness substitution for a  then

if the costs part of d is empty 
   
cost  p x            xn     
val c   if  c            ck    m  

undefined otherwise 

where m is the unique answer set of  and val    con  in is defined as the integer value for
integer constants and   for all non integer constants 
by reference to the variable time  it is possible to define time dependent action costs  we shall consider an example in section      using cost    we now introduce well defined legal action instances
and define action cost values as follows 
definition     a legal action instance a   p x             xn   is well defined iff it holds that  i  for any
time point i     there is some witness substitution  for a such that time   i and cost   a  is an
integer  and  ii  cost  a    cost   a  holds for any two witness substitutions      which coincide
on time and have defined costs  for any well defined a  its unique cost at time point i    is given
by costi  a    cost  a  where  is as in  i  
in this definition  condition  i  ensures that some cost value exists  which must be an integer 
and condition  ii  ensures that this value is unique  i e   any two different witness substitutions  and
   for a evaluate the cost part to the same integer cost value 
  

fia nswer s et p lanning u nder action c osts

an action declaration d is well defined  if all its legal instances are well defined  this will be
fulfilled if  in database terms  the variables x            xn together with time in     functionally determine the value of c  in our framework  the semantics of a k c planning domain pd   h  hd  rii
is only well defined for well defined action declarations in pd  in the rest of this paper  we assume
well definedness of kc unless stated otherwise 
using costi   we now define costs of plans 
definition     let p   hpd  q    l i be a planning problem  then  for any plan p   ha             al i
for p  its cost is defined as
costp  p    

pl

j  

p


cost
 a 
 
j
aaj

a plan p is optimal for p  if costp  p    costp  p     for each plan p   for p  i e   p has least cost
among all plans for p  the cost of a planning problem p  denoted cost p   is given by costp  
costp  p     where p  is an optimal plan for p 
in particular  costp  p       if p   hi  i e   the plan is void  note that cost p is only defined if a
plan for p exists  
usually one only can estimate some upper bound of the plan length  but does not know the exact
length of an optimal plan  although we have only defined optimality for a fixed plan length l  we
will see in section     that by appropriate encodings this can be extended to optimality for plans
with length at most l 
besides optimal plans  also plans with bounded costs are of interest  which motivates the following definition 
definition     a plan p for a planning problem p is admissible wrt  cost c  if cost p  p    c 
admissible plans impose a weaker condition on the plan quality than optimal plans  they are
particularly relevant if optimal costs are not a crucial issue  as long as the cost stays within a given
limit  and if optimal plans are difficult to compute  we might face questions like can i make it
to the airport within one hour   do i have enough change to buy a coffee  etc  which amount
to admissible planning problems  as we shall see  computing admissible plans is complexity wise
easier than computing optimal plans 
    an optimal solution for the quick bridge crossing problem
to model the quick bridge crossing problem in k c   we first extend the background knowledge as
follows  where the predicate walk describes the time a person needs to cross and max determines
which of two persons is slower 
walk joe      walk jack      walk william      walk averell      
max a  b  a     walk    a   walk    b   a    b 
max a  b  b     walk    a   walk    b   b   a 

next  we modify the declarations for cross and crosstogether from figure   by adding costs 
   in the following  subscripts will be dropped when clear from the context 

  

fie iter   faber   l eone   p feifer   p olleres

cross x  requires person x  costs wx where walk x  wx  
crosstogether x  y  requires person x   person y   x   y
costs wmax where walk x  wx   walk y  wy   max wx  wy  wmax  

the declaration of takelamp remains unchanged  as the time to hand over the lamp is negligible 
using this modified planning domain  the   step plan reported in section     has cost     actually  it is optimal for plan length l      however  when we relinquish the first intuition that the
fastest person  joe  always has the lamp and consider the problem under varying plan length  then
we can find the following   step plan 
p   h  crosstogether joe  jack     cross joe     takelamp william   
 crosstogether william  averell     takelamp jack     cross jack   
 crosstogether joe  jack   i

here  costp  p         and thus p is admissible with respect to cost     this means that the quick
bridge crossing problem has a positive answer  in fact  p has least cost over all plans of length
l      and is thus an optimal   step plan  moreover  p has also least cost over all plans that emerge
if we consider all plan lengths  thus  p is an optimal solution for the quick bridge crossing
problem under arbitrary plan length 
    bridge crossing under incomplete knowledge
the language k is well suited to model problems which involve uncertainty such as incomplete
initial states or non deterministic action effects at a qualitative level  the enriched language k c
gracefully extends to secure  conformant  plans as well  which must reach the goal under all circumstances  eiter et al       b      b   more precisely  an optimistic plan ha             an i is secure 
if it is applicable under any evolution of the system  starting from any legal initial state s     the first
action set a   for plan length l     can always be executed  i e   some legal transition hs     a    s  i
exists   and for every such possible state s     the next action set a  can be executed etc   and after
having performed all actions  the goal is always accomplished  cf  appendix for a formal definition  
while secure plans inherit costs from optimistic plans  there are different possibilities to define
optimality of secure plans  we may consider a secure plan as optimal  if it has least cost either
 among all optimistic plans  or
 among all secure plans only 
in the first alternative  there might be planning problems which have secure plans  but no optimal
secure plans  for this reason  the second alternative appears to be more appropriate 
definition     a secure plan p is optimal for a planning problem p  if it has least cost among all
secure plans for p  i e   costp  p    costp  p     for each secure plan p   for p  the secure cost of
p  denoted costsec  p   is costsec  p    costp  p     where p  is any optimal secure plan for p 
the notion of admissible secure plans is defined analogously 
for example  assume that it is known that at least one person in the bridge scenario has a lamp 
but that neither the exact number of lamps nor the allocation of lamps to persons is known  if the
four desperate persons now ask for a plan which brings them safely across the bridge  we need a
 fast  secure plan that works under all possible initial situations  in k c   this can be modeled by
replacing the initially part with the following declarations 
  

fia nswer s et p lanning u nder action c osts

initially   total haslamp x  
caused false if  haslamp joe    haslamp jack  
 haslamp william    haslamp averell  

the first statement says that each person either has a lamp or not  and the second that at least
one of them must have a lamp  for a detailed discussion on the use of the total statement for
modeling incomplete knowledge and non determinism we refer to  eiter et al       b  
as we can easily see  an optimal secure solution will take at least    minutes  since the original
case  where only joe has a lamp  is one of the possible initial situations  for which the cost of
an optimistic plan which is optimal over all plan lengths was     however  a secure plan which
is optimal over all plan lengths requires at least   steps now  but no higher cost   different from
optimistic plans  we need one extra step at the beginning which makes sure that one of those who
walk first  above  joe and jack  has the lamp  which is effected by the proper takelamp action 
an example of such a plan is the following which has cost    
p   h  takelamp joe     crosstogether joe  jack     cross joe   
 takelamp william     crosstogether william  averell     takelamp jack   
 cross jack     crosstogether joe  jack   i

we can easily check that p works for every possible initial situation  thus  it is an optimal  secure 
plan for plan length    and moreover also for arbitrary plan length 

   computational complexity
in this section  we will address the computational complexity of k c   complementing similar results
for the language k  eiter et al       b  
    complexity classes
we assume that the reader is familiar with the basic notions of complexity theory  such as p  np 
problem reductions and completeness  see e g   papadimitriou        and references therein  we
recall that the polynomial hierarchy  ph  contains the classes  p    p    p    p and pi    
p
p
npi   pi     co pi     pi     pi   for i     in particular  p    np and p    pnp  
note that these classes contain decision problems  i e   problems where the answer is yes or
no   while checking well definedness and deciding plan existence are such problems  computing
a plan is a search problem  where for each problem instance i a  possibly empty  finite set s i  of
solutions exists  to solve such a problem  a  possibly nondeterministic  algorithm must compute the
alternative solutions from this set in its computation branches  if s i  is not empty  more precisely 
search problems are solved by transducers  i e   turing machines equipped with an output tape  if
the machine halts in an accepting state  then the contents of the output tape is the result of the
computation  observe that a nondeterministic machine computes a  partial  multi valued function 
as an analog to np  the class npmv contains those search problems where s i  can be computed by a nondeterministic turing machine in polynomial time  for a precise definition  see  selp
man         in analogy to pi     by pi   mv   npmvi   i     we denote the generalization of
npmv where the machine has access to a  pi oracle 
analogs to the classes p and pi     i     are given by the classes fp and f pi     i    
which contain the partial single valued functions  that is   s i      for each problem instance
  

fie iter   faber   l eone   p feifer   p olleres

i  computable in polynomial time using no resp  a  pi oracle  we say  abusing terminology  that
a search problem a is in fp  resp  fpi      if there is a partial  single valued  function f  fp
 resp  f  fpi     such that f  i   s i  and f  i  is undefined iff s i      for example 
computing a satisfying assignment for a propositional cnf  fsat  and computing an optimal tour
in the traveling salesperson problem  tsp  are in f p  under this view  cf   papadimitriou        
a partial function f is polynomial time reducible to another partial function g  if there are
polynomial time computable functions h   and h  such that f  i    h   i  g h   i    for all i and
g h   i   is defined whenever f  i  is defined  hardness and completeness are defined as usual 
    problem setting
we will focus on the following questions 
checking well definedness  decide whether a given action description is well defined wrt  a
given planning domain pd  resp  whether a given planning domain pd is well defined 
admissible planning  decide whether for planning problem p an admissible  optimistic secure 
plan exists wrt  a given cost value c  and find such a plan 
optimal planning  find an optimal  optimistic secure  plan for a given planning problem 
notice that  eiter et al       b  focused on deciding the existence of optimistic secure plans 
rather than on actually finding plans  and presented a detailed study of the complexity of this task
under various restrictions for ground  propositional  planning problems  in this paper  we confine
the discussion to the case of planning problems p   hpd  q    l i which look for polynomial length
plans  i e   problems where the plan length l is bounded by some polynomial in the size of the input 
we shall consider here mainly ground  propositional  planning  and assume that the planning
domains are well typed and that the unique model of the background knowledge can be computed
in polynomial time  in the general case  by well known complexity results on logic programming 
cf   dantsin  eiter  gottlob    voronkov         already evaluating the background knowledge is
exptime hard  and the problems are thus provably intractable  we recall the following results 
which appear in  or directly follow from  previous work  eiter et al       b  
proposition     deciding  given a propositional planning problem p and a sequence p   ha            
al i of action sets   i  whether a given sequence t   ht             tl i is a legal trajectory witnessing that
p is an optimistic plan for p is feasible in polynomial time  and  ii  whether p is a secure plan for
p is p   complete 
    results
we start by considering checking well definedness  for this problem  it is interesting to investigate
the non ground case  assuming that the background knowledge is already evaluated  this way we
can assess the intrinsic difficulty of this task obtaining the following result 
theorem      complexity of checking well definedness  given a k c planning domain pd  
h  hd  rii and the unique model m of   checking  i  well definedness of a given action declaration d of form     wrt  pd and  ii  well definedness of pd are both  p   complete 
  

fia nswer s et p lanning u nder action c osts

proof  membership  as for  i   d is violated if it has a nonempty costs part and a legal action
instance a   p x            xn   such that either     there exist witness substitutions  and    for a such
that time   time     cost  a    val c  and cost   a    val c      and val c     val c     
or     there is no witness substitution  for a such that cost   a    val c  is an integer  such
an a can be guessed and checked  via a witness substitution  in polynomial time  and along with
a also  and    as in      note that  by definition  all variables must be substituted by constants
from the background knowledge  including numbers   and so must be values for time if it occurs in
c            ck   given a  we can decide     with the help of an np oracle  in summary  disproving welldefinedness of d is nondeterministically possible in polynomial time with an np oracle  hence 
checking well definedness of d is in co p    p    the membership part of  ii  follows from  i  
since well definedness of pd reduces to well definedness of all action declarations in it  and p  is
closed under conjunctions 
hardness  we show hardness for  i  by a reduction from deciding whether a quantified boolean
formula  qbf 
q   xy c       ck
where each ci   li        li  i   i              k  is a disjunction of literals l i j on the atoms
x   x            xn and y   xn           xm   is true  without loss of generality  we may assume that
each ci contains three  not necessarily distinct  literals  which are either all positive or all negative 
we construct a planning domain pd and d as follows  the background knowledge    is
bool     bool    
pos           pos           pos           pos           pos           pos           pos          
neg           neg           neg           neg           neg           neg           neg          

here  bool declares the truth values   and    the facts pos x     x    x    and neg x    x    x    state
those truth assignments to x    x    and x  such that the positive clause x   x   x  resp  the
negative clause x   x   x  is satisfied 
the rest of the planning domain pd consists of the single action declaration d of form
p v         vn   requires bool v         bool vn  costs   where c         ck  

where
ci

 



pos vi     vi     vi      if ci   xi    xi    xi    
neg vi     vi     vi      if ci   xi    xi    xi    

i              k 

for example  the clause c   x   x   x  is mapped to c   pos v    v    v     it is easy to see that
each legal action instance a   p b            bn   of d corresponds     to the truth assignment  a of x
given by a  xi     bi   for i              n  furthermore  a has a cost value defined  which is    iff the
formula y  c  a      ck a   is true  thus  d is well defined wrt  pd iff q is true  since pd and
 
d are efficiently constructible  this proves p   hardness 
observe that in the ground case  checking well definedness is much easier  since no substitutions need to be guessed  the test in the proof of theorem     is polynomial  thus  by our assumption
on the efficient evaluation of the background program  we obtain 
corollary     in the ground  propositional  case  checking well definedness of an action description d wrt  a kc planning domain pd   h  hd  rii  resp  of pd as a whole  is possible in
polynomial time 
  

fie iter   faber   l eone   p feifer   p olleres

we remark that checking well definedness can be expressed as a planning task in k  and also
by a logic program  we refer to  eiter  faber  leone  pfeifer    polleres      b  for details 
we now turn to computing admissible plans 
theorem      complexity of admissible planning  for polynomial plan lengths  deciding whether
a given  well defined  propositional planning problem hpd  qi has  i  some optimistic admissible
plan wrt  to a given integer b is np complete  and finding such a plan is complete for npmv   ii 
deciding whether hpd  qi has some secure admissible plan wrt  to a given integer b is  p   complete 
and computing such a plan is p  mv complete  hardness holds in both cases for fixed plan length 
as for the proof we refer to the appendix  we finally address the complexity of computing
optimal plans 
theorem      complexity of optimal planning  for polynomial plan lengths   i  computing an
optimal optimistic plan for hpd  q    l i in k c is fp   complete  and  ii  computing an optimal
secure plan for hpd  q    l i in k c is fp   complete  hardness holds in both cases even if the plan
length l is fixed 
the proof again can be found in the in the appendix 
we remark that in the case of unbounded plan length  the complexity of computing plans increases and requires  at least  exponential time in general  since plans might have exponential length
in the size of the planning problem  thus  in practical terms  constructing such plans is infeasible 
since they occupy exponential space  furthermore  as follows from previous results  eiter et al  
    b   deciding the existence of an admissible optimistic resp  secure plan for a planning problem wrt  a given cost is pspace complete resp  nexptime complete  we leave a more detailed
analysis of complexity aspects of k c for further work 

   applications
    cost efficient versus time efficient plans
in this section  we show how the language k c can be used to minimize plan length in combination
with minimizing the costs of a plan  this is especially interesting in problem settings where parallel
actions are allowed  cf   kautz   walser        lee   lifschitz         
for such domains with parallel actions  kautz and walser propose various criteria to be optimized  for instance the number of actions needed  or the number of necessary time steps when
parallel actions are allowed  as well as combinations of these two criteria         by exploiting
action costs and proper modeling  we can solve optimization problems of this sort  for example 
we can single out plans with a minimal number of actions simply by assigning cost   to all possible
actions 
we consider the following optimization problems 
   find a plan with minimal cost  cheapest plan  for a given number of steps 
   find a plan with minimal time steps  shortest plan  
   find a shortest among the cheapest plans 
  

fia nswer s et p lanning u nder action c osts

   find a cheapest among the shortest plans 
problem    is what we have already defined as optimal plans so far  we will now show how to
express    in terms of optimal cost plans as well  and how to extend this elaboration with respect
to the combinations    and    
      c heapest p lans

with

g iven p lan l ength   

as a guiding example  we refer to blocks world with parallel moves allowed  where apart from
finding shortest plans also minimizing the total number of moves is an issue  a kc encoding for this
domain  where plans are serializable  is shown in figure    serializability here means that parallel
actions are non interfering and can be executed sequentially in any order  i e  the parallel plan can
be arbitrarily unfolded to a sequential plan 
fluents  

on b  l  requires block b   location l  
blocked b  requires block b  
moved b  requires block b  

actions  

move b  l  requires block b   location l  costs   

always  

executable move b  l  if b    l 
nonexecutable move b  l  if blocked b  
nonexecutable move b  l  if blocked l  
nonexecutable move b  l  if move b   l   b   b   block l  
nonexecutable move b  l  if move b  l    l   l  
nonexecutable move b  b   if move b   l  
caused
caused
caused
caused

on b  l  after move b  l  
blocked b  if on b   b  
moved b  after move b  l  
on b  l  if not moved b  after on b  l  

figure    kc encoding for the blocks world domain
the planning problem emerging from the initial state and the goal state depicted in figure   can
be modeled using the background knowledge  bw  
block     block     block     block     block     block    
location table  
location b     block b  

and extending the program in figure   as follows 
initially   on        on    table   on        on    table   on        on    table  
goal  

on        on    table   on        on    table   on        on    table    l 

 
 

 
 

 
 

 
 

 
 

 
 

figure    a simple blocks world instance
  

fie iter   faber   l eone   p feifer   p olleres

each move is penalized with cost    which results in a minimization of the total number of moves 
let pl denote the planning problem for plan length l 
for l      we have an optimal plan which involves six moves  i e  cost p      
p    h  move    table   move    table   move    table     move        move        move        i

by unfolding the steps  this plan gives rise to similar plans of length l                that have cost   
for l      we can find among others the following optimal plan  which has cost   
p    h  move    table     move        move    table     move        move        i

this plan can not be further parallelized to having only two steps  for any plan length l      we
will obtain optimal plans similar to p     extended by void steps  thus a plan which is cheapest over
all plan lengths has cost   and needs three steps  note that shortest parallel plans  of length    are
more expensive  as explained above 
      s hortest p lans   
intuitively  it should be possible to include the minimization of time steps in the cost function  we
describe a preprocessing method which  given a k planning domain pd  a list q of ground literals 
and an upper bound i    for the plan length  generates a planning problem p   pd  q  i  such that
the optimal plans for p correspond to shortest plans which reach q in pd in at most i steps  i e  
to plans for hpd  q    l i such that l  i is minimal  we assume that no action costs are specified
in the original planning domain pd  and minimizing time steps is our only target 
first we rewrite the planning domain pd to pd  as follows  we introduce a new distinct fluent
gr and a new distinct action finish  defined as follows 
fluents  
actions  

gr 
finish costs time 

intuitively  the action finish represents a final action  which we use to finish the plan  the later
this action occurs  the more expensive the plan as we assign time as cost  the fluent gr  goal
reached  shall be true and remain true as soon as the goal has been reached  and it is triggered by
the finish action 
this can be modeled in k c by adding the following statements to the always section of the
program 
executable finish if q  not gr 
caused gr after finish 
caused gr after gr 

furthermore  we want finish to occur exclusively and we want to block the occurrence of any
other action once the goal has been reached  therefore  for every action a in pd  we add
nonexecutable a if finish 

and add not gr to the if part of each executability condition for a  finally  to avoid any inconsistencies from static or dynamic effects as soon as the goal has been reached  we add not gr to the
if part of any causation rule of the pd except nonexecutable rules which remain unchanged   
we define now p  pd  q  i    hpd   gr   i     i  we take i     as the plan length since we
need one additional step to execute the finish action 
   there is no need to rewrite nonexecutable rules because the respective actions are already switched off by
rewriting the executability conditions 

  

fia nswer s et p lanning u nder action c osts

by construction  it is easy to see that any optimal plan p   ha             aj   aj             ai   i for
the planning problem p must have aj      finish  and aj             ai      for some
j              i   we thus have the following desired property 
proposition     the optimal plans for p  are in     correspondence to the shortest plans reaching q in pd  more precisely  p   ha            aj               i is an optimal optimistic plan for
p  pd  q  i  and aj      finish  if and only if p     ha            aj i is an optimistic plan for
hpd  q    j i where j              i   and hpd  q    j    i has no optimistic plan for each j     j 
in our blocks world example  using this method we get all   step plans  if we choose i    
to compute shortest plans over all plan lengths  we can set the upper bound i large enough such
that plans of length l  i are guaranteed to exist  a trivial such bound is the total number of legal
states which is in general exponential in the number of fluents 
however  many typical applications have an inherent  much smaller bound on the plan length 
for instance  in a blocks world with n blocks  any goal configuration can be reached within at most
 n  sinit  sgoal steps  where sinit and sgoal are the numbers of stacks in the initial and the goal
state  respectively   therefore    is an upper bound for the plan length of our simple instance 
we remark that this approach for minimizing plan length is only efficient if an upper bound
close to the optimum is known  searching for a minimum length plan by iteratively increasing the
plan length may be much more efficient if no such bound is known  since a weak upper bound can
lead to an explosion of the search space  cf  the benchmarks in section      
      s hortest

among the

c heapest p lans   

in the previous subsection  we have shown how to calculate shortest plans for k programs without
action costs  combining arbitrary k c programs and the rewriting method described there is easy 
if we want to find a shortest among the cheapest plans  we can use the same rewriting  with just a
little change  all we have to do is setting the costs of all actions except finish at least as high as
the highest possible cost of the finish action  this is is obviously the plan length i      so  we
simply modify all action declarations
a requires b costs c where d 

in p by multiplying the costs with factor i     
a requires b costs c  where c     i       c  d 

this lets all other action costs take priority over the cost of finish and we can compute plans
satisfying criterion     let p denote the resultant planning problem  then we have 
proposition     the optimal plans for p  are in     correspondence to the shortest among the
cheapest plans reaching q in pd within i steps  more precisely  p   ha             aj               i
is an optimal optimistic plan for p  pd  q  i  and aj      finish  if and only if  i  p    
ha            aj i is a plan for pj   hpd  q    j i  where j              i   and  ii  if p      ha            aj   i
is any plan for pj     hpd  q    j    i where j    i  then either costpj    p        costpj  p     or
costpj    p        costpj  p     and j    j 
figure   shows p for our blocks world instance where i      one optimal plan for p  is
   one can solve any blocks world problem sequentially by first unstacking all blocks which are not on the table
 n  sinit steps  and then building up the goal configuration  n  sgoal steps  

  

fie iter   faber   l eone   p feifer   p olleres

fluents  

on b  l  requires block b   location l  
blocked b  requires block b  
moved b  requires block b  
gr 

actions  

move b  l  requires block b   location l  costs c where c        
finish costs time 

always  

executable move b  l  if b    l  not gr 
nonexecutable move b  l  if blocked b  
nonexecutable move b  l  if blocked l  
nonexecutable move b  l  if move b   l   b   b   block l  
nonexecutable move b  l  if move b  l    l   l  
nonexecutable move b  b   if move b   l  
caused
caused
caused
caused

on b  l  if not gr after move b  l  
blocked b  if on b   b   not gr 
moved b  if not gr after move b  l  
on b  l  if not moved b   not gr after on b  l  

executable finish if on        on    table   on        on    table  
on        on    table   not gr 
caused gr after finish 
caused gr after gr 
nonexecutable move b  l  if finish 
initially   on        on    table   on        on    table   on        on    table  
goal  

gr     

figure    computing the shortest plan for a blocks world instance with a minimum number of
actions

p   h  move    table     move        move    table   
 move        move          finish        i 

which has costp  p         we can now compute the optimal cost wrt  optimization    by subtracting the cost of finish and dividing by i                i                   thus  we
need a minimum of   moves to reach the goal  the minimal number of steps is obviously all steps 
except the final finish action  i e     thus  we need at least   steps for a plan with five moves 
      c heapest

among the

s hortest p lans   

again  we can use the rewriting for optimization     the cost functions have to be adapted similarly
as in the previous subsection  such that now the cost of the action finish takes priority over all other
actions costs  to this end  it is sufficient to set the cost of finish high enough  which is achieved
by multiplying it with a factor f higher than the sum of all action costs of all legal action instances
at all steps j              i      let p denote the resulting planning problem  we have 
proposition     the optimal plans for p  are in     correspondence to the cheapest among the
shortest plans reaching q in pd within i steps  more precisely  p   ha             aj               i
  

fia nswer s et p lanning u nder action c osts

is an optimal optimistic plan for p  pd  q  i  and aj      finish  if and only if  i  p    
ha            aj i is a plan for pj   hpd  q    j i  where j              i   and  ii  if p      ha            aj   i
is any plan for pj     hpd  q    j    i where j    i  then either j     j  or j     j and costpj    p      
costpj  p     
in our example  there are    possible moves  thus  we could take f        i      and
would set the costs of finish to time       i       however  we only need to take into account
those actions which can actually occur simultaneously  in our example  at most six blocks can
be moved in parallel  therefore  it is sufficient to set f       i      and assign finish cost
time  f   time      accordingly  the action declarations are modified as follows 
actions  

move b  l  requires block b   location l  costs   
finish costs c where c   time     

an optimal plan for the modified planning problem p is 
p   h  move    table   move    table   move    table   
 move        move        move          finish         i

we have costp  p          here  we can compute the optimal cost wrt  optimization    by simply
subtracting the cost of finish  i e                  since finish occurs at time point   
consequently  we need a minimum of   moves for a shortest plan  which has length          
and indeed  we have seen that  and how  the optimization problems    through    can be
represented in kc   we remark that the transformations p    p   and p all work under the restrictions
to secure and or sequential plans as well 
    traveling salesperson
as another illustrating example for optimal cost planning  we will now introduce some elaboration
of the traveling salesperson problem 
traveling salesperson problem  tsp   we start with the classical traveling salesperson problem  tsp   where we have a given set of cities and connections  e g   roads  airways  of certain costs 
we want to know a most economical round trip which visits all cities exactly once and returns to
the starting point  if such a tour exists   figure   shows an instance representing the capitals of all
austrian provinces  the dashed line is a flight connection  while all other connections are roads 
each connection is marked with the costs in traveling hours 
brg     bregenz
eis     eisenstadt
gra     graz
ibk     innsbruck
kla     klagenfurt
lin     linz
sbg     salzburg
stp     st  plten
vie     vienna

lin
sbg

 

 

ibk

 

 

vie
 

 
 
 

 

 
kla

figure    tsp in austria

eis

 

 

  

 
stp  

 

 
brg

 

gra

 

fie iter   faber   l eone   p feifer   p olleres

we represent this in kc as follows  the background knowledge  t sp defines two predicates
city c  and conn f  t  c  representing the cities and their connections with associated costs  connections can be traveled in both ways 
conn brg  ibk      conn ibk  sbg      conn ibk  vie      conn ibk  kla     
conn sbg  kla      conn sbg  gra      conn sbg  lin      conn sbg  vie     
conn kla  gra      conn lin  stp      conn lin  vie      conn lin  gra     
conn gra  vie      conn gra  eis      conn stp  vie      conn eis  vie     
conn stp  eis      conn vie  brg     
conn b  a  c     conn a  b  c  
city t     conn t      

a possible encoding of tsp starting in vienna  vie  is the k c program in figure    it includes two
actions for traveling from one city to another and for directly returning to the starting point at the
end of the round trip as soon as all cities have been visited 
actions  

travel x  y  requires conn x  y  c  costs c 
return from x  requires conn x  vie  c  costs c 

fluents  

unvisited  end 
in c  requires city c  
visited c  requires city c  

always  

executable travel x  y  if in x  
nonexecutable travel x  y  if visited y  
executable return from x  if in x  
nonexecutable return from x  if unvisited 
caused unvisited if city c   not visited c  
caused end after return from x  
caused in y  after travel x  y  
caused visited c  if in c  
inertial visited c  

noconcurrency 
initially   in vie  
goal  
end     

figure    traveling salesperson
the problem has ten optimal   step solutions with cost     we show only the first five here  as the
others are symmetrical 
p    h  travel vie  stp   
 travel lin  sbg   
 return from brg  
p    h  travel vie  eis   
 travel sbg  gra   
 return from brg  
p    h  travel vie  eis   
 travel gra  kla   
 return from brg  
p    h  travel vie  lin   
 travel gra  kla   

 travel stp  eis   
 travel sbg  kla   
i
 travel eis  stp   
 travel gra  kla   
i
 travel eis  stp   
 travel kla  sbg   
i
 travel lin  stp   
 travel kla  sbg   

 travel eis  gra     travel gra  lin   
 travel kla  ibk     travel ibk  brg   
 travel stp  lin     travel lin  sbg   
 travel kla  ibk     travel ibk  brg   
 travel stp  lin     travel lin  gra   
 travel sbg  ibk     travel ibk  brg   
 travel stp  eis     travel eis  gra   
 travel sbg  ibk     travel ibk  brg   

  

fia nswer s et p lanning u nder action c osts

 return from brg  
p    h  travel vie  gra   
 travel lin  sbg   
 return from brg  

i
 travel gra  eis     travel eis  stp     travel stp  lin   
 travel sbg  kla     travel kla  ibk     travel ibk  brg   
i

tsp with variable costs  let us now consider an elaboration of tsp  where we assume that
the costs of traveling different connections may change during the trip  note that three of the
five solutions in our example above include traveling from st polten to eisenstadt or vice versa on
the second day  let us now assume that the salesperson  who starts on monday  has to face some
exceptions which might increase the cost of the trip  for instance   i  heavy traffic jams are expected
on tuesdays on the route from st polten to eisenstadt or  ii  the salesperson shall not use the flight
connection between vienna and bregenz on mondays as only expensive business class tickets are
available on this connection in the beginning of the week  so we have to deal with different costs
for the respective connections depending on the particular day 
to this end  we first add to the background knowledge t sp a new predicate cost a  b  w  c 
representing the cost c of traveling connection a to b on weekday w which can take exceptional
costs into account 
cost a  b  w  c     conn a  b  c    int w       w  w       not ecost a  b  w  
ecost a  b  w     conn a  b  c   cost a  b  w  c    c    c  

the original costs in the predicate conn a  b  c  now represent defaults  which can be overridden
by explicitly adding different costs  for instance  to represent the exceptions  i  and  ii   we add 
cost stp  eis          cost vie  brg         

setting the exceptional costs for these two critical connections to     weekdays are coded by integers
from    monday  to    sunday   we represent a mapping from time steps to the weekdays by the
following rules which we also add to  t sp  
weekday       
weekday d  w     d   d       w   w       weekday d   w    w      
weekday d        d   d       weekday d      

note that although the modified background knowledge t sp is not stratified  since cost is defined
by cyclic negation   it has a total well founded model  and thus a unique answer set 
finally  we change the costs of traveling and returning in the k c program from figure   
actions  

travel x  y  requires conn x  y  c   costs c
where weekday time  w   cost x  y  w  c  
return from x  requires conn x  vie  c   costs c
where weekday time  w   cost x  vie  w  c  

since now the costs for p   which includes traveling from st polten to eisenstadt  on the second
day have increased due to exception  i   only four of the plans from above remain optimal  note
that unlike the default costs  exceptional costs do not apply bidirectionally  so the exception does
not affect p  and p    furthermore  due to exception  ii  the symmetrical round trips starting with
the flight trips to bregenz are no longer optimal 
the presented encoding proves to be very flexible  as it allows for adding arbitrary exceptions
for any connection on any weekday by simply adding the respective facts  moreover  even more
involved scenarios  where exceptions are defined by rules  can be modeled 
  

fie iter   faber   l eone   p feifer   p olleres

    a small example for planning under resource restrictions
although planning with resources is not the main target of our approach  the following encoding
shows that action costs can also be used in order to model optimization of resource consumption in
some cases  an important resource in real world planning is money  for instance  let us consider a
problem about buying and selling  lee   lifschitz        
i have    in my pocket  a newspaper costs    and a magazine costs     do i have
enough money to buy one newspaper and two magazines 
in kc   this can be encoded in a very compact way by the following background facts 
item newspaper      item magazine     

combined with the following short k c program 
actions  

buy item  number  requires item item  price    int number 
costs c where c   number  price 

fluents  

have item  number  requires item item  price    int number  

always  

executable buy item  number  
nonexecutable buy item  n   if buy item  n    n    n  
caused have item  number  after buy item  number  

goal  

have newspaper      have magazines          

the action buy is always executable  but one must not buy two different amounts of a certain
item at once  obviously  no admissible plan wrt  cost   exists  as the optimal plan for this problem 
h buy newspaper      buy magazine      i has cost p      therefore  the answer to the problem
is no 
our approach considers only positive action costs and does not directly allow modeling full
consumer producer provider relations on resources in general  in favor of a clear non ambiguous
definition of optimality  for instance  by allowing negative costs one could always add a producer
action to make an existing plan cheaper  whereas in our approach costs are guaranteed to increase
monotonically  allowing for a clear definition of plan costs and optimality 
on the other hand  we can encode various kinds of resource restrictions by using fluents to represent these resources  we can then model production consumption as action effects on these fluents
and add restrictions as constraints  this allows us to model even complex resource or scheduling
problems  optimization  however  remains restricted to action costs 

   transformation to logic programming
in this section  we describe how planning under action costs can be implemented by means of a
transformation to answer set programming  it extends our previous transformation  eiter et al  
    a   which maps ordinary k planning problems to disjunctive logic programs under the answer
set semantics  gelfond   lifschitz         and takes advantage of weak constraints  cf   buccafurri 
leone    rullo               as implemented in the dlv system  faber   pfeifer        eiter 
faber  leone    pfeifer      a   in addition  we show how this translation can be adapted to the
language of smodels  simons  niemela    soininen        
    disjunctive logic programs with weak constraints
first  we give a brief review of disjunctive logic programs with weak constraints 
  

fia nswer s et p lanning u nder action c osts

syntax

a disjunctive rule  for short  rule  r is a construct
a  v    v an    b         bk   not bk          not bm  

   

where all ai and bj are classical literals over a function free first order alphabet  and n     m 
k     the part left  resp  right  of    is the head  resp  body  of r  where    is omitted if
m      we let h r     a           an   be the set of head literals and b r    b    r   b   r 
the set of body literals  where b    r     b           bk   and b   r     bk             bm    a  strong 
constraint is a rule with empty head  n      
a weak constraint is a construct
  b         bk   not bk          not bm    w   

   

where w is an integer constant or a variable occurring in b             bk and all bi are classical literals  
b r  is defined as for     
a disjunctive logic program  dlpw    simply  program  is a finite set of rules  constraints and
weak constraints  here  superscript w indicates the potential presence of weak constraints 
semantics the answer sets of a program  without weak constraints are defined as usual  gelfond   lifschitz        lifschitz         there is one difference  though  we do not consider
inconsistent answer sets  the answer sets of a program  with weak constraints are defined by
selection from the answer sets s of the weak constraint free part    of  as optimal answer sets 
a weak constraint c of form     is violated  if it has an instance for which its conjunction is
satisfied with respect to the candidate answer set s  i e   there exists a substitution mapping  from
the variables in c to the herbrand base of  such that  b          bk    s and  bk          bm  
m     we then call w the violation value of c wrt      the violation cost of c wrt  s  denoted
costc  s   is the sum of all violation values over all violating substitutions for c wrt  s  the cost of
s  denoted cost  s   is then
x
cost  s   
costc  s  
c  weak constraints of 

i e   the sum of violation costs of weak constraints in  wrt  s  an answer set m of  is now
selected  called an optimal answer set   if cost   m   is minimal over all answer sets of  
from  buccafurri et al         we know that given a head cycle free disjunctive program  deciding whether a query q is true in some optimal answer set is  p   complete  the respective class for
computing such an answer set is fp   complete  together with the results from section   this indicates that translations of optimal planning problems to head cycle free disjunctive logic programs
with weak constraints or the language of smodels are feasible in polynomial time 
    translating kc to dlpw
we extend our original transformation lp p   which naturally maps a k planning problem p into a
weak constraint free program  eiter et al       a   to a new translation lp w  p   such that the optimal
answer sets of lpw  p  correspond to the optimal cost plans for the k c planning problem p 
   the colon in  w    stems from the dlv language  which allows to specify a priority layer after the colon  we do not
need priority layers in our translation  but stick to the dlv syntax 
   a weak constraint c is only admissible  if all possible violation values in all candidate answer sets s are integers 
thus  if w is a variable  then  must guarantee that w can only be bound to an integer 

  

fie iter   faber   l eone   p feifer   p olleres

basically  in lp p  fluent and action literals are extended by an additional time parameter  and
executability conditions as well as causations rules are modularly translated  rule by rule  into corresponding program rules and constraints  disjunction is used for guessing the actions which should
be executed in the plan at each point in time 
      r eview

of the

t ranslation lp p 

the basic steps of the translation from k programs to logic programs are as follows  cf   eiter et al  
    a  for details  
step    macro expansion  

first  replace all macros in the k program by their definitions 

step    background knowledge   the background knowledge  of p is already given as a logic
program and is included in lp p   without further modification 
step    auxiliary predicates  

to represent steps  we add the following facts to lp p 

time              time l   next                 next l     l  

where l is the plan length of the query q   g  l  in p at hand 
step    causation rules   causation rules are mapped to rules in lp p  by adding type information and extending fluents and actions with a time stamp using time and next  for example 
caused across x  after cross x    across x  

leads to rule across x  t      cross x  t     across x  t    person x   next t   t    
in lp p  where t    t  are new variables  here  type information person x  for across x   and
 across x   taken from the type declaration  is added  which helps to avoid unsafe logic programming rules 
step    executability conditions   similarly  each executability condition is translated to a disjunctive rule guessing whether an action occurs at a certain time step  in our running example 
executable cross x  if haslamp x  

becomes cross x  t     cross x  t      haslamp x  t    person x   next t   t    
which encodes a guess whether at time point t   action cross x  should happen  again  type information person x  is added as well as next t     t    to ensure that t  is not the last time point 
step    initial state constraints   initial state constraints are transformed like static causation
rules in step    but using the constant   instead of the variable t   and thus need no auxiliary predicate for the time stamp  for instance 
initially   caused  across x  

becomes  by again adding the type information  across x        person x  
step    goal query  
goal  

finally  the query q 

g   t             gm  tm    not gm    tm              not gn  tn      l  

is translated as follows  where goal reached is a new   ary predicate symbol 
goal reached    g   t    l           gm  tm   l   not gm    tm     l           not gn  tn   l  
   not goal reached 
  

fia nswer s et p lanning u nder action c osts

      e xtending

the

t ranslation

to

action c osts

the extended translation lpw  p  for a kc problem p first includes all rules of lp pnc    where pnc
results from p by stripping off all cost parts  furthermore  the following step is added 
step    action costs  

for any action declaration d of form     with a nonempty costs part  add 

 i  a new rule rd of the form

costp  x            xn   t  c     p x            xn   t   t            tm  
c            ck   u   t     

   

where costp is a new symbol  t and u are new variables and     time  u   as an optimization 
u   t     is only present if u occurs elsewhere in r d  
  costp  x            xn   t  c    c   

 ii  a weak constraint wcd of the form

   

for example  the cross action from the quick bridge crossing problem is translated to
costcross x  t  wx    cross x  t   person x   walk x  wx  
  costcross x  t  wx    wx   

as we showed in previous work  eiter et al       a   the answer sets of lp p  correspond to
trajectories of optimistic plans for p  the following theorem states a similar correspondence result
for lpw  p  and optimal plans for p  we define  for any consistent set of ground literals s  the sets
asj    a t    a t  j      s  a   act   and ssj    f  t    f  t  j   s  f  t   lf l    for all j    
theorem      answer set correspondence  let p   hpd  qi be a  well defined  k c planning
problem  and let lpw  p  be the above program  then 
 i  for each optimistic plan p   ha            al i of p and supporting trajectory t   hhs     a    s  i 
hs    a    s  i          hsl    al   sl ii of p   there exists some answer set s of lp w  p  such that
aj   asj for all j              l  sj   ssj   for all j              l and costp  p     costlpw  p   s  
 ii  for each answer set s of lpw  p   the sequence p   ha            al i is a solution of p  i e   an
optimistic plan  witnessed by the trajectory t   hhs     a    s  i  hs    a    s  i          hsl    al   sl ii
with costp  p     costlpw  p   s   where aj   asj and sk   ssk for all j              l and
k              l 
the proof is based on the resp  correspondence result for k  eiter et al       a   for the details 
we refer to the appendix 
from this result and the definitions of optimal cost plans and optimal answer sets  we conclude
the following result 
corollary      optimal answer set correspondence  for any well defined k c planning problem
p   hpd  q    l i  the trajectories t   hhs     a    s  i          hsl    al   sl ii of optimal plans p for p
correspond to the optimal answer sets s of lp w  p   such that aj   asj for all j              l and
sj   ssj   for all j              l 
proof  for each a  aj   the weak constraint     causes a violation value of cost j  a   furthermore  these are the
p onlypcost violations  thus  a candidate answer set s is optimal if and only if
costlpw  p   s    lj   aaj costj  a    costp  p   is minimal  i e   s corresponds to an optimal
plan 
 
a similar correspondence result also holds for admissible plans 
  

fie iter   faber   l eone   p feifer   p olleres

corollary      answer set correspondence for admissible plans  for any well defined k c planning problem p   hpd  q    l i  the trajectories t   hhs     a    s  i          hsl    al   sl ii of admissible plans p for p wrt  cost c correspond to the answer sets s of lp w  p  having costlpw  p   s   c 
such that aj   asj for all j              l and sj   ssj   for all j              l 
as for secure planning  we have introduced a technique to check security of an optimistic plan
for certain planning problem instances by means of a logic program  eiter et al       a   this
method carries over to planning with action costs in a straightforward way  and optimal resp  admissible secure plans can be similarly computed by answer set programming 
    alternative translation for smodels
apart from the presented translation using weak constraints  one could also choose an alternative
approach for the translation to answer set programming  smodels  simons et al         supports
another extension to pure answer set programming allowing to minimize over sets of predicates 
this approach could be used in an alternative formulation of step   
step  a 

for action declarations with nonempty costs parts  we add a new rule of form
cost p  x            xn                 t  c     t            tm   c            ck   u   t     

   

similar to step   above  with two differences      action name p is now a parameter  and     we add
l  n parameters with constant   between x n and t where l is the maximum arity of all actions in
pd  this is necessary in order to get unique arity l     for predicate cost  furthermore  we add
occurs p  x            xn                 t     p x            xn   t   t            tm   

   

this second rule adds the same   parameters as for to achieve unique arity l     of the new
predicate occurs  using smodels syntax  we can now compute optimal plans by adding
minimize occurs a  x        xl   t    cost a  x        xl   t  c    c  

note that smodels does not support disjunction in rule heads  so we also need to modify step   
expressing the action guess via unstratified negation or smodels choice rules 

   implementation
we have implemented an experimental prototype system  dlv k   for solving k planning problems  eiter et al       a   an improved version of this prototype it is now capable of optimal
and admissible planning with respect to the extended syntax of k c   available for experiments at
http   www dlvsystem com k   
dlvk has been realized as a frontend to the dlv system  faber   pfeifer        eiter et al  
    a   first  the planning problem at hand is transformed as described in the previous section 
then  the dlv kernel is invoked to produce answer sets  for optimistic planning the  optimal  if
action costs are defined  answer sets are then simply translated back into suitable output for the user
and printed 
in case the user specified that secure conformant planning should be performed  our system has
to check security of the plans computed  in normal  non optimal  planning  this is simply done by
checking each answer set returned right before transforming it back to user output  in the case of
  

fia nswer s et p lanning u nder action c osts

optimal secure planning  on the other hand  the candidate answer set generation of the dlv kernel
has to be intercepted  the kernel proceeds computing candidate answer sets  returning an answer
set with minimal violation cost value  by running through all candidates  here  in order to generate
optimal secure plans  the planning frontend interrupts computation  allowing only answer sets which
represent secure plans to be considered as candidates 
checking plan security is done by rewriting the translated program wrt  the candidate answer
set plan in order to verify whether the plan is secure  the rewritten check program is tested by a
separate invocation of the dlv kernel  as for further details on the system architecture we refer to
 eiter et al       a 
    usage
suppose the background knowledge and the program depicted in figure   with the cost extensions
from section     are stored in files crossing bk and crossing plan  then  by invoking the
program with the command line
dlv  fpcrossing plancrossing bk  planlength    

we compute all optimal plans solving this problem in seven steps  in the output we find  after a
supporting trajectory  the following optimal plan 
plan   crosstogether joe  jack       cross joe       takelamp william  
crosstogether william  averell        takelamp jack  
cross jack       crosstogether joe  jack      cost     

for each action  its cost is shown after a colon  if it is non zero  the switch  planlength i can
be used to set the plan length  it overrides any plan length given in the query part of the planing
problem  using  planlength    we get plans with cost     as there are no cheaper plans of that
length 
the user is then asked whether to perform the optional security check and whether to look for
further  optimal  plans  respectively  the switch  fpsec can be used instead of  fp to obtain
secure plans only 
the command line option  costbound n effects the computation of all admissible plans
with respect to cost n   for example  the resource problem described in section     can be solved
by the following call to our prototype 
dlv  fpbuying bkbuying plan  n       planlength      costbound    

correctly  no admissible plan is found  when calling the system again without cost bound  the
prototype calculates the following optimal cost plan 
plan   buy newspaper          buy magazine        

cost    

the current prototype supports simple bounded integer arithmetics  the option  n    used
above sets an upper bound of n      for the integers which may be used in a program  the builtin predicate  int is true for all integers         n   setting n high enough  taking into account
the outcome of built in arithmetic predicates a   b   c and a   b  c  is important to get
correct results  further details on the prototype are given on the dlv k web site at http   www 
dlvsystem com k  
  

fie iter   faber   l eone   p feifer   p olleres

    experiments
performance and experimental results for dlv k  without action costs and optimal planning  were
reported in previous work  eiter et al       a   in this section  we present some encouraging experimental results for planning with action costs  in particular for parallel blocks world and tsp  all
experiments were performed on a pentium iii    mhz machine with    mb of main memory running suse linux      we set a time limit of      seconds for each tested instance where exceeding
this limit is indicated by   in the result tables 
where possible  we also report results for ccalc and cmbp  two other logic based planning
systems whose input languages  c  resp  ar  have capabilities similar to k resp  k c  
ccalc  the causal calculator  ccalc  is a model checker for the languages of causal theories
 mccain   turner         it translates programs in the action language c  into the language of
causal theories which are in turn transformed into sat problems  these are then solved using a sat
solver  mccain   turner         the current version of ccalc uses mchaff  moskewicz et al  
      as its default sat solver  minimal length plans are generated iteratively increasing the plan
length up to an upper bound  ccalc is written in prolog  for our tests  we used version     b of
ccalc which we obtained from  url http   www cs utexas edu users tag cc 
  and a trial version of sicstus prolog        we used encodings taken from  lee   lifschitz 
      for parallel blocks world adapted for ccalc      these encodings are included in the
current download version of the system  for sequential blocks world we adapted the encodings
by adding the c  command noconcurrency  which resembles the respective k command  all
results for ccalc include     sec startup time 
cmbp  the conformant model based planner  cmbp   cimatti   roveri        is based on the
model checking paradigm and exploits symbolic boolean function representation techniques such
as binary decision diagrams  bryant         cmbp allows for computing sequential minimal
length plans  where the user has to declare an upper bound for the plan length  its input language
is an extension of ar  giunchiglia  kartha    lifschitz         unlike k or action languages
such as c   lee   lifschitz         this language only supports propositional actions  cmbp is
tailored for conformant planning  the results reported complement a previous comparison which
also shows the encoding for sequential blocks world in cmbp  eiter et al       a   for our tests 
we used cmbp      available at  url http   sra itc it people roveri cmbp   
      b locks w orld
tables    show the results for our different blocks world encodings in section     on several
configurations  p  denotes our simple instance from figure    while p p  are instances used in
previous work  eiter et al       a  erdem        
table   shows the results for finding a shortest sequential plan  the second and third column
show the number of blocks and the length of a shortest plan  i e   the least number of moves  solving
the respective blocks world instance  the execution time for solving the problem using the shortestplan encoding p in section     is shown in column five  using the upper bound shown in the fourth
column on the plan length  column six shows the execution time for finding the shortest plan in
an incremental plan length search starting from    similar to the method used for ccalc  the
remaining two columns show the results for ccalc and cmbp 
  

fia nswer s et p lanning u nder action c osts

problem
p 
p 
p 
p 
p 
p 

 blocks
 
 
 
 
  
  

min   moves    steps 
 
 
 
 
 
  

upper bound  steps
 
 
 
  
  
  

dlvk

dlvk
inc

    s
    s
    s
     s
 

    s
    s
    s
    s
    s
     s

ccalc
    s
    s
    s
     s
     s
     s

cmbp
     s
    s
    s
 

table    sequential blocks world   shortest plans

problem
p 
p 
p 
p 
p 
p 
p 

 blocks
 
 
 
 
 
  
  

 steps fixed 
 
 
 
 
 
 
 

min   moves
 
 
 
 
 
  
  

dlvk
    s
    s
    s
    s
    s
    s
   s

table    parallel blocks world   cheapest plans  minimal number of moves at fixed plan length   

table   shows the execution times for parallel blocks world with fixed plan length where the
number of moves is minimized  i e  problem    in section      we used the encoding in figure   
which generates parallel serializable plans  as ccalc and cmbp do not allow for optimizing
other criteria than plan length  we only have results for dlv k here 
next  table   shows some results for finding a shortest parallel plan  i e  problem    in section      first  the minimal possible number of steps is given  we processed each instance  i  using
the encoding p from section       ii  without costs by iteratively increasing the plan length and
 iii  using ccalc  by iteratively increasing the plan length until a plan is found  for every result 
the number of moves of the first plan computed is reported separately  as cmbp only supports
sequential planning  it is not included in this comparison 
finally  table   shows the results for the combined optimizations    and    for parallel blocks
world as outlined in section      the second column again contains the upper bound for the plan

upper bound
p 
p 
p 
p 
p 
p 

 
 
 
  
  
  

min   steps
 
 
 
 
 
 

dlvk
 moves
 
 
 
 

time
    s
    s
    s
 

dlvk
inc
 moves
 
 
 
  
  
  

time
    s
    s
    s
    s
    s
    s

table    parallel blocks world   shortest plan   

  

ccalc
 moves
time
 
    s
 
    s
 
    s
 
    s
  
     s
  
     s

fie iter   faber   l eone   p feifer   p olleres

  
p 
p 
p 
p 
p 
p 

upper bound
 
 
 
  
  
  

steps moves
   
   
   
   
   
     

  

dlvk

dlvk
inc

    s
    s
    s
 

    s
    s
    s
    s
 

ccalc
    s
    s
    s
     s
     s
   s

steps moves
   
   
   
   
    
    

dlvk

dlvk
inc

    s
    s
    s
   s
 

    s
    s
    s
    s
    s
   s

table    parallel blocks world        

length of the respective instance  the following three columns present the results on finding a
shortest among the cheapest plans  i e  problem    in section     
dlvk refers to the results for our combined minimal encoding p  and as described in section     
dlvk
inc refers to the results for incrementally searching for the shortest among the cheapest plans 

this is done by means of the  costbound i command line option taking the minimal
sequential costs  i e   the shortest sequential plan length as computed in table    as an upper
cost limit  as our encodings compute serializable plans  the minimal sequential length can be
used as cost limit in this special case 
ccalc a similar technique can be used with ccalc when encoding bound costs through additive fluents  lee   lifschitz        
note that the incremental strategy  used by dlv k
inc and ccalc  takes advantage of our specific formulation of the parallel blocks world problem  in general  when allowing parallel actions
which are not necessarily serializable and have arbitrary costs  the optimal parallel cost might differ
from the optimal sequential solution  in particular  plans which are longer than the cheapest sequential plans  which  in this example  coincide with the shortest sequential plans  may need to be
considered  this makes incremental search for a solution of problem    infeasible in general 
the last test is finding a cheapest among the shortest plans  that is  problem    in section     
again we have tested the integrated encoding with an upper bound  p    resp  incrementally finding
the shortest plan  unlike for problem     we cannot derive a fixed cost limit from the sequential
solution here  we really need to optimize costs  which makes an encoding in ccalc infeasible 
blocks world  results the blocks world experiments show that dlv k can solve various optimization tasks in a more effective and flexible way than the systems compared  on the other hand 
as already stated above  for the minimal plan length encodings in section      we can only solve
the problems where a tight upper bound for the plan length is known  iteratively increasing the plan
length is more effective  especially if the upper bound is much higher than the actual optimal solution  this becomes drastically apparent when execution times seem to explode from one instance
to the next  in a highly non linear manner as in table   where a solution for p  can be found in
reasonable time whereas p  and p  could not be solved within the time limit of      seconds  this
observation is also confirmed in the other tables  instance p  in table    etc   and is partly explained
by the behavior of the underlying dlv system  which is not geared towards plan search  and as a
general purpose problem solver uses heuristics which might not work out well in some cases  in
particular  during the answer set generation process in dlv  no distinction is made between actions
  

fia nswer s et p lanning u nder action c osts

and fluents  which might be useful for planning tasks to control the generation of answer sets resp 
plans  this may be part of further investigations 
interestingly  ccalc finds better quality parallel solutions for problem     cf  table     i e 
solutions with fewer moves  although it is significantly slower than our system on these instances 
for the incremental encoding of problem     ccalc seems even more effective than our system 
however  ccalc offers no means of optimization  it allows for admissible but not for optimal
planning  this makes our approach more flexible and general  as stated above  we could fortunately
exploit the fixed cost bound in this particular example for ccalc  which is not possible in general
instances of problem    
problem    is also intuitively harder than simply finding a shortest plan or a cheapest among
all shortest plans in general  while these problems can always be solved incrementally  for    we
must consider all plans of all lengths  a longer plan may be cheaper  so we cannot freeze the plan
length once a  shortest  plan has been incrementally found 
      tsp
some experimental results on tsp with variable costs are reported in tables   and    unlike for
blocks world  no comparable systems were available  none of the systems from above supports cost
optimal planning as needed for solving this problem  here  the plan length is always given by the
number of cities 
table   shows the results for our tsp instance on the austrian province capitals as in figure  
 nine cities     connections   with and without the exceptional costs as in section      with and without subscript exc in the table   further instances reported in this table with different cost exceptions
 we  lwe  rnd  are described below 
results for some bigger tsp instances  given by the capitals of the    members of the european
union  eu  with varying connection graphs and exceptional costs are shown in table    we have
used the flight distances  km  between the cities as connection costs  instances tsp eu  tspeu  
have been generated by randomly choosing a given number of connections from all possible connections between the    cities  note that tsp eu   has no solution  the time reported here is until
dlvk terminated  and for all other instances until the first optimal plan was found 
we have also tested some instances of more practical relevance than simply randomly choosing
connections  tspeu   is an instance where we have taken the flight connections of three carriers
 namely  star alliance  alitalia  and luxair   and in tsp eu   we have included only direct connections of at most     km  such a capital hopping is of interest for a small airplane with limited
range  for instance 
for each instance in tables    we have measured the execution time 
 without exceptional costs 
 with     costs for all connections on saturdays and sundays  weekends  we 
 with     costs for all connections on fridays  saturdays and sundays  long weekends  lwe  
 for some random cost exceptions  rnd   we have added a number of randomly generated exceptions with costs between   and    for tsp austria and between   and      for the instances
eu  to eu  
  

fie iter   faber   l eone   p feifer   p olleres

instance
tspaustria
tspaustria exc
tspaustria we
tspaustria lwe
tspaustria rnd
tspaustria rnd
tspaustria rnd
tspaustria rnd

 cost exceptions
 
 
  
  
  
  
   
   

cost time
       s
       s
       s
       s
       s
       s
       s
       s

table    tsp  results for tspaustria with varying exceptions

instance
tspeu  
tspeu   we
tspeu   lwe
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu  
tspeu   we
tspeu   lwe
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu  
tspeu   we
tspeu   lwe
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu  
tspeu   we
tspeu   lwe
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu  
tspeu   we
tspeu   lwe
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu   rnd

 conn 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

 except 
 
  
  
   
   
   
   
 
  
  
   
   
   
   
 
  
   
   
   
   
   
 
  
   
   
   
   
   
 
  
   
   
   
   
   
   

cost time
      s
       s
       s
       s
       s
       s
       s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
            s
           s
           s
           s
           s
           s

instance
tspeu  
tspeu   we
tspeu   lwe
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu  
tspeu   we
tspeu   lwe
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu  
tspeu   we
tspeu   lwe
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu   rnd

 conn 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

 except 
 
  
   
   
   
   
   
   
 
   
   
   
   
   
   
   
   
   
 
   
   
   
   
   
   
   
   
   
   

cost time
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
          s
         s
         s
          s
         s
          s
          s
          s
          s
          s
           s

table    tsp  various instances for the capitals of the    eu members
  

fia nswer s et p lanning u nder action c osts

tsp  results instance tspeu   shows the limits of our system  the given data allows for many
possible tours  so finding an optimal one gets very tricky  on the other hand  a realistic instance like
tspeu   with real airline connections is solved rather quickly  which is not very surprising  most
airlines have a central airport  for instance vienna for austrian airlines  and few direct connections
between the destinations served  this allows for much fewer candidate answer sets  when  as in
reality  the number of airlines we consider is limited  e g   tsp eu   has no solution at all if only
two out of star alliance  alitalia  and luxair are allowed  of course  we cannot compete with
dedicated tsp solvers algorithms  which are able to solve much bigger tsp instances and have not
been considered here  however  to our knowledge  none of these solvers can deal with features such
as incomplete knowledge  defaults  time dependent exceptional costs  etc  directly  our results even
show that execution times are stable yet in case of many exceptions  in contrast  instance tsp eu  
shows that exceptions can also cause a significant speedup  this is due to the heuristics used by the
underlying dlv system  which can single out better solutions faster if costs are not spread evenly
like in tspeu   without exceptional costs 
note that  we have also experimented with the alternative smodels translation sketched in section      we refrain from detailed discussion here  since the  i  translation is optimized for dlv and
smodels performance was worse  around factor    for the tested tsp instances  than dlv and  ii 
there is no integrated planning frontend available for smodels providing a high level planning language  nevertheless  we have shown that our approach can  with minor modifications  be adopted
in a planning system based on smodels 

   related work
in the last years  it has been widely recognized that plan length alone is only one criterion to be
optimized in planning  several attempts have been made to extend planners to also consider action
costs 
the pyrrhus system  williams   hanks        is an extension of ucpop planning which
allows for optimal planning with resources and durations  domain dependent knowledge can be
added to direct the heuristic search  a utility model has to be defined for a planning problem
which can be used to express an optimization function  this system supports a language extension
of adl  pednault         which is a predecessor of pddl  ghallab et al          the algorithm is
a synthesis of branch and bound optimization with a least commitment  plan space planner 
other approaches based on heuristic search include the use of an a  strategy together with
action costs in the heuristics  ephrati  pollack    mihlstein        and work by refanidis and
vlahavas who use multi criteria heuristics to obtain near optimal plans  considering multiple criteria
apart from plan length alone  refanidis   vlahavas         however  the described heuristics is not
fully admissible  and only guarantees optimal plans under certain restrictions  haslum   geffner 
       in fact  most heuristic state space planners are not able to guarantee optimality 
a powerful approach has been suggested by nareyek  who describes planning with resources
as a structural constraint satisfaction problem  scsp   and then solves that problem by local search
combined with global control  however  this work promotes the inclusion of domain dependent
knowledge  the general problem has an unlimited search space  and no declarative high level language is provided  nareyek        
among other related approaches  kautz and walser generalize the planning as satisfiability
approach to use integer optimization techniques for encoding optimal planning under resource pro  

fie iter   faber   l eone   p feifer   p olleres

duction consumption  kautz   walser         first  they recall that integer logic programming
generalizes sat  as a sat formula can be translated to a system of inequalities  second  they extend effects and preconditions of actions similar to a strips extension proposed by koehler for
modeling resource consumption production  koehler         kautz and walser allow for arbitrary
optimization functions but they use a non declarative  low level representation based on the algebraic modeling language ampl  fourer  gay    kernighan         they mention that koehlers
strips like formalization can be mapped to their approach  however  they can not express nondeterminism or incomplete knowledge  there is an implementation of this approach called ilpplan  which uses the ampl package  http   www ampl com    unfortunately  ampl is
not freely available  so we could not compare the system with our approach experimentally 
lee and lifschitz describe the extension c  of the action language c which allows for an intuitive encoding of resources and costs by means of so called additive fluents  lee   lifschitz 
       this way admissible planning can be realized  but optimization has not been considered in
that framework so far  an implementation of a planner based on this language is ccalc  mccain 
      which has already been described in the previous section  another implementation of a planning system based on the action language c is cplan  giunchiglia        ferraris   giunchiglia 
       the cplan system mainly focuses on conformant planning and does not support the advanced
features of c   furthermore  the code is no longer maintained 
son and pontelli propose to translate action language b to prioritized default theory and answer
set programming  they allow to express preferences between actions and rules at the object level
in an interpreter but not as a part of the input language  son   pontelli         however  these
preferences are orthogonal to our approach as they model qualitative preferences as opposed to our
overall value function of plans trajectories 

   conclusion and outlook
this work continues a research stream which pursues the usage of answer set programming for
building planning systems which offer declarative planning languages based on action languages 
where planning tasks are specified at a high level of abstraction  lifschitz      a      b   for
representation of practical planning problems  such languages must have high expressiveness and
provide convenient constructs and language elements 
towards this goal  we have presented the planning language k c   which extends the declarative
planning language k  eiter et al       b      a  by action costs which are taken into account for
generating optimal plans  i e   plans that have least total execution cost  and for admissible plans
wrt  a given cost bound  i e   plans whose total execution cost stays within a given limit  as a basis
for implementation issues  we have investigated the computational complexity of the major planning tasks in this language  where we have derived complexity results sharply characterizing their
computational cost  furthermore  we have presented a transformation of optimal and admissible
planning problems in k c to logic programming under the optimal answer set semantics  buccafurri
et al                and we have described the dlv k prototype implemented on top of the kr tool
dlv  which computes this semantics 
as we have shown  kc allows for the representation of intricate planning problems  in particular 
we have demonstrated this for a variant of the traveling salesperson problem  tsp   which could
be conveniently specified in kc   a strength of kc is that  via the underlying language k  states of
knowledge  i e   incomplete states  can be suitably respected in secure plans  i e   conformant plans
  

fia nswer s et p lanning u nder action c osts

which work under all circumstances  including nondeterministic action effects  k c is a flexible
language which  by exploiting time dependent action costs  allows for the representation of planning
under various optimality criteria such as cheapest plans  shortest plans  and combinations thereof 
our experiments have shown that various instances of the problems we considered  including
realistic instances of the tsp variant  could be decently solved  on the other hand  the current
version of dlvk does not scale to large problem instances in general  and  unsurprisingly  can not
compete with high end planning tools or specialized algorithms for a particular problem such as
tsp  we do not see this as a shortcoming  though  since our main goal at this point was to demonstrate the usefulness of the expressive capabilities of our formalism to easily represent non trivial
planning and optimization tasks  which are especially involved from the viewpoint of knowledge
representation  in this way  non trivial instances of such problems of medium size  which one may
often encounter  can be solved with little effort 
several issues remain for further work  as for the implementation  performance improvements
may be gained via improvements of the underlying dlv engine  which are subject of current work 
furthermore  alternative  more efficient transformations of kc to logic programming might be researched  e g  ones that involve preprocessing of the planning problem performing means end analysis to simplify the logic program constructed 
another issue is further language extensions  for example  a crucial difference between our
approach and resource based approaches is that the former hinges on action costs  while the latter
build on fluent values  which is a somewhat different view of the quality of a plan  a possible way to
encompass this in our language is to allow that dynamic fluent values contribute to action costs  this
needs to be carefully elaborated  though  while for deterministic planning under complete knowledge this extension is straightforward  in non deterministic domains with incomplete knowledge it
would possibly result in ambiguities  different trajectories of the same plan possibly yield different
costs when fluent values contribute to action costs  in favor of an intuitive definition of plan costs
and optimality we refrained from this extension at the current state 
a further possible extension are negative action costs  which are useful for modeling producer consumer relations among actions and resources  allowing for different priorities among
actions  i e   different cost levels  would increase the flexibility and allow for optimizing different
criteria at once  finally  the duration of actions is an important issue  in the current language  the
effects of actions are assumed to materialize in the next state  while by coding techniques  we
may express delayed effects over several states in time and or interleaving actions  constructs in the
language would be desirable  investigating these issues is part of our ongoing and future work 

acknowledgments
we are are grateful to joohyung lee for his help on using ccalc and to paul walser for his useful
informations on ilpplan  furthermore  we thank michael gelfond for interesting discussions and
suggestions  and the anonymous reviewers for their detailed and helpful comments 
this work was supported by fwf  austrian science funds  under the projects p      and
z   n   and the european commission under project fet            wasp and ist           infomix 
a preliminary  shorter version of this paper was presented at the  th european conference on
logics in artificial intelligence  jelia     cosenza  italy  september      
  

fie iter   faber   l eone   p feifer   p olleres

appendix a  the language k
this appendix contains  in shortened form  the definition of the language k and a translation of k
to answer set programs  see  eiter et al       b      a  for more details and examples 
a   basic syntax
we assume  act    f l   and  typ disjoint sets of action  fluent and type names  respectively  i e  
predicate symbols of arity     and disjoint sets  con and  var of constant and variable symbols 
here   f l    act describe dynamic knowledge and  typ describes static background knowledge  an
action  resp  fluent  type  atom is of form p t             tn    where p   act  resp   f l    typ   has arity n
and t            tn   con   var   an action  resp  fluent  type  literal l is an action  resp  fluent  type 
atom a or its negation a  where   alternatively    is the true negation symbol  we define
 l   a if l   a and  l   a if l   a  where a is an atom  a set l of literals is consistent  if
l   l     furthermore  l   resp  l   is the set of positive  resp  negative  literals in l  the
set of all action  resp  fluent  type  literals is denoted as l act  resp  lf l   ltyp    furthermore  lf l typ
 
  lf l  ltyp   ldyn   lf l  l 
act   and l   lf l typ  lact  
all actions and fluents must be declared using statements as follows 
definition a    action  fluent declaration  an action  resp  fluent  declaration  is of the form 
p x            xn   requires t            tm

   

 
var where n    is the arity of p  t           t 
where p  l 
 
m
act  resp  p  lf l    x            xn  
ltyp   m     and every xi occurs in t            tm  

if m      the keyword requires may be omitted  causation rules specify dependencies of
fluents on other fluents and actions 
definition a    causation rule  a causation rule  rule  for short  is an expression of the form
caused f if b            bk   not bk             not bl after a            am   not am             not an

   

where f  lf l  false   b            bl  lf l typ   a            an l  l  k     and n  m    
rules where n     are static rules  all others dynamic rules  when l      resp  n       if  resp 
after  is omitted  if both l   n      caused is optional 
we access parts of a causation rule r by h r     f    post    r     b            bk    post  r   
 bk             bl    pre   r     a            am    pre  r     am             an    and lit r     f  b            bl  
a            an    intuitively  pre r    pre    r   pre  r   resp  post r    post   r   post  r  
accesses the state before  resp  after  some action s  happen 
special static rules may be specified for the initial states 
definition a    initial state constraint  an initial state constraint is a static rule of the form    
preceded by initially 
the language k allows conditional execution of actions  where several alternative executability
conditions may be specified 
  

fia nswer s et p lanning u nder action c osts

definition a    executability condition  an executability condition e is an expression of the form
executable a if b            bk   not bk             not bl

    

where a  l 
act and b            bl  l  and l  k    
if l      i e   executability is unconditional   if is skipped  the parts of e are accessed by h e   
 a   pre   e     b            bk    pre  e     bk             bl    and lit e     a  b            bl    intuitively 
pre e    pre   e   pre  e  refers to the state at which some actions suitability is evaluated  the
state after action execution is not involved  for convenience  we define post   e    post  e     
all causal rules and executability conditions must satisfy the following condition  which is
similar to safety in logic programs  each variable in a default negated type literal must also occur in
some literal which is not a default negated type literal  no safety is requested for variables appearing
in other literals  the reason is that variables appearing in fluent and action literals are implicitly safe
by the respective type declarations 
notation  for any causal rule  initial state constraint  and executability condition r and    post  pre  b  
we define  r       r      r   where bs  r    posts  r   pres  r  
a     p lanning d omains

and

p lanning p roblems

definition a    action description  planning domain  an action description hd  ri consists of a
finite set d of action and fluent declarations and a finite set r of safe causation rules  safe initial
state constraints  and safe executability conditions which do not contain positive cyclic dependencies among actions  a k planning domain is a pair pd   h  adi  where  is a disjunction free
normal datalog program  the background knowledge  which is safe and has a total well founded
model  cf   van gelder  ross    schlipf           and ad is an action description  we call pd
positive  if no default negation occurs in ad 
definition a    planning problem  a planning problem p   hpd  qi is a pair of a planning domain pd and a query q  i e  
g            gm   not gm             not gn    i 

    

where g            gn  lf l are variable free  n  m     and i    denotes the plan length 
a   semantics
we start with the preliminary definition of the typed instantiation of a planning domain  this is
similar to the grounding of a logic program  with the difference being that only correctly typed
fluent and action literals are generated 
let pd   h  hd  rii be a planning domain  and let m be the  unique  answer set of   gelfond   lifschitz         then   p x             xn    is a legal action  resp  fluent  instance of an action  resp  fluent  declaration d  d of the form      if  is a substitution defined over x            xn
such that   t              tm     m   by lpd we denote the set of all legal action and fluent instances  the instantiation of a planning domain respecting type information is as follows 
   a total well founded model  if existing  corresponds to the unique answer set of a datalog program  allowing for
multiple answer sets of  would eventually lead to ambiguities in our language 

  

fie iter   faber   l eone   p feifer   p olleres

definition a    typed instantiation  for any planning domain pd   h  hd  rii  its typed instantiation is given by pd   h  hd  rii  where  is the grounding of   over  con   and
r     r    r  r    r    where r is the set of all substitutions  of the variables in r using
 con   such that lit  r    ldyn  lpd    lpd  l
f l   
in other words  in pd we replace  and r by their ground versions  but keep of the latter only
rules where the atoms of all fluent and action literals agree with their declarations  we say that a
pd   h  hd  rii is ground  if  and r are ground  and moreover that it is well typed  if pd and
pd coincide 
a     s tates

and

t ransitions

definition a    state  state transition  a state w r t a planning domain pd is any consistent set
s  lf l   lit pd   lit pd    of legal fluent instances and their negations  a state transition
is any tuple t   hs  a  s  i where s  s  are states and a  lact  lit pd  is a set of legal action
instances in pd 
observe that a state does not necessarily contain either f or f for each legal instance f of a
fluent  and may even be empty  s      state transitions are not constrained  this will be done in the
definition of legal state transitions below  we proceed in analogy to the definition of answer sets
 gelfond   lifschitz         considering first positive  i e   involving a positive planning domain 
and then general planning problems 
in what follows  we assume that pd   h  hd  rii is a well typed ground planning domain
and that m is the unique answer set of   for any other pd  the respective concepts are defined
through its typed grounding pd 
definition a    legal initial state  a state s   is a legal initial state for a positive pd  if s   is the
least set  w r t    such that post c   s    m implies h c   s    for all initial state constraints
and static rules c  r 
for a positive pd and a state s  a set a  l  
act is called executable action set w r t  s  if for each
a  a there exists an executability condition e  r such that h e     a   pre    e lf l typ  sm  
 

pre   e l 
act  a  and pre  e  lact sm       note that this definition allows for modeling
dependent actions  i e  actions which depend on the execution of other actions 
definition a     legal state transition  given a positive pd  a state transition t   hs  a  s   i is
called legal  if a is an executable action set w r t  s and s   is the minimal consistent set that satisfies
all causation rules w r t  s  a  m   that is  for every causation rule r  r  if  i  post r   s    m  
 ii  pre r   lf l typ  s  m   and  iii  pre r   lact  a all hold  then h r      false  and
h r   s   
this is now extended to general a well typed ground pd containing default negation using a
gelfond lifschitz type reduction to a positive planning domain  gelfond   lifschitz        
definition a     reduction  let pd be a ground and well typed planning domain  and let t  
hs  a  s  i be a state transition  then  the reduction pd t   h  hd  rt ii of pd by t is the planning
domain where rt is obtained from r by deleting
  

fia nswer s et p lanning u nder action c osts

   each r  r  where either post  r  s   m       or pre  r  sam        and
   all default literals not l  l  l  from the remaining r  r 
note that pd t is positive and ground  we extend further definitions as follows 
definition a     legal initial state  executable action set  legal state transition  for any planning
domain pd  a state s  is a legal initial state  if s  is a legal initial state for pd h  s  i   a set a is an
executable action set w r t  a state s  if a is executable w r t  s in pd hs a i   and  a state transition
t   hs  a  s  i is legal  if it is legal in pd t  
a     p lans
definition a     trajectory  a sequence of state transitions t   hhs     a    s  i  hs    a    s  i        
hsn    an   sn ii  n     is a trajectory for pd  if s  is a legal initial state of pd and all hs i    ai   si i 
   i  n  are legal state transitions of pd 
if n      then t   hi is empty and has s  associated explicitly 
definition a     optimistic plan  a sequence of action sets ha             ai i  i     is an optimistic
plan for a planning problem p   hpd  qi  if a trajectory t   hhs     a    s  i  hs    a    s  i         
hsi    ai   si ii exists in pd which accomplishes the goal  i e    g           gm    si and  gm             gn  
si    
optimistic plans amount to plans  valid plans etc as defined in the literature  the term
optimistic should stress the credulous view in this definition  with respect to incomplete fluent
information and nondeterministic action effects  in such cases  the execution of an optimistic plan
p might fail to reach the goal  we thus resort to secure plans 
definition a     secure plans  alias conformant plans   an optimistic plan ha             an i is a secure plan  if for every legal initial state s   and trajectory t   hhs    a    s  i          hsj    aj   sj ii such
that    j  n  it holds that  i  if j   n then t accomplishes the goal  and  ii  if j   n  then a j  
is executable in sj w r t  pd  i e   some legal transition hs j   aj     sj   i exists 
note that plans admit in general the concurrent execution of actions  we call a plan ha             an i
sequential  or non concurrent   if  a j       for all    j  n 
a   macros
k includes several macros as shorthands for frequently used concepts  let a  l  
act denote an
action atom  f  lf l a fluent literal  b a  possibly empty  sequence b             bk   not bk            
not bl where each bi  lf l typ   i              l  and a a  possibly empty  sequence a             am  
not am             not an where each aj  l  j              n 
inertia to allow for an easy representation of fluent inertia  k provides
inertial f if b after a 

defaults



caused f if not  f  b after f  a 

a default value of a fluent can be expressed by the shortcut
default f 



caused f if not  f 

it is in effect unless some other causation rule provides evidence to the opposite value 
  

fie iter   faber   l eone   p feifer   p olleres

totality

for reasoning under incomplete  but total knowledge k provides  f positive  
total f if b after a 



caused f if not f  b after a 
caused f if not f  b after a 

this is is for instance useful to model non deterministic action effects  for a discussion of the
full impact of this statement in modeling planning under incomplete knowledge and non determinism 
we refer to our previous paper on the language k  eiter et al       b  
state integrity

for integrity constraints that refer to the preceding state  k provides
forbidden b after a 

non executability



caused false if b after a 

for specifying that some action is not executable  k provides

nonexecutable a if b 



caused false after a  b 

by this definition  nonexecutable overrides executable in case of conflicts 
sequential plans to exclude simultaneous execution of actions  k provides
noconcurrency 



caused false after a    a   

where a  and a  range over all possible actions such that a     a   lpd  lact and a     a   
in all macros  if b  resp  after a  can be omitted  if b  resp  a  is empty 

appendix b  proofs
proof of theorem      membership  i   the problems are in np resp  npmv  since if l is polynomial in the size of p  any optimistic plan p   ha             al i for p with a supporting trajectory
t   ht            ti i for p can be guessed and  by proposition      verified in polynomial time  furthermore  costp  p    b can be efficiently checked  since costp  p   is easily computed  all costs
are constants  
hardness  i   k is a fragment of k c   and each k planning problem can be viewed as the problem
of deciding the existence of resp  finding an admissible plan wrt  cost    as was previously shown
 eiter et al       b   deciding existence of an optimistic plan for a given k planning problem is
np hard for fixed plan length l  hence  it is also np hard for kc  
we show that finding an optimistic plan is hard for npmv by a reduction from the well known
sat problem  cf   papadimitriou         whose instances are cnfs    c     ck of clauses ci  
li        li mi   where each li j is a classical literal over propositional atoms x    x             xn   
consider the following planning domain pd  for  
fluents  
actions  

x          xn   state   state  
c  costs          ck costs   
ax          axn  
initially   total x          total xn  
caused state  
always  
caused state  after state  
executable c  after  l               l  m   
forbidden after  l               l  m    not c   

executable ck after  lk              lk mk  
forbidden after  lk              lk mk   not ck  
executable ax  after x    forbidden after x    not ax   

executable axn after xn   forbidden after xn   not axn  

  

fia nswer s et p lanning u nder action c osts

the fluents xi and state  and the total statements in the initially section encode the candidate truth assignments  the subsequent statements force c j to be executed iff the corresponding
clause is violated by the truth assignment encoded in the initial state  the final pairs of executable
and forbidden statements force actions ax i to be executed iff the corresponding fluents x i hold 
this is because it is necessary to directly extract the computed truth assignments from the plan 
since we are dealing with a function class  the fluent state  identifies the state at time   
consider now the planning problem p    hpd   state     i  clearly  each optimistic plan
p for p corresponds to a truth assignment  p of x and vice versa  and costp  p   is the number
of clauses violated by p   thus  the admissible optimistic plans for p  wrt  cost   correspond    
to the satisfying assignments of   clearly  constructing p  from  is efficiently possible  as is
constructing a satisfying truth assignment  from a corresponding plan p  because of the actions
axi    this concludes the hardness proof 
membership  ii   since the security of each optimistic plan admissible wrt  cost k can be checked 
by proposition      with a call to a  p   oracle  membership in p  resp  in p  mv follows by
analogous considerations as in  i   where no oracle was needed  
hardness  ii   for the decision variant   p   hardness is again immediately inherited from the  p  completeness of deciding the existence of a secure plan of a problem in the language k  with
hardness even for fixed plan length  eiter et al       b   for the plan computation variant  we give
a reduction from the following p  mv complete problem  an instance i is an open qbf
q z    xy  x  y  z 
where x   x            xl   y   y            ym   and z   z            zn   respectively  and  x  y  z  is
 w l o g   a  cnf formula over x  y   and z  the solutions s i  are all truth assignments over z
for which q z  is satisfied 
suppose that  x  y  z    c        ck where ci   ci   ci   ci     now consider the following
planning domain pdq z  for q z   which is a variant of the planning domain given in the proof of
theorem     in  eiter et al       b  
fluents  
x          xl   y          ym   z          zn   state   state  
actions  
az  costs          azn costs   
initially   total x          total xl  
caused state  
always  
caused state  after state  
executable az    executable az          executable azn  
caused x  after x    caused  x  after  x   

caused xl after xl   caused  xl after  xl  
total y  after state         total ym after state  
caused z  after az    caused  z  after not az   

caused zn after azn   caused  zn after not azn  
forbidden  c       c       c    after state  

forbidden  ck      ck      ck   after state  
 x 

there are   x  many legal initial states s            s  for pdq z    which correspond     to the
possible truth assignments to x and all these initial states contain state   starting from any initial
state si   executing a set of actions represents a truth assignment to the variables in z  since all
  

fie iter   faber   l eone   p feifer   p olleres

actions are always executable  there are    z  executable action sets a            a  z    which represent
all truth assignments to z 
 y  
for each pair si and aj there exist   y   many successor state candidates si             si     which
contain fluents according to the truth assignment to x represented by s i   fluents according to the
truth assignment to z represented by a j   and fluents according to a truth assignment to y   and the
fluent state   of these candidate states  only those satisfying all clauses in  x  y  z  are legal 
by virtue of the forbidden statements 
it is not hard to see that an optimistic plan of form p   ha   i  where a    azi   zi  z   for
the goal state  exists wrt  pdq z  iff there is an assignment to all variables in x  y  z such
that the formula  x  y  z  is satisfied  furthermore  p is secure iff a  represents an assignment
to the variables in z such that  regardless of which assignment to the variables in x is chosen
 corresponding to a legal initial state s i    there is some assignment to the variables in y such that all
clauses of  x  y  z  are satisfied  i e   there is at least one state si k reachable from si by executing
a     any such si k contains state   in other words  p is secure iff  x  y  z  is true  thus  the
admissible secure plans of pdq z  wrt  cost    correspond     with the assignments to z for which
q z  is true 
since pdq z  is constructible from  x  y  z  in polynomial time  it follows that computing a
secure plan for p   hpdq z    qi  where q   state         is p  mv hard 
 
proof of theorem      membership  i   concerning membership  by performing a binary search
on the range     max   where max is an upper bound on the plan costs for a plan of polynomial
length l given by l times the sum of all action costs  we can find out the least integer v such that
any optimistic plan p for p which is admissible wrt  cost v exists  if any optimistic plan exists  
clearly  we have costp  p     v and costp   v  and thus any such plan p is optimal  since max
is single exponential in the representation size of p  the binary search  and thus computing cost p  
is  by theorem      feasible in polynomial time with an np oracle  subsequently  we can construct
an optimistic plan p such that costp  p     costp by extending a partial plan pi   ha            ai i 
i              l    step by step as follows  let a    a             am   be the set of all legal action
instances  we initialize bi      a and ask the oracle whether pi can be completed to an optimistic
plan p   ha            al i admissible wrt  costp such that ai     bi      a      if the answer is
yes  then we update bi      bi      a     else we leave bi   unchanged  we then repeat this test
for aj   j                 m  the resulting bi   is an action set such that pi     ha            ai   ai   i
where ai     bi   can be completed to an optimistic plan admissible wrt  cost p   thus  ai   is
polynomial time constructible with an np oracle 
in summary  we can construct an optimal optimistic plan in polynomial time with an np oracle 
thus  the problem is in fp   
hardness  i   we show hardness for plan length l     by a reduction from problem max weight
sat  papadimitriou         where an instance is a sat instance    c        ck as in the proof
of theorem      i   plus positive integer weightsp
w i   where i              k  then  s i  contains those
truth assignments  of x for which wsat      i   ci  true wi is maximal 
to that end  we take the planning domain pd  as in the proof of theorem     and modify the
cost of ci to wi   for i              k  thus constructing a new planning domain pd i   consider now the
planning problem pi   hpdi   state     i  since the actions cj are the only actions with nonzero
cost  any plan  corresponding top
a truth assignment   will be
p associated with the sum of weights
of violated clauses  wvio        ki   wi    wsat     since ki   wi is constant for i  minimizing
  

fia nswer s et p lanning u nder action c osts

wvio    is equivalent to maximizing wsat     hence  there is a one to one correspondence between
optimal optimistic plans of pi  for which wvio    is minimal  and maximal truth assignments for i 
furthermore  computing pi from i and extracting a max weight sat solution from an optimal
plan p is efficiently possible  this proves fp   hardness 
membership  ii   the proof is similar to the membership proof of  i   but uses an oracle which asks
for completion of a partial secure plan p i   ha            ai i to a secure plan p   ha            al i such
that ai     bi      aj    and p is admissible wrt  costp   rather than of a partial optimistic plan 
this oracle is  as easily seen  in p    thus  computing an optimal secure plan is in f p   
hardness  ii   we show hardness by a reduction from the following problem  which is f p  complete  cf   krentel          given an open qbf q z    xy  x  y  z  like in the proof
of theorem      ii   compute the lexicographically first truth assignment of z for which q z  is
satisfied 
this can be accomplished by changing the cost of each action az i in pdq z  from   to  ni  
i              n  let pd    q z   be the resulting planning domain  since the cost of az i  i e   assigning
zi the value true  is greater than the sum of the costs of all az j for i      j  n  an optimal
secure plan for the planning problem hpd    q z    state       i amounts to the lexicographically
first truth assignment for z such that q z  is satisfied  thus  fp   hardness of the problem follows 
 
proof of theorem      we prove the result by applying the well known splitting set theorem for
logic programs  lifschitz   turner         this theorem applies to logic programs  that can be
split into two parts such that one of them  the bottom part  does not refer to predicates defined in
the top part at all  the answer sets of the bottom part can then be extended to the answer sets
of the whole program by looking at the remaining  top  rules  informally  a splitting set of  is
a set u of ground literals defining the bottom part bu    of a program  each answer set sb of
bu    can then be used to reduce the remaining rules    b u    to a program eu     bu     sb  
involving only classical literals which do not occur in b u     by evaluating the literals from b u   
wrt  sb   for each answer set se of eu     bu     sb    the set s   sb  se then is an answer set of
the original program 
disregarding weak constraints  we can split the program lp w  p  into a bottom part consisting
of lp pnc    where pnc is p with the cost information stripped off  and a top part containing the
remaining rules  we then derive the correspondence between optimistic plans for p and answer sets
of lpw  p  from a similar correspondence result for lp p nc    eiter et al       a  
in detail  theorem     in  eiter et al       a  states for any k planning problem p a correspondence between the answer sets s of lp p  and supporting trajectories t of optimistic plans
p   ha            al i as in items  i  and  ii   with costs discarded  thus  any answer set s   of lp pnc  
corresponds to some trajectory t   of an optimistic plan p   for pnc and vice versa 
in what follows  when talking about lp p nc   and lpw  p   we mean the respective grounded
logic programs  lpw  p  augments lp pnc   by rules     and weak constraints      let now u  
lit lp pnc    be the set of all literals occurring in lp p nc    clearly  u splits lpw  p  as defined in
 lifschitz   turner         where we disregard weak constraints in lp w  p   since the rules of form
    introduce only new head literals  consequently  we get b u  lpw  p     lp pnc    then  for any
answer set s   of lp pnc    each rule in eu  lpw  p    bu  lpw  p    s     is of the form
costa  x            xn   t  c     body 
  

fie iter   faber   l eone   p feifer   p olleres

from the fact that all these rules are positive  we can conclude that with respect to the split by u  
any answer set s   of lp pnc   induces a unique answer set s  s   of lpw  p   therefore  modulo
costs  a correspondence between supporting trajectories t and candidate answer sets s as claimed
follows directly from theorem     in  eiter et al       a  
it remains to prove that costp  p     costlpw  p   s  holds for all candidate answer sets s corresponding to an optimistic plan p   ha             al i for p  by the correspondence shown above 
any action p x            xn    aj corresponds to exactly one atom p x             xn   j      asj  
j              l   therefore  if p x            xn   is declared with a non empty cost part  by     and
well definedness  modulo x            xn   there is exactly one fact costp  x            xn   j     c  in the
model of eu  lpw  p    bu  lpw  p    s  
furthermore  by definition of      we have that c   costj  p x            xn     i e   the cost of action
instance p x            xn   at time j  consequently 
pl the
p violation value of the weak constraint wc of
w
form     for p in lp  p  is costwc  s   
j  
p x       xn  aj costj  p x            xn     since all
violation values stem from weak constraints      in total we have cost lpw  p   s    costp  p    this
proves the result 
 

references
blum  a  l     furst  m  l          fast planning through planning graph analysis  artificial
intelligence             
bonet  b     geffner  h          planning with incomplete information as heuristic search in
belief space  in chien  s   kambhampati  s     knoblock  c  a   eds    proceedings of the
fifth international conference on artificial intelligence planning and scheduling  aips    
pp        breckenridge  colorado  usa 
bryant  r  e          graph based algorithms for boolean function manipulation  ieee transactions on computers  c               
buccafurri  f   leone  n     rullo  p          strong and weak constraints in disjunctive datalog 
in dix  j   furbach  u     nerode  a   eds    proceedings of the  th international conference
on logic programming and non monotonic reasoning  lpnmr     no       in lecture
notes in ai  lnai   pp       dagstuhl  germany  springer verlag 
buccafurri  f   leone  n     rullo  p          enhancing disjunctive datalog by constraints  ieee
transactions on knowledge and data engineering                
cimatti  a     roveri  m          conformant planning via symbolic model checking  journal of
artificial intelligence research             
dantsin  e   eiter  t   gottlob  g     voronkov  a          complexity and expressive power of
logic programming  acm computing surveys                
dimopoulos  y   nebel  b     koehler  j          encoding planning problems in nonmonotonic
logic programs  in proceedings of the european conference on planning       ecp     
pp          springer verlag 
eiter  t   faber  w   leone  n     pfeifer  g       a   declarative problem solving using the
dlv system  in minker  j   ed    logic based artificial intelligence  pp         kluwer
academic publishers 
  

fia nswer s et p lanning u nder action c osts

eiter  t   faber  w   leone  n   pfeifer  g     polleres  a       b   planning under incomplete
knowledge  in lloyd  j   dahl  v   furbach  u   kerber  m   lau  k  k   palamidessi  c  
pereira  l  m   sagiv  y     stuckey  p  j   eds    computational logic   cl       first international conference  proceedings  no       in lecture notes in ai  lnai   pp         
london  uk  springer verlag 
eiter  t   faber  w   leone  n   pfeifer  g     polleres  a       a   answer set planning under
action costs  in flesca  s   greco  s   ianni  g     leone  n   eds    proceedings of the
 th european conference on artificial intelligence  jelia   no       in lecture notes in
computer science  pp         
eiter  t   faber  w   leone  n   pfeifer  g     polleres  a       b   answer set planning under action costs  tech  rep  infsys rr             institut fur informationssysteme  technische
universitat wien 
eiter  t   faber  w   leone  n   pfeifer  g     polleres  a       a   a logic programming approach
to knowledge state planning  ii  the dlv k system  artificial intelligence              
    
eiter  t   faber  w   leone  n   pfeifer  g     polleres  a       b   a logic programming approach
to knowledge state planning  semantics and complexity  to appear in acm transactions
on computational logic 
ephrati  e   pollack  m  e     mihlstein  m          a cost directed planner  preliminary report 
in proceedings of the thirteenth national conference on artificial intelligence  aaai     
pp              aaai press 
erdem  e          applications of logic programming to planning  computational experiments 
unpublished draft  http   www cs utexas edu users esra papers html 
faber  w     pfeifer  g   since        dlv homepage   http   www dlvsystem com  
ferraris  p     giunchiglia  e          planning as satisfiability in nondeterministic domains  in
proceedings of the seventeenth national conference on artificial intelligence  aaai     july
    august          austin  texas usa  pp          aaai press   the mit press 
fourer  r   gay  d  m     kernighan  b  w          ampl  a modeling language for mathematical
programming  duxbury press 
gelfond  m     lifschitz  v          classical negation in logic programs and disjunctive
databases  new generation computing            
ghallab  m   howe  a   knoblock  c   mcdermott  d   ram  a   veloso  m   weld 
d     wilkins  d         
pddl  the planning domain definition language  tech  rep   yale center for computational vision and control  available at
http   www cs yale edu pub mcdermott software pddl tar gz 
giunchiglia  e          planning as satisfiability with expressive action languages  concurrency 
constraints and nondeterminism  in cohn  a  g   giunchiglia  f     selman  b   eds    proceedings of the seventh international conference on principles of knowledge representation
and reasoning  kr        april        breckenridge  colorado  usa  pp          morgan
kaufmann 
  

fie iter   faber   l eone   p feifer   p olleres

giunchiglia  e   kartha  g  n     lifschitz  v          representing action  indeterminacy and
ramifications  artificial intelligence             
giunchiglia  e     lifschitz  v          an action language based on causal explanation  preliminary report  in proceedings of the fifteenth national conference on artificial intelligence
 aaai      pp         
haslum  p     geffner  h          admissible heuristics for optimal planning  in chien  s   kambhampati  s     knoblock  c  a   eds    proceedings of the fifth international conference on
artificial intelligence planning and scheduling  aips     pp          breckenridge  colorado  usa  aaai press 
kautz  h     walser  j  p          state space planning by integer optimization  in proceedings of
the   th national conference on artificial intelligence  aaai      pp         
koehler  j          planning under resource constraints  in proceedings of the   th european
conference on artificial intelligence  ecai     pp         
krentel  m          generalizations of opt p to the polynomial hierarchy  theoretical computer
science                
lee  j     lifschitz  v          additive fluents  in provetti  a     cao  s  t   eds    proceedings
aaai      spring symposium on answer set programming  towards efficient and scalable
knowledge representation and reasoning  pp          stanford  ca  aaai press 
lifschitz  v     turner  h          splitting a logic program  in van hentenryck  p   ed    proceedings of the   th international conference on logic programming  iclp     pp       
santa margherita ligure  italy  mit press 
lifschitz  v     turner  h          representing transition systems by logic programs  in gelfond 
m   leone  n     pfeifer  g   eds    proceedings of the  th international conference on logic
programming and nonmonotonic reasoning  lpnmr     no       in lecture notes in ai
 lnai   pp         el paso  texas  usa  springer verlag 
lifschitz  v          foundations of logic programming  in brewka  g   ed    principles of knowledge representation  pp         csli publications  stanford 
lifschitz  v       a   action languages  answer sets and planning  in apt  k   marek  v  w  
truszczynski  m     warren  d  s   eds    the logic programming paradigm  a    year
perspective  pp          springer verlag 
lifschitz  v       b   answer set planning  in schreye  d  d   ed    proceedings of the   th
international conference on logic programming  iclp     pp        las cruces  new
mexico  usa  the mit press 
mccain  n          the causal calculator homepage   http   www cs utexas edu 
users tag cc  
mccain  n     turner  h          causal theories of actions and change  in proceedings of the
  th national conference on artificial intelligence  aaai      pp         
mccain  n     turner  h          satisfiability planning with causal theories  in cohn  a  g  
schubert  l     shapiro  s  c   eds    proceedings sixth international conference on principles of knowledge representation and reasoning  kr     pp          morgan kaufmann
publishers 
  

fia nswer s et p lanning u nder action c osts

moskewicz  m  w   madigan  c  f   zhao  y   zhang  l     malik  s          chaff  engineering an
efficient sat solver  in proceedings of the   th design automation conference  dac      
las vegas  nv  usa  june              pp          acm 
nareyek  a          beyond the plan length criterion  in local search for planning and scheduling  ecai      workshop  vol       of lecture notes in computer science  pp       
springer 
niemela  i          logic programs with stable model semantics as a constraint programming
paradigm  in niemela  i     schaub  t   eds    proceedings of the workshop on computational aspects of nonmonotonic reasoning  pp        trento  italy 
papadimitriou  c  h          computational complexity  addison wesley 
pednault  e  p  d          exploring the middle ground between strips and the situation calculus  in proceedings of the  st international conference on principles of knowledge representation and reasoning  kr     pp          toronto  canada  morgan kaufmann publishers 
inc 
refanidis  i     vlahavas  i          a framework for multi criteria plan evaluation in heuristic
state space planning  in ijcai    workshop on planning with resources 
selman  a  l          a taxonomy of complexity classes of functions  journal of computer and
system sciences                
simons  p   niemela  i     soininen  t          extending and implementing the stable model
semantics  artificial intelligence              
smith  d  e     weld  d  s          conformant graphplan  in proceedings of the fifteenth
national conference on artificial intelligence   aaai     pp          aaai press   the
mit press 
son  t  c     pontelli  e          reasoning about actions in prioritized default theory  in flesca 
s   greco  s   ianni  g     leone  n   eds    proceedings of the  th european conference on
artificial intelligence  jelia   no       in lecture notes in computer science  pp         
subrahmanian  v     zaniolo  c          relating stable models and ai planning domains  in
sterling  l   ed    proceedings of the    th international conference on logic programming 
pp          tokyo  japan  mit press 
van gelder  a   ross  k     schlipf  j          the well founded semantics for general logic
programs  journal of the acm                
weld  d  s   anderson  c  r     smith  d  e          extending graphplan to handle uncertainty
  sensing actions  in proceedings of the fifteenth national conference on artificial intelligence   aaai     pp          aaai press   the mit press 
williams  m     hanks  s          optimal planning with a goal directed utility model  in
hammond  k  j   ed    proceedings of the second international conference on artificial intelligence planning systems  aips      pp          aaai press 

  

fi