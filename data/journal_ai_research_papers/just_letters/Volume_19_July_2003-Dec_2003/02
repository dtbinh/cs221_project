journal artificial intelligence research                

submitted        published      

answer set planning action costs
thomas eiter
wolfgang faber

eiter   kr   tuwien   ac  
faber   kr   tuwien   ac  

institut fur informationssysteme  tu wien
favoritenstr        a      wien  austria

nicola leone

leone   unical  

department mathematics  university calabria
i       rende  cs   italy

gerald pfeifer
axel polleres

pfeifer   dbai   tuwien   ac  
polleres   kr   tuwien   ac  

institut fur informationssysteme  tu wien
favoritenstr        a      wien  austria

abstract
recently  planning based answer set programming proposed approach towards realizing declarative planning systems  paper  present language k c  
extends declarative planning language k action costs  k c provides notion admissible optimal plans  plans whose overall action costs within given limit resp 
minimum plans  i e   cheapest plans   demonstrate  novel language allows
expressing nontrivial planning tasks declarative way  furthermore  utilized
representing planning problems optimality criteria  computing shortest plans
 with least number steps   refinement combinations cheapest fastest plans 
study complexity aspects language k c provide transformation logic programs 
planning problems solved via answer set programming  furthermore  report experimental results selected problems  experience encouraging answer set planning may
valuable approach expressive planning systems intricate planning problems
naturally specified solved 

   introduction
recently  several declarative planning languages formalisms introduced  allow
intuitive encoding complex planning problems involving ramifications  incomplete information  non deterministic action effects  parallel actions  see e g   giunchiglia   lifschitz       
lifschitz      b  lifschitz   turner        mccain   turner        giunchiglia        cimatti  
roveri        eiter et al       b      b  
systems designed generate plans accomplish planning goals 
practice one often interested particular plans optimal respect objective
function quality  or cost  plan measured  common simple objective
function length plan  i e   number time steps achieve goal  many systems
tailored compute shortest plans  example  cmbp  cimatti   roveri        gpt
 bonet   geffner        compute shortest plans step consists single action 
graphplan algorithm  blum   furst        descendants  smith   weld        weld 
c
    
ai access foundation morgan kaufmann publishers  rights reserved 

fie iter   faber   l eone   p feifer   p olleres

anderson    smith        compute shortest plans step actions might executed
parallel 
however  other  equally important objective functions consider  particular 
executing actions causes cost  may desire plan minimizes overall cost
actions 
answer set planning  subrahmanian   zaniolo        dimopoulos  nebel    koehler       
niemela        lifschitz      b   recent declarative approach planning plans encoded answer sets logic program  issue optimal plans objective value
function addressed detail far  see section   details   paper 
address issue present extension planning language k  eiter et al       b      b  
user may associate costs actions  taken account planning
process  main contributions work follows 
define syntax semantics planning language kc   modularly extends
language k  costs associated action extending action declarations
optional cost construct describes cost executing respective action 
action costs static dynamic  may depend current stage plan
action considered execution  dynamic action costs important
natural applications  show simple variant well known traveling salesperson
problem  cumbersome model solve other  similar languages 
analyze computational complexity planning language k c   provide completeness results major planning tasks propositional setting  locate
suitable slots polynomial hierarchy classes derived it  results provide insight intrinsic computational difficulties respective planning problems 
give handle efficient transformations optimal planning knowledge representation formalisms  particular logic programs 
show  awareness results complexity analysis  planning action
costs implemented transformation answer set programming  done system prototype developed  prototype  ready experiments  available
http   www dlvsystem com k  
finally  present applications show extended language capable
easily modeling optimal planning various criteria  computing     cheapest plans
 which minimize overall action costs       shortest plans  with least number steps  
and  refinement combinations these  viz      shortest plans among cheapest     
cheapest plans among shortest  notice that  knowledge  task    
addressed works far 
extension k action costs provides flexible expressive tool representing
various problems  moreover  since ks semantics builds states knowledge rather
states world  deal incomplete knowledge plan quality  is 
best knowledge  completely novel 
experience encouraging answer set planning  based powerful logic programming
engines  allows development declarative planning systems intricate planning
  

fia nswer et p lanning u nder action c osts

tasks specified solved  work complements extends preliminary results
presented previous work  eiter et al       a  
remainder paper organized follows  next section  briefly review
language k informally presenting main constituents features simple planning
example  that  define section   extension k action costs  consider
first examples usage kc   section   devoted analysis complexity issues 
section    consider applications k c   show various types particular optimization
problems expressed k c   consider practical examples  section   
present transformation k c answer set programming  section    report
prototype implementation experiments  discussion related work section   
conclude paper outlook ongoing future work 

   short review language k
section  give brief informal overview language k  refer  eiter et al       b 
appendix formal details  assume reader familiar basic ideas
planning action languages  particular notions actions  fluents  goals plans 
illustration  shall use following planning problem running example 
problem    bridge crossing problem  four persons want cross river night plank
bridge  hold two persons time  lamp  must used
crossing  pitch dark planks missing  someone must bring lamp back
others  tricks  like throwing lamp halfway crosses  etc   allowed 
fluents states  state k characterized truth values fluents  describing relevant
properties domain discourse  fluent may true  false  unknown state is 
states k states knowledge  opposed states world fluent either true
false  which easily enforced k  desired   formally  state consistent set
 possibly negated  legal fluent instances 
action applicable precondition  a list literals fluents  holds
current state  execution may cause modification truth values fluents 
background knowledge  static knowledge invariant time k planning domain
specified normal  disjunction free  datalog program single answer set
viewed set facts  example  background knowledge specifies four persons 
person joe   person jack   person william   person averell  

type declarations  fluent action must declaration ranges arguments specified  instance 
crosstogether x  y  requires person x   person y   x   y   

specifies arguments action crosstogether  two persons cross bridge together 

across x  requires person x  
     used instead inequality avoid symmetric rules 

  

fie iter   faber   l eone   p feifer   p olleres

specifies fluent describing specific person side river  literals
requires must classical literals static background knowledge  like person x 
person y    literals built in predicates  such x   y   implementation k  dlv k system  eiter  faber  leone  pfeifer    polleres      a   currently supports built in predicates
  b     b     b obvious meaning less than  less or equal inequality
strings numbers  arithmetic built ins   b   c   b c stand integer
addition multiplication  predicate  int x  enumerates integers  up
user defined limit  
causation rules  causation rules  rules brevity  syntactically similar rules
action language c  giunchiglia   lifschitz        lifschitz      a  lifschitz   turner       
basic form 
caused f b a 

conjunction fluent action literals  possibly including default negation  b
conjunction fluent literals  possibly including default negation  f fluent literal 
informally  rule reads  b known true current state known true
previous state  f known true current state well  if part
after part allowed empty  which means true   causation rule called
dynamic  after part empty  called static otherwise 
causation rules used express effects actions ramifications  example 
caused across x  cross x    across x  
caused  across x  cross x   across x  

describe effects single person crossing bridge either direction 
initial state constraints  static rules apply states initial states  which
may unique   expressed keywords always   initially   preceding
sequences rules latter describes initial state constraints must satisfied
initial state  example 
initially   caused  across x  

enforces fluent across false initial state x satisfying declaration
fluent across  i e   persons  rule irrelevant subsequent states 
executability actions 

expressed k explicitly  instance 

executable crosstogether x  y  haslamp x  
executable crosstogether x  y  haslamp y  

declares two persons jointly cross bridge one lamp  action
may multiple executability statements  statement
executable cross x  

empty body says cross always executable  provided type restrictions x
respected  dually 
nonexecutable b 

prohibits execution action condition b satisfied  example 
nonexecutable crosstogether x  y  differentsides x  y  

  

fia nswer et p lanning u nder action c osts

says persons x cross bridge together different sides bridge 
case conflicts  nonexecutable overrides executable a 
default strong negation  k supports strong negation    written     note  however  fluent f  state neither f  f needs hold  case knowledge
f incomplete  addition  weak negation  not   interpreted default negation answer set
semantics  gelfond   lifschitz         permitted rule bodies  allows natural modeling inertia default properties  well dealing incomplete knowledge general 
example 
caused haslamp joe  haslamp jack   haslamp william   haslamp averell  

expresses conclusion default  joe lamp  whenever evident
persons it 
macros 

k provides number macros syntactic sugar  example 

inertial across x  

informally states across x  holds current state  across x  held previous state 
unless  across x  explicitly known hold  macro expands rule
caused across x   across x  across x  

moreover  totalize knowledge fluent declaring total f  shortcut
caused f  f 

caused  f f 

intuitive meaning rules unless truth value f derived  cases
f resp   f true considered 
planning domains problems  k  planning domain pd   h  hd  rii background
knowledge   action fluent declarations d  rules executability conditions r  planning
problem p   hpd  qi planning domain pd query
q   g            gm   gm             gn    l 
g            gn ground fluents l   plan length  instance  goal query
across joe   across jack   across william   across averell      

asks plans bring four persons across   steps 
plans defined using transition based semantics  execution set actions
transforms current state new state   optimistic  plan p sequence p   ha             al
sets action instances a    a            al trajectory   hhs    a    s  i  hs    a    s  i         
hsl    al   sl ii legal initial state s  state sl literals goal true 
is  starting s    legal transition t    hs    a    s  i  modeling execution actions  
 which must executable   transforms   state s    followed legal transitions
ti   hsi    ai   si i                  l  cf  appendix details   plan sequential   a    
             l  i e   step consists one action  plans enforced
including keyword noconcurrency 
besides optimistic plans  k support stronger secure  or conformant  plans  secure
plan must guaranteed work circumstances  eiter et al       b   regardless
incomplete information initial state possible nondeterminism action effects 
  

fie iter   faber   l eone   p feifer   p olleres

better readability  following always describe k planning problems p
strictly terms sets declarations  rules executability conditions  optionally use
compact representation k programs following general form 
fluents  
actions  
initially  
always  
goal  

fd
ad
ir
cr
q

 optional  sections fluents always consist lists fluent declarations f  
action declarations ad   initial state constraints ir executability conditions causation rules
cr   respectively  together background knowledge goal query q  specify
k planning problem p   hh  hd  rii  qi  given f plus ad r ir plus
cr    
    solving bridge crossing problem
using constructs  k encoding bridge crossing problem  assuming joe
initially carries lamp  shown figure    simple five step plans  l      
joe always carries lamp brings others across  one is 
p   h  crosstogether joe  jack     cross joe     crosstogether joe  william   
 cross joe     crosstogether joe  averell  

   actions costs
using language k system prototype  dlv k   already express solve
involved planning tasks  cf   eiter et al       b   however  k dlv k alone offer means
finding optimal plans objective cost function  general  different criteria plan
optimality relevant  optimality wrt  action costs shown next example 
slight elaboration bridge crossing problem  well known brain teasing riddle 
problem    quick bridge crossing problem  persons bridge crossing scenario need
different times cross bridge  namely             minutes  respectively  walking two
implies moving slower rate both  possible four persons get across within   
minutes 
first thought infeasible  since seemingly optimal plan joe  fastest 
keeps lamp leads others across takes    minutes altogether  surprisingly 
see  optimal solution indeed takes    minutes 
order allow elegant convenient encoding optimization problems 
extend k language k c one assign costs actions 
    syntax kc
let act   f l   var denote  finite  sets action names  fluent names variable symbols 
furthermore  let lact   lf l   ltyp denote sets action  fluent  type literals  respectively 
   format input files system prototype  presented section   

  

fia nswer et p lanning u nder action c osts

actions  

cross x  requires person x  
crosstogether x  y  requires person x   person y   x   y 
takelamp x  requires person x  

fluents  

across x  requires person x  
differentsides x  y  requires person x   person y  
haslamp x  requires person x  

initially    across x   haslamp joe  
always  

executable crosstogether x  y  haslamp x  
executable crosstogether x  y  haslamp y  
nonexecutable crosstogether x  y  differentsides x  y  
executable cross x  haslamp x  
executable takelamp x  
nonexecutable takelamp x  haslamp y   differentsides x  y  
caused
caused
caused
caused

across x  crosstogether x  y  
across y  crosstogether x  y  
 across x  crosstogether x  y  
 across y  crosstogether x  y  

 across x  
 across y  
across x  
across y  

caused across x  cross x    across x  
caused  across x  cross x   across x  
caused haslamp x  takelamp x  
caused  haslamp x  takelamp y   x    y  haslamp x  
caused differentsides x  y  across x    across y  
caused differentsides x  y   across x   across y  
inertial across x  
inertial  across x  
inertial haslamp x  
noconcurrency 
goal  

across joe   across jack   across william   across averell    l 

figure    k encoding bridge crossing problem
formed action names  fluent names  predicates background knowledge  including
built in predicates   respectively  using terms nonempty  finite  set constants con  
kc extends action declarations k costs follows 
definition     action declaration k c form 
p x            xn   requires t            tm costs c c            ck  

   

    p act arity n        x            xn var       t            tm   c            ck
ltyp every xi occurs t            tm       c either integer constant  variable
set variables occurring t            tm   c            ck  denoted var  d    distinguished
variable time      var  d  var  time       time occur           tm  
  

fie iter   faber   l eone   p feifer   p olleres

     keyword requires omitted  k      keyword omitted
costs c optional  here          state parameters action must variables 
fixed values  informally      means parameters action must typed
requires part  condition     asserts cost locally defined given stage
plan  referenced global variable time  conditions         ensure
variables known type information action parameters static  i e   depend
time 
planning domains planning problems k c defined k 
example  elaborated bridge crossing problem  declaration cross x 
extended follows  suppose predicate walk person  minutes  background knowledge
indicates person takes minutes cross  then  may simply declare
cross x  requires person x  costs wx walk x  wx  

    semantics kc
semantically  kc extends k cost values actions points time  plan p  
ha            al i  step   l  actions ai executed reach time point i 
ground action p x            xn   legal action instance action declaration wrt  k c
planning domain pd   h  hd  rii  exists ground substitution var  d 
 time  xi   xi     n  t            tm     unique answer
set background knowledge   called witness substitution p x             xn   
informally  action instance legal  satisfies respective typing requirements  action costs
formalized follows 
definition     let   p x            xn   legal action instance declaration form    
let witness substitution a 

costs part empty 
  
cost  p x            xn     
val c    c            ck    

undefined otherwise 

unique answer set val   con defined integer value
integer constants   non integer constants 
reference variable time  possible define time dependent action costs  shall consider example section      using cost   introduce well defined legal action instances
define action cost values follows 
definition     legal action instance   p x             xn   well defined iff holds  i 
time point    witness substitution time   cost  a 
integer   ii  cost  a    cost   a  holds two witness substitutions     coincide
time defined costs  well defined a  unique cost time point   given
costi  a    cost  a   i  
definition  condition  i  ensures cost value exists  must integer 
condition  ii  ensures value unique  i e   two different witness substitutions
  evaluate cost part integer cost value 
  

fia nswer et p lanning u nder action c osts

action declaration well defined  legal instances well defined 
fulfilled if  database terms  variables x            xn together time     functionally determine value c  framework  semantics k c planning domain pd   h  hd  rii
well defined well defined action declarations pd  rest paper  assume
well definedness kc unless stated otherwise 
using costi   define costs plans 
definition     let p   hpd  q    l i planning problem  then  plan p   ha             al
p  cost defined
costp  p    

pl

j  

p


cost
 a 
 
j
aaj

plan p optimal p  costp  p   costp  p     plan p   p  i e   p least cost
among plans p  cost planning problem p  denoted cost p   given costp  
costp  p    p optimal plan p 
particular  costp  p       p   hi  i e   plan void  note cost p defined
plan p exists  
usually one estimate upper bound plan length  know exact
length optimal plan  although defined optimality fixed plan length l 
see section     appropriate encodings extended optimality plans
length l 
besides optimal plans  plans bounded costs interest  motivates following definition 
definition     plan p planning problem p admissible wrt  cost c  cost p  p   c 
admissible plans impose weaker condition plan quality optimal plans 
particularly relevant optimal costs crucial issue  long cost stays within given
limit  optimal plans difficult compute  might face questions make
airport within one hour   enough change buy coffee  etc  amount
admissible planning problems  shall see  computing admissible plans complexity wise
easier computing optimal plans 
    optimal solution quick bridge crossing problem
model quick bridge crossing problem k c   first extend background knowledge
follows  predicate walk describes time person needs cross max determines
two persons slower 
walk joe      walk jack      walk william      walk averell      
max a  b  a     walk    a   walk    b      b 
max a  b  b     walk    a   walk    b   b   a 

next  modify declarations cross crosstogether figure   adding costs 
   following  subscripts dropped clear context 

  

fie iter   faber   l eone   p feifer   p olleres

cross x  requires person x  costs wx walk x  wx  
crosstogether x  y  requires person x   person y   x  
costs wmax walk x  wx   walk y  wy   max wx  wy  wmax  

declaration takelamp remains unchanged  time hand lamp negligible 
using modified planning domain    step plan reported section     cost     actually  optimal plan length l      however  relinquish first intuition
fastest person  joe  always lamp consider problem varying plan length 
find following   step plan 
p   h  crosstogether joe  jack     cross joe     takelamp william   
 crosstogether william  averell     takelamp jack     cross jack   
 crosstogether joe  jack  

here  costp  p         thus p admissible respect cost     means quick
bridge crossing problem positive answer  fact  p least cost plans length
l      thus optimal   step plan  moreover  p least cost plans emerge
consider plan lengths  thus  p optimal solution quick bridge crossing
problem arbitrary plan length 
    bridge crossing incomplete knowledge
language k well suited model problems involve uncertainty incomplete
initial states non deterministic action effects qualitative level  enriched language k c
gracefully extends secure  conformant  plans well  must reach goal circumstances  eiter et al       b      b   precisely  optimistic plan ha             secure 
applicable evolution system  starting legal initial state     first
action set a   for plan length l    always executed  i e   legal transition hs     a    s 
exists   every possible state     next action set a  executed etc  
performed actions  goal always accomplished  cf  appendix formal definition  
secure plans inherit costs optimistic plans  different possibilities define
optimality secure plans  may consider secure plan optimal  least cost either
among optimistic plans 
among secure plans only 
first alternative  might planning problems secure plans  optimal
secure plans  reason  second alternative appears appropriate 
definition     secure plan p optimal planning problem p  least cost among
secure plans p  i e   costp  p   costp  p     secure plan p   p  secure cost
p  denoted costsec  p   costsec  p    costp  p    p optimal secure plan p 
notion admissible secure plans defined analogously 
example  assume known least one person bridge scenario lamp 
neither exact number lamps allocation lamps persons known 
four desperate persons ask plan brings safely across bridge  need
 fast  secure plan works possible initial situations  k c   modeled
replacing initially part following declarations 
  

fia nswer et p lanning u nder action c osts

initially   total haslamp x  
caused false  haslamp joe    haslamp jack  
 haslamp william    haslamp averell  

first statement says person either lamp not  second least
one must lamp  detailed discussion use total statement
modeling incomplete knowledge non determinism refer  eiter et al       b  
easily see  optimal secure solution take least    minutes  since original
case  where joe lamp  one possible initial situations  cost
optimistic plan optimal plan lengths     however  secure plan
optimal plan lengths requires least   steps  but higher cost   different
optimistic plans  need one extra step beginning makes sure one
walk first  above  joe jack  lamp  effected proper takelamp action 
example plan following cost    
p   h  takelamp joe     crosstogether joe  jack     cross joe   
 takelamp william     crosstogether william  averell     takelamp jack   
 cross jack     crosstogether joe  jack  

easily check p works every possible initial situation  thus  optimal  secure 
plan plan length    moreover arbitrary plan length 

   computational complexity
section  address computational complexity k c   complementing similar results
language k  eiter et al       b  
    complexity classes
assume reader familiar basic notions complexity theory  p  np 
problem reductions completeness  see e g   papadimitriou        references therein 
recall polynomial hierarchy  ph  contains classes p    p    p    p pi    
p
p
npi   pi     co pi     pi     pi      particular  p    np p    pnp  
note classes contain decision problems  i e   problems answer yes
no   checking well definedness deciding plan existence problems  computing
plan search problem  problem instance  possibly empty  finite set s i 
solutions exists  solve problem   possibly nondeterministic  algorithm must compute
alternative solutions set computation branches  s i  empty  precisely 
search problems solved transducers  i e   turing machines equipped output tape 
machine halts accepting state  contents output tape result
computation  observe nondeterministic machine computes  partial  multi valued function 
analog np  class npmv contains search problems s i  computed nondeterministic turing machine polynomial time  precise definition  see  selp
man         analogy pi     pi   mv   npmvi      denote generalization
npmv machine access pi oracle 
analogs classes p pi        given classes fp f pi       
contain partial single valued functions  that is   s i     problem instance
  

fie iter   faber   l eone   p feifer   p olleres

i  computable polynomial time using resp  pi oracle  say  abusing terminology 
search problem fp  resp  fpi      partial  single valued  function f fp
 resp  f fpi     f  i  s i  f  i  undefined iff s i      example 
computing satisfying assignment propositional cnf  fsat  computing optimal tour
traveling salesperson problem  tsp  f p  view  cf   papadimitriou        
partial function f polynomial time reducible another partial function g 
polynomial time computable functions h   h  f  i    h   i  g h   i   
g h   i   defined whenever f  i  defined  hardness completeness defined usual 
    problem setting
focus following questions 
checking well definedness  decide whether given action description well defined wrt 
given planning domain pd  resp  whether given planning domain pd well defined 
admissible planning  decide whether planning problem p admissible  optimistic secure 
plan exists wrt  given cost value c  find plan 
optimal planning  find optimal  optimistic secure  plan given planning problem 
notice  eiter et al       b  focused deciding existence optimistic secure plans 
rather actually finding plans  presented detailed study complexity task
various restrictions ground  propositional  planning problems  paper  confine
discussion case planning problems p   hpd  q    l i look polynomial length
plans  i e   problems plan length l bounded polynomial size input 
shall consider mainly ground  propositional  planning  assume planning
domains well typed unique model background knowledge computed
polynomial time  general case  well known complexity results logic programming 
cf   dantsin  eiter  gottlob    voronkov         already evaluating background knowledge
exptime hard  problems thus provably intractable  recall following results 
appear  or directly follow from  previous work  eiter et al       b  
proposition     deciding  given propositional planning problem p sequence p   ha            
al action sets   i  whether given sequence   ht             tl legal trajectory witnessing
p optimistic plan p feasible polynomial time   ii  whether p secure plan
p p   complete 
    results
start considering checking well definedness  problem  interesting investigate
non ground case  assuming background knowledge already evaluated  way
assess intrinsic difficulty task obtaining following result 
theorem      complexity checking well definedness  given k c planning domain pd  
h  hd  rii unique model   checking  i  well definedness given action declaration form     wrt  pd  ii  well definedness pd p   complete 
  

fia nswer et p lanning u nder action c osts

proof  membership   i   violated nonempty costs part legal action
instance   p x            xn   either     exist witness substitutions  
time   time     cost  a    val c  cost   a    val c      val c     val c     
    witness substitution cost  a    val c  integer 
guessed checked  via witness substitution  polynomial time  along
       note that  definition  variables must substituted constants
background knowledge  including numbers   must values time occurs
c            ck   given a  decide     help np oracle  summary  disproving welldefinedness nondeterministically possible polynomial time np oracle  hence 
checking well definedness co p    p    membership part  ii  follows  i  
since well definedness pd reduces well definedness action declarations it  p 
closed conjunctions 
hardness  show hardness  i  reduction deciding whether quantified boolean
formula  qbf 
q   xy c  ck
ci   li   li  i                k  disjunction literals l i j atoms
x   x            xn   xn           xm   true  without loss generality  may assume
ci contains three  not necessarily distinct  literals  either positive negative 
construct planning domain pd follows  background knowledge   
bool     bool    
pos           pos           pos           pos           pos           pos           pos          
neg           neg           neg           neg           neg           neg           neg          

here  bool declares truth values      facts pos x     x    x    neg x    x    x    state
truth assignments x    x    x  positive clause x  x  x  resp 
negative clause x  x  x  satisfied 
rest planning domain pd consists single action declaration form
p v         vn   requires bool v         bool vn  costs   c         ck  


ci

 



pos vi     vi     vi      ci   xi   xi   xi    
neg vi     vi     vi      ci   xi   xi   xi    

             k 

example  clause c   x  x  x  mapped c   pos v    v    v     easy see
legal action instance   p b            bn   corresponds     truth assignment x
given  xi     bi                n  furthermore  cost value defined  which    iff
formula  c  ck   true  thus  well defined wrt  pd iff q true  since pd
 
efficiently constructible  proves p   hardness 
observe ground case  checking well definedness much easier  since substitutions need guessed  test proof theorem     polynomial  thus  assumption
efficient evaluation background program  obtain 
corollary     ground  propositional  case  checking well definedness action description wrt  kc planning domain pd   h  hd  rii  resp  pd whole  possible
polynomial time 
  

fie iter   faber   l eone   p feifer   p olleres

remark checking well definedness expressed planning task k 
logic program  refer  eiter  faber  leone  pfeifer    polleres      b  details 
turn computing admissible plans 
theorem      complexity admissible planning  polynomial plan lengths  deciding whether
given  well defined  propositional planning problem hpd  qi  i  optimistic admissible
plan wrt  given integer b np complete  finding plan complete npmv   ii 
deciding whether hpd  qi secure admissible plan wrt  given integer b p   complete 
computing plan p  mv complete  hardness holds cases fixed plan length 
proof refer appendix  finally address complexity computing
optimal plans 
theorem      complexity optimal planning  polynomial plan lengths   i  computing
optimal optimistic plan hpd  q    l i k c fp   complete   ii  computing optimal
secure plan hpd  q    l i k c fp   complete  hardness holds cases even plan
length l fixed 
proof found appendix 
remark case unbounded plan length  complexity computing plans increases requires  at least  exponential time general  since plans might exponential length
size planning problem  thus  practical terms  constructing plans infeasible 
since occupy exponential space  furthermore  follows previous results  eiter et al  
    b   deciding existence admissible optimistic resp  secure plan planning problem wrt  given cost pspace complete resp  nexptime complete  leave detailed
analysis complexity aspects k c work 

   applications
    cost efficient versus time efficient plans
section  show language k c used minimize plan length combination
minimizing costs plan  especially interesting problem settings parallel
actions allowed  cf   kautz   walser        lee   lifschitz         
domains parallel actions  kautz walser propose various criteria optimized  instance number actions needed  number necessary time steps
parallel actions allowed  well combinations two criteria         exploiting
action costs proper modeling  solve optimization problems sort  example 
single plans minimal number actions simply assigning cost   possible
actions 
consider following optimization problems 
   find plan minimal cost  cheapest plan  given number steps 
   find plan minimal time steps  shortest plan  
   find shortest among cheapest plans 
  

fia nswer et p lanning u nder action c osts

   find cheapest among shortest plans 
problem    already defined optimal plans far  show
express    terms optimal cost plans well  extend elaboration respect
combinations       
      c heapest p lans



g iven p lan l ength   

guiding example  refer blocks world parallel moves allowed  apart
finding shortest plans minimizing total number moves issue  kc encoding
domain  plans serializable  shown figure    serializability means parallel
actions non interfering executed sequentially order  i e  parallel plan
arbitrarily unfolded sequential plan 
fluents  

on b  l  requires block b   location l  
blocked b  requires block b  
moved b  requires block b  

actions  

move b  l  requires block b   location l  costs   

always  

executable move b  l  b    l 
nonexecutable move b  l  blocked b  
nonexecutable move b  l  blocked l  
nonexecutable move b  l  move b   l   b   b   block l  
nonexecutable move b  l  move b  l    l   l  
nonexecutable move b  b   move b   l  
caused
caused
caused
caused

on b  l  move b  l  
blocked b  on b   b  
moved b  move b  l  
on b  l  moved b  on b  l  

figure    kc encoding blocks world domain
planning problem emerging initial state goal state depicted figure  
modeled using background knowledge bw  
block     block     block     block     block     block    
location table  
location b     block b  

extending program figure   follows 
initially   on        on    table   on        on    table   on        on    table  
goal  

on        on    table   on        on    table   on        on    table    l 

 
 

 
 

 
 

 
 

 
 

 
 

figure    simple blocks world instance
  

fie iter   faber   l eone   p feifer   p olleres

move penalized cost    results minimization total number moves 
let pl denote planning problem plan length l 
l      optimal plan involves six moves  i e  cost p      
p    h  move    table   move    table   move    table     move        move        move       

unfolding steps  plan gives rise similar plans length l                cost   
l      find among others following optimal plan  cost   
p    h  move    table     move        move    table     move        move       

plan parallelized two steps  plan length l     
obtain optimal plans similar p     extended void steps  thus plan cheapest
plan lengths cost   needs three steps  note shortest parallel plans  of length   
expensive  explained above 
      hortest p lans   
intuitively  possible include minimization time steps cost function 
describe preprocessing method which  given k planning domain pd  list q ground literals 
upper bound   plan length  generates planning problem p  pd  q  i 
optimal plans p correspond shortest plans reach q pd steps  i e  
plans hpd  q    l i l minimal  assume action costs specified
original planning domain pd  minimizing time steps target 
first rewrite planning domain pd pd follows  introduce new distinct fluent
gr new distinct action finish  defined follows 
fluents  
actions  

gr 
finish costs time 

intuitively  action finish represents final action  use finish plan  later
action occurs  expensive plan assign time cost  fluent gr  goal
reached  shall true remain true soon goal reached  triggered
finish action 
modeled k c adding following statements always section
program 
executable finish q  gr 
caused gr finish 
caused gr gr 

furthermore  want finish occur exclusively want block occurrence
action goal reached  therefore  every action pd  add
nonexecutable finish 

add gr if part executability condition a  finally  avoid inconsistencies static dynamic effects soon goal reached  add gr
part causation rule pd except nonexecutable rules remain unchanged   
define p  pd  q  i    hpd   gr   i     i  take     plan length since
need one additional step execute finish action 
   need rewrite nonexecutable rules respective actions already switched
rewriting executability conditions 

  

fia nswer et p lanning u nder action c osts

construction  easy see optimal plan p   ha             aj   aj             ai  
planning problem p must aj      finish  aj             ai    
j             i   thus following desired property 
proposition     optimal plans p     correspondence shortest plans reaching q pd  precisely  p   ha            aj               optimal optimistic plan
p  pd  q  i  aj      finish  p     ha            aj optimistic plan
hpd  q    j i j             i   hpd  q    j    i optimistic plan j     j 
blocks world example  using method get   step plans  choose   
compute shortest plans plan lengths  set upper bound large enough
plans length l guaranteed exist  trivial bound total number legal
states general exponential number fluents 
however  many typical applications inherent  much smaller bound plan length 
instance  blocks world n blocks  goal configuration reached within
 n sinit sgoal steps  sinit sgoal numbers stacks initial goal
state  respectively   therefore    upper bound plan length simple instance 
remark approach minimizing plan length efficient upper bound
close optimum known  searching minimum length plan iteratively increasing
plan length may much efficient bound known  since weak upper bound
lead explosion search space  cf  benchmarks section      
      hortest

among

c heapest p lans   

previous subsection  shown calculate shortest plans k programs without
action costs  combining arbitrary k c programs rewriting method described easy 
want find shortest among cheapest plans  use rewriting 
little change  setting costs actions except finish least high
highest possible cost finish action  obviously plan length      so 
simply modify action declarations
requires b costs c d 

p multiplying costs factor     
requires b costs c  c     i      c  d 

lets action costs take priority cost finish compute plans
satisfying criterion     let p denote resultant planning problem  have 
proposition     optimal plans p     correspondence shortest among
cheapest plans reaching q pd within steps  precisely  p   ha             aj              
optimal optimistic plan p  pd  q  i  aj      finish   i  p    
ha            aj plan pj   hpd  q    j i  j             i    ii  p      ha            aj  
plan pj     hpd  q    j    i j   i  either costpj    p        costpj  p    
costpj    p        costpj  p     j   j 
figure   shows p blocks world instance      one optimal plan p
   one solve blocks world problem sequentially first unstacking blocks table
 n sinit steps  building goal configuration  n sgoal steps  

  

fie iter   faber   l eone   p feifer   p olleres

fluents  

on b  l  requires block b   location l  
blocked b  requires block b  
moved b  requires block b  
gr 

actions  

move b  l  requires block b   location l  costs c c       
finish costs time 

always  

executable move b  l  b    l  gr 
nonexecutable move b  l  blocked b  
nonexecutable move b  l  blocked l  
nonexecutable move b  l  move b   l   b   b   block l  
nonexecutable move b  l  move b  l    l   l  
nonexecutable move b  b   move b   l  
caused
caused
caused
caused

on b  l  gr move b  l  
blocked b  on b   b   gr 
moved b  gr move b  l  
on b  l  moved b   gr on b  l  

executable finish on        on    table   on        on    table  
on        on    table   gr 
caused gr finish 
caused gr gr 
nonexecutable move b  l  finish 
initially   on        on    table   on        on    table   on        on    table  
goal  

gr     

figure    computing shortest plan blocks world instance minimum number
actions

p   h  move    table     move        move    table   
 move        move          finish       i 

costp  p         compute optimal cost wrt  optimization    subtracting cost finish dividing              i                  thus 
need minimum   moves reach goal  minimal number steps obviously steps 
except final finish action  i e     thus  need least   steps plan five moves 
      c heapest

among

hortest p lans   

again  use rewriting optimization     cost functions adapted similarly
previous subsection  cost action finish takes priority
actions costs  end  sufficient set cost finish high enough  achieved
multiplying factor f higher sum action costs legal action instances
steps j                   let p denote resulting planning problem  have 
proposition     optimal plans p     correspondence cheapest among
shortest plans reaching q pd within steps  precisely  p   ha             aj              
  

fia nswer et p lanning u nder action c osts

optimal optimistic plan p  pd  q  i  aj      finish   i  p    
ha            aj plan pj   hpd  q    j i  j             i    ii  p      ha            aj  
plan pj     hpd  q    j    i j   i  either j     j  j     j costpj    p     
costpj  p     
example     possible moves  thus  could take f       i     
would set costs finish time     i       however  need take account
actions actually occur simultaneously  example  six blocks
moved parallel  therefore  sufficient set f      i      assign finish cost
time f   time     accordingly  action declarations modified follows 
actions  

move b  l  requires block b   location l  costs   
finish costs c c   time    

optimal plan modified planning problem p is 
p   h  move    table   move    table   move    table   
 move        move        move          finish        

costp  p          here  compute optimal cost wrt  optimization    simply
subtracting cost finish  i e                since finish occurs time point   
consequently  need minimum   moves shortest plan  length         
indeed  seen  and how  optimization problems      
represented kc   remark transformations p   p   p work restrictions
secure and or sequential plans well 
    traveling salesperson
another illustrating example optimal cost planning  introduce elaboration
traveling salesperson problem 
traveling salesperson problem  tsp   start classical traveling salesperson problem  tsp   given set cities connections  e g   roads  airways  certain costs 
want know economical round trip visits cities exactly returns
starting point  if tour exists   figure   shows instance representing capitals
austrian provinces  dashed line flight connection  connections roads 
connection marked costs traveling hours 
brg     bregenz
eis     eisenstadt
gra     graz
ibk     innsbruck
kla     klagenfurt
lin     linz
sbg     salzburg
stp     st  plten
vie     vienna

lin
sbg

 

 

ibk

 

 

vie
 

 
 
 

 

 
kla

figure    tsp austria

eis

 

 

  

 
stp  

 

 
brg

 

gra

 

fie iter   faber   l eone   p feifer   p olleres

represent kc follows  background knowledge sp defines two predicates
city c  conn f  t  c  representing cities connections associated costs  connections traveled ways 
conn brg  ibk      conn ibk  sbg      conn ibk  vie      conn ibk  kla     
conn sbg  kla      conn sbg  gra      conn sbg  lin      conn sbg  vie     
conn kla  gra      conn lin  stp      conn lin  vie      conn lin  gra     
conn gra  vie      conn gra  eis      conn stp  vie      conn eis  vie     
conn stp  eis      conn vie  brg     
conn b  a  c     conn a  b  c  
city t     conn t      

possible encoding tsp starting vienna  vie  k c program figure    includes two
actions traveling one city another directly returning starting point
end round trip soon cities visited 
actions  

travel x  y  requires conn x  y  c  costs c 
return from x  requires conn x  vie  c  costs c 

fluents  

unvisited  end 
in c  requires city c  
visited c  requires city c  

always  

executable travel x  y  in x  
nonexecutable travel x  y  visited y  
executable return from x  in x  
nonexecutable return from x  unvisited 
caused unvisited city c   visited c  
caused end return from x  
caused in y  travel x  y  
caused visited c  in c  
inertial visited c  

noconcurrency 
initially   in vie  
goal  
end     

figure    traveling salesperson
problem ten optimal   step solutions cost     show first five here 
others symmetrical 
p    h  travel vie  stp   
 travel lin  sbg   
 return from brg  
p    h  travel vie  eis   
 travel sbg  gra   
 return from brg  
p    h  travel vie  eis   
 travel gra  kla   
 return from brg  
p    h  travel vie  lin   
 travel gra  kla   

 travel stp  eis   
 travel sbg  kla   

 travel eis  stp   
 travel gra  kla   

 travel eis  stp   
 travel kla  sbg   

 travel lin  stp   
 travel kla  sbg   

 travel eis  gra     travel gra  lin   
 travel kla  ibk     travel ibk  brg   
 travel stp  lin     travel lin  sbg   
 travel kla  ibk     travel ibk  brg   
 travel stp  lin     travel lin  gra   
 travel sbg  ibk     travel ibk  brg   
 travel stp  eis     travel eis  gra   
 travel sbg  ibk     travel ibk  brg   

  

fia nswer et p lanning u nder action c osts

 return from brg  
p    h  travel vie  gra   
 travel lin  sbg   
 return from brg  


 travel gra  eis     travel eis  stp     travel stp  lin   
 travel sbg  kla     travel kla  ibk     travel ibk  brg   


tsp variable costs  let us consider elaboration tsp  assume
costs traveling different connections may change trip  note three
five solutions example include traveling st polten eisenstadt vice versa
second day  let us assume salesperson  starts monday  face
exceptions might increase cost trip  instance   i  heavy traffic jams expected
tuesdays route st polten eisenstadt  ii  salesperson shall use flight
connection vienna bregenz mondays expensive business class tickets
available connection beginning week  deal different costs
respective connections depending particular day 
end  first add background knowledge sp new predicate cost a  b  w  c 
representing cost c traveling connection b weekday w take exceptional
costs account 
cost a  b  w  c     conn a  b  c    int w       w  w       ecost a  b  w  
ecost a  b  w     conn a  b  c   cost a  b  w  c    c    c  

original costs predicate conn a  b  c  represent defaults  overridden
explicitly adding different costs  instance  represent exceptions  i   ii   add 
cost stp  eis          cost vie  brg         

setting exceptional costs two critical connections     weekdays coded integers
   monday     sunday   represent mapping time steps weekdays
following rules add sp  
weekday       
weekday d  w       d       w   w       weekday d   w    w      
weekday d          d       weekday d      

note although modified background knowledge sp stratified  since cost defined
cyclic negation   total well founded model  thus unique answer set 
finally  change costs traveling returning k c program figure   
actions  

travel x  y  requires conn x  y  c   costs c
weekday time  w   cost x  y  w  c  
return from x  requires conn x  vie  c   costs c
weekday time  w   cost x  vie  w  c  

since costs p   which includes traveling st polten eisenstadt  second
day increased due exception  i   four plans remain optimal  note
unlike default costs  exceptional costs apply bidirectionally  exception
affect p  p    furthermore  due exception  ii  symmetrical round trips starting
flight trips bregenz longer optimal 
presented encoding proves flexible  allows adding arbitrary exceptions
connection weekday simply adding respective facts  moreover  even
involved scenarios  exceptions defined rules  modeled 
  

fie iter   faber   l eone   p feifer   p olleres

    small example planning resource restrictions
although planning resources main target approach  following encoding
shows action costs used order model optimization resource consumption
cases  important resource real world planning money  instance  let us consider
problem buying selling  lee   lifschitz        
   pocket  newspaper costs    magazine costs    
enough money buy one newspaper two magazines 
kc   encoded compact way following background facts 
item newspaper      item magazine     

combined following short k c program 
actions  

buy item  number  requires item item  price    int number 
costs c c   number price 

fluents  

have item  number  requires item item  price    int number  

always  

executable buy item  number  
nonexecutable buy item  n   buy item  n    n    n  
caused have item  number  buy item  number  

goal  

have newspaper      have magazines          

action buy always executable  one must buy two different amounts certain
item once  obviously  admissible plan wrt  cost   exists  optimal plan problem 
h buy newspaper      buy magazine      cost p      therefore  answer problem
no 
approach considers positive action costs directly allow modeling full
consumer producer provider relations resources general  favor clear non ambiguous
definition optimality  instance  allowing negative costs one could always add producer
action make existing plan cheaper  whereas approach costs guaranteed increase
monotonically  allowing clear definition plan costs optimality 
hand  encode various kinds resource restrictions using fluents represent resources  model production consumption action effects fluents
add restrictions constraints  allows us model even complex resource scheduling
problems  optimization  however  remains restricted action costs 

   transformation logic programming
section  describe planning action costs implemented means
transformation answer set programming  extends previous transformation  eiter et al  
    a   maps ordinary k planning problems disjunctive logic programs answer
set semantics  gelfond   lifschitz         takes advantage weak constraints  cf   buccafurri 
leone    rullo               implemented dlv system  faber   pfeifer        eiter 
faber  leone    pfeifer      a   addition  show translation adapted
language smodels  simons  niemela    soininen        
    disjunctive logic programs weak constraints
first  give brief review disjunctive logic programs weak constraints 
  

fia nswer et p lanning u nder action c osts

syntax

disjunctive rule  for short  rule  r construct
a  v v    b      bk   bk       bm  

   

ai bj classical literals function free first order alphabet  n   
k    part left  resp  right     head  resp  body  r     omitted
     let h r     a             set head literals b r    b    r  b  r 
set body literals  b    r     b           bk   b  r     bk             bm     strong 
constraint rule empty head  n      
weak constraint construct
  b      bk   bk       bm    w   

   

w integer constant variable occurring b             bk bi classical literals  
b r  defined     
disjunctive logic program  dlpw    simply  program  finite set rules  constraints
weak constraints  here  superscript w indicates potential presence weak constraints 
semantics answer sets program without weak constraints defined usual  gelfond   lifschitz        lifschitz         one difference  though  consider
inconsistent answer sets  answer sets program weak constraints defined
selection answer sets weak constraint free part   optimal answer sets 
weak constraint c form     violated  instance conjunction
satisfied respect candidate answer set s  i e   exists substitution mapping
variables c herbrand base  b       bk    bk       bm  
    call w violation value c wrt      violation cost c wrt  s  denoted
costc  s   sum violation values violating substitutions c wrt  s  cost
s  denoted cost  s  
x
cost  s   
costc  s  
c weak constraints

i e   sum violation costs weak constraints wrt  s  answer set
selected  called optimal answer set   cost  m   minimal answer sets  
 buccafurri et al         know given head cycle free disjunctive program  deciding whether query q true optimal answer set p   complete  respective class
computing answer set fp   complete  together results section   indicates translations optimal planning problems head cycle free disjunctive logic programs
weak constraints language smodels feasible polynomial time 
    translating kc dlpw
extend original transformation lp p   naturally maps k planning problem p
weak constraint free program  eiter et al       a   new translation lp w  p   optimal
answer sets lpw  p  correspond optimal cost plans k c planning problem p 
   colon  w    stems dlv language  allows specify priority layer colon 
need priority layers translation  stick dlv syntax 
   weak constraint c admissible  possible violation values candidate answer sets integers 
thus  w variable  must guarantee w bound integer 

  

fie iter   faber   l eone   p feifer   p olleres

basically  lp p  fluent action literals extended additional time parameter 
executability conditions well causations rules modularly translated  rule rule  corresponding program rules constraints  disjunction used guessing actions
executed plan point time 
      r eview



ranslation lp p 

basic steps translation k programs logic programs follows  cf   eiter et al  
    a  details  
step    macro expansion  

first  replace macros k program definitions 

step    background knowledge   background knowledge p already given logic
program included lp p   without modification 
step    auxiliary predicates  

represent steps  add following facts lp p 

time              time l   next                 next l    l  

l plan length query q   g  l  p hand 
step    causation rules   causation rules mapped rules lp p  adding type information extending fluents actions time stamp using time next  example 
caused across x  cross x    across x  

leads rule across x  t      cross x  t     across x  t    person x   next t   t    
lp p  t    t  new variables  here  type information person x  across x  
 across x   taken type declaration  added  helps avoid unsafe logic programming rules 
step    executability conditions   similarly  executability condition translated disjunctive rule guessing whether action occurs certain time step  running example 
executable cross x  haslamp x  

becomes cross x  t    cross x  t      haslamp x  t    person x   next t   t    
encodes guess whether time point   action cross x  happen  again  type information person x  added well next t     t    ensure t  last time point 
step    initial state constraints   initial state constraints transformed static causation
rules step    using constant   instead variable   thus need auxiliary predicate time stamp  instance 
initially   caused  across x  

becomes  adding type information  across x        person x  
step    goal query  
goal  

finally  query q 

g   t             gm  tm    gm    tm              gn  tn      l  

translated follows  goal reached new   ary predicate symbol 
goal reached    g   t    l           gm  tm   l   gm    tm     l           gn  tn   l  
   goal reached 
  

fia nswer et p lanning u nder action c osts

      e xtending



ranslation



action c osts

extended translation lpw  p  kc problem p first includes rules lp pnc    pnc
results p stripping cost parts  furthermore  following step added 
step    action costs  

action declaration form     nonempty costs part  add 

 i  new rule rd form

costp  x            xn   t  c     p x            xn   t   t            tm  
c            ck   u       

   

costp new symbol  u new variables    time u   optimization 
u       present u occurs elsewhere r  
  costp  x            xn   t  c    c   

 ii  weak constraint wcd form

   

example  cross action quick bridge crossing problem translated
costcross x  t  wx    cross x  t   person x   walk x  wx  
  costcross x  t  wx    wx   

showed previous work  eiter et al       a   answer sets lp p  correspond
trajectories optimistic plans p  following theorem states similar correspondence result
lpw  p  optimal plans p  define  consistent set ground literals s  sets
asj    a t    a t  j    s  act   ssj    f  t    f  t  j  s  f  t  lf l    j   
theorem      answer set correspondence  let p   hpd  qi  well defined  k c planning
problem  let lpw  p  program  then 
 i  optimistic plan p   ha            al p supporting trajectory   hhs     a    s  i 
hs    a    s  i          hsl    al   sl ii p   exists answer set lp w  p 
aj   asj j              l  sj   ssj   j              l costp  p     costlpw  p   s  
 ii  answer set lpw  p   sequence p   ha            al solution p  i e  
optimistic plan  witnessed trajectory   hhs     a    s  i  hs    a    s  i          hsl    al   sl ii
costp  p     costlpw  p   s   aj   asj sk   ssk j              l
k              l 
proof based resp  correspondence result k  eiter et al       a   details 
refer appendix 
result definitions optimal cost plans optimal answer sets  conclude
following result 
corollary      optimal answer set correspondence  well defined k c planning problem
p   hpd  q    l i  trajectories   hhs     a    s  i          hsl    al   sl ii optimal plans p p
correspond optimal answer sets lp w  p   aj   asj j              l
sj   ssj   j              l 
proof  aj   weak constraint     causes violation value cost j  a   furthermore 
p onlypcost violations  thus  candidate answer set optimal
costlpw  p   s    lj   aaj costj  a    costp  p   minimal  i e   corresponds optimal
plan 
 
similar correspondence result holds admissible plans 
  

fie iter   faber   l eone   p feifer   p olleres

corollary      answer set correspondence admissible plans  well defined k c planning problem p   hpd  q    l i  trajectories   hhs     a    s  i          hsl    al   sl ii admissible plans p p wrt  cost c correspond answer sets lp w  p  costlpw  p   s  c 
aj   asj j              l sj   ssj   j              l 
secure planning  introduced technique check security optimistic plan
certain planning problem instances means logic program  eiter et al       a  
method carries planning action costs straightforward way  optimal resp  admissible secure plans similarly computed answer set programming 
    alternative translation smodels
apart presented translation using weak constraints  one could choose alternative
approach translation answer set programming  smodels  simons et al         supports
another extension pure answer set programming allowing minimize sets predicates 
approach could used alternative formulation step   
step  a 

action declarations nonempty costs parts  add new rule form
cost p  x            xn                 t  c     t            tm   c            ck   u       

   

similar step   above  two differences      action name p parameter      add
l n parameters constant   x n l maximum arity actions
pd  necessary order get unique arity l     predicate cost  furthermore  add
occurs p  x            xn                 t     p x            xn   t   t            tm   

   

second rule adds   parameters achieve unique arity l     new
predicate occurs  using smodels syntax  compute optimal plans adding
minimize occurs a  x        xl   t    cost a  x        xl   t  c    c  

note smodels support disjunction rule heads  need modify step   
expressing action guess via unstratified negation smodels choice rules 

   implementation
implemented experimental prototype system  dlv k   solving k planning problems  eiter et al       a   improved version prototype capable optimal
admissible planning respect extended syntax k c   available experiments
http   www dlvsystem com k   
dlvk realized frontend dlv system  faber   pfeifer        eiter et al  
    a   first  planning problem hand transformed described previous section 
then  dlv kernel invoked produce answer sets  optimistic planning  optimal 
action costs defined  answer sets simply translated back suitable output user
printed 
case user specified secure conformant planning performed  system
check security plans computed  normal  non optimal  planning  simply done
checking answer set returned right transforming back user output  case
  

fia nswer et p lanning u nder action c osts

optimal secure planning  hand  candidate answer set generation dlv kernel
intercepted  kernel proceeds computing candidate answer sets  returning answer
set minimal violation cost value  running candidates  here  order generate
optimal secure plans  planning frontend interrupts computation  allowing answer sets
represent secure plans considered candidates 
checking plan security done rewriting translated program wrt  candidate answer
set plan order verify whether plan secure  rewritten check program tested
separate invocation dlv kernel  details system architecture refer
 eiter et al       a 
    usage
suppose background knowledge program depicted figure   cost extensions
section     stored files crossing bk crossing plan  then  invoking
program command line
dlv fpcrossing plancrossing bk planlength    

compute optimal plans solving problem seven steps  output find 
supporting trajectory  following optimal plan 
plan   crosstogether joe  jack       cross joe       takelamp william  
crosstogether william  averell        takelamp jack  
cross jack       crosstogether joe  jack      cost     

action  cost shown colon  non zero  switch  planlength i
used set plan length  overrides plan length given query part planing
problem  using  planlength    get plans cost     cheaper plans
length 
user asked whether perform optional security check whether look
 optimal  plans  respectively  switch  fpsec used instead  fp obtain
secure plans only 
command line option  costbound n effects computation admissible plans
respect cost n   example  resource problem described section     solved
following call prototype 
dlv fpbuying bkbuying plan n      planlength     costbound    

correctly  admissible plan found  calling system without cost bound 
prototype calculates following optimal cost plan 
plan   buy newspaper          buy magazine        

cost    

current prototype supports simple bounded integer arithmetics  option  n    used
sets upper bound n      integers may used program  builtin predicate  int true integers         n   setting n high enough  taking account
outcome built in arithmetic predicates   b   c   b c  important get
correct results  details prototype given dlv k web site http   www 
dlvsystem com k  
  

fie iter   faber   l eone   p feifer   p olleres

    experiments
performance experimental results dlv k  without action costs optimal planning 
reported previous work  eiter et al       a   section  present encouraging experimental results planning action costs  particular parallel blocks world tsp 
experiments performed pentium iii    mhz machine    mb main memory running suse linux      set time limit      seconds tested instance exceeding
limit indicated   result tables 
possible  report results ccalc cmbp  two logic based planning
systems whose input languages  c  resp  ar  capabilities similar k resp  k c  
ccalc  causal calculator  ccalc  model checker languages causal theories
 mccain   turner         translates programs action language c  language
causal theories turn transformed sat problems  solved using sat
solver  mccain   turner         current version ccalc uses mchaff  moskewicz et al  
      default sat solver  minimal length plans generated iteratively increasing plan
length upper bound  ccalc written prolog  tests  used version     b
ccalc obtained  url http   www cs utexas edu users tag cc 
  trial version sicstus prolog        used encodings taken  lee   lifschitz 
      parallel blocks world adapted ccalc      encodings included
current download version system  sequential blocks world adapted encodings
adding c  command noconcurrency  resembles respective k command 
results ccalc include     sec startup time 
cmbp  conformant model based planner  cmbp   cimatti   roveri        based
model checking paradigm exploits symbolic boolean function representation techniques
binary decision diagrams  bryant         cmbp allows computing sequential minimal
length plans  user declare upper bound plan length  input language
extension ar  giunchiglia  kartha    lifschitz         unlike k action languages
c   lee   lifschitz         language supports propositional actions  cmbp
tailored conformant planning  results reported complement previous comparison
shows encoding sequential blocks world cmbp  eiter et al       a   tests 
used cmbp      available  url http   sra itc it people roveri cmbp   
      b locks w orld
tables    show results different blocks world encodings section     several
configurations  p  denotes simple instance figure    p p  instances used
previous work  eiter et al       a  erdem        
table   shows results finding shortest sequential plan  second third column
show number blocks length shortest plan  i e   least number moves  solving
respective blocks world instance  execution time solving problem using shortestplan encoding p section     shown column five  using upper bound shown fourth
column plan length  column six shows execution time finding shortest plan
incremental plan length search starting    similar method used ccalc 
remaining two columns show results ccalc cmbp 
  

fia nswer et p lanning u nder action c osts

problem
p 
p 
p 
p 
p 
p 

 blocks
 
 
 
 
  
  

min   moves    steps 
 
 
 
 
 
  

upper bound  steps
 
 
 
  
  
  

dlvk

dlvk
inc

    s
    s
    s
     s
 

    s
    s
    s
    s
    s
     s

ccalc
    s
    s
    s
     s
     s
     s

cmbp
     s
    s
    s
 

table    sequential blocks world   shortest plans

problem
p 
p 
p 
p 
p 
p 
p 

 blocks
 
 
 
 
 
  
  

 steps fixed 
 
 
 
 
 
 
 

min   moves
 
 
 
 
 
  
  

dlvk
    s
    s
    s
    s
    s
    s
   s

table    parallel blocks world   cheapest plans  minimal number moves fixed plan length   

table   shows execution times parallel blocks world fixed plan length
number moves minimized  i e  problem    section      used encoding figure   
generates parallel serializable plans  ccalc cmbp allow optimizing
criteria plan length  results dlv k here 
next  table   shows results finding shortest parallel plan  i e  problem    section      first  minimal possible number steps given  processed instance  i  using
encoding p section       ii  without costs iteratively increasing plan length
 iii  using ccalc  iteratively increasing plan length plan found  every result 
number moves first plan computed reported separately  cmbp supports
sequential planning  included comparison 
finally  table   shows results combined optimizations       parallel blocks
world outlined section      second column contains upper bound plan

upper bound
p 
p 
p 
p 
p 
p 

 
 
 
  
  
  

min   steps
 
 
 
 
 
 

dlvk
 moves
 
 
 
 

time
    s
    s
    s
 

dlvk
inc
 moves
 
 
 
  
  
  

time
    s
    s
    s
    s
    s
    s

table    parallel blocks world   shortest plan   

  

ccalc
 moves
time
 
    s
 
    s
 
    s
 
    s
  
     s
  
     s

fie iter   faber   l eone   p feifer   p olleres

  
p 
p 
p 
p 
p 
p 

upper bound
 
 
 
  
  
  

steps moves
   
   
   
   
   
     

  

dlvk

dlvk
inc

    s
    s
    s
 

    s
    s
    s
    s
 

ccalc
    s
    s
    s
     s
     s
   s

steps moves
   
   
   
   
    
    

dlvk

dlvk
inc

    s
    s
    s
   s
 

    s
    s
    s
    s
    s
   s

table    parallel blocks world        

length respective instance  following three columns present results finding
shortest among cheapest plans  i e  problem    section     
dlvk refers results combined minimal encoding p described section     
dlvk
inc refers results incrementally searching shortest among cheapest plans 

done means  costbound i command line option taking minimal
sequential costs  i e   shortest sequential plan length computed table    upper
cost limit  encodings compute serializable plans  minimal sequential length
used cost limit special case 
ccalc similar technique used ccalc encoding bound costs additive fluents  lee   lifschitz        
note incremental strategy  used dlv k
inc ccalc  takes advantage specific formulation parallel blocks world problem  general  allowing parallel actions
necessarily serializable arbitrary costs  optimal parallel cost might differ
optimal sequential solution  particular  plans longer cheapest sequential plans  which  example  coincide shortest sequential plans  may need
considered  makes incremental search solution problem    infeasible general 
last test finding cheapest among shortest plans  is  problem    section     
tested integrated encoding upper bound  p   resp  incrementally finding
shortest plan  unlike problem     cannot derive fixed cost limit sequential
solution here  really need optimize costs  makes encoding ccalc infeasible 
blocks world results blocks world experiments show dlv k solve various optimization tasks effective flexible way systems compared  hand 
already stated above  minimal plan length encodings section      solve
problems tight upper bound plan length known  iteratively increasing plan
length effective  especially upper bound much higher actual optimal solution  becomes drastically apparent execution times seem explode one instance
next  highly non linear manner table   solution p  found
reasonable time whereas p  p  could solved within time limit      seconds 
observation confirmed tables  instance p  table    etc   partly explained
behavior underlying dlv system  geared towards plan search 
general purpose problem solver uses heuristics might work well cases 
particular  answer set generation process dlv  distinction made actions
  

fia nswer et p lanning u nder action c osts

fluents  might useful planning tasks control generation answer sets resp 
plans  may part investigations 
interestingly  ccalc finds better quality parallel solutions problem     cf  table     i e 
solutions fewer moves  although significantly slower system instances 
incremental encoding problem     ccalc seems even effective system 
however  ccalc offers means optimization  allows admissible optimal
planning  makes approach flexible general  stated above  could fortunately
exploit fixed cost bound particular example ccalc  possible general
instances problem    
problem    intuitively harder simply finding shortest plan cheapest among
shortest plans general  problems always solved incrementally    
must consider plans lengths  longer plan may cheaper  cannot freeze plan
length  shortest  plan incrementally found 
      tsp
experimental results tsp variable costs reported tables      unlike
blocks world  comparable systems available  none systems supports cost
optimal planning needed solving problem  here  plan length always given
number cities 
table   shows results tsp instance austrian province capitals figure  
 nine cities     connections   without exceptional costs section      with without subscript exc table   instances reported table different cost exceptions
 we  lwe  rnd  described below 
results bigger tsp instances  given capitals    members european
union  eu  varying connection graphs exceptional costs shown table   
used flight distances  km  cities connection costs  instances tsp eu  tspeu  
generated randomly choosing given number connections possible connections    cities  note tsp eu   solution  time reported
dlvk terminated  instances first optimal plan found 
tested instances practical relevance simply randomly choosing
connections  tspeu   instance taken flight connections three carriers
 namely  star alliance  alitalia  luxair   tsp eu   included direct connections     km  capital hopping interest small airplane limited
range  instance 
instance tables    measured execution time 
without exceptional costs 
    costs connections saturdays sundays  weekends  we 
    costs connections fridays  saturdays sundays  long weekends  lwe  
random cost exceptions  rnd   added number randomly generated exceptions costs      tsp austria        instances
eu  eu  
  

fie iter   faber   l eone   p feifer   p olleres

instance
tspaustria
tspaustria exc
tspaustria we
tspaustria lwe
tspaustria rnd
tspaustria rnd
tspaustria rnd
tspaustria rnd

 cost exceptions
 
 
  
  
  
  
   
   

cost time
       s
       s
       s
       s
       s
       s
       s
       s

table    tsp results tspaustria varying exceptions

instance
tspeu  
tspeu   we
tspeu   lwe
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu  
tspeu   we
tspeu   lwe
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu  
tspeu   we
tspeu   lwe
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu  
tspeu   we
tspeu   lwe
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu  
tspeu   we
tspeu   lwe
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu   rnd

 conn 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

 except 
 
  
  
   
   
   
   
 
  
  
   
   
   
   
 
  
   
   
   
   
   
 
  
   
   
   
   
   
 
  
   
   
   
   
   
   

cost time
      s
       s
       s
       s
       s
       s
       s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
            s
           s
           s
           s
           s
           s

instance
tspeu  
tspeu   we
tspeu   lwe
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu  
tspeu   we
tspeu   lwe
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu  
tspeu   we
tspeu   lwe
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu   rnd
tspeu   rnd

 conn 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

 except 
 
  
   
   
   
   
   
   
 
   
   
   
   
   
   
   
   
   
 
   
   
   
   
   
   
   
   
   
   

cost time
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
           s
          s
         s
         s
          s
         s
          s
          s
          s
          s
          s
           s

table    tsp various instances capitals    eu members
  

fia nswer et p lanning u nder action c osts

tsp results instance tspeu   shows limits system  given data allows many
possible tours  finding optimal one gets tricky  hand  realistic instance
tspeu   real airline connections solved rather quickly  surprising 
airlines central airport  for instance vienna austrian airlines  direct connections
destinations served  allows much fewer candidate answer sets   as
reality  number airlines consider limited  e g   tsp eu   solution
two star alliance  alitalia  luxair allowed  course  cannot compete
dedicated tsp solvers algorithms  able solve much bigger tsp instances
considered here  however  knowledge  none solvers deal features
incomplete knowledge  defaults  time dependent exceptional costs  etc  directly  results even
show execution times stable yet case many exceptions  contrast  instance tsp eu  
shows exceptions cause significant speedup  due heuristics used
underlying dlv system  single better solutions faster costs spread evenly
tspeu   without exceptional costs 
note that  experimented alternative smodels translation sketched section      refrain detailed discussion here  since  i  translation optimized dlv
smodels performance worse  around factor    tested tsp instances  dlv  ii 
integrated planning frontend available smodels providing high level planning language  nevertheless  shown approach can  minor modifications  adopted
planning system based smodels 

   related work
last years  widely recognized plan length alone one criterion
optimized planning  several attempts made extend planners consider action
costs 
pyrrhus system  williams   hanks        extension ucpop planning
allows optimal planning resources durations  domain dependent knowledge
added direct heuristic search  utility model defined planning problem
used express optimization function  system supports language extension
adl  pednault         predecessor pddl  ghallab et al          algorithm
synthesis branch and bound optimization least commitment  plan space planner 
approaches based heuristic search include use a  strategy together
action costs heuristics  ephrati  pollack    mihlstein        work refanidis
vlahavas use multi criteria heuristics obtain near optimal plans  considering multiple criteria
apart plan length alone  refanidis   vlahavas         however  described heuristics
fully admissible  guarantees optimal plans certain restrictions  haslum   geffner 
       fact  heuristic state space planners able guarantee optimality 
powerful approach suggested nareyek  describes planning resources
structural constraint satisfaction problem  scsp   solves problem local search
combined global control  however  work promotes inclusion domain dependent
knowledge  general problem unlimited search space  declarative high level language provided  nareyek        
among related approaches  kautz walser generalize planning satisfiability
approach use integer optimization techniques encoding optimal planning resource pro  

fie iter   faber   l eone   p feifer   p olleres

duction consumption  kautz   walser         first  recall integer logic programming
generalizes sat  sat formula translated system inequalities  second  extend effects preconditions actions similar strips extension proposed koehler
modeling resource consumption production  koehler         kautz walser allow arbitrary
optimization functions use non declarative  low level representation based algebraic modeling language ampl  fourer  gay    kernighan         mention koehlers
strips like formalization mapped approach  however  express nondeterminism incomplete knowledge  implementation approach called ilpplan  uses ampl package  http   www ampl com    unfortunately  ampl
freely available  could compare system approach experimentally 
lee lifschitz describe extension c  action language c allows intuitive encoding resources costs means called additive fluents  lee   lifschitz 
       way admissible planning realized  optimization considered
framework far  implementation planner based language ccalc  mccain 
      already described previous section  another implementation planning system based action language c cplan  giunchiglia        ferraris   giunchiglia 
       cplan system mainly focuses conformant planning support advanced
features c   furthermore  code longer maintained 
son pontelli propose translate action language b prioritized default theory answer
set programming  allow express preferences actions rules object level
interpreter part input language  son   pontelli         however 
preferences orthogonal approach model qualitative preferences opposed
overall value function plans trajectories 

   conclusion outlook
work continues research stream pursues usage answer set programming
building planning systems offer declarative planning languages based action languages 
planning tasks specified high level abstraction  lifschitz      a      b  
representation practical planning problems  languages must high expressiveness
provide convenient constructs language elements 
towards goal  presented planning language k c   extends declarative
planning language k  eiter et al       b      a  action costs taken account
generating optimal plans  i e   plans least total execution cost  admissible plans
wrt  given cost bound  i e   plans whose total execution cost stays within given limit  basis
implementation issues  investigated computational complexity major planning tasks language  derived complexity results sharply characterizing
computational cost  furthermore  presented transformation optimal admissible
planning problems k c logic programming optimal answer set semantics  buccafurri
et al                described dlv k prototype implemented top kr tool
dlv  computes semantics 
shown  kc allows representation intricate planning problems  particular 
demonstrated variant traveling salesperson problem  tsp   could
conveniently specified kc   strength kc that  via underlying language k  states
knowledge  i e   incomplete states  suitably respected secure plans  i e   conformant plans
  

fia nswer et p lanning u nder action c osts

work circumstances  including nondeterministic action effects  k c flexible
language which  exploiting time dependent action costs  allows representation planning
various optimality criteria cheapest plans  shortest plans  combinations thereof 
experiments shown various instances problems considered  including
realistic instances tsp variant  could decently solved  hand  current
version dlvk scale large problem instances general  and  unsurprisingly 
compete high end planning tools specialized algorithms particular problem
tsp  see shortcoming  though  since main goal point demonstrate usefulness expressive capabilities formalism easily represent non trivial
planning optimization tasks  especially involved viewpoint knowledge
representation  way  non trivial instances problems medium size  which one may
often encounter  solved little effort 
several issues remain work  implementation  performance improvements
may gained via improvements underlying dlv engine  subject current work 
furthermore  alternative  efficient transformations kc logic programming might researched  e g  ones involve preprocessing planning problem performing means end analysis simplify logic program constructed 
another issue language extensions  example  crucial difference
approach resource based approaches former hinges action costs  latter
build fluent values  somewhat different view quality plan  possible way
encompass language allow dynamic fluent values contribute action costs 
needs carefully elaborated  though  deterministic planning complete knowledge extension straightforward  non deterministic domains incomplete knowledge
would possibly result ambiguities  different trajectories plan possibly yield different
costs fluent values contribute action costs  favor intuitive definition plan costs
optimality refrained extension current state 
possible extension negative action costs  useful modeling producer consumer relations among actions resources  allowing different priorities among
actions  i e   different cost levels  would increase flexibility allow optimizing different
criteria once  finally  duration actions important issue  current language 
effects actions assumed materialize next state  coding techniques 
may express delayed effects several states time and or interleaving actions  constructs
language would desirable  investigating issues part ongoing future work 

acknowledgments
grateful joohyung lee help using ccalc paul walser useful
informations ilpplan  furthermore  thank michael gelfond interesting discussions
suggestions  anonymous reviewers detailed helpful comments 
work supported fwf  austrian science funds  projects p     
z   n   european commission project fet            wasp ist           infomix 
preliminary  shorter version paper presented  th european conference
logics artificial intelligence  jelia     cosenza  italy  september      
  

fie iter   faber   l eone   p feifer   p olleres

appendix a  language k
appendix contains  shortened form  definition language k translation k
answer set programs  see  eiter et al       b      a  details examples 
a   basic syntax
assume act   f l   typ disjoint sets action  fluent type names  respectively  i e  
predicate symbols arity    disjoint sets con var constant variable symbols 
here  f l   act describe dynamic knowledge typ describes static background knowledge 
action  resp  fluent  type  atom form p t             tn    p act  resp  f l   typ   arity n
t            tn con var   action  resp  fluent  type  literal l action  resp  fluent  type 
atom negation a   alternatively    true negation symbol  define
 l   l    l   l   a  atom  set l literals consistent 
l  l     furthermore  l   resp  l   set positive  resp  negative  literals l 
set action  resp  fluent  type  literals denoted l act  resp  lf l   ltyp    furthermore  lf l typ
 
  lf l ltyp   ldyn   lf l l 
act   l   lf l typ lact  
actions fluents must declared using statements follows 
definition a    action  fluent declaration  action  resp  fluent  declaration  form 
p x            xn   requires t            tm

   

 
var n   arity p           
p l 
 

act  resp  p lf l    x            xn
ltyp      every xi occurs t            tm  

     keyword requires may omitted  causation rules specify dependencies
fluents fluents actions 
definition a    causation rule  causation rule  rule  short  expression form
caused f b            bk   bk             bl a              am            

   

f lf l  false   b            bl lf l typ   a            l  l k    n   
rules n     static rules  others dynamic rules  l      resp  n        resp 
after  omitted  l   n      caused optional 
access parts causation rule r h r     f    post    r     b            bk    post  r   
 bk             bl    pre   r     a               pre  r     am                lit r     f  b            bl  
a               intuitively  pre r    pre    r  pre  r   resp  post r    post   r  post  r  
accesses state  resp  after  action s  happen 
special static rules may specified initial states 
definition a    initial state constraint  initial state constraint static rule form    
preceded initially 
language k allows conditional execution actions  several alternative executability
conditions may specified 
  

fia nswer et p lanning u nder action c osts

definition a    executability condition  executability condition e expression form
executable b            bk   bk             bl

    

l 
act b            bl l  l k   
l      i e   executability unconditional   skipped  parts e accessed h e   
 a   pre   e     b            bk    pre  e     bk             bl    lit e     a  b            bl    intuitively 
pre e    pre   e  pre  e  refers state actions suitability evaluated 
state action execution involved  convenience  define post   e    post  e     
causal rules executability conditions must satisfy following condition 
similar safety logic programs  variable default negated type literal must occur
literal default negated type literal  safety requested variables appearing
literals  reason variables appearing fluent action literals implicitly safe
respective type declarations 
notation  causal rule  initial state constraint  executability condition r  post  pre  b  
define  r       r   r   bs  r    posts  r  pres  r  
a     p lanning omains



p lanning p roblems

definition a    action description  planning domain  action description hd  ri consists
finite set action fluent declarations finite set r safe causation rules  safe initial
state constraints  safe executability conditions contain positive cyclic dependencies among actions  k planning domain pair pd   h  adi  disjunction free
normal datalog program  the background knowledge  safe total well founded
model  cf   van gelder  ross    schlipf           ad action description  call pd
positive  default negation occurs ad 
definition a    planning problem  planning problem p   hpd  qi pair planning domain pd query q  i e  
g            gm   gm             gn    i 

    

g            gn lf l variable free  n      denotes plan length 
a   semantics
start preliminary definition typed instantiation planning domain 
similar grounding logic program  difference correctly typed
fluent action literals generated 
let pd   h  hd  rii planning domain  let  unique  answer set  gelfond   lifschitz         then   p x             xn    legal action  resp  fluent  instance action  resp  fluent  declaration form      substitution defined x            xn
  t              tm      lpd denote set legal action fluent instances  instantiation planning domain respecting type information follows 
   total well founded model  existing  corresponds unique answer set datalog program  allowing
multiple answer sets would eventually lead ambiguities language 

  

fie iter   faber   l eone   p feifer   p olleres

definition a    typed instantiation  planning domain pd   h  hd  rii  typed instantiation given pd   h  hd  rii  grounding  over con  
r     r    r r  r    r set substitutions variables r using
con   lit  r   ldyn lpd   lpd l
f l   
words  pd replace r ground versions  keep latter
rules atoms fluent action literals agree declarations  say
pd   h  hd  rii ground  r ground  moreover well typed  pd
pd coincide 
a     tates



ransitions

definition a    state  state transition  state w r t planning domain pd consistent set
lf l  lit pd  lit pd    legal fluent instances negations  state transition
tuple   hs  a  s  s  s  states lact lit pd  set legal action
instances pd 
observe state necessarily contain either f f legal instance f
fluent  may even empty  s      state transitions constrained  done
definition legal state transitions below  proceed analogy definition answer sets
 gelfond   lifschitz         considering first positive  i e   involving positive planning domain 
general planning problems 
follows  assume pd   h  hd  rii well typed ground planning domain
unique answer set   pd  respective concepts defined
typed grounding pd 
definition a    legal initial state  state   legal initial state positive pd   
least set  w r t    post c    implies h c  s    initial state constraints
static rules c r 
positive pd state s  set l  
act called executable action set w r t  s 
exists executability condition e r h e     a   pre    e lf l typ sm  
 

pre   e l 
act a  pre  e  lact sm       note definition allows modeling
dependent actions  i e  actions depend execution actions 
definition a     legal state transition  given positive pd  state transition   hs  a   
called legal  executable action set w r t    minimal consistent set satisfies
causation rules w r t    is  every causation rule r r   i  post r     
 ii  pre r  lf l typ    iii  pre r  lact hold  h r      false 
h r  s   
extended general well typed ground pd containing default negation using
gelfond lifschitz type reduction positive planning domain  gelfond   lifschitz        
definition a     reduction  let pd ground well typed planning domain  let  
hs  a  s  state transition  then  reduction pd   h  hd  rt ii pd planning
domain rt obtained r deleting
  

fia nswer et p lanning u nder action c osts

   r r  either post  r  s       pre  r  sam       
   default literals l  l l  remaining r r 
note pd positive ground  extend definitions follows 
definition a     legal initial state  executable action set  legal state transition  planning
domain pd  state s  legal initial state  s  legal initial state pd h  s    set
executable action set w r t  state s  executable w r t  pd hs a i   and  state transition
  hs  a  s  legal  legal pd  
a     p lans
definition a     trajectory  sequence state transitions   hhs     a    s  i  hs    a    s  i        
hsn      sn ii  n    trajectory pd  s  legal initial state pd hs i    ai   si i 
  n  legal state transitions pd 
n        hi empty s  associated explicitly 
definition a     optimistic plan  sequence action sets ha             ai i     optimistic
plan planning problem p   hpd  qi  trajectory   hhs     a    s  i  hs    a    s  i         
hsi    ai   si ii exists pd accomplishes goal  i e    g           gm   si  gm             gn  
si    
optimistic plans amount plans  valid plans etc defined literature  term
optimistic stress credulous view definition  respect incomplete fluent
information nondeterministic action effects  cases  execution optimistic plan
p might fail reach goal  thus resort secure plans 
definition a     secure plans  alias conformant plans   optimistic plan ha             secure plan  every legal initial state   trajectory   hhs    a    s  i          hsj    aj   sj ii
  j n  holds  i  j   n accomplishes goal   ii  j   n  j  
executable sj w r t  pd  i e   legal transition hs j   aj     sj   exists 
note plans admit general concurrent execution actions  call plan ha            
sequential  or non concurrent    a j        j n 
a   macros
k includes several macros shorthands frequently used concepts  let l  
act denote
action atom  f lf l fluent literal  b  possibly empty  sequence b             bk   bk            
bl bi lf l typ                l   possibly empty  sequence              
am             aj l  j              n 
inertia allow easy representation fluent inertia  k provides
inertial f b a 

defaults



caused f  f  b f  a 

default value fluent expressed shortcut
default f 



caused f  f 

effect unless causation rule provides evidence opposite value 
  

fie iter   faber   l eone   p feifer   p olleres

totality

reasoning incomplete  total knowledge k provides  f positive  
total f b a 



caused f f  b a 
caused f f  b a 

instance useful model non deterministic action effects  discussion
full impact statement modeling planning incomplete knowledge non determinism 
refer previous paper language k  eiter et al       b  
state integrity

integrity constraints refer preceding state  k provides
forbidden b a 

non executability



caused false b a 

specifying action executable  k provides

nonexecutable b 



caused false a  b 

definition  nonexecutable overrides executable case conflicts 
sequential plans exclude simultaneous execution actions  k provides
noconcurrency 



caused false a    a   

a  a  range possible actions     a  lpd lact a     a   
macros  b  resp  a  omitted  b  resp  a  empty 

appendix b  proofs
proof theorem      membership  i   problems np resp  npmv  since l polynomial size p  optimistic plan p   ha             al p supporting trajectory
  ht            ti p guessed and  proposition      verified polynomial time  furthermore  costp  p   b efficiently checked  since costp  p   easily computed  all costs
constants  
hardness  i   k fragment k c   k planning problem viewed problem
deciding existence resp  finding admissible plan wrt  cost    previously shown
 eiter et al       b   deciding existence optimistic plan given k planning problem
np hard fixed plan length l  hence  np hard kc  
show finding optimistic plan hard npmv reduction well known
sat problem  cf   papadimitriou         whose instances cnfs   c   ck clauses ci  
li   li mi   li j classical literal propositional atoms x    x             xn   
consider following planning domain pd  
fluents  
actions  

x          xn   state   state  
c  costs          ck costs   
ax          axn  
initially   total x          total xn  
caused state  
always  
caused state  state  
executable c   l               l  m   
forbidden  l               l  m    c   

executable ck  lk              lk mk  
forbidden  lk              lk mk   ck  
executable ax  x    forbidden x    ax   

executable axn xn   forbidden xn   axn  

  

fia nswer et p lanning u nder action c osts

fluents xi state  total statements initially section encode candidate truth assignments  subsequent statements force c j executed iff corresponding
clause violated truth assignment encoded initial state  final pairs executable
forbidden statements force actions ax executed iff corresponding fluents x hold 
necessary directly extract computed truth assignments plan 
since dealing function class  fluent state  identifies state time   
consider planning problem p   hpd   state     i  clearly  optimistic plan
p p corresponds truth assignment p x vice versa  costp  p   number
clauses violated p   thus  admissible optimistic plans p wrt  cost   correspond    
satisfying assignments   clearly  constructing p efficiently possible 
constructing satisfying truth assignment corresponding plan p  because actions
axi    concludes hardness proof 
membership  ii   since security optimistic plan admissible wrt  cost k checked 
proposition      call p   oracle  membership p  resp  p  mv follows
analogous considerations  i   where oracle needed  
hardness  ii   decision variant  p   hardness immediately inherited p  completeness deciding existence secure plan problem language k 
hardness even fixed plan length  eiter et al       b   plan computation variant  give
reduction following p  mv complete problem  instance open qbf
q z    xy  x  y  z 
x   x            xl     y            ym   z   z            zn   respectively   x  y  z 
 w l o g    cnf formula x    z  solutions s i  truth assignments z
q z  satisfied 
suppose  x  y  z    c        ck ci   ci   ci   ci     consider following
planning domain pdq z  q z   variant planning domain given proof
theorem      eiter et al       b  
fluents  
x          xl   y          ym   z          zn   state   state  
actions  
az  costs          azn costs   
initially   total x          total xl  
caused state  
always  
caused state  state  
executable az    executable az          executable azn  
caused x  x    caused x  x   

caused xl xl   caused xl xl  
total y  state         total ym state  
caused z  az    caused z  az   

caused zn azn   caused zn azn  
forbidden  c       c       c    state  

forbidden  ck      ck      ck   state  
 x 

  x  many legal initial states s            s  pdq z    correspond    
possible truth assignments x initial states contain state   starting initial
state si   executing set actions represents truth assignment variables z  since
  

fie iter   faber   l eone   p feifer   p olleres

actions always executable     z  executable action sets a            a  z    represent
truth assignments z 
 y  
pair si aj exist   y   many successor state candidates si             si    
contain fluents according truth assignment x represented   fluents according
truth assignment z represented j   fluents according truth assignment  
fluent state   candidate states  satisfying clauses  x  y  z  legal 
virtue forbidden statements 
hard see optimistic plan form p   ha    where a   azi   zi z  
goal state  exists wrt  pdq z  iff assignment variables x z
formula  x  y  z  satisfied  furthermore  p secure iff a  represents assignment
variables z that  regardless assignment variables x chosen
 corresponding legal initial state    assignment variables
clauses  x  y  z  satisfied  i e   least one state si k reachable si executing
a     si k contains state   words  p secure iff  x  y  z  true  thus 
admissible secure plans pdq z  wrt  cost    correspond     assignments z
q z  true 
since pdq z  constructible  x  y  z  polynomial time  follows computing
secure plan p   hpdq z    qi  q   state         p  mv hard 
 
proof theorem      membership  i   concerning membership  performing binary search
range     max   where max upper bound plan costs plan polynomial
length l given l times sum action costs  find least integer v
optimistic plan p p admissible wrt  cost v exists  if optimistic plan exists  
clearly  costp  p     v costp   v  thus plan p optimal  since max
single exponential representation size p  binary search  thus computing cost p  
is  theorem      feasible polynomial time np oracle  subsequently  construct
optimistic plan p costp  p     costp extending partial plan pi   ha            ai i 
             l   step step follows  let    a               set legal action
instances  initialize bi      ask oracle whether pi completed optimistic
plan p   ha            al admissible wrt  costp ai    bi      a      answer
yes  update bi      bi      a     else leave bi   unchanged  repeat test
aj   j                 m  resulting bi   action set pi     ha            ai   ai  
ai     bi   completed optimistic plan admissible wrt  cost p   thus  ai  
polynomial time constructible np oracle 
summary  construct optimal optimistic plan polynomial time np oracle 
thus  problem fp   
hardness  i   show hardness plan length l     reduction problem max weight
sat  papadimitriou         instance sat instance   c   ck proof
theorem      i   plus positive integer weightsp
w                k  then  s i  contains
truth assignments x wsat        ci  true wi maximal 
end  take planning domain pd proof theorem     modify
cost ci wi                k  thus constructing new planning domain pd   consider
planning problem pi   hpdi   state     i  since actions cj actions nonzero
cost  plan  corresponding top
truth assignment  
p associated sum weights
violated clauses  wvio        ki   wi   wsat     since ki   wi constant i  minimizing
  

fia nswer et p lanning u nder action c osts

wvio    equivalent maximizing wsat     hence  one to one correspondence
optimal optimistic plans pi  for wvio    minimal  maximal truth assignments i 
furthermore  computing pi extracting max weight sat solution optimal
plan p efficiently possible  proves fp   hardness 
membership  ii   proof similar membership proof  i   uses oracle asks
completion partial secure plan p   ha            ai secure plan p   ha            al
ai    bi      aj    p admissible wrt  costp   rather partial optimistic plan 
oracle is  easily seen  p    thus  computing optimal secure plan f p   
hardness  ii   show hardness reduction following problem  f p  complete  cf   krentel          given open qbf q z    xy  x  y  z  proof
theorem      ii   compute lexicographically first truth assignment z q z 
satisfied 
accomplished changing cost action az pdq z     ni  
             n  let pd    q z   resulting planning domain  since cost az  i e   assigning
zi value true  greater sum costs az j     j n  optimal
secure plan planning problem hpd    q z    state       i amounts lexicographically
first truth assignment z q z  satisfied  thus  fp   hardness problem follows 
 
proof theorem      prove result applying well known splitting set theorem
logic programs  lifschitz   turner         theorem applies logic programs
split two parts one them  bottom part  refer predicates defined
top part all  answer sets bottom part extended answer sets
whole program looking remaining  top  rules  informally  splitting set
set u ground literals defining bottom part bu    program  answer set sb
bu    used reduce remaining rules   b u    program eu     bu     sb  
involving classical literals occur b u     evaluating literals b u   
wrt  sb   answer set se eu     bu     sb    set   sb se answer set
original program 
disregarding weak constraints  split program lp w  p  bottom part consisting
lp pnc    pnc p cost information stripped off  top part containing
remaining rules  derive correspondence optimistic plans p answer sets
lpw  p  similar correspondence result lp p nc    eiter et al       a  
detail  theorem      eiter et al       a  states k planning problem p correspondence answer sets lp p  supporting trajectories optimistic plans
p   ha            al items  i   ii   costs discarded  thus  answer set   lp pnc  
corresponds trajectory   optimistic plan p   pnc vice versa 
follows  talking lp p nc   lpw  p   mean respective grounded
logic programs  lpw  p  augments lp pnc   rules     weak constraints      let u  
lit lp pnc    set literals occurring lp p nc    clearly  u splits lpw  p  defined
 lifschitz   turner         disregard weak constraints lp w  p   since rules form
    introduce new head literals  consequently  get b u  lpw  p     lp pnc    then 
answer set   lp pnc    rule eu  lpw  p    bu  lpw  p        form
costa  x            xn   t  c     body 
  

fie iter   faber   l eone   p feifer   p olleres

fact rules positive  conclude respect split u  
answer set   lp pnc   induces unique answer set   lpw  p   therefore  modulo
costs  correspondence supporting trajectories candidate answer sets claimed
follows directly theorem      eiter et al       a  
remains prove costp  p     costlpw  p   s  holds candidate answer sets corresponding optimistic plan p   ha             al p  correspondence shown above 
action p x            xn   aj corresponds exactly one atom p x             xn   j    asj  
j             l   therefore  p x            xn   declared non empty cost part     
well definedness  modulo x            xn   exactly one fact costp  x            xn   j    c 
model eu  lpw  p    bu  lpw  p    s  
furthermore  definition      c   costj  p x            xn     i e   cost action
instance p x            xn   time j  consequently 
pl
p violation value weak constraint wc
w
form     p lp  p  costwc  s   
j  
p x       xn  aj costj  p x            xn     since
violation values stem weak constraints      total cost lpw  p   s    costp  p   
proves result 
 

references
blum  a  l     furst  m  l          fast planning planning graph analysis  artificial
intelligence             
bonet  b     geffner  h          planning incomplete information heuristic search
belief space  chien  s   kambhampati  s     knoblock  c  a   eds    proceedings
fifth international conference artificial intelligence planning scheduling  aips    
pp        breckenridge  colorado  usa 
bryant  r  e          graph based algorithms boolean function manipulation  ieee transactions computers  c               
buccafurri  f   leone  n     rullo  p          strong weak constraints disjunctive datalog 
dix  j   furbach  u     nerode  a   eds    proceedings  th international conference
logic programming non monotonic reasoning  lpnmr     no       lecture
notes ai  lnai   pp       dagstuhl  germany  springer verlag 
buccafurri  f   leone  n     rullo  p          enhancing disjunctive datalog constraints  ieee
transactions knowledge data engineering                
cimatti  a     roveri  m          conformant planning via symbolic model checking  journal
artificial intelligence research             
dantsin  e   eiter  t   gottlob  g     voronkov  a          complexity expressive power
logic programming  acm computing surveys                
dimopoulos  y   nebel  b     koehler  j          encoding planning problems nonmonotonic
logic programs  proceedings european conference planning       ecp     
pp          springer verlag 
eiter  t   faber  w   leone  n     pfeifer  g       a   declarative problem solving using
dlv system  minker  j   ed    logic based artificial intelligence  pp         kluwer
academic publishers 
  

fia nswer et p lanning u nder action c osts

eiter  t   faber  w   leone  n   pfeifer  g     polleres  a       b   planning incomplete
knowledge  lloyd  j   dahl  v   furbach  u   kerber  m   lau  k  k   palamidessi  c  
pereira  l  m   sagiv  y     stuckey  p  j   eds    computational logic   cl       first international conference  proceedings  no       lecture notes ai  lnai   pp         
london  uk  springer verlag 
eiter  t   faber  w   leone  n   pfeifer  g     polleres  a       a   answer set planning
action costs  flesca  s   greco  s   ianni  g     leone  n   eds    proceedings
 th european conference artificial intelligence  jelia   no       lecture notes
computer science  pp         
eiter  t   faber  w   leone  n   pfeifer  g     polleres  a       b   answer set planning action costs  tech  rep  infsys rr             institut fur informationssysteme  technische
universitat wien 
eiter  t   faber  w   leone  n   pfeifer  g     polleres  a       a   logic programming approach
knowledge state planning  ii  dlv k system  artificial intelligence              
    
eiter  t   faber  w   leone  n   pfeifer  g     polleres  a       b   logic programming approach
knowledge state planning  semantics complexity  appear acm transactions
computational logic 
ephrati  e   pollack  m  e     mihlstein  m          cost directed planner  preliminary report 
proceedings thirteenth national conference artificial intelligence  aaai     
pp             aaai press 
erdem  e          applications logic programming planning  computational experiments 
unpublished draft  http   www cs utexas edu users esra papers html 
faber  w     pfeifer  g   since        dlv homepage   http   www dlvsystem com  
ferraris  p     giunchiglia  e          planning satisfiability nondeterministic domains 
proceedings seventeenth national conference artificial intelligence  aaai     july
   august          austin  texas usa  pp          aaai press   mit press 
fourer  r   gay  d  m     kernighan  b  w          ampl  modeling language mathematical
programming  duxbury press 
gelfond  m     lifschitz  v          classical negation logic programs disjunctive
databases  new generation computing            
ghallab  m   howe  a   knoblock  c   mcdermott  d   ram  a   veloso  m   weld 
d     wilkins  d         
pddl planning domain definition language  tech  rep   yale center computational vision control  available
http   www cs yale edu pub mcdermott software pddl tar gz 
giunchiglia  e          planning satisfiability expressive action languages  concurrency 
constraints nondeterminism  cohn  a  g   giunchiglia  f     selman  b   eds    proceedings seventh international conference principles knowledge representation
reasoning  kr        april        breckenridge  colorado  usa  pp          morgan
kaufmann 
  

fie iter   faber   l eone   p feifer   p olleres

giunchiglia  e   kartha  g  n     lifschitz  v          representing action  indeterminacy
ramifications  artificial intelligence             
giunchiglia  e     lifschitz  v          action language based causal explanation  preliminary report  proceedings fifteenth national conference artificial intelligence
 aaai      pp         
haslum  p     geffner  h          admissible heuristics optimal planning  chien  s   kambhampati  s     knoblock  c  a   eds    proceedings fifth international conference
artificial intelligence planning scheduling  aips     pp          breckenridge  colorado  usa  aaai press 
kautz  h     walser  j  p          state space planning integer optimization  proceedings
  th national conference artificial intelligence  aaai      pp         
koehler  j          planning resource constraints  proceedings   th european
conference artificial intelligence  ecai     pp         
krentel  m          generalizations opt p polynomial hierarchy  theoretical computer
science                
lee  j     lifschitz  v          additive fluents  provetti  a     cao  s  t   eds    proceedings
aaai      spring symposium answer set programming  towards efficient scalable
knowledge representation reasoning  pp          stanford  ca  aaai press 
lifschitz  v     turner  h          splitting logic program  van hentenryck  p   ed    proceedings   th international conference logic programming  iclp     pp       
santa margherita ligure  italy  mit press 
lifschitz  v     turner  h          representing transition systems logic programs  gelfond 
m   leone  n     pfeifer  g   eds    proceedings  th international conference logic
programming nonmonotonic reasoning  lpnmr     no       lecture notes ai
 lnai   pp         el paso  texas  usa  springer verlag 
lifschitz  v          foundations logic programming  brewka  g   ed    principles knowledge representation  pp         csli publications  stanford 
lifschitz  v       a   action languages  answer sets planning  apt  k   marek  v  w  
truszczynski  m     warren  d  s   eds    logic programming paradigm    year
perspective  pp          springer verlag 
lifschitz  v       b   answer set planning  schreye  d  d   ed    proceedings   th
international conference logic programming  iclp     pp        las cruces  new
mexico  usa  mit press 
mccain  n          causal calculator homepage   http   www cs utexas edu 
users tag cc  
mccain  n     turner  h          causal theories actions change  proceedings
  th national conference artificial intelligence  aaai      pp         
mccain  n     turner  h          satisfiability planning causal theories  cohn  a  g  
schubert  l     shapiro  s  c   eds    proceedings sixth international conference principles knowledge representation reasoning  kr     pp          morgan kaufmann
publishers 
  

fia nswer et p lanning u nder action c osts

moskewicz  m  w   madigan  c  f   zhao  y   zhang  l     malik  s          chaff  engineering
efficient sat solver  proceedings   th design automation conference  dac      
las vegas  nv  usa  june              pp          acm 
nareyek  a          beyond plan length criterion  local search planning scheduling  ecai      workshop  vol       lecture notes computer science  pp       
springer 
niemela  i          logic programs stable model semantics constraint programming
paradigm  niemela  i     schaub  t   eds    proceedings workshop computational aspects nonmonotonic reasoning  pp        trento  italy 
papadimitriou  c  h          computational complexity  addison wesley 
pednault  e  p  d          exploring middle ground strips situation calculus  proceedings  st international conference principles knowledge representation reasoning  kr     pp          toronto  canada  morgan kaufmann publishers 
inc 
refanidis  i     vlahavas  i          framework multi criteria plan evaluation heuristic
state space planning  ijcai    workshop planning resources 
selman  a  l          taxonomy complexity classes functions  journal computer
system sciences                
simons  p   niemela  i     soininen  t          extending implementing stable model
semantics  artificial intelligence              
smith  d  e     weld  d  s          conformant graphplan  proceedings fifteenth
national conference artificial intelligence   aaai     pp          aaai press  
mit press 
son  t  c     pontelli  e          reasoning actions prioritized default theory  flesca 
s   greco  s   ianni  g     leone  n   eds    proceedings  th european conference
artificial intelligence  jelia   no       lecture notes computer science  pp         
subrahmanian  v     zaniolo  c          relating stable models ai planning domains 
sterling  l   ed    proceedings    th international conference logic programming 
pp          tokyo  japan  mit press 
van gelder  a   ross  k     schlipf  j          well founded semantics general logic
programs  journal acm                
weld  d  s   anderson  c  r     smith  d  e          extending graphplan handle uncertainty
  sensing actions  proceedings fifteenth national conference artificial intelligence   aaai     pp          aaai press   mit press 
williams  m     hanks  s          optimal planning goal directed utility model 
hammond  k  j   ed    proceedings second international conference artificial intelligence planning systems  aips      pp          aaai press 

  


