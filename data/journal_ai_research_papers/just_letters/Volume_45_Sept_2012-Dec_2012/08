journal artificial intelligence research                  

submitted        published      

tractable set constraints
manuel bodirsky

bodirsky lix polytechnique fr

ecole polytechnique  lix
 umr      du cnrs 
      palaiseau  france

martin hils

hils math univ paris diderot fr

institut de mathematiques de jussieu
 umr      du cnrs 
universite paris diderot paris  
ufr de mathematiques
      paris cedex     france

abstract
many fundamental problems artificial intelligence  knowledge representation 
verification involve reasoning sets relations sets modeled
set constraint satisfaction problems  set csps   problems frequently intractable 
several important set csps known polynomial time tractable 
introduce large class set csps solved quadratic time  class 
call ei  contains previously known tractable set csps  new
ones crucial importance example description logics  class ei set
constraints elegant universal algebraic characterization  use show
every set constraint language properly contains ei set constraints already
finite sublanguage np hard constraint satisfaction problem 

   introduction
constraint satisfaction problems computational problems where  informally  input
consists finite set variables finite set constraints imposed variables 
task decide whether assignment values variables
constraints simultaneously satisfied  set constraint satisfaction problems special
constraint satisfaction problems values sets  constraints might 
instance  force one set includes another set x  one set x disjoint another
set y  constraints might ternary  or  generally  finite arity  
constraint intersection two sets x contained z  symbols
px x yq z 
systematically study computational complexity constraint satisfaction problems  turned fruitful approach consider constraint satisfaction problems
csppq set allowed constraints formed fixed finite set relations
r dk  possibly infinite  common domain d  example  equals q 
rational numbers  tu usual order rationals  csppq
problem deciding whether given set  binary  constraints form x
common solution rational numbers  way parametrizing conc
    
ai access foundation  rights reserved 

fibodirsky   hils

straint satisfaction problem constraint language led many strong algorithmic
results  e g   bulatov   dalmau        idziak  markovic  mckenzie  valeriote    willard 
      barto   kozik        bodirsky   kutz        bodirsky   kara         many
powerful hardness conditions large classes constraint satisfaction problems  schaefer 
      bulatov  krokhin    jeavons        bulatov              bodirsky   kara        
set constraint language set relations r pp pnqqk common domain
p pnq set subsets natural numbers  moreover  require
relation r defined boolean combination equations signature       c 
      function symbols intersection  union  complementation  empty
full set  respectively  details formal definition set constraint languages
found section    section    give many examples set constraint languages 
choice n notational convenience  could selected infinite set
purposes  e g   rn instead n  natural choice spatial reasoning  one may even
replace p pnq infinite boolean algebra  see theorem     
following  set constraint satisfaction problem  set csp  problem form
csppq finite set constraint language   shown marriott odersky
set csps contained np 
drakengren jonsson        initiated search set csps solved
polynomial time  showed csppt      uq solved polynomial time 

x holds iff x subset equal y 
x    holds iff x disjoint sets 
x holds iff x distinct sets 
showed csppq solved polynomial time relations
defined formulas form
x 

y      xk yk   x  y 

x 

y      xk yk   x     y 

form

x            xk   y            yk necessarily distinct variables  drakengren   jonsson 
      thm       call set relations defined way drakengren jonssons set constraint language  easy see algorithm
present runs time quadratic size input  hand  show
contains relation defined x  y    x  y  relation defined
x  x    x  x  problem csppq np hard  drakengren   jonsson       
thm      
    contributions outline 
present significant extension drakengren jonssons        set constraint language  section    whose csp still solved quadratic time input size  section     call set constraint language ei  unlike drakengren jonssons set
   

fitractable set constraints

constraint language  language contains ternary relation defined px x q z 
relation particular interest description logics discuss
below  moreover  show extension ei contains finite sublanguage
np hard set csp  section     using concepts model theory universal
algebra  sense  present maximal tractable class set constraint satisfaction
problems 
algorithm based concept independence constraint languages
discovered several times independently   s  lassez   mcaloon        jonsson  
backstrom        marriott   odersky        see koubarakis        broxvall  jonsson 
  renz        cohen  jeavons  jonsson    koubarakis         however  apply
concept twice novel  nested way  leads two level resolution procedure
implemented run quadratic time  technique use prove correctness
algorithm important contribution paper  believe similar
approach applied many contexts  technique inspired already
mentioned connection universal algebra 
    application areas related literature
mention three different contexts set constraints appeared literature 
      set constraints programming languages 
set constraints find applications program analysis  here  set constraint form
x   x set expressions  examples set expressions    denoting
empty set   set valued variables  union intersection sets  expressions
form f pz    z  q f function symbol z    z  set expressions 
unfortunately  worst case complexity reasoning tasks considered
setting high  often exptime hard  for survey this  see aiken        
recently  shown quantifier free combination set constraints  without
function symbols  cardinality constraints  quantifier free pressburger arithmetic 
satisfiability problem np  kuncak   rinard         logic  called qfbapa 
interesting program verification  kuncak  nguyen    rinard        
      tractable description logics 
description logics family knowledge representation formalisms used
formalize reason concept definitions  computational complexity
computational tasks studied various formalisms usually quite high 
however  last years series description logics  example el  el   horn fl   
various extensions fragments  kusters   molitor        baader        baader 
brandt    lutz        krotzsch  rudolph    hitzler         discovered
crucial tasks e g  entailment  concept satisfiability knowledge base satisfiability
decided polynomial time 
two basic assertions made el
horn fl  c    c   there
c  c    c  x c  c   every c  c  c     concept
names c    c    c    ei set constraints  latter treated
   

fibodirsky   hils

framework drakengren jonsson  none description logics tractable
knowledge base satisfiability problem contains ei set constraints 
      spatial reasoning 
several spatial reasoning formalisms  like rcc   rcc    closely related set constraint satisfaction problems  formalisms allow reason relations
regions  fundamental formalism rcc    see  e g   jonsson   drakengren        
one think region non empty set  possible  binary  relationships containment  disjointness  equality  overlap  disjunctive combinations thereof  thus 
exclusion empty set prominent difference set constraint languages studied drakengren jonsson        contained class set constraint
languages considered rcc   fragments  see section  
csp rcc   csps reducts set csps  proposition    

   constraint satisfaction problems
use existing terminology logic model theory  convenient describe
constraint languages structures  see  e g   hodges         structure tuple
pd  f   f           r   r         q set  the domain    function
dki  where ki called arity    ri relation d  i e   subset
dli  where li called arity ri    function assume
function symbol denote   relation ri relation symbol
denote ri   constant symbols treated   ary function symbols 
set relation function symbols structure called signature  
say  structure  signature contains relation symbols
function symbols  say relational structure  context
constraint satisfaction  relational structures called constraint languages 
constraint language   called sublanguage  or reduct  constraint language
relations   subset relations  and called expansion     
let relational structure domain finite signature   constraint
satisfaction problem following computational problem  denoted csppq 
given finite set variables v conjunction finitely many atomic formulas
form rpx            xk q  x            xk p v r p   satisfiable   is 
exist assignment   v every constraint rpx            xk q input
pspx  q          spxk qq p r  
mapping called solution instance csppq  conjuncts
called constraints  note introduce constraint satisfaction problems
csppq finite constraint languages  i e   relational structures finite relational
signature 

example    problem cspppq  qq problem deciding whether given set
constraints form x solution simultaneously satisfies constraints 
   

fitractable set constraints

   set constraint languages
section  give formal definitions set constraint languages  let structure domain p pnq  set subsets natural numbers  signature
t      c      u 



  binary function symbol denotes intersection  i e    s x 
  binary function symbol union  i e    s y 

c unary function symbol complementation  i e   cs function maps
n nzs 
    constants  treated   ary function symbols  denoting empty set
full set n  respectively 

h

sometimes  simply write   function  s   function  s   i e  
distinguish function symbol respective function  use symbols
     symbols x  prevent confusion meta mathematical usages x
text 
set constraint language relational structure whose relations quantifier free
definition s  always allow equality first order formulas  equality symbol
always interpreted true equality relation domain structure 
write x abbreviation x   x 
example    ternary relation px  y  z q
definition z   px   q x   s 

p p pn q    x   z

 

quantifier free

theorem    see marriott   odersky        proposition       let set constraint
language finite signature  csppq np 
easy see np hard set csps  shown next example 
example    consider set constraint language contains eight relations

tpx  y  zq   x         z  u
tpx  y  zq   x         z  u
tpx  y  zq   x         z  u
tpx  y  zq   x         z  u
tpx  y  zq   x         z  u
tpx  y  zq   x         z  u
tpx  y  zq   x         z  u
tpx  y  zq   x         z  u  
set csp relations well known   sat problem  npcomplete  garey   johnson        
well known structure pp pnq        c      q boolean algebra 
   

fibodirsky   hils

  playing role false    playing role true 
c playing role


 

    playing role      respectively 

refer work koppelberg        background boolean algebras 
confuse logical connectives connectives boolean algebras  always
use symbols       c instead usual function symbols       boolean
algebras  facilitate notation  write x instead cpxq  x instead
p x q 
assume terms functional signature
t      c      u written


 inner  conjunctive normal form  cnf   i e   ni  nj   lij lij either
form x form x variable x  note every term t      c      u rewritten equivalent term form  using usual laws boolean algebras  boole 
       allow special
case n    in case becomes     special case
ni
ni    in case j   lij becomes     refer ci   tlij     j ni u
 inner  clause t  lij  inner  literal ci   say set inner clauses
satisfiable exists assignment v p pnq inner clauses 

union evaluation literals equals n  this case formula
n
i  ci   satisfying assignment  
example    inequality x p pnq equivalently written py   xq px   q   
formula  two inner clauses  positive negative inner literal 
assume quantifier free formulas signature
t      c      u written

mi
 outer  conjunctive normal form  cnf   i e  
j   lij lij either
i 
form    a positive  outer  literal   form    a negative  outer  literal   
again  well known easy see every quantifier free formula find
formula form equivalent every boolean algebra  refer
ci   tlij     j mi u  outer  clause   lij  outer  literal ci  
whenever convenient  identify set clauses 
example    consider formula px   z q   px   z q  rewritten
px   z q px   z q  subsequently replace inequality literals x
py   xq   px   q    see example     arrive formula discussed
normal form  two outer clauses  one two positive outer literals 
two negative outer literals 
mentioned introduction  csps reducts rcc    and therefore
many reducts rcc    formulated set csps  network satisfaction problem rcc   seen csp following structure rcc   domain
p pnqzthu binary relations given follows  relation r rcc  
exists quantifier free t      c      u formula px    x  q ps    s  q p r
s  s  non empty  ps    s  q true s  clear
finitely many inequivalent quantifier free formulas language t      c      u 
hence rcc   finitely many relations 
   

fitractable set constraints

proposition    let reduct rcc    exists set constraint language
csppq csppq problem 
proof  let             n formulas define relations  which domain
p pnqzthu   let structure domain p pnq relations r            rn defined
            n s  is  difference additional element
thu  appears none relations   prove every finite
conjunction atomic formulas form ri px            xk q satisfiable
conjunction satisfiable   satisfiable clearly satisfiable
since induced substructure   conversely  satisfiable  
solution must property spxi q h  xi appear
constraint  since constraints force arguments non empty   hence  setting
spxi q non empty subset n still solution  implies claim 
proposition   shows class set csps contains class csps reducts
rcc    inclusion clearly strict  set csps cannot formulated
csps reducts rcc    since relations set constraint languages arbitrary
arity  reducts rcc   contain binary relations 

   horn horn set constraints
section  study horn horn set constraints  class set constraints admits
intuitive syntactic description thus easy define  universal algebraic
considerations class section     lead us another class set constraints  called
ei introduced section      class strictly contains class horn horn set
constraints  universal algebraic description key maximality result
prove section    tractability  set constraint languages ei allow
 linear time  reduction satisfiability horn horn clauses  see proposition      note
classes set constraints  horn horn ei  studied before 
    horn horn relations
definition    quantifier free formula called horn horn
   every outer clause outer horn  i e   contains one positive outer literal 
   every inner clause positive outer literals inner horn  i e   contains one
positive inner literal 
relation r p pnqk called
outer horn defined conjunction outer horn clauses 
inner horn defined formula form pc      ck q
ci inner horn 

 

horn horn defined horn horn formula s 
example    inequality

horn horn  recall may defined py   xq px   yq   
   

fibodirsky   hils

example    using previous example  relation
easily seen horn horn  too 
example    ternary relation tpx  y  z q   x  
horn horn definition x     z   

tpx  y  u  vq   x   u vu

zu  encountered above 

proposition    drakengren jonssons set constraint language contains horn horn
relations 
proof  disjointness relation    definition x      inner horn 
inequality relation horn horn since inner clauses definition py   xq px   q
  one positive inner literal  inclusion relation x definition
  x    inner horn 
horn horn preserved adding additional outer disequality literals outer
clauses  relations considered drakengren jonssons language horn horn 
    universal algebraic preliminaries
see section  class horn horn formulas preserved several
important functions defined set subsets natural numbers 
definition   
let   pp pnqq  p pnq function maps pair sets ps    s  q
set t a   p s  u t a     p s  u 

denote fin set finite non empty subsets n  let f   p pnq p pfin q 
f ps q   ts 

  s  finite non emptyu  

let g   n fin bijection  since sets countable  bijection exists  
let e   p pnq p pnq defined
eps q tg  pt q  

p f ps qu  

let ei function defined eipx  q epipx  qq 
intuitively  functions e ei designed forget unions  this
formalized definition      preserving basic operations  see lemma
   proposition   case e  
definition    let f   pp pnqqk p pnq function  r p pnql relation 
say f preserves r following holds  a            ak p pp pnqql
pf pa            ak  q          f pa l           akl qq p r ai p r k  f preserve r 
say f violates r  say f strongly preserves r a            ak p pp pnqql
pf pa             ak  q          f pa l           akl qq p r ai p r k 
first order formula defines relation r s  f preserves  strongly preserves 
r  say f preserves  strongly preserves    finally  g   pp pnqql p pnq
function  say f preserves  strongly preserves  g preserves  strongly
preserves 
 
graph g  i e   relation px            xl   g px            xl qq   x            xl n  
   

fitractable set constraints

note injective function f preserves function g  strongly preserves
g 
example    consider function f   pp pnqq  p pnq  px  q x   y  f preserves
  since x   x    y  whenever x x  y  y  hand  f strongly
preserve   shown f pn  hq f ph  nq 
fact    mapping isomorphism s  s 
proof  mapping
inverted mapping sends n ta    a p
u  ta    a   p u   straightforward verify strongly preserves       c       
clearly  ipx  q h x

h 

similarly  since natural numbers partitioned even odd numbers 
ipx  q n x n 
let s  s  subsets n  verify preserves c show
ipcps    s  qq  definition equal ips    s  q  equals cpips    s  qq  suppose
 a    then 
p ps       q  

p s 

a  r s 
 a  r ips   s q
p ips   s q

argument  a 
even strongly preserves c 

  analogous  thus  preserves c  since injective 

let ps    s  q pt    t  q pp pnq    show ipps    s  q pt    t  qq 
definition equal ips    t    s    t  q  equals ips    s  q   ipt    t  q 
 a  before 
p ips    t    s    t  q a 

p ps    t q

 a  p ips   s q   ipt   t q

argument  a    analogous  thus  preserves
injective  even strongly preserves   
verification

  

since

  similar   

proposition    function e following properties 
e injective 

  
x  y  z p p pnq x  
epxq   epy q epz q 

e strongly preserves      


z  x

   



y 



x 

fibodirsky   hils

proof  verify properties one one  since g bijective  epxq epy q
x finite subsets  case x y  hence e
injective  thus  prove e strongly preserves          suffices check e
preserves         
since g bijective  gpnq equals set finite subsets n 
hence epnq n  shows e preserves    compute ephq g  pf phqq
g  phq h 
next  verify x  p p pnq epxq   epy q epx   q  let p n
arbitrary  p epxq   epy q gpaq p f pxq x f py q  definition f
since gpaq finite subset n  case gpaq p f px   q 
case p epx   q  concludes proof e preserves   
verify x   z  x y  x  epxq   epy q epz q  first
observe u  v n u v epuq epv q since e preserves   
implies epxq   epy q epz q  since x x  a  b p x 
r y  b p y  b r x  ta  bu p f pz q  ta  bu r f pxq f py q  hence 
g  pta  buq p epz q  g  pta  buq r epxq   epy q  shows epz q epxq   epy q 
note particular e preserves         moreover  epcpxqq cpepxqq 
follows preservation     since x  cpxq  therefore epxq  epcpxqq  equivalent
inclusion above  e strongly preserve          therefore ei
strongly preserves         
following direct consequence fact isomorphisms k
preserve horn formulas   since simple proof instructive follows 
give special case relevant here 
proposition    outer horn relations preserved i 
proof  let conjunction outer horn clauses variables v   let tt     t 
           tk  u outer clause   let u  v   v p pnq two assignments satisfy
clause  let w   v p pnq given x ipupxq  v pxqq  suppose w satisfies
tj     j k  since injective must tj   u v
  j k  therefore neither assignment satisfies negative literals  hence  u v
must satisfy t     since isomorphism s  s  preserves particular
t     hence w satisfies t    
proposition     inner horn relations strongly preserved e 






proof  observe x   p j j q   equivalent x   p j yj q j yj   strongly
preserved e since e strongly preserves    clearly implies statement 
note proposition   proposition    imply ei strongly preserves inner horn
relations  later need following 

n  k    following equivalent 
epx  q     epxk q   epy  q     epyl q   

exists k xi   p j j q   

lemma     let x            xk   y            yl
  
  

   

fitractable set constraints

   exists k epxi q   p


j

epyj qq   

   j yjl   jl epyj q   
proof  implication
p q p q  suppose every k ai p n
ai r xi   xi   p j j q  let c g  ta    a            ak u   k 


c r epxi q   j l epyj q  see this  first observe ai p j l yj   xi   therefore 
ta           ak u p jl f pyj q   f pxiq k  conclude c r epx q     epxk q  
epy  q     epyl q 
implication p q p q follows directly proposition     implication p q
p q trivial  second statement direct consequence proposition    
k

proposition     every horn horn relation preserved e i  particular
ei 
proof  suppose r horn horn definition variables v   since r
particular outer horn  preserved proposition   
verify r preserved e  let u   v p pnq assignment
satisfies   is  u satisfies least one literal outer clause   suffices
show assignment v   v p pnq defined x epupxqq satisfies outer
literal  suppose first outer literal positive  horn horn 
form x   y      yl   form y      yl    preserved e
lemma    
now  suppose outer literal negative  is  form x      xk   y   
  yl   k    treat case k    case similar 
suppose contradiction v px  q  
  vpxk q   vpy q     vpyl q    lemma    
exists k upxi q   p j upy j qq    particular
upx  q     upxk q   upy  q     upyl q    contradiction assumption u
satisfies  
    ei set constraints
section introduce class ei set constraints  show strictly contains
horn horn relations  give several examples non examples  present
algorithmic reduction csps ei set constraints satisfiability finite sets
horn horn clauses 
definition     set relations quantifier free definition
preserved operation ei denoted ei 
remark  note definition operation ei  definition    involved bijection g
n fin   see later  proposition    proposition     class
ei independent precise choice g 
recall proposition    ei contains horn horn relations  present
examples relations ei  examples relations ei
horn horn 
   

fibodirsky   hils

example     give example relation clearly ei  relation
r tpx  q   x    u violated ei  consider s  t a   p nu s  t a
    p nu  ps    s  q p r  since isomorphism s 
pips    s  q  ips    s  qq p r  since neither ips    s  q ips    s  q ips    s  q
ips    s  q  get epips    s  qq   epips    s  qq ep q   proposition    therefore 
peips   s q  eips   s qq r r wanted show 
example     relation r tpx  y  z q   px q   py z qu preserved
ei  note p       q  p       q p r  eip    q  eip    q  eip    q pairwise distinct
since ei injective 
example     formula

p x   xq
  px   yq
  pv     u     x    q
clearly horn horn  however  relation defined formula ei 
px   y   u   u q und px   y   u   v q relation  neither ipx   x q ipy   y q
ipy    y  q ipx    x  q  proposition    peipx    x  q  eipy    y  q  eipu    u  q  eipv    v  qq satisfies
formula  equivalent horn horn formula  since formula preserved
i 
example     formula ppx    q   pu   v  qq   px    q   px    q
horn horn  however  preserved e i  reason one clauses
negative literal x      conjuncts tx    u tx    u  therefore 
every tuple p r tuple eptq satisfies x     r well  proposition   
r preserved i  case  authors suspect equivalent horn horn
formula  generally  open whether exist formulas preserved e
i  equivalent horn horn formula 
corollary     class horn horn relations proper subclass ei 
proof  proposition    shows ei contains horn horn relations  example    shows
inclusion strict 
prepare results viewed partial converse proposition    
definition     quantifier free formula  in syntactic form described end
section    called reduced every formula obtained removing outer literal
equivalent s 
note slightly different notion reduced formula introduced
bodirsky  chen  pinsker         variant using better suited
purposes 
lemma     structure s  every quantifier free formula equivalent reduced
formula 
   

fitractable set constraints

proof  clear every quantifier free formula written formula cnf
form discussed theorem    remove successively outer
literals long results equivalent formula 
first prove partial converse proposition   
proposition     let reduced formula preserved i  outer clause
horn 
proof  let v set variables   assume contradiction contains outer
clause two positive literals  t    t     remove literal t   
clause c  resulting formula inequivalent   hence assignment
s    v p pnq satisfies none literals c except t     similarly 
assignment s    v p pnq satisfies none literals c except t    
injectivity i  since strongly preserves c           assignment   v p pnq
defined x ips  pxq  s  pxqq satisfy two literals t    t     since
strongly preserves c        none literals c satisfied mappings
well  contradiction assumption preserved i 
definition     let v set variables    v p pnq mapping 
function v p pnq form x epspxqq called core assignment 
lemma     every quantifier free formula exists formula inner
clauses inner horn  satisfying core assignments 
preserved ei  set satisfying core assignments closed
ei 
proof  suppose outer clause c positive outer literal  
contains inner clause c   x      xk         l horn  i e   k   
replace outer literal   k literals t             tk   ti obtained
replacing c xi         l  
claim resulting formula   set satisfying core assignments 
observe xi         l c  hence ti   implies    arbitrary satisfying
assignment   satisfies either one positive outer literals ti    case
observation shows satisfies   satisfies one outer literals c 
case satisfies literal   hence    implies   conversely  let
satisfying core assignment   satisfies literal c   
satisfies literal     satisfies     otherwise  must satisfy    hence
spx  q    spxk q  spy  q    spyl q    since core assignment  lemma    implies
exists k spxi q   spy  q     spyl q    satisfies    
suppose outer clause c negative outer literal  
contains inner clause c   x      xk         l horn  i e   k   
replace clause c k clauses c            ck ck obtained c
replacing c xi         l  
claim resulting formula   set satisfying core assignments 
observe x      xk         l   implies xi         l    every
k  observation shows arbitrary assignment assignment    
   

fibodirsky   hils

conversely  let satisfying core assignment     satisfies one literals
c    satisfies   otherwise  must satisfy xi         l  
k  lemma    satisfies x      xk         l   
perform replacements obtain formula   inner clauses
horn  formula satisfies requirements first statement lemma 
prove second statement  let u  v   v p pnq two satisfying core assignments
    since   satisfying core assignments  u v satisfy  
mapping w   v p pnq given x eipupxq  v pxqq core assignment 
ei preserves   mapping w satisfies   since   core assignments 
w satisfying assignment     proves statement 
single technical condition guarantees  extra condition
 see proposition     formulas satisfying certain universl algebraic property hornhorn  allow us perform reduction csp associated  finite  set
constraint languages ei satisfiability horn horn clauses 
definition     quantifier free formula  in syntactic form described end
section    called strongly reduced every formula obtained removing outer
literal set satisfying core assignments s 
proposition     let strongly reduced formula whose inner clauses horn 
set satisfying core assignments closed ei  horn horn 
proof  let v set variables   suffices show clauses outer
horn  assume contradiction contains outer clause two positive literals 
t    t     remove literal t    clause c  resulting formula
strictly less satisfying core assignments  shows existence core assignment
s    v p pnq satisfies none literals c except t     similarly  exists
core assignment s    v p pnq satisfies none literals c except t    
assumption  inner clauses t  t  horn  claim assignment
  v p pnq defined x eips  pxq  s  pxqq satisfy clause c  since ei
strongly preserves inner horn clauses  satisfy t      t    
reasons satisfy literals c  contradicts assumption
satisfying core assignments preserved ei 
satisfiability horn horn clauses computational problem decide whether 
given finite set horn horn clauses  satisfying assignment s 
proposition     let finite set constraint language ei  csppq
reduced linear time satisfiability horn horn clauses 
proof  let instance csppq  let v set variables appear
  constraint rpx            xk q   let r definition r s 
lemma     exists formula r satisfying core assignments r
inner clauses horn  moreover  since r preserved ei  lemma
asserts set satisfying core assignments r preserved ei 
assume without loss generality r strongly reduced  seen similarly
lemma     proposition     formula r horn horn 
   

fitractable set constraints

let set horn horn clauses formulas r px            xk q obtained constraints rpx            xk q described manner  claim satisfiable instance
csppq satisfiable  follows fact constraint
rpx            xk q   formulas r r satisfying core assignments 
r r preserved ei  for r follows proposition     
particular function x eipx  xq 
note proposition    reduce satisfiability ei satisfiability proper
subclass horn horn set constraints  general horn horn set constraints allow
inner clauses negative outer literals horn  reduction produces hornhorn clauses inner clauses horn 

   algorithm horn horn set constraints
present algorithm takes input set horn horn clauses decides
satisfiability pp pnq        c      q time quadratic length input 
proposition     section therefore conclude proof csppq tractable
relations ei 
mentioned introduction  algorithm based two procedures 
resolution like  inner procedure essentially well known positive unit resolution
procedure horn sat  outer procedure basically algorithm
used literature independence constraint satisfaction  see  e g   jonsson  
backstrom        koubarakis        broxvall et al         cohen et al          contribution section way nest two algorithms obtain polynomial time
decision procedure satisfiability horn horn clauses 
start discussing first procedure algorithm  call inner
resolution algorithm  case boolean positive unit resolution  dowling   gallier 
      one implement procedure inner res runs linear time
input size 
lemma     let finite set inner horn clauses  following equivalent 
  



  satisfiable s 

   inner respq figure   accepts 
  



  solution whose image contained


th  nu 

proof  obvious   unsatisfiable inner respq rejects  fact 

inner clauses c derived inner res   formula c   logically implied

   conversely  algorithm accepts set eliminated variables
n remaining variables h  satisfies clauses  removed clauses
positive literal satisfied  remaining clauses least one negative literal
final stage algorithm  clauses negative literals final stage
algorithm satisfied 




proof previous lemma shows   satisfiable
  satisfiable two element boolean algebra  see following 
   

fibodirsky   hils

inner res  
   input  finite set inner horn clauses
   accepts iff   satisfiable
entire algorithm 
contains empty clause  reject 
repeat    true
repeat   true
repeat    false
contains positive unit clause txu
repeat    true
remove clauses literal x occurs 
remove literal x clauses 
end
loop
accept



figure    inner resolution algorithm 
holds generally  and inner horn clauses   following
well known  shown proof given koppelberg       
weaker proposition      there  give proof convenience reader 
fact     let t    t  terms

t      c      u  following equivalent 

    t    satisfiable two element boolean algebra 
t      t    satisfiable boolean algebras 
t      t    satisfiable boolean algebra 
t      t    satisfiable finite boolean algebra 

   t 
  
  
  

proof  obviously      implies          implies     
    implies      assume t      t    satisfying assignment
boolean algebra c  let x            xn variables occur t  t    let xi ci
satisfying assignment  t      t    satisfiable boolean sub algebra
n
c  c generated tc            cn u  c  finite  it  p  q elements  
    implies      first note finite boolean algebra isomorphic boolean
algebra pp px q        c      q subsets finite set x  x p x  consider map hx  
p px q t    u  hpy q     x p   hpy q   otherwise  hx homomorphism
boolean algebras  particular  shows every non zero element finite
boolean algebra c  homomorphism h c two element boolean algebra
hpaq    suppose      assume t      t    satisfying
assignment finite boolean algebra c  let c element denoted t  c
assignment  c    let h homomorphism c t    u
hpcq    i e  hpcq    construction  image satisfying assignment h
satisfying assignment t      t    t    u 
   

fitractable set constraints

statement t    instead t      t    given proposition
      koppelberg         fact    following consequence crucial way
use inner resolution procedure algorithm 
lemma     let finite set inner horn clauses  following equivalent 
   inner respytx            xk   y            yl uq rejects 


  s 


proof 
  implies x      xk         l  

    x   
  xk   y      yl   unsatisfiable s  fact     case
    x      xk        
  unsatisfiable   element
l
boolean algebra  case     x      xk         l  
  

  implies x      xk         l

unsatisfiable two element boolean algebra  seen lemma    
turn holds inner respytx             xk    y             yl  uq rejects 
outer res  
   input  finite set horn horn clauses
   accepts iff satisfiable pp pnq        c      q
entire algorithm 
contains empty clause  reject 
repeat    true
repeat   true
repeat    false
let set inner horn clauses terms
positive unit clauses tt  u  
inner res rejects   reject 
negative literal   clauses
inner clause tx            xk               l u
call inner res
tx             xk    y             yl  u
inner res rejects remove clause
end
clauses removed 
remove outer literal   clause
repeat    true
end
loop
accept

figure    outer resolution algorithm 
theorem     algorithm outer res figure   decides satisfiability sets hornhorn clauses quadratic time 
proof  first argue algorithm rejects   indeed solution  first
note whole argument  set clauses satisfying tuples
   

fibodirsky   hils

 i e   corresponding formulas equivalent   observe negative literals get
removed clauses  negative literal   gets removed clause
inner res rejects tx             xk    y             yl  u inner clause
tx           xk   y           yl u t  lemma     inner res rejects ytx             xk    y 
           yl  u implies x      xk         l    hence  positive
unit clauses imply   therefore literal   removed clause
without changing set satisfying tuples  algorithm rejects either inner res
rejects derives empty clause  cases clear satisfiable 
thus  suffices construct solution algorithm accepts  let set
inner clauses terms positive unit clauses final stage  algorithm
accepts  remaining negative outer literal tt  u remaining inner clause
tx            xk               l u exists assignment v p pnq satisfies
ytx      xk         l  u  otherwise  lemma     inner resolution algorithm
would rejected tx             xk    y             yl  u  would removed
inner clause t  let d            ds enumeration remaining inner clauses
appear remaining negative outer literals 
write s ary operation defined px            xs q ipx    ipx            ipxs    xs q qq
 where fact     claim   v p pnq given
x pd  pxq          ds pxqq

satisfies clauses   let c clause   assumption  final stage
algorithm  clause c still non empty  note since formulas input
horn horn  contain one positive literal  holds particular c 
therefore distinguish following cases 
final state algorithm  c still contains negative literal    since  
removed  remaining inner clause tx            xk               l u
t  observe spx  q     spxk q   spy  q     spyl q   dj px  q  
  dj pxk q   dj py q     dj pyl q     j s  hence  since
px  q     pxk q   py  q     pyl q    satisfies    shows
satisfies c 
negative literals removed c algorithm  positive
literal t    c inner clauses t  horn  part
  therefore t    satisfied s  indeed  assumption assignments dj
satisfy   preserved i 
conclude solution   inner resolution algorithm linear time
complexity  outer resolution algorithm performs linear number calls
inner resolution algorithm  straightforward implement necessary data
structures outer resolution obtain running time quadratic input
size 
combining proposition    theorem     obtain following 
theorem     let finite set constraint language ei  csppq
solved quadratic time 
   

fitractable set constraints

   maximal tractability
section show class ei maximal tractable set constraint language 
specifically  let set constraint language strictly contains ei relations 
show contains finite set relations   already problem
cspp  q np hard  theorem     
    universal algebraic approach
proof use so called universal algebraic approach complexity constraint satisfaction problems  requires re formulate set csps constraint
satisfaction problems  categorical structures  detailed introduction
universal algebraic approach  categorical structures  see bodirsky         structure
countable domain called  categorical countable structures satisfy
first order sentences isomorphic  see  e g   hodges        
theorem ryll nardzewski  countable signatures  equivalent requiring
every relation preserved automorphisms  first order definable
 see  e g   hodges         useful consequence  categorical structure   whenever two tuples c pc            cn q pd            dn q satisfy
first order formulas  automorphism maps c d 
example  categorical structure pq  q  by cantors theorem   nonexample given pz  q  note pq  q pz  q csp  indeed  two
infinite linear orders share csp  since even finite substructures 
characterisation infinite structures  categorical structure
csp given bodirsky  hils  martin         empirically 
observed constraint satisfaction problems studied temporal spatial
reasoning typically called qualitative formulated
 categorical template 
set constraint languages general  categorical  this follows easily
mentioned theorem ryll nardzewski   however  every set csp formulated
csp  categorical structure  see this  first recall basic facts
boolean algebras  countable atomless  boolean algebras isomorphic  koppelberg 
      corollary       see hodges        example   page       let denote
countable atomless boolean algebra  let denote domain a  again  use  
  denote join meet a  respectively  since axioms boolean algebras
property atoms written first order sentences  follows
 categorical  structure b quantifier elimination every first order formula
b equivalent quantifier free formula  well known quantifier elimination
 see hodges        exercise    page       make use following 
theorem     marriott   odersky        corollary       quantifier free formula satisfiable infinite boolean algebra satisfiable infinite boolean
algebras 
   isomorphism structure called automorphism  
   atom boolean algebra element x   x x
   boolean algebra contains atoms  called atomless 

   

x

fibodirsky   hils

particular  b infinite boolean algebra             n quantifier free
formulas signature t      c      u  relational structure signature tr            rn u ri n defined b  csppq
depend choice b 
fundamental concept complexity theory constraint satisfaction problems
notion primitive positive definitions  first order formula called primitive positive
 pp  form
dx           xn p      mq
formula form rpy            yl q form y  y   
r relation symbol y    y            yl either free variables tx            xn u 
say k ary relation r dk primitive positive definable  pp definable 
 structure domain iff exists primitive positive formula px            xk q
k free variables x            xk tuple pb            bk q r pb            bk q
true  
example     relation tpx  q p p pnq    x u pp definable pp pnq  s  q
tpx  y  z q   x   z u  pp definition px  x  q   x  the definition even
quantifier free  
example     relation tpx    x    x    q p p pnq    x    x    x  u pp definable
pp pnq  q tpx  y  z q   x   z u  pp definition du ps px    x    uq  
pu  x    qq 
every relation structure preserved operation f   f called
polymorphism   note polymorphisms preserve relations pp
definition   following shown finite domain constraint satisfaction
bulatov et al          easy proof works infinite domain constraint satisfaction 
lemma     let r relation primitive positive definition structure  
csppq csp expansion relation r polynomial time equivalent 
following theorem one reasons useful work  categorical
templates  when possible  
theorem     bodirsky   nesetril         let  categorical structure  r
primitive positive definable r preserved polymorphisms  
previous next result together used translate questions
primitive positive definability
purely operational questions  let set  let opnq
pnq set operations finite arity 
dn d  let  
n 
p
n
q
operation p called projection fixed p t           nu n tuples
px           xnq p dn identity px           xnq xi  composition k ary
operation f k operations g            gk arity n n ary operation defined

pf pg           gk qqpx           xnq

f g px           xnq          gk px           xnq  
   

fitractable set constraints

definition     say f locally generates f   dn every finite subset
operation g   dn obtained operations f
projection maps composition f paq g paq p  
theorem     see szendrei        corollary      bodirsky        proposition         let
f set operations domain d  operation f   dk preserves
finitary relations preserved operations f f locally generates
f 
set automorphisms structure denoted autpq  following 
always consider sets operations f contain autpaq  therefore make following
convention  f o  say f generates f p f autpaq locally generates f  
    ei set constraints atomless boolean algebra
previous subsection seen set csps formulated csps
 categorical structures  section  describe  categorical templates
correspond set csps ei set constraints  order so  define analogs
operations e i  defined instead p pnq 
proposition     isomorphism a  a 
proof  straightforward verify a  countable atomless boolean algebra 

motivated properties e described lemma     make following definition 
definition     let b b  two arbitrary boolean algebras domains b b    
respectively  let g   b b   function strongly preserves          say
g forgets unions k    l    x            xk   y            yl p b
epx  q     epxk q   epy  q     epyl q  
exists k xi   y      yl

  

proposition     exists injection e   strongly preserves
a  forgets unions 

       

proof  construction e standard application konigs tree lemma categorical structures  see  e g   bodirsky   dalmau        lemma     suffices show
injection f every finite induced substructure b f
strongly preserves          forgets unions 
let b finite substructure a  let b domain b  let c
pp pb q        c      q boolean algebra subsets b  claim g   b p pb q
given g p q   g pxq tz   z     z b xu x  
preserves      definition 
   

fibodirsky   hils

preserves

   x  p b  including case x     
g pxq  c g py q tz   z     z b x   z b u
 
z   z     z b px  b q
g p x  b q  

injective  x 
x y 
strongly preserves

p b gpxq gpyq  x b b x  hence
   follows previous two items 

forgets unions  shown analogously proof lemma    






indeed  one xi   y      yl   iff xi b j yj iff xi   j yj j yj iff


g pxi q  j g pyj q j g pyj q iff g pxi q  g py  q    g pyl q    thus  xi   y      yl  
  k implies g px  q     g pxk q   g py  q     g pyl q   
prove converse  use finite boolean algebra b may identified
pp paq        c      q finite set a  xi   xi   y      yl              k 
may choose ai p azxi   i e  ai p j yj   xi              k  let c   ta            ak u
a  c p b  construction  k one tc u r g pxi q   g py  q     g pyl q 
particular  follows g px  q     g pxk q   g py  q     g pyl q   
clearly  embedding h c a  f   hpg q homomorphism
b forgets unions 
proposition     let quantifier free formula signature t      c      u 
e preserves e preserves a  moreover  every operation
strongly preserves         forgets unions generates e  generated
e 
proof  let tuple elements a  clearly  exists tuple b elements
p pnq b satisfy set quantifier free formulas  follows
fact every finite boolean algebra boolean algebra subsets finite set 
observe whether tuple epbq satisfies quantifier free formula
depends   lemma     since e strongly preserves          forgets unions 
true quantifier free formulas hold epaq  hence  e preserves
e preserves s 
prove second part statement  use theorem     suppose c
tuples  of length  elements satisfy quantifier free
formulas  since quantifier elimination  follows c satisfy firstorder formulas a  consequence theorem ryll nardzewski mentioned

beginning section      exists automorphism maps c d 
observations theorem     implies operations strongly preserve
         forget unions generate other 
r operation px  q epipx  qq 
let ei
   

fitractable set constraints

proposition     let quantifier free formula signature t      c      u 
r preserves a  moreover  every binary operation
ei preserves ei
r generated
g strongly preserves          forgets unions generates ei 
r
ei 
proof  arguments similar ones given proof proposition     a 
a  n tuples elements a  n tuples b    b  elements p pnq
pa    a  q pb    b  q satisfy set quantifier free formulas  whether
eipb    b  q satisfies quantifier free formula depends   ei strongly preserves   
r pa    a  q  ei
r preserves
      forgets unions  holds ei
ei preserves s 
proof second part statement identical one proposition    

    central argument
give central argument maximal tractability ei  stated universalalgebraic language  say operation ak depends argument
p t           k u pk  q ary operation f   x            xk p
f px            xk q f   px            xi    xi

            xk

q 

equivalently characterize k ary operations depend i th argument
requiring x            xk p x i p
f px            xk q f px            xi    x i   xi

            xk

q 

following general fact injective maps 
lemma     let f   ak function depends arguments 
locally generated set injective operations f  f injective 
proof  first prove every term px            xn q formed operations f
variables x            xn every variable appears least defines injective
map  prove induction term structure  case n  
x  nothing show  otherwise  form f pt            tk q k ary f p f
tj tj pxi            ximpj q q j k term operations f variables
xi            ximpj q appears least tj   suppose a            p
b            bn p pa            q pb            bn q  want show ai bi
n  since f injective must tj pai            aimpj q q tj pbi            bimpj q q
j k  since every variable x            xn appears least once  variable
xi must appear tj   j k  since tj defines injective operation inductive
assumptions  must ai bi   follows defines injective map 
suppose f operation locally generated f depends
arguments  thus  ci            cin di f pci            cin q
f pci            cii    di   cii             cin q  let a              b            bn p f pa            q
f pb            bn q  show a  b            bn   since f locally generated
   

fibodirsky   hils

f  exists term px            xn q composed variables x            xn operations f pe            en q f pe            en q elements e            en
set ta              b            bn   c             cnn   d            dn u  i  variable xi must appear
px            xn q pci            cin q pci            cii    di   cii             cin q  hence  argument
beginning proof shows px            xn q defines injective map 
therefore a  b            bn   shown f injective 
r u  either tf u generates ei 
r f
theorem     let f operation generated tei
generated teu 

r u 
proof  show statement theorem  let f k ary operation generated tei
sake notation  let x            xl arguments f depends  l k 
let f     al operation given f   px            xl q f px            xl    xl   xl           xl q 
observe f   depends arguments  locally generated injective operations 
lemma     f   injective  since f   generated operations preserve      
   f   preserves them  f   injective  even strongly preserves         
consider first case l    i e   f   unary  finite subsets a 
operation f   equals automorphism a  f generated autpaq
nothing show  assume otherwise  is  assume finite set
p autpaq f   pxq apxq x p s  claim f   forgets
unions  see this  let u            um   v            vn f   pu  q     f   pum q  
u  term pxq composed
f   pv  q     f   pvn q    since f   generated tei
r
ei  automorphisms a  single variable x f   pxq pxq
x p tu            um   v            vn u  choice s  term cannot composed
automorphisms alone  hence must p autpaq operational terms t    t 
r f   pxq apei
r pt  pxq  t  pxqqq
composed automorphisms ei
r
x p s  ei forgets unions  exists k t  pui q  t  pv  q    tl pvn q   
since t  strongly preserves    means ui   v       v n    see proof
proposition      wanted show  proposition    follows f  
generated e  f generated e well 
next  consider case l    let g binary operation defined g px  q
 
f px  y          q  functions depends arguments  cannot generated
automorphisms alone  hence  term form
r pt  px  q  t  px  qqq
px  q apei


p autpaq 
r automorphisms a 
t  t  operational terms composed ei 
two variables x y 

g px  q px  q px  q p tu            um   v            vn u 

claim g forgets unions  assume g pu  q    g pum q  g pv  q    g pvn q  
elements u  pu     u   q          um pu m   u m q  v  pv     v   q          vn pvn    vn  q a   
r forgets unions  exists k t  pui q  t  pv  q    t  pvn q  
since ei
   

fitractable set constraints

t  pui q t  pv  q   t  pvn q    suppose first t  depends arguments  t 
defines injective operation strongly preserves    follows ui   v       v n  
a  since equations inner horn  argue similarly t  depends
arguments  cases established g forgets unions  suppose
t  t  depend arguments  consider first case
t  depends first argument  function x t  px  xq injective
strongly preserves    t  pui q   t  pv  q     t  pvn q   derive
u i   v       vn    holds a  case  t  must depend second argument 
since depends arguments  therefore u i   v       vn    holds
a  situation t  depends second argument t  depends
r
first argument analogous  g forgets unions  proposition     g generates ei 
r
consequently  f generates ei 
theorem     let set constraint language  suppose contains relations
ei  contains relation ei  finite sublanguage  
cspp  q np hard 
proof  r    r          relations   let               quantifier free formulas
define r    r          pp pnq        c      q  let r a   r a         relations defined
              a  let relational structure domain exactly
r contains
relations  proposition     contains relation preserved ei 
r consider set f polymorphisms  
relations preserved ei 
theorem     operations f locally generated eri 
set f contain eri  since would contradict theorem    fact
r since f locally closed  follows
contains relation preserved ei 
theorem    operations f p f generated e  relation
tpx  y  zq   x z   x zu preserved operations f  we already seen
relation example     hence pp definable theorem     relation
np complete csp  bodirsky   kara         let   reduct contains
exactly relations appear pp definition tpx  y  z q   x z   x z u
  clearly  finitely many relations  denote corresponding relation
symbols     lemma     cspp  q np hard 
establishes hardness csppq  let      reduct   claim
cspp  q cspp  q computational problem  show
conjunction atomic    formulas satisfiable   true    
replacing atomic    formula quantifier free definition  follows
theorem    

   concluding remarks
introduced powerful set constraint language ei set constraints 
particular contains horn horn set constraints previously studied tractable set
constraint languages  constraint satisfaction problems ei solved polynomial
even quadratic time  tractability result complemented complexity result
shows tractability ei set constraints best possible within large class
set constraint languages 
   

fibodirsky   hils

would remark algorithm test whether given finite set
constraint language  where relations language given quantifier free formulas
signature t      c      u  contained ei  means so called metaproblem ei set constraints decided effectively 
proposition     algorithm test whether given quantifier free formula
signature t      c      u defines relation ei 
proof  clear effectively transformed normal form described
section    assume conjunction outer clauses 
atomic formula form   inner conjunctive normal form 
let n number variables   test two n tuples u    u 
elements p pnq satisfy   n tuple eipu    u  q satisfies well  note
whether tuple satisfies depends boolean algebra generated
entries tuple s  boolean algebra generated n elements size
n
     therefore  finitely many cases check  pair boolean
algebras generating tuples u    u    check whether eipu    u  q satisfies follows 
lemma     eipu    u  q satisfies atomic formula   every inner clause
x   
  xk   epy q     epy q exists k ipu   u
  q satisfies
xi   j j    turn true u  u  satisfy xi   j j   
truth value non atomic formulas tuple eipu    u  q computed
truth value atomic formulas usual way 

finally would remark one analogously obtain tractability
class constraints inner clauses positive outer literals dual horn
 i e   one negative literal   statements proofs respective result
obtained dualizing following formal sense  dual relation r
definable boolean algebra relation tcptq   p ru  dual k ary operation
f domain operation px            xk q cpf pcpx  q          cpxk qqq  proofs
translate literally proofs dualized versions statements 

acknowledgments
extended abstract article appeared proceedings ijcai    bodirsky  hils 
  krimkevitch           want thank francois bossiere pointed mistakes
conference version paper  one mistake concerned reduction csp
languages ei satisfiability horn horn clauses  concerned problem
previous proof theorem    
manuel bodirsky received funding erc european communitys
seventh framework programme  fp            grant agreement no          
   third author conference version left author team preparation journal version 

   

fitractable set constraints

references
aiken  a          set constraints  results  applications  future directions  proceedings
second workshop principles practice constraint programming 
pp         
baader  f          least common subsumers specific concepts description logic
existential restrictions terminological cycles  proceedings international
joint conferences artificial intelligence  ijcai   pp         
baader  f   brandt  s     lutz  c          pushing el envelope  international joint
conferences artificial intelligence  ijcai   pp         
barto  l     kozik  m          constraint satisfaction problems bounded width 
proceedings annual symposium foundations computer science  focs  
pp         
bodirsky  m          complexity classification infinite domain constraint satisfaction 
memoire dhabilitation diriger des recherches  universite diderot paris    available
arxiv           
bodirsky  m   chen  h     pinsker  m          reducts equality primitive
positive interdefinability  journal symbolic logic                   
bodirsky  m     dalmau  v          datalog constraint satisfaction infinite templates  appear journal computer system sciences  preliminary
version appeared proceedings symposium theoretical aspects
computer science  stacs    
bodirsky  m   hils  m     krimkevitch  a          tractable set constraints  proceedings
international joint conferences artificial intelligence  ijcai   pp         
bodirsky  m   hils  m     martin  b          scope universal algebraic approach constraint satisfaction  appear logical methods computer science  lmcs         available arxiv          v   extended abstract
announced results appeared proceedings logic computer
science  lics    
bodirsky  m     kara  j          complexity equality constraint languages  theory
computing systems                 conference version appeared proceedings
computer science russia  csr    
bodirsky  m     kara  j          complexity temporal constraint satisfaction problems  journal acm               extended abstract appeared
proceedings symposium theory computing  stoc    
bodirsky  m     kutz  m          determining consistency partial tree descriptions 
artificial intelligence              
bodirsky  m     nesetril  j          constraint satisfaction countable homogeneous
templates  journal logic computation                 
boole  g          investigation laws thought  walton  london  reprinted
philisophical library  new york       
   

fibodirsky   hils

broxvall  m   jonsson  p     renz  j          disjunctions  independence  refinements 
artificial intelligence                    
bulatov  a  a          tractable conservative constraint satisfaction problems  proceedings symposium logic computer science  lics   pp          ottawa 
canada 
bulatov  a  a          dichotomy theorem constraint satisfaction problems
  element set  journal acm                
bulatov  a  a     dalmau  v          simple algorithm maltsev constraints  siam
journal computing               
bulatov  a  a   krokhin  a  a     jeavons  p  g          classifying complexity
constraints using finite algebras  siam journal computing             
cohen  d   jeavons  p   jonsson  p     koubarakis  m          building tractable disjunctive
constraints  journal acm                 
dowling  w  f     gallier  j  h          linear time algorithms testing satisfiability
propositional horn formulae  journal logic programming                
drakengren  t     jonsson  p          reasoning set constraints applied tractable
inference intuitionistic logic  journal logic computation                
garey  m     johnson  d          guide np completeness  csli press  stanford 
hodges  w          model theory  cambridge university press 
idziak  p  m   markovic  p   mckenzie  r   valeriote  m     willard  r          tractability
learnability arising algebras subpowers  siam journal computing                   
jonsson  p     backstrom  c          unifying approach temporal constraint reasoning 
artificial intelligence                  
jonsson  p     drakengren  t          complete classification tractability rcc   
journal artificial intelligence research            
koppelberg  s          projective boolean algebras  handbook boolean algebras 
vol     pp          north holland  amsterdam new york oxford  tokyo 
koubarakis  m          tractable disjunctions linear constraints  basic results applications temporal reasoning  theoretical computer science              
krotzsch  m   rudolph  s     hitzler  p          complexity horn description
logics  owl  experiences directions workshop 
kuncak  v   nguyen  h  h     rinard  m  c          deciding boolean algebra presburger arithmetic  journal automatic reasoning                 
kuncak  v     rinard  m  c          towards efficient satisfiability checking boolean
algebra presburger arithmetic  proceedings international conference
automated deduction  cade   pp         
kusters  r     molitor  r          approximating specific concepts description
logics existential restrictions  ai communications               
   

fitractable set constraints

lassez  j  l     mcaloon  k          independence negative constraints  international
joint conference theory practice software development  tapsoft   volume    pp       
marriott  k     odersky  m          negative boolean constraints  theoretical computer
science                    
schaefer  t  j          complexity satisfiability problems  proceedings
symposium theory computing  stoc   pp         
szendrei  a          clones universal algebra  seminaire de mathematiques superieures 
les presses de luniversite de montreal 

   


