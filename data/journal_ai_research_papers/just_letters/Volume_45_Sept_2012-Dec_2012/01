journal artificial intelligence research               

submitted        published      

tractability csp classes defined forbidden patterns
david a  cohen

dave cs rhul ac uk

department computer science
royal holloway  university london
egham  surrey  uk

martin c  cooper

cooper irit fr

irit
university toulouse iii        toulouse  france

paid creed

p creed qmul ac uk

school mathematical sciences
queen mary  university london
mile end  london  uk

daniel marx

dmarx cs bme hu

computer automation research institute
hungarian academy sciences  mta sztaki 
budapest  hungary

andras z  salamon

andras salamon ed ac uk

laboratory foundations computer science
school informatics  university edinburgh  uk

abstract
constraint satisfaction problem  csp  general problem central computer
science artificial intelligence  although csp np hard general  considerable
effort spent identifying tractable subclasses  main two approaches consider
structural properties  restrictions hypergraph constraint scopes  relational
properties  restrictions language constraint relations   recently  authors
considered hybrid properties restrict constraint hypergraph relations
simultaneously 
key contribution novel concept csp pattern classes problems
defined forbidden patterns  which viewed forbidding generic sub problems  
describe theoretical framework used reason classes problems
defined forbidden patterns  show framework generalises certain known
hybrid tractable classes 
although close obtaining complete characterisation concerning
tractability general forbidden patterns  prove dichotomy special case  classes
problems arise forbid binary negative patterns  generic subproblems disallowed tuples specified   case show  finite
sets of  forbidden patterns define either polynomial time solvable np complete classes
instances 
c
    
ai access foundation  rights reserved 

ficohen  cooper  creed  marx   salamon

   introduction
constraint satisfaction paradigm consider computational problems
assign values  from domain  variables  constraints  constraint
limits  simultaneous  values list variables  its scope  assigned 
typical situation pair variables might represent starting times two jobs
machine shop scheduling problem  reasonable constraint would require minimum time
gap values assigned two variables 
constraint satisfaction proved useful modelling tool variety contexts 
scheduling  timetabling  planning  bio informatics computer vision 
led development number successful constraint solvers  unfortunately  solving
general constraint satisfaction problem  csp  instances np hard
significant research effort finding tractable fragments csp 
principle stratify csp two quite distinct natural ways  structure constraint scopes instance csp thought hypergraph
variables vertices  generally relational structure  find
tractable classes restricting relational structure  allowing arbitrary constraints
resulting scopes  dechter   pearl         sub problems general constraint
problem obtained restrictions called structural  alternatively  set allowed assignments variables scope seen relation  choose
allow specified kinds constraint relations  allow interact arbitrary structure  jeavons  cohen    gyssens         restrictions called relational
language based 
structural subclasses defined specifying set hypergraphs  or relational structures  allowed structures csp instances  shown tractable
structural classes characterised limiting appropriate  structural  width measures
 dechter   pearl        freuder        gyssens  jeavons    cohen        gottlob  leone 
  scarcello        marx      a      b   example  tractable structural class binary
csps obtained whenever restrict constraint structure  which graph
case  bounded tree width  dechter   pearl        freuder         fact 
shown that  subject certain complexity theoretic assumptions  structures
give rise tractable csps bounded  hyper  tree width  dalmau 
kolaitis    vardi        grohe              marx      a      b  
relational subclasses defined specifying set constraint relations  complexity subclass arising restriction precisely determined
called polymorphisms set relations  bulatov  jeavons    krokhin        cohen
  jeavons         polymorphisms specify that  whenever set tuples
constraint relation  cannot case particular tuple  the result applying
polymorphism  constraint relation  thus relationship allowed tuples disallowed tuples inside constraint relations key importance
relational tractability given class instances  whilst general dichotomy
yet proven relational case  many dichotomies sub problems
obtained  instance bulatov         bulatov et al         bulatov        
  

fitractability csp classes defined forbidden patterns

using structural relational restrictions limits possible subclasses
defined  allowing restrictions structure relations able
identify new tractable classes  call restrictions hybrid reasons tractability 
several hybrid results published binary csps  jegou        weigel   bliek 
      cohen        salamon   jeavons        cooper  jeavons    salamon        cooper  
zivny      b   instead looking set constraint scopes constraint language 
results captured tractability based properties  coloured  microstructure
csp instances  microstructure binary csp instance graph hv  ei v
set possible assignments values variables e set pairs mutually
consistent variable value assignments  jegou         coloured microstructure 
vertices representing assignment variable vi labelled colour representing
variable vi   maintains distinction assignments different variables 
coloured microstructure csp instance captures structure
relations csp instance natural place look tractable classes
neither purely structural purely relational  results  coloured  microstructure
properties  three particular note  first observed class instances
perfect microstructure tractable  salamon   jeavons         proper
generalisation well known hybrid tractable csp class whose instances allow arbitrary
unary constraints every pair variables constrained equal  regin 
      van hoeve         hybrid class whose microstructure triangulated  jegou 
      weigel   bliek        cohen         perfect microstructure property excludes
infinite set induced subgraphs microstructure 
secondly  joint winner property  jwp   cooper   zivny      b  applied csps
provides different hybrid class strictly generalises class csp instances
disequality constraint      every pair variables arbitrary set
unary constraints  forbidding single pattern  a subgraph  coloured
microstructure  jwp generalized hierarchies soft non binary constraints  cooper   zivny      a   including  example  soft hierarchical global cardinality
constraints  reduction minimum convex cost flow problem 
thirdly  called broken triangle property properly extends structural notion
acyclicity interesting hybrid class  cooper et al          broken triangle
property specified excluding particular pattern coloured microstructure 
notion forbidden pattern study paper  therefore work directly
csp instance  or equivalently coloured microstructure  rather microstructure
abstraction simple graph  allows us introduce language expressing
hybrid classes terms forbidden patterns  providing framework search
novel hybrid tractable classes  case binary negative patterns able
characterise tractable  finite sets of  forbidden patterns  state necessary
condition tractability  finite set of  general patterns 
    contributions
paper generalise definition csp instance csp pattern
three types tuple constraint relations  tuples explicitly al  

ficohen  cooper  creed  marx   salamon

lowed disallowed tuples labelled unknown    defining natural notion
containment patterns csp  able describe problems defined forbidden
patterns  class csp instances defined forbidding particular pattern exactly
instances contain   use framework capture tractability
identifying local patterns allowed disallowed tuples  within small groups connected
constraints  whose absence enough guarantee tractability 
using concept forbidden patterns  lay foundations theory
used reason classes csps defined hybrid properties  since first
work kind  primarily focus simplest case  binary patterns tuples
either disallowed unknown  called negative patterns   give large class binary
negative patterns give rise intractable classes problems and  using this  show
negative pattern defines tractable class problems must certain
structure  able prove structure enough guarantee tractability
thus providing dichotomy tractability defined forbidding binary negative patterns 
importantly  intractability results allow us give necessary condition
form general tractable patterns 
remainder paper structured follows  section   define constraint
satisfaction problems  give definitions used paper  then  section   
define notion csp pattern describe classes problems defined forbidden
patterns  give examples tractable classes defined forbidden patterns three
variables  section   show one must take size patterns account
notion maximal classes defined forbidding patterns  general  yet able
make conjecture concerning dichotomy hybrid tractability defined general
forbidden patterns  however  section   able give necessary condition
class tractable section   prove dichotomy negative patterns  finally 
section   summarise results discuss directions future research 

   preliminaries
definition      csp instance triple hv  d  ci where 
v finite set variables  with n    v    
finite set called domain  with    d   
c set constraints  constraint c c pair c   h  where 
list distinct variables called scope c 
relation arity    called relation c  set tuples
allowed c 
solution csp instance p   hv  d  ci mapping   v where 
h  c s    where s   represents tuple resulting application
component wise list variables   
   viewed natural generalisation csp three valued logic 

  

fitractability csp classes defined forbidden patterns

simplicity presentation  assume variables domains 
unary constraints used impose different domains different variables 
arity csp largest arity constraint scopes  long term
aim identify tractable subclasses csp problem detected
polynomial time  paper describe general theory forbidden patterns
arbitrary arity consider implications new theory tractable classes
arity two  binary  problems specified finite sets forbidden patterns  cases
certain class membership decided polynomial time 
csp decision problem  asks whether particular csp instance solution 
already np complete binary csps  example  straightforward reduction
graph colouring problem set colours used domain
csp instance  vertices graph map csp variables vi   edges  i  j  map
disequality constraints vi    vj  
sometimes convenient paper use equivalent functional formulation
constraint  alternative formulation scope constraint h  abstracted set variables possible assignment seen function f   d 
constraint relation alternative view function set possible
assignments    set  t  f   where  convention  tuples occur
constraint relation map   follows assignment set
variables allowed h  restriction mapped  
definition      function f   x x  notation f  s means
function domain satisfying f  s  x    f  x  x s 
given set v variables domain d  constraint functional representation
pair h  v    t  f    csp instance functional representation triple hv  d  ci c set constraints functional representation 
solution  to csp instance hv  d  ci functional representation  mapping
  v where  h  c  s       
functional formulation clearly equivalent relational formulation
use whichever seems appropriate throughout paper  choice always
clear context 
following notions standard study csp  binary csp instance
one maximum arity constraint scope two  subproblem
variables u v instance hu  d  cu cu set constraints h  c
u   instance arc consistent v    v  v   solution
subproblem  v    extended solution subproblem  v    v    
constraint graph binary csp instance   hv  d  ci graph vertices
v edges set scopes binary constraints c  since often convenient
consider  possibly irrelevant  constraint exists every pair variables 
introduce refined notion true constraint graph 
definition      binary constraint v  v  improper allows every pair
values allowed unary constraints v  v    proper otherwise 
true constraint graph binary csp instance constraint graph
instance removing improper binary constraints 
  

ficohen  cooper  creed  marx   salamon

may sometimes need disregard unary constraints following 
definition      binary reduction csp instance obtained removing
constraint set constraints whose scope arity two 

   forbidden patterns csp
paper explain define classes csp instances forbidding
occurrence certain patterns  csp pattern generalisation csp instance 
csp pattern define relations relative three valued logic  t  f  u    meaning
pattern seen representing set csp instances undefined value u replaced either f   forbidding csp pattern equivalent
simultaneously forbidding instances sub problems 
definition      define three valued logic  t  f  u    u stands unknown
undefined  set  t  f  u   partially ordered u   u   f f
incomparable  let finite set  k ary three valued relation function
  dk  t  f  u    given k ary three valued relations     say realises  
x dk  x     x  
extend definition csp constraint pattern include additional structure set variable names set domain values  set relations
set question  adding structure makes patterns specific  therefore capture larger  hence interesting  tractable classes  example  domain
totally ordered define tractable max closed class  jeavons   cooper        
independent total order domain variable capture
renamable horn class  green   cohen         placing order variables
pattern allow us define class tree structured csp instances 
definition      csp pattern quadruple   hv  d  c  si  where 
v set variables  associated relational structure universe v  
domain  associated relational structure universe d 
c set constraint patterns  constraint pattern c c pair c   h  i 
v   scope c  list distinct variables    t  f  u  
three valued relation  in functional representation  c  constraint pattern
non trivial three valued relation maps least one tuple  t  f   
structure  set consisting relational structures associated
variable set domain 
arity csp pattern maximum arity constraint pattern h   
basic type pattern one employs structure  empty 
frequently require patterns use disequality relation     applied every pair
  

fitractability csp classes defined forbidden patterns

specified subset variables  allow several subsets variables
structure 
paper relations occurring structure arity two  interpretation limited selected binary relations representing disequality partial
order  structure variable set domain clear context 
explicitly mention it  different kinds structure imposed csp patterns  indeed
structures specified general relations would interesting area future study 
weakest structure consider allows us say two variables
distinct  thus structure csp pattern simply set disequalities
subsets variables  paper denote disequalities neq v            vr   meaning
variables v    v            vr pairwise distinct  pattern structure
called flat  indeed  paper mostly concerned flat patterns  two
variables occur together scope constraint pattern  assume
implicitly includes disequality neq v    v    
thus csp patterns defined using relational structures three sorts  variables 
domain values  variable value assignments  constraint patterns csp
pattern three valued relations sort variable value assignments  csp
pattern flat structure specifies relations sort variables  partial order
variables relation sort variables  partial orders domain
values relations sort domain values 
simplicity presentation  assume throughout paper two constraint
patterns c scope  and that  case csp instances  two
constraints scope   represent binary csp patterns simple diagrams  oval represents domain variable  dot domain value  tuples
constraint patterns value f shown dashed lines  value solid
lines value u depicted all 
definition      constraint pattern h  called negative never takes
value   csp pattern negative every constraint pattern negative 
    patterns  csps occurrence
csp instance implicitly assumed variables domain values
distinct  equivalent existence implicit disequalities neq variable
names domain values  csp instance csp pattern  with structure
variables domain values distinct  three valued relations
constraint patterns never take value u   is  decide possible tuple
whether relation not  furthermore  csp instance  pair
variables assume constraint exists scope  explicit constraint
given scope  assume relation complete  i e  contains tuples 
contrasted csp patterns absence explicit constraint
pair variables implies truth value tuple undefined 
order define classes csp instances forbidding patterns  require formal
definition occurrence  containment  pattern within instance  define
general notion containment one csp pattern within another pattern  informally 
names variables domain elements csp pattern inconsequential
  

ficohen  cooper  creed  marx   salamon

containment allows renaming variables domain values variable 
thus  order define containment patterns  firstly require formal definition
renaming  arbitrary renaming  unless explicitly prohibited disequality
structure  two distinct variables may map variable two distinct domain
values may map domain value  furthermore  pattern occurs another 
may use subset variables second pattern  hence notion require
known renaming extension 
domain labelling set variables assignment domain values
variables  variable domain renaming induces mapping domain labellings
scopes constraints  simply assign renamed domain values renamed variables  natural way extend mapping domain labellings mapping
constraint pattern  truth value mapped domain labelling
truth value original domain labelling  however  may occur two domain
labellings scope map domain labelling  instead resulting value
taken greatest original truth values   in order process
well defined  two domain labellings constraint mapped domain labelling  original truth values must comparable   leads following
formal definition renaming extension first step towards definition
containment 
definition      let   hv  d  c  si     hv     d    c       csp patterns 
say   renaming extension exist variable renaming function   v v   domain renaming function   v d  s 
assignment renaming function f   v v   d  induced  s  t  defined
f  hv  ai    hs v   t v  a i satisfy 
constraint pattern h  c  two domain labellings      
f       f                  comparable  f     denotes
assignment f   s   d  v   f  s v     t v    v   
c      hs        h  c   where  assignment f   s   d       f     u
f        f every        f     max        f       f   otherwise 
structure  s  f preserve structure  mapping induces
homomorphism relational structures variable sets  mapping
induces homomorphism relational structures domains   in
particular  neq v    v    s  s v       s v    neq s v     s v         
use patterns define sets csp instances forbidding occurrence  containment  patterns csp instances  way able characterise
tractable subclasses csp  informally  pattern said occur csp instance
p find sub problem q p  formed taking subsets variables domains 
realises   q realises if  renaming variables domain values  
constraint pattern realised corresponding constraint q  definition     
renaming extension  extra variables  domain values disequalities introduced  thus need combine notions renaming extension realisation
formally define mean pattern occurring another pattern  and  particular 
csp instance  
  

fitractability csp classes defined forbidden patterns

definition      say csp pattern occurs csp pattern p   hv  d  c  si
 or p contains    denoted p   renaming extension hv  d  c     si
where  every constraint pattern h    c   constraint pattern h  c and 
furthermore  realises    
pattern  
d 
b
b

c



b




c





x


z



x

 i 

c




x

 ii 

 iii 

pattern  
b





c


x

example      example describes three simple containments  consider three csp
patterns  pattern   i  iii   patterns occur in  contained in  pattern  
mappings f    f    f    respectively  describe 
f  simply bijection  although patterns different  valid containment
pattern   i  pattern   three valued relation pattern   realisation
three valued relation pattern   i   replacing  b  d    u  b  d    f  
f  maps  x  a    x  b    y  c  themselves  maps  y  d   y  d   
 y  d   merging domain elements possible values three valued
constraint relation pattern   ii  comparable tuples involving assignments  y  d 
 y  d    and  furthermore  restriction three valued relation pattern   ii 
either two assignments realised three valued constraint relation
pattern     b  d    f  a  d      example  replacing  a  d      u
 a  d      similar manner  pattern   i  contained pattern   simple
mapping f   maps  x  b    x  a   x  b   y  c    y  d   y  c  
finally  f  maps  y  c   y  d  themselves  maps  x  a   z  b  pattern   iii   x  a   x  b   respectively  pattern    merging variables pos  

ficohen  cooper  creed  marx   salamon

sible three valued relations agree neq x  z  structure
pattern   iii  

pattern  
z
b

b





z
c




x

c




x

neq x  z 
 i 

 ii 

throughout paper  use notation neq v            vr   denote fact
variables v            vr csp pattern distinct  worth discussing structure
implies far definition     concerned  structure source pattern must
preserved target pattern  thus pattern   iii  occurs pattern   i   pattern   i 
contained pattern   iii  since structure neq x  z  preserved target
pattern  structure neq v    v    considered preserved renaming extension
  even explicitly given   implicit  example  due existence
non trivial constraint pattern h    v    v    example  consider
two csp patterns  pattern   i  ii   pattern   i  mapped pattern   ii 
simple bijection three valued relation pattern   ii  realisation
three valued relation pattern   i   structure neq x  z  considered preserved
mapping due existence non trivial constraint pattern variables
x z pattern   ii   hence  pattern   i  occurs pattern   ii  
continuing need define mean say class csp
instances definable forbidden patterns 
definition      let c class csp instances maximum arity k  say
c definable forbidden patterns set patterns x set
csp instances maximum arity k none patterns x occur precisely
instances c 
notation  let x set csp patterns maximum arity k  use csp x  
denote set csp instances element x occurs  x singleton
   use csp   denote csp     
paper  consider classes csp x   sets x csp patterns
binary sense constraint patterns scope size exactly two 
x patterns x binary  csp x   closed arc consistency
 in sense arc consistency closure instance csp x   belongs
  

fitractability csp classes defined forbidden patterns

csp x    operation updates unary constraints  indeed  changing
unary constraints cannot introduce patterns x instance csp x   
    tractable patterns
paper define  forbidding certain patterns  tractable subclasses csp 
furthermore  give examples truly hybrid classes  i e  classes definable
purely relational purely structural properties  
definition      finite set patterns x intractable csp x   np hard 
tractable polynomial time algorithm solve csp x    single pattern
tractable  intractable     tractable  intractable    we assume throughout paper
p   np  therefore sets tractable intractable patterns disjoint  
worth observing classes csp instances defined forbidding patterns
fixed domain  recall  however  csp instance finite domain 
structure present csp instance assumed given part instance  particular 
variables csp instance assumed distinct  finite sets patterns x  
number possible renaming extensions particular instance p polynomial
size p   hence determine whether instance lies csp x   exhaustive
search polynomial time 
need following simple lemmas proofs intractability results later
sections paper 
lemma                     
proof      constraint pattern h  maps constraint pattern h      
  realises   transitivity follows following facts 
realisation operation transitive 
          definition      structure   preserved  
hence    
lemma       let x sets csp patterns suppose every pattern
  pattern x   csp x   csp t   
proof  let p csp x      p x   cannot p
  since would imply exists x p hence
p lemma      hence  p csp t   
corollary       let x sets csp patterns suppose every pattern
  pattern x  
csp t   intractable csp x   intractable conversely 
csp x   tractable whenever csp t   tractable 
finally  give examples tractable patterns  first example negative
pattern since truth values relations f u  
  

ficohen  cooper  creed  marx   salamon

pattern   simple negative pattern 
v


x
c
c 

w
b
neq v  w  x 

example       consider pattern    defines class csps trivially tractable 
forbidding pattern   ensures paths two variables true
constraint graph  thus  problem forbidding pattern   decomposed set
independent sub problems  two variables 

example       cooper zivny      b  showed forbidding pattern negtrans
shown pattern   describes tractable class csp instances  seen generalisation well known tractable class problems  alldifferent unary  costa 
      regin        van hoeve         instance class consists set variables
v   set arbitrary unary constraints v   constraint v    w defined pair
distinct variables v  w v   forbidding negtrans equivalent saying disallowed
tuples form transitive relation  i e   hv  ai   hx  bi   hx  bi   hw  ci  disallowed
 hv  ai   hw  ci  must disallowed  thus negtrans occur binary csp
instance class alldifferent unary transitivity equality  equality
exactly disallowed  

pattern   negative transitive pattern  negtrans 
v
x

w

neq v  w  x 
cooper zivny      b  recently showed tractable class defined
forbidding pattern    negtrans  extended soft constraint problems 
  

fitractability csp classes defined forbidden patterns

    tractable patterns structure
paper primarily studies patterns weak structure conditions
imposed variables distinct  however  worth pointing adding
structure pattern allows us capture larger classes instances  example     
show forbidden pattern capture class csps tree width  
adding variable ordering pattern    case pattern containment must preserve
total order  ordered pattern   consider unordered csp p
csp   exists ordering variable set p forbidden 
order define tractable class  must possible find ordering polynomial
time  case patterns examples           
pattern   tree structure pattern  tree 

v 
v 
v 
v    v    v 
example       consider pattern tree  given pattern    show class
csp tree  exactly set csps whose true constraint graph forest  i e  tree
width     first  suppose p csp tree   then  exists ordering    v            vn  
variable shares proper constraint one variable preceding
ordering  hand  suppose p csp whose true constraint graph
tree  ordering vertices according pre order traversal  obtain ordering
variable shares proper constraint one variable preceding
ordering  its parent   thus  p csp tree  

example       forbidding pattern btp shown pattern   known brokentriangle property  cooper et al          order capture class forbidden
pattern impose total order pattern variables  cooper et al        
proved class csp instances csp btp  solved polynomial time and 
indeed  csp instances csp btp  unknown total ordering variables
recognised solved polynomial time 

easy see tree  shown pattern    occurs btp  with truthvalues u changed    follows lemma      csp tree  csp btp  
hence class csp btp  includes csp instances whose true constraint graph tree 
however  csp btp  includes certain csp instances whose true constraint graph
  

ficohen  cooper  creed  marx   salamon

pattern   broken triangle pattern  btp 

b

v 


v 
v 
v    v    v 

tree width r value r  consider  example  csp instance r     variables
identical constraint every pair variables simply disallows single
tuple h    i 
tractable forbidden pattern order imposed variables 
obtain another tractable class considering problems forbidding pattern without
ordering condition  class obtained generally smaller  easier establish
containment flat pattern  example  consider pattern   flat version
pattern    seen forbidding pattern   gives rise class csp instances
paths length greater two true constraint graph 
hand  forbidding pattern   gives much larger class csp instances
true constraint graph tree width   
case broken triangle property  obtain strictly smaller tractable
class forbidding pattern   triples variables v    v    v  irrespective order 
easily exhibit csp instance shows inclusion strict  example 
  variable csp instance boolean domains consisting two constraints v    v   
v    v  variable ordering v    v    v    unordered version btp
recently used obtain dichotomy patterns consisting   constraints  cooper  
escamocher        

   maximal tractable classes defined forbidden patterns
relational tractability define maximal tractable sub problem csp problem
given set possible relations  class relations maximal possible
add even one relation without sacrificing tractability 
case structural tractability picture less clear  since measure
complexity infinite set hypergraphs  or  generally  relational structures  
obtain tractability bound width measure structures  whatever
width measure chosen containment class width bounded k inside
class width bounded k    maximal class possible  although
k unique maximal class structurally tractable instances   section 
show case forbidden patterns situation similar 
  

fitractability csp classes defined forbidden patterns

definition      let   hv  d  c  si   hv     d    c       two flat csp patterns 
  dd
    now  extend constraint pattern
form disjoint unions v v
  setting value tuple including elements d 
c domain dd
  
u   extend similarly constraint patterns c     way define c c
  forming disjoint union   adding
define structure
 
disequalities neq v  v   v v v   v     set disjoint union
  hv v
    dd
    c c
   
  i 

lemma      let flat non empty  i e  containing least one variable  binary
csp patterns 
  
csp   csp      csp 
  tractable whenever csp   csp    tractable 
moreover  csp 
proof  begin showing strict inclusion
  
csp   csp      csp 
inclusion holds follows directly lemma       among patterns
occurs  let pattern smallest number variables  define similarly 
see inclusion strict  observe occur csp pattern whose
domain disjoint union   whose variable set size equal
larger variable sets   csp instance containing pattern
neither csp   csp     however  construct csp instance containing
   structure
imposing disequalities
pattern contained csp 

variables means contained pattern 
simply enough variables 
   p csp   csp    p solved polynomial
suppose p csp 
time  tractability csp   csp    
may suppose p   choose particular occurrence p let
denote set variables used containment  consider assignment  
d  let pt denote problem obtained making assignment enforcing
arc consistency resulting problem  corresponds adding new unary
constraints p  
must occur p   see this  observe
show occurs pt
containment pm naturally induces containment p extends
p   considering occurrence   thus  conclude
containment
pt csp     solved polynomial time 
construction  solution pt extends solution p adding assignment
variables   moreover  every solution p corresponds solution pt
  d  since size fixed  iterate solutions polynomial
time  p solution  find solution pt   find
pt solution  know p solution  thus  since solve
pt polynomial time  solve p polynomial time 
corollary      tractable class defined forbidding flat pattern maximal 
  

ficohen  cooper  creed  marx   salamon

defined disjoint
proof  let tractable flat pattern  consider pattern

union two copies   lemma     csp  
tractable
 
csp     csp  
hence csp   maximal tractable class 
follows cannot characterise tractable forbidden patterns exhibiting
maximal tractable classes defined forbidding pattern  or finite set patterns 
since lemma     finite set replaced single pattern   indeed 
consequence lemma     construct infinite chain patterns 
forbidding one gives rise slightly larger tractable class  naturally  place
upper bound size patterns finitely many patterns
consider  maximal tractable classes defined forbidden patterns bounded size
necessarily exist 

   binary flat negative patterns
moment  able make conjecture concerning complete characterisation complexity general forbidden patterns  although conjecture
dichotomy exists  nonetheless  restricting attention special case  forbidden
binary flat negative patterns  able obtain dichotomy  recall pattern
flat structure imposed variables distinct 
negative constraint patterns h  i  never takes value  
begin defining three particular patterns one infinite class patterns 
use patterns characterise large class intractable patterns  prove
finite set flat negative patterns class simple structure  one
patterns must contained one particular set patterns  call pivots 
means tractable set patterns must include pattern occurs
pivot pattern  furthermore  demonstrate forbidding pivot pattern gives rise
tractable class  leads simple characterisation tractability finite
sets binary flat negative patterns 
pattern   cycle   
c 
c
v 

v 

v 

v 

v 

neq v            v   

  

v 

fitractability csp classes defined forbidden patterns

pattern   valency
x 

x  

x 

x  

x 

x  
neq x    x    x    x     neq x     x     x    

pattern    path

v 

v 

v 

w 

w 

w 

neq v    v    v    w    neq w    w    w   
definition     below  define concept neg connected binary pattern 
correspond binary patterns true constraint graph every realisation
binary csp instance connected graph  first generalise notion true
constraint graph csp patterns  call resulting graph negative structure graph 
definition      let binary pattern  vertices negative structure
graph g variables   pair vertices edge g form
scope whose constraint pattern assigns least one tuple value f   say
pattern neg connected negative structure graph connected  case
negative patterns  use simpler term connected instead neg connected 
pattern    valency   pattern     path  pattern     valency path 
connected  note pattern connected may occur connected pattern
 and vice versa   pattern   shows cycle    connected  one example
generic pattern cycle k  k    structure cycle k 
variables distinct  except special case k     structure
includes neq c  c     additional requirement means cycle    composed
single binary constraint pattern containing two distinct disallowed tuples  following
theorem uses patterns show patterns intractable 

  

ficohen  cooper  creed  marx   salamon

pattern    valency path
v 

v 
w 
v 

w 

w 

x

neq v    v    v     neq w    w    w     neq x  w   
theorem      let x finite set neg connected binary patterns  if  x  
least one cycle k   for k     valency  path  valency path occurs
  x intractable 
proof  let x finite set neg connected negative binary patterns let  
number variables largest element x  
assuming least one four patterns occurs x   construct
class csps element x occurs polynomial time
reduction well known np complete problem  sat  garey   johnson        
construction involve three gadgets  examples shown figure   
gadgets serve particular purpose 
   cycle gadget  shown figure   a  special case   variables  enforces
cycle boolean variables  v    v            vr   take value 
   clause gadget figure   b  equivalent clause v  v  v    since vc
value domain one three vi variables set true 
obtain   clauses three variables inverting domains vi
variables 
   line gadget figure   c   imposes constraint v  v    used
impose logically equivalent constraint v  v   
cycle gadget connected clause gadget via line gadgets  three types
gadgets specified ensure one negative edge adjacent
vertex coloured microstructure  except cycle gadget connected line
gadget 
now  suppose instance  sat n propositional variables
x            xn clauses c            cm  
begin construction csp instance p solve  sat instance using
n copies cycle gadget  figure   a    m        variables               n 
m     
variables along ith copy cycle denoted  vi    vi            vi
  
  

fitractability csp classes defined forbidden patterns

v 

f

v 

vc
v 

v 

v 


f
v 

f

v 
 a 

 b 


f
v 

v 
 c 

figure     a  making copies variable  v    v    v    v      b  imposing
ternary constraint vc   v  v  v     c  line constraints length  
imposes v  v   

solution csp instance p constraints 
variables vij   j              m        must value  di   therefore consider
vij copy xi  
consider clause cw   eight cases consider similar
show details one case  suppose cw xi xj xk  
build clause gadget  figure   b   three boolean variables ciw   cjw ckw
invert domain ckw since occurs negatively cw   solution
constructed csp must satisfy s ciw   s cjw   s ckw      
complete insertion cw csp instance adding line gadgets
length        figure   c    connect cycle gadgets corresponding xi   xj xk
w     
clause gadget clause cw since xi   xj xk occur cw   connect vi
w     
ciw since xi positive cw   s ciw     possible s vi
     
  

ficohen  cooper  creed  marx   salamon

w     

solution s  similarly  connect vj
cjw   finally  since xk occurs negatively
cw   impose line constraints direction  ensures s ckw     f
w     
possible s vk
    f   imposing constraints ensures solution
possible least one cycles corresponding variables xi   xj   xk
assigned value would make corresponding literal cw true 
continue construction clause  sat instance  since   constant 
clearly polynomial reduction  sat 
show csp instance p constructed manner described cannot contain pattern x   showing neg connected
pattern containing cycle k   for   k     valency  path  valency path
occur instance  sufficient show csp instance p contain
patterns x  
csp instance p constraint contains one disallowed tuple  thus 
x cycle    cannot occur p   furthermore  p built
cycles length m        paths length        cannot contain cycles less
      vertices  thus  since   maximum number vertices element x  
follows x cycle k    k    occur p  
define valency variable x number distinct variables share
constraint pattern x  suppose valency   x neg connected 
possible require variable valency four   pair
variables valency three connected path length   negative structure
graph   certainly p variables valency four  moreover  fact p
built using paths length       means two valency three variables joined
path length    thus  x occur p valency  
next  consider case path   x neg connected  must
two distinct  but possibly overlapping  three variable lines  with disallowed tuples
constraint patterns match domain values  separated   variables 
place disallowed tuples meet p connect line gadget
cycle gadget  connection sites always distance greater   
conclude   p whenever path  
finally  consider case valency path   x neg connected 
here  must variable valency least   path constraint patterns
three variables intersecting disallowed tuples  must connected path
less   variables negative structure graph   observed above 
places p disallowed tuples meeting line gadget meets
cycle gadget  path least   variables one points
every variable valency    thus    p whenever valency path  
remains consider sets negative binary patterns could tractable 
this  need define pivot patterns  pivot r   contain every tractable negative
binary pattern 
definition      let v    p   v            vr    w            wr    x            xr       a  b 
   neq p  v            vr   w            wr   x            xr     define pattern pivot r   
  

fitractability csp classes defined forbidden patterns

pattern    pivot   
v 

v 

v 
w 

w 

w 

p

x 

x 

x 

b

neq p  v    v    v    w    w    w    x    x    x   

hv  d  cp cv cw cx   si 
cp    h p  v     ab   h p  w     ab   h p  x     bb i 
cv    h vi   vi      ab                r   
cw    h wi   wi      ab                r   
cx    h xi   xi      ab                r   
ab  a  b    f   ab  s  t    u  for  s  t      a  b    bb  b  b    f   bb  s  t    u
 for  s  t      b  b    pattern pivot r  structure variables
distinct  see pattern    example  pivot    
say pattern variables v            vr distinct variable pattern
structure includes neq v            vr    following proposition characterises sets
connected binary flat negative distinct variable patterns theorem     prove
intractable 
proposition      connected binary flat negative distinct variable pattern either
contains cycle k   for k     valency  path  valency path 
occurs pivot r  integer r    
proof  suppose contain patterns valency  cycle k   for k    
path  valency path  recall valency variable x number distinct
variables share constraint pattern x  since contain valency
contain one variable valency three variables must valency
two  moreover  since cycle k    k    negative structure graph
contain cycles  thus  since connected  negative structure graph
consists three disjoint paths joined single vertex  two disallowed tuples
  

ficohen  cooper  creed  marx   salamon

distinct scopes intersect  call union scopes footprint
intersection  fact negative structure graph acyclic
contain path means pairs intersecting disallowed tuples must
footprint  moreover  fact contain valency path means
intersections must occur variable valency    exists  fact
flat negative means renaming extension pair disallowed tuples ha  bi 
hc  di scope hu  vi merged domain renaming function t 
i e  t hu  ai    t hu  ci  t hv  bi    t hv  di   follows occurs pivot r  
r    
corollary      let x finite set connected binary flat negative distinct variable
patterns  csp x   tractable x occurs pivot r  
integer r    
prove result patterns necessarily distinct variable 
corollary      let x finite set connected binary flat negative patterns 
csp x   tractable x occurs pivot r   integer
r    
proof  connected binary flat negative pattern  let dv   denote set connected
binary flat negative distinct variable patterns occurs 
domain    variables  use dv x   denote union sets dv  
x  
lemma       csp   csp dv     every csp instance p p  
p dv    follows csp dv    csp    hence
csp     csp dv     since csp x   intersection csp   x
csp dv x    intersection csp dv    x   csp x    
csp dv x    
corollary      csp dv x    tractable pattern dv   
x   occurs pivot r  r      but  definition dv    occurs
        therefore  csp x   tractable occurs pivot r  integer
r    
arbitrary  not necessarily flat negative  binary csp pattern   denote
neg   flat negative pattern obtained replacing truth values
u constraint patterns ignoring structure beyond disequalities
variables  recall structure flat pattern contains disequality relations
variables  neg   flat pattern definition  set patterns x  
neg x   naturally defined set neg x      neg     x    clearly csp neg x   
csp x    following result follows immediately corollary      provides
necessary condition tractability general patterns 
corollary      let x finite set binary patterns x   neg  
connected  csp x   tractable x neg   occurs
pivot r   integer r    
  

fitractability csp classes defined forbidden patterns

   pivot theorem
theorem      pivot r  tractable r   
theorem together corollary     immediately provides dichotomy finite
sets connected binary flat negative patterns  section devoted proof
theorem  which call pivot theorem   conclude section giving
dichotomy finite sets flat negative patterns necessarily connected 
need definitions graph theory 
definition      subdivision graph g graph obtained replacing edges
g simple paths 
minor graph g graph obtained g deleting edges  contracting
edges removing isolated vertices  graph h topological minor graph g
subdivision h subgraph g 
need use following well known theorem robertson seymour        
theorem      every planar graph h integer k     graph
contain h minor  tree width k 
particular  graph large tree width  contains large grid minor 
section consider hexagonal grid minors instead  see figure     reason
well known fact graph maximum degree three minor another graph 
topological minor latter notion convenient proofs 
illustrated figure    h hexagonal grid graph composed hexagons honeycomb
pattern  width h number hexagons horizontal vertical directions 
definition      let g   r n every graph tree width least g r  contains
  r      hexagonal grid topological minor 
let us observe following simple property first 
lemma      three degree three vertices hexagonal grid width  r begin disjoint
paths length r 
proof  vertex different row simply choose path
along row  in direction away nearest boundary grid   see vertices
a  b c figure   visualise typical situation 
otherwise may possible  rotating grid         degrees get
three vertices lie different rows  cannot separate vertices rotating
corners equilateral triangle  x  y  z p  q  r diagram 
triangle interior row  row   x  y  z diagram 
extend two vertices along row drop third interior row
along row  thus  example  path beginning would drop one row
continue along row   
remaining case three vertices form equilateral triangle occupying
two adjacent rows  p  q  r diagram  case orientation
two vertices row lie along edge
  

ficohen  cooper  creed  marx   salamon

grid  diagram rotate either         degrees achieve p  q  r 
extend two three vertices along row third shift away
centre triangle order find empty row along path
extended 
row  
b



x

row  
row  

z

row  

c
row  
row  
row  

r
p

q

figure    hexagonal grid width   rows picked bold numbered 
following combinatorial result crucial algorithm  interesting
right 
lemma      let g   connected graph tree width least g r  let a  b  c
distinct vertices g  g contains   pairwise vertex disjoint paths starting a  b  c 
respectively  length r 
proof  let h   r      hexagonal grid  definition g r   graph g contains
h topological minor  note h contains vertices degree   boundary 
cause complications proof  avoid complication  observe
h subdivision graph h whose every vertex degree   focus
graph h instead 

let hg
denote subdivision h appearing g let denote vertices

degree three hg
  mengers theorem  dirac        vertex disjoint paths pa  
pb   pc g a  b  c distinct vertices sa   sb   sc s  respectively  choose paths

way total number edges used hg
minimized 

let x  two vertices correspond adjacent vertices h   means

hg
contains path q endpoints x whose internal vertices disjoint
s  suppose that  say  pa contains internal vertex q  claim either    
x   sa   sb   sc       sa  x  y  pb   pc disjoint q  suppose    
hold  say  x    sa   sb   sc    consider internal vertex q q closest x used
  

fitractability csp classes defined forbidden patterns

one paths  reroute path q x without using edges

outside hg
  would create new set paths smaller number edges outside


hg   unless rerouted path use edges outside hg
q 
possible path goes q q  means one path
intersecting q  path intersects q q x definition q
path uses vertices q y  thus case     holds 
lemma     three independent paths length r     vertices sa   sb
sc  non subdivided  hexagonal grid h  correspond paths xa   xb   xc

hg
  use paths create three independent paths length least r a  b
c g  definition  path xa go sb sc   therefore  claim
previous paragraph  xa disjoint pb pc   xa uses path q x
y  sb   sc    x  y  means neither         happen pb pc intersects
q  xa disjoint pa well  create new path ta simply concatenating
pa xa   otherwise  way xa intersect pa first subdivided edge
h xa goes  this place case     claim happen  
case  create new path ta following pa meets subdivided edge
following xa   edge h corresponds   edges h  path ta could
meet   edges h fewer xa does  path ta will  either case  meet
least r subdivided edges h length least r  build tb tc
analogous fashion 
require following technical lemma proofs 
lemma      let p binary csp instance  suppose assignment x 
d  extend solution p solution assigning x
d  y  path proper binary constraints x y  furthermore 
path first constraint along path disallows tuple hd  d 
last constraint disallows tuple hd    d  i 
proof  let sx solution p including assignment x similarly let sy
solution p including assignment d  y 
define graph g variables p   edge x variable z
assignment x incompatible domain value z  similarly 
edge variable z assignment d  incompatible
domain value z  finally edge two variables
x constraint proper 
let cx component g containing x  define assignment variables
p setting s z    sx  z  z cx s z    sy  z  otherwise  solution
p since possible unsatisfied constraint would variable cx
variable cx   choice cx cannot happen 
hypothesis  know s y     d  required path proper
binary constraints 
note lemma     binary constraint x forbids
assigning x d  y  setting d    d  d    yields required path
proper binary constraints  length one 
first show csp pivot r   tractable special case restricted structure 
  

ficohen  cooper  creed  marx   salamon

lemma      subclass csp pivot r   consisting instances 
arc consistent binary reduction 
unary constraints variables degree two constraint graph 
true constraint graph subdivided three connected graph 

time complexity n  dg r     

proof  let p instance satisfying conditions lemma  time nd   
join binary constraints along subdivided edge eliminating intermediate variables
go  obtain instance p     whose constraint graph three connected 
may improper binary constraints arbitrary unary constraints  let g denote
true constraint graph p g  three connected graph obtained g
contracting subdivided edges  true constraint graph p   subgraph g 
vertex set 

solve p   csp negtrans  time n  d   n   d   cooper   zivny      b  

clearly n  dg r    since g r    r  furthermore  g  tree width

g r  p   solved time ndg r     dechter   pearl         either
case solution extended solution original instance p time o nd  
remaining case consider negtrans occurs p   tree
width g  least g r   complete proof deriving contradiction
p   csp pivot r    order show case cannot occur 
suppose negtrans occurs p   variables a  b  c values da   db   dc  
da

dc



c
db
b

lemma      g  contains   vertex disjoint paths ta   tb   tc starting a  b  c  respectively  length least r  recall true constraint graph g
original instance p subdivided three connected graph p   obtained
p joining binary constraints along subdivided edges  let ta   tb   tc denote paths
g corresponding ta   tb   tc g    recall negtrans occurs p   variables
a  b  c values da   db   dc  
let c first vertices along subdivided edges b c
g  embedding negtrans p   shows hdb   da disallowed join
arc consistent path b a  since path is  construction  subdivision
edge p   know unary constraints occur internal vertices  know 
arc consistency binary constraints  assignments   da b   db
extend consistent assignment path b  so  lemma     know
value da domain hdb   da disallowed p
  

fitractability csp classes defined forbidden patterns

constraint b a  similarly value dc hdb   dc disallowed p
constraint c  appending path b path ta
path b c tc   together tb   obtain three independent paths length
least r proper constraints p   beginning variable b  two beginning constraints
disallowing tuple value db b  shown pivot r  indeed occur
p done 
csp pivot r   places upper bound length chain dependencies
may followed discard partial solution cannot extended solution 
informally speaking  forbidding pivot r  pattern bounds amount local search
may done extending partial solution larger partial solution 
amount effort may required increases length chains inference 
worst case behaviour quantified precisely following result  first
require definitions 
definition      let g graph u subset vertices g  induced graph
g u   g u graph vertex set u whose edges edges g
connect two vertices u  
graphs g   hv  ei g    hv     e   define g g    hv v     e e   i 
graph g say hu    u  separation g   g u    g u    neither
u    u  subset other  separator separation hu    u  u  u 
order  u  u     minimal separator one minimal order 
torso u  separation hu    u  obtained induced graph g u   
adding every edge vertices separator hu    u  i 

theorem       class pivot r  free instances solvable time n  dg r     
proof  prove result induction number variables 
base case straightforward  instance fewer g r    variables 
clearly solve exhaustive search time n  dg r      inductive case

assume solve smaller instances n   k variables time n  dg r     
let p pivot r  free instance n   k variables  first make p arc consistent
time o n  d     bessiere  regin  yap    zhang         since p arc consistent  unary
constraints longer effect  remove unary improper binary constraints
p time o n  d     let g true constraint graph resulting instance  p    
g separation order two either three connected three
vertices  three connected case solve p     hence p   time n  dg r   
lemma      p three variables trivial solve time o d    
so  assume g separation order two  definition torso
size   separator torso size   separator g  hence find size   separation
hu    u  torso u  separation order two  assume
torso u  either three connected three vertices 
consider separator   u  u  hu    u  i  empty p   composed two smaller independent
pivot r  free instances solved time

 
g r   
 
g r   
n 
  n 
n    n    n   n    n    n  follows

solve p time n  dg r      done 
  

ficohen  cooper  creed  marx   salamon

   m  consider structure g u     three connected 
vertex degree least three  case add unary constraint
and  lemma      solve instance time n  dg r      hence find  time

dn  dg r      values variable extend variables u    adding restriction unary constraint variable leaves induced instance u  pivot r  free

see  induction  solve p   time dn  dg r       n     dg r     

n  dg r      done 
finally must consider    x  y   since minimal know g u   
connected path x u    denote q csp instance
induced g u     together path u  x y  constraint graph
q subdivision torso u  either three connected three
vertices  latter case q tree width two so  addition unary
constraints x y  solved time o n  d     dechter   pearl         torso
u  three connected degrees x q least three 
addition
unary constraints x can  lemma      solve case time
n  dg r      hence solve q possible unary constraints x

allow one value x y  time d  n  dg r     
value variable x know whether extends solution
variables q  similarly  value variable know whether extends
solution variables q  express two restrictions unary constraints 
u x  u y  x y  lastly find binary constraint c x  y  x
specifies precisely pairs values  allowed u x  u y   extend variables
u    obtain solving subdivided three connected instance seeing
pairs disallowed subdivided edge u  pairs set constraint
relation c x  y  f  
u x  allows values x p solution stop 
consider instance r  induced p   u  together constraints
u x   u y  c x  y   construction  p solution r solution 
pivot t  occurring r must use pair values disallowed c x  y  since cannot
occur p     suppose hd  d  disallowed c x  y   follows assignment
x  d  extend solution q assigning x d 
extend solution problem induced p   u    lemma     path
proper constraints x g u     furthermore  first constraint along
path disallows tuple hd  d  last constraint disallows tuple hd    d  i 
follows cannot embed pivot r  instance r induced u  together
constraint c x  y   otherwise would able embed
instance p   
since r csp pivot r    solve time n  dg r    inductive hypoth

esis  thus  final case  complexity d  n  dg r      n  dg r      n  dg r   
done 
theorem     important gives us tractable class csps defined forbidding
negative pattern which  unlike csp tree   contains problems unbounded tree width 
cannot captured structural tractability  true even pivot    
example class csp instances csp pivot     unbounded tree width 
consider n variable csp instance pn domain             n  whose constraint graph
  

fitractability csp classes defined forbidden patterns

complete graph and  pair distinct values i  j             n   constraint
variables vi   vj disallows single pair assignments  hvi   ji   hvj   ii   since assignment hvi   ji occurs single disallowed tuple  pivot    occur pn   hence
pn csp pivot      produce example class instances csp pivot    
unbounded tree width csp negtrans   modify pn
introducing boolean variable vij pair   j replacing constraint
variables vi   vj constraints vi   vij vj   vij   former disallowing single pair
assignments  hvi   ji   hvij    i  latter pair assignments  hvj   ii   hvij    i  
pattern negtrans occurs triple assignments  hvi   ji   hvij    i   hvj   ii  
dichotomy finite sets connected binary flat negative patterns follows
directly theorem     corollary     
theorem       let x finite set connected binary flat negative patterns  x
tractable x contained pivot r   integer
r    
informally speaking  dichotomy states bounding length problematic
pivot r  style inference chains leads tractability  moreover class
instances defined finite set forbidden flat patterns tractable  must avoid
problematic inference chains form 
dichotomy easily extends patterns necessarily connected 
negative pattern connected  decomposed connected patterns corresponding connected components negative structure graph   call
patterns connected components  
corollary       let x finite set binary flat negative patterns  x tractable
x   connected components contained
pivot r   integer r    
proof  let x finite set binary flat negative patterns  let cc   represent set
connected components pattern   cc x   union sets cc     x   
suppose x tractable  consider arbitrary subset x   cc x  
set x   contains exactly one connected component pattern x   lemma     
csp x     csp x    hence x   tractable  therefore  corollary     
pattern   x   occurs pivot r   integer r       way
true possible choices x   x connected
components occur pivot r   integer r    
hand  suppose x   connected components
x occurs pivot r   r     let k number connected components
  occurs disjoint union k copies pivot r   tractable
theorem     k   applications lemma      follows   hence x  
tractable 

   conclusion
paper described framework identifying classes csps terms forbidden
patterns  used tool identifying tractable classes csp  gave several
examples small patterns used define tractable classes csps 
  

ficohen  cooper  creed  marx   salamon

search general result  restricted special case binary
patterns binary csps  theorem     showed csp x   np hard every
pattern set x contains least one four patterns  patterns                moreover 
showed binary flat negative pattern contain patterns
must contained within  possibly several copies of  special type pattern called
pivot  hence  contained  several copies of  pivot necessary condition
pattern tractable  showed forbidding pivot pattern defines
tractable class 
beyond dichotomy binary flat negative patterns  interesting see
new tractable classes defined general binary patterns non binary
patterns  particular  important area future research determining maximal
tractable classes problems defined patterns fixed size  given number
variables number variable value assignments   avenue future research
characterisation complexity patterns involving structure uses
disequalities groups variables  total ordering variables 

acknowledgments
authors acknowledge support anr project anr    blan       epsrc grants
ep f         ep i          erc starting grant paramtight  no          
epsrc platform grant ep f         

references
bessiere  c   regin  j  c   yap  r  h  c     zhang  y          optimal coarse grained
arc consistency algorithm  artificial intelligence           pp          doi         
j artint             
bulatov  a   jeavons  p     krokhin  a          classifying complexity constraints
using finite algebras  siam journal computing          pp          doi    
     s                 
bulatov  a  a          tractable conservative constraint satisfaction problems  lics    
proceedings   th ieee symposium logic computer science  pp         
doi         lics              
bulatov  a  a          dichotomy theorem constraint satisfaction problems  element set  journal acm          pp         doi                         
cohen  d     jeavons  p          complexity constraint languages  rossi et al 
 rossi et al          chap     pp         
cohen  d  a          new class binary csps arc consistency decision
procedure  cp     proceedings  th international conference principles
practice constraint programming  no       lecture notes computer
science  pp          springer verlag  doi                              
cooper  m  c     escamocher  g          dichotomy   constraint forbidden csp
patterns  aaai     proceedings twenty sixth aaai conference ar  

fitractability csp classes defined forbidden patterns

tificial intelligence  available from  https   www aaai org ocs index php aaai 
aaai   paper view           
cooper  m  c   jeavons  p  g     salamon  a  z          generalizing constraint satisfaction
trees  hybrid tractability variable elimination  artificial intelligence        
     pp          doi         j artint             
cooper  m  c     zivny  s       a   hierarchically nested convex vcsp  cp     proceedings   th international conference principles practice constraint
programming  pp          springer verlag  doi                              
cooper  m  c     zivny  s       b   hybrid tractability valued constraint problems 
artificial intelligence             pp            doi         j artint         
    
costa  m  c          persistency maximum cardinality bipartite matchings  operations
research letters          pp          doi                              
dalmau  v   kolaitis  p  g     vardi  m  y          constraint satisfaction  bounded
treewidth  finite variable logics  cp     proceedings  th international conference principles practice constraint programming  no      
lecture notes computer science  pp          springer verlag  doi         
                 
dechter  r     pearl  j          network based heuristics constraint satisfaction problems  artificial intelligence          pp       doi                              
dechter  r     pearl  j          tree clustering constraint networks  artificial intelligence          pp          doi                              
dirac  g  a          short proof mengers graph theorem  mathematika          pp 
      doi         s                 
freuder  e  c          complexity k tree structured constraint satisfaction problems 
aaai     proceedings eighth national conference artificial intelligence 
pp      available from  http   www aaai org library aaai      aaai       
php 
garey  m  r     johnson  d  s          computers intractability  guide theory
np completeness  w  h  freeman  san francisco  ca 
gottlob  g   leone  n     scarcello  f          hypertree decompositions tractable
queries  journal computer system sciences          pp          doi    
     jcss           
green  m  j     cohen  d  a          tractability approximating constraint languages 
cp     proceedings  th international conference principles practice
constraint programming  vol       lecture notes computer science  pp     
     springer verlag  doi                              
grohe  m          structure tractable constraint satisfaction problems  mfcs    
proceedings   st symposium mathematical foundations computer science  vol       lecture notes computer science  pp        springer verlag 
doi                    
  

ficohen  cooper  creed  marx   salamon

grohe  m          complexity homomorphism constraint satisfaction problems
seen side  journal acm          pp       doi         
                
gyssens  m   jeavons  p  g     cohen  d  a          decomposing constraint satisfaction
problems using database techniques  artificial intelligence          pp        doi 
                             
jeavons  p   cohen  d     gyssens  m          closure properties constraints  journal
acm          pp          doi                       
jeavons  p  g     cooper  m  c          tractable constraints ordered domains  artificial
intelligence          pp          doi                              
jegou  p          decomposition domains based micro structure finite
constraint satisfaction problems  aaai     proceedings eleventh national conference artificial intelligence  pp          available from  http 
  www aaai org library aaai      aaai       php 
marx  d       a   beat treewidth   theory computing         pp        
doi         toc      v   a    
marx  d       b   tractable hypergraph properties constraint satisfaction conjunctive queries  stoc     proceedings   nd acm symposium theory
computing  pp          acm  doi                         
regin  j  c          filtering algorithm constraints difference csps  aaai    
proceedings twelfth national conference artificial intelligence  vol     pp 
        available from  http   www aaai org library aaai      aaai       
php 
robertson  n     seymour  p  d          graph minors  v  excluding planar graph  journal combinatorial theory  series b      pp         doi                      
        
rossi  f   van beek  p     walsh  t   eds            handbook constraint programming 
foundations artificial intelligence  elsevier 
salamon  a  z     jeavons  p  g          perfect constraints tractable  cp    
proceedings   th international conference principles practice constraint programming  vol       lecture notes computer science  pp         
springer verlag  doi                              
van hoeve  w  j          alldifferent constraint  survey  proceedings  th
annual workshop ercim working group constraints  available from 
http   arxiv org abs cs        v  
weigel  r     bliek  c          reformulation constraint satisfaction problems 
ecai     proceedings   th european conference artificial intelligence  pp 
       

  


