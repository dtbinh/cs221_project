journal of artificial intelligence research               

submitted        published      

the tractability of csp classes defined by forbidden patterns
david a  cohen

dave cs rhul ac uk

department of computer science
royal holloway  university of london
egham  surrey  uk

martin c  cooper

cooper irit fr

irit
university of toulouse iii        toulouse  france

paid creed

p creed qmul ac uk

school of mathematical sciences
queen mary  university of london
mile end  london  uk

daniel marx

dmarx cs bme hu

computer and automation research institute
hungarian academy of sciences  mta sztaki 
budapest  hungary

andras z  salamon

andras salamon ed ac uk

laboratory for foundations of computer science
school of informatics  university of edinburgh  uk

abstract
the constraint satisfaction problem  csp  is a general problem central to computer
science and artificial intelligence  although the csp is np hard in general  considerable
effort has been spent on identifying tractable subclasses  the main two approaches consider
structural properties  restrictions on the hypergraph of constraint scopes  and relational
properties  restrictions on the language of constraint relations   recently  some authors
have considered hybrid properties that restrict the constraint hypergraph and the relations
simultaneously 
our key contribution is the novel concept of a csp pattern and classes of problems
defined by forbidden patterns  which can be viewed as forbidding generic sub problems   we
describe the theoretical framework which can be used to reason about classes of problems
defined by forbidden patterns  we show that this framework generalises certain known
hybrid tractable classes 
although we are not close to obtaining a complete characterisation concerning the
tractability of general forbidden patterns  we prove a dichotomy in a special case  classes
of problems that arise when we can only forbid binary negative patterns  generic subproblems in which only disallowed tuples are specified   in this case we show that all  finite
sets of  forbidden patterns define either polynomial time solvable or np complete classes
of instances 
c
    
ai access foundation  all rights reserved 

ficohen  cooper  creed  marx   salamon

   introduction
in the constraint satisfaction paradigm we consider computational problems in which we
have to assign values  from a domain  to variables  under some constraints  each constraint
limits the  simultaneous  values that a list of variables  its scope  can be assigned  in a
typical situation some pair of variables might represent the starting times of two jobs in a
machine shop scheduling problem  a reasonable constraint would require a minimum time
gap between the values assigned to these two variables 
constraint satisfaction has proved to be a useful modelling tool in a variety of contexts 
such as scheduling  timetabling  planning  bio informatics and computer vision  this has
led to the development of a number of successful constraint solvers  unfortunately  solving
general constraint satisfaction problem  csp  instances is np hard and so there has been
significant research effort into finding tractable fragments of the csp 
in principle we can stratify the csp in two quite distinct and natural ways  the structure of the constraint scopes of an instance of the csp can be thought of as a hypergraph
where the variables are the vertices  or more generally as a relational structure  we can find
tractable classes by restricting this relational structure  while allowing arbitrary constraints
on the resulting scopes  dechter   pearl         sub problems of the general constraint
problem obtained by such restrictions are called structural  alternatively  the set of allowed assignments to the variables in the scope can be seen as a relation  we can choose
to allow only specified kinds of constraint relations  but allow these to interact in an arbitrary structure  jeavons  cohen    gyssens         such restrictions are called relational
or language based 
structural subclasses are defined by specifying a set of hypergraphs  or relational structures  which are the allowed structures for csp instances  it has been shown that tractable
structural classes are characterised by limiting appropriate  structural  width measures
 dechter   pearl        freuder        gyssens  jeavons    cohen        gottlob  leone 
  scarcello        marx      a      b   for example  a tractable structural class of binary
csps is obtained whenever we restrict the constraint structure  which is a graph in this
case  to have bounded tree width  dechter   pearl        freuder         in fact  it has
been shown that  subject to certain complexity theoretic assumptions  the only structures
which give rise to tractable csps are those with bounded  hyper  tree width  dalmau 
kolaitis    vardi        grohe              marx      a      b  
relational subclasses are defined by specifying a set of constraint relations  the complexity of the subclass arising from any such restriction is precisely determined by the so
called polymorphisms of the set of relations  bulatov  jeavons    krokhin        cohen
  jeavons         the polymorphisms specify that  whenever some set of tuples is in a
constraint relation  then it cannot be the case that a particular tuple  the result of applying
the polymorphism  is not in the constraint relation  it is thus the relationship between allowed tuples and disallowed tuples inside the constraint relations that is of key importance
to the relational tractability of any given class of instances  whilst a general dichotomy has
not yet been proven for the relational case  many dichotomies on sub problems have been
obtained  for instance those by bulatov         bulatov et al         or bulatov        
  

fitractability of csp classes defined by forbidden patterns

using only structural or only relational restrictions limits the possible subclasses that
can be defined  by allowing restrictions on both the structure and the relations we are able
to identify new tractable classes  we call these restrictions hybrid reasons for tractability 
several hybrid results have been published for binary csps  jegou        weigel   bliek 
      cohen        salamon   jeavons        cooper  jeavons    salamon        cooper  
zivny      b   instead of looking at the set of constraint scopes or the constraint language 
these results captured tractability based on the properties of the  coloured  microstructure
of csp instances  the microstructure of a binary csp instance is the graph hv  ei where v
is the set of possible assignments of values to variables and e is the set of pairs of mutually
consistent variable value assignments  jegou         in the coloured microstructure  the
vertices representing an assignment to variable vi are labelled by a colour representing
variable vi   this maintains the distinction between assignments to different variables 
the coloured microstructure of a csp instance captures both the structure and the
relations of a csp instance and so it is a natural place to look for tractable classes which are
neither purely structural nor purely relational  of the results on  coloured  microstructure
properties  three are of particular note  first it was observed that the class of instances
with a perfect microstructure is tractable  salamon   jeavons         this is a proper
generalisation of the well known hybrid tractable csp class whose instances allow arbitrary
unary constraints and in which every pair of variables is constrained to be not equal  regin 
      van hoeve         and of the hybrid class whose microstructure is triangulated  jegou 
      weigel   bliek        cohen         the perfect microstructure property excludes
an infinite set of induced subgraphs from the microstructure 
secondly  the joint winner property  jwp   cooper   zivny      b  applied to csps
provides a different hybrid class that also strictly generalises the class of csp instances
with a disequality constraint      between every pair of variables and an arbitrary set of
unary constraints  but does so by forbidding a single pattern  a subgraph  in the coloured
microstructure  the jwp has been generalized to hierarchies of soft non binary constraints  cooper   zivny      a   including  for example  soft hierarchical global cardinality
constraints  by reduction to a minimum convex cost flow problem 
thirdly  the so called broken triangle property properly extends the structural notion
of acyclicity to a more interesting hybrid class  cooper et al          the broken triangle
property is specified by excluding a particular pattern in the coloured microstructure  it is
the notion of forbidden pattern that we study in this paper  we therefore work directly with
the csp instance  or equivalently its coloured microstructure  rather than its microstructure
abstraction which is a simple graph  this allows us to introduce a language for expressing
hybrid classes in terms of forbidden patterns  providing a framework in which to search
for novel hybrid tractable classes  in the case of binary negative patterns we are able
to characterise all tractable  finite sets of  forbidden patterns  we also state a necessary
condition for the tractability of a  finite set of  general patterns 
    contributions
in this paper we generalise the definition of a csp instance to that of a csp pattern
which has three types of tuple in its constraint relations  tuples which are explicitly al  

ficohen  cooper  creed  marx   salamon

lowed disallowed and tuples which are labelled as unknown    by defining a natural notion
of containment of patterns in a csp  we are able to describe problems defined by forbidden
patterns  a class of csp instances defined by forbidding a particular pattern  are exactly
those instances that do not contain   we use this framework to capture tractability by
identifying local patterns of allowed and disallowed tuples  within small groups of connected
constraints  whose absence is enough to guarantee tractability 
using the concept of forbidden patterns  we lay foundations for a theory that can be
used to reason about classes of csps defined by hybrid properties  since this is the first
work of this kind  we primarily focus on the simplest case  binary patterns in which tuples
are either disallowed or unknown  called negative patterns   we give a large class of binary
negative patterns which give rise to intractable classes of problems and  using this  show
that any negative pattern that defines a tractable class of problems must have a certain
structure  we are able to prove that this structure is also enough to guarantee tractability
thus providing a dichotomy for tractability defined by forbidding binary negative patterns 
importantly  our intractability results also allow us to give a necessary condition on the
form of general tractable patterns 
the remainder of the paper is structured as follows  in section   we define constraint
satisfaction problems  and give other definitions used in the paper  then  in section    we
define the notion of a csp pattern and describe classes of problems defined by forbidden
patterns  we give some examples of tractable classes defined by forbidden patterns on three
variables  in section   we show that one must take the size of patterns into account to have
a notion of maximal classes defined by forbidding patterns  in general  we are not yet able
to make any conjecture concerning a dichotomy for hybrid tractability defined by general
forbidden patterns  however  in section   we are able to give a necessary condition for such
a class to be tractable and in section   prove the dichotomy for negative patterns  finally 
in section   we summarise our results and discuss directions for future research 

   preliminaries
definition      a csp instance is a triple hv  d  ci where 
 v is a finite set of variables  with n    v    
 d is a finite set called the domain  with d    d   
 c is a set of constraints  each constraint c  c is a pair c   h  i where 
  is a list of distinct variables called the scope of c 
  is a relation over d of arity    called the relation of c  it is the set of tuples
allowed by c 
a solution to the csp instance p   hv  d  ci is a mapping s   v  d where  for each
h  i  c we have s      where s   represents the tuple resulting from the application
of s component wise to the list of variables   
   this can be viewed as the natural generalisation of the csp to a three valued logic 

  

fitractability of csp classes defined by forbidden patterns

for simplicity of presentation  we assume that all variables have the same domains 
unary constraints can be used to impose different domains for different variables 
the arity of a csp is the largest arity of any of its constraint scopes  our long term
aim is to identify all tractable subclasses of the csp problem which can be detected in
polynomial time  in this paper we describe a general theory of forbidden patterns for
arbitrary arity but only consider the implications of the new theory for tractable classes of
arity two  binary  problems specified by finite sets of forbidden patterns  in such cases we
are certain that class membership can be decided in polynomial time 
the csp decision problem  which asks whether a particular csp instance has a solution 
is already np complete for binary csps  for example  there is a straightforward reduction
from graph colouring to this problem in which the set of colours is used as the domain of
the csp instance  vertices i of the graph map to csp variables vi   and edges  i  j  map to
disequality constraints vi    vj  
it will sometimes be convenient in this paper to use an equivalent functional formulation
of a constraint  in this alternative formulation the scope  of the constraint h  i is abstracted to a set of variables and each possible assignment is seen as a function f     d 
the constraint relation in this alternative view is then a function from the set of possible
assignments  d   into the set  t  f   where  by convention  the tuples which occur in the
constraint relation are those which map to t   it follows that any assignment to the set of
all variables is allowed by h  i when its restriction to  is mapped to t by  
definition      for any function f   x  y and s  x  the notation f  s means the
function with domain s satisfying f  s  x    f  x  for all x  s 
given a set v of variables and a domain d  a constraint in functional representation
is a pair h  i where   v and    d   t  f    a csp instance in functional representation is a triple hv  d  ci where c is a set of constraints in functional representation 
a solution  to a csp instance hv  d  ci in functional representation  is a mapping
s   v  d where  for each h  i  c we have  s      t  
the functional formulation is clearly equivalent to the relational formulation and we
will use whichever seems more appropriate throughout the paper  the choice will always
be clear from the context 
the following notions are standard in the study of the csp  a binary csp instance is
one where the maximum arity of any constraint scope is two  the subproblem of i on
variables u  v is the instance hu  d  cu i where cu is the set of constraints h  i  c
such that   u   the instance i is arc consistent if v    v   v   each solution to the
subproblem of i on  v    can be extended to a solution to the subproblem of i on  v    v    
the constraint graph of a binary csp instance i   hv  d  ci is the graph with vertices
v and edges the set of scopes of binary constraints in c  since it is often convenient to
consider that a  possibly irrelevant  constraint exists between every pair of variables  we
introduce the refined notion of true constraint graph 
definition      a binary constraint between v  and v  is improper if it allows every pair
of values allowed by the unary constraints on v  and v    and proper otherwise 
the true constraint graph of a binary csp instance is the constraint graph of the
instance after removing any improper binary constraints 
  

ficohen  cooper  creed  marx   salamon

we may also sometimes need to disregard unary constraints so we have the following 
definition      the binary reduction of a csp instance is obtained by removing from
the constraint set all those constraints whose scope does not have arity two 

   forbidden patterns in csp
in this paper we explain how we can define classes of csp instances by forbidding the
occurrence of certain patterns  a csp pattern is a generalisation of a csp instance  in a
csp pattern we define the relations relative to a three valued logic on  t  f  u    meaning
that the pattern can be seen as representing the set of csp instances in which each undefined value u is replaced by either t or f   forbidding a csp pattern is equivalent to
simultaneously forbidding all these instances as sub problems 
definition      we define a three valued logic on  t  f  u    where u stands for unknown
or undefined  the set  t  f  u   is partially ordered so that u   t and u   f but t and f
are incomparable  let d be a finite set  a k ary three valued relation on d is a function
   dk   t  f  u    given k ary three valued relations  and     we say  realises   if
x  dk  x      x  
we can extend the definition of a csp or constraint pattern to include additional structure on the set of variable names or the set of domain values  as a set of relations on the
set in question  adding structure makes patterns more specific  we can therefore capture larger  and hence more interesting  tractable classes  for example  when the domain
is totally ordered we can define the tractable max closed class  jeavons   cooper        
when we have an independent total order for the domain of each variable we can capture
the renamable horn class  green   cohen         and placing an order on variables in a
pattern will allow us to define the class of tree structured csp instances 
definition      a csp pattern is a quadruple    hv  d  c  si  where 
 v is the set of variables  with an associated relational structure with universe v  
 d is the domain  with an associated relational structure with universe d 
 c is a set of constraint patterns  each constraint pattern c  c is a pair c   h  i 
where   v   the scope  of c  is a list of distinct variables and    d   t  f  u   is
the three valued relation  in functional representation  of c  a constraint pattern
is non trivial if its three valued relation maps at least one tuple to  t  f   
 s is the structure  a set consisting of the relational structures associated with its
variable set and its domain 
the arity of a csp pattern  is the maximum arity of any constraint pattern h  i of  
our most basic type of pattern is one which employs no structure  with s empty  we
also frequently require patterns which use a disequality relation     applied to every pair
  

fitractability of csp classes defined by forbidden patterns

from some specified subset of variables  and we allow several such subsets of variables in
the structure 
in this paper the relations occurring in the structure all have arity two  and their interpretation is limited to a few selected binary relations representing disequality or a partial
order  when the structure of a variable set or domain is clear from the context  we will not
explicitly mention it  different kinds of structure can be imposed on csp patterns  indeed
structures specified by more general relations would be an interesting area for future study 
the weakest structure that we will consider only allows us to say when two variables are
distinct  thus the structure s of a csp pattern is then simply a set of disequalities between
subsets of variables  in this paper we denote such disequalities by neq v            vr   meaning
that variables v    v            vr are all pairwise distinct  a pattern with such a structure will
be called flat  indeed  in this paper we are mostly concerned with flat patterns  if two
variables occur together in the scope of some constraint pattern  then we also assume that
s implicitly includes the disequality neq v    v    
thus csp patterns are defined using relational structures with three sorts  for variables 
for domain values  and for variable value assignments  the constraint patterns of a csp
pattern are then three valued relations over the sort of variable value assignments  if a csp
pattern is flat then its structure specifies relations over the sort of variables  a partial order
over the variables is also a relation over the sort of variables  and partial orders over domain
values are relations over the sort of domain values 
for simplicity of presentation  we assume throughout this paper that no two constraint
patterns in c have the same scope  and that  in the case of csp instances  that no two
constraints have the same scope   we will represent binary csp patterns by simple diagrams  each oval represents the domain of a variable  each dot a domain value  the tuples
in constraint patterns with value f are shown as dashed lines  those with value t as solid
lines and those with value u are not depicted at all 
definition      a constraint pattern h  i will be called negative if  never takes the
value t   a csp pattern  is negative if every constraint pattern in  is negative 
    patterns  csps and occurrence
in a csp instance it is implicitly assumed that all variables and all domain values are
distinct  this is equivalent to the existence of implicit disequalities neq between all variable
names and all domain values  a csp instance is just a csp pattern  with a structure that
all variables and all domain values are distinct  in which the three valued relations of the
constraint patterns never take the value u   that is  we decide for each possible tuple
whether it is in the relation or not  furthermore  in a csp instance  for each pair of
variables we assume that a constraint exists with this scope  if no explicit constraint is
given on this scope  then we assume that the relation is complete  i e  it contains all tuples 
this can be contrasted with csp patterns for which the absence of an explicit constraint
on a pair of variables implies that the truth value of each tuple is undefined 
in order to define classes of csp instances by forbidding patterns  we require a formal
definition of an occurrence  containment  of a pattern within an instance  we define the
more general notion of containment of one csp pattern within another pattern  informally 
the names of the variables and domain elements of a csp pattern are inconsequential and
  

ficohen  cooper  creed  marx   salamon

a containment allows a renaming of the variables and the domain values of each variable 
thus  in order to define the containment of patterns  we firstly require a formal definition
of a renaming  in an arbitrary renaming  unless explicitly prohibited by a disequality in
the structure  two distinct variables may map to the same variable and two distinct domain
values may map to the same domain value  furthermore  when a pattern occurs in another 
it may use only a subset of the variables of the second pattern  hence the notion we require
is known as a renaming extension 
a domain labelling of a set of variables is just an assignment of domain values to those
variables  variable and domain renaming induces a mapping on the domain labellings of
scopes of constraints  we simply assign the renamed domain values to the renamed variables  there is a natural way to extend this mapping of domain labellings to a mapping
of a constraint pattern  the truth value of each mapped domain labelling is the same as
the truth value of the original domain labelling  however  it may occur that two domain
labellings of some scope map to the same domain labelling  so instead the resulting value
is taken to be the greatest of the original truth values   in order for this process to be
well defined  if two domain labellings of a constraint are mapped to the same domain labelling  then their original truth values must be comparable   this leads to the following
formal definition of a renaming extension which is the first step towards the definition of
containment 
definition      let    hv  d  c  si and     hv     d    c     s   i be csp patterns 
we say that   is a renaming extension of  if there exist a variable renaming function s   v  v   and a domain renaming function t   v  d  d  such that s  t and
the assignment renaming function f   v  d  v    d  induced by  s  t  and defined by
f  hv  ai    hs v   t v  a i satisfy 
 for each constraint pattern h  i  c  for any two domain labellings        d for
which f       f        we have that     and       are comparable  where f     denotes
the assignment f   s    d  such that v    f  s v     t v    v   
 c      hs      i   h  i  c   where  for each assignment f   s    d       f     u if
f        f for every    d   and    f     max        f       f   otherwise 
 if  has any structure  then s  t and f preserve this structure  the mapping s induces
a homomorphism between the relational structures of the variable sets  and mapping
t induces a homomorphism between the relational structures of the domains   in
particular  if neq v    v     s  then s v       s v    and neq s v     s v      s     
we will use patterns to define sets of csp instances by forbidding the occurrence  containment  of the patterns in the csp instances  in this way we will be able to characterise
tractable subclasses of the csp  informally  a pattern  is said to occur in a csp instance
p if we can find a sub problem q of p  formed by taking subsets of variables and domains 
which realises   q realises  if  after renaming of variables and domain values in   each
constraint pattern in  is realised by the corresponding constraint in q  by definition     
during a renaming extension  extra variables  domain values and disequalities can be introduced  thus we only need to combine the notions of renaming extension and realisation to
formally define what we mean by a pattern occurring in another pattern  and  in particular 
in a csp instance  
  

fitractability of csp classes defined by forbidden patterns

definition      we say that a csp pattern  occurs in a csp pattern p   hv  d  c  si
 or that p contains    denoted   p   if there is a renaming extension hv  d  c     si of 
where  for every constraint pattern h    i  c   there is a constraint pattern h  i  c and 
furthermore   realises    
pattern  
d 
b
b

c

d

b

a
a

c

d

y

x

d
z

y

x

 i 

c

a
y

x

 ii 

 iii 

pattern  
b

d

a

c
y

x

example      this example describes three simple containments  consider the three csp
patterns  pattern   i  iii   these patterns occur in  or are contained in  pattern   by the
mappings f    f    and f    respectively  which we will now describe 
f  is simply a bijection  although the patterns are different  this is a valid containment
of pattern   i  into pattern   because the three valued relation of pattern   is a realisation
of the three valued relation in pattern   i   we are replacing  b  d    u by  b  d    f  
f  maps  x  a    x  b   and  y  c  to themselves  and maps both  y  d  and  y  d    to
 y  d   this merging of domain elements is possible because the values of the three valued
constraint relation of pattern   ii  are comparable on tuples involving the assignments  y  d 
and  y  d    and  furthermore  the restriction of the three valued relation of pattern   ii 
to either of these two assignments is realised by the three valued constraint relation of
pattern     b  d    f and  a  d    t   for example  we are replacing  a  d      u by
 a  d    t   in a similar manner  pattern   i  is also contained in pattern   by the simple
mapping f   which maps both of  x  b    x  a  to  x  b  and both of  y  c    y  d  to  y  c  
finally  f  maps  y  c  and  y  d  to themselves  and maps  x  a  and  z  b  in pattern   iii  to  x  a  and  x  b   respectively  in pattern    this merging of variables is pos  

ficohen  cooper  creed  marx   salamon

sible because the three valued relations agree and because there is no neq x  z  structure
in pattern   iii  

pattern  
z
b

b

d

d

z
c

a
y

x

c

a
y

x

neq x  z 
 i 

 ii 

throughout this paper  we use the notation neq v            vr   to denote the fact that the
variables v            vr of a csp pattern are distinct  it is worth discussing what this structure
implies as far as definition     is concerned  structure in the source pattern must be
preserved in the target pattern  thus pattern   iii  occurs in pattern   i   but pattern   i 
is not contained in pattern   iii  since the structure neq x  z  is not preserved in the target
pattern  the structure neq v    v    is considered to be preserved by a renaming extension
  of  even if it is not explicitly given in   but is implicit  for example  due to the existence
of a non trivial constraint pattern h  i in   such that v    v     as an example  consider
the two csp patterns  pattern   i  ii   pattern   i  can be mapped to pattern   ii  by
a simple bijection so that the three valued relation of pattern   ii  is a realisation of the
three valued relation in pattern   i   the structure neq x  z  is considered to be preserved
by this mapping due to the existence of a non trivial constraint pattern between variables
x and z in pattern   ii   hence  pattern   i  occurs in pattern   ii  
before continuing we need to define what we mean when we say that a class of csp
instances is definable by forbidden patterns 
definition      let c be any class of csp instances with maximum arity k  we say that
c is definable by forbidden patterns if there is some set of patterns x for which the set
of csp instances of maximum arity k in which none of the patterns in x occur are precisely
the instances in c 
notation  let x be a set of csp patterns with maximum arity k  we will use csp x   to
denote the set of csp instances in which no element   x occurs  when x is a singleton
   we will use csp   to denote csp     
in this paper  we only consider classes csp x   for sets x of csp patterns which are
binary in the sense that all constraint patterns have scope of size exactly two 
for all x such that all patterns in x are binary  csp x   is closed under arc consistency
 in the sense that the arc consistency closure of any instance i  csp x   belongs to
  

fitractability of csp classes defined by forbidden patterns

csp x    and any other operation which only updates unary constraints  indeed  changing
unary constraints cannot introduce any of the patterns x in any instance i  csp x   
    tractable patterns
in this paper we will define  by forbidding certain patterns  tractable subclasses of the csp 
furthermore  we will give examples of truly hybrid classes  i e  classes not definable by
purely relational or purely structural properties  
definition      a finite set of patterns x is intractable if csp x   is np hard  it is
tractable if there is a polynomial time algorithm to solve csp x    a single pattern  is
tractable  intractable  if    is tractable  intractable    we assume throughout this paper
that p   np  and therefore that the sets of tractable and intractable patterns are disjoint  
it is worth observing that classes of csp instances defined by forbidding patterns do
not have a fixed domain  recall  however  that each csp instance has a finite domain  any
structure present in a csp instance is assumed given as part of the instance  in particular 
all variables in a csp instance are assumed to be distinct  for finite sets of patterns x  
the number of possible renaming extensions into a particular instance p is polynomial in
the size of p   hence we can determine whether an instance lies in csp x   by exhaustive
search in polynomial time 
we will need the following simple lemmas for our proofs of intractability results in later
sections of this paper 
lemma      if      and        then       
proof  if       then each constraint pattern h  i of  maps to a constraint pattern h       i
such that   realises   the transitivity of  follows from the following facts 
 the realisation operation is transitive 
 if      and        then by definition      any structure in   is preserved in  
and hence in    
lemma       let x and t be sets of csp patterns and suppose that for every pattern
  t   there is some pattern   x for which      then csp x    csp t   
proof  let p  csp x    so    p for each   x   then we cannot have   p for any
  t   since this would imply that there exists some   x such that     p and hence
that   p by lemma      hence  p  csp t   
corollary       let x and t be sets of csp patterns and suppose that for every pattern
  t   there is some pattern   x for which     
we then have that csp t   is intractable if csp x   is intractable and conversely  that
csp x   is tractable whenever csp t   is tractable 
finally  we give some examples of tractable patterns  the first example is a negative
pattern since the only truth values in the relations are f and u  
  

ficohen  cooper  creed  marx   salamon

pattern   a very simple negative pattern 
v
a

x
c
c 

w
b
neq v  w  x 

example       consider pattern    this defines a class of csps which is trivially tractable 
forbidding pattern   ensures that there are no paths of more than two variables in the true
constraint graph  thus  any problem forbidding pattern   can be decomposed into a set of
independent sub problems  each with at most two variables 

example       cooper and zivny      b  showed that forbidding the pattern negtrans
shown in pattern   describes a tractable class of csp instances  this can be seen as a generalisation of the well known tractable class of problems  alldifferent unary  costa 
      regin        van hoeve         an instance of this class consists of a set of variables
v   a set of arbitrary unary constraints on v   and the constraint v    w defined on each pair
of distinct variables v  w  v   forbidding negtrans is equivalent to saying that disallowed
tuples form a transitive relation  i e  if  hv  ai   hx  bi  and  hx  bi   hw  ci  are disallowed then
 hv  ai   hw  ci  must also be disallowed  thus negtrans does not occur in any binary csp
instance in the class alldifferent unary by the transitivity of equality  equality being
exactly what is disallowed  

pattern   negative transitive pattern  negtrans 
v
x

w

neq v  w  x 
cooper and zivny      b  also recently showed that the tractable class defined by
forbidding pattern    negtrans  can be extended to soft constraint problems 
  

fitractability of csp classes defined by forbidden patterns

    tractable patterns with structure
this paper primarily studies patterns with a weak structure in that the only conditions that
are imposed are that variables are distinct  however  it is worth pointing out that adding
structure to a pattern allows us to capture larger classes of instances  in example     
below we show that a forbidden pattern can capture the class of csps with tree width  
by adding a variable ordering to pattern    in this case pattern containment must preserve
the total order  for an ordered pattern   we will consider an unordered csp p to be in
csp   if there exists some ordering of the variable set of p such that  is forbidden  in
order for  to define a tractable class  it must be possible to find this ordering in polynomial
time  this is the case for the patterns in examples      and      
pattern   tree structure pattern  tree 

v 
v 
v 
v    v    v 
example       consider the pattern tree  given as pattern    we will show that the class
csp tree  is exactly the set of csps whose true constraint graph is a forest  i e  has tree
width     first  suppose p  csp tree   then  there exists some ordering     v            vn  
such that each variable shares a proper constraint with at most one variable preceding it
in the ordering  on the other hand  suppose p is a csp whose true constraint graph is a
tree  by ordering the vertices according to a pre order traversal  we obtain an ordering in
which each variable shares a proper constraint with at most one variable preceding it in the
ordering  its parent   thus  p  csp tree  

example       forbidding the pattern btp shown in pattern   is known as the brokentriangle property  cooper et al          in order to capture this class by a forbidden
pattern we again have to impose a total order on pattern variables  cooper et al        
proved that the class of csp instances csp btp  can be solved in polynomial time and 
indeed  that csp instances in csp btp  for some unknown total ordering of the variables
can be recognised and solved in polynomial time 

it is easy to see that tree  shown in pattern    occurs in btp  with some truthvalues u being changed to t    it follows from lemma      that csp tree   csp btp  
hence the class csp btp  includes all csp instances whose true constraint graph is a tree 
however  csp btp  also includes certain csp instances whose true constraint graph has
  

ficohen  cooper  creed  marx   salamon

pattern   broken triangle pattern  btp 

b

v 

a
v 
v 
v    v    v 

tree width r for any value of r  consider  for example  a csp instance with r     variables
and an identical constraint between every pair of variables which simply disallows the single
tuple h    i 
for any tractable forbidden pattern with an order imposed on the variables  we can
obtain another tractable class by considering problems forbidding the pattern without this
ordering condition  the class obtained is generally smaller  because it is easier to establish
containment of the flat pattern  for example  consider pattern   which is the flat version of
pattern    we have seen that forbidding pattern   gives rise to the class of csp instances
in which there are no paths of length greater than two in the true constraint graph  on the
other hand  forbidding pattern   gives the much larger class of csp instances in which the
true constraint graph has tree width   
in the case of the broken triangle property  we also obtain a strictly smaller tractable
class by forbidding pattern   for all triples of variables v    v    v  irrespective of their order 
we can easily exhibit a csp instance that shows this inclusion to be strict  for example  the
  variable csp instance over boolean domains consisting of the two constraints v    v   
v    v  with the variable ordering v    v    v    this unordered version of btp was
recently used to obtain a dichotomy for patterns consisting of   constraints  cooper  
escamocher        

   on maximal tractable classes defined by forbidden patterns
in relational tractability we can define a maximal tractable sub problem of the csp problem
given by a set  of possible relations  such a class of relations is maximal if it is not possible
to add even one more relation to  without sacrificing tractability 
in the case of structural tractability the picture is less clear  since here we measure the
complexity of an infinite set of hypergraphs  or  more generally  relational structures   we
obtain tractability if we have a bound on some width measure of these structures  whatever
width measure is chosen we have a containment of the class with width bounded by k inside
that of the class of width bounded by k    and so no maximal class is possible  although for
each k there is a unique maximal class of structurally tractable instances   in this section 
we show that in the case of forbidden patterns the situation is similar 
  

fitractability of csp classes defined by forbidden patterns

definition      let    hv  d  c  si and    hv     d    c     s   i be any two flat csp patterns 
   and dd
     now  extend each constraint pattern in
we can form the disjoint unions v v
   by setting the value of any tuple including elements of d  to
c to be over the domain dd
   
be u   and extend similarly the constraint patterns in c     in this way we can define c c
   by forming the disjoint union of s and s   and adding all
also define the structure s s
 
disequalities neq v  v   for all v  v and v    v     then we set the disjoint union of 
   hv v
     dd
     c c
     s s
   i 
and  to be 
lemma      let  and  be flat non empty  i e  containing at least one variable  binary
csp patterns  then
   
csp    csp      csp 
   is tractable whenever csp   and csp    are tractable 
moreover  we have that csp 
proof  we begin by showing the strict inclusion
   
csp    csp      csp 
that the inclusion holds follows directly from lemma       among all patterns in which 
occurs  let  be a pattern with the smallest number of variables  we define   similarly 
to see that the inclusion is strict  observe that  and  occur in a csp pattern whose
domain is the disjoint union of those for  and     but whose variable set has size equal
to the larger of the variable sets of  and     any csp instance containing this pattern
is neither in csp   nor in csp     however  we can construct a csp instance containing
    as the structure of 
 imposing disequalities
this pattern which is contained in csp 

between variables of  and  means that  is not contained in this pattern  there are
simply not enough variables 
    if p  csp    csp    then p can be solved in polynomial
suppose p  csp 
time  by the tractability of csp   and csp    
so we may suppose that   p   choose a particular occurrence of  in p and let 
denote the set of variables used in the containment  consider any assignment t    
d  let pt denote the problem obtained by making this assignment and then enforcing
arc consistency on the resulting problem  this corresponds to adding some new unary
constraints to p  
 must occur in p   to see this  observe that
we will show that if  occurs in pt then 
any containment of  in pm naturally induces a containment of  in p that extends to a
 in p   by considering the occurrence of  in   thus  we can conclude
containment of 
that pt  csp     and so can be solved in polynomial time 
by construction  any solution to pt extends to a solution to p by adding the assignment
t to the variables   moreover  every solution to p corresponds to a solution to pt for some
t     d  since the size of  is fixed  we can iterate over the solutions to  in polynomial
time  if p has a solution  then we will find it as the solution to some pt   if we find that no
pt has a solution  then we know p does not have a solution  thus  since we can solve each
pt in polynomial time  we can also solve p in polynomial time 
corollary      no tractable class defined by forbidding a flat pattern is maximal 
  

ficohen  cooper  creed  marx   salamon

 defined by the disjoint
proof  let  be any tractable flat pattern  consider the pattern 

union of two copies of   by lemma     we have that csp  
is tractable but also that
  
csp     csp  
and hence csp   is not a maximal tractable class 
it follows that we cannot characterise tractable forbidden patterns by exhibiting all
maximal tractable classes defined by forbidding a pattern  or any finite set of patterns 
since by lemma     such a finite set can be replaced by a single pattern   indeed  a
consequence of lemma     is that we can construct an infinite chain of patterns  such that
forbidding each one gives rise to a slightly larger tractable class  naturally  if we place an
upper bound on the size of the patterns then there are only finitely many patterns that we
can consider  so maximal tractable classes defined by forbidden patterns of bounded size
necessarily exist 

   binary flat negative patterns
for the moment  we are not able to make a conjecture concerning the complete characterisation of the complexity of general forbidden patterns  although we conjecture that a
dichotomy exists  nonetheless  by restricting our attention to a special case  forbidden
binary flat negative patterns  we are able to obtain a dichotomy  recall that a pattern is
flat if the only structure that can be imposed is that variables are distinct  and that it is
negative if in all of its constraint patterns h  i   never takes the value t  
we begin by defining three particular patterns and one infinite class of patterns  we
then use these patterns to characterise a very large class of intractable patterns  we prove
that any finite set of flat negative patterns not in this class has a simple structure  one of
the patterns must be contained in one of a particular set of patterns  which we call pivots 
this means that any tractable such set of patterns must include a pattern which occurs in
a pivot pattern  furthermore  we demonstrate that forbidding any pivot pattern gives rise
to a tractable class  this then leads to a simple characterisation of the tractability of finite
sets of binary flat negative patterns 
pattern   cycle   
c 
c
v 

v 

v 

v 

v 

neq v            v   

  

v 

fitractability of csp classes defined by forbidden patterns

pattern   valency
x 

x  

x 

x  

x 

x  
neq x    x    x    x      neq x     x     x    

pattern    path

v 

v 

v 

w 

w 

w 

neq v    v    v    w     neq w    w    w   
in definition     below  we define the concept of a neg connected binary pattern  these
correspond to binary patterns  such that the true constraint graph of every realisation of
 as a binary csp instance is a connected graph  we first generalise the notion of true
constraint graph to csp patterns  we call the resulting graph the negative structure graph 
definition      let  be any binary pattern  the vertices of the negative structure
graph g are the variables of   a pair of vertices is an edge in g if and only if they form
a scope in  whose constraint pattern assigns at least one tuple the value f   we say that
a pattern  is neg connected if its negative structure graph is connected  in the case of
negative patterns  we use the simpler term connected instead of neg connected 
pattern    valency   pattern     path  and pattern     valency path  are not
connected  note that a pattern which is not connected may occur in a connected pattern
 and vice versa   pattern   shows cycle    which is connected  this is just one example
of the generic pattern cycle k  where k     the only structure for cycle k  is that
all variables are distinct  except for the special case k     for which the structure also
includes neq c  c     this additional requirement means that cycle    is composed of a
single binary constraint pattern containing two distinct disallowed tuples  the following
theorem uses these patterns to show that most patterns are intractable 

  

ficohen  cooper  creed  marx   salamon

pattern    valency path
v 

v 
w 
v 

w 

w 

x

neq v    v    v     neq w    w    w     and neq x  w   
theorem      let x be any finite set of neg connected binary patterns  if  for each   x  
at least one of cycle k   for some k      valency  path  or valency path occurs
in   then x is intractable 
proof  let x be a finite set of neg connected negative binary patterns and let   be the
number of variables in the largest element of x  
assuming at least one of the four patterns occurs in each   x   we can construct a
class of csps in which no element of x occurs and to which we have a polynomial time
reduction from the well known np complete problem  sat  garey   johnson        
the construction will involve three gadgets  examples of which are shown in figure   
these gadgets each serve a particular purpose 
   the cycle gadget  shown in figure   a  for the special case of   variables  enforces
that a cycle of boolean variables  v    v            vr   all take the same value 
   the clause gadget in figure   b  is equivalent to the clause v   v   v    since vc has
a value in its domain if and only if one of the three vi variables is set to true  we can
obtain all other   clauses on these three variables by inverting the domains of the vi
variables 
   the line gadget in figure   c   imposes the constraint v   v    it can also be used to
impose the logically equivalent constraint v   v   
the cycle gadget will be connected to the clause gadget via line gadgets  these three types
of gadgets have been specified to ensure that at most one negative edge is adjacent to any
vertex in the coloured microstructure  except when the cycle gadget is connected to a line
gadget 
now  suppose that we have an instance  of  sat with n propositional variables
x            xn and m clauses c            cm  
we begin our construction of a csp instance p to solve the  sat instance  by using
n copies of the cycle gadget  figure   a    each with m        variables  for i              n 
m     
the variables along the ith copy of this cycle are denoted by  vi    vi            vi
   in any
  

fitractability of csp classes defined by forbidden patterns

v 
t
f

v 

vc
v 

v 

v 

t
f
v 
t
f

v 
 a 

 b 

t
f
v 

v 
 c 

figure     a  making copies of the same variable  v    v    v    v      b  imposing the
ternary constraint vc   v   v   v     c  a line of constraints of length   which
imposes v   v   

solution to a csp instance p with these and other constraints  we will have that the
variables vij   j              m        must all have the same value  di   we can therefore consider
each vij as a copy of xi  
consider the clause cw   there are eight cases to consider but they are all very similar
so we will show the details for just one case  suppose that cw  xi  xj  xk   we
build the clause gadget  figure   b   with the three boolean variables being ciw   cjw and ckw
and invert the domain of ckw since it occurs negatively in cw   then any solution s to our
constructed csp must satisfy s ciw    s cjw    s ckw     t  
we complete the insertion of cw into the csp instance by adding some line gadgets of
length        figure   c    we connect the cycle gadgets corresponding to xi   xj and xk
w     
to the clause gadget for clause cw since xi   xj and xk occur in cw   we connect vi
w     
to ciw since xi is positive in cw   so s ciw     t is only possible when s vi
    t   for
  

ficohen  cooper  creed  marx   salamon

w     

any solution s  similarly  we connect vj
to cjw   finally  since xk occurs negatively in
cw   we impose the line constraints in the other direction  this ensures that s ckw     f is
w     
only possible when s vk
    f   imposing these constraints ensures that a solution is
only possible when at least one of the cycles corresponding to variables xi   xj   and xk is
assigned a value that would make the corresponding literal in cw true 
we continue this construction for each clause of the  sat instance  since   is a constant 
this is clearly a polynomial reduction from  sat 
we now show that any csp instance p constructed in the manner we have just described cannot contain any pattern in x   we do this by showing that no neg connected
pattern containing cycle k   for    k      valency  path  or valency path can
occur in the instance  this is sufficient to show that the csp instance p does not contain
any of the patterns in x  
in the csp instance p no constraint contains more than one disallowed tuple  thus 
any   x for which cycle      cannot occur in p   furthermore  p is built from
cycles of length m        and paths of length        and so cannot contain any cycles on less
than       vertices  thus  since   is the maximum number of vertices in any element of x  
it follows that no   x for which cycle k     for any k     can occur in p  
we define the valency of a variable x to be the number of distinct variables which share
a constraint pattern with x  suppose valency    where   x is neg connected  for
this to be possible we require that there is a variable of valency four in   or a pair of
variables of valency three connected by a path of length at most   in the negative structure
graph of   certainly p has no variables of valency four  moreover  the fact that p was
built using paths of length       means that no two of its valency three variables are joined
by a path of length at most    thus    x does not occur in p if valency   
next  consider the case when path    where   x is neg connected  here  must
have two distinct  but possibly overlapping  three variable lines  with disallowed tuples in
these constraint patterns that match at domain values  separated by at most   variables 
the only place where disallowed tuples can meet in p is when we connect the line gadget
to the cycle gadget  these connection sites are always at distance greater than    so we can
conclude that    p whenever path   
finally  consider the case where valency path    where   x is neg connected 
here   must have a variable of valency at least   and a path of constraint patterns on
three variables with intersecting disallowed tuples  and these must be connected by a path
of less than   variables in the negative structure graph of   as observed above  the only
places in p where we can have disallowed tuples meeting is where the line gadget meets
the cycle gadget  and there is a path of at least   variables between each one of these points
and every other variable of valency    thus     p whenever valency path   
it remains to consider which sets of negative binary patterns could be tractable  for
this  we need to define the pivot patterns  pivot r   which contain every tractable negative
binary pattern 
definition      let v    p    v            vr     w            wr     x            xr    d    a  b 
and s    neq p  v            vr   w            wr   x            xr     we define the pattern pivot r   
  

fitractability of csp classes defined by forbidden patterns

pattern    pivot   
v 

v 

v 
w 

w 

w 

p
a
x 

x 

x 

b

neq p  v    v    v    w    w    w    x    x    x   

hv  d  cp  cv  cw  cx   si  where
cp    h p  v     ab i   h p  w     ab i   h p  x     bb i 
cv    h vi   vi      ab i   i              r    
cw    h wi   wi      ab i   i              r    
cx    h xi   xi      ab i   i              r    
and where ab  a  b    f   ab  s  t    u  for all  s  t      a  b    bb  b  b    f   bb  s  t    u
 for all  s  t      b  b    the pattern pivot r  has the structure s that all its variables are
distinct  see pattern    for an example  pivot    
we say that a pattern  on variables v            vr is a distinct variable pattern if its
structure includes neq v            vr    the following proposition characterises those sets of
connected binary flat negative distinct variable patterns which theorem     does not prove
intractable 
proposition      any connected binary flat negative distinct variable pattern  either
contains cycle k   for some k      valency  path  or valency path  or itself
occurs in pivot r  for some integer r     
proof  suppose  does not contain any of the patterns valency  cycle k   for any k     
path  or valency path  recall that the valency of a variable x is the number of distinct
variables which share a constraint pattern with x  since  does not contain valency it
can only contain one variable of valency three and all other variables must have valency
at most two  moreover  since cycle k     for k     the negative structure graph of 
does not contain any cycles  thus  since  is connected  the negative structure graph of
 consists of up to three disjoint paths joined at a single vertex  if two disallowed tuples
  

ficohen  cooper  creed  marx   salamon

over distinct scopes intersect  then we call the union of the scopes the footprint of the
intersection  the fact that the negative structure graph of  is acyclic and that  does not
contain path means that all such pairs of intersecting disallowed tuples in  must have the
same footprint  moreover  the fact that  does not contain valency path means that
all such intersections must occur at the variable with valency    if it exists  the fact that 
is flat and negative means that in a renaming extension any pair of disallowed tuples ha  bi 
hc  di over the same scope hu  vi in  can be merged by the domain renaming function t 
i e  t hu  ai    t hu  ci  and t hv  bi    t hv  di   it then follows that  occurs in pivot r  
for some r     
corollary      let x be a finite set of connected binary flat negative distinct variable
patterns  then csp x   is tractable only if there is some   x that occurs in pivot r  
for some integer r     
we now prove the same result for patterns which are not necessarily distinct variable 
corollary      let x be a finite set of connected binary flat negative patterns  then
csp x   is tractable only if there is some   x that occurs in pivot r   for some integer
r     
proof  for  a connected binary flat negative pattern  let dv   denote the set of connected
binary flat negative distinct variable patterns in which  occurs  which have the same
domain as  and at most    variables  we use dv x   to denote the union of the sets dv  
for   x  
by lemma       csp    csp dv     for every csp instance p such that   p  
we have   p for some   dv    it follows that csp dv     csp    and hence
csp     csp dv     since csp x   is just the intersection of the csp   for   x
and csp dv x    the intersection of the csp dv    for   x   we have that csp x    
csp dv x    
by corollary      csp dv x    is tractable only if some pattern   dv    for some
  x   occurs in pivot r  for some r       but  by definition of dv     occurs in 
and          therefore  csp x   is tractable only if  occurs in pivot r  for some integer
r     
for an arbitrary  not necessarily flat or negative  binary csp pattern   we denote
by neg   the flat negative pattern obtained from  by replacing all truth values t by
u in all constraint patterns in  and ignoring any structure beyond disequalities between
variables  recall that the structure of a flat pattern only contains disequality relations
between variables  so neg   is a flat pattern by definition  for a set of patterns x  
neg x   is naturally defined as the set neg x      neg       x    clearly csp neg x   
 csp x    the following result follows immediately from corollary      it provides a
necessary condition for tractability of general patterns 
corollary      let x be a finite set of binary patterns such that for each   x   neg   is
connected  then csp x   is tractable only if there is some   x such that neg   occurs
in pivot r   for some integer r     
  

fitractability of csp classes defined by forbidden patterns

   the pivot theorem
theorem      pivot r  is tractable for all r    
this theorem together with corollary     immediately provides a dichotomy for finite
sets of connected binary flat negative patterns  most of this section is devoted to the proof
of this theorem  which we call the pivot theorem   we conclude this section by giving a
dichotomy for finite sets of flat negative patterns which are not necessarily connected 
we will need some definitions from graph theory 
definition      a subdivision of a graph g is a graph obtained by replacing some edges
of g with simple paths 
a minor of a graph g is any graph obtained from g by deleting edges  contracting
edges and removing isolated vertices  a graph h is a topological minor of a graph g if a
subdivision of h is a subgraph of g 
we will need to use the following well known theorem of robertson and seymour        
theorem      for every planar graph h there is an integer k     such that if a graph
does not contain h as a minor  then its tree width is at most k 
in particular  if a graph has large tree width  then it contains a large grid minor  in this
section we will consider hexagonal grid minors instead  see figure     the reason for this is
the well known fact that if a graph of maximum degree three is a minor of another graph 
then it is a topological minor and the latter notion is more convenient for our proofs  as
illustrated in figure    an h hexagonal grid is a graph composed of hexagons in a honeycomb
pattern  its width h is the number of hexagons in both horizontal and vertical directions 
definition      let g   r  n be such that every graph of tree width at least g r  contains
the   r      hexagonal grid as a topological minor 
let us observe the following simple property first 
lemma      any three degree three vertices of the hexagonal grid of width  r begin disjoint
paths of length r 
proof  if each vertex is in a different row then we can simply choose a path for each of them
along their row  in the direction away from the nearest boundary of the grid   see vertices
a  b and c in figure   to visualise this typical situation 
otherwise it may be possible  by rotating the grid through     or     degrees to get all
three vertices to lie on different rows  if we cannot separate the vertices by rotating then
they are the corners of an equilateral triangle  such as x  y  z or p  q  r in the diagram 
if the triangle has an interior row  such as row   for x  y  z in the diagram  then we
can extend two vertices along their row and drop the third to the interior row and then
along that row  thus  for example  the path beginning at y would drop down one row and
continue along row   
the only remaining case is when the three vertices form an equilateral triangle occupying
just two adjacent rows  like p  q  r in the diagram  in this case there is some orientation
for which the two vertices that are on the same row do not both lie along the edge of the
  

ficohen  cooper  creed  marx   salamon

grid  in the diagram we can rotate either     or     degrees to achieve this for p  q  r 
now we can extend two of the three vertices along their row and the third can shift away
from the centre of the triangle in order to find an empty row along which the path can be
extended 
row  
b

y

x

row  
row  

z

row  
a
c
row  
row  
row  

r
p

q

figure    a hexagonal grid of width   with the rows picked out in bold and numbered 
the following combinatorial result is crucial for our algorithm  but it is interesting in
its own right 
lemma      let g be a   connected graph of tree width at least g r  and let a  b  c be
distinct vertices of g  then g contains   pairwise vertex disjoint paths starting at a  b  c 
respectively  and each having length r 
proof  let h be the   r      hexagonal grid  by the definition of g r   graph g contains
h as a topological minor  note that h contains some vertices of degree   on the boundary 
which will cause some complications in the proof  to avoid this complication  we observe
that h is a subdivision of a graph h  whose every vertex has degree   and we will focus
on the graph h  instead 

let hg
denote the subdivision of h  appearing in g and let s denote the vertices of

degree three in hg
  by mengers theorem  dirac        there are vertex disjoint paths pa  
pb   pc in g from a  b  c to distinct vertices sa   sb   sc in s  respectively  choose the paths in

such a way that the total number of edges used by them that are not in hg
is minimized 

let x  y  s be two vertices that correspond to adjacent vertices in h   this means

that hg
contains a path q with endpoints x and y whose internal vertices are disjoint
from s  suppose that  say  pa contains an internal vertex of q  we claim that either    
x  y   sa   sb   sc   or     sa   x  y  and pb   pc are disjoint from q  suppose that     does
not hold  say  x    sa   sb   sc    consider the internal vertex q of q closest to x that is used
  

fitractability of csp classes defined by forbidden patterns

by one of the paths  we can reroute this path from q to x without using any further edges

outside hg
  this would create a new set of paths with smaller number of edges outside


hg   unless the rerouted path did not use any further edges outside hg
after q  this is
only possible if the path goes from q to y on q  but this means that there is only one path
intersecting q  no path intersects q between q and x by the definition of q and the same
path uses all the vertices from q to y  thus case     holds 
by lemma     there are three independent paths of length r     from the vertices sa   sb
and sc in the  non subdivided  hexagonal grid h  which correspond to paths xa   xb   xc in

hg
  we will use these paths to create three independent paths of length at least r from a  b
and c in g  by definition  the path xa does not go through sb or sc   therefore  by the claim
in the previous paragraph  xa is disjoint from pb and pc   if xa uses the path q between x
and y  then sb   sc    x  y  means that neither     or     can happen if pb or pc intersects
q  if xa is disjoint from pa as well  then we create a new path ta by simply concatenating
pa and xa   otherwise  the only way xa can intersect pa is on the first subdivided edge
of h  where xa goes  this is the only place where case     of the claim can happen   in
this case  we create a new path ta by following pa until it meets this subdivided edge and
then following xa   as each edge of h  corresponds to up to   edges of h  path ta could
meet up to   edges of h fewer than what xa does  the path ta will  in either case  meet
at least r subdivided edges of h and so has length at least r  we can build tb and tc in an
analogous fashion 
we will require the following technical lemma in our proofs 
lemma      let p be any binary csp instance  suppose that the assignment of d to x  or
of d  to y both extend to a solution of p but that there is no solution assigning both d to x
and d  to y  then there is a path of proper binary constraints between x and y  furthermore 
there is such a path such that the first constraint along this path disallows some tuple hd  d  i
and the last constraint disallows some tuple hd    d  i 
proof  let sx be any solution to p including the assignment of d to x and similarly let sy
be any solution to p including the assignment of d  to y 
define a graph g on the variables of p   there is an edge from x to a variable z if and
only if the assignment of d to x is incompatible with some domain value for z  similarly 
there is an edge from y to a variable z if and only if the assignment of d  to y is incompatible
with some domain value for z  finally there is an edge between any two variables other
than x and y if and only if the constraint between them is proper 
let cx be the component of g containing x  define an assignment s to the variables
of p by setting s z    sx  z  if z  cx and s z    sy  z  otherwise  this is a solution to
p since the only possible unsatisfied constraint would have to be between a variable of cx
and a variable not in cx   but by the choice of cx this cannot happen 
by hypothesis  we know that s y     d  and so we have the required path of proper
binary constraints 
note that if in lemma     there is a binary constraint between x and y that forbids
assigning d to x and d  to y  then setting d    d  and d    d yields the required path of
proper binary constraints  of length one 
we first show that csp pivot r   is tractable in a special case with restricted structure 
  

ficohen  cooper  creed  marx   salamon

lemma      the subclass of csp pivot r   consisting of instances 
 which have an arc consistent binary reduction 
 which have no unary constraints on variables of degree two in the constraint graph 
 where the true constraint graph is a subdivided three connected graph 

has time complexity o n  dg r     

proof  let p be an instance satisfying the conditions of the lemma  in time o nd    we
join the binary constraints along each subdivided edge eliminating intermediate variables
as we go  to obtain the instance p     whose constraint graph is three connected  but which
may have some improper binary constraints and arbitrary unary constraints  let g denote
the true constraint graph of p and g  the three connected graph obtained from g by
contracting subdivided edges  the true constraint graph of p   is a subgraph of g  on the
same vertex set 

we can solve p    csp negtrans  in time o n  d   n   d   cooper   zivny      b  

this is clearly o n  dg r    since g r     for all r  furthermore  if g  has tree width at

most g r  then p   can be solved in time o ndg r     dechter   pearl         in either
case this solution can be extended to a solution of the original instance p in time o nd  
the only remaining case to consider is when negtrans occurs in p   and the tree
width of g  is also at least g r   we will complete the proof by deriving the contradiction
p   csp pivot r    in order to show that this case cannot occur 
suppose negtrans occurs in p   on variables a  b  c and values da   db   dc  
da

dc

a

c
db
b

by lemma      g  contains   vertex disjoint paths ta   tb   tc starting at a  b  c  respectively  each having length at least r  recall that the true constraint graph g of the
original instance p was a subdivided three connected graph and that p   was obtained from
p by joining binary constraints along subdivided edges  let ta   tb   tc denote the paths in
g corresponding to ta   tb   tc in g    recall also that negtrans occurs in p   on variables
a  b  c and values da   db   dc  
now let a and c be the first vertices along the subdivided edges from b to a and c in
g  the embedding of negtrans in p   shows that hdb   da i is disallowed by the join of the
arc consistent path from b to a  since this path is  by construction  a subdivision of an
edge of p   we know that no unary constraints occur on any internal vertices  we also know 
by arc consistency of the binary constraints  that the assignments a   da or b   db both
extend to a consistent assignment to the path between a and b  so  by lemma     we know
that there is some value da in the domain of a such that hdb   da i is disallowed in p by the
  

fitractability of csp classes defined by forbidden patterns

constraint between b and a  similarly there is a value dc for which hdb   dc i is disallowed in p
by the constraint between a and c  by appending the path from b to a to the path ta and
the path from b to c to tc   together with tb   we obtain three independent paths of length at
least r of proper constraints in p   beginning at variable b  two beginning with constraints
disallowing a tuple with value db at b  so we have shown that pivot r  does indeed occur
in p and we are done 
csp pivot r   places an upper bound on the length of the chain of dependencies that
may have to be followed to discard a partial solution that cannot be extended to a solution 
informally speaking  forbidding the pivot r  pattern bounds the amount of local search
that may have to be done when extending a partial solution to a larger partial solution  the
amount of effort that may be required increases with the length of such chains of inference 
and this worst case behaviour is quantified more precisely in the following result  we first
require some definitions 
definition      let g be a graph and u be a subset of the vertices of g  the induced graph
g u   of g on u is the graph with vertex set u and whose edges are those edges of g which
connect two vertices of u  
for graphs g   hv  ei and g    hv     e   i define g  g    hv  v     e  e   i 
in a graph g we say that hu    u  i is a separation if g   g u     g u    and neither of
u    u  is a subset of the other  the separator of the separation hu    u  i is u   u  and
its order is  u   u     a minimal separator is one of minimal order 
the torso of u  in the separation hu    u  i is obtained from the induced graph g u    by
adding every edge between the vertices of the separator of hu    u  i 

theorem       the class of pivot r  free instances is solvable in time o n  dg r     
proof  we will prove the result by induction on the number of variables 
the base case is straightforward  when the instance has fewer than g r    variables  we
can clearly solve it by exhaustive search in time o n  dg r      for the inductive case we can

assume that we can solve all smaller instances with n   k variables in time o n  dg r     
let p be any pivot r  free instance with n   k variables  first make p arc consistent
in time o n  d     bessiere  regin  yap    zhang         since p is now arc consistent  unary
constraints no longer have any effect  remove all unary and improper binary constraints
from p in time o n  d     let g be the true constraint graph of the resulting instance  p    
if g has no separation of order two then it is either three connected or has at most three
vertices  in the three connected case we can solve p     and hence p   in time o n  dg r   
by lemma      if p has at most three variables then it is trivial to solve in time o d    
so  we can assume that g has a separation of order two  by definition of the torso any
size   separator of a torso is a size   separator of g  hence we can find a size   separation
hu    u  i where the torso of u  has no separation of order two  so we can assume that the
torso of u  is either three connected or has at most three vertices 
now consider the separator m   u   u  of hu    u  i  if m is empty then p   is composed of two smaller independent
pivot r  free instances and so can be solved in time

 
g r   
 
g r   
o n  d
  o n  d
where n    n    n and    n    n    n  it follows that we can

solve p in time o n  dg r      so we are done 
  

ficohen  cooper  creed  marx   salamon

if m    m  then we consider the structure of g u     it is three connected  so m
vertex has degree at least three  in this case we can add any unary constraint on m
and  by lemma      solve the instance in time o n  dg r      hence we can find  in time

o dn  dg r      which values of the variable m extend to all variables of u    adding this restriction as a unary constraint on variable m leaves the induced instance on u  pivot r  free

and we see  by induction  that we can solve p   in time o dn  dg r       n      dg r     

o n  dg r      so we are done 
finally we must consider m    x  y   since m is minimal we know that g u    is
connected and there is a path between x and y in u    denote by q the csp instance
induced on g u     together with some path in u  from x to y  the constraint graph of
q is a subdivision of the torso of u  which is either three connected or has at most three
vertices  in the latter case q has tree width at most two so  after the addition of unary
constraints on x and y  can be solved in time o n  d     dechter   pearl         if the torso
of u  is three connected then the degrees of x and of y in q are at least three  after the
addition of any
 unary constraints on x and y we can  by lemma      solve this case in time
o n  dg r      hence we can solve q with all possible unary constraints on x and y which

only allow one value for each of x and y  in time o d  n  dg r     
for each value of variable x we now know whether it extends to some solution on all
the variables in q  similarly  for each value of variable y we know whether it extends to a
solution on all variables in q  we can express these two restrictions as unary constraints 
u x  and u y  on x and y  lastly we find the binary constraint c x  y  on x and y which
specifies precisely which pairs of values  allowed by u x  and u y   extend to all variables
of u    this we obtain by solving the subdivided three connected instance and seeing which
pairs are disallowed by the subdivided edge in u   for such pairs we do not set the constraint
relation in c x  y  to f  
if u x  allows no values for x then p has no solution and we stop 
now consider the instance r  which is induced by p   on u  together with the constraints
u x   u y  and c x  y   by construction  p has a solution if and only if r has a solution 
any pivot t  occurring in r must use a pair of values disallowed by c x  y  since it cannot
occur in p     suppose that hd  d  i is disallowed by c x  y   it follows that the assignment of d
to x  or of d  to y both extend to a solution of q but assigning both d to x and d  to y does
not extend to a solution of the problem induced by p   on u    by lemma     there is a path
of proper constraints between x and y in g u     furthermore  the first constraint along this
path disallows some tuple hd  d  i and the last constraint disallows some tuple hd    d  i  it
follows that we cannot embed pivot r  in the instance r induced on u  together with the
constraint c x  y   otherwise we would have been able to embed it
 in the instance p   
since r  csp pivot r    we can solve it in time o n  dg r    by our inductive hypoth

esis  thus  in this final case  the complexity is o d  n  dg r      n  dg r      o n  dg r   
and we are done 
theorem     is important as it gives us a tractable class of csps defined by forbidding
a negative pattern which  unlike csp tree   contains problems of unbounded tree width 
and so cannot be captured by structural tractability  this is true even for pivot     as
an example of a class of csp instances in csp pivot     with unbounded tree width 
consider the n variable csp instance pn with domain             n  whose constraint graph
  

fitractability of csp classes defined by forbidden patterns

is the complete graph and  for each pair of distinct values i  j              n   the constraint
on variables vi   vj disallows a single pair of assignments  hvi   ji   hvj   ii   since each assignment hvi   ji occurs in a single disallowed tuple  pivot    does not occur in pn   and hence
pn  csp pivot      to produce an example of a class of instances in csp pivot    
with unbounded tree width and which are not in csp negtrans   we can modify pn by
introducing a boolean variable vij for each pair i   j and by replacing the constraint on
variables vi   vj by constraints on vi   vij and on vj   vij   the former disallowing the single pair
of assignments  hvi   ji   hvij    i  and the latter the pair of assignments  hvj   ii   hvij    i   the
pattern negtrans occurs on each triple of assignments  hvi   ji   hvij    i   hvj   ii  
the dichotomy for finite sets of connected binary flat negative patterns now follows
directly from theorem     and corollary     
theorem       let x be a finite set of connected binary flat negative patterns  then x is
tractable if and only if there is some   x that is contained in pivot r   for some integer
r     
informally speaking  this dichotomy states that bounding the length of problematic
pivot r  style inference chains leads to tractability  and moreover that when a class of
instances defined by a finite set of forbidden flat patterns is tractable  then it must avoid
problematic inference chains of this form 
this dichotomy easily extends to patterns which are not necessarily connected  when
a negative pattern  is not connected  it can be decomposed into connected patterns corresponding to the connected components of the negative structure graph of   we call these
patterns the connected components of  
corollary       let x be a finite set of binary flat negative patterns  then x is tractable
if and only if for some   x   each of the connected components of  is contained in
pivot r   for some integer r     
proof  let x be a finite set of binary flat negative patterns  let cc   represent the set of
connected components of a pattern   and cc x   the union of all the sets cc      x   
suppose that x is tractable  consider an arbitrary subset x   of cc x   such that the
set x   contains exactly one connected component from each pattern   x   by lemma     
csp x      csp x    and hence x   is also tractable  therefore  by corollary      there is
some pattern    x   that occurs in pivot r   for some integer r        the only way this
can be true for all possible choices of x   is if there is some   x such that all connected
components of  occur in pivot r   for some integer r     
on the other hand  suppose that for some   x   each of the connected components of
  x occurs in pivot r   where r      let k be the number of connected components
of   then  occurs in the disjoint union of k copies of pivot r   this is tractable by
theorem     and k    applications of lemma      it follows that   and hence x   is
tractable 

   conclusion
in this paper we described a framework for identifying classes of csps in terms of forbidden
patterns  to be used as a tool for identifying tractable classes of the csp  we gave several
examples of small patterns that can be used to define tractable classes of csps 
  

ficohen  cooper  creed  marx   salamon

in the search for a general result  we restricted ourselves to the special case of binary
patterns and binary csps  in theorem     we showed that csp x   is np hard if every
pattern in a set x contains at least one of four patterns  patterns           and      moreover 
we showed that any binary flat negative pattern  that does not contain any of these patterns
must itself be contained within  possibly several copies of  a special type of pattern called
a pivot  hence  being contained in  several copies of  a pivot is a necessary condition for
pattern  to be tractable  we then showed that forbidding the pivot pattern defines a
tractable class 
beyond this dichotomy for binary flat negative patterns  it will be interesting to see
what new tractable classes can be defined by more general binary patterns or by non binary
patterns  in particular  an important area of future research is determining all maximal
tractable classes of problems defined by patterns of some fixed size  given by the number of
variables or the number of variable value assignments   a further avenue for future research
is the characterisation of the complexity of patterns involving structure that uses more than
just disequalities between groups of variables  such as a total ordering on its variables 

acknowledgments
the authors acknowledge support from anr project anr    blan       epsrc grants
ep f         and ep i          erc starting grant paramtight  no           and
epsrc platform grant ep f         

references
bessiere  c   regin  j  c   yap  r  h  c     zhang  y          an optimal coarse grained
arc consistency algorithm  artificial intelligence           pp          doi         
j artint             
bulatov  a   jeavons  p     krokhin  a          classifying the complexity of constraints
using finite algebras  siam journal on computing          pp          doi    
     s                 
bulatov  a  a          tractable conservative constraint satisfaction problems  in lics    
proceedings of   th ieee symposium on logic in computer science  pp         
doi         lics              
bulatov  a  a          a dichotomy theorem for constraint satisfaction problems on a  element set  journal of the acm          pp         doi                         
cohen  d     jeavons  p          the complexity of constraint languages  in rossi et al 
 rossi et al          chap     pp         
cohen  d  a          a new class of binary csps for which arc consistency is a decision
procedure  in cp     proceedings of the  th international conference on principles
and practice of constraint programming  no       in lecture notes in computer
science  pp          springer verlag  doi                              
cooper  m  c     escamocher  g          a dichotomy for   constraint forbidden csp
patterns  in aaai     proceedings of the twenty sixth aaai conference on ar  

fitractability of csp classes defined by forbidden patterns

tificial intelligence  available from  https   www aaai org ocs index php aaai 
aaai   paper view           
cooper  m  c   jeavons  p  g     salamon  a  z          generalizing constraint satisfaction
on trees  hybrid tractability and variable elimination  artificial intelligence        
     pp          doi         j artint             
cooper  m  c     zivny  s       a   hierarchically nested convex vcsp  in cp     proceedings of the   th international conference on principles and practice of constraint
programming  pp          springer verlag  doi                              
cooper  m  c     zivny  s       b   hybrid tractability of valued constraint problems 
artificial intelligence             pp            doi         j artint         
    
costa  m  c          persistency in maximum cardinality bipartite matchings  operations
research letters          pp          doi                              
dalmau  v   kolaitis  p  g     vardi  m  y          constraint satisfaction  bounded
treewidth  and finite variable logics  in cp     proceedings of the  th international conference on principles and practice of constraint programming  no      
in lecture notes in computer science  pp          springer verlag  doi         
                 
dechter  r     pearl  j          network based heuristics for constraint satisfaction problems  artificial intelligence          pp       doi                              
dechter  r     pearl  j          tree clustering for constraint networks  artificial intelligence          pp          doi                              
dirac  g  a          short proof of mengers graph theorem  mathematika          pp 
      doi         s                 
freuder  e  c          complexity of k tree structured constraint satisfaction problems 
in aaai     proceedings of the eighth national conference on artificial intelligence 
pp      available from  http   www aaai org library aaai      aaai       
php 
garey  m  r     johnson  d  s          computers and intractability  a guide to the theory
of np completeness  w  h  freeman  san francisco  ca 
gottlob  g   leone  n     scarcello  f          hypertree decompositions and tractable
queries  journal of computer and system sciences          pp          doi    
     jcss           
green  m  j     cohen  d  a          tractability by approximating constraint languages 
in cp     proceedings of the  th international conference on principles and practice
of constraint programming  vol       of lecture notes in computer science  pp     
     springer verlag  doi                              
grohe  m          the structure of tractable constraint satisfaction problems  in mfcs    
proceedings of the   st symposium on mathematical foundations of computer science  vol       of lecture notes in computer science  pp        springer verlag 
doi                    
  

ficohen  cooper  creed  marx   salamon

grohe  m          the complexity of homomorphism and constraint satisfaction problems
seen from the other side  journal of the acm          pp       doi         
                
gyssens  m   jeavons  p  g     cohen  d  a          decomposing constraint satisfaction
problems using database techniques  artificial intelligence          pp        doi 
                             
jeavons  p   cohen  d     gyssens  m          closure properties of constraints  journal
of the acm          pp          doi                       
jeavons  p  g     cooper  m  c          tractable constraints on ordered domains  artificial
intelligence          pp          doi                              
jegou  p          decomposition of domains based on the micro structure of finite
constraint satisfaction problems  in aaai     proceedings of the eleventh national conference on artificial intelligence  pp          available from  http 
  www aaai org library aaai      aaai       php 
marx  d       a   can you beat treewidth   theory of computing         pp        
doi         toc      v   a    
marx  d       b   tractable hypergraph properties for constraint satisfaction and conjunctive queries  in stoc     proceedings of the   nd acm symposium on theory of
computing  pp          acm  doi                         
regin  j  c          a filtering algorithm for constraints of difference in csps  in aaai    
proceedings of the twelfth national conference on artificial intelligence  vol     pp 
        available from  http   www aaai org library aaai      aaai       
php 
robertson  n     seymour  p  d          graph minors  v  excluding a planar graph  journal of combinatorial theory  series b      pp         doi                      
        
rossi  f   van beek  p     walsh  t   eds            handbook of constraint programming 
foundations of artificial intelligence  elsevier 
salamon  a  z     jeavons  p  g          perfect constraints are tractable  in cp    
proceedings of the   th international conference on principles and practice of constraint programming  vol       of lecture notes in computer science  pp         
springer verlag  doi                              
van hoeve  w  j          the alldifferent constraint  a survey  in proceedings of the  th
annual workshop of the ercim working group on constraints  available from 
http   arxiv org abs cs        v  
weigel  r     bliek  c          on reformulation of constraint satisfaction problems  in
ecai     proceedings of the   th european conference on artificial intelligence  pp 
       

  

fi