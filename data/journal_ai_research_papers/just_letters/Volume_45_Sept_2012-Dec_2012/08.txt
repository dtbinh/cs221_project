journal of artificial intelligence research                  

submitted        published      

tractable set constraints
manuel bodirsky

bodirsky lix polytechnique fr

ecole polytechnique  lix
 umr      du cnrs 
      palaiseau  france

martin hils

hils math univ paris diderot fr

institut de mathematiques de jussieu
 umr      du cnrs 
universite paris diderot paris  
ufr de mathematiques
      paris cedex     france

abstract
many fundamental problems in artificial intelligence  knowledge representation  and
verification involve reasoning about sets and relations between sets and can be modeled as
set constraint satisfaction problems  set csps   such problems are frequently intractable 
but there are several important set csps that are known to be polynomial time tractable 
we introduce a large class of set csps that can be solved in quadratic time  our class 
which we call ei  contains all previously known tractable set csps  but also some new
ones that are of crucial importance for example in description logics  the class of ei set
constraints has an elegant universal algebraic characterization  which we use to show that
every set constraint language that properly contains all ei set constraints already has a
finite sublanguage with an np hard constraint satisfaction problem 

   introduction
constraint satisfaction problems are computational problems where  informally  the input
consists of a finite set of variables and a finite set of constraints imposed on those variables 
the task is to decide whether there is an assignment of values to the variables such that all
the constraints are simultaneously satisfied  set constraint satisfaction problems are special
constraint satisfaction problems where the values are sets  and the constraints might  for
instance  force that one set y includes another set x  or that one set x is disjoint to another
set y  the constraints might also be ternary  or  more generally  of any finite arity   such
as the constraint that the intersection of two sets x and y is contained in z  in symbols
px x yq  z 
to systematically study the computational complexity of constraint satisfaction problems  it has turned out to be a fruitful approach to consider constraint satisfaction problems
csppq where the set of allowed constraints is formed from a fixed finite set  of relations
r  dk over a  possibly infinite  common domain d  for example  if d equals q  the
rational numbers  and  is tu where  is the usual order of the rationals  then csppq
is the problem of deciding whether a given set of  binary  constraints of the form x  y
has a common solution over the rational numbers  this way of parametrizing the conc
    
ai access foundation  all rights reserved 

fibodirsky   hils

straint satisfaction problem by a constraint language  has led to many strong algorithmic
results  e g   bulatov   dalmau        idziak  markovic  mckenzie  valeriote    willard 
      barto   kozik        bodirsky   kutz        bodirsky   kara         and to many
powerful hardness conditions for large classes of constraint satisfaction problems  schaefer 
      bulatov  krokhin    jeavons        bulatov              bodirsky   kara        
a set constraint language  is a set of relations r  pp pnqqk where the common domain
d  p pnq is the set of all subsets of the natural numbers  moreover  we require that each
relation r can be defined by a boolean combination of equations over the signature       c 
   and    which are function symbols for intersection  union  complementation  the empty
and full set  respectively  details of the formal definition of set constraint languages can be
found in section    in section    we give many examples of set constraint languages  the
choice of n is just for notational convenience  we could have selected any infinite set for our
purposes  e g   rn instead of n  a more natural choice in spatial reasoning  one may even
replace p pnq by any infinite boolean algebra  see theorem     
in the following  a set constraint satisfaction problem  set csp  is a problem of the form
csppq for a finite set constraint language   it has been shown by marriott and odersky
that all set csps are contained in np 
drakengren and jonsson        initiated the search for set csps that can be solved
in polynomial time  they showed that csppt      uq can be solved in polynomial time 
where
 x  y holds iff x is a subset of or equal to y 
 x    y holds iff x and y are disjoint sets  and
 x  y holds iff x and y are distinct sets 
they also showed that csppq can be solved in polynomial time if all relations in  can be
defined by formulas of the form
x 

 y         xk  yk   x   y 

x 

 y         xk  yk   x     y 

or of the form

where x            xk   y            yk are not necessarily distinct variables  drakengren   jonsson 
      thm       we will call the set of all relations that can be defined in this way drakengren and jonssons set constraint language  it is easy to see that the algorithm they
present runs in time quadratic in the size of the input  on the other hand  they also show
that if  contains the relation defined by x   y    x   y  and the relation defined by
x   x    x   x  then the problem csppq is np hard  drakengren   jonsson       
thm      
    contributions and outline 
we present a significant extension of drakengren and jonssons        set constraint language  section    whose csp can still be solved in quadratic time in the input size  section     we call this set constraint language ei  unlike drakengren and jonssons set
   

fitractable set constraints

constraint language  our language also contains the ternary relation defined by px x y q  z 
which is a relation that is of particular interest in description logics  we will discuss this
below  moreover  we show that any further extension of ei contains a finite sublanguage
with an np hard set csp  section     using concepts from model theory and universal
algebra  in this sense  we present a maximal tractable class of set constraint satisfaction
problems 
our algorithm is based on the concept of independence in constraint languages which
was discovered several times independently in the   s  lassez   mcaloon        jonsson  
backstrom        marriott   odersky        see also koubarakis        broxvall  jonsson 
  renz        cohen  jeavons  jonsson    koubarakis         however  we apply this
concept twice in a novel  nested way  which leads to a two level resolution procedure that
can be implemented to run in quadratic time  the technique we use to prove the correctness
of the algorithm is also an important contribution of our paper  and we believe that a similar
approach can be applied in many other contexts  our technique is inspired by the already
mentioned connection to universal algebra 
    application areas and related literature
we mention three different contexts where set constraints appeared in the literature 
      set constraints for programming languages 
set constraints find applications in program analysis  here  a set constraint is of the form
x  y   where x and y are set expressions  examples of set expressions are    denoting
the empty set   set valued variables  and union and intersection of sets  but also expressions
of the form f pz    z  q where f is a function symbol and z    z  are again set expressions 
unfortunately  the worst case complexity of most of the reasoning tasks considered in this
setting is very high  often exptime hard  for a survey on this  see aiken         more
recently  it has been shown that the quantifier free combination of set constraints  without
function symbols  and cardinality constraints  quantifier free pressburger arithmetic  has
a satisfiability problem in np  kuncak   rinard         this logic  called qfbapa  is
interesting for program verification  kuncak  nguyen    rinard        
      tractable description logics 
description logics are a family of knowledge representation formalisms that can be used to
formalize and reason with concept definitions  the computational complexity of most of the
computational tasks that have been studied for the various formalisms is usually quite high 
however  in the last years a series of description logics  for example el  el   horn fl   
and various extensions and fragments  kusters   molitor        baader        baader 
brandt    lutz        krotzsch  rudolph    hitzler         has been discovered where
crucial tasks such as e g  entailment  concept satisfiability and knowledge base satisfiability
can be decided in polynomial time 
two of the basic assertions that can be made in el
and horn fl  are c    c   there
is no c  that is also c    and c  x c   c   every c  that is c  is also c     for concept
names c    c    c    these are ei set constraints  and the latter has not been treated in
   

fibodirsky   hils

the framework of drakengren and jonsson  none of the description logics with a tractable
knowledge base satisfiability problem contains all ei set constraints 
      spatial reasoning 
several spatial reasoning formalisms  like rcc   and rcc    are closely related to set constraint satisfaction problems  these formalisms allow to reason about relations between
regions  in the fundamental formalism rcc    see  e g   jonsson   drakengren        
one can think of a region as a non empty set  and possible  binary  relationships are containment  disjointness  equality  overlap  and disjunctive combinations thereof  thus  the
exclusion of the empty set is the most prominent difference between the set constraint languages studied by drakengren and jonsson         contained in the class of set constraint
languages considered here  and rcc   and its fragments  we will see in section   that
the csp for rcc   and the csps for all its reducts are set csps  proposition    

   constraint satisfaction problems
to use existing terminology in logic and model theory  it will be convenient to describe
constraint languages by structures  see  e g   hodges         a structure  is a tuple
pd  f   f           r   r         q where d is a set  the domain of    each fi is a function from
dki  d  where ki is called the arity of fi    and each ri is a relation over d  i e   a subset
of dli  where li is called the arity of ri    for each function fi we assume that there is a
function symbol which we denote by fi   and for each relation ri we have a relation symbol
which we denote by ri   constant symbols will be treated as   ary function symbols  the
set  of all relation and function symbols for some structure  is called the signature of  
and we also say that  is a   structure  if the signature of  only contains relation symbols
and no function symbols  we also say that  is a relational structure  in the context of
constraint satisfaction  relational structures  are also called constraint languages  and a
constraint language   is called a sublanguage  or reduct  of a constraint language  if the
relations in   are a subset of the relations in   and  is called an expansion of     
let  be a relational structure with domain d and a finite signature    the constraint
satisfaction problem for  is the following computational problem  also denoted by csppq 
given a finite set of variables v and a conjunction  of finitely many atomic formulas of the
form rpx            xk q  where x            xk p v and r p    is  satisfiable in   that is  does there
exist an assignment s   v  d such that for every constraint rpx            xk q in the input we
have that pspx  q          spxk qq p r  
the mapping s is also called a solution to the instance  of csppq  and the conjuncts
of  are called constraints  note that we only introduce constraint satisfaction problems
csppq for finite constraint languages  i e   relational structures  with a finite relational
signature 

example    the problem cspppq  qq is the problem of deciding whether a given set of
constraints of the form x  y has a solution that simultaneously satisfies all constraints 
   

fitractable set constraints

   set constraint languages
in this section  we give formal definitions of set constraint languages  let s be the structure with domain p pnq  the set of all subsets of natural numbers  and with signature
t      c      u  where



  is a binary function symbol that denotes intersection  i e    s  x 
  is a binary function symbol for union  i e    s  y 

 c is a unary function symbol for complementation  i e   cs is the function that maps
s  n to nzs 
   and   are constants  treated as   ary function symbols  denoting the empty set
and the full set n  respectively 

h

sometimes  we simply write   for the function  s and   for the function  s   i e   we do
not distinguish between a function symbol and the respective function  we use the symbols
     and not the symbols x  y to prevent confusion with meta mathematical usages of x
and y in the text 
a set constraint language is a relational structure whose relations have a quantifier free
definition in s  we always allow equality in first order formulas  and the equality symbol
 is always interpreted to be the true equality relation on the domain of the structure  we
write x  y as an abbreviation for x   y  x 
example    the ternary relation px  y  z q
definition z   px   y q  x   y over s 

p p pn q    x   y  z

 

has the quantifier free

theorem    see marriott   odersky        proposition       let  be a set constraint
language with a finite signature  then csppq is in np 
it is easy to see that there are np hard set csps  as shown in the next example 
example    consider the set constraint language  that contains the eight relations

tpx  y  zq   x      y      z   u
tpx  y  zq   x      y      z   u
tpx  y  zq   x      y      z   u
tpx  y  zq   x      y      z   u
tpx  y  zq   x      y      z   u
tpx  y  zq   x      y      z   u
tpx  y  zq   x      y      z   u
tpx  y  zq   x      y      z   u  
then the set csp for those relations is the well known   sat problem  which is npcomplete  garey   johnson        
it is well known that the structure pp pnq        c      q is a boolean algebra  with
   

fibodirsky   hils

   playing the role of false  and   playing the role of true 
 c playing the role of


 

  and   playing the role of   and    respectively 

we refer to the work of koppelberg        for background on boolean algebras 
to not confuse logical connectives with the connectives of boolean algebras  we always
use the symbols       and c instead of the usual function symbols       and in boolean
algebras  to facilitate the notation  we also write x instead of cpxq  and x  y instead of
p x  y q 
we assume that all terms t over the functional signature
t      c      u are written in


 inner  conjunctive normal form  cnf   i e   as t  ni  nj i   lij where lij is either of the
form x or of the form x for a variable x  note that every term over t      c      u can be rewritten into an equivalent term of this form  using the usual laws of boolean algebras  boole 
       we allow the special
case n     in which case t becomes     and the special case
ni
ni     in which case j   lij becomes     we refer to ci   tlij      j  ni u as an
 inner  clause of t  and to lij as an  inner  literal of ci   we say that a set of inner clauses
is satisfiable if there exists an assignment from v  p pnq such that for all inner clauses 
the
union of the evaluation of all literals equals n  this is the case if and only if the formula
n
i  ci    has a satisfying assignment  
example    inequality x  y on p pnq can be equivalently written as py   xq px   y q    
in this formula  we have two inner clauses  each with a positive and a negative inner literal 
we assume that all quantifier free formulas  over the signature
t      c      u are written

mi
in  outer  conjunctive normal form  cnf   i e   as   m
j   lij where lij is either
i 
of the form t     a positive  outer  literal   or of the form t     a negative  outer  literal   
again  it is well known and easy to see that we can for every quantifier free formula find
a formula in this form which is equivalent to it in every boolean algebra  we refer to
ci   tlij      j  mi u as an  outer  clause of   and to lij as an  outer  literal of ci  
whenever convenient  we identify  with its set of clauses 
example    consider the formula px  y   y  z q   px  y   y  z q  it can be rewritten
as px  y   y  z q px  y   y  z q  when we subsequently replace inequality literals x  y
by py   xq   px   y q     see example     we arrive at a formula which is in the discussed
normal form  it has two outer clauses  one with two positive outer literals  and the other
with two negative outer literals 
as mentioned in the introduction  all csps for reducts of rcc    and therefore also
many reducts of rcc    can be formulated as set csps  the network satisfaction problem for rcc   can be seen as the csp for the following structure rcc   with domain
p pnqzthu and all binary relations given as follows  for each relation r of rcc   there
exists a quantifier free t      c      u formula px    x  q such that ps    s  q p r if and only if
both s  and s  are non empty  and ps    s  q is true in s  it is clear that there are only
finitely many inequivalent quantifier free formulas over the language t      c      u  and
hence rcc   has only finitely many relations 
   

fitractable set constraints

proposition    let  be a reduct of rcc    then there exists a set constraint language 
such that csppq and csppq are the same problem 
proof  let             n be the formulas the define the relations of   which has domain
p pnqzthu   let  be the structure with domain p pnq and relations r            rn defined
by             n in s  that is  the only difference between  and  is the additional element
thu  which appears in none of the relations of   we have to prove that every finite
conjunction  of atomic formulas of the form ri px            xk q is satisfiable in  if and only if
the conjunction is satisfiable in   if  is satisfiable over  then it is clearly also satisfiable
over  since  is an induced substructure of   conversely  if  is satisfiable over   then
any solution must have the property that if spxi q  h  then xi does not appear in any
constraint  since the constraints force that their arguments are non empty   hence  setting
spxi q to any non empty subset of n will still be a solution  which implies the claim 
proposition   shows that the class of set csps contains the class of all csps for reducts
of rcc    the inclusion is clearly strict  there are set csps that cannot be formulated as
csps for reducts of rcc    since relations in set constraint languages can have arbitrary
arity  while reducts of rcc   only contain binary relations 

   horn horn set constraints
in this section  we study horn horn set constraints  a class of set constraints which admits
an intuitive syntactic description and which is thus easy to define  universal algebraic
considerations on this class in section     lead us to another class of set constraints  called
ei and introduced in section      this class strictly contains the class of horn horn set
constraints  its universal algebraic description is the key for the maximality result which
we will prove in section    as for tractability  set constraint languages from ei allow for a
 linear time  reduction to satisfiability of horn horn clauses  see proposition      we note
that these classes of set constraints  horn horn and ei  have not been studied before 
    horn horn relations
definition    a quantifier free formula is called horn horn if
   every outer clause is outer horn  i e   contains at most one positive outer literal  and
   every inner clause of positive outer literals is inner horn  i e   contains at most one
positive inner literal 
a relation r  p pnqk is called
 outer horn if it can be defined over s by a conjunction of outer horn clauses 
 inner horn if it can be defined over s by a formula of the form pc         ck q
where each ci is inner horn 

 

 horn horn if it can be defined by a horn horn formula over s 
example    inequality

 is horn horn  recall that it may defined by py   xq px   yq    
   

fibodirsky   hils

example    using the previous example  the relation
easily be seen to be horn horn  too 
example    the ternary relation tpx  y  z q   x   y
has the horn horn definition x   y   z    

tpx  y  u  vq   x  y   u  vu can

 zu  which we have encountered above 

proposition    drakengren and jonssons set constraint language only contains horn horn
relations 
proof  the disjointness relation    has the definition x   y     so is inner horn  the
inequality relation  is horn horn since both inner clauses in its definition py   xq px   y q 
  have only one positive inner literal  the inclusion relation x  y has the definition
y   x     so is inner horn 
horn horn is preserved under adding additional outer disequality literals to the outer
clauses  so all relations considered in drakengren and jonssons language are horn horn 
    universal algebraic preliminaries
as we will see in this section  the class of horn horn formulas is preserved by several
important functions defined on the set of subsets of natural numbers 
definition   
 let i   pp pnqq   p pnq be the function that maps a pair of sets ps    s  q
to the set t a   a p s  u y t a     a p s  u 

 denote by fin the set of finite non empty subsets of n  and let f   p pnq  p pfin q 
f ps q   ts 

 s   s  is finite and non emptyu  

 let g   n  fin be a bijection  since both sets are countable  such a bijection exists  
 let e   p pnq  p pnq be defined by
eps q  tg  pt q   t

p f ps qu  

 let ei be the function defined by eipx  y q  epipx  y qq 
intuitively  the functions e and ei are designed so that they forget unions  this will be
formalized in definition      while preserving the other basic operations in s  see lemma
   and proposition   for the case of e  
definition    let f   pp pnqqk  p pnq be a function  and r  p pnql be a relation  then
we say that f preserves r if the following holds  for all a            ak p pp pnqql we have that
pf pa            ak  q          f pa l           akl qq p r if ai p r for all i  k  if f does not preserve r  we
also say that f violates r  we say that f strongly preserves r if for all a            ak p pp pnqql
we have that pf pa             ak  q          f pa l           akl qq p r if and only if ai p r for all i  k  if  is
a first order formula that defines a relation r over s  and f preserves  strongly preserves 
r  then we also say that f preserves  strongly preserves    finally  if g   pp pnqql  p pnq is
a function  we say that f preserves  strongly preserves  g if it preserves  strongly
preserves 
 
the graph of g  i e   the relation px            xl   g px            xl qq   x            xl  n  
   

fitractable set constraints

note that if an injective function f preserves a function g  then it also strongly preserves
g 
example    consider the function f   pp pnqq   p pnq  px  y q  x   y  then f preserves
  since x   y  x    y  whenever x  x  and y   y  on the other hand  f does not strongly
preserve   as is shown by f pn  hq  f ph  nq 
fact    the mapping i is an isomorphism between s  and s 
proof  the mapping
 i can be inverted by the mapping that sends s  n to ta    a p
s u  ta    a   p s u   it is straightforward to verify that i strongly preserves       c       
 clearly  ipx  y q  h if and only if x  y

 h 

 similarly  since the natural numbers are partitioned by the even and odd numbers 
ipx  y q  n if and only if x  y  n 
 let s  and s  be subsets of n  to verify that i preserves c we have to show that
ipcps    s  qq  which is by definition equal to ips    s  q  equals cpips    s  qq  suppose
that a   a    then 
a p i ps     s   q  a  

p s 

 a  r s 
  a  r ips   s q
 a p ips   s q

the argument for a   a 
even strongly preserves c 

  is analogous  thus  i preserves c  since i is injective  it

 let ps    s  q and pt    t  q be from pp pnq    we have to show that ipps    s  q pt    t  qq 
which is by definition equal to ips    t    s    t  q  equals ips    s  q   ipt    t  q  with
a   a  as before 
a p ips    t    s    t  q  a 

p ps    t q

  a  p ips   s q   ipt   t q

the argument for a   a    is again analogous  thus  i preserves
injective  it even strongly preserves   
the verification for

  

since i is

  is similar to that for   

proposition    the function e has the following properties 
 e is injective 

   and
for x  y  z p p pnq such that x   y 
epxq   epy q  epz q 

 e strongly preserves       and


z  not x

   



y  and not y



x  we have that

fibodirsky   hils

proof  we verify the properties one by one  since g is bijective  epxq  epy q if and only if
x and y have the same finite subsets  this is the case if and only if x  y  and hence e is
injective  thus  to prove that e strongly preserves       and    it suffices to check that e
preserves       and   
since g is bijective  we have that gpnq equals the set of all finite subsets of n  and
hence epnq  n  which shows that e preserves    we also compute ephq  g  pf phqq 
g  phq  h 
next  we verify that for all x  y p p pnq we have epxq   epy q  epx   y q  let a p n be
arbitrary  we have a p epxq   epy q if and only if gpaq p f pxq x f py q  by definition of f
and since gpaq is a finite subset of n  this is the case if and only if gpaq p f px   y q  this
is the case if and only if a p epx   y q  which concludes the proof that e preserves   
we verify that if x   y  z  not x  y  and not y  x  then epxq   epy q  epz q  first
observe that for all u  v  n with u  v we have epuq  epv q since e preserves    this
implies that epxq   epy q  epz q  since x  y and y  x  there are a  b such that a p x 
a r y  b p y  b r x  then we have that ta  bu p f pz q  but ta  bu r f pxq y f py q  hence 
g  pta  buq p epz q  but g  pta  buq r epxq   epy q  this shows that epz q  epxq   epy q 
note that in particular e preserves     and     moreover  epcpxqq  cpepxqq  this
follows from preservation of     since x  cpxq  and therefore epxq  epcpxqq  which is equivalent
to the inclusion above  both e and i strongly preserve       and    and therefore also ei
strongly preserves       and   
the following is a direct consequence of the fact that isomorphisms between k and 
preserve horn formulas over   since the simple proof is instructive for what follows  we
give it for the special case that is relevant here 
proposition    outer horn relations are preserved by i 
proof  let  be a conjunction of outer horn clauses with variables v   let tt      t  
           tk   u be an outer clause of   let u  v   v  p pnq be two assignments that satisfy
this clause  let w   v  p pnq be given by x  ipupxq  v pxqq  suppose that w satisfies
tj    for all    j  k  since i is injective we must have that tj    for both u and v for
   j  k  and therefore neither assignment satisfies the negative literals  hence  u and v
must satisfy t      since i is an isomorphism between s  and s  it preserves in particular
t      and hence w also satisfies t     
proposition     inner horn relations are strongly preserved by e 






proof  observe that x   p j y j q    is equivalent to x   p j yj q  j yj   which is strongly
preserved by e since e strongly preserves    this clearly implies the statement 
note that proposition   and proposition    imply that ei strongly preserves inner horn
relations  we later also need the following 

 n  where k     then the following are equivalent 
epx  q        epxk q   epy  q        epyl q    

there exists an i  k such that xi   p j y j q    

lemma     let x            xk   y            yl
  
  

   

fitractable set constraints

   there exists an i  k such that epxi q   p


j

epyj qq    

    we have that j yjl    if and only if jl epyj q    
proof  for the implication 
from p q to p q  suppose that there is for every i  k an ai p n
such that ai r xi   xi   p j y j q  let c be g  ta    a            ak u   then for each i  k  we


have that c r epxi q   j l epyj q  to see this  first observe that ai p j l yj   xi   therefore 
ta           ak u p jl f pyj q   f pxiq for all i  k  we conclude that c r epx q        epxk q  
epy  q        epyl q 
the implication p q  p q follows directly from proposition     the implication p q 
p q is trivial  the second statement is a direct consequence of proposition    
for k

proposition     every horn horn relation is preserved by e and i  and so in particular
by ei 
proof  suppose that r has a horn horn definition  over s with variables v   since r is
in particular outer horn  it is preserved by i by proposition   
now we verify that r is preserved by e  let u   v  p pnq be an assignment that
satisfies   that is  u satisfies at least one literal in each outer clause of   it suffices to
show that the assignment v   v  p pnq defined by x  epupxqq satisfies the same outer
literal  suppose first that the outer literal is positive  because  is horn horn  it is of the
form x   y         yl    or of the form y         yl     which is preserved by e by
lemma    
now  suppose that the outer literal is negative  that is  of the form x         xk   y   
     yl    for some k     we will treat the case k     the other case being similar 
suppose for contradiction that v px  q   
    vpxk q   vpy q        vpyl q     by lemma    
there exists an i  k such that upxi q   p j upy j qq     but then we have in particular that
upx  q        upxk q   upy  q        upyl q     in contradiction to the assumption that u
satisfies  
    ei set constraints
in this section we introduce the class of ei set constraints  show that it strictly contains
all horn horn relations  give several examples and non examples  then we present an
algorithmic reduction from csps for ei set constraints to satisfiability for finite sets of
horn horn clauses 
definition     the set of all relations with a quantifier free definition over s that are
preserved by the operation ei is denoted by ei 
remark  note that the definition of the operation ei  definition    involved a bijection g
between n and fin   we will see later  proposition    and proposition     that the class
ei is independent from the precise choice of g 
recall from proposition    that ei contains all horn horn relations  we now present
examples of relations that are not from ei  and examples of relations that are in ei but
not horn horn 
   

fibodirsky   hils

example     we give an example of a relation that is clearly not from ei  the relation
r  tpx  y q   x   y   u is violated by ei  consider s   t a   a p nu and s   t a
    a p nu  then ps    s  q p r  and since i is an isomorphism between s  and s we
also have that pips    s  q  ips    s  qq p r  since neither ips    s  q  ips    s  q nor ips    s  q 
ips    s  q  we get that epips    s  qq   epips    s  qq  ep q    by proposition    therefore 
peips   s q  eips   s qq r r which is what we wanted to show 
example     the relation r  tpx  y  z q   px  y q   py  z qu is also not preserved by
ei  note that p       q  p       q p r  but eip    q  eip    q  and eip    q are pairwise distinct
since ei is injective 
example     the formula

p x   y  xq
  px   y  yq
  pv      u      x   y   q
is clearly not horn horn  however  the relation defined by the formula is from ei  if
px   y   u   u q und px   y   u   v q are from that relation  then neither ipx   x q  ipy   y q nor
ipy    y  q  ipx    x  q  by proposition    peipx    x  q  eipy    y  q  eipu    u  q  eipv    v  qq satisfies
the formula  there is no equivalent horn horn formula  since the formula is not preserved
by i 
example     the formula ppx   y   q   pu   v   qq   px   y   q   px   y   q is not
horn horn  however  it is preserved by e and by i  the reason is that one of its clauses has
the negative literal x   y     and the conjuncts tx   y   u and tx   y   u  therefore 
for every tuple t p r the tuple eptq satisfies x   y    and is in r as well  by proposition   
r is preserved by i  in this case  the authors suspect that there is no equivalent horn horn
formula  more generally  it is open whether there exist formulas that are preserved by e and
i  but that are not equivalent to a horn horn formula 
corollary     the class of horn horn relations is a proper subclass of ei 
proof  proposition    shows that ei contains all horn horn relations  example    shows
that the inclusion is strict 
we prepare now some results that can be viewed as a partial converse of proposition    
definition     a quantifier free formula   in the syntactic form described at the end of
section    is called reduced if if every formula obtained from  by removing an outer literal
is not equivalent to  over s 
we note that a slightly different notion of a reduced formula has been introduced by
bodirsky  chen  and pinsker         the variant we are using here is better suited for our
purposes 
lemma     in the structure s  every quantifier free formula is equivalent to a reduced
formula 
   

fitractable set constraints

proof  it is clear that every quantifier free formula can be written as a formula  in cnf
and in the form as we have discussed it after theorem    we now remove successively outer
literals as long as this results in an equivalent formula 
we first prove a partial converse of proposition   
proposition     let  be a reduced formula that is preserved by i  then each outer clause
of  is horn 
proof  let v be the set of variables of   assume for contradiction that  contains an outer
clause with two positive literals  t     and t      if we remove the literal t     from
its clause c  the resulting formula is inequivalent to   and hence there is an assignment
s    v  p pnq that satisfies none of the literals of c except for t      similarly  there is
an assignment s    v  p pnq that satisfies none of the literals of c except for t      by
injectivity of i  and since i strongly preserves c        and    the assignment s   v  p pnq
defined by x  ips  pxq  s  pxqq does not satisfy the two literals t     and t      since i
strongly preserves c        none of the other literals in c is satisfied by those mappings as
well  in contradiction to the assumption that  is preserved by i 
definition     let v be a set of variables  and s   v  p pnq be a mapping  then a
function from v  p pnq of the form x  epspxqq is called a core assignment 
lemma     for every quantifier free formula  there exists a formula  such that all inner
clauses are inner horn  and such that  and  have the same satisfying core assignments 
if  is preserved by ei  then the set of all satisfying core assignments of  is closed under
ei 
proof  suppose that  has an outer clause c with a positive outer literal t    such that t
contains an inner clause c   x         xk   y          y l that is not horn  i e   k     then
we replace the outer literal t    in  by k literals t              tk    where ti is obtained
from t by replacing c by xi   y          y l  
we claim that the resulting formula   has the same set of satisfying core assignments 
observe that xi   y          y l  c  and hence ti    implies t     an arbitrary satisfying
assignment of   satisfies either one of the positive outer literals ti     in which case that
observation shows that it also satisfies   or it satisfies one of the other outer literals of c 
in which case it also satisfies this literal in   hence    implies   conversely  let s be a
satisfying core assignment of   if s satisfies a literal from c other than t     then it also
satisfies this literal in     and s satisfies     otherwise  s must satisfy t     and hence
spx  q     spxk q  spy  q     spyl q     since s is a core assignment  lemma    implies
that there exists an i  k such that spxi q   spy  q        spyl q     so s satisfies    
suppose that  has an outer clause c with a negative outer literal t    such that t
contains an inner clause c   x         xk   y          y l that is not horn  i e   k    
then we replace the clause c in  by k clauses c            ck where ck is obtained from c
by replacing c with xi   y          y l  
we claim that the resulting formula   has the same set of satisfying core assignments 
observe that x         xk   y          y l    implies that xi   y          y l     for every
i  k  the observation shows that an arbitrary assignment of  is also an assignment of    
   

fibodirsky   hils

conversely  let s be a satisfying core assignment of     if s satisfies one of the other literals
of c other than t     then s satisfies   otherwise  s must satisfy xi   y        y l    for
all i  k  and by lemma    we have that s also satisfies x         xk   y          y l    
we perform these replacements until we obtain a formula   where all inner clauses are
horn  this formula satisfies the requirements of the first statement of the lemma 
to prove the second statement  let u  v   v  p pnq be two satisfying core assignments
of     since   and  have the same satisfying core assignments  u and v also satisfy   then
the mapping w   v  p pnq given by x  eipupxq  v pxqq is a core assignment  and because
ei preserves   the mapping w satisfies   since  and   have the same core assignments 
w is also a satisfying assignment of     which proves the statement 
we now single out a technical condition which guarantees  under some extra condition
 see proposition     that formulas satisfying a certain universl algebraic property are hornhorn  this will allow us to perform a reduction from a csp associated to a  finite  set
constraint languages from ei to satisfiability of horn horn clauses 
definition     a quantifier free formula   in the syntactic form described at the end of
section    is called strongly reduced if every formula obtained from  by removing an outer
literal does not have the same set of satisfying core assignments over s 
proposition     let  be a strongly reduced formula all of whose inner clauses are horn 
if the set of satisfying core assignments of  is closed under ei  then  is horn horn 
proof  let v be the set of variables of   it suffices to show that all clauses of  are outer
horn  assume for contradiction that  contains an outer clause with two positive literals 
t     and t      if we remove the literal t     from its clause c  the resulting formula
has strictly less satisfying core assignments  this shows the existence of a core assignment
s    v  p pnq that satisfies none of the literals of c except for t      similarly  there exists
a core assignment s    v  p pnq that satisfies none of the literals of c except for t     
by assumption  the inner clauses of t  and t  are horn  we claim that the assignment
s   v  p pnq defined by x  eips  pxq  s  pxqq does not satisfy the clause c  since ei
strongly preserves inner horn clauses  we have that s does not satisfy t       t      for
the same reasons s does not satisfy any other literals in c  this contradicts the assumption
that the satisfying core assignments for  are preserved by ei 
satisfiability of horn horn clauses is the computational problem to decide whether 
given a finite set s of horn horn clauses  there is a satisfying assignment for s 
proposition     let  be a finite set constraint language from ei  then csppq can be
reduced in linear time to satisfiability of horn horn clauses 
proof  let  be an instance of csppq  and let v be the set of variables that appear in
  for each constraint rpx            xk q from   let r be the definition of r over s  by
lemma     there exists a formula r that has the same satisfying core assignments as r
and where all inner clauses are horn  moreover  since r is preserved by ei  the lemma
asserts that the set of all satisfying core assignments of r is preserved by ei  we can
assume without loss of generality that r is strongly reduced  this can be seen similarly to
lemma     by proposition     the formula r is horn horn 
   

fitractable set constraints

let  be the set of all horn horn clauses of formulas r px            xk q obtained from constraints rpx            xk q in  in the described manner  we claim that  is a satisfiable instance
of csppq if and only if  is satisfiable  this follows from the fact that for each constraint
rpx            xk q in   the formulas r and r have the same satisfying core assignments  and
that both r and r are preserved by ei  for r this follows from proposition      so in
particular by the function x  eipx  xq 
note that in proposition    we reduce satisfiability for ei to satisfiability for a proper
subclass of horn horn set constraints  while for general horn horn set constraints we allow
that inner clauses of negative outer literals are not horn  the reduction only produces hornhorn clauses where all inner clauses are horn 

   algorithm for horn horn set constraints
we present an algorithm that takes as input a set  of horn horn clauses and decides
satisfiability of  over s  pp pnq        c      q in time quadratic to the length of the input 
by proposition     this section will therefore conclude the proof that csppq is tractable
when all relations in  are from ei 
as mentioned in the introduction  our algorithm is based on two procedures  both
resolution like  the inner procedure is essentially the well known positive unit resolution
procedure for horn sat  and the outer procedure is basically an algorithm that has been
used in the literature about independence in constraint satisfaction  see  e g   jonsson  
backstrom        koubarakis        broxvall et al         cohen et al          our contribution in this section is the way how to nest these two algorithms to obtain a polynomial time
decision procedure for satisfiability of horn horn clauses 
we start by discussing the first procedure of our algorithm  which we call the inner
resolution algorithm  as in the case of boolean positive unit resolution  dowling   gallier 
      one can implement the procedure inner res such that it runs in linear time in the
input size 
lemma     let  be a finite set of inner horn clauses  then the following are equivalent 
  



    is satisfiable over s 

   inner respq from figure   accepts 
  



    has a solution whose image is contained in


th  nu 

proof  it is obvious that     is unsatisfiable when inner respq rejects  in fact  for
all
inner clauses c derived by inner res from   the formula c    is logically implied by

     conversely  if the algorithm accepts then we can set all eliminated variables to
n and all remaining variables to h  which satisfies all clauses  in the removed clauses the
positive literal is satisfied  and in the remaining clauses we have at least one negative literal
at the final stage of the algorithm  and all clauses with negative literals at the final stage
of the algorithm are satisfied 




the proof of the previous lemma shows that     is satisfiable over s if and only if
    is satisfiable over the two element boolean algebra  as we will see in the following 
   

fibodirsky   hils

inner res  
   input  a finite set  of inner horn clauses
   accepts iff     is satisfiable
during the entire algorithm 
if  contains an empty clause  then reject 
repeat    true
while repeat   true do
repeat    false
if  contains a positive unit clause txu then
repeat    true
remove all clauses where the literal x occurs 
remove the literal x from all clauses 
end if
loop
accept



figure    inner resolution algorithm 
this holds more generally  and not only for inner horn clauses   the following should be
well known  and can be shown with the same proof as given by koppelberg        for the
weaker proposition      there  we give the proof here for the convenience of the reader 
fact     let t    t  be terms over

t      c      u  then the following are equivalent 

     t     is satisfiable over the two element boolean algebra 
t       t     is satisfiable over all boolean algebras 
t       t     is satisfiable over some boolean algebra 
t       t     is satisfiable over some finite boolean algebra 

   t 
  
  
  

proof  obviously      implies      and     implies     
for     implies      assume that t       t     has a satisfying assignment in some
boolean algebra c  let x            xn be the variables which occur in t  or t    and let xi  ci
be a satisfying assignment  then t       t     is satisfiable in the boolean sub algebra
n
c  of c generated by tc            cn u  and c  is finite  it has at most  p  q elements  
for     implies      first note that any finite boolean algebra is isomorphic to the boolean
algebra pp px q        c      q of subsets of some finite set x  if x p x  consider the map hx  
p px q  t    u  hpy q     if x p y   and hpy q    otherwise  then hx is a homomorphism
of boolean algebras  in particular  this shows that for every non zero element a of a finite
boolean algebra c  there is a homomorphism h from c to the two element boolean algebra
such that hpaq     now suppose      and assume that t       t     has a satisfying
assignment in some finite boolean algebra c  let c be the element denoted by t  in c
under this assignment  so c     now let h be a homomorphism from c to t    u such that
hpcq     i e  hpcq     by construction  the image of the satisfying assignment under h is
a satisfying assignment of t       t     in t    u 
   

fitractable set constraints

the same statement for t     instead of t       t     has been given in proposition
      koppelberg         fact    has the following consequence that is crucial for the way
how we use the inner resolution procedure in our algorithm 
lemma     let  be a finite set of inner horn clauses  the following are equivalent 
   inner respytx            xk   y            yl uq rejects 


   over s 


proof 
    implies that x         xk   y          y l    if and only if
 
    x      
  xk   y         yl    is unsatisfiable over s  by fact     this is the case if
and only if       x         xk   y         
y    is unsatisfiable over the   element
 l
boolean algebra  which is the case if and only if       x       xk   y        y l    is
  

    implies that x         xk   y          y l

unsatisfiable over the two element boolean algebra  as we have seen in lemma     this in
turn holds if and only if inner respytx              xk     y              yl   uq rejects 
outer res  
   input  a finite set  of horn horn clauses
   accepts iff  is satisfiable over pp pnq        c      q
during the entire algorithm 
if  contains an empty clause  then reject 
repeat    true
while repeat   true do
repeat    false
let  be the set of all inner horn clauses of terms t
from positive unit clauses tt   u in  
if inner res rejects   then reject 
for each negative literal t    in clauses from 
for each inner clause d  tx            xk   y             y l u of t
call inner res on
 y tx              xk     y              yl   u
if inner res rejects then remove clause d from t
end for
if all clauses in t have been removed  then
remove outer literal t    from its clause
repeat    true
end for
loop
accept

figure    outer resolution algorithm 
theorem     the algorithm outer res in figure   decides satisfiability for sets of hornhorn clauses in quadratic time 
proof  we first argue that if the algorithm rejects   then  has indeed no solution  first
note that during the whole argument  the set of clauses  has the same satisfying tuples
   

fibodirsky   hils

 i e   the corresponding formulas are equivalent   observe that only negative literals get
removed from clauses  and that a negative literal t    only gets removed from a clause
when inner res rejects  y tx              xk     y              yl   u for each inner clause
tx           xk   y           yl u of t  by lemma     if inner res rejects  ytx              xk     y  
           yl   u then  implies that x         xk   y          y l     hence  the positive
unit clauses imply that t    and therefore the literal t    can be removed from the clause
without changing the set of satisfying tuples  now the algorithm rejects if either inner res
rejects  or if it derives the empty clause  in both cases it is clear that  is not satisfiable 
thus  it suffices to construct a solution when the algorithm accepts  let  be the set of
all inner clauses of terms from positive unit clauses at the final stage  when the algorithm
accepts  for each remaining negative outer literal tt   u and each remaining inner clause
d  tx            xk   y             y l u of t there exists an assignment d from v  p pnq that satisfies
 ytx       xk   y        y l   u  otherwise  by lemma     the inner resolution algorithm
would have rejected  y tx              xk     y              yl   u  and would have removed
the inner clause d from t  let d            ds be an enumeration of all remaining inner clauses
d that appear in all remaining negative outer literals 
write is for the s ary operation defined by px            xs q  ipx    ipx            ipxs    xs q    qq
 where i is as in fact     we claim that s   v  p pnq given by
x  is pd  pxq          ds pxqq

satisfies all clauses in   let c be a clause from   by assumption  at the final stage of the
algorithm  the clause c is still non empty  also note that since all formulas in the input
were horn horn  they contain at most one positive literal  this holds in particular for c 
and we therefore only have to distinguish the following cases 
 at the final state of the algorithm  c still contains a negative literal t     since t   
has not been removed  there is a remaining inner clause d  tx            xk   y             y l u
of t  observe that spx  q        spxk q   spy  q        spyl q    if and only if dj px  q  
     dj pxk q   dj py q        dj pyl q    for all    j  s  hence  and since
d px  q        d pxk q   d py  q        d pyl q     s satisfies t     this shows that
s satisfies c 
 all negative literals have been removed from c during the algorithm  the positive
literal t     of c is such that the inner clauses of t  are horn  they will be part of
  and therefore t     is satisfied by s  indeed  by assumption the assignments dj
satisfy   and  is preserved by i 
we conclude that s is a solution to   the inner resolution algorithm has a linear time
complexity  the outer resolution algorithm performs at most a linear number of calls to
the inner resolution algorithm  and it is straightforward to implement all necessary data
structures for outer resolution to obtain a running time that is quadratic in the input
size 
combining proposition    with theorem     we obtain the following 
theorem     let  be a finite set constraint language from ei  then csppq can be
solved in quadratic time 
   

fitractable set constraints

   maximal tractability
in this section we show that the class ei is a maximal tractable set constraint language 
more specifically  let  be a set constraint language that strictly contains all ei relations 
we then show that  contains a finite set of relations   such that already the problem
cspp  q is np hard  theorem     
    the universal algebraic approach
in our proof we use the so called universal algebraic approach to the complexity of constraint satisfaction problems  which requires that we re formulate set csps as constraint
satisfaction problems for  categorical structures  for a more detailed introduction to the
universal algebraic approach for  categorical structures  see bodirsky         a structure
 with a countable domain is called  categorical if all countable structures that satisfy
the same first order sentences as  are isomorphic to   see  e g   hodges         by the
theorem of ryll nardzewski  and for countable signatures  this is equivalent to requiring
that every relation that is preserved by the automorphisms  of  is first order definable in
  see  e g   hodges         a useful consequence of this is that in an  categorical structure   whenever two tuples c  pc            cn q and d  pd            dn q from  satisfy the same
first order formulas  there is an automorphism  of  which maps c to d 
an example of an  categorical structure is pq  q  by cantors theorem   and a nonexample is given by pz  q  note that pq  q and pz  q have the same csp  indeed  any two
infinite linear orders share the same csp  since they even have the same finite substructures 
a characterisation of those infinite structures for which there is an  categorical structure
having the same csp has been given by bodirsky  hils  and martin         empirically 
it can be observed that constraint satisfaction problems studied in temporal and spatial
reasoning are typically called qualitative if and only if they can be formulated with an
 categorical template 
set constraint languages are in general not  categorical  this follows easily by the
mentioned theorem of ryll nardzewski   however  every set csp can be formulated as the
csp of an  categorical structure  to see this  we first have to recall some basic facts about
boolean algebras  all countable atomless  boolean algebras are isomorphic  koppelberg 
      corollary       see also hodges        example   on page       let a denote such a
countable atomless boolean algebra  and let a denote the domain of a  again  we use  
and   to denote join and meet in a  respectively  since the axioms of boolean algebras and
the property of not having atoms can all be written as first order sentences  it follows that a
is  categorical  a structure b has quantifier elimination if every first order formula is over
b equivalent to a quantifier free formula  it is well known that a has quantifier elimination
 see hodges        exercise    on page       we will also make use of the following 
theorem     marriott   odersky        corollary       a quantifier free formula is satisfiable in some infinite boolean algebra if and only if it is satisfiable in all infinite boolean
algebras 
   an isomorphism of a structure  with itself is called an automorphism of  
   an atom in a boolean algebra is an element x    such that for all y with x x y
y     if a boolean algebra does not contains atoms  it is called atomless 

   

 y and x  y we have

fibodirsky   hils

in particular  when b is an infinite boolean algebra and             n are quantifier free
formulas over the signature t      c      u  and when  is the relational structure with signature tr            rn u where ri is for each i  n defined by i over b  then csppq does not
depend on the choice of b 
a fundamental concept in the complexity theory of constraint satisfaction problems is
the notion of primitive positive definitions  a first order formula is called primitive positive
 pp  if it is of the form
dx           xn p         mq
where for each i  m the formula i is of the form rpy            yl q or of the form y   y    and
where r is a relation symbol and y    y            yl are either free variables or from tx            xn u 
we say that a k ary relation r  dk is primitive positive definable  pp definable  over a
  structure  with domain d iff there exists a primitive positive formula px            xk q with
the k free variables x            xk such that a tuple pb            bk q is in r if and only if pb            bk q
is true in  
example     the relation tpx  y q p p pnq    x  y u is pp definable in pp pnq  s  q where
s  tpx  y  z q   x   y  z u  the pp definition is s px  x  y q   x  y  the definition is even
quantifier free  
example     the relation tpx    x    x    y q p p pnq    x    x    x   y u is pp definable
in pp pnq  s q where s  tpx  y  z q   x   y  z u  the pp definition is du ps px    x    uq  
s pu  x    y qq 
when every relation of a structure  is preserved by an operation f   then f is called a
polymorphism of   note that polymorphisms of  also preserve all relations that have a pp
definition in   the following has been shown for finite domain constraint satisfaction by
bulatov et al          the easy proof also works for infinite domain constraint satisfaction 
lemma     let r be a relation with a primitive positive definition in a structure   then
csppq and the csp for the expansion of  by the relation r are polynomial time equivalent 
the following theorem is one of the reasons why it is useful to work with  categorical
templates  when this is possible  
theorem     bodirsky   nesetril         let  be an  categorical structure  then r is
primitive positive definable in  if and only if r is preserved by all polymorphisms of  
the previous and the next result together can be used to translate questions about
primitive positive definability 
into purely operational questions  let d be a set  let opnq
pnq the set of operations on d of finite arity  an
be dn  d  and let o be  
n  o
p
n
q
operation  p o is called a projection if for some fixed i p t           nu and for all n tuples
px           xnq p dn we have the identity px           xnq  xi  the composition of a k ary
operation f and k operations g            gk of arity n is the n ary operation defined by

pf pg           gk qqpx           xnq

 f g px           xnq          gk px           xnq  
   

fitractable set constraints

definition     we say that f  o locally generates f   dn  d if for every finite subset
a of d there is an operation g   dn  d that can be obtained from the operations in f
and projection maps by composition such that f paq  g paq for all a p an  
theorem     see szendrei        corollary      also bodirsky        proposition         let
f  o be a set of operations with domain d  then an operation f   dk  d preserves all
finitary relations that are preserved by all operations in f if and only if f locally generates
f 
the set of all automorphisms of a structure  is denoted by autpq  in the following  we
always consider sets of operations f that contain autpaq  and therefore make the following
convention  for f  o  we say that f generates f p o if f y autpaq locally generates f  
    ei set constraints over the atomless boolean algebra
in the previous subsection we have seen that all set csps can be formulated as csps for
 categorical structures  in this section  we describe those  categorical templates that
correspond to set csps for ei set constraints  in order to do so  we define analogs of the
operations e and i  defined on a instead of p pnq 
proposition     there is an isomorphism i between a  and a 
proof  it is straightforward to verify that a  is again a countable atomless boolean algebra 

motivated by the properties of e described in lemma     we make the following definition 
definition     let b and b  be two arbitrary boolean algebras with domains b and b    
respectively  and let g   b  b   be a function that strongly preserves       and    we say
that g forgets unions if for all k     l     and x            xk   y            yl p b we have
epx  q        epxk q   epy  q        epyl q   
if and only if there exists an i  k such that xi   y         yl

   

proposition     there exists an injection e   a  a that strongly preserves
in a  and that forgets unions 

      and  

proof  the construction of e is by a standard application of konigs tree lemma for categorical structures  see  e g   bodirsky   dalmau        lemma     it suffices to show
that there is an injection f from every finite induced substructure b of a to a such that f
strongly preserves       and    and forgets unions 
so let b be such a finite substructure of a  and let b be the domain of b  let c 
pp pb q        c      q be the boolean algebra of the subsets of b  we claim that g   b  p pb q
given by g p q    and g pxq  tz   z      z b xu for x   
 preserves   and    this is by definition 
   

fibodirsky   hils

 preserves

   for x  y p b  including the case that x    or y     we have
g pxq  c g py q  tz   z      z b x   z b y u
 
 z   z      z b px  b y q
 g p x  b y q  

 is injective  if x  y
x  y 
 strongly preserves

p b such that gpxq  gpyq  then x b y and y b x  and hence
   this follows from the previous two items 

 forgets unions  this can be shown analogously to the proof of lemma    






indeed  one has xi   y         yl    iff xi b j yj iff xi   j yj  j yj iff


g pxi q  j g pyj q  j g pyj q iff g pxi q  g py  q     g pyl q     thus  xi   y       yl   
for some    i  k implies g px  q        g pxk q   g py  q        g pyl q    
to prove the converse  we use that the finite boolean algebra b may be identified with
pp paq        c      q for some finite set a  if xi   xi   y       yl    for i             k 
we may choose ai p azxi   i e  ai p j yj   xi   for i             k  let c   ta            ak u 
a  so c p b  by construction  for i  k one has tc u r g pxi q   g py  q        g pyl q  in
particular  it follows that g px  q        g pxk q   g py  q        g pyl q    
clearly  there is an embedding h from c into a  then f   hpg q is a homomorphism from
b to a that forgets unions 
proposition     let  be a quantifier free formula over the signature t      c      u  then
e preserves  over s if and only if e preserves  over a  moreover  every operation from
a  a that strongly preserves       and   and forgets unions generates e  and is generated
by e 
proof  let a be a tuple of elements from a  clearly  there exists a tuple b of elements from
p pnq such that a and b satisfy the same set  of quantifier free formulas  this follows from
the fact that every finite boolean algebra is the boolean algebra of subsets of a finite set 
now observe that whether or not the tuple epbq satisfies a quantifier free formula  only
depends on   by lemma     since e strongly preserves       and    and forgets unions 
the same is true for the quantifier free formulas that hold on epaq  hence  e preserves 
over a if and only if e preserves  over s 
to prove the second part of the statement  we use theorem     suppose that c and
d are tuples  of the same length  of elements from a that satisfy the same quantifier free
formulas  since a has quantifier elimination  it follows that c and d satisfy the same firstorder formulas in a  by the consequence of the theorem of ryll nardzewski mentioned at
 by the
the beginning of section      there exists an automorphism  of a that maps c to d 
above observations and theorem     this implies that all operations that strongly preserve
      and    and forget unions generate each other 
r be the operation px  y q  epipx  y qq 
let ei
   

fitractable set constraints

proposition     let  be a quantifier free formula over the signature t      c      u  then
r preserves  over a  moreover  every binary operation
ei preserves  over s if and only if ei
r and is generated by
g that strongly preserves       and    and forgets unions generates ei 
r
ei 
proof  the arguments are similar to the ones given in the proof of proposition     if a 
and a  are n tuples of elements from a  there are n tuples b    b  of elements from p pnq such
that pa    a  q and pb    b  q satisfy the same set  of quantifier free formulas  whether or not
eipb    b  q satisfies a quantifier free formula  only depends on   as ei strongly preserves   
r pa    a  q  and so ei
r preserves  over a if
   and    and forgets unions  the same holds for ei
and only if ei preserves  over s 
the proof of the second part of the statement is identical to the one for proposition    

    the central argument
we now give the central argument for the maximal tractability of ei  stated in universalalgebraic language  we say that an operation from ak  a depends on the argument
i p t           k u if there is no pk  q ary operation f   such that for all x            xk p a
f px            xk q  f   px            xi    xi

            xk

q 

we can equivalently characterize k ary operations that depend on the i th argument by
requiring that there are x            xk p a and x i p a such that
f px            xk q  f px            xi    x i   xi

            xk

q 

the following is a general fact about injective maps 
lemma     let f   ak  a be a function that depends on all arguments  and which is
locally generated by a set of injective operations f  then f is injective 
proof  we first prove that every term t px            xn q formed from operations from f over
the variables x            xn such that every variable appears at least once defines an injective
map  we prove this by induction over the term structure  in case that n    and t is just
x  there is nothing to show  otherwise  t has the form f pt            tk q for a k ary f p f such
that tj  tj pxi            ximpj q q is for all j  k a term over operations from f with variables
xi            ximpj q each of which appears at least once in tj   now suppose that a            an p a
and b            bn p a are such that t pa            an q  t pb            bn q  we want to show that ai  bi
for all i  n  since f is injective we must have that tj pai            aimpj q q  tj pbi            bimpj q q
for all j  k  since every variable from x            xn appears in t at least once  the variable
xi must appear in tj   for some j  k  since tj defines an injective operation by inductive
assumptions  we must have that ai  bi   it follows that t defines an injective map 
now suppose that f is an operation that is locally generated by f and depends on
all arguments  thus  for each i there are ci            cin and di such that f pci            cin q 
f pci            cii    di   cii             cin q  let a            an   b            bn p a be such that f pa            an q 
f pb            bn q  we have to show that a   b            an  bn   since f is locally generated
   

fibodirsky   hils

by f  there exists a term t px            xn q composed from the variables x            xn and operations from f such that t pe            en q  f pe            en q for all elements e            en from the
set ta            an   b            bn   c             cnn   d            dn u  for all i  the variable xi must appear in
t px            xn q because t pci            cin q  t pci            cii    di   cii             cin q  hence  the argument
from the beginning of the proof shows that t px            xn q defines an injective map  and
therefore that a   b            an  bn   we have shown that f is injective 
r u  then either tf u generates ei 
r or f
theorem     let f be an operation generated by tei
is generated by teu 

r u 
proof  to show the statement of the theorem  let f be a k ary operation generated by tei
for the sake of notation  let x            xl be the arguments on which f depends  for l  k 
let f     al  a be the operation given by f   px            xl q  f px            xl    xl   xl           xl q 
observe that f   depends on all arguments  and is locally generated by injective operations 
by lemma     f   is injective  since f   is generated by operations that preserve       and
   also f   preserves them  as f   is injective  it even strongly preserves       and   
consider first the case that l     i e   f   is unary  if for all finite subsets of a  the
operation f   equals an automorphism of a  then f is generated by autpaq and there is
nothing to show  so assume otherwise  that is  assume that there is a finite set s  a
such that there is no a p autpaq with f   pxq  apxq for all x p s  we claim that f   forgets
unions  to see this  let u            um   v            vn be from a such that f   pu  q        f   pum q  
 u  there is a term t pxq composed
f   pv  q        f   pvn q     since f   is generated by tei
r
from ei  the automorphisms of a  and a single variable x such that f   pxq  t pxq for all
x p s y tu            um   v            vn u  by the choice of s  this term cannot be composed of
automorphisms alone  and hence there must be a p autpaq and operational terms t    t 
r such that f   pxq  apei
r pt  pxq  t  pxqqq for all
composed from automorphisms of a and ei
r
x p s  as ei forgets unions  there exists an i  k such that t  pui q  t  pv  q     tl pvn q    
since t  strongly preserves    this means that ui   v          v n     see the proof of
proposition      which is what we wanted to show  by proposition    it follows that f   is
generated by e  but then f is generated by e as well 
next  consider the case that l     let g be the binary operation defined by g px  y q 
 
f px  y          y q  this functions depends on both arguments  and so cannot be generated by
the automorphisms of a alone  hence  there is a term of the form
r pt  px  y q  t  px  y qqq
t px  y q  apei

where
 a p autpaq 
r the automorphisms of a  and the
 t  and t  are operational terms composed from ei 
two variables x and y 

 g px  y q  t px  y q for all px  y q p tu            um   v            vn u 

we claim that g forgets unions  assume g pu  q     g pum q  g pv  q     g pvn q    for
some elements u   pu     u   q          um  pu m   u m q  v   pv     v   q          vn  pvn    vn  q from a   
r forgets unions  there exists an i  k such that t  pui q  t  pv  q     t  pvn q    and
since ei
   

fitractable set constraints

t  pui q t  pv  q    t  pvn q     suppose first that t  depends on both arguments  then t 
defines an injective operation and strongly preserves    it follows that ui   v        v n   
in a  since these equations are inner horn  we can argue similarly if t  depends on both
arguments  and in those cases we have established that g forgets unions  suppose now
that each of t  and t  does not depend on both arguments  consider first the case that
t  only depends on the first argument  then the function x  t  px  xq is injective and
strongly preserves    and from t  pui q   t  pv  q        t  pvn q    we derive as above that
u i   v          vn     holds in a  in this case  t  must depend on the second argument 
since t depends on both arguments  we therefore also have that u i   v        vn     holds
in a  the situation that t  only depends on the second argument and t  only depends on
r
the first argument is analogous  so g forgets unions  by proposition     g generates ei 
r
consequently  also f generates ei 
theorem     let  be a set constraint language  suppose that  contains all relations from
ei  and also contains a relation that is not from ei  then there is a finite sublanguage  
of  such that cspp  q is np hard 
proof  when r    r          are the relations of   let               be quantifier free formulas that
define r    r          over s  pp pnq        c      q  let r a   r a         be the relations defined
by               over a  and let  be the relational structure with domain a and exactly those
r and contains
relations  by proposition      contains a relation that is not preserved by ei 
r consider the set f of all polymorphisms of   by
all relations that are preserved by ei 
theorem     all operations in f are locally generated by eri 
the set f does not contain eri  since this would contradict by theorem    the fact
r since f is locally closed  it follows
that  contains a relation that is not preserved by ei 
from theorem    that all operations f p f are generated by e  but then the relation
tpx  y  zq   x  y  z   x  y  zu is preserved by all operations in f  we have already seen
this relation in example     and hence pp definable in  by theorem     this relation has
an np complete csp  bodirsky   kara         let   be the reduct of  that contains
exactly the relations that appear in the pp definition of tpx  y  z q   x  y  z   x  y  z u
in   clearly  there are finitely many such relations  we denote the corresponding relation
symbols by        by lemma     cspp  q is np hard 
this establishes also the hardness of csppq  let   be the     reduct of   we claim
that cspp  q and cspp  q are the same computational problem  we have to show that
a conjunction of atomic     formulas  is satisfiable in   if and only if it is true in    
replacing each atomic     formula in  by its quantifier free definition  this follows from
theorem    

   concluding remarks
we have introduced the powerful set constraint language of ei set constraints  which in
particular contains all horn horn set constraints and all previously studied tractable set
constraint languages  constraint satisfaction problems over ei can be solved in polynomial
 even quadratic  time  our tractability result is complemented by a complexity result
which shows that tractability of ei set constraints is best possible within a large class of
set constraint languages 
   

fibodirsky   hils

we would also like to remark that there is an algorithm to test whether a given finite set
constraint language  where relations in the language are given by quantifier free formulas
over the signature t      c      u  is contained in ei  this means that the so called metaproblem for ei set constraints can be decided effectively 
proposition     there is an algorithm to test whether a given quantifier free formula over
the signature t      c      u defines a relation from ei 
proof  it is clear that  can be effectively transformed into the normal form that is described
in section    so we will from now on assume that  is a conjunction of outer clauses  and
that each atomic formula is of the form t    where t is in inner conjunctive normal form 
let n be the number of variables of   we have to test that for any two n tuples u    u 
of elements of p pnq that satisfy   the n tuple eipu    u  q satisfies  as well  note that
whether or not a tuple satisfies  in s only depends on the boolean algebra generated
by the entries of this tuple in s  any boolean algebra generated by n elements is of size
n
at most      therefore  there are finitely many cases to check  for each pair of boolean
algebras with generating tuples u    u    we check whether eipu    u  q satisfies  as follows  by
lemma     eipu    u  q satisfies an atomic formula t    if and only if for every inner clause
x    
     xk   epy q        epy q of t there exists an i  k such that ipu   u
  q satisfies
xi   j y j     this in turn is true if and only if both u  and u  satisfy xi   j y j    
the truth value of non atomic formulas of the tuple eipu    u  q can then be computed from
the truth value of the atomic formulas in the usual way 

finally we would also like to remark that one can analogously obtain tractability for
the class of constraints where the inner clauses of the positive outer literals are dual horn
 i e   have at most one negative literal   all statements and proofs for the respective result
can be obtained by dualizing in the following formal sense  the dual of a relation r that is
definable over a boolean algebra is the relation tcptq   t p ru  the dual of a k ary operation
f on the same domain is the operation px            xk q  cpf pcpx  q          cpxk qqq  the proofs
then translate literally into proofs for the dualized versions of the statements 

acknowledgments
an extended abstract of this article appeared in the proceedings of ijcai    bodirsky  hils 
  krimkevitch           we want to thank francois bossiere who pointed out mistakes in
the conference version of the paper  one mistake concerned the reduction from the csp
for languages from ei to satisfiability of horn horn clauses  the other concerned a problem
in a previous proof of theorem    
manuel bodirsky has received funding from the erc under the european communitys
seventh framework programme  fp            grant agreement no          
   the third author of the conference version left the author team for the preparation of the journal version 

   

fitractable set constraints

references
aiken  a          set constraints  results  applications  and future directions  in proceedings
of the second workshop on the principles and practice of constraint programming 
pp         
baader  f          least common subsumers and most specific concepts in a description logic
with existential restrictions and terminological cycles  in proceedings of international
joint conferences on artificial intelligence  ijcai   pp         
baader  f   brandt  s     lutz  c          pushing the el envelope  in international joint
conferences on artificial intelligence  ijcai   pp         
barto  l     kozik  m          constraint satisfaction problems of bounded width  in
proceedings of the annual symposium on foundations of computer science  focs  
pp         
bodirsky  m          complexity classification in infinite domain constraint satisfaction 
memoire dhabilitation a diriger des recherches  universite diderot  paris    available
at arxiv           
bodirsky  m   chen  h     pinsker  m          the reducts of equality up to primitive
positive interdefinability  journal of symbolic logic                   
bodirsky  m     dalmau  v          datalog and constraint satisfaction with infinite templates  to appear in the journal on computer and system sciences  a preliminary
version appeared in the proceedings of the symposium on theoretical aspects of
computer science  stacs    
bodirsky  m   hils  m     krimkevitch  a          tractable set constraints  in proceedings
of international joint conferences on artificial intelligence  ijcai   pp         
bodirsky  m   hils  m     martin  b          on the scope of the universal algebraic approach to constraint satisfaction  to appear in logical methods in computer science  lmcs         available at arxiv          v   an extended abstract that
announced some of the results appeared in the proceedings of logic in computer
science  lics    
bodirsky  m     kara  j          the complexity of equality constraint languages  theory of
computing systems                 a conference version appeared in the proceedings
of computer science russia  csr    
bodirsky  m     kara  j          the complexity of temporal constraint satisfaction problems  journal of the acm               an extended abstract appeared in the
proceedings of the symposium on theory of computing  stoc    
bodirsky  m     kutz  m          determining the consistency of partial tree descriptions 
artificial intelligence              
bodirsky  m     nesetril  j          constraint satisfaction with countable homogeneous
templates  journal of logic and computation                 
boole  g          an investigation of the laws of thought  walton  london  reprinted by
philisophical library  new york       
   

fibodirsky   hils

broxvall  m   jonsson  p     renz  j          disjunctions  independence  refinements 
artificial intelligence                    
bulatov  a  a          tractable conservative constraint satisfaction problems  in proceedings of the symposium on logic in computer science  lics   pp          ottawa 
canada 
bulatov  a  a          a dichotomy theorem for constraint satisfaction problems on a
  element set  journal of the acm                
bulatov  a  a     dalmau  v          a simple algorithm for maltsev constraints  siam
journal on computing               
bulatov  a  a   krokhin  a  a     jeavons  p  g          classifying the complexity of
constraints using finite algebras  siam journal on computing             
cohen  d   jeavons  p   jonsson  p     koubarakis  m          building tractable disjunctive
constraints  journal of the acm                 
dowling  w  f     gallier  j  h          linear time algorithms for testing the satisfiability
of propositional horn formulae  the journal of logic programming                
drakengren  t     jonsson  p          reasoning about set constraints applied to tractable
inference in intuitionistic logic  journal of logic and computation                
garey  m     johnson  d          a guide to np completeness  csli press  stanford 
hodges  w          model theory  cambridge university press 
idziak  p  m   markovic  p   mckenzie  r   valeriote  m     willard  r          tractability
and learnability arising from algebras with few subpowers  siam journal on computing                   
jonsson  p     backstrom  c          a unifying approach to temporal constraint reasoning 
artificial intelligence                  
jonsson  p     drakengren  t          a complete classification of tractability in rcc   
journal of artificial intelligence research            
koppelberg  s          projective boolean algebras  in handbook of boolean algebras 
vol     pp          north holland  amsterdam new york oxford  tokyo 
koubarakis  m          tractable disjunctions of linear constraints  basic results and applications to temporal reasoning  theoretical computer science              
krotzsch  m   rudolph  s     hitzler  p          on the complexity of horn description
logics  in owl  experiences and directions workshop 
kuncak  v   nguyen  h  h     rinard  m  c          deciding boolean algebra with presburger arithmetic  journal of automatic reasoning                 
kuncak  v     rinard  m  c          towards efficient satisfiability checking for boolean
algebra with presburger arithmetic  in proceedings of the international conference
on automated deduction  cade   pp         
kusters  r     molitor  r          approximating most specific concepts in description
logics with existential restrictions  ai communications               
   

fitractable set constraints

lassez  j  l     mcaloon  k          independence of negative constraints  in international
joint conference on theory and practice of software development  tapsoft   volume    pp       
marriott  k     odersky  m          negative boolean constraints  theoretical computer
science                    
schaefer  t  j          the complexity of satisfiability problems  in proceedings of the
symposium on theory of computing  stoc   pp         
szendrei  a          clones in universal algebra  seminaire de mathematiques superieures 
les presses de luniversite de montreal 

   

fi