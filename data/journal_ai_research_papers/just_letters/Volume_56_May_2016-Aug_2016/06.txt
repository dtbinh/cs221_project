journal of artificial intelligence research                  

submitted        published      

research note
time bounded best first search for reversible and non reversible
search graphs
carlos hernandez

carlos   hernandez   u   unab   cl

departamento de ciencias de la ingeniera 
universidad andres bello 
santiago  chile

jorge a  baier

jabaier   ing   puc   cl

departamento de ciencia de la computacion
pontificia universidad catolica de chile
santiago  chile

roberto asn

rasin   ucsc   cl

departamento de ingeniera informatica
universidad catolica de la santsima concepcion
concepcion  chile

abstract
time bounded a  is a real time  single agent  deterministic search algorithm that expands
states of a graph in the same order as a  does  but that unlike a  interleaves search and action execution  known to outperform state of the art real time search algorithms based on korfs learning
real time a   lrta   in some benchmarks  it has not been studied in detail and is sometimes not
considered as a true real time search algorithm since it fails in non reversible problems even it
the goal is still reachable from the current state  in this paper we propose and study time bounded
best first search  tb bfs   a straightforward generalization of the time bounded approach to any
best first search algorithm  furthermore  we propose restarting time bounded weighted a   tbr
 wa     an algorithm that deals more adequately with non reversible search graphs  eliminating
backtracking moves and incorporating search restarts and heuristic learning  in non reversible
problems we prove that tb bfs  terminates and we deduce cost bounds for the solutions returned
by time bounded weighted a   tb wa     an instance of tb bfs   furthermore  we prove tbr
 wa    under reasonable conditions  terminates  we evaluate tb wa  in both grid pathfinding and
the    puzzle  in addition  we evaluate tbr  wa   on the racetrack problem  we compare our
algorithms to lss lrtwa   a variant of lrta  that can exploit lookahead search and a weighted
heuristic  a general observation is that the performance of both tb wa   and tbr  wa   improves as the weight parameter is increased  in addition  our time bounded algorithms almost
always outperform lss lrtwa  by a significant margin 

   introduction
in many search applications  time is a very scarce resource  examples range from video game path
finding  where a handful of milliseconds are given to the search algorithm controlling automated
characters  bulitko  bjornsson  sturtevant    lawrence         to highly dynamic robotics  schmid 
tomic  ruess  hirschmuller    suppa         in those settings  it is usually assumed that a standard
search algorithm will not be able to compute a complete solution before an action is required  and
thus execution and search must be interleaved 
c
    
ai access foundation  all rights reserved 

fih ern andez   baier     a s in

time bounded a   bjornsson  bulitko    sturtevant        is an algorithm suitable for searching under tight time constraints  in a nutshell  given a parameter k  it runs a standard a  search
towards the goal rooted in the initial state  but after k expansions are completed  a move is performed and then search  if still needed  is resumed  the move is computed as follows  if the agent
is in the path  found by a  from the root node to the best node b in the search frontier then the
agent is moved towards b following the path   otherwise  it performs backtracking move  returning the agent to its previous state  the algorithm always terminates with the agent at the goal
state  if the problem has a solution 
time bounded a  is an algorithm that is relevant to the real time search community  it is
significantly superior to well known real time heuristic search algorithms in some applications 
indeed hernandez  baier  uras  and koenig        showed it significantly outperforms state of theart real time heuristic search algorithms such as rtaa   koenig   likhachev        and dartaa 
 hernandez   baier        in pathfinding 
being a relatively new algorithm  time bounded a  has not been studied deeply in the literature  one of the reasons for this is perhaps its inability to adequately deal with non reversible
problems  indeed  in non reversible problems any real time search algorithm will fail as soon the
algorithm has led the agent to a dead end state  i e   one from which the goal is unreachable  timebounded a   however  has an additional failure condition  it will always fail as soon as a backtrack
move is required over an unreversible action  thus the class of problems it cannot solve is more limited compared to other real time search algorithms  like  for example  the well known lrta   korf 
       for this reason  time bounded a  is sometimes excluded from experimental comparisons
with real time search algorithms  see e g  burns  ruml    do        p       
in this paper we extend the time bounded search approach in two directions  as already noted
by their authors  bjornsson et al          the time bounded approach is not limited just to a   a first
contribution of this paper is a study of what are the implications of using other search algorithms
instead of a   specifically  we generalize time bounded a  to time bounded best first search 
in general  if a is an instance of best first search  we call tb a  the algorithm that results from
applying the time bounded approach to a  a second contribution of this paper is an extension to the
time bounded search approach that allows the algorithm to deal more adequately with non reversible
problems  the algorithm we propose here  restarting time bounded weighted a which we call
tbr  wa    can be seen as lying in the middle ground between time bounded algorithms and
learning based real time search algorithms like korfs learning real time a   lrta           in
fact  tbr  wa   restarts search from the current state when a backtracking move is not available
and updates the heuristic function 
we carry out a theoretical analysis of both time bounded weighted a   tb wa     an instance
of tb bfs   and of tbr  wa    for tb wa   we establish upper and lower bounds for the
solution cost  our cost bound establishes that  in some domains  the solution cost may be reduced
significantly by increasing w without increasing search time  hence  in contrast to what is wellknown about weighted a  when solving offline search problems  we might obtain better solutions
by increasing the weight  this result is important since it suggests that tb wa    with w     
should be preferred to tb a   in domains in which wa  runs faster than a   while wa  does not
always run faster than a   see e g   wilt   ruml         it is known that it does in many situations 
experimentally  we evaluate tb wa   on pathfinding benchmarks and in the    puzzle  and
tbr  wa   on the racetrack problem  in all three benchmarks we observe performance improvement as w is increased  in addition  we observe tb wa   is significantly superior to both tb a  
   

fit ime  b ounded b est f irst s earch for r eversible and n on   reversible s earch g raphs

and lss lrtwa   rivera  baier    hernandez         a real time search algorithm that can use
weighted heuristics 
this paper extends work that appears in conference proceedings  hernandez  asn    baier 
       by including an empirical analysis on new benchmarks  counter strike maps  the racetrack 
and the    puzzle   by extending pathfinding experiments with    neighbor connectivity  by providing a lower bound for the cost of the solution returned by tb wa    theorem    below   and by
introducing  analyzing  and evaluating tbr  wa   
the rest of the paper is organized as follows  we start by describing the background needed
for the rest of the paper  then we describe tb bfs  and tbr  bfs   including a formal analysis
of their properties  then we describe the experimental results  and finish with a summary and
perspectives for future research 

   background
below we describe the background for the rest of the paper 
    search in reversible and non reversible environments
a search graph is a tuple g    s  a   where s is a finite set of states  a  s  s is a set of edges
which represent the actions available to the agent in each state  a path over graph  s  a  from s to
t is a sequence of states    s  s     sn   where  si   si      a  for all i              n      s    s 
and sn   t  we say that t is a successor of s if  s  t  is an edge in a  moreover  for every s  s we
define succ s     t    s  t   a  
a cost function c for a search graph  s  a  is such that c   a  p
r    i e   it associates an action
with a positive cost  the cost of a path    s  s     sn is c     n 
i   c si   si      i e  the sum
of the costs of each edge considered in the path  a cost optimal path from s to t is one that has
lowest cost among all paths between s and t  we denote this cost by c  s  t   in addition  we denote
by ct  s  t  the cost of a cost optimal path between s and t that visits states only in t   that is  a
cost optimal path    s  s        sn such that s   s    sn   t  and si  t   for all i              n     
a search problem is a tuple  s  a  c  sstart   sgoal   where g    s  a  is a search graph  sstart
and sgoal are states in s  and c is a cost function for g  a search graph g    s  a  is reversible if
a is symmetric  that is  whenever  s  t   a then  t  s   a  a search problem is reversible if and
only if its search graph is reversible  consequently  problem is non reversible if its search graph
contains an action  s  t  but does not contain an action  t  s  
a solution to a search problem is a path from sstart to sgoal  
    best first search
best first search  bfs   pearl        encompasses a family of search algorithms for static environments which associate an evaluation function f  s  with every state s  the priority is such that
f  s    f  t  when s is viewed as a more promising node than t  bfs starts off by initializing the
priority of all states in the search space to infinity  except for sstart   for which the priority is set to
f  sstart    a priority queue open is initialized as containing sstart   in each iteration  the algorithm
extracts from open the state with lowest priority  s  for each successor t of s it computes the evaluation fs  t   considering the path that has been found to t from s  if fs  t  is lower than f  t   then t
   

fih ern andez   baier     a s in

is added to open and f  t  is set to fs  t   the algorithm repeats this process until sgoal is in open
with the lowest priority 
a pseudo code is presented in algorithm    the f  value of state s is usually implemented as
an attribute of s  and the open list is implemented as a priority list  furthermore  we assume the
cost fs  t  computed in line    is a function of the path to t via s  thus fs  t  can only take a finite
number of values during an execution of bfs  because it depends on the  finite  number of simple
paths that connect the initial state with s 
algorithm    best first search

  
  

sroot  scurrent
open  
foreach s  s do
f  s   
f  sroot    evaluation for sroot
insert sroot in open
while open     do
let s be the state with minimum f  value in open
if s   sgoal then
return s
remove s from open
foreach t  succ s  do
fs  t   evaluation function for t considering that t is discovered from s
if fs  t    f  t  then
f  t   fs  t 
parent t   s
insert t in open

  

return no solution

 
 
 
 
 
 
 
 
 
  
  
  
  
  
  

an instance of best first search is weighted a   wa    pohl         wa  computes the evaluation function in terms of two other functions  g and h  the g value corresponds to the cost of the
lowest cost path found so far towards s  and it is implemented as an attribute of s  wa s evaluation function is defined as f  s    g s    wh s   where g s  is the cost of the lowest cost path
found from sstart to s  in addition  h is a non negative  user given heuristic function such that h s 
estimates the cost of a path from s to sgoal   finally  w is a real number greater than or equal to   
the pseudo code for wa  can be obtained from algorithm   by storing the g value as an attribute of the state  while the h value is computed by an external function  the resulting pseudo code
appears in algorithm   
a heuristic function h is admissible if and only if h s   c  s  sgoal    for all s  s  function
h is consistent if h sgoal        and h s   c s  t    h t  for every edge  s  t  of the search graph 
consistency implies that if  is a path from s to t then h s   c     h t   which  in turn  implies
admissibility 
bfss closed listdenoted henceforth by closed is defined as the set of states that are not in
open and that are such that g s  is not infinity   in other words  it contains the states for which a
path is known but that are not being considered for re expansion 
   bfs initially sets f  s  to infinity for every s that is not the start node  in wa  this translates to setting g s  to infinity
for all s except from sstart  

   

fit ime  b ounded b est f irst s earch for r eversible and n on   reversible s earch g raphs

algorithm    weighted a 

  
  

sroot  scurrent
open  
foreach s  s do
g s   
f  s   
g sroot     
f  sroot    wh sroot  
insert sroot in open
while open     do
let s be the state with minimum f  value in open
if s   sgoal then
return s
remove s from open
foreach t  succ s  do
gs t   min g t   g s    c s  t  
if gs t   g t  then
g t   gs t
f  t   g t    wh t 
parent t   s
insert t in open

  

return no solution

 
 
 
 
 
 
 
 
 
  
  
  
  
  
  
  
  
  

if h is admissible  wa  is known to find a solution whose cost cannot exceed wc  sstart   sgoal   
as such  wa  may return increasingly worse solutions as w is increased  the advantage of increasing w is that search time is usually decreased because fewer states are expanded  when w     
wa  is equivalent to a   hart  nilsson    raphael         another interesting result generalizes a
well known property of consistent heuristics of the a  algorithm  it is formally stated as follows 
lemma    ebendt   drechsler        at every moment during the execution of weighted a  from
state sroot   if h is consistent  upon expansion of a state s  line    of algorithm     it holds that
g s   wc  sroot   s  
another instance of best first search is greedy best first search  gbfs   here f is equal to
the user given heuristic function h  when wa  is used with a sufficiently large value of w  both
wa  and gbfs rank nodes in a similar way  indeed  let fgbfs and fwa  denote  respectively  the f
function for gbfs and wa   if w is such that it exceeds the g value of every node ever generated
and two nodes s  and s  have been generated with the same g value by both algorithms such that
fgbfs  s      h s      h s      fgbfs  s     then it will hold that fwa   s      fwa   s     however 
even if w is sufficiently large  the reverse is not always true since fwa   s      fwa   s    can hold
true when h s      h s     because the g value in fwa  acts in practice as a tie breaker 
    real time heuristic search
in real time search the objective is to solve a search problem subject to an additional real time
constraint  under this constraint  a constant amount of time  independent of problem size  is given
to the search algorithm  by the end of which it is expected to perform one or more actions in a
sequence  such a constant is very small in relation to the time that would be required by an offline
   

fih ern andez   baier     a s in

search algorithm to solve search problem  if after performing actions the agent has not reached
the goal  the process repeats  each iteration of the algorithm can be understood as two consecutive
episodes      a search episode  in which a path is computed  and     an execution episode  in which
the actions in such a path are performed 
rather than receiving a time limit in seconds  most real time search algorithms receive a parameter  say k  and guarantee that the computational time taken by the search episode is bounded by a
non decreasing function of k  an example of a real time search algorithm is local search space 
learning real time a   lss lrta   algorithm     koenig   sun         it receives a search
problem p and a parameter k  in its search episode  it runs a bounded execution of a  rooted at
the current state which expands at most k states  following  it updates the heuristic values of those
states in the closed list of the a  run  this update  usually referred to as learning step  makes h
more informed  and guarantees that the following holds for every s in a s closed list 
h s    min  cclosed  s  t    h t   
topen

   

the execution episode performs the actions that appear in the path found by a  from the current
state towards the state which has lowest f  value in the open list  in reversible search spaces if h
algorithm    lss lrta 
 
 
 
 
 
 
 
 

input  a search problem p and a natural number k
s  sstart
while s is not a goal state do
run a  from s until k states are expanded or a goal node the best state in open
best  state in a s closed list with lowest f  value
for each s  closed do
update the h value of s such that equation   holds
move along the path found by a  between s and best
s  best 

is initially consistent it can be shown that lss lrta  terminates when the search problem has a
solution  koenig   sun         if the search space is non reversible  however  termination cannot
be guaranteed  as we see later  time bounded algorithms  without restarts  can prove a solution
does not exist as well  this property does not hold for algorithms whose search expands nodes
whose distance from the current state is bounded  like lss lrta  
    comparing two real time search algorithms
one way frequently used in the literature to compare two real time search algorithms a and b is by
comparing the cost of the returned paths when the algorithms are configured is such a way that their
search episodes have approximately the same duration  assume that a real time search algorithm
requires n search episodes to solve a search problem and that its runtime is t   then we say that the
average time per search episode for that run is t  n 
to evaluate the relative performance of two algorithms a and b we use a set of benchmark
problems p and a set of algorithm parameters  for each parameter of algorithm a  we obtain and
record the average solution cost for all problems in p and the average time per episode  we do
likewise with b and then plot the average solution cost versus the average time per episode for each
algorithm  if the curve for algorithm a is always on top of the curve for algorithm b we can clearly
   

fit ime  b ounded b est f irst s earch for r eversible and n on   reversible s earch g raphs

state that b is superior to a  because b returns better quality solutions for a comparable search time
per episode 
another approach that has been used to compare real time search algorithms is the game time
model  hernandez et al          in this model  time is partitioned into uniform time intervals  an
agent can execute one movement during each time interval  and search and movements are done
in parallel  the objective is to move the agent from its start location to its goal location in as few
time intervals as possible  the game time model is motivated by video games  video games often
partition time into game cycles  each of which is only a couple of milliseconds long  bulitko et al  
       when using the game time model  the implementation of the real time search algorithm is
modified to stop search as soon as t units of timewhere t is a parameterhave passed 

   time bounded best first search
time bounded a   tb a    bjornsson et al         is a real time search algorithm based on a  
intuitively  tb a   can be understood as an algorithm that runs an a  search from sstart to sgoal
that alternates a search phase with an execution phase until the goal is reached  in each search phase
a bounded number of states are expanded using a   in the execution phase there are two cases 
if the agent is on the path from sstart to the best state in open  then a forward movement on that
path is performed  otherwise  the algorithm performs backtracking moves in which the agent is
moved to the state from where it came from  the search phase does not execute if a path connecting
sstart and sgoal has already been found  the algorithm terminates when the agent has reached the
goal 
our generalization of tb a   is time bounded best first search  which simply replaces a 
in tb a   by a best first search  its pseudo code is shown in algorithm    the parameters
are a search problem  s  a  c  sstart   sgoal    and an integer k which we refer to as the lookahead
parameter 
tb bfs  uses a variable scurrent to store the current state of the agent  its movetogoal procedure  called from main  implements the loop that alternates search and execution  at initialization
 lines       scurrent is initialized to sstart   and  among other things  bfss open list is set to
contain sstart only  if the goal state has not been reached  represented by the fact that variable
goalf ound is false   a bounded version of bfs is called  line     that expands k states  and then
computes a path from sstart to the state in open that minimizes the evaluation function f   the
path is built quickly by following parent pointers  and it is stored in variable path  in the execution phase  lines        if the current position of the agent  scurrent   is on path  then the agent
performs the action determined by the state immediately following scurrent on path  otherwise  a
backtracking move is implemented by moving the agent to the parent of s in the search tree of bfs 
parent scurrent    the use of backtracking moves is a mechanism that guarantees that the agent will
eventually reach a state in variable path because  in the worst case  the agent will eventually reach
sstart   as soon as such a state is reached the agent will start moving towards the state believed to be
closest to the goal 
algorithm   is equivalent to tb a   when bfs is replaced by a   finally  we call timebounded greedy best first search  tb gbfs   the algorithm that results when we use greedy
best first search instead of bfs 
note that the length of the path cannot in general be bounded by a constant on the size of the
problem  to bound the computation of each search episode we can use the same technique described
   

fih ern andez   baier     a s in

algorithm    time bounded best first search
 
 
 
 
 
 
 
 
 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

procedure initializesearch  
sroot  scurrent
open  
foreach s  s do
f  s   
f  sroot    evaluation for sroot
insert sroot in open
goalfound  false
function bounded best first search  
expansions   
while open     and expansions   k and f  sgoal     mintopen f  t  do
let s be the state with minimum f  value in open
remove s from open
foreach t  succ s  do
compute fs  t  considering that t is discovered from s 
if fs  t    f  t  then
f  t   fs  t 
parent t   s
insert t in open
expansions  expansions    
if open    then return false
let sbest be the state with minimum priority in open 
if sbest   sgoal then goalfound  true
path  path from sroot to sbest
return true
function movetogoal  
scurrent  sstart
initializesearch  
while scurrent    sgoal do
if goalfound   false then
if bounded best first search     false then return false
if scurrent is on path then
scurrent  state after scurrent on path
else
scurrent  parent scurrent   
execute movement to scurrent
return true
procedure main
if movetogoal     true then
print the agent is now at the goal state 
else
print no solution 

   

fit ime  b ounded b est f irst s earch for r eversible and n on   reversible s earch g raphs

by bjornsson et al          whereby an additional counter  analogous to k is used to measure the
effort for path extraction   this is omitted from the pseudocode for clarity 
    properties
now we analyze a few interesting properties of the algorithms we have just proposed  first  just
like tb a    tb bfs  always terminates and finds a solution if one exists  this is an important
property since many real time heuristic search algorithms  e g   lss lrta   enter an infinite loop
on unsolvable problems  second  we prove an upper and a lower bound on the cost of solutions
returned by tb wa    this bound is interesting since it suggests that by increasing w one might
obtain better solutions rather than worse 
theorem   tb bfs  will move an agent to the goal state given a reversible search problem p if a
solution to p exists  otherwise  it will eventually print no solution 
proof  follows from the fact that best first search eventually finds a path towards the goal  this is
because of the fact that the search space is finite and that each state can only be inserted into open a
finite number of times  in addition  all moves carried out by the algorithm  including moving from
s to parent s   are executable in a reversible search space 

it is important to note that the reason why tb bfs  will eventually print no solution in an
unsolvable problem is dependent on the fact that an open list is used  lss lrta  cannot always
detect unsolvable problems because search can only expand a locality around the current state  this
is a characteristic of agent centered search algorithms  koenig         a class of algorithms that
tb bfs  is not a member of 
the following two lemmas are intermediate results that allow us to prove an upper bound on the
cost of solutions obtained with tb wa    the results below apply to tb a   but to our knowledge
lemma   and theorem   had not been proven before for tb a   
in the results below  we assume that p    s  a  c  sstart   sgoal   is a reversible search problem 
that tb wa   is run with a parameter w    and that h is an admissible heuristic  furthermore  we
assume that c    max u v a c u  v   that c   min u v a c u  v   and that n  w  is the number
of expansions needed by wa  to solve p   finally  we assume k  n  w  which is a reasonable
assumption given that we are in a real time setting 
lemma   the cost of the moves incurred by an agent controlled by tb wa   before goalfound
becomes true is bounded from below by b n  w  
cc and bounded from above by b n  w  
cc   
k
k
proof  n  w     states are expanded before goalfound becomes true  if k states are expanded
per call to the search procedure  then clearly b n  w  
c is the number of calls for which best firstk
search terminates without setting goalfound to true  each move costs at least c and at most c   
from where the result follows 

now we focus on the cost that is incurred after a complete path is found  the following lemma
is related to a property enjoyed by tb a   and stated in theorem   by hernandez et al         
lemma   the cost of the moves incurred by an agent controlled by tb wa   after goalfound has
become true cannot exceed  wc  sstart   sgoal   
   

fih ern andez   baier     a s in

proof  assume goalfound has just become true  let  be the path that starts in sstart   ends in
scurrent and that is defined by following the parent pointers back to sstart   path  is the prefix of a
path to the lowest f  value state in a previous run of wa  and therefore  by lemma    is such that
c     wc  sstart   sgoal    now the worst case in terms of number of movements necessary to reach
the goal is that path and  coincide only in sstart   in this case  the agent has to backtrack all the
way back to sstart   once sstart is reached  the agent has to move to the goal through a path of cost at
most wc  sstart   sgoal    thus the agent may not incur a cost higher than  wc  sstart   sgoal   to reach
the goal 

now we obtain a lower bound and an upper bound on the solution cost for tb wa   which
follows straightforwardly from the two previous lemmas 
theorem   let c be the solution cost obtained by tb wa    then 
b

n  w     
n  w      
cc  c  b
cc    wc  sstart   sgoal   
k
k

proof  we put together the inequalities implied by lemmas   and   



a first observation about this result is that it has been shown empirically that in some domains 
when w is increased  n  w  may decrease substantially  gaschnig         for example  reports that
in the   puzzle n     is exponential in the depth d of the solution whereas n  w   for a large w is
subexponential in d  in other domains like grid pathfinding  it is well known that using high values
for w results in substantial reductions in expanded nodes  see e g   likhachev  gordon    thrun 
       thus  when increasing w  both the lower bound and the first term of the upper bound may
decrease substantially  the second term of the upper bound   wc  sstart   sgoal    when increasing
w  may increase only linearly with w  this suggests that there are situations in which better  rather
than worse quality solutions may be found when w is increased  as we see later  this is confirmed
by our experimental evaluation 
a second observation about the bounds is that the factor b n  w      kc decreases as k increases  this suggests that when k is large  i e   close to n  w    increasing w may actually lead to
decreased performance 
putting both observations together  theorem   suggests that tb wa   will produce better solutions than tba  when k is relatively small in problems in which wa  expands fewer nodes than
a  in offline mode  problems in which wa  does not expand fewer nodes than a  exist  wilt  
ruml        
finally  it is not hard to see that theorem   can be generalized to other algorithms that provide
optimality guarantees  given two search algorithms a and b that provide such bounds and whose
relative performance is known  the theorem can be used as a predictor of the relative performance
of tb a  versus tb b  
    non reversible search problems via restarting
in non reversible problems  well known real time heuristic search algorithms such as lss lrta 
will fail when  in the execution episode  a state from which there is no path to the goal is visited 
time bounded algorithms like tb bfs  will fail under that very same condition but they will also
fail as soon as a physical backtrack is required over a non reversible action  this second condition
   

fit ime  b ounded b est f irst s earch for r eversible and n on   reversible s earch g raphs

for failure is the reason why sometimes time bounded algorithms are discarded for use in nonreversible domains  the objective of this section is to propose a time bounded algorithm that  when
used in non reversible problems  will not fail due to the latter condition  but only due to the former 
our modification of tb wa   for non reversible problems comes from incorporating into it the
two key characteristics of real time search algorithms like lss lrta   search restarts and heuristic
updates  indeed  whenever physical backtracking is not available  or  more generally  when some
predefined restart condition holds  our algorithm restarts search  in addition  to avoid getting
trapped in infinite loops  our algorithm updates the heuristic using the same update rule of lsslrta   we call the resulting algorithm restarting time bounded weighted a   tbr  wa    
algorithm   shows the details of tbr  wa    lines      are the most relevant difference
with the previous algorithm  the algorithm restarts search when the agent is not in path and certain
restart condition  which must become true when there is no action leading from the current state
 scurrent   to its parent  parent scurrent    
algorithm    restarting time bounded weighted a 
 
 
 
 
 
 
 
 
 
  
  
  
  
  
  
  
  
  
  
  
  

function movetogoal  
scurrent  sstart
initializesearch  
while scurrent    sgoal do
if goalfound   false then
if bounded wa      false then return false 
if scurrent is on path then
scurrent  state after scurrent on path
execute movement to scurrent
else if restart condition holds then
update heuristic function h using lss lrta  update rule  equation   
initializesearch  
else
scurrent  parent scurrent   
execute movement to scurrent
return true
procedure main
if movetogoal     true then
print the agent is now at the goal state 
else
print no solution 

note that prior to restarting the algorithm updates the heuristic just as lss lrta  would  this
can be implemented with a version of dijkstras algorithm  note that the number of states that may
need to be updated may not be bounded by a constant  if needed  we can compute the update in
an incremental manner  across several episodes  we refer the reader to the analysis of koenig and
sun         and hernandez and baier        for details about the implementation and proofs of
correctness 
      t ermination of tbr  wa  
tbr  wa   can be used in both reversible and non reversible domains  if the heuristic function h
is initially consistent and the search graph is strongly connected  the algorithm terminates 
   

fih ern andez   baier     a s in

theorem   let p be a search problem with a strongly connected search graph  then tbr  wa   
run with a consistent heuristic h  finds a solution for p  
the proof for theorem   depends on some intermediate results  some of which have proofs that
appear elsewhere  the following result establishes that if h is consistent  then it remains consistent
after being updated 
lemma    koenig   sun        if h is consistent it remains consistent after h is updated with
equation   
another intermediate results says that h cannot decrease after an update following equation   
lemma    koenig   sun        if h is initially consistent then h s   for every s  cannot decrease
if h is updated following equation   
another intermediate result says that h s  finitely converges  which intuitively means that even
if we wanted to apply an infinite number of updates to h  then from some point on  h will not change
anymore 
definition    finite convergence  a series of functions  fi  i  finitely converges to function f if
there exists an n such that for every m  n  it holds that fm   f   in addition  we say that a series
of functions  fi  i  finitely converges if there exists a function f to which it finitely converges 
lemma   let h  be a consistent heuristic function and p be a strongly connected graph  let
    hi  i  be such that hk   is the function that results from     assigning hk to hk   then    
updating hk   using equation    for some set closed and open generated by a bounded weighted
a  run rooted at an arbitrary state  then  finitely converges 
proof  a first observation is that hk  s  is bounded from above by a positive number for every s
and every k  indeed  because of lemma    hk is consistent  and thus admissible  for every k  in
addition  because the problem has a solution  hk  s   c  s  sgoal    for every s and every k 
a second observation is that the set of h values that any state s can take is finite  even if  is
infinite  formally we prove h s     hk  s    k     is a finite set  indeed  it is not hard to verify
by induction  we leave it as an exercise to the reader  that by using equation    for every k     it
holds that hk  s    c ks     h   s    for some  possibly empty path ks originating in s and finishing
in s    now recall that hk  s  is bounded from above and observe there are only finitely many paths
in the graph whose cost is bounded  we conclude that h s  is a finite set  for every s 
now the proof follows by contradiction  assuming  does not finitely converge  because  is
non decreasing  lemma     the only possibility is that  increases infinitely often  this implies
that there is at least one state s such that h s  is infinite  a contradiction  we conclude  finitely
converges 

note that the previous lemma is not saying anything about the function that  converges to  we
do not need to know which function is it for the rest of the proof  the last intermediate result is
related to the result by ebendt and drechsler        that was stated in section      lemma    
lemma   at every moment during the execution of weighted a  from state sroot   if h is consistent 
for every state s in the open list  it holds that g s   wcclosed  sroot   s  
   

fit ime  b ounded b est f irst s earch for r eversible and n on   reversible s earch g raphs

proof  let  be a cost optimal path from sroot to s that visits only states in closed  let s  be the
state that precedes s in   because s  is part of an optimal path we have 
cclosed  sroot   s      c s    s    cclosed  sroot   s  

   

because s is a successor of s    it holds that 
g s   g s      c s    s  

   

g s     wc  sroot   s    

   

g s   wc  sroot   s      c s    s  

   

g s   wcclosed  sroot   s      wc s    s    w cclosed  sroot   s      c s    s   

   

because of lemma    we have that 

inequalities   and   imply 
because w     and cclosed  c  

substituting with equation   we have that 
g s   wcclosed  sroot   s  

   


which finishes the proof 
now we provide a proof of the main result of this section 

proof  of theorem      let us assume the algorithm does not terminate and thus enters an infinite
loop  note this means the algorithm restarts an infinite number of times  otherwise  weighted a 
would eventually find the goal state  allowing the agent to reach the goal   assume a moment
during this infinite execution after h has converged  we know this by lemma     and let s  s        be
an infinite sequence of states such that si is a state where search was restarted  we now prove that
for every i  h si     h si     
let o denote the contents of the open list exactly when the algorithm expanded si     and closed
denote the contents of the closed list immediately before the heuristic is updated  from equation   
the following holds 
h si     cclosed  si   so     h so   

for some so  o

   

we can rewrite equation   as 
wh si     wcclosed  si   so     wh so   

   

let g so   denote the g value of so exactly when si   is preferred for expansion over so   now 
we prove that wcclosed  si   so    g so    indeed  if so  closed this follows from lemma   and
from the fact that cclosed  c and w     on the other hand  if so  open  then we obtain
wcclosed  si   so    g so   from lemma    now we use this fact to write 
wh si    g so     wh so   
   

    

fih ern andez   baier     a s in

because the algorithm preferred to expand si   instead of so   then g so     wh so    g si      
wh si      and hence 
wh si    g si       wh si     
    
finally  because w     and g si         we obtain h si     h si     
this implies that the sequence of states s  s        has strictly decreasing h values  but because
the state space is finite  it must be the case that si   sj   for some i and j with i    j  which would
lead to conclude that h si     h si    a contradiction 


   experimental results
this section presents our experimental results  the objective of our experimental evaluation was to
understand the effect of the weight configuration on the performance of both tb wa   and tbr
 wa    to that end  we evaluate tb wa   in reversible search problems  grid pathfinding and the
   puzzle   and tbr  wa   in a non reversible problem  the racetrack   for reference  we compare
against lss lrtwa   rivera et al          a version of lss lrta  that uses weighted a  rather
than a  in the search phase  we used this algorithm since it is among the few real time search
algorithms that are able to exploit weights during search  lss lrtwa  is configured to perform a
single action in each execution phase 
we decided not to include results for wlss lrta   rivera et al          another real time
search algorithm that exploits weights  for two reasons  first  our new results are focused on relatively large lookahead values  over       with these lookahead values  rivera et al          in
grid like terrain  observe improvements but not very significant  second  we observed that  on the
   puzzle  wlss lrta  yields worse performance as w is increased 
in section     we report results in    and    neighbor grids in a similar manner as was reported
in an earlier publication  hernandez et al          section     reports results for    and    neighbor
grids using the game time model  cf  section       section     reports results on non reversible
maps in a deterministic version of a setting used to evaluate algorithms for the stochastic shortestpath problem  bonet   geffner         finally  subsection     reports results on the    puzzle 
the path finding tasks of section     and section     are evaluated using   neighbor  bulitko
et al         koenig   likhachev        and   neighbor
 grids  aine   likhachev         see
figure     the costs of the movements are       and   for  respectively  orthogonal  diagonal 
chess knight movements  in our implementation the agent cannot jump over obstacles  in addition  a diagonal movement  d  d   for d          is illegal in  x  y  if either  x d  y  or  x  y  d 
is an obstacle  for   neighbor and    neighbor grids we use the octile distance and the euclidean
distance as heuristic values  respectively  all experiments were run on an intel r  core tm  i           ghz machine  with  gbytes of ram running linux  all algorithms have a common
code base and use a standard binary heap for open  ties in open are broken in favor of larger
g values  we do not have a rule for breaking further ties 
    results in   neighbor and    neighbor grid maps
we evaluated the algorithms considering solution cost and runtime  as measures of solution quality
and efficiency  respectively  for several lookahead and weight values 
we used all          maps from the video game baldurs gate  bg   all the room maps
 rooms   and all maps of different size from the starcraft  sc  available from n  sturtevants
   

fit ime  b ounded b est f irst s earch for r eversible and n on   reversible s earch g raphs

  neighbor bg maps

    
    
    

algorithm

cost  log scale 

cost  log scale 

 
   
  

 
tb

 w
a 

   
  

 
 w
a 

  neighbor counter strike maps

lookahead  
lookahead   
lookahead    
lookahead    
lookahead    
lookahead     

     
     

tb

algorithm

  neighbor starcraft maps

      

   
  

 
tb

 w
a 

   
  

 
 w
a 
tb

tb

 w
a 

   
  

 
   
  

 
tb

 w
a 

   
  

 
   
  

 w
a 
tb

   
  

 w
a 
tb

tb

 w
a 

   
  

 w
a 

   
  
tb

 w
a 
tb

 

   
 

   

   
 

   

 

    

 w
a 

    

     

   
  

    

lookahead  
lookahead  
lookahead   
lookahead   
lookahead    
lookahead    

tb

    
    

cost  log scale 

lookahead  
lookahead  
lookahead   
lookahead   
lookahead    
lookahead    

     
cost  log scale 

  neighbor room maps
     

    
    
   

lookahead  
lookahead   
lookahead    
lookahead    
lookahead    
lookahead     

 e   

      
     
     

algorithm

  
a 
 

  
 

  
tb

 w

a 
 

  
 

  
tb

 w

a 
 

  
 

  
 w
tb

 w

a 
 

  
 

  
tb

 w

a 
 

  
 

  
tb

tb

 w

a 
 

  
 

  
a 
 

  
 

  
tb

 w

a 
 

  
 

  
tb

 w

a 
 

  
 

  
tb

 w

a 
 

  
 

  
  
 
tb

 w

a 
 
 w

tb

tb

 w

a 
 

  
 

  

    

algorithm

figure    in the   neighbor results  solution cost tends to decrease as w or the lookahead parameter
is increased 

path finding repository  sturtevant         in addition  we used   large maps from counter strike
 cs   whose sizes range between between            and            
we evaluated six lookahead values                          for the          maps and six
lookahead values                              for sc and cs maps  we used six weight values
                                for each map we generated    random solvable search problems  resulting in      problems for bg       problems for rooms       problems for sc  and    
problems for cs 
figures   and   show performance measures for the   neighbor grid maps  note here that the
average search time per episode is the same across all algorithms when using the same lookahead
parameter  this is because search time per episode is proportional to the lookahead parameter and
depends on no other variable  in particular  it does not depend on the weight   thus fair conclusions
can be drawn when comparing two configurations if their lookahead parameter is set to the same
value 
   

fih ern andez   baier     a s in

  neighbor bg maps

 
   
  

 
tb

 w
a 

   
  

 
 w
a 

  neighbor counter strike maps

lookahead  
lookahead   
lookahead    
lookahead    
lookahead    
lookahead     

runtime  ms 

runtime  ms 

   
  

 
   
  

algorithm

  neighbor starcraft maps

  

 w
a 

tb

tb

 w
a 

   
  
 w
a 

a 
  

algorithm

tb

 

  
  

  
tb
 

w

a 
  

  

  
tb
 

w

a 
  

  

  
w
tb
 

tb
 

w

a 
  

  

  
  
a 
  
w

tb
 

tb
 

w

a 
  

  

  

 

 

 

  
 
 
 
 
 
 w
a 

 

   
  

 

  

tb

runtime  ms 

 

lookahead  
lookahead  
lookahead   
lookahead   
lookahead    
lookahead    

  

tb

lookahead  
lookahead  
lookahead   
lookahead   
lookahead    
lookahead    

 
runtime  ms 

  neighbor room maps

 
 
 

lookahead  
lookahead   
lookahead    
lookahead    
lookahead    
lookahead     

     
     

    
   

algorithm

 

 

    
a  
tb
 w

tb
 w

a  

    

 
    
a  
tb
 w

 
    
a  
tb
 w

 
    

    

a  
tb
 w

 w

tb
 w

a  

  
a 
 

  
 

  
tb

tb

 w

a 
 

  
 

  

 w

a 
 

  
 

  
tb

tb

 w

a 
 

  
 

  
  
 
a 
 

 w
tb

tb

 w

a 
 

  
 

  

 

  

algorithm

figure    in the   neighbor results  search time typically decreases as w or the lookahead parameter
is increased 

we observe the following relations hold for all maps regarding solution cost and search time 

solution cost for most lookahead values  solution cost decreases as w is increased  more significant improvements are observed for lower lookahead values  this is not surprising in the light
of our cost bound  theorem      for large lookahead parameters         the value of w does
not affect solution cost significantly  when the lookahead parameter increases  fewer search
episodes are needed and less physical backtracks  back moves  are needed  hernandez et al  
       back moves strongly influence the performance of the algorithms  in tb wa    when
w is increased the number of back moves decreases  which explains the improvement in solution quality  for example  in the bg maps  when using lookahead    the average reduction of
back moves is          when comparing w     and w      whereas when lookahead is    
this reduction is only      when comparing w     and w     
   

fit ime  b ounded b est f irst s earch for r eversible and n on   reversible s earch g raphs

   neighbor bg maps
lookahead  
lookahead  
lookahead   
lookahead   
lookahead    
lookahead    

    
    
    
    

     
    
    
    
    

   

algorithm

cost  log scale 

cost  log scale 

 
   
  

 
tb

 w
a 

   
  

 
 w
a 

   neighbor counter strike maps

lookahead  
lookahead   
lookahead    
lookahead    
lookahead    
lookahead     

     
     

tb

algorithm

   neighbor starcraft maps

      

   
  

 
tb

 w
a 

   
  

 w
a 

   
  
tb

 
 w
a 
tb

tb

 w
a 

   
  

 
   
  

 
tb

 w
a 

   
  

 
tb

 w
a 

   
  

 
   
  

 w
a 
tb

 
 w
a 
tb

 

   
  

 w
a 

   
  
tb

 w
a 

 

   
   

   

tb

lookahead  
lookahead  
lookahead   
lookahead   
lookahead    
lookahead    

     
cost  log scale 

     
cost  log scale 

   neighbor room maps

    
    
   

lookahead  
lookahead   
lookahead    
lookahead    
lookahead    
lookahead     

 e   

      
     
     

algorithm

  
a 
 

  
 

  
tb

 w

a 
 

  
 

  
tb

 w

a 
 

  
 

  
 w
tb

 w

a 
 

  
 

  
tb

 w

a 
 

  
 

  
tb

tb

 w

a 
 

  
 

  
a 
 

  
 

  
tb

 w

a 
 

  
 

  
tb

 w

a 
 

  
 

  
tb

 w

a 
 

  
 

  
  
 
tb

 w

a 
 
 w

tb

tb

 w

a 
 

  
 

  

    

algorithm

figure    in the    neighbor results  solution cost tends to decrease as w or the lookahead parameter
is increased 

search time as w is increased  search time decreases significantly for lower lookahead values
and decreases moderately for higher lookahead values  in rooms we observe the largest
improvements when w is increased  this behavior in rooms is explained because wa 
performs very well in this type of map for w     
figures   and   show performance measures for the    neighbor grid maps  we observe the
same relations observed in   neighbor grid maps regarding solution cost and search time 
        n eighbor versus    n eighbor g rid m aps
lower cost solutions are obtained with   neighbor grids than with    neighbor grids for the lookahead values       and    in bg  note that there exist some    neighbor movements which are more
expensive than any   neighbor moves  so for small lookaheads     neighbor solutions may have
a similar number of moves  but a worse quality than   neighbor solutions  on the other hand  a
   

fih ern andez   baier     a s in

   neighbor bg maps

 
   
  

 
tb

 w
a 

   
  

 

   neighbor counter strike maps

lookahead  
lookahead   
lookahead    
lookahead    
lookahead    
lookahead     

runtime  ms 

runtime  ms 

 w
a 

algorithm

   neighbor starcraft maps

  

   
  

 

algorithm

 w
a 

tb

tb

 w
a 

   
  
 w
a 

a 
  

   
  

 

  
  

  
tb
 w

a 
  

  

  
tb
 w

a 
  

  

  
tb
 w

a 
  

  

  
  
tb
 w

a 
  
tb
 w

tb
 w

a 
  

  

  

 

  
 
 
 
 
 

tb

 

 

 

 w
a 

 

  

   
  

 

  

tb

runtime  ms 

 

lookahead  
lookahead  
lookahead   
lookahead   
lookahead    
lookahead    

  

tb

lookahead  
lookahead  
lookahead   
lookahead   
lookahead    
lookahead    

 
runtime  ms 

   neighbor room maps

 
 
 

lookahead  
lookahead   
lookahead    
lookahead    
lookahead    
lookahead     

     
     

    
   

algorithm

 

 

    
a  
tb
 w

tb
 w

a  

    

 
    
a  
tb
 w

 
    
a  
tb
 w

 
    

    

a  
tb
 w

 w

tb
 w

a  

  
a 
 

  
 

  
tb

tb

 w

a 
 

  
 

  

 w

a 
 

  
 

  
tb

tb

 w

a 
 

  
 

  
  
 
a 
 

 w
tb

tb

 w

a 
 

  
 

  

 

  

algorithm

figure    in the    neighbor results  search time typically decreases as w or the lookahead parameter is increased 

 a 

 b 

figure      neighborhoods  a  and    neighborhoods  b  

   

fit ime  b ounded b est f irst s earch for r eversible and n on   reversible s earch g raphs

  neighbor counter strike maps
     

tb wa       
tb wa       
tb wa       
tb wa       
tb wa       
tb wa       

    
    
    
    
    
    
    
    
    

tb wa       
tb wa       
tb wa       
tb wa       
tb wa       
tb wa       

    
number of time intervals

number of the time intervals

     

   neighbor counter strike maps

    
    
    
    
    
    
    

   

   

   

   

   

   

    

duration of time interval  ms 

   

   

   

   

   

   

duration of the time interval  ms 

figure    results in the game time model 
similar quality is observed for other lookahead values  tb wa    for almost all values of w and
lookahead configurations  on    neighbor grids performs fewer moves than on   neighbor grids 
for example  in sc when w       and the lookahead parameter is         neighbor grids need
a factor of     more moves than    neighbor grids  note however that some    neighbor moves
have a higher cost than   neighbor moves  regarding runtime  tb wa   in   neighbor connectivity runs faster than tb wa   in    neighbor connectivity  this happens because the expansion of a
state with    neighbor connectivity takes more time than expanding the same state with   neighbor
connectivity 
    results on the game time model
we report results for tb wa   using the game time model in the counter strike maps for  and    neighbor grids  we use                              milliseconds as the duration of the time
intervals  in this setting  the quality of the solution is measured as the number of time intervals
required to solve the problem  so the fewer the intervals that are used  the better the solution quality
is 
figure   shows average performance  we observe that when the length of the time interval increases  tb wa   yields solutions of better quality  on the other hand  as w is increased  tb wa  
obtains better solutions  this can be observed more clearly when the duration of the intervals is
small  e g      ms   we also observe that better quality solutions with     rather that with   neighbor
connectivity  this is because with    neighbor connectivity the agent can perform a knight move in
a single interval 
    results on non reversible search graphs  the racetrack
in this section we compare tbr wa   and lss lrtwa  on a deterministic version of the racetrack problem  barto  bradtke    singh        bonet   geffner         in this problem the race   

fih ern andez   baier     a s in

extended hansen racetrack
   

tbr wa       
tbr wa       
tbr wa       
tbr wa       
lss lrt wa       
lss lrt wa       
lss lrt wa       
lss lrt wa       

   
   

tbr wa       
tbr wa       
tbr wa       
tbr wa       
lss lrt wa       
lss lrt wa       
lss lrt wa       
lss lrt wa       

   
   
number of actions

   
number of actions

game map racetrack
   

   
   

   
   
   
   
   

   

   

average time per search  ms 

 

 

 

  

 

  

  

 

 
  

 

 

  

 

  

  

 
  

 

 
  

 

 

  

 

  

 

 

  

  

 

 

  

  

 

  
  

  

 

  

average time per search  ms 

figure    results on the racetrack grids 
track is represented as a grid where some cells are marked as obstacles  similar to grid pathfinding 
the problem is to move an agent from a set of initial positions to any of the cells marked as a final
position  nevertheless  in this problem the agent has an associated velocity  and the set of actions
involve accelerating  vertically or horizontally   or performing a no op action which maintains the
current velocity 
a state in the racetrack is a tuple  x  y  vx   vy    where  x  y  is the position of the vehicle  and
 vx   vy   is the velocity vector  the actions are represented as tuples of the form  ax   ay    where
ax   ay             which correspond to an acceleration vector  unlike the original version  barto
et al          in ours actions are deterministic and we have only one initial and one destination cell 
because actions are deterministic  when  ax   ay   is performed in  x  y  vx   vy    the new state is given
by  x    y     vx    vy     where vx    vx  ax and vy    vy  ay   and where  x    y     is computed considering
the vehicle changes its velocity to  vx    vy    before moving  when the movement towards  x    y    
would lead to crashing into an obstacle  like bonet and geffner        do  we leave the vehicle next
to such an obstacle with velocity        
in our experiments  we used two racetracks  the firstwhich we refer to as hrtis a    
    grid which corresponds to an extended version of the racetrack used by hansen and zilberstein         which is a        grid   we also use the game map ar    sr from baldurs gate 
whose size is    x     below we refer to such a map by grt 
we generated    random test cases for hrt and grt that were such that the manhattan distance
between the initial state and goal state was greater than half of the width of the map  the absolute
value of each of the components of the velocity vector is restricted to be at most    as a heuristic
we use the euclidean distance divided by the maximum speed 
we evaluated tbr  wa   and lss lrtawa  with four weight values                       figure   shows a plot of the number of actions versus average time per search episode  for tbr  wa  
the number of actions corresponds to the sum of the number of moves plus the number of times the
   

fit ime  b ounded b est f irst s earch for r eversible and n on   reversible s earch g raphs

tbwa    
tbwa    
tbwa    
tbwa    
lss lrtwa    
lss lrtwa    
lss lrtwa    
lss lrtwa    

 
  
  
 
  
 
  
 
  
 
  
 
  
 
  
 
  
 
  
 
  
 

   

lookahead

      

tbwa    
tbwa    
tbwa    
tbwa    
lss lrtwa    
lss lrtwa    
lss lrtwa    
lss lrtwa    

     

 
  
  
 
  
 
  
 
  
 
  
 
  
 
  
 
  
 
  
 
  
 

    

   puzzle
number of expansions  log scale 

cost  log scale 

   puzzle

lookahead

figure    cost and time comparison between tb wa and lss lrtwa 

vehicle did not move  we do this because tbr  wa   does not make any movements when search
is restarted 
it is important to note that the time spent updating the heuristic is proportional to the number
of states being updated  as such an update by tbr  wa   may take more time than an update
by lss lrtwa  because the closed list may contain more states for the former algorithm  for
this reason we use in our comparison the average time per search  which considers both search and
update time 
in hrt  figure    we observe that the worst behavior is the one obtained with tbr  wa        
both algorithms improve performance when increasing w  but tbr  wa    used with a weight
greater than      is the algorithm that clearly yields the best performance  in grt  the worst algorithms are tbr  wa        and lss lrta       here  both algorithms improve when increasing
the weight 
because in this benchmark we used fewer problems than on the game maps  we carried out
a     confidence analysis on for the cost of the solutions  in the hrt  this showed that costs
for our best configuration tbr  wa        could be     away from the true mean  while for
lss lrta       costs could be     away from the true mean  in the grt  on the other hand 
the difference in performance of the two best configurations tbr     and lss lrtwa     is not
statistically significant 
finally  our experiments showed that the computational cost of learning phase of tb wa   is
not higher than that of lss lrta wa    indeed  the number of updates carried out by tb wa  
is     times less than the number of updates carried out by lss lrta wa   in hrt and     time
less in grt  this explains the better performance in terms of runtime 
   

fih ern andez   baier     a s in

    results on the    puzzle
we chose the    puzzle as a another domain for evaluating the time bounded algorithms  we
build our    puzzle implementation extending richard korfs implementation available from carlos linaress homepage   we present results for tb wa    and lss lrt wa   algorithms  we
use the     test cases presented by korf         which uses the manhattan distance as a heuristic 
in this domain we report the results in a slightly different way  first  we omit results for tb a  
 tb wa   with w      because it does not terminate in a reasonable time  this is due to the fact
that a  needs too many expansions for solving the hardest test cases  second  we use the number
of expansions instead of runtime as an efficiency measure  in this domain  we found this measure
to be more stable since  in general  solving all     problems does not take too much time when
w         s for w          s for w       and thus time is prone to be affected by external factors
controlled by the operating system 
figure   shows the performance of tb wa   and lss lrt wa    we use lookahead values
in                             and weights in               we observe the following relations 
solution cost the solution cost of tb wa   decreases as w is increased for almost all lookahead
values  tb wa   obtains better results than lss lrtwa  for all lookahead values when
w      with w     the performance of tb wa   is worse than the performence of lsslrta   on the other hand  tb wa   with w     obtains a solution     times better on
average than the solution obtained by lss lrta   lss lrtwa  with w      
number of expansions the number of expansions of tb wa   decreases as w is increased 
tb wa   is more efficient than lss lrtwa  for all lookahead values and w      the
worst performing configuration for tb wa   is w     
note that the curve remains flat for several of the configurations  this is because a small
number of expansions are needed to solve the problem 
in conclusion  considering solution cost and number of expansions  in    puzzle tb wa   is
the better algorithm  for instance  the average solution cost of tb wa   is     times better on
average than the average solution cost of lss lrta  
we did not compare to the greedy algorithm of  parberry         which is real time but domainspecific  unlike our 

   summary and conclusions
this paper introduced time bounded best first search  a generalization of the real time search
algorithm time bounded a   in addition  it introduced a restarting version of the time bounded
approach  tbr  wa    which unlike tb bfs   has a better coverage of non reversible domains 
we carried out a theoretical analysis of both tb wa   and tbr  wa    including termination
results and a cost bound for tb wa    given a weight w  our bound suggests that tb wa   will be
significantly superior to tb a   precisely on search problems in which wa  expands significantly
fewer states than a   in addition  our bound suggests that tb wa   may not yield benefits in
domains in which wa   run offline  will not yield any improvements over a   our theoretical
bounds can be easily adapted to other instances of best first search that offer guarantees on solution
   http   scalab uc m es clinares download source ida ida html

   

fit ime  b ounded b est f irst s earch for r eversible and n on   reversible s earch g raphs

quality  for tbr  wa    we proved termination in strongly connected graphs  even if they contain
non reversible actions  this property is also enjoyed by real time search algorithms of the lrta 
family but is not enjoyed by tb bfs  
in our experimental evaluation  that focused on pathfinding  the    puzzle  and the racetrack
problem  we found both tb wa   and tbr  wa   to be significantly superior to some real time
search algorithms of the lrta  family  in addition  we found that performance tends to improve as
the weight parameter is increased  without increasing the time per search episode  this finding is
interesting because although quality can also be improved by increasing the lookahead parameter 
this increases the time spent on each search episode 
it is well known that in many search benchmarks  wa  may expand significantly fewer nodes
than a   consistent with this  in our experiments  time bounded versions of suboptimal algorithms
like weighted a  produce significantly better solutions than those obtained by tb a    improvements are less noticeable when the lookahead parameter is large  as is also predicted by theory 
we are not the first to observe performance gains when using weights in a real time setting 
indeed  our findings are consistent with those of rivera et al          who also obtain better solutions
by using weighted heuristics  our work adds another piece of evidence that justifies studying the
incorporation of weights into other real time algorithms  e g   ribs and eda   sturtevant  bulitko 
  bjornsson        sharon  felner    sturtevant         finally  sla   shue   zamani       
and lrts  bulitko   lee        are two algorithms that also perform backtracking moves  an
investigation of whether or not restarts could provide benefits for those algorithms is left for future
work 

acknowledgements
we thank vadim bulitko for providing the counter strike maps  this research was partly funded by
fondecyt grant number         

references
aine  s     likhachev  m          truncated incremental search  faster replanning by exploiting
suboptimality  in proceedings of the   th aaai conference on artificial intelligence  aaai  
bellvue  washington  usa 
barto  a  g   bradtke  s  j     singh  s  p          learning to act using real time dynamic programming  artificial intelligence                 
bjornsson  y   bulitko  v     sturtevant  n  r          tba   time bounded a   in proceedings
of the   st international joint conference on artificial intelligence  ijcai   pp         
bonet  b     geffner  h          labeled rtdp  improving the convergence of real time dynamic
programming   in icaps  vol     pp       
bulitko  v     lee  g          learning in real time search  a unifying framework  journal of
artificial intelligence research             
bulitko  v   bjornsson  y   sturtevant  n     lawrence  r          real time heuristic search for
game pathfinding  applied research in artificial intelligence for computer games  springer 
burns  e   ruml  w     do  m  b          heuristic search when time matters  journal of artificial
intelligence research             
   

fih ern andez   baier     a s in

ebendt  r     drechsler  r          weighted a  search   unifying view and application  artificial
intelligence                    
gaschnig  j          exactly how good are heuristics   toward a realistic predictive theory of bestfirst search  in reddy  r   ed    proceedings of the  th international joint conference on
artificial intelligence  ijcai   pp          william kaufmann 
hansen  e  a     zilberstein  s          lao  a heuristic search algorithm that finds solutions with
loops  artificial intelligence               
hart  p  e   nilsson  n     raphael  b          a formal basis for the heuristic determination of
minimal cost paths  ieee transactions on systems science and cybernetics       
hernandez  c   asn  r     baier  j  a          time bounded best first search  in proceedings of
the  th symposium on combinatorial search  socs  
hernandez  c     baier  j  a          avoiding and escaping depressions in real time heuristic
search  journal of artificial intelligence research             
hernandez  c   baier  j  a   uras  t     koenig  s          tbaa   time bounded adaptive a  
in proceedings of the   th international joint conference on autonomous agents and multi
agent systems  aamas   pp           valencia  spain 
koenig  s          agent centered search  artificial intelligence magazine                
koenig  s     likhachev  m          fast replanning for navigation in unknown terrain  ieee
transactions on robotics                
koenig  s     likhachev  m          real time adaptive a   in proceedings of the  th international
joint conference on autonomous agents and multi agent systems  aamas   pp         
koenig  s     sun  x          comparing real time and incremental heuristic search for real time
situated agents  autonomous agents and multi agent systems                
korf  r  e          real time heuristic search  artificial intelligence                  
korf  r  e          linear space best first search  artificial intelligence              
likhachev  m   gordon  g  j     thrun  s          ara   anytime a  with provable bounds on
sub optimality  in proceedings of the   th conference on advances in neural information
processing systems  nips   vancouver  canada 
parberry  i          memory efficient method for fast computation of short    puzzle solutions 
ieee trans  comput  intellig  and ai in games               
pearl  j          heuristics  preintelligent search strategies for computer problem solving 
addison wesley longman publishing co   inc   boston  ma  usa 
pohl  i          heuristic search viewed as path finding in a graph  artificial intelligence       
       
rivera  n   baier  j  a     hernandez  c          incorporating weights into real time heuristic
search  artificial intelligence           
schmid  k   tomic  t   ruess  f   hirschmuller  h     suppa  m          stereo vision based indoor outdoor navigation for flying robots  in ieee rsj international conference on intelligent robots and systems  iros   pp           
   

fit ime  b ounded b est f irst s earch for r eversible and n on   reversible s earch g raphs

sharon  g   felner  a     sturtevant  n  r          exponential deepening a  for real time agentcentered search  in proceedings of the  th symposium on combinatorial search  socs   pp 
       
shue  l     zamani  r          an admissible heuristic search algorithm  in komorowski  h  j  
  ras  z  w   eds    proceedings of the  th international symposium methodologies for
intelligent systems  ismis   vol      of lncs  pp        springer 
sturtevant  n          benchmarks for grid based pathfinding  transactions on computational
intelligence and ai in games                 
sturtevant  n  r   bulitko  v     bjornsson  y          on learning in agent centered search  in
proceedings of the  th international joint conference on autonomous agents and multi agent
systems  aamas   pp          toronto  ontario 
wilt  c  m     ruml  w          when does weighted a  fail   in proceedings of the  th symposium on combinatorial search  socs   niagara falls  ontario  canada 

   

fi