journal artificial intelligence research                  

submitted        published      

computing repairs inconsistent dl programs el ontologies
eiter   kr   tuwien   ac  

thomas eiter
michael fink
daria stepanova

fink   kr   tuwien   ac  
dasha   kr   tuwien   ac  

institut fr informationssysteme  tu wien 
favoritenstrae            vienna  austria

abstract
description logic  dl  ontologies non monotonic rules two prominent knowledge
representation  kr  formalisms complementary features essential various applications  nonmonotonic description logic  dl  programs combine formalisms thus providing support rule based reasoning top dl ontologies using well defined query interface
represented so called dl atoms  unfortunately  interaction rules ontology may
incur inconsistencies dl program lacks answer sets  i e   models   thus yields
information  issue addressed recently defined repair answer sets  computing
effective practical algorithm proposed dl lite ontologies reduces repair computation constraint matching based so called support sets  however  algorithm exploits
particular features dl lite readily applied repairing dl programs
prominent dls el  compared dl lite   el support sets may neither small
support sets might exist  completeness algorithm may need given
support information bounded  thus provide approach computing repairs
dl programs el ontologies based partial  incomplete  support families  latter
constructed using datalog query rewriting techniques well ontology approximation based
logical difference el terminologies  show maximal size number support sets given dl atom estimated analyzing properties support hypergraph 
characterizes relevant set tbox axioms needed query derivation  present declarative implementation repair approach experimentally evaluate set benchmark
problems  promising results witness practical feasibility repair approach 

   introduction
description logics  dls  powerful formalism knowledge representation  kr 
used formalize domains interest describing meaning terms relationships
them  well suited terminological modelling contexts as  semantic web  data
integration ontology based data access  calvanese  de giacomo  lenzerini  lembo  poggi   
rosati      b  calvanese  de giacomo  lembo  lenzerini  poggi    rosati      a   reasoning
actions  baader  lutz  milicic  sattler    wolter         spatial reasoning  zccep   mller 
       runtime verification program analysis  baader  bauer    lippmann        kotek 
simkus  veith    zuleger         mention few 
dls fragments classical first order logic  shortcomings modelling application settings  nonmonotonicity closed world reasoning needs expressed 
rules nonmonotonic logic programming offer features  addition  serve well
tool declaring knowledge reasoning individuals  modelling nondeterminism model generation possible answer set programming  get best two
c
    
ai access foundation  rights reserved 

fie iter   f ink   tepanova



    blacklisted staff




    staffrequest hasaction action hassubject staff hastarget project
      blacklistedstaffrequest staffrequest hassubject blacklisted



    staffrequest r        hassubject r    john      blacklisted  john 



    hastarget r    p        hasaction r    read       action read  


     projfile p          hasowner  p    john  






     chief  y   hasowner  z      projfile z   









     grant x  dl project projfile  staffrequest  x   deny x  
p 




     deny x  dl staff chief   blacklistedstaffrequest  x  





    


hasowner
 y 
z  

grant x  






dl   hastarget  x     dl   hassubject  x  z  















figure    dl program policy ontology
worlds dls nonmonotonic rules  natural idea combining led number
approaches combination  often called hybrid knowledge bases  see work
motik rosati        references therein  among them  nonmonotonic description logic
 dl  programs  eiter  ianni  lukasiewicz  schindlauer    tompits        prominent approach
so called dl atoms serve query interfaces ontology loose coupling enable bidirectional information flow rules ontology  possibility add
information rules part prior query evaluation allows adaptive combinations  however  loose interaction rules ontology easily lead inconsistency 
lack models answer sets 
example   consider dl program   ho  pi figure   formalizing access policy
ontology   ht   ai  bonatti  faella    sauro         whose taxonomy  tbox  given
                 sample data part  abox  a  besides facts            simple
rule       rule part p contains defaults            expressing staff members granted
access project files unless blacklisted  constraint       forbids owners project information lack access it  parts  p o  interact via dl atoms
dl project projfile  staffrequest  x   latter specifies temporary update via operator   prior querying it  i e  additional assertions project c  considered individual c  projfile c  true interpretation p  instances x staffrequest
retrieved o  inconsistency arises john  chief project p  owner files 
access them 
inconsistency well known problem logic based data intensive systems  problem treating logically contradicting information studied various fields  e g  belief
revision  alchourrn  grdenfors    makinson        grdenfors   rott         knowledge base
updates  eiter  erdem  fink    senko         diagnosis  reiter         ontology based data access  lembo  lanzerini  rosati  ruzzi    savo         nonmonotonic reasoning  brewka       
sakama   inoue         many others   cf  bertossi  hunter    schaub        nguyen       
martinez  molinaro  subrahmanian    amgoud        bertossi         hybrid formalisms
far inconsistency management concentrated mostly inconsistency tolerance  instance 
   

fic omputing r epairs nconsistent dl p rograms el ntologies

mknf knowledge bases paraconsistent semantics developed knorr  alferes  hitzler
        huang  li  hitzler        kaminski  knorr  leite         dl programs inconsistency tolerance issues targeted fink         paraconsistent semantics based
logic introduced  furthermore  phrer  heymans  eiter       
considered suppressing certain problematic dl atoms  approaches aimed reasoning
inconsistent system rather making required changes system arrive consistent
state  contrast repair techniques recently developed eiter  fink 
stepanova            d  
theoretical framework repairing inconsistent dl programs proposed eiter et al 
        ontology abox  a likely source errors  changed modified dl program
answer sets  called repair answer sets  different repair options including deletion abox formulas various restricted forms addition considered together naive algorithm
computing repair answer sets lacked practicality 
effective repair algorithm dl atoms decided without dynamic ontology
access presented eiter  fink  stepanova         based support sets  eiter  fink 
redl    stepanova      b  dl atoms  portions input together abox
determine truth value dl atom  algorithm exploits complete support families  i e 
stocks support sets value dl atom every interpretation determined   repeated  ontology access avoided  approach works well
dl lite   prominent tractable dl  since complete support families small easy
compute 
however  unfortunately  dls approach readily usable  general
large infinite support families  applies even el  another wellknown important dl offers tractable reasoning widely applied many domains  including biology   cf  e g   schulz  cornet    spackman        aranguren  bechhofer  lord  sattler   
stevens         medicine  steve  gangemi    mori         chemistry  policy management  etc  due
features el include range restrictions concept conjunctions left hand side
inclusion axioms  dl atom accessing el ontology arbitrarily large infinitely
many support sets general  latter excluded acyclic tboxes  often occurring
practice  gardiner  tsarkov    horrocks         complete support families still large 
constructing well managing might impractical  obstructs deployment
approach proposed eiter et al       d  el ontologies  paper tackle issue
develop repair computation techniques dl programs ontologies el  focus el 
since apart simple widely used  dl well researched  available effective
algorithms query rewriting important reasoning readily used 
specifically  introduce general algorithm repair answer set computation operates partial  incomplete  support families along techniques families
effectively computed  problem computing repair answer sets dl programs
el ontologies p   complete  in formulation decision problem  refer work
stepanova        details complexity  
contributions advances previous works eiter et al       b      d       
summarized follows 
effective computation repair answer sets exploit support sets eiter et al 
     d   contrast approaches eiter et al       d         however  tbox
classification invoked  use datalog rewritings queries computing support sets
   

fie iter   f ink   tepanova

 see hansen  lutz  seylan    wolter         introduce notion partial support
families  ontology reasoning access completely eliminated 
general constructing complete support families always feasible el ontologies  provide novel methods computing partial support families exploiting ontology
approximation techniques based logical difference el terminologies considered konev  ludwig  walther  wolter        ludwig walther        
capture restricted classes tboxes  complete support families still
effectively computed  consider support hypergraph dl atoms  inspired
ontology hypergraphs  nortje  britz    meyer        ecke  ludwig    walther        
support hypergraph serves characterize tbox parts relevant deriving
query  analysis support hypergraphs allows us estimate maximal size
number support sets needed form complete support family 
generalize algorithm repair answer set computation proposed eiter et al       d 
el ontologies handled  novel algorithm operates partial support
families  principle applied ontologies dls beyond el  uses
hitting sets disable known support sets negative dl atoms performs evaluation
postchecks needed compensate incompleteness support families  moreover  trades
answer completeness scalability using minimal hitting sets  however completeness may
ensured simple extension 
provide system prototype declarative realization novel algorithm repair
answer set computation  repair approach evaluated using novel benchmarks  results show promising potential proposed approach 
organization  rest paper organized follows  section    recall basic notions
preliminary results  section   deals support sets computation  section  
discusses partial support family construction based tbox approximation techniques  section  
analyze properties support hypergraph estimating maximal size number support sets complete support family dl atom  section    algorithm repair answer
set computation declarative implementation presented  experiments presented section    followed discussion related work section   concluding remarks section   

   preliminaries
section  recall basic notions description logics  focus el  baader 
brandt    lutz         dl programs  eiter et al          background description
logics   see baader  calvanese  mcguinness  nardi    patel schneider        
    description logic knowledge bases
consider description logic  dl  knowledge bases  kbs  signature   hi  c  ri
set individuals  constants   set c concept names  unary predicates   set r role
names  binary predicates  usual  dl knowledge base  or ontology  pair   ht   ai
tbox abox a  finite sets formulas capturing taxonomic resp  factual
   

fic omputing r epairs nconsistent dl p rograms el ntologies

tnorm


    staffrequest hasaction action




   
staffrequest hassubject staff




   
staffrequest
hastarget project



    hasaction action chasa a
 
    hassubject staff chass  st




    hastarget project chast  p




    chasa a chass  st chasa ahass  st



    chasa ahass  st chast  p staffrequest

figure    normalized tbox

























knowledge  whose form depends underlying dl  abuse notation  write  
viewing set formulas 
syntax  el  concepts c  denoting sets objects  roles r  denoting binary relations
objects  obey following syntax  c atomic concept r r
atomic role 
c     c c   r c
el  tbox axioms form c  c   also called generalized concept inclusion axioms 
gcis   c    c  el concepts  abox formulas form a c  r c  d  
c  r r  c  i  sequel  use p generic predicate c r  if
distinction immaterial  
example el ontology given figure   
definition    normalized tbox  tbox normalized  axioms one following forms 
a  a 
a  a  a 
r a  a 
a  r a   
a    a    a  atomic concepts 
e g   axiom     example   normal form  axioms         not 
el tbox  equivalent tbox normal form constructible linear time  stuckenschmidt 
parent    spaccapietra         over extended signature    baader et al         
special class tboxes widely studied literature el terminologies  defined follows 
definition    el terminology  el terminology el tbox   satisfying following conditions 
    consists axioms forms c c  atomic c
arbitrary el concept 
    concept name occurs left hand side axioms  
example  tbox ontology figure   el terminology 
semantics  semantics dl ontologies based first order interpretations  baader et al  
       interpretation pair   hi   non empty domain interpretation
   linear complexity results obtained standard assumption dls atomic concepts
constant size  i e   length binary string representing atomic concept depend particular
knowledge base 

   

fie iter   f ink   tepanova

function assigns individual c object ci   concept name c subset
c   role name r binary relation ri   interpretation extends
inductively non atomic concepts c roles r according concept resp  role constructors 
el   r c i    o    ho    o  ri   o  c    c d i    o    o  c   o  di   
satisfaction axiom resp  assertion w r t  interpretation i  i e       follows 
 i     c d  c di    ii     c a   ai c    iii     r a  b    ai   bi   ri  
furthermore  satisfies set formulas   denoted          
tbox  respectively abox a  ontology o  satisfiable  or consistent  
interpretation satisfies it  call abox consistent tbox   consistent 
since negation neither available expressible el  el ontologies consistent 
example   ontology figure   consistent  satisfying interpretation   hi  
exists     john  read   p    r     action    read    blacklisted   staff    john  
hassubject    r    john   staffrequest   blacklistedstaffrequest    r     hasaction  
 r    read    hastarget    r    p    
throughout paper  consider ontologies el unique name assumption  una  
i e   o     o  whenever o     o  holds interpretation  however  results carry
ontologies without una  hard see una el effect query
answering   cf  lutz  toman    wolter        
    dl programs
dl program   ho  pi pair dl ontology set p dl rules  extend
rules non monotonic logic programs special dl atoms  formed signature
  hc  p  i  c  ri  p   hc  pi signature rule part p set c constant
symbols  finite  set p predicate symbols  called lp predicates  non negative arities 
  hi  c  ri dl signature  set p disjoint c  r  simplicity  assume
c   i 
syntax   disjunctive  dl program   ho  pi consists dl ontology finite set p
dl rules r form
a        b            bk   bk             bm

   

negation failure  naf   ai     n  first order atom p  t 
predicate p p  called ordinary lp atom  bi     m  either lp atom dlatom  rule constraint  n      normal  n    call h r     a             
head r  b r     b            bk   bk             bm   body r  b    r     b            bk  
b  r     bk             bm   denote positive negative parts b r  respectively 
dl atom d  t  form
dl   q   t  
   

 a    s  op   p            sm op pm     input list i    m  si
c r  op    update operator  pi p input predicate arity
si   intuitively  op   increases si extension pi  
   strong negation added resp  emulated usual  eiter et al         

   

fic omputing r epairs nconsistent dl p rograms el ntologies

 b  q  t  dl query  one forms  i  c t   c concept
term   ii  r t    t     r role t    t  terms   iii  c  c   t    
note inclusion dl queries form c  c  easily reduced instance queries  
thus simplicity  consider work instance dl queries 
example   consider dl atom dl project projfile  staffrequest  x   rule     
figure   x   r    dl query staffrequest r     list   project projfile
contains input predicate projfile extends ontology predicate project via update
operator  
semantics  semantics dl program
  ho  pi given terms grounding
gr     ho  gr p i c  i e   gr p    rp gr r  contains possible ground instances
rules r p c  remainder  default assume ground 
 herbrand  interpretation set hb ground atoms  hb herbrand base p  hc  pi  i e  set ground atoms p   satisfies lp  dl atom a 

 i  i  lp atom 
 ii   a     q  t    ht   ai  dl atom form     
 d   


 

ai  i  ai  i     si   t    pi   t  i     m 

   

i  

satisfaction dl rule r  resp  set p rules  herbrand interpretation   hp  oi
usual  satisfies bj   satisfy bj   satisfies   satisfies
r p    o denote satisfies  is model of  object    dl atom  rule set rules  superscript    specifies ontology dl atoms
evaluated  model minimal  model exists i 
example   dl atom   dl project projfile  staffrequest  r    satisfied interpretation    projfile p     hasowner  p    john    since    staffrequest r      

o  staffreqeust r     still holds   o d   d     staffrequest r    
repair answer sets  various semantics dl programs extend answer set semantics logic
programs  gelfond   lifschitz        dl programs   e g   eiter et al         lukasiewicz       
wang  you  yuan    shen        shen         concentrate weak answer sets  eiter
et al          treat dl atoms atoms naf  flp answer sets  eiter  ianni  schindlauer    tompits         obey stronger foundedness condition  answer sets
ordinary logic program interpretations minimal models program reduct 
intuitively captures assumption based application rules reconstruct interpretation 
i o
p relative hb results gr p  deleting
weak  reduct pweak
 i  rules r either    o dl atom b    r     o l l b  r  
 ii  dl atoms b    r  literals b  r  
   evaluating   dl   c  c        reduces evaluating   dl   ac    a   
 ac  c    c  ac     ac   a    fresh constant ac    ac  fresh concepts  similar
tbox normalization  

   

fie iter   f ink   tepanova

i o
flp reduct pflp
p results gr p  deleting rules r  whose bodies

satisfied i  i e      bi   bi     k   o bj   bj   k   j m 
illustrate notions example 

example   let figure    let rule set p contain facts            rules
           x  y  z instantiated r    john  p  respectively  consider interpretation  
i o
 projfile p     hasowner  p    john   chief  john   grant r      flp reduct pflp
contains
i o
rules p  weak  reduct pweak
rule      replaced fact grant r    

definition    x deletion repair answer set  interpretation x deletion repair answer set

  ht a  pi x  flp  weak    minimal model pxi t   a 
called x deletion repair     a  standard x answer set 
example      projfile p     chief  john   hasowner  p    john   grant john   weak
flp repair answer set example   repair   a  blacklisted  john   
notation  denote normal logic program p  p  set answer sets p 
dl program x     resp  ras x     set x answer sets  resp  x repair
answer sets   
general flp answer set weak  answer set  vice versa  i e  flp answer sets
restrictive notion  however  many cases weak flp answer sets coincide 
information reducts  see works eiter et al         wang et al         
shifting lemma  simplify matters avoid dealing logic program predicates separately  shall shift eiter et al       d  lp input dl atoms ontology  given
dl atom   dl   q   t  p p   call pp  c  input assertion d  pp
fresh ontology predicate c c  ad set assertions  tbox
dl atom d  let td    pp p   p p    interpretation i  let
odi   td  pp   t  ad   p  t  i   have 
proposition     eiter et al       d  every   a  dl atom   dl   q   t  interi
pretation i  holds   o iff   od dl   q   t  iff odi    q  t  
unlike oi  d   odi clear distinction native assertions input assertions
w r t   via facts pp axioms pp p    mirroring lp input  note normal
form  td normal form 

   support sets dl atoms
section  recall support sets dl atoms eiter et al       b   effective
optimization means  repair  answer set computation  eiter et al       d   intuitively  support
set dl atom   dl   q   t  portion input that  together abox assertions 
sufficient conclude query q  t  evaluates true  i e   given subset
interpretation set abox assertions ontology o  conclude
  o q  t   basically  method suggests precomputing support sets dl atom
nonground level  dl program evaluation  candidate interpretation ground instances
support sets computed  help prune search space  repair  answer sets 
   

fic omputing r epairs nconsistent dl p rograms el ntologies

exploiting proposition    following definition support sets using ontology
predicates 
definition     ground support sets  given ground dl atom   dl   q   t   set aad
support set w r t  ontology   ht   ai  td    q  t   supp  d  denote
set support sets w r t  o 
support sets grouped families support sets simply support families  formally 
definition     support family  collection supp  d  support sets dl atom
w r t  ontology support family w r t  o 
general el particular  even  minimal support sets arbitrarily large
infinitely many support sets may exist  not acyclic tboxes   still exponentially many
support sets possible   however  nonetheless exploit repair answer set
computation algorithms section   
support sets linked interpretations following notion 
definition     coherence  support set dl atom coherent interpretation i 
pp   c  holds p c  i 
example    dl atom   dl project projfile  staffrequest  r    figure   two
support sets  s     staffrequest r     s     hassubject r    john  projectprojfile  p    
staff  john  hasaction r    read    action read     s  coherent interpretation 
s  coherent interpretations  projfile p     
evaluation w r t  reduces search coherent support sets 
proposition    let   dl   q   t  ground dl atom  let   ht   ai ontology 
let interpretation  then    o iff supp  d  exists s t  coherent i 
using sufficient portion support sets  completely eliminate ontology access
evaluation dl atoms  naive approach  one precomputes support sets ground dlatoms respect relevant aboxes  uses repair answer set computation 
scale practice  since support sets may computed incoherent
candidate repair answer sets 
alternative fully interleave support set computation search repair answer
sets  construct coherent ground support sets dl atom interpretation
fly  input dl atom may change different interpretations  support sets must
recomputed  however  since reuse may possible  effective optimizations immediate 
better solution precompute support sets nonground level  is  schematic support
sets  prior repair computation  furthermore  may leave concrete abox open 
support sets dl atom instance easily obtained syntactic matching 
    dl   q  x 
 
definition     nonground support sets  let tbox  let d x 
 
nonground dl atom  suppose v x set distinct variables c set constants 
nonground support set w r t  set    p   y              pk  y k    atoms
   

fie iter   f ink   tepanova

 i  y             y k v
 k    support set
 ii  substitution   v c  instance    p   y              pk  y
 
d x  w r t  oc   ac   ac set possible abox assertions c 
ontology   ac   denote suppo  d  set nonground support sets
w r t   
ac takes care possible abox  considering largest abox  since
implies supp  d  supp  d   
example      dl project projfile  staffrequest  x   set s     staffrequest x   
nonground support set  likewise set s     action w    staff  y    hassubject x     
hastarget x   z    projectprojfile  z    hasaction x   w    
sufficiently large portion nonground support sets precomputed  ontology access
fully avoided  call portion complete support family 
definition     complete support family  family suppo  d  nonground support sets
  w r t  ontology complete  every support set
 non ground  dl atom d x 
 
 
  exist
supp  d x      x c  extension   v c v x


   
example    consider dl atom d x    dl project projfile  staffrequest  x  figure    family    s    s    s    s    s    s    complete w r t  o  ht   hastarget 
hs   hassubject ha   hasaction 







s 
s 
s 
s 
s 
s 

   staffrequest x    
   project y    ht  x      hs  x   z    staff  z    ha x   z    action z    
   projectprojfile  y    ht  x      hs  x   z    staff  z    ha x   z    action z    
   project y    ht  x      hs  x   z    blacklisted  z    ha x   z    action z    
   projectprojfile  y    ht  x      hs  x   z    blacklisted  z    ha x   z    action z    
   blacklistedstaffrequest x    


say two nonground support sets  resp  support families  ground identical 
groundings coincide  e g   support sets s     p  x   r x     s     p  x   r x  z  
ground identical dl atom d x    dl   q  x   respective support families
 s     s    
definition     subsumption  nonground support set subsumed   denoted s 
every ground instance ground instance exists s 
nonground support families  say s  subsumed s    denoted s  s   
instance s  instance s  exists holds 
example       blacklistedstaffrequest x   hassubject x     blacklisted  y    support
set dl atom d x    dl staff chief   blacklistedstaffrequest  x  w r t  figure    subsumed    blacklistedstaffrequest x     i e  s  moreover 
s     s     s   support families    s       s 
 blacklistedstaffrequest x   hassubject x   z   blacklisted  z     mutually subsume other 
   

fic omputing r epairs nconsistent dl p rograms el ntologies

axiom
datalog rule
a  a 
a   x  a   x 
a  a  a  a   x  a   x   a   x 
r a  a  a   x  r x     a   y  
a  r a 
r x  oa    a   x 
a   oa    a   x 

table    el tbox rewriting
definition     maximal support set size  maxsup  maximal support set size dl atom
w r t    denoted maxsup d    smallest integer n   every complete nonground support family w r t  support set  s    n  support set
exists w r t  suppd  o   s   n 
instance  dl atom tbox example     maximal support set
size    i e   maxsup d      
    computing support sets
section  provide methods constructing nonground support sets  natural approach
computation nonground support sets exploit  conjunctive  query answering methods
el  e g   rosati        lutz et al         kontchakov  lutz  toman  wolter    zakharyaschev 
      stefanoni  motik    horrocks        
suppose given dl program   ho  pi    ht   ai el ontology 
    dl   q  x  
  method construct nonground support sets d x 
 
dl atom d x 
following three steps 
step    dl query rewriting tbox  first step exploits rewriting dl  tbox td    pp p   p p   set datalog rules 
query q d x 
preprocessing stage  tbox td normalized  technique restricts syntactic form
tboxes decomposing complex simpler axioms  purpose  set fresh concept
symbols introduced  normalized form td norm td computed  rewrite part
tbox relevant query q datalog program prog q tdnorm using translation
given table    variant translation prez urbina  motik  horrocks       
zhao  pan  ren         rewriting axioms form a  r a   fourth axiom
table     introduce fresh constants  oa    represent unknown objects  similar rewriting
exploited r equiem system  prez urbina et al          function symbols used
instead fresh constants  result obtain 
lemma    every data part  i e   abox a  every ground assertion q  c   deciding whether
prog q tdnorm    q  c  equivalent checking td norm    q  c  
step    query unfolding  second step proceeds standard unfolding rules
prog q td norm w r t  target dl query q  start rule q head expand
body using rules program prog q tdnorm   applying procedure exhaustively 
get number rules correspond rewritings query q td norm   note
always possible obtain rewritings effectively  since general might
   

fie iter   f ink   tepanova

prog q td norm


     chasa a  x   hasaction x      action y   




     chass  st  x   hassubject x      staff  y   



     chast  p  x   hastarget x      project y   
 

  
  chasa ahass  st  x   chasa a  x    chass  st  x   





  
 
staffrequest x   chasa ahass  st  x    chast  p  x   



    project x   projectprojfile  x   

















figure    dl query rewriting dl project projfile  staffrequest  x  td norm
infinitely many cyclic  still exponentially many acyclic   discuss
techniques computing partial support families next section 
step    support set extraction  last step extracts nonground support sets rewritings
step    select containing predicates td obtain rules r form
  p   y              pk  y k    pk  
 k              pnp  y n   
q x 
 y
   
pk  

n

pi native ontology predicate   k  predicate mirroring lp input
otherwise  bodies rules correspond support sets given dl atom  i e 
 k              pnp  y
 n   
   p   y              pk  y k    pk  
 y
   
pk  

n

following holds 
    dl   q  x 
  dl atom program   ho  pi el
proposition    let d x 
 
ontology   ht   ai  every set constructed steps     nonground support set d x  
shifting lemma  working support sets focus ontology predicates
operate them  specifically  rules form     k n fully reflect nonground
support sets definition     ground instantiations rule constants c
implicitly correspond ground support sets 
illustrate computation nonground support sets dl atoms el ontologies 
example    consider dl atom dl project projfile  staffrequest  x  accessing el ontology   ht   ai figure    datalog rewriting computed step   given
figure    step   obtain following query unfoldings staffrequest 
    staffrequest x  staffrequest x  
    staffrequest x  hasaction x     action y    hassubject x    
staff  y    hastarget x     projectprojfile  y   
    staffrequest x  hasaction x     action y    hassubject x    
staff  y    hastarget x     project y   
    staffrequest x  hasaction x     action y    hassubject x    
blacklisted  y    hastarget x     project y   
    staffrequest x  hasaction x     action y    hassubject x    
blacklisted  y    hastarget x     projectprojfile  y   
step   thus get rule     s     hasaction x     action y    staff  y   
hassubject x     hastarget x     projectprojfile  y    rule     s    action y   
hasaction x    staff  y   hassubject x     project y   hastarget x              
    remaining support sets similarly obtained 

   

fic omputing r epairs nconsistent dl p rograms el ntologies

    partial support families
finding support sets dl atom tightly related computing solutions logic based
abduction problem  abduction important mode reasoning widely applied different areas
ai including planning  diagnosis  natural language understanding many others  console 
sapino    dupr         various variants problem actively studied  e g  eiter 
gottlob  leone        bienvenu         unfortunately  practically important
problems context abduction intractable even restricted propositional theories  eiter
  makino         abduction problem el tboxes considered bienvenu        
represented tuple ht   h  oi  tbox   set atomic concepts h atomic concept
o  explanation set  a              h     a        o 
abox ad contains atomic concepts  computing nonground support sets  
dl   q  x  accessing   ht   ai corresponds abduction problem htd   sig a ad    qi 
roles occur ad   one introduce new fresh concepts construct complex
concepts hypothesis  e g   r a inclusion cr a r a added td   cr a
h  cr a fresh concept 
unlike dl lite   support families dl atoms el ontologies particular
structure  large  maximal support set size exponential size  
example    consider following acyclic tbox   contains axioms 
    r b  s b  b 
    r b  s b  b 
   
 n  r bn  s bn  bn
d    dl   b    x     maximal support set size    witnessed
s     r x    x     b   x     s x    x     b   x     

dl atom d    dl   b    x     maxsup d          due s     r x    x    
r x    x     b   x     s x    x     b   x     s x    x     r x    x     b   x     s x    x     b   x     
moreover  di   dl   bi   x   maxsup di     maxsup di             n 
note maximal support set dn involves n     predicates  therefore  tbox
form   sig t     k  lower bound worst case support set size
 k          k    single exponential size  

general many unfoldings produced step    according recent results
hansen et al          complete support families el computed large classes ontologies  therefore  still exploit support families  unlike eiter et al       d  require
complete  develop techniques computing partial  i e  incomplete  support families dl atoms  natural approach context aim finding support sets bounded
size  general  due cyclic dependencies r c c  possible el
dl lite   support sets arbitrary large  analysis vast number ontologies
revealed many realistic cases ontologies contain  nor imply  cyclic axioms  gardiner
et al          thus assume practical considerations tbox ontology given
dl program acyclic  i e   entail inclusion axioms form r c c  however  even
restriction support sets large example    shows 
   

fie iter   f ink   tepanova

computing complete support families computationally expensive  natural approach
produce support sets certain size k using e g  limited program unfolding 
unfolding branch reaches depth k  stop expand different branch  similarly  compute limited number k support sets stopping rule unfolding program prog q tdnorm
k th support set produced  alternative approach  based tbox approximation
techniques  pursued next section 

   partial support family construction via tbox approximation
provide practical methods construct partial support families using tbox approximation 
    tbox approximation
approximation dl ontologies source language l different target language l
well known important technique ontology management  existing approaches
approximation roughly divided syntactic approaches semantic approaches  former 
e g  tserendorj  rudolph  krtzsch  hitzler        wache  groot  stuckenschmidt         focus syntactic form axioms original ontology appropriately
rewrite axioms comply syntax target language  rather effective general produce unsound answers  pan   thomas         semantic approaches
focus model based entailment original ontology  rather syntactic structure 
aim preserving entailments much possible transforming ontology
target language  general sound  might computationally expensive
 console  mora  rosati  santarelli    savo        
task computing partial support families  sound ontology approximation techniques
relevant  choose dl lite core target approximation language  lies intersection el dl lite   complete support families effectively identified  eiter
et al       d   approach approximating tbox el dl lite core exploits logical
difference el tboxes considered konev et al          idea behind decide
whether two ontologies give answers queries given vocabulary  called signature 
  compute succinct representation difference empty  typical queries include
subsumption concepts  instance queries conjunctive queries  setting subsumption queries particular interest  based nonground support families constructed 
  ontology   ht   ai 
approach follows  given dl atom   dl   q  x 
eliminate tbox td axioms outside dl lite core language  obtain simplified
tbox td   compute succinct representation logical difference td td
w r t     sig ad a  q   axioms logical difference fall dl lite core
added td   restricting predicates potentially appear support sets avoid
redundant computations approximate relevant part tbox  approach
particularly attractive  logical difference el intensively studied  e g  lutz 
walther  wolter        konev et al          polynomial algorithms available
el terminologies  thus confine latter 
present approximation approach formally  first recall notions introduced
konev et al         
   

fic omputing r epairs nconsistent dl p rograms el ntologies

definition      concept difference   concept difference el terminologies t 
t  set cdiff  t    t    el inclusions t     t       
example    terminologies t     b e  e r   c b  t   
 c a  b  c  holds cdiff  t    t         a  b  c  

cdiff  t    t       b r      b  r  
two el terminologies entail concept subsumptions signature   i e  holds
cdiff  t    t      cdiff  t    t        called  concept inseparable 
c
c
denoted t  c
t    e g  example    t  t  t    t   
logical difference terms instance queries defined follows 
definition      instance difference   instance difference terminologies t  t 
set idiff  t    t    pairs form  a      abox  instance
assertion  t     t        say t  t   instance inseparable 
symbols t  t  idiff  t    t      idiff  t    t       
easily seen  t  t  implies t  c
t    converse obvious holds 
theorem     cf  lutz   wolter        el terminologies t  t  signature   t  c

t  iff t  t   
    partial support family construction
show dl atom set support sets  concept inseparable terminologies  prior that  establish following lemma 
lemma    let   dl   q   t  dl atom  let   ht    ai el ontology  let t 
c
tbox  t  c
t     sig a  sig q   p   p p    t  t   

  sig ad   
armed this  obtain following result equivalence nonground support families 
  dl atom let t    t  el terminologies
proposition    let   dl   q  x 
c
t  t    sig a ad q   p   p p    s  s  complete nonground
support families w r t  o    ht    ai o    ht    ai  respectively  s  s 
ground identical 
given two el terminologies t  t    inclusions c cdiff  t    t     resp 
c cdiff  t    t     following konev et al         called left  resp  right  witnesses denoted
lhs
cwtnrhs
 t    t     resp  cwtn  t    t      shown every inclusion c concept difference t  t  contains either left right witness 
theorem     cf  konev et al         let t  t  el terminologies signature 
cdiff  t    t     either c member cdiff  t    t     sig  
concept name c el concepts occurring  
   

fie iter   f ink   tepanova

algorithm    partsupfam  compute partial support family
  ontology   ht   ai
input  dl atom   dl   q  x  
output  partial nonground support family suppo  d 
 a   sig a ad   q 
 b  td  pp p   p p  
 c  td td   c   c    a  r      a  r   
rhs
lhs
 d  lrw cwtn  td   td   cwtn  td   td  


 e  td td  c lrw   c   a  r   
 f   complsupf am d  td   
return
logical difference two el terminologies compact representation consists
inclusions atomic concept name either left right hand side  may
inclusions atomic concepts sides role restrictions form r   fall
target language dl lite core dl  therefore reintroduced 
ready describe algorithm p artsupf  see algorithm    compute partial
  ontology
families support sets  input given dl atom   dl   q  x 
  ht   ai  el terminology  first set signature  a  predicates
relevant support set computation d  construct tbox td  b  simplified
version td  c  removing td axioms form c d  c complex
concept  i e  axioms dl lite core fragment   d  compute right hand side
left hand side witnesses td td store lrw   that   e 
construct tbox td extending td axioms lrw   concepts form
r sides inclusions  based support set construction method dl lite eiter
et al       d   obtain complete support family td  f   partial support
family  
proposition    family computed algorithm   fulfills suppo  d   i e   partial
support family given dl atom w r t    a 
lwr    d  cdiff  td   td      e   guaranteed complete proposition     general algorithm   used computing support families dl atoms
accessing arbitrary tboxes    practically efficient procedures  d  available acyclic
el terminologies  konev et al         

   bounded support sets
section  analyze size number support sets given dl atom have 
bounds quantities hand  one limit search space support sets 
precisely  aim support set families sufficient evaluating dl atom  support
sets  properly  subsumed another support set  i e     dropped 
consider non ground support families subsume  in particular  complete  support
family  formally 
   computing logical difference arbitrary tboxes recent results feng  ludwig  walther        might
exploited 

   

fic omputing r epairs nconsistent dl p rograms el ntologies

definition      complete support family  say nonground support family dl atom
 complete w r t  ontology o  suppo  d  
thus question bounds size support sets cardinality smallest s 
throughout section  tacitly assume tboxes acyclic  i e  entail inclusions form r c c 
    estimation support set size bounds
first consider estimate maximal size support sets smallest  complete support
family analyzing syntactic properties given tbox  start with  recall work
konev et al         atomic concept primitive terminology   occurs
axiom left hand side  pseudo primitive  either primitive occurs
left hand side axioms c  c arbitrary el concept 
el terminology every pseudo primitive    a   
a        r   c        rm  cm    atomic  conjunct ai exists    ai
 konev et al         lemma      obtain 
proposition    let   dl   q   t  dl atom  let el terminology  q
pseudo primitive   maxsup d      
proposition    exploits specific case  support set size bound    providing
liberal syntactic conditions ensure bounded size support sets  use ontology hypergraphs  nortje et al         ecke et al          latter widely studied extracting
modules ontologies  nortje et al          determining concept difference el terminologies  ecke et al          efficient reasoning owl   ql  lembo  santarelli    savo        
important tasks 
first let us recall notion directed hypergraph  natural generalization
directed graph  proposed ausiello  datri  sacc        context databases represent functional dependencies 
definition     directed hypergraph  directed hypergraph pair g    v  e   v
set nodes graph e set directed hyperedges form e    h  h   
h  h v nonempty sets called hypernodes 
given hyperedge e    h  h    call h tail e h head e  denoted
tail  e  head  e   respectively  hypernode singleton   h       binary hypernode 
 h       abuse notation  singleton  v   simply write v  notion
ontology hypergraph dl el introduced ecke et al         follows 
definition     ontology hypergraph  let el tbox normal form  let c r 
ontology hypergraph gt directed hypergraph gt    v  e  
v    xa   c   sig t      xr   r r   sig t      x   
e      xa     xb      b  
   xa     xr   xy      r y   c    
   xr   xy     xa      r y   c    
   xb    xb      xa      b  b    
   

fie iter   f ink   tepanova

xr 

xr 

xa 

xa 

x c 

xr 

xa 

xa 

x c 

xd

xr 

figure    hypergraph gt example   
example    consider following tbox normal form 

    c  c 

    r   a  c 
    r   a  c 
    a  a 
 

    r  a
   
r   a 
 
 
 

ontology hypergraph gt  sig t   depicted figure   







 



define notions directed path two nodes incoming path singleton
node ontology hypergraph  natural generalizations path standard graph 
definition     directed path  incoming path  suppose el tbox normal form 
gt    v  e  ontology hypergraph  x  v singleton nodes occurring gt  
directed path x gt sequence   e    e            en  hyper  edges  that 
 i  tail  e    x 
 ii  head  en   y 
 iii  every ei     n  successor s ei     ej ei exists gt j   i  head  ei  
tail  ej    s ei     s ei   implies head  ei      head  ei       
incoming path singleton node x v gt    v  e  directed path   e            en
node v x  head  en     x  set incoming paths node x
hypergraph g denoted paths x   g  
intuitively  hyperedges ontology hypergraph gt model inclusion relations  complex 
concepts   consequently  incoming path singleton node xc gt models chain
inclusions logically follow   c rightmost element chain 
example    let us look ontology hypergraph gt figure    sequence edges
      xr    xa     xa       xr    xa     xc   
   

fic omputing r epairs nconsistent dl p rograms el ntologies

x  p

xr 

 

xr 

xa 

xa 

x c 

xr 

xa 

xd

xc

xa

x c 

xb

xd

xq


 a  gsupp d  t
example   


 b  gsupp d  t
example   

figure    examples support hypergraphs
incoming path xc  gt reflects inclusions r   a  c  r    r   a    c   
sequence
      xr    xa     xa       xr    xa     xc       xr    xa     xc       xc    xc     xd  
incoming path singleton xd   following set inclusions extracted 
    c  c  d      r   a  c  d      r   a  r   a  d      r   a  r    r   a    d 

introduce notion support hypergraph dl atom 
definition     support hypergraph  support hypergraph dl atom d dl   q   t 

constructed follows 
normal ontology   ht   ai hypergraph gsupp d  t
   build ontology hypergraph gtd    v  e     sig a ad    q  
   leave nodes edges paths xq   gtd   remove nodes edges 
   xc gtd c     paths xc   gtd    hyper  node n exists  p   xp
n   leave xc   otherwise remove corresponding edges 
   xr gtd   r     leave e     xr   y   xc    xc    xr   y   exists gtd  
 xd      otherwise remove e 
let us illustrate notion support hypergraph following example 
 
example    let example    accessed dl atom   dl a  p    d  x  

td    a p  a     support hypergraph gsupp d  t   sig td   shown figure  a  node xd colored blue corresponds dl query d  edge   xd     xr    xa    

  lie incoming path xd  

gsupp d  t
   

fie iter   f ink   tepanova

describing approach extracting support sets dl atom hypergraph 
introduce notion tree acyclicity  alternative definitions refer reader works 
e g  ausiello  datri  sacc         gallo  longo  pallottino        thakur
tripathi        
definition     tree acyclicity  hypergraph g    v  e  called tree acyclic   i  one
directed path exists g singleton nodes x  v   ii  g paths  
e            ek tail  e    head  ek       
refer hypergraphs tree acyclic tree cyclic 




   b
example    gsupp d  t
figure  a tree acyclic  g   gsupp d  t


   a
a    b a       b  not  neither g   gsupp d  t
 
 
c    

hypergraph gsupp d  t
  dl   q  x      d c  c a  c b  b q 
  sig t   given figure  b tree cyclic  since contains two paths xd xq  
namely     xd   xc   xa    xa   xb    xq     xd   xc   xb    xa   xb    xq  


support hypergraph gsupp d  t
   v  e  dl atom   dl   q  x  contains
incoming paths xq start nodes corresponding predicates ad construction 
i e  reflects inclusions q right hand side predicates ad left
hand side entailed td   hence  traversing edges incoming paths xq  
construct sufficiently many query rewritings q tbox td corresponding nonground
support sets allow subsume every nonground support family w r t  o 
support hypergraph given dl atom tree acyclic  support sets conveniently constructed annotating nodes variables xi   n way described
hx
below  use subscripts annotations  e g  xc means node xc annotated
hx  x

variable xi   xr j states xr annotated ordered pair variables xi   xj  
approach proceeds follows  start node xq   annotate x   
hx
i e  xq     traverse hypergraph backwards  going head edge tail 
every edge e encounter annotate tail  e  based form annotation
head  e   variable names occur annotation head  e  and or fresh variable names xi  
n  following way 
     tail  e       
hx

      head  e     xc     tail  e  annotated hxi i 
hxi   xi 

      head  e     xr 
hxi

hxi

  xc       tail  e    xc  annotated hxi  i  i e 

obtain xc     
hxi

     tail  e       head  e     xc

  
hx

hx

      tail  e   xc   xc     xc  xc  annotated xi   i e   xc   xc    
hxi  xi 

      tail  e   xr    xc     get  xr 
   

hxi

  xc      

fic omputing r epairs nconsistent dl p rograms el ntologies

every annotated hypernode n   one create set nonground atoms predicate names
extracted labels hypernodes variable names annotations  nonground
support sets   dl   q  x    constructed incoming paths xq  
pick incoming path   xq containing n edges  start traversing
edge en head  en      xq    first immediate support set s     q x      next
one  s    extracted annotated tail en taking nonground predicates labels
variables  pick edge ek head  ek   tail  en    obtain support
sets substituting nonground atoms correspond head  ek   tail  en   s  atoms
extracted tail  ek    repeated  one fact construct incoming path backwards
along support set extraction  maximal path obtained 

example    consider maximal incoming path xd gsupp d  t
figure  a 

   xa  p    xa       xr    xa     xa       xr    xa     xc       xr    xa     xc       xc    xc     xd   
 z
   
 z
   
 z
   
 z
 
 
 z
   
e 

e 

e 

e 

e 

hx 
 i
traversing path backwards  i e  edges order e    e    e    e    e    obtain   xhx
a  p  xa   e  

 z
  
hx
hx
hx
hx
hx hx
hx
hx
hx
   x 
   x 
   x 
 xa      xc         xhx
 xa      xc         xc     xc      xd     
  xhx
 xa       xa          xhx
r 
r 
r 
 z
   
 z
   
 z
   
 z
 
 
 

e 

e 

e 

 

e 

nonground support sets extracted resulting annotated path follows 

s     d x     immediately obtained head  xd   
first incoming path consider     e    get s     c   x     c   x     
next path     e    e  head  e    tail  e     yielding support set s     c   x    
r   x    x     a   x    x     
then      e    e  get s     c   x     r   x    x     a   x     
    e    e    e  yields s     r   x    x     a   x     r   x    x     a   x     
    e    e    e    extract s     r   x    x     r   x    x     a   x     c   x     
    e    e    e    e  yields s     r   x    x     r   x    x     a   x     r   x    x     a   x     
    e    e    e    e    extract s     r   x    x     r   x    x     a p   x     c   x     
finally      e    e    e    e    e  get s     r   x    x     r   x    x     a p   x    
r   x    x     a   x     

following lemma formally asserts correctness procedure 

lemma    let sg support family constructed tree acyclic hypergraph g gsupp d  t
  sg  complete w r t  o  i e   sg every suppo  d  
  dl   q  x  

particular  lemma    holds complete w r t  ontology   ht   ai  thus
determine sufficiently many nonground support sets looking support hypergraph  note restriction tree acyclic tboxes crucial correctness procedure
above  ensures every node hypergraph annotated once 
lemma    allows us reason structure size support sets analyzing
parameters support hypergraph  one parameter  instance  maximal number
n   g  hyperedges singleton head node excluding   xr      xa    occurring
incoming path xq hypergraph g 
   

fie iter   f ink   tepanova

xq

xl

xe
xf

xd

xm

xb

xa

xk
xc


figure    support hypergraph gsupp d  t
example   

proposition    let   ht   ai el ontology normal form  let  
  dl atom tree acyclic support hypergraph g
dl   q  x 
 
supp d  t

maxsup d  maxg

supp d  t


 n   gsupp d  t
       

   

tree cyclic hypergraphs  bound tight  illustrate next 
example    consider dl atom d x    dl   q  x  accessing tbox td  


    e f l


    f
    c k
    e k
 
td  



    b e
    l q

support hypergraph depicted figure      sig td    six hyperedges singleton head nodes  maximal support set size d x     e g   
 a x   b x   d x   k x   

next define out  in degrees nodes hypergraph 
definition     hyper outdegree  indegree  given directed hypergraph g    v  e  
hyper outdegree denoted hd   x   resp   hyper indegree hd  x   singleton node x v
number hyperedges e e tail  e  x  resp   head  e  x  either  tail  e      
 head  e        similarly  outdegree d   x   resp   indegree  x   x number
edges e e tail  e     x   resp   head  e     x    head  e      tail  e       


example    nodes x v  xa p   xd   hypergraph gsupp d  t
figure  a hyper 
 
outdegree    xap  xd hd  xap      hd  xd        moreover  d   xap        
hyper indegrees hd  xa      hd  xa      hd  xc      hd  xc         graph

  xc    xa     xd    holds hd   xc      hd   xa      hd  xd       
g   gsupp d  t
moreover   xa        


   

fic omputing r epairs nconsistent dl p rograms el ntologies

let us define
smax  x  g    maxpaths x g   n   g  m   g       
   
p
m   g    xa  hdc   xa       hdc   xa   number hyperedges form
  xa   xb    xc    


example    consider gsupp d  t
figure  a  paths xd   gsupp d  t
  contains single maximal path xd   viz     xa p    xa       xr    xa     xa       xr    xa     xc       xr    xa     xc    
  xc    xc     xd    n   g       four hyperedges singleton head node 
m   g       nodes hyper outdegree    hence smax  xq   g             
   hypergraph figure   single maximal incoming path xq   n   g      
m   g     hdc   xa         hdc   xe           thus smax  xq   g                


generalize bound maximal support set size proposition    using
parameter smax  xq   g  node corresponding dl query q dl atom d  obtain
following result hypergraphs possibly tree cyclic 
proposition    let   ht   ai el ontology normal form  let  
  dl atom support hypergraph g
dl   q  x 
supp d  t   role predi
cates  maxsup d   smax  xq   gsupp d  t   

      
example    tree cyclic hypergraph figure   smax  xq   gsupp d  t
  indeed maximal support set size   dl   q  x   hypergraph figure  a

  hyperedges  every node x v  hd   x     thus  smax  xq   gsupp d  t
      
coincides maxsup d      dl a  p    q  x  


note proposition     take computing m   g  outgoing hyperedges
form   xc   xd    xe   account  c  d  e concepts  moreover  roles occur  
multiple outgoing hyperedges involving roles r r influence support set size 
example    let support hypergraph   dl   q  x  hyperedges   xr   xc    xd   
  xc   xs    xm      xd   xm    xq   r   reflecting axioms r c d  s c
dq  largest minimal support set s  r x     c y    s x  z   c z    size
n      n number hyperedges singleton head node  hd   xc       
    number support sets
orthogonal question considered previous section conditions given
number n support sets sufficient obtain  complete support family  problem tightly
related counting minimal solutions abduction problem  analyzed hermann
pichler        propositional theories various restrictions  particular  counting minimal explanations shown   conp complete general propositional theories
 p  complete horn propositional theories  el subsumes propositional horn logic  determining size smallest  complete support family least  p  hard thus intractable 
size support sets  support hypergraph fruitfully exploited estimating
maximal number support sets given dl atom  provide estimate  traverse
support hypergraph forward starting leaves label every node xp number
rewritings p   conveniently compute labels  introduce support weight functions 
   

fie iter   f ink   tepanova


definition     support weight function  let gsupp d  t
   v  e  support hypergraph
dl atom d  support weight function ws   v n assigns every node xa v number
ws xa   rewritings w r t   

every node tree acyclic support hypergraph  value ws conveniently computed recursive manner 

proposition    let gsupp d  t
tree acyclic support hypergraph dl atom  normalized  ontology   ht   ai  ws given follows  vc v set nodes
concepts 



   p
q
ws x         x  x ws x  

p
p

   x  t  vc   x   t  e ws x   

hd  x       x      x
  vc  
otherwise 
   

 x     t    t   x   e  

demonstrate usage proposition    following examples 

example    compute ws x  nodes gsupp d  t
figure  a  traverse graph
leaves root  x  xr    xa    xc    xr    xa p    xr    obtain ws x       furthermore 
ws xa      ws xc         ws xa         ws xc         finally  ws xd         ws xc   
ws xc                   number rewritings d x   and hence support sets
d x    dl a  p    d  x   identified example    

example    consider tbox    a b q  c a  a  e a  f b  g b  h
b  l  dl atom   dl   q  x   whose support hypergraph   sig t  
figure    ws xq         ws xb   ws xa                   indeed   
rewritings q x   namely s     a x   b x    s     c x   b x    s     d x   b x   
s     e x   b x    s     a x   f  x    s     a x   g x    s     a x   h x    s   
 c x   f  x    s     c x   g x    s      c x   h x    s      d x   f  x    s    
 d x   g x    s      d x   h x    s      e x   f  x    s      e x   g x    s    
 e x   h x    s      q x   
immediate corollary proposition     obtain

   v  e  tree acyclic support hypergraph dl atom  
corollary    let gsupp d  t
  el ontology   ht   ai  edge e e satisfies  tail  e    head  e     
dl   q  x 

x
ws tail  e       
   
ws v   
ee   head e  v

thus query node xq   get ws xq      e       fact  proposition    leads
simple bound size  minimal complete support families general cases 
   

fic omputing r epairs nconsistent dl p rograms el ntologies

xc

xd

xe

xf

xa

xg

xh

xb

xq

figure    hypergraph gsupp d  t


   v  e  tree acyclic support hypergraph dl atom
proposition    let gsupp d  t
  el ontology  every edge e     x  y   z  e edges
  dl   q  x 
e    e  e head  ei    x  y           holds head  e      head  e    
 sg
     e      
supp d  t


example    hypergraph gsupp d  t
figure  a single maximal path length   
hyperedges satisfy condition corollary       support sets   s     e      holds 

condition proposition    e e    e  violated  maximal size minimal complete support family assessed easily  instance  support hyper
figure   contains   edges     support sets  shown k
graph gsupp d  t

nodes gsupp d  t violate condition  sg
contains  e k       support sets 
supp d  t

considered example  yields bound              far tight 
note proposition    applied tree cyclic support hypergraphs 

  dl   q  x    
example    consider tree cyclic support hypergraph gsupp d  t
 d c  c a  c b  b q    sig t    shown figure  b  using
proposition    get ws xd        ws xc        ws xa        ws xb        ws xq    
           however  q x    rewritings      s     q x        s     a x   b x   
    s     c x        s     d x   
intuitively  tree cyclic hypergraphs support weight function ws may account nonminimal rewritings  b x   c x     a x   c x     a x   d x     b x   d x   
rewritings counted multiple times  thus general  ws x  provides upper bound
number rewriting  likewise  bound proposition    tight even simple treecyclic support hypergraphs  e g   one dl atom   dl   q  x  w r t  tbox bi  
bi q    n  contains   n edges  n     support sets 


   repair computation based partial support families
section  present algorithm soundransset computing deletion repair answer
sets  shown stepanova         deciding whether given dl program   ht a  pi
el ontology deletion repair answer set p   complete general case 
membership part established guessing candidate repair abox along candidate
   

fie iter   f ink   tepanova

answer set   ht   pi  suitability guess checked using np oracle 
clearly efficient    n   candidate repair aboxes n    a   even finding
answer set would cheap 
restrict search space repairs approach work eiter et al       d 
exploiting support families dl atoms  however  contrast results eiter et al       d  
support families required complete  families complete  which may
known asserted construction   soundransset guaranteed complete 
otherwise  may miss repair answer set  easy extension ensures completeness 
algorithm repair answer set computation  shown algorithm    proceeds follows 
start  a  computing family nonground support sets dl atom 
next  b  so called replacement program constructed 
replacement program obtained simple rewriting gr    dl atom
replaced ordinary atom ed  called replacement atom   disjunctive choice rule
ed ned added informally guesses truth value d  ed  respectively ned  
stands value true  respectively false   repair answer set augmented
proper choice ed resp  ned answer set  eiter et al         proposition      thus
search confined answer sets   found using standard asp
solver 
 c  answer sets computed one one 
determine  d  sets dp  resp  dn   dl atoms guessed true  resp 
i 
a  instantiates dl atoms
false  use function gr s  i 

dp dn relevant ground support sets  i e   compatible i 
 e  loop minimal hitting sets h support sets dl atoms dn
consist abox assertions   f  construct h set dp atoms
dp least one support set disjoint h  thus removing h
affect values atoms dp   

 g  evaluate postcheck atoms dn dp  dp a h w r t  i 
boolean flag rep stores evaluation result function eval n  resp  eval p    specifically  given dn  resp  dp    a h  function eval n  resp  eval p   returns true 
atoms dn  resp  dp   evaluate false  resp  true  
  h  p  succeeds   h 
rep true foundedness check flpfnd i 


restriction i  original language output repair answer set 
remark many cases  foundedness check might trivial superfluous  eiter 
fink  krennwallner  redl    schller      a   e g   loops dl atoms 
consider weak answer sets  eiter et al          entirely skipped 
example    let dl program example   equivalence    axioms    
    weakened   assertions project p    blacklistedstaffrequest r   
added abox a  moreover  assume d   r      dl project projfile  staffrequest  r    
d   r    dl staff chief   blacklistedstaffrequest  r     d   r   p    dl   hastarget  r   p   
   

fic omputing r epairs nconsistent dl p rograms el ntologies

algorithm    soundransset  compute deletion repair answer sets
input   ht a  pi
output  set repair answer sets
 a  compute set nonground support families dl atoms
 b  construct replacement program
 c    

dn  d   ned i  
sigr
a  
 d 
dp  d   ed i  
gr s  i 


 e 
minimal hitting sets h dn sigr  d  

 f 
dp  d dp   sigr  d  s t  h    
a h  evalp  dp  dp   i 
a h 
 g 
rep evaln  dn   i 
ht a h  pi  output i 

 h 
rep flpfnd i 
end
end

d   r   john    dl   hassubject  r   john    b  following replacement program
constructed 



    ed   r    ned   r         ed   r    ned   r         ed   r    p    ned   r    p    








   
e
 r 
 
john 

ne
 r 
 
john  
   
projfile p 
  
   
hasowner
 p 
 
john  


d 
d 






    chief  john  hasowner  p    john   projfile p    
 
 


    grant r    ed   r     deny r    










    deny r    ed   r    





     hasowner  p    john   grant r     ed   r    p     ed   r    john  

suppose    ed    ned    ed    ed    hasowner  p    john   projfile p     chief  john   returned
 c  following partial support families obtained  d  


sigr  d       s    s     s     hasaction r    read    hassubject r    john   action read   
staff  john   hastarget r    p     projectprojfile  p     s     staffrequest r     


sigr  d       s   s     s     staffrequest r    hassubject r    john  blacklisted  john  
s     blacklistedstaffrequest r     


sigr  d       s     s     hastarget r    p     


sigr  d       s     s     hassubject r    john   
 e  get hitting set h    staffrequest r     blacklistedstaffrequest r      disjoint
s    s  s    thus  f  obtain dp    d    d    d     g  check whether
d  false a h  true  rep   false pick different hitting set h   e g 
 blacklisted  john   blacklistedstaffrequest r      proceeding h   get  g  
h    true flp check succeeds  f   interpretation i 
output 
eval n  d    i 

following results state algorithm works properly 
   

fie iter   f ink   tepanova

theorem    algorithm soundransset sound  i e   given program   ht a  pi  every
output deletion repair answer set  
know addition support families complete  postchecks  g 
redundant  dp   dp   set rep   true  otherwise rep   false 
theorem    suppose input program   ht a  pi algorithm soundransset 
holds dl atom support family computed step  a  soundransset
 complete  algorithm soundransset complete  i e   outputs every deletion repair
answer set  
easily turn soundransset complete algorithm  modifying  e  consider
hitting sets  minimal ones  worst case  means fallback almost naive
algorithm  note hitting sets enumerated efficiently relative number  
    optimizations extensions
research repairing databases  see work bertossi        overview  suggests several
techniques  potential interest dl programs  could exploited optimizing
extending repair approach  localization repairs proposed eiter  fink  greco 
lembo        one technique  cautiously part data affected inconsistency identified search repairs narrowed part  using localization 
setting ontology abox split safe set facts  touched
repair  set facts  probably  affected  affected part repaired  result
combined safe abox part get final solution  find suitable abox split  meta
knowledge ontology  e g  modules  additional domain information  used 
another common approach tackling inconsistency problem  proved effective
databases  decomposition  eiter et al          here  available knowledge decomposed
parts  reasons inconsistency identified part separately 
respective repairs conveniently merged  databases decomposition natural 
general unclear inconsistent dl program effectively decomposed  one way
approach problem determining dl atoms whose replacement atoms guessed true
 resp  false  answer sets   given set dl atoms  one aim first searching
repair every dl atom desired value  extend solution
get final result  modules dl programs  as identified dlvhex solver 
exploited program decomposition 
repairs equally useful certain setting  various filterings repairs applied get plausible candidates  here  qualitative domain specific aspects repairs
crucial importance practicability  formulated terms additional local constraints express instance facts involving certain predicates constants must
preserved  resp  checked removal   furthermore  number facts predicates constants allowed deletion bounded  filterings incorporated repair approach 
yet several extensions possible conditional predicate dependence  example  user might willing express condition staffrequest r   eliminated
hasaction r   read   holds data part  blacklisted staff members removed 
files  modifying separate staffrequest issued non blacklisted staff
member 
   

fic omputing r epairs nconsistent dl p rograms el ntologies

  p  y
  
 r    supd  x 

a p

 
  
 y
 r    supd  x 


  p  y
  
 r    ned  x  


          pnd  y
    ned  x  
  a p  y
  
 r    p d  y


    rb s p  y
    
 r    sdp  y

a p  
a p  

    
 r    sd  y   rb sd  y     nd sda p  y

  ed  x  
  cd   supd  x 
 
 r    eval  x 

 
 
 r    eval  x  ned  x   cd

  cd   supd  x 
 
 r    ed  x  

figure    rules rd declarative implementation
    implementation
implemented repair approach c   system prototype  dlliteplugin dlvhex
system        
discussed  support sets el ontologies rich structure  thus computation  tbox classification work eiter et al       d  insufficient  indeed  need
identify inclusions atomic concepts  inclusions form c b 
c arbitrarily complex concept b atomic  constructing support sets thus exploit r equiem tool  prez urbina et al          rewrites target query tbox
using datalog rewriting techniques  limiting number  resp  size  rewritings  partial
support families computed 
principle support sets may subsumed smaller support sets  e g    r c  d  a c  
 a c     support sets redundant thus eliminate implementation 
support families constructed  use declarative approach determining repair
answer sets  minimal hitting set computation accomplished rules  end 
  three fresh predicates  i  supd  x  
   ii  p  y
      iii  a p  y
   
dl atom d x 


    intuitively say d x 
    xx
   i  support set   ii 
introduced 
support set involving rule predicates   iii  support set involving abox predicates  and
possibly rule predicates   called mixed support set  furthermore  every dl atom d x   rules
rd figure   added replacement program  
  known
rules  atom cd informally says support family d x 
complete  information completeness support families certain dl atoms added
declarative program form facts cd   rules  r     r    reflect information
  potential repair  rb s  stands rule body representing support
support sets d x 
             ppnd  y
    
set s  i e  rb s    a          ak    a            ak    nd s    pp d  y
             ppnd  y
      encodes ontology part pp  y
    states assertion
 pp d  y
id

 
 
pi  y   marked deletion  constraint  r    forbids d x   guessed false matching
  matching
support set consists input assertions   r    means instead d x 
mixed support set  assertion ontology part must eliminated  rule  r   
  guessed true  completeness support family unknown matching
says d x 
 
support set available  evaluation postcheck necessary  eval  x   
rule  r    similar

 
d x  guessed false  rule  r    states dl atom guessed true must support
set  support family known complete 
set facts f acts a     pp   c    p   c  a   encoding abox assertions comp
 cd   sd complete support family d  added program   answer sets
   

fie iter   f ink   tepanova


    projfile p         hasowner  p    john       issued  john  r    





    chief  john  hasowner  p    john   projfile p    





    deny r    ed  r    



    hasowner  p    john   issued  john  r     deny r    




    ed  r    ned  r    





    supd  x   pblacklistedstaffrequest  x    pblacklistedstaffrequest  x  




    pblacklistedstaffrequest  x   ned  x    pblacklistedstaffrequest  x   
r        supd  x   pstaffrequest  x    pstaffrequest  x    phassubject  x     



phassubject  x     pblacklisted  y    pblacklisted  y   





    
p
 x
  phassubject  x     pblacklisted  y   ned  x   pblacklisted  y   
staffrequest




pstaffrequest  x   





phassubject  x     




    
eval
 x 

e
 x  

c
 

sup
 x  








     eval  x  ned  x   cd  



     ed  x   cd   supd  x  



























































figure    program r example   
proceed evaluation postcheck atoms
computed  answer set i 
d  c  fact eval   c  answer set  evaluation postchecks succeed 
original program i 
way one identifies
extract repair answer set   i 
weak repair answer sets  flp repair answer sets  additional minimality check needed 
many cases  however  flp weak answer sets coincide  cf  eiter et al       a   particular 
holds example benchmark programs consider 
formally show described approach indeed correctly computes weak repair answer sets 
proposition    let   ho  pi ground dl program  el ontology  let
dl atom sd suppo  d   let rd set rules  r     r    d  define
    r f acts a  comp 

r   rd   f acts a     pp   c    p   c  a  comp  cd   sd  complete
w r t  o   suppose      evaluation postcheck succeeds every dl atom
ras weak     moreover  cd comp every dl atom d 
cd   comp  i 

ras weak       i          
let us demonstrate usage declarative implementation example 
example    consider figure   replacement program rules r   hp  oi 
example    p follows 

    projfile p         hasowner  p    john       issued  john  r    




    chief  john  hasowner  p    john   projfile p    
p 

    deny r    dl staff chief   blacklistedstaffrequest  r    



    hasowner  p    john   issued  john  r     deny r    
   











 

fic omputing r epairs nconsistent dl p rograms el ntologies

assume d x    dl staff chief   blacklistedstaffrequest  x  given
incomplete support family sd    s    s     s     blacklistedstaffrequest x    s   
 staffrequest x    hassubject x      blacklisted  y     interpretation  ned  r    
pstaffrequest  r     pblacklisted  john   evald   among answer sets r facts a  
post check needed d r     test succeeds  thus i 
repair answer set 
eval i 


   evaluation
repair answer set computation approach implemented within dlvhex system  details
found work stepanova         software freely online available  dlliteplugin         approach evaluated multi core linux server running dlvhex      
htcondor load distribution system  htcondor         specialized workload management system compute intensive tasks  using two cores  amd      se cpus   gb
ram 
best knowledge  similar system repairing inconsistent dl programs exists  list systems evaluating dl programs includes dr e w system  drew       
xiao        dlplugin dlvhex system  dlplugin         dr e w system exploits
datalog rewritings evaluating dl programs el ontologies  however  handle inconsistencies  focus work  thus dr e w per se could used baseline
experiments  facilitate comparison  thus extended dr e w naive repair
technique  guess repair abox followed check suitability  however 
immediate implementation turned infeasible even small instances  general
search space repairs ways large full exploitation  guided search needed ensure
scalability  dlplugin dlvhex system invokes r acer p ro reasoner  racerpro       
back end evaluating calls ontology  however  lightweight ontologies even
standard evaluation mode without repair extensions  scales worse dlliteplugin  eiter
et al       b   thus focus latter experiments 
    evaluation workflow
general workflow experimental evaluation follows  first step  constructed benchmarks building rules constraints top existing ontologies
data parts constructed programs become inconsistent  instances generated using
shell scripts  dl program benchmark generation scripts        size conflicting data
part parameter  benchmarks run using htcondor system  times
extracted log files runs  run  measured time computing first
repair answer set  including support set computation  timeout     seconds 
benchmark  present experimental results tables  first column p specifies
size instance  varied according certain parameters specific benchmark  
parentheses number generated instances  e g   value        first column states
set    instances size    tested  columns represent particular repair
configurations  grouped three sets 
first set refers settings  complete support families exploited 
second third refer settings size  respectively number computed sup   

fie iter   f ink   tepanova

port sets restricted   complete setting  addition limit number facts  lim f   
predicates  lim p  constants  lim c  involved facts removed  e g   lim p    
states set removed facts involve two predicates  parameter del  p stores
predicates deleted  e g   del  p   staffrequest means repairs obtained
removing facts staffrequest 
restricted configurations  column size   n  resp  num   n  states
computed partial support families size  resp  number  support sets n  n    
fact support sets computed  system aware  completeness 
exploit partial  completeness number size restriction cases  i e  support sets
atom computed number size limits yet reached  support family
considered atom  complete 
entry t m  n   total average running time  including support set generation
timeouts   number timeouts n number found repair answer sets 
    benchmarks
evaluation developed algorithms  considered following benchmarks 
    policy benchmark variant example    rule      p changed
deny x   dl staff chief   unauthorizedstaffrequest  x   two axioms 
namely unauthorizedstaffrequest staffrequest hassubject unauthorized
blacklisted unauthorized added  
    openstreetmap benchmark contains set rules ontology enhanced personalized route planning semantic information  myits ontology        extended
abox containing data openstreetmap project  osm        
    lubm benchmark comprises rules top well known lubm ontology  lubm 
      el 
describe benchmark results details  experimental data online available
 experimental data        
      access p olicy c ontrol
considered aboxes n staff members  n                 data set  
projects   possible actions  furthermore     staff members unauthorized    
blacklisted  generating instances  used probability p      with p column   
fact hasowner  pi   si   added rules part p si   pi   staff  si    project pi  
 i e   instances vary facts hasowner  pi   si   p   parameter  here  p ranges    
    etc     a         etc     a    a      total average running times
settings shown tables     sr stands staffrequest  experiments
performed aboxes chosen size  i e   a     a      a      demonstrate
approach works small  medium large data 
regards a     limiting  complete setting number predicates removal slightly
increases running times  restricting repairs removing facts staffrequest
slow repair computation compared unrestricted case  many actual
repairs indeed satisfy condition  results bounded number size support sets
   

fic omputing r epairs nconsistent dl p rograms el ntologies

p
       
       
       
       
       
       
       
       

 complete support families
restr  
lim p    
del p   sr
                         
            
                         
            
                         
            
                         
            
                         
            
                         
            
                         
            
                         
            

incomplete support families
size    
size    
num    
             
                          
             
                          
             
                          
              
                          
                                          
                                          
                                          
                                          

num  
            
            
            
            
            
            
            
            

table    policy benchmark  a  
p
     
      
      
      
      
      
      
      

 complete support families
restr  
lim p    
del p   sr
           
            
            
           
            
            
                         
            
                         
            
                          
             
                          
             
                          
             
                          
             

incomplete support families
size    
num    
            
            
            
            
            
            
            
            
                           
                           
                           
                           

num  
            
            
            
            
             
             
             
             

table    policy benchmark  a   
p
      
       
       
       
       
       
       
       

 complete support families
restr  
lim p    
del p   sr
             
             
             
             
             
             
             
             
             
             
             
             
              
                            
              
                            
              
                             
                                             

incomplete support families
size    
num    
             
             
             
             
             
             
             
             
                             
                             
                             
                             

num  
             
             
             
             
              
              
              
              

table    policy benchmark  a   
almost constant  except size limited   smaller  just size   size   shown  
support sets exceed bound post evaluation checks often fail  visibly impacts
running times  support sets large  them  seen
insignificant difference times num     num    
significantly larger abox a      get value p considered settings
perform almost identical except lim p     bit slower  moreover  running times increase
gracefully value p  bounding support set size   produces timeouts  thus
column omitted   computing support sets size   always sufficient identify repairs 
largest setting a       complete case finding arbitrary repair faster
restriction lim p       p       p      results lim p    
   

fie iter   f ink   tepanova

p
       
       
       
       
       
       
       
       
       

 complete support families
restr  
lim f    
lim c     
             
             
             
             
             
             
             
             
             

             
             
             
             
             
             
             
             
             

             
             
             
             
             
             
             
             
             

size    
             
            
            
            
             
             
             
             
              

incomplete support families
size    
num    
             
             
             
             
             
             
             
             
             

             
             
             
             
             
             
             
             
             

num    
             
             
             
             
             
             
             
             
             

num  
             
             
             
             
             
             
             
             
             

table    open street map benchmark results

outperform unrestricted setting  posed limitation restricts search space repairs effectively  removing facts staffrequest longer always sufficient  witnessed
decreased number identified repairs del  p   staffrequest compared lim p      
time increases rather gracefully p long repair answer sets found 
      pen treet ap
second benchmark  added rules top ontology developed myits project 
fixed ontology contains      axioms      axioms tbox     
abox  fragment relevant scenario rules p shown figure    
intuitively  states building features located inside private areas publicly accessible
covered bus stop bus stop roof  rules p check public stations lack
public access  using cwa private areas 
used method introduced eiter  schneider  imkus  xiao        extract data
openstreetmap repository  osm         constructed abox extracting
sets bus stops       leisure areas       irish city cork  well islocatedinside
relations      i e   bus stops located leisure areas   data gathered
many volunteers  chances inaccuracies may high  e g  imprecise gps data   since
data roofed bus stops private areas yet unavailable  randomly made    
bus stops roofed     leisure areas private  finally  added bsi
islocatedinside bsi   laj   fact busstop bsi   p probability p      instances
inconsistent since data set roofed bus stops located inside private areas 
results shown table     complete setting arbitrary repairs computed
    seconds faster repairs bounded changes  restricted configuration
times vary much except size      significant time increase observed 
repairs found smaller instances  previous benchmark computing small
number support sets often sufficient  configuration num     expected slightly
slower num      computing support sets cheap  postchecks take time  
   

fic omputing r epairs nconsistent dl p rograms el ntologies



 



    buildingfeature islocatedinside private nopublicaccess
    busstop roofed coveredbusstop




    publicstation x  dl busstop busstop  coveredbusstop  x  



dl   private  x  
p 
    


dl buildingfeature
publicstation  nopublicaccess  x  



publicstation x   









figure     dl program openstreetmap ontology
p
      
       
       
       
       
       
       
       
       
       

restr  
             
             
             
             
             
             
             
             
             
             

 complete support families
lim f    
lim p    
                           
                           
                          
                          
                          
                          
                          
                          
                          
                          

lim c     
             
             
             
            
            
            
            
            
            
            

incomplete support families
size    
size    
                           
                           
                           
                           
                           
                           
                           
                           
                           
                           

num  
             
             
             
             
             
             
             
             
             
             

table    lubm benchmark results
      lubm
tested approach dl programs   hp  oi built el version
lubm ontology  whose tbox extended following axioms 
    graduatestudent assists lecturer ta
    graduatestudent teaches undergraduatestudent ta
rules follows 


    stud  x   dl   employee  x    dl   ta  x   
 
p 
    dl student stud   taof   x      takesexam x    
    states unless teaching assistant  ta  known employee  he she student 
    forbids teaching assistants take exams courses teach 
abox contains information one university     students     teaching
assistants  constructed dedicated abox generator  lubm data generator         pairs
constants t  c  teachingassistantof  t  c  a  facts takesexam t  c  randomly
added rules part probability p      thus contradicting part dl program
growing respect p 
results benchmark provided table    bounding  complete setting
number removed facts   slows computation  repairs satisfying condition
exist  instances p     i e   inconsistency entrenched     facts must
dropped obtain repair  moreover  often involve    constants according
   

fie iter   f ink   tepanova

column    absence repairs lim f     lim c      found faster repair
unrestricted mode 
limiting support set size   allows one find repairs instances delay less
   seconds compared  complete setting  however  many support sets
benchmark  thus bounding number less effective 
    general results discussion
one observe  complete settings settings post evaluation checks fast 
running times vary slightly growing p  due declarative implementation 
computing repairs reduced finding answer sets program     r facts a 
comp followed possible evaluation postchecks  benchmarks difference
instances size pi pi   data part logic program  small compared
part facts a    constant p  thus long postchecks needed  times
required repairing differ much even though programs become inconsistent 
expected  using  complete support families works well practice  naturally  takes
time compute restricted repairs rather arbitrary repairs  however  imposed restrictions strong repair satisfy them  solver may recognize faster 
reported hansen et al          el tboxes originate real world applications
admit fo rewritings  of reasonable size  almost cases  provides evidence realworld el tboxes hardly contain involving constraints conceptual level  hence either
size number support sets dl atoms often turn limited  novel algorithms
deletion repair answer set computation demonstrated applicability dl programs
real world data  open street map benchmark results table    
benchmarks run synthetic  still vary w r t  tbox
abox sizes  capability algorithms handling diverse dl programs confirms
potential approach 

   related work
inconsistencies dl programs studied several works  phrer et al         fink       
eiter et al             d   phrer et al  proposed inconsistency tolerant semantics  keeping
ontology untouched  dl atoms introduce inconsistency well rules involving
deactivated  repair problem  outlined open issue phrer et al   formalized eiter
et al          notions repair repair answer sets together naive algorithm
computation proposed  latter optimized eiter et al       d       
dl lite effectively exploiting complete support families dl atoms  approach
general  differs one eiter et al       d        uses partial  not
necessarily complete  support families applied ontologies dl  though
possible impact complexity 
hybrid formalisms  inconsistency management concentrated inconsistency tolerance rather repair  instance  huang et al         presented four valued paraconsistent
semantics based belnaps logic  belnap        hybrid mknf knowledge bases  motik  
rosati         prominent tightly coupled combination rules ontologies 
inspired paracoherent stable semantics sakama inoue         work huang
et al         extended huang  hao  luo        handle incoherent mknf kbs 
   

fic omputing r epairs nconsistent dl p rograms el ntologies

i e  programs inconsistency arises result dependency atom default
negation analogy work fink         another direction inconsistency handling
hybrid mknf kbs using three valued  well founded  semantics knorr  alferes  hitzler         avoids incoherence disjunction free stratified programs  recently 
extended kaminski et al         additional truth values evaluate contradictory
pieces knowledge  works aim inconsistency tolerance rather repair  geared
spirit query answering inherent well founded semantics  such  limited
normal logic programs  dl programs allow disjunctive rule heads 
context description logics  repairing ontologies studied intensively  foremost
handle inconsistency  dl program repair related abox cleaning  masotti  rosati   
ruzzi        rosati  ruzzi  graziosi    masotti         however  latter differs various
respects  aims restoring consistency inconsistent ontology deleting  minimal sets
assertions  i e   computing  maximal deletion repairs   deal inconsistency incurred
top consistent ontology  arbitrary  non monotonic  rules access query
interface  furthermore  must consider multiple aboxes  via updates   use el instead
dl lite  refining algorithm compute  maximal deletion repairs possible 
problem computing support families tightly related finding solutions abduction
problem  considered bienvenu        theories expressed el terminologies 
hypothesis h    a              set atomic concepts  observation another atomic
concept  solution abduction problem set h     ai ai o 
setting general involves roles along atomic concepts  abduction
studied various related areas e g   dl lite ontologies calvanese  ortiz  simkus 
stefanoni         propositional logic eiter makino         datalog eiter et al 
       gottlob  pichler  wei         etc  using incomplete support families dl atoms
related spirit approximate inconsistency tolerant reasoning dls using restricted support
sets considered bienvenu rosati         however  focus repair computation
model generation bienvenu rosati target inference repairs 
methods constructing partial support families exploit results logical difference
el terminologies presented konev et al         ecke et al          recently
extended elhr ludwig walther        general tboxes feng et al 
       
repairing inconsistent non monotonic logic programs investigated work
sakama inoue         approach deleting rules based extended abduction
studied  however  restore consistency addition rules possible  latter considered
balduccini gelfond         occams razor consistency restoring rules may
added  methods explaining inconsistency arises logic program studied  e g  
syrjnen         exploited model based diagnosis reiter        debug logic program  generalized debugging logic programs investigated e g   gebser  phrer  schaub 
tompits         recently  schulz  satoh  toni        considered characterization
reasons inconsistency extended logic programs  i e   disjunction free logic programs
strong  classical  negation weak negation  terms culprit sets literals  based
well founded maximal partial stable model semantics  derivation based method explain culprits described  however  remains open debugging logic programs
based culprit sets could done whether could fruitfully extended debugging dlprograms  latter addressed oetsch  phrer  tompits        related
f

   

fie iter   f ink   tepanova

challenging but  best knowledge  unexplored problem repairing rule part
dl program 

   conclusion
considered computing repair answer sets dl programs el ontologies 
generalized support set approach eiter et al       d      b  dl lite work
incomplete families supports sets  advance needed since el complete support families large even infinite  discussed generate support sets  exploiting query
rewriting ontologies datalog  lutz et al         rosati        stefanoni et al         
contrast work eiter et al       d   tbox classification invoked  moreover 
developed alternative techniques effective computation partial support families 
approach approximate relevant part tbox dl lite core exploiting notion logical
difference el terminologies  compute complete support families approximated tbox using methods eiter et al       d   obtained support family complete 
approximated tbox logically equivalent original one 
estimate maximal size support sets  analyzed properties novel support hypergraph  corresponds subgraph ontology hypergraph  nortje et al        
ecke et al          nodes encode ontology predicates  or pairs them    hyper  edges
reflect tbox inclusions  shown traversing support hypergraph one conveniently
compute upper bound number support sets given dl atom  if  addition 
support hypergraph satisfies certain conditions  e g  tree acyclicity   exact estimate
obtained 
developed sound algorithm computing deletion repair answer sets dl programs
el ontologies  complete case support families known complete 
algorithm trades answer completeness scalability  a simple variant ensures completeness  
implemented novel algorithm using declarative means within system prototype 
invokes r equiem reasoner partial support family computation  experimental assessment repair approach  set novel benchmarks constructed including real
world data  availability complete support families adds scalability repair
computation  partial support families work surprisingly well practice due structure
benchmark instances  support sets either small them  thus postevaluation checks cause much overhead  overall  experimental evaluation revealed
promising potential novel repair methodology practical applications 
    outlook
directions future work considered area manifold  cover theoretical
practical aspects inconsistency handling approach  theoretical side  relevant open
issue sufficient conditions computing nonground support sets dl atom
accessing el ontology becomes tractable  work gebser et al         bounded
tree width might considered  parameters density support hypergraph
various acyclicity properties  analyzing complexity counting support sets complete
support family might give hints possible restricted settings  support family computation
efficient  complexity analysis interesting problem such  practical
   

fic omputing r epairs nconsistent dl p rograms el ntologies

side  optimization current implementation extending range applications real use
cases another issue 
repair may intermingled stepping techniques used debugging dl programs  oetsch
et al          considered dl programs monolithic structures applying repair
techniques  repair computation performed dl program taken whole 
interesting relevant quest extend approach dealing modular dl programs 
splitting program separate components individually evaluated well known
programming technique  studied context dl programs  eiter et al         
clear  however  extent program classes repair methods
adapted modular setting 
considered el paper  basic algorithm approach applicable
dls  extensions work el  el   easily possible  main difference
negation  expressible via concept  ontology get inconsistent
updates dl atoms  leading increased number support sets need effectively
computed appropriately handled  extension expressive dls shiq  shoin
even sroiq challenging  efficient methods support set construction remain
developed  relatively high complexity dls  comes computational cost 
hand  computation may done  even offline  reused  fortunately 
support families need complete  may expect return investment time support
set construction overall running time 
orthogonal dls  one study various additional repair possibilities  e g  bounded
addition  overview repair possibilities see work eiter et al         
concentrated repairing data part ontology  natural allow changes
rules interfaces  repairing rules  works asp debugging frhstck  phrer 
friedrich         gebser et al          syrjnen        used starting point 
problem challenging search space possible changes large  priorities rules
atoms involving might applied ensure high quality rule repairs  interfaces
similarly admit numerous modifications  makes type repair difficult  user interaction
probably required 
last least one could develop methods repairing hybrid formalisms including
tightly coupled hybrid kbs even general representations hex programs  eiter et al  
       instead ontology arbitrary sources computation accessed logic
program  heterogeneity external sources hex programs makes repair paraconsistent
reasoning challenging task 

acknowledgments
thank anonymous reviewers detailed constructive suggestions helped
improve work  article significantly extends preliminary work eiter  fink  stepanova
     c   research supported austrian science fund  fwf  projects p     
p      
   

fie iter   f ink   tepanova

appendix a  proofs section  
a   proof proposition   
   proposition       o iff td ai    q  t   ai    pp   t  ad   p  t  i  
thus    ai support set w r t  o  coherent construction 
   supp  d  coherent i  form   ai
ai ai   thus ai   td    q  t   monotonicity td ai    q  t  
hence proposition      o d 
a   proof proposition   
 
consider instance    p   y             pk  yk    set form     d x  
  v c  show support set w r t  oc   ht   ac  recall ac set
 
possible abox assertions c   i e   ac ad  which clearly holds  td    q x  
 
latter equivalent tdnorm    q x  
turn lemma    equivalent
 
 
prog q td norm    q x   let prog   prog q td norm   let prog i       
 
program results prog unfolding rule w r t  target query q x  

i  

 
 
prog
   q x  iff prog    q x  holds  construction s  rule
  thus prog    q x  
 
r form     prog   clearly  r     q x 

 
 
 
 
follows prog    q x  hence td norm    q x  td    q x  

appendix b  proofs section  
b   proof lemma   
towards contradiction  assume t d  c
t d   w l o g  t d    p  p  t d     p  p   

p    p    observe differ predicates pp   p p occurs
    t d  t    t d  t  consists axioms pp p pp occur
t  t    first show p  must hold  indeed  otherwise p    thus p   
pp sig ad   p p   let    p   c   p       p   c   p p  c  
otherwise  i e   p       arbitrary c i  t d model ci p i
 resp  ci p i ci p  ip   pp    thus p     p     el negation free pp occurs
axioms left      p  pp   follows t d     p  p    contradiction 
proves p      two cases 
 i  p    t  c
t  implies t     p  p    monotonicity t d    p  p    contradiction 
 ii  p      p    pp   p p occurs   p   claim t     p p   
indeed  otherwise t  model p   p    easily seen interpretation


coincides pp   p   p  pp   pp   model
t    however      pp p    would contradiction  proves claim 
claim t  c
t    follows t     p p  monotonicity t d    p p   
pp p t    follows t     p  p    contradiction 
b   proof proposition   
suppose s  complete nonground support family w r t  o  let instance

s      ad ac ad   lemma     t d c
t d   thus theorem     t d
   

fic omputing r epairs nconsistent dl p rograms el ntologies

t  well  definition  instance inseparability   aboxes  assertions
t d      holds t d      hence t d ad    q  c   consequently 
  ad  ground  support set w r t  o    s  complete nonground support family
w r t  o    follows instance s    converse membership symmetric 
hence  s  s  ground identical 
b   proof proposition   
towards contradiction  assume   suppo  d  exists  grounding exists
td     d x   however  td    d x   according  f   nonground
support set w r t  td   td lrw   consequently  td     td   contradiction 
td td construction  c  lrw    c   td    c   td     c   td
lhs
 d  definition cwtnrhs
cwtn  

appendix c  proofs section  
c   proof lemma   

w r t  ontology  
construction support sets given hypergraph gsupp d  t
ht   ai presented mimics dl query unfolding tbox td   formally
show  i  set extracted described way indeed nonground support sets d 
 ii  ground instance nonground support set d   nonground  support
set constructed following procedure suitable ground
substitution   proves sg holds 
first prove  i  induction length n incoming paths  support sets
extracted 

base  n    consider path hypergraph gsupp d  t
  assume single
 hyper   edge e   construction  hyperedge must xq head node  i e  head  e   
xq   four possibilities      tail  e     xc        tail  e     xr   xc        tail  e   
 xc   xd       tail  e     xr      annotate nodes path variables described
above  extract nonground atoms labels annotations nodes  result
case     obtain  c x            r x    x     c x            c x     d x     
      r x    x      x  fresh variable  construction hypergraph edges
forms         correspond tbox axioms c q  r c q  c q r  q
respectively  therefore  sets constructed considered cases reflect
dl query unfoldings d  hence represent nonground support sets proposition    
induction step  suppose statement true n  i e  path n edges sets extracted way described nonground support sets d  consider path   e            en
n   edges  let e   e  first edge   induction hypothesis  sets extracted
path   e   e            en following approach support sets d  several
possibilities form e      tail  e     xc   head  e     xd        tail  e     xr   xc  
head  e     xd        tail  e     xc   xd   head  e     xb        tail  e     xr    
head  e     xc        tail  e     xc   head  e     xr   xd   
     construction xc xd annotated xi   let family sets
extracted  e  pick set c xi   occurs  substitute c xi   d xi   
obtain set   induction hypothesis must support set d  however 

   

fie iter   f ink   tepanova

clearly support set  mimics additional unfolding step accounts rule
c x  d x  datalog rewriting td  
let us look      assume set d xi   nonground atoms constructed using
procedure  xi must annotation xd   according construction  xr   xd  
annotated  hxi   xj i  hxj i   xj fresh variable  sets get result
substituting d xi    r xi   xj    c xj     latter mimics unfolding step
q accounts rule d xi   r xi   xj    c xj   rewriting td   support
set induction hypothesis  must support set well  cases        
analyzed analogously  thus sets size n     extracted support sets d 
remains prove  ii   towards contradiction  assume ground instance
suppo  d  exists  ground instance every suppo  d 
constructed procedure   s  support set  definition td norm
   q  c   thus lemma    prog q tdnorm    q  c   turn means q  c 
    sm    
backchaining proof s    s            sm prog q td norm form s    q x 
     c  si    si  hi   bi  i      hi bi
  substitution x
rule resp  fact prog q td norm general unifier hi atom si   
without loss generality  hi   a   oa    hi    r   x  oa    bi
empty end  i e  positions k  k              m  sj resp  sj       j k


amounts instance support set sj resp  sj  
generated gsupp d  t
  particular 


sk  instance sk  consequently  hk   hk             hm     s  instance sk 





well  means instance   sk    contradiction 
c   proof proposition   
prove statement induction number n hyperedges singleton head node

g   gsupp d  t
dl atom dl   q  x  
base  n      show maxsup d       hyperedges required form exist g 
several cases possible   i  g contains hyperedges form  xc    xr   xd      ii  g
hyperedges form   xr      xc    xc    xr        iii  g hyperedges 
 i  consider hyperedge   ej must exist   head  ei   tail  ej   
latter implies ej form   xr   xd    xd   n       i e  contradiction 
 ii   iii   construction contains gcis c c  either atomic
form r   axioms fall dl lite core fragment   minimal
support sets size    moreover   s      reflects dl lite core inconsistency arising
updated ontology  eiter et al       d   negation available expressible el 
exists thus maximal support set size   
induction step  suppose statement true n  prove n    let   e            ek

maximal number n   hyperedges singleton
incoming path xq gsupp d  t
head node  assume ei first hyperedge required form occurring   let us
split two parts  e            ei ei             ek   consider hypergraph g    v  e   
e   e    e            ei    tbox reconstructed it  induction hypothesis 
maxsup d   w r t    ht   ai bounded n      let hypergraph g    v  e  
e   e  ei   correspond tbox   assumption head  ei     xa   i e  ei either
reflects b c r b a  two cases possible  either   q    q 
   

fic omputing r epairs nconsistent dl p rograms el ntologies

x c n 

x cn

x c nk

xcn

   

xcn

 

  
 

k

  
 
   
xq

figure     fragment hypergraph used illustration proof proposition   
former case  ei single hyperedge   i e  n      support sets obtained rewriting q
b c q r b q size    support sets constructed combining
query rewritings predicates occurring left hand side gcis reflected ei  
rewritings size   shown base case  thus overall support set size w r t 
bounded   n     
suppose    q  i e  ei reflects either b c r b a  definition
incoming path  hyper  edge ej must exist  head  ei   tail  ej    moreover  note ej
unique  hyper  edge connected ei   otherwise given hypergraph tree cyclic  i e 
contradiction  distinguish two cases      head  ei     tail  ej   ej corresponds        
    head  ei   tail  ej   ej reflects b        
   consider maximal support set w r t    suppose a y   holds  induction

hypothesis  s  n  g   gsupp d  t
tree acyclic  single atom might

occur s  adding edge ei g obtain support set atom a y  
substituted atoms b y   c y    r z    b z  result additional
query unfolding step  hence support set size bounded n     
   ej reflects b         support set  a y    b y    must exist  unfolding
respective datalog rule  get bound n     support set w r t   

c   proof sketch proposition   
observe tree acyclic hypergraphs nodes hyper out degree    hence
m   g       thus  g tree acyclic  proposition    support set size given
dl atom bounded n   g         equals smax   show claimed bound
correct tree cyclic hypergraphs  intuitively  m   g  must subtracted n   g 
avoid certain atoms support set counted multiple times  regarding structure
support hypergraph distinguish two cases   i  roles appear hypergraph   ii  xr g 
holds r    
   

fie iter   f ink   tepanova

first consider  i   since concepts appear support hypergraph assumption  support sets contain atoms single variable x  occurs  consider
node xcn hdc   xcn     k  k      i e   k outgoing hyperedges
xcn containing nodes corresponding concepts    xcn    xcn    xcn         xcnk  xcn    xcn  
 
k
 see figure      support sets  cn    x             cn k  x     get support sets
 cn   x             cnk  x     cn  x      estimating maximal support set size number hyperedges hypergraph  cn  x    counted k times  appears  as variable
guaranteed x     avoid multiple countings  m   g  must subtracted n   g  
consider  ii   construction g  every hypernode  xr   xc   edges e   
 xa    xr   xc    e      xr   xc    xb   exist g  thus xr occurs   consider
support set  b x    rewriting tbox axiom reflected e    get datalog rule
b x  r x     c y    axiom r c reflected e  rewritten datalog rules
r x  oc   a x   c oc   a x   unifying oc obtain unfolding a x  
essentially shows role occurring support hypergraph   support sets
involve single variable  case  shown  i   provided bound correct 
c   proof proposition   

proof induction number n  hyper  edges g   gsupp d  t
  base  n    g
 hyper  edges  node one support set 
induction step  suppose statement holds n  show holds g n      hyper 
edges  obviously  holds x vr   g tree acyclic normal form  g
node x hd   x    d   x       i e   outgoing  hyper  edges  hd  x      
 x        i e   incoming  hyper  edge  g tree acyclic  rewriting
set qx    a x    x   xa consists qx rewritings sets qtail e 
 hyper  nodes tail  e  head  e    x  tail  e   xb    resp    xb   xc     xr   xc   
rewritings  b x    resp   b x   c x     r x     c y      is  ws xa  
sum number rewritings qtail e  denoted qtail e    plus    consider
arbitrary e head  e    xa let g   g e  g n edges tree acyclic 
induction hypothesis node x v g   value ws x   denoted wsg  x       
furthermore  ws qtail e    ws x    x    xa g g  thus get x   xa  

wsg  x    wsg  x    ws qtail e   
x
wsg  x    
    


    



 x 

x

x



wsg  x    

x



wsg  x    

 x  x

x

ws x     ws qtail e   

x

x

ws x     ws qtail e   



 x  t  vc   x   t  e

 x  t  vc   x   t  e

 x  x

    



x

x

x

ws x  

 x  t  vc   x   t  e



 x     t    t   x   e   e   e    e    x  above  obtain
ws qtail  e    simply need count combinations rewritings node tail  e  
case tail  e     xr   xb    where ws xr         need add number rewritings
tail hyperedge  t   xr   xb     as normal form  must form  xc    
   

fic omputing r epairs nconsistent dl p rograms el ntologies

c   proof corollary   
q
immediate proposition     hypothesis      form  y  vc  
thus x ws x     ws y   i e   ws tail  e   rightmost term   
c   proof sketch proposition   
condition e e    e    every set  x  equation    
q  t     x  y     
contains  at least  one element  say x  ws x       thus x wsg  x   equals ws y 

  inductive argument  obtain every node xa vc  
g   gsupp d  t
ws xa     number distinct edges g occur incoming paths xa
xb vc edge   xb     xr   xa    e  plus number edges 
turn implies query node xq   ws xq      e      holds  construction edge e e
among respective edges xq   result follows immediately 

appendix d  proofs section  
d   proof theorem   
  get  h  answer set  
suppose supransset outputs   i 
foundedness check w r t  ontology     a h succeeded  thus
remains show compatible set   i e   dl atom   dp


iff   o dn iff    o d  towards contradiction  suppose case 
 d  partitioned dl atoms two sets  dp dn   corresponding dl atoms guessed

respectively  set sigr
a   since assume
true false i 
gr s  i 
compatible  one following must hold 

    dl atom dn     o d  two possibilities   i  either

support set sigr  d   ii  support sets identified  case  i   guaranteed
support sets      since otherwise hitting sets h found
 e   hence must exist support set  
    according  e  h   
thus   suppd  o    rep   true  h   post check must succeeded  g  

i e     o must hold  contradiction  case  ii   likewise post evaluation must
succeeded  h   raises contradiction 




    dl atom dp      o d  hence sigr  d        dp   post evaluation
performed  g   latter  however  must succeeded  rep   true  h  
contradiction  hence compatible set   thus deletion repair answer set  
d   proof theorem   
following lemmas useful prove theorem    
lemma    let asx    x  flp  weak     ht   a  pi ground dl program 
   ed   dl     t d   ned   dl      t d  answer set  
dl set dl atoms occurring  
lemma follows general result compatible sets basis evaluation
approach hex programs dlvhex solver  cf   eiter et al       a   
   

fie iter   f ink   tepanova


lemma    let   ht   a  pi ground dl program let      i 

asx     x  flp  weak    suppose dl atom occurring p 

holds   t iff   t d  asx       ht     pi 
  pxi t pxi t coincide  asx     minimal
proof  note   i 

model pxi t   consequently  model pxi t   moreover  minimal 

j satisfies pxi t   j    pxi t   hence answer set pxi t   contradiction 

suppose ras x     implies asx       ht   pi 
a  lemma    answer set thus considered  c    d   dp

dn set  correct  guess   o dl atom d     
  d    
proposition     completeness s  obtain dp gr s  i 


  d      gr s  i 
  d  gr s  i 
a  d  holds
dn gr s  i 



dl atom d  follows dn sgr  d   a          means


h     hitting set dn sigr  d    hence minimal hitting set h h





considered  e    f   dp set dp dp sigr  d  exists
h     hence h     thus  g  call eval p     yields true 
  h  d      thus rep true  eventually   h 
likewise call eval n     gr s  i 

test flpfnd i  ht a h  pi  succeed  x answer set   ht   pi 
output 
lemma      ht   h  pi    h  thus step  h    i 
d   proof proposition   
ras weak     towards contradiction 
first show every       holds i 


suppose      exists i    ras weak     every
  weak       ht     pi  particular    a  p   c    pp   c  i 
i 
  weak       ht     pi several possibilities   i 
holds i 
c    ii 
guess replacement atoms ed   ned model
extension i 
 o
compatible set    iii  interpretation j i 
model p i 
 
extension i 
weak

c hence follows i 
c  
  
case  i  impossible   

  towards contradiction  assume
assume  ii  true  consider interpretation i 

 
  o ned i 
compatible   dl atom either     i 





holds  case      i 
  
d  ed i 
d  support set
       

exists  consider whether sd   sd   former case  must
coherent i 

contain abox assertions sda   otherwise constraint form  r    violated  due
rule  r    least one assertion pid sda must marked deletion  note pid
present   relevant support set w r t    sd known complete 
immediately arrive contradiction  otherwise  rule form  r    applied 
evaluation postcheck succeeded assumption  get contradiction    sd  
sd known complete  rule form  r    applied  due successful
   o d 
evaluation postcheck  contradiction obtained  suppose     true  i 
  sd known complete 
support set exists w r t  coherent i 
   

fic omputing r epairs nconsistent dl p rograms el ntologies

constraint  r    violated  contradicts        thus  body rule  r    satisfied 
evaluation postcheck issued fails  hence get contradiction 
 o
model p i 
finally  assume  iii  holds  i e  interpretation j i 
weak  
 j contains atoms signature   let us consider im      
set   i 



know       hence rule ri must exist   im    b ri   
gl

gl

gl


im    
recall       r f acts a  comp   rgl
 o
 o
 o

i 
p i 
p i 

  f acts a  comp igl   rgl
iff rgl
weak
weak j     pweak construction
must ri   however 
gl weak reducts  contradiction  therefore  rgl
gl


latter raises contradiction  rule rgl atoms signature head im

coincide rule head  thus follows     b rigl    contradiction  therefore 
    holds  global contradiction  i e  i 
ras weak    follows 
i 
  
h rgl

consider case support family sd known complete  prove
as         ras weak     shown above  remains check
as       ras weak     towards contradiction  assume ras weak    exists

       every extension i  ras weak     abox exists
      ht     pi  construct extension follows 


   ed     o d   ned      o d 

 pp   c    p   c  a a   f acts a  comp
 supd   c    d  c  support set sd coherent i 
 s p   c       rb s a p   c     s a p   c       rb s a p   c    nd s a p   c    








since assumption         one following must hold 

 i         r f acts a  comp igl

 ii  j exists  j      r f acts a  comp igl  

satisfies rules forms  r    r   
first assume  i  true  construction i 
 
 
moreover  constraints form  r    violated  dl atom d  c     o d  c 
support set consists input assertions  rules  r     r    present

reduct   igl      cd dl atom d  c  

thus rule r       ri could form  r    r    case
gl



 

 

form  r     dl atom d  c  would exist    o d  c   proposition    support set
hence  r must
d  c  would exist coherent i  construction sda p   c 
  i 

form  r     however    o d  c  completeness sd proposition     construction
implies r violated 
supd   c  i 

let  ii  hold  i e  j exists s t  j      igl   j contains dl atom
d  c  exactly one ed   c  ned   c    contains ed   c  ned   c   interpretations j
coincide replacement atoms ed   c  ned   c   suppose   j contains atoms
    p i o   hence rule ri o p i o   exists
language   j 
weak
weak
weak
    h ri o    consider respective rule ri   j     h rj   
   b ri o    j 
j 
gl
gl
gl
weak
weak
   

fie iter   f ink   tepanova

   construction weak gl reduct  respectively  positive
must j     b rgl






j   b r i o   same  hence  replacement atom e   
normal atoms b rgl
c   resp 
weak






ned   c   must occur positively b rgl    ed   c    j  resp  ned   c    j  
already argued  latter possible  leading contradiction 

consequently    j must contain atoms language r  every rule rgl


form  r    r   j    b ri   iff    b ri    thus j agree atoms p   c 
 
a p
sd   c  

 

gl

gl



similarly  via  r     r    must j agree atoms supd   c   finally 
conclusion 
holds pp   c  pp   c  rules  r    construction i 


j   holds  violates  ii  
thus  follows       consequently       ras weak      holds  proves
result 

references
alchourrn  c  e   grdenfors  p     makinson  d          logic theory change  partial
meet contraction revision functions  j  symbolic logic                
aranguren  m  e   bechhofer  s   lord  p  w   sattler  u     stevens  r  d          understanding
using meaning statements bio ontology  recasting gene ontology owl 
bmc bioinformatics            
ausiello  g   datri  a     sacc  d          graph algorithms functional dependency manipulation  j  acm                
ausiello  g   datri  a     sacc  d          minimal representation directed hypergraphs  siam
j  computing                
baader  f   bauer  a     lippmann  m          runtime verification using temporal description
logic  proc   th intl symp  frontiers combining systems  frocos       pp         
baader  f   brandt  s     lutz  c          pushing el envelope  proc    th intl joint conf 
artificial intelligence  ijcai       pp         
baader  f   calvanese  d   mcguinness  d   nardi  d     patel schneider  p  f   eds           
description logic handbook  theory  implementation applications  cambridge university press       
baader  f   lutz  c   milicic  m   sattler  u     wolter  f          integrating description logics
action formalisms  first results  proc    th national conf  artificial intelligence   th
conf  innovative applications artificial intelligence  pp         
balduccini  m     gelfond  m          logic programs consistency restoring rules  intl
symp  logical formalization commonsense reasoning  aaai      spring symposium series  pp      
belnap  n          useful four valued logic  modern uses multiple valued logic  pp      
reidel publishing company  boston 
bertossi  l  e          database repairing consistent query answering  morgan   claypool
publishers  ottawa  canada 
   

fic omputing r epairs nconsistent dl p rograms el ntologies

bertossi  l  e   hunter  a     schaub  t          introduction inconsistency tolerance  inconsistency tolerance  result dagstuhl seminar   pp      
bienvenu  m          complexity abduction el family lightweight description logics 
proc    th intl conf  principles knowledge representation reasoning  kr      
pp         
bienvenu  m     rosati  r          new inconsistency tolerant semantics robust ontology based
data access  proc    th intl workshop description logics  pp       
bonatti  p  a   faella  m     sauro  l          el default attributes overriding  proceedings  th intl semantic web conf   iswc       pp       
brewka  g          preferred subtheories  extended logical framework default reasoning 
proc    th intl joint conf  artificial intelligence  ijcai       pp           
calvanese  d   de giacomo  g   lembo  d   lenzerini  m   poggi  a     rosati  r       a  
ontology based database access  proc    th italian symposium advanced database
systems  sebd       pp         
calvanese  d   de giacomo  g   lenzerini  m   lembo  d   poggi  a     rosati  r       b  
mastro i  efficient integration relational data dl ontologies  proc    th
intl workshop description logics 
calvanese  d   ortiz  m   simkus  m     stefanoni  g          reasoning explanations
negative query answers dl lite  j  artificial intelligence research             
console  l   sapino  m  l     dupr  d  t          role abduction database view updating 
j  intelligent information systems               
console  m   mora  j   rosati  r   santarelli  v     savo  d  f          effective computation
maximal sound approximations description logic ontologies  proc    th intl semantic
web conf   iswc       part ii  pp         
dlliteplugin dlvhex system         https   github com hexhex dlliteplugin 
scripts dl program benchmark generation        
dlliteplugin benchmarks 

https   github com hexhex 

dlplugin dlvhex system         https   github com hexhex dlplugin 
dr e w reasoner dl programs datalog rewritable description logics         http   
www kr tuwien ac at research systems drew  
ecke  a   ludwig  m     walther  d          concept difference el terminologies using
hypergraphs  proc  intl workshop document changes  modeling  detection  storage
visualization 
eiter  t   erdem  e   fink  m     senko  j          updating action domain descriptions  proc 
  th intl joint conf  artificial intelligence  ijcai       pp         
eiter  t   fink  m   greco  g     lembo  d          repair localization query answering
inconsistent databases  acm transactions database systems        
eiter  t   fink  m   krennwallner  t   redl  c     schller  p       a   efficient hex program
evaluation based unfounded sets  j  artificial intelligence research             
   

fie iter   f ink   tepanova

eiter  t   fink  m   redl  c     stepanova  d       b   exploiting support sets answer set
programs external evaluations  proc    th conf  artificial intelligence  aaai      
pp           
eiter  t   fink  m     stepanova  d          data repair inconsistent dl programs  proc    rd
intl joint conf  artificial intelligence  ijcai       pp         
eiter  t   fink  m     stepanova  d       c   computing repairs inconsistent dl programs
el ontologies  proc    th joint european conf  logics artificial intelligence  jelia
      pp         
eiter  t   fink  m     stepanova  d       d   towards practical deletion repair inconsistent
dl programs  proc    st european conf  artificial intelligence  ecai       pp         
eiter  t   fink  m     stepanova  d       d   data repair inconsistent dl programs  tech  rep 
infsys rr             institut f  informationssysteme  tu wien  a      vienna  austria 
eiter  t   gottlob  g     leone  n          abduction logic programs  semantics complexity  theoretical computer science                   
eiter  t   ianni  g   lukasiewicz  t   schindlauer  r     tompits  h          combining answer
set programming description logics semantic web  j  artificial intelligence 
                     
eiter  t   ianni  g   schindlauer  r     tompits  h          uniform integration higher order
reasoning external evaluations answer set programming  proc    th intl joint conf 
artificial intelligence  ijcai       pp       
eiter  t     makino  k          computing abductive explanations propositional horn
theory  j  acm        
eiter  t   schneider  p   imkus  m     xiao  g          using openstreetmap data create benchmarks description logic reasoners  proc   nd intl workshop owl reasoner evaluation  ore       vol        pp       
experimental data inconsistent dl programs         http   www kr tuwien ac at 
staff dasha jair el benchmark instances zip 
feng  s   ludwig  m     walther  d          logical difference el  terminologies
towards tboxes  proc   st intl workshop sem  technologies  iwost       pp       
fink  m          paraconsistent hybrid theories  proc    th intl conf  principles knowledge representation reasoning  kr       pp         
frhstck  m   phrer  j     friedrich  g          debugging answer set programs ouroboros extending sealion plugin  proc    th intl conf  logic programming nonmonotonic
reasoning  lpnmr       pp         
gallo  g   longo  g     pallottino  s          directed hypergraphs applications  discrete
applied mathematics                
grdenfors  p     rott  h          belief revision  handbook logic artificial intelligence
logic programming           
gardiner  t   tsarkov  d     horrocks  i          framework automated comparison
description logic reasoners  proc   th intl semantic web conf   iswc       pp         
   

fic omputing r epairs nconsistent dl p rograms el ntologies

gebser  m   phrer  j   schaub  t     tompits  h          meta programming technique
debugging answer set programs  proc    rd conf  artificial intelligence  aaai       pp 
       
gelfond  m     lifschitz  v          classical negation logic programs disjunctive databases 
new generation computing            
gottlob  g   pichler  r     wei  f          efficient datalog abduction bounded treewidth 
proc    nd intl conf  artificial intelligence  aaai       pp           
grau  b  c   horrocks  i   kazakov  y     sattler  u          right amount  extracting
modules ontologies  proc    th intl conf  world wide web  www       pp     
    
hansen  p   lutz  c   seylan  i     wolter  f          query rewriting el tboxes  efficient
algorithms  proc    th intl workshop description logics  pp         
hermann  m     pichler  r          counting complexity propositional abduction  j  computer
system sciences                
htcondor load distribution system  version               http   research cs wisc edu 
htcondor  
huang  s   hao  j     luo  d          incoherency problems combination description logics
rules  j  applied mathematics            
huang  s   li  q     hitzler  p          reasoning inconsistencies hybrid mknf knowledge
bases  logic j  igpl                
kaminski  t   knorr  m     leite  j          efficient paraconsistent reasoning ontologies
rules  proc    th intl joint conf  artificial intelligence  ijcai       pp           
knorr  m   alferes  j  j     hitzler  p          coherent well founded model hybrid mknf
knowledge bases  proc    th european conf  artificial intelligence  ecai       pp 
      
knorr  m   alferes  j  j     hitzler  p          local closed world reasoning description logics
well founded semantics  artificial intelligence                      
konev  b   ludwig  m   walther  d     wolter  f          logical difference lightweight
description logic el  j  artificial intelligence research             
kontchakov  r   lutz  c   toman  d   wolter  f     zakharyaschev  m          combined
approach query answering dl lite  proc    th intl conf  principles knowledge
representation  kr       pp         
kotek  t   simkus  m   veith  h     zuleger  f          towards description logic program
analysis  extending alcqio reachability  proc    th intl workshop description
logics  pp         
lembo  d   lenzerini  m   rosati  r   ruzzi  m   savo  d  f          inconsistency tolerant query
answering ontology based data access  j  web sem           
lembo  d   santarelli  v     savo  d  f          graph based approach classifying owl   ql
ontologies  proc    th intl workshop description logics  pp         
lubm benchmark         http   swat cse lehigh edu projects lubm  
   

fie iter   f ink   tepanova

lubm data generator         http   code google com p combo obda  
ludwig  m     walther  d          logical difference elhr terminologies using hypergraphs  proc    st european conf  artifical intelligence  ecai       pp         
lukasiewicz  t          novel combination answer set programming description logics
semantic web  ieee trans  knowledge data engineering                   
lutz  c   toman  d     wolter  f          conjunctive query answering description logic el
using relational database system  boutilier  c   ed    proc    st joint intl conf  artificial
intelligence  ijcai       pp           
lutz  c   walther  d     wolter  f          conservative extensions expressive description logics 
proc    th intl joint conf  artificial intelligence  ijcai       pp         
lutz  c     wolter  f          deciding inseparability conservative extensions description
logic el  j  symbolic computation                
martinez  m  v   molinaro  c   subrahmanian  v  s     amgoud  l          general framework
reasoning inconsistency  springer briefs computer science  springer       
masotti  g   rosati  r     ruzzi  m          practical abox cleaning dl lite  progress report  
proc  description logics workshop 
motik  b     rosati  r          reconciling description logics rules  j  acm        
    
myits   personalized intelligent mobility service         http   www kr tuwien ac at 
research projects myits geoconceptsmyits v    lite owl  
nguyen  n  t          advanced methods inconsistent knowledge management  advanced
information knowledge processing  springer 
nortje  r   britz  a     meyer  t          module theoretic properties reachability modules
sriq  proc    th intl workshop description logics  pp         
oetsch  j   phrer  j     tompits  h          stepwise debugging description logic programs 
j  correct reasoning  pp         
open street map project         http   www openstreetmap org  
zccep    l     mller  r          combining dl lite spatial calculi feasible geothematic query answering  proc    th intl workshop description logics 
pan  j  z     thomas  e          approximating owl dl ontologies  proc    nd intl conf 
artificial intelligence  aaai       pp           
prez urbina  h   motik  b     horrocks  i          tractable query answering rewriting
description logic constraints  j  applied logic               
phrer  j   heymans  s     eiter  t          dealing inconsistency combining ontologies
rules using dl programs   proc   th extended semantic web conf   eswc       part
i  pp         
r acer p ro reasoner owl ontologies         http   franz com agraph racer  
reiter  r          theory diagnosis first principles  j  artificial intelligence              
   

fic omputing r epairs nconsistent dl p rograms el ntologies

rosati  r          conjunctive query answering el  proceedings   th intl workshop
description logics 
rosati  r   ruzzi  m   graziosi  m     masotti  g          evaluation techniques inconsistency handling owl   ql ontologies  proc    th intl semantic web conf   iswc      
pp         
sakama  c     inoue  k          paraconsistent stable semantics extended disjunctive programs 
j  logic computation               
sakama  c     inoue  k          abductive framework computing knowledge base updates 
theory practice logic programming               
schulz  c   satoh  k     toni  f          characterising explaining inconsistency logic
programs  proc    th intl conf   lpnmr       pp         
schulz  s   cornet  r     spackman  k  a          consolidating snomed cts ontological
commitment  applied ontology            
shen  y  d          well supported semantics description logic programs  proc    nd intl
joint conf  artificial intelligence  ijcai       pp           
stefanoni  g   motik  b     horrocks  i          small datalog query rewritings el  proc 
  th intl workshop description logics 
stepanova  d          inconsistencies hybrid knowledge bases  phd thesis  vienna university
technology 
steve  g   gangemi  a     mori  a  r          modelling sharable medical concept system 
ontological foundation galen  aime  pp         
stuckenschmidt  h   parent  c     spaccapietra  s   eds            modular ontologies  concepts 
theories techniques knowledge modularization  vol       lecture notes computer science  springer 
syrjnen  t          debugging inconsistent answer set programs  proc    th intl workshop
nonmonotonic reasoning  nmr       pp       
thakur  m     tripathi  r          linear connectivity problems directed hypergraphs  theoretical computer science                       
tserendorj  t   rudolph  s   krtzsch  m     hitzler  p          approximate owl reasoning
screech  proc   nd intl conf  web reasoning rule systems  rr       pp         
wache  h   groot  p     stuckenschmidt  h          scalable instance retrieval semantic web
approximation  proc   st intl workshops web information systems engineering 
wise       pp         
wang  y   you  j  h   yuan  l  y     shen  y  d          loop formulas description logic
programs  theory practice logic programming                  
xiao  g          inline evaluation hybrid knowledge bases  ph d  thesis  vienna university
technology  austria 
zhao  y   pan  j  z     ren  y          implementing evaluating rule based approach
querying regular el  ontologies  proc   th intl conf  hybrid intelligent systems 
      pp         

   


