journal artificial intelligence research               

submitted        published      

query predicate emptiness ontology based data access
franz baader

franz   baader   tu   dresden   de

tu dresden  germany

meghyn bienvenu

meghyn   lirmm   fr

cnrs  universite de montpellier
  inria  france

carsten lutz

clu   uni   bremen   de

university bremen  germany

frank wolter

wolter   liverpool   ac   uk

department computer science
university liverpool  uk

abstract
ontology based data access  obda   database querying enriched ontology
provides domain knowledge additional vocabulary query formulation  identify query
emptiness predicate emptiness two central reasoning services context  query emptiness asks whether given query empty answer databases formulated given
vocabulary  predicate emptiness defined analogously  quantifies universally queries
contain given predicate  paper  determine computational complexity query
emptiness predicate emptiness el  dl lite  alc families description logics 
investigate connection ontology modules  perform practical case study evaluate
new reasoning services 

   introduction
recent years  paradigm ontology based data access  obda  gained increased popularity  general idea add ontology database querying provide domain knowledge
enrich vocabulary available formulation queries  particularly
useful data queried highly incomplete multiple data sources diverging vocabularies integrated  poggi  lembo  calvanese  de giacomo  lenzerini    rosati 
       obda taken particular verve area description logic  dl 
studied intensively lightweight dls members dl lite el
families  tractable regarding data complexity querying  expressive
dls alc shiq families querying intractable data complexity  use obda former  see example work calvanese  de giacomo 
lembo  lenzerini  poggi  rodriguez muro  rosati         lutz  toman  wolter        
perez urbina  motik  horrocks         chortaras  trivela  stamou        eiter  ortiz 
simkus  tran  xiao         surveys krotzsch        kontchakov  rodriguezmuro  zakharyaschev         latter  see work glimm  lutz  horrocks  sattler
        ortiz  calvanese  eiter         bienvenu  ten cate  lutz  wolter        well
references given work ortiz simkus        
c
    
ai access foundation  rights reserved 

fibaader   b ienvenu   l utz     w olter

obda approach fueled availability ontologies aim providing standard
vocabulary targeted application domain  particular  many ontologies
bio medical domain snomed ct  ihtsdo         nci  golbeck  fragoso  hartel  hendler  oberthaler    parsia         go  gene ontology consortium        
formulated dl allow comparably inexpensive adoption obda bio medical applications querying electronic medical records  patel  cimino  dolby  fokoue  kalyanpur 
kershenbaum  ma  schonberg    srinivas         ontologies kind typically
broad coverage vocabulary often contain tens even hundreds thousands predicates
embrace various subject areas anatomy  diseases  medication  even social context
geographic location  given application  small fragment ontologys vocabulary actually occur data  still  remaining predicates potentially useful
formulating queries linked data vocabulary ontologythis precisely
obda enriches vocabulary available query formulation 
due size complexity involved ontologies vocabularies  however 
difficult understand additional predicates useful query formulation
write meaningful queries extended vocabulary  static analysis tools analyzing
queries would thus useful  paper  consider fundamental static analysis problem
query emptiness well natural variation called predicate emptiness  former 
problem decide whether given query q provides empty answer databases
formulated given data vocabulary   query emptiness thus helps identify queries
useless due wrong use ontology vocabulary  standard static analysis problem many
subareas database theory xml  see e g  work benedikt  fan  geerts       
references therein 
example  consider following simple ontology o 
diabetespatient patient u disease diabetes
diabetespatientwithoutmedication patient u disease diabetes u
medication for diabetes
assume used support querying medical patient database unary table
concept names patient diabetes binary tables role names disease
medication for  distinguishing particular diabetes type   type    example 
database could given following set assertions 
patient a  
disease a  type   

patient b  

medication for a  type   

diabetes type   

disease b  type   

diabetes type   

thus  patient diabetes type   medication b patient
diabetes type    obda  queries interpreted open world assumption thus one
interested certain answers query q w r t  a  is  answers q
extension satisfy ontology agreement  concrete query
q   x    diabetespatient x  
b certain answers q   x  w r t  adespite fact predicate diabetespatient used q   x  occur a  since formulated using data vocabulary
   patient  disease  medication for  diabetes  
 

fiq uery p redicate e mptiness

q uery evaluation

e mptiness

dl

iq

cq

iq query   cq predicate

cq query

el

pt ime c 

np c 

pt ime c 

pt ime c

el

pt ime c 

np c 

e xp ime c 

e xp ime c 

eli

e xp ime c 

e xp ime c 

e xp ime c 

e xp ime c 

horn alcif

e xp ime c 

e xp ime c 

e xp ime c 

e xp ime c 

nl og pace c 

np c 

nl og pace c 

conp c 

pt ime c 

np c 

conp c 

conp c 

alc

e xp ime c 

e xp ime c 

ne xp ime c 

ne xp ime c 

alci

e xp ime c 

 e xp ime c 

ne xp ime c 

 e xp ime c 

alcf

e xp ime c 

e xp ime c 

undecidable

undecidable

dl litecore f  r
dl litehorn

figure    known complexity results query evaluation new complexity results emptiness

say q   x  non empty given o  regard evidence q   x  potentially
useful query databases formulated vocabulary   another example  consider query
q   x    diabetespatientwithoutmedication x 
certain answer q   x  w r t  since  open world assumption  mere
absence information b medication diabetes type   type   imply
negation true  one even show that  whatever database a  formulated vocabulary
use  never certain answer q   x  w r t  a    case  say
q   x  empty given o  contrast q   x   query thus useless  databases 
consider predicate emptiness  problem decide whether given predicate p
data vocabulary   case queries q involve p yield empty answer
 databases  example above  predicate diabetespatientwithoutmedication empty
w r t  important class conjunctive queries  queries constructed atomic formulas using conjunction existential quantification   predicate emptiness used identify
predicates ontology useless query formulation  even starting construct
concrete query  graphical user interface  example  predicates would offered
users query formulation  notion predicate emptiness loosely related predicate
emptiness datalog queries studied e g  vardi        levy        
aim paper perform detailed study query emptiness predicate emptiness
various dls including members el  dl lite  alc families  concentrating
two common query languages dl based obda  instance queries  iqs  conjunctive
queries  cqs   resulting combinations dls query languages  determine
 un decidability exact computational complexity query emptiness predicate emptiness 
results summarized right side figure   range pt ime basic members
el dl lite families via ne xp ime basic members alc family undecidable alc extended functional roles  alcf   adopt standard notion combined
 

fibaader   b ienvenu   l utz     w olter

complexity  measured terms size whole input  tbox  data vocabulary 
query predicate symbol  
restricted data vocabulary quantification  databases
definition  query emptiness predicate emptiness reduce standard reasoning problems
query evaluation query containment  formally  demonstrated undecidability result alcf  contrasted decidability query entailment
containment dl  shown calvanese  de giacomo  lenzerini         emptiness decidable  complexity still often differs query evaluation  simplify
comparison  display figure   known complexity results query evaluation considered dls  please consult work baader  brandt  lutz               krotzsch  rudolph 
hitzler         eiter  gottlob  ortiz  simkus        results concerning el
horn extensions  work calvanese  de giacomo  lembo  lenzerini  rosati       
artale  calvanese  kontchakov  zakharyaschev        results dl lite  work
tobies         hustadt  motik  sattler         lutz         ortiz  simkus  eiter
       results dls alc family  comparing two sides figure   
observe clear relationship complexity emptiness checking
complexity query evaluation  indeed  problems often similar complexity 
several cases emptiness checking difficult corresponding query evaluation problem  way around  complexities incomparable  note
extension el el bottom concept  used express class disjointness  
observe particularly significant difference tractability evaluating instance queries
e xp ime completeness checking iq query emptiness 
key ingredient developing algorithms establishing upper complexity bounds emptiness show that  searching databases witness non emptiness  such database
non emptiness q  given example   one often focus single
database constructed specifically purpose class databases easier handle
class databases  single database   class databases consider depends
dl question  reason  secondary theme paper analyze shape witness
databases  turns alc extension alci inverse roles  consider
single exponential size database whose construction reminiscent type elimination filtration
constructions known modal logic literature  el extension eli  may
concentrate single witness candidate  much simpler one  consists facts
constructed using data vocabulary single constant  extensions el 
use class databases witness candidates  namely tree forest structure 
dl lite  may restrict attention class databases whose size bounded polynomially
w r t  input query ontology 
demonstrate predicate emptiness useful reasoning service static analysis 
perform experiments using well known large scale medical ontology snomed ct coupled
real world data vocabulary  corresponding terms obtained analyzing clinical notes
hospital  randomly generated vocabularies  real world vocabulary 
contains               concept names       role names snomed ct 
       predicates turned non empty iqs        non empty cqs  thus 
snomed ct provides substantial number additional predicates query formulation
large number predicates cannot meaningfully used queries  databases 
thus  identifying relevant predicates via predicate emptiness potentially helpful 
 

fiq uery p redicate e mptiness

consider use query predicate emptiness extraction modules
ontology  thus  instead using emptiness directly support query formulation  show
used simplify ontology   substitute ontology subset ontology
gives certain answers conjunctive queries  databases  replacing
large ontology  potentially quite small   substitute supports comprehension ontology
thereby formulation meaningful queries  show that  eli  one use predicate emptiness extract particularly natural  substitute ontology  called cq  core 
containing exactly axioms original ontology contain predicates
non empty  databases  thus  predicates cq  core ontology meaningfully used queries posed  databases  example  cq  core ontology
o     diabetespatient patient u disease diabetes  
second axiom removed cq contains diabetespatientwithoutmedication
empty given o  analyze practical interest cq  cores  carry case study
compute cq  cores ontology snomed ct coupled various signatures 
showing tend drastically smaller original ontology smaller
 modules  popular way extracting modules ontologies  grau  horrocks  kazakov   
sattler        
article structured follows  begin section   recalling syntax semantics description logics considered work  section    introduce four notions
emptiness  iq query  iq predicate  cq predicate  cq query  investigate formal relationships them  first observe iq query iq predicate emptiness coincide
 so three problems consider  cq predicate emptiness corresponds cqquery emptiness cqs restricted simple form  exhibit two polynomial
reductions predicate query emptiness  dls considered paper except
dl lite family  cq predicate emptiness polynomially reducible iq query emptiness  horn dls considered paper  iq query emptiness polynomially reducible
cq predicate emptiness 
section    investigate computational complexity decidability query predicate emptiness alc family expressive dls  alc alci  provide tight
complexity bounds  showing ne xp ime completeness three emptiness problems alc
iq query emptiness cq predicate emptiness alci   e xp ime completeness
cq query emptiness alci  situation dramatically  and surprisingly  different
alcf  emptiness problems proven undecidable  previously mentioned 
complexity upper bounds alc alci rely characterization non emptiness terms
special witness database  complexity lower bounds undecidability results proven
means reductions tiling problems 
section    continue investigation query predicate emptiness considering
dl el horn extensions  plain el  provide simple characterization nonemptiness terms maximal singleton database  allows us show three emptiness
problems decided polynomial time  using characterization fact
standard reasoning eli e xp ime complete  obtain e xp ime completeness emptiness
checking eli  extensions el allow contradictions  singleton database may
consistent ontology  requiring another approach  handle extensions  show
 

fibaader   b ienvenu   l utz     w olter

sufficient consider tree shaped databases witnesses non emptiness  devise
decision procedure emptiness checking based upon tree automata  obtain manner
e xp ime upper bound horn alcif  sharply contrasts undecidability result
 non horn  alcf  interestingly  show matching e xp ime lower bound
considerably simpler dl el   standard reasoning tasks tractable 
section    turn attention dl lite family lightweight dls 
commonly considered dls ontology based data access  show cq query emptiness
conp complete considered dl lite dialects  iq query emptiness cq predicate
emptiness  show complexity depends whether considered dialect allows conjunctions left hand side axioms  standard dialects dl litecore   dl liter  
dl litef   allow conjunction  show iq query emptiness cq predicate
emptiness nl og pace complete  dialects dl litehorn admits conjunctions 
iq query emptiness cq predicate emptiness conp complete  difference complexity due fact dialects allowing conjunction  need consider witnesses nonemptiness polynomial size  whereas absence conjunction  sufficient
consider databases consist single assertion 
section    apply query predicate emptiness extract modules ontology 
introduce notion  substitute cq  core ontology show eli
cq  core ontology  substitute  relate  substitutes notions module
proposed literature  particular  observe semantic syntactic  modules  grau
et al         examples  substitutes  thus  algorithms computing modules
used compute  possibly non minimal   substitutes  demonstrate potential
utility  substitutes emptiness checking experiments based snomed ct 
finally  sections      conclude paper discussing related future work  please
note improve readability text  technical proofs deferred appendix 

   preliminaries
dls  concepts inductively defined help set constructors  starting countably infinite sets nc concept names nr role names  constructors important paper summarized figure    inverse role form r r role name
role role name inverse role  uniformity  define double inverse identity 
is   r      r role names r  throughout paper  use a  b denote concept
names  c  denote  possibly compound  concepts  r denote roles 
shall concerned variety different dls well known literature 
least expressive ones el dl lite  logical underpinnings owl 
profiles owl  el owl  ql  respectively  motik  grau  horrocks  wu  fokoue    lutz 
       el  concepts constructed according following grammar using constructors
top concept  conjunction  existential restriction 
c 

   

 

 



  c ud

 

r c

ranging concept names r role names  dl lite concepts tboxes
introduced section    basic expressive dl consider paper alc
extension el constructors bottom concept  negation  disjunction value restriction 
c 

   

 

 



 

  c ud
 

 

c td

 

r c

 

r c

fiq uery p redicate e mptiness

name

syntax

concept name
role name


r

semantics
ai
ri

top concept
bottom concept
negation
conjunction
disjunction
existential restriction
value restriction
role inverse

 

c
c ud
c td
r c
r c
r

 i  
 
  c
c di
c di
 d   e c  d  e  ri  
 d   e    d  e  ri e c  
  d  e     e  d  ri  

concept inclusion
concept assertion
role assertion

cvd
a a 
r a  b 

c di
ai ai
 ai   bi   ri

figure    syntax semantics dl constructors  tbox axioms  abox assertions 

availability additional constructors indicated concatenation letters subscripts 
letter stands addition inverse roles  inside existential value restrictions  present 
subscript stands adding   gives  example  extension alci alc
inverse roles  whose constructors exactly ones shown figure    defines
extension eli el inverse roles existential restrictions bottom concept 
concept inclusion  ci  dl l takes form c v d  c l concepts 
use c abbreviation cis c v v c  description logic  ontologies
formalized tboxes  given dls l introduced above  l tbox finite set
cis l  use letter f write lf denote description logic tboxes consist
cis l  functionality statements funct r   r role name
inverse role  if inverse roles admitted l   example  alcf thus extension alc
tboxes contain cis alc functionality statements role names  use
term axioms refer concept inclusions functionality statements uniform way 
addition dls introduced above  consider dls impose restrictions
constructors used side concept inclusions  horn alci concept
inclusion  ci  form l v r  l r concepts defined syntax rules
r  r                r u r    l r   r r   r r
l  l              l u l    l l    r l
ranging concept names r  potentially inverse  roles  horn alcif tbox
finite set horn alci cis functionality statements funct r   note different
definitions horn dls found work hustadt  motik  sattler         eiter et al 
        kazakov         original definition hustadt  motik  sattler based
polarity rather technical  prefer  equivalent  definition 
size  t   tbox obtained taking sum lengths axioms 
length axiom number symbols needed write word 
 

fibaader   b ienvenu   l utz     w olter

databases represented using abox  finite set concept assertions a a 
role assertions r a  b   a  b drawn countably infinite set ni individual names 
concept name  r role name  note role assertions cannot use inverse roles 
shortcut  though  sometimes write r  a  b  r b  a  a  use ind a  denote
set individual names used abox a  knowledge base pair k    t   a 
tbox abox 
semantics description logics defined terms interpretation    i     
domain non empty set interpretation function maps concept name nc
subset ai   role name r nr binary relation ri   individual
name element ai   extension compound concepts inductively defined
shown third column figure    interpretation satisfies  i  ci c v c di  
statement funct r  ri functional   iii  assertion a a  ai ai    vi  assertion
r a  b   ai   bi   ri   then  model tbox satisfies axioms   model
abox satisfies assertions a  tbox satisfiable model abox
satisfiable w r t  tbox common model  write    c v
models satisfy ci c v d 
consider two types queries  first  instance queries  iqs  take form a v  
concept name v individual variable taken set nv   note instance queries
used query concept names  role names  traditional definition  due
fact role assertions implied abox explicitly contained it 
thus querying trivial   general conjunctive queries  cqs  take form  u   v    u 
conjunction atoms form a v  r v  v     v  v   individual variables
 v  u nv   variables existentially quantified called answer variables 
arity q defined number answer variables  queries arity   called boolean 
use var q   avar q   qvar q  denote set variables  answer variables  quantified
variables respectively query q  on  use iq refer set iqs cq
refer set cqs 
let interpretation q  instance conjunctive  query q arity k answer
variables v            vk   match q mapping   var q   v  ai
a v  q    v    v      ri r v  v     q  every answer variable v var q  
individual name  v    ai   write    q a            ak   match
q  vi     aii every   k  knowledge base  t   a   write
     q a            ak      q a            ak   models a  case   a            ak  
certain answer q w r t  a  use certt  a  q  denote set certain answers
q w r t  a  note q boolean query     certt  a  q 
match q every model   a  otherwise certt  a  q      query evaluation problem
cqs dl l problem decide l tbox   abox a  cq q arity k  tuple
 a ind a k   whether  a certt  a  q  
use term predicate refer concept name role name signature refer
set predicates  in introduction  informally called signature vocabulary   sig q 
denotes set predicates used query q  similarly sig t   sig a  refer
signature tbox abox a   abox abox uses predicates
signature   likewise  concept 
   longer true presence role hierarchy statements which  however  consider paper 

 

fiq uery p redicate e mptiness

context query answering dls  sometimes useful adopt unique name
assumption  una   requires ai    bi interpretations a  b ni
   b  results obtained paper depend una  following well known
lemma shows una make difference alci  and fragments el
alc  certain answers queries change 
lemma   let alci tbox  abox  q cq  certt  a  q  identical
without una 
analogous statement fails alcf  e g  abox    f  a  b   f  a  b     satisfiable w r t  tbox    funct r   without una  and thus certt  a  a v       
unsatisfiable una  and thus certt  a  a v     ind a   

   query predicate emptiness
introduce central notions reasoning problems studied paper  show
interrelated  make basic observations used throughout paper  following
definition introduces different notions emptiness studied paper 
definition   let tbox  signature  q  iq  cq  query language  call
q query q empty given  aboxes satisfiable w r t   
certt  a  q     
predicate q empty given every q query q sig q  empty
given  
follows  signatures used aboxes called abox signatures  quantify
aboxes formulated abox signature address typical database applications
data changes frequently  thus deciding emptiness based concrete abox
much interest  example  assume aboxes formulated signature
   person  hasdisease  diseasea  diseaseb 
following  upper case words concept names lower case ones
role names  signature typically fixed application design phase  similar schema
design databases  tbox  take
   person v hasfather  person u male   diseasea v infectiousdisease  
iq infectiousdisease v  cq v hasfather u  v  non empty given
despite using predicates cannot occur data  witnessed  aboxes  diseasea a  
 person a    respectively  illustrates tbox enriches vocabulary
available query formulation  contrast  cq
vv    hasfather u  v  hasdisease v  v     infectiousdisease v      
uses predicates plus additional one abox signature  empty
given  
 

fibaader   b ienvenu   l utz     w olter

regarding predicate emptiness  interesting observe choice query language
important  example  predicate male iq empty given   cq empty
witnessed  abox  person a   cq v male v   thus makes sense use male
instance queries  aboxes given   whereas meaningfully used conjunctive
queries 
every iq cq  predicate cq empty must iq empty  illustrated
example  converse hold  note role names iq empty
given since role name cannot occur instance query  contrast  hasfather clearly
cq empty example 
follows lemma   that  alci fragments  query emptiness predicate emptiness oblivious whether una made  iq cq  established
following lemma  true alcif despite fact certain answers queries
differ without una 
lemma   let alcif tbox  cq q empty given una iff
empty given without una 
proof lemma   given appendix  direction left right one assumes
q non empty given without una takes witness  abox a  using model
satisfying without una identifying a  b ind a  ai   bi one
define  abox a  shows q non empty given una 
conversely  one assumes q non empty given una takes witness
 abox a  one use show q non empty given without una 
exception dl lite dialect  containing role inclusions  dls considered
paper fragments alcif  thus  free adopt una not  remainder
paper  choose whatever convenient  careful always point explicitly
whether una made not  dl lite dialect covered formulation lemma  
observe discussion dl lite even lemma   holds free adopt
una case well 
relevant note decision disallow individual names query atoms without
loss generality  indeed  easily verified predicate emptiness whether
admit individuals queries not  moreover  immediate reduction query emptiness
generalized cqs  which may contain individual names  query emptiness cqs defined
paper  suffices replace every individual query fresh answer variable xa  
test whether resulting query  without individuals  empty given  
definition   gives rise four natural decision problems 
definition   let q  iq  cq  
q query emptiness problem deciding  given tbox   signature   qquery q  whether q empty given  
q predicate emptiness means decide  given tbox   signature   predicate s 
whether q empty given  
  

fiq uery p redicate e mptiness

iq query   iq predicate
emptiness
emptiness
trivial

cq query
emptiness

theorem  
 materializable dls 

lemma  

theorem  

cq predicate
emptiness

figure    polytime reductions emptiness notions 
clearly  four problems intimately related  particular  iq query emptiness iqpredicate emptiness effectively problem since instance query consists
single predicate  reason  disregard iq predicate emptiness
speak iq query emptiness  cq case  things different  indeed  following lemma
shows cq predicate emptiness corresponds cq query emptiness cqs restricted
simple form  easy consequence fact that  since composite concepts queries
disallowed  cqs purely positive  existential  conjunctive 
lemma   nc  resp  r nr   cq predicate empty given iff conjunctive query
v a v   resp  vv   r v  v      empty given  
lemma   allows us consider queries form v a v  vv   r v  v     dealing
cq predicate emptiness  on  without notice 
trivially  iq query emptiness special case cq query emptiness  following observation less obvious applies dls considered paper except dl lite
family 
theorem   dl contained alcif admits cis r b v b r   v b b
concept name  cq predicate emptiness polynomially reduced iq query emptiness 
proof  let tbox  signature  b concept name occur  
role name occur   prove
   cq predicate empty given iff iq b v  empty  s  given tbox
    tb  a v b   tb    r b v b   r   r occurs   
   r cq predicate empty given iff iq b v  empty  s  given tbox
    tb  r   v b   tb above 
proofs points     similar  concentrate point    first suppose cqpredicate non empty given    abox      v a v   choose
a  ind a  set a      s a    b    b ind a    using fact      v a v 
definition a      shown     a     b a     converse direction 
suppose b iq query non empty  s  given      s  abox a 
    a     b a  ind a     let obtained a  removing assertions
s a  b   using fact     a     b a  definition a      shown
     v a v  


  

fibaader   b ienvenu   l utz     w olter

figure   gives overview available polytime reductions four  rather  three 
problems  terms computational complexity  cq query emptiness thus  potentially  hardest problem  cq predicate emptiness simplest  precisely  cq query emptiness
dl l belongs complexity class c  larger equal pt ime   iq query emptiness
cq predicate emptiness l c  moreover  dls l satisfying conditions
theorem    c hardness cq predicate emptiness l implies c hardness cq query emptiness
iq query emptiness l 
certain conditions  prove converse theorem    following work
lutz wolter         call model tbox abox materialization
every cq q arity k tuple  a ind a k      q  a  iff      q  a   dl l
called materializable every abox satisfiable w r t  exists materialization
a  typical dl lite dialects  dl el  horn extensions el elif
materializable  lutz   wolter        
theorem   let l materializable dl admits cis form a  u a  v a   
a    a    a  nc   then  l  iq query emptiness polynomially reduced cq predicate
emptiness 
proof  claim iq a v  empty given iff b cq empty  x  given
tbox      a u x v b   b x concept names occur  
direction  assume a v  iq non empty given   let abox      a a  ind a   set a      x a    easy see
    a     v b v  thus b cq predicate non empty  x  given    
direction  assume b cq non empty  x  given     let a 
 x  abox satisfiable       a     v b v   may assume
x a  a  ind a    adding assertions neither result unsatisfiability
w r t    invalidate     a     v b v   assumption materializability  exists
materialization     a       v b v   definition     may assume
 
 
 
 
x   ind a    b   ai x  if case  take modified version 
  
  
 
 
  
 
       defined setting x    ind a     b    ai x     
 
remaining concept role names      still satisfies   a  since x ind a   
  
 
u x v b inclusion containing x b still materialization since
concept role names         v b v  implies ind a   
     b a   since   materialization   a    implies     a     b a   definition
    implies      a a   obtained a  dropping assertions form
x b   since  abox satisfiable w r t   since a  satisfiable w r t       witnesses
a v  non empty given  

final observation section  note deciding query predicate emptiness
essentially abox satisfiability whenever contains symbols used tbox 
described reductions  suffices consider cq query emptiness  cq q    u   v    u 
associate every individual variable v q individual name av set
aq    a av     a v  conjunct    r av   av      r v  v     conjunct   
theorem   let alcif tbox  signature sig t     q cq  q
empty given iff sig q    aq unsatisfiable w r t   
  

fiq uery p redicate e mptiness

proof   if  assume q non empty given    abox
satisfiable w r t  certt  a  q       clearly implies sig q  since otherwise
predicate sig q    find model predicate
interpreted empty set  would mean certt  a  q      thus remains show aq
satisfiable w r t    end  let model a  since certt  a  q       exists
match q i  modify setting aiv    v  variables v used q  readily checked
modified model aq   thus aq satisfiable w r t  required 
 only if  assume sig q  aq satisfiable w r t    sig aq     since
clearly certt  aq  q       means q non empty given  


   expressive description logics
consider query predicate emptiness alc family expressive dls  establishing tight
complexity results alc alci  undecidability alcf  start upper bound
proofs  showing iq query emptiness cq predicate emptiness alci ne xp ime  cq query emptiness alc  moreover  establish cq query emptiness
 e xp ime  move corresponding lower bound proofs establish
undecidability considered emptiness problems alcf 
    upper bounds
first main step proofs show that  deciding emptiness problems alc
alci  suffices consider single special  abox  specifically  show construct
given satisfiable tbox abox signature canonical  abox  
every cq q  certt  at    q     exists  abox satisfiable
w r t  certt  a  q       prove ne xp ime upper bounds iq query emptiness alci computing    in exponential time  guessing model    of
exponential size  t     falsifies query   e xp ime upper bound cq query
emptiness alci obtained even simpler way computing   checking
whether certt  at    q    using known algorithms  significantly work required obtain
ne xp ime upper bound cq query emptiness alc  construct     need
exercise lot care check whether certt  at    q    without leaving ne xp ime 
let satisfiable alci tbox abox signature  define canonical  abox
  introduce well known notion types  or hintikka sets   pratt        kaminski 
schneider    smolka         closure cl t     smallest set contains
nc well concepts occur  potentially subconcept  closed
single negations  type set cl t     model
    ti  d   ti  d     c cl t       c   type
realized i  let tt   denote set types   role name r
t  t  tt     say pair  t  t    r coherent write  r t 
c t  whenever r c t 
c whenever r  c t   
seen implies corresponding conditions existential restrictions 
c t  r c cl c    implies r c t 
  

fibaader   b ienvenu   l utz     w olter

definition    canonical  abox  let satisfiable alci tbox abox signature 
fix  distinct  individual name tt     canonical  abox   defined
follows 
     a at     tt     nc  
 r at   at       r t  t  t  tt     r nr   
cardinality tt   exponential size cardinality  
set tt   computed exponential time making use well known e xp ime procedures
concept satisfiability w r t  tboxes alci  gabbay  kurucz  wolter    zakharyaschev       
p      thus    exponential size computed exponential time  interesting
note abox   finitary version canonical model basic modal logic
essentially identical model constructed pratts type elimination procedure  pratt        
fact  exactly identical sig t    show   satisfiable w r t   
lemma    let satisfiable alci tbox abox signature    satisfiable
w r t   
proof  let interpretation   defined setting
 

  tt  

ait  

   t tt     t 

rit  

    t  t    tt   tt      r t   

nc r nr   one prove induction structure c c
cl t      c iff c     definition types  c v c imply t 
thus    model   immediate consequence definition    
model     fact    regarded reduct   signature  

crucial tool analyzing properties canonical aboxes  introduce homomorphism
aboxes  let a  aboxes  abox homomorphism a  total
function h   ind a  ind a    following conditions satisfied 
a a  implies a h a   a   
r a  b  implies r h a   h b   a   
next lemma identifies central property abox homomorphisms regarding query answering 
lemma    alci tbox  q cq      q a               h abox
homomorphism a      a     q h a             h an    
proof  prove contrapositive  thus assume   a      q h a             h an    
model   a        q h a             h an     define model starting  
 
reinterpreting individual names ind a  setting ai   h a i ind a   since
individual names occur   model   model a  a a  a 
a h a   a  definition abox homomorphisms  since   model a  definition
i  follows ai ai   case r a  b  analogous  finally        q h a             h an   
definition yield     q a               thus shown       q a              

  

fiq uery p redicate e mptiness

following lemma characterizes satisfiability  aboxes w r t  existence abox
homomorphism    
lemma    let satisfiable alci tbox abox signature   abox satisfiable
w r t  iff abox homomorphism    
proof  assume satisfiable w r t    let model a  define homomorphism h
  setting h a      type realized ai i  using
definition     one see h indeed abox homomorphism  conversely  let h
abox homomorphism     lemma       satisfiable w r t    proof
lemma    shows one construct model model   using
homomorphism h  thus satisfiable w r t   

ready prove main property   regarding emptiness  discussed
beginning section 
theorem    let satisfiable alci tbox abox signature  cq q empty
given iff certt  at    q     
proof  direction follows directly fact   satisfiable w r t   by
lemma      direction  let certt  at    q      show q empty given  
take  abox satisfiable w r t    lemmas        certt  at    q    implies
certt  a  q      required 

employ theorem    prove ne xp ime upper bounds iq query emptiness 
theorem    alci  iq query emptiness ne xp ime 
proof  let satisfiable tbox  abox signature  a v  iq emptiness
given decided  employ following 
fact  abox a        a a   exists model ai   ai
 i    ind a       t    
proof fact        a a   exists model j aj   aj  
may assume  aj   ind a   disjoint domain tt    interpretation   
defined proof lemma     where assume         define union
restriction j  aj   ind a   interpretation    expanded adding ri
pairs
 aj   t  tj  aj    r t  ind a   tt     
 t  aj    r tj  aj    ind a   tt     
model ai   ai required size  finishes proof fact 
ne xp ime algorithm computes canonical abox    in exponential time  guesses
every ind at     model ia  ia    ind at          t     algorithm returns yes
ind at     
   ia model    
  

fibaader   b ienvenu   l utz     w olter

   aia   aia  
conditions checked exponential time  thus  theorem    fact above 
algorithm returns yes iff a v  empty given  

note theorem   cq predicate emptiness alci ne xp ime well  cq query
emptiness alci  easily derive  e xp ime upper bound using   results
work calvanese et al         complexity query answering dls 
theorem    alci  cq query emptiness  e xp ime 
proof   e xp ime algorithm obtained first computing canonical abox  
certt  at    q   checking whether latter empty  done  e xp ime since
shown work calvanese et al           a  q alci tbox 
p n 
set certt  a  q  computed time  p m  
p polynomial  size a 
n size q 

provide improved ne xp ime upper bound cq query emptiness alc 
allow us show alc three emptiness problems complexity 
theorem    alc  cq query emptiness ne xp ime 
proof somewhat technical reuses machinery fork rewritings spoilers introduced
lutz         proves combined complexity cq answering dl shq
e xp ime  concretely  show one decide emptiness cq q abox
signature given alc tbox guessing extension aet   canonical abox  
assertions prevent possible match q checking aet   satisfiable w r t 
  example  q a x   obviously suffices add a a  every individual  
 we allow complex concepts used abox   general case requires careful
analysis assertions considered additions  mentioned
fork rewritings spoilers enter picture  fact  used prove that  since
inverse roles tbox  suffices consider extensions   contain additional
individual names additional assertions taken candidate set whose size
polynomial size   q  remains show satisfiability  t   aet    
decided  non deterministically  time single exponential size q  full details
given appendix 
    lower bounds undecidability
prove matching lower bounds upper complexity bounds presented show undecidability iq query emptiness  cq predicate emptiness  cq query emptiness alcf 
undecidability proof ne xp ime lower bound proof reduction two different
tiling problems  first asks tiling finite rectangle  unbounded  size
second asks tiling  n  n  square   e xp ime lower bound cq query emptiness alci straightforward reduction query entailment alci  begin
ne xp ime lower bound 
theorem    alc  cq predicate emptiness ne xp ime hard 
  

fiq uery p redicate e mptiness

proof  proof reduction ne xp ime hard  n  n  tiling problem  instance
tiling problem given natural number n      coded unary  triple  t  h  v  
non empty  finite set tile types including initial tile tinit placed lower left
corner  h horizontal matching relation  v vertical matching relation 
tiling  t  h  v   map f                n                 n    f          tinit  
 f  i  j   f  i      j   h    n     f  i  j   f  i  j       v j    n   
ne xp ime complete decide whether instance  n  n  tiling problem tiling 
reduction  let n      t  h  v   instance  n  n  tiling problem
   t            tp    construct signature tbox alc  t  h  v  
solution selected concept name cq predicate empty given  
proof  convenient impose una 
formulating reduction tbox  use role names x represent  n  n grid two binary counters x counting    n    counters use concept
names x            xn  y            yn  bits  respectively  contains following wellknown inclusions stating value counter x            xn  incremented going
x successors value counter y            yn  incremented going y successors 
k              n   

u

 j k





 j k

xj v  xk x xk   u  xk x xk  

xj v  xk x xk   u  xk x xk  

similarly y            yn  y  states value counter x change
going y successors value counter change going xsuccessors               n   
xi v y xi  

xi v y xi

yi v x yi  

yi v x yi  


addition  states counter x  n    x successor
counter  n    y successor 
x  u u xn  v x  

y  u u yn  v y  

states tinit holds        tiling complete 
x  u u xn  u y  u u yn  v tinit  
states tiling condition violated  true 
    j p  ti u tj v a 
  i  j p  ti   tj     h  ti u x tj v a 
  i  j p  ti   tj     v   ti u y tj v a 
  

 v



 ip

ti  

fibaader   b ienvenu   l utz     w olter

finally  since cannot use negation aboxes  states concept names x             x n 
            n  equivalent x            xn  y            yn    respectively   
           n   
xi v x   xi v x   yi v   yi v x  
set    x  y  x            xn    y            yn    x             x n                n    show
claim   t  h  v    n  n  tiling iff exists  abox satisfiable w r t 
     v a v  
proof claim  assume first  t  h  v    n  n  tiling  construct a  regard
pairs  i  j     n j    n individual names let x  i  j    i      j  
   n   y  i  j    i  j       j    n    set xk  i  j  kth bit
   x k  i  j  kth bit    yk  i  j  kth bit j    k  i  j 
kth bit j    readily checked satisfiable w r t       v a v  
conversely  assume  t  h  v    n  n  tiling given f                n   
             n    t  let  abox satisfiable w r t    show       v a v  
let model a  ai     done  otherwise re define interpretation
t            tp follows  associate every uniquely determined pair  id   jd  
given values counters x i  set tki iff f  id   jd     tk let
ai     readily checked resulting interpretation still model a 

follows preceding result iq query emptiness cq query emptiness
alc alci ne xp ime hard  cq query emptiness alci  easily derive
 e xp ime lower bound results complexity query entailment alci 
theorem    alci  cq query emptiness  e xp ime hard 
proof  shown lutz        cq entailment alci  e xp ime hard already
aboxes form  a a   boolean cqs  clearly strengthened empty
aboxes  replace a a  empty abox compensate adding tbox   v
r a r fresh role name  thus remains observe boolean cq q entailed
empty abox iff q non empty    

show simple addition functional roles alc leads undecidability cqpredicate emptiness  thus iq query emptiness cq query emptiness  proof
reduction tiling problem asks tiling rectangle finite size  which neither
fixed bounded   reduction involves couple technical tricks using concept
names universally quantified second order variables  allows us enforce
grid structure using standard frame axioms modal logic  which second order nature  
reduction requires role names functional inverse functional  since inverse
functionality cannot expressed alcf  use modal logic frame axiom enforce
different   forwards  functional role name interpreted inverse role name
interested in  course  undecidability carries variants alcf use concept
constructor     r  instead functional roles additional sort  dls qualified
unqualified number restrictions 
theorem    alcf  cq predicate emptiness undecidable 
  

fiq uery p redicate e mptiness

instance aforementioned tiling problem given triple  t  h  v   non empty 
finite set tile types including initial tile tinit placed lower left corner final tile
tfinal placed upper right corner  h horizontal matching relation  v
tt vertical matching relation  tiling  t  h  v   map f               n             m 
n     f          tinit   f  n  m    tfinal    f  i  j   f  i      j   h   n 
 f  i  j   f  i  j       v   m  undecidable whether instance tiling problem
tiling 
reduction  let  t  h  v   instance tiling problem    t            tp   
construct signature tbox  t  h  v   solution selected
concept name cq predicate non empty given  
abox signature    t            tp   x  y  x     t            tp used concept
names  x  y  x   functional role names  use role names x represent horizontal vertical adjacency points rectangle  role names x
simulate inverses x y    use additional auxiliary concept names  particular u
r mark upper right border rectangle  zc     zc     zx     zx     zy     zy   serve
second order variables  c serves flag indicates grid cells closed position
set  ix iy similar flags intended behavior role names x  x
y    concept name propagated grid upper right corner lower
left one  ensuring flags set everywhere  every position grid labeled
least one tile type  horizontal vertical matching conditions satisfied 
lower left corner grid reached  set flag  query v a v  asks
for 
tbox defined set following cis   ti   tj   t    range triples
 ti   tj   h  ti   t    v   e  c  x  y   ranges
boolean combinations concept names ze   ze     i e   concepts l  u l  li
ze i ze i  
tfinal v u u u r
x  u u u tj   u ix u ti v u u
y  r u u t    u iy u ti v r u
x  tj u u y y   u y  t  u u x y   u ix u iy u c u ti v
u tinit v
bx u x x  bx v ix
u y y  by v iy
x y bc u y x bc v c
u v y  r v x  u v x u

r v y r



 s tp

ts u tt v

cis ix iy responsible enforcing x inverse x inverse
y  least abox individuals interested in  fact  abox contains
assertions x a  b  x  b  c  thus violates intended interpretation x x  
interpret zx   zx   left hand sides possible instantiations ci
ix violated  e g  making zx   zx   true a  false c  abox contains
x a  b   x  b  a   possible  since x functional  thus enforce x
  

fibaader   b ienvenu   l utz     w olter

inverse functional  cis c achieve similar way closing grid cells  i e  
x y successor y x successor every relevant abox individual coincide  however 
seen proofs  works x inverse functional 
establish theorem     suffices prove following lemma  see appendix details  
lemma     t  h  v   admits tiling iff  abox satisfiable
     v a v  

   el horn extensions
study query predicate emptiness dl el several horn extensions  first 
show that  plain el  three emptiness problems decided polynomial time  reason
case  exponential size canonical abox   section   replaced
total  abox contains single individual instance  predicates 
note satisfiable w r t  el tbox el cannot express unsatisfiability 
approach works eli  case one obtains e xp ime upper bound
optimal since subsumption eli already e xp ime hard  baader et al               
soon unsatisfiability expressed  situation changes drastically  fact  show
even el subsumption standard reasoning tasks still tractable   all versions
of  emptiness e xp ime hard  nevertheless  emptiness horn extensions el turns
easier emptiness expressive dls  contrast undecidability result alcf
ne xp ime hardness result alc  emptiness e xp ime even horn alcif 
reason unraveling tolerance horn description logics observed work lutz
wolter         implies looking aboxes witness non emptiness 
restrict tree shaped ones  enables use automata theoretic techniques
decide emptiness 
    el eli
begin showing el  cq query emptiness  cq predicate emptiness  iq query
emptiness pt ime  proofs transparent simple  signature   total
 abox     a a        r a       r   
lemma    let el tbox signature  cq q empty given iff
certt  a  q     
proof  proof simplified version proof theorem      contrapositive the 
direction follows fact satisfiable w r t    direction  let
certt  a  q      show q empty given   take  abox a  define abox
homomorphism setting h a     ind a    lemmas       
certt  a  q    implies certt  a  q      required 

lemma    provides polytime reduction cq query emptiness  and  therefore  iq query
emptiness cq predicate emptiness  query evaluation problem cqs  
appendix  show due simple shape   checking whether certt  a  q   
done polynomial time  fact  give polytime procedure either returns certt  a  q   
succeeds constructing boolean forest shaped query qb empty given iff q is 
  

fiq uery p redicate e mptiness

construction relies fact that  immediate consequence results proved lutz
wolter         emptiness q given implies existence model
certt  a  q    shape tree extended reflexive loops root 
checking       qb requires answer concept queries extension elu el
universal role  possible pt ime  lutz   wolter         obtain following
result 
theorem    el  iq query emptiness cq query emptiness decided pt ime 
matching pt ime lower bound theorem    shown reduction subsumption
el  pt ime hard  haase         consider el tbox el concepts c d 
ci c v follows if  if  iq b v  non empty signature  a 
given tbox  a v c  v b   a  b concept names appear c 
  thus  obtain
theorem    el  iq query emptiness cq query emptiness pt ime hard 
observe lemma   materializability el obtain cq predicate emptiness
pt ime complete well el 
note need little proof lemma    go through  suffices total
 abox satisfiable every tbox  thus reduce emptiness query answering
total  abox extension el unable express contradictions  another
important example  consider eli  since cq evaluation eli e xp ime complete 
obtain e xp ime upper bound case  matching lower bound obtained
e xp ime hardness subsumption eli simple reduction subsumption iq query
emptiness given above 
theorem    eli  iq query emptiness cq query emptiness e xp ime complete 
follows lemma   materializability eli cq predicate emptiness e xp imecomplete eli 
    horn extensions involving negation functionality
simplest extension el express unsatisfiability el   begin showing
iq emptiness el e xp ime hard  thus significantly harder subsumption instance checking  both decided polynomial time   end  first show
decide iq query emptiness el sufficient consider emptiness w r t  directed treeshaped aboxes  abox called directed tree shaped following conditions hold 
   directed graph gda    ind a     a  b    r a  b  a   tree 
   a  b ind a   one role name r r a  b  r b  a 
 and one case  
proposition    instance query b v  non empty signature given el  tbox iff
exists directed tree shaped  abox satisfiable w r t       b a 
root a 
  

fibaader   b ienvenu   l utz     w olter

proof  provide sketch since result follows general proposition    proved below  assume b v  non empty given   find  abox
satisfiable w r t       b a   let potentially infinite abox obtained
unfolding follows  individuals words a  r  rn  a   
ri  ai   ai         n  include a a  r  rn    iff a an  
include r a  r    a  r  rn an     rn  an   an     a  one show satisfiable w r t  since is       b a  iff      b a   compactness first order
consequence  obtain finite abox a    a     b a   a  required 

theorem    el   iq query emptiness e xp ime hard 
proof  let     b v  given  proposition     b v  non empty given iff
exists directed tree shaped  abox witness non emptiness b v 
given   directed tree shaped  aboxes viewed el concepts using symbols
only  vice versa  thus  witness  abox exists iff exists el concept c using
symbols c satisfiable w r t     c v b  following
established carefully analyzing reduction underlying theorem    work lutz
wolter         given el  tbox   signature   concept name b  e xp ime hard
decide exists el concept c using symbols c satisfiable
w r t     c v b  establishes e xp ime hardness non emptiness  using fact
e xp ime   coe xp ime  hardness result transfers iq query emptiness 

observe lemma   materializability el obtain cq predicate emptiness
e xp ime hard well el  
instead proving matching e xp ime upper bound emptiness el  
expressive horn dl horn alcif  el fragment  fact  rest
section devoted proof following theorem  interesting contrast result
undecidability emptiness alcf 
theorem    horn alcif  cq query emptiness e xp ime 
strategy proof theorem    follows  first exhibit polynomial time reduction
cq query emptiness horn alcif cq query emptiness elif   then  show
non emptiness cq q elif  tbox always witnessed aboxes certain 
forest like shape  consider canonical models forest shaped aboxes  and tbox
consideration   constructed chase like procedure special kind
materialization  cf  section     is  answers returned model precisely certain
answers  central observation matches q canonical models forest shaped aboxes
grouped equivalence classes induced certain splittings q  finally
show construct  equivalence class  tree automaton decides existence
forest shaped witness abox whose canonical model admits match q falls class 
throughout proof  generally impose una 
begin reduction cq query emptiness elif   fact  reduction even
shows suffices consider elif  tboxes normal form  mean
cis take one forms
a  u u v b 

v r b 
  

r a v b 

fiq uery p redicate e mptiness

a  a              b nc       r role name inverse role 
proposition    every horn alcif tbox   abox signature   cq q  one construct
polynomial time elif  tbox   normal form q empty given iff q
empty given    
proof proposition    standard given appendix  follows  assume
elif tboxes normal form 
next define canonical models  let  t   a  elif kb satisfiable
w r t    construct  typically infinite  canonical model  a  t   a   start viewed
interpretation  is   a   ind a   ait  a    a   a a  a   rit  a     a  b   
r a  b  a   exhaustively apply following completion rules 


   a  u u v ai  a   n 
  ait  a   add
ait  a  
   r a v b    d  e  rit  a   e ait  a  
  b  a   add b  a  
   v r b   ait  a   either
   r b it  a funct r   
 






 a

 a

 a

 a

 a
 r   
  add  d  e  r
e

b
  e fresh
element 
  b  a   add e
   v r b   funct r    ait  a    d  e  rit  a   e


 a
b
 
construction rendered deterministic using ordering inclusions domain
elements decide among different possible rule applications  reason  may speak
canonical model  call model u universal homomorphism u
model a  is  function h   u au implies h d  ai  
 d  e  ru implies  h d   h e   ri   h au     ai ind a   important
property  a universal   fact  following standard prove omit
details  see example work lutz wolter        
lemma    let elif  tbox abox satisfiable w r t     a
universal model  t   a  
let elif tbox  abox satisfiable w r t    easy consequence
lemma     abox witness cq q non empty given
satisfiable w r t  match q  a  
next step proof theorem    establish proposition constrains shape
aboxes considered deciding emptiness elif   follows 
abox called tree shaped
   undirected graph ga    ind a     a  b    r a  b  a   tree 
   readers wondering relationship universal models materializations defined section   
remark every universal model tbox abox materialization a  conversely 
materialization a  exists universal model  lutz   wolter        

  

fibaader   b ienvenu   l utz     w olter

   a  b ind a   one role name r r a  b  r b  a  a 
one case 
working tree shaped aboxes  often designate one individuals root 
root tree shaped abox fixed  use a a denote restriction
individuals b whose unique path root ga contains a  call b ind a 
r successor  resp  r  successor  ind a  r a  b  a a  resp  r b  a  a a   
consider  rooted  tree shaped interpretations tree shaped queries  defined analogously
tree shaped aboxes 
 abox forest shaped aboxes a    a            ak following
conditions satisfied 
   union a    a            ak  
   k  ind a     
       j k  ind ai   ind aj      ind ai   ind a         
     k  ai tree shaped abox rooted individual ind a    
call a  root component a            ak tree components  width k 
degree smallest number n every tree component ai every ind ai   
number assertions r a  b  r b  a  ai bounded n  following proposition
clarifies role forest shaped aboxes witnesses non emptiness 
proposition    let elif  tbox  abox signature  q cq  q non empty
given   witnessed  abox forest shaped  width  q  
degree  t   
proposition    proved appendix taking witness  abox a  selecting part
size  q  identified match q serves root component forest shaped
abox  unraveling infinite abox starting selected part  afterwards removing
unnecessary individual names obtain desired degree  finally applying compactness
make resulting witness finite 
clearly  assume w l o g  forest shaped witness aboxes according proposition     individual names used root component taken fixed set ind cardinality
 q   make assumption without notice follows 
next analyze matches forest shaped aboxes  using splitting query components  similar splittings queries used appendix b  simpler  forest
splitting cq q tuple f    q     q    q            qn     q   obtained q identifying variables  q    q            qn partition atoms q       var q    ind
following conditions satisfied
   q            qn tree shaped 
   var qi   var q        n 
   var qi   var qj         j n 
  

fiq uery p redicate e mptiness

let elif  tbox  forest shaped abox root component a    match
q  a   note  a consists extended  potentially infinite  trees attached
abox individuals generated completion rules  type f  
 q     q    q            qn     q   obtained q identifying variables sends
element  q  consists atoms q   matches a   part  a   q            qn
maximal connected components q     q    restriction range ind  note
that  matter match choose  maximal connected components q     q  must
tree shaped match tree shaped part  a   consists tree component
plus attached trees generated completion rules  thus every match type
following immediate  wt  q f denotes set forest shaped  aboxes width
 q  degree  t   admit match q type f  
lemma    let elif  tbox  abox signature  q cq  q empty
given wt  q f empty every forest splitting f q 
on  let elif  tbox normal form  abox signature  q cq 
assume want decide whether q empty given   lemma     suffices check
whether wt  q f empty every forest splitting f q 
note defining set wt  q f possible definition forest splitting
refer particular abox  turn due use fixed set individual
names ind root components forest aboxes  fact  first quantifying forest splittings
lemma    quantifying forest shaped aboxes  when testing emptiness
wt  q f   essential obtaining single exponential time upper bound  since number
forest splittings single exponential  q   obtain bound test emptiness
wt  q f time single exponential  t      q   achieve constructing 
forest splitting f q  two way alternating parity automaton infinite trees  twapa  af
accepts non empty language wt  q f      note infinite trees needed
automata take trees input represent  finite  forest shaped  abox a 
 potentially infinite  model  
start introducing necessary background twapas  let
denote positive
integers  tree non empty  and potentially infinite  set closed prefixes 
node root   use standard concatenation words  nodes trees  and 
convention  take x     x  x i      x x   note  
undefined     node x said child node x  x called parent
x i  slightly depart vardis original definition twapas  vardi        working
trees full  is  define m ary tree tree whose nodes
 rather exactly  children  w l o g   assume nodes m ary tree
            m    infinite path p prefix closed set p every n   
unique x p  x    n 
set x  use b    x  denote set positive boolean formulas x  i e  
formulas built using conjunction disjunction elements x used propositional variables  special formulas true false allowed well  alphabet  
 labeled tree pair  t  v   tree v   node labeling function 

n

n

n
n
n

definition     twapa  two way alternating parity automaton  twapa  m ary trees
tuple    s      s    f   finite set states  finite alphabet   
  

fibaader   b ienvenu   l utz     w olter

b    tran a   transition function tran a     hii   i                 m   set
transitions a  s  initial state  f    g            gk   sequence subsets
satisfying g  g        gh   s  called parity condition 
intuitively  transition  hii  s      means copy automaton state sent
i th successor current node  required exist  contrast  transition   i   s 
sends copy i th successor exists  transitions  hii  s    i   s        
interpreted similarly   indicates sending copy predecessor   indicates sending
copy current node  note transition  h i  s  cannot applied root 
definition     run  acceptance  run twapa    s      s    f    labeled tree
 t  v   s labeled tree  t             s       y     x  s 
 s  v  x     implies  possibly empty  set   d    s              dn   sn    tran a 
satisfies   n 
   di   hji  x j defined  x j      y i     x j  si   
   di    j  x j defined belongs    y i     x j  si   
given infinite path p   denote inf p   set states q infinitely
many p  y  form  d  q   say run  t     accepting
infinite paths p   exists even k inf p   gk    inf p   gk     
 labeled tree  t  v   accepted accepting run  t  v    use
l a  denote set  labeled trees accepted a 
note original definition twapas  vardi        uses transitions form
 hii  q              m   since  hii  q    i   q  coincide full m ary trees  easy
see emptiness version twapas reduced polynomial time emptiness
twapas original definition since encode m ary trees full m ary trees  vardi       
shown emptiness problem twapas e xp ime complete  precisely 
algorithm that  given twapa    s      s    f    decides whether l a    runs
time exponential cardinality polynomial cardinality size  
remind reader given two twapas a  a  ai    si       s  i     
easy construct  in polynomial time  twapa l a    l a    l a   
state set s  s   
make accessible twapas  encode forest shaped  aboxes width  q 
degree  t   m ary trees     q   t    already mentioned 
tree additionally encodes model encoded abox  explain alphabet used
shape trees detail  root node labeled element alphabet
r consists sig t   aboxes  i  ind a  ind   ii  r a  b  implies r  
 iii  satisfies functionality statements   let sub t   denote set concepts
occur subconcepts  non root nodes labeled elements alphabet n
consists subsets
 nc sub t       m      r  r   r nr occurs     ind    a   b v r a  
  

fiq uery p redicate e mptiness

contains  i  exactly one role name inverse role   ii  one element ind 
 iii  either role name inverse role exactly one element form and 
latter case  a 
tree ht   i   labeling described supposed represent forest shaped abox aht  i together model iht  i abox   individuals aht  i
abox labels root   plus non root nodes whose label contains
marker   nodes denote domain elements iht  i identified
abox individual  assertions aht  i concept role memberships iht  i
represented labels ht   i  note abox sig t   abox whereas aht  i uses
signature   fact   assertions part aht  i assertions
part iht  i  
need impose additional conditions make sure r n  labeled tree ht   i
indeed represents abox model intended  call ht   i proper satisfies following
conditions x  
   root labeled element r nodes element n  
     x  n contains element ind a  x child root   element
ind otherwise 
   take path remove root node  because carries special label  
nodes whose label contains form finite  possibly empty  prefix resulting path 
   child x   y  n   b v r a one
following true 
 a  x root  b   x  r   y  
 b  x root ind  b a    x   a  r    y  
roles individual names element labels describe elements connected
elements via roles aht  i iht  i   particular  successor root contains
role r individual name ind  node represents r successor a  label
elements form serve special marking purpose    x   means
element x  which part iht  i aht  i since   x  cannot contain  
satisfy concept inclusion b v r a  later need special markers make
sure iht  i model aht  i   materialization aht  i  
explanations subsequent definitions  three conditions imposed elements
four conditions used define properness make sense reader 
let ht   i proper r n  labeled tree  define aht  i iht  i formally  let
abox labels root   let restriction signature  
 abox aht  i described ht   i
aht  i    a x      x  nc   x  
 r b  x     b  r      x    r x  b     b  r       x  
 r x  y    child x   x    y  r   y  
 r y  x    child x   x    y  r   y  
  

fibaader   b ienvenu   l utz     w olter

interpretation iht  i follows 
iht  i

   t       ind a 



iht  i

   a   a a  a   x     x  nc  

r

iht  i

    a  b    r a  b  a    a  x     a  r    x     x  a     a  r     x  
  x  y    child x r   y     x  y    x child r   x  

ciht  i

  c

c ind aht  i  

apart represented abox instead interpretation  aht  i identical
restriction iht  i individuals aht  i symbols   particular means
iht  i model aht  i   note abox aht  i forest shaped  abox  conversely 
forest shaped  abox width  q  degree  t    define proper
m ary r n  labeled trees ht   i aht  i   iht  i    a  
let f    q     q    q            qn     splitting q  build twapa af m ary
r n  labeled trees accepts exactly trees ht   i aht  i wt  q f  
number states af polynomial  t      q  since checked time singleexponential number states whether l af       obtain desired e xp ime upper
bound deciding whether wt  q f     construct af intersection following
twapas 
   aprop   makes sure input tree proper 
     ensures input tree ht   i iht  i model  
   awf ensures ht   i satisfies certain well foundedness condition 
   amatch guarantees  exploiting conditions ensured previous automata 
input tree ht   i aht  i wt  q f  
construction first automaton aprop straightforward  details left reader 
note that  enforce condition   proper trees  automaton needs make use parity
acceptance condition  a co buchi condition would actually sufficient   second twapa
ensures following conditions satisfied non root nodes x  x  input tree 
r a  b      funct r     a  r      x  
funct r   a  r    x    x     x   x   
funct r    x one child r   y   additionally r   x  
child y 
a  u u v  a   a            a        a a      
a  u u v  a                x     x  
v r b a a        i  b  r a  b   b b       
 ii  child x root  a  r  b    x  
  

fiq uery p redicate e mptiness

v r b   x    i   a  r     x  b a        ii  r   x 
x non root parent b   y    iii  x child  r  b    y  
r a v b  i   r a  b   a b        ii  child root
 a  r  a    y   b a      
r a v b  i   a  r     x  a a  label root   ii  r   x 
x parent   y    iii  x child  r  a    y   b   x  
working exact details aprop left reader 
ideally  would third automaton awf ensure iht  i canonical model
aht  i   however  seem easily possible model constructed
applying completion rules certain order difficult simulate automatonnote
applying rules different order might result construction interpretation
isomorphic one obtained following prescribed application order  thus define
awf achieve crucial property canonical models positive information  concept
role memberships domain elements  reason  namely contained
aht  i logically implied aht  i together   formalize terms
derivations 

let ht   i proper r n  labeled tree  a   nc sub t         x  a  ht  i  
derivation a  x  ht   i finite l labeled tree ht        i  l set pairs  a  x 
 nc sub t        x aiht  i   require root   labeled
 a    x      minimal nodes z       z     a  x   one
following holds 
       x ind aht  i   
       x  ci a  u u v children z            zn z  
    zi      ai   x    n 
       x  ci r a  v child z   z       z        a    x   
 x  x    riht  i   moreover  b   x   child z    z  
    z         b  x  
       x  ci a  v r a funct r  child z   z  
    z        a    x     x    x  riht  i   moreover  b   x   child z   
z       z         b  x  
              x   b   x   child z   z       z        b  x  
     x   ci a  v r a   child z   z       z      
 a    x     x    x  riht  i either  i  x child x     ii  x child
root  x  ind   r  x      x  
say ht   i well founded whenever x aiht  i   nc     
derivation x ht   i  hard construct twapa awf accepts precisely
well founded proper r n  labeled trees  essentially  automaton verify existence
required derivations implementing conditions     transitions  additionally
using co buchi condition ensure finiteness derivation 
next let f    q     q    q            qn      automaton amatch checks
  

fibaader   b ienvenu   l utz     w olter

   match q  iht  i
   match qi iht  i v var q    var qi     v     v  
amatch easy construct omit details  announced  define af
accepts intersection languages accepted aprop     awf   amatch   remains
show wt  q f empty iff l af   empty 
this  first clarify relation well foundedness  canonical models  universal models  call proper r n  labeled tree ht   i canonical  i  iht  i canonical
model aht  i    ii  every x         x   concept   x 
element x created due application third completion rule inclusion
form b v r a parent x  
lemma   
   proper r n  labeled tree canonical  well founded 
   ht   i proper r n  labeled tree well founded iht  i model  
iht  i universal model aht  i  
proof lemma    found appendix  point   established tracing applications
completion rules applied construct canonical model aht  i showing
addition make gives rise derivation  point    first show one
make certain uniformity assumption derivations show define homomorphism
iht  i model aht  i starting part iht  i corresponds root
component aht  i moving downwards along tree shaped parts iht  i  
lemma    wt  q f   iff l af      
proof  first assume wt  q f      forest shaped  abox width
 t   degree  q  satisfiable w r t  match q  a type f  
let ht   i m ary proper r n  labeled tree satisfies aht  i   canonical 
ht   i l aprop    since satisfiable w r t    iht  i    a model thus
ht   i l aprop    point   lemma     ht   i l awf    finally  match witnesses
conditions     definition amatch satisfied thus ht   i l amatch  
done 
conversely  assume tree ht   i l af    since ht   i l aprop      aht  i
defined  definition  forest shaped  abox width  t   degree  q  
remains show match q  a type f   since ht   i l at  
l awf    iht  i model ht   i well founded  point   lemma     iht  i thus
universal model a  ht   i l amatch    conditions     definition
amatch satisfied  verified that  consequently  match q iht  i
type f   composing homomorphism iht  i  a   exists since iht  i
universal  yields match q  a type f  


  

fiq uery p redicate e mptiness

   dl lite family
study query predicate emptiness dl lite family description logics  calvanese
et al         artale et al          begin with  introduce dialects dl lite consider 
basic concepts b defined
b

   

 

 

 

r  

ranges nc r  possibly inverse  roles  dl litecore tbox finite
set cis form b  v b  b  u b  v   b  b  basic concepts  thus 
dl litecore included eli but  includes inverse roles  included el  dl litef
extension dl litecore functionality statements  dl liter extension dllitecore role inclusions r v s  r  roles  dl liter logical underpinning
owl profile owl  ql  motik et al          finally  dl litehorn extension dl litecore
conjunctions basic concepts left hand side cis  alternatively  defined
fragment eli qualified existential restrictions r c replaced unqualified existential
restrictions r    details  refer readers work calvanese et al          artale
et al          calvanese  de giacomo  lembo  lenzerini  rosati        
briefly discuss una dl lite dialects introduced above  first observe dllitehorn dl litef fragments alcif  thus  lemma    query emptiness predicate emptiness dl litehorn dl litef oblivious whether una made not 
dl liter fragment alcif  is  however  straightforward show dl liter
certain answers cqs depend whether one adopts una not  thus 
dl liter query emptiness predicate emptiness oblivious whether una made
not  following proofs make una 
main results follows  cq query emptiness conp complete dl lite dialects 
conp lower bound holds already fragment dl litecore without role names 
contrast  complexity deciding iq query emptiness cq predicate emptiness depends
whether conjunctions admitted left hand side concept inclusions not 
conjunctions admitted  as dl litecore   dl liter   dl litef    iq query emptiness
cq predicate emptiness nl og pace complete  conjunctions admitted  as dllitehorn    iq query emptiness cq predicate emptiness conp complete  again 
lower bound holds already fragments dls without role names 
note follows use theorem   gives polynomial reduction
cq predicate emptiness iq query emptiness certain dls apply dl lite
dialects  instead give direct proofs  results presented figure   dl lite dialects
straightforward consequences results established section 
begin proving conp lower bounds  let lcore dl admits cis v b
u b v   let lhorn dl admits cis u a  v b u b v  
a  a    b concept names 
theorem    lhorn   iq query emptiness  cq query emptiness  cq predicate emptiness
conp hard  lcore   cq query emptiness conp hard 
proof  proofs reduction well known conp complete problem testing whether
propositional formula conjunctive normal form  cnf  unsatisfiable  let     k
  

fibaader   b ienvenu   l utz     w olter

cnf formula  v            vn variables used   a            ak concept names representing clauses  av    av            avn   avn concept names representing literals  let
additional concept name  set    av    av            avn   avn    consider lhorn  tbox
consisting following cis 
avj u avj v   j n 
a j v ai   k  j     vj disjunct  
a  u u ak v  
straightforward show a u  empty given iff u a u  empty given
iff unsatisfiable  thus  deciding iq query emptiness  cq predicate emptiness  cq query
emptiness lhorn conp hard  conp hardness result cq query emptiness lcore  
drop last ci use cq a   u  ak  u  instead 

prove matching upper complexity bounds  considering logics dl litecore   dlliter   dl litef   dl litehorn   end  formulate general sufficient conditions
deciding emptiness pt ime conp  say dl l polysize emptiness witness property whenever cq q empty given   exists  abox
polynomial size size q satisfiable w r t  certt  a  q      
lemma    let l description logic polysize emptiness witness property
query evaluation problem cqs l np  moreover  assume satisfiability aboxes
w r t  l tboxes decided polynomial time  cq query emptiness l conp 
proof  np algorithm deciding whether cq q empty w r t  guesses  i   abox
polynomial size q   ii  tuple  a individual names ind a  appropriate
length   iii  polysize certificate  a certt  a  q   verifies polynomial time
satisfiable w r t  guessed certificate valid 

theorem    dl litecore   dl liter   dl litef   dl litehorn   deciding cq query emptiness
conp 
proof  conditions stated lemma    shown calvanese et al         artale
et al          sketch proof polysize emptiness witness property  assume  a certt  a  q 
cq q    u   v    u  tbox dls listed theorem statement
assume satisfiable w r t    use canonical model  a lemma   
 for dl litecore   dl litef   dl litehorn used without modification since
fragments elif   dl liter   one add following completion rule
construction  a    x  y  rit  a r v   add  x  y  sit  a    let
match q  a   recall  a consists restriction individuals ait  a
ind a  tree shaped interpretations ia attached ait  a   let a   set assertions
use individual names ind a  exists v var q   v    ait  a
 v  ia   moreover  individual ind a     selected exists
role r b r a  b  a  select one r a  b   include a     let a    a   a    
clearly abox a  required  polynomial size  satisfiable w r t   being subset
a   construction  satisfies  a certt  a   q  


  

fiq uery p redicate e mptiness

say dl l singleton emptiness witness property whenever cq q form
a v  v a v  empty given   exists  abox containing one
assertion satisfiable w r t  certt  a  q      
lemma    let l description logic singleton emptiness witness property
query evaluation problem cqs form a v  v a v  l nl og pace  moreover  assume satisfiability singleton aboxes w r t  l tboxes decided nl og pace 
iq query emptiness cq predicate emptiness l nl og pace 
proof  non deterministic logarithmic space algorithm deciding whether cq form a v 
v a v  empty w r t  iterates  aboxes containing one assertion
checks whether least one aboxes satisfiable w r t  satisfies      v a v 
or  respectively       a a   individual ind a  

theorem    dl litecore   dl liter   dl litef   deciding iq query emptiness cqpredicate emptiness nl og pace complete 
proof  nl og pace upper bound  conditions stated lemma    shown
calvanese et al         artale et al          sketch proof singleton emptiness
witness property  assume  a certt  a  q  cq q form a v  v a v  tbox
dls listed theorem statement  assume satisfiable w r t   
consider case q   v a v   case q   a v  similar  proof theorem    
use canonical model  a   let mapping  a  v  ait  a
consider uniquely determined ind a   v    ait  a  v  ia   using
fact conjunctions occur left hand side cis   one show exists
single assertion form b a  r a  b  abox a  consisting assertion 
   certt  a   q   follows a  desired witness abox 
matching lower bound follows directly fact deciding whether    v b
nl og pace hard tboxes dl litecore  artale et al         


   case study application modularity
demonstrate usefulness emptiness two ways  first  carry case study
predicate emptiness medical domain  find use realistic ontology adds
significant number non empty predicates abox signature large
number predicates empty  static analysis  thus potentially non trivial user
manually distinguish non empty empty predicates  second  show  predicate 
emptiness used produce smaller version tbox tailor made querying
given abox signature  in sense  module tbox   replacing potentially
much smaller module facilitates comprehension tbox  thus helping query formulation 
support claims experiments 
case study  use comprehensive medical ontology snomed ct  provides
systematic vocabulary used medical information interchange enable interoperable electronic health records  covers diverse medical areas clinical findings  symptoms  diagnoses  procedures  body structures  organisms  substances  pharmaceuticals  devices specimens 
  

fibaader   b ienvenu   l utz     w olter

concepts roles

iq
cq axioms
axioms
non empty non empty  mod  cq  core

   

  

    

    

    

    

   

  

    

    

    

    

    

  

    

    

     

    

    

  

    

    

     

    

    

  

     

     

     

     

    

  

     

     

     

     

     

  

     

     

     

     

     

  

     

     

     

     

figure    experimental results
snomed ct formulated el extended role inclusions  which removed experiments   contains         concept names    role names  use snomed ct
together abox signature real world application randomly generated abox
signatures  real world signature obtained analyzing clinical notes emergency
department intensive care unit two australian hospitals  using natural language processing methods detect snomed ct concepts roles   contains       concepts    roles 
signature         iq non empty predicates        cq non empty predicates
computed  thus  snomed ct provides substantial number additional predicates query
formulation  roughly identical number predicates abox signature  however 
numbers show majority predicates snomed ct cannot meaningfully used
queries  aboxes  thus identifying relevant ones via predicate emptiness potentially
helpful  somewhat surprisingly  number cq non empty predicates    
higher number iq non empty symbols 
analyzed randomly generated signatures contain                          
concept names       role names          role names ontology   every
signature contains special role name role group  used snomed ct implement
certain modeling pattern present aboxes allow pattern there 
number concept role names  generated    signatures  columns iq nonempty cq non empty figure   show results  numbers averages
   experiments size  additional experiments confirm findings real world
signature  case  substantial number additional predicates becomes available query
formulation  large number predicates empty 
come application modularity  recall main motivation studying
emptiness support query formulation  tboxes large complex  difficult
understand whether tbox contains sufficient background knowledge given query q
non empty answer  abox  case  clearly make sense
   see current collaborative projects health information technologies research laboratory university
sydney  hitrl        

  

fiq uery p redicate e mptiness

pose q  abox tbox used background ontology  similarly 
hard find whether tbox sufficiently powerful entail given predicate occur
query non empty answer  abox  again  case 
predicate used formulating queries  here  go one step further  instead
using emptiness directly support query formulation  use simplify tbox 
precisely  consider problem extracting  hopefully small   subset given tbox
gives exactly answers cqs  or iqs   abox  subset called
 substitute w r t  cq  or iq  respectively  original tbox replace original
tbox answering cqs  or iqs  respectively   working small  substitute instead
original tbox supports comprehension tbox thereby formulation meaningful
queries 
beyond scope paper investigate  substitutes depth  instead  show that 
description logic eli  predicate emptiness gives rise particularly natural kind substitute call cq  core  cq  core obtained removing concept inclusions
contain predicate cq predicate empty w r t  tbox  thus 
cq  core give answers cqs original tbox  aboxes 
appealing property predicates occur used meaningfully cq
querying  aboxes 
show widely known semantic  modules introduced grau et al        
 substitutes cq  cores cannot larger semantic  modules  unless original
ontology contains tautological concept inclusions   evaluate method practice compare
size cq  cores  modules  extend case study based snomed ct
extraction cq  cores comparison  modules  start defining  substitutes
formal way 
definition    let   q  iq  cq      substitute w r t  q
 aboxes q q  certt    a  q    certt  a  q  
aware  substitutes according definition    studied before 
closely related types modules  example   modules give answers
cqs formulated signature  aboxes studied work lutz wolter        
kontchakov  wolter  zakharyaschev         konev  ludwig  walther  wolter         botoeva  kontchakov  ryzhikov  wolter  zakharyaschev               romero  kaminski 
grau  horrocks         stronger version module provided  modules require original tbox model conservative extension module regarding signature
  studied konev  lutz  walther  wolter        gatens  konev  wolter        
however  important difference  modules  substitutes
latter restrict signature abox  queries  contrast  mentioned
 modules guarantee answers cqs formulated signature  and  aboxes  
particular  follows minimal modules  defined work kontchakov et al        
konev et al          general used  substitute 
show eli  and  therefore  fragment el  one use cq predicate
emptiness straightforward way compute  substitute w r t  cq  let tbox
abox signature  cq  core   denoted tcq   set concept inclusions
x sig   cq predicate empty given  

  

fibaader   b ienvenu   l utz     w olter

theorem    let tbox eli  cq  core  substitute w r t  cq
 and thus w r t  iq  
proof  let   cq  core assume         q  a   abox a  consider
canonical model    a   introduced section         a model   a 
   a     q  a   sufficient show    a model   let c v    
assume    a     c v d  c    a      let qc  v  tree shaped conjunctive
query corresponding c  constructed standard way  see appendix b formal definition
similar construction      a    v qc  v         v qc  v   hence     
v qc  v  x sig c  cq empty given   since c v  
obtain      v qd  v   qd  v  tree shaped conjunctive query corresponding d 
thus  x sig d  cq empty given   means c v    
contradiction 

note theorem     cq  core computed polynomial time el tbox 
make simple observations regarding cq  cores 
   theorem    fails dls admit negation  example     a v b  b v e 
   a    substitute w r t  cq coincides   cq  core
empty 
   cq  core always minimal  substitute w r t  cq  consider  example   
 a v b    v b    b  v b    let    a        a v b    v b   
 substitute w r t  cq cq  core coincides  
   let iq  core tbox defined analogy cq  core   based iqemptiness instead cq emptiness  iq  core cannot serve  substitute
w r t  iq even el tbox  example  let    a v r b  r b v e 
   a   b iq empty given iq  core empty  however 
empty tbox  substitute w r t  iq since      e a     a a   
interestingly  contrast  modules discussed above   modules introduced grau
et al         turn examples  substitutes  define  modules  let signature 
 
 
two interpretations   coincide w r t    x   x x  
subset   tbox called semantic  module w r t  every interpretation
 
interpretation   coincides w r t  sig t     x   x  
sig t     model       shown work grau et al         extracting minimal
semantic  module complexity standard reasoning  that is  subsumption  
addition  shown syntactic approximation called syntactic  module computed
polynomial time  every syntactic  module semantic  module  necessarily
way around   following lemma establishes relationship  modules substitutes  concept inclusion c v tautological    c v d 
proposition    let tbox formulated dls introduced paper  let  
semantic  module w r t   
      substitute w r t  cq 
  

fiq uery p redicate e mptiness

   sig t     contains predicates cq empty given  
   eli tbox contain tautological cis  cq  core
contained    
proof  point    suppose         q  a     semantic  module w r t 
 abox  let model       q  a   consider interpretation  
coincides   sig t     x   remaining predicates x 
  model since   semantic  module w r t      model since
 abox  since shrank extension predicates transitioning  
    q  a         q  a   hence       q  a   required 
point    assume x cq empty given   x   sig t      suppose x  
concept name  the case x   r role name r similar left reader   take
 abox satisfiable w r t       v a v   let model  t   a  
 
let   interpretation coincides sig t      
 
remaining  in particular ai      definition semantic  modules    model
 t   a   derived contradiction   shows       v a v  
point    assume formulated eli contains tautological inclusions  let c v
      then  definition semantic  modules  sig c v d  contains predicate
x   sig t      because otherwise c v tautology   thus  point    sig c v d 
contains predicate cq empty given   c v cq  core  
required 

point    use algorithms computing syntactic semantic  modules
ones provided work grau et al         find  substitutes large variety dls 
point    modules provide over approximation set predicates
cq empty  finally  point   means that  eli   modules cannot smaller cq  core
unless tautological concept inclusions  general  however   modules larger
cq  core tbox  following example shows case already acyclic
el tboxes  let
   a v s   r     u s   r      b r     u r     
   a   predicates cq empty given a  s    s    r    r    hence
cq  core contains first ci   however  non trivial semantic  modules
w r t   and thus syntactic ones either  
demonstrate potential usefulness  substitutes cq  core extending
case study medical domain  use ontology snomed ct abox
signatures described beginning section  analyzing size cq  core comparing size original ontology syntactic  module  real world
signature  cq  core contains                concept inclusions snomed ct  thus 
   size original ontology   module w r t  turns significantly
larger cq  core  containing        axioms  random signatures  sizes cq cores  modules shown two right most columns figure    confirm
findings real world signature  cq  core much smaller original ontology
 module 
  

fibaader   b ienvenu   l utz     w olter

q uery c ontainment

q uery e mptiness

dl

iq

cq

iq

cq

el

e xp ime c 

e xp ime c 

pt ime c 

pt ime c

el

e xp ime c 

e xp ime c 

e xp ime c 

e xp ime c

eli  horn alcif

e xp ime c 

 e xp ime c 

e xp ime c 

e xp ime c 

pt ime

conp c 

nl og pace c 

conp c 

conp c 

p   c 

conp c 

conp c 

ne xp ime c 

ne xp ime h  

ne xp ime c 

ne xp ime c 

ne xp ime c 

 e xp ime c 

dl litecore
dl litehorn
alc

 ne xp ime
alci

ne xp ime c 

 ne xp ime c 

figure    query containment vs query emptiness

   related work
query emptiness fundamental problem static analysis database queries 
called query satisfiability problem  xml  example  takes following form  given
xpath query p dtd d  exist xml document conforms
answer p non empty  complexity problem ranges tractable
undecidable depending xpath fragment  see e g  work benedikt et al        
references therein  dl context  query emptiness first considered work lubyte
tessaris         use step guide enrichment ontologies 
query emptiness problem studied paper special case following query
containment problem  first considered work bienvenu  lutz  wolter        
regard pair  t   q  consists tbox query q compound query q  called
ontology mediated query  omq   answers q certain answers q w r t 
 bienvenu et al          take two omqs qi    ti   qi            q  q  iqs
cqs arity  q   contained q    abox signature   aboxes satisfiable w r t  t  t    certt   a  q    certt   a  q     case 
write q  q    notion containment generalizes traditional query containment
problem dls  calvanese et al         relativizing abox signature admitting
distinct tboxes t  t    query emptiness iq q given clearly polynomially
reduced  containment setting t      q    q  t      q    a x  fresh concept
name a  similarly cqs  deciding  containment  however  often computationally harder
deciding query emptiness  table   summarizes known results  results el dllite work bienvenu et al          results eli work bienvenu 
hansen  lutz  wolter         results alc alci work bienvenu
et al         bourhis lutz        
query emptiness closely related explaining negative answers queries  problem
studied  example  calvanese  ortiz  simkus  stefanoni         adopting abductive reasoning approach  described follows  assume       q  a  tbox   abox
a  query q  explain  a answer q  one wants find minimal aboxes e
  

fiq uery p redicate e mptiness

certain signature interest e satisfiable w r t    e    q  a  
 aboxes e regarded explanation missing answer used debugging purposes  shown work calvanese et al         query emptiness iqs
boolean cqs reduces  under many one logarithmic space reductions  problem deciding
existence explanation       q  a      dl litea   reduction even works
unions conjunctive queries arity  calvanese et al         use observation obtain
lower complexity bounds explaining negative query answers  exploiting results published
conference predecessor paper  baader  bienvenu  lutz    wolter        
conjecture that  conversely  techniques proving upper complexity bounds query emptiness
 such ones paper  used obtain upper bounds explaining negative answers 

   conclusion
investigated computational complexity query predicate emptiness el 
dl lite  alc families dls  concentrating instance queries conjunctive queries
showing complexities range nl og pace undecidable  highlighted that 
different dls query languages  different kinds witness aboxes sufficient establish
non emptiness  dls queries considered paper  would interesting
investigate future work  include following 
dls include transitive roles  role inclusions  symmetric roles  role inclusion axioms
 horrocks  kutz    sattler        kazakov        
cases  straightforward reductions results presented paper possible 
example  iq query emptiness horn shif decidable e xp ime since every
horn shif tbox   iq a x   abox signature   one construct polynomial
time horn alcif tbox        a a  iff     a     a a   aboxes
 hustadt et al         kazakov         cases  cq query emptiness
horn shif  seems reduction 
dls include nominals 
important classes queries unions conjunctive queries  ucqs  
materializable dls horn alcif 
w ucq query emptiness reduced cq
query emptiness since every ucq q   ii qi   x        q  a  iff
     qi   a   simple reduction work non horn dls
alc 
would interesting develop practical algorithms emptiness evaluate algorithms real world ontologies queries  note algorithms el dl lite
easily implementable efficient presented paper  actually confirmed
case study section    work required design efficient algorithms expressive dls  finally  would relevant investigate notion  substitute introduced
application modularity detail  example  open question compute minimal  substitutes expressive dls alc practice  involved
complexities 
  

fibaader   b ienvenu   l utz     w olter

acknowledgements
first author partially supported cfaed  center advancing electronics dresden 
second author partially supported anr project pagoda  anr    js           
grateful julian mendez dirk walther supporting us case study  would
thank anonymous reviewers provided excellent comments helped us improve
paper 

appendix a  proofs section  
formulate result proved again 
lemma   let alcif tbox  cq q empty given una iff
empty given without una 
proof  consider cq q answer variables v            vn  
 only if  assume q non empty given without una  abox satisfiable w r t  without una certt  a  q     without una 
take model suppose without loss generality infinite  define
equivalence relation ind a  setting b whenever ai   bi   choose single
representative equivalence class  denote representative equivalence
class containing a  let a  abox obtained replacing individual  
show a  satisfiable w r t  una certt  a   q     una 
regarding satisfiability  easy see model  t and  a  satisfies
una individuals appearing a    moreover  since infinite  reinterpret
individual names ni   ind a    obtain interpretation model a  satisfies
una 
showing certt  a   q     una  take  a              certt  a  q  without
una  aim show  a              certt  a   q   let j   model a 
 
satisfies una  show match q j    vi      ai  j every
 
  n  consider interpretation j obtained j   setting aj    a  j every
ind a   easy see j model without una  j    q a             
match q j  vi     aj
every   n 
desired match q j     finishes proof 
 if  assume q non empty given una   abox
satisfiable w r t  una certt  a  q     una  clearly 
satisfiable w r t  without una remains show certt  a  q     without
una  let  a              certt  a  q  una  let model without
una  show    q a               ind a   let ia following
unfolding ai  
domain ia ia consists words d  r  d  rk  dk d            dk
r            rk   potentially inverse  roles d    ai    di   di     rii   k 
ri    ri   functional ri     k  r   a  b    b ind a  r 
functional 
aia    d  r  d  dk   dk ai   nc  
  

fiq uery p redicate e mptiness

ria     d  r  d  dk   d  r  d  dk rk   dk       r   rk    
  d  r  d  dk rk   dk     d  r  d  dk     r   rk     r nr  
assume ia mutually disjoint let individual name root ia  
obtain interpretation j taking disjoint union ia   ind a   adding  a  b  rj
whenever r a  b  a  setting aj   ind a   one show j model
una  thus j    q a              match q j  vi      ai  j
every   n  verified   defined setting    vi     ai  vi     ind a 
   vi     dk  v    d            dk k   match q i  thus    q a              
required 


appendix b  proofs section  
restate first result proved 
theorem    alc  cq query emptiness ne xp ime 
general idea proving theorem    follows  given alc tbox   signature  
cq q  theorem    suffices test whether         q  thus start computing     check whether         q  guess extension set  
concept inclusions extension   set a  abox assertions   a 
satisfied models   q match  subsequently  remains
test satisfiability   a  w r t      subtlety lies selecting class extensions
guessed careful enough way final satisfiability check carried
ne xp ime 
reuse technical definitions results work lutz        proves
combined complexity cq answering dl shq e xp ime  definitions
slightly modified since lutz considers cqs without answer variables uses dl shq 
alc proper fragment  however  straightforward verify proofs given
lutz work modified definitions 
cq q viewed directed graph gdq    vqd   eqd   vqd   var q  eqd  
  v  v       r v  v     q r nr    call q directed tree shaped gdq directed tree
r v  v      s v  v     q implies r   s  q directed tree shaped v  root gdq   call v 
root q  u var q   write q u denote restriction q atoms contain
variables u   set dtrees q  directed tree shaped subqueries q defined follows 
dtrees q     q u   u   reachq  v   v var q   q u directed tree shaped 
reachq  v  set variables reachable v gdq   say
q   obtained q performing fork elimination q   obtained q selecting two
atoms r v     v  s v      v  v     v      v qvar q  v      v      identifying v  
v     
q   fork rewriting q q   obtained q repeatedly  but necessarily exhaustively  performing fork elimination 
  

fibaader   b ienvenu   l utz     w olter

q   maximal fork rewriting q q   fork rewriting fork elimination
possible q    
following shown work lutz         plays central role subsequent
definitions 
lemma    variable renaming  every cq unique maximal fork rewriting 
following definitions splittings spoilers taken work lutz  understand splitting cq q intuitive level  useful consider matches q model
tbox abox special shape  consists core part whose elements exactly
 the interpretations of  abox individuals tree shaped parts attached
element core part disjoint other  fact  proved lutz       q 
model described shape     q  match q model
described shape partitions variables q several sets  set r contains variables matched abox individual  sets s            sn represent disjoint tree shaped
subqueries q matched tree part whose root connected variable
r via role atom q  set represents collection tree shaped subqueries
q disconnected variables r si   addition partitioning  splittings
record variable r set s            sn connected abox elements
variables r mapped to  define splittings formally 
let k    t   a  alc knowledge base q cq  splitting q w r t  k tuple  
hr  t  s            sn     i  r  t  s            sn partitioning var q                 n  r
assigns set si variable  i  r    r ind a  assigns variable r
individual a  splitting satisfy following conditions 
   cq q t variable disjoint union directed tree shaped queries 
   queries q si     n  directed tree shaped 
   r v  v     q  one following holds   i  v  v   belong set r  t  s            sn
 ii  v r   i    v  v   si root q si  
     n  unique r nr r  i   v    q  v  root q si  
   avar q  r 
let q directed tree shaped cq  define alc concept cq v v var q  
v leaf gdq   cq v  
otherwise  cq v  

u

a v q

au

u c 
u r c

a v q

r v v    q

q v    

v root q  use cq abbreviate cq v  
following  allow compound concepts negated roles used abox assertions  semantics assertions corresponding kbs defined expected way 
interpretation satisfies c a  ai c satisfies r a  b  satisfy r a  b  
let   hr  t  s            sn     splitting q w r t  k q            qk  directed
tree shaped  disconnected components q t   alc knowledge base  t     a    spoiler q 
k  one following conditions hold 
  

fiq uery p redicate e mptiness

     v cqi       k 
   atom a v  q v r a  v   a   
   atom r v  v     q v  v   r r  v    v      a   
   d   i    a    n    r cq s v  root q si

r  i   v    q 
call k  spoiler q k  i  every fork rewriting q   q  every splitting q  
w r t  k  k  spoiler q     k     ii  k  minimal property  i   following
result proved work lutz        
theorem    let k    t   a  alc knowledge base q cq  k     q iff
spoiler  t     a    q k a  satisfiable w r t     
following lemma  observed lutz  plays central role obtaining ne xp ime
decision procedure 
lemma    let k    t   a  alc knowledge base  q cq  q maximal fork rewriting 
k     t     a    spoiler q k  k  contains concept inclusions abox
assertions following form 
     v cq  q   dtrees q   
   a a  ind a  occurring q 
   r a  b  a  b ind a  r occurring q 
   d a  ind a    r cq    r occurs q q   dtrees q   
note definition spoiler q k refers fork rewritings q 
exponentially many  lemma    refers unique maximal form rewriting q  
fact  since cardinality dtrees q   clearly bounded size q  number concept
inclusions assertions listed lemma    polynomial size q 
set proof theorem     theorems        cq q empty
signature given tbox iff spoiler  t     a    q  t         a 
satisfiable w r t      given cq q  signature tbox   thus decide emptiness
q given follows 
   compute    
   guess tbox   abox a  satisfy conditions     lemma    kb
k    t       role assertion r a  b    r a  b  a   
   verify  t     a    spoiler q  t       
   verify   a  satisfiable w r t     
  

fibaader   b ienvenu   l utz     w olter

remains argue yields ne xp ime algorithm  already noted  step   carried
 deterministic  exponential time  due conditions     lemma    since  
size exponential   tbox   abox a  guessed step  
size exponential   size polynomial q  step   implemented
straightforward iteration fork rewritings q   q splittings q   w r t   t       
requires exponential time 
thus remains deal step    let closure single negations union
following sets concepts 
nc  
concepts occur  possibly subconcepts  
concept names occur q 
concepts cq r cq subconcepts  q dtrees q    q maximal fork
rewriting q  r occurs q 
based remark lemma     easy verify  and crucial argument    
polynomial     q   type set model  
     c   c    section    introduce notion
coherence types  say pair  types  t  t    r coherent  denoted  r t   
r c   c t  implies r c t  set  types computed e xp ime 
verify satisfiability   a  w r t      guess map   ind at       accept
following two conditions satisfied reject otherwise 
 i  c c    a  implies c  c 
 ii  r b  c    a    c  c   r c imply r c  b  
clearly  checking whether two conditions satisfied done single exponential time 
thus remains argue   a  satisfiable w r t    case exists
map verifying conditions  first note given model kb  t       a    
define desired map setting  c     c   ci c    conversely  given map
satisfying conditions  i   ii   define interpretation follows 
 

ai    t   t 

ri     t  t       r t   

ci    c 

readily verified c   c iff c   this 
show  using similar argument given lemma     model  t       a    
complete proof undecidability result  theorem     proving lemma    
lemma     t  h  v   admits tiling iff  abox satisfiable w r t 
     v a v  
proof   only if  straightforward  consider tiling f               n              m 
 t  h  v    create individuals ai j   n   j m  consider abox
composed following assertions 
  

fiq uery p redicate e mptiness

x ai j   ai   j       n   j
x  ai   j   ai j       n   j
y ai j   ai j       j     n
 ai j     ai j     j     n
th  ai j   f  i  j    th  
easily verified satisfiable w r t  satisfies      v a v  
 if  let  abox satisfiable w r t       v a v   first show
ix iy enforce x inverse x inverse y  respectively  c
forces relevant grid cells closed  r  x  y  call ind a  r defect exists
b ind a  r a  b  r  b  a    a  call inv defect x defect
y defect  call ind a  cl defect exist x a  b   y a  c   y b  d   x c  e 
   e inv defect  b y defect c x defect 
claim    exists model ind a  
 d   ai   iri   r defects ind a  r  x  y  
 d   ai   c   cl defects ind a  
moreover  satisfies following conditions ind a   role names r  h             p  
     ind a  
   ai   a 
    a  a    ri implies r a  a    a 
   thi implies th  a  a 
proof claim    let r  x  y   call two element set  a  b  r defect witness exists
c ind a  r a  c   r  c  b  a  consider undirected graph g nodes ind a 
set r defect witnesses edges  note g degree two  since r r
functional   hence g three colorable  choose three coloring g colors br     zr   uzr    
br     zr   u zr   br     zr   u zr  
concept names
sand choose interpretation



zr     zr   correspondingly  set ir   i        br i u r r  br i    
call two element set  d  e  cl defect witness exist x a  b   y a  c   y b  d   x c  e 
inv defect  b y defect c x defect  consider undirected
graph g nodes ind a  set cl defect witnesses edges  note g degree
two  again since x  x   y  functional   hence g three colorable colors
c    zc   u zc     c    zc   u zc   c    zc   u zc  
choose interpretation
concept names zc     zc   correspondingly  set c   i        x y ci u y x ci  i  
since neither existential restrictions concept names th occur right hand side
cis   hard verify interpret remaining concept names
way additional conditions satisfied   end proof claim 
  

fibaader   b ienvenu   l utz     w olter

let model satisfying conditions claim    additionally assume w l o g 
a   minimal  model j satisfying conditions claim  
aj ai j least one inclusions proper 
let aa ai   exhibit grid structure gives rise tiling  t  h  v   
start identifying diagonal starts aa ends instance tfinal  
claim    set g    r   ai   j    ai   j             rk   aik   jk  aik  jk    tfinal  aik  jk   

i       j       a      aa  
      k  either  i  r    x  i      i       j      j   ii  r    y 
j      j       i      i   
proof claim  sequence  convert new model j
interpreting false points reachable  equivalently  a  aa setting
aj   ai    aa    contradicts a   minimality i   end proof claim 
let n number occurrences role x abox g claim   number
occurrences y  next show
claim   
 
 a  a    tinit

 b  ai j ri implies   n 
 c  ai j u implies j   m 
 d  ai j ai j ind g  
 e  ai j ind g    unique  th ai j thi   henceforth denoted ti j  
 f   ti j   ti   j   h ai j   ai   j ind g   ti j   ti j     v ai j   ai j  
ind g  
proof claim  point  a  easy consequence fact a      aa   aa ai  
a   minimal   b   first note unique   k   n             k 
  n                   due ci r v x   ai    j  
  ri   show

ais  js
  r        suffices use cis r v x  r v y r  proof
 c  similar  prove  d   f  together  showing induction    d   f  satisfied
initial parts
g      r   ai   j    ai   j             r    ai    j   ai   j    
g    k  base case  ai   j    aa ai clearly implies ai   j    thus  d 
satisfied  point  e  follows  a  disjointness tiles expressed   point  f 
vacuously true since single individual g    induction step  assume g  
satisfies  d   f   distinguish four cases 
ai    j    u u r i  
  

fiq uery p redicate e mptiness

since g   satisfies  d   ai    j     definition a  minimality together fact ai    j    u u r i ensure
ai    j    x  tg u u y y   u y  th u u x y   u ix u iy u c u tf  i
 tf   tg   h  tf   th   v   using functionality x y  easy
show g  satisfies  d   f  
ai    j    u u r i  
since ai    j   ri   ensures x successor ai    j   i  moreover 
ai    j     together definition   get
ai    j    y  tg u u r  u iy u tf  i
 tf   tg   v   must i    i     j    j        r     y  using
functionality y  easy show g  satisfies  d   f  
ai    j    u u r i  
analogous previous case 
ai    j    u u r i  
neither x successor y successor ai    j    u u r i   follows
      k  contradiction   k 
 end proof claim 
next  extend g full grid conditions  a   e  claim   still satisfied 
achieved  trivial read solution tiling problem  construction grid
consists exhaustive application following two steps 
   x ai j   ai   j    y ai   j   ai   j     g ai j   ind g  y ai j   ai j    
g x ai j     ai   j     g  identify ai j   ind a  y ai j   ai j    
x ai j     ai   j     add latter two assertions g 
   y ai j   ai j      x ai j     ai   j     g ai   j ind g  x ai j   ai   j  
g y ai   j   ai   j     g  identify ai   j ind a  x ai j   ai   j  
y ai   j   ai   j     add latter two assertions g 
hard see exhaustive application rules yields full grid  i e   final g
 i  ind g     ai j   n  j m    ii  x ai j   ai   j     g iff i        j   j    
 iii  y ai j   ai   j     g iff   i  j     j     
since two steps construction completely analogous  deal case  
detail  thus let x ai j   ai   j    y ai   j   ai   j     g ai j  
  ind g   clearly    n
j   m   b   c   thus ai j
   r u  i   since ai j  d 
a   minimal  get
ai j  x  tg u u y y   u y  th u u x y   u ix u iy u c u tf  i
 tf   tg   h  tf   th   v   together minimality means
select ai j     b ind a  y ai j   ai j      x ai j     b  a  ai j     b   ti j    
  

fibaader   b ienvenu   l utz     w olter

th   choice   a    d    e   second half  f  clearly satisfied  get properties
required step   above  show b   ai   j     show this 
satisfaction  b   c  apply construction step  cis
r v x  r v y r

u v y  u v x u

ensure  b   c  still satisfied construction step  showing b   ai   j  
give us first half  f   finally  prove b   ai   j   sufficient show ai j
cl defect ind a   follows claim   since ai j c   ai j ixi iyi   ai   j iyi  
ai j   ixi  
use completed grid build solution tiling problem  tile point
 i  j  unique tile satisfied ai j ind a   property  f  claim  
correctness grid construction ensure adjacent tiles satisfy vertical horizontal
constraints 


appendix c  proofs section  
theorem     el  cq query emptiness decided pt ime 
proof  lemma     suffices show n ary cq q alphabet   decided
pt ime whether      q a             total  abox  first note
     q a             iff   ab    qb 
ab obtained adding assertion x a    x concept name
occur     q 
qb boolean cq obtained q adding conjunct x v  answer variable v
quantifying away answer variables 
recall discussion lemma    every cq q viewed directed graph
gdq   say boolean cq q directed forest shaped disjoint union directed treeshaped boolean cqs  every boolean cq q directed forest shaped corresponds concept
cq description logic elu extends el universal role u      q iff
     c a  ind a   lutz   wolter         checking latter condition possible
pt ime  lutz   wolter         thus  sufficient convert qb polynomial time directed
forest shaped cq qb    ab    qb iff   ab    qb   
construct qb  qb  exhaustively apply following rewriting rules 
   r v  v      r v     v      query  identify v v   replacing occurrences
v   v 
   r v     v  s v      v  query  with r    s   identify v  v     v    replacing
occurrences v   v    v 
   cycle r   v    v             rn   vn    vn    vn   v  query  v            vn    contains
least two variables  identify variables v            vn  replacing occurrences
v            vn  v   
  

fiq uery p redicate e mptiness

resulting query contains reflexive loop r v  v  r
    immediately return
no  otherwise  replace final step reflexive loop r v  v  r x v  
query resulting last step qb    easy see query obtained point
directed forest shaped since every variable one predecessor cycles
corresponding directed graph 
prove correctness algorithm  first establish following claim 
claim  qb  defined    ab    qb iff   ab    qb   
suffices prove rule application preserves  non entailment query ab  
preliminary  recall that  shown lutz wolter         exists materialization
jt  ab  t   ab   directed tree shaped interpretation individual root
 potentially  additional reflexive loops added root  an interpretation directed treeshaped corresponding cq domain elements interpretation regarded
variables directed tree shaped   assume rewriting rule   applied query p resulting
query p    clear   ab    pb  implies   ab    pb  converse  assume   ab    pb
let jt  ab materialization ab introduced above  match p
jt  ab   since jt  ab contain domain elements d  d    d      d 
j

j

role name r   d  d     r  ab  d    d     r  ab   match p jt  ab must map
identified variables v v   domain element thus match p   
two rules replacement r v  v   r   x v  dealt similar way 
claim  substitute qb qb  intended  moreover  easy see
  ab     qb algorithm returns due reflexive loop r v  v  r
    simply use
interpretation jt  ab proof claim 

proposition     every horn alcif tbox   abox signature   cq q  one construct
polynomial time elif  tbox   normal form q empty given iff q
empty given    
proof  proof similar reductions provided work hustadt et al        
kazakov         nevertheless  kazakov considers reductions preserving subsumption only 
hustadt  motik  sattler kazakov reduce elif tboxes 
give detailed proof 
following rules used rewrite elif  tbox normal form  all freshly
introduced concept names sig t   sig q   assume l v r given 
l form l  u l  r concept name  take fresh concept name
replace l v r l v v r  r concept name  either l  l 
concept names  take fresh concept names a    a  replace l v r l  v a   
l  v a  a  u a  v r 
l form l  l  r concept name  replace l v r l  v r
l  v r  otherwise take fresh concept name replace l v r l v v r 
l form r l  l  concept name  take fresh concept name a 
replace l v r l  v a  r a  v r 
r form a  replace l v r l u v  
  

fibaader   b ienvenu   l utz     w olter

r form r  u r  l concept name  take fresh concept name
replace l v r l v v r  otherwise take fresh concept names a    a 
replace l v r l v a    l v a    a  v r    a  v r   
r form l  r    replace l v r l u l  v r   
r form r r  r  concept name  take fresh concept name a 
replace l v r l v r a  a  v r   
r form r r    replace l v r r  l v r 
resulting tbox   required  particular  every  abox model    
model   conversely  every model extended
model appropriately interpreting fresh concept names  consequently 
certt  q  a    certt    q  a  thus q empty given iff q empty given    

proposition     let elif  tbox  abox signature  q cq  q non empty
given   witnessed  abox forest shaped  width  q  
degree  t   
proof  assume q answer variables v            vn non empty given  
find  abox satisfiable w r t  certt  a  q       identify forestshaped witness non emptiness q given   consider canonical model  a
 t   a   construction   a consists abox part i    restriction  a
ind a   tree shaped interpretations ia   ind a   rooted containing abox
individuals  since  a universal  match q  a   let consist individuals
ind a  v var q   v  ia  possibly  v    a   let a 
abox obtained restricting individuals   going root component
forest shaped witness seeking define  observe  ind a      q    add
tree components  consider     typically infinite  tree shaped abox aua
obtained unraveling starting a  work lutz wolter        
ind aua   set sequences   c  r  c        rm  cm c            cm ind a 
r            rm   possibly inverse  roles  i  c    a   ii  c       iii  rj  cj    cj  

  j   m   iv   cj    rj 
      cj     rj   j      say copy
cm  
a c  ind aua   copy c  a   aua  
ind aua   copy c    rc  ind aua    r     aua  
ind aua   copy c    r c  ind aua    r     aua  
let ab union a  tree shaped aboxes  aua      observe conditions
b note
 ii   iv  first item since satisfies functionality statements   a 
b
forest shaped  need neither finite degree  t    going fix
later 
next aim show ab satisfiable w r t  certt  ab q       end 
construct universal model j ab   start ab viewed interpretation j   
  

fiq uery p redicate e mptiness

construction canonical models  take  ind a  copies
b copy tree interpretation ia  i  root    ii  j       
ind a  
 iii     implies disjointness    iv    identical original
tree interpretation ia  and copy   d  result renaming ia   d 
called copy d  desired interpretation j obtained taking union j   
note every element j copy element  a   that  construction  j
b
model a 
straightforward show induction structure c every eli concept c
every element e j copy  a   e c j iff c  a   since  a
model   follows j model thus ab satisfiable w r t    sketch
proof j universal  let model ab   start define homomorphism h 
b remains extend h  components
j setting h   a    ai ind a  
j   copy tree interpretation ia  a copy a  shown
work lutz wolter        that 
b copy ind a   ait  a implies   ab    a   concept
   ind a 
names a 
recall  a generated derivation rules building canonical models  using
straightforward induction number rule applications exploiting    fact
normal form  one construct homomorphism ha ia h a     
renaming  obtain homomorphism h h        desired
homomorphism h union h  h   thus established j universal  going
construction j  and particular using point  iv    verified match
q  a match q j   since j universal  yields certt  ab q     desired 
want remove individuals ab resulting abox degree  t  
still witnesses non emptiness q given   since j universal  homomorphism h j canonical model  ab  composing match h  obtain match
q  ab sends every variable individual a  element tree
individual  inductively mark individuals ab relevant match   starting
individuals a  proceeding follows  whenever rule     adds marked individual
x ait  ab construction  ab presence  x  y  rit  a  please see
formulation mentioned rules   mark y  verified every individual outside
a  one marked neighbor existential restriction    potentially infinite  forest shaped abox abd obtained ab dropping assertions involve least one
unmarked individual thus degree  t    moreover  marking construction ensures
canonical model  abd contains a  interpretation ia   ind a     hence match
q  abd  
point  abox abd almost required forest witness  except may infinite 
remains invoke compactness obtain finite subset abf abd certt  abf  q      
clearly  abf contains forest witness non emptiness q given  

   lutz wolter        actually show case root component a  ab start
unravel consists individual names a  contains concept role assertions  proof goes
case 

  

fibaader   b ienvenu   l utz     w olter

following lemmas establish two statements lemma    
lemma    every canonical proper r n  labeled tree well founded 
proof  let ht   i canonical proper r n  labeled tree  let i    i          interpretations encountered construction canonical model aht  i   since ht   i
canonical  iht  i canonical model aht  i  
slightly abuse terminology using term concept atom refer statements
form b e  b concept name  or    e domain element  role atom take
form r e  e    r role e  e  domain elements  say concept atom b e   resp 
role atom r e  e     interpretation j e b j  resp   e  e    rj    atom
iht  i   rank smallest ii   show induction rank
every concept atom iht  i derivation  thus ht   i well founded 
induction start straightforward concept atoms i  involve concept    
element x either x ind a        x        x  
every atom derivation depth    induction step  let b x  concept atom
ii     ii   consider rule application resulted addition b x  
   assume b x  ii   application rule    is  a  u u v
b x aij   j n 
every   j n  atom aj  x  rank i  ih  derivation
htj      j aj x  obtain derivation ht        b x setting         jw   w
tj              b  x       jw      j  w  
   assume b x  ii   application rule    is  r a v b
x  r a ii  
x  r a ii   must exist ii  x  y  rii aii  
atom a y  rank i  ih  derivation ht          y 
x i    x ind aht  i    define derivation ht        b x setting
         w   w                b  x        w         w  
next consider case x   i    x   ind aht  i    properness  
concept e nc     e   x   since x   i  x   ii  
    j   x ij   ij    since ht   i canonical  element x created
due application rule   using concept inclusion form f v s e  x e ij  
applying ih  obtain derivation ht            e x  thus define derivation
ht        b x setting          w   w        w   w                 b  x  
     w         w        w          w  
   assume b x  ii   application rule   involving v r b  
is  ii aii  y  x  rii     rii  
atom a y  rank i  ih  exists derivation ht          y 
moreover  since x created applying inclusion v r b y  second
condition canonicity ensures b   x   thus define derivation b x
taking tree ht                 w   w                b  x        w         w  
  

fiq uery p redicate e mptiness

   assume b x      x  ii   application rule   involving v
r e  e        is  ii aii  y  x  rii     rii  
atom a y  rank i  ih  exists derivation ht          y 
moreover  since x created applying inclusion v r e y  second
condition canonicity ensures e   x   thus define derivation   x
taking tree ht                     w   w                   x             e  x  
      w         w  
   assume b x  ii   application rule    is  v r b  
funct r    aii    y  x  rii  
atom a y  rank i  ih  exists derivation ht          y 
x i    obtain derivation b x taking tree ht                 w  
w                b  x        w         w   x   i    use
argument point   find derivation ht            e x  obtain derivation
ht        b x setting          w   w        w   w                 b  x  
     w         w        w          w  

lemma    let ht   i proper r n  labeled tree well founded iht  i
model   iht  i universal model aht  i  
proof  assume ht   i well founded proper r n  labeled tree iht  i model
  obligation pair  a  x  x   x   every obligation
 a  x   choose derivation hta x    a x x ht   i minimal depth  obligations  a    x     a    x     write  a    x     a    x     a    x    occurs node label
hta   x     a   x  i 
claim  relation acyclic 
proof claim  assume contrary obligations  a    x              an   xn  
 ai   xi    ai     xi     n  an     xn         a    x     may assume without loss generality     j n   ai   xi       aj   xj    i e   obligations
 a    x              an   xn   pairwise distinct  let ki depth htai  xi    ai  xi  i
depth shallow derivation  ai   xi   contained htai    xi      ai    xi   i 
htai  xi    ai  xi minimal depth  ki  i   moreover  clearly  i ki    
thus shown k           kn    n   consequently  derivation  a    x   
hta   x     a   x  must start root htai  xi    ai  xi i  implies  a    x       a    x   
contradiction fact obligations distinct  finishes proof claim 
claim  assume w l o g  chosen derivation hta x    a x i  node
labeled  b  y   subtree hta x    a x rooted node chosen derivation
htb y    b y  uniformity assumption  
prove iht  i universal model aht  i   take model aht  i  
show homomorphism h iht  i i  constructing h step by step fashion 
start  set h a    ai individual names occur aht  i   extension
h  argue
  

fibaader   b ienvenu   l utz     w olter

   x aiht  i concept name  h x  defined hta x    a x uses elements
domain h  h x  ai  
    x  y  riht  i r role h x   h y  defined   h x   h y   ri  
    x  y  riht  i   child x   h y  defined  h x  defined 
start observing initial mapping h  point   trivial since model aht  i
role edges restriction iht  i domain h aht  i   point    use
fact individual aht  i x parent   properness implies
x individual aht  i  and hence x belongs domain h  
point   proved induction depth hta x    a x i  induction start  consider
depth zero       x ind aht  i    a x  aht  i   since model aht  i
definition h  h x  ai  
induction step  assume hta x    a x uses elements domain h 
definition derivations gives rise following cases 
    x   ci a  u u v   n  child
z   z ta x  a x  z        ai   x  
  n  let zi child z  a x  zi      ai   x   subderivation
hta x    a x rooted zi chosen derivation htai  x    ai  x ai x  follows
htai  x    ai  x uses elements domain h depth strictly smaller
hta x    a x i  therefore apply induction hypothesis get h x  aii   since
model a  u u v   obtain h x  ai  
    x   ci r a  v child z   z ta x  a x  z        a    x   
 x  x    riht  i  
subderivation hta x    a x rooted z   chosen derivation hta   x     a   x  a 
x    thus contains elements domain h strictly smaller depth
hta x    a x i  thus use ih infer h x    b   use point  
get  h x   h x     ri   since model r a  v   h x  ai  
    x   ci a  v r a funct r  child z   z ta x
 a x  z        a    x     x    x  riht  i  
previous item  use ih point   get h x    b  h x   h x    
ri   since model contains a  v r a funct r   follows
h x  ai  
      
    x   b   x  and child z ta x  a x  z     b  x  
case applicable since b   x       x   hence x domain
h 
  x   ci a  v r a   child z   z ta x  a x  z      
 a    x     x    x  riht  i either  i  x child x     ii  x child
root  x  ind   r  x      x  
case applicable since   x       x   hence x domain
h 
  

fiq uery p redicate e mptiness

extend h  first show h yet total  exists edge  b
x  yb  riht  i

concept name h b
x  defined  h b
  undefined    b
   and consequently
  b
    hta by    a by elements except root node domain
h 
assume contrary h total edge  i e   every edge  b
x  yb 
riht  i h b
x  defined  h b
  undefined    b
   derivation hta by    a by
contains non root node domain h  pick one edge  b
x  yb  riht  i
associated derivation hta by    a by minimal depth  since h b
x  defined h b
 
undefined  follows point   either x
b parent yb   yb child root node
 b
x  r    b
   since derivation rule   applicable rule node label contains

formulation rule  must thus ci a  v r a unique
child z ta by satisfies  a by  z     a    x
b   since x
b domain h  non root node
domain h must somewhere z  consequently  find nodes z    z  ta by
z  successor z  domain element x
b   a by  z    domain h 
 
domain element yb  a by  z    domain h  definition derivation rules 
must  b
x    yb    siht  i role s  point    either yb  child x
b    yb 
 
 
child root node label contains  b
x   s   follows x
b related yb  one
derivation rules      consequently  b   b
    hta by    a by contains
iht  i
 
 
 
obligation  b  yb    thus  edge  b
x   yb  
satisfies conditions associated
derivation htb by     b by  strictly smaller depth hta by    a by i  contradicting minimality
hta by    a by i 
extend h using edge  b
x  yb  riht  i whose existence established 
definition derivations  ci a  v r a child z ta by
 a by  z     a    x
b   since elements hta by    a by except root node domain h 
subderivation hta by    a by rooted z uses elements domain h 
uniformity assumption  derivation hta   bx    a   bx i  thus ih yields h b
x  a  iht  i  
iht  i
iht  i
 
since v r a    b
x  d  r

  set h b
    d 
remains show points     satisfied extended h  point   obviously is  
start point    assume  x  y  siht  i   h x  h y  defined already
extension h  done  otherwise  construction h must  x  y  s     b
x  yb  r 
 or  x  y  s     b
y  x
b  r    equivalent   choice h b
    h b
x   h b
   ri  
hence  x  y  si   point   proved induction depth a x  initial version
h  induction start exactly same  induction step  cases differ
following ones 

    x   b   x        child z ta x  a x  z     b  x  
immediate since     
  x   ci a  v r a   child z   z ta x  a x  z      
 a    x     x    x  riht  i either  i  x child x     ii  x child
root  x  ind   r  x      x  
since   x   x   ind aht  i    x must introduced domain
h examination edge  x    x  riht  i   since child z   labeled  a    x    
use ci a  v r a choose h x  h x  aiht  i  

  

fibaader   b ienvenu   l utz     w olter

references
artale  a   calvanese  d   kontchakov  r     zakharyaschev  m          dl lite family
relations  journal artifical intelligence research  jair           
baader  f   bienvenu  m   lutz  c     wolter  f          query predicate emptiness description logics  proceedings   th international conference principles knowledge
representation reasoning  kr  
baader  f   brandt  s     lutz  c          pushing el envelope  proceedings   th
international joint conference artificial intelligence  ijcai   pp         
baader  f   brandt  s     lutz  c          pushing el envelope further  proceedings
workshop owl  experiences directions  owled  
benedikt  m   fan  w     geerts  f          xpath satisfiability presence dtds  journal
acm             
bienvenu  m   hansen  p   lutz  c     wolter  f          first order rewritability conjunctive
queries horn description logics  proceedings   th international joint conference
artificial intelligence  ijcai  
bienvenu  m   lutz  c     wolter  f          query containment description logics reconsidered 
proceedings   th international conference principles knowledge representation reasoning  kr  
bienvenu  m   ten cate  b   lutz  c     wolter  f          ontology based data access  study
disjunctive datalog  csp  mmsnp  acm transactions database system
 tods             
botoeva  e   kontchakov  r   ryzhikov  v   wolter  f     zakharyaschev  m          query inseparability description logic knowledge bases  proceedings   th international
conference principles knowledge representation reasoning  kr  
botoeva  e   kontchakov  r   ryzhikov  v   wolter  f     zakharyaschev  m          games
query inseparability description logic knowledge bases  artificial intelligence journal
 aij              
bourhis  p     lutz  c          containment monadic disjunctive datalog  mmsnp  expressive
description logics  proceedings   th international conference principles
knowledge representation reasoning  kr  
calvanese  d   de giacomo  g   lembo  d   lenzerini  m   poggi  a   rodriguez muro  m    
rosati  r          ontologies databases  dl lite approach  tutorial lectures
 th international reasoning web summer school  vol       lecture notes computer
science  pp          springer 
calvanese  d   de giacomo  g   lembo  d   lenzerini  m     rosati  r          tractable reasoning
efficient query answering description logics  dl lite family  journal automated
reasoning  jar                 
calvanese  d   de giacomo  g   lembo  d   lenzerini  m     rosati  r          data complexity
query answering description logics  artificial intelligence journal  aij               
  

fiq uery p redicate e mptiness

calvanese  d   de giacomo  g     lenzerini  m          decidability query containment
constraints  proceedings   th acm sigact sigmod sigart symposium
principles database systems  pods   pp         
calvanese  d   ortiz  m   simkus  m     stefanoni  g          reasoning explanations
negative query answers dl lite  journal artificial intelligence research  jair      
       
chortaras  a   trivela  d     stamou  g  b          optimized query rewriting owl   ql 
proceedings   rd international conference automated deduction  cade   pp 
       
eiter  t   gottlob  g   ortiz  m     simkus  m          query answering description logic
horn shiq  proceedings   th european conference logics artificial intelligence  jelia   pp         
eiter  t   ortiz  m   simkus  m   tran  t     xiao  g          query rewriting horn shiq plus
rules  proceedings   th aaai conference artificial intelligence  aaai  
gabbay  d   kurucz  a   wolter  f     zakharyaschev  m          many dimensional modal logics 
theory applications  elsevier 
gatens  w   konev  b     wolter  f          lower upper approximations depleting modules
description logic ontologies  proceedings   st european conference artificial
intelligence  ecai   pp         
gene ontology consortium         gene ontology  http   geneontology org    online  accessed
   april       
glimm  b   lutz  c   horrocks  i     sattler  u          answering conjunctive queries
shiq description logic  journal artificial intelligence research  jair              
golbeck  j   fragoso  g   hartel  f   hendler  j   oberthaler  j     parsia  b          national
cancer institutes thesaurus ontology  journal web semantics  science  services
agents world wide web             
grau  b  c   horrocks  i   kazakov  y     sattler  u          modular reuse ontologies  theory
practice  journal artifical intelligence research  jair              
haase  c          complexity subsumption extensions el  masters thesis  dresden university technology 
hitrl         health information technologies research laboratory  university sydney 
http   sydney edu au engineering it hitru   online  accessed    april       
horrocks  i   kutz  o     sattler  u          even irresistible sroiq  proceedings
  th international conference principles knowledge representation reasoning
 kr   pp       
hustadt  u   motik  b     sattler  u          decomposition rule decision procedures
resolution based calculi  proceedings   th international conference logic
programming artificial intelligence reasoning  lpar   pp       
hustadt  u   motik  b     sattler  u          reasoning description logics reduction
disjunctive datalog  journal automated reasoning  jar                 
  

fibaader   b ienvenu   l utz     w olter

ihtsdo         snomed ct  global language healthcare  http   www ihtsdo org snomedct   online  accessed    april       
kaminski  m   schneider  t     smolka  g          correctness worst case optimality prattstyle decision procedures modal hybrid logics  proceedings   th international conference automated reasoning analytic tableaux related methods
 tableaux   pp         
kazakov  y          consequence driven reasoning horn shiq ontologies  proceedings
  st international joint conference artificial intelligence  ijcai   pp           
kazakov  y          extension complex role inclusion axioms description logic
sroiq  proceedings  th international joint conference automated reasoning
 ijcar   pp         
konev  b   ludwig  m   walther  d     wolter  f          logical difference lightweight
description logic el  journal artificial intelligence research  jair              
konev  b   lutz  c   walther  d     wolter  f          model theoretic inseparability modularity
description logic ontologies  artificial intelligence journal  aij              
kontchakov  r   rodriguez muro  m     zakharyaschev  m          ontology based data access
databases  short course  proceedings international reasoning web summer
school  pp         
kontchakov  r   wolter  f     zakharyaschev  m          logic based ontology comparison
module extraction  application dl lite  artificial intelligence               
     
krotzsch  m          owl   profiles  introduction lightweight ontology languages  tutorial lectures  th international reasoning web summer school  vol       lecture
notes computer science  pp          springer 
krotzsch  m   rudolph  s     hitzler  p          complexity boundaries horn description logics 
proceedings   nd aaai conference artificial intelligence  aaai   pp         
levy  a          irrelevance reasoning knowledge based systems  ph d  thesis  stanford university 
lubyte  l     tessaris  s          supporting design ontologies data access  proceedings   st international description logic workshop  dl  
lutz  c          complexity cq answering expressive description logics  proceedings
 th international joint conference automated reasoning  ijcar   pp         
lutz  c   toman  d     wolter  f          conjunctive query answering description logic el
using relational database system  proceedings   st international joint conference
artificial intelligence  ijcai   pp           
lutz  c     wolter  f          deciding inseparability conservative extensions description
logic el  journal symbolic computation                
lutz  c     wolter  f          non uniform data complexity query answering description
logics  proceedings   th international conference principles knowledge
representation reasoning  kr  
  

fiq uery p redicate e mptiness

motik  b   grau  b  c   horrocks  i   wu  z   fokoue  a     lutz  c          owl   web ontology language  profiles  w c recommendation  available http   www w  org tr owl profiles  
ortiz  m   calvanese  d     eiter  t          data complexity query answering expressive
description logics via tableaux  journal automated reasoning  jar               
ortiz  m     simkus  m          reasoning query answering description logics  proceedings  th international reasoning web summer school  vol       lecture notes
computer science  pp       springer 
ortiz  m   simkus  m     eiter  t          worst case optimal conjunctive query answering
expressive description logic without inverses  proceedings   rd aaai conference
artificial intelligence  aaai   pp         
patel  c   cimino  j  j   dolby  j   fokoue  a   kalyanpur  a   kershenbaum  a   ma  l   schonberg 
e     srinivas  k          matching patient records clinical trials using ontologies 
proceedings  th international semantic web conference  iswc   pp         
perez urbina  h   motik  b     horrocks  i          comparison query rewriting techniques
dl lite  proceedings   nd international description logic workshop  dl  
poggi  a   lembo  d   calvanese  d   de giacomo  g   lenzerini  m     rosati  r          linking
data ontologies  journal data semantics             
pratt  v  r          models program logics  proceedings ieee annual symposium
foundations computer science  focs   pp         
romero  a  a   kaminski  m   grau  b  c     horrocks  i          ontology module extraction
via datalog reasoning  proceedings   th aaai conference artificial intelligence
 aaai   pp           
tobies  s          complexity results practical algorithms logics knowledge representation  ph d  thesis  rwth aachen 
vardi  m  y          automata theory database theoreticans  proceedings  th acm
sigact sigmod sigart symposium principles database systems  pods   pp    
   
vardi  m  y          reasoning past two way automata  proceedings   th
international colloquium automata  languages programming  icalp   pp         

  


