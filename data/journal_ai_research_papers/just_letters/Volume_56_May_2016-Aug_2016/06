journal artificial intelligence research                  

submitted        published      

research note
time bounded best first search reversible non reversible
search graphs
carlos hernandez

carlos   hernandez   u   unab   cl

departamento de ciencias de la ingeniera 
universidad andres bello 
santiago  chile

jorge a  baier

jabaier   ing   puc   cl

departamento de ciencia de la computacion
pontificia universidad catolica de chile
santiago  chile

roberto asn

rasin   ucsc   cl

departamento de ingeniera informatica
universidad catolica de la santsima concepcion
concepcion  chile

abstract
time bounded a  real time  single agent  deterministic search algorithm expands
states graph order a  does  unlike a  interleaves search action execution  known outperform state of the art real time search algorithms based korfs learning
real time a   lrta   benchmarks  studied detail sometimes
considered true real time search algorithm since fails non reversible problems even
goal still reachable current state  paper propose study time bounded
best first search  tb bfs   straightforward generalization time bounded approach
best first search algorithm  furthermore  propose restarting time bounded weighted a   tbr
 wa     algorithm deals adequately non reversible search graphs  eliminating
backtracking moves incorporating search restarts heuristic learning  non reversible
problems prove tb bfs  terminates deduce cost bounds solutions returned
time bounded weighted a   tb wa     instance tb bfs   furthermore  prove tbr
 wa    reasonable conditions  terminates  evaluate tb wa  grid pathfinding
   puzzle  addition  evaluate tbr  wa   racetrack problem  compare
algorithms lss lrtwa   variant lrta  exploit lookahead search weighted
heuristic  general observation performance tb wa   tbr  wa   improves weight parameter increased  addition  time bounded algorithms almost
always outperform lss lrtwa  significant margin 

   introduction
many search applications  time scarce resource  examples range video game path
finding  handful milliseconds given search algorithm controlling automated
characters  bulitko  bjornsson  sturtevant    lawrence         highly dynamic robotics  schmid 
tomic  ruess  hirschmuller    suppa         settings  usually assumed standard
search algorithm able compute complete solution action required 
thus execution search must interleaved 
c
    
ai access foundation  rights reserved 

fih ern andez   baier    

time bounded a   bjornsson  bulitko    sturtevant        algorithm suitable searching tight time constraints  nutshell  given parameter k  runs standard a  search
towards goal rooted initial state  k expansions completed  move performed search  still needed  resumed  move computed follows  agent
path found a  root node best node b search frontier
agent moved towards b following path   otherwise  performs backtracking move  returning agent previous state  algorithm always terminates agent goal
state  problem solution 
time bounded a  algorithm relevant real time search community 
significantly superior well known real time heuristic search algorithms applications 
indeed hernandez  baier  uras  koenig        showed significantly outperforms state of theart real time heuristic search algorithms rtaa   koenig   likhachev        dartaa 
 hernandez   baier        pathfinding 
relatively new algorithm  time bounded a  studied deeply literature  one reasons perhaps inability adequately deal non reversible
problems  indeed  non reversible problems real time search algorithm fail soon
algorithm led agent dead end state  i e   one goal unreachable  timebounded a   however  additional failure condition  always fail soon backtrack
move required unreversible action  thus class problems cannot solve limited compared real time search algorithms  like  example  well known lrta   korf 
       reason  time bounded a  sometimes excluded experimental comparisons
real time search algorithms  see e g  burns  ruml    do        p       
paper extend time bounded search approach two directions  already noted
authors  bjornsson et al          time bounded approach limited a   first
contribution paper study implications using search algorithms
instead a   specifically  generalize time bounded a  time bounded best first search 
general  instance best first search  call tb a  algorithm results
applying time bounded approach a  second contribution paper extension
time bounded search approach allows algorithm deal adequately non reversible
problems  algorithm propose here  restarting time bounded weighted a which call
tbr  wa    seen lying middle ground time bounded algorithms
learning based real time search algorithms korfs learning real time a   lrta          
fact  tbr  wa   restarts search current state backtracking move available
updates heuristic function 
carry theoretical analysis time bounded weighted a   tb wa     instance
tb bfs   tbr  wa    tb wa   establish upper lower bounds
solution cost  cost bound establishes that  domains  solution cost may reduced
significantly increasing w without increasing search time  hence  contrast wellknown weighted a  solving offline search problems  might obtain better solutions
increasing weight  result important since suggests tb wa    with w     
preferred tb a   domains wa  runs faster a   wa 
always run faster a   see e g   wilt   ruml         known many situations 
experimentally  evaluate tb wa   pathfinding benchmarks    puzzle 
tbr  wa   racetrack problem  three benchmarks observe performance improvement w increased  addition  observe tb wa   significantly superior tb a  
   

fit ime  b ounded b est f irst earch r eversible n   reversible earch g raphs

lss lrtwa   rivera  baier    hernandez         real time search algorithm use
weighted heuristics 
paper extends work appears conference proceedings  hernandez  asn    baier 
       including empirical analysis new benchmarks  counter strike maps  racetrack 
   puzzle   extending pathfinding experiments    neighbor connectivity  providing lower bound cost solution returned tb wa    theorem    below  
introducing  analyzing  evaluating tbr  wa   
rest paper organized follows  start describing background needed
rest paper  describe tb bfs  tbr  bfs   including formal analysis
properties  describe experimental results  finish summary
perspectives future research 

   background
describe background rest paper 
    search reversible non reversible environments
search graph tuple g    s  a   finite set states  set edges
represent actions available agent state  path graph  s  a 
sequence states   s  s  sn    si   si     a              n     s    s 
sn   t  say successor  s  t  edge a  moreover  every
define succ s     t    s  t  a  
cost function c search graph  s  a  c   p
r    i e   associates action
positive cost  cost path   s  s  sn c     n 
i   c si   si      i e  sum
costs edge considered path  cost optimal path one
lowest cost among paths t  denote cost c  s  t   addition  denote
ct  s  t  cost cost optimal path visits states   is 
cost optimal path   s  s        sn   s    sn   t  si               n    
search problem tuple  s  a  c  sstart   sgoal   g    s  a  search graph  sstart
sgoal states s  c cost function g  search graph g    s  a  reversible
symmetric  is  whenever  s  t   t  s  a  search problem reversible
search graph reversible  consequently  problem non reversible search graph
contains action  s  t  contain action  t  s  
solution search problem path sstart sgoal  
    best first search
best first search  bfs   pearl        encompasses family search algorithms static environments associate evaluation function f  s  every state s  priority
f  s    f  t  viewed promising node t  bfs starts initializing
priority states search space infinity  except sstart   priority set
f  sstart    priority queue open initialized containing sstart   iteration  algorithm
extracts open state lowest priority  s  successor computes evaluation fs  t   considering path found s  fs  t  lower f  t  
   

fih ern andez   baier    

added open f  t  set fs  t   algorithm repeats process sgoal open
lowest priority 
pseudo code presented algorithm    f  value state usually implemented
attribute s  open list implemented priority list  furthermore  assume
cost fs  t  computed line    function path via s  thus fs  t  take finite
number values execution bfs  depends  finite  number simple
paths connect initial state s 
algorithm    best first search

  
  

sroot scurrent
open
foreach
f  s 
f  sroot   evaluation sroot
insert sroot open
open   
let state minimum f  value open
  sgoal
return
remove open
foreach succ s 
fs  t  evaluation function considering discovered
fs  t    f  t 
f  t  fs  t 
parent t 
insert open

  

return solution

 
 
 
 
 
 
 
 
 
  
  
  
  
  
  

instance best first search weighted a   wa    pohl         wa  computes evaluation function terms two functions  g h  g value corresponds cost
lowest cost path found far towards s  implemented attribute s  wa s evaluation function defined f  s    g s    wh s   g s  cost lowest cost path
found sstart s  addition  h non negative  user given heuristic function h s 
estimates cost path sgoal   finally  w real number greater equal   
pseudo code wa  obtained algorithm   storing g value attribute state  h value computed external function  resulting pseudo code
appears algorithm   
heuristic function h admissible h s  c  s  sgoal    s  function
h consistent h sgoal        h s  c s  t    h t  every edge  s  t  search graph 
consistency implies path h s  c     h t   which  turn  implies
admissibility 
bfss closed listdenoted henceforth closed defined set states
open g s  infinity   words  contains states
path known considered re expansion 
   bfs initially sets f  s  infinity every start node  wa  translates setting g s  infinity
except sstart  

   

fit ime  b ounded b est f irst earch r eversible n   reversible earch g raphs

algorithm    weighted a 

  
  

sroot scurrent
open
foreach
g s 
f  s 
g sroot    
f  sroot   wh sroot  
insert sroot open
open   
let state minimum f  value open
  sgoal
return
remove open
foreach succ s 
gs t   min g t   g s    c s  t  
gs t   g t 
g t  gs t
f  t  g t    wh t 
parent t 
insert open

  

return solution

 
 
 
 
 
 
 
 
 
  
  
  
  
  
  
  
  
  

h admissible  wa  known find solution whose cost cannot exceed wc  sstart   sgoal   
such  wa  may return increasingly worse solutions w increased  advantage increasing w search time usually decreased fewer states expanded  w     
wa  equivalent a   hart  nilsson    raphael         another interesting result generalizes
well known property consistent heuristics a  algorithm  formally stated follows 
lemma    ebendt   drechsler        every moment execution weighted a 
state sroot   h consistent  upon expansion state  line    algorithm     holds
g s  wc  sroot   s  
another instance best first search greedy best first search  gbfs   f equal
user given heuristic function h  wa  used sufficiently large value w 
wa  gbfs rank nodes similar way  indeed  let fgbfs fwa  denote  respectively  f
function gbfs wa   w exceeds g value every node ever generated
two nodes s  s  generated g value algorithms
fgbfs  s      h s      h s      fgbfs  s     hold fwa   s      fwa   s     however 
even w sufficiently large  reverse always true since fwa   s      fwa   s    hold
true h s      h s     g value fwa  acts practice tie breaker 
    real time heuristic search
real time search objective solve search problem subject additional real time
constraint  constraint  constant amount time  independent problem size  given
search algorithm  end expected perform one actions
sequence  constant small relation time would required offline
   

fih ern andez   baier    

search algorithm solve search problem  performing actions agent reached
goal  process repeats  iteration algorithm understood two consecutive
episodes      search episode  path computed      execution episode 
actions path performed 
rather receiving time limit seconds  real time search algorithms receive parameter  say k  guarantee computational time taken search episode bounded
non decreasing function k  example real time search algorithm local search space 
learning real time a   lss lrta   algorithm     koenig   sun         receives search
problem p parameter k  search episode  runs bounded execution a  rooted
current state expands k states  following  updates heuristic values
states closed list a  run  update  usually referred learning step  makes h
informed  guarantees following holds every a s closed list 
h s    min  cclosed  s  t    h t   
topen

   

execution episode performs actions appear path found a  current
state towards state lowest f  value open list  reversible search spaces h
algorithm    lss lrta 
 
 
 
 
 
 
 
 

input  search problem p natural number k
sstart
goal state
run a  k states expanded goal node best state open
best state a s closed list lowest f  value
closed
update h value equation   holds
move along path found a  best
best 

initially consistent shown lss lrta  terminates search problem
solution  koenig   sun         search space non reversible  however  termination cannot
guaranteed  see later  time bounded algorithms  without restarts  prove solution
exist well  property hold algorithms whose search expands nodes
whose distance current state bounded  lss lrta  
    comparing two real time search algorithms
one way frequently used literature compare two real time search algorithms b
comparing cost returned paths algorithms configured way
search episodes approximately duration  assume real time search algorithm
requires n search episodes solve search problem runtime   say
average time per search episode run  n 
evaluate relative performance two algorithms b use set benchmark
problems p set algorithm parameters  parameter algorithm a  obtain
record average solution cost problems p average time per episode 
likewise b plot average solution cost versus average time per episode
algorithm  curve algorithm always top curve algorithm b clearly
   

fit ime  b ounded b est f irst earch r eversible n   reversible earch g raphs

state b superior a  b returns better quality solutions comparable search time
per episode 
another approach used compare real time search algorithms game time
model  hernandez et al          model  time partitioned uniform time intervals 
agent execute one movement time interval  search movements done
parallel  objective move agent start location goal location
time intervals possible  game time model motivated video games  video games often
partition time game cycles  couple milliseconds long  bulitko et al  
       using game time model  implementation real time search algorithm
modified stop search soon units timewhere parameterhave passed 

   time bounded best first search
time bounded a   tb a    bjornsson et al         real time search algorithm based a  
intuitively  tb a   understood algorithm runs a  search sstart sgoal
alternates search phase execution phase goal reached  search phase
bounded number states expanded using a   execution phase two cases 
agent path sstart best state open  forward movement
path performed  otherwise  algorithm performs backtracking moves agent
moved state came from  search phase execute path connecting
sstart sgoal already found  algorithm terminates agent reached
goal 
generalization tb a   time bounded best first search  simply replaces a 
tb a   best first search  pseudo code shown algorithm    parameters
search problem  s  a  c  sstart   sgoal    integer k refer lookahead
parameter 
tb bfs  uses variable scurrent store current state agent  movetogoal procedure  called main  implements loop alternates search execution  initialization
 lines       scurrent initialized sstart   and  among things  bfss open list set
contain sstart only  goal state reached  represented fact variable
goalf ound false   bounded version bfs called  line     expands k states 
computes path sstart state open minimizes evaluation function f  
path built quickly following parent pointers  stored variable path  execution phase  lines        current position agent  scurrent   path  agent
performs action determined state immediately following scurrent path  otherwise 
backtracking move implemented moving agent parent search tree bfs 
parent scurrent    use backtracking moves mechanism guarantees agent
eventually reach state variable path because  worst case  agent eventually reach
sstart   soon state reached agent start moving towards state believed
closest goal 
algorithm   equivalent tb a   bfs replaced a   finally  call timebounded greedy best first search  tb gbfs   algorithm results use greedy
best first search instead bfs 
note length path cannot general bounded constant size
problem  bound computation search episode use technique described
   

fih ern andez   baier    

algorithm    time bounded best first search
 
 
 
 
 
 
 
 
 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

procedure initializesearch  
sroot scurrent
open
foreach
f  s 
f  sroot   evaluation sroot
insert sroot open
goalfound false
function bounded best first search  
expansions  
open    expansions   k f  sgoal     mintopen f  t 
let state minimum f  value open
remove open
foreach succ s 
compute fs  t  considering discovered s 
fs  t    f  t 
f  t  fs  t 
parent t 
insert open
expansions expansions    
open   return false
let sbest state minimum priority open 
sbest   sgoal goalfound true
path path sroot sbest
return true
function movetogoal  
scurrent sstart
initializesearch  
scurrent    sgoal
goalfound   false
bounded best first search     false return false
scurrent path
scurrent state scurrent path
else
scurrent parent scurrent   
execute movement scurrent
return true
procedure main
movetogoal     true
print the agent goal state 
else
print no solution 

   

fit ime  b ounded b est f irst earch r eversible n   reversible earch g raphs

bjornsson et al          whereby additional counter  analogous k used measure
effort path extraction   omitted pseudocode clarity 
    properties
analyze interesting properties algorithms proposed  first 
tb a    tb bfs  always terminates finds solution one exists  important
property since many real time heuristic search algorithms  e g   lss lrta   enter infinite loop
unsolvable problems  second  prove upper lower bound cost solutions
returned tb wa    bound interesting since suggests increasing w one might
obtain better solutions rather worse 
theorem   tb bfs  move agent goal state given reversible search problem p
solution p exists  otherwise  eventually print solution 
proof  follows fact best first search eventually finds path towards goal 
fact search space finite state inserted open
finite number times  addition  moves carried algorithm  including moving
parent s   executable reversible search space 

important note reason tb bfs  eventually print solution
unsolvable problem dependent fact open list used  lss lrta  cannot always
detect unsolvable problems search expand locality around current state 
characteristic agent centered search algorithms  koenig         class algorithms
tb bfs  member of 
following two lemmas intermediate results allow us prove upper bound
cost solutions obtained tb wa    results apply tb a   knowledge
lemma   theorem   proven tb a   
results below  assume p    s  a  c  sstart   sgoal   reversible search problem 
tb wa   run parameter w   h admissible heuristic  furthermore 
assume c    max u v a c u  v   c   min u v a c u  v   n  w  number
expansions needed wa  solve p   finally  assume k n  w  reasonable
assumption given real time setting 
lemma   cost moves incurred agent controlled tb wa   goalfound
becomes true bounded b n  w  
cc bounded b n  w  
cc   
k
k
proof  n  w    states expanded goalfound becomes true  k states expanded
per call search procedure  clearly b n  w  
c number calls best firstk
search terminates without setting goalfound true  move costs least c c   
result follows 

focus cost incurred complete path found  following lemma
related property enjoyed tb a   stated theorem   hernandez et al         
lemma   cost moves incurred agent controlled tb wa   goalfound
become true cannot exceed  wc  sstart   sgoal   
   

fih ern andez   baier    

proof  assume goalfound become true  let path starts sstart   ends
scurrent defined following parent pointers back sstart   path prefix
path lowest f  value state previous run wa  therefore  lemma   
c     wc  sstart   sgoal    worst case terms number movements necessary reach
goal path coincide sstart   case  agent backtrack
way back sstart   sstart reached  agent move goal path cost
wc  sstart   sgoal    thus agent may incur cost higher  wc  sstart   sgoal   reach
goal 

obtain lower bound upper bound solution cost tb wa  
follows straightforwardly two previous lemmas 
theorem   let c solution cost obtained tb wa    then 
b

n  w   
n  w     
cc c b
cc    wc  sstart   sgoal   
k
k

proof  put together inequalities implied lemmas     



first observation result shown empirically domains 
w increased  n  w  may decrease substantially  gaschnig         example  reports
  puzzle n     exponential depth solution whereas n  w   large w
subexponential d  domains grid pathfinding  well known using high values
w results substantial reductions expanded nodes  see e g   likhachev  gordon    thrun 
       thus  increasing w  lower bound first term upper bound may
decrease substantially  second term upper bound   wc  sstart   sgoal    increasing
w  may increase linearly w  suggests situations better  rather
worse quality solutions may found w increased  see later  confirmed
experimental evaluation 
second observation bounds factor b n  w     kc decreases k increases  suggests k large  i e   close n  w    increasing w may actually lead
decreased performance 
putting observations together  theorem   suggests tb wa   produce better solutions tba  k relatively small problems wa  expands fewer nodes
a  offline mode  problems wa  expand fewer nodes a  exist  wilt  
ruml        
finally  hard see theorem   generalized algorithms provide
optimality guarantees  given two search algorithms b provide bounds whose
relative performance known  theorem used predictor relative performance
tb a  versus tb b  
    non reversible search problems via restarting
non reversible problems  well known real time heuristic search algorithms lss lrta 
fail when  execution episode  state path goal visited 
time bounded algorithms tb bfs  fail condition
fail soon physical backtrack required non reversible action  second condition
   

fit ime  b ounded b est f irst earch r eversible n   reversible earch g raphs

failure reason sometimes time bounded algorithms discarded use nonreversible domains  objective section propose time bounded algorithm that 
used non reversible problems  fail due latter condition  due former 
modification tb wa   non reversible problems comes incorporating
two key characteristics real time search algorithms lss lrta   search restarts heuristic
updates  indeed  whenever physical backtracking available  or  generally 
predefined restart condition holds  algorithm restarts search  addition  avoid getting
trapped infinite loops  algorithm updates heuristic using update rule lsslrta   call resulting algorithm restarting time bounded weighted a   tbr  wa    
algorithm   shows details tbr  wa    lines      relevant difference
previous algorithm  algorithm restarts search agent path certain
restart condition  must become true action leading current state
 scurrent   parent  parent scurrent    
algorithm    restarting time bounded weighted a 
 
 
 
 
 
 
 
 
 
  
  
  
  
  
  
  
  
  
  
  
  

function movetogoal  
scurrent sstart
initializesearch  
scurrent    sgoal
goalfound   false
bounded wa      false return false 
scurrent path
scurrent state scurrent path
execute movement scurrent
else restart condition holds
update heuristic function h using lss lrta  update rule  equation   
initializesearch  
else
scurrent parent scurrent   
execute movement scurrent
return true
procedure main
movetogoal     true
print the agent goal state 
else
print no solution 

note prior restarting algorithm updates heuristic lss lrta  would 
implemented version dijkstras algorithm  note number states may
need updated may bounded constant  needed  compute update
incremental manner  across several episodes  refer reader analysis koenig
sun         hernandez baier        details implementation proofs
correctness 
      ermination tbr  wa  
tbr  wa   used reversible non reversible domains  heuristic function h
initially consistent search graph strongly connected  algorithm terminates 
   

fih ern andez   baier    

theorem   let p search problem strongly connected search graph  tbr  wa   
run consistent heuristic h  finds solution p  
proof theorem   depends intermediate results  proofs
appear elsewhere  following result establishes h consistent  remains consistent
updated 
lemma    koenig   sun        h consistent remains consistent h updated
equation   
another intermediate results says h cannot decrease update following equation   
lemma    koenig   sun        h initially consistent h s   every s  cannot decrease
h updated following equation   
another intermediate result says h s  finitely converges  intuitively means even
wanted apply infinite number updates h  point on  h change
anymore 
definition    finite convergence  series functions  fi  i  finitely converges function f
exists n every n  holds fm   f   addition  say series
functions  fi  i  finitely converges exists function f finitely converges 
lemma   let h  consistent heuristic function p strongly connected graph  let
   hi  i  hk   function results     assigning hk hk      
updating hk   using equation    set closed open generated bounded weighted
a  run rooted arbitrary state  finitely converges 
proof  first observation hk  s  bounded positive number every
every k  indeed  lemma    hk consistent  thus admissible  every k 
addition  problem solution  hk  s  c  s  sgoal    every every k 
second observation set h values state take finite  even
infinite  formally prove h s     hk  s    k    finite set  indeed  hard verify
induction  we leave exercise reader  using equation    every k   
holds hk  s    c ks     h   s    some  possibly empty path ks originating finishing
s    recall hk  s  bounded observe finitely many paths
graph whose cost bounded  conclude h s  finite set  every s 
proof follows contradiction  assuming finitely converge 
non decreasing  lemma     possibility increases infinitely often  implies
least one state h s  infinite  contradiction  conclude finitely
converges 

note previous lemma saying anything function converges to 
need know function rest proof  last intermediate result
related result ebendt drechsler        stated section      lemma    
lemma   every moment execution weighted a  state sroot   h consistent 
every state open list  holds g s  wcclosed  sroot   s  
   

fit ime  b ounded b est f irst earch r eversible n   reversible earch g raphs

proof  let cost optimal path sroot visits states closed  let s 
state precedes   s  part optimal path have 
cclosed  sroot   s      c s    s    cclosed  sroot   s  

   

successor s    holds that 
g s  g s      c s    s  

   

g s    wc  sroot   s    

   

g s  wc  sroot   s      c s    s  

   

g s  wcclosed  sroot   s      wc s    s    w cclosed  sroot   s      c s    s   

   

lemma    that 

inequalities     imply 
w     cclosed c  

substituting equation   that 
g s  wcclosed  sroot   s  

   


finishes proof 
provide proof main result section 

proof  of theorem      let us assume algorithm terminate thus enters infinite
loop  note means algorithm restarts infinite number times  otherwise  weighted a 
would eventually find goal state  allowing agent reach goal   assume moment
infinite execution h converged  we know lemma     let s  s       
infinite sequence states si state search restarted  prove
every i  h si     h si     
let denote contents open list exactly algorithm expanded si     closed
denote contents closed list immediately heuristic updated  equation   
following holds 
h si     cclosed  si       h so   



   

rewrite equation   as 
wh si     wcclosed  si       wh so   

   

let g so   denote g value exactly si   preferred expansion   now 
prove wcclosed  si     g so    indeed  closed follows lemma  
fact cclosed c w    hand  open  obtain
wcclosed  si     g so   lemma    use fact write 
wh si   g so     wh so   
   

    

fih ern andez   baier    

algorithm preferred expand si   instead   g so     wh so   g si      
wh si      hence 
wh si   g si       wh si     
    
finally  w     g si         obtain h si     h si     
implies sequence states s  s        strictly decreasing h values 
state space finite  must case si   sj   j    j  would
lead conclude h si     h si    contradiction 


   experimental results
section presents experimental results  objective experimental evaluation
understand effect weight configuration performance tb wa   tbr
 wa    end  evaluate tb wa   reversible search problems  grid pathfinding
   puzzle   tbr  wa   non reversible problem  the racetrack   reference  compare
lss lrtwa   rivera et al          version lss lrta  uses weighted a  rather
a  search phase  used algorithm since among real time search
algorithms able exploit weights search  lss lrtwa  configured perform
single action execution phase 
decided include results wlss lrta   rivera et al          another real time
search algorithm exploits weights  two reasons  first  new results focused relatively large lookahead values  over       lookahead values  rivera et al         
grid like terrain  observe improvements significant  second  observed that 
   puzzle  wlss lrta  yields worse performance w increased 
section     report results       neighbor grids similar manner reported
earlier publication  hernandez et al          section     reports results       neighbor
grids using game time model  cf  section       section     reports results non reversible
maps deterministic version setting used evaluate algorithms stochastic shortestpath problem  bonet   geffner         finally  subsection     reports results    puzzle 
path finding tasks section     section     evaluated using   neighbor  bulitko
et al         koenig   likhachev        and   neighbor
grids  aine   likhachev         see
figure     costs movements         for  respectively  orthogonal  diagonal 
chess knight movements  implementation agent cannot jump obstacles  addition  diagonal movement  d  d   for         illegal  x  y  either  x d  y   x   d 
obstacle    neighbor    neighbor grids use octile distance euclidean
distance heuristic values  respectively  experiments run intel r  core tm  i           ghz machine   gbytes ram running linux  algorithms common
code base use standard binary heap open  ties open broken favor larger
g values  rule breaking ties 
    results   neighbor    neighbor grid maps
evaluated algorithms considering solution cost runtime  measures solution quality
efficiency  respectively  several lookahead weight values 
used         maps video game baldurs gate  bg   room maps
 rooms   maps different size starcraft  sc  available n  sturtevants
   

fit ime  b ounded b est f irst earch r eversible n   reversible earch g raphs

  neighbor bg maps

    
    
    

algorithm

cost  log scale 

cost  log scale 

 
   
  

 
tb

 w
a 

   
  

 
 w
a 

  neighbor counter strike maps

lookahead  
lookahead   
lookahead    
lookahead    
lookahead    
lookahead     

     
     

tb

algorithm

  neighbor starcraft maps

      

   
  

 
tb

 w
a 

   
  

 
 w
a 
tb

tb

 w
a 

   
  

 
   
  

 
tb

 w
a 

   
  

 
   
  

 w
a 
tb

   
  

 w
a 
tb

tb

 w
a 

   
  

 w
a 

   
  
tb

 w
a 
tb

 

   
 

   

   
 

   

 

    

 w
a 

    

     

   
  

    

lookahead  
lookahead  
lookahead   
lookahead   
lookahead    
lookahead    

tb

    
    

cost  log scale 

lookahead  
lookahead  
lookahead   
lookahead   
lookahead    
lookahead    

     
cost  log scale 

  neighbor room maps
     

    
    
   

lookahead  
lookahead   
lookahead    
lookahead    
lookahead    
lookahead     

 e   

      
     
     

algorithm

  
a 
 

  
 

  
tb

 w

a 
 

  
 

  
tb

 w

a 
 

  
 

  
 w
tb

 w

a 
 

  
 

  
tb

 w

a 
 

  
 

  
tb

tb

 w

a 
 

  
 

  
a 
 

  
 

  
tb

 w

a 
 

  
 

  
tb

 w

a 
 

  
 

  
tb

 w

a 
 

  
 

  
  
 
tb

 w

a 
 
 w

tb

tb

 w

a 
 

  
 

  

    

algorithm

figure      neighbor results  solution cost tends decrease w lookahead parameter
increased 

path finding repository  sturtevant         addition  used   large maps counter strike
 cs   whose sizes range                     
evaluated six lookahead values                                  maps six
lookahead values                              sc cs maps  used six weight values
                                map generated    random solvable search problems  resulting      problems bg       problems rooms       problems sc     
problems cs 
figures     show performance measures   neighbor grid maps  note
average search time per episode across algorithms using lookahead
parameter  search time per episode proportional lookahead parameter
depends variable  in particular  depend weight   thus fair conclusions
drawn comparing two configurations lookahead parameter set
value 
   

fih ern andez   baier    

  neighbor bg maps

 
   
  

 
tb

 w
a 

   
  

 
 w
a 

  neighbor counter strike maps

lookahead  
lookahead   
lookahead    
lookahead    
lookahead    
lookahead     

runtime  ms 

runtime  ms 

   
  

 
   
  

algorithm

  neighbor starcraft maps

  

 w
a 

tb

tb

 w
a 

   
  
 w
a 

a 
  

algorithm

tb

 

  
  

  
tb
 

w

a 
  

  

  
tb
 

w

a 
  

  

  
w
tb
 

tb
 

w

a 
  

  

  
  
a 
  
w

tb
 

tb
 

w

a 
  

  

  

 

 

 

  
 
 
 
 
 
 w
a 

 

   
  

 

  

tb

runtime  ms 

 

lookahead  
lookahead  
lookahead   
lookahead   
lookahead    
lookahead    

  

tb

lookahead  
lookahead  
lookahead   
lookahead   
lookahead    
lookahead    

 
runtime  ms 

  neighbor room maps

 
 
 

lookahead  
lookahead   
lookahead    
lookahead    
lookahead    
lookahead     

     
     

    
   

algorithm

 

 

    
a  
tb
 w

tb
 w

a  

    

 
    
a  
tb
 w

 
    
a  
tb
 w

 
    

    

a  
tb
 w

 w

tb
 w

a  

  
a 
 

  
 

  
tb

tb

 w

a 
 

  
 

  

 w

a 
 

  
 

  
tb

tb

 w

a 
 

  
 

  
  
 
a 
 

 w
tb

tb

 w

a 
 

  
 

  

 

  

algorithm

figure      neighbor results  search time typically decreases w lookahead parameter
increased 

observe following relations hold maps regarding solution cost search time 

solution cost lookahead values  solution cost decreases w increased  significant improvements observed lower lookahead values  surprising light
cost bound  theorem      large lookahead parameters         value w
affect solution cost significantly  lookahead parameter increases  fewer search
episodes needed less physical backtracks  back moves  needed  hernandez et al  
       back moves strongly influence performance algorithms  tb wa   
w increased number back moves decreases  explains improvement solution quality  example  bg maps  using lookahead    average reduction
back moves          comparing w     w      whereas lookahead    
reduction      comparing w     w     
   

fit ime  b ounded b est f irst earch r eversible n   reversible earch g raphs

   neighbor bg maps
lookahead  
lookahead  
lookahead   
lookahead   
lookahead    
lookahead    

    
    
    
    

     
    
    
    
    

   

algorithm

cost  log scale 

cost  log scale 

 
   
  

 
tb

 w
a 

   
  

 
 w
a 

   neighbor counter strike maps

lookahead  
lookahead   
lookahead    
lookahead    
lookahead    
lookahead     

     
     

tb

algorithm

   neighbor starcraft maps

      

   
  

 
tb

 w
a 

   
  

 w
a 

   
  
tb

 
 w
a 
tb

tb

 w
a 

   
  

 
   
  

 
tb

 w
a 

   
  

 
tb

 w
a 

   
  

 
   
  

 w
a 
tb

 
 w
a 
tb

 

   
  

 w
a 

   
  
tb

 w
a 

 

   
   

   

tb

lookahead  
lookahead  
lookahead   
lookahead   
lookahead    
lookahead    

     
cost  log scale 

     
cost  log scale 

   neighbor room maps

    
    
   

lookahead  
lookahead   
lookahead    
lookahead    
lookahead    
lookahead     

 e   

      
     
     

algorithm

  
a 
 

  
 

  
tb

 w

a 
 

  
 

  
tb

 w

a 
 

  
 

  
 w
tb

 w

a 
 

  
 

  
tb

 w

a 
 

  
 

  
tb

tb

 w

a 
 

  
 

  
a 
 

  
 

  
tb

 w

a 
 

  
 

  
tb

 w

a 
 

  
 

  
tb

 w

a 
 

  
 

  
  
 
tb

 w

a 
 
 w

tb

tb

 w

a 
 

  
 

  

    

algorithm

figure       neighbor results  solution cost tends decrease w lookahead parameter
increased 

search time w increased  search time decreases significantly lower lookahead values
decreases moderately higher lookahead values  rooms observe largest
improvements w increased  behavior rooms explained wa 
performs well type map w     
figures     show performance measures    neighbor grid maps  observe
relations observed   neighbor grid maps regarding solution cost search time 
        n eighbor versus    n eighbor g rid aps
lower cost solutions obtained   neighbor grids    neighbor grids lookahead values          bg  note exist    neighbor movements
expensive   neighbor moves  small lookaheads     neighbor solutions may
similar number moves  worse quality   neighbor solutions  hand 
   

fih ern andez   baier    

   neighbor bg maps

 
   
  

 
tb

 w
a 

   
  

 

   neighbor counter strike maps

lookahead  
lookahead   
lookahead    
lookahead    
lookahead    
lookahead     

runtime  ms 

runtime  ms 

 w
a 

algorithm

   neighbor starcraft maps

  

   
  

 

algorithm

 w
a 

tb

tb

 w
a 

   
  
 w
a 

a 
  

   
  

 

  
  

  
tb
 w

a 
  

  

  
tb
 w

a 
  

  

  
tb
 w

a 
  

  

  
  
tb
 w

a 
  
tb
 w

tb
 w

a 
  

  

  

 

  
 
 
 
 
 

tb

 

 

 

 w
a 

 

  

   
  

 

  

tb

runtime  ms 

 

lookahead  
lookahead  
lookahead   
lookahead   
lookahead    
lookahead    

  

tb

lookahead  
lookahead  
lookahead   
lookahead   
lookahead    
lookahead    

 
runtime  ms 

   neighbor room maps

 
 
 

lookahead  
lookahead   
lookahead    
lookahead    
lookahead    
lookahead     

     
     

    
   

algorithm

 

 

    
a  
tb
 w

tb
 w

a  

    

 
    
a  
tb
 w

 
    
a  
tb
 w

 
    

    

a  
tb
 w

 w

tb
 w

a  

  
a 
 

  
 

  
tb

tb

 w

a 
 

  
 

  

 w

a 
 

  
 

  
tb

tb

 w

a 
 

  
 

  
  
 
a 
 

 w
tb

tb

 w

a 
 

  
 

  

 

  

algorithm

figure       neighbor results  search time typically decreases w lookahead parameter increased 

 a 

 b 

figure      neighborhoods  a     neighborhoods  b  

   

fit ime  b ounded b est f irst earch r eversible n   reversible earch g raphs

  neighbor counter strike maps
     

tb wa       
tb wa       
tb wa       
tb wa       
tb wa       
tb wa       

    
    
    
    
    
    
    
    
    

tb wa       
tb wa       
tb wa       
tb wa       
tb wa       
tb wa       

    
number time intervals

number time intervals

     

   neighbor counter strike maps

    
    
    
    
    
    
    

   

   

   

   

   

   

    

duration time interval  ms 

   

   

   

   

   

   

duration time interval  ms 

figure    results game time model 
similar quality observed lookahead values  tb wa    almost values w
lookahead configurations     neighbor grids performs fewer moves   neighbor grids 
example  sc w       lookahead parameter         neighbor grids need
factor     moves    neighbor grids  note however    neighbor moves
higher cost   neighbor moves  regarding runtime  tb wa     neighbor connectivity runs faster tb wa      neighbor connectivity  happens expansion
state    neighbor connectivity takes time expanding state   neighbor
connectivity 
    results game time model
report results tb wa   using game time model counter strike maps  and    neighbor grids  use                              milliseconds duration time
intervals  setting  quality solution measured number time intervals
required solve problem  fewer intervals used  better solution quality
is 
figure   shows average performance  observe length time interval increases  tb wa   yields solutions better quality  hand  w increased  tb wa  
obtains better solutions  observed clearly duration intervals
small  e g      ms   observe better quality solutions     rather   neighbor
connectivity     neighbor connectivity agent perform knight move
single interval 
    results non reversible search graphs  racetrack
section compare tbr wa   lss lrtwa  deterministic version racetrack problem  barto  bradtke    singh        bonet   geffner         problem race   

fih ern andez   baier    

extended hansen racetrack
   

tbr wa       
tbr wa       
tbr wa       
tbr wa       
lss lrt wa       
lss lrt wa       
lss lrt wa       
lss lrt wa       

   
   

tbr wa       
tbr wa       
tbr wa       
tbr wa       
lss lrt wa       
lss lrt wa       
lss lrt wa       
lss lrt wa       

   
   
number actions

   
number actions

game map racetrack
   

   
   

   
   
   
   
   

   

   

average time per search  ms 

 

 

 

  

 

  

  

 

 
  

 

 

  

 

  

  

 
  

 

 
  

 

 

  

 

  

 

 

  

  

 

 

  

  

 

  
  

  

 

  

average time per search  ms 

figure    results racetrack grids 
track represented grid cells marked obstacles  similar grid pathfinding 
problem move agent set initial positions cells marked final
position  nevertheless  problem agent associated velocity  set actions
involve accelerating  vertically horizontally   performing no op action maintains
current velocity 
state racetrack tuple  x  y  vx   vy     x  y  position vehicle 
 vx   vy   velocity vector  actions represented tuples form  ax   ay   
ax   ay            correspond acceleration vector  unlike original version  barto
et al          actions deterministic one initial one destination cell 
actions deterministic   ax   ay   performed  x  y  vx   vy    new state given
 x        vx    vy     vx    vx  ax vy    vy  ay    x        computed considering
vehicle changes velocity  vx    vy    moving  movement towards  x       
would lead crashing obstacle  bonet geffner        do  leave vehicle next
obstacle velocity        
experiments  used two racetracks  firstwhich refer hrtis   
    grid corresponds extended version racetrack used hansen zilberstein         which       grid   use game map ar    sr baldurs gate 
whose size    x     refer map grt 
generated    random test cases hrt grt manhattan distance
initial state goal state greater half width map  absolute
value components velocity vector restricted    heuristic
use euclidean distance divided maximum speed 
evaluated tbr  wa   lss lrtawa  four weight values                       figure   shows plot number actions versus average time per search episode  tbr  wa  
number actions corresponds sum number moves plus number times
   

fit ime  b ounded b est f irst earch r eversible n   reversible earch g raphs

tbwa    
tbwa    
tbwa    
tbwa    
lss lrtwa    
lss lrtwa    
lss lrtwa    
lss lrtwa    

 
  
  
 
  
 
  
 
  
 
  
 
  
 
  
 
  
 
  
 
  
 

   

lookahead

      

tbwa    
tbwa    
tbwa    
tbwa    
lss lrtwa    
lss lrtwa    
lss lrtwa    
lss lrtwa    

     

 
  
  
 
  
 
  
 
  
 
  
 
  
 
  
 
  
 
  
 
  
 

    

   puzzle
number expansions  log scale 

cost  log scale 

   puzzle

lookahead

figure    cost time comparison tb wa lss lrtwa 

vehicle move  tbr  wa   make movements search
restarted 
important note time spent updating heuristic proportional number
states updated  update tbr  wa   may take time update
lss lrtwa  closed list may contain states former algorithm 
reason use comparison average time per search  considers search
update time 
hrt  figure    observe worst behavior one obtained tbr  wa        
algorithms improve performance increasing w  tbr  wa    used weight
greater      algorithm clearly yields best performance  grt  worst algorithms tbr  wa        lss lrta       here  algorithms improve increasing
weight 
benchmark used fewer problems game maps  carried
    confidence analysis cost solutions  hrt  showed costs
best configuration tbr  wa        could     away true mean 
lss lrta       costs could     away true mean  grt  hand 
difference performance two best configurations tbr     lss lrtwa    
statistically significant 
finally  experiments showed computational cost learning phase tb wa  
higher lss lrta wa    indeed  number updates carried tb wa  
    times less number updates carried lss lrta wa   hrt     time
less grt  explains better performance terms runtime 
   

fih ern andez   baier    

    results    puzzle
chose    puzzle another domain evaluating time bounded algorithms 
build    puzzle implementation extending richard korfs implementation available carlos linaress homepage   present results tb wa    lss lrt wa   algorithms 
use     test cases presented korf         uses manhattan distance heuristic 
domain report results slightly different way  first  omit results tb a  
 tb wa   w      terminate reasonable time  due fact
a  needs many expansions solving hardest test cases  second  use number
expansions instead runtime efficiency measure  domain  found measure
stable since  general  solving     problems take much time
w         s w          s w       thus time prone affected external factors
controlled operating system 
figure   shows performance tb wa   lss lrt wa    use lookahead values
                            weights               observe following relations 
solution cost solution cost tb wa   decreases w increased almost lookahead
values  tb wa   obtains better results lss lrtwa  lookahead values
w      w     performance tb wa   worse performence lsslrta   hand  tb wa   w     obtains solution     times better
average solution obtained lss lrta   lss lrtwa  w      
number expansions number expansions tb wa   decreases w increased 
tb wa   efficient lss lrtwa  lookahead values w     
worst performing configuration tb wa   w     
note curve remains flat several configurations  small
number expansions needed solve problem 
conclusion  considering solution cost number expansions     puzzle tb wa  
better algorithm  instance  average solution cost tb wa       times better
average average solution cost lss lrta  
compare greedy algorithm  parberry         real time domainspecific  unlike our 

   summary conclusions
paper introduced time bounded best first search  generalization real time search
algorithm time bounded a   addition  introduced restarting version time bounded
approach  tbr  wa    unlike tb bfs   better coverage non reversible domains 
carried theoretical analysis tb wa   tbr  wa    including termination
results cost bound tb wa    given weight w  bound suggests tb wa  
significantly superior tb a   precisely search problems wa  expands significantly
fewer states a   addition  bound suggests tb wa   may yield benefits
domains wa   run offline  yield improvements a   theoretical
bounds easily adapted instances best first search offer guarantees solution
   http   scalab uc m es clinares download source ida ida html

   

fit ime  b ounded b est f irst earch r eversible n   reversible earch g raphs

quality  tbr  wa    proved termination strongly connected graphs  even contain
non reversible actions  property enjoyed real time search algorithms lrta 
family enjoyed tb bfs  
experimental evaluation  focused pathfinding     puzzle  racetrack
problem  found tb wa   tbr  wa   significantly superior real time
search algorithms lrta  family  addition  found performance tends improve
weight parameter increased  without increasing time per search episode  finding
interesting although quality improved increasing lookahead parameter 
increases time spent search episode 
well known many search benchmarks  wa  may expand significantly fewer nodes
a   consistent this  experiments  time bounded versions suboptimal algorithms
weighted a  produce significantly better solutions obtained tb a    improvements less noticeable lookahead parameter large  predicted theory 
first observe performance gains using weights real time setting 
indeed  findings consistent rivera et al          obtain better solutions
using weighted heuristics  work adds another piece evidence justifies studying
incorporation weights real time algorithms  e g   ribs eda   sturtevant  bulitko 
  bjornsson        sharon  felner    sturtevant         finally  sla   shue   zamani       
lrts  bulitko   lee        two algorithms perform backtracking moves 
investigation whether restarts could provide benefits algorithms left future
work 

acknowledgements
thank vadim bulitko providing counter strike maps  research partly funded
fondecyt grant number         

references
aine  s     likhachev  m          truncated incremental search  faster replanning exploiting
suboptimality  proceedings   th aaai conference artificial intelligence  aaai  
bellvue  washington  usa 
barto  a  g   bradtke  s  j     singh  s  p          learning act using real time dynamic programming  artificial intelligence                 
bjornsson  y   bulitko  v     sturtevant  n  r          tba   time bounded a   proceedings
  st international joint conference artificial intelligence  ijcai   pp         
bonet  b     geffner  h          labeled rtdp  improving convergence real time dynamic
programming   icaps  vol     pp       
bulitko  v     lee  g          learning real time search  unifying framework  journal
artificial intelligence research             
bulitko  v   bjornsson  y   sturtevant  n     lawrence  r          real time heuristic search
game pathfinding  applied research artificial intelligence computer games  springer 
burns  e   ruml  w     do  m  b          heuristic search time matters  journal artificial
intelligence research             
   

fih ern andez   baier    

ebendt  r     drechsler  r          weighted a  search   unifying view application  artificial
intelligence                    
gaschnig  j          exactly good heuristics   toward realistic predictive theory bestfirst search  reddy  r   ed    proceedings  th international joint conference
artificial intelligence  ijcai   pp          william kaufmann 
hansen  e  a     zilberstein  s          lao  heuristic search algorithm finds solutions
loops  artificial intelligence               
hart  p  e   nilsson  n     raphael  b          formal basis heuristic determination
minimal cost paths  ieee transactions systems science cybernetics       
hernandez  c   asn  r     baier  j  a          time bounded best first search  proceedings
 th symposium combinatorial search  socs  
hernandez  c     baier  j  a          avoiding escaping depressions real time heuristic
search  journal artificial intelligence research             
hernandez  c   baier  j  a   uras  t     koenig  s          tbaa   time bounded adaptive a  
proceedings   th international joint conference autonomous agents multi
agent systems  aamas   pp           valencia  spain 
koenig  s          agent centered search  artificial intelligence magazine                
koenig  s     likhachev  m          fast replanning navigation unknown terrain  ieee
transactions robotics                
koenig  s     likhachev  m          real time adaptive a   proceedings  th international
joint conference autonomous agents multi agent systems  aamas   pp         
koenig  s     sun  x          comparing real time incremental heuristic search real time
situated agents  autonomous agents multi agent systems                
korf  r  e          real time heuristic search  artificial intelligence                  
korf  r  e          linear space best first search  artificial intelligence              
likhachev  m   gordon  g  j     thrun  s          ara   anytime a  provable bounds
sub optimality  proceedings   th conference advances neural information
processing systems  nips   vancouver  canada 
parberry  i          memory efficient method fast computation short    puzzle solutions 
ieee trans  comput  intellig  ai games               
pearl  j          heuristics  preintelligent search strategies computer problem solving 
addison wesley longman publishing co   inc   boston  ma  usa 
pohl  i          heuristic search viewed path finding graph  artificial intelligence       
       
rivera  n   baier  j  a     hernandez  c          incorporating weights real time heuristic
search  artificial intelligence           
schmid  k   tomic  t   ruess  f   hirschmuller  h     suppa  m          stereo vision based indoor outdoor navigation flying robots  ieee rsj international conference intelligent robots systems  iros   pp           
   

fit ime  b ounded b est f irst earch r eversible n   reversible earch g raphs

sharon  g   felner  a     sturtevant  n  r          exponential deepening a  real time agentcentered search  proceedings  th symposium combinatorial search  socs   pp 
       
shue  l     zamani  r          admissible heuristic search algorithm  komorowski  h  j  
  ras  z  w   eds    proceedings  th international symposium methodologies
intelligent systems  ismis   vol      lncs  pp        springer 
sturtevant  n          benchmarks grid based pathfinding  transactions computational
intelligence ai games                
sturtevant  n  r   bulitko  v     bjornsson  y          learning agent centered search 
proceedings  th international joint conference autonomous agents multi agent
systems  aamas   pp          toronto  ontario 
wilt  c  m     ruml  w          weighted a  fail   proceedings  th symposium combinatorial search  socs   niagara falls  ontario  canada 

   


