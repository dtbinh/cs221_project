journal of artificial intelligence research                  

submitted        published      

computing repairs of inconsistent dl programs over el ontologies
eiter   kr   tuwien   ac   at

thomas eiter
michael fink
daria stepanova

fink   kr   tuwien   ac   at
dasha   kr   tuwien   ac   at

institut fr informationssysteme  tu wien 
favoritenstrae            vienna  austria

abstract
description logic  dl  ontologies and non monotonic rules are two prominent knowledge
representation  kr  formalisms with complementary features that are essential for various applications  nonmonotonic description logic  dl  programs combine these formalisms thus providing support for rule based reasoning on top of dl ontologies using a well defined query interface
represented by so called dl atoms  unfortunately  interaction of the rules and the ontology may
incur inconsistencies such that a dl program lacks answer sets  i e   models   and thus yields no
information  this issue is addressed by recently defined repair answer sets  for computing which
an effective practical algorithm was proposed for dl lite a ontologies that reduces a repair computation to constraint matching based on so called support sets  however  the algorithm exploits
particular features of dl lite a and can not be readily applied to repairing dl programs over
other prominent dls like el  compared to dl lite a   in el support sets may neither be small
nor only few support sets might exist  and completeness of the algorithm may need to be given
up when the support information is bounded  we thus provide an approach for computing repairs
for dl programs over el ontologies based on partial  incomplete  support families  the latter are
constructed using datalog query rewriting techniques as well as ontology approximation based on
logical difference between el terminologies  we show how the maximal size and number of support sets for a given dl atom can be estimated by analyzing the properties of a support hypergraph 
which characterizes a relevant set of tbox axioms needed for query derivation  we present a declarative implementation of the repair approach and experimentally evaluate it on a set of benchmark
problems  the promising results witness practical feasibility of our repair approach 

   introduction
description logics  dls  are a powerful formalism for knowledge representation  kr  that is
used to formalize domains of interest by describing the meaning of terms and relationships between
them  they are well suited for terminological modelling in contexts such as  the semantic web  data
integration and ontology based data access  calvanese  de giacomo  lenzerini  lembo  poggi   
rosati      b  calvanese  de giacomo  lembo  lenzerini  poggi    rosati      a   reasoning
about actions  baader  lutz  milicic  sattler    wolter         spatial reasoning  zccep   mller 
       or runtime verification and program analysis  baader  bauer    lippmann        kotek 
simkus  veith    zuleger         to mention a few 
as most dls are fragments of classical first order logic  they have some shortcomings for modelling application settings  where nonmonotonicity or closed world reasoning needs to be expressed 
rules as in nonmonotonic logic programming offer these features  in addition  they serve well as
a tool for declaring knowledge and reasoning about individuals  and for modelling nondeterminism in model generation as possible in answer set programming  to get the best out of the two
c
    
ai access foundation  all rights reserved 

fie iter   f ink   s tepanova



    blacklisted  staff




     staffrequest  hasaction action  hassubject staff  hastarget project
o       blacklistedstaffrequest  staffrequest  hassubject blacklisted



    staffrequest r        hassubject r    john      blacklisted  john 



    hastarget r    p        hasaction r    read       action read  


     projfile p          hasowner  p    john  






      chief  y    hasowner  z   y    projfile z   









     grant x   dl project  projfile  staffrequest  x   not deny x  
p 




      deny x   dl staff  chief   blacklistedstaffrequest  x  





    


hasowner
 y 
z  
not
grant x  






dl   hastarget  x  y    dl   hassubject  x  z  















figure    dl program  over a policy ontology
worlds of dls and nonmonotonic rules  the natural idea of combining them led to a number of
approaches for such a combination  which are often called hybrid knowledge bases  see the work
of motik and rosati        and references therein  among them  nonmonotonic description logic
 dl  programs  eiter  ianni  lukasiewicz  schindlauer    tompits        are a prominent approach
in which so called dl atoms serve as query interfaces to the ontology in a loose coupling and enable a bidirectional information flow between the rules and the ontology  the possibility to add
information from the rules part prior to query evaluation allows for adaptive combinations  however  the loose interaction between rules and ontology can easily lead to inconsistency  that is to a
lack of models or answer sets 
example   consider the dl program    ho  pi in figure   formalizing an access policy over
an ontology o   ht   ai  bonatti  faella    sauro         whose taxonomy  tbox  t is given
by          while         is a sample data part  abox  a  besides facts            and a simple
rule       the rule part p contains defaults            expressing that staff members are granted
access to project files unless they are blacklisted  and a constraint       which forbids that owners of project information lack access to it  both parts  p and o  interact via dl atoms such as
dl project  projfile  staffrequest  x   the latter specifies a temporary update of o via the operator   prior to querying it  i e  additional assertions project c  are considered for each individual c  such that projfile c  is true in an interpretation of p  before all instances x of staffrequest
are retrieved from o  inconsistency arises as john  the chief of project p  and owner of its files 
has no access to them 
inconsistency is a well known problem in logic based and data intensive systems  and the problem of treating logically contradicting information has been studied in various fields  e g  belief
revision  alchourrn  grdenfors    makinson        grdenfors   rott         knowledge base
updates  eiter  erdem  fink    senko         diagnosis  reiter         ontology based data access  lembo  lanzerini  rosati  ruzzi    savo         nonmonotonic reasoning  brewka       
sakama   inoue         and many others   cf  bertossi  hunter    schaub        nguyen       
martinez  molinaro  subrahmanian    amgoud        bertossi         in hybrid formalisms so
far inconsistency management has concentrated mostly on inconsistency tolerance  for instance 
   

fic omputing r epairs of i nconsistent dl p rograms over el o ntologies

for mknf knowledge bases paraconsistent semantics was developed by knorr  alferes  and hitzler
        huang  li  and hitzler        and kaminski  knorr  and leite         for dl programs inconsistency tolerance issues were targeted by fink         where a paraconsistent semantics based
on the logic of here and there was introduced  furthermore  phrer  heymans  and eiter       
considered suppressing certain problematic dl atoms  these approaches aimed at reasoning in
an inconsistent system rather then making required changes to the system to arrive at a consistent
state  this is in contrast to repair techniques that have been recently developed by eiter  fink  and
stepanova            d  
in the theoretical framework for repairing inconsistent dl programs proposed by eiter et al 
        the ontology abox  a likely source of errors  is changed such that the modified dl program
has answer sets  called repair answer sets  different repair options including deletion of abox formulas and various restricted forms of addition have been considered together with a naive algorithm
for computing repair answer sets which lacked practicality 
an effective repair algorithm in which all dl atoms can be decided without dynamic ontology
access was presented by eiter  fink  and stepanova         it is based on support sets  eiter  fink 
redl    stepanova      b  for dl atoms  the portions of the input that together with the abox
determine the truth value of the dl atom  the algorithm exploits complete support families  i e 
stocks of support sets from which the value of a dl atom under every interpretation can be determined  such that an  repeated  ontology access can be avoided  the approach works well for
dl lite a   which is a prominent tractable dl  since complete support families are small and easy
to compute 
however  unfortunately  for other dls this approach is not readily usable  because in general
there can be large or infinite support families  this applies even for el  which is another wellknown important dl that offers tractable reasoning and is widely applied in many domains  including biology   cf  e g   schulz  cornet    spackman        aranguren  bechhofer  lord  sattler   
stevens         medicine  steve  gangemi    mori         chemistry  policy management  etc  due
to the features of el that include range restrictions and concept conjunctions on the left hand side
of inclusion axioms  a dl atom accessing an el ontology can have arbitrarily large and infinitely
many support sets in general  while the latter is excluded for acyclic tboxes  often occurring in
practice  gardiner  tsarkov    horrocks         complete support families can be still very large 
and constructing as well as managing them might be impractical  this obstructs the deployment of
the approach proposed by eiter et al       d  to el ontologies  in this paper we tackle this issue and
develop repair computation techniques for dl programs over ontologies in el  we focus on el 
since apart from being simple and widely used  this dl is well researched  and available effective
algorithms for query rewriting and other important reasoning can be readily used 
more specifically  we introduce here a more general algorithm for repair answer set computation that operates on partial  incomplete  support families along with techniques how such families
can be effectively computed  the problem of computing repair answer sets for dl programs over
el ontologies is p   complete  in its formulation as a decision problem  we refer to the work of
stepanova        for details on the complexity  
our contributions and advances over previous works by eiter et al       b      d        are
summarized as follows 
 for effective computation of repair answer sets we exploit the support sets of eiter et al 
     d   in contrast to the approaches of eiter et al       d         however  where tbox
classification is invoked  we use datalog rewritings of queries for computing support sets
   

fie iter   f ink   s tepanova

 see also hansen  lutz  seylan    wolter         we introduce the notion of partial support
families  with which ontology reasoning access can be completely eliminated 
 as in general constructing complete support families is not always feasible for el ontologies  we provide novel methods for computing partial support families by exploiting ontology
approximation techniques based on the logical difference between el terminologies as considered by konev  ludwig  walther  and wolter        and ludwig and walther        
 to capture restricted classes of tboxes  for which complete support families can still be
effectively computed  we consider a support hypergraph for dl atoms  which is inspired
by ontology hypergraphs  nortje  britz    meyer        ecke  ludwig    walther        
the support hypergraph serves to characterize the tbox parts that are relevant for deriving
the query  the analysis of support hypergraphs allows us to estimate the maximal size and
number of support sets that is needed to form a complete support family 
 we generalize the algorithm for repair answer set computation proposed by eiter et al       d 
such that el ontologies can be handled  the novel algorithm operates on partial support
families  and in principle can be applied to the ontologies in any dls beyond el  it uses
hitting sets to disable known support sets of negative dl atoms and performs evaluation
postchecks if needed to compensate incompleteness of support families  moreover  it trades
answer completeness for scalability by using minimal hitting sets  however completeness may
be ensured by a simple extension 
 we provide a system prototype with a declarative realization of the novel algorithm for repair
answer set computation  our repair approach has been evaluated using some novel benchmarks  the results show very promising potential of the proposed approach 
organization  the rest of the paper is organized as follows  in section    we recall basic notions
and preliminary results  section   deals with support sets and their computation  while section  
discusses partial support family construction based on tbox approximation techniques  in section  
we analyze properties of a support hypergraph for estimating the maximal size and number of support sets in a complete support family for a dl atom  in section    the algorithm for repair answer
set computation and its declarative implementation are presented  experiments are presented in section    followed by a discussion of related work in section   and concluding remarks in section   

   preliminaries
in this section  we recall basic notions of description logics  where we focus on el  baader 
brandt    lutz         and dl programs  eiter et al          for more background on description
logics   see baader  calvanese  mcguinness  nardi    patel schneider        
    description logic knowledge bases
we consider description logic  dl  knowledge bases  kbs  over a signature o   hi  c  ri with
a set i of individuals  constants   a set c of concept names  unary predicates   and a set r of role
names  binary predicates  as usual  a dl knowledge base  or ontology  is a pair o   ht   ai
of a tbox t and an abox a  which are finite sets of formulas capturing taxonomic resp  factual
   

fic omputing r epairs of i nconsistent dl p rograms over el o ntologies

tnorm


    staffrequest  hasaction action




   
staffrequest  hassubject staff




   
staffrequest
 hastarget project



    hasaction action  chasa a
 
    hassubject staff  chass  st




    hastarget project  chast  p




    chasa a  chass  st  chasa ahass  st



    chasa ahass  st  chast  p  staffrequest

figure    normalized tbox

























knowledge  whose form depends on the underlying dl  in abuse of notation  we also write o  
t  a viewing o as a set of formulas 
syntax  in el  concepts c  denoting sets of objects  and roles r  denoting binary relations
between objects  obey the following syntax  where a  c is an atomic concept and r  r an
atomic role 
c  a      c  c   r c
in el  tbox axioms are of the form c   c   also called generalized concept inclusion axioms 
gcis   where c    c  are el concepts  abox formulas are of the form a c  or r c  d   where
a  c  r  r  and c  d  i  in the sequel  we use p as a generic predicate from c  r  if the
distinction is immaterial  
an example of an el ontology is given in figure   
definition    normalized tbox  a tbox is normalized  if all of its axioms have one of the following forms 
a   a 
a   a   a 
r a   a 
a   r a   
where a    a    a  are atomic concepts 
e g   the axiom     in example   is in normal form  while the axioms     and     are not  for
any el tbox  an equivalent tbox in normal form is constructible in linear time  stuckenschmidt 
parent    spaccapietra         over an extended signature    baader et al         
a special class of tboxes widely studied in literature are el terminologies  defined as follows 
definition    el terminology  an el terminology is an el tbox t   satisfying the following conditions 
    t consists of axioms of the forms a  c and a  c  where a is atomic and c is an
arbitrary el concept 
    no concept name occurs more then once on the left hand side of axioms in t  
for example  the tbox of the ontology in figure   is an el terminology 
semantics  the semantics of dl ontologies is based on first order interpretations  baader et al  
       an interpretation is a pair i   hi   i i of a non empty domain i and an interpretation
   linear complexity results are obtained under the standard assumption in dls that each of the atomic concepts is of
constant size  i e   the length of a binary string representing an atomic concept does not depend on the particular
knowledge base 

   

fie iter   f ink   s tepanova

function i that assigns to each individual c  i an object ci  i   to each concept name c a subset
c i of i   and to each role name r a binary relation ri over i   the interpretation i extends
inductively to non atomic concepts c and roles r according to the concept resp  role constructors 
as for el   r c i    o    ho    o  i  ri   o   c i   and  c  d i    o    o   c i   o   di   
satisfaction of an axiom resp  assertion  w r t  an interpretation i  i e  i      is as follows 
 i  i    c  d  if c i  di    ii  i    c a   if ai  c i    iii  i    r a  b   if  ai   bi    ri  
furthermore  i satisfies a set of formulas   denoted i      if i     for each    
a tbox t  respectively an abox a  an ontology o  is satisfiable  or consistent   if some
interpretation i satisfies it  we call an abox a consistent with a tbox t   if t  a is consistent 
since negation is neither available nor expressible in el  all el ontologies are consistent 
example   the ontology o in figure   is consistent  a satisfying interpretation i   hi   i i
exists  where i    john  read   p    r     action i    read    blacklisted i   staff i    john  
hassubject i    r    john   staffrequest i   blacklistedstaffrequest i    r     hasaction i  
 r    read    hastarget i    r    p    
throughout the paper  we consider ontologies in el under the unique name assumption  una  
i e   o  i    o  i whenever o     o  holds in any interpretation  however  our results carry over
to ontologies without una  as it is not hard to see that the una has for el no effect on query
answering   cf  lutz  toman    wolter        
    dl programs
a dl program    ho  pi is a pair of a dl ontology o and a set p of dl rules  which extend
rules in non monotonic logic programs with special dl atoms  they are formed over a signature
   hc  p  i  c  ri  where p   hc  pi is a signature of the rule part p with a set c of constant
symbols and a  finite  set p of predicate symbols  called lp predicates  of non negative arities  and
o   hi  c  ri is a dl signature  the set p is disjoint with c  r  for simplicity  we assume
c   i 
syntax  a  disjunctive  dl program    ho  pi consists of a dl ontology o and a finite set p
of dl rules r of the form
a          an  b            bk   not bk             not bm

   

where not is negation as failure  naf   and each ai      i  n  is a first order atom p  t  with
predicate p  p  called ordinary or lp atom  and each bi      i  m  is either an lp atom or a dlatom  the rule is a constraint  if n      and normal  if n     we call h r     a            an   the
head of r  and b r     b            bk   not bk             not bm   the body of r  b    r     b            bk  
and b   r     bk             bm   denote the positive and the negative parts of b r  respectively 
a dl atom d  t  is of the form
dl   q   t  
   
where
 a     s  op   p            sm op m pm   m    is the input list and for each i     i  m  si 
c  r  op i     is an update operator  and pi  p is an input predicate of the same arity
as si   intuitively  op i    increases si by the extension of pi  
   strong negation a can be added resp  emulated as usual  eiter et al         

   

fic omputing r epairs of i nconsistent dl p rograms over el o ntologies

 b  q  t  is a dl query  which has one of the forms  i  c t   where c is a concept and t is a
term   ii  r t    t     where r is a role and t    t  are terms   iii  c   c  and  t    
note that inclusion dl queries of the form c   c  can be easily reduced to instance queries  
thus for simplicity  we consider in this work only instance dl queries 
example   consider a dl atom dl project  projfile  staffrequest  x   in the rule      of 
in figure   for x   r    it has a dl query staffrequest r     its list    project  projfile
contains an input predicate projfile which extends the ontology predicate project via an update
operator  
semantics  the semantics of a dl program
s    ho  pi is given in terms of its grounding
gr     ho  gr p i over c  i e   gr p    rp gr r  contains all possible ground instances of
all rules r in p over c  in the remainder  by default we assume that  is ground 
a  herbrand  interpretation of  is a set i  hb  of ground atoms  where hb  is the herbrand base for p  hc  pi  i e  the set of all ground atoms over p   i satisfies an lp  or dl atom a 
if
 i  a  i  if a is an lp atom  and
 ii  o  i  a     q  t  where o   ht   ai  if a is a dl atom of form      where
i  d   

m
 

ai  i  and ai  i     si   t    pi   t   i      i  m 

   

i  

satisfaction of a dl rule r  resp  a set p of rules  by a herbrand interpretation i of    hp  oi
is then as usual  where i satisfies not bj   if i does not satisfy bj   i satisfies   if it satisfies each
r  p  by i   o  we denote that i satisfies  is a model of  an object   where  can be an  dl atom  a rule or a set of rules  the superscript o of    specifies the ontology on which dl atoms are
evaluated  a model i of  is minimal  if no model i  of  exists such that i   i 
example   the dl atom d   dl project  projfile  staffrequest  r    is satisfied by the interpretation i    projfile p     hasowner  p    john    since o    staffrequest r     for o  

o  staffreqeust r     it still holds that i   o d  as o  i  d     staffrequest r    
repair answer sets  various semantics for dl programs extend the answer set semantics of logic
programs  gelfond   lifschitz        to dl programs   e g   eiter et al         lukasiewicz       
wang  you  yuan    shen        shen         we concentrate here on weak answer sets  eiter
et al          which treat dl atoms like atoms under naf  and flp answer sets  eiter  ianni  schindlauer    tompits         which obey a stronger foundedness condition  both are like answer sets
of an ordinary logic program interpretations that are minimal models of a program reduct  which
intuitively captures that assumption based application of the rules can reconstruct the interpretation 
i o
of p relative to o and to i  hb results from gr p  by deleting
the weak  reduct pweak
 i  all rules r such that either i    o d for some dl atom d  b    r   or i   o l for some l  b   r  
 ii  all dl atoms in b    r  and all literals in b   r  
   evaluating d   dl   c   c      over o   t  a reduces to evaluating d   dl   ac    a  over o  
t   ac   c    c   ac     a   ac   a    where a is a fresh constant and ac    ac  are fresh concepts  similar
as in tbox normalization  

   

fie iter   f ink   s tepanova

i o
the flp reduct pflp
of p results from gr p  by deleting all rules r  whose bodies are not
o
satisfied by i  i e  i     bi   for some bi      i  k or i   o bj   for some bj   k   j  m  we
illustrate the notions on an example 

example   let o be as in figure    and let the rule set p contain the facts            and the rules
           with x  y  z instantiated to r    john  p  respectively  consider the interpretation i  
i o
 projfile p     hasowner  p    john   chief  john   grant r      while the flp reduct pflp
contains
i o
all rules of p  in the weak  reduct pweak
the rule      is replaced by the fact grant r    

definition    x deletion repair answer set  an interpretation i is an x deletion repair answer set

of    ht  a  pi for x   flp  weak    if it is a minimal model of pxi t a   where a  a  any
such a is called an x deletion repair of   if a   a  then i is a standard x answer set 
example   i    projfile p     chief  john   hasowner  p    john   grant john   is both a weak
and flp repair answer set of  in example   with a repair a   a  blacklisted  john   
notation  we denote for any normal logic program p by as  p  the set of all answer sets of p 
and for any dl program  by as x     resp  ras x     the set of all x answer sets  resp  x repair
answer sets  of  
in general an flp answer set is a weak  answer set  but not vice versa  i e  flp answer sets are
a more restrictive notion  however  in many cases weak and flp answer sets coincide  for more
information on the reducts  see works by eiter et al         and wang et al         
shifting lemma  to simplify matters and avoid dealing with the logic program predicates separately  we shall shift as eiter et al       d  the lp input of dl atoms to the ontology  given a
dl atom d   dl   q   t  and p  p    we call pp  c  an input assertion for d  where pp
is a fresh ontology predicate and c  c  ad is the set of all such assertions  for a tbox t and
a dl atom d  we let td   t   pp  p   p  p     and for an interpretation i  we let
odi   td  a   pp   t   ad   p  t   i   we then have 
proposition     eiter et al       d  for every o   t  a  dl atom d   dl   q   t  and interi
pretation i  it holds that i   o d iff i   od dl   q   t  iff odi    q  t  
unlike oi  d   in odi there is a clear distinction between native assertions and input assertions
for d w r t  i  via facts pp and axioms pp  p    mirroring its lp input  note that if t is in normal
form  then also td is in normal form 

   support sets for dl atoms
in this section  we recall support sets for dl atoms by eiter et al       b   which are an effective
optimization means for  repair  answer set computation  eiter et al       d   intuitively  a support
set for a dl atom d   dl   q   t  is a portion of its input that  together with abox assertions 
is sufficient to conclude that the query q  t  evaluates to true  i e   given a subset i   i of an
interpretation i and a set a  a of abox assertions from the ontology o  we can conclude
that i   o q  t   basically  our method suggests precomputing support sets for each dl atom at the
nonground level  during dl program evaluation  for each candidate interpretation ground instances
of support sets are computed  which help to prune the search space for  repair  answer sets 
   

fic omputing r epairs of i nconsistent dl p rograms over el o ntologies

exploiting proposition    we have the following definition of support sets using only ontology
predicates 
definition     ground support sets  given a ground dl atom d   dl   q   t   a set s  aad
is a support set for d w r t  an ontology o   ht   ai  if td  s    q  t   by supp o  d  we denote the
set of all support sets s for d w r t  o 
support sets are grouped into families of support sets or simply support families  more formally 
definition     support family  any collection s  supp o  d  of support sets for a dl atom d
w r t  an ontology o is a support family of d w r t  o 
in general and for el in particular  even  minimal support sets can be arbitrarily large and
infinitely many support sets may exist  not for acyclic tboxes t   where still exponentially many
support sets are possible   however  we nonetheless can exploit them for the repair answer set
computation algorithms in section   
support sets are linked to interpretations by the following notion 
definition     coherence  a support set s of a dl atom d is coherent with an interpretation i  if
for each pp   c   s it holds that p c   i 
example    the dl atom d   dl project  projfile  staffrequest  r    from figure   has two
support sets  s     staffrequest r     and s     hassubject r    john  projectprojfile  p    
staff  john  hasaction r    read    action read     s  is coherent with any interpretation  while
s  is coherent only with interpretations i   projfile p     
the evaluation of d w r t  i then reduces to the search for coherent support sets 
proposition    let d   dl   q   t  be a ground dl atom  let o   ht   ai be an ontology  and
let i be an interpretation  then  i   o d iff some s  supp o  d  exists s t  s is coherent with i 
using a sufficient portion of support sets  we can completely eliminate the ontology access for
the evaluation of dl atoms  in a naive approach  one precomputes all support sets for all ground dlatoms with respect to relevant aboxes  and then uses them during the repair answer set computation 
this does not scale in practice  since support sets may be computed that are incoherent with all
candidate repair answer sets 
an alternative is to fully interleave the support set computation with the search for repair answer
sets  here we construct coherent ground support sets for each dl atom and interpretation on the
fly  as the input to a dl atom may change in different interpretations  its support sets must be
recomputed  however  since reuse may not be possible  effective optimizations are not immediate 
a better solution is to precompute support sets at the nonground level  that is  schematic support
sets  prior to repair computation  furthermore  in that we may leave the concrete abox open  the
support sets for a dl atom instance are then easily obtained by syntactic matching 
    dl   q  x 
  be a
definition     nonground support sets  let t be a tbox  and let d x 
 
nonground dl atom  suppose v  x is a set of distinct variables and c is a set of constants  a
nonground support set for d w r t  t is a set s    p   y              pk  y k    of atoms such that
   

fie iter   f ink   s tepanova

 i  y             y k  v and
 k    is a support set
 ii  for each substitution    v  c  the instance s    p   y              pk  y
 
for d x  w r t  oc   t  ac   where ac is the set of all possible abox assertions over c 
for any ontology o   t  ac   we denote by suppo  d  the set of all nonground support sets for
d w r t  t  
here ac takes care of any possible abox  by considering the largest abox  since o  o
implies that supp o  d   supp o  d   
example    for d   dl project  projfile  staffrequest  x   the set s     staffrequest x   
is a nonground support set  and likewise the set s     action w    staff  y    hassubject x   y   
hastarget x   z    projectprojfile  z    hasaction x   w    
if a sufficiently large portion of nonground support sets is precomputed  then the ontology access
can be fully avoided  we call such a portion a complete support family 
definition     complete support family  a family s  suppo  d  of nonground support sets for
  w r t  an ontology o is complete  if for every support set s 
a  non ground  dl atom d x 
 
 
  exist
supp o  d x    where   x  c  some s   s and an extension    v  c of  to v  x


such that s   s   
example    consider the dl atom d x    dl project  projfile  staffrequest  x  from figure    the family s    s    s    s    s    s    s    is complete for d w r t  o  where ht   hastarget 
hs   hassubject and ha   hasaction 







s 
s 
s 
s 
s 
s 

   staffrequest x    
   project y    ht  x   y    hs  x   z    staff  z    ha x   z     action z     
   projectprojfile  y    ht  x   y    hs  x   z    staff  z    ha x   z     action z     
   project y    ht  x   y    hs  x   z    blacklisted  z    ha x   z     action z     
   projectprojfile  y    ht  x   y    hs  x   z    blacklisted  z    ha x   z     action z     
   blacklistedstaffrequest x    


we say that two nonground support sets  resp  support families  are ground identical  if their
groundings coincide  e g   the support sets s     p  x   r x  y    and s     p  x   r x  z   are
ground identical for a dl atom d x    dl   q  x   and so are the respective support families
 s    and  s    
definition     subsumption  a nonground support set s is subsumed by s    denoted by s   s 
if for every ground instance s of s some ground instance s   of s  exists such that s    s 
for nonground support families  we say that s  is subsumed by s    denoted s   s    if for each
instance s of s  s  some instance s   of s  in s  exists such that s    s holds 
example    s    blacklistedstaffrequest x   hassubject x   y   blacklisted  y    is a support
set for the dl atom d x    dl staff  chief   blacklistedstaffrequest  x  w r t  t from figure    which is subsumed by s     blacklistedstaffrequest x     i e  s   s  moreover 
s  s  where s    s    and s   s   while the support families s    s  s    and s    s 
 blacklistedstaffrequest x   hassubject x   z   blacklisted  z     mutually subsume each other 
   

fic omputing r epairs of i nconsistent dl p rograms over el o ntologies

axiom
datalog rule
a   a 
a   x   a   x 
a   a   a  a   x   a   x   a   x 
r a   a  a   x   r x  y    a   y  
a   r a 
r x  oa     a   x 
a   oa     a   x 

table    el tbox rewriting
definition     maximal support set size  maxsup  the maximal support set size of a dl atom d
w r t  t   denoted by maxsup d    is the smallest integer n    such that for every complete nonground support family s for d w r t  t and support set s  s with  s    n  a support set s   s
exists for d w r t  t in suppd  o  with  s     n 
for instance  for the dl atom d and the tbox t from example     the maximal support set
size is    i e   maxsup d      
    computing support sets
in this section  we provide methods for constructing nonground support sets  a natural approach
for the computation of nonground support sets is to exploit  conjunctive  query answering methods
in el  e g   rosati        lutz et al         kontchakov  lutz  toman  wolter    zakharyaschev 
      stefanoni  motik    horrocks        
suppose we are given a dl program    ho  pi  where o   ht   ai is an el ontology  and
    dl   q  x  
  our method to construct nonground support sets for d x 
  has
a dl atom d x 
the following three steps 
step    dl query rewriting over the tbox  the first step exploits the rewriting of the dl  over the tbox td   t   pp  p   p  p    into a set of datalog rules 
query q of d x 
at a preprocessing stage  the tbox td is normalized  this technique restricts the syntactic form
of tboxes by decomposing complex into simpler axioms  for this purpose  a set of fresh concept
symbols is introduced  once the normalized form td norm of td is computed  we rewrite the part of
the tbox that is relevant for the query q into a datalog program prog q tdnorm using the translation
given in table    which is a variant of a translation by prez urbina  motik  and horrocks       
and zhao  pan  and ren         when rewriting axioms of the form a   r a   fourth axiom
in table     we introduce fresh constants  oa    to represent unknown objects  a similar rewriting
is exploited in the r equiem system  prez urbina et al          where function symbols are used
instead of fresh constants  as a result we obtain 
lemma    for every data part  i e   abox a  and every ground assertion q  c   deciding whether
prog q tdnorm  a    q  c  is equivalent to checking td norm  a    q  c  
step    query unfolding  the second step proceeds with the standard unfolding of the rules of
prog q td norm w r t  the target dl query q  we start with a rule that has q in the head and expand
its body using other rules of the program prog q tdnorm   by applying this procedure exhaustively 
we get a number of rules which correspond to the rewritings of the query q over td norm   note
that it is not always possible to obtain all of the rewritings effectively  since in general there might
   

fie iter   f ink   s tepanova

prog q td norm

 
     chasa a  x    hasaction x   y    action y   




     chass  st  x    hassubject x   y    staff  y   


 
     chast  p  x    hastarget x   y    project y   
 

  
  chasa ahass  st  x    chasa a  x    chass  st  x   





  
 
staffrequest x    chasa ahass  st  x    chast  p  x   



    project x    projectprojfile  x   

















figure    dl query rewriting for dl project  projfile  staffrequest  x  over td norm
be infinitely many of them if t is cyclic  and still exponentially many for acyclic t   we discuss
techniques for computing partial support families in the next section 
step    support set extraction  the last step extracts nonground support sets from the rewritings
of step    we select those containing only predicates from td and obtain rules r of the form
   p   y              pk  y k    pk  
 k              pnp  y n   
q x 
 y
   
pk  

n

where each pi is a native ontology predicate if    i  k  and a predicate mirroring lp input of d
otherwise  the bodies of such rules correspond to the support sets for a given dl atom  i e 
 k              pnp  y
 n   
s    p   y              pk  y k    pk  
 y
   
pk  

n

now the following holds 
    dl   q  x 
  be a dl atom of a program    ho  pi with an el
proposition    let d x 
 
ontology o   ht   ai  every set s constructed in steps     is a nonground support set for d x  
by the shifting lemma  when working with support sets we can focus on the ontology predicates
and operate only on them  more specifically  rules of the form     for k  n fully reflect nonground
support sets as of definition     and ground instantiations of such a rule over constants from c
implicitly correspond to ground support sets 
we now illustrate the computation of nonground support sets for dl atoms over el ontologies 
example    consider a dl atom dl project  projfile  staffrequest  x  accessing an el ontology o   ht   ai from figure    the datalog rewriting for d computed at step   is given in
figure    in step   we obtain the following query unfoldings for staffrequest 
    staffrequest x   staffrequest x  
    staffrequest x   hasaction x  y    action y    hassubject x  y    
staff  y     hastarget x  y     projectprojfile  y    
    staffrequest x   hasaction x  y    action y    hassubject x  y    
staff  y     hastarget x  y     project y    
    staffrequest x   hasaction x  y    action y    hassubject x  y    
blacklisted  y     hastarget x  y     project y    
    staffrequest x   hasaction x  y    action y    hassubject x  y    
blacklisted  y     hastarget x  y     projectprojfile  y    
in step   we thus get from the rule     s     hasaction x  y    action y    staff  y    
hassubject x  y     hastarget x  y     projectprojfile  y     and from rule     s    action y   
hasaction x  y   staff  y    hassubject x  y     project y    hastarget x  y      from         
and     the remaining support sets are similarly obtained 

   

fic omputing r epairs of i nconsistent dl p rograms over el o ntologies

    partial support families
finding all support sets for a dl atom is tightly related to computing all solutions to a logic based
abduction problem  abduction is an important mode of reasoning widely applied in different areas
of ai including planning  diagnosis  natural language understanding and many others  console 
sapino    dupr         various variants of this problem were actively studied  e g  by eiter 
gottlob  and leone        and bienvenu         unfortunately  most of the practically important
problems in the context of abduction are intractable even for restricted propositional theories  eiter
  makino         the abduction problem for el tboxes has been considered by bienvenu        
represented by a tuple ht   h  oi  with a tbox t   a set of atomic concepts h and an atomic concept
o  an explanation is a set  a            an    h  such that t    a          an  o  if the
abox a  ad contains only atomic concepts  then computing all nonground support sets for d  
dl   q  x  accessing o   ht   ai corresponds to an abduction problem htd   sig a  ad    qi 
if roles occur in a  ad   then one has to introduce new fresh concepts to construct the complex
concepts as hypothesis  e g   for r a an inclusion cr a  r a can be added to td   and cr a
to h  where cr a is a fresh concept 
unlike for dl lite a   support families for dl atoms over el ontologies have no particular
structure  they can be large  and maximal support set size can be exponential in the size of t  
example    consider the following acyclic tbox t   which contains the axioms 
    r b   s b   b 
    r b   s b   b 
   
 n  r bn   s bn   bn
for d    dl   b    x     the maximal support set size is    which is witnessed by
s     r x    x     b   x     s x    x     b   x     

for the dl atom d    dl   b    x     we have maxsup d          due to s     r x    x    
r x    x     b   x     s x    x     b   x     s x    x     r x    x     b   x     s x    x     b   x     
moreover  for di   dl   bi   x   we have maxsup di     maxsup di               i  n 
note that the maximal support set for dn involves n     predicates  therefore  if the tbox is
of the above form  and  sig t     k  a lower bound for the worst case support set size for d is
 k          k    which is single exponential in the size of t  

while in general many unfoldings can be produced at step    according to recent results of
hansen et al          complete support families for el can be computed for large classes of ontologies  therefore  we still exploit support families  but unlike eiter et al       d  we do not require
them to be complete  and develop techniques for computing partial  i e  incomplete  support families for dl atoms  a natural approach in this context is to aim at finding support sets of bounded
size  in general  due to cyclic dependencies such as r c  c  which are possible in el but not
in dl lite a   support sets can be arbitrary large  an analysis of a vast number of ontologies has
revealed that in many realistic cases ontologies do not contain  nor imply  cyclic axioms  gardiner
et al          we thus assume for practical considerations that the tbox of the ontology in a given
dl program is acyclic  i e   it does not entail inclusion axioms of form r c  c  however  even
under this restriction support sets can be large as example    shows 
   

fie iter   f ink   s tepanova

if computing complete support families is computationally too expensive  a natural approach
is to produce only support sets of a certain size k using e g  limited program unfolding  when an
unfolding branch reaches the depth k  we stop and expand a different branch  similarly  we can compute a limited number k of support sets by stopping the rule unfolding of the program prog q tdnorm
once the k th support set is produced  an alternative approach  based on tbox approximation
techniques  is pursued in the next section 

   partial support family construction via tbox approximation
we now provide practical methods to construct partial support families using tbox approximation 
    tbox approximation
the approximation of dl ontologies over a source language l in a different target language l
is a well known and important technique in ontology management  existing approaches for such
approximation are roughly divided into syntactic approaches and semantic approaches  the former 
e g  those by tserendorj  rudolph  krtzsch  and hitzler        and wache  groot  and stuckenschmidt         focus on the syntactic form of the axioms of the original ontology and appropriately
rewrite the axioms that do not comply with the syntax of the target language  they are rather effective in general but can produce unsound answers  pan   thomas         semantic approaches
focus on the model based entailment from the original ontology  rather than on its syntactic structure 
they aim at preserving these entailments as much as possible while transforming the ontology into
the target language  in general they are sound  but they might be computationally more expensive
 console  mora  rosati  santarelli    savo        
for our task of computing partial support families  sound ontology approximation techniques
are relevant  we choose dl lite core as the target approximation language  as it lies in the intersection of el and dl lite a   for which complete support families can be effectively identified  eiter
et al       d   our approach for approximating a tbox in el to dl lite core exploits the logical
difference between el tboxes considered by konev et al          the idea behind it is to decide
whether two ontologies give the same answers to queries over a given vocabulary  called signature 
  and compute a succinct representation of the difference if it is not empty  typical queries include
subsumption between concepts  instance queries and conjunctive queries  in our setting subsumption queries are of particular interest  as based on them nonground support families are constructed 
  and an ontology o   ht   ai 
our approach is as follows  given a dl atom d   dl   q  x 
we eliminate from the tbox td axioms outside the dl lite core language  and obtain a simplified
tbox td   we then compute a succinct representation of the logical difference between td and td
w r t      sig ad  a   q   the axioms in the logical difference that fall into dl lite core are
then added to td   by restricting  to predicates that can potentially appear in support sets we avoid
redundant computations and we approximate only the relevant part of the tbox  this approach
is particularly attractive  as the logical difference for el was intensively studied  e g  by lutz 
walther  and wolter        and konev et al          and polynomial algorithms are available for
el terminologies  we thus confine ourselves here to the latter 
to present our approximation approach formally  we first recall some notions introduced by
konev et al         
   

fic omputing r epairs of i nconsistent dl p rograms over el o ntologies

definition      concept difference  the  concept difference between el terminologies t 
and t  is the set cdiff  t    t    of all el inclusions  over  such that t      and t       
example    for the terminologies t     b  e  e  r   c  a  b  and t   
 c  a  d  b  d  c  it holds that cdiff  t    t       for     a  b  c   while

cdiff  t    t       b  r   for     b  r  
if two el terminologies entail the same concept subsumptions over the signature   i e  it holds
that cdiff  t    t      cdiff  t    t        then they are called  concept inseparable  which is
c
c
denoted by t  c
 t    e g  in example    we have that t   t  and t    t   
the logical difference in terms of instance queries is defined as follows 
definition      instance difference  the  instance difference between terminologies t  and t 
is the set idiff  t    t    of pairs of the form  a     where a is a  abox and  a  instance
assertion  such that t   a     and t   a       we say that t  and t  are  instance inseparable 
in symbols t  i t  if idiff  t    t      idiff  t    t       
as easily seen  t  i t  implies t  c
 t    the converse is not obvious but also holds 
theorem     cf  lutz   wolter        for any el terminologies t  and t  and signature   t  c

t  iff t  i t   
    partial support family construction
we now show that a dl atom has the same set of support sets under  concept inseparable terminologies  prior to that  we establish the following lemma 
lemma    let d   dl   q   t  be a dl atom  let o   ht    ai be an el ontology  and let t  be
c
a tbox  if t  c
 t    where   sig a   sig q    p   p  p     then t  d  t  d   where

     sig ad   
armed with this  we obtain the following result on equivalence of nonground support families 
  be a dl atom and let t    t  be el terminologies such that
proposition    let d   dl   q  x 
c
t   t  where    sig a  ad  q    p   p  p     if s  and s  are complete nonground
support families for d w r t  o    ht    ai and o    ht    ai  respectively  then s  and s  are
ground identical 
given two el terminologies t  and t    the inclusions c  a  cdiff  t    t     resp  a 
c  cdiff  t    t     are following konev et al         called left  resp  right  witnesses and denoted
lhs
as cwtnrhs
  t    t     resp  cwtn  t    t      it was shown that every inclusion c  d in the concept difference of t  and t  contains either a left or a right witness 
theorem     cf  konev et al         let t  and t  be el terminologies and  a signature  if
  cdiff  t    t     then either c  a or a  d is a member of cdiff  t    t     where a  sig  
is a concept name and c and d are el concepts occurring in  
   

fie iter   f ink   s tepanova

algorithm    partsupfam  compute partial support family
  ontology o   ht   ai
input  dl atom d   dl   q  x  
output  partial nonground support family s  suppo  d  for d
 a     sig a  ad    q 
 b  td  t   pp  p   p  p   
 c  td  td   c  d   c    a  r   or d    a  r   
rhs
lhs
 d  lrw  cwtn  td   td    cwtn  td   td  


 e  td  td   c  d  lrw   c  d   a  r   
 f  s   complsupf am d  td   
return s
the logical difference between two el terminologies in its compact representation consists
only of inclusions with an atomic concept name on either the left or the right hand side  some may
have inclusions with atomic concepts on both sides or role restrictions of the form r   which fall
into our target language of dl lite core dl  and can be therefore reintroduced 
we are now ready to describe the algorithm p artsupf am  see algorithm    to compute partial
  and an ontology
families of support sets  as input we are given a dl atom d   dl   q  x 
o   ht   ai  where t is an el terminology  we first set the signature  in  a  to predicates
relevant for support set computation for d  we then construct the tbox td in  b  and its simplified
version td in  c  by removing from td all axioms of the form c  d  where c or d is a complex
concept  i e  all axioms that are not in the dl lite core fragment  in  d  we compute right hand side
and left hand side witnesses between td and td for  and store them in lrw   after that  in  e  we
construct the tbox td by extending td with all axioms from lrw   having concepts of the form a or
r on both sides of inclusions  based on the support set construction method for dl lite a of eiter
et al       d   we then obtain a complete support family s for td in  f   which is a partial support
family for t  
proposition    the family s computed by algorithm   fulfills s  suppo  d   i e   s is a partial
support family for a given dl atom d w r t  t where o   t  a 
if lwr    in  d  or cdiff  td   td      in  e   then s is guaranteed to be complete by proposition     while in general algorithm   can be used for computing support families for dl atoms
accessing arbitrary tboxes    practically efficient procedures for  d  are available only for acyclic
el terminologies  konev et al         

   bounded support sets
in this section  we analyze the size and the number of support sets that a given dl atom can have 
with bounds on these quantities at hand  one can limit the search space of support sets  more
precisely  we aim at support set families that are sufficient for evaluating the dl atom  as support
sets s  that are  properly  subsumed by another support set s  i e   s  s    can be dropped  we
consider non ground support families that subsume any other  in particular  any complete  support
family  more formally 
   for computing logical difference between arbitrary tboxes recent results by feng  ludwig  and walther        might
be exploited 

   

fic omputing r epairs of i nconsistent dl p rograms over el o ntologies

definition      complete support family  we say a nonground support family s for a dl atom
d is  complete w r t  an ontology o  if s  s for s  suppo  d  
thus the question are bounds on the size of support sets in s and the cardinality of a smallest s 
throughout this section  we tacitly assume that tboxes are acyclic  i e  they do not entail inclusions of the form r c  c 
    estimation of support set size bounds
we first consider an estimate on the maximal size of support sets in the smallest  complete support
family by analyzing the syntactic properties of a given tbox  to start with  we recall from the work
of konev et al         that an atomic concept a is primitive in a terminology t   if it occurs in no
axiom of t on the left hand side  and pseudo primitive  if it is either primitive or occurs only on the
left hand side of axioms a  c  where c is an arbitrary el concept 
for an el terminology t and every pseudo primitive a such that t    d  a  where d  
a          an  r   c        rm  cm   some  atomic  conjunct ai in d exists such that t    ai  a
 konev et al         lemma      from this we obtain 
proposition    let d   dl   q   t  be a dl atom  and let t be an el terminology  if q is
pseudo primitive in t   then maxsup d      
proposition    exploits a specific case  in which the support set size bound is    for providing
more liberal syntactic conditions on t that ensure bounded size of support sets  we use ontology hypergraphs  nortje et al         ecke et al          the latter have been widely studied for extracting
modules of ontologies  nortje et al          determining concept difference between el terminologies  ecke et al          efficient reasoning in owl   ql  lembo  santarelli    savo         and
other important tasks 
first let us recall the notion of a directed hypergraph  which is a natural generalization of a
directed graph  proposed by ausiello  datri  and sacc        in the context of databases to represent functional dependencies 
definition     directed hypergraph  a directed hypergraph is a pair g    v  e   where v is a
set of nodes of the graph and e is a set of directed hyperedges of the form e    h  h     where
h  h   v are nonempty sets called hypernodes 
given a hyperedge e    h  h     we call h the tail of e and h  the head of e  denoted by
tail  e  and head  e   respectively  a hypernode is a singleton  if  h       and a binary hypernode 
if  h       in abuse of notation  for a singleton  v   we also simply write v  the notion of an
ontology hypergraph for dl el introduced by ecke et al         is as follows 
definition     ontology hypergraph  let t be an el tbox in normal form  and let   c  r 
the ontology hypergraph gt of t is a directed hypergraph gt    v  e   where
v    xa   a  c     sig t       xr   r  r     sig t       x    and
e      xa     xb      a  b  t   
   xa     xr   xy      a  r y  t   y  c     
   xr   xy     xa      r y  a  t   y  c      
   xb    xb      xa      b   b   a  t   
   

fie iter   f ink   s tepanova

xr 

xr 

xa 

xa 

x c 

xr 

xa 

xa 

x c 

xd

xr 

figure    hypergraph gt from example   
example    consider the following tbox in normal form 

    c   c   d

     r   a   c 
    r   a   c 
    a   a 
t  

     r  a  a
   
d  r   a 
 
 
 

the ontology hypergraph gt for  sig t   is depicted in figure   







 



we now define the notions of directed path between two nodes and incoming path to a singleton
node in an ontology hypergraph  both are natural generalizations of a path in a standard graph 
definition     directed path  incoming path  suppose that t is an el tbox in a normal form 
gt    v  e  is an ontology hypergraph  and x  y  v are singleton nodes occurring in gt   then a
directed path between x and y in gt is a sequence    e    e            en of  hyper  edges  such that 
 i  tail  e     x 
 ii  head  en    y 
 iii  for every ei   i   n  some successor s ei     ej of ei exists in gt such that j   i  head  ei   
tail  ej    and s ei     s ei   implies head  ei      head  ei   for i    i  
an incoming path to a singleton node x  v in gt    v  e  is a directed path    e            en
from any node y  v to x  such that head  en     x  the set of all incoming paths to a node x in a
hypergraph g is denoted by paths x   g  
intuitively  hyperedges in an ontology hypergraph gt model inclusion relations between  complex 
concepts over  in t   consequently  an incoming path to a singleton node xc in gt models a chain
of inclusions that logically follow from t   such that c is the rightmost element of the chain 
example    let us look at the ontology hypergraph gt in figure    the sequence of edges
      xr    xa     xa       xr    xa     xc   
   

fic omputing r epairs of i nconsistent dl p rograms over el o ntologies

x a  p

xr 

 

xr 

xa 

xa 

x c 

xr 

xa 

xd

xc

xa

x c 

xb

xd

xq


 a  gsupp d  t
from example   


 b  gsupp d  t
from example   

figure    examples of support hypergraphs
is an incoming path to xc  in gt that reflects the inclusions r   a   c  and r    r   a     c   
the sequence
      xr    xa     xa       xr    xa     xc       xr    xa     xc       xc    xc     xd  
is an incoming path to the singleton xd   from which the following set of inclusions can be extracted 
    c  c  d      r   a  c  d      r   a  r   a  d  and     r   a  r    r   a     d 

we now introduce our notion of a support hypergraph for a dl atom 
definition     support hypergraph  a support hypergraph for a dl atom d dl   q   t  over a

constructed as follows 
normal ontology o   ht   ai is a hypergraph gsupp d  t
   build the ontology hypergraph gtd    v  e   where    sig a  ad     q  
   leave all nodes and edges in paths xq   gtd   and remove all other nodes and edges 
   for xc  gtd with c     if in paths xc   gtd   a  hyper  node n exists such that  p   xp 
n     then leave xc   otherwise remove it and all of its corresponding edges 
   for xr  gtd   such that r     leave e     xr   y   xc    if  xc    xr   y   exists in gtd   where
y   xd      otherwise remove e 
let us illustrate the notion of a support hypergraph on the following example 
  and
example    let t from example    be accessed by the dl atom d   dl a   p    d  x  

td   t   a p   a     the support hypergraph gsupp d  t for d with    sig td   is shown in figure  a  the node xd colored in blue corresponds to the dl query of d  the edge   xd     xr    xa    

  as it does not lie on the incoming path to xd  

is not in gsupp d  t
   

fie iter   f ink   s tepanova

before describing the approach of extracting support sets for a dl atom from a hypergraph  we
introduce the notion of tree acyclicity  for alternative definitions we refer the reader to the works 
e g  by ausiello  datri  and sacc         gallo  longo  and pallottino        and thakur and
tripathi        
definition     tree acyclicity  a hypergraph g    v  e  is called tree acyclic  if  i  at most one
directed path exists in g between any singleton nodes x  y  v  and  ii  g has no paths   
e            ek such that tail  e     head  ek       
we refer to hypergraphs that are not tree acyclic as tree cyclic 




   t   b 
example    gsupp d  t
in figure  a is tree acyclic  while g    gsupp d  t
 with t

   t   a 
a    b  a    and       b  is not  and neither is g    gsupp d  t
   where t
 
c    

the hypergraph gsupp d  t
for d   dl   q  x   t    d  c  c  a  c  b  a  b  q 
and    sig t   given in figure  b is tree cyclic  since it contains two paths between xd and xq  
namely     xd   xc   xa    xa   xb    xq and     xd   xc   xb    xa   xb    xq  


the support hypergraph gsupp d  t
   v  e  for a dl atom d   dl   q  x  contains all
incoming paths to xq that start from nodes corresponding to predicates in a  ad by construction 
i e  it reflects all inclusions with q on the right hand side and predicates over a  ad on the left
hand side that are entailed from td   hence  by traversing edges of all incoming paths to xq   we can
construct sufficiently many query rewritings of q over the tbox td corresponding to nonground
support sets that allow to subsume every nonground support family w r t  o 
if a support hypergraph for a given dl atom is tree acyclic  then support sets can be conveniently constructed from it by annotating nodes with variables xi   i  n in a way as described
hx i
below  we use subscripts for annotations  e g  xc i means that the node xc is annotated with the
hx  x i

variable xi   while xr i j states that xr is annotated with the ordered pair of variables xi   xj  
the approach proceeds as follows  we start from the node xq   which we annotate with x   
hx i
i e  xq     then we traverse the hypergraph backwards  going from a head of an edge to its tail 
for every edge e that we encounter we annotate tail  e  based on its form and on the annotation of
head  e   with variable names that occur in annotation of head  e  and or fresh variable names xi  
i  n  in the following way 
    if  tail  e        then
hx i

      if head  e     xc  i    then tail  e  is annotated with hxi i 
hxi   xi  i

      if head  e     xr 
hxi i

hxi i

  xc       then tail  e    xc  is annotated with hxi  i  i e  we

obtain xc     
hxi i

    if  tail  e       and head  e     xc

   then
hx i

hx i

      if tail  e   xc   xc     then both xc  and xc  are annotated with xi   i e   xc  i  xc  i   
hxi  xi  i

      if tail  e   xr    xc     then we get  xr 
   

hxi i

  xc      

fic omputing r epairs of i nconsistent dl p rograms over el o ntologies

from every annotated hypernode n   one can create a set of nonground atoms with predicate names
extracted from labels of hypernodes and variable names from their annotations  the nonground
support sets for d   dl   q  x    are then constructed from the incoming paths to xq  
we pick some incoming path   to xq containing n edges  and start traversing it from the
edge en with head  en      xq    the first immediate support set is s     q x      the next
one  s    is extracted from the annotated tail of en by taking nonground predicates of labels and
variables  we then pick an edge ek such that head  ek    tail  en    and obtain further support
sets by substituting nonground atoms that correspond to head  ek    tail  en   in s  with the atoms
extracted from tail  ek    this is repeated  one can in fact construct the incoming path backwards
along with the support set extraction  until a maximal path is obtained 

example    consider the maximal incoming path to xd of gsupp d  t
from figure  a 

    xa  p    xa       xr    xa     xa       xr    xa     xc       xr    xa     xc       xc    xc     xd   
 z
   
 z
   
 z
   
 z
 
 
 z
   
e 

e 

e 

e 

e 

hx  i
 i
traversing the path backwards  i e  edges in the order e    e    e    e    e    we obtain   xhx
a  p  xa   e  

 z
  
hx i
hx i
hx i
hx i
hx i hx i
hx i
hx i
hx i
   x  i
   x  i
   x  i
 xa      xc         xhx
 xa      xc         xc     xc      xd     
  xhx
 xa       xa          xhx
r 
r 
r 
 z
   
 z
   
 z
   
 z
 
 
 

e 

e 

e 

 

e 

the nonground support sets for d are extracted from the resulting annotated path as follows 

 s     d x     is immediately obtained from head  xd   
 the first incoming path to consider is     e    from which we get s     c   x     c   x     
 next is the path     e    e  as head  e     tail  e     yielding the support set s     c   x    
r   x    x     a   x    x     
 then  from     e    e  we get s     c   x     r   x    x     a   x     
     e    e    e  yields s     r   x    x     a   x     r   x    x     a   x     
 from     e    e    e    we extract s     r   x    x     r   x    x     a   x     c   x     
     e    e    e    e  yields s     r   x    x     r   x    x     a   x     r   x    x     a   x     
 from     e    e    e    e    we extract s     r   x    x     r   x    x     a p   x     c   x     
 finally  from     e    e    e    e    e  we get s     r   x    x     r   x    x     a p   x    
r   x    x     a   x     

the following lemma formally asserts the correctness of the procedure 

lemma    let sg be the support family constructed from a tree acyclic hypergraph g gsupp d  t
  then sg is  complete for d w r t  o  i e   sg  s for every s  suppo  d  
for d   dl   q  x  

in particular  lemma    holds for each complete s for d w r t  the ontology o   ht   ai  thus
we can determine sufficiently many nonground support sets for d by just looking at its support hypergraph  note that the restriction to tree acyclic tboxes is crucial for correctness of the procedure
from above  as it ensures that every node of a hypergraph is annotated only once 
lemma    allows us to reason about the structure and size of support sets by analyzing only
parameters of the support hypergraph  one such parameter  for instance  is the maximal number
n   g  of hyperedges with a singleton head node excluding   xr      xa    occurring on some
incoming path  to xq of a hypergraph g 
   

fie iter   f ink   s tepanova

xq

xl

xe
xf

xd

xm

xb

xa

xk
xc


figure    support hypergraph gsupp d  t
from example   

proposition    let o   ht   ai be an el ontology with t in a normal form  and let d  
  be a dl atom with a tree acyclic support hypergraph g 
dl   q  x 
  then
supp d  t

maxsup d   maxg 

supp d  t


 n   gsupp d  t
       

   

for tree cyclic hypergraphs  the bound from above is not tight  which we illustrate next 
example    consider the dl atom d x    dl   q  x  accessing the tbox td  


    e  f  l 


     a  d  f
    a  c  k
    e  k  m
 
td  



     a  b  e
    m  l  q

the support hypergraph for d is depicted in figure    where    sig td    there are six hyperedges with singleton head nodes  but the maximal support set size for d x  is    e g  s  
 a x   b x   d x   k x   

we next define out  and in degrees of nodes in a hypergraph 
definition     hyper outdegree and  indegree  given a directed hypergraph g    v  e   the
hyper outdegree denoted by hd   x   resp   hyper indegree hd  x   of a singleton node x  v is
the number of hyperedges e  e such that tail  e   x  resp   head  e   x  and either  tail  e      
or  head  e        similarly  the outdegree d   x   resp   indegree d  x   of x is the number of
edges e  e such that tail  e     x   resp   head  e     x   and  head  e      tail  e       


example    all nodes x  v  xa p   xd   in the hypergraph gsupp d  t
of figure  a have hyper 
 
outdegree    while for xap  and xd we have hd  xap      hd  xd        moreover  d   xap        
for hyper indegrees we have hd  xa      hd  xa      hd  xc      hd  xc         in the graph

   xc    xa     xd    it holds that hd   xc      hd   xa      hd  xd       
g    gsupp d  t
moreover  d  xa        


   

fic omputing r epairs of i nconsistent dl p rograms over el o ntologies

now let us define that
smax  x  g    maxpaths x g   n   g   m   g       
   
p
where m   g    xa   hdc   xa        and hdc   xa   is the number of hyperedges of form
  xa   xb    xc   on  


example    consider gsupp d  t
in figure  a  where paths xd   gsupp d  t
  contains a single maximal path to xd   viz      xa p    xa       xr    xa     xa       xr    xa     xc       xr    xa     xc    
  xc    xc     xd    we have n   g       as four hyperedges on  have a singleton head node  and
m   g       as all nodes have hyper outdegree at most    hence smax  xq   g              
   the hypergraph in figure   has a single maximal incoming path  to xq   and n   g      
m   g     hdc   xa          hdc   xe            thus smax  xq   g                 


we generalize the bound on the maximal support set size for d from proposition    using the
parameter smax  xq   g  for a node corresponding to the dl query q of a dl atom d  and obtain
the following result for hypergraphs that are possibly tree cyclic 
proposition    let o   ht   ai be an el ontology with t in a normal form  and let d  
  be a dl atom with support hypergraph g 
dl   q  x 
supp d  t   such that  has no role predi
cates  then maxsup d    smax  xq   gsupp d  t   

       and
example    for the tree cyclic hypergraph in figure   we have smax  xq   gsupp d  t
  is indeed the maximal support set size for d   dl   q  x   the hypergraph in figure  a has

  hyperedges  and for every node x  v  hd   x      thus  smax  xq   gsupp d  t
       which
coincides with maxsup d    where d   dl a   p    q  x  


note that in proposition     we take in computing m   g  only outgoing hyperedges of the
form   xc   xd    xe   into account  where c  d  e are concepts  and moreover  no roles occur in  
multiple outgoing hyperedges involving roles r with r   do not influence the support set size 
example    let a support hypergraph for d   dl   q  x  have the hyperedges   xr   xc    xd   
  xc   xs    xm      xd   xm    xq   where r    reflecting the axioms r c  d  s c  m and
m  dq  a largest minimal support set for d is s  r x  y    c y    s x  z   c z    its size is
n      where n is the number of hyperedges with a singleton head node  while hd   xc        
    number of support sets
orthogonal to the question considered in the previous section is under which conditions a given
number n of support sets is sufficient to obtain a  complete support family  this problem is tightly
related to counting minimal solutions for an abduction problem  which was analyzed by hermann
and pichler        for propositional theories under various restrictions  in particular  counting minimal explanations was shown to be    conp complete for general propositional theories and
 p  complete for horn propositional theories  as el subsumes propositional horn logic  determining the size of a smallest  complete support family is at least  p  hard and thus intractable 
like for the size of support sets  the support hypergraph can be fruitfully exploited for estimating
the maximal number of support sets for a given dl atom  to provide such an estimate  we traverse
the support hypergraph forward starting at the leaves and label every node xp with the number of
rewritings for p   to conveniently compute the labels  we introduce support weight functions 
   

fie iter   f ink   s tepanova


definition     support weight function  let gsupp d  t
   v  e  be a support hypergraph for a
dl atom d  a support weight function ws   v  n assigns to every node xa  v the number
ws xa   of rewritings of a over t w r t   

for every node in a tree acyclic support hypergraph  the value of ws can be conveniently computed in a recursive manner 

proposition    let gsupp d  t
be a tree acyclic support hypergraph for a dl atom d over a  normalized  ontology o   ht   ai  then ws is given as follows  where vc  v is the set of nodes for
concepts 



   p
q
ws x        t t   x  x t ws x  

p
p

  t t   x  t  vc   x   t  e ws x   

if hd  x      and d  x      or x 
  vc  
otherwise 
   

where t   x     t    t   x    e  

we demonstrate the usage of proposition    by the following examples 

example    to compute ws x  for the nodes of gsupp d  t
in figure  a  we traverse the graph from
leaves to the root  and for x   xr    xa    xc    xr    xa p    xr    we obtain ws x       furthermore 
ws xa      ws xc         ws xa         ws xc         finally  ws xd         ws xc    
ws xc                    which is the number of rewritings for d x   and hence support sets for
d x    dl a   p    d  x   identified in example    

example    consider the tbox t    a  b  q  c  a  d  a  e  a  f  b  g  b  h 
b  a  l  and a dl atom d   dl   q  x   whose support hypergraph for    sig t   is in
figure    we have that ws xq         ws xb    ws xa                    and indeed there are   
rewritings for q x   namely s     a x   b x    s     c x   b x    s     d x   b x   
s     e x   b x    s     a x   f  x    s     a x   g x    s     a x   h x    s   
 c x   f  x    s     c x   g x    s      c x   h x    s      d x   f  x    s    
 d x   g x    s      d x   h x    s      e x   f  x    s      e x   g x    s    
 e x   h x    and s      q x   
as an immediate corollary of proposition     we obtain

   v  e  be a tree acyclic support hypergraph for the dl atom d  
corollary    let gsupp d  t
  over an el ontology o   ht   ai  if each edge e  e satisfies  tail  e    head  e     
dl   q  x 
then
x
ws tail  e       
   
ws v   
ee   head e  v

thus for the query node xq   we get ws xq      e       in fact  proposition    leads to this
simple bound on the size of   minimal complete support families in more general cases 
   

fic omputing r epairs of i nconsistent dl p rograms over el o ntologies

xc

xd

xe

xf

xa

xg

xh

xb

xq

figure    hypergraph gsupp d  t


   v  e  be a tree acyclic support hypergraph for the dl atom
proposition    let gsupp d  t
  over an el ontology  such that for every edge e     x  y   z   e and edges
d   dl   q  x 
e    e   e such that head  ei     x  y   i          it holds that head  e      head  e     then
 sg 
     e      
supp d  t


example    the hypergraph gsupp d  t
in figure  a has a single maximal path of length    and its
hyperedges satisfy the condition of corollary     as d has   support sets   s     e      holds  

if the condition of proposition    on e and e    e  is violated  then the maximal size of a  minimal complete support family can not be assessed that easily  for instance  the support hyper
from figure   contains   edges  but d has    support sets  it can be shown that if k
graph gsupp d  t

nodes in gsupp d  t violate the condition  then sg 
contains at most  e k       support sets 
supp d  t

for the considered example  this yields a bound of              which is far from tight 
we note that proposition    can not be applied for tree cyclic support hypergraphs 

for d   dl   q  x   t  
example    consider a tree cyclic support hypergraph gsupp d  t
 d  c  c  a  c  b  a  b  q  and    sig t    which is shown in figure  b  using
proposition    we get ws xd        ws xc        ws xa        ws xb        ws xq    
           however  q x  has only   rewritings      s     q x        s     a x   b x   
    s     c x    and     s     d x   
intuitively  for tree cyclic hypergraphs the support weight function ws may also account for nonminimal rewritings  b x   c x     a x   c x     a x   d x     b x   d x    and some
rewritings can be counted multiple times  thus in general  ws x  provides only an upper bound
for the number of rewriting  likewise  the bound in proposition    is not tight even for simple treecyclic support hypergraphs  e g   the one for the dl atom d   dl   q  x  w r t  the tbox a  bi  
bi  q     i  n  contains    n edges  but d has only n     support sets 


   repair computation based on partial support families
in this section  we present our algorithm soundransset for computing deletion repair answer
sets  as shown by stepanova         deciding whether a given dl program    ht  a  pi over
an el ontology has some deletion repair answer set is p   complete in the general case  where the
membership part is established by guessing a candidate repair abox a  a along with a candidate
   

fie iter   f ink   s tepanova

answer set i for    ht  a   pi  and the suitability of the guess is checked using an np oracle 
clearly this is not efficient  as there are   n   candidate repair aboxes for n    a   even if finding
an answer set i of  would be cheap 
we restrict the search space of repairs in our approach as in the work of eiter et al       d  by
exploiting support families for dl atoms  however  in contrast to the results by eiter et al       d  
the support families are not required to be complete  if the families are complete  which may
be known or asserted in their construction   then soundransset is guaranteed to be complete 
otherwise  it may miss repair answer set  but an easy extension ensures completeness 
our algorithm for repair answer set computation  shown as algorithm    proceeds as follows 
 we start at  a  by computing a family s of nonground support sets for each dl atom 
 next in  b  the so called replacement program  is constructed 
the replacement program is obtained by a simple rewriting of gr    where each dl atom d
is replaced by an ordinary atom ed  called replacement atom   and a disjunctive choice rule
ed  ned  is added that informally guesses the truth value of d  where ed  respectively ned  
stands for the value true  respectively false   each repair answer set of  augmented with the
proper choice of ed resp  ned is an answer set of   eiter et al         proposition      thus
the search can be confined to answer sets i of   which can be found using a standard asp
solver 
 in  c  the answer sets i of  are computed one by one 
 we determine in  d  the sets dp  resp  dn   of dl atoms that are guessed true  resp 
 for i 
 a  which instantiates s for the dl atoms in
false  in it and then use the function gr s  i 

dp  dn to relevant ground support sets  i e   those compatible with i 
 in  e  we loop through all minimal hitting sets h  a of the support sets for dl atoms in dn
that only consist of abox assertions  and in  f  we construct for each h the set dp of atoms
from dp that have at least one support set which is disjoint from h  thus removing h from
a does not affect the values of atoms in dp   

 then in  g  we evaluate in a postcheck the atoms in dn and dp  dp over t  a h w r t  i 
a boolean flag rep stores the evaluation result of a function eval n  resp  eval p    more specifically  given dn  resp  dp    i and t  a h  the function eval n  resp  eval p   returns true  if
all atoms in dn  resp  dp   evaluate to false  resp  true  
 t  a   h  p  succeeds  then in  h  the
 if rep is true and the foundedness check flpfnd i 


restriction i  of i to the original language of  is output as repair answer set 
we remark that in many cases  the foundedness check might be trivial or superfluous  eiter 
fink  krennwallner  redl    schller      a   e g   when there are no loops through dl atoms  if
we consider weak answer sets  eiter et al          it can be entirely skipped 
example    let  be the dl program from example   with equivalence    in the axioms    
and     weakened to   and with further assertions project p    and blacklistedstaffrequest r   
added to the abox a  moreover  assume that d   r      dl project  projfile  staffrequest  r    
d   r    dl staff  chief   blacklistedstaffrequest  r     d   r   p    dl   hastarget  r   p   
   

fic omputing r epairs of i nconsistent dl p rograms over el o ntologies

algorithm    soundransset  compute deletion repair answer sets
input   ht  a  pi
output  a set of repair answer sets of 
 a  compute a set s of nonground support families for the dl atoms in 
 b  construct the replacement program 
 c  for i  as    do

 dn   d   ned  i  
 sigr
 a  
 d 
dp   d   ed  i  
 gr s  i 
s

 e 
for all minimal hitting sets h  a of d dn sigr  d   do

 f 
dp   d  dp   s  sigr  d  s t  s  h    
 t  a h   evalp  dp  dp   i 
 t  a h 
 g 
rep  evaln  dn   i 
 ht  a h  pi  then output i 

 h 
if rep and flpfnd i 
end
end

and d   r   john    dl   hassubject  r   john   then in  b  the following replacement program
 is constructed 



    ed   r     ned   r         ed   r     ned   r         ed   r    p     ned   r    p     








   
e
 r 
 
john 

ne
 r 
 
john  
   
projfile p 
  
   
hasowner
 p 
 
john  


d 
d 






    chief  john   hasowner  p    john   projfile p    
  
 


    grant r     ed   r     not deny r    










     deny r     ed   r    





       hasowner  p    john   not grant r     ed   r    p     ed   r    john  

suppose that i    ed    ned    ed    ed    hasowner  p    john   projfile p     chief  john   is returned
at  c  and that the following partial support families are obtained in  d  


 sigr  d       s    s     where s     hasaction r    read    hassubject r    john   action read   
staff  john   hastarget r    p     projectprojfile  p     and s     staffrequest r     


 sigr  d       s   s     where s     staffrequest r    hassubject r    john  blacklisted  john  
and s     blacklistedstaffrequest r     


 sigr  d       s     where s     hastarget r    p     


 sigr  d       s     where s     hassubject r    john   
at  e  we get a hitting set h    staffrequest r     blacklistedstaffrequest r      which is disjoint
with s    s  and s    thus in  f  we obtain dp    d    d    d    and then in  g  we check whether
d  is false under a h  as this is not true  rep   false and we pick a different hitting set h    e g 
 blacklisted  john   blacklistedstaffrequest r      proceeding with h    we get to  g   and as
 t  a  h    true and the flp check succeeds at  f   the interpretation i 
  is output 
eval n  d    i 

the following results state that our algorithm works properly 
   

fie iter   f ink   s tepanova

theorem    algorithm soundransset is sound  i e   given a program    ht  a  pi  every
output i is a deletion repair answer set of  
if we know in addition that the support families are complete  then the postchecks at  g  are
redundant  if dp   dp   then we set rep   true  otherwise rep   false 
theorem    suppose that for the input program    ht  a  pi of algorithm soundransset  it
holds that for each dl atom in  the support family in s computed in step  a  of soundransset
is  complete  then algorithm soundransset is complete  i e   it outputs every deletion repair
answer set of  
we can easily turn soundransset into a complete algorithm  by modifying  e  to consider all
hitting sets  but not only minimal ones  in the worst case  this means a fallback to almost the naive
algorithm  note that all hitting sets can be enumerated efficiently relative to their number  
    optimizations and extensions
research in repairing databases  see the work by bertossi        for overview  suggests several
techniques  which are of potential interest for dl programs  and could be exploited for optimizing
and extending our repair approach  localization of repairs proposed by eiter  fink  greco  and
lembo        is one such technique  where cautiously a part of the data that is affected by inconsistency is identified and the search of repairs is narrowed down to this part  using localization  in
our setting the ontology abox can be split into a safe set of facts  which will not be touched by any
repair  and a set of facts that are  probably  affected  after the affected part is repaired  the result is
then combined with the safe abox part to get the final solution  to find a suitable abox split  meta
knowledge about the ontology  e g  modules  additional domain information  can be used 
another common approach for tackling an inconsistency problem  which proved to be effective
for databases  is decomposition  eiter et al          here  the available knowledge is decomposed
into parts  such that the reasons for inconsistency are identified in each part separately  and then
the respective repairs are conveniently merged  while for databases decomposition is natural  it
is in general unclear how an inconsistent dl program can be effectively decomposed  one way
to approach this problem is by determining dl atoms whose replacement atoms are guessed true
 resp  false  in all answer sets of   given a set of such dl atoms  one can aim at first searching
for a repair under which every such dl atom has the desired value  and then extend the solution
to get the final result  modules of dl programs  as identified by the dlvhex solver  can also be
exploited for program decomposition 
as not all repairs are equally useful for a certain setting  various filterings on repairs can be applied to get the most plausible candidates  here  qualitative and domain specific aspects of repairs
are of crucial importance for their practicability  these can be formulated in terms of additional local constraints that express for instance that facts involving certain predicates or constants must be
preserved  resp  should be checked for removal   furthermore  the number of facts predicates constants allowed for deletion can be bounded  these filterings are incorporated in our repair approach 
yet there are several further extensions possible like conditional predicate dependence  for example  a user might be willing to express the condition that staffrequest r   can only be eliminated if
hasaction r   read   holds in the data part  or blacklisted staff members can not be removed  if they
own files  for modifying which a separate staffrequest has been issued by a non blacklisted staff
member 
   

fic omputing r epairs of i nconsistent dl p rograms over el o ntologies

   s p  y
  
 r    supd  x 
d
a p

  s
  
 y
 r    supd  x 
d

  s p  y
  
 r      ned  x  
d

            pnd  y
     ned  x  
  s a p  y
  
 r    p d  y
d

     rb s p  y
    
 r    sdp  y
d
a p  
a p  

    
 r    sd  y    rb sd  y     nd sda p  y

   ed  x  
  not cd   not supd  x 
 
 r    eval d  x 

 
 
 r    eval d  x   ned  x   not cd

  cd   not supd  x 
 
 r      ed  x  

figure    rules rd for declarative implementation
    implementation
we have implemented our repair approach in c   in a system prototype  dlliteplugin of the dlvhex
system        
as discussed  the support sets for el ontologies are of a rich structure  and thus for their computation  tbox classification as in the work of eiter et al       d  is insufficient  indeed  we need
to identify not only inclusions between atomic concepts  but also all inclusions of the form c  b 
where c is an arbitrarily complex concept and b is atomic  for constructing support sets we thus exploit the r equiem tool  prez urbina et al          which rewrites the target query over the tbox
using datalog rewriting techniques  by limiting the number  resp  size  of the rewritings  partial
support families can be computed 
in principle some support sets may be subsumed by smaller support sets  e g    r c  d  a c  
by  a c     these support sets are redundant and thus we eliminate them in our implementation 
after the support families are constructed  we use a declarative approach for determining repair
answer sets  in which the minimal hitting set computation is accomplished by rules  to this end 
  the three fresh predicates  i  supd  x  
   ii  s p  y
     and  iii  s a p  y
    are
for each dl atom d x 
d
d
     which intuitively say that d x 
    xx
  has  i  some support set   ii  some
introduced  where y
support set involving only rule predicates  and  iii  some support set involving abox predicates  and
possibly rule predicates   called mixed support set  furthermore  for every dl atom d x   the rules
rd in figure   are added to the replacement program  
  is known to be
in these rules  the atom cd informally says that the support family for d x 
complete  information about completeness of support families for certain dl atoms can be added
to the declarative program in the form of facts cd   the rules  r     r    reflect information about
  under a potential repair  rb s  stands for a rule body representing a support
support sets of d x 
             not ppnd  y
    
set s  i e  rb s    a          ak if s    a            ak    nd s    not pp d  y
             ppnd  y
      encodes the ontology part of s and pp  y
    states that the assertion
where  pp d  y
id

 
 
pi d  y   is marked for deletion  the constraint  r    forbids that d x   if guessed false has a matching
  has a matching
support set that consists only of input assertions   r    means that if instead d x 
mixed support set  then some assertion from its ontology part must be eliminated  the rule  r   
  is guessed true  completeness of its support family is unknown and no matching
says that if d x 
 
support set is available  then an evaluation postcheck is necessary  eval d  x   
rule  r    is similar

 
for d x  guessed false  the rule  r    states that a dl atom guessed true must have some support
set  if its support family is known to be complete 
the set of facts f acts a     pp   c    p   c   a   encoding the abox assertions and comp 
 cd   sd is a complete support family for d  are added to the program   and then its answer sets
   

fie iter   f ink   s tepanova


    projfile p         hasowner  p    john       issued  john  r    





    chief  john   hasowner  p    john   projfile p    





     deny r     ed  r    



      hasowner  p    john   issued  john  r     deny r    




    ed  r     ned  r    





    supd  x    pblacklistedstaffrequest  x    not pblacklistedstaffrequest  x  




     pblacklistedstaffrequest  x    ned  x    pblacklistedstaffrequest  x   
  r        supd  x    pstaffrequest  x    not pstaffrequest  x    phassubject  x   y   



not phassubject  x  y    pblacklisted  y    not pblacklisted  y   





    
p
 x
   phassubject  x   y    pblacklisted  y    ned  x   pblacklisted  y   
staffrequest




pstaffrequest  x   





phassubject  x   y   




    
eval
 x 

e
 x  
not
c
 
not
sup
 x  

d
d
d
d



     eval d  x   ned  x   not cd  



       ed  x   cd   not supd  x  



























































figure    program   r from example   
 we proceed with an evaluation postcheck for all atoms
are computed  for each such answer set i 
d  c  for which the fact eval d   c  is in the answer set  if all evaluation postchecks succeed  then we
  of the original program  from i 
 this way one identifies
extract the repair answer set i   i 
weak repair answer sets  for flp repair answer sets  an additional minimality check is needed  in
many cases  however  the flp and weak answer sets coincide  cf  eiter et al       a   in particular 
this holds for the example and benchmark programs that we consider 
we now formally show that the described approach indeed correctly computes weak repair answer sets 
proposition    let    ho  pi be a ground dl program  where o is an el ontology  let for each
dl atom d of  be sd  suppo  d   and let rd be the set of rules  r     r    for d  define
      r  f acts a   comp 
s
where r   d rd   f acts a     pp   c    p   c   a  and comp   cd   sd is  complete for
d w r t  o   suppose i  as      is such that the evaluation postcheck succeeds for every dl atom
   ras weak     moreover  if cd  comp for every dl atom d 
d with cd   comp  then i 

then ras weak       i    i  as       
let us demonstrate the usage of the declarative implementation through an example 
example    consider in figure   the replacement program  and the rules r of    hp  oi 
where o is as in example    and p is as follows 

    projfile p         hasowner  p    john       issued  john  r    




    chief  john   hasowner  p    john   projfile p    
p 

    deny r     dl staff  chief   blacklistedstaffrequest  r    



      hasowner  p    john   issued  john  r     deny r    
   











 

fic omputing r epairs of i nconsistent dl p rograms over el o ntologies

assume that for d x    dl staff  chief   blacklistedstaffrequest  x  we are given an
incomplete support family sd    s    s     where s     blacklistedstaffrequest x    and s   
 staffrequest x    hassubject x   y    blacklisted  y     then the interpretation i   ned  r    
pstaffrequest  r     pblacklisted  john   evald   is among the answer sets of   r  facts a   as
 a post check is needed for d r     this test succeeds  and thus i 
  is a repair answer set 
eval d  i 


   evaluation
the repair answer set computation approach is implemented within the dlvhex system  the details
can be found in the work of stepanova         and the software is freely online available  dlliteplugin         our approach was evaluated on a multi core linux server running dlvhex       under
the htcondor load distribution system  htcondor         which is a specialized workload management system for compute intensive tasks  using two cores  amd      se cpus  and  gb
ram 
to the best of our knowledge  no similar system for repairing inconsistent dl programs exists  the list of systems for evaluating dl programs includes the dr e w system  drew       
xiao        and the dlplugin of the dlvhex system  dlplugin         the dr e w system exploits
datalog rewritings for evaluating dl programs over el ontologies  however  it can not handle inconsistencies  which are the focus of our work  thus dr e w per se could not be used as a baseline
for experiments  to facilitate a comparison  we have thus extended dr e w with a naive repair
technique  where a guess of a repair abox is followed by a check of its suitability  however  this
immediate implementation turned out to be infeasible even on small instances  as in general the
search space for repairs is ways too large for its full exploitation  guided search is needed to ensure
scalability  the dlplugin of the dlvhex system invokes r acer p ro reasoner  racerpro        as
a back end for evaluating calls to the ontology  however  for lightweight ontologies even in the
standard evaluation mode without any repair extensions  it scales worse than the dlliteplugin  eiter
et al       b   thus we focus on the latter in our experiments 
    evaluation workflow
the general workflow of the experimental evaluation was as follows  in the first step  we constructed benchmarks by building rules and constraints on top of existing ontologies such that for
some data parts the constructed programs become inconsistent  the instances were generated using
shell scripts  dl program benchmark generation scripts        with the size of the conflicting data
part as a parameter  the benchmarks were then run using the htcondor system  and the times were
extracted from the log files of the runs  in each run  we measured the time for computing the first
repair answer set  including support set computation  with a timeout of     seconds 
for each benchmark  we present our experimental results in tables  the first column p specifies
the size of the instance  varied according to certain parameters specific for each benchmark   and
in parentheses the number of generated instances  e g   the value        in the first column states
that a set of    instances of size    were tested  the other columns represent particular repair
configurations  grouped into three sets 
the first set refers to the settings where  complete support families were exploited  while the
second and the third refer to the settings in which the size  respectively the number of computed sup   

fie iter   f ink   s tepanova

port sets was restricted  for the  complete setting  we in addition limit the number of facts  lim f   
predicates  lim p  and constants  lim c  involved in facts that can be removed  e g   lim p    
states that the set of removed facts can involve at most two predicates  the parameter del  p stores
predicates that can be deleted  e g   del  p   staffrequest means that repairs can be obtained by
removing only facts over staffrequest 
in the restricted configurations  the column size   n  resp  num   n  states that in the
computed partial support families the size  resp  number  of support sets is at most n  if n    
then in fact all support sets were computed  but the system is not aware of the  completeness  we
exploit partial  completeness for the number and size restriction cases  i e  if no more support sets
for an atom are computed and the number size limits were not yet reached  then the support family
for the considered atom is  complete 
in an entry t m  n   t is the total average running time  including support set generation and
timeouts   m is the number of timeouts and n is the number of found repair answer sets 
    benchmarks
for the evaluation of the developed algorithms  we considered the following benchmarks 
    the policy benchmark is a variant of example    in which the rule      of p is changed
to deny x    dl staff chief   unauthorizedstaffrequest  x   and two further axioms 
namely unauthorizedstaffrequest  staffrequest  hassubject unauthorized and
blacklisted  unauthorized are added to t  
    the openstreetmap benchmark contains a set of rules over the ontology for enhanced personalized route planning with semantic information  myits ontology        extended by an
abox containing data from the openstreetmap project  osm        
    the lubm benchmark comprises rules on top of the well known lubm ontology  lubm 
      in el 
we now describe the benchmark results in details  all experimental data are online available
 experimental data        
      access p olicy c ontrol
we considered aboxes an with n staff members  for n                  each data set has  
projects and   possible actions  furthermore     of the staff members are unauthorized and     are
blacklisted  for generating instances  we used the probability p      with p from column    that a
fact hasowner  pi   si   is added to the rules part p for each si   pi   such that staff  si    project pi   
a  i e   instances vary only on facts hasowner  pi   si   in p   as a parameter  here  p ranges from    
    etc  to    for a   and from       etc  to    for a    and a      the total average running times
for these settings are shown in tables     where sr stands for staffrequest  the experiments
were performed for the aboxes of the chosen size  i e   a     a      a      to demonstrate how our
approach works on small  medium and large data 
as regards a     limiting in the  complete setting the number of predicates for removal slightly
increases the running times  restricting repairs to removing facts only over staffrequest does
not slow down the repair computation compared to the unrestricted case  as many of the actual
repairs indeed satisfy this condition  the results for bounded number and size of support sets are
   

fic omputing r epairs of i nconsistent dl p rograms over el o ntologies

p
       
       
       
       
       
       
       
       

 complete support families
no restr  
lim p    
del p   sr
                         
            
                         
            
                         
            
                         
            
                         
            
                         
            
                         
            
                         
            

incomplete support families
size    
size    
num    
             
                          
             
                          
             
                          
              
                          
                                          
                                          
                                          
                                          

num   
            
            
            
            
            
            
            
            

table    policy benchmark  a  
p
     
      
      
      
      
      
      
      

 complete support families
no restr  
lim p    
del p   sr
           
            
            
           
            
            
                         
            
                         
            
                          
             
                          
             
                          
             
                          
             

incomplete support families
size    
num    
            
            
            
            
            
            
            
            
                           
                           
                           
                           

num   
            
            
            
            
             
             
             
             

table    policy benchmark  a   
p
      
       
       
       
       
       
       
       

 complete support families
no restr  
lim p    
del p   sr
             
             
             
             
             
             
             
             
             
             
             
             
              
                            
              
                            
              
                             
                                             

incomplete support families
size    
num    
             
             
             
             
             
             
             
             
                             
                             
                             
                             

num   
             
             
             
             
              
              
              
              

table    policy benchmark  a   
almost constant  except when the size is limited to   or smaller  just size   and size   are shown  
here support sets exceed the bound and post evaluation checks often fail  which visibly impacts the
running times  while the support sets are large  there are just few of them  this can be seen from the
insignificant difference between the times for num     and num    
for the significantly larger abox a      we get that for each value of p the considered settings
perform almost identical except that lim p     is a bit slower  moreover  the running times increase
gracefully with the value of p  while bounding the support set size to   produces only timeouts  thus
the column is omitted   computing support sets of size   is always sufficient to identify repairs 
for the largest setting a      in the  complete case finding an arbitrary repair is faster than
under the restriction lim p       but only up to p       from p      the results for lim p    
   

fie iter   f ink   s tepanova

p
       
       
       
       
       
       
       
       
       

 complete support families
no restr  
lim f    
lim c     
             
             
             
             
             
             
             
             
             

             
             
             
             
             
             
             
             
             

             
             
             
             
             
             
             
             
             

size    
             
            
            
            
             
             
             
             
              

incomplete support families
size    
num    
             
             
             
             
             
             
             
             
             

             
             
             
             
             
             
             
             
             

num    
             
             
             
             
             
             
             
             
             

num   
             
             
             
             
             
             
             
             
             

table    open street map benchmark results

outperform the unrestricted setting  as the posed limitation restricts the search space of repairs effectively  removing only facts over staffrequest is no longer always sufficient  which is witnessed
by the decreased number of identified repairs for del  p   staffrequest compared to lim p      
again the time increases rather gracefully with p as long as repair answer sets are found 
      o pen s treet m ap
for the second benchmark  we added rules on top of the ontology developed in the myits project 
the fixed ontology contains      axioms  where     axioms are in the tbox and      are in the
abox  the fragment t  of t relevant for our scenario and the rules p are shown in figure    
intuitively  t  states that building features located inside private areas are not publicly accessible
and a covered bus stop is a bus stop with a roof  the rules p check that public stations do not lack
public access  using cwa on private areas 
we used the method introduced by eiter  schneider  imkus  and xiao        to extract data
from the openstreetmap repository  osm         we constructed an abox a by extracting the
sets of all bus stops       and leisure areas       of the irish city cork  as well as islocatedinside
relations between them      i e   bus stops located in leisure areas   as the data has been gathered
by many volunteers  chances of inaccuracies may be high  e g  imprecise gps data   since the
data about roofed bus stops and private areas was yet unavailable  we randomly made     of
the bus stops roofed and     of leisure areas private  finally  we added for each bsi such that
islocatedinside bsi   laj    a the fact busstop bsi   to p with probability p      some instances
are inconsistent since in our data set there are roofed bus stops located inside private areas 
the results are shown in table    for the  complete setting arbitrary repairs are computed
about     seconds faster than the repairs with bounded changes  for the restricted configuration
the times do not vary much except for size      where a significant time increase is observed  and
repairs are found only for smaller instances  like in the previous benchmark computing a small
number of support sets is often sufficient  but the configuration num     is as expected slightly
slower than num      computing support sets is here cheap  while postchecks take some time  
   

fic omputing r epairs of i nconsistent dl p rograms over el o ntologies



t  



    buildingfeature  islocatedinside private  nopublicaccess
    busstop  roofed  coveredbusstop




    publicstation x   dl busstop  busstop  coveredbusstop  x  



not dl   private  x  
p 
    


dl buildingfeature
 publicstation  nopublicaccess  x  



publicstation x   









figure     dl program over openstreetmap ontology
p
      
       
       
       
       
       
       
       
       
       

no restr  
             
             
             
             
             
             
             
             
             
             

 complete support families
lim f    
lim p    
                           
                           
                          
                          
                          
                          
                          
                          
                          
                          

lim c     
             
             
             
            
            
            
            
            
            
            

incomplete support families
size    
size    
                           
                           
                           
                           
                           
                           
                           
                           
                           
                           

num   
             
             
             
             
             
             
             
             
             
             

table    lubm benchmark results
      lubm
we have also tested our approach on dl programs    hp  oi built over an el version of the
lubm ontology  whose tbox was extended with the following axioms 
    graduatestudent  assists lecturer  ta
    graduatestudent  teaches undergraduatestudent  ta
the rules of  are as follows 


    stud  x    not dl   employee  x    dl   ta  x   
 
p 
      dl student  stud   taof   x   y    takesexam x   y  
here     states that unless a teaching assistant  ta  is known to be an employee  he she is a student 
while     forbids teaching assistants to take exams in the courses they teach 
the abox contains information about one university with more then     students     teaching
assistants  constructed by a dedicated abox generator  lubm data generator         for pairs of
constants t  c  such that teachingassistantof  t  c  is in a  the facts takesexam t  c  are randomly
added to the rules part with probability p      thus the contradicting part in the dl program is
growing with respect to p 
the results for this benchmark are provided in table    bounding in the  complete setting
the number of removed facts to   slows down the computation  if repairs satisfying the condition
exist  for instances with p      i e   inconsistency is more entrenched   more than   facts must
be dropped to obtain a repair  moreover  they often involve more than    constants according to
   

fie iter   f ink   s tepanova

column    the absence of repairs for lim f     and lim c      is found faster than a repair in the
unrestricted mode 
limiting the support set size to   allows one to find repairs for all instances with a delay of less
than    seconds compared to the  complete setting  however  there are many support sets for this
benchmark  and thus bounding their number is less effective 
    general results discussion
one can observe that for  complete settings and settings where post evaluation checks are fast  the
running times vary only slightly with growing p  this is due to our declarative implementation  in
which computing repairs is reduced to finding answer sets of the program       r  facts a  
comp followed by possible evaluation postchecks  in our benchmarks the difference between
instances of size pi and pi   is the data part of the logic program  which is small compared to the
part facts a  of   that is constant for all p  thus as long as postchecks are not needed  the times
required for repairing  do not differ much even though the programs become more inconsistent 
as expected  using  complete support families works well in practice  naturally  it takes more
time to compute restricted repairs rather than arbitrary repairs  however  when the imposed restrictions are too strong such that no repair can satisfy them  the solver may recognize this faster 
as reported by hansen et al          el tboxes that originate from real world applications
admit fo rewritings  of reasonable size  in almost all cases  this provides some evidence that realworld el tboxes hardly contain involving constraints on the conceptual level  and that hence either
the size or number of support sets for dl atoms often turn out to be limited  the novel algorithms
for deletion repair answer set computation demonstrated their applicability for dl programs over
some real world data  open street map benchmark results in table    
while most of the other benchmarks that we have run are synthetic  they still vary w r t  tbox
and abox sizes  the capability of our algorithms for handling such diverse dl programs confirms
the potential of our approach 

   related work
inconsistencies in dl programs were studied in several works  phrer et al         fink       
eiter et al             d   phrer et al  proposed an inconsistency tolerant semantics  keeping the
ontology untouched  the dl atoms that introduce inconsistency as well as rules involving them are
deactivated  the repair problem  outlined as an open issue by phrer et al   was formalized by eiter
et al          where the notions of repair and repair answer sets together with a naive algorithm
for their computation were proposed  the latter was then optimized by eiter et al       d       
for dl lite a by effectively exploiting complete support families for dl atoms  our approach is
more general  and it differs from the one of eiter et al       d        in that it uses partial  not
necessarily complete  support families and can be applied to ontologies in any dl  though with a
possible impact on complexity 
in other hybrid formalisms  inconsistency management has concentrated on inconsistency tolerance rather than on repair  for instance  huang et al         presented a four valued paraconsistent
semantics based on belnaps logic  belnap        for hybrid mknf knowledge bases  motik  
rosati         which are the most prominent tightly coupled combination of rules and ontologies 
inspired by the paracoherent stable semantics of sakama and inoue         the work of huang
et al         was extended by huang  hao  and luo        to handle also incoherent mknf kbs 
   

fic omputing r epairs of i nconsistent dl p rograms over el o ntologies

i e  programs in which inconsistency arises as a result of the dependency of an atom on its default
negation in analogy to the work of fink         another direction of inconsistency handling for
hybrid mknf kbs is using the three valued  well founded  semantics of knorr  alferes  and hitzler         which avoids incoherence for disjunction free stratified programs  most recently  this
has been extended by kaminski et al         with additional truth values to evaluate contradictory
pieces of knowledge  these works aim at inconsistency tolerance rather than repair  and are geared
in spirit to query answering that is inherent to well founded semantics  as such  it is limited to
normal logic programs  while dl programs allow for disjunctive rule heads 
in the context of description logics  repairing ontologies has been studied intensively  foremost
to handle inconsistency  our dl program repair is related to abox cleaning  masotti  rosati   
ruzzi        rosati  ruzzi  graziosi    masotti         however  the latter differs in various
respects  it aims at restoring consistency of an inconsistent ontology by deleting  minimal sets
of assertions  i e   computing  maximal deletion repairs   we deal with inconsistency incurred
on top of a consistent ontology  by arbitrary  non monotonic  rules which access it with a query
interface  furthermore  we must consider multiple aboxes at once  via updates   and use el instead
of dl lite  refining our algorithm to compute  maximal deletion repairs is possible 
the problem of computing support families is tightly related to finding solutions to an abduction
problem  which was considered by bienvenu        for theories t expressed in el terminologies 
a hypothesis h    a            an   is a set of atomic concepts  and an observation is another atomic
concept  a solution to the abduction problem is any set s  h  such that t    ai s ai  o 
our setting is more general and involves also roles along with atomic concepts  abduction has
been studied in various related areas e g   for dl lite ontologies by calvanese  ortiz  simkus  and
stefanoni         for propositional logic by eiter and makino         for datalog by eiter et al 
       and gottlob  pichler  and wei         etc  using incomplete support families for dl atoms
is related in spirit to approximate inconsistency tolerant reasoning in dls using restricted support
sets as considered by bienvenu and rosati         however  we focus on repair computation and
model generation while bienvenu and rosati target inference from all repairs 
our methods for constructing partial support families exploit the results on the logical difference
between el terminologies presented by konev et al         and ecke et al          recently they
were extended to elhr by ludwig and walther        and to general tboxes by feng et al 
       
repairing inconsistent non monotonic logic programs has been investigated in the work of
sakama and inoue         where an approach for deleting rules based on extended abduction was
studied  however  to restore consistency addition of rules is also possible  the latter was considered
by balduccini and gelfond         where under occams razor consistency restoring rules may be
added  methods for explaining why the inconsistency arises in a logic program were studied  e g  
by syrjnen         who exploited model based diagnosis of reiter        to debug a logic program  generalized debugging of logic programs was investigated e g   by gebser  phrer  schaub 
and tompits         most recently  schulz  satoh  and toni        considered a characterization
of reasons for inconsistency in extended logic programs  i e   disjunction free logic programs with
both strong  classical  negation and weak negation  in terms of culprit sets of literals  based on
the well founded and maximal partial stable model semantics  and a derivation based method to explain such culprits has been described  however  it remains open how debugging of logic programs
based on culprit sets could be done and whether this could be fruitfully extended to debugging dlprograms  the latter has been addressed by oetsch  phrer  and tompits        and is related to
f

   

fie iter   f ink   s tepanova

the challenging but  to the best of our knowledge  unexplored problem of repairing the rule part of
a dl program 

   conclusion
we have considered computing repair answer sets of dl programs over el ontologies  for which
we generalized the support set approach of eiter et al       d      b  for dl lite a to work with
incomplete families of supports sets  this advance is needed since in el complete support families can be large or even infinite  we discussed how to generate support sets  by exploiting query
rewriting over ontologies to datalog  lutz et al         rosati        stefanoni et al          which
is in contrast to the work by eiter et al       d   where tbox classification is invoked  moreover 
we have developed alternative techniques for effective computation of partial support families  our
approach is to approximate a relevant part of the tbox to dl lite core exploiting a notion of logical
difference between el terminologies  and then compute complete support families over an approximated tbox using methods of eiter et al       d   the obtained support family is complete  if the
approximated tbox is logically equivalent to the original one 
to estimate the maximal size of support sets  we have analyzed the properties of a novel support hypergraph  which corresponds to a subgraph of an ontology hypergraph  nortje et al        
ecke et al          where nodes encode ontology predicates  or pairs of them   while  hyper  edges
reflect tbox inclusions  we have shown how traversing a support hypergraph one can conveniently
compute an upper bound for the number of support sets for a given dl atom  if  in addition  the
support hypergraph satisfies certain conditions  e g  tree acyclicity   then an exact estimate can be
obtained 
we developed a sound algorithm for computing deletion repair answer sets for dl programs
over el ontologies  which is complete in case all support families are also known to be complete 
the algorithm trades answer completeness for scalability  a simple variant ensures completeness  
we have implemented the novel algorithm using declarative means within a system prototype  that
invokes a r equiem reasoner for partial support family computation  for an experimental assessment of our repair approach  a set of novel benchmarks has been constructed including real
world data  while the availability of complete support families adds to the scalability of the repair
computation  partial support families work surprisingly well in practice due to the structure of the
benchmark instances  the support sets are either small or there are just few of them  and thus postevaluation checks do not cause much overhead  overall  our experimental evaluation has revealed a
promising potential of the novel repair methodology for practical applications 
    outlook
the directions for future work in the considered area are manifold  they cover both theoretical and
practical aspects of our inconsistency handling approach  on the theoretical side  a relevant open
issue are sufficient conditions under which computing all nonground support sets for a dl atom
accessing an el ontology becomes tractable  like in the work of gebser et al         bounded
tree width might be considered  but also other parameters like density of a support hypergraph or
various acyclicity properties  analyzing the complexity of counting support sets in a complete
support family might give hints to possible restricted settings  in which support family computation
is efficient  but such a complexity analysis is also an interesting problem as such  on the practical
   

fic omputing r epairs of i nconsistent dl p rograms over el o ntologies

side  optimization of the current implementation and extending the range of applications to real use
cases is another issue 
repair may be intermingled with stepping techniques used for debugging dl programs  oetsch
et al          we considered the dl programs as monolithic structures when applying our repair
techniques  that is the repair computation was performed on a dl program taken as a whole  it is
an interesting and a relevant quest to extend the approach for dealing with modular dl programs 
splitting a program into separate components that can be individually evaluated is a well known
programming technique  which has been studied in the context of dl programs  eiter et al         
it is not clear  however  to which extent and for which program classes the repair methods can be
adapted for the modular setting 
while we have considered el in this paper  the basic algorithm and approach is applicable also
to other dls  extensions of our work to el  and el   are easily possible  the main difference
is negation  which is expressible via the  concept  the ontology can get inconsistent through the
updates of dl atoms  leading to an increased number of support sets that need to be effectively
computed and appropriately handled  the extension to expressive dls such as shiq  shoin
or even sroiq is more challenging  as efficient methods for support set construction remain to
be developed  by the relatively high complexity of these dls  this comes at a computational cost 
on the other hand  the computation may be done once  even offline  and can be reused  fortunately 
support families need not be complete  but we may expect a return of investment of time in support
set construction for the overall running time 
orthogonal to other dls  one can study various additional repair possibilities  e g  bounded
addition  for overview of repair possibilities see the work of eiter et al          here we have
concentrated on repairing the data part of the ontology  but it is also natural to allow changes in
rules and interfaces  for repairing rules  the works on asp debugging by frhstck  phrer  and
friedrich         gebser et al          and syrjnen        can be used as a starting point  but
the problem is challenging as the search space of possible changes is large  priorities on the rules
and atoms involving them might be applied to ensure high quality of rule repairs  the interfaces
similarly admit numerous modifications  which makes this type of repair as difficult  user interaction
is most probably required 
last but not least one could develop methods for repairing other hybrid formalisms including
tightly coupled hybrid kbs or even more general representations like hex programs  eiter et al  
       where instead of an ontology arbitrary sources of computation can be accessed from a logic
program  heterogeneity of external sources in hex programs makes both repair and paraconsistent
reasoning a very challenging task 

acknowledgments
we thank the anonymous reviewers for their detailed and constructive suggestions which helped to
improve this work  this article significantly extends preliminary work of eiter  fink  and stepanova
     c   the research has been supported by the austrian science fund  fwf  projects p      and
p      
   

fie iter   f ink   s tepanova

appendix a  proofs for section  
a   proof of proposition   
   by proposition     i   o d iff td  a  ai    q  t   where ai    pp   t   ad   p  t   i  
thus  s   a  ai is a support set of d w r t  o  and it is coherent with i by construction 
   if s  supp o  d  is coherent with i  then s is of the form s   a  ai where a  a
and ai  ai   and thus s  a  ai   as td  s    q  t   by monotonicity td  a  ai    q  t  
hence by proposition    i   o d 
a   proof of proposition   
  where
consider any instance s    p   y             pk  yk    of a set s of form     for d x  
   v  c  we show that s is a support set w r t  oc   ht   ac i  recall that ac is the set of all
 
possible abox assertions over c   i e   s  ac  ad  which clearly holds  and td  s    q x  
 
the latter is equivalent to tdnorm  s    q x  
which in turn by lemma    is equivalent to
 
 
prog q td norm  s    q x   let prog   prog q td norm   and let prog i     for each i    
 
be the program that results from prog i by unfolding a rule w r t  the target query q x  
then
i  
i
 
 
prog
 s    q x  iff prog  s    q x  holds  now by construction of s  there is a rule
  and thus prog i  s    q x  
 
r of the form     in some prog i   clearly  r   s    q x 
it
 
 
 
 
follows that prog  s    q x  and hence td norm  s    q x  and td  s    q x  

appendix b  proofs for section  
b   proof of lemma   
towards a contradiction  assume t d  c
 t d   then w l o g  t d    p   p  but t d     p   p   

where p    p      observe that  and  differ only on predicates pp   such that p  p occurs in
  and that t    t d  t    t d  t  consists only of axioms pp  p where pp does not occur in
t  or t    we first show that p    must hold  indeed  otherwise p       and thus p   
pp  sig ad   for some p  p from   now let a    p   c   if p     and a    p   c   p p  c  
otherwise  i e   p         for an arbitrary c  i  then t d  a has a model i in which ci  p i
 resp  ci  p i and ci  p  ip   and pp i     thus p     p     as el is negation free and pp occurs
in axioms only on the left  as i     p   pp   it follows t d     p   p    which is a contradiction 
this proves p        now there are two cases 
 i  p     t  c
 t  implies t     p   p    by monotonicity t d    p   p    a contradiction 
 ii  p        then p    pp   where p  p occurs in   and p    we claim that t     p  p   
indeed  otherwise t  has a model i such that p i   p  i   then as easily seen the interpretation i 


that coincides with i on  and has pp i   p i   p  i and pp i    for each pp      is a model
of t  d   however  i      pp  p    which would be a contradiction  this proves the claim  now
from the claim and t  c
 t    it follows t     p  p  and by monotonicity t d    p  p    as
pp  p  t  d   it follows t  d    p   p    this is a contradiction 
b   proof of proposition   
suppose that s  is a complete nonground support family w r t  o  and let s be any instance of any
i
s  s    then s   a  ad  ac  ad   by lemma     t d c
 t d   thus by theorem     t d 
   

fic omputing r epairs of i nconsistent dl p rograms over el o ntologies

t  d as well  by definition of  instance inseparability  for all  aboxes a and  assertions 
such that t d  a      it holds that t d  a      hence t d  a  ad    q  c   consequently 
s   a  ad is a  ground  support set of d w r t  o    if s  is a complete nonground support family
w r t  o    it follows that s is an instance of some s   s    the converse membership is symmetric 
hence  s  and s  are ground identical 
b   proof of proposition   
towards a contradiction  assume some s   s   suppo  d  exists  then a grounding  exists such
that s    td     d x   however  s    td    d x   as according to  f   s  is a nonground
support set for d w r t  td   td  lrw   consequently  td     td   which is a contradiction  because
td  td by construction in  c  and lrw    c   d   td    c   d   td     c   d    td by
lhs
 d  and definition of cwtnrhs
 and cwtn  

appendix c  proofs for section  
c   proof of lemma   

for d w r t  the ontology o  
the construction of support sets from a given hypergraph gsupp d  t
ht   ai that we have presented mimics the dl query unfolding over the tbox td   we now formally
show that  i  each set s extracted in the described way is indeed a nonground support sets for d 
and  ii  for each ground instance s of a nonground support set s for d  a  nonground  support
set s  can be constructed following our procedure such that s    s for some suitable ground
substitution    this proves that sg  s holds 
we first prove  i  by induction on the length n of incoming paths  from which the support sets
are extracted 

base  n    consider any path  in the hypergraph gsupp d  t
  assume that there is a single
 hyper   edge e in   by construction  this hyperedge must have xq as a head node  i e  head  e   
xq   there are four possibilities      tail  e     xc        tail  e     xr   xc        tail  e   
 xc   xd   or     tail  e     xr      we annotate the nodes of a path by variables as described
above  and extract the nonground atoms from labels and annotations of the nodes  as a result for
the case     we obtain  c x      for       r x    x     c x      for       c x     d x      and for
      r x    x      where x  is a fresh variable  by construction of the hypergraph the edges of the
forms         correspond to the tbox axioms c  q  r c  q  c  d  q and r   q
respectively  therefore  the sets that have been constructed in all of the considered cases reflect the
dl query unfoldings of d  and hence they represent nonground support sets for d by proposition    
induction step  suppose that the statement is true for n  i e  from a path with n edges all sets extracted in the way described above are nonground support sets for d  consider a path    e            en
with n   edges  and let e   e  be the first edge of   by the induction hypothesis  all sets extracted
from the path    e   e            en following our approach are support sets for d  there are several
possibilities for the form of e      tail  e     xc   and head  e     xd        tail  e     xr   xc  
and head  e     xd        tail  e     xc   xd   and head  e     xb        tail  e     xr     and
head  e     xc    or     tail  e     xc   and head  e     xr   xd   
as for      by construction both xc and xd are annotated with xi   let s be a family of sets
extracted from  e  we pick a set s in which c xi   occurs  we substitute c xi   in s with d xi   
and obtain a set s    by the induction hypothesis s must be a support set for d  however  then

   

fie iter   f ink   s tepanova

clearly s  is also a support set  as it mimics an additional unfolding step that accounts for the rule
c x   d x  of the datalog rewriting of td  
let us look at      assume a set s  d xi   of nonground atoms has been constructed using
our procedure  then xi must be an annotation for xd   according to our construction  xr   xd   is
annotated with  hxi   xj i  hxj i   where xj is a fresh variable  the sets s  that we get from  result
by substituting d xi   in some s with  r xi   xj    c xj     the latter mimics the unfolding step
for q that accounts for the rule d xi    r xi   xj    c xj   of the rewriting td   as s is a support
set for d by the induction hypothesis  s  must be a support set for d as well  the cases         can
be analyzed analogously  thus all sets of size n     extracted from  are support sets for d 
it remains to prove  ii   towards a contradiction  assume that some ground instance s of
some s  suppo  d  exists  such that for each ground instance s   of every s   suppo  d 
constructed by our procedure we have s     s  as s is a support set  by definition td norm 
s    q  c   thus by lemma    prog q tdnorm  s    q  c   this in turn means that q  c  has a
    and sm    
backchaining proof s    s            sm from prog q td norm s of the form s    q x 
     c  and si    si   hi   bi  i   i     where hi  bi is a
where   is the substitution x
rule resp  fact in prog q td norm  s and i is the most general unifier of hi with some atom in si   
without loss of generality  we have hi   a   oa    if hi    r   x  oa    and all i such that bi is
empty are at the end  i e  at the positions k  k              m  then each sj resp  sj        j  k


amounts to an instance of a support set sj resp  sj  
of d generated from gsupp d  t
  in particular 


sk  is an instance of sk  and consequently  hk   hk             hm     s  is an instance of sk 





as well  but this means s   s for some instance s  of s   sk    a contradiction 
c   proof of proposition   
we prove the statement by induction on the number n of hyperedges with a singleton head node in

g   gsupp d  t
for the dl atom dl   q  x  
base  n      we show that maxsup d       if no hyperedges of the required form exist in g 
several cases are possible   i  g contains only hyperedges of the form  xc    xr   xd      ii  g has
only hyperedges of the form   xr      xc   or  xc    xr       or  iii  g has no hyperedges 
 i  consider some hyperedge in   then some ej must exist in   such that head  ei    tail  ej   
the latter implies that ej is of the form   xr   xd    xd   but then n       i e  contradiction 
for  ii  and  iii   by construction t contains only gcis c  d such that c  d are either atomic
or of the form r   these axioms fall into the dl lite core fragment  for which all   minimal
support sets s have size at most    moreover   s      reflects in dl lite core inconsistency arising
in the updated ontology  eiter et al       d   as negation is not available nor expressible in el  no
such s exists and thus the maximal support set size for d is   
induction step  suppose that the statement is true for n  we prove it for n    let    e            ek

with a maximal number n   of hyperedges with a singleton
be an incoming path to xq in gsupp d  t
head node  assume that ei is the first hyperedge of the required form occurring in   let us
split  into two parts  e            ei and ei             ek   consider the hypergraph g     v  e     where
e    e    e            ei    and the tbox t  reconstructed from it  by the induction hypothesis 
maxsup d   w r t  o   ht    ai is bounded by n      now let the hypergraph g     v  e    with
e    e    ei   correspond to the tbox t    by our assumption head  ei     xa   i e  ei either
reflects b  c  a or r b  a  two cases are possible  either a   q or a    q  in the
   

fic omputing r epairs of i nconsistent dl p rograms over el o ntologies

x c n 

x cn

x c nk

xcn

   

xcn

 

  
 

k

  
 
   
xq

figure     fragment of a hypergraph used for illustration in the proof of proposition   
former case  ei is a single hyperedge on   i e  n      support sets obtained from rewriting q over
b  c  q or r b  q are of size at most    the other support sets are constructed by combining
query rewritings of predicates occurring on the left hand side of gcis reflected by ei   each of these
rewritings has size at most   as shown in the base case  thus the overall support set size for d w r t 
t  is bounded by    n     
suppose now that a    q  i e  ei reflects either b  c  a or r b  a  by definition of an
incoming path a  hyper  edge ej must exist  such that head  ei    tail  ej    moreover  note that ej
is a unique  hyper  edge connected to ei on   as otherwise the given hypergraph is tree cyclic  i e 
contradiction  we distinguish two cases      head  ei     tail  ej   and ej corresponds to a         
    head  ei    tail  ej   and ej reflects a  b         
   consider a maximal support set s for d w r t  t    and suppose a y    s holds  by induction

hypothesis  s   n  as g    gsupp d  t
 is tree acyclic  only a single atom over a might

occur in s  adding the edge ei to g from s we obtain a support set s  with the atom a y  
substituted with atoms b y   and c y    or r z  y   and b z  as a result of an additional
query unfolding step  hence the support set size of s  will be bounded by n     
   if ej reflects a  b          then a support set s   a y    b y    must exist  by unfolding
the respective datalog rule  we get the bound n     on the support set s  for d w r t  t    

c   proof sketch of proposition   
observe that in tree acyclic hypergraphs all nodes have a hyper out degree at most    and hence
m   g       thus  if g is tree acyclic  then by proposition    the support set size for a given
dl atom is bounded by n   g          which equals smax   we now show that the claimed bound
is also correct for tree cyclic hypergraphs  intuitively  m   g  must be subtracted from n   g  to
avoid that certain atoms in a support set are counted multiple times  regarding the structure of the
support hypergraph we distinguish two cases   i  no roles appear in a hypergraph   ii  for all xr  g 
it holds that r    
   

fie iter   f ink   s tepanova

first we consider  i   since only concepts appear in the support hypergraph by our assumption  all support sets will contain atoms in which only a single variable x  occurs  consider some
node xcn in  such that hdc   xcn     k  where k      i e   there are k outgoing hyperedges
from xcn containing nodes corresponding to concepts    xcn    xcn    xcn         xcnk  xcn    xcn  
 
k
 see figure      from support sets s   cn    x             cn k  x     we will get support sets s  
 cn   x             cnk  x     cn  x      estimating the maximal support set size as the number of hyperedges in the hypergraph  cn  x    is counted k times  but it appears only once  as its variable is
guaranteed to be x     to avoid such multiple countings  m   g  must be subtracted from n   g  
consider now  ii   by construction of g  for every hypernode  xr   xc     edges e   
 xa    xr   xc    and e      xr   xc    xb   exist in g  thus if xr occurs in   then consider a
support set s   b x    rewriting the tbox axiom reflected by e    we get a datalog rule
b x   r x  y    c y    then the axiom r c  a reflected by e  is rewritten to datalog rules
r x  oc    a x   c oc    a x   unifying y with oc we obtain an unfolding a x   this
essentially shows that if no role occurring in a support hypergraph is in   then all support sets
involve only a single variable  in this case  as shown in  i   the provided bound is correct 
c   proof of proposition   

the proof is by induction on the number n of  hyper  edges in g   gsupp d  t
  base  n    if g has
no  hyper  edges  each node has one support set 
induction step  suppose the statement holds for n  we show it holds for g with n      hyper 
edges  obviously  it holds for x  vr   as g is tree acyclic and t is in normal form  g has a
node x such that hd   x    d   x       i e   there are no outgoing  hyper  edges  and hd  x      
or d  x        i e   there is some incoming  hyper  edge  as g is tree acyclic  the rewriting of
the set qx    a x    where x   xa consists of qx and the rewritings of all sets qtail e  of
 hyper  nodes tail  e  such that head  e    x  if tail  e  is  xb    resp    xb   xc     xr   xc    these
are all rewritings of  b x    resp   b x   c x     r x  y    c y      that is  ws xa   is the
sum of the number of all rewritings of each qtail e  denoted qtail e    plus    consider now an
arbitrary e with head  e    xa and let g    g e  as g  has n edges and is tree acyclic  by the
induction hypothesis for each node x  v in g    the value of ws x   denoted wsg   x   is as in     
furthermore  ws qtail e    and ws x    x    xa is in g  the same as in g  we thus get for x   xa  

wsg  x    wsg   x    ws qtail e   
x y
wsg   x    
    
t t

    



 x 

x t

x

y

wsg  x    

x

y

wsg  x    

t t   x  x t

x

ws x     ws qtail e   

x

x

ws x     ws qtail e   



 x  t  vc   x   t  e 

t t    x  t  vc   x   t  e 

t t    x  x t

    

t t

x

x

x

ws x  

t t   x  t  vc   x   t  e



where t   x     t    t   x    e    and e    e    e   and t   x  is as above  to obtain
ws qtail  e    we simply need to count the combinations of the rewritings of each node in tail  e  
and in case tail  e     xr   xb    where ws xr         we need to add the number of rewritings of
the tail of each hyperedge  t   xr   xb     as t is in normal form  t must be of the form  xc    
   

fic omputing r epairs of i nconsistent dl p rograms over el o ntologies

c   proof of corollary   
this q
is immediate from proposition     under the hypothesis  in     each t is of form  y   vc  
thus x t ws x     ws y   i e   ws tail  e   and the rightmost term is   
c   proof sketch of proposition   
under the condition on e and e    e    every set t  t   x  in equation    
q such that  t     x  y     
contains  at least  one element  say x  such that ws x       and thus x t wsg  x   equals ws y 

  by an inductive argument  we then obtain that for every node xa  vc  
in g   gsupp d  t
ws xa      is the number of distinct edges in g that occur on incoming paths to xa and any
xb  vc such that an edge   xb     xr   xa    is in e  plus the number of all such edges  this in
turn implies that for the query node xq   ws xq      e      holds  as by construction each edge e  e
is among the respective edges for xq   from this the result follows immediately 

appendix d  proofs for section  
d   proof of theorem   
    we can get to  h  only if i is an answer set of   and
suppose supransset outputs i   i 
if the foundedness check of i w r t  the ontology t  a   where a   a h succeeded  it thus
remains to show that i is a compatible set for t  a   i e   that for each dl atom d in   d  dp


iff i   o d and d  dn iff i    o d  towards a contradiction  suppose that this is not the case  in
 d  we partitioned the dl atoms into two sets  dp and dn   corresponding to dl atoms d guessed

 respectively  and set sigr
 a   since we assume that i is not
to be true and false in i 
to gr s  i 
compatible  one of the following must hold 

    for some dl atom d in dn   we have i   o d  there are two possibilities   i  either there is

a support set s  sigr  d  or  ii  no support sets for d were identified  in case  i   we are guaranteed
that all support sets s for d are such that s  a      since otherwise no hitting sets h are found in
 e   hence there must exist some support set s such that s  a  
    according to  e  s  h    
and thus s   suppd  o    now as rep   true at  h   a post check of d must have succeeded in  g  

i e  i    o d must hold  this is a contradiction  in case  ii   likewise post evaluation of d must have
succeeded in  h   which again raises a contradiction 




    for some dl atom d in dp   we have i    o d  hence sigr  d      d   dp   and post evaluation
is performed for d in  g   the latter  however  must have succeeded  as rep   true at  h   this is a
contradiction  hence i is a compatible set for    and thus a deletion repair answer set of  
d   proof of theorem   
the following lemmas are useful to prove theorem    
lemma    let i  asx    where x   flp  weak   and    ht   a  pi is a ground dl program 
then i   i   ed   d  dl   i   t a d    ned   d  dl   i    t a d  is an answer set of  
where dl is the set of all dl atoms occurring in  
this lemma follows from a more general result on compatible sets as the basis of the evaluation
approach of hex programs in the dlvhex solver  cf   eiter et al       a   
   

fie iter   f ink   s tepanova

 
lemma    let    ht   a  pi be a ground dl program and let i  as    such that i   i 

asx     where x   flp  weak    suppose a  a is such that for each dl atom d occurring in p 

it holds that i   t a d iff i   t a d  then i  asx     where    ht   a   pi 
    pxi t a and pxi t a coincide  as i  asx     it is a minimal
proof  we note that for i   i 

model of pxi t a   consequently  i is also a model of pxi t a   moreover  i is minimal  as if some

j  i satisfies pxi t a   then j    pxi t a   hence i is not an answer set of pxi t a   a contradiction 

suppose i  ras x     this implies that i  asx     where    ht  a   pi  for some
 a  by lemma    i is an answer set of  and thus is considered in  c   in  d   dp and

dn are set to the  correct  guess for i   o d for each dl atom d  where o   t  a   from
 a   d      and
proposition    and  completeness of s  we obtain for each d  dp that gr s  i 


 a   d      as gr s  i 
 a   d   gr s  i 
 a  d  holds for each
for each d  dn that gr s  i 

i

dl atom d  it follows for each d  dn and s  sgr  d  that s   a   a        this means that
s

h    a   a is a hitting set of d dn sigr  d    and hence some minimal hitting set h  h  will

a



be considered in  e   in  f   dp will be set to dp as for each d  dp some s  sigr  d  exists
such that s  h      and hence s  h     thus in  g  the call eval p       yields true  and
 a   h  d      thus rep is true  eventually  in  h  the
likewise the call eval n       as gr s  i 

test flpfnd i  ht  a h  pi  will succeed  as i is an x answer set of    ht  a   pi  and by
  is output  
lemma    also of    ht  a   h  pi  as a  a   h  thus in step  h  i   i 
d   proof of proposition   
   ras weak     towards a contradiction 
we first show that for every i  as       it holds that i 


suppose some i  as      exists such that i    ras weak     then for every a  a we have
    as weak     with    ht   a   pi  in particular  for a   a  p   c    pp   c   i 
that i 
    as weak     with    ht   a   pi there are several possibilities   i  no
it holds that i 
c    ii  no such
  with a guess for the replacement atoms ed   ned is a model of 
extension of i 
   o
  is a compatible set for     iii  some interpretation j  i 
  is a model of p i 
 
extension of i 
weak

c and hence it follows that i 
c  
    
the case  i  is impossible     

   towards a contradiction  assume that
assume that  ii  is true  consider the interpretation i 

   or
    o d and ned  i 
it is not compatible for    then for some dl atom d either     i 



o
o
 holds  in case      as i 
    
d  and ed  i 
d  some support set s for d that is
    i    

 exists  now consider whether s  sd or s   sd   in the former case  s must
coherent with i 

contain abox assertions sda   as otherwise some constraint of the form  r    is violated  due to the
rule  r    at least one assertion pid in sda must be marked for deletion  note that then pid is not
present in a   and s is not a relevant support set for d w r t  a   if sd is known to be complete  then
we immediately arrive at a contradiction  otherwise  the rule of the form  r    is applied  and as the
evaluation postcheck for d succeeded by our assumption  we get a contradiction  if s   sd   then
sd is not known to be complete  and again the rule of the form  r    is applied  due to the successful
     o d  no
evaluation postcheck  a contradiction is obtained  now suppose that     is true  as i 
    if sd is known to be complete  then the
support set for d exists w r t  o that is coherent with i 
   

fic omputing r epairs of i nconsistent dl p rograms over el o ntologies

constraint  r    is violated  but this contradicts i        thus  the body of the rule  r    is satisfied 
and an evaluation postcheck is issued for d that fails  hence we get a contradiction 
   o
  is a model of p i 
finally  assume that  iii  holds  i e  some interpretation j  i 
weak   the
   j contains only atoms over the signature of   let us consider im   i   m  
set m   i 



we know that i  as       hence some rule ri must exist in   i such that im    b ri   
gl

gl

gl

i
but im    
recall that        r  f acts a   comp   now rgl can not be in
   o
   o
   o

i 
i  p i 
i  p i 

   f acts a   comp igl   as rgl
iff rgl
weak
weak and j     pweak by construction
i must be in ri   however  the
of the gl and weak reducts  which is a contradiction  therefore  rgl
gl

i
latter also raises a contradiction  no rule in rgl has atoms over the signature of  in its head and im

and i coincide on the rule head  thus it follows i     b rigl    which is a contradiction  therefore 
   as     holds  and we have a global contradiction  i e  i 
   ras weak    follows 
i 
i   
h rgl

we now consider the case where each support family sd is known to be complete  and prove
that then as         ras weak     from what has been shown above  it remains to check that
as        ras weak     towards a contradiction  assume some i  ras weak    exists such
that i 
  as      for every extension i of i  as i  ras weak     some abox a  a exists such
that i  as     with    ht   a   pi  we construct an extension i of i as follows 


i   i   ed   i   o d    ned   i    o d  

 pp   c    p   c   a a    f acts a   comp 
 supd   c    d  c  has some support set from sd coherent with i  
 s p   c    i    rb s a p   c      s a p   c    i    rb s a p   c    nd s a p   c    
d

d

d

d

since by our assumption i   as       one of the following must hold 

 i  i         r  f acts a   comp igl or

 ii  some j  i exists  such that j       r  f acts a   comp igl  

 it satisfies  and all rules of the forms  r    r   
first assume that  i  is true  by construction of i 
 
 
moreover  constraints of the form  r    can not be violated  as no dl atom d  c  with i    o d  c 
can have a support set that consists only of input assertions  the rules  r    and  r    are not present

in the reduct   igl   as i    cd for each dl atom d  c  

thus the rule r from   such that i     ri could only be of the form  r   or  r    in case of
gl



 

 

form  r     some dl atom d  c  would exist such that i    o d  c   by proposition    no support set
 hence  r must be of
for d  c  would exist that is coherent with i  and by construction sda p   c  
  i 

the form  r     however  as i   o d  c  by completeness of sd and proposition     by construction
 which implies that r can not be violated 
we have supd   c   i 

now let  ii  hold  i e  some j  i exists s t  j      igl   as j contains for each dl atom
d  c  exactly one out of ed   c  and ned   c  and   contains ed   c   ned   c   the interpretations j and
i coincide on all replacement atoms ed   c  and ned   c   suppose that i   j contains some atoms
      p i o   hence some rule ri o  p i o   exists such that
from the language of   then j 
weak
weak
weak
      h ri o    consider the respective rule ri in i   as j     h rj   
     b ri o    but j 
j 
gl
gl
gl
weak
weak
   

fie iter   f ink   s tepanova

i    by construction of the weak and gl reduct  respectively  the positive
we must have j     b rgl






j   and in b r i o   are the same  hence  some replacement atom e   
normal atoms in b rgl
d c   resp 
weak

i




ned   c   must occur positively in b rgl    such that ed   c   i   j  resp  ned   c   i   j   as we have
already argued  the latter is not possible  leading to a contradiction 
i of
consequently  i   j must contain only atoms from the language of r  for every rule rgl


form  r   or  r   we have j    b ri   iff i    b ri    thus i and j agree on all atoms s p   c  and
 
a p
sd   c  

 

gl

gl

d

similarly  via  r    and  r    we must have that i and j agree on all atoms supd   c   finally 
 in conclusion 
the same holds for all pp   c  and pp   c  by the rules  r    and the construction of i 


j   i holds  which violates  ii  
thus  it follows that i  as       consequently  as       ras weak      holds  this proves
the result 

references
alchourrn  c  e   grdenfors  p     makinson  d          on the logic of theory change  partial
meet contraction and revision functions  j  symbolic logic                
aranguren  m  e   bechhofer  s   lord  p  w   sattler  u     stevens  r  d          understanding
and using the meaning of statements in a bio ontology  recasting the gene ontology in owl 
bmc bioinformatics            
ausiello  g   datri  a     sacc  d          graph algorithms for functional dependency manipulation  j  of the acm                
ausiello  g   datri  a     sacc  d          minimal representation of directed hypergraphs  siam
j  on computing                
baader  f   bauer  a     lippmann  m          runtime verification using a temporal description
logic  in proc   th intl symp  on frontiers of combining systems  frocos       pp         
baader  f   brandt  s     lutz  c          pushing the el envelope  in proc    th intl joint conf 
on artificial intelligence  ijcai       pp         
baader  f   calvanese  d   mcguinness  d   nardi  d     patel schneider  p  f   eds            the
description logic handbook  theory  implementation and applications  cambridge university press       
baader  f   lutz  c   milicic  m   sattler  u     wolter  f          integrating description logics and
action formalisms  first results  in proc    th national conf  artificial intelligence and   th
conf  innovative applications of artificial intelligence  pp         
balduccini  m     gelfond  m          logic programs with consistency restoring rules  in intl
symp  logical formalization of commonsense reasoning  aaai      spring symposium series  pp      
belnap  n          a useful four valued logic  in modern uses of multiple valued logic  pp      
reidel publishing company  boston 
bertossi  l  e          database repairing and consistent query answering  morgan   claypool
publishers  ottawa  canada 
   

fic omputing r epairs of i nconsistent dl p rograms over el o ntologies

bertossi  l  e   hunter  a     schaub  t          introduction to inconsistency tolerance  in inconsistency tolerance  result from a dagstuhl seminar   pp      
bienvenu  m          complexity of abduction in the el family of lightweight description logics 
in proc    th intl conf  on principles of knowledge representation and reasoning  kr      
pp         
bienvenu  m     rosati  r          new inconsistency tolerant semantics for robust ontology based
data access  in proc    th intl workshop on description logics  pp       
bonatti  p  a   faella  m     sauro  l          el with default attributes and overriding  in proceedings of the  th intl semantic web conf   iswc       pp       
brewka  g          preferred subtheories  an extended logical framework for default reasoning  in
proc    th intl joint conf  on artificial intelligence  ijcai       pp           
calvanese  d   de giacomo  g   lembo  d   lenzerini  m   poggi  a     rosati  r       a  
ontology based database access  in proc    th italian symposium on advanced database
systems  sebd       pp         
calvanese  d   de giacomo  g   lenzerini  m   lembo  d   poggi  a     rosati  r       b  
mastro i  efficient integration of relational data through dl ontologies  in proc    th
intl workshop on description logics 
calvanese  d   ortiz  m   simkus  m     stefanoni  g          reasoning about explanations for
negative query answers in dl lite  j  artificial intelligence research             
console  l   sapino  m  l     dupr  d  t          the role of abduction in database view updating 
j  of intelligent information systems               
console  m   mora  j   rosati  r   santarelli  v     savo  d  f          effective computation of
maximal sound approximations of description logic ontologies  in proc    th intl semantic
web conf   iswc       part ii  pp         
dlliteplugin of dlvhex system         https   github com hexhex dlliteplugin 
scripts for dl program benchmark generation        
dlliteplugin benchmarks 

https   github com hexhex 

dlplugin of the dlvhex system         https   github com hexhex dlplugin 
dr e w reasoner for dl programs over datalog rewritable description logics         http   
www kr tuwien ac at research systems drew  
ecke  a   ludwig  m     walther  d          the concept difference for el terminologies using
hypergraphs  in proc  intl workshop on document changes  modeling  detection  storage
and visualization 
eiter  t   erdem  e   fink  m     senko  j          updating action domain descriptions  in proc 
  th intl joint conf  on artificial intelligence  ijcai       pp         
eiter  t   fink  m   greco  g     lembo  d          repair localization for query answering from
inconsistent databases  acm transactions on database systems        
eiter  t   fink  m   krennwallner  t   redl  c     schller  p       a   efficient hex program
evaluation based on unfounded sets  j  artificial intelligence research             
   

fie iter   f ink   s tepanova

eiter  t   fink  m   redl  c     stepanova  d       b   exploiting support sets for answer set
programs with external evaluations  in proc    th conf  artificial intelligence  aaai      
pp           
eiter  t   fink  m     stepanova  d          data repair of inconsistent dl programs  in proc    rd
intl joint conf  on artificial intelligence  ijcai       pp         
eiter  t   fink  m     stepanova  d       c   computing repairs for inconsistent dl programs over
el ontologies  in proc    th joint european conf  logics in artificial intelligence  jelia
      pp         
eiter  t   fink  m     stepanova  d       d   towards practical deletion repair of inconsistent
dl programs  in proc    st european conf  artificial intelligence  ecai       pp         
eiter  t   fink  m     stepanova  d       d   data repair of inconsistent dl programs  tech  rep 
infsys rr             institut f  informationssysteme  tu wien  a      vienna  austria 
eiter  t   gottlob  g     leone  n          abduction from logic programs  semantics and complexity  theoretical computer science                   
eiter  t   ianni  g   lukasiewicz  t   schindlauer  r     tompits  h          combining answer
set programming with description logics for the semantic web  j  artificial intelligence 
                     
eiter  t   ianni  g   schindlauer  r     tompits  h          a uniform integration of higher order
reasoning and external evaluations in answer set programming  in proc    th intl joint conf 
on artificial intelligence  ijcai       pp       
eiter  t     makino  k          on computing all abductive explanations from a propositional horn
theory  j  of the acm        
eiter  t   schneider  p   imkus  m     xiao  g          using openstreetmap data to create benchmarks for description logic reasoners  in proc   nd intl workshop on owl reasoner evaluation  ore       vol        pp       
experimental data with inconsistent dl programs         http   www kr tuwien ac at 
staff dasha jair el benchmark instances zip 
feng  s   ludwig  m     walther  d          the logical difference for el  from terminologies
towards tboxes  in proc   st intl workshop on sem  technologies  iwost       pp       
fink  m          paraconsistent hybrid theories  in proc    th intl conf  on principles of knowledge representation and reasoning  kr       pp         
frhstck  m   phrer  j     friedrich  g          debugging answer set programs with ouroboros extending the sealion plugin  in proc    th intl conf  logic programming and nonmonotonic
reasoning  lpnmr       pp         
gallo  g   longo  g     pallottino  s          directed hypergraphs and applications  discrete
applied mathematics                
grdenfors  p     rott  h          belief revision  handbook of logic in artificial intelligence and
logic programming           
gardiner  t   tsarkov  d     horrocks  i          framework for an automated comparison of
description logic reasoners  in proc   th intl semantic web conf   iswc       pp         
   

fic omputing r epairs of i nconsistent dl p rograms over el o ntologies

gebser  m   phrer  j   schaub  t     tompits  h          a meta programming technique for
debugging answer set programs  in proc    rd conf  artificial intelligence  aaai       pp 
       
gelfond  m     lifschitz  v          classical negation in logic programs and disjunctive databases 
new generation computing            
gottlob  g   pichler  r     wei  f          efficient datalog abduction through bounded treewidth 
in proc    nd intl conf  on artificial intelligence  aaai       pp           
grau  b  c   horrocks  i   kazakov  y     sattler  u          just the right amount  extracting
modules from ontologies  in proc    th intl conf  world wide web  www       pp     
    
hansen  p   lutz  c   seylan  i     wolter  f          query rewriting under el tboxes  efficient
algorithms  in proc    th intl workshop on description logics  pp         
hermann  m     pichler  r          counting complexity of propositional abduction  j  computer
and system sciences                
htcondor load distribution system  version               http   research cs wisc edu 
htcondor  
huang  s   hao  j     luo  d          incoherency problems in a combination of description logics
and rules  j  applied mathematics            
huang  s   li  q     hitzler  p          reasoning with inconsistencies in hybrid mknf knowledge
bases  logic j  of the igpl                
kaminski  t   knorr  m     leite  j          efficient paraconsistent reasoning with ontologies and
rules  in proc    th intl joint conf  on artificial intelligence  ijcai       pp           
knorr  m   alferes  j  j     hitzler  p          a coherent well founded model for hybrid mknf
knowledge bases  in proc    th european conf  on artificial intelligence  ecai       pp 
      
knorr  m   alferes  j  j     hitzler  p          local closed world reasoning with description logics
under the well founded semantics  artificial intelligence                      
konev  b   ludwig  m   walther  d     wolter  f          the logical difference for the lightweight
description logic el  j  artificial intelligence research             
kontchakov  r   lutz  c   toman  d   wolter  f     zakharyaschev  m          the combined
approach to query answering in dl lite  in proc    th intl conf  on principles of knowledge
representation  kr       pp         
kotek  t   simkus  m   veith  h     zuleger  f          towards a description logic for program
analysis  extending alcqio with reachability  in proc    th intl workshop on description
logics  pp         
lembo  d   lenzerini  m   rosati  r   ruzzi  m   savo  d  f          inconsistency tolerant query
answering in ontology based data access  j  web sem           
lembo  d   santarelli  v     savo  d  f          a graph based approach for classifying owl   ql
ontologies  in proc    th intl workshop on description logics  pp         
lubm benchmark         http   swat cse lehigh edu projects lubm  
   

fie iter   f ink   s tepanova

lubm data generator         http   code google com p combo obda  
ludwig  m     walther  d          the logical difference for elhr terminologies using hypergraphs  in proc    st european conf  artifical intelligence  ecai       pp         
lukasiewicz  t          a novel combination of answer set programming with description logics
for the semantic web  ieee trans  knowledge and data engineering                   
lutz  c   toman  d     wolter  f          conjunctive query answering in the description logic el
using a relational database system  in boutilier  c   ed    proc    st joint intl conf  artificial
intelligence  ijcai       pp           
lutz  c   walther  d     wolter  f          conservative extensions in expressive description logics 
in proc    th intl joint conf  artificial intelligence  ijcai       pp         
lutz  c     wolter  f          deciding inseparability and conservative extensions in the description
logic el  j  of symbolic computation                
martinez  m  v   molinaro  c   subrahmanian  v  s     amgoud  l          a general framework
for reasoning on inconsistency  springer briefs in computer science  springer       
masotti  g   rosati  r     ruzzi  m          practical abox cleaning in dl lite  progress report  
in proc  of description logics workshop 
motik  b     rosati  r          reconciling description logics and rules  j  of the acm        
    
myits   personalized intelligent mobility service         http   www kr tuwien ac at 
research projects myits geoconceptsmyits v    lite owl  
nguyen  n  t          advanced methods for inconsistent knowledge management  advanced
information and knowledge processing  springer 
nortje  r   britz  a     meyer  t          module theoretic properties of reachability modules for
sriq  in proc    th intl workshop on description logics  pp         
oetsch  j   phrer  j     tompits  h          stepwise debugging of description logic programs  in
j  of correct reasoning  pp         
open street map project         http   www openstreetmap org  
zccep    l     mller  r          combining dl  lite with spatial calculi for feasible geothematic query answering  in proc    th intl workshop on description logics 
pan  j  z     thomas  e          approximating owl dl ontologies  in proc    nd intl conf  on
artificial intelligence  aaai       pp           
prez urbina  h   motik  b     horrocks  i          tractable query answering and rewriting under
description logic constraints  j  of applied logic               
phrer  j   heymans  s     eiter  t          dealing with inconsistency when combining ontologies
and rules using dl programs   in proc   th extended semantic web conf   eswc       part
i  pp         
r acer p ro reasoner for owl ontologies         http   franz com agraph racer  
reiter  r          a theory of diagnosis from first principles  j  artificial intelligence              
   

fic omputing r epairs of i nconsistent dl p rograms over el o ntologies

rosati  r          on conjunctive query answering in el  in proceedings of the   th intl workshop
on description logics 
rosati  r   ruzzi  m   graziosi  m     masotti  g          evaluation of techniques for inconsistency handling in owl   ql ontologies  in proc    th intl semantic web conf   iswc      
pp         
sakama  c     inoue  k          paraconsistent stable semantics for extended disjunctive programs 
j  of logic and computation               
sakama  c     inoue  k          an abductive framework for computing knowledge base updates 
theory and practice of logic programming               
schulz  c   satoh  k     toni  f          characterising and explaining inconsistency in logic
programs  in proc    th intl conf   lpnmr       pp         
schulz  s   cornet  r     spackman  k  a          consolidating snomed cts ontological
commitment  applied ontology            
shen  y  d          well supported semantics for description logic programs  in proc    nd intl
joint conf  on artificial intelligence  ijcai       pp           
stefanoni  g   motik  b     horrocks  i          small datalog query rewritings for el  in proc 
  th intl workshop on description logics 
stepanova  d          inconsistencies in hybrid knowledge bases  phd thesis  vienna university
of technology 
steve  g   gangemi  a     mori  a  r          modelling a sharable medical concept system 
ontological foundation in galen  in aime  pp         
stuckenschmidt  h   parent  c     spaccapietra  s   eds            modular ontologies  concepts 
theories and techniques for knowledge modularization  vol       of lecture notes in computer science  springer 
syrjnen  t          debugging inconsistent answer set programs  in proc    th intl workshop
on nonmonotonic reasoning  nmr       pp       
thakur  m     tripathi  r          linear connectivity problems in directed hypergraphs  theoretical computer science                       
tserendorj  t   rudolph  s   krtzsch  m     hitzler  p          approximate owl reasoning with
screech  in proc   nd intl conf  web reasoning and rule systems  rr       pp         
wache  h   groot  p     stuckenschmidt  h          scalable instance retrieval for the semantic web
by approximation  in proc   st intl workshops on web information systems engineering 
wise       pp         
wang  y   you  j  h   yuan  l  y     shen  y  d          loop formulas for description logic
programs  theory and practice of logic programming                  
xiao  g          inline evaluation of hybrid knowledge bases  ph d  thesis  vienna university of
technology  austria 
zhao  y   pan  j  z     ren  y          implementing and evaluating a rule based approach to
querying regular el  ontologies  in proc   th intl conf  hybrid intelligent systems  his
      pp         

   

fi