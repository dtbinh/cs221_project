journal of artificial intelligence research               

submitted        published      

query and predicate emptiness in ontology based data access
franz baader

franz   baader   tu   dresden   de

tu dresden  germany

meghyn bienvenu

meghyn   lirmm   fr

cnrs  universite de montpellier
  inria  france

carsten lutz

clu   uni   bremen   de

university of bremen  germany

frank wolter

wolter   liverpool   ac   uk

department of computer science
university of liverpool  uk

abstract
in ontology based data access  obda   database querying is enriched with an ontology that
provides domain knowledge and additional vocabulary for query formulation  we identify query
emptiness and predicate emptiness as two central reasoning services in this context  query emptiness asks whether a given query has an empty answer over all databases formulated in a given
vocabulary  predicate emptiness is defined analogously  but quantifies universally over all queries
that contain a given predicate  in this paper  we determine the computational complexity of query
emptiness and predicate emptiness in the el  dl lite  and alc families of description logics 
investigate the connection to ontology modules  and perform a practical case study to evaluate the
new reasoning services 

   introduction
in recent years  the paradigm of ontology based data access  obda  has gained increased popularity  the general idea is to add an ontology to database querying to provide domain knowledge
and to enrich the vocabulary that is available for the formulation of queries  this is particularly
useful when the data to be queried is highly incomplete and when multiple data sources with diverging vocabularies are integrated  poggi  lembo  calvanese  de giacomo  lenzerini    rosati 
       obda has been taken up with particular verve in the area of description logic  dl  where it
has been studied intensively both for lightweight dls such as the members of the dl lite and el
families  which are tractable regarding the data complexity of querying  and for more expressive
dls such as those of the alc and shiq families where querying is intractable in data complexity  for the use in obda of the former  see for example the work of calvanese  de giacomo 
lembo  lenzerini  poggi  rodriguez muro  and rosati         lutz  toman  and wolter        
perez urbina  motik  and horrocks         chortaras  trivela  and stamou        and eiter  ortiz 
simkus  tran  and xiao         and the surveys by krotzsch        and kontchakov  rodriguezmuro  and zakharyaschev         for the latter  see the work of glimm  lutz  horrocks  and sattler
        ortiz  calvanese  and eiter         and bienvenu  ten cate  lutz  and wolter        as well
as the references given in the work of ortiz and simkus        
c
    
ai access foundation  all rights reserved 

fibaader   b ienvenu   l utz     w olter

the obda approach is fueled by the availability of ontologies that aim at providing a standard
vocabulary for the targeted application domain  in particular  there are now many such ontologies
in the bio medical domain such as snomed ct  ihtsdo         nci  golbeck  fragoso  hartel  hendler  oberthaler    parsia         and go  gene ontology consortium         which are
all formulated in a dl and allow a comparably inexpensive adoption of obda in bio medical applications such as querying electronic medical records  patel  cimino  dolby  fokoue  kalyanpur 
kershenbaum  ma  schonberg    srinivas         ontologies of this kind typically have a very
broad coverage and their vocabulary often contain tens or even hundreds of thousands of predicates
that embrace various subject areas such as anatomy  diseases  medication  and even social context
and geographic location  in any given application  only a small fragment of the ontologys vocabulary will actually occur in the data  still  the remaining predicates are potentially very useful for
formulating queries as they are linked to the data vocabulary by the ontologythis is precisely how
obda enriches the vocabulary available for query formulation 
due to the size and complexity of the involved ontologies and vocabularies  however  it can
be difficult to understand which of the additional predicates are useful for query formulation and
how to write meaningful queries in the extended vocabulary  static analysis tools for analyzing these
queries would thus be very useful  in this paper  we consider the fundamental static analysis problem
of query emptiness as well as a natural variation of it called predicate emptiness  in the former 
the problem is to decide whether a given query q provides an empty answer over all databases
formulated in a given data vocabulary   query emptiness thus helps to identify queries which are
useless due to wrong use of the ontology vocabulary  it is a standard static analysis problem in many
subareas of database theory such as xml  see e g  the work of benedikt  fan  and geerts       
and references therein 
as an example  consider the following simple ontology o 
diabetespatient  patient u has disease diabetes
diabetespatientwithoutmedication  patient u has disease diabetes u
on medication for diabetes
assume that o is used to support querying of a medical patient database which has a unary table
for the concept names patient and diabetes and binary tables for the role names has disease and
on medication for  distinguishing in particular between diabetes of type   and type    for example 
the database could be given by the following set a of assertions 
patient a  
has disease a  type   

patient b  

on medication for a  type   

diabetes type   

has disease b  type   

diabetes type   

thus  a is a patient with diabetes of type   who is on medication for it and b is a patient with
diabetes of type    in obda  queries are interpreted under an open world assumption and thus one
is interested in the certain answers to a query q w r t  o and a  that is  the answers to q on which
all extension of a that satisfy the ontology o are in agreement  for the concrete query
q   x    diabetespatient x  
a and b are the certain answers to q   x  w r t  o and adespite the fact that the predicate diabetespatient used in q   x  does not occur in a  since a is formulated using only the data vocabulary
    patient  has disease  on medication for  diabetes  
 

fiq uery and p redicate e mptiness

q uery evaluation

e mptiness

dl

iq

cq

iq query   cq predicate

cq query

el

pt ime c 

np c 

pt ime c 

pt ime c

el

pt ime c 

np c 

e xp t ime c 

e xp t ime c 

eli

e xp t ime c 

e xp t ime c 

e xp t ime c 

e xp t ime c 

horn alcif

e xp t ime c 

e xp t ime c 

e xp t ime c 

e xp t ime c 

nl og s pace c 

np c 

nl og s pace c 

conp c 

pt ime c 

np c 

conp c 

conp c 

alc

e xp t ime c 

e xp t ime c 

ne xp t ime c 

ne xp t ime c 

alci

e xp t ime c 

 e xp t ime c 

ne xp t ime c 

 e xp t ime c 

alcf

e xp t ime c 

e xp t ime c 

undecidable

undecidable

dl litecore f  r
dl litehorn

figure    known complexity results for query evaluation and new complexity results for emptiness

we say that q   x  is non empty for  given o  we regard this as evidence that q   x  is a potentially
useful query on databases formulated in vocabulary   as another example  consider the query
q   x    diabetespatientwithoutmedication x 
there is no certain answer to q   x  w r t  o and a since  under the open world assumption  the mere
absence of the information that b is on medication for diabetes of type   or type   does not imply
that its negation is true  one can even show that  whatever database a  formulated in vocabulary 
we use  there will never be any certain answer to q   x  w r t  o and a    in this case  we say that
q   x  is empty for  given o  in contrast to q   x   this query is thus useless on  databases 
we also consider predicate emptiness  the problem to decide whether for a given predicate p
and data vocabulary   it is the case that all queries q which involve p yield an empty answer over
all  databases  in the example above  the predicate diabetespatientwithoutmedication is empty
w r t  o and  for the important class of conjunctive queries  queries constructed from atomic formulas using conjunction and existential quantification   predicate emptiness can be used to identify
predicates in the ontology that are useless for query formulation  before even starting to construct
a concrete query  in a graphical user interface  for example  such predicates would not be offered
to users for query formulation  our notion of predicate emptiness is loosely related to predicate
emptiness in datalog queries as studied e g  by vardi        and levy        
the aim of this paper is to perform a detailed study of query emptiness and predicate emptiness
for various dls including members of the el  dl lite  and alc families  concentrating on the
two most common query languages in dl based obda  instance queries  iqs  and conjunctive
queries  cqs   for all of the resulting combinations of dls and query languages  we determine the
 un decidability and exact computational complexity of query emptiness and predicate emptiness 
our results are summarized on the right side of figure   and range from pt ime for basic members
of the el and dl lite families via ne xp t ime for basic members of the alc family to undecidable for alc extended with functional roles  alcf   we adopt the standard notion of combined
 

fibaader   b ienvenu   l utz     w olter

complexity  which is measured in terms of the size of the whole input  tbox  data vocabulary  and
query or predicate symbol  
because of the restricted data vocabulary  and the quantification over all  databases in their
definition  query emptiness and predicate emptiness do not reduce to standard reasoning problems
such as query evaluation and query containment  formally  this is demonstrated by our undecidability result for alcf  which should be contrasted with the decidability of query entailment and
containment in this dl  as shown by calvanese  de giacomo  and lenzerini         when emptiness is decidable  the complexity still often differs from that of query evaluation  to simplify the
comparison  we display in figure   known complexity results for query evaluation in the considered dls  please consult the work of baader  brandt  and lutz               krotzsch  rudolph 
and hitzler         and eiter  gottlob  ortiz  and simkus        for the results concerning el and
its horn extensions  the work of calvanese  de giacomo  lembo  lenzerini  and rosati        and
artale  calvanese  kontchakov  and zakharyaschev        for the results on dl lite  and the work
of tobies         hustadt  motik  and sattler         lutz         and ortiz  simkus  and eiter
       for the results on dls from the alc family  by comparing the two sides of figure    we
observe that there is no clear relationship between the complexity of emptiness checking and the
complexity of query evaluation  indeed  while the problems are often of similar complexity  there
are several cases in which emptiness checking is more difficult than the corresponding query evaluation problem  it can also be the other way around  and complexities can also be incomparable  note
that for the extension el of el with the bottom concept   used to express class disjointness   we
observe a particularly significant difference between the tractability of evaluating instance queries
and the e xp t ime completeness of checking iq query emptiness 
a key ingredient in developing algorithms and establishing upper complexity bounds for emptiness is to show that  when searching for databases that witness non emptiness  such as the database
a for the non emptiness of q  for  given o in the above example   one can often focus on a single
database constructed specifically for that purpose or on a class of databases that are easier to handle
than the class of all databases  which single database   class of databases to consider depends on the
dl in question  for this reason  a secondary theme of this paper is to analyze the shape of witness
databases  it turns out that in alc and its extension alci with inverse roles  we can consider a
single exponential size database whose construction is reminiscent of type elimination and filtration
constructions known from the modal logic literature  for el and its extension eli  we may also
concentrate on a single witness candidate  but a much simpler one  it consists of all facts that can
be constructed using the data vocabulary and a single constant  for other extensions of el  we
use a class of databases as witness candidates  namely those that have a tree or forest structure  in
dl lite  we may restrict our attention to the class of databases whose size is bounded polynomially
w r t  the input query and ontology 
to demonstrate that predicate emptiness is a useful reasoning service for static analysis  we
perform experiments using the well known and large scale medical ontology snomed ct coupled
with both a real world data vocabulary  corresponding to terms obtained by analyzing clinical notes
from a hospital  and with randomly generated vocabularies  for the real world vocabulary  which
contains       of the         concept names and    of the    role names in snomed ct 
       predicates turned out to be non empty for iqs and        to be non empty for cqs  thus 
snomed ct provides a very substantial number of additional predicates for query formulation
while a large number of other predicates cannot meaningfully be used in queries over  databases 
thus  identifying the relevant predicates via predicate emptiness is potentially very helpful 
 

fiq uery and p redicate e mptiness

we also consider the use of query and predicate emptiness for the extraction of modules from
an ontology  thus  instead of using emptiness directly to support query formulation  we show how
it can be used to simplify an ontology  a  substitute of an ontology is a subset of the ontology
that gives the same certain answers to all conjunctive queries over all  databases  replacing a
large ontology with a  potentially quite small   substitute supports comprehension of the ontology
and thereby the formulation of meaningful queries  we show that  for eli  one can use predicate emptiness to extract a particularly natural  substitute of an ontology  called its cq  core 
containing exactly those axioms from the original ontology that contain only predicates which are
non empty for  databases  thus  all predicates in the cq  core of an ontology can be meaningfully used in queries posed to  databases  in our example  the cq  core of the ontology o is
o     diabetespatient  patient u has disease diabetes  
the second axiom was removed because any cq that contains diabetespatientwithoutmedication
is empty for  given o  to analyze the practical interest of cq  cores  we carry out a case study
where we compute cq  cores for the ontology snomed ct coupled with various signatures 
showing that they tend to be drastically smaller than the original ontology and also smaller than
 modules  a popular way of extracting modules from ontologies  grau  horrocks  kazakov   
sattler        
this article is structured as follows  we begin in section   by recalling the syntax and semantics of the description logics considered in this work  in section    we introduce four notions of
emptiness  iq query  iq predicate  cq predicate  and cq query  and investigate the formal relationships between them  we first observe that iq query and iq predicate emptiness coincide
 so there are only three problems to consider  and that cq predicate emptiness corresponds to cqquery emptiness where cqs are restricted to a very simple form  we also exhibit two polynomial
reductions between predicate and query emptiness  for all dls considered in this paper except those
from the dl lite family  cq predicate emptiness is polynomially reducible to iq query emptiness  and for all horn dls considered in this paper  iq query emptiness is polynomially reducible
to cq predicate emptiness 
in section    we investigate the computational complexity and decidability of query and predicate emptiness in the alc family of expressive dls  for alc and alci  we provide tight
complexity bounds  showing ne xp t ime completeness for all three emptiness problems in alc
and for iq query emptiness and cq predicate emptiness in alci  and  e xp t ime completeness
for cq query emptiness in alci  the situation is dramatically  and surprisingly  different for
alcf  for which all emptiness problems are proven undecidable  as previously mentioned  the
complexity upper bounds for alc and alci rely on a characterization of non emptiness in terms
of a special witness database  the complexity lower bounds and undecidability results are proven
by means of reductions from tiling problems 
in section    we continue our investigation of query and predicate emptiness by considering
the dl el and its horn extensions  for plain el  we provide a simple characterization of nonemptiness in terms of a maximal singleton database  which allows us to show that all three emptiness
problems can be decided in polynomial time  using the same characterization and the fact that
standard reasoning in eli is e xp t ime complete  we obtain e xp t ime completeness of emptiness
checking in eli  for extensions of el that allow for contradictions  the singleton database may not
be consistent with the ontology  requiring another approach  to handle such extensions  we show
 

fibaader   b ienvenu   l utz     w olter

that it is sufficient to consider tree shaped databases as witnesses for non emptiness  and we devise
a decision procedure for emptiness checking based upon tree automata  we obtain in this manner an
e xp t ime upper bound for horn alcif  which sharply contrasts with our undecidability result
for  non horn  alcf  interestingly  we can show a matching e xp t ime lower bound for the
considerably simpler dl el   for which standard reasoning tasks are tractable 
in section    we turn our attention to the dl lite family of lightweight dls  which are the most
commonly considered dls for ontology based data access  we show that cq query emptiness is
conp complete for all considered dl lite dialects  for iq query emptiness and cq predicate
emptiness  we show that the complexity depends on whether the considered dialect allows for conjunctions on the left hand side of axioms  for standard dialects like dl litecore   dl liter   and
dl litef   which do not allow for conjunction  we show that iq query emptiness and cq predicate
emptiness are nl og s pace complete  for dialects like dl litehorn that admits conjunctions  both
iq query emptiness and cq predicate emptiness are conp complete  this difference in complexity is due to the fact that for dialects allowing conjunction  we need to consider witnesses for nonemptiness that are of polynomial size  whereas in the absence of conjunction  it is sufficient to
consider databases that consist of a single assertion 
in section    we apply query and predicate emptiness to extract modules of an ontology  we
introduce the notion of a  substitute and of a cq  core of an ontology and show that for eli the
cq  core of an ontology is a  substitute  we also relate  substitutes to other notions of module
proposed in the literature  in particular  we observe that semantic and syntactic  modules  grau
et al         are examples of  substitutes  and thus  algorithms for computing such modules can
also be used to compute  possibly non minimal   substitutes  we then demonstrate the potential
utility of  substitutes and emptiness checking by experiments based on snomed ct 
finally  in sections   and    we conclude the paper by discussing related and future work  please
note that to improve the readability of the text  some technical proofs are deferred to the appendix 

   preliminaries
in dls  concepts are inductively defined with the help of a set of constructors  starting with countably infinite sets nc of concept names and nr of role names  the constructors that are most important in this paper are summarized in figure    an inverse role has the form r with r a role name
and a role is a role name or an inverse role  for uniformity  we define double inverse to be identity 
that is   r      r for all role names r  throughout the paper  we use a  b to denote concept
names  c  d to denote  possibly compound  concepts  and r and s to denote roles 
we shall be concerned with a variety of different dls that are all well known from the literature 
the least expressive ones are el and dl lite  which are the logical underpinnings of the owl 
profiles owl  el and owl  ql  respectively  motik  grau  horrocks  wu  fokoue    lutz 
       in el  concepts are constructed according to the following grammar using the constructors
top concept  conjunction  and existential restriction 
c  d

   

 

 

a

  c ud

 

r c

with a ranging over concept names and r over role names  dl lite concepts and tboxes will be
introduced in section    the basic expressive dl we consider in this paper is alc which is the
extension of el with the constructors bottom concept  negation  disjunction and value restriction 
c  d

   

 

 



  a

  c ud
 

 

c td

 

r c

 

r c

fiq uery and p redicate e mptiness

name

syntax

concept name
role name

a
r

semantics
ai
ri

top concept
bottom concept
negation
conjunction
disjunction
existential restriction
value restriction
role inverse

 

c
c ud
c td
r c
r c
r

 i   i
i   
i   c i
c i  di
c i  di
 d  i   e  c i with  d  e   ri  
 d  i   e  i    d  e   ri  e  c i  
  d  e     e  d   ri  

concept inclusion
concept assertion
role assertion

cvd
a a 
r a  b 

c i  di
ai  ai
 ai   bi    ri

figure    syntax and semantics of dl constructors  tbox axioms  and abox assertions 

the availability of additional constructors is indicated by concatenation of letters or subscripts  the
letter i stands for the addition of inverse roles  inside existential and value restrictions  if present 
and the subscript  stands for adding   this gives  for example  the extension alci of alc
with inverse roles  whose constructors are exactly the ones shown in figure    it also defines the
extension eli  of el with inverse roles in existential restrictions and the bottom concept 
a concept inclusion  ci  in a dl l takes the form c v d  where c and d are l concepts 
we use c  d as an abbreviation for the cis c v d and d v c  in description logic  ontologies
are formalized as tboxes  given any of the dls l introduced above  an l tbox is a finite set of
cis in l  we use the letter f and write lf to denote the description logic in which tboxes consist
not only of cis in l  but also of functionality statements funct r   where r is a role name or an
inverse role  if inverse roles are admitted in l   for example  alcf is thus the extension of alc
in which tboxes can contain cis in alc and functionality statements for role names  we use the
term axioms to refer to concept inclusions and functionality statements in a uniform way 
in addition to the dls introduced above  we also consider some dls that impose restrictions
on which constructors can be used on which side of concept inclusions  a horn alci concept
inclusion  ci  is of the form l v r  where l and r are concepts defined by the syntax rules
r  r             a   a   r u r    l t r   r r   r r
l  l             a   l u l    l t l    r l
with a ranging over concept names and r over  potentially inverse  roles  a horn alcif tbox
t is a finite set of horn alci cis and functionality statements funct r   note that different
definitions of horn dls can be found in the work of hustadt  motik  and sattler         eiter et al 
        and kazakov         as the original definition by hustadt  motik  and sattler based on
polarity is rather technical  we prefer the above  equivalent  definition 
the size  t   of a tbox t is obtained by taking the sum of the lengths of its axioms  where the
length of an axiom is the number of symbols needed to write it as a word 
 

fibaader   b ienvenu   l utz     w olter

databases are represented using an abox  which is a finite set of concept assertions a a  and
role assertions r a  b   where a  b are drawn from a countably infinite set ni of individual names 
a is a concept name  and r is a role name  note that role assertions cannot use inverse roles  as
a shortcut  though  we sometimes write r  a  b   a for r b  a   a  we use ind a  to denote
the set of individual names used in the abox a  a knowledge base is a pair k    t   a  with t a
tbox and a an abox 
the semantics of description logics is defined in terms of an interpretation i    i   i    the
domain i is a non empty set and the interpretation function i maps each concept name a  nc
to a subset ai of i   each role name r  nr to a binary relation ri on i   and each individual
name a to an element ai  i   the extension of i to compound concepts is inductively defined
as shown in the third column of figure    an interpretation i satisfies  i  a ci c v d if c i  di  
a statement funct r  if ri is functional   iii  an assertion a a  if ai  ai   and  vi  an assertion
r a  b  if  ai   bi    ri   then  i is a model of a tbox t if it satisfies all axioms in t   and a model
of an abox a if it satisfies all assertions in a  a tbox is satisfiable if it has a model and an abox
a is satisfiable w r t  a tbox t if t and a have a common model  we write t    c v d if all
models of t satisfy the ci c v d 
we consider two types of queries  first  instance queries  iqs  take the form a v   where a is a
concept name and v an individual variable taken from a set nv   note that instance queries can only
be used to query concept names  but not role names  this is the traditional definition  which is due
to the fact that role assertions can only be implied by an abox if they are explicitly contained in it 
and thus querying is trivial   the more general conjunctive queries  cqs  take the form  u   v    u 
where  is a conjunction of atoms of the form a v  and r v  v     with v  v   individual variables from
 v   u  nv   variables that are not existentially quantified are called answer variables  and the
arity of q is defined as the number of its answer variables  queries of arity   are called boolean 
we use var q   avar q   and qvar q  to denote the set of variables  answer variables  and quantified
variables respectively in the query q  from now on  we use iq to refer to the set of all iqs and cq
to refer to the set of all cqs 
let i be an interpretation and q an  instance or conjunctive  query q of arity k with answer
variables v            vk   a match of q in i is a mapping    var q   i such that  v   ai for
all a v   q    v    v       ri for all r v  v      q  and for every answer variable v  var q  
there is an individual name a with  v    ai   we write i    q a            ak   if there is a match
 of q in i such that  vi     aii for every    i  k  for a knowledge base  t   a   we write
t   a    q a            ak   if i    q a            ak   for all models i of t and a  in this case   a            ak  
is a certain answer to q w r t  t and a  we use certt  a  q  to denote the set of all certain answers
to q w r t  t and a  note that when q is a boolean query  we have     certt  a  q  if there is a
match for q in every model of t   a  and otherwise certt  a  q      the query evaluation problem
for cqs for a dl l is the problem to decide for an l tbox t   abox a  cq q of arity k  and tuple
 a  ind a k   whether  a  certt  a  q  
we use the term predicate to refer to a concept name or role name and signature to refer to a
set of predicates  in the introduction  we informally called a signature a vocabulary   then sig q 
denotes the set of predicates used in the query q  and similarly sig t   and sig a  refer to the
signature of a tbox t and abox a  a  abox is an abox that uses only predicates from the
signature   and likewise for a  concept 
   this is no longer true in the presence of role hierarchy statements which  however  we do not consider in this paper 

 

fiq uery and p redicate e mptiness

in the context of query answering in dls  it is sometimes useful to adopt the unique name
assumption  una   which requires that ai    bi for all interpretations i and all a  b  ni with
a    b  the results obtained in this paper do not depend on the una  the following well known
lemma shows that the una does not make a difference in alci  and all its fragments such as el
and alc  because the certain answers to queries do not change 
lemma   let t be an alci tbox  a an abox  and q  cq  then certt  a  q  is identical with
and without the una 
an analogous statement fails for alcf  e g  because the abox a    f  a  b   f  a  b     is satisfiable w r t  the tbox t    funct r   without the una  and thus certt  a  a v        but
unsatisfiable with the una  and thus certt  a  a v     ind a   

   query and predicate emptiness
we introduce the central notions and reasoning problems studied in this paper  show how they are
interrelated  and make some basic observations that are used throughout the paper  the following
definition introduces the different notions of emptiness studied in this paper 
definition   let t be a tbox   a signature  and q   iq  cq  a query language  then we call
 an q query q empty for  given t if for all  aboxes a that are satisfiable w r t  t   we have
certt  a  q     
 a predicate s q empty for  given t if every q query q with s  sig q  is empty for 
given t  
in what follows  the signatures  used in aboxes will be called abox signatures  we quantify over
all aboxes that are formulated in the abox signature to address typical database applications in
which the data changes frequently  and thus deciding emptiness based on a concrete abox is not of
much interest  as an example  assume that aboxes are formulated in the signature
    person  hasdisease  diseasea  diseaseb 
where here and in the following  all upper case words are concept names and all lower case ones
are role names  this signature is typically fixed in the application design phase  similar to schema
design in databases  for the tbox  we take
t    person v hasfather  person u male   diseasea v infectiousdisease  
then both the iq infectiousdisease v  and the cq v hasfather u  v  are non empty for  given t
despite using predicates that cannot occur in the data  as witnessed by the  aboxes  diseasea a  
and  person a    respectively  this illustrates how the tbox t enriches the vocabulary that is
available for query formulation  by contrast  the cq
vv    hasfather u  v   hasdisease v  v      infectiousdisease v      
which uses the same predicates plus an additional one from the abox signature  is empty for 
given t  
 

fibaader   b ienvenu   l utz     w olter

regarding predicate emptiness  it is interesting to observe that the choice of the query language
is important  for example  the predicate male is iq empty for  given t   but not cq empty as
witnessed by the  abox  person a   and the cq v male v   it thus makes no sense to use male
in instance queries over  aboxes given t   whereas it can be meaningfully used in conjunctive
queries 
as every iq is also a cq  a predicate that is cq empty must also be iq empty  as illustrated
by the above example  the converse does not hold  also note that all role names are iq empty for 
given any t since a role name cannot occur in an instance query  by contrast  hasfather is clearly
not cq empty in the above example 
it follows from lemma   that  in alci and its fragments  query emptiness and predicate emptiness are oblivious as to whether or not the una is made  both for iq and cq  as established by the
following lemma  this is also true in alcif despite the fact that the certain answers to queries
can differ with and without the una 
lemma   let t be an alcif tbox  then each cq q is empty for  given t with the una iff it
is empty for  given t without the una 
the proof of lemma   is given in the appendix  for the direction from left to right one assumes
that q is non empty for  given t without the una and takes a witness  abox a  using a model
i satisfying a and t without the una and by identifying any a  b  ind a  with ai   bi one
can define a  abox a  from a that shows that q is non empty for  given t with the una 
conversely  one assumes that q is non empty for  given t with the una and takes a witness
 abox a  one can use a to show that q is non empty for  given t without the una 
with the exception of a dl lite dialect  containing role inclusions  all dls considered in this
paper are fragments of alcif  thus  we are free to adopt the una or not  in the remainder of
the paper  we will choose whatever is more convenient  but be careful to always point out explicitly
whether the una is made or not  for the dl lite dialect not covered by the formulation of lemma  
we will observe in our discussion of dl lite that even lemma   holds and so we are free to adopt
the una or not in that case as well 
it is also relevant to note that our decision to disallow individual names in query atoms is without
any loss of generality  indeed  it is easily verified that predicate emptiness is the same whether we
admit individuals in queries or not  moreover  there is an immediate reduction of query emptiness
for generalized cqs  which may contain individual names  to query emptiness for cqs as defined
in this paper  it suffices to replace every individual a in the query by a fresh answer variable xa   and
then test whether the resulting query  without individuals  is empty for  given t  
definition   gives rise to four natural decision problems 
definition   let q   iq  cq   then
 q query emptiness is the problem of deciding  given a tbox t   a signature   and an qquery q  whether q is empty for  given t  
 q predicate emptiness means to decide  given a tbox t   a signature   and a predicate s 
whether s is q empty for  given t  
  

fiq uery and p redicate e mptiness

iq query   iq predicate
emptiness
emptiness
trivial

cq query
emptiness

theorem  
 materializable dls 

lemma  

theorem  

cq predicate
emptiness

figure    polytime reductions between emptiness notions 
clearly  these four problems are intimately related  in particular  iq query emptiness and iqpredicate emptiness are effectively the same problem since an instance query consists only of a
single predicate  for this reason  we will from now on disregard iq predicate emptiness and only
speak of iq query emptiness  in the cq case  things are different  indeed  the following lemma
shows that cq predicate emptiness corresponds to cq query emptiness where cqs are restricted to
a very simple form  it is an easy consequence of the fact that  since composite concepts in queries
are disallowed  cqs are purely positive  existential  and conjunctive 
lemma   a  nc  resp  r  nr   is cq predicate empty for  given t iff the conjunctive query
v a v   resp  vv   r v  v      is empty for  given t  
lemma   allows us to consider only queries of the form v a v  and vv   r v  v     when dealing
with cq predicate emptiness  from now on  we do this without further notice 
trivially  iq query emptiness is a special case of cq query emptiness  the following observation is less obvious and applies to all dls considered in this paper except those from the dl lite
family 
theorem   in any dl contained in alcif that admits cis r b v b and r   v b with b a
concept name  cq predicate emptiness can be polynomially reduced to iq query emptiness 
proof  let t be a tbox   a signature  b a concept name that does not occur in t and   and s a
role name that does not occur in t and   we prove that
   a is cq predicate empty for  given t iff the iq b v  is empty for    s  given the tbox
t     t  tb   a v b   where tb    r b v b   r   s or r occurs in t   
   r is cq predicate empty for  given t iff the iq b v  is empty for    s  given the tbox
t     t  tb   r   v b   where tb is as above 
the proofs of points   and   are similar  and we concentrate on point    first suppose that a is cqpredicate non empty for  given t   then there is a  abox a such that t   a    v a v   choose
an a   ind a  and set a     a   s a    b    b  ind a    using the fact that t   a    v a v 
and the definition of a  and t     it can be shown that t     a     b a     for the converse direction 
suppose that b is iq query non empty for  s  given t     then there is a  s  abox a  such
that t     a     b a  for some a  ind a     let a be obtained from a  by removing all assertions
s a  b   using the fact that t     a     b a  and the definition of a  and t     it can be shown that
t   a    v a v  
o

  

fibaader   b ienvenu   l utz     w olter

figure   gives an overview of the available polytime reductions between our four  rather  three 
problems  in terms of computational complexity  cq query emptiness is thus  potentially  the hardest problem  while cq predicate emptiness is the simplest  more precisely  if cq query emptiness
in a dl l belongs to a complexity class c  larger than or equal to pt ime   then iq query emptiness
and cq predicate emptiness in l are also in c  moreover  for dls l satisfying the conditions of
theorem    c hardness of cq predicate emptiness in l implies c hardness of cq query emptiness
and iq query emptiness in l 
under certain conditions  we can also prove the converse of theorem    following the work of
lutz and wolter         we call a model i of a tbox t and an abox a a materialization of t
and a if for every cq q of arity k and tuple  a  ind a k   i    q  a  iff t   a    q  a   a dl l is
called materializable if for every abox a that is satisfiable w r t  t there exists a materialization
of t and a  typical dl lite dialects  the dl el  and horn extensions of el such as elif  are
materializable  lutz   wolter        
theorem   let l be a materializable dl that admits cis of the form a  u a  v a    where
a    a    a   nc   then  in l  iq query emptiness can be polynomially reduced to cq predicate
emptiness 
proof  we claim that the iq a v  is empty for  given t iff b is cq empty for    x  given the
tbox t     t   a u x v b   where b and x are concept names that do not occur in t  
for the if direction  assume that a v  is iq non empty for  given t   and let a be a abox such that t   a    a a  for some a  ind a   set a     a   x a    it is easy to see that
t     a     v b v  and thus b is cq predicate non empty for    x  given t    
for the only if direction  assume that b is cq non empty for    x  given t     and let a 
be a    x  abox which is satisfiable with t   and such that t     a     v b v   we may assume
that x a   a  for all a  ind a    as adding these assertions can neither result in unsatisfiability
w r t  t   nor invalidate t     a     v b v   by our assumption of materializability  there exists a
materialization i   of t   and a  and we have i      v b v   by definition of t     we may assume
 
 
 
 
that x i   ind a    and b i   ai  x i  if this is not the case  we can take a modified version 
  
  
 
 
  
 
i      of i   that is defined by setting x i    ind a     b i    ai  x i   and y i    y i for all
 
remaining concept and role names y   then i    still satisfies t   and a  since x i  ind a    and
  
 
a u x v b is the only inclusion containing x or b and it is still a materialization since y i  y i
for all concept and role names y    but then i      v b v  implies that there is an a  ind a    with
i      b a   since i   is a materialization of t   and a    this implies t     a     b a   by definition of
t     this implies t   a    a a   where a is obtained from a  by dropping all assertions of the form
x b   since a is a  abox and satisfiable w r t  t  since a  is satisfiable w r t  t      it witnesses
that a v  is non empty for  given t  
o
as a final observation in this section  we note that deciding query and predicate emptiness is
essentially just abox satisfiability whenever  contains all symbols used in the tbox  by the
described reductions  it suffices to consider cq query emptiness  for a cq q    u   v    u  we
associate with every individual variable v in q an individual name av and set
aq    a av     a v  is a conjunct in     r av   av      r v  v     is a conjunct in   
theorem   let t be an alcif tbox   a signature with sig t      and q a cq  then q is
empty for  given t iff sig q     or aq is unsatisfiable w r t  t  
  

fiq uery and p redicate e mptiness

proof   if  assume that q is non empty for  given t   then there is a  abox a that is
satisfiable w r t  t and such that certt  a  q       this clearly implies sig q    since otherwise
there is a predicate in sig q     and we can find a model of t and a in which this predicate is
interpreted as the empty set  which would mean certt  a  q      it thus remains to show that aq is
satisfiable w r t  t   to this end  let i be a model of t and a  since certt  a  q       there exists a
match  of q in i  modify i by setting aiv    v  for all variables v used in q  it is readily checked
that the modified i is a model of aq and t   thus aq is satisfiable w r t  t as required 
 only if  assume that sig q    and aq is satisfiable w r t  t   then sig aq      since
clearly certt  aq  q       this means that q is non empty for  given t  
o

   expressive description logics
we consider query and predicate emptiness in the alc family of expressive dls  establishing tight
complexity results for alc and alci  and undecidability for alcf  we start with upper bound
proofs  showing that iq query emptiness and cq predicate emptiness in alci are in ne xp t ime  and so is cq query emptiness in alc  moreover  we establish that cq query emptiness
is in  e xp t ime  we then move on to the corresponding lower bound proofs and also establish
undecidability of all considered emptiness problems in alcf 
    upper bounds
the first main step in our proofs is to show that  when deciding emptiness problems in alc or
alci  it suffices to consider a single special  abox  specifically  we show how to construct
from a given satisfiable tbox t and abox signature  the canonical  abox at   such that for
every cq q  we have certt  at    q      if and only if there exists a  abox a that is satisfiable
w r t  t such that certt  a  q       we then prove ne xp t ime upper bounds for iq query emptiness in alci by computing at    in exponential time  and then guessing a model of at    of
exponential size in  t   and   that falsifies the query  an  e xp t ime upper bound for cq query
emptiness in alci is obtained in an even simpler way by computing at   and then checking
whether certt  at    q     using known algorithms  significantly more work is required to obtain
a ne xp t ime upper bound for cq query emptiness in alc  we again construct at     but need to
exercise a lot of care to check whether certt  at    q     without leaving ne xp t ime 
let t be a satisfiable alci tbox and  an abox signature  to define the canonical  abox
for t   we introduce the well known notion of types  or hintikka sets   pratt        kaminski 
schneider    smolka         the closure cl t     of t and  is the smallest set that contains
  nc as well as all concepts that occur  potentially as a subconcept  in t and is closed under
single negations  a type for t and  is a set t  cl t     such that for some model i of t and
some d  i   we have t   ti  d   where ti  d     c  cl t       d  c i   is the type for t
and  realized by d in i  let tt   denote the set of all types for t and   for a role name r and
t  t   tt     we say that the pair  t  t    is r coherent and write t  r t  if
 c  t  whenever r c  t  and
 c  t whenever r  c  t   
it can be seen that the above implies also corresponding conditions on existential restrictions  such
as c  t  and r c  cl c  t   implies r c  t 
  

fibaader   b ienvenu   l utz     w olter

definition    canonical  abox  let t be a satisfiable alci tbox and  an abox signature 
fix a  distinct  individual name at for each t  tt     the canonical  abox at   for t is defined
as follows 
at      a at     a  t and t  tt     a    nc   
 r at   at      t  r t  and t  t   tt     r    nr   
the cardinality of tt   is at most exponential in the size of t and the cardinality of   and the
set tt   can be computed in exponential time by making use of well known e xp t ime procedures
for concept satisfiability w r t  tboxes in alci  gabbay  kurucz  wolter    zakharyaschev       
p      thus  at   is of exponential size and can be computed in exponential time  it is interesting
to note that the abox at   is a finitary version of the canonical model for basic modal logic and is
essentially identical to the model constructed by pratts type elimination procedure  pratt         in
fact  it is exactly identical when   sig t    we now show that at   is satisfiable w r t  t  
lemma    let t be a satisfiable alci tbox and  an abox signature  then at   is satisfiable
w r t  t  
proof  let the interpretation it   be defined by setting
it  

  tt  

ait  

   t  tt     a  t 

rit  

    t  t     tt    tt     t  r t   

for all a  nc and r  nr   one can prove by induction on the structure of c that for all c 
cl t      we have c  t iff t  c it     by definition of types  c v d  t and c  t imply d  t 
thus  it   is a model of t   it is an immediate consequence of the definition of at   that it   is
also a model of at     in fact  at   can be regarded as the reduct of it   to signature  
o
as a crucial tool for analyzing the properties of canonical aboxes  we introduce homomorphism
between aboxes  let a and a  be aboxes  an abox homomorphism from a to a  is a total
function h   ind a   ind a    such that the following conditions are satisfied 
 a a   a implies a h a    a   
 r a  b   a implies r h a   h b    a   
the next lemma identifies a central property of abox homomorphisms regarding query answering 
lemma    if t is an alci tbox  q is a cq such that t   a    q a            an    and h is an abox
homomorphism from a to a    then t   a     q h a             h an    
proof  we prove the contrapositive  thus assume that t   a      q h a             h an     then there is a
model i   of t and a  such that i       q h a             h an     define a model i by starting with i   and
 
reinterpreting the individual names in ind a  by setting ai   h a i for each a  ind a   since
individual names do not occur in t   i is a model of t   it is also a model of a  if a a   a  then
a h a    a  by definition of abox homomorphisms  since i   is a model of a  and by definition
of i  it follows that ai  ai   the case r a  b   a is analogous  finally  i       q h a             h an   
and the definition of i yield i     q a            an    we have thus shown that t   a     q a            an   
o
  

fiq uery and p redicate e mptiness

the following lemma characterizes satisfiability of  aboxes w r t  t by the existence of an abox
homomorphism into at    
lemma    let t be a satisfiable alci tbox and  an abox signature  a  abox a is satisfiable
w r t  t iff there is an abox homomorphism from a to at    
proof  assume a is satisfiable w r t  t   let i be a model of t and a  define a homomorphism h
from a to at   by setting h a    at   where t is the type for t and  realized by ai in i  using
the definition of at     one can see that h is indeed an abox homomorphism  conversely  let h be
an abox homomorphism from a to at     by lemma     at   is satisfiable w r t  t   the proof
of lemma    shows how one can construct a model of t and a from a model of t and at   using
the homomorphism h  thus a is satisfiable w r t  t  
o
we are now ready to prove the main property of at   regarding emptiness  as discussed at the
beginning of this section 
theorem    let t be a satisfiable alci tbox and  an abox signature  a cq q is empty for 
given t iff certt  at    q     
proof  the only if direction follows directly from the fact that at   is satisfiable w r t  t  by
lemma      for the if direction  let certt  at    q      to show that q is empty for  given t  
take a  abox a that is satisfiable w r t  t   by lemmas    and     certt  at    q     implies
certt  a  q      as required 
o
we now employ theorem    to prove the ne xp t ime upper bounds for iq query emptiness 
theorem    in alci  iq query emptiness is in ne xp t ime 
proof  let t be a satisfiable tbox   an abox signature  and a v  an iq for which emptiness for
 given t is to be decided  we employ the following 
fact  for any abox a  if t   a     a a   then there exists a model i of t and a with ai   ai and
 i     ind a       t    
proof of fact  if t   a     a a   then there exists a model j of t and a with aj   aj   we
may assume that  aj   a  ind a   is disjoint from the domain tt    of the interpretation it   
defined in the proof of lemma     where we assume that         now define i as the union of
the restriction of j to  aj   a  ind a   and the interpretation it    expanded by adding to ri
all pairs
  aj   t  such that tj  aj    r t  a  ind a   and t  tt     
  t  aj   such that t  r tj  aj    a  ind a   and t  tt     
then i is a model of t and a with ai   ai of the required size  this finishes the proof of the fact 
the ne xp t ime algorithm computes the canonical abox at    in exponential time  and guesses
for every a  ind at     a model ia with  ia     ind at          t     the algorithm returns yes
if for all a  ind at     
   ia is a model of at   and t   and
  

fibaader   b ienvenu   l utz     w olter

   aia   aia  
both conditions can be checked in exponential time  thus  by theorem    and the fact above  the
algorithm returns yes iff a v  is empty for  given t  
o
note that by theorem   cq predicate emptiness in alci is in ne xp t ime as well  for cq query
emptiness in alci  we can easily derive a  e xp t ime upper bound using at   and results from
the work of calvanese et al         on the complexity of query answering in dls 
theorem    in alci  cq query emptiness is in  e xp t ime 
proof  the  e xp t ime algorithm is obtained by first computing the canonical abox at   and
certt  at    q   and then checking whether the latter is empty  this can be done in  e xp t ime since
it is shown in the work of calvanese et al         that for all t   a  and q with t an alci tbox 
p n 
the set certt  a  q  can be computed in time  p m  
with p a polynomial  m the size of t  a 
and n the size of q 
o
we provide an improved ne xp t ime upper bound for cq query emptiness in alc  which will
allow us to show that for alc our three emptiness problems have the same complexity 
theorem    in alc  cq query emptiness is in ne xp t ime 
the proof is somewhat technical and reuses the machinery of fork rewritings and spoilers introduced
by lutz         who proves that the combined complexity of cq answering in the dl shq is
in e xp t ime  more concretely  we show that one can decide emptiness of a cq q for an abox
signature  given an alc tbox t by guessing an extension aet   of the canonical abox at  
with assertions that prevent any possible match of q and then checking that aet   is satisfiable w r t 
t   for example  if q is a x   then it obviously suffices to add a a  for every individual a in at  
 we allow here also complex concepts to be used in an abox   the general case requires a careful
analysis of the assertions that have to be considered as additions  and this is where the mentioned
fork rewritings and spoilers enter the picture  in fact  they are used to prove that  since there are
no inverse roles in the tbox  it suffices to consider extensions of at   that contain no additional
individual names and where the additional assertions are taken from a candidate set whose size is
polynomial in the size of at   and q  it remains to show that satisfiability of  t   aet     can be
decided  non deterministically  in time single exponential in the size of t and q  full details are
given in the appendix 
    lower bounds and undecidability
we prove matching lower bounds for the upper complexity bounds presented above and show undecidability of iq query emptiness  cq predicate emptiness  and cq query emptiness for alcf 
the undecidability proof and the ne xp t ime lower bound proof are by reduction of two different
tiling problems  where the first asks for a tiling of a finite rectangle of any  unbounded  size and the
second asks for a tiling of the  n   n  square  the  e xp t ime lower bound for cq query emptiness in alci is by a straightforward reduction to query entailment in alci  we begin with the
ne xp t ime lower bound 
theorem    in alc  cq predicate emptiness is ne xp t ime hard 
  

fiq uery and p redicate e mptiness

proof  the proof is by reduction of a ne xp t ime hard  n   n  tiling problem  an instance of this
tiling problem is given by a natural number n      coded in unary  and a triple  t  h  v   with
t a non empty  finite set of tile types including an initial tile tinit to be placed on the lower left
corner  h  t  t a horizontal matching relation  and v  t  t a vertical matching relation  a
tiling for  t  h  v   is a map f                n                   n      t such that f          tinit  
 f  i  j   f  i      j    h for all i    n     and  f  i  j   f  i  j        v for all j    n     it is
ne xp t ime complete to decide whether an instance of the  n   n  tiling problem has a tiling 
for the reduction  let n     and  t  h  v   be an instance of the  n   n  tiling problem with
t    t            tp    we construct a signature  and a tbox t in alc such that  t  h  v   has a
solution if and only if a selected concept name a is cq predicate empty for  given t   for the
proof  it is convenient to impose the una 
when formulating the reduction tbox  we use role names x and y to represent the  n   n grid and two binary counters x and y for counting from   to  n     the counters use concept
names x            xn  and y            yn  as their bits  respectively  t contains the following wellknown inclusions stating that the value of the counter x            xn  is incremented when going to
x successors and the value of the counter y            yn  is incremented when going to y successors 
for k              n    

u

 j k

and

t

 j k

xj v  xk t x xk   u  xk t x xk  

xj v  xk t x xk   u  xk t x xk  

and similarly for y            yn  and y  t also states that the value of the counter x does not change
when going to y successors and the value of the counter y does not change when going to xsuccessors  for i              n    
xi v y xi  

xi v y xi

yi v x yi  

yi v x yi  

and
in addition  t states that when the counter x is  n     it does not have an x successor and if the
counter y is  n     it does not have a y successor 
x  u    u xn  v x  

y  u    u yn  v y  

t states that tinit holds at        and that the tiling is complete 
x  u    u xn  u y  u    u yn  v tinit  
t states that if a tiling condition is violated  then a is true 
 for all    i   j  p  ti u tj v a 
 for all    i  j  p such that  ti   tj     h  ti u x tj v a 
 for all    i  j  p such that  ti   tj     v   ti u y tj v a 
  

 v

t

 ip

ti  

fibaader   b ienvenu   l utz     w olter

finally  since we cannot use negation in aboxes  t states that concept names x             x n 
and y             y n  are equivalent to x            xn  and y            yn    respectively  for i  
           n    
xi v x i   xi v x i   yi v y i   yi v x i  
we set     x  y  x            xn    y            yn    x             x n    y             y n    and show
claim   t  h  v   has no  n   n  tiling iff there exists a  abox a that is satisfiable w r t  t such
that t   a    v a v  
proof of claim  assume first that  t  h  v   has no  n   n  tiling  to construct a  we regard
the pairs  i  j  with i    n and j    n as individual names and let x  i  j    i      j    a for
i    n    and y  i  j    i  j        a for j    n     we also set xk  i  j   a if the kth bit of
i is    x k  i  j   a if the kth bit of i is    yk  i  j   a if the kth bit of j is    and y k  i  j   a if
the kth bit of j is    it is readily checked that a is satisfiable w r t  t and that t   a    v a v  
conversely  assume that  t  h  v   has a  n   n  tiling given by f                n     
             n     t  let a be a  abox that is satisfiable w r t  t   we show that t   a     v a v  
let i be a model of t and a  if ai     we are done  otherwise re define the interpretation of
t            tp and a as follows  associate with every d  i the uniquely determined pair  id   jd  
given by the values of the counters x and y at d in i  then set d  tki iff f  id   jd     tk and let
ai     it is readily checked that the resulting interpretation is still a model of t and a 
o
it follows from the preceding result that iq query emptiness and cq query emptiness for
alc and alci are ne xp t ime hard  for cq query emptiness in alci  we can easily derive
a  e xp t ime lower bound from results on the complexity of query entailment in alci 
theorem    in alci  cq query emptiness is  e xp t ime hard 
proof  it was shown by lutz        that cq entailment in alci is  e xp t ime hard already for
aboxes of the form  a a   and for boolean cqs  this can clearly be strengthened to empty
aboxes  replace a a  with the empty abox and compensate for this by adding to the tbox   v
r a with r a fresh role name  it thus remains to observe that a boolean cq q is entailed by t and
the empty abox iff q is non empty for     and t  
o
we now show that the simple addition of functional roles to alc leads to undecidability of cqpredicate emptiness  thus also of iq query emptiness and cq query emptiness  the proof is by
reduction from a tiling problem that asks for a tiling of a rectangle of finite size  which is neither
fixed nor bounded   the reduction involves a couple of technical tricks such as using concept
names that are not in  as universally quantified second order variables  this allows us to enforce
a grid structure using standard frame axioms from modal logic  which are second order in nature  
the reduction requires role names that are both functional and inverse functional  since inverse
functionality cannot be expressed in alcf  we also use a modal logic frame axiom to enforce that
a different   forwards  functional role name is interpreted as the inverse of the role name that we
are interested in  of course  undecidability carries over to variants of alcf that use a concept
constructor     r  instead of functional roles as an additional sort  and to all dls with qualified or
unqualified number restrictions 
theorem    in alcf  cq predicate emptiness is undecidable 
  

fiq uery and p redicate e mptiness

an instance of the aforementioned tiling problem is given by a triple  t  h  v   with t a non empty 
finite set of tile types including an initial tile tinit to be placed on the lower left corner and a final tile
tfinal to be placed on the upper right corner  h  t  t a horizontal matching relation  and v 
tt a vertical matching relation  a tiling for  t  h  v   is a map f               n             m   t
such that n  m     f          tinit   f  n  m    tfinal    f  i  j   f  i      j    h for all i   n  and
 f  i  j   f  i  j        v for all i   m  it is undecidable whether an instance of the tiling problem
has a tiling 
for the reduction  let  t  h  v   be an instance of the tiling problem with t    t            tp    we
construct a signature  and a tbox t such that  t  h  v   has a solution if and only if a selected
concept name a is cq predicate non empty for  given t  
the abox signature is     t            tp   x  y  x   y    where t            tp are used as concept
names  and x  y  x   and y  are functional role names  we use the role names x and y to represent horizontal and vertical adjacency of points in the rectangle  and the role names x and y  to
simulate the inverses of x and y  in t   we use additional auxiliary concept names  in particular u
and r mark the upper and right border of the rectangle  zc     zc     zx     zx     zy     zy   serve as
second order variables  c serves as a flag which indicates that grid cells are closed at the position
where it is set  and ix and iy are similar flags for the intended behavior of the role names x  x and
y  y    the concept name y is propagated through the grid from the upper right corner to the lower
left one  ensuring that these flags are set everywhere  that every position of the grid is labeled with
at least one tile type  and that the horizontal and vertical matching conditions are satisfied  when
the lower left corner of the grid is reached  we set a as a flag  which is what the query v a v  asks
for 
the tbox t is defined as the set of the following cis  where  ti   tj   t    range over all triples
from t such that  ti   tj    h and  ti   t     v and where be   for e   c  x  y   ranges over all
boolean combinations of the concept names ze   and ze     i e   over all concepts l  u l  where li
is ze i or ze i  
tfinal v y u u u r
x  u u y u tj   u ix u ti v u u y
y  r u y u t    u iy u ti v r u y
x  tj u y u y y   u y  t  u y u x y   u ix u iy u c u ti v y
y u tinit v a
bx u x x  bx v ix
by u y y   by v iy
x y bc u y x bc v c
u v y  r v x  u v x u

r v y r

t

 s tp

ts u tt v 

the cis for ix and iy are responsible for enforcing that x is the inverse of x and y  the inverse
of y  at least at those abox individuals that we are interested in  in fact  if the abox contains
assertions x a  b  and x  b  c  and thus violates the intended interpretation of x and x   then we
can interpret zx   and zx   such that the left hand sides of all possible instantiations of the ci
for ix are violated  e g  by making zx   and zx   true at a  but false at c  if the abox contains
x a  b   x  b  a   then this is not possible  since x and y  are functional  we thus enforce that x
  

fibaader   b ienvenu   l utz     w olter

and y are inverse functional  the cis for c achieve in a similar way the closing of grid cells  i e  
that the x y successor and the y x successor of every relevant abox individual coincide  however 
as can be seen from the proofs  this only works if x and y are inverse functional 
to establish theorem     it suffices to prove the following lemma  see the appendix for details  
lemma     t  h  v   admits a tiling iff there is a  abox a that is satisfiable with t and such
that t   a    v a v  

   el and its horn extensions
we study query and predicate emptiness for the dl el and several of its horn extensions  first  we
show that  in plain el  all three emptiness problems can be decided in polynomial time  the reason
is that in this case  the exponential size canonical abox at   from section   can be replaced with
a total  abox a that contains only a single individual which is an instance of all  predicates 
note that a is satisfiable w r t  any el tbox because el cannot express unsatisfiability  the
same approach works for eli  but in this case one obtains only an e xp t ime upper bound which
is optimal since subsumption for eli is already e xp t ime hard  baader et al                as
soon as unsatisfiability can be expressed  the situation changes drastically  in fact  we show that
even in el where subsumption and other standard reasoning tasks are still tractable   all versions
of  emptiness are e xp t ime hard  nevertheless  emptiness in horn extensions of el turns out to
be easier than emptiness in expressive dls  in contrast to the undecidability result for alcf and
the ne xp t ime hardness result for alc  emptiness is in e xp t ime even in horn alcif  the
reason is the unraveling tolerance of horn description logics observed in the work of lutz and
wolter         which implies that when looking for aboxes that witness non emptiness  we can
restrict ourselves to tree shaped ones  this enables the use of automata theoretic techniques to
decide emptiness 
    el and eli
we begin by showing that in el  cq query emptiness  cq predicate emptiness  and iq query
emptiness are all in pt ime  the proofs are transparent and simple  for any signature   the total
 abox is a     a a     a      r a   a     r    
lemma    let t be an el tbox and  a signature  any cq q is empty for  given t iff
certt  a  q     
proof  the proof is a simplified version of the proof of theorem     the  contrapositive of the 
only if direction follows from the fact that a is satisfiable w r t  t   for the if direction  let
certt  a  q      to show that q is empty for  given t   take a  abox a  define an abox
homomorphism from a to a by setting h a     a for all a  ind a    by lemmas    and    
certt  a  q     implies certt  a  q      as required 
o
lemma    provides a polytime reduction of cq query emptiness  and  therefore  iq query
emptiness and cq predicate emptiness  to the query evaluation problem for cqs over a   in the
appendix  we show that due to the simple shape of a   checking whether certt  a  q     can be
done in polynomial time  in fact  we give a polytime procedure that either returns certt  a  q   
 or succeeds in constructing a boolean forest shaped query qb that is empty for  given t iff q is 
  

fiq uery and p redicate e mptiness

the construction relies on the fact that  as an immediate consequence of results proved by lutz and
wolter         emptiness of q for  given t implies the existence of a model i of t and a with
certt  a  q     and such that i has the shape of a tree extended with reflexive loops at the root 
checking t   a     qb then only requires to answer concept queries in the extension elu of el
with the universal role  which is possible in pt ime  lutz   wolter         we obtain the following
result 
theorem    in el  iq query emptiness and cq query emptiness can be decided in pt ime 
a matching pt ime lower bound for theorem    can be shown by a reduction of subsumption in
el  which is pt ime hard  haase         consider an el tbox t and el concepts c and d 
then the ci c v d follows from t if  and only if  the iq b v  is non empty for the signature  a 
given the tbox t   a v c  d v b   where a  b are concept names that do not appear in c  d
or t   thus  we obtain
theorem    in el  iq query emptiness and cq query emptiness are pt ime hard 
observe that by lemma   and materializability of el we obtain that cq predicate emptiness is
pt ime complete as well in el 
note that we need very little for the proof of lemma    to go through  it suffices that the total
 abox a is satisfiable with every tbox  we can thus reduce emptiness to query answering
over the total  abox in any extension of el that is unable to express contradictions  as another
important example  we consider eli  since cq evaluation in eli is e xp t ime complete  we
only obtain an e xp t ime upper bound in this case  a matching lower bound is obtained from the
e xp t ime hardness of subsumption in eli and the simple reduction of subsumption to iq query
emptiness given above 
theorem    in eli  iq query emptiness and cq query emptiness are e xp t ime complete 
it follows from lemma   and materializability of eli that cq predicate emptiness is e xp t imecomplete in eli 
    horn extensions involving negation or functionality
the simplest extension of el that can express unsatisfiability is el   we begin by showing that
iq emptiness in el is e xp t ime hard  and thus significantly harder than subsumption and instance checking  both of which can be decided in polynomial time   to this end  we first show
that to decide iq query emptiness in el it is sufficient to consider emptiness w r t  directed treeshaped aboxes  where an abox a is called directed tree shaped if the following conditions hold 
   the directed graph gda    ind a     a  b    r a  b   a   is a tree 
   for all a  b  ind a   there is at most one role name r such that r a  b   a or r b  a   a
 and only one of these is the case  
proposition    an instance query b v  is non empty for a signature  given an el  tbox t iff
there exists a directed tree shaped  abox a that is satisfiable w r t  t such that t   a    b a  for
the root a of a 
  

fibaader   b ienvenu   l utz     w olter

proof  we provide a sketch only since this result also follows from the more general proposition    proved below  assume b v  is non empty for  given t   we find a  abox a that is
satisfiable w r t  t such that t   a    b a   let the potentially infinite abox a be obtained by
unfolding a as follows  the individuals of a are the words a  r     rn  an such that a    a and
ri  ai   ai      a for all    i   n  then include a a  r     rn  an   in a iff a an    a and
include r a  r     an   a  r     an rn an     in a if rn  an   an      a  one can show that a is satisfiable w r t  t since a is  and that t   a    b a  iff t   a    b a   by compactness of first order
consequence  we obtain a finite abox a   a with t   a     b a   a  is as required 
o
theorem    in el   iq query emptiness is e xp t ime hard 
proof  let t     and b v  be given  by proposition     b v  is non empty for  given t iff
there exists a directed tree shaped  abox a that is a witness for the non emptiness of b v  for
 given t   directed tree shaped  aboxes can be viewed as el concepts using symbols from 
only  and vice versa  thus  such a witness  abox exists iff there exists an el concept c using
symbols from  only such that c is satisfiable w r t  t and t    c v b  now the following can
be established by carefully analyzing the reduction underlying theorem    in the work of lutz and
wolter         given an el  tbox t   a signature   and a concept name b  it is e xp t ime hard
to decide if there exists an el concept c using symbols from  only such that c is satisfiable
w r t  t and t    c v b  this establishes e xp t ime hardness of non emptiness  using the fact
that e xp t ime   coe xp t ime  this hardness result transfers to iq query emptiness 
o
observe that by lemma   and materializability of el we obtain that cq predicate emptiness is
e xp t ime hard as well in el  
instead of proving a matching e xp t ime upper bound only for emptiness in el   we do this
for the expressive horn dl horn alcif  of which el is a fragment  in fact  the rest of this
section is devoted to the proof of the following theorem  it is interesting to contrast this result with
the undecidability of emptiness in alcf 
theorem    in horn alcif  cq query emptiness is in e xp t ime 
the strategy for the proof of theorem    is as follows  we first exhibit a polynomial time reduction
from cq query emptiness in horn alcif to cq query emptiness in elif    then  we show
that non emptiness of a cq q under an elif   tbox is always witnessed by aboxes of a certain 
forest like shape  we then consider canonical models of forest shaped aboxes  and the tbox
under consideration   which can be constructed by a chase like procedure and are a special kind of
materialization  cf  section     that is  the answers returned for this model are precisely the certain
answers  a central observation is that matches of q in canonical models of forest shaped aboxes
can be grouped into equivalence classes that are induced by certain splittings of q  we finally
show how to construct  for each equivalence class  a tree automaton that decides the existence of a
forest shaped witness abox whose canonical model admits a match of q that falls into that class 
throughout this proof  we generally impose the una 
we begin with the reduction to cq query emptiness in elif    in fact  the reduction even
shows that it suffices to consider elif   tboxes that are in normal form  by which we mean that
all cis take one of the forms
a  u    u an v b 

a v r b 
  

r a v b 

fiq uery and p redicate e mptiness

where a  a            an   b  nc        and r is a role name or inverse role 
proposition    for every horn alcif tbox t   abox signature   and cq q  one can construct
in polynomial time an elif   tbox t   in normal form such that q is empty for  given t iff q is
empty for  given t    
the proof of proposition    is standard and given in the appendix  in what follows  we assume that
all elif  tboxes are in normal form 
we next define canonical models  let  t   a  be an elif  kb such that a is satisfiable
w r t  t   to construct the  typically infinite  canonical model it  a of  t   a   start with a viewed
as an interpretation  that is  it  a   ind a   ait  a    a   a a   a   and rit  a     a  b   
r a  b   a   then exhaustively apply the following completion rules 
i

   if a  u    u an v a  t and d  ai t  a for    i  n  and d 
  ait  a   then add d to
ait  a  
   if r a v b  t    d  e   rit  a   e  ait  a   and d 
  b it  a   then add d to b it  a  
   if a v r b  t   d  ait  a   and either d 
   r b it  a and funct r    t or d 
 
i
i
i
i
i
t
 a
t
 a
t
 a
t
 a
t
 a
 r   
  then add  d  e  to r
and e
to 
and b
  where e is a fresh
element 
  b it  a   then add e to
   if a v r b  t   funct r   t   d  ait  a    d  e   rit  a   and e 
i
t
 a
b
 
the construction can be rendered deterministic by using an ordering of the inclusions and domain
elements to decide among different possible rule applications  for this reason  we may speak of the
canonical model  we call a model u of t and a universal if there is a homomorphism from u to
any model i of t and a  that is  a function h   u  i such that d  au implies h d   ai  
 d  e   ru implies  h d   h e    ri   and h au     ai for all a  ind a   the most important
property of it  a is that it is universal   in fact  the following is standard to prove and we omit
details  see for example the work of lutz and wolter        
lemma    let t be an elif   tbox and a an abox that is satisfiable w r t  t   then it  a is a
universal model of  t   a  
let t be an elif  tbox and a a  abox that is satisfiable w r t  t   it is an easy consequence
of lemma    that a  abox a is a witness for a cq q being non empty for  given t if and only
if a is satisfiable w r t  t and there is a match of q in it  a  
the next step in our proof of theorem    is to establish a proposition that constrains the shape
of aboxes to be considered when deciding emptiness in elif    here and in what follows  an
abox a is called tree shaped if
   the undirected graph ga    ind a     a  b    r a  b   a   is a tree 
   for readers wondering about the relationship between universal models and materializations as defined in section   
we remark that every universal model of a tbox t and abox a is a materialization of t and a  conversely  if there
is a materialization of t and a  then there exists also a universal model of t and a  lutz   wolter        

  

fibaader   b ienvenu   l utz     w olter

   for all a  b  ind a   there is at most one role name r such that r a  b   a or r b  a   a 
and only one of these is the case 
when working with tree shaped aboxes  we often designate one of the individuals as the root  if
the root of the tree shaped abox a has been fixed  then we use a a to denote the restriction of a
to those individuals b whose unique path to the root in ga contains a  and we call b  ind a  an
r successor  resp  r  successor  of a  ind a  if r a  b   a a  resp  r b  a   a a    we will
also consider  rooted  tree shaped interpretations and tree shaped queries  defined analogously to
tree shaped aboxes 
a  abox a is forest shaped if there are aboxes a    a            ak such that the following
conditions are satisfied 
   a is the union of a    a            ak  
   k   ind a     
   for    i   j  k  ind ai    ind aj      and  ind ai    ind a         
   for    i  k  ai is a tree shaped abox rooted at some individual in ind a    
we call a  the root component of a and a            ak the tree components  the width of a if k  the
degree of a is the smallest number n such that for every tree component ai and every a  ind ai   
the number of assertions r a  b  and r b  a  in ai is bounded by n  the following proposition
clarifies the role of forest shaped aboxes as witnesses for non emptiness 
proposition    let t be an elif   tbox   an abox signature  and q a cq  if q is non empty
for  given t   then this is witnessed by a  abox that is forest shaped  has width at most  q   and
degree at most  t   
proposition    is proved in the appendix by taking a witness  abox a  selecting a part of a of
size  q  that is identified by a match of q and that serves as the root component of the forest shaped
abox  then unraveling a into a infinite abox starting from the selected part  afterwards removing
unnecessary individual names to obtain the desired degree  and finally applying compactness to
make the resulting witness finite 
clearly  we can assume w l o g  that in forest shaped witness aboxes according to proposition     the individual names used in the root component are taken from a fixed set ind of cardinality
 q   we will make this assumption without further notice in what follows 
we next analyze matches in forest shaped aboxes  using a splitting of the query into components  these are similar to the splittings of queries used in appendix b  but simpler  a forest
splitting of a cq q is a tuple f    q     q    q            qn     where q   can be obtained from q by identifying variables  q    q            qn is a partition of the atoms of q     and    var q     ind such that the
following conditions are satisfied
   q            qn are tree shaped 
   var qi    var q       for    i  n 
   var qi    var qj      for    i   j  n 
  

fiq uery and p redicate e mptiness

let t be an elif   tbox  a a forest shaped abox with root component a    and  a match
of q in it  a   note that it  a consists of a extended with  potentially infinite  trees attached
to abox individuals that have been generated by the completion rules  then  is of type f  
 q     q    q            qn     if q   can be obtained from q by identifying those variables that  sends to the
same element  q  consists of the atoms in q   that  matches to the a   part of it  a   q            qn are
the maximal connected components of q     q    and  is the restriction of  to range ind  note
that  no matter which match  we choose  the maximal connected components of q     q  must be
tree shaped because they match into a tree shaped part of it  a   which consists of a tree component
of a plus the attached trees generated by the completion rules  thus every match  has a type and
the following is immediate  where wt  q f denotes the set of forest shaped  aboxes of width at
most  q  and degree at most  t   that admit a match of q which is of type f  
lemma    let t be an elif   tbox   an abox signature  and q a cq  then q is empty for 
given t if and only if wt  q f is empty for every forest splitting f of q 
from now on  let t be an elif   tbox t in normal form   an abox signature  and q a cq  and
assume that we want to decide whether q is empty for  given t   by lemma     it suffices to check
whether wt  q f is empty for every forest splitting f of q 
note that defining the set wt  q f is possible only because the definition of a forest splitting
does not refer to a particular abox  which in turn is due to our use of the fixed set of individual
names ind for the root components of forest aboxes  in fact  first quantifying over forest splittings
as in lemma    and then quantifying over forest shaped aboxes  when testing emptiness of some
wt  q f   is essential for obtaining a single exponential time upper bound  since the number of
forest splittings is single exponential in  q   we obtain such a bound if we can test emptiness of
each wt  q f in time single exponential in  t      q   we will achieve this by constructing  for each
forest splitting f of q  a two way alternating parity automaton on infinite trees  twapa  af that
accepts a non empty language if and only if wt  q f      note that infinite trees are needed because
automata will take trees as input that represent not only a  finite  forest shaped  abox a  but also
a  potentially infinite  model of a and t  
we start by introducing the necessary background for twapas  let
denote the positive
integers  a tree is a non empty  and potentially infinite  set t   closed under prefixes  the
node  is the root of t   we use standard concatenation on the words from   nodes of trees  and 
as a convention  take x      x and  x  i       x for all x   and i    note that     is
undefined  when i     the node x  i is said to be a child of the node x  and x is called the parent of
x  i  we will slightly depart from vardis original definition of twapas  vardi        by working
with trees which are not full  that is  we define an m ary tree as a tree each of whose nodes has at
most  rather than exactly  m children  w l o g   we assume that all nodes in an m ary tree are from
            m    an infinite path p of t is a prefix closed set p  t such that for every n     there
is a unique x  p with  x    n 
for any set x  we use b    x  to denote the set of all positive boolean formulas over x  i e  
formulas built using conjunction and disjunction over the elements of x used as propositional variables  and where the special formulas true and false are allowed as well  for an alphabet   a
 labeled tree is a pair  t  v   with t a tree and v   t   a node labeling function 

n

n

n
n
n

definition     twapa  a two way alternating parity automaton  twapa  on m ary trees is a
tuple a    s      s    f   where s is a finite set of states   is a finite alphabet     s   
  

fibaader   b ienvenu   l utz     w olter

b    tran a   is the transition function with tran a     hii   i    i               m    s the set
of transitions of a  s   s is the initial state  and f    g            gk   is a sequence of subsets of s
satisfying g   g          gh   s  called the parity condition 
intuitively  a transition  hii  s  with i     means that a copy of the automaton in state s is sent to the
i th successor of the current node  which is then required to exist  by contrast  the transition   i   s 
only sends a copy if the i th successor exists  the transitions  hii  s  and   i   s  with i         are
interpreted similarly where   indicates sending a copy to the predecessor and   indicates sending
a copy to the current node  note that a transition  h i  s  cannot be applied at the root 
definition     run  acceptance  a run of a twapa a    s      s    f   on a  labeled tree
 t  v   is a t  s labeled tree  t     such that         s    and for all y  t    y     x  s 
and  s  v  x      implies that there is a  possibly empty  set   d    s              dn   sn     tran a 
that satisfies  and is such that for    i  n 
   if di   hji  then x  j is defined  x  j  t   y  i  t   and  y  i     x  j  si   
   if di    j  and x  j is defined and belongs to t   then y  i  t and  y  i     x  j  si   
given an infinite path p  t   we denote by inf p   the set of all states q such that there are infinitely
many y  p such that  y  is of the form  d  q   we say that the run  t     is accepting if for all
infinite paths p  t   there exists an even k such that inf p    gk     and inf p    gk     
a  labeled tree  t  v   is accepted by a if there is an accepting run of a on  t  v    we use
l a  to denote the set of all  labeled trees accepted by a 
we note that the original definition of twapas  vardi        only uses transitions of the form
 hii  q  with i              m   since  hii  q  and   i   q  coincide for full m ary trees  it is easy to
see that emptiness for our version of twapas can be reduced in polynomial time to emptiness for
twapas in the original definition since we can encode m ary trees as full m ary trees  vardi       
has shown that the emptiness problem of twapas is e xp t ime complete  more precisely  there
is an algorithm that  given a twapa a    s      s    f    decides whether l a     and runs in
time exponential in the cardinality of s and polynomial in the cardinality of  and size of   we
also remind the reader that given two twapas a  and a  with ai    si   i   i   s  i   fi    it is very
easy to construct  in polynomial time  a twapa a such that l a    l a     l a    and a has
state set s   s   
to make them accessible to twapas  we encode forest shaped  aboxes of width at most  q 
and degree at most  t   as m ary trees  where m    q    t    as has already been mentioned  each
such tree additionally encodes a model of the encoded abox  we now explain the alphabet used
and the shape of the trees in more detail  the root node is labeled with an element of the alphabet
r that consists of all sig t   aboxes a such that  i  ind a   ind   ii  r a  b   a implies r   
and  iii  a satisfies all functionality statements in t   let sub t   denote the set of concepts that
occur in t and their subconcepts  non root nodes are labeled with elements from the alphabet n
that consists of all subsets
   nc  sub t       m      r  r   r  nr occurs in t     ind    a   b v r a  t  
  

fiq uery and p redicate e mptiness

such that  contains  i  exactly one role name or inverse role   ii  at most one element of ind  and
 iii  either m and a role name or inverse role from  or exactly one element of the form a and  in
the latter case  also a 
a tree ht   i with   a labeling as described above is supposed to represent a forest shaped abox aht  i together with a model iht  i of this abox and of t   the individuals of aht  i are
those in the abox that labels the root of t   plus all non root nodes of t whose label contains the
marker m   all other nodes of t denote domain elements of iht  i that are not identified by any
abox individual  both the assertions in aht  i and the concept and role memberships in iht  i are
represented by the labels of ht   i  note that the abox a is a sig t   abox whereas aht  i uses
signature   in fact  only the  assertions in a will be part of aht  i while all assertions in a will
be part of iht  i  
we need to impose some additional conditions to make sure that a r  n  labeled tree ht   i
indeed represents an abox and model as intended  we call ht   i proper if it satisfies the following
conditions for all x  t  
   the root is labeled with an element a of r and all other nodes with an element of n  
     x   n contains an element of ind a  if x is a child of the root of t   and no element of
ind otherwise 
   if we take any path in t and remove the root node  because it carries a special label   then the
nodes whose label contains m form a finite  possibly empty  prefix of the resulting path 
   if y is a child of x and a    y   n   then there is some b v r a  t such that one of
the following is true 
 a  x is not the root  b    x  and r    y  
 b  x is the root and for some a  ind  b a     x  and  a  r     y  
the roles and individual names in element labels describe how these elements are connected to
other elements via roles in aht  i and in iht  i   in particular  if a successor of the root contains both
the role r and the individual name a  ind  then that node represents an r successor of a  the label
elements that are of the form a serve a special marking purpose  if a    x   then this means
that the element x  which is part of iht  i but not of aht  i since   x  cannot contain m   is there
to satisfy some concept inclusion b v r a  we will later need these special markers to make
sure that iht  i is not just some model of aht  i   but a materialization of aht  i and t   with these
explanations and the subsequent definitions  the three conditions imposed on the elements of  and
the four conditions used to define properness above should make sense to the reader 
let ht   i be a proper r  n  labeled tree  we now define aht  i and iht  i formally  let a
be the abox that labels the root  of t   and let a be the restriction of a to signature   then the
 abox aht  i described by ht   i is
aht  i   a   a x    a    x   nc   and m    x  
  r b  x     b  r  m      x     r x  b     b  r   m      x  
  r x  y    y is a child of x and m    x     y  and r    y  
  r y  x    y is a child of x and m    x     y  and r    y  
  

fibaader   b ienvenu   l utz     w olter

and the interpretation iht  i is as follows 
iht  i

   t        ind a 

a

iht  i

   a   a a   a    x   a    x   nc  

r

iht  i

    a  b    r a  b   a     a  x     a  r     x      x  a     a  r      x  
   x  y    y is a child of x and r    y      x  y    x is a child of y and r    x  

ciht  i

  c

for all c  ind aht  i  

apart from being represented as an abox instead of as an interpretation  aht  i is identical to the
restriction of iht  i to the individuals in aht  i and symbols in   which in particular means that
iht  i is a model of aht  i   note that the abox aht  i is a forest shaped  abox  conversely 
for any forest shaped  abox of width at most  q  and degree at most  t    we can define a proper
m ary r  n  labeled trees ht   i such that aht  i   a and iht  i   it  a  
let f    q     q    q            qn     be a splitting for q  we now build a twapa af over m ary
r  n  labeled trees that accepts exactly those trees ht   i such that aht  i  wt  q f   the
number of states of af will be polynomial in  t      q  and since it can be checked in time singleexponential in the number of states whether l af        we obtain the desired e xp t ime upper
bound for deciding whether wt  q f     we construct af as the intersection of the following
twapas 
   aprop   which makes sure that the input tree is proper 
   at   which ensures that the input tree ht   i is such that iht  i is a model of t  
   awf which ensures that ht   i satisfies a certain well foundedness condition 
   amatch which guarantees  exploiting the conditions ensured by the previous automata  that
the input tree ht   i is such that aht  i  wt  q f  
the construction of the first automaton aprop is straightforward  and details are left to the reader 
note that  to enforce condition   of proper trees  the automaton needs to make use of the parity
acceptance condition  a co buchi condition would actually be sufficient   the second twapa at
ensures that the following conditions are satisfied for all non root nodes x  x  of the input tree 
 if r a  b       and funct r   t   then  a  r      x  
 if funct r   t and  a  r     x     x     then x   x   
 if funct r   t   then x has at most one child y with r    y   and if additionally r    x  
then there is no such child y 
 if a  u    u an v a  t and  a   a           an  a         then a a       
 if a  u    u an v a  t and  a            an      x   then a    x  
 if a v r b  t and a a        then  i  there is some b such that  r a  b   b b        
or  ii  there is a child x of the root such that  a  r  b     x  
  

fiq uery and p redicate e mptiness

 if a v r b  t and a    x   then  i   a  r      x  and b a         ii  r    x  and
x has non root parent y with b    y   or  iii  x has a child y with  r  b     y  
 if r a v b  t and  i   r a  b   a b        or  ii  there is some child y of the root such
that  a  r  a     y   then b a       
 if r a v b  t and  i   a  r      x  and a a  is in the label of the root   ii  r    x 
and x has parent y with a    y   or  iii  x has child y with  r  a     y   then b    x  
working out the exact details of aprop is again left to the reader 
ideally  we would like the third automaton awf to ensure that iht  i is the canonical model of t
and aht  i   however  this does not seem to be easily possible because that model is constructed by
applying completion rules in a certain order which is difficult to simulate by an automatonnote
that applying the rules in a different order might result in the construction of an interpretation that is
not isomorphic to the one obtained when following the prescribed application order  we thus define
awf to achieve only the crucial property of canonical models that all positive information  concept
and role memberships of domain elements  is there for a reason  namely because it is contained in
aht  i or because it is logically implied by aht  i together with t   we formalize this in terms of
derivations 
i
let ht   i be a proper r  n  labeled tree  a    nc  sub t          and x   a  ht  i   a
derivation of a  at x  in ht   i is a finite l labeled tree ht        i  where l is the set of pairs  a  x 
with a   nc  sub t         and x  aiht  i   we require that the root of t   is labeled with
 a    x    and that t   is minimal such that for all nodes z of t   with     z     a  x   one of the
following holds 
   a        and x  ind aht  i   
   a     x  and there are a ci a  u    u an v a  t and children z            zn of z in t   such
that     zi      ai   x  for    i  n 
   a     x  and there is a ci r a  v a  t and a child z   of z in t   with     z        a    x   
such that  x  x     riht  i   moreover  if b     x   then there is a child z    of z in t   with
    z         b  x  
   a     x  and there is a ci a  v r a  t with funct r   t and a child z   of z in t   with
    z        a    x    such that  x    x   riht  i   moreover  if b     x   then there is a child z   
of z in t   with     z         b  x  
   a            x   b     x   and there is a child z   of z in t   with     z        b  x  
   a    x   there is a ci a  v r a  t   and there is a child z   of z in t   with     z      
 a    x    such that  x    x   riht  i and either  i  x is a child of x  in t   or  ii  x is a child of
the root  x   ind  and  r  x       x  
we say that ht   i is well founded if whenever x  aiht  i   with a  nc       then there is a
derivation of a at x in ht   i  it is not hard to construct a twapa awf that accepts precisely the
well founded proper r  n  labeled trees  essentially  the automaton can verify the existence of
all required derivations by implementing the conditions   to   above as transitions  additionally
using a co buchi condition to ensure finiteness of the derivation 
next let f    q     q    q            qn      the automaton amatch checks that
  

fibaader   b ienvenu   l utz     w olter

    is a match for q  in iht  i and
   there is a match  for qi in iht  i such that if v  var q     var qi    then  v     v  
amatch is easy to construct and we once more omit details  as announced  we define af such that
it accepts the intersection of the languages accepted by aprop   at   awf   and amatch   it remains to
show that wt  q f is empty iff l af   is empty 
to do this  we first clarify the relation between well foundedness  canonical models  and universal models  we call a proper r  n  labeled tree ht   i canonical if  i  iht  i is the canonical
model of aht  i and t   and  ii  for every x  t     with m     x   the concept a    x  is such
that the element x was created due to an application of the third completion rule to an inclusion of
the form b v r a and the parent of x in t  
lemma   
   if a proper r  n  labeled tree is canonical  then it is well founded 
   if ht   i is a proper r  n  labeled tree that is well founded and iht  i is a model of t  
then iht  i is a universal model of t and aht  i  
a proof of lemma    can be found in the appendix  point   is established by tracing the applications
of the completion rules applied to construct the canonical model of aht  i and t and showing that
each addition that they make gives rise to a derivation  for point    we first show that one can
make a certain uniformity assumption on derivations and then show how to define a homomorphism
from iht  i to any model of aht  i and t by starting at the part of iht  i that corresponds to the root
component of aht  i and then moving downwards along the tree shaped parts of iht  i  
lemma    wt  q f    iff l af      
proof  first assume that wt  q f      then there is a forest shaped  abox a of width at most
 t   and degree at most  q  that is satisfiable w r t  t and a match  of q in it  a that is of type f  
let ht   i be an m ary proper r  n  labeled tree that satisfies aht  i   a and is canonical 
then ht   i  l aprop    since a is satisfiable w r t  t   iht  i   it  a is a model of t and thus
ht   i  l aprop    by point   of lemma     ht   i  l awf    finally  the match  witnesses that
conditions   and   from the definition of amatch are satisfied and thus ht   i  l amatch   and we
are done 
conversely  assume that there is a tree ht   i  l af    since ht   i  l aprop    a   aht  i
is defined  by definition  it is a forest shaped  abox of width at most  t   and degree at most  q  
it remains to show that there is a match  of q in it  a that is of type f   since ht   i  l at   
l awf    iht  i is a model of t and ht   i is well founded  by point   of lemma     iht  i is thus
a universal model of t and a  because ht   i  l amatch    conditions   and   from the definition
of amatch are satisfied  it can be verified that  consequently  there is a match  of q in iht  i that is
of type f   composing  with the homomorphism from iht  i to it  a   which exists since iht  i is
universal  yields a match of q in it  a that is of type f  
o

  

fiq uery and p redicate e mptiness

   the dl lite family
we study query and predicate emptiness in the dl lite family of description logics  calvanese
et al         artale et al          to begin with  we introduce the dialects of dl lite we consider 
basic concepts b are defined by
b

   

 

  a

 

r  

where a ranges over nc and r over all  possibly inverse  roles  a dl litecore tbox t is a finite
set of cis of the form b  v b  and b  u b  v   where b  and b  are basic concepts  thus 
dl litecore is included in eli but  because it includes inverse roles  not included in el  dl litef
is the extension of dl litecore with functionality statements  dl liter is the extension of dllitecore with role inclusions r v s  where r  s are roles  dl liter is the logical underpinning of the
owl profile owl  ql  motik et al          finally  dl litehorn is the extension of dl litecore
with conjunctions of basic concepts on the left hand side of cis  alternatively  it can be defined as
the fragment of eli  with qualified existential restrictions r c replaced by unqualified existential
restrictions r    for further details  we refer readers to the work of calvanese et al          artale
et al          and calvanese  de giacomo  lembo  lenzerini  and rosati        
we briefly discuss the una for the dl lite dialects introduced above  first observe that dllitehorn and dl litef are fragments of alcif  thus  by lemma    query emptiness and predicate emptiness for dl litehorn and dl litef are oblivious as to whether the una is made or not 
dl liter is not a fragment of alcif  it is  however  straightforward to show that for dl liter
the certain answers to cqs do not depend on whether one adopts the una or not  thus  also for
dl liter query emptiness and predicate emptiness are oblivious as to whether the una is made or
not  in the following proofs we make the una 
our main results are as follows  cq query emptiness is conp complete for all dl lite dialects 
the conp lower bound holds already for the fragment of dl litecore without role names  by
contrast  the complexity of deciding iq query emptiness and cq predicate emptiness depends
on whether conjunctions are admitted on the left hand side of concept inclusions or not  if no
conjunctions are admitted  as in dl litecore   dl liter   and dl litef    then iq query emptiness
and cq predicate emptiness are nl og s pace complete  if conjunctions are admitted  as in dllitehorn    then both iq query emptiness and cq predicate emptiness are conp complete  again 
the lower bound holds already for the fragments of the dls without role names 
we note that in what follows we do not use theorem   which gives a polynomial reduction of
cq predicate emptiness to iq query emptiness for certain dls but does not apply to the dl lite
dialects  instead we give direct proofs  the results presented in figure   for the dl lite dialects
are straightforward consequences of the results established in this section 
we begin by proving the conp lower bounds  let lcore be the dl that admits only cis a v b
and a u b v   and let lhorn be the dl that admits only cis a u a  v b and a u b v   where
a  a    and b are concept names 
theorem    in lhorn   iq query emptiness  cq query emptiness  and cq predicate emptiness are
conp hard  in lcore   cq query emptiness is conp hard 
proof  the proofs are by reduction from the well known conp complete problem of testing whether
a propositional formula in conjunctive normal form  cnf  is unsatisfiable  let           k
  

fibaader   b ienvenu   l utz     w olter

be a cnf formula  v            vn the variables used in   a            ak concept names for representing clauses  and av    av            avn   avn concept names for representing literals  let a be an
additional concept name  and set     av    av            avn   avn    consider the lhorn  tbox t
consisting of the following cis 
 avj u avj v  for all    j  n 
 a j v ai for all    i  k and each  j     vj that is a disjunct of i  
 a  u    u ak v a  
it is straightforward to show that a u  is empty for  given t iff u a u  is empty for  given t
iff  is unsatisfiable  thus  deciding iq query emptiness  cq predicate emptiness  and cq query
emptiness in lhorn is conp hard  for the conp hardness result for cq query emptiness in lcore  
we drop the last ci from t and use the cq a   u       ak  u  instead 
o
we now prove matching upper complexity bounds  considering the logics dl litecore   dlliter   dl litef   and dl litehorn   to this end  we formulate general sufficient conditions for
deciding emptiness in pt ime and in conp  we say that a dl l has the polysize emptiness witness property if whenever a cq q is not empty for  given t   then there exists a  abox a of
polynomial size in the size of t and q that is satisfiable w r t  t and such that certt  a  q      
lemma    let l be any description logic with the polysize emptiness witness property such that
the query evaluation problem for cqs for l is in np  moreover  assume that satisfiability of aboxes
w r t  l tboxes can be decided in polynomial time  then cq query emptiness in l is in conp 
proof  an np algorithm deciding whether a cq q is not empty w r t  t and  guesses  i  a  abox
a of polynomial size in t and q   ii  a tuple  a of individual names from ind a  of the appropriate
length  and  iii  a polysize certificate that  a  certt  a  q   it then verifies in polynomial time that a
is satisfiable w r t  t and the guessed certificate is valid 
o
theorem    in dl litecore   dl liter   dl litef   and dl litehorn   deciding cq query emptiness
is in conp 
proof  the conditions stated in lemma    have been shown by calvanese et al         and artale
et al          we sketch a proof of the polysize emptiness witness property  assume  a  certt  a  q 
for a cq q    u   v    u  and a tbox t in any of the dls listed in the theorem statement and
further assume that a is satisfiable w r t  t   we use the canonical model it  a from lemma   
 for dl litecore   dl litef   and dl litehorn this can be used without any modification since they
are fragments of elif    for dl liter   one has to add the following completion rule for the
construction of it  a   if  x  y   rit  a and r v s  t   then add  x  y  to sit  a    let  be a
match for q in it  a   we recall that it  a consists of its restriction to the individuals ait  a with
a  ind a  and tree shaped interpretations ia attached to ait  a   let a   be the set of assertions in
a that only use individual names a  ind a  such that there exists v  var q  with  v    ait  a
or  v   ia   moreover  for any individual a  ind a     selected above such that there exists a
role r and b with r a  b   a  select one such r a  b   and include it in a     let a    a    a    
clearly the abox a  is as required  it is of polynomial size  it is satisfiable w r t  t  being a subset
of a   and by construction  it satisfies  a  certt  a   q  
o

  

fiq uery and p redicate e mptiness

we say that a dl l has the singleton emptiness witness property if whenever a cq q of the form
a v  or v a v  is not empty for  given t   then there exists a  abox a containing at most one
assertion which is satisfiable w r t  t and such that certt  a  q      
lemma    let l be any description logic with the singleton emptiness witness property such that
the query evaluation problem for cqs of the form a v  and v a v  for l is in nl og s pace  moreover  assume that satisfiability of singleton aboxes w r t  l tboxes can be decided in nl og s pace 
then iq query emptiness and cq predicate emptiness in l are in nl og s pace 
proof  a non deterministic logarithmic space algorithm deciding whether a cq of the form a v 
or v a v  is not empty w r t  t iterates over all  aboxes a containing at most one assertion and
checks whether at least one of those aboxes a is satisfiable w r t  t and satisfies t   a    v a v 
or  respectively  t   a    a a   for an individual a  ind a  
o
theorem    in dl litecore   dl liter   and dl litef   deciding iq query emptiness and cqpredicate emptiness are nl og s pace complete 
proof  for the nl og s pace upper bound  the conditions stated in lemma    have been shown
by calvanese et al         and artale et al          we sketch a proof of the singleton emptiness
witness property  assume  a  certt  a  q  for a cq q of the form a v  or v a v  and a tbox
t in any of the dls listed in the theorem statement  further assume that a is satisfiable w r t  t  
we consider the case q   v a v   the case q   a v  is similar  as in the proof of theorem    
we use the canonical model it  a   let  be a mapping into it  a such that  v   ait  a and
consider the uniquely determined a  ind a  such that  v    ait  a or  v   ia   using the
fact that no conjunctions occur on the left hand side of cis in t   one can show that there exists a
single assertion of the form b a  or r a  b  such that for the abox a  consisting of that assertion 
we have     certt  a   q   it follows that a  is the desired witness abox 
the matching lower bound follows directly from the fact that deciding whether t    a v b is
nl og s pace hard for tboxes t in dl litecore  artale et al         
o

   case study and application to modularity
we demonstrate the usefulness of emptiness in two ways  first  we carry out a case study for
predicate emptiness in the medical domain  where we find that the use of a realistic ontology adds
a significant number of non empty predicates to the abox signature while there is also a large
number of predicates that are empty  in static analysis  it is thus potentially non trivial for a user to
manually distinguish the non empty from the empty predicates  second  we show that  predicate 
emptiness can be used to produce a smaller version of a tbox t that is tailor made for querying
with a given abox signature  in a sense  a module of the tbox   replacing t with the potentially
much smaller module facilitates comprehension of the tbox  thus helping with query formulation 
we again support our claims by experiments 
in the case study  we use the comprehensive medical ontology snomed ct  which provides
a systematic vocabulary used for medical information interchange and to enable interoperable electronic health records  it covers diverse medical areas such as clinical findings  symptoms  diagnoses  procedures  body structures  organisms  substances  pharmaceuticals  devices and specimens 
  

fibaader   b ienvenu   l utz     w olter

concepts roles

iq
cq axioms
axioms
non empty non empty  mod  cq  core

   

  

    

    

    

    

   

  

    

    

    

    

    

  

    

    

     

    

    

  

    

    

     

    

    

  

     

     

     

     

    

  

     

     

     

     

     

  

     

     

     

     

     

  

     

     

     

     

figure    experimental results
snomed ct is formulated in el extended with role inclusions  which we removed for the experiments   it contains about         concept names and    role names  we use snomed ct
together with an abox signature from a real world application and with randomly generated abox
signatures  the real world signature was obtained by analyzing clinical notes of the emergency
department and the intensive care unit of two australian hospitals  using natural language processing methods to detect snomed ct concepts and roles   it contains       concepts and    roles 
for this signature         iq non empty predicates and        cq non empty predicates were
computed  thus  snomed ct provides a substantial number of additional predicates for query
formulation  roughly identical to the number of predicates in the abox signature  however  these
numbers also show that the majority of predicates in snomed ct cannot meaningfully be used in
queries over  aboxes  and thus identifying the relevant ones via predicate emptiness is potentially
very helpful  somewhat surprisingly  the number of cq non empty predicates is only about    
higher than the number of iq non empty symbols 
we have analyzed randomly generated signatures that contain                    and       
concept names and    or    role names      and     of the role names in the ontology   every
signature contains the special role name role group  which is used in snomed ct to implement
a certain modeling pattern and should be present also in aboxes to allow the same pattern there 
for each number of concept and role names  we generated    signatures  the columns iq nonempty and cq non empty of figure   show the results  where the numbers are averages for the
   experiments for each size  these additional experiments confirm the findings for our real world
signature  in each case  a substantial number of additional predicates becomes available for query
formulation  but there is also a large number of predicates that are empty 
we now come to the application in modularity  recall that our main motivation for studying
emptiness is to support query formulation  as tboxes can be large and complex  it can be difficult
to understand whether a tbox contains sufficient background knowledge so that a given query q
can have a non empty answer over a  abox  if this is not the case  it clearly does not make sense
   see current collaborative projects of the health information technologies research laboratory at the university
of sydney  hitrl        

  

fiq uery and p redicate e mptiness

to pose q to any  abox when this tbox is used as the background ontology  similarly  it can be
hard to find out whether a tbox is sufficiently powerful to entail that a given predicate can occur
in some query that has a non empty answer over some  abox  again  if this is not the case  then
that predicate should not be used when formulating queries  here  we go one step further  instead
of using emptiness directly to support query formulation  we use it to simplify the tbox  more
precisely  we consider the problem of extracting a  hopefully small   subset of a given tbox that
gives exactly the same answers to all cqs  or iqs  for any  abox  such a subset will be called
a  substitute w r t  cq  or iq  respectively  of the original tbox and can replace the original
tbox when answering cqs  or iqs  respectively   working with a small  substitute instead of
the original tbox supports comprehension of the tbox and thereby the formulation of meaningful
queries 
it is beyond the scope of this paper to investigate  substitutes in depth  instead  we show that 
in the description logic eli  predicate emptiness gives rise to a particularly natural kind of substitute that we call the cq  core  the cq  core is obtained by removing all concept inclusions
that contain a predicate which is cq predicate empty for  w r t  the tbox  thus  not only does
the cq  core give the same answers to cqs as the original tbox for  aboxes  but it also has
the appealing property that all predicates which occur in it can be used meaningfully in a cq when
querying  aboxes 
we also show that the widely known semantic  modules introduced by grau et al         are
 substitutes and that cq  cores cannot be larger than semantic  modules  unless the original
ontology contains tautological concept inclusions   to evaluate the method in practice and compare
the size of cq  cores and  modules  we also extend our case study based on snomed ct to the
extraction of cq  cores and their comparison with  modules  we start by defining  substitutes
in a formal way 
definition    let t    t and q   iq  cq   then t   is a  substitute for t w r t  q if for all
 aboxes a and all q  q  we have that certt    a  q    certt  a  q  
we are not aware that  substitutes according to definition    have been studied before  but they are
closely related to other types of modules  for example   modules that give the same answers to all
cqs formulated in signature  for all  aboxes are studied in the work of lutz and wolter        
kontchakov  wolter  and zakharyaschev         konev  ludwig  walther  and wolter         botoeva  kontchakov  ryzhikov  wolter  and zakharyaschev               and romero  kaminski 
grau  and horrocks         a stronger version of a module is provided by  modules that require the original tbox to be a model conservative extension of the module regarding the signature
  as studied by konev  lutz  walther  and wolter        and gatens  konev  and wolter        
however  an important difference between all those  modules and our  substitutes is that the
latter only restrict the signature of the abox  but not of the queries  in contrast  the mentioned
 modules only guarantee the same answers to cqs formulated in signature   and for  aboxes  
in particular  it follows that minimal modules  as defined in the work of kontchakov et al        
and konev et al          can in general not be used as a  substitute 
we now show that in eli  and  therefore  also in its fragment el  one can use cq predicate
emptiness in a straightforward way to compute a  substitute w r t  cq  let t be a tbox and  an
abox signature  the cq  core of t   denoted tcq   is the set of all concept inclusions   t such
that no x  sig   is cq predicate empty for  given t  

  

fibaader   b ienvenu   l utz     w olter

theorem    let t be a tbox in eli  then the cq  core of t is a  substitute for t w r t  cq
 and thus also w r t  iq  
proof  let t   be the cq  core of t and assume that t     a     q  a  for some  abox a  consider
the canonical model it    a   introduced in section      then it    a is a model of t   and a  and
it    a     q  a   it is sufficient to show that it    a is a model of t   let c v d  t   t   and
assume that it    a     c v d  then c it    a      let qc  v  be the tree shaped conjunctive
query corresponding to c  constructed in the standard way  see appendix b for a formal definition
of a similar construction   then it    a    v qc  v  and so t     a    v qc  v   hence t   a   
v qc  v  and all x  sig c  are not cq empty for  given t   since c v d  t   we also
obtain t   a    v qd  v   where qd  v  is the tree shaped conjunctive query corresponding to d 
thus  no x  sig d  is cq empty for  given t   but this means that c v d  t     which is a
contradiction 
o
note that by theorem     the cq  core can be computed in polynomial time if t is an el tbox 
we make some simple observations regarding cq  cores 
   theorem    fails in dls that admit negation  for example  for t    a v b  b v e 
and     a   any  substitute of t w r t  cq coincides with t   but the cq  core of t is
empty 
   the cq  core is not always a minimal  substitute w r t  cq  consider  for example  t  
 a v b    a v b    b  v b    and let     a   then t      a v b    a v b    is a
 substitute w r t  cq of t but the cq  core of t coincides with t  
   let the iq  core of tbox t be defined in analogy to the cq  core of t   but based on iqemptiness instead of cq emptiness  then the iq  core cannot serve as a  substitute of t
w r t  iq even when t is an el tbox  for example  let t    a v r b  r b v e  and
    a   then b is iq empty for  given t and so the iq  core of t is empty  however 
the empty tbox is not a  substitute of t w r t  iq since t   a    e a  for a    a a   
interestingly  in contrast to the  modules discussed above  the  modules introduced by grau
et al         turn out to be examples of  substitutes  to define  modules  let  be a signature 
 
 
two interpretations i and i   coincide w r t   if i   i and x i   x i for all x    a
subset t   of a tbox t is called a semantic  module of t w r t   if for every interpretation i the
 
interpretation i   that coincides with i w r t    sig t     and in which x i    for all x    
sig t     is a model of t   t     it is shown in the work of grau et al         that extracting a minimal
semantic  module is of the same complexity as standard reasoning  that is  subsumption   in
addition  it is shown that a syntactic approximation called the syntactic  module can be computed
in polynomial time  every syntactic  module is a semantic  module  but not necessarily the
other way around   the following lemma establishes the relationship between  modules and substitutes  a concept inclusion c v d is tautological if     c v d 
proposition    let t be a tbox formulated in any of the dls introduced in this paper  and let t  
be a semantic  module of t w r t    then
   t   is a  substitute of t w r t  cq 
  

fiq uery and p redicate e mptiness

     sig t     contains all predicates that are not cq empty for  given t  
   if t is an eli tbox and does not contain tautological cis  then the cq  core of t is
contained in t    
proof  for point    suppose t     a     q  a   where t   be a semantic  module of t w r t   and a
is a  abox  let i be a model of t   and a such that i     q  a   and consider the interpretation i  
that coincides with i   on   sig t     and in which x i    for all remaining predicates x  then
i   is a model of t since t   is a semantic  module of t w r t    and i   is a model of a since a
is a  abox  since we only shrank the extension of predicates when transitioning from i to i   and
i     q  a   we have i       q  a   hence t   a     q  a   as required 
for point    assume x is not cq empty for  given t   but x     sig t      suppose x   a
for a concept name a  the case x   r for a role name r is similar and left to the reader   take a
 abox a that is satisfiable w r t  t and such that t   a    v a v   let i be a model of  t   a  
 
and let i   be the interpretation that coincides with i on   sig t     and in which y i    for all
 
remaining y  in particular we have ai      by definition of semantic  modules  i   is a model
of  t   a   we have derived a contradiction because i   shows that t   a     v a v  
for point    assume t is formulated in eli and contains no tautological inclusions  let c v
d  t   t     then  by the definition of semantic  modules  sig c v d  contains a predicate
x     sig t      because otherwise c v d is a tautology   thus  by point    sig c v d 
contains a predicate that is cq empty for  given t   but then c v d is not in the cq  core of t  
as required 
o
by point    we can use the algorithms for computing syntactic or semantic  modules such as the
ones provided in the work of grau et al         to find  substitutes in a large variety of dls 
by point    such modules also provide an over approximation of the set of predicates that are not
cq empty  finally  point   means that  in eli   modules cannot be smaller than the cq  core
unless there are tautological concept inclusions  in general  however   modules can be larger than
the cq  core of a tbox  the following example shows that this can be the case already for acyclic
el tboxes  let
t    a v s   r     u s   r      b  r     u r     
and     a   the predicates that are not cq empty for  given t are a  s    s    r    r    hence the
cq  core of t contains only the first ci of t   however  t has no non trivial semantic  modules
w r t    and thus no syntactic ones either  
we now demonstrate the potential usefulness of  substitutes and the cq  core by extending
our case study from the medical domain  we again use the ontology snomed ct and the abox
signatures described at the beginning of this section  analyzing the size of the cq  core and comparing it to the size of the original ontology and of the syntactic  module  for the real world
signature  cq  core contains        of the         concept inclusions in snomed ct  thus  it
is of about    the size of the original ontology  the  module w r t   turns out to be significantly
larger than the cq  core  containing        axioms  for the random signatures  the sizes of cq cores and  modules are shown in the two right most columns of figure    they again confirm the
findings for the real world signature  the cq  core is much smaller both than the original ontology
and than the  module 
  

fibaader   b ienvenu   l utz     w olter

q uery c ontainment

q uery e mptiness

dl

iq

cq

iq

cq

el

e xp t ime c 

e xp t ime c 

pt ime c 

pt ime c

el

e xp t ime c 

e xp t ime c 

e xp t ime c 

e xp t ime c

eli  horn alcif

e xp t ime c 

 e xp t ime c 

e xp t ime c 

e xp t ime c 

in pt ime

conp c 

nl og s pace c 

conp c 

conp c 

p   c 

conp c 

conp c 

ne xp t ime c 

ne xp t ime h  

ne xp t ime c 

ne xp t ime c 

ne xp t ime c 

 e xp t ime c 

dl litecore
dl litehorn
alc

in  ne xp t ime
alci

ne xp t ime c 

 ne xp t ime c 

figure    query containment vs query emptiness

   related work
query emptiness is a fundamental problem in the static analysis of database queries  it is also
called the query satisfiability problem  for xml  for example  it takes the following form  given
an xpath query p and a dtd d  does there exist an xml document t such that t conforms to
d and the answer of p on t is non empty  the complexity of this problem ranges from tractable
to undecidable depending on the xpath fragment  see e g  the work of benedikt et al         and
references therein  in a dl context  query emptiness has been first considered in the work of lubyte
and tessaris         who use it as a step to guide the enrichment of ontologies 
the query emptiness problem studied in this paper is a special case of the following query
containment problem  first considered in the work of bienvenu  lutz  and wolter         we can
regard a pair  t   q  which consists of a tbox t and a query q as a compound query q  called an
ontology mediated query  omq   such that the answers to q are the certain answers to q w r t  t
 bienvenu et al          now take two omqs qi    ti   qi    i          such that q  and q  are iqs
or cqs of the same arity  then q  is  contained in q    for an abox signature   if for all aboxes a that are satisfiable w r t  t  and t    we have certt   a  q     certt   a  q     in this case  we
write q   q    this notion of containment generalizes the more traditional query containment
problem in dls  calvanese et al         by relativizing it to an abox signature and admitting
distinct tboxes t  and t    query emptiness of an iq q for  given t can clearly be polynomially
reduced to  containment by setting t    t   q    q  t      and q    a x  for a fresh concept
name a  and similarly for cqs  deciding  containment  however  is often computationally harder
than deciding query emptiness  table   summarizes known results  the results about el and dllite are from the work of bienvenu et al          the results about eli from the work of bienvenu 
hansen  lutz  and wolter         and the results about alc and alci from the work of bienvenu
et al         and bourhis and lutz        
query emptiness is also closely related to explaining negative answers to queries  this problem
was studied  for example  by calvanese  ortiz  simkus  and stefanoni         adopting an abductive reasoning approach  it can be described as follows  assume t   a     q  a  for a tbox t   abox
a  and query q  to explain that  a is not an answer to q  one wants to find minimal aboxes e over
  

fiq uery and p redicate e mptiness

a certain signature  of interest such that a  e is satisfiable w r t  t and t   a  e    q  a   such
 aboxes e are then regarded as an explanation for the missing answer and can be used for debugging purposes  it is shown in the work of calvanese et al         that query emptiness of iqs and
boolean cqs reduces  under many one logarithmic space reductions  to the problem of deciding the
existence of an explanation for t   a     q  a  with a     for dl litea   the reduction even works
for unions of conjunctive queries of any arity  calvanese et al         use this observation to obtain
lower complexity bounds for explaining negative query answers  exploiting the results published
in the conference predecessor of this paper  baader  bienvenu  lutz    wolter         they also
conjecture that  conversely  techniques for proving upper complexity bounds for query emptiness
 such as the ones in this paper  can be used to obtain upper bounds for explaining negative answers 

   conclusion
we have investigated the computational complexity of query and predicate emptiness in the el 
dl lite  and alc families of dls  concentrating on instance queries and conjunctive queries and
showing that complexities range from nl og s pace to undecidable  we have also highlighted that 
for different dls and query languages  different kinds of witness aboxes are sufficient to establish
non emptiness  dls and queries that are not considered in this paper  but which would be interesting
to investigate in future work  include the following 
 dls that include transitive roles  role inclusions  symmetric roles  or role inclusion axioms
 horrocks  kutz    sattler        kazakov        
in some cases  straightforward reductions to results presented in this paper are possible  for
example  iq query emptiness in horn shif is decidable in e xp t ime since for every
horn shif tbox t   iq a x   and abox signature   one can construct in polynomial
time a horn alcif tbox t   such that t   a    a a  iff t     a     a a  for all  aboxes
a  hustadt et al         kazakov         in other cases  such as cq query emptiness in
horn shif  there seems to be no such reduction 
 dls that include nominals 
 other important classes of queries such as unions of conjunctive queries  ucqs  
for materializable dls such as horn alcif 
w ucq query emptiness can be reduced to cq
query emptiness since for every ucq q   ii qi   x   we have t   a    q  a  iff there is an
i  i such that t   a    qi   a   such a simple reduction does not work for non horn dls such
as alc 
it would also be interesting to develop practical algorithms for emptiness and to evaluate these algorithms on real world ontologies and queries  note that our algorithms for el and dl lite are
easily implementable and efficient as presented in this paper  this was actually confirmed by the
case study in section    more work will be required to design efficient algorithms for more expressive dls  finally  it would be relevant to investigate the notion of a  substitute introduced
in our application to modularity in more detail  for example  it is an open question how to compute minimal  substitutes in expressive dls such as alc in practice  and what are the involved
complexities 
  

fibaader   b ienvenu   l utz     w olter

acknowledgements
the first author was partially supported by cfaed  center for advancing electronics dresden  and
the second author was partially supported by the anr project pagoda  anr    js           
we are grateful to julian mendez and dirk walther for supporting us in the case study  we would
like to thank the anonymous reviewers who provided excellent comments that helped us to improve
the paper 

appendix a  proofs for section  
we formulate the result to be proved again 
lemma   let t be an alcif tbox  then each cq q is empty for  given t with the una iff
it is empty for  given t without the una 
proof  consider a cq q with answer variables v            vn  
 only if  assume that q is non empty for  given t without the una  then there is a abox a such that a is satisfiable w r t  t without the una and certt  a  q      without the una 
take a model i of a and t and suppose without loss of generality that i is infinite  define
an equivalence relation  over ind a  by setting a  b whenever ai   bi   choose a single
representative from each equivalence class  and denote by a the representative of the equivalence
class containing a  let a  be the abox obtained from a by replacing each individual a by a   we
show that a  is satisfiable w r t  t with the una and that certt  a   q      with the una 
regarding satisfiability  it is easy to see that i is a model of  t and  a  and that it satisfies the
una for the individuals appearing in a    moreover  since i is infinite  we can reinterpret the
individual names in ni   ind a    to obtain an interpretation that is a model of a  and t and satisfies
the una 
now for showing certt  a   q      with the una  take some  a            an    certt  a  q  without
the una  we aim to show that  a            an    certt  a   q   let j   be any model of t and a  that
 
satisfies the una  we have to show that there is a match for q in j   with  vi      ai  j for every
 
   i  n  consider the interpretation j obtained from j   by setting aj    a  j for every
a  ind a   it is easy to see that j is a model of a and t without the una  so j    q a            an  
and there is a match  for q in j such that  vi     aj
i for every    i  n  then  is also the
desired match for q in j     which finishes the proof 
 if  assume that q is non empty for  given t with the una  then there is a  abox a
such that a is satisfiable w r t  t with the una and certt  a  q      with the una  clearly  a is
also satisfiable w r t  t without the una and it remains to show that certt  a  q      without the
una  let  a            an    certt  a  q  with the una  and let i be any model of a and t without
the una  we have to show that i    q a            an    for any a  ind a   let ia be the following
unfolding of i at ai  
 the domain ia of ia consists of all words d  r  d     rk  dk with d            dk  i and
r            rk   potentially inverse  roles such that d    ai    di   di      rii for all i   k 
ri    ri   for functional ri   and i   k  and r   a  b    a for any b  ind a  if r  is
functional 
 aia    d  r  d     dk   dk  ai   for all a  nc  
  

fiq uery and p redicate e mptiness

 ria     d  r  d     dk   d  r  d     dk rk   dk       r   rk     
  d  r  d     dk rk   dk     d  r  d     dk     r   rk     for all r  nr  
assume that the ia are mutually disjoint and let the individual name a be the root of ia   then we
obtain the interpretation j by taking the disjoint union of all ia   a  ind a   adding  a  b  to rj
whenever r a  b   a  and setting aj   a for all a  ind a   one can show that j is a model of a
and t with the una  thus j    q a            an   and there is a match  for q in j with  vi      ai  j
for every    i  n  it can be verified that    defined by setting     vi     ai if  vi     a  ind a 
and     vi     dk if  v    d            dk with k    is a match of q in i  thus i    q a            an    as
required 
o

appendix b  proofs for section  
we restate the first result to be proved 
theorem    in alc  cq query emptiness is in ne xp t ime 
the general idea for proving theorem    is as follows  given an alc tbox t   a signature  
and a cq q  by theorem    it suffices to test whether t   at       q  we thus start by computing at     to check whether t   at       q  we then guess an extension of t with a set t   of
concept inclusions and an extension of at   with a set a  of abox assertions such that t   and a 
that are satisfied only in models of t and at   in which q has no match  subsequently  it remains to
test the satisfiability of at    a  w r t  t  t     the subtlety lies in selecting the class of extensions
to be guessed from in a careful enough way so that the final satisfiability check can be carried out
in ne xp t ime 
we reuse some technical definitions and results from the work of lutz        who proves that
the combined complexity of cq answering in the dl shq is in e xp t ime  the definitions are
slightly modified since lutz considers only cqs without answer variables and uses the dl shq 
of which alc is a proper fragment  however  it is straightforward to verify that the proofs given
by lutz also work with our modified definitions 
a cq q can be viewed as a directed graph gdq    vqd   eqd   with vqd   var q  and eqd  
  v  v       r v  v      q for some r  nr    we call q directed tree shaped if gdq is a directed tree and
r v  v      s v  v      q implies r   s  if q is directed tree shaped and v  is the root of gdq   we call v 
the root of q  for u  var q   we write q u to denote the restriction of q to atoms that contain only
variables from u   the set dtrees q  of directed tree shaped subqueries of q is defined as follows 
dtrees q     q u   u   reachq  v   v  var q   q u is directed tree shaped 
where reachq  v  is the set of variables that are reachable from v in gdq   we say that
 q   is obtained from q by performing fork elimination if q   is obtained from q by selecting two
atoms r v     v  and s v      v  such that v     v      v  qvar q  and v      v      and identifying v  
and v     
 q   is a fork rewriting of q if q   is obtained from q by repeatedly  but not necessarily exhaustively  performing fork elimination 
  

fibaader   b ienvenu   l utz     w olter

 q   is a maximal fork rewriting of q if q   is a fork rewriting and no further fork elimination is
possible in q    
the following is shown in the work of lutz         and it plays a central role in the subsequent
definitions 
lemma    up to variable renaming  every cq has a unique maximal fork rewriting 
the following definitions of splittings and spoilers are also taken from the work of lutz  to understand a splitting of a cq q on an intuitive level  it is useful to consider matches of q in a model i of a
tbox t and abox a that has a special shape  i consists of a core part whose elements are exactly
 the interpretations of  the abox individuals in a and of tree shaped parts that are attached to the
element in the core part and disjoint from each other  in fact  it is proved by lutz that if t   a     q 
then there is a model i of t and a of the described shape such that i     q  a match of q in a model
of the described shape partitions the variables in q into several sets  a set r which contains the variables that are matched to an abox individual  sets s            sn which represent disjoint tree shaped
subqueries of q that are matched into a tree part of i and whose root is connected to some variable
in r via a role atom in q  and a set t which represents a collection of tree shaped subqueries of
q that are disconnected from the variables in r and si   in addition to this partitioning  splittings
record the variable in r to which each set s            sn is connected and the abox elements that the
variables in r are mapped to  we now define splittings formally 
let k    t   a  be an alc knowledge base and q a cq  a splitting of q w r t  k is a tuple   
hr  t  s            sn     i  where r  t  s            sn is a partitioning of var q                  n   r
assigns to each set si a variable  i  in r  and    r  ind a  assigns to each variable in r an
individual in a  a splitting has to satisfy the following conditions 
   the cq q t is a variable disjoint union of directed tree shaped queries 
   the queries q si      i  n  are directed tree shaped 
   if r v  v      q  then one of the following holds   i  v  v   belong to the same set r  t  s            sn
or  ii  v  r   i    v  and v    si is the root of q si  
   for    i  n  there is a unique r  nr such that r  i   v     q  with v  the root of q si  
   avar q   r 
let q be a directed tree shaped cq  we define an alc concept cq v for each v  var q  
 if v is a leaf in gdq   then cq v  
 otherwise  cq v  

u

a v q

au

u c 
u r c

a v q

r v v    q

q v    

if v is the root of q  we use cq to abbreviate cq v  
in the following  we allow compound concepts and negated roles to be used in abox assertions  the semantics of such assertions and corresponding kbs is defined in the expected way  an
interpretation i satisfies c a  if ai  c i and i satisfies r a  b  if i does not satisfy r a  b  
let    hr  t  s            sn     i be a splitting of q w r t  k such that q            qk are the  directed
tree shaped  disconnected components of q t   an alc knowledge base  t     a    is a spoiler for q 
k  and  if one of the following conditions hold 
  

fiq uery and p redicate e mptiness

     v cqi  t     for some i with    i  k 
   there is an atom a v   q with v  r and a  v    a   
   there is an atom r v  v      q with v  v    r and r  v    v       a   
   d   i     a  for some i with    i  n  and where d   r cq s with v  root of q si
i
and r  i   v     q 
we call k  a spoiler for q and k if  i  for every fork rewriting q   of q  and every splitting  of q  
w r t  k  k  is a spoiler for q     k  and   and  ii  k  is minimal with property  i   the following
result is proved in the work of lutz        
theorem    let k    t   a  be an alc knowledge base and q a cq  then k     q iff there is a
spoiler  t     a    for q and k such that a  a  is satisfiable w r t  t  t    
the following lemma  which was observed by lutz  plays a central role for obtaining a ne xp t ime
decision procedure 
lemma    let k    t   a  be an alc knowledge base  q a cq  q  its maximal fork rewriting 
and k     t     a    a spoiler for q and k  then k  contains only concept inclusions and abox
assertions of the following form 
     v cq  with q    dtrees q    
   a a  with a  ind a  and a occurring in q 
   r a  b  with a  b  ind a  and r occurring in q 
   d a  with a  ind a  and d   r cq    where r occurs in q and q    dtrees q    
note that while the definition of a spoiler for q and k refers to all fork rewritings of q  of which
there are exponentially many  lemma    only refers to the unique maximal form rewriting q    in
fact  since the cardinality of dtrees q    is clearly bounded by the size of q  the number of concept
inclusions and assertions listed in lemma    is only polynomial in the size of a and q 
we are now set up for the proof of theorem     by theorems    and     a cq q is empty for a
signature  given a tbox t iff there is a spoiler  t     a    for q and  t   at     such that at    a 
is satisfiable w r t  t  t     given a cq q  signature  and tbox t   we can thus decide emptiness
of q for  given t as follows 
   compute at    
   guess a tbox t   and an abox a  that satisfy conditions   to   from lemma    for the kb
k    t   at     and such that there is no role assertion r a  b   at   with r a  b   a   
   verify that  t     a    is a spoiler for q and  t   at     
   verify that at    a  is satisfiable w r t  t  t    
  

fibaader   b ienvenu   l utz     w olter

it remains to argue that this yields a ne xp t ime algorithm  as already noted  step   can be carried
out in  deterministic  exponential time  due to conditions   to   from lemma    and since at  
is of size at most exponential in t and   the tbox t   and abox a  guessed in step   are of
size at most exponential in t and   and of size polynomial in q  step   can be implemented by
a straightforward iteration over all fork rewritings q   of q and splittings  of q   w r t   t   at     
which requires only exponential time 
it thus remains to deal with step    let  be the closure under single negations of the union of
the following sets of concepts 
   nc  
 all concepts that occur in t  possibly as subconcepts  
 all concept names that occur in q 
 all concepts cq and r cq and their subconcepts  where q  dtrees q     q  the maximal fork
rewriting of q  and r occurs in q 
based on the remark after lemma     it is easy to verify  and crucial for our argument  that   
is polynomial in   t   and q  a  type is a set t   such that for some model i of t  t  
and some d  i   we have t    c     d  c i    as in section    we introduce a notion of
coherence between types  we say that the pair of  types  t  t    is r coherent  denoted t  r t    if
for all r c    c  t  implies r c  t  the set t of all  types can be computed in e xp t ime 
to verify satisfiability of at    a  w r t  t  t     we guess a map    ind at      t   accept
if the following two conditions are satisfied and reject otherwise 
 i  c c   at    a  implies c   c  and
 ii  r b  c   at    a    c   c   and r c   imply r c   b  
clearly  checking whether these two conditions are satisfied can be done in single exponential time 
it thus remains to argue that at    a  is satisfiable w r t  t  t   just in the case that there exists a
map  verifying these conditions  first note that given a model i of the kb  t  t     at    a    
we can define the desired map by setting  c     c     ci  c i    conversely  given a map 
satisfying conditions  i  and  ii   we define an interpretation i as follows 
i   t

ai    t  t   a  t 

ri     t  t     t  t   t  r t   

ci    c 

it is readily verified that for all c   and t  t   we have c  t iff t  c i   from this  we can
show  using a similar argument to that given in lemma     that i is a model of  t t     at   a    
we now complete the proof of our undecidability result  theorem     by proving lemma    
lemma     t  h  v   admits a tiling iff there is a  abox a that is satisfiable w r t  t and such
that t   a    v a v  
proof   only if  straightforward  consider a tiling f               n               m   t for
 t  h  v    create individuals ai j for    i  n and    j  m  and consider the abox a
composed of the following assertions 
  

fiq uery and p redicate e mptiness

 x ai j   ai   j   for    i   n and    j  m
 x  ai   j   ai j   for    i   n and    j  m
 y ai j   ai j     for    j   m and    i  n
 y   ai j     ai j   for    j   m and    i  n
 th  ai j   if f  i  j    th  
it can easily be verified that a is satisfiable w r t  t and satisfies t   a    v a v  
 if  let a be a  abox satisfiable w r t  t and such that t   a    v a v   we first show that
ix and iy enforce that x is the inverse of x and y  is the inverse of y  respectively  and that c
forces relevant grid cells to be closed  for r   x  y  we call a  ind a  an r defect if there exists
b  ind a  such that r a  b   a and r  b  a    a  we call a an inv defect if it is an x defect or
a y defect  we call a  ind a  a cl defect if there exist x a  b   y a  c   y b  d   x c  e   a with
d    e such that a is not an inv defect  b is not a y defect and c is not an x defect 
claim    there exists a model i of t and a such that for all a  ind a  
 d   ai   iri   for all r defects a  ind a  and r   x  y  
 d   ai   c i   for all cl defects a  ind a  
moreover  i satisfies the following conditions for all a  ind a   role names r  and h              p  
   i   ind a  
   ai   a 
    a  a     ri implies r a  a     a 
   a  thi implies th  a   a 
proof of claim    let r   x  y   call a two element set  a  b  a r defect witness if there exists
c  ind a  such that r a  c   r  c  b   a  consider the undirected graph g with nodes ind a 
and the set of r defect witnesses as its edges  note that g has degree at most two  since r and r are
functional   hence g is three colorable  choose a three coloring of g with colors br     zr   uzr    
br     zr   u zr   and br     zr   u zr  
of the concept names
sand choose the interpretation
i

i
zr     zr   in i correspondingly  we set ir   i        br i u r r  br i    
call a two element set  d  e  a cl defect witness if there exist x a  b   y a  c   y b  d   x c  e  
a such that a is not an inv defect  b is not a y defect and c is not an x defect  consider the undirected
graph g with nodes ind a  and the set of cl defect witnesses as its edges  note that g has degree at
most two  again since x  x   y  and y  are all functional   hence g is three colorable with colors
c    zc   u zc     c    zc   u zc   and c    zc   u zc   and we
s can choose the interpretation of
the concept names zc     zc   in i correspondingly  we set c i   i        x y ci u y x ci  i  
since neither existential restrictions nor the concept names th occur in the right hand side of
cis in t   it is not hard to verify that we can interpret the remaining concept names in t in such a
way that the additional conditions on i are satisfied   end of proof of claim 
  

fibaader   b ienvenu   l utz     w olter

let i be a model satisfying the conditions of claim    we additionally assume w l o g  that i
is a  y  minimal  there is no model j of t and a satisfying the conditions of claim   such that
aj  ai and y j  y i and at least one of these inclusions is proper 
let aa  ai   we now exhibit a grid structure in a that gives rise to a tiling for  t  h  v    we
start by identifying a diagonal that starts at aa and ends at an instance of tfinal  
claim    there is a set g    r   ai   j    ai   j             rk   aik   jk  aik  jk    tfinal  aik  jk     a such
that
 i       j       and a      aa  
 for        k  we either have  i  r    x  i      i       and j      j  or  ii  r    y 
j      j       and i      i   
proof of claim  if there is no such sequence  we can convert i into a new model j of t and
a by interpreting y as false at all points reachable in i  equivalently  a  from aa and setting
aj   ai    aa    which contradicts the a  y  minimality of i   end of proof of claim 
let n be the number of occurrences of the role x in the abox g from claim   and m the number of
occurrences of y  we next show
claim    we have that
i  
 a  a     tinit

 b  ai j  ri implies i   n 
 c  ai j  u i implies j   m 
 d  ai j  y i for all ai j  ind g  
 e  for all ai j  ind g   there is a  unique  th with ai j  thi   henceforth denoted ti j  
 f   ti j   ti   j    h for all ai j   ai   j  ind g  and  ti j   ti j      v for all ai j   ai j   
ind g  
proof of claim  point  a  is an easy consequence of the fact that a      aa   aa  ai   and i is
a  y  minimal  for  b   first note that there is a unique    k such that is   n for all s              k 
and is   n for all s                     due to the ci r v x   ai    j   
  ri   to show that
i
ais  js 
  r for all s         it suffices to use the cis r v x  and r v y r  the proof of
 c  is similar  we prove  d   f  together  showing by induction on   that  d   f  are satisfied for all
initial parts
g      r   ai   j    ai   j             r    ai    j   ai   j    
of g  with    k  for the base case  ai   j    aa  ai clearly implies ai   j   y i   thus  d 
is satisfied  point  e  follows from  a  and the disjointness of tiles expressed in t   point  f  is
vacuously true since there is only a single individual in g    for the induction step  assume that g  
satisfies  d   f   we distinguish four cases 
 ai    j     u u r i  
  

fiq uery and p redicate e mptiness

since g   satisfies  d   we have ai    j    y i   and the definition of t and the a  y minimality of i together with the fact ai    j     u u r i ensure that
ai    j     x  tg u y u y y   u y  th u y u x y   u ix u iy u c u tf  i
for some  tf   tg    h and  tf   th    v   using the functionality of x and y  it is now easy
to show that g  satisfies  d   f  
 ai    j     u u r i  
since ai    j    ri   t ensures that there is no x successor of ai    j   in i  moreover 
ai    j    y i   together with the definition of t   we get
ai    j     y  tg u y u r  u iy u tf  i
for some  tf   tg    v   we must have i    i     j    j        and r     y  using the
functionality of y  it is now easy to show that g  satisfies  d   f  
 ai    j     u u r i  
analogous to the previous case 
 ai    j     u u r i  
then there is neither an x successor nor a y successor of ai    j     u u r i   it follows
that        k  in contradiction to    k 
 end of proof of claim 
next  we extend g to a full grid such that conditions  a   e  from claim   are still satisfied  once
this is achieved  it is trivial to read off a solution for the tiling problem  the construction of the grid
consists of exhaustive application of the following two steps 
   if x ai j   ai   j    y ai   j   ai   j      g and there is no ai j    ind g  with y ai j   ai j     
g and x ai j     ai   j      g  then identify an ai j    ind a  such that y ai j   ai j      a
and x ai j     ai   j      a and add the latter two assertions to g 
   if y ai j   ai j      x ai j     ai   j      g and there is no ai   j  ind g  with x ai j   ai   j   
g and y ai   j   ai   j      g  then identify an ai   j  ind a  such that x ai j   ai   j    a
and y ai   j   ai   j      a and add the latter two assertions to g 
it is not hard to see that exhaustive application of these rules yields a full grid  i e   for the final g
we have  i  ind g     ai j   i  n  j  m    ii  x ai j   ai   j      g iff i    i     and j   j     and
 iii  y ai j   ai   j      g iff i   i  and j     j     
since the two steps of the construction are completely analogous  we only deal with case  
in detail  thus let x ai j   ai   j    y ai   j   ai   j      g with ai j   
  ind g   clearly  i   n
and j   m  by  b  and  c   we thus have ai j 
   r t u  i   since ai j  y i by  d  and i is
a  y  minimal  we get that
ai j   x  tg u y u y y   u y  th u y u x y   u ix u iy u c u tf  i
for some  tf   tg    h and  tf   th    v   this together with the minimality of i means we can
select ai j     b  ind a  such that y ai j   ai j      x ai j     b   a  ai j     b  y i   and ti j    
  

fibaader   b ienvenu   l utz     w olter

th   with this choice   a    d    e   and the second half of  f  are clearly satisfied  to get the properties
required by step   above  we have to show that b   ai   j     if we can show this  then the
satisfaction of  b  and  c  before we apply the construction step  and the cis
r v x  r v y r

u v y  u v x u

ensure that  b  and  c  are still satisfied after the construction step  showing b   ai   j   will also
give us the first half of  f   finally  to prove that b   ai   j   it is sufficient to show that ai j is not
a cl defect in ind a   but this follows from claim   since ai j  c i   ai j  ixi  iyi   ai   j  iyi  
and ai j    ixi  
we can now use the completed grid to build a solution to our tiling problem  the tile at point
 i  j  is the unique tile which is satisfied by i at ai j  ind a   property  f  of claim   and the
correctness of our grid construction ensure that adjacent tiles satisfy the vertical and horizontal
constraints 
o

appendix c  proofs for section  
theorem     in el  cq query emptiness can be decided in pt ime 
proof  by lemma     it suffices to show that for any n ary cq q and alphabet   it can be decided
in pt ime whether t   a    q a           a   where a is the total  abox  first note that we have
t   a    q a           a   iff t   ab    qb  where
 ab is obtained from a by adding the assertion x a    where x is a concept name that
does not occur in   t   and q 
 qb is the boolean cq obtained from q by adding the conjunct x v  for each answer variable v
and then quantifying away all answer variables 
recall from the discussion before lemma    that every cq q can be viewed as a directed graph
gdq   we say that a boolean cq q is directed forest shaped if it is a disjoint union of directed treeshaped boolean cqs  every boolean cq q that is directed forest shaped corresponds to a concept
cq in the description logic elu that extends el with the universal role u such that t   a    q iff
t   a    c a  for all a  ind a   lutz   wolter         checking the latter condition is possible in
pt ime  lutz   wolter         thus  it is sufficient to convert qb in polynomial time into a directed
forest shaped cq qb  such that t   ab    qb iff t   ab    qb   
to construct qb  from qb  we exhaustively apply the following rewriting rules 
   if r v  v      and r v     v      are in the query  then identify v and v   by replacing all occurrences
of v   with v 
   if r v     v  and s v      v  are in the query  with r    s   then identify v  v     and v    by replacing
all occurrences of v   and v    with v 
   if a cycle r   v    v             rn   vn    vn    vn   v  is in the query and  v            vn    contains
at least two variables  then identify all variables v            vn  by replacing all occurrences of
v            vn  with v   
  

fiq uery and p redicate e mptiness

if the resulting query contains a reflexive loop r v  v  with r 
    then we immediately return
no  otherwise  we replace in a final step each reflexive loop r v  v  with r   with x v   the
query resulting from this last step is qb    it is easy to see that the query obtained at this point is
directed forest shaped since every variable has at most one predecessor and there are no cycles in
the corresponding directed graph 
to prove correctness of this algorithm  we first establish the following claim 
claim  if qb  is defined  then t   ab    qb iff t   ab    qb   
it suffices to prove that each rule application preserves  non entailment of the query by t and ab  
as a preliminary  we recall that  as shown by lutz and wolter         there exists a materialization
jt  ab of  t   ab   which is a directed tree shaped interpretation with the individual a as its root
and  potentially  additional reflexive loops added to this root  an interpretation is directed treeshaped if the corresponding cq in which the domain elements of the interpretation are regarded as
variables is directed tree shaped   assume that rewriting rule   is applied to a query p resulting in
a query p    it is clear that t   ab    pb  implies t   ab    pb  for the converse  assume t   ab    pb
and let jt  ab be the materialization of t and ab introduced above  then there is a match of p
in jt  ab   since jt  ab does not contain domain elements d  d    d   with d    d  and such that for
j

j

some role name r   d  d      r t  ab and  d    d      r t  ab   this match of p in jt  ab must map the
identified variables v and v   to the same domain element and is thus also a match of p    the other
two rules and the replacement of r v  v   r    with x v  can be dealt with in a similar way 
by the claim  we can substitute qb with qb  as intended  moreover  it is easy to see that we have
t   ab     qb if the algorithm returns no due to a reflexive loop r v  v  with r 
    simply use the
interpretation jt  ab as in the proof of the claim 
o
proposition     for every horn alcif tbox t   abox signature   and cq q  one can construct
in polynomial time an elif   tbox t   in normal form such that q is empty for  given t iff q is
empty for  given t    
proof  the proof is similar to reductions provided in in the work of hustadt et al         and
kazakov         nevertheless  because kazakov considers reductions preserving subsumption only 
and because hustadt  motik  and sattler and also kazakov do not reduce to elif  tboxes  we
give a detailed proof 
the following rules can be used to rewrite t into an elif   tbox in normal form  all freshly
introduced concept names are not in sig t      sig q   assume l v r is given 
 if l is of the form l  u l  and r is not a concept name  then take a fresh concept name a
and replace l v r by l v a and a v r  if r is a concept name  and either l  or l  are
not concept names  then take fresh concept names a    a  and replace l v r by l  v a   
l  v a  and a  u a  v r 
 if l is of the form l  t l  and r is a concept name  then replace l v r by l  v r and
l  v r  otherwise take a fresh concept name a and replace l v r by l v a and a v r 
 if l is of the form r l  and l  is not a concept name  then take a fresh concept name a  and
replace l v r by l  v a  and r a  v r 
 if r is of the form a  then replace l v r by l u a v  
  

fibaader   b ienvenu   l utz     w olter

 if r is of the form r  u r  and l is not a concept name  then take a fresh concept name a
and replace l v r by l v a and a v r  otherwise take fresh concept names a    a  and
replace l v r by l v a    l v a    a  v r    and a  v r   
 if r is of the form l  t r    then replace l v r by l u l  v r   
 if r is of the form r r  and r  is not a concept name  then take a fresh concept name a  and
replace l v r by l v r a  and a  v r   
 if r is of the form r r    then replace l v r by r  l v r 
the resulting tbox t   is as required  in particular  for every  abox a and model i of a and t    
we have that i is also a model of t   conversely  every model i of a and t can be extended
to a model of t by appropriately interpreting the fresh concept names  consequently  we have
certt  q  a    certt    q  a  and thus q is empty for  given t iff q is empty for  given t    
o
proposition     let t be an elif   tbox   an abox signature  and q a cq  if q is non empty
for  given t   then this is witnessed by a  abox that is forest shaped  has width at most  q   and
degree at most  t   
proof  assume that q has answer variables v            vn and is non empty for  given t   then we
can find a  abox a that is satisfiable w r t  t and such that certt  a  q       to identify a forestshaped witness for the non emptiness of q for  given t   consider the canonical model it  a of
 t   a   by construction  it  a consists of an abox part i    which is the restriction of it  a to
ind a   and tree shaped interpretations ia   a  ind a   rooted at a and containing no other abox
individuals  since it  a is universal  there is a match  of q in it  a   let i consist of all individuals
a  ind a  such that there is some v  var q  with  v  in ia  possibly  v    a   let a  be
the abox obtained by restricting a to the individuals in i   this is going to be the root component
of the forest shaped witness we are seeking to define  observe that  ind a       q    to add the
tree components  we consider  for each a  i   the  typically infinite  tree shaped abox aua that is
obtained by unraveling a starting from a  as in the work of lutz and wolter        
 ind aua   is the set of sequences    c  r  c        rm  cm with c            cm  ind a  and
r            rm   possibly inverse  roles such that  i  c    a   ii  c    i    iii  rj  cj    cj    a

for all    j   m  and  iv   cj    rj 
      cj     rj   for j      we say that  is a copy
of cm  
 if a c   a and   ind aua   is a copy of c  then a    aua  
 if   ind aua   is a copy of c  and    rc   ind aua    then r      aua  
 if   ind aua   is a copy of c  and    r c   ind aua    then r      aua  
we let ab be the union of a  and the tree shaped aboxes  aua   a  i    observe that by conditions
b note
 ii  and  iv  of the first item and since a satisfies all functionality statements in t   so does a 
b
that a is forest shaped  but need neither be finite nor of degree at most  t    we are going to fix this
later 
we next aim to show that ab is satisfiable w r t  t and that certt  ab q       to this end  we
construct a universal model j of ab and t   start with ab viewed as an interpretation j    as in
  

fiq uery and p redicate e mptiness

the construction of canonical models  then take  for each a  ind a  and each of as copies  
b a copy i of the tree interpretation ia such that  i  the root of i is    ii  j  i      
ind a  
 iii       implies disjointness of i and i   and  iv  if    a then i is identical to the original
tree interpretation ia  and not a copy   if d   i is the result of renaming d  ia   then d  is
called a copy of d  the desired interpretation j is obtained by taking the union of j  and all i  
note that every element of j is the copy of an element in it  a   and that  by construction  j is a
b
model of a 
it is straightforward to show by induction on the structure of c that for every eli concept c
and every element e  j that is a copy of d  it  a   e  c j iff d  c it  a   since it  a is a
model of t   it follows that j is a model of t and thus ab is satisfiable w r t  t   we only sketch the
proof that j is universal  let i be a model of ab and t   we start to define a homomorphism h  from
b it remains to extend h  to the i components of
j to i by setting h   a    ai for all a  ind a  
j   each such i is a copy of a tree interpretation ia in it  a such that  is a copy of a  it is shown
in the work of lutz and wolter        that 
b is a copy of a  ind a   then a  ait  a implies t   ab    a   for all concept
   if   ind a 
names a 
recall that it  a was generated by the derivation rules for building canonical models  using a
straightforward induction on the number of rule applications and exploiting    and the fact that
t is in normal form  one can construct a homomorphism ha from ia to i such that h a    i  
by renaming  we obtain a homomorphism h from i to i such that h      i   the desired
homomorphism h is the union of h  and all h   we have thus established that j is universal  going
through the construction of j  and in particular using point  iv    it can be verified that the match 
of q in it  a is also a match of q in j   since j is universal  this yields certt  ab q      as desired 
we now want to remove individuals from ab such that the resulting abox is of degree at most  t  
and still witnesses non emptiness of q for  given t   since j is universal  there is a homomorphism h from j to the canonical model it  ab  composing the match  with h  we obtain a match 
of q in it  ab that sends every variable to an individual in a  or to an element of a tree below such an
individual  we inductively mark individuals in ab that are relevant for the match    starting with all
individuals in a  and then proceeding as follows  whenever rule   or   adds a marked individual
x to ait  ab during the construction of it  ab because of the presence of  x  y   rit  a  please see
the formulation of the mentioned rules   then mark y  it can be verified that every individual outside
of a  has at most one marked neighbor for each existential restriction in t   the  potentially infinite  forest shaped abox abd obtained from ab by dropping all assertions that involve at least one
unmarked individual is thus of degree at most  t    moreover  the marking construction ensures that
the canonical model it  abd contains a  and each interpretation ia   a  ind a     hence  is a match
for q in it  abd  
at this point  the abox abd is almost the required forest witness  except that it may be infinite 
it remains to invoke compactness to obtain a finite subset abf  abd such that certt  abf  q      
clearly  abf contains a forest witness for the non emptiness of q for  given t  
o
   lutz and wolter        actually show this for the case where the root component a  of ab from which we start to
unravel consists of all the individual names in a  but contains no concept and role assertions  the proof also goes
through in our case 

  

fibaader   b ienvenu   l utz     w olter

the following lemmas establish the two statements in lemma    
lemma    every canonical proper r  n  labeled tree is well founded 
proof  let ht   i be a canonical proper r  n  labeled tree  and let i    i          be the interpretations encountered during the construction of the canonical model of t and aht  i   since ht   i is
canonical  iht  i is the canonical model of aht  i and t  
we will slightly abuse terminology by using the term concept atom to refer to statements of the
form b e  where b is a concept name  or    and e is a domain element  a role atom will take the
form r e  e    with r a role and e  e  domain elements  we will say that a concept atom b e   resp 
role atom r e  e     is in an interpretation j if e  b j  resp   e  e     rj    for each atom  in
iht  i   the rank of  is the smallest i such that  is in ii   we show by induction on the rank that
every concept atom in iht  i has a derivation  thus ht   i is well founded 
the induction start is straightforward as concept atoms in i  involve a concept from      
and an element x such that either x  ind a  with a       or x  t      with m    x   and
every such atom has a derivation of depth    for the induction step  let b x  be a concept atom in
ii     ii   we consider the rule application that resulted in the addition of b x  
   assume that b x  is in ii   because of an application of rule    that is  a  u    u an v
b  t and x  aij i for    j  n 
for every    j  n  the atom aj  x  has rank at most i  so by the ih  there is a derivation
htj      j i of aj at x  we obtain a derivation ht        i of b at x by setting t          jw   w 
tj              b  x   and     jw      j  w  
   assume that b x  is in ii   because of an application of rule    that is  there is r a v b 
t such that x   r a ii  
as x   r a ii   there must exist some y  ii such that  x  y   rii and y  aii  
the atom a y  has rank at most i  so by the ih  there is a derivation ht          i of a at y  if
x  i    then x  ind aht  i    and so we can define a derivation ht        i of b at x by setting
t           w   w  t                b  x   and      w         w  
next consider the case in which x   i    then x   ind aht  i    so by properness of t   there
is a concept e  nc      such that e     x   since x   i  but x   ii   there is some
    j   i such that x  ij   ij    since ht   i is canonical  the element x was created
due to an application of rule   using a concept inclusion of the form f v s e  so x  e ij  
applying the ih  we obtain a derivation ht            i of e at x  we can thus define a derivation
ht        i of b at x by setting t           w   w  t         w   w  t                 b  x  
     w         w   and      w          w  
   assume that b x  is in ii   because of an application of rule   involving a v r b  t  
that is  there is some y  ii such that y  aii and  y  x   rii     rii  
the atom a y  has rank at most i  so by the ih  there exists a derivation ht          i of a at y 
moreover  since x was created by applying the inclusion a v r b  t to y  the second
condition of canonicity ensures that b     x   we can thus define a derivation of b at x by
taking the tree ht        i with t           w   w  t                b  x   and      w         w  
  

fiq uery and p redicate e mptiness

   assume that b x      x  is in ii   because of an application of rule   involving a v
r e  t  e        that is  there is some y  ii such that y  aii and  y  x   rii     rii  
the atom a y  has rank at most i  so by the ih  there exists a derivation ht          i of a at y 
moreover  since x was created by applying the inclusion a v r e  t to y  the second
condition of canonicity ensures that e     x   we can thus define a derivation of   at x by
taking the tree ht        i with t               w   w  t                   x             e  x  
and       w         w  
   assume that b x  is in ii   because of an application of rule    that is  a v r b  t  
funct r   t   y  aii   and  y  x   rii  
the atom a y  has rank at most i  so by the ih  there exists a derivation ht          i of a at y  if
x  i    we obtain a derivation of b at x by taking the tree ht        i with t           w  
w  t                b  x   and      w         w   if if x   i    then we can use the same
argument as in point   to find a derivation ht            i of e at x  we then obtain a derivation
ht        i of b at x by setting t           w   w  t         w   w  t                 b  x  
     w         w   and      w          w  
o
lemma    let ht   i be a proper r  n  labeled tree that is well founded and such that iht  i
is a model of t   then iht  i is a universal model of t and aht  i  
proof  assume that ht   i is well founded proper r  n  labeled tree and that iht  i is a model
of t   an obligation is a pair  a  x  such that x  t and a    x   for every obligation
 a  x   choose a derivation hta x    a x i of a at x in ht   i that is of minimal depth  for obligations  a    x     a    x     we write  a    x      a    x    if  a    x    occurs as a node label in
hta   x     a   x  i 
claim  the  relation is acyclic 
proof of claim  assume to the contrary that there are obligations  a    x              an   xn   such that
 ai   xi     ai     xi     for all i  n and  an     xn         a    x     we may assume without loss of generality that for all    i   j  n   ai   xi       aj   xj    i e   the obligations
 a    x              an   xn   are pairwise distinct  let ki be the depth of htai  xi    ai  xi i and  i the
depth of the most shallow derivation of  ai   xi   contained in htai    xi      ai    xi   i  because
htai  xi    ai  xi i is of minimal depth  we have ki   i   moreover  we clearly also have  i  ki    
we thus have shown that k              kn    n   consequently  the derivation of  a    x   
in hta   x     a   x  i must start at the root of htai  xi    ai  xi i  which implies  a    x       a    x    in
contradiction to the fact that these obligations are distinct  this finishes the proof of the claim 
by the claim  we can assume w l o g  that if in some chosen derivation hta x    a x i  a node is
labeled with  b  y   then the subtree of hta x    a x i rooted at this node is the chosen derivation
htb y    b y i  uniformity assumption  
to prove that iht  i is a universal model of t and aht  i   take a model i of aht  i and t   we
show that there is a homomorphism h from iht  i to i  constructing h in a step by step fashion  to
start  set h a    ai for all individual names a that occur in aht  i   now and after each extension
of h  we argue that
  

fibaader   b ienvenu   l utz     w olter

   if x  aiht  i with a a concept name  h x  is defined and hta x    a x i uses only elements
from the domain of h  then h x   ai  
   if  x  y   riht  i with r a role and h x   h y  are defined  then  h x   h y    ri  
   if  x  y   riht  i   y is a child of x in t   and h y  is defined  then h x  is also defined 
we start by observing that for the initial mapping h  point   is trivial since i is a model of aht  i
and all role edges in the restriction of iht  i to the domain of h are from aht  i   for point    we use
the fact that if y is an individual in aht  i and x is the parent of y in t   then properness of t implies
that x is also an individual in aht  i  and hence x belongs to the domain of h  
point   is proved by induction on the depth of hta x    a x i  for the induction start  consider
depth zero  then a         x  ind aht  i    and a x   aht  i   since i is a model of aht  i
and by definition of h  we have h x   ai  
now for the induction step  assume that hta x    a x i uses only elements from the domain of h 
the definition of derivations gives rise to the following cases 
 a     x   and there is a ci a  u    u an v a  t such that for    i  n  there is a child
z   of z in ta x with  a x  z        ai   x  
for    i  n  let zi be the child of z with  a x  zi      ai   x   then the subderivation
of hta x    a x i rooted at zi is the chosen derivation htai  x    ai  x i of ai at x  it follows that
htai  x    ai  x i only uses elements from the domain of h and its depth is strictly smaller than
that of hta x    a x i  we can therefore apply the induction hypothesis to get h x   aii   since
i is a model of t and a  u    u an v a  t   we obtain h x   ai  
 a     x   there is a ci r a  v a  t and a child z   of z in ta x with  a x  z        a    x   
such that  x  x     riht  i  
the subderivation of hta x    a x i rooted at z   is the chosen derivation hta   x     a   x  i of a  at
x    and thus it contains only elements from the domain of h and has a strictly smaller depth
than hta x    a x i  we can thus use the ih to infer that h x     b i   and we can use point   to
get  h x   h x      ri   since i is a model of t and r a  v a  t   we have h x   ai  
 a     x   there is a ci a  v r a  t with funct r   t and a child z   of z in ta x with
 a x  z        a    x    such that  x    x   riht  i  
as in the previous item  we can use the ih and point   to get h x     b i and  h x   h x     
ri   since i is a model of t and t contains both a  v r a and funct r   it follows that
h x   ai  
 a        
    x   b     x  and there is a child z of  in ta x with  a x  z     b  x  
this case is not applicable since if b     x   then m     x   hence x is not in the domain
of h 
 a    x   there is a ci a  v r a  t   and there is a child z   of z in ta x with  a x  z      
 a    x    such that  x    x   riht  i and either  i  x is a child of x  in t   or  ii  x is a child of
the root  x   ind  and  r  x       x  
this case is not applicable since if a    x   then m     x   hence x is not in the domain
of h 
  

fiq uery and p redicate e mptiness

to extend h  we first show that if h is not yet total  then there exists an edge  b
x  yb   riht  i

and a concept name a such that h b
x  is defined  h b
y   is undefined  a    b
y    and consequently
a    b
y     and hta by    a by i is such that all elements in it except the root node are in the domain
of h 
assume to the contrary that h is not total but there is no such edge  i e   for every edge  b
x  yb  
riht  i such that h b
x  is defined  h b
y   is undefined  and a    b
y    the derivation hta by    a by i
contains a non root node that is not in the domain of h  pick one such edge  b
x  yb   riht  i such
that its associated derivation hta by    a by i is of minimal depth  since h b
x  is defined and h b
y   is
undefined  it follows from point   that either x
b is the parent of yb in t   or yb is a child of the root node
and  b
x  r     b
y    since derivation rule   is the only applicable rule when the node label contains

a and by the formulation of that rule  there must thus be a ci a  v r a  t such that the unique
child z of  in ta by satisfies  a by  z     a    x
b   since x
b is in the domain of h  the non root node that
is not in the domain of h must be somewhere below z  consequently  we find nodes z    z   ta by
such that z  is a successor of z  and the domain element x
b  in  a by  z    is in the domain of h  but
 
the domain element yb in  a by  z    is not in the domain of h  by definition of the derivation rules 
we must have  b
x    yb     siht  i for some role s  and by point    either yb  is a child of x
b  in t   or yb 
 
 
is a child of the root node and its label contains  b
x   s   it follows that x
b is related to yb  by one of
the derivation rules   and    consequently  there is a b     b
y     such that hta by    a by i contains the
iht  i
 
 
 
obligation  b  yb    thus  the edge  b
x   yb    s
satisfies the above conditions and its associated
derivation htb by     b by  i is of strictly smaller depth than hta by    a by i  contradicting the minimality
of hta by    a by i 
we now extend h using the edge  b
x  yb   riht  i whose existence we have just established 
by the definition of derivations  there is a ci a  v r a  t and a child z of  in ta by with
 a by  z     a    x
b   since all elements in hta by    a by i except the root node are in the domain of h 
the subderivation of hta by    a by i rooted at z uses only elements from the domain of h  by our
uniformity assumption  this derivation is just hta   bx    a   bx i  and thus ih yields h b
x   a  iht  i  
iht  i
iht  i
 
since a v r a  t   there is a  b
x  d   r
with d  a
  set h b
y     d 
it remains to show that points   and   are satisfied for the extended h  point   obviously is  
we start with point    assume that  x  y   siht  i   if h x  and h y  were defined already before
the extension of h  we are done  otherwise  by construction of h we must have  x  y  s     b
x  yb  r 
 or  x  y  s     b
y  x
b  r    which is equivalent   by the choice of h b
y    we have  h b
x   h b
y     ri  
hence  x  y   si   point   is proved by induction on the depth of a x  as for the initial version
of h  the induction start is exactly the same  and for the induction step  the only cases that differ
are the following ones 
 a 
    x   b     x   a      and there is a child z of  in ta x with  a x  z     b  x  
immediate since a     
 a    x   there is a ci a  v r a  t   and there is a child z   of z in ta x with  a x  z      
 a    x    such that  x    x   riht  i and either  i  x is a child of x  in t   or  ii  x is a child of
the root  x   ind  and  r  x       x  
since a    x   we have x   ind aht  i    so x must have been introduced into the domain
of h during the examination of edge  x    x   riht  i   since the child z   is labeled  a    x    
we will use the ci a  v r a  t and choose h x  such that h x   aiht  i  
o
  

fibaader   b ienvenu   l utz     w olter

references
artale  a   calvanese  d   kontchakov  r     zakharyaschev  m          the dl lite family and
relations  journal of artifical intelligence research  jair           
baader  f   bienvenu  m   lutz  c     wolter  f          query and predicate emptiness in description logics  in proceedings of the   th international conference on principles of knowledge
representation and reasoning  kr  
baader  f   brandt  s     lutz  c          pushing the el envelope  in proceedings of the   th
international joint conference on artificial intelligence  ijcai   pp         
baader  f   brandt  s     lutz  c          pushing the el envelope further  in proceedings of the
workshop on owl  experiences and directions  owled  
benedikt  m   fan  w     geerts  f          xpath satisfiability in the presence of dtds  journal
of the acm             
bienvenu  m   hansen  p   lutz  c     wolter  f          first order rewritability of conjunctive
queries in horn description logics  in proceedings of the   th international joint conference
on artificial intelligence  ijcai  
bienvenu  m   lutz  c     wolter  f          query containment in description logics reconsidered 
in proceedings of the   th international conference on principles of knowledge representation and reasoning  kr  
bienvenu  m   ten cate  b   lutz  c     wolter  f          ontology based data access  a study
through disjunctive datalog  csp  and mmsnp  acm transactions on database system
 tods             
botoeva  e   kontchakov  r   ryzhikov  v   wolter  f     zakharyaschev  m          query inseparability for description logic knowledge bases  in proceedings of the   th international
conference in the principles of knowledge representation and reasoning  kr  
botoeva  e   kontchakov  r   ryzhikov  v   wolter  f     zakharyaschev  m          games for
query inseparability of description logic knowledge bases  artificial intelligence journal
 aij              
bourhis  p     lutz  c          containment in monadic disjunctive datalog  mmsnp  and expressive
description logics  in proceedings of the   th international conference on principles of
knowledge representation and reasoning  kr  
calvanese  d   de giacomo  g   lembo  d   lenzerini  m   poggi  a   rodriguez muro  m    
rosati  r          ontologies and databases  the dl lite approach  in tutorial lectures of
the  th international reasoning web summer school  vol       of lecture notes in computer
science  pp          springer 
calvanese  d   de giacomo  g   lembo  d   lenzerini  m     rosati  r          tractable reasoning
and efficient query answering in description logics  the dl lite family  journal of automated
reasoning  jar                 
calvanese  d   de giacomo  g   lembo  d   lenzerini  m     rosati  r          data complexity
of query answering in description logics  artificial intelligence journal  aij               
  

fiq uery and p redicate e mptiness

calvanese  d   de giacomo  g     lenzerini  m          on the decidability of query containment
under constraints  in proceedings of the   th acm sigact sigmod sigart symposium
on principles of database systems  pods   pp         
calvanese  d   ortiz  m   simkus  m     stefanoni  g          reasoning about explanations for
negative query answers in dl lite  journal of artificial intelligence research  jair      
       
chortaras  a   trivela  d     stamou  g  b          optimized query rewriting for owl   ql 
in proceedings of the   rd international conference on automated deduction  cade   pp 
       
eiter  t   gottlob  g   ortiz  m     simkus  m          query answering in the description logic
horn shiq  in proceedings of the   th european conference on logics in artificial intelligence  jelia   pp         
eiter  t   ortiz  m   simkus  m   tran  t     xiao  g          query rewriting for horn shiq plus
rules  in proceedings of the   th aaai conference on artificial intelligence  aaai  
gabbay  d   kurucz  a   wolter  f     zakharyaschev  m          many dimensional modal logics 
theory and applications  elsevier 
gatens  w   konev  b     wolter  f          lower and upper approximations for depleting modules
of description logic ontologies  in proceedings of the   st european conference on artificial
intelligence  ecai   pp         
gene ontology consortium         the gene ontology  http   geneontology org    online  accessed
   april       
glimm  b   lutz  c   horrocks  i     sattler  u          answering conjunctive queries in the
shiq description logic  journal of artificial intelligence research  jair              
golbeck  j   fragoso  g   hartel  f   hendler  j   oberthaler  j     parsia  b          the national
cancer institutes thesaurus and ontology  journal of web semantics  science  services and
agents on the world wide web             
grau  b  c   horrocks  i   kazakov  y     sattler  u          modular reuse of ontologies  theory
and practice  journal of artifical intelligence research  jair              
haase  c          complexity of subsumption in extensions of el  masters thesis  dresden university of technology 
hitrl         health information technologies research laboratory  university of sydney 
http   sydney edu au engineering it hitru   online  accessed    april       
horrocks  i   kutz  o     sattler  u          the even more irresistible sroiq  in proceedings of
the   th international conference on principles of knowledge representation and reasoning
 kr   pp       
hustadt  u   motik  b     sattler  u          a decomposition rule for decision procedures by
resolution based calculi  in proceedings of the   th international conference on logic for
programming artificial intelligence and reasoning  lpar   pp       
hustadt  u   motik  b     sattler  u          reasoning in description logics by a reduction to
disjunctive datalog  journal of automated reasoning  jar                 
  

fibaader   b ienvenu   l utz     w olter

ihtsdo         snomed ct  the global language of healthcare  http   www ihtsdo org snomedct   online  accessed    april       
kaminski  m   schneider  t     smolka  g          correctness and worst case optimality of prattstyle decision procedures for modal and hybrid logics  in proceedings of the   th international conference on automated reasoning with analytic tableaux and related methods
 tableaux   pp         
kazakov  y          consequence driven reasoning for horn shiq ontologies  in proceedings of
the   st international joint conference on artificial intelligence  ijcai   pp           
kazakov  y          an extension of complex role inclusion axioms in the description logic
sroiq  in proceedings of the  th international joint conference on automated reasoning
 ijcar   pp         
konev  b   ludwig  m   walther  d     wolter  f          the logical difference for the lightweight
description logic el  journal of artificial intelligence research  jair              
konev  b   lutz  c   walther  d     wolter  f          model theoretic inseparability and modularity
of description logic ontologies  artificial intelligence journal  aij              
kontchakov  r   rodriguez muro  m     zakharyaschev  m          ontology based data access
with databases  a short course  in proceedings of the international reasoning web summer
school  pp         
kontchakov  r   wolter  f     zakharyaschev  m          logic based ontology comparison and
module extraction  with an application to dl lite  artificial intelligence               
     
krotzsch  m          owl   profiles  an introduction to lightweight ontology languages  in tutorial lectures of the  th international reasoning web summer school  vol       of lecture
notes in computer science  pp          springer 
krotzsch  m   rudolph  s     hitzler  p          complexity boundaries for horn description logics 
in proceedings of the   nd aaai conference on artificial intelligence  aaai   pp         
levy  a          irrelevance reasoning in knowledge based systems  ph d  thesis  stanford university 
lubyte  l     tessaris  s          supporting the design of ontologies for data access  in proceedings of the   st international description logic workshop  dl  
lutz  c          the complexity of cq answering in expressive description logics  in proceedings
of the  th international joint conference on automated reasoning  ijcar   pp         
lutz  c   toman  d     wolter  f          conjunctive query answering in the description logic el
using a relational database system  in proceedings of the   st international joint conference
on artificial intelligence  ijcai   pp           
lutz  c     wolter  f          deciding inseparability and conservative extensions in the description
logic el  journal of symbolic computation                
lutz  c     wolter  f          non uniform data complexity of query answering in description
logics  in proceedings of the   th international conference on principles of knowledge
representation and reasoning  kr  
  

fiq uery and p redicate e mptiness

motik  b   grau  b  c   horrocks  i   wu  z   fokoue  a     lutz  c          owl   web ontology language  profiles  w c recommendation  available at http   www w  org tr owl profiles  
ortiz  m   calvanese  d     eiter  t          data complexity of query answering in expressive
description logics via tableaux  journal of automated reasoning  jar               
ortiz  m     simkus  m          reasoning and query answering in description logics  in proceedings of the  th international reasoning web summer school  vol       of lecture notes in
computer science  pp       springer 
ortiz  m   simkus  m     eiter  t          worst case optimal conjunctive query answering for an
expressive description logic without inverses  in proceedings of the   rd aaai conference
on artificial intelligence  aaai   pp         
patel  c   cimino  j  j   dolby  j   fokoue  a   kalyanpur  a   kershenbaum  a   ma  l   schonberg 
e     srinivas  k          matching patient records to clinical trials using ontologies  in
proceedings of the  th international semantic web conference  iswc   pp         
perez urbina  h   motik  b     horrocks  i          a comparison of query rewriting techniques
for dl lite  in proceedings of the   nd international description logic workshop  dl  
poggi  a   lembo  d   calvanese  d   de giacomo  g   lenzerini  m     rosati  r          linking
data to ontologies  journal of data semantics             
pratt  v  r          models of program logics  in proceedings of ieee annual symposium on
foundations of computer science  focs   pp         
romero  a  a   kaminski  m   grau  b  c     horrocks  i          ontology module extraction
via datalog reasoning  in proceedings of the   th aaai conference on artificial intelligence
 aaai   pp           
tobies  s          complexity results and practical algorithms for logics in knowledge representation  ph d  thesis  rwth aachen 
vardi  m  y          automata theory for database theoreticans  in proceedings of the  th acm
sigact sigmod sigart symposium on principles of database systems  pods   pp    
   
vardi  m  y          reasoning about the past with two way automata  in proceedings of the   th
international colloquium on automata  languages and programming  icalp   pp         

  

fi