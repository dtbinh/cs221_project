journal artificial intelligence research                 

submitted        published      

deterministic oversubscription planning heuristic search 
abstractions reformulations
carmel domshlak
vitaly mirkis

dcarmel ie technion ac il
mirkis   gmail com

faculty industrial engineering   management 
technion   israel institute technology 
haifa  israel

abstract
classical planning objective achieve one equally attractive goal
states low total action cost possible  objective deterministic oversubscription
planning  osp  achieve valuable possible subset goals within fixed
allowance total action cost  although numerous applications various fields share
latter objective  substantial algorithmic advances made deterministic
osp  tracing key sources progress classical planning  identify severe lack
effective domain independent approximations osp 
focus optimal planning  goal bridge gap  two classes
approximation techniques found especially useful context optimal
classical planning  based state space abstractions based logical landmarks goal reachability  question study whether similar in spirit 
yet possibly mathematically different  approximation techniques developed osp 
context abstractions  define notion additive abstractions osp  study
complexity deriving effective abstractions rich space hypotheses  reveal
substantial  empirically relevant islands tractability  context landmarks 
show standard goal reachability landmarks certain classical planning tasks
compiled osp task interest  resulting equivalent osp task lower
cost allowance  thus smaller search space  empirical evaluation confirms
effectiveness proposed techniques  opens wide gate developments
oversubscription planning 

   introduction
tools automated action planning allow autonomous systems selecting course
action get things done  deterministic planning probably basic  thus
fundamental  setting automated action planning  russell   norvig        
viewed problem finding trajectories interest large scale yet concisely
represented state transition systems  computational approaches deterministic planning
vary around way trajectories interest defined 
basic structure acting situations underconstrained overconstrained
resources respectively captured days called classical deterministic
planning  fikes   nilsson         smith        termed oversubscription
deterministic planning  osp   classical planning  task find cost effective
trajectory possible goal satisfying state  oversubscription planning  task
find goal effective  or valuable  state possible via cost satisfying trajectory 
c
    
ai access foundation  rights reserved 

fidomshlak   mirkis

optimal classical planning optimal osp  tasks constrained finding
cost effective trajectories goal effective states  respectively  classical
planning osp viewed foundational variants deterministic planning 
many variants  net benefit planning cost bounded planning  defined
terms mixing relaxing two  
osp extensively advocated years  theory practice
classical planning studied advanced much intensively  remarkable
success continuing progress heuristic search solvers classical planning one notable example  primary enablers success advances domain independent
approximations  heuristics  cost needed achieve goal state given state 
thus possible similarly rich palette effective heuristic functions
osp would advance state art problem 
two classes approximation techniques found especially useful context optimal classical planning  based state space abstractions  edelkamp       
haslum  botea  helmert  bonet    koenig        helmert  haslum  hoffmann    nissim 
      katz   domshlak      a  based logical landmarks goal reachability  karpas   domshlak        helmert   domshlak        domshlak  katz    lefler 
      bonet   helmert        pommerening   helmert         considering osp heuristic search  question whether similar in spirit  yet possibly mathematically
different  approximation techniques developed heuristic search osp  precisely question study here 
starting basic question state space abstractions osp actually are  show notion abstraction differs substantially classical planning osp  hence  first define  additive  abstractions abstraction
heuristics osp  investigate computational complexity deriving
effective abstraction heuristics scope homomorphic abstraction skeletons 
paired cost  value  budget partitions  along revealing significant
islands tractability  study exposes interesting interplay knapsackstyle problems combinatorial optimization  continuous convex optimization 
certain principles borrowed explicit abstractions classical planning 
introduce study  landmarks  logical properties osp plans achieve
valuable states  show  landmarks correspond regular goal reachability
landmarks certain classical planning tasks straightforwardly derived
osp tasks interest  show  landmarks compiled
back osp task interest  resulting equivalent osp task 
stricter cost satisfaction constraint  thus smaller effective search space 
finally  show landmark based task enrichment combined
mutually stratifying way best first branch and bound search used osp
planning  resulting incremental procedure interleaves search landmark
discovery  entire framework independent osp planner specifics 
particular  heuristic functions employs 
   connections differences popular variants deterministic planning discussed
section   

  

fion oversubscription planning heuristic search

empirical evaluation large set osp tasks confirms effectiveness proposed techniques  moreover  best knowledge  implementation constitutes
first domain independent solver optimal osp  hope advances
important computational problem follow 
work revision extension formulations results presented
authors icaps      ecai       mirkis   domshlak               paper
structured follows  section   formulate general model deterministic planning 
define several variants deterministic planning terms model  and  particular 
show oversubscription planning differs conceptually classical planning 
popular variants deterministic planning net benefit planning
cost bounded planning  specify simple model representation language
osp  well provide essential background heuristic search  and  particular 
osp heuristic search  sections     devoted  respectively  abstractions
abstraction approximations osp  section   devoted exploiting reachability
landmarks osp tasks  section   conclude discuss promising directions
future work  sake readability  proofs relegated appendix a 
details empirical results relegated appendix b 

   background
mentioned introduction  specific variants deterministic planning differ
way interest preference trajectories defined  instance  classical
planning  fikes   nilsson         trajectory interest connects designated initial
state one designated goal states  preference towards trajectories
lower total cost transitions along them  among other  non classical variants
deterministic planning
oversubscription planning  smith         topic interest here 
net benefit planning  van den briel  sanchez  do    kambhampati        sanchez
  kambhampati        baier  bacchus    mcilraith        bonet   geffner       
benton  do    kambhampati        coles   coles        keyder   geffner        
cost bounded  also known resource constrained  planning  haslum   geffner       
hoffmann  gomes  selman    kautz        gerevini  saetti    serina        thayer  
ruml        thayer  stern  felner    ruml        haslum        nakhost  hoffmann 
  muller        
planning preferences temporal properties trajectories  baier et al  
      gerevini  haslum  long  saetti    dimopoulos        benton  coles    coles 
      
interestingly  working paper  learned quite different
variants deterministic planning often collectively referred oversubscription
planning  result  difference terms expressiveness necessarily clear  thus  relationship already
done collective sense oversubscription planning always apparent 
issue address first 
  

fidomshlak   mirkis

    models
adopting extending notation geffner bonet         view many
variants deterministic planning  including classical planning  well many popular
non classical variants  special cases state model
  hs  s    u  o    c  qi

   

with 
finite set states s 
initial state s  s 
state value function u     r      
operators o s  applicable state s 
deterministic state transition function  s  o  s     s  o  stands
state resulting applying o s  s 
operator cost function c   r    
quality measure q   p   r     p  infinite  set trajectories
s  along operators o  trajectory p sequence operators ho           
o  o s    and  inductively  oi o          s    o            oi     oi     
model  trajectory p solution  preference towards solutions
higher quality 
p follows  sjk stands end state trajectory applied
state s  c     c o  additive cost   likewise  graphical skeleton
gm   hs    oi model refers edge annotated  unweighted digraph induced
nodes gm states s  edge labels operators o 
contains edge s  labeled iff o s  s     s  o  
first  consider quality measure
q       u sjk  c   

   

measure assumes state values operator costs comparable  thus represents tradeoff value end state cost trajectory  consider
fragment state model      instances quality measure q   
instance  value function
 
 
sgoal
u s   
   
  otherwise
partitions state space sgoal s  u takes finite value   
rest states  u takes value   finding optimal solution
instance fragment corresponds finding shortest path s  single node
edge weighted digraph g  obtained gm  i  annotating edges
latter costs c   ii  adding dummy node zero cost edges
   

fion oversubscription planning heuristic search

constraint

preference

net benefit

oversubscription

constraint

end state value

action cost
preference

classical

cost bounded

figure    schematic classification four deterministic planning models along strictness
approach cost operator sequences value
operator sequence end states  white blocks planning models
solved single source single target shortest path problems 

goal nodes sgoal   specified non canonical way  fragment
easily verified correspond model classical planning  sgoal classical
planning goal states 
staying quality measure q  removing requirement u comply
eq     obtain fragment generalizes classical planning  constitutes
basic model called net benefit planning  sanchez   kambhampati         importantly  instance fragment reduced finding shortest path
single node s  single node edge weighted digraph g  obtained gm
 i  annotating edges gm costs c   ii  adding dummy node andpedges
nodes    ii  setting cost new edge  s    s  s  s  u s    
reduction works net value maximization end state equivalent
minimization net loss giving possible end states 
basic idea underlies keyder geffners        scheme compiling certain standard representation formalisms net benefit planning standard classical planning
formalism  
consider alternative quality measure
 
u sjk   c   b
q     
 
 
otherwise
b

   

   worth noting wost case complexity equivalence classical planning net benefit
planning shown prior work keyder geffner        van den briel et al         
however  equivalence prescriptive enough suggest practically effective compilations
compactly represented net benefit planning tasks classical planning tasks 

   

fidomshlak   mirkis

b r   predefined bound cost trajectories  fragment
basic model  instances characterized quality measure qb
value functions eq     constitutes model called costbounded planning  thayer   ruml         well  finding optimal solution
problem instance corresponds finding shortest path s  edge weighted
digraph g  derived gm identically case classical planning   this 
particular  explains natural heuristic search methods cost bounded
planning exploit heuristics developed classical planning  haslum        
arrive fourth fragment basic model  staying quality measure qb removing requirement u comply eq     obtain fragment
generalizes cost bounded planning  constitutes model oversubscription planning  smith         illustrated figure    hard constraint classical planning
translates soft preference osp  hard constraint osp translates soft preference classical planning  however  contrast cost optimal  net benefit  classical
planning  fragment appear reducible single source single target
shortest path problem  terms digraph g obtained gm annotating
edges costs c  finding optimal solution instance oversubscription planning
requires  i  finding shortest paths s  states u s        ii  filtering
states reachable s  within cost allowance b   iii 
selecting remaining states state maximizes u 
contrast oversubscription planning three popular variants
deterministic planning discussed least two important implications  first 
single shortest path searched using best first forward search procedures
  searching shortest paths numerous targets simultaneously requires different 
exhaustive  forward search framework branch and bound  second  net benefit
cost bounded planning clearly potential  directly indirectly  reuse rich
toolbox heuristic functions developed years classical planning  contrast 
due differences underlying computational model  necessarily
true oversubscription planning  examining prospects heuristic functions
osp precisely focus work here 
    notation
k n     k  denote set                k   indicator function subset
set x function  a   x        defined  a  x      x  a  x      x   a 
following nebel         talk size mathematically well defined object
x  symbolically   x    mean size  reasonable  encoding x  assignment
variable v value denoted hv di  often refer single variable assignments
propositions 

   strictly speaking  shortest path s  found  still checked
cost bound b  test  however  local   problem solving finishes independently tests
outcome 

   

fion oversubscription planning heuristic search

    model representation
departing general model oversubscription planning  follows restrict attention instances model compactly representable language
close sas  language classical planning  backstrom   klein        backstrom  
nebel         language  deterministic oversubscription planning  osp  task
given sextuple
  hv  s    u  o  c  bi 

   


    v    v            vn   finite set finite domain state variables  complete
assignment v representing state    dom v    dom vn   state
space task 
    s  designated initial state 
    u efficiently computable state value function u   r    
    finite set operators  operator represented pair
hpre o   eff o i partial assignments v   called preconditions effects o  respectively 
    c   r   operator cost function 
    b r   cost budget allowed task 
consider semantics task description terms
basic model 

osp task   hv  s    u  o  c  bi said induce model   s  s    u  o    c  qb  
qb quality measure     instantiated budget b  transition
function specified follows  partial assignment p v   let v p  v denote
subset variables instantiated p  and  v v p   p v  denote value provided
p variable v  similarly classical planning semantics sas    operator
applicable state iff s v    pre o  v  v v pre o    applying changes
value v v eff o   eff o  v   resulting state denoted sjok 
notation defined applicable s  denoting empty sequence operators  
applying sequence operators ho            om state defined inductively sjk   
sjo            oj k    sjo            oj  kjoj k  operator sequence called s plan
applicable state qb         is  c   b 

auxiliary notation used later on  osp task   hv  s    u  o  c  bi 
  vv dom v  denote union  uniquely labeled  state variable domains 
state proposition hv di d  hv di used shortcut notation
s v    d 
example simple osp task figure   used illustrate model representation  example  truck initially location a  drive  only  location
location b location b location c  two packages  x y  initially
location b  package truck location  package
loaded onto truck  package truck  unloaded
   

fidomshlak   mirkis

x



b

c

 a 
oi
pre oi  
eff oi  

driveab
i  
 ht ai 
 ht bi 

drivebc
i  
 ht bi 
 ht ci 

loadbx
i  
 ht bi   hx bi 
 hx t i 

loadby
i  
 ht bi   hy bi 
 hy t i 

unloadcx
i  
 ht ci   hx t i 
 hx ci 

oi
pre oi  
eff oi  

unloadbx
i  
 ht bi   hx t i 
 hx bi 

unloadby
i  
 ht bi   hy t i 
 hy bi 

unloadcy
i  
 ht ci   hy t i 
 hy ci 

loadcx
i  
 ht ci   hx ci 
 hx t i 

loadcy
    
 ht ci   hy ci 
 hy t i 

 b 
u  

cbb

o 
abb

o 

bbb

btb
o 
o 
o 
o 
bbt

ctb

o 
o 

ccb

btt

o 

ctt

o 
o 
o 
o 
o 
o 

o  
o 
u  

o  
o 

cbc

ctb

o 
o 

ccb

btt

o 

ctt

cbt

u  

o 
o 

ctc

u  
cct

o  u  
o 
ccc

o  
o 

 c 
u  

cbb

o 
abb

o 

bbb

btb
o 
o 
o 
o 
bbt

o 
o 
o 
o 
o 
o 

o  
o 
u  

cbt

o  
o 

u  

o 
o 

ctc

u  
cct

o  u  
o 
ccc

o  
o 

cbc

 d 

figure    simple running example osp task   a  illustrating story   b  listing operators   c   d  depicting graphical skeleton induced state
model   c  shows region graphical skeleton gm structurally
reachable initial state abb  grayed area  d  corresponds
sub region cannot reached initial state budget
b     

trucks current location   drive  load  unload  operator task costs one unit
cost  cost budget set four units cost  finally  value one  value unit 
earned package present location c 
osp task described using three state variables v    t  x  y  
dom t     a  b  c  dom x    dom y     a  b  c     corresponding possible
locations truck two packages  respectively 

operator set ffo    o            o    
detailed figure   b   state model   s  s    u  o    c  qb induced
   

fion oversubscription planning heuristic search

bfbb     hv  s    u  o  c  bi 
open    new max heap ordered f  n    h shni  b g n  
initialize best solution n    make root node s   
open insert n  
closed    
best cost    
open empty  
n    open pop max  
f  n  u shn i   break
u shni    u shn i   update n    n
shni   closed g n    best cost shni  
closed   closed  shni 
best cost shni     g n 
foreach o shni  
n     make node shnijok  n 
g n      b f  n    u shn i   continue
open insert n   

return n
figure    best first branch and bound  bfbb  search osp
task    dom t dom x dom y   initial state s    abb  with three letters names states capturing three components domain cross product  
operator cost c oi       operators oi   cost budget b      state values


     ac   bc   ca   cb 
u s         cc 


   otherwise

 

graphical skeleton gm depicted figures   c    d   figure   c  shows
region graphical skeleton gm structurally reachable initial state
abb  grayed area figure   d  corresponds sub region cannot
reached initial state budget b     
    osp heuristic search
two major ingredients heuristic search planner search algorithm
heuristic function  classical planning  heuristic typically function h   r  
    h s  estimating cost h  s  optimal s plans  heuristic h admissible
lower bounding  is  h s  h  s  states s  common heuristic search
algorithms optimal classical planning    require admissible heuristics 
contrast  heuristic osp function h   r   r     h s  b  estimating
value h  s  b  optimal s plans cost budget b  heuristic h admissible
upper bounding  is  h s  b  h  s  b  states cost budgets b  well 
   

fidomshlak   mirkis

search algorithms optimal osp  best first branch and bound  bfbb    require
admissible heuristics pruning search branches without violating solution optimality 
figure   depicts pseudo code description bfbb osp  shni denotes state
associated search node n  cost so far g n  total cost action sequence
associated n  unlike   order nodes selected open
list affect optimality guarantees  though may  course  seriously affect
empirical efficiency search   figure    ordering open corresponds
decreasing order h shni  b g n    duplicate detection reopening mechanisms
bfbb similar  pearl         addition  bfbb maintains best
solution n found far uses prune generated nodes evaluated higher
u shn i   likewise  complying semantics osp  generated nodes n costso far g n  higher problems budget b immediately pruned 
open list becomes empty node n selected list promises less lower
bound  bfbb returns  the plan associated with  best solution n   h admissible 
is  h based pruning generated nodes sound  returned plan
guaranteed optimal 
let us return heuristic functions  domain independent planning
automatically derived description model language choice 
useful heuristic function must efficiently computable description
model  well relatively accurate estimates  improving accuracy heuristic
function without substantially worsening time complexity computing translates
faster search plans 
classical planning  numerous approximation techniques  monotonic relaxation  bonet   geffner              hoffmann   nebel         critical trees  haslum
  geffner         network flow  van den briel  benton  kambhampati    vossen       
bonet         logical landmarks goal reachability  richter  helmert    westphal       
karpas   domshlak        helmert   domshlak        bonet   helmert        
abstractions  edelkamp        helmert  haslum    hoffmann        katz   domshlak 
    a   translated effective heuristic functions  likewise  different heuristics
classical planning combined point wise maximizing and or additive
ensembles  edelkamp        haslum  bonet    geffner        coles  fox  long    smith 
      katz   domshlak      b  helmert   domshlak        
contrast  development heuristic functions osp progressed beyond
initial ideas smith         principle  reduction keyder geffner       
net benefit classical planning used reduce osp classical planning realvalued state variables  koehler        helmert        fox   long        hoffmann       
gerevini  saetti    serina        gerevini et al         edelkamp        dvorak   bartak 
      coles  coles  fox    long         far  however  progress heuristic search classical
planning numeric state variables mostly achieved around direct extensions
delete relaxation heuristics via numeric relaxed planning graphs  hoffmann       
edelkamp        gerevini et al                unfortunately  heuristics preserve
information consumable resources budgeted operator cost oversubscription
   bfbb extensively used net benefit planning  benton  van den briel    kambhampati       
coles   coles        do  benton  van den briel    kambhampati         well variants
deterministic planning  bonet   geffner        brafman   chernyavsky        

   

fion oversubscription planning heuristic search

planning  negative action effects decrease values numeric variables
ignored  possibly special handling so called cyclic resource transfer  coles
et al         
first step overcoming lack effective heuristics osp  next section
study abstractions osp  definition properties  prospects
deriving admissible abstraction heuristics  section   study prospects
adapting osp toolbox logical landmarks goal reachability  date  abstractions
landmarks responsible state of the art admissible heuristics classical
planning  thus special interest here 

   abstractions
term abstraction usually associated simplifying original model  factoring
details less crucial given context  context determines details reduced  better preserved  abstraction created used  cousot
  cousot        clarke  grumberg    peled        helmert et al         domshlak  hoffmann    sabharwal        katz   domshlak      b   general terms  abstracting model
corresponds associating set  typically computationally attractive 
models m            mk solutions models satisfy certain properties respect solutions   particular  deterministic planning heuristic search 
abstractions used derive heuristic estimates states model interest  
given state abstraction m            mk  
    mapped abstract states s  m            sk mk  
    k models abstraction solved respective initial states s            sk  

    aggregation quality resulting k solutions used heuristic estimate
s 
sometimes schematically sometimes precisely  process constructing abstractions state model   hs  s    u  o    c  qi seen two step process

    selecting abstraction skeleton     g                  gk   k     pair
 gi     comprises edge labeled digraph gi   hsi   ti   oi i  nodes si   edges ti  
edge labels oi   state mapping   si  
    extending set abstract models    m            mk    that   k  
gi graphical skeleton gmi mi  
qualify valid abstraction model   resulting set abstract models
satisfy certain conditions specific variant deterministic planning
consideration  instance  optimal solutions abstract models classical
planning required costly respective solutions original
models  constraint satisfied individual abstract models case maxaggregation  pearl         k abstract models jointly  case additive abstractions  yang  culberson  holte  zahavi    felner        katz   domshlak      b  
   

fidomshlak   mirkis

show  concept abstractions general  additive abstractions particular 
different osp  and  better worse  many degrees freedom
respective concepts classical planning 
    abstractions osp problems
given
abstraction


skeleton     g                  gk   k    osp state model  
s  s    u  o    c  qb   digraph gi   hsi   ti   oi implicitly defines set osp state
models consistent it  set given ci ui bi   ci set
functions operators oi r     ui set functions states si r    
bi   r     terms  point  c  u  b  ci ui bi induces osp model
consistent gi   vice versa 
connecting sets models digraphs as  let
c   c  ck  
u   u  uk  
b   b  bk  
state   every point  c  u  b  c u b induces set models
n

 c u b 
 c u b 
m c u b    m 
          mk
 
 c u b 

mi




  si    s     u i   oi     c i   qb i   

states si operators oi correspond nodes edge labels gi  
transition function  s  o    s  iff ti contains arc s  labeled
oi  
initial state  s    determined initial state s  state mapping  

operator cost function  state value function  cost budget directly determined choice  c  u  b  
choices  c  u  b  c u b  induced sets models m c u b 
used deriving admissible estimates state interest s    others cannot 
respective qualification defined below 
definition
   additive osp
abstraction 
let   s  s    u  o    c  qb osp model     g                  g    k   
abstraction skeleton    c  u  b  c u b  m c u b   additive 
abstraction   denoted
m c u b  aas m 

def

h  s    b  hm c u b   s    b   

x

hi  i  s     b i   

i k 

is  hm c u b   s    b  admissible estimate h  s    b  
   

fion oversubscription planning heuristic search

gm

  s 
o     
  
  
  s 
s 
o 

o 

  s 

g 

g 


     
o  zz
z
zz
zz

o 

o 
o 

  s 

s   

o 

  s   

 a 

o 

     

s   

o 

o 

  s   
o 



  s   

 b 
figure    illustration running example

simple terms  set models forms additive osp abstraction jointly models
underestimate value obtained initial state  within
  example  let g
given cost budget 
 a graphical skeleton state
figure


model    s            s     s    u   o            o       c  qb   c oi       operators oi  
b      u si           i   let     g          g         abstraction skeleton
  g  g  figure  b state mappings
 
s            
   si    
 
s  i   otherwise
 
s         
   si    
 
s  i   otherwise
consider set models m c u b    constant c        c           b      b         and 
j      u i  si j           j   optimal plan s   plan   h s    o    s      s    o    s   i 
 c u b 

qb         optimal    s    plan m 
    h s      o    s     i 
 c u b 
b   
q           optimal    s    plan m 
    h s      o    s     i 
qb              since
h  s    b    qb    qb           qb           h      s     b       h      s     b     
m c u b  additive abstraction  
theorem   osp task   hv  s    u  o  c  bi  abstraction skeleton  
  g                  gk   k      aas   digraphs given
explicitly  hm  s    b  computed time polynomial        m   



proof  let    mi  i k    mi   si    s     ui   oi     ci   qbi   additive abstraction basis as   k   let si     s si   ci  i  s     s  bi    since
   optimal classical planning  requirement abstraction overestimate costs typically
posed states original model  initial state  yang et al         katz  
domshlak      b  helmert et al          extra requirement  however  pragmatic reasons
efficiency allows abstraction computed preprocessing individually every
state examined search  heuristics osp  however  functions state
available cost budget  latter directly applies initial  aka current  state only 
sum  defining abstractions respect entire state space necessity classical
planning  osp even clear whether defining abstractions respect specific pair
state budget deliver practical benefits  not  however  interpreted
formal impossibility claim  investigation direction definitely worthwhile 

   

fidomshlak   mirkis

      

ssss
kk
ss
kkkk
   u   
sssskk  c      sssskk      b 
kkkkss
kkkkss
 c  u   

   u  b 
 c    b 
sss
sss
kkk
kkk
 c  u  b 

figure    fragments restricted optimization abstractions c u b
digraphs given explicitly  shortest paths  s    states gi  and
thus  particular  determining si    computed time polynomial
  m  
p
 k   turn  since hi  i  s     bi     maxssi  ui  s   hm  s    b    i k  hi  i  s     bi  
computed time polynomial   m   

message theorem   positive  yet establishes necessary condition
relevance osp abstractions practice  given osp task   fixed
abstraction skeleton joint performance measure space c u b 
able automatically separate  c  u  b  c u b constitute
abstractions not  within former set  denoted
c u b 
home abstraction provides us accurate  aka low  estimate
h  s    b  possible  here  even first item agenda necessarily trivial as 
general  seems lack convenient combinatorial properties  instance  generally
form combinatorial rectangle c u b  consider osp state model
gm abstraction skeleton running example  let c c cost function
vector c    c    constant functions value    two performance
measures  c  u  b    c  u    b    cub defined via budget vectors b    b         b        
b     b           b            value function vectors u u    u     u     u      
u      evaluating zero states except u    s        u      s          
   
hard verify m c u b  aas m c u  b   aas   m c u b    state
 c u b 
s    u    s          reachable m 
s         s    b        
 
 
 c u   b   
 c u
 b
 
 

  state s    u     s          reachable m 
s         s   
 
 
b           contrast  m c u  b   aas m c u b    aas   sets
models  model either comes budget  and initial state model
 
value zero   states non zero value all  hence  m c u  b 
 
m c u b   estimate h  s    b  zero  h  s    b      
light above  approach overall agenda complexity analysis abstractionbased heuristic functions steps  different fixations three dimensions
a  if  instance  given vector value functions u known belong
projection u  search quality abstraction abstraction
subset a   u    a  corresponding projection  u   show below 
even constrained optimizations kind challenging  lattice figure   depicts range options constrained optimization  extreme settings 
   

fion oversubscription planning heuristic search

o 

g 

g 

  s   
uu
u
u
uu

o 

  s   

o 

s   

o 

  s   

o 

     
j

s   

o   o 

o 



o 

  s   
j

o 

figure    homomorphic abstraction skeleton g   figure  
a       simply renaming a  a c  u  b  corresponds single abstraction
m c u b  a 
    partitions homomorphic abstractions
proceed consider specific family additive abstractions  reveal
interesting properties  show contains substantial islands tractability 
definition   allowing general abstraction skeletons  work focus homomorphic abstraction skeletons   helmert et al         
definition
  abstraction skeleton
    g                  gk   k    osp state

model   s  s    u  o    c  qb homomorphic if   k   oi   o   s  o    s 
 i  s   o   s     ti  
instance  running example  abstraction skeleton figure  b homomorphic  since  e g    s    o    s    gm yet     s     o       s        s      o    s        gm    
abstraction skeleton figure   homomorphic  furthermore  focus fragment
additive abstractions
ap    cp bp    
cp c  u  bp b correspond cost  value  budget partitions 
respectively 



definition   given osp state model   s  s    u  o    c  qb   homomorphic
abstraction skeleton     g                  gk   k    joint performance measure
c u b 
p
c c cost partition iff  operator o  i k  c i  o  c o  
p
u u value partition iff  state s  i k  u i  i  s   u s  
p
b b budget partition iff  i k  b i  b 
follows  node x lattice figure    ap  x  refer a x ap  
e g   ap    u      a   u    ap  
begin analysis ap establishing interesting completeness relationship
sets cp bp   well even stronger individual completeness cp
bp   formulated theorem    properties ap play key role computational
analysis later on 
   results hold verbatim general labeled paths preserving abstraction skeletons
studied katz domshlak      b  context optimal classical planning  however 
presentation somewhat accessible restricted homomorphic abstraction skeletons 

   

fidomshlak   mirkis

c

cp

b

bp



   

b

c

bp

cp



   

figure    illustration sub claims         theorem         gray ellipse
within bp stands subset budget partitions b pair c
abstraction  is  ap  c    b       however  pairing budget
partitions b c requires careful selection value partition u  so
m c u b  abstraction   exists budget partition b
choice u job 

theorem   given osp task   hv  s    u  o  c  bi homomorphic abstraction
skeleton     g                  gk   k     
    cost partition c cp   exists budget partition b bp

m c u b   value partitions u  

    budget partition b bp   exists cost partition c cp

m c  u b  value partitions u  
proof theorem   appears appendix a  p       figure   illustrates statement sub claim     theorem    well as  indirectly  corollaries   first
corollary theorem   projections ap cp     bp entire sets
cp     bp   respectively  is  cost partition c  and similarly  budget partition value partition  matched abstraction partition
component  second  budget partition b paired given cost
partition c abstractions   is  b bp   ap  c    b      
always budget partitions paired c  finally  pairing
c compatible budget partitions b c requires careful selection value
partition u  exists c compatible budget partition b choice
u result m c u b  abstraction  
priori  properties ap simplify task abstraction discovery
optimization within space partitions cp bp   later show
indeed case  however  complexity analysis abstraction discovery within cp bp
general terms still problematic osp formalism parametric
   respective illustration sub claim     theorem   completely similar  mutatis mutandis 

   

fion oversubscription planning heuristic search

representation value functions  hence  proceed examining abstraction
discovery osp context fixed value partitions u  

   value partitions complete abstractions
let osp task  explicitly given homomorphic abstraction skeleton  
u value partition as  immediate corollary theorem  
ap    u    empty  thus try computing min c u b ap   u   hm c u b   s    
yet  however  know whether task polynomial time solvable
non trivial class value partitions  fact  although ap    u    known  theorem   
non empty  so  too  subsets ap    u  b  ap  c  u     finding even
abstraction  c  u  b  ap    u    necessarily easy 
      binary value partitions
first step  examine abstraction discovery within fragment ap
value functions u i  abstract models call   binary  later  section     
show findings   binary abstract value functions extended general
value partitions 
definition   real valued function f called   binary codomain f      
r    set f   binary functions called strong functions f
codomain       
one hand    binary functions constitute rather basic family value functions 
hence  abstraction optimization hard them  likely hard nontrivial family abstract value functions  hand    binary abstract value
functions seem fit well abstractions planning tasks value functions linear
combinations indicators  representing achievement goal value state
variable 
respect  first tractability results abstraction discovery ap    u   
u strong   binary value partition  first  and simpler  result theorem  
assumes fixed action cost partition  next result  theorem   
simultaneous selection admissible pairs cost budget partitions  corollary  
theorem    show results theorem   theorem    respectively 
extended pseudo polynomial algorithms general   binary value partitions 
      strong   binary value partitions knapsack problem
first tractability result abstraction discovery within ap  c  u    u strong
  binary value partition c arbitrary cost partition  key role played
well known
knapsackffproblem  dantzig        kellerer  pferschy    pisinger        


instance  wi    i n    w knapsack problem given weight allowance w
set objects  n   object  n  annotated
 
pwith weight wi value
   n 
objective


find

subset
z

 n 

maximizes



subsets
z
iz
p

w

w 

strict
knapsack

refer


variant knapsack
 

iz
inequality constraint strict  knapsack np hard  karp        garey   johnson 
   

fidomshlak   mirkis

       exist pseudo polynomial algorithms run time polynomial
description problem unary representation w  dudzinski   walukiewicz 
       latter property makes solving knapsack practical many applications
ratio minwi wi reasonably low  likewise    j i  j  n   greedy algorithm
solves problem linear time iteratively expanding z one weight wise
lightest objects  n    z  z cannot expanded within w  
theorem    ap  c  u      strong   binary u 
let   hv  s    u  o  c  bi osp task  explicit homomorphic abstraction skeleton   u strong   binary value partition  given cost partition c cp  
finding abstraction  c  u  b  ap  c  u    computing corresponding heuristic
estimate hm c u b   s    b  done time polynomial        as   
proof  proof reduction polynomial fragment knapsack problem
corresponding items identical value  let     g                  gk   k     and 
given u strong   binary value partition  let codomain u i       
r   
 k   let wi cost cheapest path gi  s     one the 
states si u i  s      since explicit abstraction skeleton  set  wi  i k 
computed time polynomial   as   using one standard algorithms




single source shortest paths problem  consider knapsack problem  wi    i k    b  
weights wi value identical objects  let z  k 
solution  optimization  knapsack problem  recall computable
polynomial time  given that  define budget profile b b follows 
 
wi   z
 k   b  i   
  
otherwise 
remains shown  c  u  b   actually induces additive abstraction

  assume contrary m c u b    aas   let optimal s   plan
  construction knapsack problem b   z 

 c u b  
 s  plan p
qb  i   i       definition    assumption implies
mi

qb      iz qb  i   i      z   however  theorem    exists least one
budget partition b bp m c u b  aas   note budget partition
induces ap
feasible solution z      i   wi b i   knapsack problem  satisfying
qb    iz   qb i   i      z      this  however  implies  z     z      contradicting

optimality z  thus accomplishing proof m c u b   aas  

construction proof theorem   may appear somewhat counterintuitive 
interested minimizing heuristic estimate h  s    b   abstraction

m c u b   selected via value maximizing knapsack problem  indeed  ultimately
would obtain
min
hm c u b   s    b  
   
b    c u b ap

heuristic manage compute polynomial time actually
max
b    c u b ap

hm c u b   s    b  
   

   

fion oversubscription planning heuristic search

time  note that  fixed pair c cp u   estimate eq   
still least  and possibly much more  accurate estimate would obtained
providing k abstract models entire budget b  later show
superior accuracy verified experiments  first proceed examining
working general   binary value partitions 
strong   binary value partitions rather restrictive  finding element
ap  c  u    general   binary u longer polynomiala reduction knapsack
straightforward  however  knapsack solvable pseudo polynomial time  plugging
knapsack algorithm proof theorem   results search algorithm
ap  c  u    general   binary u 
corollary    ap  c  u        binary u 
let   hv  s    u  o  c  bi osp task  explicit homomorphic abstraction skeleton   u   binary value partition  given cost partition c cp   finding
abstraction  c  u  b  ap  c  u    computing corresponding heuristic estimate
hm c u b   s    b  done time polynomial         as    unary representation
budget b  
test illustrate value additive abstractions bring heuristic search
osp  implemented prototype heuristic search osp solver  top fast downward
planner  helmert         since  unlike classical net benefit planning  osp still lacks
standard suite benchmarks comparative evaluation  cast role
strips classical planning tasks international planning competitions  ipc            translation osp done associating separate unit value
proposition conjunctive goal corresponding classical ipc task 
within prototype  implemented bfbb search osp  provided support
basic pattern database abstraction skeletons  action cost partitions  abstraction selection ap  c  u    strong   binary value partitions proof theorem   
specifically  task k sub goals 
 i  abstraction skeleton comprised set k projections planning task onto
connected subsets ancestors respective k goal variables causal graph 
size projection limited      abstract states  ancestors
goal variable v added corresponding projection  initialized contain
v  breadth first manner  v back along arcs causal graph 
abstraction could expanded within aforementioned size limit 
 ii  value partition u associated entire value sub goal hv di  only 
projection associated v 
 iii  cost partition c distributed cost operator uniformly
projections invalidate o  i e   reflected least one state variable
affected o 
evaluation  compared bfbb node expansions three heuristic functions 
tagged blind  basic  hm   three heuristics  h value node n set  
cost budget n over consumed  cost budget over consumed  then 
   aware domain independent planner optimal osp 

   

fidomshlak   mirkis

airport     
blocks     
depot    
driverlog     
freecell    
grid    
gripper    
logistics     
miconic     
mystery    
openstacks    
rovers     
satellite    
tpp    
trucks    
pipesw t     
pipesw nt    
psr small     
zenotravel     
total

hm
  
  
 
  
 
 
 
  
  
 
 
  
 
 
 
  
 
  
  
   

   
basic
  
  
 
  
 
 
 
  
  
 
 
  
 
 
 
  
 
  
  
   

blind
  
  
 
  
 
 
 
  
  
 
 
  
 
 
 
  
 
  
  
   

hm
  
  
 
  
 
 
 
  
  
 
 
  
 
 
 
  
 
  
  
   

   
basic
  
  
 
  
 
 
 
  
  
 
 
 
 
 
 
  
 
  
 
   

blind
  
  
 
  
 
 
 
  
  
 
 
 
 
 
 
  
 
  
 
   

hm
  
  
 
  
 
 
 
  
  
 
 
 
 
 
 
  
 
  
 
   

   
basic
  
  
 
 
 
 
 
  
  
 
 
 
 
 
 
  
 
  
 
   

blind
  
  
 
 
 
 
 
  
  
 
 
 
 
 
 
  
 
  
 
   

hm
  
  
 
  
 
 
 
  
  
 
 
 
 
 
 
  
 
  
 
   

    
basic
  
  
 
 
 
 
 
  
  
 
 
 
 
 
 
  
 
  
 
   

blind
  
  
 
 
 
 
 
  
  
 
 
 
 
 
 
  
 
  
 
   

table    number problems solved across different budgets using open list ordered heuristic evaluation figure  

blind bfbb constitutes trivial baseline h n  simply set total value
goals 
basic bfbb  h n  set total value goals  individually
achieved within respective projection abstraction  see theorem    given entire
remaining budget 
hm additive abstraction heuristic selected ap  c  u   
proof theorem   
evaluation contained planning tasks could determine offline
minimal cost budget needed achieve goals  task approached
four different budgets  corresponding                     minimal
cost needed achieve goals task  run restricted    minutes 
table   shows number tasks solved within domain level cost budget  
figure   depicts results terms expanded nodes across four levels cost budget 
 figures       appendix b provide detailed view results figure  
breaking different levels cost budget   despite simplicity
abstraction skeletons used  number nodes expanded bfbb hm
typically substantially lower number nodes expanded basic bfbb 
difference sometimes reaching three orders magnitude 
   reiterate task considered solved upon termination bfbb  is 
optimal plan found proven optimal 

   

fion oversubscription planning heuristic search

 a 
   

unsolved

   
   
   
hm

   
   
   

unsolved

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr small
tpp
trucks
rovers
satellite
zenotravel

   

     
                                  
blind

 b 
   

unsolved

   
   
hm

   
   
   
unsolved

   
   

     
                                  
basic

figure    comparative view empirical results table   terms expanded nodes

      freeing cost partition  knapsack meets convex optimization
returning algorithmic analysis context strong   binary value partitions 
proceed relaxing constraint sticking fixed action cost partition c 
buys flexibility selecting abstractions ap    u     allowing us improve
accuracy heuristic estimates  still retaining computational tractability 
   

fidomshlak   mirkis

input    hv  s    u  o  c  bi      g                  gk   k     
strong   binary value partition u
output   u 
    k
reduce gi nodes reachable  s   
  k downto  
always achievable m  return
return  
always achievable m  

ellipsoid method separation oracle lm
      solution x dom x   l 
x   b return true
else return false
 a 
separation oracle lm
   x dom x    
let permutation  k 
x b 
p      x b        x b   k   
x   i m  x b   i    return yes
p
else return constraint i m  b   i  
 b 
figure    polynomial time algorithm computing  u  strong   binary value
partition u  theorem   

given osp task   hv  s    u  o  c  bi  homomorphic abstraction skeleton as 
value partition u as  let


 u    min
max
   
hm c u b   s    b   
ccp

b    c u b ap

obviously  estimate h s    b     u  least accurate estimate eq   
derived respect fixed cost partition c 
show that  osp task   abstraction skeleton     g                
 gk   k      strong   binary value partition u as   u 
computed polynomial time  corresponding algorithm shown figure   
figure  a depicting macro flow algorithm figure  b depicting specific
implementation solve sub routine makes overall time complexity
algorithm polynomial 
high level flow algorithm figure  a follows  since u strong  binary value partition  let codomain abstract value functions u i       
r    given that   c  u  b  ap    u     holds hm c u b   s   
     k   k abstract models m c u b 
contribute additive estimate hm c u b   s  either   
   

fion oversubscription planning heuristic search

first loop algorithm preprocessing for loop eliminates
abstraction skeleton nodes structurally unreachable abstract initial
states    s             k  s       ease presentation  follows assume
cleanup abstraction skeleton leaves gi least one state whose value
  second for loop algorithm decreasingly iterates values  k   k
                 possibly come abstractions ap    u    positive
estimate h  s    b   candidates  u  tested turn via sub routine
always achievable  test returns positive first time  done 
tested candidate identified  u   otherwise  test fails  k  
 u       particular implying state value greater   reached
s  budget b 
test always achievable  u    based linear program  lp  lm
    given
eq      linear program defined variables
 
 
 
 
   
 c i  o    
x     
 d s  sgi  b i  
oo

i k 

constraints    a     c   objective maximizing value variable  
lm
   
max
subject


d i  s         
 k    d s  d s      c i  o    s    o  s  gi
 


b i  d s  
gi s t  u i  s   
 
c i  o    
 k 
  p
 
i k  c i  o  c o 
x
z  k    z     
b i  

   a 

   b 
   c 

iz

roles different variables lm
  follows 
variable c i  o  captures cost associated label digraph gi
as 
state gi   variable d s  captures cost cheapest path gi
 s    s  given edges gi weighted consistently values
variables c i    
variable b i  captures minimal budget needed reaching gi state value
state  s     given that  again  edges gi weighted consistently
variable vector c i  
    preprocessing step replaced adding extra constraints linear program described
below  however  would unnecessarily complicate presentation without adding much value 

   

fidomshlak   mirkis

singleton variable captures minimal total cost reaching states value
precisely k models m c u b   
semantics constraints lm
  follows 
first two sets constraints    a  come simple lp formulation

p single
p source shortest paths problem source node  s     optimizing
i k 
sgi d s  fixed weighting c edges leads computing precisely
that  k digraphs simultaneously 
third set constraints    a  establishes costs cheapest paths  gi  
states  s    states valued   enforcing semantics variables b             b k  
constraints    b  cost partition constraints enforce c cp  
constraints    c  enforce aforementioned semantics objective variable  
two things worth noting here  first  nodes digraphs g            gk
structurally reachable source nodes    s             k  s     respectively  as

ensured first for loop algorithm  
polytope induced l  bounded
non empty  indeed  assignment oo  c i  o   consistent
positiveness constraints    b   variables d   bounded
lengths respective shortest paths  turn  bounding d   bounds
variables c             c k  via third set constraints    a   constraints    c 
bound objective  
second  number variables  well number constraints    a 


k
   b   polynomial        as    number constraints    c 
  thus 
solving lm
  using standard methods linear programming infeasible  lemma  
show problem actually mitigated  then  lemma   show
semantics lm
  match objective finding  u  
lemma   algorithm figure   terminates time polynomial        as   
proof  runtime complexity algorithm boils complexity solving
lm
    and  number variables l   m   well number constraints
   a 
polynomial        as    number constraints    c 
   b  
k
cannot solved polynomial time using standard methods linear
 
thus 
l
 

programming  simplex algorithm  dantzig        interior point methods  nemirovsky   yudin         however  using algorithms 
ellipsoid algorithm  grotschel  lovasz    schrijver        random walks family
algorithms originating work bertsimas vempala         lp
exponential number constraints solved polynomial time  provided
polynomial time separation oracle lp  polynomial time separating oracle
convex set k rn procedure given x rn   either verifies x k
returns hyperplane separating x k  procedure run polynomial time 
case  separation problem is  given assignment variables lm
    test
whether satisfies    a      b      c   not  produce inequality among    a  
   b      c  violated assignment 
   

fion oversubscription planning heuristic search

show separation problem lm
  solved polynomial time
using called m sum minimization lps  punnen         precisely
 parametrized m  procedure separation oracle lm
  figure  b does  number
constraints    a     b  polynomial  satisfaction assignment x dom x  
tested directly substitution  constraints    c   letp permutation  k 
x b        x b        x b   k     x   i m  x b   i    
easy see
px satisfies constraints    c   otherwise  violated
inequality i m  b   i   

lemma   algorithm figure  a computes  u  
proof lemma   appears appendix a  p       combining statements
lemmas      theorem   summarizes tractability result abstraction discovery
ap    u    strong   binary value partitions u 
theorem    ap    u    s    strong   binary u 
given osp task   hv  s    u  o  c  bi  homomorphic explicit abstraction skeleton
  strong   binary value partition u    u  computed time polynomial
       as   
unfortunately  practical value result theorem   yet evaluated 
far  found reasonably efficient implementation ellipsoid method
linear inequalities  while  best knowledge  random walks algorithms  bertsimas   vempala        never implemented all  hope state
affairs change soon  allowing powerful algorithms used theory 
practice 
      strong general   binary value partitions
recall polynomial result theorem   strong   binary value partitions easily
extends corollary   pseudo polynomial algorithm general   binary value partitions  turns pseudo polynomial extension theorem   possible well 
though technically involved  corresponding algorithm shown figure    
following format figure    figure   a depicts macro flow algorithm
figure   b shows specific implementation solve sub routine desired
time complexity achieved 
similarly algorithm figure    preprocessing for loop algorithm first
eliminates abstraction skeleton nodes structurally unreachable
abstract initial states    s             k  s     next  algorithm performs binary
search interval containing  u     since u   binary value partition   k  
       r    denote codomain abstract value
p function u i   given that 
 c  u  b  ap    u     holds h c u b   s    iz z  k  
size combinatorial hypothesis space prohibitive  while loop figure   
performs binary search relaxed hypothesis space  corresponding continuous
    binary search could used algorithm figure   well  would
mere optimization  necessary avoid exponential blowup time complexity 

   

fidomshlak   mirkis

input    hv  s    u  o  c  bi      g                  gk   k     
  binary value partition u
output   u 
    k
reduce gi nodes reachable  s   
let       mini k 
p
 
i k 
 
v        
always achievable v  v
else v
    return  
else return
always achievable v  
ellipsoid method separation oracle lv      solution x dom x   lv 
x   b return true
else return false
 a 
separation oracle lv 
 x dom x    

strict knapsack   x b i     i k    x       solution z  k 
p
iz   v return yes
p
else return constraint iz b i 
 b 
figure     pseudo polynomial algorithm approximating  u  general   binary
value partitions u  theorem    

p
interval     i k    r     parameter serves sufficient precision criterion
termination 
iteration corresponding interval       algorithm uses sub routine
always achievable test hypothesis  u  v  v mid point      
test positive  next tested hypothesis  u  v     v   midpoint
 v     otherwise  next hypothesis corresponds midpoint    v  
while loop done  reported estimate set   still might lag
 u   lag arbitrarily reduced reducing   anyway   u 
ensures admissibility estimate  if  however  while loop terminates     
 u    mini k  implies  u       return 
test always achievable  u  v based linear program lv   
defined variables x eq     obtained lm
  replacing constraints    c 
constraints    c  
   

fion oversubscription planning heuristic search

lv   
max
subject


d i  s         
 k    d s  d s      c i  o    s    o  s  gi
 


b i  d s  
gi s t  u i  s   
 
c i  o    
 k 
  p
 
i k  c i  o  c o 
x
x
z  k  s t 
v  
b i  
iz

   a 

   b 
   c 

iz

semantics variables remains lm
    captures minimal
total cost ofpreaching states  si  i k  abstract models m c u b 
total value i k  u i  si   v  new constraint    c  enforces semantics  
lemma        algorithm figure    terminates time polynomial
        as    log     unary representation budget b  
p



proof  number iterations while loop approximately log  i k 
 

run time iterations boils complexity solving lv    here 
v
lemma   linear programs lm
    number variables l    well number
constraints    a     b   polynomial        as    number
constraints    c    k    therefore  always achievable v  employs ellipsoid
method sub routine separation oracle lv  associated separation problem 
show separation problem lv  solved pseudo polynomial time
using standard pseudo polynomial procedure strict knapsack problem 
given assignment x dom x    feasibility respect    a     b 
tested directly substitution 
constraints    c  
let z  k  optimal solution
strict knapsack problem  x b i     i k    x     weight allowance x   k
objects  object  k  associated weight x b i   value  
p
value iz z smaller v  x satisfies constraints
   c   assume contrary x violatesp
constraint    c   corresponding
 
setpz  k   definition    c  
iz   v  assumption 
x    
x b i   
that 
however 
implies
z   feasible solution
 
iz
strict knapsack  value higher presumably optimal z 
p
otherwise  iz v  z itselfpprovides us constraint    c 
violated x  x    
iz x b i   holds
virtue z
solution strict knapsack problem  x b i     i k    x    


   

fidomshlak   mirkis

lemma         mini k    algorithm figure   a computes
 u   
proof lemma   appears appendix a  p       combining statements
lemmas      theorem    summarizes result optimized abstraction discovery
ap    u    general   binary value partitions u  importantly  note algorithm
figure    depends unary representation budget  possible
state values  particular  means dependence complexity number
alternative sub goals osp task interest polynomial  finally  theorem   
formulated terms estimate precision values abstract value
functions u i  arbitrary real numbers  case integer valued sets functions
u  well various special cases real valued functions   u  determined
precisely using simplification algorithm figure     instance              k
integers  setting value        results while loop terminating
   u   details  however  theoretical interest  reasonably small
values   practice difference estimates h s  b  h s  b     
theorem     ap    u    s      binary u 
given osp task   hv  s    u  o  c  bi  homomorphic explicit abstraction skeleton  
  g                  gk   k        binary value partition u        possible
approximate  u  within additive factor time polynomial         as    log    
unary representation budget b  
    general value partitions
  binary value partitions rather useful themselves  turns
pseudo polynomial algorithms abstraction discovery explicit homomorphic abstraction skeletons   binary value partitions extended rather easily arbitrary value
partitions  using following observations 
    osp task   hv  s    u  o  c  bi  homomorphic abstraction skeleton  
  g                  gk   k      value partition u as  number
distinct values taken u i  trivially upper bounded number states gi  

    pseudo polynomial solvability knapsack problem extends general
variant known multiple choice knapsack  dudzinski   walukiewicz        kellerer
et al         
multiple choice  mc  knapsack problem hn            nm   w given weight
allowance w classes objects n            nm   object j ni annotated
weight wij value ij   objective
find set z contains
p
one
p object class maximizes  i j z ij sets satisfying
 i j z wij w  strict mc knapsack  refer variant mc knapsack
inequality constraint strict  mc knapsack generalizes regular knapsack
thus np hard  however  similarly regular knapsack problem  mc knapsack
admits pseudo polynomial  dynamic programming algorithm runs time polynomial
   

fion oversubscription planning heuristic search

description problem unary representation w  dudzinski  
walukiewicz        kellerer et al         
theorem     ap  c  u    
let   hv  s    u  o  c  bi osp task  let     g                  gk   k    explicit homomorphic abstraction skeleton   let u arbitrary value
partition as  given cost partition c cp   possible find abstraction
 c  u  b  ap  c  u    compute corresponding heuristic estimate hm c u b   s    b 
time polynomial         as    unary representation budget b 
proof  proof similar proof theorem    compilation
mc knapsack problem 
 k   let ni number distinct values taken u i   let  i            ini   r 
codomain u i   and  j  ni    let wij cost cheapest path gi
 s     one the  states si u i  s    ij   since explicit abstraction
skeleton   k   holds ni  si    set  wij  i k  j ni   computed
time polynomial   as   using one standard algorithms single source shortest
paths problem 
consider mc knapsack problem weight allowance b k classes
objects n            nk    ni     ni object j ni annotated weight wij

value ij   let z ki   ni solution  optimization  mc knapsack problem 
recall computable pseudo polynomial time  given that  define budget profile
b b follows 
 
wij    i  j  z

 k   b  i   
  
otherwise 
showing  c  u  b   actually induces additive abstraction completely identical proof corresponding argument theorem    thus omitted 

theorem     ap    u    
given osp task   hv  s    u  o  c  bi  homomorphic explicit abstraction skeleton  
  g                  gk   k      arbitrary value partition u as      
possible approximate  u  within additive factor time polynomial      
  as    log     unary representation budget b  
algorithm abstraction discovery theorem    depicted figure    
high level flow differs flow algorithm figure    general   binary
value partitions initialization parameters   major difference
algorithms tests candidate values v based linear
programs lv    defined follows 
 k   let  i            ini   r  codomain u i   v r    linear
program lv  defined eq     variables


 
 
 
 d s  sgi
x     
 b i  j  
 c i  o   
    
i k 

j ni  

   

oo

fidomshlak   mirkis

input    hv  s    u  o  c  bi      g                  gk   k     
  binary value partition u
output   u 
    k
reduce gi nodes reachable  s   
let       mini k  minj ni   ij
p
 
i k  maxj ni   ij
 
v        
always achievable v  v
else v
    return  
else return
always achievable v  
ellipsoid method separation oracle lv      solution x dom x   lv 
x   b return true
else return false
 a 
separation oracle lv   x
dom x    

strict mc knapsack   x b    j     j  j n               x b k  j    kj  j nk     x    
  solution z  n     nk  
p
i k  iz i    v return yes
p
else return constraint i k  b i  z i  
 b 
figure      a  modification algorithm figure    arbitrary value partitions
u  theorem       b  pseudo polynomial time separation oracle
corresponding linear programs lv  eq    

variables differ variable set lv   see eq     larger set b variables 
variable b i  j  captures minimal budget needed reaching gi state
value i j state  s     given edges gi weighted consistently
variable vector c i  
   

fion oversubscription planning heuristic search

lv   
max
subject


d i  s         
 k    d s  d s      c i  o    s    o  s  gi
 


b i  j  d s  
j  ni  s gi s t  u i  s    ij
   a 
 
c i  o    
 k 
  p
 
   b 
i k  c i  o  c o 
z  n     nk  
x
x
s t 
iz i  v  
b i  z i   
i k 

   c 

i k 

lemma   linear programs lv    number variables
lv    well number constraints    a     b   polynomial     
  as    number constraints    c   dk     maxi k  ni   therefore 
always achievable v  employs ellipsoid method pseudo polynomial time separation oracle  latter based solving strict mc knapsack problem  see
figure   b   otherwise  solving lv  solving lv  similar 
lemma         algorithm figure    terminates time polynomial
        as    log     unary representation budget b  
lemma    given osp task   hv  s    u  o  c  bi  homomorphic explicit abstraction
skeleton     g                  gk   k      arbitrary value partition u
as       algorithm figure    computes  u   
proof lemma    similar proof lemma    strict knapsack
separation problems replaced strict mc knapsack separation problems 
proof lemma    similar proof lemma    mutatis mutandis  together 
lemmas       establish theorem    

   landmarks osp
addition state space abstractions  family approximation techniques
found extremely effective context optimal classical planning based notion
logical landmarks goal reachability  karpas   domshlak        helmert   domshlak 
      domshlak et al         bonet   helmert        pommerening   helmert        
section proceed examining prospects reachability landmarks
heuristic search osp planning 
   

fidomshlak   mirkis

    landmarks classical planning
state classical planning task   landmark property operator sequences
satisfied s plans  hoffmann  porteous    sebastia         instance 
fact landmark state assignment single variable true point
every s plan  state of the art admissible heuristics classical planning use
called disjunctive action landmarks  corresponding set operators
every s plan contains least one operator set  karpas   domshlak       
helmert   domshlak        bonet   helmert        pommerening   helmert        
follows consider popular notion landmarks  simply refer disjunctive
action landmarks state s landmarks  ease presentation  discussion take place context landmarks initial state task 
simply referred landmarks  for   
deciding whether operator set l landmark classical planning task
pspace hard  porteous  sebastia    hoffmann         therefore  landmark heuristics
employ landmark discovery methods polynomial time sound  incomplete 
follows assume access procedure  actual way landmarks
discovered tangential contribution 
landmark cost
p set l s landmarks 

  
function lcost   l r admissible
lcost l  h  s   singleton set
l    l   lcost l     minol c o  natural admissible landmark cost function 
extends directly non singleton sets pairwise disjoint landmarks  general sets
landmarks  lcost devised polynomial time via operator cost partitioning  katz
  domshlak      b   either given l  karpas   domshlak         within actual
process generating l  helmert   domshlak        
     landmarks budget reduction
landmarks play important role  both satisficing optimal  classical planning 
far exploited osp  first glance  probably surprise 
osp investigated much less classical planning  since
landmarks must satisfied plans empty operator sequence always
plan osp task  notion landmark seem useful here  said
that  consider anytime output improvement property bfbb forward search 
empty plan interesting useless 
found bfbb right beginning  general  stages search 
anytime search algorithms bfbb maintain best so far solution   prune
branches promise value lower equal qb     hence  principle  algorithms
may benefit information properties satisfied plans value
larger qb     polynomial time discovery value landmarks arbitrary osp
tasks still open problem  however  looking needed available 
show classical planning machinery reachability landmarks actually
effectively exploited osp 
p follows  assume value function additive  u s   
hv dis uv  d   uv  d    variable value pairs hv di  is  value state
sum  mutually independent  non negative marginal values propositions
comprising s  value different s plans osp task varying zero
   

fion oversubscription planning heuristic search

value optimal s plan  which may zero   let  landmark state
property satisfied s plan achieves something valuable 
instance  disjunctive action landmarks use here  l  landmark
s  every s plan qb        contains operator l  follows  unless
stated otherwise  focus  landmarks  the initial state of   
definition   given osp task   hv  s    u  o  c  bi   compilation classical planning task   hv   s    g     c
v   v  g  
dom g           
s    s   hg  i  
g    hg  i  


  og   ohv di   hv di d  uv  d       
pre ohv di      hv di  eff ohv di      hg  i  
 
c     
c  o   
 
  
  ohv di og
put simply  semantics value hg  i auxiliary variable g
verified proposition positive value achieved 
terms  simply extends structure set zero cost actions
applying corresponds verifying positive value achieved
  constructing trivially polynomial time  allows us discover
 landmarks using standard machinery classical planning landmark discovery 
theorem    osp task   landmark l l landmark  
proof  proof rather straightforward  let p set plans
qb        p set plans   definition p  plan p 
exists proposition hv di uv  d      hv di s  jk  likewise  since
s 
   s ff  hg  i  o  applicable

s    ffhence  definition


ohv di  
ohv di applicable s 
hg  i

j

k 

is 


 
hv di
hv di p   turn 

l landmark   ohv di contains operator l  l o 
contains operator l well  proves landmarks l
operators  landmarks  

theorem    hand  derive  landmarks using method
classical planning landmark extraction  employed lama planner  richter et al         lm cut family techniques  helmert   domshlak       
bonet   helmert         however  first glance  discriminative power knowing
needed achieve something valuable seems negligible comes deriving effective heuristic estimates osp  good news that  osp  information
effectively exploited slightly different way 
   

fidomshlak   mirkis

consider schematic example searching optimal plan ops task
budget b  using bfbb admissible heuristic h  suppose one
sequence  all unit cost  operators    ho    o            ob   i  applicable initial state
  positive value state along end state  clearly
value higher zero achieved given budget b  search
continue beyond initial state  unless h s      counts cost b     operators
  now  suppose h s      counts cost  oi           ob         
 o      o              oi    discovered  landmarks   given that  suppose
modify  a  setting cost operators o    o            oi  zero   b  reducing
budget b      since operators o    o            oi  applied anyway
along value collecting plan   modification seems preserve semantics
  time  modified task  bfbb heuristic h prune
initial state thus establish without search empty plan optimal plan
  course  way modified example simplistic example itself 
yet  example motivate idea landmark based budget reduction osp 
well illustrates basic idea behind generically sound task modifications
discuss next 

definition   let   hv  s    u  o  c  bi osp task  l    l            ln   set
pairwise disjoint  landmarks   lcost admissible landmark cost function
l  budget reducing compilation osp task l   hvl   s l   ul   ol   cl   bl

n
x
bl   b
lcost li  
    
i  


vl   v  vl            vln  
dom vli            
s l   s   hvl    i           hvln   i  
ul   u 
ol  

n
 
i  

oli  

n
 

 o   li   

i  

pre o    pre o   hvli   i  eff o    eff o   hvli   i  
 
c o  
 oo
cl     
 
c o  lcost li      oli
words  l extends structure
mirroring operators  landmark li cheaper lcost li   versions 
   

fion oversubscription planning heuristic search

cbb

o 
o 

o  o 
abb

o 
o 

o 
btb
o 
o 
bbb
o 
o 
bbt
o 

ctb

o 
o 
o 
btt
o 
o 
o 
o 
cbt
o 

u  

o 
o 
o 

u  

ccb

o 
o  
o 
o 
ctt
o 
o 
u  

o 
o 
o 
o  
o 

ctc

u  
cct

o 
u  
o 
o 
o 
ccc
o  
o 

cbc

 a 
u  

cbb
ctb

o 
abb

o 

bbb

btb
o 
o 
o 
o 
bbt

o 
o 
o 
btt

o 
o 
o 

o 
o 

o 

cbb

o  
o 
ctt

u  
cbt

o  
o 

u  

ccb

o 
o 

ctc

o  o 

o  u  

o 
u  
cct

ccc

abb

o  
o 

cbc

o 
o 

o 
btb
o 
o 
bbb
o 
o 
bbt
o 

o 
o 

ctb

o 
o 
o 
btt
o 
o 
o 
o 
cbt
o 

o 
o 
o 

o 
o 
o 
o  
o 

u  
ccb

o 
o  
o 
o 
ctt
o 
o 
u  

u  
ctc

u  
cct

o 
u  
o 
o 
o 
ccc
o  
o 

cbc

figure     illustrations example landmark based budget reducing compilation
l    a  structurally reachable parts graphical skeleton model
induced l   illustrated projection l variables original
task   along comparison budget wise reachable parts
graphical skeletons induced models  b  original task  c 
compiled task l  

using disposable propositions hvl    i           hvln   i ensure one
instance discounted operators li applied along operator
sequence initial state    
compensating discounted operators li reducing budget precisely
lcost li   
example  consider simple osp task figure    p       cost budget
b      assume provided set four landmarks l    l            l   
l     o     l     o     l     o    o    l     o    o     admissible landmark cost
function lcost li            compiling  l  lcost  using budget reducing
compilation definition
  results task l budget bl     c o     
discounted operators ni   oli    o    o    o    o    o    o    
states correspond complete assignments three variables v  
 t  x  y   l already seven variables vl    t  x  y  vl    vl    vl    vl     thus  depicting
    note that  auxiliary variable g  compilation effectively change value
hg  i hg  i  auxiliary variables vli l change values  only  hvli   i hvli   i 
difference reflects positive semantics usually associated value    aka value
true  planning propositions  semantics state l containing proposition hvli   i
still allowed apply  one the  discounted operators associated landmark li
onwards 

   

fidomshlak   mirkis

compile and bfbb     hv  s    u  o  c  bi 
    compilation
l    set landmarks
lcost    admissible landmark cost function l
l    budget reducing compilation  l  lcost 
n    bfbb l  
return plan associated n
figure     bfbb search landmark based budget reduction
structurally reachable parts graphical skeleton gml problematic  still 
illustrate search space   figure    a  show  structurally reachable parts
the  graphical skeleton model induced projection variables
 t  x  y  only  arcs corresponding discounted operators colored  color
distinguishing landmark responsible respective discounted operators 
figures    b     c  illustrate effect budget reducing compilation depicting parts graphical skeletons gm gml actually reachable
respective cost budgets b     bl      states btt ctt
reachable initial state budget allowance    states corresponding btt ctt longer reachable l   reducing size search space
bfbb  time  formulated theorem    below  reduction
search space affect plans lead valuable states  resulting effective
equivalence l  
theorem    let   hv  s    u  o  c  bi osp task  l set pairwise disjoint
 landmarks   lcost admissible landmark cost function l  l
respective budget reducing compilation   every qb        
plan l l qbl  l     qb     vice versa 
proof theorem    appears appendix a  p       budget reducing ospto osp compilation definition   clearly polynomial time  compile and bfbb
procedure  depicted figure    
    generates  compilation  
    uses off the shelf tools classical planning generate set landmarks l
admissible landmark cost function lcost 
    compiles  l  lcost    obtaining osp task l  
optimal solution l  and thus   searched using search algorithm
optimal osp bfbb 
proceed consider general sets landmarks  comments concerning setup theorem    order  first  reduced budget bl turns
lower cost cheapest action applicable initial state  obviously
search needed  empty plan reported optimal right away  second 
   

fion oversubscription planning heuristic search

zero cost landmarks useless compilation much useless deriving
landmark heuristics optimal planning  hence  lcost follows assumed
strictly positive  third  applicable state brings benefits
yet adds branching search  hence  implementation  landmark li l
operator li   precondition regular operators ol extended
 hvli   i   hard verify extension preserves correctness
l terms theorem     finally  value initial state zero  is 
empty plan positive value   compilation positive
cost landmarks all  however  easily fixed considering valuable
propositions hv di uv  d      hv di   s    ignore time
problem non zero value initial states  and assume qb          return
later systematic discussion 
    non disjoint  landmarks
budget reducing compilation l sound pairwise disjoint landmarks 
general sets  landmarks  example  consider planning task
which  operator o  c o    b  qb  hoi       qb       
operator sequences    hoi  is  value greater zero achievable  
via operator o  suppose set  landmarks l    l            ln   
n      lcost li        n  
pnthat  landmarks contain o 
case  budget l bl   b i   lcost li    cost cheapest replica
o  is  cost cheapest operator sequence achieving non zero value  
n

n

i  

i  

c o  max lcost li     b max lcost li     b

n
x

lcost li     bl  

i  

hence  state positive value reachable s l l   thus l
value equivalent sense theorem    
example shows compiling non disjoint  landmarks independently
sound  principle  made sound follows  let   hv  s    u  o  c  bi
osp task  let l    l            ln   set  landmarks   let lcost admissible
landmark cost function l  components l   hvl   s l   ul   ol   cl   bl
still defined definition    except operator sets ol            oln   latter
constructed independently other  sequentially  content
oli depending content olj   j   i  ordering sets oli
constructed arbitrary 
operator   n  let oo i denote set cost
discounted representatives introduced
construction ol            oli  

  n  operator o  li oo   i  cl  o       oli     
otherwise  oli contains operator operator
li

 
o  li

   

oo   i   

    

fidomshlak   mirkis

defined similarly definition   as 
pre o    pre o   hvli   i  
eff o    eff o   hvli   i  
 
c o  lcost li   
cl  o   
cl  o  lcost li   

li  
 

o  li oo   i 

    

compilation extended way sound arbitrary sets  landmarks 
pairwise disjoint landmarks reduces basic compilation used theorem    
general  however  extended compilation longer polynomial size
explicit representation
 oo i        lj  ji olj     
example  let l    l    l    l     l     a  b   l     a  c   l     a  d   generation
ol      a    b    effectively follows definition    ol    base set operators
eq     already  a  c  a     thus  ol      a    c    a     where         denoting
a    ai derived according eq     ai    consequently  base set operators
ol   a  d  a    a    a     resulting ol     a    d    a    a    a     where               
ai derived ai    sum  l ends       l  representatives operator a 
since non disjoint landmarks bring information  typical outputs
standard techniques landmark extraction classical planning  present
different  slightly involved  compilation polynomial sound arbitrary
sets  landmarks 
definition   let   hv  s    u  o  c  bi osp task  l    l            ln   set
pairwise disjoint  landmarks   lcost admissible landmark cost function
l  operator o  let l o  denote set landmarks l contain
o  then  generalized budget reducing compilation osp task l  
hvl   s l   ul   ol   cl   bl
bl   b

n
x

lcost li   

i  

vl   v  vl            vln  
dom vli            
s l   s   hvl    i           hvln   i  
ul   u 
ol    o   l   get l    l l 

pre o    pre o   hvl   i   l l o   
eff o    eff o   hvl   i   l l o   

    


pre get l      hvl   i  
eff get l      hvl   i  
   

    

fion oversubscription planning heuristic search




c o   p
cl      c o  ll o  lcost l  


lcost l  

 oo
 
 o

    

  get l 

illustrate compilation  let l    l    l    l    
l     a  b  
l     b  c  
l     a  c  
operators cost    let
lcost l      lcost l      lcost l        
l   vl   v  vl    vl    vl   
ol    a  b  c  get l     get l     get l     
with  e g  
pre a    pre a   hvl    i   hvl    i  
eff a    eff a   hvl    i   hvl    i  
cl  a      
and  get l    
pre get l        hvl   i  
eff get l        hvl   i  
cl  get l         
intuition behind compilation definition   follows  eq      applying
discounted operator saves total cost landmarks containing o  therefore 
executed states corresponding control propositions
 hvl   i   l l o   hold  indicating cost landmark l o  already
saved reaching s 
avoid double savings around l o   applying turns control propositions sjok 
however  considering example above  suppose optimal plan original
task contains instance operator a  followed instance operator b 
instance operator c  applying instead would block us applying b instead
b  thus value optimal plan compilation lower qb    
rescue comes get l  actions allow selective spending
individual landmark costs lcost l   example  applying saves cost
landmarks l  l    applying get l    spend lcost l    safely set
   

fidomshlak   mirkis

control proposition hvl    i  turn  enable b applied next steps 
applying b save cost l  re save cost l    way 
compilation leads equivalence l   formulated theorem   
proven appendix a  p      
theorem    let   hv  s    u  o  c  bi osp task  let l    l            ln   set
 landmarks   let lcost admissible landmark cost function l  let l
 generalized  budget reducing compilation   every qb        
plan l l qbl  l     qb     vice versa 
     landmarks   incremental bfbb
discussed earlier  value initial state zero  empty plan
positive value  thus  compilation definition  
landmarks positive cost  passing noted small problem remedied
considering valuable facts hv di uv  d      hv di   s   
consider aspect osp closely  show discovery  landmarks
incremental revelation plans bfbb combined mutually stratifying
way 
let   hv  s    u  o  c  bi osp task interest  suppose given set
plans             n   so  longer interested searching plans
achieve something  searching plans achieve something beyond
            n already achieve  specifically  let si   s  ji k end state  
set propositions d  let goods s  set propositions hv di
uv  d       new plan end state achieves something beyond             n
already achieve  then    n 
goods s    goods si       
put observation work 
definition   given osp task   hv  s    u  o  c  bi set reference states sref  
 s            sn        sref   compilation classical planning task   sref    
hv   s    g     c
v   v  x            xn   search  collect  
dom xi     dom search    dom collect           
s    s   hsearch  i   hcollect  i   hx    i           hxn   i  
g    hx    i           hxn   i  
n
 
 
oi  f inish  
i  


   

fion oversubscription planning heuristic search

   o   o  
pre o    pre o   hsearch  i  
eff o    eff o  
c  o    c o  

pre f inish     
eff f inish     hcollect  i   hsearch  i  
c  f inish      
oi    oi g   si sref   g goods d    si   
pre oi g      g  hcollect  i  
eff oi g      hxi   i  
c  oi g       
note
goal g cannot achieved without applying f inish operator 
regular operators applied f inish 
subgoal achieving operators oi g applied f inish 
way  first part plan   sref   determines plan   second part
verifies end state plan achieves subset value carrying propositions
goods d  included state sref    
theorem    let   hv  s    u  o  c  bi osp task  sref    s            sn   subset
states  l landmark   sref   l o  plan
goods s  jk    goods si      si sref   contains instance least one
operator l     o   l  
proof  assume contrary exists plan   ho            ok
goods s  jk    goods si      si sref   yet l      let  g            gn  
arbitrary set propositions goods s  jk    goods s             goods s  jk    goods sn   
respectively  construction   sref     immediate
  sref     ho            ok   f inish  o  g            on gn
plan   sref   and  assumption l    holds   sref   l    
this  however  contradicts l landmark   sref    

    solve   verify technique appears helpful many planning formalism compilations  see 
e g   work keyder geffner        

   

fidomshlak   mirkis

inc compile and bfbb     hv  o  s    c  u  bi 
initialize global variables 
n    s 
   best solution far
sref     s       current reference states
loop 
  sref        sref   compilation
l    set landmarks   sref  
lcost    admissible landmark cost function l
l    budget reducing compilation  l  lcost 
inc bfbb l   sref   n     done 
return plan associated n
inc bfbb    sref   n  
open    new max heap ordered f  n    h shni  b g n  
open insert make root node s    
closed  
best cost    
open empty  
n    open pop max  
f  n  u shn i   break
u shni    u shn i   update n    n
goods shni    goods s    s  sref  
sref    sref  shni 
termination criterion  return updated
   rest similar bfbb figure  

shni   closed g n    best cost shni  
closed   closed  shni 
best cost shni     g n 
foreach o shni  
n     make node shnijok  n 
g n      b f  n    u shn i   continue
open insert n   
return done
figure     iterative bfbb landmark enhancement
theorem    allows us define iterative version bfbb  inc compile and bfbb 
depicted figure     successive iterations inc compile and bfbb correspond
running regular bfbb successively informed    sref   compilations  
states discovered iteration making    sref   compilation used iteration    
informed 
inc compile and bfbb maintains pair global variables  set reference states
sref best solution far n   iteration loop  modified version
bfbb  inc bfbb  called    sref   compilation   created basis
   

fion oversubscription planning heuristic search

current sref   reference set sref extended inc bfbb non redundant
value carrying states discovered search  n updated search discovers
nodes higher value 
open list becomes empty node n selected list promises
less lower bound  inc bfbb returns indicator  done  best solution
n found far  across iterations inc compile and bfbb  optimal  case 
inc compile and bfbb leaves loop extracts optimal plan n   however 
inc bfbb may terminate different way  certain complementary termination
criterion satisfied  latter criterion comes assess whether updates sref
performed current session inc bfbb warrant updating    sref   compilation
restarting search  terminated way  inc bfbb returns respective indicator 
inc compile and bfbb goes another iteration loop  updated sref
n   note that  optimality algorithm holds termination
condition  latter greatly affect runtime efficiency algorithm 
theorem    inc compile and bfbb search algorithm sound complete optimal osp 
proof  first  complementary termination criterion employed inc bfbb procedure  inc compile and bfbb guaranteed terminate  complementary termination criterion checked inc bfbb proper expansion
global reference set sref   thus number calls inc bfbb inc compile and bfbb
upper bounded  s  
terms search  inc bfbb different regular bfbb procedure  turn 
theorem     additional pruning power budget reducing compilation reference
states sref affects search nodes n u shni    maxssref u s   note that 
time best solution far n updated inc bfbb  necessarily added sref
 since goods shn i  new n included goods s  sref    thus  optimal
solutions cannot pruned inc bfbb overall search inc compile and bfbb
therefore sound 

    empirical evaluation
evaluate merits landmark based budget reducing compilation  extended prototype osp solver section   following components 
   sref   compilation osp tasks arbitrary sets reference states sref  
generation disjunctive action landmarks    sref   compilations using lm cut
procedure  helmert   domshlak        fast downward 
incremental bfbb procedure inc compile and bfbb figure    
search termination criterion satisfied  only  examined node n improves
current value lower bound  i e   n becomes new best so far node n  
preliminary evaluation  added two optimality preserving enhancements search  auxiliary variables compilations increase dimensionality problem  known negatively affect quality abstraction
   

fidomshlak   mirkis

 a  blind
   

unsolved

   
   
   
   
   
   

unsolved

compile and bfbb

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr small
tpp
trucks
rovers
satellite
zenotravel

   

   
                                   
bfbb

 b  hm
   

unsolved

   
   
   
   
   

unsolved

compile and bfbb

   

   

   
                                   
bfbb

figure     comparative view empirical results terms expanded nodes  bfbb
vs  compile and bfbb   a  blind  b  abstraction hm heuristics

heuristics  domshlak et al          first devised projections respect original osp problem   open list ordered search done original
problem  is 


x
h shniv   b g n   
lcost l   
vl  shni

sv projection l state variables original osp task  
change heuristic evaluation sound  theorem    particular implies
   

fion oversubscription planning heuristic search

admissible heuristic admissible heuristic l   vice versa  second 
new node n generated  check whether
x
x
lcost l  
lcost l  g n     
g n   
l hvl   ishn 

l hvl   ishni

previously generated node n  corresponds state original
problem   is  shn  iv   shniv   so  n pruned right away  optimality
preservation enhancement established lemma    proven appendix a 
p      
lemma    let osp task    sref      sref   compilation   l set
landmarks   sref     lcost admissible landmark cost function l  l
respective budget reducing compilation  l  lcost    let     pair plans
v
l end states s  s    respectively  sv
    s 
cl       

x

lcost l  cl       

l hvl   is 

x

lcost l  

    

l hvl   is 

then  plan    extends     exists plan    extends  
  qbl       

qbl      

evaluation included regular bfbb planning   solving using landmarkbased compilation via compile and bfbb  simple setting inc compile and bfbb
described above  three approaches evaluated blind heuristic
additive abstraction heuristic hm described section    figures       depict results
evaluation terms expanded nodes  similarly experiment reported
section    task approached four different budgets  corresponding     
               minimal cost needed achieve goals task 
run restricted    minutes  figures   a   b compare number
expanded nodes bfbb compile and bfbb across four levels cost budget 
blind  a  abstraction hm  b  heuristics  figures   a   b provide similar
comparison bfbb inc compile and bfbb  figures   a   b
compile and bfbb inc compile and bfbb    figures       figures      
appendix b provide detailed view results figures        respectively 
breaking different levels cost budget 
figure   shows  results satisfactory  informative heuristic
guidance all  number nodes expanded compile and bfbb typically much
lower number nodes expanded bfbb  difference reaching three
orders magnitude once      task budget pairs behind figure  a    
pairs solved compile and bfbb search  by proving plan
achieve value higher initial state   while  unsurprisingly   
tasks solved search bfbb 
    present detailed comparison terms running times  per node cpu
time overhead due landmark based budget reduction      technical difficulties
implementation inc compile and bfbb led us limit comparison graph tasks
solved methods 

   

fidomshlak   mirkis

 a  blind
   
   
inc compile and bfbb

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr small
tpp
trucks
rovers
satellite
zenotravel

   
   
   
   
   
   
   
                                   
bfbb

 b  hm
   
inc compile and bfbb

   
   
   
   
   
   
   
   
                                   
bfbb

figure     comparative view empirical results terms expanded nodes  bfbb
vs  inc compile and bfbb   a  blind  b  abstraction hm heuristics

expected  impact landmark based budget reduction lower
search equipped meaningful heuristic  figure   b   nonetheless  even
abstraction heuristic hand  number nodes expanded compile and bfbb
often substantially lower number nodes expanded bfbb  here  bfbb
compile and bfbb solved search       task budget pairs  respectively  finally  despite rather ad hoc setting incremental inc compile and bfbb procedure 
switching compile and bfbb inc compile and bfbb typically beneficial  obvi   

fion oversubscription planning heuristic search

 a  blind
   
   
inc compile and bfbb

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr small
tpp
trucks
rovers
satellite
zenotravel

   
   
   
   
   
   
     
                                  
compile and bfbb

 b  hm
   
inc compile and bfbb

   
   
   
   
   
   
   
     
                                  
compile and bfbb

figure     comparative view empirical results terms expanded nodes 
compile and bfbb vs  inc compile and bfbb   a  blind  b  abstraction hm heuristics

ously  much deeper investigation development inc compile and bfbb still required 
especially context choice iteration termination criterion 

   summary future work
deterministic oversubscription planning captures computational core one
important setups automated action selection  yet  despite apparent importance
   

fidomshlak   mirkis

problem  sufficiently investigated  work  progressed towards
translating spectacular advances classical deterministic planning deterministic
osp  tracing key sources progress classical planning  identified severe lack
effective approximations osp  worked towards bridging gap 
focus two classes approximation techniques underly state ofthe art optimal heuristic search solvers classical planning  state space abstractions
goal reachability landmarks  first  defined notion additive abstractions osp 
studied complexity deriving effective abstractions rich space hypotheses 
revealed substantial  empirically relevant islands tractability abstraction
discovery problem  next  showed standard goal reachability landmarks certain
classical planning tasks compiled osp task interest  resulting
equivalent osp task lower cost allowance  thus sometimes dramatically
smaller search space 
techniques proposed satisfy properties required efficient search
algorithms optimal osp  however  believe techniques  especially
landmark based budget reducing compilations  beneficial satisficing osp
optimal osp  particular difference optimal satisficing
planning appears much smaller osp classical deterministic planning 
many interesting questions remain open future work  prospects
developments oversubscription planning appear quite promising  within specific
context work  two interesting research directions     optimization value
partitions given cost partitions  is  optimizing abstraction discovery ap  c      
    thoroughly investigating interleaved landmark discovery search osp
introduced section      broader context  propose  well  additional candidates
future research 
following work katz domshlak      a  implicit abstractions classical planning  computational merits implicit abstractions osp
investigated  inevitably give us better understanding computational
tractability boundaries deterministic osp 
basic model deterministic planning section     used provide unifying
comparative view basic models classical  cost bounded  net benefit 
oversubscription planning  one practically motivated extension model lift
action costs vectors action costs  variant cost bounded planning
already investigated  nakhost et al          natural examine
extension context osp 
unfortunately  results abstractions seem extend directly vectors
costs  level planning model  adding cost measures shifts problem solving
polynomial time shortest path s  problems np hard restricted shortest path s 
problems  handler   zang         nonetheless  knapsack problem  restricted shortest path problem solved pseudo polynomial time  desrochers
  soumis         thus extension results vectors costs might still
achievable 
time  machinery landmark based budget reducing compilations
osp straightforwardly extends vectors costs budgets  hence  even
   

fion oversubscription planning heuristic search

quality heuristic osp multiple cost measures available  blind search
still stratified information coming problem landmarks 
pruning mechanism bfbb must rely admissible  upper bounding
heuristic estimates  special properties required heuristic used guide
search choices bfbb  thus  developing informative yet necessarily admissible
heuristics osp clearly interest 
acknowledgments
work partially supported eoard grant fa                isf
grant         

appendix a  proofs
theorem   given osp task   hv  s    u  o  c  bi homomorphic abstraction
skeleton     g                  gk   k     
    cost partition c cp   exists budget partition b bp

m c u b   value partitions u  
    budget partition b bp   exists cost partition c cp

m c  u b  value partitions u  
proof  let   h s    o    s      s    o    s              sn      sn  i optimal s   plan  
and   k   let   h i  s     o     s               i  sn        on   i mapping
gi   since homomorphic  paths             k well defined 
    p
given cost partition c cp   let budget profile b b defined b  i   

j n  c i  oj     k   first  note b bp since
x
i k 

  

x x

b  i   

c i  oj  

i k  j n 

x

  

c oj   b 

j n 

   c cost partition     s   plan  
second  u u  construction b    s    plan abstract
 c u b  
model mi
  now  let u    k   let optimal  s    plan
 c u b  
mi
 
x
i k 

qb

 i 

  

 i  

x

 i 

qb

  

 i   qb    

    

i k 

   optimality       sn   end state u
value partition  therefore   c  u  b   induces additive abstraction  

is  m c u b   aas  
   

fidomshlak   mirkis

    given budget partition b  let cost profile c c defined c  i  o    c o  b i 
b  
forpall operators o   k   first  c cp since b bp implies
 

i k  b i          second  u u  construction c    s   b
 c  u b 

plan mi
  following exactly line reasoning eq    

accomplishes proof m c  u b  aas u  

lemma   algorithm figure  a computes  u  
proof  due boundness non emptiness polytope induced lm
    termination algorithm straightforward  thus  given strong   binary partition u 
question whether value algorithm terminates  u   first  let
us show that 
    k   x solution lm
    x   b if  cost partition
c cp   exists budget partition b bp  c  u  b  abstraction
hm c u b   s    m 
   assume contrary that  cost partition c cp   exists budget partition b bp hm c u b 
 s    m  yet x     b  given values provided x cost variables oo  c i  o    let c corresponding cost partition 
            k induced lengths shortest paths    s             k  s    valued states g            gk   respectively  assumption  let b budget partition
hm c u b   s    m  first  definition strong   binary value partitions 
hm c u b   s    implies exists z k   z    that  z  b i   
second  constraint    c   maximization   fact bound b i 
imply together that  z  x b i       putting things together  obtain
bbp

b

x

b i 

iz

x

 

iz

x

   c 

x b i    

iz

contradicting assumption 
   assume contrary that  x   b  yet exists cost partition c cp
that  budget partitions b bp  c  u  b  ap   hm c u b   s      m 
let shortest path lengths             k defined above  respect
specific cost partition c assumption 
likewise  let xc solution lm
 

extra constraint cost variables oo  c i  o   assigned c  since objective
lm
  maximize value  
x   xc    

    

now  let
z 

argmax

x

z    k   z     m iz  

   

 

fion oversubscription planning heuristic search

together  constraint    c   maximization   fact bound
b i   via cost variables  imply
xc     

x

xc  b i    

iz

x

 

    

iz

turn  together x   b eq      eq     implies
 
xc  b i   
b i   
  

iz
otherwise

budget partition  c  u  b  ap   hm c u b   s    m  contradicting assumption 
proved sub claim     basically captures semantics lm
    suppose
algorithm terminates within loop  returns     
construction algorithm  x solution lm
    x   b      cost
partition c cp   exists  c  u  b  ap h c u b   s  m    k 
trivially  u    m  otherwise    k  know algorithm terminate
previous iteration corresponding      again     implies exists
cost partition c cp  c  u  b  ap induce h c u b   s   m       hence 
definition  u    u     m       turn  since u strong   binary value
partition   u    m  finally  algorithm terminates loop
returns    precisely argument basis    implies  u      

lemma         mini k    algorithm figure   a computes
 u   
proof  arguments boundness non emptiness polytope induced
lv  precisely polytope lm
  studied lemma    thus
termination algorithm straightforward  follows  prove value
returned algorithm satisfies claim lemma  let u given   binary
partition  similarly proof lemma    first prove sub claim that 
   v r     x solution lv    x   b if  cost partition
c cp   exists budget partition b bp  c  u  b  abstraction
hm c u b   s    v 
proof    mirrors proof respective sub claim lemma    mutatis mutandis 
thus provided ease verification 
   assume contrary that  cost partition c cp   exists budget
partition b bp hm c u b   s    v  yet x     b 

given values provided x cost variables oo  c i  o    let c corresponding cost partition  and   k   let induced length shortest
path  s     valued states gi   assumption  let b budget
partition hm c u b   s    v  first 
p definition   binary value partitions 
hm c u b   s    v implies exists z k  iz v that  z  b i   
   

fidomshlak   mirkis

second  constraint    c   maximization   fact bound b i 
  imply together that  z  x b i       putting things together  obtain
bbp

b

x

b i 

iz

x

 

iz

x

   c 

x b i    

iz

contradicting assumption 
   assume contrary that  x   b  yet exists cost partition c cp
that  budget partitions b bp  c  u  b  ap   hm c u b   s      v 
let shortest path lengths             k defined above  respect
specific cost partition c assumption 
likewise  let xc solution lv 

extra constraint cost variables oo  c i  o   assigned c  since objective
lv  maximize value  
x   xc    

    

now  let
z   argmax

x

 
pz  k   iz  
iz   v

 

together  constraint    c   maximization   fact bound
b i   via cost variables  imply
xc     

x

xc  b i    

iz

x

 

    

iz

turn  together x   b eq      eq     implies
 
xc  b i    z
b i   
 
  
otherwise
budget partition  c  u  b  ap   hm c u b   s    v  contradicting assumption 
finalizes proof sub claim     now pconsider interval end points
termination
while loop   
i k    then  trivially   u   
p
otherwise    i k    then  construction algorithm  iteration
loop  test always achievable   issued  came back negative  thus 
solutions x l    x      b  hence       u      now        then 
construction algorithm  iteration loop  test always achievable  
issued  came back positive  thus  solutions x l    x    b 
hence       u    putting properties together while loops
termination condition implies  u     u    finally      
  mini k  implies   mini k    turn  since  u  corresponds sum values
states k models m c u b     u  concluded implies    u      

   

fion oversubscription planning heuristic search

theorem    let   hv  s    u  o  c  bi osp task  l set pairwise disjoint
 landmarks   lcost admissible landmark cost function l  l
respective budget reducing compilation   every qb        
plan l l qbl  l     qb     vice versa 
proof  let l plan
snfor l   let operator sequence obtained replacing
operators i   oli along l respective operators o 
definition
action set l eq      applicable s    s  jk  
s l jl k   ni   dom vli    thus  qb      qbl  l    likewise  definition
action set l eq     fact operator ol achieves control
propositions  hvl    i           hvln   i    oli l      that 

c   cl  l    

n
x

lcost li   

i  

p
turn  b   bl   ni   lcost li   eq      cl  l   bl virtue l
plan l   therefore  holds c   b  thus plan  
opposite direction  let plan qb         let l
operator sequence obtained replacing   landmark l l  every first occurrence
operator l respective cost reduced operator ol   easy
verify l applicable s l   qbl  l     qb     likewise  definition
 landmarks  every l l presence along   that 

c l     c  

n
x

lcost li   b

i  

n
x

lcost li     bl  

i  

first equality pairwise disjointness  l            ln    inequality
plan   second equality eq      thus  l plan l  


theorem    let   hv  s    u  o  c  bi osp task  let l    l            ln   set
 landmarks   let lcost admissible landmark cost function l  let l
 generalized  budget reducing compilation   every qb        
plan l l qbl  l     qb     vice versa 
proof  let l plan l   let operator sequence obtained  i  replacing
operators respective operators o   ii  removal get operators 
eq      applicable s    s  jk   s l jl k    hvl    i           hvln   i   thus 
qb      qbl  l    now   landmark l l  let  l  number instances
cost reduced counterparts operators l along l   eqs        
l l  l must contain least  l    instances operator get l   that 

   

fidomshlak   mirkis

x

c   cl  l    

x

lcost l 

ol ll o 

  cl  l    

x
x

  l    lcost l 



 l lcost l 



  cl  l    

x

x

  l    lcost l 



lcost l 



bl  

x

lcost l 



  b 
thus plan  
opposite direction  let   ho            om plan qb        
definition  landmarks  every landmark li l presence along   let
 i    f  i   n   first occurrence
ffoperator li along   is  f  i   


let   o              o k    k n  operator sequence obtained
argminj m   oj li   
ordering operators i n   of  i    consistently   note that  since  landmarks
l necessarily disjoint  may f  i    f  j       j n  thus
k strictly smaller n 
given above  let l operator sequence obtained based
    replacing o i  along o i   
    inserting right o i  arbitrary ordered sequence actions
i 
 

 get l    l l   o j    o i    l  

    

j  

note set union semantics eq      even multiple operators  o              o i    
appear landmark l together o i    one instance operator get l 
inserted step     o i   
hard verify l applicable s l   qbl  l     qb     now 
step     expanding l reduces cost operator sequence
k
x

x

lcost l   

i   ll o i   

x

 l lcost l  



 l  number occurrences operators fromp
l   turn  step    
expanding l increases cost operator sequence   l    lcost l  
because  eq      among  l  operators o i  along l o i  l 
first preceded dedicated instances operator get l   thus 
x
x
cl  l     c  
lcost l  b
lcost l    bl  




is  l plan l  


   

fion oversubscription planning heuristic search

lemma    let osp task    sref      sref   compilation   l set
landmarks   sref     lcost admissible landmark cost function l  l
respective budget reducing compilation  l  lcost    let     pair plans
v
l end states s  s    respectively  sv
    s 
cl       

x

lcost l  cl       

then  plan
b
l
q         qbl       

lcost l  

    

l hvl   is 

l hvl   is 

  

x

extends     exists plan    extends  

proof  notation claim  proof constructive mapping plan
   corresponding plan     
first  derive    plan     i  removing f inish operator
get   operators   ii  replacing instances discounted operator
instances respective original operator o  results plan          e
p
s           sv
  c       cl       
l hvl   is  lcost l   see latter 

operator ol   let      denote number instances along     given that 

c       cl     

x

 get l  lcost l   



x

  cl       

lcost l 



  cl       

x

x

x

 o 



o ll o 






x

lcost l 

 o   get l  

o ll o 

    

lcost l   s   hvl   i 



  cl       

x

lcost l  

l hvl   is 

second fourth equalities formula manipulations  first equality
direct construction     third equality definition budget
reducing compilation  specifically  eqs        
similarly construction p
      construct      

s           sv

c 
 
 
c
 
 
 
 
 
l
 
l hvl   is  lcost l   thus  eq      c     c     
also  setting lemma  s           s          hence          e plan
  qb         qb       
last step  construct    plan    l claim  first 
properties   claim  plan   achieves landmarks l s     l  
hvl   i s     second  definition landmark set l   e must satisfy rest
landmarks  is  ls     l   hvl   i s     let us denote operator instances along
 e ho            ok i  k     e    let  l            lk   partition ls  li ls 
subset landmarks ls  oi first achiever along  e  
given that  consider operator sequence  e     k    recursively defined via        
and  li      i     i   hoi i  else  i     i   hoi i   arbitrary 
   

fidomshlak   mirkis

sequencing operators
 get l    l li hvl   i s  j  kj  i   k  
finally  set          e  
eqs        definition budget reducing compilation 
easy
p
verify construction  e ensures cl   e     c  e   hvl   is  lcost l 
qbl   e     qb        turn  properties     implies qbl         qbl      
cl         cl        cl   e   
finally  since
x
lcost l 
cl        c    
hvl   is 


x

cl   e     c  e  

lcost l  

hvl   is 


cl         c       c  e  

x

lcost l  



thus  since c     c             e valid plan  
x
cl       c       c  e  
lcost l 




c     



x

lcost l 



b

x

lcost l  



finalizing proof    plan l claim 

   



fion oversubscription planning heuristic search

appendix b  detailed evaluation results
 a 
   

unsolved

   
   
   
hm

   
   
   

unsolved

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr small
tpp
trucks
rovers
satellite
zenotravel

   

     
                                  
blind

 b 
   

unsolved

   
   
hm

   
   
   
unsolved

   
   

     
                                  
basic

figure     comparison figure    p       restricted tasks budgeted    
minimal cost achieving entire set subgoals

   

fidomshlak   mirkis

 a 
   

unsolved

   
   
   
hm

   
   
   

unsolved

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr small
tpp
trucks
rovers
satellite
zenotravel

   

     
                                  
blind

 b 
   

unsolved

   
   
hm

   
   
   
unsolved

   
   

     
                                  
basic

figure     comparison figure    p       restricted tasks budgeted    
minimal cost achieving entire set subgoals

   

fion oversubscription planning heuristic search

 a 
   

unsolved

   
   
   
hm

   
   
   

unsolved

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr small
tpp
trucks
rovers
satellite
zenotravel

   

     
                                  
blind

 b 
   

unsolved

   
   
hm

   
   
   
unsolved

   
   

     
                                  
basic

figure     comparison figure    p       restricted tasks budgeted    
minimal cost achieving entire set subgoals

   

fidomshlak   mirkis

 a 
   

unsolved

   
   
   
hm

   
   
   

unsolved

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr small
tpp
trucks
rovers
satellite
zenotravel

   

     
                                  
blind

 b 
   

unsolved

   
   
hm

   
   
   
unsolved

   
   

     
                                  
basic

figure     comparison figure    p       restricted tasks budgeted     
minimal cost achieving entire set subgoals

   

fion oversubscription planning heuristic search

 a  blind
   

unsolved

   
compile and bfbb

   
   
   
   
   

unsolved

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr small
tpp
trucks
rovers
satellite
zenotravel

   

   
                                   
bfbb

 b  hm
   

unsolved

compile and bfbb

   
   
   
   
   
unsolved

   
   

   
                                   
bfbb

figure     comparison figure     p       restricted tasks budgeted    
minimal cost achieving entire set subgoals

   

fidomshlak   mirkis

 a  blind
   

unsolved

   
compile and bfbb

   
   
   
   
   

unsolved

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr small
tpp
trucks
rovers
satellite
zenotravel

   

   
                                   
bfbb

 b  hm
   

unsolved

compile and bfbb

   
   
   
   
   
unsolved

   
   

   
                                   
bfbb

figure     comparison figure     p       restricted tasks budgeted    
minimal cost achieving entire set subgoals

   

fion oversubscription planning heuristic search

 a  blind
   

unsolved

   
compile and bfbb

   
   
   
   
   

unsolved

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr small
tpp
trucks
rovers
satellite
zenotravel

   

   
                                   
bfbb

 b  hm
   

unsolved

compile and bfbb

   
   
   
   
   
unsolved

   
   

   
                                   
bfbb

figure     comparison figure     p       restricted tasks budgeted    
minimal cost achieving entire set subgoals

   

fidomshlak   mirkis

 a  blind
   

unsolved

   
compile and bfbb

   
   
   
   
   

unsolved

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr small
tpp
trucks
rovers
satellite
zenotravel

   

     
                                  
bfbb

 b  hm
   

unsolved

compile and bfbb

   
   
   
   
   
unsolved

   
   

     
                                  
bfbb

figure     comparison figure     p       restricted tasks budgeted     
minimal cost achieving entire set subgoals

   

fion oversubscription planning heuristic search

 a  blind
   
   
inc compile and bfbb

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr small
tpp
trucks
rovers
satellite
zenotravel

   
   
   
   
   
   
   
                                   
bfbb

 b  hm
   

inc compile and bfbb

   
   
   
   
   
   
   
   
                                   
bfbb

figure     comparison figure     p       restricted tasks budgeted    
minimal cost achieving entire set subgoals

   

fidomshlak   mirkis

 a  blind
   
   
inc compile and bfbb

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr small
tpp
trucks
rovers
satellite
zenotravel

   
   
   
   
   
   
   
                                   
bfbb

 b  hm
   

inc compile and bfbb

   
   
   
   
   
   
   
   
                                   
bfbb

figure     comparison figure     p       restricted tasks budgeted    
minimal cost achieving entire set subgoals

   

fion oversubscription planning heuristic search

 a  blind
   
   
inc compile and bfbb

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr small
tpp
trucks
rovers
satellite
zenotravel

   
   
   
   
   
   
   
                                   
bfbb

 b  hm
   

inc compile and bfbb

   
   
   
   
   
   
   
   
                                   
bfbb

figure     comparison figure     p       restricted tasks budgeted    
minimal cost achieving entire set subgoals

   

fidomshlak   mirkis

 a  blind
   
   
inc compile and bfbb

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr small
tpp
trucks
rovers
satellite
zenotravel

   
   
   
   
   
   
     
                                  
bfbb

 b  hm
   

inc compile and bfbb

   
   
   
   
   
   
   
     
                                  
bfbb

figure     comparison figure     p       restricted tasks budgeted     
minimal cost achieving entire set subgoals

   

fion oversubscription planning heuristic search

references
backstrom  c     klein  i          planning polynomial time  sas pubs class 
computational intelligence                
backstrom  c     nebel  b          complexity results sas  planning  computational
intelligence                 
baier  j  a   bacchus  f     mcilraith  s          heuristic search approach planning
temporally extended preferences  artificial intelligence                    
benton  j   coles  a  j     coles  a  i          temporal planning preferences
time dependent continuous costs  proceedings   nd international conference
automated planning scheduling  icaps   pp      
benton  j   do  m     kambhampati  s          anytime heuristic search partial satisfaction planning  artificial intelligence                    
benton  j   van den briel  m     kambhampati  s          hybrid linear programming
relaxed plan heuristic partial satisfaction planning problems  proceedings
seventeenth international conference automated planning scheduling
 icaps   pp       
bertsimas  d     vempala  s          solving convex programs random walks  journal
acm                 
bonet  b          admissible heuristic sas  planning obtained state
equation  proceedings   rd international joint conference artificial
intelligence  ijcai   pp           
bonet  b     geffner  h          planning heuristic search  artificial intelligence        
        
bonet  b     geffner  h          heuristics planning penalties rewards formulated logic computed circuits  artificial intelligence              
         
bonet  b     helmert  m          strengthening landmark heuristics via hitting sets 
proceedings   th european conference artificial intelligence  ecai   pp 
       
brafman  r  i     chernyavsky  y          planning goal preferences constraints 
proceedings international conference automated planning scheduling  pp         
clarke  e   grumberg  o     peled  d          model checking  mit press 
coles  a  i   fox  m   long  d     smith  a  j          additive disjunctive heuristics
optimal planning  proceedings   th international conference automated
planning scheduling  icaps   pp       
coles  a  j   coles  a   fox  m     long  d          hybrid lp rpg heuristic modelling
numeric resource flows planning  journal artificial intelligence research     
       
   

fidomshlak   mirkis

coles  a  j     coles  a  i          lprpg p  relaxed plan heuristics planning
preferences  proceedings   st international conference automated planning scheduling  icaps   pp       
cousot  p     cousot  r          abstract interpretation frameworks  journal logic
computation                
dantzig  g  b          linear programming extensions  princeton university press 
dantzig  t          number  language science  macmillan 
desrochers  m     soumis  f          generalized permanent labelling algorithm
shortest path problem time windows  information systems operations
research             
do  m  b   benton  j   van den briel  m     kambhampati  s          planning goal
utility dependencies  proceedings   th international joint conference
artificial intelligence  ijcai   pp           
domshlak  c   hoffmann  j     sabharwal  a          friends foes  planning
satisfiability abstract cnf encodings  journal artificial intelligence research 
           
domshlak  c   katz  m     lefler  s          landmark enhanced abstraction heuristics 
artificial intelligence            
dudzinski  k     walukiewicz  s          exact methods knapsack problem
generalizations  european journal operational research          
dvorak  f     bartak  r          integrating time resources planning  proceedings   nd ieee international conference tools artificial intelligence
 ictai   pp       
edelkamp  s          planning pattern databases  proceedings european
conference planning  ecp   pp       
edelkamp  s          taming numbers durations model checking integrated
planning system  journal artificial intelligence research             
fikes  r  e     nilsson  n          strips  new approach application theorem
proving problem solving  artificial intelligence            
fox  m     long  d          pddl     extension pddl expressing temporal
planning problems  journal artificial intelligence research            
garey  m  r     johnson  d  s          computers intractability  guide theory
np completeness  w h  freeman company  new york 
geffner  h     bonet  b          concise introduction models methods automated planning  synthesis lectures artificial intelligence machine learning 
morgan   claypool 
gerevini  a   haslum  p   long  d   saetti  a     dimopoulos  y          deterministic
planning fifth international planning competition  pddl  experimental
evaluation planners  artificial intelligence                    
   

fion oversubscription planning heuristic search

gerevini  a   saetti  a     serina  i          planning stochastic local search
temporal action graphs lpg  journal artificial intelligence research         
    
gerevini  a   saetti  a     serina  i          approach efficient planning numerical
fluents multi criteria plan quality  artificial intelligence                    
grotschel  m   lovasz  l     schrijver  a          ellipsoid method consequences
theorems combinatorial optimization  combinatorica            
handler  g     zang  i          dual algorithm constrained shortest path problem 
networks             
haslum  p          heuristics bounded cost search  proceedings   rd international conference automated planning scheduling  icaps   pp         
haslum  p   bonet  b     geffner  h          new admissible heuristics domainindependent planning  proceedings   th national conference artificial
intelligence  aaai   pp           
haslum  p   botea  a   helmert  m   bonet  b     koenig  s          domain independent
construction pattern database heuristics cost optimal planning  proceedings
  th national conference artificial intelligence  aaai   pp           
haslum  p     geffner  h          admissible heuristics optimal planning  proceedings   th international conference artificial intelligence planning systems
 aips   pp         
haslum  p     geffner  h          heuristic planning time resources  proceedings
 th european conference planning  ecp   pp         
helmert  m          decidability undecidability results planning numerical
state variables  proceedings sixth international conference artificial
intelligence planning scheduling  aips   pp       
helmert  m          fast downward planning system  journal artificial intelligence
research             
helmert  m     domshlak  c          landmarks  critical paths abstractions  whats
difference anyway   proceedings   th international conference automated planning scheduling  icaps   pp         
helmert  m   haslum  p     hoffmann  j          flexible abstraction heuristics optimal
sequential planning  proceedings   th international conference automated
planning scheduling  icaps   pp         
helmert  m   haslum  p   hoffmann  j     nissim  r          merge and shrink abstraction 
method generating lower bounds factored state spaces  journal acm 
               
hoffmann  j          metric ff planning system  translating ignoring delete lists
numeric state variables  journal artificial intelligence research             
hoffmann  j   gomes  c  p   selman  b     kautz  h  a          sat encodings statespace reachability problems numeric domains  proceedings   th international joint conference artificial intelligence  ijcai   pp           
   

fidomshlak   mirkis

hoffmann  j     nebel  b          planning system  fast plan generation
heuristic search  journal artificial intelligence research             
hoffmann  j   porteous  j     sebastia  l          ordered landmarks planning  journal
artificial intelligence research             
karp  r          reducibility among combinatorial problems  complexity computer
computations  pp         plenum press  new york 
karpas  e     domshlak  c          cost optimal planning landmarks  proceedings
international joint conference artificial intelligence  ijcai      pp      
     
katz  m     domshlak  c       a   implicit abstraction heuristics  journal artificial
intelligence research            
katz  m     domshlak  c       b   optimal admissible composition abstraction heuristics  artificial intelligence              
kellerer  h   pferschy  u     pisinger  d          knapsack problems  springer verlag
berlin 
keyder  e     geffner  h          soft goals compiled away  journal artificial
intelligence research             
koehler  j          planning resource constraints  proceedings   th european
conference artificial intelligence  ecai   pp         
mirkis  v     domshlak  c          abstractions oversubscription planning  proceedings   rd international conference automated planning scheduling
 icaps   pp         
mirkis  v     domshlak  c          landmarks oversubscription planning  proceedings
  rd european conference artificial intelligence  ecai   pp         
nakhost  h   hoffmann  j     muller  m          resource constrained planning  monte
carlo random walk approach  proceedings   nd international conference
automated planning scheduling  icaps   pp         
nebel  b          compilability expressive power propositional planning
formalisms  journal artificial intelligence research             
nemirovsky  a     yudin  n          interior point polynomial methods convex programming  siam 
pearl  j          heuristics   intelligent search strategies computer problem solving 
addison wesley 
pommerening  f     helmert  m          incremental lm cut  proceedings   rd
international conference automated planning scheduling  icaps   pp     
     rome  italy 
porteous  j   sebastia  l     hoffmann  j          extraction  ordering  usage
landmarks planning  proceedings  th european conference planning
 ecp      pp       
   

fion oversubscription planning heuristic search

punnen  a  p          k sum linear programming  journal operational research
society                 
richter  s   helmert  m     westphal  m          landmarks revisited  proceedings
  rd aaai conference artificial intelligence  aaai      pp         
russell  s     norvig  p          artificial intelligence  modern approach    edition  
pearson 
sanchez  r     kambhampati  s          planning graph heuristics selecting objectives over subscription planning problems  proceedings   th international
conference automated planning scheduling  icaps   pp         
smith  d          choosing objectives over subscription planning  proceedings
  th international conference automated planning scheduling  icaps   pp 
       
thayer  j  t     ruml  w          bounded suboptimal search  direct approach using
inadmissible estimates  proceedings   nd international joint conference
artificial intelligence  ijcai   pp         
thayer  j  t   stern  r  t   felner  a     ruml  w          faster bounded cost search
using inadmissible estimates  proceedings   nd international conference
automated planning scheduling  icaps   pp         
van den briel  m   sanchez  r   do  m  b     kambhampati  s          effective approaches
partial satisfaction  over subscription  planning  proceedings   th aaai
conference artificial intelligence  aaai   pp         
van den briel  m   benton  j   kambhampati  s     vossen  t          lp based heuristic optimal planning  proceedings   th international conference
principles practice constraint programming  cp   pp         
yang  f   culberson  j   holte  r   zahavi  u     felner  a          general theory
additive state space abstractions  journal artificial intelligence research     
       

   


