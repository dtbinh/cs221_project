journal articial intelligence research                  

submitted        published      

lazy model expansion 
interleaving grounding search

broes decat gmail com

broes de cat

om partners  belgium

marc denecker cs kuleuven be

marc denecker

dept  computer science  kuleuven  belgium

pstuckey unimelb edu au

peter stuckey

national ict australia
dept  computing information systems
university melbourne  australia

maurice bruynooghe

dept  computer science  kuleuven  belgium

maurice bruynooghe cs kuleuven be

abstract

finding satisfying assignments variables involved set constraints
cast  bounded  model generation problem  search  bounded  models theory
logic  state of the art approach bounded model generation rich knowledge representation languages answer set programming  asp  fo   csp
modeling language zinc  ground and solve   reduce theory ground
propositional one apply search algorithm resulting theory 
important bottleneck blow up size theory caused grounding
phase  lazily grounding theory search way overcome bottleneck 
present theoretical framework implementation context fo  
knowledge representation language  instead grounding parts theory  justications
derived parts it  given partial assignment grounded part
theory valid justications formulas non grounded part  justications
provide recipe construct complete assignment satises non grounded part 
justication particular formula becomes invalid search  new one
derived  fails  formula split part grounded part
justied  experimental results illustrate power generality approach 

   introduction
world lled combinatorial problems 

include important combinatorial

optimization tasks planning  scheduling rostering  combinatorics problems
extremal graph theory  countless puzzles games  solving combinatorial problems
hard  methods know tackle involve kind search 
various

declarative paradigms

developed solve problems 



approaches  objects attributes searched represented symbols 
constraints satised objects represented expressions symbols

c      ai access foundation  rights reserved 


fide cat  denecker  stuckey   bruynooghe
declarative language  solvers search values symbols satisfy
constraints  idea found elds constraint programming  cp   apt        
asp  marek   truszczyski         sat  mixed integer programming  mip   etc 
terminology logic  declarative method amounts expressing desired properties

logical theory  data particular problem instance
partial interpretation  or structure   solving process
apply model generation  specically model expansion  mitchell   ternovska        
problem class sentences

corresponds naturally

task nding structure expands input partial structure satises
theory  resulting structure solution problem  model generation expansion 
studied example eld knowledge representation  kr   baral         thus
analogous task solving constraint satisfaction problems  studied cp 
generating answer sets logic programs  studied asp 
similarities areas go deeper extend level used techniques 

state of the art approaches often follow two phase solving methodology 



rst phase  input theory  rich language hand  reduced fragment
language supported search algorithm  second phase  search
algorithm applied reduced theory eectively search models  example 
model generation language minizinc  nethercote et al         performed reducing ground language flatzinc  search algorithms available  similarly 
language

pc  

fo  

 denecker   ternovska        reduced propositional fragment

 see  e g   wittocx  marin    denecker         asp reduced propositional

asp  see  e g   gebser  schaub    thiele         reduced theory often ground
fragment language  refer resulting reduced theory
rst phase

grounding

grounding



phase  where quantiers instantiated elements

domain   elds  grounding referred attening  unrolling  splitting
propositionalization  solving methodology generally referred

and solve 

ground 

grounding becomes bottleneck users turn applications large domains
complex constraints  indeed  easy see grounding size fo formula
exponential nesting depth quantiers arity predicates polynomial
size universe discourse 

increasing number applications

size grounded theory large memory 



example  son  pontelli  le        discuss several asp applications groundand solve approach turns inadequate 
paper  present novel approach remedy bottleneck  called

lazy model

expansion  grounding generated lazily  on the y  search  instead upfront  approach works associating justications non ground parts theory 
valid justication non ground formula recipe expand partial structure
precise  partial  structure satises formula  course  crucial
recipe lot compact grounding formula  given partial structure
valid justication non ground formulas   total  structure obtained
extending partial structure literals justications non ground
formulas  justications selected way total structure model
whole initial theory 

consequently  model generation limited grounded

part theory  model found part  extended model

   

filazy model expansion  interleaving grounding search
whole theory  however  new assignment model generation conict one
justications  case  alternative justication needs sought  none
found  associated formula split two parts  one part grounded one
part valid justication still available 

example     

consider

sokoban

problem  planning problem robot

push blocks around   d grid arrange given goal conguration  constraint
move action target position
 at time

t 

pp

moved block

bb

currently

empty  expressed

 t  b  p  b p   move b  p  t  empty p  t  

   

known advance many time steps needed  one ideally wants assume
large even innite number steps  using ground and solve  blows size
grounding  incremental grounding  iteratively extending time domain
large enough allow plan  developed avoid blow up context
planning  gebser et al          approach general depend
presence one domain incrementally increased 
returning example  instead grounding sentence      associate
justication  recipe satisfy it 

make

move b  p  t 

false

b  p







recipe  search nds model grounded part problem
conict recipe  model extended literals recipe obtain
model whole theory  however  search would decide move block

p 

b 

position

time t    conict created recipe  resolve it  instance sentence    

conict partial model search split sentence     replaced
equivalent sentences 

move b    p    t    empty p    t   

   

 t  b  p  b p   t    b    p      move b  p  t  empty p  t 

   

sentence     grounded passed search component use check


empty p    t   

holds 

sentence     non ground satised recipe

move b  p  t  false except

move b    p    t    

search makes moves 

instances grounded  search nds partial plan problem hand 
literals recipe remaining non ground formula making

move b  p  t 

false instances sentence     grounded complete plan 
main contributions paper are 



theoretical framework

lazy model expansion 

aiming minimally instantiat 

ing quantied variables  paves way solution long standing problem
handling quantiers search problems  encountered  e g   elds asp  lefvre
  nicolas        sat modulo theories  ge   de moura         framework
generalizes existing approaches related grounding bottleneck
incremental domain extension  claessen   srensson        lazy clause generation  ohrimenko  stuckey    codish        

   

fide cat  denecker  stuckey   bruynooghe


complete algorithm lazy model expansion logic

fo id   

extension

rst order logic  fo  inductive denitions  a language closely related asp
shown denecker et al          includes ecient algorithms derive consistent
sets justications maintain throughout changes partial structure
 e g   search  



idp

implementation extending

knowledge base system  de cat et al        

experiments illustrate power generality lazy grounding 
lazy grounding new step ability solve complex combinatorial problems 
avoiding up front grounding step previous approaches  lazy grounding ground
enough problem solve it  method developed logic

fo id   



become clear  justications associated rules  rules similar
rules used asp systems  hence  discussed towards end paper 
framework algorithms applied context asp 
paper organized follows 

section    necessary background nota 

tions introduced  formal denitions lazy grounding

fo id  

presented

section    followed presentation relevant algorithms heuristics sections  
   experimental evaluation provided section    followed discussion related
future work conclusion  preliminary version paper appeared work
de cat  denecker  stuckey        de cat        ch     

   preliminaries
section  provide necessary background logic
tasks model generation model expansion

fo id  

fo id   

inference

ground and solve

approach model expansion 

   

fo id  

first  dene syntax semantics logic

fo id  

 denecker   ternovska        

extension rst order logic  fo  inductive denitions  assume familiarity
fo  without loss generality  limit

fo id  

function free fragment  function

symbols always eliminated using graph predicates  enderton        
 function free  vocabulary



consists set predicate symbols 

propositional

    denoting true
false respectively  predicate symbols usually denoted p   q  r  atoms a  literals
 atoms negation  l  variables x    domain elements d  e
denote ordered set objects e            en   p n predicate p arity n 

symbols   ary predicate symbols  include symbols

methods model generating developed require  possibly innite 
domain



  domain atom

p p n dn   n tuple domain elements  likewise 

given xed  given  function free  vocabulary

atom form
consider

domain literals 

consists domain n ary relation p dn
predicate symbols p n   alternatively  n ary relation viewed
n
function  t  f    propositional symbols   respectively interpreted
f  
structure



interpreting

   

filazy model expansion  interleaving grounding search
model generation algorithms maintain


inconsistent

partial

structures may  temporarily  nd

state  example conict arises  represent

introduced  consist domain
n ary predicate p   three  four valued relation p  
n
function  t  f   u  i   structure two valued range relations  t  f   
partial three valued range  t  f   u   four valued general  thus  two valued
states  three valued four valued structures



and 

structures three valued four valued 

unqualied  term

structure

stands general  four valued case 
given xed





  alternative way represent

domain

ai

 t







 f







a  ai    inconsistent 
ai   u  unknown 

domain atom


 

domain literals 
 structures
 

set

indeed  one to one correspondence sets

otherwise  hence 

may treat four valued structures sets domain literals vice versa  structure

inconsistent least one domain atom inconsistent 

vocabulary naturally viewed structure larger
  namely setting ai   u domain atom predicate      
set predicate symbols  use i  denote restriction symbols
i 

  set domain atoms  use i s denote restriction    
i 
  u otherwise  call two valued structure two valued
domain atoms unknown otherwise 
  truth value v dened follows  t    f   f     t  u    u
inverse v
 
  i  truth order  t truth values dened  t u  t f  t  t f  
precision order  p dened  p  p u  p f  p u  orders pointwise
 
extended arbitrary  structures  say   expansion p  
 


domain atom a 
p   viewing structures sets domain literals 
 
corresponds  
structure

 
vocabulary

assume familiarity syntax  function free  fo  facilitate reasoning
partially grounded formulas  deviate standard fo quantify explicitly

x d    x d     
d  sometimes abbreviate x  d          xn dn   x     similarly
  given formula    x  indicates x free variables   substitution
variable x formula term denoted  x t   ground formula  in domain  
specied subsets domain

d 

denoted

d 

formula without variables  hence without quantiers   similar properties notations
used

rules

 introduced below  

voc t   set predicate symbols occur theory  
structure   voc i  set symbols interpreted   unless specied otherwise 
theories structures range vocabulary  
language fo id   extends fo  inductive  denitions  theory fo id  
 nite  set sentences denitions  denition  nite  set rules
form x   p  x            xn     p predicate symbol fo formula 
atom p  x  referred head rule body  given rule r   let
head  r  body r  denote respectively head body r  given denition  
domain atom p dened exists rule x   p  x 



  otherwise p open   domain literal p dened p
denote

   

fide cat  denecker  stuckey   bruynooghe
  sets dened open domain atoms denoted defined   
open    respectively 

dened


without loss generality  assume denition domain atom dened
one rule  technically  means rules

p  x   

x d    p  x      x d   

d  d      rules always made disjunct
x d  d    p  x        x d    d    p  x     

pairwise disjunct 

transforming

x d    d    p  x     
      model semantics
semantics

fo id  

two valued model semantics 

nevertheless  introduce

concepts three  four valued semantics useful dening semantics
denitions formalizing lazy grounding 

use standard four valued truth

assignment function  dened structural induction pairs fo domain formulas



interpret  


p   p  d   

structures

   i   min t       
   i   max t       
  i         
 x    i   max t    x d i   d   
 x    i   min t    x d i   d   
assignment function monotonic precision order 

p    



p

 

 

hence  formula true partial structure  true two valued expansions
it 

also 



two valued  respectively three valued  four valued 



two valued



two valued

 respectively three valued  four valued  
structure


  t 





model

 

satises

sentence



 notation

    



satisfaction relation dened denitions well  semantics

denitions based parametrized well founded semantics  extension wellfounded semantics logic programs informally described rst work van gelder
        formally dened

fo id   s

denitions denecker         semantics

formalizes informal semantics rule sets  inductive  denitions  denecker       
structure
 notation      two valued wellfounded model denoted wf   i open     structure i open    denecker
  ternovska         case wf   i open     two valued  model expanding
i open     structure satises theory two valued model
sentences denitions   next subsection  present formalization
denecker  bruynooghe    marek        denecker   vennekens        


model

 

satises

denition

well founded semantics using notion
according

fo id   s

justication 

methodology   formal  denitions used express informal

denitions  work denecker vennekens         shown

fo id  

de 

nitions oer uniform representation important types informal denitions

   

filazy model expansion  interleaving grounding search
expressing informal denitions leads rule sets



called

total

well founded model



two valued  denecker   ternovska        

total 

formally  denition

two valued structure



open  



general  totality undecidable  however

broad  syntactically dened classes denitions proven total  e g   nonrecursive  positive  stratied locally stratied denitions  see denecker   ternovska 
       inspection current

fo id  

applications shows practice  non total deni 

tions occur rarely almost always contain modeling error  also  cases totality
established simple syntactic check 

totality usefully exploited

computation  lazy grounding techniques introduced exploit totality
applied total denitions  restriction matches

fo id   s

methodology and  practice  impose strong limitation 

design

case

input theory contain denitions known total  lost 
denitions grounded completely up front  case lazy grounding applied
safely remaining sentences total denitions input 

equivalence 
equivalent

two theories





  

dierent vocabularies 

 

 
expanded model vice

restricted
  strongly  equivalent expansions
unique  extension   strong   equivalence structure dened similarly 
 
model expanding expanded model expanding vice versa 
obtain strong equivalence  expansions unique  theory   often
 
derive strongly voc t   equivalent theory given structure   transformations
 
preserve satisability number models model directly mapped
model projection voc t   
versa 

model

two theories



canonical theories 



simplify presentation  lazy grounding techniques

presented theories form

 pt     

single denition function free rules 



pt

propositional symbol 

without loss generality 



first 

mentioned above  standard techniques  enderton        allow one make theory functionfree  second  multiple denitions always combined one described denecker
ternovska        marin  gilis  denecker         achieved renaming
dened predicates denitions  merging rules one set adding
equivalence constraints predicates renamings 

             n    

equivalent theory

 pt    pt   n   



pt

 
voc t   

third  theory

resulting previous step translated strongly

new propositional symbol 

transformation results ground set sentences denition consisting
set  ground non ground  rules  lazy grounding cope non ground
rules  furthermore  assume rule bodies negation normal form  negation
occurs front atoms  that  dened domain atom
rule

x   p  x 



dd


p  

unique

 

methods proposed extended full

fo id  

functions 

extended methods implemented system  however  introduces number
rather irrelevant technicalities want avoid here 

   

fide cat  denecker  stuckey   bruynooghe
      justifications

canonical theory        explained
correspond one to one sets domain literals 

denition      direct
justication   direct justication dened domain literal p

 respectively p   consistent non empty set domain literals that 

rule x   p  x    holds  x d     respectively

 x d    f   

 
consistent superset direct justication p direct justication
 
well  indeed  body  x d  true true precise   also  direct
justication empty denition  true every structure  minimal
direct justication     

assume presence domain

above  recall  structures domain

example     

consider domain



direct justication

   d            dn  

denition

x   p  x  q x  r x 
x   q x  p  x 

q di  



 p  di   



q di  







 p  di    

domain literals

many direct justications  unique minimal ones

p  di    q di     r di   
p  di    q di    r di     atoms r di   open

subset relation  minimal direct justications
minimal direct justication
direct justication 

g pair hv  ei set v nodes set e directed
 vi   vj   nodes  node v v   denote g v 
g v     w    v  w  e  

 directed  graph
i e   ordered pairs
children

v 

i e  

denition      justication  
domain literals





justication

denition

domain literal

l  j l 



graph

j

edges 
set

set

either empty direct

justication l 
thus  justication graph encodes every dened domain literal none one
direct justication  sequel say
denoted set pairs

l s 





j



dened l



j l      

justication

direct justication l 

denition      justication subgraph  

let

j

justication

 

justication

literal l subgraph jl nodes edges j reachable l  justication
set literals l subgraph jl nodes edges j reachable l l 
justication j total l j dened literal reachable
l dened   total set literals l total literal l 
justication j consistent structure consistent none literals



j
j

dened false

i 

total l  leaves

jl

open domain literals 

   

filazy model expansion  interleaving grounding search
denition     
li li    

positive literals 

cycle

j

path justication

sequence

edge li li  

negative

justication

j

j 

l  l       

path

positive

consists negative literals 

set domain literals path

j

that 

consists

mixed

otherwise 

starts ends

domain literal  cycle positive  respectively  negative  domain literals
positive literals  respectively  negative literals   otherwise cycle mixed 
innite path may cyclic not 
intuitively  justication
truth

l 

j



nite  every innite path cyclic 

containing domain literal

l

provides argument

strength argument depends truth leaves

innite paths cycles
provides argument

jl  
l

leaves true every innite path negative 
true  leaf false unknown 

mixed loop  argument

l

jl

jl

contains positive

weak  notice justications

l

may still

argue l s truth 

denition      justies  

l well founded justication
j every innite path jl negative  otherwise l unfounded j  
justication j justies set literals l dened  the set l literals
justication j    i  jl total l   ii  literal l well founded j    iii 
set literals jl consistent 

p  d 

q d 

say dened literal

p  d 

r d 

p  d 

q d 

p  d 

q d 

r d 

q d 
 i 

 ii 

 iii 

figure    justications denition

example     



p  d 

d 

example     contain dened domain atoms

justication  ii  justies

 iii   however  total


example     

figure    show possible justications  ordered  i   iv  left

right  denition

q d   d d  



 iv 



p  d 



p  d 
q d 



q d 

 iv  justies

p  d 

p  d 
q d  



 i  positive cycle unfounded

q d  

relationship justications well founded semantics investigated dierent publications  denecker   de schreye              marin        
recall results paper relies  rst result states
literals


l

l 
jl  

model







leaves

jl

j

justies

true  satises literals



proposition      j justication justies set domain literals l
literals jl true every model  open  leaves jl true 
   

fide cat  denecker  stuckey   bruynooghe
interpretation iopen two valued open    well founded model
wf  iopen   computed time polynomial size domain  shown chen
warren         general  wf  iopen   three valued structure  wf  iopen   twovalued  unique model expands iopen   otherwise  model
expands iopen   proposition follows fact justication j justies
l leaves j true iopen   literals l true wf  iopen   

example    

 



r d 

true



r d 

justication  ii  justies l    q d  
iopen interpreting open predicates  
wf  iopen    particular  model

 continued example     

unique open leaf


r d  

structure

iopen   q d 
true  q d  true 

true

proposition       model   justication j exists consists
literals true   dened dened domain literals true justies
them 

corollary       case

total  justication j justies set domain
literals l  every two valued open   structure consistent jl extended
unique way model satises literals l 
 pt    
justies pt  

hence  canonical theory
justication

j

exists

 recall 



total   theory satisable

    generating models
model generation
model

t 

inference task takes input theory



returns output

model expansion  mx  dened mitchell et al         inference

task takes input theory
subvocabulary

 



vocabulary

returns expansion










two valued structure
satises

t 



here 

general inference problem dened wittocx  marin  denecker       
takes input  potentially partial  structure
satises





 

returns expansion







t 

already mentioned  state of the art approach model expansion
 similar asp  grounding



context



fo id  

afterwards applying search

resulting ground theory  latter can  e g   accomplished sat id  search
algorithm  marin et al         
below  present grounding algorithm basis lazy mx algorithm 
assume familiarity basic conict driven clause learning  cdcl  algorithm
sat solvers  marques silva  lynce    malik        

      grounding
overview intelligent grounding techniques

fo id   

refer reader

work wittocx  denecker  bruynooghe        wittocx et al         
present basic principle 

vocabulary   partial structure
  returns ground theory   strongly

grounder takes input theory
domain

d 

interpreting least

 



   

filazy model expansion  interleaving grounding search
 equivalent



assume







i 

theory

t 

called

canonical theory form

grounding





given

i 

recall

 pt     

one way compute grounding using top down process theory  iteratively
applying grounding steps direct subformulas rule formula hand  grounding
let  x 
let domains x  tseitin transformation replaces
 
atom  x   new  x  ary predicate symbol called tseitin symbol  extends
rule x    x    new theory strongly  equivalent

algorithm may replace subformulas new predicate symbols follows 
formula

original one  vennekens et al         
procedure one step ground  outlined figure    performs one step grounding process  called formula rule



canonical form  algorithm replaces

g
 rules formulas  possibly non ground part r  rules   formula  g
consists ground formulas  replacing returned ground formulas extending
returned rules produces theory strongly voc t   equivalent original 
rule   g consists ground rules  replacing sets returned
rules results theory strongly voc t   equivalent original 
direct subformulas tseitin symbols returns pair consisting ground part

algorithm    one step ground algorithm 
  function one step ground  formula rule  
 
switch
 
case   p return h    i 
 
case p
 
 
 
 
 
  
  
  
  
  
  
  

hg 

   one step ground    

return h p gg g   i 
case         w
n
return h  i   n  ti     ti       n  i 
case         n
return h ti       n     ti       n  i 
case x   p  x 
return h   p  x  x d   x d    d i 
case x  w x 
return h  dd t x d      t x d   x d    d i 
case x    x 
return h t x d    d    t x d   x d    d i 


v

grounding theory boils applying one step ground sentence
 which copies

pt

pt

ground part  rule theory repeatedly applying

one step ground returned rules

r  all returned sentences rules g ground  

use ground refer algorithm overall process 
   tseitin        introduced symbols part normal form transformation 

   

fide cat  denecker  stuckey   bruynooghe
various improvements exist  returning



returning

  

atoms interpreted





conjunctions whenever false conjunct encountered  analogously

disjunctions quantications  
also  algorithm one step ground introduces large number tseitin symbols  stateof the art grounding algorithms use number optimizations reduce number
symbols  optimizations directly applicable techniques presented
paper  start naive one step ground algorithm  section    present
optimized version one step ground introduces fewer tseitin symbols hence
results smaller groundings 

   lazy grounding lazy model expansion
lazy grounding refer process partially grounding theory
lazy model expansion  lazy mx  process interleaves lazy grounding

use term
term

model expansion grounded part  section      formalize framework
lazy model expansion

fo id  

theories  section      formalize instance

framework basis current implementation  section      illustrate
operation 

    lazy model expansion fo id  theories
given canonical theory

   pt    

input structure

iin  

models expanding

iin

searched interleaving lazy grounding search already grounded part 
rst focus lazy grounding 
apart initial step moves

pt

grounded part  input step

consists set rules still grounded  already grounded theory three valued
structure expansion initial input structure 
subsequent grounding step replace non ground rules ground rules might
introduce new rules  hence  state grounding includes set
set



 the

delayed denition  

g

ground rules

 possibly  non ground rules  denitions

g  in follows abbreviated gd   voc   equivalent
original denition hence  gd total  grounding procedure guarantee
that  times  g total 
given partial structure iin rule sets g   key idea behind lazy
model expansion  i  use search algorithm search model g
expansion iin pt true   ii  maintain justication j literals
true dened justied gd j consistent    iii 
interleave steps  i   ii  move parts g literal dened
property

needs justied cannot justied 

hg     j  ii
yet grounded  justication j  
  g     j empty graph 

thus  control lazy model expansion  suces maintain state
consisting grounded rules
three valued structure

i 

g  

initially 

rules





iin  

lazy model expansion searches space

denition      acceptable state  
tence

acceptable

states 

tuple hg     j  ii theory atomic senpt   total denition   input structure iin acceptable state  i  gd   g

   

filazy model expansion  interleaving grounding search




gd strongly voc   equivalent    ii  domain
   iii  j justication gd    iv  expansion
l literals true dened justied j    vi  jl  
literals l  consistent  

total denitions

atom dened


v

iin  

    set

justication

example     

g



consider theory

 pt     





denition



pt t  t  t   



x   q x  
 

t  x   r x  




t  x   q x  
let



structure

 pt   t   

 hence 

t 



t 













unknown  

g







denitions consisting rst rule remaining rules  respectively  furthermore  let

j  t   q d    d    tuple hg     j  ii acceptable
t  literal dened justied j  

state  indeed 

already said  lazy model expansion algorithm starts initial state

      j       iin  

acceptable dened literals unknown

state  either renes



propagation choice  backjumps 

g  

iin  



resulting

state unacceptable  repair operation restores acceptability  steps described
section     


gd  

algorithm tries compute acceptable state



corollary       would entail model

pt

justied

exists  computed

eciently well founded model computation  intermediate states  justication
may non total

pt  

iii  

note that   
justied

 

contain unfounded literals  inconsistent 

justication must

gd  

indeed  assume literal

justication graph leaf dened

g

l



depends positively negatively l  every attempt extend justication graph

l gd might fail  e g   forbidden
cycle  consider  e g   denitions g    p q     q p    case 
would correct take p justication q true  even though valid
justication within   indeed  model exists justies q full denition gd  
total justication graph justies

proposition      let hg     j  ii acceptable state 

gd well founded model
expands literals true dened  delayed  denition  

proof 

l

let

set literals true

justies literals
expands

l 



dened

open literals



state acceptable 

j

hence  corollary       exists well founded model

l 

example      continued example      
 

 



model

j

 i e  

g   pt

interpreted randomly 

well founded evaluation  assigning

 q d    d   

derives

t 

true 

moreover 

true well founded model  note

r atoms

occur





j 

following theorem states obtained expansion model

   

t 

r



fide cat  denecker  stuckey   bruynooghe
theorem      let hg     j  ii acceptable state theory    pt     input
structure iin pt true i voc g   model g   exists
model expands i voc g    
proof  i voc g  
justication

jg

model


g

domain literals true
combine one

follows proposition      exists

i voc g    

g

consists

two justications 

follows  dened literal

l



gd  



j

j



jg  



l 
jg

dened

jc  l    jg  l   jc takes edges either j
dened literal  justication gd  
verify jc justies pt   first  total pt   indeed  path pt either
consists literals dened g   branch total jg g   passes
 
literal l dened   justied j according condition  v  hence
 jc  l    jl  total  such  pt cannot reach dened literal gd
jc undened  second  jc contain unfounded literals starting pt  
path pt either path jg  so well founded justies g  
tail j  well founded property  v    finally  set literals reachable pt
jc consistent  see look paths jc pt   rst follow
jg consists true literals   may get path j contains
literals consistent   case  impossible reach literal
set

jc  l    j l  

jc

g  

justies every true dened literal

otherwise  set

negation 
follows proposition     exists model


pt

true  since

gd

expands

i voc g  

gd strongly equivalent   proposition follows 

achieved well founded evalstarting two valued open gd   

recall eectively computing model
uation

gd  

polynomial data complexity 

structure expanding

i voc g  

 chen   warren        

theorem  required
compute two valued model
justication justies

pt  

g  



model

g  

actually  need

suces search partial structure

so  relax requirement expense

maintaining justications literals true



dened

g  

corollary      let hg     j  ii acceptable state theory

   pt     input

structure iin pt true j justies pt gd   exists
model expands i s set dened literals jpt  
g expanding iin pt true implies lack models
g model expanding iin   unsatisable
core  i e   set rules g model exists expands iin   hence 
unsatisable core    pt      nd unsatisable core  one can  example 
failure nd model





expanding

iin  

indeed 

use techniques described torlak  chang  jackson        

    practical justication management fo id  theories
roughly speaking  lazy model expansion framework consists two components 
one hand  standard model expansion algorithm operates

 pt   g   and 
gd lazily

hand  justication manager maintains justication

   



filazy model expansion  interleaving grounding search
grounds

 

lazy model expansion performs search space acceptable states

aims reaching state theorem      or corollary      applicable  avoid slowing
search model expansion  work done justication manager
lazy grounding must limited  achieve this  designed system
justication manager access grounded denition

g

need restore

state search algorithm backtracks current structure
manager access



g

particular  literal dened

i 

justication

maintains justications restricted

 



allowed direct justication  justication

manager maintains following properties 



literals direct justications either open



direct justications
structure



j

gd

dened

 

kept consistent current

i 

justication graph dened

j

unfounded literals total 

distinguish acceptable states meet additional requirements acceptable
states dened denition      call

denition    

 default acceptable state 

 

default acceptable states   dene as 

state



hg     j  ii

default acceptable

state acceptable state and  addition      literals direct justications either
open

gd

dened

 

ii

   

j

justies set literals

j

dened 

follows default acceptable states satisfy two extra conditions  justify
literals dened
consistent 



terms literals dened

g  

dened

 

consistent 

j



true



set literals

acceptable state  suces literals

j

since default acceptable states acceptable states 

theorem     corollary     hold default acceptable states 
standard model expansion  main state changing operations make



precise  by making literals true  either choice propagation  make



less precise  by backjumping  

model expansion modies






  

  hg     j  ii default acceptable state
 
new state hg     j  necessarily

default acceptable state  following propositions identify situations acceptability
preserved 

proposition      let hg     j  ii default acceptable state  l set literals unknown
  consistent structure l   i  literals l either dened
direct justication j  ii  direct justication j contains negation
literal l  hg     j    default acceptable state 
proof 



literals true

    literals true


j

consistent

literals true

i 

i 

i 



direct justication  follows
direct justication  justications
consistent    hence  j justies

dened

dened

ii

then      

dened

 

proposition      let hg     j  ii default acceptable state  hg     j   
   p default acceptable state 

   

fide cat  denecker  stuckey   bruynooghe
proof 


i  j

j

justication

justies literals dened

justies literals dened



true

default acceptable state  literals dened
literals dened
hidden loops


g



 

 

gd  



true

i 



i 

subset

  

g

allowed direct justications

restriction quite limiting  see next section  avoid

loops detected maintaining justication

current implementation do  several methods exist

l dened g allowed direct
  provided established l s justication cannot loop gd  
one case body rule l dened literals  step analyze
dependency graph  literal dened g allowed direct justication
literal dened provided literals belong strongly connected

extend class default acceptable states  literals
justications

component dependency graph  case  cannot part cycle 

    example
rest section  illustrate behavior lazy model expansion articial
example  constructed way main features illustrated  next section 
processes involved described detail 
focus operation justication manager interaction
solving process  manager activated unacceptable state  either solver
falsies literal occurs direct justication

j

l dened
l extend

true literal

justied j   one option repair search justication
j   general problem hard model expansion problem itself 
corollary       manager searches
extend

j 

nd one  grounds l s denition moves

example uses theory



shown

locally direct justication justies l
g  

states symmetric graph  edge    exists

r   
   d            dn  
equality predicate identity relation  below omitted    predicates edge  r
root interpreted  r root dened  particular  root dened
singleton  d     specifying root d   

least one node root node  predicate
root node  input structure

p












pt
c 
c 
x   root x 
x   r x 



root   

reachable  predicate

interprets domain

c  c 
x   root x  r x 
 x y  d    edge x  y  edge y  x 
x   d 
root x    edge x  y  r y 

   
   
   
   
   













lazy mx algorithm proceeds follows 
   initial default acceptable state


hg     j  ii



g  



j

empty 

   

   propagation

 pt   g  

sets





 pt   

expands structure

conditions proposition     longer satised 

   

i 



resulting state

filazy model expansion  interleaving grounding search
acceptable since

j 

pt

true dened



direct justication

j direct justication pt  
atom pt unique direct justication  c    c    extending j
restore  default  acceptability since c    c  direct justication j
pt remains unjustied  therefore  alternative taken rule     moved
g   now  default acceptable state obtained 
one option repair acceptability extend

 pt   c    c     c  c  justied  consider
c  rule      edge open  manager build direct justication
 edge d  d       d  d    d     sets negative edge literals true  extends j
 setting positive edge literals true would equally good   justies c 
avoids grounding rule dening c   

   unit propagation sets
rst

   literal

c 

cannot justied  with local approach  since direct jus 

tications contains unjustied dened literals 

however  rule     existentially

quantied  one avoid grounding whole rule performing tseitin transformation isolate one instance ground instance  purpose

d   

 root d    r d    
  a 
x    d      root x  r x    b 

illustration  make  bad  choice instantiating



c 


rule   a  moved

g

x



default acceptable state reached 

   acceptable state propagation possible  choice
made 

c 

true  body rule   a  become true  preferably

selecting tseitin  this would trigger grounding   rst disjunct selected
model expansion propagation extends structure
literal

root d   

denition
dening

root

root


  d    d    

dened

unique direct justication

root d    r d    

rule     cannot justied since
false  manager partially grounds

splits ground rule   a  non ground rule   b 

domain elements 



root d    d    d    a 
x    d      root x  x   d    b 



g   note root d    justied  d    d    gd   hence
root d    direct justications   whenever grounding

rule   a  moved
safe use

done  justication manager interrupted propagation  infer truth
additional literals  detect inconsistency  which result backjumping  
cases  manager resume revision justication afterwards 
acceptable state reached 
unacceptable  due unjustied

here  even though resulting state still

r d     

g
root d    conict 

creation new rule   a 

interrupts manager  propagation using new rule derives

   pt   c    c     subsequent propagation sets structure
 pt   c    c    root d        still default acceptable state  t justied  

backtracking





rule   b  transformed split another instance 



 root d    r d     t 
  ba 
t  x    d    d      root x  r x    bb 

   



fide cat  denecker  stuckey   bruynooghe
g  

rule   ba  moved

rule   bb  remains

 

state default

acceptable 

t    choosing rst disjunct rule   ba 
r d     literal root d    dened  
justied direct justication   d    d      literal r d    cannot justied
direct justication  as edge literals false current justication graph 
rule     transformed split instance d    actually  instance

   again  search avoids new tseitin
propagates

root d   



turn disjunctive body complex subformula  avoid grounding
subformula  break two parts introduce another tseitin 







r d    root d    t 
  aa 


t    edge d    y  r y 
  ab 
x    d      r x  root x 





  edge x  y  r y 
  b 
rule   aa  moved

g  

others remain

 

 pt   c    c    root d     t  root d     r d      hence propagation rule   aa  g extends t    direct justication justifying
t  and  hence  rule   ab  partially grounded splitting d  case 


t   edge d    d    r d     t 
  aba 
t     d      edge d    y  r y    abb 

   current structure

rule   aba  moved

g

rule   abb  remains

   search selects rst disjunct

r d    
it 

literal

extending

j

r d   

dened

 

t   s rule body propagates edge d    d   
   root d     direct justication

direct justication yields acceptable default

root d    dened g   however  root d    justied gd  
j direct justication discussed earlier 
justication manager faces new problem  true literal edge d    d    conict
 
 
 
direct justication  edge d       d      c   rule       handle
conict  splits aected instance  x   d      d    rule 


c   edge d    d    edge d    d     t 
  a 
t   x y  d      d    d       edge x  y  edge y  x    b 

acceptable state  since

making safe extend

g rule   b  remains   direct justication
 edge d  d       d  d    d      d    d       unaected part direct
justication c    restores acceptability 

rule   a  moved

t 

set

   propagation rule   a  extends





edge d    d   



t    literal edge d    d    
t   rule   b    resolve

true  conict direct justication

it  justication manager partially grounds rule   b  splits instance

 x   d      d    follows 


  ba 
t   edge d    d    edge d    d     t 
t   x y  d      d    d      d    d      


edge x  y  edge y  x    bb 

   

filazy model expansion  interleaving grounding search
g rule   bb  remains   t  inherits direct
edge d    d    removed  propagation rule   ba  extends
state acceptable  t  dened justied 

rule   ba  moved
justication


t   

now 

t 



resulting

g

consists rules        a     a     ba     aa     aba     a     ba  

consists rules   b     bb     b     abb     bb   cur pt   c    c    root d     root d     edge d    d     edge d    d     r d     r d    
t  t    t    t     model pt g  
literals  root d     r d    t  dened   literal root d     dened
rule   b    d    d     direct justication  literal r d     dened rule   b  
 root d    direct justication  literal t    dened rule   bb  direct justication
set negative edge literals except edge d    d    edge d    d     obtain
full model theory  extended literals direct justications 

residual denition
rent structure





case  assigns open literals model completed wellfounded model computation

gd  

actually  done without grounding

denition  jansen  jorissen    janssens        

   justication management
section      instantiated general framework  developed section     
justication manager access

 

example section      justi 

cation constructed demand  i e   time literal needed  dierent  direct
justication  body dening rule analyzed justication extracted 
failed  part rule grounded  called
imagine

global approach 

rules



local approach 

one

considered attempt

select direct justications minimize grounding rules whole  obviously 
global approach time consuming  applied every time
adjustment justication required  section  describe approaches 
describing algorithms  introduce notations assume normalizations done  function nnf reduces formula negation normal form 

set single element    used shorthands  s 
s  s   j justication  denote j l d  graph identical j except l
justied d  assume quantiers range single variable variable names


reused formula  furthermore  assume basic reductions applied
formulas  e g  

 

reduces

  x  

reduces

t 

   

    local approach
algorithm   shows top level lazy mx model expansion algorithm  taking input
theory

 pt    



iin   denitions g initialized
initialized iin   set ground sentences tg
initial justication j empty  auxiliary  fifo 

initialized empty 

latter keeps track literals direct

input structure

empty denition  respectively 
initialized fact
queue

qch

pt

justication needs checked 
main loop performs model expansion

tg g  

interleaved work

justication manager towards establishing default acceptable state  model expansion

   

fide cat  denecker  stuckey   bruynooghe
part consists propagation  the call propagate   test whether current state
inconsistent  with learning backjumping   test whether model

tg g

found  returning model justication  choice step

tg g

selects literal unknown

assigns value 

propagation returns literals

entailed ground theory  partial  structure  example applying
unit propagation unfounded wellfoundedness propagation  marin et al         
test model performed default acceptable state  i e   queue

qch

empty   test succeeds  ensures well founded model computation
expand current structure



extended direct justications literals

model whole theory  choice step takes place default acceptable
state  ensures search space limited state space default acceptable
states 

justication manager activated propagation choice step assigns

literal
valid 



l 
l

calling check literal  checked whether current justication remains
dened

queue

qch



justication  needs justication added

processing justication manager 



l

 
justication another literal l   justication becomes inconsistent
another justication added

qch  

occurs





l 

needs

processing done selecting

elements queue calling lazy ground function 

latter function rst

attempts nd  dierent  consistent direct justication l  fails  splits
rule instance dening

l





partially grounds it  hence

g

extended  new

clauses may trigger propagation  therefore processing queued literals interleaved
propagation and  possibly  backtracking   note backtracking might restore
consistency



direct justication

j l 

literal

l



qch  

      lazy grounding one rule
function lazy ground  algorithm    checks whether literal
tion  not  simply returns  otherwise  checks whether

l

l

needs direct justica 

valid justication  i e  

one satises invariants detailed below  so  returns  otherwise  passes
rule body used construct justication  the negation dening rule
literal negative  build djust  function attempts nd valid direct
justication  besides literal rule body  initial justication  derived
rule body  passed build djust  latter function successful  justication
updated lazy ground done  not  direct justication literal

false

l

set

split and ground called ground part rule dening l 

going details  rst analyze properties want maintain
current justication
considered part

j

j 

direct justications literals

qch queue
j are 



since might invalid  global invariants



literals unfounded



set literals

j

 recall  negative cycles allowed  

j

consistent 

direct justication

  j l  j



l

queue  invariants lazy

grounding process are 



contains literals dened

g

 unless literal safely justied

discussed before  

   

gd  



filazy model expansion  interleaving grounding search

algorithm    lazy mx lazy model expansion algorithm 
  function lazy mx  atomic sentence pt   denition   structure iin  
output  either model g j false

 
 
 
 
 
 
 
 
  
  
  
  
  
  
  
  
  
  

  
  
  

tg

    pt   

g

true

  

 

  

  j

  

 

  

iin   qch

  

l    propagate tg g     
   l 
foreach l l qch   check literal l qch   
inconsistent
tg    learn nogood i   tg   
conict root level return false  
   state backjump point 
else qch empty
 l  qch      dequeue qch   
lazy ground l  
else model tg g
return   j  

else

select choice literal l 



  

  l 

qch   check literal l qch   

function check literal  literal l  literal queue qch  
data  global j output  updated queue
l dened j l    undef qch    enqueue l qch    
foreach l  l j l    qch    enqueue l   qch    
return qch  

algorithm    lazy grounding literal 
  function lazy ground  literal l 
data  global   j
 
l l dened
 
j l  exists obeys invariants return 
 
else

 
 
 
 
 
  
  

 



   body rule dening l 

l negative literal

   nnf   
dj    build djust l    init just l   
dj    false j    j l dj   return 

else

j

 

j l false  

split and ground l  

   

 

fide cat  denecker  stuckey   bruynooghe


literals
queue


qch  

dened



either direct justication

j

belong

qch

invariants imply default acceptable state reached

queue

empty  indeed  follows invariants current justication total
situation hence literals direct justication justied  denition      
due policy followed queue literals  current justication consistent



literals true



dened



justication  hence

hg     j  ii



default acceptable state 

      building direct justification
purpose build djust  algorithm    extend
literal

l

 

dened

i 
formula



l

j

suitable direct justication

literal

j l 

currently undened



inconsistent

recursive function takes three parameters      literal

l 

made true direct justication  initially whole body

ii

   

rule dening literal  note initialization takes negation rule

iii  description direct justication derived far  initialized

literal negative    

init just l   algorithm  assume

dierent quantiers range

dierent variables 
going details  discuss represent direct justications 

basically 

could represent direct justication set ground literals  however  set
quite large using ground representation might hence defy purpose lazy

hl  bi l set
b set bindings xi di xi variable di
domain  set bindings b    x  d            xn dn   represents set variable
substitutions sb     x   d            xn  dn     di di     n    set ground
literals represented hl  bi  l   l l sb    direct justication
literal p  d            dn    dened rule x   p  x    initialized init just l 
h   x   d             xn  dn   i  eect  b allows identify relevant rule instantiation

grounding 

instead  represent direct justication pair

possibly non ground literals

providing appropriate variable instantiation domains  set literals
empty 
build djust algorithm searches set literals making
recursively calling subformulas
larger justication

 





true 

works

composing results afterwards

set literals found  example none

exists consistent direct justications 

false

returned 

base case formula literal  make literal true  instances
literal set bindings

b

must true  hence  set literals

l

extended

literal itself  resulting direct justication satisfy invariants 
checked call valid  returns

true call valid l  dj  dj
l j l dj  satises

 part   direct justication

satises invariants
invariants

justication 
universally quantied formula
quantied variable 

x d 

x  

true instance

hence  recursive call  set bindings

b

extended

existentially quantied formula  suces one instance true  hence 

minimal approach try instance separately one succeeds  fail 

   

false



filazy model expansion  interleaving grounding search

algorithm    build djust algorithm 
  function build djust  literal l  formula justication hl  bi 
input  b binds free variables
output  either direct justication false
 
switch
 
case literal
 
valid l  hl     bi  return hl     bi 
 
else return false  
 
case x d   
 
return build djust l    hl  b  x d   i  
 
case x d   
 
large d   
  
return build djust l    hl  b  x d   i  
  
foreach di d 

  
  

hl    b      build djust l    hl  b  x  di   i  
hl    b    
  false return hl    b   i 

  
  
  
  
  
  

return false  
case         n
foreach     n 

  
  
  
  
  

return hl  bi 
case         n
foreach     n 

  

hl    b      build djust l    hl  bi  
hl    b     false return false  
else hl  bi    hl    b   i 

hl    b      build djust l    hl  bi  
hl    b    
  false return hl    b   i 

return false  

   

fide cat  denecker  stuckey   bruynooghe
returned  note however want iterate domain element
large  would similar constructing grounding itself  instead 
extend binding

x d 







large 

conjunction similar universal quantication  except

explicit iteration conjunct needed  soon one conjunct fails  whole
conjunction fails  disjunction similar existential quantication small domain 
note build djust non deterministic due choices domain element justify
existentially quantied formula  disjunct justify disjunction 

example     

consider following rule large domain

d 

h x   p  x   y   q x  y  r x  y  
assume

j empty
h p  x     x d i

loops keep track of 

applying build djust

p  x  body chosen 
corresponds direct justication  p  x    x d   alternatively  second disjunct chosen  returns h q x  y   r x  y     x d  d i  represents direct
justication  q x  y    x d  d   r x  y    x d  d  


h

returns

rst disjunct

      partially grounding rule
last bit lazy model expansion algorithm handles case justication
found denition literal

l

grounded 

straightforward way

would call one step ground rule dening l  store result

g



 

however  many cases operation results much grounding 

example     

form x   p  x  situation
p  d   applying one step ground r  would instantiate
x elements d  resulting  d  rules  fact suces split r  two rules 
one instance x   one remainder  another example applies rule r 
form h x   q x  r x  direct justication j h     q x    x d  
q d  becomes false  justication manager may need ground rule  applying
one step ground would instantiate universally quantied x elements  
instead  better split instance x   introduce tseitin
remainder  producing h  q d  r d   g x   q x  r x 
  direct justication obtained incrementally removing q d 
h   discussed section       
consider rule

r 

justication found atom

split and ground algorithm  algorithm    ground part rule dening
given literal
dening



l

l 

say


p  

rst step split rule instance rule

grounded  the call split  

denes


p  

let

replace rule

additionally return rule


p  x d  

x   p  x  rule
x   p  x 

afterwards  apply one step ground

latter rule add computed rules either

g



   

result split and ground denition
one  limit ground denition
equivalent

gd



gd ground previous
empty g strongly voc   

 

   recall  head new grounded rule always dierent head already grounded rules 

   

filazy model expansion  interleaving grounding search
algorithm    split and ground algorithm 
  function split and ground  literal l 
input  l dened
result  update g     j   qch
 
 

r    split l      split updates
  g    d      one step ground r  
g   g        

 

even justication found  better splitting

l

applying

one step ground  shown example      first  splitting made signicantly
intelligent  discussed section        second  improve one step ground
ground part expressions possible  describe below 

improving one step ground 
subformulas instantiations
result consists

 d 

l iterates
x   p  x  

applying one step ground rule

 

example



sentence

new rules many new tseitin symbols  instead  depending

value l  sucient introduce one  or some  subformulas  shown
algorithm    extends switch statement one step ground two higherpriority cases 



l

true  sucient ground one disjunct existential instantiation

delay rest tseitin introduction 

l

false  take similar approach

conjunction universal quantication 

algorithm    additional cases one step ground algorithm 
  switch r
 
case l         n i l   

 
 

 
 
 
 

choose

    n  

return h l     t
case l x   i l   

w

choose

j     n i j  i 

d 

return h l  x d      t
analogous cases









x    i 
combination i l    f  

      algorithmic properties
correctness termination presented algorithms discussed following theorem 

theorem      correctness termination   lazy mx returns interpretation  

expanding literals direct justications j   applying well founded evaluation gd restricting voc t   results model   algorithm returns
false   interpretation exists precise iin satises  

   

fide cat  denecker  stuckey   bruynooghe
algorithm lazy mx terminates nite domain d  otherwise  termination
possible guaranteed  
proof 

lazy mx returns interpretation

i 

model

g



qch

empty  given

properties split and ground  applying lazy ground literal l  either
valid justication dened
state and  theorem     
returns

false  



g  

gd

qch



empty  default acceptable

expanded model whole theory  lazy mx

proven

models

hence

l

hence



g

models

iin  

case 

iin  

models expanding

without calls lazy ground  search algorithm terminates nite
tion lazy ground produces ever increasing ground theory
limit  hence  lazy mx always terminates





nite 

g

g   func 

full grounding

innite  limit

g



innite grounding  termination cannot guaranteed 

      symbolic justifications  incremental querying splitting
algorithms presented sound complete 

however 

improved taking formulas justications derived account 

symbolic justications incremental querying 
 subformulas   formula

example     

 

multiple justications exist

grounding delayed 

consider formula

x   p  x  q x  



h p  x     x d i

h q x     x d i justications  that  could derive justication 
d  make either p  d  q d  true  hence  grounding necessary
p  d  q d  become false d 





automatically changing build djust follows 



algorithm allowed select multiple disjunctions   existential quantications
even valid justication already found one  lines        



build djust longer returns justication  symbolic

justication formula



entails original formula  formula built build djust reects
subformulas instantiations selected 



 

justication

 
 p  x    x
x   p  x  q x  

derived directly set non false literals  full  grounding
example  formula

d  


x   p  x  q x  

instead justication

build djust might return justication formula

validity check  valid  extended return false justication formula false 

allowing complex formulas  instead conjunction universally quantied literals   validity check whether formula become false incremental changes




expensive  fact

incremental query

problem  exper 

iments  limit depth allowed formulas use straightforward  expensive 
algorithm evaluates whole formula whenever assignment falsify it 
   possible change integration

lazy ground lazy mx guarantee termination nite

model exists  see section     

   

filazy model expansion  interleaving grounding search
body splitting 

described algorithm   section        split simply splits

rule instance denes l  one step ground grounds rule instance step step 
accordance structure formula  however  grounding triggered
conict current justication  one step ground blind origin
conict 

using conicting literals  one could focus grounding part

formula contributes conict  one restructuring rule part
grounded  contains conict  part grounded 
old justication adjusted still apply 

latter part split

introducing new tseitins transformation called body splitting  approach
inserted algorithm   call split  this  original justication  call

jold  

passed extra argument split and ground 

example     

h x   p  x   let h p  x     x d i justication h true   p  d  becomes false  easy see split
violating instantiation rewriting original rule h p  d  adding
rule x   p  x   crucially  justication second part derived
original justication  namely h p  x     x d i  second part hence
added justication j rst part added g  
consider rule

r direct justication jold done ecient way 
v true domain literal partial structure direct justication
rule r contains negation v   implementation binding s 
justication instantiates v extracted representation
direct justication rule  simplicity  assume  x   d            dn   single
instance  recursive algorithm visits formula body r depth rst  whenever
quantication x   encountered x equal xj x  replaced
 x dj      x   dj    tseitin transformation applied left hand
revision rule

assume

conjunct algorithm recurses right hand conjunct remains
binding  new rule dening new tseitin jold v direct justication  similarly 
existential quantication replaced disjunction 

result set new rules

new justication sought smaller rule

r 

passed

one step ground  correctness follows fact jold v valid justication  none
new rules contains

example     

v 

correctness tseitin transformation 

example      justications sought

h

rule

h x   p  x   y   q x  y  r x  y   
j    q x  y    x d  d   r x  y    x
  l   q d    d    becomes false  j longer
consistent cannot repaired  j l  however  still consistent  
justication whole body  hand  j l justication
subformula p  x    q x  y  r x  y  instantiation x dierent
d    consequently  split quantication x   x d  x   d 

assume selected justication

d  d  



p  d   

true

apply tseitin transformation former  afterwards  recursively visit latter
formula apply similar reasoning existential quantication  operations

   

fide cat  denecker  stuckey   bruynooghe
 split   
x d 

 





p  x 




q x  y 

 split   

p  d   

  d 

 





r x  y 
q d       

r d        q d    d    r d    d   

x   p  x    q x  y  r x  y  split violating
q d    d     original justication without q d    d    justication

figure    rule body
literal

left hand side splits  justication formula shown blue 
remaining non justied formula shown red 

formula illustrated figure    result consists following rules 
rule

h

even ground 




h t   p  d     t   q d    d    r d    d       






t  x d    p  x    q x  y  r x  y  




  q d   y  r d   y  

 
 
 
 
optimize traversal formula
path taken parse tree

example     



 

build djust extended store

direct justications subformulas 

c   x y  d    edge x  y  edge y  x 
justied  j empty interpret edge  build djust algorithm recursively
visits body rule edge x  y  returned valid literal use  going
one level  store edge x  y  edge y  x   selected  edge x  y    assuming
disjuncts selected  edge x  y  returned again  going back
quantications  store that  quantications  selected set relevant
 
domain elements  build djust returns justication formula  x y    edge x  y  
assume rule

build djust given access
direct justication 

jold  

similar optimizations possible repairing

consider example      assume

p  d   

unknown

i 



case  left branch figure   transformed rule still valid 

p  d    direct
justication rule h t   p  d     y  d d      q d    y  r d    y    
t  example     

direct justication  right branch  repair select disjunct

    global approach
finding justications using greedy local approach easily lead grounding
necessary  consider example sentences

   

x   p  x 



x   p  x  q x  

filazy model expansion  interleaving grounding search
applying local approach second sentence rst  with empty
construction makes atoms

p

j   

might result

false  applying local approach

rst sentence nds valid justication it  fully grounded  global
approach takes set rules input tries select direct justications


expected

grounding size whole set minimal 

cast task  called

optimal justication problem  problem graph
rule nodes r justication nodes j  

follows  graph consists two types nodes 

justication node symbolic set literals representing possible justication  for

   rule node pair
 t  f   u   pair hr  ti rule r head l
expresses exists direct justication l  pair hr  f exists direct
justication l pair hr  ui r justication 

literals dened rule

hr  ti

r

rule





 

given current partial structure

truth value

three types edges 

valid edges

rule node

 the negation   head

conict edges

hr  ti  hr  f i  justication node j



j

justies

r 



ii

    rule nodes rule dierent truth value     

iii  rule node hr  ti  hr  f i 
l  l    iv  rule node hr  ui 

justication nodes contain opposite literals   

r

denes


 or

r

l 

l 

justication node contains

denes

l 

justication node contains



l

 a conict

l

hr  ti  hr  f i 

j

needs justication  

depends on edges

justication node

contains negative  positive  literals dened
aim select subsets



l

rsel r



j
r 

jsel j

rule node





selected rule node connected valid edge least one selected justication node 



conict edges exist pairs selected nodes 



neither positive mixed cycles exist subgraph consisting valid
depends on edges selected nodes 

selection

 rsel   jsel  

extracted follows 
rule

r



satisfying constraints  initial justication

literal

hr  ti  hr  f i 

l  l 



selected rule  direct justication union

justications justication nodes
edge 

j

given direct justication dened

jsel

connected

hr  ti  hr  f i 

valid

moreover  literals dened rules rule node selected

added initial

qch

queue  handled local approach  complete solution

must justication them 

hr  ui

selected  means grounding

instances rule delayed literals denes become assigned 
type problem somewhat related np hard

hitting set

 or

set cover  

problem  karp         given set top bottom nodes edges them 
task nd minimal set bottom nodes top node edge
least one selected bottom node 

   

fide cat  denecker  stuckey   bruynooghe
hg     j  ii  input optimal justication
  node constructed
truth value known   conict

given default acceptable state

problem generated follows  rule
three truth values  only one
edges added 

valid edges justication nodes obtained using  straightforward 

adaptation build djust returns set possible justications make head
rule true  false   e g   rule

p  x 

x   p  x    build djust called literal
 x d   conict depends on edges derived

binding initialized

checking dependencies justications rules justications 



keep ecient  done symbolic level 

example     

pt   c 



c 

x   root x  r x 
 x y  d    edge x  y  edge y  x 
x   d 
root x    edge x  y  r y 

   
   
   
   






consider theory running example 

propagated true  denition






c 
c 
x


 
root x 



x   r x 











associated optimal construction set input shown figure    note rule

c  c  true  
root x  root x 

nodes  use dened head literals identify rule  literal
hence one rule node rules          neither
justied

x d 

hence

hroot  ui

tuple 

four solutions subset maximal respect rule nodes  namely
following rule node selections 

 hr  ui   hroot  ui   hc    ti 

 a 

 hr  f   hc    ti 

 b 

 hr  ti   hc    ti 

 c 

 hc    ti   hc    ti 

 d 

these  multiple justication selections possible  also shown figure    


c   

select justication

 iv  



c 

choose

 v 



 vi 

 but

both  
objective maximize number selected rule nodes  minimize
expected grounding size 

obtain estimate expected grounding size 

following conditions taken account 



depend size grounding rule 



assigning multiple justications rule result lower estimate rule
grounded false 



variables occurring multiple justications result less matching instantiations 



practical applications  number false atoms far exceeds number
true ones model  hence  positive literals justication higher
cost negative ones 

   

filazy model expansion  interleaving grounding search
hr  f

h root x   edge x  y     x d  d i

hr  ui

h root x   r x     x d i

hr  ti

h root x     x d i

hc    ti

h root x   r x     x d i

hc    ti

h edge x  y     x d  d i

hroot  ui

h edge x  y     x d  d i

 i 

 ii  

 iii 
 iv 
 v 
 vi 

figure    graph part input optimal justication problem example     

rule nodes shown left  justication nodes right 

valid edges shown green  conict edges red depends on edges blue 
readability  conicts justications unknown rule nodes
shown 

approximate expected grounding size function
input rule

r

 with head

h  

j 

takes

n

selected type justication  rule selected     

justication  u   justication
cations

expsize

h  t 

justication

h  f   

set justi 

function returns expected grounding size rule  size r   dened

below  weighted depending type justication  weights derived two
estimates 

pval

ptr

probability atom become assigned

probability

n

assigned atom true  hence  dened formally below  non delayed rules     

u

full size used  rule without justication     weighted



    weighted

ptr  

product justications
namely

pt

literals

f

false one    

j



j 

  ptr  

true justication

latter two weights multiplied

factor product sum two terms 

times number negative literals

j 

pval  

j



  ptr

times number positive

eect expected size decreases number justications

increases expected size increases justication literals 

expsize  r  n      size r 
expsize  r  u      size r  pval
expsize  r  f   j    size r  pval    ptr  



    ptr    pos 

lits 

j 

jj

  ptr  neg  lits  j  

expsize  r  t  j    size r  pval ptr
    ptr    pos  lits  j 
jj

  ptr  neg 
probabilities  assumed

pval

lots literals get value 

lits 

j  

small  currently      reect hope

ptr

less half  reect atoms

   

fide cat  denecker  stuckey   bruynooghe
often assigned false true  function

size

dened below  function returns

number atoms grounding rule formula  except existential quantication
disjunction  these  take account grounded partially
using tseitin transformation  taking logarithm total grounding size 

size l     
size l     size      
size x       size  
x
size i  
size         n    
i   n 

size x       log d  size  
p

i   n  size i  

size         n     log n 

n

solutions optimal justication problem minimize term

x

expsize  r  t r   j r  

rd


t r 

type  t 

f 



u 



j r 

justication literal dened

r 

example      continued example       size rule c    log d    c 

  d  log     root d       r d   log      log d      
consider assigning justication  iv  c    results expected cost rule
     log d            as construction relies making r true   additionally 
would force grounding rule dening r  increasing cost size
rule r  optimal solution problem figure   rule node selection  a 
 
justication  vi  c    cost sum      log         for justication
 vi       log d     the expected size rule c     now  rule c 


passed local approach 
solve optimal justication problem 

idp s

optimization inference applied

 meta level  declarative specication task 

 

larger theories

t 

problem

turns quite hard  two approximations considered reduce search
space 

first  number selected justications rule limited   

values

size r 

grow quite large  approximation

standard approach   rounding integer values applied

dlog size r  e

idp s

second 

used  a

support oating

point number still preliminary  resulting specication could solved optimality
within seconds tested theories  lazy model expansion  global approach
applied initial phase tseitin literals representing sentences original
theory propagated true 

   heuristics inference tasks
section discusses tune lazy grounding search heuristics
underlying sat solver obtain eective implementation lazy model expansion 
   specication part

idp

 s public distribution 

   

filazy model expansion  interleaving grounding search
describe inferences tasks beyond model expansion useful
context lazy grounding  less important issues discussed appendix a 

    heuristics
heuristics play important role lazy grounding algorithms  serve nd
right balance much ground long search  rst discuss
heuristics chosen  afterwards  discuss alternative approach minimize
grounding 

      balance grounding search
algorithms leave room number heuristic choices important
eect performance 

briey discuss choices 

guideline

decisions  following principles used 



avoid leaving search process without enough information make informed
decision  example  avoid losing much  unit  propagation introducing
many tseitin symbols 



prevent creating grounding large  may example happen
result long propagate ground sequence 

recall  goal create minimal grounding  solve model expansion problems
avoiding large grounding 
below  introduce number parameters aect heuristics 

exact

values used experimental evaluation parameters introduced specied
appendix a 
split and ground  handling disjunction existential quantication 
choice many disjuncts expand  expand one instantiation time
rule

h x   p  x  

done algorithm    lines       iterative application results

ground theory

h p  d    t 
t  p  d    t 
t  p  d    t 
 
 
 

tn x    d    d            dn     p  x  
sat solver minisat  used


p  di  

idp

system  initially assigns

atoms  choice triggers iteration propagation grounding 

f





resulting thrashing behavior reduced somewhat  grounding compact
grounding introduces

n

disjuncts time 

h p  d          p  dn  
x    d    d            dn     p  x  

   

fide cat  denecker  stuckey   bruynooghe
remedy this  two search related heuristics changed  first  initial truth
value randomized  favoring false  as models  many atoms false
true   second  search algorithms typically

restart

 ever increasing  threshold

number conicts  sometimes caching truth value assigned atoms  

polarity caching   

allows solver take learned information account search heuristic
staying approximately part search space 

case lazy grounding 

might want jump another part search space come across long
propagate ground sequences  end  introduce concept

randomized restarts 

take place  ever increasing  threshold number times

g

extended

randomly ipping cached truth values 
addition  build djust always returns

false

estimated formula

small grounding  indeed  grounding formulas help search  whether formula
considered small determined terms  estimated  grounding size 
strategy used split and ground 



whenever formula one step ground

would applied small  ground applied instead  completely ground formula 

      late grounding
grounding applied search process soon unit propagation taken place 
result focus current location search space  danger
grounding much solution part space  alternatively  could
apply opposite strategy  namely ground late possible  apply additional
grounding search algorithm terminates without ever found model
acceptable default state  strategy well known elds incremental proving
planning  domain  number time steps  increased search
previous  smaller bound nished  guarantees minimal grounding  prototype
strategy implemented

idp

good results planning problems 

    related inference tasks
bulk paper focuses model expansion  mx 
solutions structures two valued

voc t   

fo id  

theories

t 



often  one interested

small subset symbols voc t    example case model generation
so id   language extends fo id  existential quantication relations 
so id   problem p            pn   initial structure   relation symbols p           
pn   fo id  theory  solved model generation fo id  theory
initial structure dropping interpretation symbols p            pn
models  another example query evaluation fo id    given theory   initial
structure formula free variables x  all fo id     purpose evaluating
query ht   i  nd assignments domain elements x model
exists expands  x d  true  solve model expansion
fo id    new predicate symbol introduced answers query tuples

domain elements true model theory extended
sentence x    x  denition  x    x    
cases  approaches using  standard  model expansion compute total interpretation afterwards drop unnecessary information  quite inecient  lazy model

   

filazy model expansion  interleaving grounding search
expansion save lot work partially grounding theory  however 
model found grounded part  justications remaining denitions
used expand structure model full theory 

although expansion

obtained polynomial time  still inecient afterwards large part model
dropped 
remedy this  dene variant model expansion task  denoted

t 

restricted

mx 

additional list symbols o 
 
called output symbols  solutions structures two valued symbols
expansion exists extends model   adapting lazy
restricted mx takes input theory

structure

grounding solve restricted mx done analysis justications
need added  completely  structure  splitting

gd

multiple denitions

evaluating dening output symbols symbols depend  using
stratication argument  
above mentioned inference tasks cast trivially restricted mx problems
lazy restricted mx greatly improves eciency respect ground and solve 
shown experimental section 
extension

fo id  



procedurally interpreted

symbols  de cat et al        

provides another class interesting problems  predicate symbols xed interpretation  know whether tuple belongs predicate  procedural function
executed  approach provides clean way combine declarative procedural specications  consider example symbol

isp rime n 

interpreted

procedure executes ecient prime verication algorithm returns true
given argument prime  generally interested complete interpretation

isp rime  cast restricted mx problem isp rime o 

solving

problem using lazy grounding benet executing associated function



search relevant atoms

isp rime d  

task  show experimental

evaluation next section 

   experiments


idp

system state of the art model expansion engine  observed

previous answer set programming competitions  denecker et al         calimeri et al        
alviano et al          lazy model expansion algorithms presented paper
implemented

idp

system  extending existing algorithms  de cat  bogaerts 

devriendt    denecker        
current implementation incomplete sense cycle check justications implemented yet  aects inductive denitions non inductive
ones replaced fo formulas completion 

workaround

lack cycle check  build djust  function constructs direct justication  returns
false rules dening inductive predicates  consequence  instance rule
immediately grounded  although lazily  domain atom dened rule assigned value  another consequence inductively dened predicates cannot used
justications rules  aects three benchmarks asp competition  de   within asp community  sometimes referred show predicates 

   

fide cat  denecker  stuckey   bruynooghe
scribed section       namely

reachability  sokoban



labyrinth 

these 

grounding might delayed even complete implementation 
section organized follows  section      evaluate overhead completely
grounding theory using presented approach  section      evaluate eect
lazy grounding number benchmarks asp competition 

section     

number additional properties presented algorithms demonstrated 
tested three dierent setups 
 referred

g s   idp

idp

standard ground and solve approach

lazy model expansion  lazy  award winning asp

system gringo clasp  asp   used

idp

version       lazy  gringo       clasp       st 

parameters lazy grounding algorithms discussed section      values
used experiments documented appendix a  experiments sections    
    run    bit ubuntu       system quad core      ghz processor
  gb ram  experiments section     run    bit ubuntu       system
   core      ghz processor     gb ram  timeout      seconds
memory limit   gb used  out of time indicated

t 

out of memory

m  

    eect grounding time
lazy grounding may reduce grounding size time causes overhead  instance 
expect  naive  incremental querying justications costly discussed previously  aim section quantify overhead caused lazy grounding 
experiments compare grounding time standard idp system


naive

instance lazy grounding algorithm forced generate complete

grounding starting search  instance obtained standard algorithm using small changes  shortcut ground small formulas turned
o  disjuncts instances existentially quantied formulas grounded one one 
dened literal enqueued lazy grounding soon appears

g  

comparison 

measure cost standard lazy grounding algorithm computes partial
groundings 
devised six benchmarks test various aspects novel algorithm  benchmark simple theory two sentences simple solve  benchmarks
designed measure cost dierent aspects lazy grounding  delaying resuming grounding  querying needed resume grounding  splitting formulas  etc 
specically  tested aspects following 
   overhead delaying resuming grounding case existential quantier
large domain 

sentence

n disjuncts  naive lazy
n   tseitin symbols 

clause
introduces

x   p  x  

standard grounding creates single

grounding grounds formula piece piece

   overhead case inductive denition 

 x   p  x  p  x  q x   

standard grounding naive lazy grounding construct ground rule



p  d 

atom 
   benchmarks  experimental data complete results available

krr experiments lazygrounding jair 

   

http   dtai cs kuleuven be 

filazy model expansion  interleaving grounding search
   overhead case universal quantication 
standard grounding creates

n

sentence

x   p  x  



atomic formulas  naive lazy grounding splits one

instance time introduces

n 

tseitin symbols 

   lifted unit propagation  lup   wittocx et al               important preprocessing step reduce grounding size  concretely  applying lup rules

x   r x 
x   r x    p  x  y 
derives second formula follows rst hence need
grounded all  theory used check whether lup remains equally important
system lazy grounding 

x  
r x    p  x  y   standard grounding creates formula instance
x tseitin grounding   p  d  y   naive lazy grounding creates
extra tseitin instance x extra set tseitins piece piece
grounding subformula   p  d  y  

   overhead case nested universal quantication  sentence form

   overhead incremental querying case symbolic justication validated  sentence

x   r x  s x  

identical justication formula 

formula validated checking falsity query
query re evaluated time

r atom



 atom

x   r x  s x  



falsied 

      results
experiments done predicates

p



q

arity  

r





arity   

domains size                    none predicates symbols interpreted
structure 
experiments  overhead time required solve initial optimization
problem  for global approach  always around      seconds  negligible 
results rst three experiments shown dierences standard
grounding naive lazy grounding negligible 

expected experiment   

experiments      shows actual implementation eliminates overhead
tseitins quantiers nested  three experiments  standard lazy
grounding able justify formulas without grounding hence fast almost
insensitive domain size  shown figure    dierence standard
grounding naive lazy grounding experiment    cases  use lup
big impact size grounding hence time  experiment    
showed top level quantier create overhead lazy grounding  experiment  
shows hold anymore nested quantiers naive lazy grounding
substantial overhead compared standard grounding  note overhead
worst case 

tseitins justied  denitions grounded 

explains normal lazy grounding faster standard grounding insensitive
domain size 

experiment   shows complex justication formula causes

signicant overhead naive lazy grounding  here  overhead worst case

   

fide cat  denecker  stuckey   bruynooghe

   grounding bounds

   nested universal quantification

  

   complex justification  shared variables
   

  

ground without lup
ground lup
naive lazy ground without lup
naive lazy ground lup
lazy ground lup

  
  

ground
naive lazy ground
lazy ground

  

ground
naive lazy ground
lazy ground

   
   

  
   

 

seconds

seconds

seconds

  
 

 

   
   

 
   
 

 

   

 

 

 

 
 

  

  

  

  

  

   
   
 

  

domain size

  

  

domain size

  

  

 

  

  

  

  

  

domain size

figure    time overhead naive lazy grounding ground and solve completely
grounding input theory  benchmarks         time includes grounding  solving time needed nd justications  time required
standard lazy grounding algorithm shown comparison 

visible normal lazy grounding  still  important part future research reduce
overhead incremental querying complex justication formulas 

    asp competition benchmarks
second  selected benchmarks previous asp competitions evaluate lazy
grounding algorithm realistic setting  many benchmarks solutions competition carefully ne tuned speed minimal grounding  lazy grounding usually
unable substantially reduce grounding theories and  due overhead 
slower standard ground solve  reason  sometimes selected
modelings benchmarks natural less optimized time grounding size  justify ground aim work improve inference
declarative

modeling

 de cat et al          emphasis developing intricate

encodings  modeling problem close natural language specication 
selected following problems  see competition websites complete descriptions   consist problems known hard  order evaluate eect
lazy model expansion search  problems typically result large grounding 

reachability 

given directed graph  determine whether path exists two

given nodes 

labyrinth 

planning problem agent traverses graph moving

connected nodes reach given goal node  addition  graph manipulated
change connectedness 

packing 

given rectangle number squares  squares grid

without overlaps 

disjunctive scheduling 

schedule number actions given earliest start

latest end time additional constraints precedence disjointness 

   

filazy model expansion  interleaving grounding search
  inst 

  solved

g s

benchmark

sokoban
disj  sched 
packing
labyrinth
reachability
stable marr 
graph col 

  

  

  

 

lazy
  

  

  

  
  

   

  

  

  

 

   

  

  

  
  

  

  

avg  time  sec  

asp

  

g s

lazy

asp

   

  

 

   

   

 

   

   

  
 

   

   

   
  

   
 

   

  

 

   

   

  

   

  

   
  
  

table    number solved instances asp benchmarks average time taken
solved instances  dierent solvers solve quite dierent sets instances 

sokoban 

planning problem robot push number blocks goal

positions  constrained   d maze 

graph colouring 

given graph  assign colour nodes  from given set colours  

connected nodes colour 

stable marriage 

given set men women set preferences  nd

stable assignment  swap results better match 
these  used instances           competitions  except
    

reachability

instances  huge data les none systems

stable marriage  graph colouring reachability 
packing disjunctive
idp
scheduling  constructed natural fo   encoding made faithful translation
asp  complex benchmarks labyrinth sokoban  used original
fo  idp gringo clasp s asp specications submitted      competition 

designed handle 



based encodings available asp core   encodings 

lazy model expansion  replaced cardinality expressions fo encoding
former justications derived yet  increases size full grounding 

      results
number solved instances average time shown table    average grounding
size

idp

 

setup shown table   

time grounding size  unsolved instances

reachability    times g s 
asp   disjunctive scheduling    times asp  labyrinth      times g s 
asp   packing    times g s    times lazy     times asp  stable
marriage     times asp   unsolved instances caused time out  
taken account  memory overows happened
  times

   grounding consists variable instantiation interleaved formula simplication  e g   dropping false
disjuncts  true conjuncts  replacing disjunctions true disjuncts true conjunctions false
conjunctions false  etc   simplication steps may seriously reduce grounding size 
  

idp

automatic symmetry breaking  cause dierence

colouring 

   

g s



asp



graph

fide cat  denecker  stuckey   bruynooghe
ground size    atoms 
benchmark

sokoban
disj  sched 
packing
labyrinth
reachability
stable marr 
graph col 

g s
        
        
        
        
        
        
        

lazy
        
        
        
        
        
        
        

ground time

asp
        
        
        
        
        
        
        

table    average grounding size number
marks  setups 
taken 

g s



asp 

lazy

solved

g s sec  

asp

   
     
     
     
     
     

   

 sec  

   
   
   
   
    
   
   

instances asp bench 

setup  size nal ground theory

average grounding time shown 

results show lazy model expansion solved instances setups
four seven cases  cases  problems got solved signicantly
time threshold 

seven cases   nal  grounding size smaller

lazy model expansion  orders magnitude one case 

colouring 

sokoban  labyrinth graph

lazy model expansion outperformed ground and solve  indicating

sokoban 
lazy grounding size even higher g s  possible due fo encoding
cardinalities   indicating large part search space explored  stable
marriage  relatively small dierence grounding size g s lazy leads us
loss information outweighed gain grounding less up front  e g  
nal

believe dierent search heuristic main factor  lazy grounding itself 
experimented

airport pickup asp      benchmark  fairly standard

scheduling problem  transporting passengers taxis taking account fuel consumption 
except upper bound time provided 

 

hence ground and solve approach

would need construct innite grounding  applying straightforward lazy model expansion resulted grounding large  however  prototype uses
late grounding heuristic described section     

idp

solved one ten instances 

others  grounding problem  search took long
time intervals

   n

considered get sucient

n

solve problem  even

standard search heuristic  
presented results show that  although often benecial  lazy model expansion
considerable overhead hard search problems  hand  inspecting
outcome experiments  observed class specications instances
solved lazy grounding traditional grounding partially overlap  suggests
might good idea integrate approaches

portfolio

system  system

either select heuristically whether use ground and solve lazy model expansion
 based input  running parallel  aborting either one uses much
memory  however  problems considered  lazy model expansion could start search
   possible derive nite worst case thresholds airport pickup problem  is  however 
part original specication 

   

filazy model expansion  interleaving grounding search
much earlier ground and solve  even though got lost often search 
leads us believe realize full potential lazy grounding  work necessary
developing suitable heuristics  possibly user specied ones  

    specic experiments
addition asp competition benchmarks  experiments conducted using
crafted benchmarks illustrate specic properties lazy grounding algorithm 
rst part table   shows results scalability experiments 
benchmarks

packing  sokoban



disjunctive scheduling 

selected simple prob 

lem instance gradually extended domain size orders magnitude  size
grid  packing  number time points  sokoban 

disjunctive scheduling  



results show instances  lazy model expansion scales much better
ground and solve strategies
satisable instances  however 
signicantly 

idp

gringo clasp satisable well un 

disjunctive scheduling solving time still increases

reason lazy heuristics still naive make uninformed

choices often 
mentioned previous section  asp competition problems typically small
groundings since running benchmarks large system handle
provide useful comparison systems  hence  evaluated lazy model expansion
number crafted benchmarks grounding non trivial 
work look practical applications type 

part future

constructed following

benchmarks 

dynamic reachability 


lazy evaluation

example described section     

procedurally interpreted

prime numbers 

symbols  using simple theory

described section      predicate symbol

isp rime  



interpreted procedure returns true argument prime 

function



predicate encoding



experiment simulates model generation theory unknown domain 

huge domain 

used    quantied formulas
x    used x     model
 
domain size     

unknown domain expressed new predicate

x  

translated

x    used x   



x  

generation simulated model expansion



one  faithful asp encoding constructed  second part table   shows
results benchmarks  show signicant improvement lazy model expansion ground and solve examples  case 
memory overow grounding 


disjunctive scheduling 

lazy

g s



asp

went

found solutions within seconds  however 

evident lazy approach would benet

improved heuristics  increasing domain size signicantly increases solving time 
instances intrinsically harder 

      closer inherent complexity 
modeling phase application  dierent encodings typically tested out 
attempt improve performance locate bugs  modeling experimental

   

fide cat  denecker  stuckey   bruynooghe
benchmark

packing   
packing   
packing   
sokoban    
sokoban    
sokoban    
disj sched sat    
disj sched sat    
disj sched sat    
disj sched unsat    
disj sched unsat    
disj sched unsat    
dynamic reachability
procedural
function
modelgeneration

lazy

g s

asp

   

   

   

   

   

   

   

     

   

    

   

   

   

    

   

   



    

    

    

    
     

     

     

      





    

    

    

    

     

     













     
    
    
    
    

table    solving time additional crafted benchmarks  one instance each 

benchmarks  noticed simplifying theory dropping constraints often resulted
dramatic reduction time lazy model expansion took nd model  standard
model expansion  hand  much less aected simplications 



opinion  observation  hardly denitive evidence  another indication
presented algorithms able derive justications parts theory
satised cheaply  way  approach able distinguish better problems
inherently dicult problems would large grounding 

   related work
lazy model expansion oers solution blow up grounding often occurs
ground and solve model expansion methodology

fo id  

theories 

answer set

programming  asp  sat modulo theories  smt  techniques process theories
large grounding  constraint store constraint programming  cp  mixed
integer programming clauses sat considered equivalent grounded
theory  they often derived quantied descriptions ci

j

  cj



        become large  lefvre nicolas        ge

de moura        reported blow up problem paradigms multitude
techniques developed address it  distinguish four approaches 
first  concerning grounding up front  research done towards

grounding

static analysis
ii

   

reducing size

input derive bounds variable

instantiations  wittocx et al                    techniques

compile

specic types sen 

tences compact ground sentences  tamura et al         metodi   codish        

iii  detect parts evaluated polynomially  leone et al         gebser et al        
iv  detect parts relevant task hand  e g  

 

jansen et al          

   

filazy model expansion  interleaving grounding search
context query problems  shown work leone et al          naturally 
approaches used conjunction lazy grounding reduce
size grounding 

idp 



e g   lazy grounding already combined      

second  size grounding reduced

enriching

language 

iii  

ex 

ample  asp solvers typically support ground aggregates  interpreted second order functions
cardinality sum take sets arguments   cp smt solvers support
 uninterpreted  functions  recently  constraint asp paradigm developed  ostrowski   schaub         integrates asp cp extending asp language

constraint

atoms  interpreted constraints csp problem thus

handled using cp techniques  various casp solvers already available  clingcon  ostrowski schaub   ezcsp  balduccini         mingo  liu  janhunen    niemel 
      inca  drescher   walsh         technique integrated
cat et al         

inca

idp

idp

 de

fact implement lazy clause generation  ohrimenko

et al          optimized form lazy grounding specic types constraints 
language hex asp  eiter et al         extends asp  time

external



atoms

represent  higher order  external function calls 
third 

incremental approaches

well known model generation  theorem proving

planning  tasks  domain typically xed advance  part
structure sought  number time steps planning problem  recall
sokoban example introduction   approach typically works grounding
problem initial guess  the number elements in  domain 

afterwards 

search applied  model found  domain extended grounding
done  iterated model found bound maximum domain size
hit  if one known  

technique applied  e g   prover paradox  claessen  

srensson        asp solver iclingo  gebser et al         
fourth  closest lazy grounding itself  large body research devoted
delaying grounding specic types expressions necessary  for example
result propagation   propagation techniques rst order level delay grounding
propagation ensues researched within asp  lefvre   nicolas        dal
pal et al         dao tran et al         within cp  ohrimenko et al         



techniques used conjunction lazy grounding derive intelligent
justications specic types constraints presented here  example  dao tran et
al  presented ecient algorithm bottom up propagation denition  within
smt  various theory propagators work lazily transforming theory sat 
theory bit vectors bruttomesso et al         

ge de moura       

investigated quantier handling combining heuristic instantiation methods research
decidable fragments fo theories  eciently checked models 
within asp  work done goal directed reasoning  bonatti  pontelli 
son        marple  bansal  min  gupta        demonstrate approaches 
style sld resolution  apply top down instantiation answer queries innite
domains  saptawijaya pereira        extend abduction framework lazily generate
part relevant sentences  search algorithms  justications  or

watches  

used

derive constraint result propagation already satised  hence need
checked propagation phase  nightingale et al         show maintaining
 short  justications signicantly reduce cost propagation phase 

   

fide cat  denecker  stuckey   bruynooghe
fact  well known technique already exists combines search lazy instantiation quantiers  namely

skolemization 

existentially quantied variables re 

placed newly introduced function symbols 

universal quantications handled

instantiating introduced function symbols 

reasoning consistency can 

e g   achieved congruence closure algorithms  capable deriving consistency without eectively assigning interpretation function symbols 

techniques

used tableau theorem proving  hhnle        smt solvers  detlefs  nelson    saxe 
      

formula  jackson  bjorner    schulte        interleaves creating ground pro 

gram giving smt solver  iterating symbolic guesses proved wrong 
skolemization based techniques typically work well case small number constants
needs introduced  diculty case relevant domain large  one
see lazy grounding  with support function symbols  could incorporate skolemization adapting rules grounding existential universal quantication  expect
skolemization complementary lazy grounding  in depth investigation part
future work 
eld probabilistic inference  several related techniques developed
rely lazy instantiation  first  problog system uses form static dependency
analysis ground  probabilistic  program context given query  constructing
possible ways derive query top down fashion  kimmig et al          second 
so called

lazy inference 

applied e g 

lazysat

fact that  considered inference   xed 

 singla   domingos         exploits

default

assumption exists

expression certainly contribute probabilities 

hence  expressions

assumption certainly holds considered search  third 

cutting plane inference

 riedel        applies lazy inference interleaved setting 

constructing part program assumptions satised 

   future work
several aspects presented work need investigation  one aspect extending
support lazily ground complex expressions  including aggregate expressions

p
  xd p  x  f  x       
atom p  d  true    p

 nested  function terms  consider example sentence
expresses sum terms
predicate

f

f  d 



function  larger    one observe necessary

ground whole sentence up front 
 hence positive   set

example 

 p  d     f  d        

f

maps natural numbers

minimal justication 

even easy

justication found  suce grounding part sentence delay

p

p  d    f  d          
p
p
tseitin symbol dened  
p  d    f  d         xd d  p  x  f  x        indeed 
model sentence false  original inequality satised 

remainder 

example  create ground sentence

 

second aspect whether advantages grounding earlier  example
guarantee propagation lost  grounding later  possibly reducing size grounding even more  example  consider sentences

p



p  









large formulas justication found  instead grounding least one
sentences  might add

p

list atoms search algorithm assign

   

filazy model expansion  interleaving grounding search
ground either sentences

p

assigned value  it might even

unsatisability detected grounding either one  
given lazy grounding useful  lazy

forgetting

grounded theory 

ground theory extended making structure precise  ground theory
could reduced backtracking 

storing justication violations

caused grounding  derive grounding forgotten violation
longer problematic  e g   backtracking   this  algorithm needs developed
tracks grounding splitting dependencies rules given justications 
closely resembles techniques used tableau theorem proving smt  theory
hand compacted moving dierent part search space 
approach described lazy grounding applied answer set generation
eld asp  asp  logic program stable semantics seen one rule
set  single denition  however  asp programs satisfy major condition
apply lazy grounding  indeed programs typically non total  due presence
constraints rules form

p np  np p



choice rules

result

multiple stable models  however  described denecker et al          practical
asp programs partitioned set choice rules  set

total

denitions set

constraints  the so called generate dene test partition   asp program
gdt partitioned  translated straightforwardly equivalent

fo id  

theory

contains total denitions  suggests way apply lazy grounding
asp programs 

   conclusion
solvers used domains sat  smt asp often confronted problems
large ground  lazy model expansion  technique described paper 
interleaves grounding search order avoid grounding bottleneck  technique
builds upon concept justication  deterministic recipe extend interpretation
satises certain constraints  theoretical framework developed lazy
model expansion language

fo id   algorithms presented derive

maintain justications interleave grounding state of the art cdcl search
algorithms 

framework aims bounded model expansion  domains

nite  initial step towards handling innite domains eciently  experimental
evaluation provided  using implementation

idp

system  lazy

model expansion compared state of the art ground and solve approach 



experiments showed considerable improvement ground and solve existing benchmarks
well new applications  main disadvantage less informed search algorithm 
caused delay propagation introduction additional symbols  possible
solution develop new heuristics portfolio approaches combine strengths
methods  finally  indicated way proposed methods applied
beyond

fo id   

asp solvers general 

   

fide cat  denecker  stuckey   bruynooghe
acknowledgements
research  broes de cat funded agency innovation science
technology flanders  iwt   research supported fwo vlaanderen
project goa         research fund kuleuven 

nicta funded

australian government department communications australian
research council ict centre excellence program 

appendix a  details algorithms
appendix  mention parameter values well optimizations
reduce grounding overhead and or improve search  optimization  indicate currently implemented  and part experimental results  part
future work 

a   parameter values
     number parameters introduced control behavior lazy model
expansion 

here  provide details values used experimental evaluation 

values set manually  based experience limited number observations
 e g   extension threshold works similar conict threshold sat solver  
part future work study impact dierent values 



existential quantication     instantiations grounded time  disjunction    disjuncts grounded time  turned give best balance
introducing many tseitin atoms grounding much 



initial truth value



initial threshold randomized restarts     extensions ground theory 



probability

   



f

otherwise 

doubled restart 



formula considered small estimated grounding size

   

atoms 

a   extension fo  idp
far  described lazy model expansion algorithm function free
however 

fo  idp  

knowledge base language

idp

fo id   

system  supports much richer

input language  besides types use initialize domains supports
 partial  functions  aggregates arithmetic 

current implementation ignores

latter extensions straightforward adaptation build djust  algorithm    
case literals extended return

fo id  

false

literal part function free

language  example  given rule

justication

q f  x  

h x   p  x  q f  x    p  x  used

cannot  functions  option replace

graph predicates preprocessing step  experiments section     
functions  any  given input structure hence play role 
part future work extend lazy grounding extensions  especially
functions  techniques developed smt constraint programming handle  ground 

   

filazy model expansion  interleaving grounding search
atoms containing function symbols useful reduce size grounding improve
search  previous work  techniques integrated

idp

system  de cat

et al         certainly worthwhile fully integrate lazy grounding 

a   cheap propagation checks 
lazy mx  checked assigned literal whether dened



whether

violates justications  implement cheaply  implementation maintains
mapping literals

g  

states whether literal dened



lists

justications negation occurs  mapping extended whenever new literal
added

g

maintained whenever justications change 

performance

search loop unaected long literals assigned mapping empty 

a   stopping early
algorithm    took standard stopping criterion used search algorithms
 line      stop conict free state



two valued symbols

principle  may stop earlier  partial structure

pt  

indeed  corollary     tells us





tg g  



admits total justication

expanded model 

dened
irrelevant  in eect  appear justication  trigger grounding
a s denition  turn might introduce new literals dened   causing cascade

considerable impact grounding size  indeed  assigning truth value atom


unnecessary groundings assignments 
justication

g  

solver algorithm maintain

cannot know exactly justication exists 

instead 

implemented algorithm chooses literals watched formula rule 



stops partial structure unwatched literals may assigned 
shown suces guarantee



admits justication  hence safe stop

search 

a   approximate justications
cases  build djust cannot nd valid justication large formula

i 
false least one atom p
literals already false

example formula

x   p  x  

build djust returns

false  instead  adapted build djust heuristic

check number expected violations  small enough  justication still
returned  naturally  required check whether real violations 
querying justication formula

i 

apply lazy ground them 

references
alviano  m   calimeri  f   charwat  g   dao tran  m   dodaro  c   ianni  g   krennwallner 
t   kronegger  m   oetsch  j   pfandler  a   phrer  j   redl  c   ricca  f   schneider 
p   schwengerer  m   spendier  l  k   wallner  j  p     xiao  g          fourth
answer set programming competition  preliminary report 
t  c   eds   
apt  k  r         

cabalar  p     son 

lpnmr  vol       lncs  pp        springer 
principles constraint programming  cambridge university press 
   

fide cat  denecker  stuckey   bruynooghe
balduccini  m         

industrial size scheduling asp cp 

delgrande  j  p    

lpnmr  vol       lncs  pp          springer 
knowledge representation  reasoning  declarative problem solving 

faber  w   eds   
baral  c         

cambridge university press  new york  ny  usa 
bonatti  p  a   pontelli  e     son  t  c         

credulous resolution answer set

programming  fox  d     gomes  c  p   eds   

aaai  pp          aaai press 

bruttomesso  r   cimatti  a   franzn  a   griggio  a   hanna  z   nadel  a   palti  a  
  sebastiani  r         
verication problems 

lazy layered smt bv  solver hard industrial

damm  w     hermanns  h   eds   

lncs  pp          springer 

cav 

vol      

calimeri  f   ianni  g     ricca  f          third open answer set programming competition 

tplp                 

chen  w     warren  d  s          tabled evaluation delaying general logic programs 

j  acm               

claessen  k     srensson  n         

new techniques improve mace style model

proceedings cade    workshop  model computation   principles 
algorithms  applications 
nding 

dal pal  a   dovier  a   pontelli  e     rossi  g          answer set programming
constraints using lazy grounding  hill  p  m     warren  d  s   eds   
    

lncs  pp          springer 

dao tran  m   eiter  t   fink  m   weidinger  g     weinzierl  a         

iclp 

vol 

omiga  

open minded grounding on the y answer set solver  del cerro  l  f   herzig  a  

jelia  vol       lncs  pp          springer 
cat  b          separating knowledge computation  fo    knowledge base
system model expansion inference  ph d  thesis  ku leuven  leuven  belgium 
  mengin  j   eds   

de

de cat  b   bogaerts  b   bruynooghe  m     denecker  m         
modelling language  idp system 

corr  abs           

predicate logic

de cat  b   bogaerts  b   devriendt  j     denecker  m          model expansion
presence function symbols using constraint programming 

ictai  pp           

ieee 
de cat  b   denecker  m     stuckey  p  j          lazy model expansion incremental
grounding  dovier  a     costa  v  s   eds   

iclp  technical communications  

lipics  pp          schloss dagstuhl   leibniz zentrum fuer informatik 
delgrande  j  p     faber  w   eds            logic programming nonmonotonic reasoning     th international conference  lpnmr       vancouver  canada  may       
      proceedings  vol       lncs  springer 
vol    

denecker  m          well founded semantics principle inductive denition 
dix  j   del cerro  l  f     furbach  u   eds   
springer 

   

jelia  vol       lncs  pp      

filazy model expansion  interleaving grounding search
denecker  m          extending classical logic inductive denitions  lloyd  j  w  
dahl  v   furbach  u   kerber  m   lau  k  k   palamidessi  c   pereira  l  m   sagiv 
y     stuckey  p  j   eds   

cl  vol       lncs  pp          springer 

denecker  m   bruynooghe  m     marek  v  w          logic programming revisited  logic
programs inductive denitions 

acm trans  comput  log                 

denecker  m     de schreye  d          justication semantics  unifying framework
semantics logic programs 

tech  rep       department computer science 

k u leuven 
denecker  m     de schreye  d          justication semantics  unifying framework
semantics logic programs  pereira  l  m     nerode  a   eds   

lpnmr  pp 

        mit press 
denecker  m   lierler  y   truszczynski  m     vennekens  j         
mal semantics answer set programming 

iclp  technical communications  

vol    

tarskian infor 

dovier  a     costa  v  s   eds   

lipics 

pp          schloss dagstuhl

  leibniz zentrum fuer informatik 
denecker  m     ternovska  e          logic nonmonotone inductive denitions 

trans  comput  log                    

acm

denecker  m     vennekens  j          well founded semantics principle inductive denition  revisited  baral  c   de giacomo  g     eiter  t   eds   

kr 

pp 

      aaai press 
denecker  m   vennekens  j   bond  s   gebser  m     truszczyski  m          second
answer set programming competition 

erdem  e   lin  f     schaub  t   eds   

lpnmr  vol       lncs  pp          springer 
detlefs  d   nelson  g     saxe  j  b         
checking 

j  acm                 

simplify  theorem prover program

technical communications   th international conference logic programming  iclp       september            budapest 
hungary  proceedings  vol     lipics  schloss dagstuhl   leibniz zentrum fuer in 

dovier  a     costa  v  s   eds           

formatik 
drescher  c     walsh  t          answer set solving lazy nogood generation  dovier 
a     costa  v  s   eds   

iclp  technical communications  

vol    

lipics 

pp 

        schloss dagstuhl   leibniz zentrum fuer informatik 
eiter  t   ianni  g   schindlauer  r     tompits  h          uniform integration higherorder reasoning external evaluations answer set programming 

kaelbling 

ijcai  pp        professional book center 
mathematical introduction logic  second edition  

l  p     saotti  a   eds   
enderton  h  b         

academic

press 

logic programming nonmonotonic reasoning    th international conference  lpnmr       potsdam  germany  september
             proceedings  vol       lncs  springer 

erdem  e   lin  f     schaub  t   eds           

   

fide cat  denecker  stuckey   bruynooghe
ge  y     de moura  l  m          complete instantiation quantied formulas satisabiliby modulo theories  bouajjani  a     maler  o   eds   

lncs  pp          springer 

cav 

vol      

gebser  m   kaminski  r   kaufmann  b   ostrowski  m   schaub  t     thiele  s         
engineering incremental asp solver 
 eds   

garca de la banda  m     pontelli  e 

iclp  vol       lncs  pp          springer 

gebser  m   kaminski  r   knig  a     schaub  t          advances gringo series   
delgrande  j  p     faber  w   eds   

lpnmr 

vol      

lncs 

pp         

springer 
gebser  m   schaub  t     thiele  s         

gringo   new grounder answer set

programming  baral  c   brewka  g     schlipf  j  s   eds   

lncs  pp          springer 

hhnle  r         
 eds   

tableaux related methods 

lpnmr  vol      

robinson  j  a     voronkov  a 

handbook automated reasoning  pp          elsevier mit press 

jackson  e  k   bjorner  n     schulte  w         

open world logic programs  new

foundation formal specications  tech  rep  msr tr          microsoft research 
jansen  j   jorissen  a     janssens  g          compiling input

 
tabled prolog rules idp  

fo   inductive denitions

tplp                   

karp  r          reducibility among combinatorial problems  miller  r     thatcher  j 
 eds   

complexity computer computations  pp         plenum press 

kimmig  a   demoen  b   de raedt  l   santos costa  v     rocha  r         
implementation probabilistic logic programming language problog 

                 

lefvre  c     nicolas  p         



tplp 

rst version new asp solver  asperix 

erdem  e   lin  f     schaub  t   eds   

lpnmr 

vol      

lncs 



pp         

springer 
leone  n   pfeifer  g   faber  w   eiter  t   gottlob  g   perri  s     scarcello  f         
dlv system knowledge representation reasoning 

log                 

acm trans  comput 

liu  g   janhunen  t     niemel  i          answer set programming via mixed integer
programming 

brewka  g   eiter  t     mcilraith  s  a   eds   

kr 

pp       

aaai press 
marek  v  w     truszczyski  m         
gramming paradigm 
d  s   eds   

stable models alternative logic pro 

apt  k  r   marek  v  w   truszczyski  m     warren 

logic programming paradigm     year perspective 

pp         

springer verlag 
marin  m         

model generation id logic 

ph d  thesis  department computer

science  ku leuven  belgium 
marin  m   gilis  d     denecker  m          relation id logic answer
set programming  alferes  j  j     leite  j  a   eds   
pp          springer 

   

jelia 

vol      

lncs 

filazy model expansion  interleaving grounding search
marin  m   wittocx  j   denecker  m     bruynooghe  m          sat id   satisability
propositional logic extended inductive denitions  kleine bning  h     zhao 
x   eds   

sat  vol       lncs  pp          springer 

marple  k   bansal  a   min  r     gupta  g          goal directed execution answer
set programs  schreye  d  d   janssens  g     king  a   eds   

ppdp 

pp       

acm 
marques silva  j  p   lynce  i     malik  s         

conict driven clause learning sat

handbook
satisability  vol      frontiers articial intelligence applications  pp     
solvers 

biere  a   heule  m   van maaren  h     walsh  t   eds   

     ios press 
metodi  a     codish  m          compiling nite domain constraints sat bee 

tplp                   

mitchell  d  g     ternovska  e         

framework representing solving np

search problems  veloso  m  m     kambhampati  s   eds   

aaai 

pp         

aaai press   mit press 
mitchell  d  g   ternovska  e   hach  f     mohebali  r         

model expansion

framework modelling solving search problems  tech  rep  tr          simon
fraser university  canada 
nethercote  n   stuckey  p   becket  r   brand  s   duck  g     tack  g          minizinc 
towards standard cp modelling language  bessiere  c   ed   


lncs  pp          springer 

cp    

vol      

nightingale  p   gent  i  p   jeerson  c     miguel  i          short long supports
constraint propagation 

j  artif  intell  res   jair           

ohrimenko  o   stuckey  p  j     codish  m          propagation via lazy clause generation 

constraints                 

ostrowski  m     schaub  t         

                 

asp modulo csp  clingcon system 

riedel  s          cutting plane map inference markov logic 

statistical relational learning  srl       

saptawijaya  a     pereira  l  m         

tplp 

international workshop

towards practical tabled abduction logic

programs  correia  l   reis  l  p     cascalho  j   eds   

epia  vol       lncs 

pp          springer 
singla  p     domingos  p          memory ecient inference relational domains  gil 
y     mooney  r  j   eds   

aaai  pp          aaai press 

son  t  c   pontelli  e     le  t         

two applications asp prolog system 

decomposable programs multi context systems  flatt  m     guo  h  f   eds   

padl  vol       lecture notes computer science  pp         springer 

tamura  n   taga  a   kitagawa  s     banbara  m          compiling nite linear csp
sat 

constraints                 

   

fide cat  denecker  stuckey   bruynooghe
torlak  e   chang  f  s  h     jackson  d          finding minimal unsatisable cores
declarative specications  cullar  j   maibaum  t  s  e     sere  k   eds   
vol      

lncs  pp          springer 

fm 

tseitin  g  s          complexity derivation propositional calculus  slisenko 
a  o   ed   

studies constructive mathematics mathematical logic ii  pp     

     consultants bureau  n y 
van gelder  a          alternating xpoint logic programs negation 

syst  sci                  

j  comput 

vennekens  j   marin  m   wittocx  j     denecker  m          predicate introduction
logics xpoint semantics  part i  logic programming 

                 

fundamenta informaticae 

wittocx  j   denecker  m     bruynooghe  m          constraint propagation rst order
logic inductive denitions 

acm trans  comput  logic                    

wittocx  j   marin  m     denecker  m         

idp system  model expansion system

extension classical logic  denecker  m   ed   

lash  pp          acco 

wittocx  j   marin  m     denecker  m          grounding fo fo id  bounds 

j  artif  intell  res   jair              

   


