journal artificial intelligence research                  

submitted        published      

distributed evaluation nonmonotonic multi context systems
minh dao tran
thomas eiter
michael fink
thomas krennwallner

dao   kr   tuwien   ac  
eiter   kr   tuwien   ac  
fink   kr   tuwien   ac  
tkren   kr   tuwien   ac  

institute fur informationssysteme  tu wien
favoritenstrasse       a      vienna  austria

abstract
multi context systems  mcss  formalism systems consisting knowledge bases
 possibly heterogeneous non monotonic  interlinked via bridge rules  global
system semantics emerges local semantics knowledge bases  also called contexts 
equilibrium  mcss related formalisms inherently targeted distributed settings  truly distributed algorithms evaluation available  address shortcoming present suite algorithms includes basic algorithm dmcs  advanced version dmcsopt exploits topology based optimizations  streaming algorithm
dmcs streaming computes equilibria packages bounded size  algorithms behave quite differently several respects  experienced thorough experimental evaluation
system prototype  experimental results  derive guideline choosing appropriate
algorithm running mode particular situations  determined parameter settings 

   introduction
last decade  increasing interest systems comprise information
multiple knowledge bases  includes wide range application fields data integration  multi agent systems  argumentation many others  picture concrete real world
application  may consider metis  velikova et al          industrial prototype system facilitating timely human decision making maritime control  application  human operators
need support determine whether ship entering port might hide identity illegal activities might high risk environmental hazard  access risks  metis relies
number heterogeneous external information sources commercial ship database ihs
fairplay   ship tracking websites   news items history pollution events ship may
involved in 
rise word wide web distributed systems propelled development 
date several ai based formalisms available host multiple  possibly distributed knowledge
bases compound system  well known formalisms distributed sat solving  hirayama
  yokoo         distributed constraint satisfaction  faltings   yokoo        yokoo   hirayama 
       distributed ontologies different flavors  homola         mweb  analyti  antoniou   
damasio         different approaches multi context systems  giunchiglia   serafini       
ghidini   giunchiglia        brewka  roelofsen    serafini        brewka   eiter        bikakis
   www ihs com products maritime information 
   marinetraffic com  myship com
c
    
ai access foundation  rights reserved 

fidao  t ran   e iter   f ink     k rennwallner

figure    pinpointing joker
  antoniou        rooted mccarthys        work  among them  focus heterogeneous nonmonotonic multi context systems  mcss   brewka   eiter        
generalization previous proposals  mcss powerful formalism specify systems
knowledge bases may different formats reasoning powers  ranging simple
query answering relational database reasoning description logic knowledge bases  see
baader et al          well nonmonotonic formalisms default logic  reiter       
answer set programs  gelfond   lifschitz         allow heterogeneous knowledge bases
deal impedance mismatch them  mcss abstract knowledge bases plain mathematical structures  top  special bridge rules interlink knowledge bases  bridge rule
adds formula knowledge base  depending certain beliefs knowledge bases  hence
semantics knowledge base associated bridge rules  forms context  depends
contexts  possibly cyclic manner  based this  mcss equilibrium semantics
terms global states every context adopts abstract local model  called belief set 
conformant local models adopted contexts addition obeys
bridge rules  following simple example  paraphrase ghidini giunchiglias
       magic box  illustrates power idea 
example   suppose computer game  players batman robin chased player joker
partially occluded area  shown figure    robin wounded cannot read distance
objects  neither batman robin tell jokers exact position    box  batman
assure columns      robin tell row    however 
exchange partial knowledge  pinpoint joker row   column   
model batman robin contexts whose local knowledge bases include information jokers position  exchanged using bridge rules  row  x      
row  x    batman  informally imports robins knowledge  context    row
positions  full encoding given example    equilibrium emerging mcs discloses
jokers position batman robin 
   

fid istributed e valuation n onmonotonic ulti   context ystems

although mcss related formalisms inherently target distributed systems  truly distributed algorithms computing equilibria mcss available  brewka eiter       
encoded equilibria hex programs  eiter  ianni  schindlauer    tompits        
evaluated using dlvhex solver  however  approach elegantly offers full heterogeneity  fully centralized needs technical assumptions  roelofsen  serafini  cimatti       
proposed earlier algorithm check satisfiability homogeneous  monotonic mcs
centralized control accesses contexts parallel  hence truly distributed   bikakis
antoniou        instead gave distributed algorithm defeasible multi context systems 
however  latter homogeneous  possibly nonmonotonic  contexts particular type
semantics  algorithm serves query answering model building 
lack distributed algorithms evaluating mcss based local context handlers due
several obstacles 
abstract view local semantics belief sets limits algorithm global level
interference knowledge bases evaluation process context 
towards real life applications  certain levels information hiding security required
 e g  information exchange knowledge bases companies  selected
information transferred contexts via well defined interfaces  prevents context
getting insight neighbors optimization  instance learn conflicts  i e  
joint beliefs leading contradiction  across contexts 
mcs system topology  i e   structure context linkage  might unknown context 
disables decomposing system efficient  modular evaluation 
bridge rules might fuel cyclic information flow group contexts  even
context easy evaluate  e g   knowledge bases acyclic logic programs   global cycles
require nontrivial care 
article  address obstacles present results towards efficient distributed evaluation mcss  main contributions suite generic algorithms dmcs  dmcsopt 
dmcs streaming work truly distributed  implementation system prototype 
detail  contributions follows 
    algorithms optimization techniques
    first  basic algorithm dmcs aims fully distributed setting deal obstacles
generic way  contexts exchange belief sets call history  i e   access path
traversing bridge rules   information  global level  belief states formed
tuples belief sets  context bridge rules must respect belief sets neighbors
computing belief sets using local solver knowledge base  cycles detected
call history  context gets request finds call history  break cycle 
guessing technique used checks return path 
    localizing contexts knowledge system information exchange  dmcs
fairly easily adapt context changes  additions deletions   time faces
scalability issues  enhance performance optimized version dmcsopt  disclose
meta level information contexts  viz   i  topology context dependencies  exploited
decomposing mcs sub mcss  blocks  linked block tree   ii  interface contexts  optimizing data transfer blocks   i  breaks cycles
   

fidao  t ran   e iter   f ink     k rennwallner

advance  ii  significantly reduces duplicate local evaluation  yields remarkable performance gain 
    still dmcs dmcsopt compute equilibria mcs  escape
scalability memory issues  multiple local belief sets lead combinatorial explosion
global level  thus consider computing equilibria streaming mode  end  contexts pass
belief sets one shot parents gradually small packages  memory blowup
thus avoided moreover contexts continue earlier wait answers
neighbors  approach seems user friendly equilibria gradually appear rather
once  possibly long time  one may quit computation seeing sufficiently
many results  i e   equilibria  
    implementation experiments
implemented algorithms system prototype  assess effects optimization techniques  set benchmarking system conducted comprehensive experiments
mcss various topologies interlinking  results confirm expectation optimization techniques general  nutshell   i  decomposition technique clearly improves
performance non streaming mode   ii  streaming worthwhile may still find answers
non streaming times out   iii  streaming  choosing package size important 
 iv  system topology important optimization techniques show drastic improvements
specific topologies   v  sometimes  techniques yield gain incur overhead 
results work provide truly distributed algorithms evaluating mcss 
distributed versions non monotonic knowledge base formalisms
 e g   distributed answer set programs   underlying principles techniques might
exploited related contexts  furthermore  may provide basis evaluation extensions generalizations mcss  non ground mcss  fink  ghionna    weinzierl        
managed mcss  brewka  eiter  fink    weinzierl         supported mcs  tasharrofi   ternovska 
       reactive mcss  goncalves  knorr    leite        brewka  ellmauthaler    puhrer        
    organization
remainder article organized follows  next section provides preliminaries
multi context systems  section   introduces basic distributed algorithm dmcs  section   develops optimized algorithm dmcsopt  section   presents streaming algorithm dmcs streaming  experimental results prototype implementation reported
section    section    consider related works  section   summarize address
open issues  increase readability  proofs moved appendix 

   preliminaries
sections briefly introduces preliminaries needed rest article 
    multi context systems
first  present formalization heterogeneous nonmonotonic multi context systems  mcss 
proposed brewka eiter        described brewka  eiter  fink        
   

fid istributed e valuation n onmonotonic ulti   context ystems

serves base work  idea behind mcss allow different logics used
different contexts  model information flow among contexts via bridge rules  notion
logic defined follows 
definition    cf  brewka   eiter        logic l    kbl   bsl   accl   composed
following components 
   kbl set well formed knowledge bases l  consists set
elements called formulas 
   bsl set possible belief sets  bsl set elements called beliefs 

   accl   kbl  bsl function describing semantics logic  assigning
element kbl set acceptable sets beliefs 
notion logic generic  abstracts formation agents beliefs bare
minimum  structure formulas  both knowledge base belief sets  dismissed 
viewed naked elements  likewise particular inference mechanism associated
knowledge base  logical properties imposed belief sets  term belief
reflects statements held agent might epistemic basis  without going
detail  assignment acceptable beliefs sets knowledge base  intuitively
set beliefs agent willing adopt given knowledge base  captures logics
 e g   nonmonotonic logics  multiple even acceptable belief sets possible 
abstract model allows us capture range different logics knowledge representation
reasoning  including classical logic  modal logics  epistemic logics  spatial logics  description
logics etc  nonmonotonic logics default logic  reiter        answer set programs
 gelfond   lifschitz         different varieties settings  comparison formalisms
given brewka et al          example  classical  propositional predicate logic  may
modeled follows 
kb  set  well formed  sentences signature  
bs  set deductively closed sets  sentences   i e   cn s    s  cn  
denotes deductive closure  
acc kb   singleton containing deductive closure kb  i e   acc kb     cn kb   
example nonmonotonic logics   disjunctive  logic programs answer set semantics  gelfond   lifschitz        modeled
kb  set logic programs signature  
bs  set consistent sets literals  
acc kb   set  kb  answer sets kb according gelfond lifschitz         
refer setting  used repeatedly sequel  answer set programming
 asp   note answer sets knowledge base kb amount particular   valued models kb 
intuitively  positive literal p answer set s  p known true  negative
   common  exclude inconsistent answer sets admitted gelfond lifschitz        

   

fidao  t ran   e iter   f ink     k rennwallner

literal p s  p known false  known means literal present
fact derivable rules  neither p p s  truth value p unknown 
mcs modeling possible worlds  scenarios  view via answer sets  generated
answer set solver  however  asp implementations capture inference  truth
query respectively answer sets  forms belief set formation 
bridge rules  based logics  bridge rules introduced provide uniform way interlinking
heterogeneous information sources follows 
definition    cf  brewka   eiter        let l    l            ln    multi  set logics  lk bridge rule l    k n  form
 c    p              cj   pj     cj     pj               cm   pm  

   

 i    m  ci             n  pi element belief set lci  
 ii  kb kbk   holds kb  s  kbk  
informally  bridge rules refer bodies contexts  identified ci   thus add
information contexts knowledge base depending believed disbelieved
contexts  contrast giunchiglias        multi context systems  single  global set
bridge rules  context knows bridge rules 
means connecting contexts available  mcss formally defined 
definition    brewka   eiter        multi context system  mcs     c            cn   consists
collection contexts ci    li   kb   br   li    kbi   bsi   acci   logic  kb
kbi knowledge base  br set li  bridge rules  l            ln   
example    contd  scenario example   formalized mcs    c    c    
contexts l    l  instances answer set programming  and 


col  x  see col  x  
kb     f f 
r 
col  x  see col  x  


row  x       row  x   
br    
row  x  covered row  x       see row  x         row  x   


row  x  see row  x  
kb     f f 
r 
row  x  see row  x  


col  x       col  x   
br    
 
col  x  covered col  x       see col  x         col  x   

f    row      row      row      col      col      col       
f     see col      see col       
f     see row       
   

fid istributed e valuation n onmonotonic ulti   context ystems


r 





joker row  x  
joker col  x  

row  x  joker
row  x  joker
col  x  joker



col  x  joker




in  row  x   row  x  
in  row  x   row  y    x    y 
in  col  x   col  x  
in  col  x   col  y    x    y 





 




here  x variables used schematic rules  range rows resp  columns  i e  
        intuitively  c  formalizes batmans knowledge scene c  robin 
knowledge bases kb   kb     facts f represent box size      f  f  state
batman robin see  viz  joker columns     respectively
row    next two rules simply map sensed locations respective facts  informally  rules
r make guess row column joker is  concluded box  first
two rules   may lead multiple belief sets  importantly  batman adjusts knowledge base
depending beliefs communicated robin  bridge rules br     vice versa  bridge rules br     
convenience  introduce following notation conventions  mcs  
 c       
    cn    denote bi set
beliefs occur belief sets context ci   i e  
bi   sbsi s  let bm   ni   bi  simply b  understood   without loss
generality  assume distinct contexts ci cj   bi bj     bridge
atom form  i   bi   appearing bridge rule   holds bi bi  
    semantics multi context systems
semantics mcs defined terms special belief states  sequences  
 s            sn   si element bsi   intuitively  si belief set
knowledge base kb   however  bridge rules must respected  end  kb augmented
conclusions bridge rules applicable  precisely  bridge rule r form    
applicable s  pi sci     j  pk
  sck   j     k m  denote
head  r  head r  app r  s  set bridge rules r r applicable s 
then 
definition    brewka   eiter        belief state    s            sn   mcs    c           
cn   equilibrium  si acci  kb  head  r    r app br   s       n 
equilibrium thus belief state contains context acceptable belief set 
given belief sets contexts 
example    contd  mcs example   single equilibrium    s    s   
s    f f  f  s    f f  f  f     joker in  row      row     
row      col      col      col       equilibrium indeed reflects intuition
scenario example    batman robin together infer location joker 
single one cannot accomplish task without communication 
example   let    c    c    c    c    mcs li asp logics  signatures
     a        b        c  d  e        f  g   suppose
kb       br      a      b        c   
   

fidao  t ran   e iter   f ink     k rennwallner

kb       br      b      g   
kb      c d  c   br      c e      f    
kb      f g    br      
one check     a    b    c  d    g   equilibrium  
computation equilibria given mcs realized declarative implementation using hex programs  eiter et al         evaluated using dlvhex system  
idea translate mcs hex program  i  disjunctive facts guessing
truth values beliefs   ii  hex rules capturing bridge rules   iii  constraints external
atoms capturing acceptability functions  details concrete implementation
approach  refer reader mcs ie system  bogl  eiter  fink    schuller        
article  pursue sophisticated approach  i e   design implement distributed
algorithms  compute equilibria mcss  evaluation  centralized component
controls communication contexts  context independently runs instance
algorithm communicates exchange beliefs well detect break
cycles  novel contributions described next sections 

   basic algorithm  dmcs 
section introduces first  basic  truly distributed algorithm evaluating equilibria
mcs  algorithm takes general setting input  is  context minimal
knowledge whole system  words  knows interface direct neighbors  parents child contexts  topological information metadata
system  setting  concentrate distributeness  section   shifts focus towards
optimization techniques metadata provided 
taking local stance  consider context ck compute parts  potential  equilibria
system contain coherent information contexts reachable ck  
    basic notions
start basic concepts  import closure formally captures reachability 
definition    import closure  let    c            cn   mcs  import neighborhood
context ck   k             n   set
in k     ci    ci   pi   b r   r br k   
furthermore  import closure ic  k  ck smallest set  i  k  ii 
s  in i  s 
equivalently  define import closure constructively ic  k     k 

ic    k    in k   ic j    k    iic j  k  in i  



j  ic

j

 k  

example   consider example    in              in      in           in     
  import closure c  ic                     see figure    
   www kr tuwien ac at research systems dlvhex 

   

fid istributed e valuation n onmonotonic ulti   context ystems

c 

c 

ic    

in   
c 

c 

c 

c 

c 

c 
 a  import neighborhood c 

 b  import closure c 

figure    import neighborhood import closure
s 

s 

   



   



   

sj

   

sn

 



   



   

ti

   

tj

   

tn

    

s 

   



   

ti

   

sj    tj  

   

figure    joining partial belief states
based import closure define partial equilibria 
definition
   partial belief states equilibria  let    c            cn   mcs  let
sn

  i   bsi   sequence    s            sn   si bsi       n 
partial belief state  pbs    partial equilibrium  pe  w r t  ck   k             n  
ic  k  implies si acci  kb  head  r    r app br   s       ic  k  implies
si       n 
note ic  k  essentially defines subsystem   connected bridge rules  use
pes instead equilibria   keep original mcs intact 
combining partial belief states    s            sn      t            tn    define
join    partial belief state  u            un  

si   ti   si   ti  
ui  
    n
ti   ti    si    
 see figure     note    void  couples si   ti bsi different  naturally 
join two sets partial belief states       s      s    
example   consider two sets partial belief states 
        b      f  g         b      f  g    
         c  d  e    f  g          c  d  e    f  g          c  d  e    f  g     
   

fidao  t ran   e iter   f ink     k rennwallner

join given

    

    b    c  d  e    f  g        b    c  d  e    f  g   
    b    c  d  e    f  g  


 

    basic algorithm
given mcs starting context ck   aim finding pes w r t  ck distributed
way  end  design algorithm dmcs whose instances run independently node
context communicate exchanging sets partial belief states 
provides method distributed model building  dmcs algorithm applied
mcs provided appropriate solvers respective context logics available  main
feature dmcs  compute projected partial equilibria  i e   pes projected relevant
part beliefs showing ck import closure  exploited specific tasks
like  e g   local query answering consistency checking  computing projected pes 
information communicated contexts minimized  keeping communication cost low 
sequel  present basic version algorithm  abstracting low level implementation issues  overall mcs structure assumed unknown context nodes  idea
follows  starting context ck   visit import closure expanding import neighborhood
context ci depth first search  dfs   leaf context reached cycle detected  finding current context set hist already visited contexts  leaf context simply
computes local belief sets  transforms partial belief states  returns result
parent  invoking context  figure  a   case cycle  figure  c   context ci detects
cycle must break it   i  guessing belief sets export interface   ii  transforming
guesses partial belief states   iii  returning invoking context 
intermediate context ci produces partial belief states joined  i e   consistently
combined  partial belief states neighbors  enable this  ci returns local belief sets 
joined results neighbors  figure  b  
computing projected pes  algorithm offers parameter v called relevant interface
must fulfill conditions w r t  import closure next discuss 
notation  given  partial  belief state set v b beliefs  denote s v restriction
v  i e    partial  belief state      s   v           sn  v    si  v   si v si     
 v     set  partial  belief states  let s v    s v   s   next 
definition    recursive import interface  mcs    c            cn   k             n  
call v k     pi    ci   pi   b r   r brk   import interface context ck v  k   

iic  k  v i  recursive import interface context ck  
correct relevant interface v  two extremal cases      v   v  k      v   vb   b 
     dmcs basically checks consistency import closure ck computing pes
projected interface beliefs       computes pes w r t  ck   between  providing fixed
interface v  problem specific knowledge  such query variables  and or infrastructure information
exploited keep computations focused relevant projections partial belief states 
projections partial belief states cached every context recomputation
recombination belief states local belief sets kept minimum 
assume context ck background process  or daemon unix terminology 
waits incoming requests form  v  hist   upon starts computation outlined
   

fid istributed e valuation n onmonotonic ulti   context ystems

si  



ss    sj

lsolve s 

 v  hist 

  
 i


 v  hist 

sj



 

ci

c 

 v

 h






cj

c 
lsolve                
 a  leaf context

 b  intermediate context

v
ci

hi

st

 

  
 

  

i 

cj

  

  

c 
ct
 c  cycle breaking

figure    basic distributed algorithm   casewise
algorithm    process serves purpose keeping cache c k  persistent 
write ci  dmcs v  hist  specify send  v  hist  process context ci wait
return message 
algorithm   uses following primitives 
function lsolve s   algorithm     augments knowledge base kb current context
heads bridge rules br applicable w r t  partial belief state s  computes
local belief sets using function acc  combines local belief set s  returns
resulting set partial belief states 
function guess v  ck    guesses possible truth assignments relevant interface w r t 
ck   i e   bk v  
dmcs proceeds following way 

 a  check cache appropriate partial belief state 
   order relate beliefs bk   v either vector sets  variables v prefixed context ids 
simplicity  kept v set without assumptions 

   

fidao  t ran   e iter   f ink     k rennwallner

algorithm    dmcs v  hist  ck    lk   kb k   br k  
input  v  relevant interface  hist  visited contexts
data  c k   static cache
output  set accumulated partial belief states
 a 

c k  empty return c k 
  

 b 
 c 

 d 

k hist
   guess v  ck  
else
                  hist    hist  k 
foreach in k 
  ti  
      ci  dmcs v  hist 

 e 

foreach    lsolve t  

 f 

c k     s v

   cyclic  guess local beliefs w r t  v
   acyclic  collect neighbor beliefs add local ones

return s v
algorithm    lsolve s  ck    lk   kb k   br k  
input  s  partial belief state    s            sn  
output  set locally acceptable partial belief states
   acck  kb k  head  r    r app brk   s   
return   s              sk    tk   sk             sn     tk t 

 b  check cycle 
 c  cycle detected  guess partial belief states relevant interface context
running dmcs 
 d  cycle detected  import neighbor contexts needed  request partial belief
states neighbors join them 
 e  compute local belief states given partial belief states collected neighbors 
 f  cache current  projected  partial belief state 
next examples illustrate evaluation runs dmcs finding partial equilibria
different mcs  start acyclic run 
example   reconsider example    suppose user invokes c   dmcs v    
v    a  b  c  f  g   trigger evaluation process  next  c  forwards  d  requests c 
c    call c    called first time  c  calculates  e  belief sets
assembles set partial belief states
s             f  g            f  g     
   

fid istributed e valuation n onmonotonic ulti   context ystems

v

c      s 
c 
s    v

   v

c      s 

c      s 
c 

c 
   v

figure    cyclic topology
caching s   v  f   c  returns s   v   s  one contexts c    c  whose request arrived
first  second call  c  simply returns s   v context cache 
c  c  next call lsolve  in  e   two times each  results s    resp  s   
s  example   
        b      f  g         b      f  g    
         c  d  e    f  g          c  d  e    f  g          c  d  e    f  g     
thus 
s   v

        b      f  g         b      f  g    

s   v

         c    f  g          c    f  g          c    f  g     

c    computing  d 
s   v    s   v        b    c    f  g        b    c    f  g        b    c    f  g   
calls lsolve  e  thrice compute final result 
s   v      a    b    c    f  g      a    b    c    f  g      a    b    c    f  g     
next example illustrates run dmcs cyclic topology 
example   let    c    c    c    mcs li asp logic 
kb       br      a      b   
kb       br      b      c   
kb       br      c      a   
figure   shows cyclic topology   suppose user sends request c  calling c   dmcs v    v    a  b  c   step  d  algorithm    c  calls c   dmcs v       
context c  issues call c   dmcs v           thus c  invokes c   dmcs v             
point  instance dmcs c  detects cycle  b  guesses partial belief states
s        a          a       
   

fidao  t ran   e iter   f ink     k rennwallner

  v  then  following dotted lines figure    set s    v   s   return value
request c    joins initial empty belief state         gives us
calls lsolve t    e   resulting
s       a      c  d      a      c  d      a      c  d     
next step c  return s   v back c    proceed c  before  result
set belief states
s       a    b    c      a    b    c      a    b    c     
sent back c  s   v   notice belief state   a    b    c   inconsistent
c    eventually eliminated c  evaluates s   v lsolve 
next  c  join s   v         yields s   v   use result call lsolve 
union gives us
s       a    b    c      a    b    c     
sent back user final result 
given mcs    c            cn   context ck   using recursive import interface ck  
i e   v  k   relevant interface safe  lower  bound correctness algorithm   
follows  let   ck   v  k  above 
theorem    correctness dmcs partial equilibrium  every v v  k   holds
  ck  dmcs v    iff partial equilibrium w r t  ck     s v  
compute partial equilibria ck use vb   holds using vb preserves
belief sets returned step  e   projection step  f  takes effect 
corollary   partial equilibrium w r t  ck iff ck  dmcs vb     
assumption single root context c    i e   ic    
  n  dmcs computes equilibria 
corollary   mcs single root context c    equilibrium iff
c   dmcs vb     
analysis algorithm yields following upper bound computational complexity
communication activity 
proposition   let    c            cn   mcs  run dmcs context ck
interface v  holds
    total number calls lsolve exponentially bound n  v   i e   o  n v    
    number messages exchanged contexts ci   ic  k   bounded
   e k    e k      i  cj     ic  k   r bri    cj   pj   b r   
   

fid istributed e valuation n onmonotonic ulti   context ystems

    discussion
algorithm dmcs naturally proceeds forward import direction context ck   thus  starting
there  computes partial equilibria cover ck contexts import closure 
contexts ignored  fact  unknown contexts closure  partial
equilibria may exist ck import closure  whole mcs could equilibrium 
because  e g    p   contexts access beliefs ck closure get inconsistent   p  
isolated context subsystem inconsistent 
enhancements dmcs may deal situations   p    context neighborhood
may include importing supporting contexts  intuitively  ci imports cj   ci
must register cj   carefully adapting dmcs  solve  p    however   p   remains 
needs knowledge global system topology 
suitable assumption manager exists every context ci system
reach ask whether isolated inconsistent context subsystem exists  confirms this 
ci dmcs instance simply returns   eliminating partial equilibria 
improve decentralization information hiding  weaken manager assumption
introducing routers  instead asking m  context ci queries assigned router r  collects
topology information needed ci looks cache  information exchange ci
r flexible  depending system setting  could contain contexts import information
ci   isolated inconsistent contexts 
advantage topological information ci recognize cyclic acyclic
branches upfront  invocation order neighborhood optimized  starting
acyclic branches entering cyclic subsystems  caching mechanism adapted
acyclic branches  intermediate results complete cache meaningful even across
different evaluation sessions 
setting  safe assuming v  k  v  needed resp  ck
import closure join contexts  i e   contexts least two parents  access
path information context  could calculate v fly adjust
mcs traversal  particular  tree  ring shaped   restrict v locally shared
interface ck import neighbors  i e   restricting v bridge atoms br k  
presence join contexts  v must made big enough  e g  using path information  furthermore 
join contexts may eliminated virtually splitting them  orthogonal parts contexts
accessed  way  scalability many contexts achieved 
next  present optimization techniques using topological information system 

   topology based optimization algorithm  dmcsopt 
basic version  algorithm dmcs uses metadata apart minimal information
context must know  interface every neighboring context  scalability
issues tracked following problems 
    contexts unaware context dependencies system beyond neighbors  thus
treat neighbors equally  specifically  cyclic dependencies remain undetected context 
seeing invocation chain  requests models context chain  furthermore  context
ci know whether neighbor cj already requested models another neighbor cj  
would passed ci   hence  ci makes possibly superfluous request cj    
   

fidao  t ran   e iter   f ink     k rennwallner

    context ci returns local models combined results neighbors  case
multiple models  result size become huge system size number neighbors
increases  fact  one main performance obstacles 
section address optimizations increase scalability distributed mcs evaluation  resorting methods graph theory  aim decomposing  pruning  improved
cycle breaking dependencies mcss  focusing      describe decomposition method
using biconnected components inter context dependencies  based break cycles
prune acyclic parts ahead create acyclic query plan  address      foster partial view
system  often sufficient satisfactory answer  compromise partial
information performance  thus define set variables import dependency
system project models context bare minimum remain meaningful 
manner  omit needless information circumvent excessive model combinations 
proceed follows  introducing running example superficial explanation
optimization it  present details techniques section      section     introduces
notion query plans  used section     describe algorithm dmcsopt
intertwines decomposition pruning variable projection performance gains mcs evaluation 
    running scenario
first present scenario example   running example section 
example    scientists group  group four scientists  alice  bob  charlie  demi meets
conference closing arrange travel back home  options going train car
 which slower   use train  bring along food  alice group
leader finally decides  based information gets bob charlie  
alice prefers go car  would object bob charlie want go train 
charlie daughter  fiona  mind either option  fiona sick wants
fastest transport get home  demi got married  husband  eddie  wants back
soon  even sooner would come soon  demi tries yield husbands plea 
charlie charge buying provisions go train  might choose either salad
peanuts  notably  alice allergic nuts  options beverages coke juice  bob
modest  agrees choice charlie demi transport dislikes coke  charlie
demi want bother others personal matters communicate
preferences  sufficient reaching agreement 

example    scenario example   encoded mcs    c            c    
alice      bob      etc lexicographical order li asp logics  knowledge bases kbi
bridge rules bri follows 




car   train    
train        train           train     
c    kb    
br    
 
nuts    
nuts        peanuts     
   similar scenarios already investigated realm multi agent systems  on social answer set programming see  e g   buccafurri   caminiti         aim introducing new semantics scenarios 
example serves plain mcs showcase algorithms 

   

fid istributed e valuation n onmonotonic ulti   context ystems

b 

 
 

 
 

 
 

 
 
 

 

b 

 

 

 

b 
 
 

 
 b  diamond ring block tree

 a  diamond ring

figure    topologies decomposition scientist group example

c    kb  

c    kb  

c    kb  
c    kb  
c    kb  



car        car           car     
    car     train      br     train        train           train       


     coke     


car   train    








train   urgent    
urgent        sick     
 
 
br    
salad   peanuts   train    
train        train    





coke   juice   train  




  car   train   br     train        sooner      




  sooner   soon   br     soon        train      


  sick   fit   br      

context dependencies shown fig   a  three equilibria  namely 
  train       train       train     urgent     juice     salad       train     
 soon     sooner       sick      
  train       train       train     juice     salad       train       soon     sooner       fit      
  car       car       car       car         fit      
example    consider mcs    c            c    context dependencies drawn figure  a  user queries c  cares local belief sets c   
evaluation process  c  discard local belief sets c  c  answering call
c  c    however  c  calls c   or c     invoked context must carry local belief sets
c  answers c    reason belief sets c  cause inconsistent joins c 
partial belief states returned c  c    c  c  contribute directly
computing local belief sets c    note belief sets c  c  play role determining
applicability bridge rules c   
   

fidao  t ran   e iter   f ink     k rennwallner

query

query
c 
c 

c 
c 

c 

c 

c 

 s

c 
 a  original topology

c 

c 

     s   
 b  triangle

c 

 

c 

c 

 

 

 s

  

 

c 

s 

 

c 

 

c 

c 

 c  transitive reduction

figure    topology example     two stacked zig zag diamonds 
now  take sub system including c    c    c    assuming c  bridge rules atoms
     p         p    body  c  atoms      p     is  c  depends c 
c    c  depends c   see fig   b   straightforward approach evaluate mcs asks
c  belief sets c  c    c  depends c    would need another query
c  c  evaluate c  w r t  belief sets c    shows evident redundancy  c 
need compute belief sets twice  simple caching strategies could mellow second belief
state building c    nonetheless  c  asks c    context transmit belief states back 
thus consuming network resources 
moreover  c  asks pes c    receive set pes covers belief sets
c  addition contexts c  import closure  excessive c  view 
needs know      p         p     however  c  needs belief states c 
c  reply c    c  reports belief sets  which consistent w r t  c     c  cant
align belief sets received c  received c    realizing c  reports
belief sets c    call c  must made 
    decomposition nonmonotonic mcs
based observations above  present optimization strategy pursues two orthogonal
goals   i  prune dependencies mcs cut superfluous transmissions  belief state building 
joining belief states   ii  minimize content transmissions  start defining
topology mcs 
definition    topology  topology mcs    c            cn   directed graph gm  
 v  e   v    c            cn   resp  v               n   i  j  e iff rule br
atom  j p  body 
first optimization technique made three graph operations  get coarse view
topology splitting biconnected components  form tree representation mcs 
then  edge removal techniques yield acyclic structures 
   

fid istributed e valuation n onmonotonic ulti   context ystems

sequel  use standard terminology graph theory  see bondy   murty        
graphs directed default  may view undirected graphs directed graphs
edges  u  v    v  u  undirected edge  u  v  
graph g edges e g   denote g s maximal subgraph g
edges s  suppose v   v  g  nonempty  subgraph g     v     e     g
vertex set v   edge set e     u  v  e g    u  v v  g   subgraph induced
v     denoted g v      induced subgraph g v   v     denoted g v     results g
deleting vertices v   together incident edges  v      v   write g v g  v  
two vertices u v g said connected   directed  path u v
g  i e   sequence vertices u   v    v            vn   v   vi   vi     e g    
           n   path trivial n      undirected graph g  connectedness equivalence
relation v  g   thus partition v  g  nonempty subsets v    v            vw
two vertices u v g connected iff belong set vi  
subgraphs g v     g v             g vw   called components g  w      i e   g exactly
one component   g connected  otherwise  g disconnected 
directed graph g strongly connected  vertices u  v v  g  path u v
vice versa exists  strongly connected components g subgraphs g v             g vm  
unique partition graph g pairwise disjoint induced subgraphs  i e   vi vj    
strongly connected 
furthermore  directed graph g weakly connected  turning edges undirected edges
yields connected graph  vertex c weakly connected graph g cut vertex  g c
disconnected  biconnected graph weakly connected graph without cut vertices 
block graph g maximal
biconnected
subgraph g  given set blocks b 


union blocks b defined b   bb b  union two graphs g     v    e   
g     v    e    defined g  g     v  v    e  e    
let  g     b c  e  denote undirected bipartite graph  called block tree graph g 

 i  b set blocks g 
 ii  c set cut vertices g 
 iii   b  c  e b b c c iff c v  b  
note  g  forest graph g rooted tree g weakly connected 
example    consider graph figure  a  one check   cut vertex
two blocks  viz  subgraphs induced                           
next example shows block tree scenario example   
example    topology gm example    shown figure  a  two cut vertices 
namely      thus block tree  gm    figure  b  contains blocks b    b    b   
subgraphs gm induced                               respectively 
topological sort directed graph linear ordering vertices every
directed edge  u  v  vertex u vertex v  u comes v ordering 
   

fidao  t ran   e iter   f ink     k rennwallner

pruning  acyclic topologies  triangle presented figure  b  exploit minimal
graph representation avoid unnecessary calls contexts  namely  transitive reduction
graph gm   recall aho  garey  ullman        graph g transitive
reduction directed graph g whenever following two conditions satisfied 
 i  directed path vertex u vertex v g iff directed path u v
g 
 ii  graph fewer edges g satisfying condition  i  
note g unique g acyclic  instance  graph figure  c unique transitive
reduction one figure  a 
ear decomposition another essential part optimization strategy break cycles removing edges  end  use ear decompositions cyclic graphs  block may multiple
cycles necessarily strongly connected  thus first decompose blocks strongly
connected components  using tarjans algorithm  tarjan        task  one gets byproduct topological sort directed acyclic graph formed strongly connected components 
yield sequence nodes r            rs used entry points component  next
step break cycles 
ear decomposition strongly connected graph g rooted node r sequence p  
hp            pm subgraphs g
 i  g   p  pm  
 ii  p  simple cycle  i e   repeated edges vertices  r v  p    
 iii  pi  i      non trivial path  without cycles  whose endpoint ti p  pi   
nodes not 
let cb g  p   set edges containing       r  p  last edge   i   ti   pi       
here     vertex belonging edge root node r simple cycle p   
example    take  example  strongly connected graph g figure  a  ear decomposition g rooted node   p   hp    p    p    p 
vp               ep                             

vp               ep                     

vp               ep                     

vp            ep             

last edges pi dashed  form set cb g  p                                      
removing edges results acyclic topology figure  b 
intuitively  ear decomposition used remove cycles original system  
resulting acyclic topology  algorithms evaluating mcss designed conveniently 
trade edge     t  removed   context c    despite leaf
context  guess values variables ct   following example shows application
optimization techniques running scenario 
example     contd  block b   gm   acyclic  transitive reduction gives b 
edges                           b  cyclic  hb  ear decomposition rooted   
removing cb b    hb  i              obtain b   edges           b  acyclic already
reduced  fig   b shows final result  dotted edges removed  
   

fid istributed e valuation n onmonotonic ulti   context ystems

 

 

 

 

 

 

 

 

 

 

 a  strongly connected component

 b  acyclic topology

figure    ear decomposition example
graph theoretic concepts introduced here  particular transitive reduction acyclic blocks
ear decomposition cyclic blocks  used implement first optimization mcs
evaluation outlined above  intuitively  block  apply ear decomposition get rid cycles  with trade off guessing   use transitive reduction minimize communication 
given transitive reduction b acyclic block b b  total order v  b     one
evaluate respective contexts reverse order total order computing pes
context ck   first context simply computes local belief sets whichrepresented
set partial belief states s  constitutes initial set partial belief states t    iteration
step    ti computed joining ti  local belief sets si considered context ci  
given final tk   tk  v  k  set pes ck  restricted contexts v  b    
refined recursive import  next  define second part optimization strategy
handles minimization information needed transmission two neighboring contexts
ci cj   purpose  refine notion recursive import interface  definition   
context w r t  particular neighbor given  sub  graph 
definition   given mcs    c            cn   subgraph g gm  
edge  i  j 


e g   recursive import interface ci cj w r t  g v  i  j g   v  i   g j b 
g j contains nodes g reachable j  
example     contd  mcs example     v        train     train     peanuts    
car     coke     car     train     sooner     sick      focus block b    refined recursive
import interface v       b obtained removing bridge atoms contexts
 
blocks b  b    yielding  train     train     peanuts     car     coke     car     train     
algorithms  algorithms     combine optimization techniques outlined above  intuitively 
optimizetree takes input block tree parent cut vertex cp root cut vertex cr   traverses dfs manner calls optimizeblock every block  call results collected
   note v  k  defined definition   

   

fidao  t ran   e iter   f ink     k rennwallner

algorithm    optimizetree t    b c  e   cp   cr  
input    block tree  cp   identifiesslevel   cr   identifies
level cp

output  f   removed edges b  v  labels   b  f
b        f      v   
cp   cr
b       b b   cr v  b  
else
b       b b    b  cp   e 

 a 

 b 

   initialize siblings b  return values

foreach sibling block b b  
   sibling blocks b parent cp
e    optimizeblock b  cp  
   prune block
 
c     c c    b  c  e c    cp  
   children cut vertices b
b      b e  f    f e
foreach edge  i  j  b   dos
   setup interface pruned b

v i  j     v  i  j b   cc   v  cp   bc    t e v  cp   bt
foreach child cut vertex c c  
   accumulate children
 f     v        optimizetree t  b  c  cp  
f    f f     v    v v  
return  f  v 

set f removed edges  blocks processed  final result optimizetree
pair  f  v  v labeling remaining edges  optimizeblock takes graph g calls
cyclebreaker cyclic g  decomposes g strongly connected components  creates
ear decomposition p component gc   breaks cycles removing edges cb gc   p   
resulting acyclic subgraph g  optimizeblock computes transitive reduction g
returns edges removed g  optimizetree continues computing labeling v remaining edges  building recursive import interface  keeping relevant
interface beliefs child cut vertices removed edges  example     appendix b  illustrates
algorithms     detailed run mcs example    
formally  following property holds 
proposition   given mcs context ck k cut vertex topology gm  
optimizetree t  gm    k  k  returns pair  f  v 
 i  subgraph g gm  f induced ic  k  acyclic 
 ii  block b g  i  j  e b   holds v i  j  v  i  j b  
regarding computational cost computation  obtain 
proposition   given mcs context ck k cut vertex topology gm  
optimizetree t  gm    k  k  runs polynomial  quadratic  time size  gm   resp  gm  

   

fid istributed e valuation n onmonotonic ulti   context ystems

algorithm    optimizeblock g   graph  r   context id 

 c 
 d 

f   
g cyclic
f    cyclebreaker g  r 

   ear decomposition strongly connected components

let g transitive reduction g f
return e g    e g  

   removed edges g

    query plan
given topology mcs  need represent stripped version contains
minimal dependencies contexts interface beliefs need transferred contexts  representation query plan used execution processing 
syntactically  query plans following form 
definition     query plan  query plan mcs w r t  context ck labeled subgraph
gm induced ic  k  e   e gm    edge labels v   e g     
mcs context ck   every query plan suitable evaluating m  however 
following query plan fact effective 
definition     effective query plan  given mcs context ck   effective query plan
respect ck k    v  g   e g  f  v  g subgraph gm induced
ic  k   f  v    optimizetree t  gm    k  k  
next use k mcs evaluation  tacitly assume query plans effective 
    evaluation query plans
present algorithm dmcsopt  based dmcs exploits optimization
techniques above  idea dmcsopt follows  start context ck traverse
given query plan k expanding outgoing edges k context  dfs 
leaf context ci reached  context simply computes local belief sets  transforms belief
sets partial belief states  returns result parent  ci  j   p  bridge rules
bodies context cj query plan  this means broke cycle removing last
edge cj    possible truth assignments import interface cj considered 
result context ci set partial belief states  amounts join  i e  
consistent combination  local belief sets results neighbors  final result
obtained ck   keep recomputation recombination belief states local belief sets
minimum  partial belief states cached every context 
algorithm   shows distributed algorithm  dmcsopt  instance context ck  
input id c predecessor context  which process awaits   proceeds based
 acyclic  query plan r w r t  context cr   i e   starting context system  algorithm
maintains cache k  cache ck  which kept persistent  
ci  dmcsopt c   send id c dmcsopt context ci wait result 
guess v   guess possible truth assignments interface beliefs v 
   

fidao  t ran   e iter   f ink     k rennwallner

algorithm    dmcsopt c   context id predecessor  ck    lk   kb k   br k  
data  r   query plan w r t  starting context cr label v  cache k   cache
output  set accumulated partial belief states
 a 

 b 
 c 

 d 

 e 

cache k  empty
   cache k 
else
                 
foreach  k  i  e r         ci  dmcsopt k 

   neighbor belief sets

in k  s t   k  i 
  e r   ti  
   guess v c  k     
   guess removed dependencies r
  
foreach    lsolve t  
   get local beliefs w r t 
cache k    
 c  k  e r    i e   ck non root 
return s v c k 
else
return

lsolve s   algorithm     given partial belief state s  augment kbk heads
bridge rules brk applicable w r t      kb k    compute local belief sets acc kb k   
merge s  return resulting set partial belief states 
steps algorithm   explained follows 
 a   b  check cache  empty get neighbor contexts query plan  request
partial belief states neighbors join them 
 c   i   p  bridge rules brk  k  i 
  e r    neighbor delivered
belief sets ci step  b   i e   ti      call guess interface v c  k 
join result  intuitively  happens edges removed
cycles  
 d  compute local belief states given partial belief states collected neighbors 
 e  return locally computed belief states project variables v c  k  nonroot contexts  point mask parts belief states needed
contexts lying different block  gm   
theorem   shows dmcsopt sound complete 
theorem   let ck context mcs   let k query plan definition    let
b    p v k  j     k  j  e k     then 
v
 i    ck  dmcsopt k   exists partial equilibrium w r t  ck
    s vb  
 ii  partial equilibrium w r t  ck   exists   ck  dmcsopt k 
    s vb  
   

fid istributed e valuation n onmonotonic ulti   context ystems

   streaming equilibria  dmcs streaming 
algorithm dmcsopt shows substantial improvements dmcs  however  sizes
local knowledge bases context interfaces increase  suffers bottlenecks 
stems way models exchanged contexts  suppose context c 
accesses several neighbors c            cm acyclic information flow  ci   n 
ni pes  ci computes dmcs resp  dmcsopt local models  must join pes
neighbors  may lead n  n  nm many pes  input
local solver  may take considerable time exhaust memory  even
local model computation starts 
note however instead neighbor would transfer portion pes 
computation c  avoid memory blowup  moreover  strategy helps reduce
inactive running time c  waiting neighbors return pes  c  already start
local computing neighbors producing models 
general  indispensable trade computation time  due recomputations  less
memory eventually partial equilibria c  shall computed  idea underlying
streaming evaluation method distributed mcs  particularly useful user interested
obtaining instead answers system  realistic scenarios
current evaluation algorithm manage output resource constraints
practice equilibrium all 
section  turn idea concrete streaming algorithm dmcs streaming
computing partial equilibria  main features briefly summarized follows 
algorithm fully distributed  i e   instances components run every context
communicate  thus cooperating level peers 
invoked context ci   algorithm streams  i e  computes  k   partial equilibria
ci time  particular  setting k     allows consistency checking mcs
 sub  system 
issuing follow up invocations one may compute next k partial equilibria context c 
equilibria exist  i e   evaluation scheme complete 
local buffers used storing exchanging local models  partial belief states 
contexts  avoiding space explosion problem 
section mainly studies streaming aspect algorithm  simplify presentation omit interface contexts  principles presented applied
dmcs dmcsopt adapting interface pruning topology preprocessing
time  furthermore  assume work acyclic mcss  treatment cyclic cases easily
achieved adding guessing code solving component dmcs dmcsopt 
best knowledge  similar streaming algorithm neither developed
particular case computing equilibria mcs  generally computing models
distributed knowledge bases  thus  results obtained interest setting
heterogeneous mcs  relevant general model computation reasoning
distributed  potentially homogeneous  knowledge bases e g  distributed sat instances 
   

fidao  t ran   e iter   f ink     k rennwallner

request  k    k   

k belief states

handler

ci

cj 

solver

joiner

  
 

output

cjm

figure    dmcs streaming architecture
algorithm    handler k    k    package range  ci
output k     k    output k     k   
solver k     k    joiner k    k  k     
call solver

    basic streaming procedure
basic idea follows  pair neighboring contexts communicate multiple rounds 
request effect receive k pes  communication window k pes
ranges k   th pe k   th    k    k    pe  parent context ci requests child
context cj pair  k    k    receive time later package k pes  receiving
indicates cj fewer k  models  parallelized version discussed section     
important subroutines new algorithm dmcs streaming take care receiving
requests parents  receiving joining answers neighbors  local solving returning
results parents  reflected four components  handler  solver  output  joiner
 only active non leaf contexts   see figure   architectural overview 
components except handler  shown algorithm    communicate using message queues 
joiner j queues store partial equilibria j neighbors  solver one queue hold joined
pes joiner  output queue carry results solver  bound space usage 
queue limit number entries  queue full  resp   empty   enqueuing writer
 resp   dequeuing reader  automatically blocked  furthermore  getting element removes
queue  makes room pes queue later  property frees us
synchronization technicalities 
algorithms     show solver joiner work  use following primitives 
lsolve s   works lsolve dmcs dmcsopt  addition may return one
answer time may able tell whether models left  moreover  require
results lsolve returned fixed order  regardless called  property
key guarantee correctness algorithm 
get first           k   send neighbor c   c   request first k partial equilibria  i e   k      k    k  return models  store respective queues
return true  otherwise  return false  some neighbor inconsistent  
   

fid istributed e valuation n onmonotonic ulti   context ystems

algorithm    solver   ci
data  input queue  q  maximal number models  k 

 a 
 b 

count     
count   k 
ci leaf   
else call joiner pop q
  count    k 

 c 

count   k 
pick next model   lsolve s 
    
push   output q
count    count    
else break
refresh   push output q

get next    k   request next k equilibria neighbor cc    cc  sends back models  store queue q  return true  otherwise  return false neighbor already
exhaustively returned pes previous request  note subroutine needs keep
track range already asked neighbor  maintaining set counters 
counter w r t  neighbor cc  initialized   increased time get next    k  called 
value t  request cc  asks tth package k models  i e   models range
given k     t    k     k    k  get first           k  called  counters
range            reset   
refresh    reset counters flags joiner starting states  e g   first join true 
counters   
process context ci triggered message parent  contains
range  k    k    arrives handler  latter notifies solver compute k  models output
collect range  k    k    return parent  furthermore  sets package
size joiner k   k  k      case ci needs query neighbors  cf  algorithm    
solver receives notification handler  first prepares input local solver 
ci leaf context  input gets empty set assigned step  a   otherwise  solver triggers
joiner  step  b   input neighbors  fed input them  lsolve used step  c 
compute k  results send output queue 
joiner  activated intermediate contexts discussed  gathers partial equilibria neighbors fixed ordering stores joined  consistent input local buffer 
communicates one input time solver upon request  fixed joining order guaranteed always asking first package k models neighbors beginning step  d  
subsequent rounds  begin finding first neighbor cc  return models
 step  e    reset query ask first packs k models neighbors cc  cc    
neighbors run models step  f   joining process ends sends solver 
note procedure guarantees models missed  lead consider combinations  inputs solver  multiple times  using cache helps mitigate
   

fidao  t ran   e iter   f ink     k rennwallner

algorithm    joiner   ci
data  queue q            queue qj in i     c            cj    buffer partial equilibria  buf  
flag first join
true
buf empty
pop buf   push solver q
return

 d 

 e 

 f 

first join
get first    j  k    false
push solver q
return
else first join    false
else
      
get next    k    false   j           
      j
get first         k 
else     j
push solver q
return
s  q            sj qj add s        sj buf
c 

c 

c 

c 

c 

c 

c 

figure     binary tree mcs

recomputation  unlimited buffering quickly exceeds memory limits  recomputation
inevitable part trading computation time less memory 
output component simply reads queue receives reaches k  models
 cf  algorithm     upon reading  throws away first k    models keeps ones
k  onwards  eventually  fewer k  models returned solver  output
return parent 
example    let    c            cn   mcs given integer      n  
 m     contexts  let       integer  let contexts asp logics     m  
   

fid istributed e valuation n onmonotonic ulti   context ystems

algorithm    output   ci
data  input queue  q  starting model  k    end model  k 
buf    count     
count   k 
pick output q
  count    k     
else count    count    
count   k     
wait output q
  count    k     
else
count    count    
add buf
buf empty
send parent
else
send content buf parent

context ci    li   kbi   bri  
 
kbi  

 aji



aji

ti     j    bri  

 


ti   i   aj i   
fi j   
ti   i       aj i    

   

 m   let ci
kbi    aji aji     j    bri    

   

intuitively  binary tree shaped mcs depth     size alphabet
context  figure    shows mcs n     contexts depth      internal contexts
knowledge bases bridge rules      leaf contexts      directed
edges show dependencies bridge rules  system equilibria    s            sn  
si    aki   ti      k   
compute one pe using dmcs dmcsopt  one needs transfer packages   
pes context parent  as context ci computes subsets  a i           a i    
intermediate context receives    results children  whose join leads     inputs
lsolve  invokes lsolve often returns    models parent 
wait this 
hand  dmcs streaming needs transfer single pe pair
connected contexts  significant saving  indeed  consider e g              i e  
   c    c    c     querying c  package size k     first causes query forwarded
c  pair k    k       c  leaf context  invokes local solver eventually gets five
different models  however  returns one pe c    say     a         note t  projected
among atoms c  accessed c    happens c    assume
   

fidao  t ran   e iter   f ink     k rennwallner

return       a      c    root context c    two pes neighbors consistently
combined     a       a       feeding local solver  c  obtains five models  returns
one them  say     a     t      a       a      
following proposition shows correctness algorithm 
proposition   let    c            cn   mcs              n  let k   integer 
input     k  ci  handler  ci  output returns k different partial equilibria respect ci  
fact k least k partial equilibria exist 
    parallelized streaming
one might expect  strategy ignoring k  models collecting next k
likely effective  reason context uses one solver 
general serve one parent  i e   requests different ranges models size k 
new parent context requests models  refresh state solver joiner
redo scratch  unavoidable  unless context satisfies specific property one
parent call it 
way address problem parallelization  idea serve parent suite
handler  joiner  solver output  basic interaction units still shown
figure    notable difference component runs individual thread 
significant change solver control joiner waits queue get new input
local solving process  joiner independently queries neighbors  combines pes
neighbors  puts results solver queue 
effect waste recomputation time unused models  however  parallelization limits practice  dmcsopt may run memory  unlimited parallel
instances streaming algorithm exceed number threads processes operating
system support  happens contexts reach others many alternative paths 
stacked diamond topology  number threads exponential number connected contexts  prohibits scaling large system sizes  however  real world applications number
paths might still ok 
compromise two extremes bounded parallel algorithm  idea create
fixed size pool multiple threads components share among contexts  incoming requests cannot served resources available  algorithm continues basic
streaming procedure  realization remains future work 

   experimental evaluation
implemented algorithms using c    system prototype called dmcs 
available online   space reasons  omit detailed presentation refer work
bairakdar  dao tran  eiter  fink  krennwallner      b   dao tran        ch      briefly 
main components global architecture  i  command line frontend dmcs user
access system   ii  demons daemon represent nodes contain  a set of  contexts 
 iii  manager dmcsm containing meta information mcs  topology  interfaces 
   http   www kr tuwien ac at research systems dmcs 
https   github com distributedmcs dmcs 

   

fid istributed e valuation n onmonotonic ulti   context ystems

c 

c 

c 

c 

c 

c 
c 

c 

c 

c 

c 

c 

c 

c 

c 

c 
c 

c 
c 

c 

c 

c 

c 

 a  binary tree  t 

c 

c 

 b  diamond  d 

 c  zig zag  z 

c 

 d  ring  r 

figure     topologies testing dmcs algorithms
helper dmcsgen generating configurations optimized components  contexts implemented groups threads communicate concurrent message queues 
system two main command line tools  viz  running algorihms test case generation  respectively  allows switch different algorithms modes simply changing
command line arguments 
turn experimental evaluation dmcs various aspects  next describe
benchmarks set up  go runs results interpretation 
    benchmark setup
idea analyze strong weak points algorithm respect different parameters 
namely system topology  system size  local theory  i e   knowledge base  size  interface size 
specifically  considered mcss topologies figure     including 
binary tree  t   binary trees grow balanced  i e   every level except last one complete 
topology  edge needs removed form optimal topology  every
intermediate node cut vertex  import interface query plan drastically reduced 
leading extreme performance improvement 
 stack of  diamond s   d   diamond consists four nodes connecting c  c  figure   b  stack diamonds combines multiple diamonds row  i e   stacking diamonds
tower  m     contexts  similar binary tree  edge removed constructing
query plan  w r t  topology  every context connecting two diamonds cut vertex 
such  import interface query plan refined every diamond  avoids
significantly repetition partial pes evaluation 
 stack of  zig zag diamond s   z   zig zag diamond diamond connection
two middle contexts  depicted contexts c  c  figure   c  stack zigzag diamonds built above  topology interesting removing two edges per
block  query plan turns linear topology 
ring  r   ring  figure   d   query plan removes connection context cn c 
carries interface way back c    topology requires guess   

fidao  t ran   e iter   f ink     k rennwallner

a 

a 

a 

a 

a 

a 

a 

a 

figure     local theory structure
ing checking dmcs algorithm  thus quite unpredictable algorithm
performs better general 
quantitative parameters represented tuple p    n  s  b  r  
n system size  number contexts  
local theory size  number ground atoms local theory  
b number local atoms used bridge atoms contexts 
words  number interface atoms 
r maximal number bridge rules  generator generates bridge rule iterating
  r     chance  hence average r   bridge rules generated  allow
bridge bodies size     
test configuration formulated x  n  s  b  r  x  t  d  z  r  represents topology n  s  b  r integers representing quantitative  i e   size related  parameters 
would run several instances one configuration  final formulation test instance
xi   n  s  b  r   index test instance 
inside context  local theories structured follows  context ci ground atoms
indicated ai             ai s   rules form ai j ai k k   j      j odd 
otherwise  randomly choose k j   j     probability     possibility 
case k   rule exist  example context local theory size  
illustrated dependency graph figure     here  bold arrows stand fixed
rules dashed arrows stands rules decided randomization  corresponding local
theory figure is 


a  a 
a  a 

a  a 
a  a 

a  a 
a  a 

a  a 
a  a 


 

setting  local context  m answer sets      s    
furthermore  one obtain deterministic contexts  having one answer set  disallowing
cycles structure local theories 
    experiments
conducted experiments host system using   core intel r  xeon r  cpu    ghz processor   gb ram  running ubuntu linux          furthermore  used dlv  build ben sep
        gcc        back end asp solver 
ran comprehensive set benchmarks setup described section     
parameter space p    n  s  b  r  huge  singled initial probing phase following
values experiments 
   

fid istributed e valuation n onmonotonic ulti   context ystems

    

dmcs
dmcsopt

   

  

 

   

    
  

t        
 

 

d        
  

z        
  

r        
  

t         
  

d         
  

  

z         
  

r         
  

  

figure     dmcs vs  dmcsopt non streaming mode
system size n  depending topology 
t 
d 

n                         
n                       

z 
r 

n                           
n                   

s  b  r fixed either                      respectively 
combination topology x parameters p    n  s  b  r  denoted x n  s  b  r  x n s b r
 used figures   parameter setting tested five instances  instance 
measured total running time total number returned partial equilibria dmcs 
dmcsopt non streaming streaming mode  latter mode  dmcs streaming 
asked k answers  k               parameter influences size packages
transferred contexts  at k partial equilibria transferred one message  
streaming mode  asking one pe may require multiple rounds get answers 
interest see fast first answers arrive compared answers  thus compared
running time tasks k      k       
    observations interpretations
figures       summarize results experiments  run times seconds timeout
    seconds  data  several interesting properties observed  organize
analysis along following aspects      comparing dmcs dmcsopt      comparing
streaming non streaming mode      effect package size      role topologies 
    behavior algorithms deterministic contexts 
      dmcs vs   dmcsopt
figure    shows running time dmcs dmcsopt computing partial equilibria  i e  
non streaming mode  five instances respective parameter settings  clearly dmcsopt
outperforms dmcs  explained fact computing answers  dmcs
always produces partial equilibria dmcsopt  one pe returned dmcsopt
   

fidao  t ran   e iter   f ink     k rennwallner

   

   
dmcs  st
dmcsopt  st
dmcs   
dmcsopt   

dmcs  st
dmcsopt  st
dmcs    
dmcsopt    

  

  

 

 

   

t 

t 

t 

t 

t 

d 

 a                

d 

d 

d 

d 

 b  d              

    

   
dmcs  st
dmcsopt  st
dmcs   
dmcsopt   

dmcs  st
dmcsopt  st
dmcs   
dmcsopt   

   

  

  

 

 

   

   

z 

z 

z 

z 

z 

r 

 c  z              

r 

r 

r 

r 

 d  r             

figure     dmcs vs  dmcsopt streaming mode
obtained projecting many partial equilibria returned dmcs imported interface 
furthermore  intermediate results transferred one message  makes difference
terms number communications algorithms  such  dmcs must spend
time processing possibly exponentially input  hence  unsurprisingly  consistently
slower dmcsopt 
however  observation streaming mode different  figure    shows running time
dmcs dmcsopt streaming mode compute first     respectively    unique partial
equilibria                respectively d                z               r              
first view  dmcsopt consistently slower dmcs  one might question correctness
results  however  surprise  pe returned dmcsopt correspond several pes returned dmcs  hence  batch first k unique answers dmcs
corresponds smaller number  few  unique answers dmcsopt 
therefore  comparing dmcs dmcsopt streaming mode measuring runtime
compute first k answers fair  thus took time algorithms finished first
round answers  denoted dmcs  st dmcsopt  st figure      setting 
observed following 
majority cases dmcsopt finishes first round faster dmcs  however
    instances  way around  shows effect using query plan 
   

fid istributed e valuation n onmonotonic ulti   context ystems

however  cases dmcs wins  explained follows  first all  streaming
mode  transfer packages k partial equilibria time  therefore  effect reducing
amount total work done always apply non streaming mode  furthermore 
every context  compute k pes project output interface returning
results  according strategy  context ci returns k  partial equilibria non streaming
mode k  partial equilibria streaming another context cj   might happen k  much
smaller k  hence provide enough input cj compute k pes  therefore  cj
issue requests ci asking packages k pes  e g    k       k     k       k  
etc  costs dmcsopt time even compute first batch pes root context 
another approach compute always k unique partial equilibria returning parent
context  however  strategy risks compute even local models k unique partial
equilibria found 
overall  much difference running time dmcsopt slower dmcs  except
instance r   figure   d   however comes different reason  cyclic topology
guess and check effects  play much important role choosing dmcs
dmcsopt  see section        
      treaming vs   n   streaming dmcs
compare streaming non streaming algorithm  dmcs resp  dmcsopt  
figure    shows results dmcs    a   results dmcsopt compute
first    resp      pes small systems local knowledge bases    b  large systems local theories    c   excluding ring  which behaves abnormally due guess and check 
one see that 
dmcs  streaming mode definitely worth pursuing since dmcs non streaming
mode times many cases  see figure      streaming mode still could find
answers reasonable time 
dmcsopt  situation bit different  streaming loses non streaming
small instances  due recomputation streaming mode pays transferring
chunks partial equilibria contexts  furthermore  duplications answers 
one moves larger systems local knowledge bases  streaming mode starts gaining
back  however  always win  recomputation still significantly takes time cases 
summing up  system small enough  one try non streaming mode
avoids recomputation duplication pes different rounds computation  large
systems  streaming rescue us timing out  even pay recomputation  still
helps cases results needed  e g  brave query answering  membership
query pe  
      e ffects package ize treaming ode
considerations raise question optimal number pes transferred
return messages contexts  analyze experimental results streaming
mode package sizes            give hints this 
figure    shows average time compute   pe dmcsopt streaming mode
respect three package sizes  one see transferring single pe get first answer
   

fidao  t ran   e iter   f ink     k rennwallner

    

non streaming
streaming   
streaming    

   

  

 

   

    
  

t         

 

 

d         
  

  

z         

  

r        
  

  

 a  dmcs
    

non streaming
streaming   
streaming    

   

  

 

   

    
  

t         

 

 

d         
  

  

z         

  

r        
  

  

 b  dmcsopt small systems local theories
    

non streaming
streaming   
streaming    

   

  

 

   

    
  

 

t           

 

d           
  

  

z           

  

r          
  

  

 c  dmcsopt large systems local theories

figure     non streaming vs  streaming dmcs dmcsopt
acceptable cases  particular guessing needed  moving size   small
package size    sometimes better  one save communication time  sending
package    partial equilibria vs  sending ten times package single pe   setting
 small package sizes     effective communication big factor 
   

fid istributed e valuation n onmonotonic ulti   context ystems

    

streaming  
streaming   
streaming    

   
  
 
   
    
     
  

 

t            

 

d           

  

z           
  

r          
  

  

figure     average time dmcsopt find one partial equilibrium streaming mode  varying
package size
happens real applications contexts located physically distributed nodes 
cases  computing    partial equilibria faster computing   pe    consecutive times 
furthermore  package size   safe cases guessing applied  e g  
r                   cases  large enough package size might help cover correct
guess  general  guarantee coverage  thoroughly solve problem 
one needs apply conflict learning whole mcs evaluation 
also  interesting see package size      dmcsopt usually times out 
reason many duplications dmcsopt stuck local search branch
promises fewer     partial equilibria  algorithm lose time without finding
new unique answers eventually time out 
find good package size p specific setting  topology  system size  local theory size  
one may run system training set apply binary search p 
      e ffect opology
quick glance plots figures      reveals pattern algorithms  especially
optimizations  perform better tree zigzag diamond  depending dmcs
dmcsopt  worst ring 
system topology plays important role here  aspects affect performance
algorithms  i  number connections   ii  structure block trees cut vertices 
 iii  acyclicity vs  cyclicity 
regarding  i   topology introduces number connections based system size  tree
fewer connections diamond zigzag  reduces communication
local solving time fewer requests made  performance dmcs topologies
proves observation  one follows argument  ring must offer best performance 
however  actually case due aspect  iii  shortly analyze below 
concerning  ii   tree ultimately optimized every intermediate node cut vertex 
hence  applying query plan dmcsopt  strip beliefs pes sent
child contexts parent context  words  local beliefs context ci needed
transferred back parents  drastically decreases amount information
   

fidao  t ran   e iter   f ink     k rennwallner

    
dmcs    
dmcsopt    

   

  

 
  

 

r        
 

 

 

r        
 

  

  

r          
  

  

  

figure     dmcs vs  dmcsopt streaming mode package size     ring
communicated  importantly  number calls lsolve  due special property 
dmcsopt performs extremely well tree topology  scales hundreds contexts 
comparing diamond zigzag  number cut vertices  however  zigzag
converted linear topology optimal query plan  cf  figure   c   therefore
processed much faster diamond  figure     dmcsopt scales zigzag    contexts
average time compute one answer still better one diamond    contexts 
regarding  iii   ring cyclic topology topologies acyclic  hence
algorithms must guess and check context topology  making
right guess important  even important reducing communication calls local
solvers  result running dmcs dmcsopt topology  figure     follow
pattern  absolutely depends specific instance whether sequential guessing
luckily arrives result  therefore  frequently see dmcs outperforms dmcsopt
streaming mode  cases  guessing root context  after detecting cycle 
effective guessing parent root context according optimal query plan 
based observations  one come best strategy evaluate different types
topologies  dealing mcss arbitrary topologies  looks natural decompose
parts familiar topologies efficient strategies known  combine
strategies overall evaluation method  studying beyond scope work
interesting issue future research 
      b ehavior eterministic c ontexts
considered algorithms mcss consisting possibly non deterministic contexts 
i e   one acceptable belief set per knowledge base  intriguing see
algorithms behave contexts always exactly one accepted belief set per knowledge base 
might underlying logic genuinely deterministic accepted belief set
clear  e g   closure classical logic  among multiple candidates particular belief set chosen
 in implementations typically first best solution computed  e g  sat solving asp  
observed that 
non cyclic topologies  performance difference dmcs dmcsopt 
smaller interface used dmcsopt reduce number intermediate pes
transferred contexts  one partial equilibrium computed every context 
   

fid istributed e valuation n onmonotonic ulti   context ystems

    

dmcs
dmcsopt
mcs ie

   

  

 

   

    
  

t        
 

 

d        
  

z        
  

r        
  

t         
  

d         
  

  

z         
  

r         
  

  

figure     dmcs vs  dmcsopt streaming mode package size     ring
cyclic topology  ring   guessing plays main role  hence depends individual
instance whether dmcs dmcsopt wins  case non deterministic contexts  cf 
section        
non streaming mode much faster streaming  on dmcs dmcsopt  
reasonable request partial equilibria redundant 
      c omparison mcs ie p p dr
systems close dmcs mcs ie  bogl et al          p p dr  bikakis  antoniou    hassapis         former plugin dlvhex system originally developed compute
explanations inconsistency multi context systems  includes mode computing
equilibria mcs  however  mcs ie implemented centralized approach  figure   
presents run time dmcs  dmcsopt comparison mcs ie computing partial equilibria respective configurations  shows mcs ie outperforms dmcs since
inherits powerful decomposition technique dlvhex  however  decomposition based
topological information dmcsopt turns efficient  localizes interface beliefs communicate blocks contexts  specific mcs
exploited general decomposition technique dlvhex 
p p dr supports distributed query answering multi context systems based defeasible
logic  details  see section    present comparison dmcs p p dr 
converted benchmark p p drs style converting local knowledge bases
bridge rules defeasible local meta rules  added fixed trust order contexts 
queried root context atom appearing one answers dmcs streaming
package size     turned p p dr always found answers around      seconds 
regardless tested instance  behavior explained follows  find answers
query atom  algorithm p p dr first evaluates local theory  determine truth
value query  terminates  otherwise algorithm consults neighbors get evidence
reasoning  local knowledge base structure  converted p p drs defeasible
theories  allows local decision  system works local theory root context
   http   www kr tuwien ac at research systems mcsie tut 

   

fidao  t ran   e iter   f ink     k rennwallner

every test case  thus results almost constant execution time  even asking neighbours
necessary  p p dr general may much faster dmcs  query answering process
inherently deterministic low complexity logic  turn  formalism less expressive 
detailed study issue remains future work 
      ummary
summing up  analysis experimental results shows clear winner among
algorithms  dmcs vs  dmcsopt  different running modes  streaming vs  non streaming 
different package size  different topologies  distill guideline choose
setup fits specific instances practice  including issues open investigation 
briefly stated follows 
choose dmcsopt dmcs non streaming mode  except cyclic topologies 
streaming mode  choose appropriate package size carefully  e g   binary search
training instances 
decompose random topologies parts whose topologies effective strategies evaluate 
study combine strategies systems 

   related work
section  resume discussion related work  starting multi context systems 
provide details work roelofsen et al          bikakis et al         consider
work  move related formalisms sat  csp asp 
roelofsen et al         described evaluation monotone mcs classical theories using
sat solvers contexts parallel  used  co inductive  fixpoint strategy check mcs
satisfiability  centralized process iteratively combines results sat solvers  apart
truly distributed  extension nonmonotonic mcs non obvious  furthermore 
caching technique used 
serafini  borgida  tamilin        serafini tamilin        developed distributed
tableaux algorithms reasoning distributed ontologies  regarded multi context
systems special bridge rules  algorithms serve decide whether system consistent  provided cyclic context dependencies exist  in technical terms  distributed tbox
acyclic   drago system  serafini   tamilin        implements approach owl ontologies  compared ours  work tailored specific class multi context systems resp 
knowledge bases  without nonmonotonic negation cyclic dependencies  which challenging   furthermore  targets query answering rather model building  sense dual
problem 
related work regards distributed evaluation system p p dr bikakis
et al          developed distributed algorithm query evaluation multi context system
framework specifically based  propositional  defeasible logic  framework  contexts built using defeasible rules exchange literals via bridge rules  trust order
contexts supplied  knowledge base context has  terminology  single
accepted belief set contains literals concluded  global system semantics given
terms  unique  three valued assignment literals  determined using algorithm  whether literal l provably  not  logical conclusion system  whether remains
   

fid istributed e valuation n onmonotonic ulti   context ystems

open  apart tailored particular logic preference mechanisms evaluating interlinked contexts  applying algorithm model building straightforward  particular 
produces unique belief sets  dealing nondeterminism multiple equilibria possible 
work computing equilibria distributed multi context systems clearly related
work solving constraint satisfaction problems  csp  sat solving distributed setting 
yokoo hirayama        survey algorithms distributed csp solving  usually developed setting node  agent  holds exactly one variable  constraints
binary  communication done via messages  every node holds constraints
involved  adopted later works  gao  sun    zhang        generalized
 yokoo   hirayama         relation topology based optimization techniques section   
biconnected components used baget tognetti        decompose csp problems 
decomposition used localize computation single solution components undirected constraint graphs  along lines  approach based directed dependencies 
allows us use query plan mcs evaluation 
predominant solution methods csp backtracking algorithms  bessiere  bouyakhf 
mechqrane  wahbi        took step backtracking dynamic total ordering agents guided nogoods  approach  however  allows cyclic dependency
contexts  hirayama yokoo        presented suite algorithms solving distributed sat  dissat   based random assignment improvement flips reduce conflicts 
however  algorithms geared towards finding single model  extension streaming
multiple  or all  models straightforward  works distributed csp sat 
similar 
finally   distributed  sat csp solving concerns monotonic systems  removal clauses
resp  constraints preserves satisfiability   mcss evaluation concerns nonmonotonic systems 
even contexts monotonic  e g   clause sets   makes efficient evaluation difficult 
important structural properties search space cannot exploited 
adjiman  chatalic  goasdoue  rousset  simon        present framework peer to peer
inference systems  local theories propositional clause sets share atoms special algorithm consequence finding available  pursue dual problem model building 
applying needs straightforward  furthermore  dealing non monotonic
systems  peer to peer systems adjiman et al  monotonic 
moving asp  pontelli  son  nguyens        asp prolog shares mcs idea
integrating several knowledge bases  called modules  possibly different semantics  however  restricted module semantics asp prolog  that is  least herbrand model  
asp prolog pursues query answering instead model building 
streaming  answer set streaming algorithm hex programs  which generalize asp
external information access  given eiter  fink  ianni  krennwallner  schuller
        despite similarities algorithm dmcs streaming  rather different  monolithic programs syntactically decomposed modules answer sets computed modular
fashion  fully distributed combines partial models lower components input
upper components straightforwardly  moreover  may use exponential space components 
   

fidao  t ran   e iter   f ink     k rennwallner

   conclusion
considered distributed evaluation multi context systems  mcss  introduced
brewka eiter        general formalism interlink possibly nonmonotonic heterogeneous knowledge bases  presented suite generic algorithms compute equilibria  i e   semantics mcs fully distributed manner  using local solvers knowledge
bases contexts  contains basic algorithm dmcs  advanced version dmcsopt
uses topology based optimizations  streaming variant dmcs streaming computing
partial equilibria gradually  believe underlying principles techniques might
exploited related contexts  particular distributed evaluation non monotonic
knowledge base formalisms 
algorithms implemented prototype system available open source  
top implementation  conducted comprehensive experiments compare performance algorithms gave insight analysis results  points advantages 
disadvantages well time memory trade algorithms different situations
depending parameters system topology  local interface theory size  number
equilibria desired user  based this  user choose setting  algorithm mode 
fits need best finding  partial  equilibria mcs  extensive treatment given
dao tran        
work open issues  several issues remain investigation  one improvement algorithms  here  experimental results ring topology strongly suggest
incorporate conflict learning  proved valuable asp sat solving  dmcs
dmcsopt  expect cyclic topologies benefit better guided guessing process  another issue concerns semantics variants mcss  former  grounded
equilibria considered dao tran         akin answer sets logic programs
applicable mcss satisfy certain algebraic conditions  characterized answer
sets using  adapted  loop formula approach  lee   lifschitz         dealing supported
equilibria  tasharrofi   ternovska         however  open 
regarding mcs variants  managed mcss  brewka et al         generalize bridge rules derive
operations  commands  management function applied knowledge bases  seems
possible generalize algorithms setting  efficient realization straightforward  another generalization mcs concerns dynamic data  areas sensor networks  social
networks  smart city applications  data may change even continuously arrive nodes 
motivates reactive stream processing mcss  goncalves et al         brewka et al         
last least  allowing contexts evolve via interation users changes environment valuable extention  extending algorithms settings interesting
challenging 
finally  extending work query answering mcss  user poses query
context receives results derived  partial  equilibria another natural issue 
need building whole equilibria  better performance may achieved 

acknowledgments
research supported austrian science fund  fwf  projects p     
p      
   

fid istributed e valuation n onmonotonic ulti   context ystems

c    

c 

c 

c    

c 

c 

c    

figure     introducing guess context s 
thank reviewers pointing corrections constructive suggestions
helped improve presentation work  thank antonis bikakis providing us
p p dr system experimental comparison 

appendix a  proofs
proof theorem  
prove theorem  first prove following lemmas       latter aims simplifying
proof cyclic case  based notion converting cyclic mcss acyclic ones 
lemma   context ck partial belief state mcs    c            cn   
app brk   s    app brk   s v   vb v v  k  
proof r app brk   s    ci   pi   b    r    pi sci
 cj   pj   b  r    pj
  scj   need show pi sci  vci pj
  scj  vcj   indeed 
v vb vcj vbj scj  vcj scj   therefore  pj
  scj pj
  scj  vcj  
now  assume pi
  sci  vci   fact pi sci   follows pi
  vci   hence

pi
  v  k   contradiction fact pi occurs bridge rule body 
therefore  r app brk   s v   

next lemma    based following notions convert cyclic mcss acyclic
ones show corresponding equilibria  intuition  illustrated figure   
examples         introduce additional context ck take care guessing every cycle
breaker ck   then  bridge rules ck parents modified point ck  
formally realize idea starting function ren renames part bridge rules 
definition    let ck context mcs   let v interface running dmcs 
renaming function ren defined follows 

atom a  ren a  k  v   

ag


bk v
otherwise


context index c  ren c  k  v   

c
c

c             n 
otherwise

bridge atom  ci   pi    ren  ci   pi    k  v     ren ci   k  v    ren pi   k  v  

   

fidao  t ran   e iter   f ink     k rennwallner

bridge body b     c    p           cj   pj    
ren b  k  v     ren  ci   pi    k  v     ci   pi   b 
bridge rule r   head  r  b r  
ren r  k  v    head  r  ren b r   k  v 
set bridge rules br   ren br   k  v     ren r  k  v    r br  
context ci    li   kb   br     ren ci   k  v     li   kb   ren bri   k  v   
example    let us slightly modify mcs    c    c    c    example   follows 
kb      e e   br      a      e        b   
kb       br      b      c   
kb       br      c      a   
applying function ren contexts c  c  results following bridge rules wrt  interface v    a  b  c  e  
ren br        v     a      eg         b   
ren br        v     c      ag    
two contexts ci cj   former called parent latter respect interface
v  denoted parent ci   cj   v  iff exists bridge rule r br exists  c   p 
b r  p bj v 
set contexts  cc    cc            cc    mcs called cycle w r t  interface v iff
 
parent cc    c    v 
parent cci   cci     v 
 i  

holds  one pick arbitrary context set cycle breaker  given mcs  
several ways choose  finite  set contexts cycle breakers  algorithm dmcs 
step  d  practically establishes cycle breakers based order elements in k 
iterated  next definition  interested particular set cycle breakers 
definition    given mcs    c            cn    let cb rm    cc            ccj   set cyclebreakers based application dmcs starting context cr   conversion
equal acyclic   based cb rm interface v done follows 

ren ci   i  v  ci cb rm
 
 
let ci    li   kb   br    
ci
otherwise
let ci      li   kb   br   i     ck cbm ren ci    k  v   
  
br  a  i   ag     bi v 
   
let ci       li   kb   br    
 

br
 


br   i

ci cb rm
otherwise

cj cb rm   introduce cj    lj   kb j   br j   br j   kb j    ag ag  
bj v        c               cn      cc            ccj   
    order composing function ren different parameters k matter here 

   

fid istributed e valuation n onmonotonic ulti   context ystems

example     contd  let mcs example    cb rm    c     then  conversion definition    gives      c       c       c       c     where 
g
kb      e e   br    
     a      e         b  

     ag   

e      eg     

kb       br    
     b      c   
g
kb       br    
     c         

kb      eg eg  

ag ag     br      

lemma    let mcs   conversion acyclic mcs definition    
equilibria       correspondence 
proof  sketch  let  r     r    runs dmcs     respectively  due
selection cb rm construct      r     r    order visiting contexts 
except  r    revisits cycle breaker ck cb rm   counterpart  r    visits ck  
corresponding locations 
 r    calls guess v  ck   step  c  
 r    calls lsolve               step  e  since ck leaf context 
construction local knowledge base ck gives us exactly guess ck   furthermore 
guesses passed parent contexts ck later unified additional
bridge rules  k   ag   introduced br    
k   therefore  belief combinations  step  d   done
ck executed input runs  r     r     correspondence equilibria
hence follows 

proof  theorem    thanks lemma     need prove theorem   acyclic
case automatically get result cyclic case 
   start showing soundness dmcs  let   ck  dmcs v    v v  k  
show partial equilibrium acyclic w r t  ck     s v  
proceed structural induction topology  
base case  ck leaf in k    brk   k
  hist  means  d 
executed  hence   e   lsolve runs exactly               get result set belief
states   lsolve                               tk                 tk acck  kbk     show
  s v   towards contradiction  assume partial equilibrium    s            sn  
w r t  ck     s v   in k      get ic  k     k   thus partial belief
state              tk                where tk acck  kbk    partial equilibrium w r t  ck  
contradiction 
induction step  assume context ck import neighborhood in k     i            im  
i    ci   dmcs v  hist  k   
  
 
im   cim  dmcs v  hist  k   
   

fidao  t ran   e iter   f ink     k rennwallner

induction hypothesis  every  ij ij   exists partial equilibrium ij
w r t  cij ij  v    ij  
let   ck  dmcs v  hist   need show every   s  partial equilibrium w r t  ck     s v   indeed  since in k       step  d  executed  let
  i        im
result combining partial belief states
scalling dmcs ci            cim   furthermore 
 
 
step  e      v    lsolve s       eventually    s v  
since every dmcs ci            cim returns partial equilibria w r t  cij projected v 
every partial equilibrium w r t  cij projected v  acyclic visited
contexts in k   thus lemma   get every   app brk     gives us
applicable bridge rules r regardless tj     j
  in k   hence    lsolve t  
returns partial belief states  component projected v except kth component 
every preserves applicability rules lemma    get every   s v  
exists partial equilibrium w r t  ck     s v  
   give proof completeness dmcs structural induction topology
acyclic   let    s            sn   partial equilibrium w r t  ck let     s v  
show   ck  dmcs v    
base case  ck leaf context  then  executing ck  dmcs v     step  d  ignored
step  e  called input               lsolve               gives us belief sets ck  
equilibrium w r t  ck   s  hence      s v returned ck  dmcs v    
induction case  suppose import neighborhood context ck in k     i            im    let
restriction every context cij in k  denoted ij   where 

s    ic  ij  
 
 
 
ij
   s            sn   s   

otherwise
informally speaking  restriction keeps belief sets contexts reachable cij
sets non reachable contexts   induction hypothesis  ij  v computed
cij  dmcs v    ij in k   show s v computed ck  dmcs v    
indeed  considering acyclic   holds ij  v returned call
cij  dmcs v   k    k plays role calls cij neighbors  means
step  d   contains   si              sim sij appears position ij s 
since partial equilibrium w r t  ck   sk acck  kbk  head  r   
r app brk   s     furthermore  choosing v v  k   lemma   tells us applicability
bridge rules preserved projection belief sets v  gives us sk lsolve t  
step  e   hence     s v returned ck  dmcs v    

proof proposition  
    context ck   let number calls local solver denoted c k   number
calculated computation step  d   bounded maximal number
combined partial belief sets neighbors  formally speaking 
c k  iin k    vbi     in k   v   n v   
   

fid istributed e valuation n onmonotonic ulti   context ystems

hence whole mcs  upper bound calls lsolve run dmcs
c    kn c k  n  n v 
    context ck mcs    c            cn    set e k  contains dependencies
contexts ci ic  k   visit  i  j  e k  exactly twice dfs traversal  
calling cj  dmcs v  hist  ci   retrieving s v cj ci   furthermore 
caching technique step  a  prevents recomputation already visited nodes  thus prevents
recommunication subtree visited node  claim hence follows 

proof proposition  
item  i  trivial see since cyclebreaker applied algorithm    prove item  ii   let us look
two cases edge     t  removed original topology step  a  algorithm   
    t  removed cyclebreaker  causes certain nodes graph cannot reach
via    however  interface ct provides already attached v i  j  via v  cp   bt  
    t  removed transitive reduction  change reachability
nodes  therefore  interface ct provides already included v  i  j b    


argument gives us property  ii  
proof proposition  
first  estimate complexity compute v i  j  loop  a  
 
 
v i  j     v  i  j b  
v  cp   bc
v  cp   bt
cc  

   t e

one hand  refined recursive import v  i  j  b defined  definition    
v  i  j  b    v  i 

 

b   

 b    j

b    j contains nodes reachable j 
hand  since sets possible beliefs different contexts disjoint 

 
cc  

v  cp   bc

 

v  cp   bt   v  cp   scc  bc s   t e bt

   t e


since recursive import interface node k defined v  k    iic  k  v i  
expression compute v i  j  end combination set intersection  union  projection 
implementation sets using hash set  is  look takes o     operators
implemented linear time  therefore  v i  j  computed linear time total number
beliefs contexts system 
given gm   block tree graph  gm   constructed linear time  vats   moura 
       ear decomposition  step  c   done linear time  valdes  tarjan    lawler 
   

fidao  t ran   e iter   f ink     k rennwallner

       transitive reduction  step  d   computed quadratic time respect number
edges block 
optimizetree t  gm    k  k  iterates blocks  assume blocks b         
bm   bi contains ni edges  n  
i   ni total number edges original
graph  let ti time process block bi   bound total processing time
assessed follows 



x
x
x
 
t 
ti
ni  
ni      n   
i  

i  

i  

therefore  ignore loop  a   optimizetree done quadratic time size
original input  i e   size gm  

proof theorem  
prove this  need proposition    claim partial equilibria returned dmcs
dmcsopt correspondence  first  need following supportive notion 

definition    let ck context mcs   let k query plan definition    
block b k   block interface b  whose root vertex cb  
vb    p v i  j     i  j  e b   bcb  
let ci context b  self recursive import interface ci b
 
v  i b   bi
v  i    b  
 i   e k  

proposition    let ck context mcs
  let k query plan definition   
ck belongs block b k let v   bk vb   then 
 i    dmcsopt k  called cc  c  k  e k   c   k  exists
partial equilibrium ck  dmcs v        s v  c k b  c  k  e k  
    s v  k b c   k 
 ii  ck  dmcs v     exists dmcsopt k  called cc
    s v  c k b  c  k  e k       s v  k b c   k 
detailed proof proposition    given next section  give proof theorem   
proof  theorem     i  let   ck  dmcsopt k  result dmcsopt  proposi  
 
  
tion     i 
sc   k  exists ck  dmcs v       v  k b  
choose v   bk vb   note v  k  v v collects bridge atoms blocks 
might contain blocks reachable k  theorem    exists partial equilibrium
     s v   thus 
     s v   v  k b
  s v  k b
v  k b v
b v  k b
  s vb
v
 ii  let partial equilibrium ms  theorem    exists    ck  dmcs v   
     s v choose v   bk vb   above  v  k  v  proposition     ii 
c   k  exists   ck  dmcsopt k          v  k b   above 
    s vb  

   

fid istributed e valuation n onmonotonic ulti   context ystems

proof proposition   
support proof proposition     need following lemmas 
lemma    assume context ck import neighborhood in k     i            im     k  ij   removed original topology optimizeblock b  cb   
 i 

  dmcsopt k  ci 
  
 

i 

  ci   dmcs vb    
  
 

 im

  dmcsopt k  cim

im

  cim  dmcs vb    

every partial equilibrium    ij   exists ij     s v  k ij  b  
let      i               im   i              ssim   then        exists
 
v  k  ij  b  
     vinput    m  vinput               j  
 
proof prove induction number neighbors in k  
base case  in k     i   claim trivially holds 
induction case  in k     i            i     u      i               i     u   i              i    
u   u     exists u u u     u  vinput         need show
  u       i    exists u    i       vinput        
assume opposite holds  i e   exists   u        u   u      i   
u u  i  u     u  vinput            s v  k i   b  
u    void 
means exists context ct reachable ck two different ways  one via i 
via one i            i   ut      st      ut    st   either
 i  ut    st     
 ii  ut    st    
case  i  cannot happen ct reachable ck   hence vinput          bt   
v  k  i    bt     
concerning case  ii   ut  vinput          st  v  k i         hence exists
ut   ut  vinput       
  st  v  k i      means vinput          bt    v  k  i    bt  


however  definition   recursive import interface  v  k  ix  b   v  k 
 b k b    b ix contains nodes b reachable ix   follows v  k  i   

v  k  ij     j     reaches t  share projection bt   hence vinput      
   bt   v  k  i    bt  
reach contradiction  therefore lemma    proved 


lemma    join operator    following properties  given arbitrary belief states s    u
size   i        ii           iii      t    u      s         u  
properties hold sets belief states 
proof first two properties trivial prove  prove associativity 
let r       t    u   w    s         u   consider joins left right 
position    n   ri wi determined locally comparing si   ti ui  
   

fidao  t ran   e iter   f ink     k rennwallner

si  




ti  


n

ui  

n




n

n

n





n



n

n

n



n

n

n

si   ti


n
n
n
n
n
n

n


n
n

ti   ui

n
n

n

n
n
n
n

n

n

ui   si

n

n
n
n

n
n
n

n
n
n

ri

ui
ti
ti
void
si
si
void
si
void
si
void
void
void

wi

ui
ti
ti
void
si
si
void
si
void
si
void
void
void

table    possible cases joining position

reach inconsistency  process terminates void returned  otherwise  conclude value
ri   wi continue next position  final join returned position n processed
without inconsistency 
possible combination si   ti   wi shown table    one see always
outcome ri wi   therefore  end either r   w
void   concludes join operator    commutative 

lemma    let ci cj two contexts block executing
optimizetree directed path ci cj   suppose   dmcsopt k  ci
j   dmcsopt k  cj        j  

proof use cache dmcsopt change result disregarded  i e  
assume without loss generality cache k    dmcsopt  indeed  cache k  filled
result computation empty  i e   ck accessed first time  
never changed dmcsopt returns cache k   i e   value computation
empty cache k  
assumption  lemma    proven taking path ci   cp            cph  
cj connects ci cj   arguing index               h   holds p    p    
j      indeed  show induction path 
base case      h  statement     holds ph    j   j    j   j identity
 lemma        i   
induction case  consider     h  suppose already established induction hypothesis
p      p       j  
   

fid istributed e valuation n onmonotonic ulti   context ystems

definition p  dmcsopt  holds p    lsolve t     is 
statements  b   c   form   p           holds edge  p    p     
e     commutative associative  lemma        ii   iii    induction
hypothesis  get
  p            s p       j          j     s p           
is  form j        
next  lsolve t   change value component interpretation
defined j   is  lsolve t      j   lsolve t    means p    lsolve t     lsolve t     
j   p     j   proves statement     holds   
eventually  get         p    p     j      j  

based lemma     following result 
lemma    assume import neighborhood context ck in k     i            im   
ij   dmcsopt k  cij     j m  furthermore  suppose edge  k  ij   removed
optimization process    j m   ci  neighbor ck exists path
k ij i  optimized topology  i    i     ij   words  input
dmcsopt ck affected removal  k  ij   
proof since cij ci  direct children ck   follows belong block 
therefore  lemma    i    i     ij  

proof  proposition     proceed structural induction block tree mcs   first 
consider case topology single block b  case  interface passed
dmcs v   vb  
base case  ck leaf  compare call dmcsopt k  ck ck  dmcs v    
v   v  k b   bk   algorithm   returns local belief sets ck projected v algorithm   returns plain local belief sets  claim follows v   v  k b   bk  
induction case  assume import neighborhood context ck in k     i            im   
 i 

  dmcsopt k  ci 
  
 

i 

  ci   dmcs vb    
  
 

 im

  dmcsopt k  cim

im

  cim  dmcs vb    

every partial equilibrium    ij   exists ij     s v  k ij  b  
two cases  first  edge  k  ij   removed optimization procedure  then 
lemma     correspondence input dmcsopt dmcs ck  
hand  assume edge  k  ij   removed optimization process 
removal either transitive reduction ear decomposition  former case  lemma   
shows input ck affected removal edge  latter case  removal
one three possibilities illustrated figure     assuming context c  gets called 
 i          last edge simple cycle p                      
    abuse notation  write lsolve t  





lsolve t  

   

fidao  t ran   e iter   f ink     k rennwallner

 

  
  

  

 

 

 

 

 
 

 

 

figure     possible cycle breakings
 ii          last edge path p                   
 iii           last edge path p                   
cases  i   iii  differ case  ii  sense cycle recognized dmcs
case  ii   cycle detected along corresponding path 
now  consider  k  ij   removed situations similar cases  i   iii   dmcsopt
issue guess step  c  algorithm   v k  ij    includes v  cb   bij   vb bij  
hand  dmcs recognize cycle cij issue guess vb bij step  c 
algorithm    therefore  guess fed equally ck  
 k  ij   removed situations similar case  ii   guesses ck interface
cij eventually filtered combined local belief states computed cij  
starting node path containing  k  ij   last edge  in ear decomposition  
figure     node   
cases  whenever input   lsolve dmcsopt k  called
cc   input lsolve ck  dmcs vb      therefore  claim output holds 
proposition    holds single leaf block  one see upper blocks
need import interface
beliefs cut vertices  also root contexts lower blocks  
setting v   bk vb   results dmcsopt dmcs projected interface
cut vertices identical  therefore  upper blocks receive input regarding
interfaces cut vertices running algorithms  therefore final results projected
v  k b end same 


proof proposition  
note components handler output simply take care communication part
dmcs streaming  output makes sure models sent back invokers correspondence request handler got  routines joiner solver main
components play role step  b   d  algorithm    respectively 
   

fid istributed e valuation n onmonotonic ulti   context ystems

t   

t   
t   

t   

  

t   

  



  

  

t   

  



  

  

t   

  



  

  

t   

  



  


t   

t   

t   

  

t   

  



  

  

t   

  



  

  

t  p 

  



  

tm  



  

tm pm



  

tm  



  

tm pm



tm  pm 

tm  pm 


  

tm  



  

tm pm



tm   

  

tm  



  

tm pm



  

tm  




  

t  p 

  



  


t  p 

tm   

tm   

  




t   

tm   

tm   

tm  pm 


  

t   

  



  



tm  p 


t  p 

  

t  p 

  



  

tm  pm 

  

tm pm

t   

t   

t   

t   

t  p 

  

t   

  



  

tm   


  

f  m  m 



  

t   

  



  

  

f  m  m 



  

t  p 

  



  

  

f  m  m 



  

t  p 

  



  

  

f  m  m 



  

t  p 

  



  

tm  pm 

tm   

tm  pm 

tm  pm 

  

f  m  m 

t   

t   

t  p 

  

t   

  



  



  

t  p 

  



  

  

t  p 

  



  

f  m    m 

f  m    m 

f  m    m 

 

 t       f     m  







 t  p     f     m  

 

f     m  

 

 



table    accumulation joiner

prove correctness dmcs streaming  need show input lsolve
complete sense step  e  algorithm   exhaustively executed  full join
partial equilibria neighboring contexts delivered 
   

fidao  t ran   e iter   f ink     k rennwallner

formally  assume current contexts import neighborhood                m   assume
neighbor ci   m  full partial equilibria ti returned packages size
k denoted ti             ti pi   is  ti   ti         ti pi   correctness algorithm 
assume ti             ti pi fixed partition ti   possible when  example  lsolve
always returns answers fixed order  need show accumulation join
algorithm   actually t              tm  
indeed  possible join t  i     t  i              tm im considered joiner  performs
lexicographical traversal suitable combinations  formally speaking  let f  p  q   q  
q  denote join result neighbors p q  is  f  p  q    tp    tp     
          tq  
according lexicographical order  accumulation joiner pj  
 t  j   
f     m     f     m  demonstrated table   
shows input lsolve complete  hence  dmcs streaming correct 


appendix b  detailed run optimizetree
example    illustrate call optimizetree t    b c  e   cp   cr   block set b  
 b    b    b     b                  b            b            c              e     b         b       
 b         cp   cr     
local knowledge bases presented example     have 
b     car     train     nuts    
b     car     train    
b     car     train     salad     peanuts     coke     juice     urgent    

b     car     train    
b     soon    sooner    
b     fit     sick    

since cp   cr   start b      b     f   v    
call optimizeblock b        since b  acyclic  transitive reduction applied 
get b                                              subroutine returns e                    
child cut vertices b  c             update f                  
next  update label edges  i  j  b    this  let us enumerate recursive
import interfaces  starting import interface  every node     
v       train     train     peanuts    
v       car     coke     train     car     train    
v    
v    
v    
v    
v    
v    

v       train     sick    
v       train    

v       sooner    
v     

 train     train     peanuts     car     coke     car     train     sooner     sick    
 train     car     coke     train     car     sooner     sick    
 train     sooner     sick    
 train     sooner    
 train     sooner    


now  let us compute v       b    v      b     b    b               thus
 
 
 
 
 
 

v       b    v      b  b       train     train     peanuts     car     coke     car     train    
similarly  b       b            have 
v          v     b     car     train    
v          v     b     train    
   

fid istributed e valuation n onmonotonic ulti   context ystems

removed edges updated labels stored respectively f v block b 
summarized as 
f                   
v        

v       



v     b 



v     b 

v         v        v     b  v     b 
v         v        v     b  v     b 




train     train     peanuts    
 
car     coke     car     train  
   train     peanuts     car     coke     car     train    
   train     peanuts     car     coke     car     train    

next  call optimizetree t   b          optimizetree t   b           eventually process
blocks b  b  manner above  two calls respectively return 
f             
v             sooner    

f     
v              train     sick    

combining results together  optimizetree t        returns set removed edges
f                           
updated labels v remaining edges blocks
v      
v      
v      
v      
v      

 
 
 
 
 

 train     train     peanuts     car     coke     car     train    
 train     peanuts     car     coke     car     train    
 train     peanuts     car     coke     car     train    
 sooner    
 train     sick    

references
adjiman  p   chatalic  p   goasdoue  f   rousset  m  c     simon  l          distributed reasoning
peer to peer setting  application semantic web  j  artif  intell  res              
aho  a  v   garey  m  r     ullman  j  d          transitive reduction directed graph 
siam j  comput                
analyti  a   antoniou  g     damasio  c  v          mweb  principled framework modular
web rule bases semantics  acm trans  comput  log             
baader  f   calvanese  d   mcguinness  d   nardi  d     patel schneider  p  f   eds           
description logic handbook  cambridge university press 
baget  j  f     tognetti  y  s          backtracking biconnected components constraint
graph  nebel  b   ed    proceedings seventeenth international joint conference
artificial intelligence  ijcai       seattle  washington  usa  august             pp     
     morgan kaufmann 
bairakdar  s  e  d   dao tran  m   eiter  t   fink  m     krennwallner  t       a   decomposition
distributed nonmonotonic multi context systems  janhunen  t     niemela  i   eds   
logics artificial intelligence     th european conference  jelia       helsinki  finland 
september              proceedings  vol       lecture notes computer science  pp 
      springer 
   

fidao  t ran   e iter   f ink     k rennwallner

bairakdar  s  e  d   dao tran  m   eiter  t   fink  m     krennwallner  t       b   dmcs
solver distributed nonmonotonic multi context systems  janhunen  t     niemela  i 
 eds    logics artificial intelligence     th european conference  jelia       helsinki 
finland  september              proceedings  vol       lecture notes computer science  pp          springer 
bessiere  c   bouyakhf  e   mechqrane  y     wahbi  m          agile asynchronous backtracking
distributed constraint satisfaction problems  ieee   rd international conference
tools artificial intelligence  ictai       boca raton  fl  usa  november           
pp         
bikakis  a     antoniou  g          defeasible contextual reasoning arguments ambient
intelligence  ieee transactions knowledge data engineering                   
bikakis  a   antoniou  g     hassapis  p          strategies contextual reasoning conflicts
ambient intelligence  knowl  inf  syst               
bogl  m   eiter  t   fink  m     schuller  p          mcs ie system explaining inconsistency
multi context systems  logics artificial intelligence     th european conference 
jelia       helsinki  finland  september              proceedings  vol       lecture
notes computer science  pp          springer 
bondy  a     murty  u  s  r          graph theory  vol      graduate texts mathematics 
springer 
brewka  g   eiter  t   fink  m     weinzierl  a          managed multi context systems  walsh 
t   ed    proceedings   nd international joint conference artificial intelligence
 ijcai      pp          aaai press ijcai 
brewka  g   ellmauthaler  s     puhrer  j          multi context systems reactive reasoning
dynamic environments  ellmauthaler  s     puhrer  j   eds    proceedings international workshop reactive concepts knowledge representation  reactknow        pp 
      tech rep     computer science institute  univ  leipzig  issn           
brewka  g     eiter  t          equilibria heterogeneous nonmonotonic multi context systems 
proceedings twenty second aaai conference artificial intelligence  july       
      vancouver  british columbia  canada  pp          aaai press 
brewka  g   eiter  t     fink  m          nonmonotonic multi context systems  flexible approach integrating heterogeneous knowledge sources  balduccini  m     son  t  c 
 eds    logic programming  knowledge representation  nonmonotonic reasoning   essays dedicated michael gelfond occasion   th birthday  vol       lecture notes computer science  pp          springer 
brewka  g   roelofsen  f     serafini  l          contextual default reasoning  veloso  m  m 
 ed    ijcai       proceedings   th international joint conference artificial intelligence  hyderabad  india  january             pp         
buccafurri  f     caminiti  g          logic programming social features  theory practice
logic programming                 
dao tran  m          distributed nonmonotonic multi context systems  algorithms efficient
evaluation  ph d  thesis  faculty informatics  vienna university technology  austria 
   

fid istributed e valuation n onmonotonic ulti   context ystems

dao tran  m   eiter  t   fink  m     krennwallner  t          distributed nonmonotonic multicontext systems  lin  f   sattler  u     truszczynski  m   eds    principles knowledge representation reasoning  proceedings twelfth international conference 
kr       toronto  ontario  canada  may             aaai press 
dao tran  m   eiter  t   fink  m     krennwallner  t          model streaming distributed multicontext systems  mileo  a     fink  m   eds     nd international workshop logicbased interpretation context  modeling applications  vol      ceur workshop
proceedings  pp       
eiter  t   fink  m   ianni  g   krennwallner  t     schuller  p          pushing efficient evaluation
hex programs modular decomposition  delgrande  j  p     faber  w   eds      th international conference logic programming nonmonotonic reasoning  lpnmr       
vancouver  bc  canada  may              vol       lecture notes computer science 
pp         springer 
eiter  t   ianni  g   schindlauer  r     tompits  h          uniform integration higher order
reasoning external evaluations answer set programming  ijcai  pp       
faltings  b     yokoo  m          introduction  special issue distributed constraint satisfaction 
artif  intell                
fink  m   ghionna  l     weinzierl  a          relational information exchange aggregation
multi context systems  delgrande  j  p     faber  w   eds      th international conference logic programming nonmonotonic reasoning  lpnmr        vancouver  bc 
canada        may        vol       lecture notes computer science  pp         
springer 
gao  j   sun  j     zhang  y          improved concurrent search algorithm distributed csps 
australian conference artificial intelligence  pp         
gelfond  m     lifschitz  v          classical negation logic programs disjunctive databases 
new generation comput                  
ghidini  c     giunchiglia  f         
local models semantics  contextual reasoning locality compatibility  artif  intell                  
giunchiglia  f          contextual reasoning  epistemologia  special issue linguaggi e le
macchine              
giunchiglia  f     serafini  l          multilanguage hierarchical logics or  without
modal logics  artif  intell               
goncalves  r   knorr  m     leite  j          evolving multi context systems  schaub  t  
friedrich  g     osullivan  b   eds    proceedings   st eureopean conference
artificial intelligence  ecai      prague  czech republic  august              ios press 
hirayama  k     yokoo  m          distributed breakout algorithms  artif  intell           
      
homola  m          semantic investigations distributed ontologies  ph d  thesis  comenius
university  bratislava  slovakia 
   

fidao  t ran   e iter   f ink     k rennwallner

lee  j     lifschitz  v          loop formulas disjunctive logic programs  palamidessi  c 
 ed    logic programming    th international conference  iclp       mumbai  india  december             proceedings  lecture notes computer science  pp          springer 
mccarthy  j          notes formalizing context  bajcsy  r   ed    proceedings   th
international joint conference artificial intelligence  chambery  france  august    september          pp          morgan kaufmann 
pontelli  e   son  t     nguyen  n  h          combining answer set programming prolog 
asp prolog system  balduccini  m     son  t   eds    logic programming  knowledge
representation  nonmonotonic reasoning  vol        pp          springer berlin heidelberg 
reiter  r          logic default reasoning  artificial intelligence            
roelofsen  f   serafini  l     cimatti  a          many hands make light work  localized satisfiability multi context systems  de mantaras  r  l     saitta  l   eds    proceedings
  th eureopean conference artificial intelligence  ecai      including prestigious
applicants intelligent systems  pais       valencia  spain  august              pp       
ios press 
serafini  l   borgida  a     tamilin  a          aspects distributed modular ontology reasoning  nineteenth international joint conference artificial intelligence  ijcai       
pp          aaai press 
serafini  l     tamilin  a          drago  distributed reasoning architecture semantic web 
gomez perez  a     euzenat  j   eds    semantic web  research applications 
second european semantic web conference  eswc       heraklion  crete  greece  may   
  june          proceedings  lecture notes computer science  pp          springer 
tarjan  r  e          depth first search linear graph algorithms  siam j  comput        
       
tasharrofi  s     ternovska  e          generalized multi context systems   baral  c   giacomo 
g  d     eiter  t   eds    principles knowledge representation reasoning  proceedings fourteenth international conference  kr       vienna  austria  july             
aaai press 
valdes  j   tarjan  r  e     lawler  e  l          recognition series parallel digraphs  siam
j  comput                 
vats  d     moura  j  m  f          graphical models block tree graphs  corr  abs           
velikova  m   novak  p   huijbrechts  b   laarhuis  j   hoeksma  j     michels  s         
integrated reconfigurable system maritime situational awareness  ecai          st
european conference artificial intelligence        august       prague  czech republic
  including prestigious applications intelligent systems  pais        pp           
yokoo  m     hirayama  k          algorithms distributed constraint satisfaction  review 
autonomous agents multi agent systems               

   


