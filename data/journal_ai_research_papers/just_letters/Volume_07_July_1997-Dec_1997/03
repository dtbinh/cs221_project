journal artificial intelligence research              

submitted       published     

identifying hierarchical structure sequences 
linear time algorithm
craig g  nevill manning
ian h  witten
department computer science
university waikato  hamilton  new zealand 

cgn cs waikato ac  nz
ihw cs waikato ac  nz

abstract
equitur algorithm infers hierarchical structure sequence discrete symbols
replacing repeated phrases grammatical rule generates phrase  continuing
process recursively  result hierarchical representation original sequence 
offers insights lexical structure  algorithm driven two constraints reduce
size grammar  produce structure by product  equitur breaks new ground
operating incrementally  moreover  methods simple structure permits proof operates
space time linear size input  implementation process       
symbols per second applied extensive range real world sequences 

   introduction
many sequences discrete symbols exhibit natural hierarchical structure  text made
paragraphs  sentences  phrases  words  music composed major sections  motifs  bars 
notes  records user interface behavior encode hierarchical structure tasks users
perform  computer programs constitute modules  procedures  statements  discovering
natural structure underlies sequences challenging interesting problem wide
range applications  phrase discovery music analysis  programming
demonstration code optimization 
search structure sequences occurs many different fields  adaptive text
compression seeks models sequences used predict upcoming symbols
encoded efficiently  bell et al          however  text compression models
extremely opaque  illuminate hierarchical structure sequence  grammatical
inference techniques induce grammars set example sentences  possibly along set
negative examples  gold        angluin        berwick pilato         however 
crucial operation input continuous stream segmented sentences 
are  effect  independent examples structure sought  brief review
pertinent systems appears section    techniques markov modeling hidden markov
modeling make attempt abstract information hierarchical form  rabiner juang       
laird saul         sequence learning occurs areas automaton modeling
 gaines         adaptive systems  andreae         programming demonstration  cypher 
       human performance studies  cohen et al          generally plays peripheral
role 
paper describe sequitur  algorithm infers hierarchical structure
sequence discrete symbols  basic insight phrases appear
replaced grammatical rule generates phrase  process
continued recursively  producing hierarchical representation original sequence  result
     ai access foundation morgan kaufmann publishers  rights reserved

finevill manning   witten

strictly grammar  rules generalized generate one string   it
provide good basis inferring grammar  beyond scope paper  
scheme resembles one developed arose work language acquisition  wolff 
                         operated time quadratic respect length
input sequence  whereas algorithm describe takes linear time  let us investigate
sequences containing several million tokensin previous work examples much smaller 
largest mentioned thousand tokens  another difference  crucial
importance practical applications  new algorithm works incrementally 
return wolffs scheme  compare sequitur  section   
ability deal easily long sequences greatly extended range sequiturs
application  applied artificially generated fractal like sequences produced lsystems  and  along unification based rule generalizer  used recover original lsystem  method inferred relatively compact deterministic  context free grammars
million symbol sequences representing biological objects obtained stochastic  contextsensitive  l systems  turn greatly speeded graphical rendering objects 
applied sequitur    mbyte segments digital library generate hierarchical
phrase indexes text  provides novel method browsing  nevill manning et al  
       algorithm compresses multi megabyte dna sequences effectively
general purpose compression algorithms  finally  post processing  elicited
structure two million word extract genealogical database  successfully identifying
structure database compressing much efficiently best known
algorithms  touch applications section   below  nevill manning       
describes all 
paper describes sequitur algorithm evaluates behavior  next section
gives concise description algorithm terms constraints form output
grammar  section   gives taste kind hierarchies sequitur capable inferring
realistic sequences  section   describes implementation detail  particular
emphasis achieves efficiency  section   shows run time storage
requirements linear number input symbols  section   discusses algorithms
behavior extreme input strings  end quantitative analysis sequiturs
performance several example sequences  review related research 

   sequitur algorithm
sequitur forms grammar sequence based repeated phrases sequence 
repetition gives rise rule grammar  repeated subsequence replaced nonterminal symbol  producing concise representation overall sequence 
pursuit brevity drives algorithm form maintain grammar  and  byproduct  provide hierarchical structure sequence 
left figure  a sequence contains repeating string bc  note
sequence already grammara trivial one single rule  compress it  sequitur forms
new rule bc  replaces occurrences bc  new grammar appears right
figure  a 
sequence figure  b shows rules reused longer rules  longer
sequence consists two copies sequence figure  a  since represents exact

  

fii nferring sequential structure sequences

repetition  compression achieved forming rule abcdbc replace halves
sequence  gains made forming rule b bc compress rule a 
demonstrates advantage treating sequence  rule s  part grammarrules may
formed rule analogous way rules formed rule s  rules within rules
constitute grammars hierarchical structure 
grammars figures  a  b share two properties 
p     pair adjacent symbols appears grammar 
p     every rule used once 
property p   requires every digram grammar unique  referred
digram uniqueness  property p  ensures rule useful  called rule utility 
two constraints exactly characterize grammars sequitur generates 
figure  c shows happens properties violated  first grammar contains
two occurrences bc  p  hold  introduces redundancy bc appears twice 
second grammar  rule b used once  p   hold  removed 
grammar would become concise  grammars figures  a  b ones
properties hold sequence  however  always unique grammar
properties  example  sequence figure  d represented
grammars right  obey p   p    deem either grammar acceptable 
repetitions cannot overlap  string aaa give rise rule  despite containing two
digrams aa 
sequiturs operation consists ensuring properties hold  describing
algorithm  properties act constraints  algorithm operates enforcing constraints
grammar  digram uniqueness constraint violated  new rule formed 
rule utility constraint violated  useless rule deleted  next two subsections describe
occurs 
    digram uniqueness
sequitur observes new symbol  appends rule s  last two symbols rule
new symbol predecessorform new digram  digram occurs elsewhere
grammar  first constraint violated  restore it  new rule formed digram
right hand side  headed new non terminal symbol  two original digrams
replaced non terminal symbol 
sequence

grammar



abcdbc

aada
bc

c

abcdbcabcdbc

aa
abcdbc

sequence

grammar

b

abcdbcabcdbc

aa
abdb
b bc



aabaaab

aaa
aab

cc
bc
b aa
c bda

abaab
aa

figure   example sequences grammars reproduce them   a 
sequence one repetition   b  sequence nested repetition   c 
two grammars violate two constraints   d  two different grammars
sequence obey constraints 

  

finevill manning   witten

table   shows grammars result successive symbols sequence
abcdbcabcd processed  second column shows sequence observed far  third
column gives grammar created sequence  fourth column notes constraints
violated  actions taken resolve violations 
sequitur adds final c symbol    digram bc appears twice  sequitur creates
new rule a  bc right hand side  replaces two occurrences bc a 
illustrates basic procedure dealing duplicate digrams 
appearance duplicate digram always result new rule  new digram
appears right hand side existing rule  new rule need created  nonterminal symbol heads existing rule replaces digram  symbol   table   
third bc appears  existing non terminal symbol replaces third occurrence bc 
results new pair repeating digrams  aa  shown next line table    sequitur
accordingly forms new rule b  replaces two occurrences aa  sequitur creates
maintains hierarchy iterative process  substitution bc results new
digram aa  replaced b  larger sequences  changes ripple
grammar  forming matching longer rules higher hierarchy 
symbol
number

string
far

resulting
grammar

remarks

 



sa

 

ab

ab

 

abc

abc

 

abcd

abcd

 

abcdb

abcdb

 

abcdbc

abcdbc

bc appears twice

aada
bc

enforce digram uniqueness

 

abcdbca

aadaa
bc

 

abcdbcab

aadaab
bc

 

abcdbcabc

aadaabc
bc

bc appears twice

aadaaa
bc

enforce digram uniqueness 
aa appears twice

bdab
bc
b aa

enforce digram uniqueness

bdabd
bc
b aa

bd appears twice

cac
bc
b aa
c bd

enforce digram uniqueness 
b used

cac
bc
c aad

enforce rule utility

  

abcdbcabcd

table   operation two grammar constraints 
digram uniqueness rule utility

  

fii nferring sequential structure sequences

    rule utility
now  right hand sides rules grammar two symbols long  longer
rules formed effect rule utility constraint  ensures every rule used
once  table    symbol    demonstrates idea  appended rule s 
new digram bd causes new rule  c  formed  however  forming rule leaves one
appearance rule b  violating second constraint  reason  b removed
grammar  right hand side substituted one place occurs  removing b
means rule c contains three symbols  mechanism forming long rules 
form short rule temporarily  subsequent symbols continue match  allow new rule
supersede shorter one delete latter  although creation deletion rules
appears inefficient first glance  performed efficiently appropriate data
structures  importantly  keeps track long matches within grammar  obviating
need external data structures  simplifies algorithm considerably  permitting concise
proof linear time complexity  see section    

   structures inferred realistic sequences
described mechanism sequitur builds grammar  embarking
efficiency issues  instructive consider structures simple technique infer
realistic sequences  case applied sequitur large sample excerpted
part structure illustrative purposes 
figures  a   b  c show parts three hierarchies inferred text bible
english  french  german  hierarchies formed without knowledge preferred
structure words phrases  nevertheless capture many meaningful regularities 
figure  a  word beginning split begin ninga root word suffix  many words
word groups appear distinct parts hierarchy  spaces made visible
replacing bullets   algorithm produces french version figure  b 
commencement split analogous way beginninginto root commence
suffix ment  again  words au  dieu cieux distinct units hierarchy 
german version figure  c correctly identifies words sentence  well phrase
die himmel und die  fact  hierarchy heaven figure  a bears
similarity german equivalent 
london oslo bergen corpus  johansson et al         contains     million words tagged
word classes  example  sentence labour sentiment would still favour
abolition house lords tagged classes determiner noun noun auxiliary adverb
verb article noun preposition article noun preposition noun  hierarchy sequitur infers
word classes corresponds possible parse sentence corpus 
tree expressed terms parts speech  figure  d shows part inferred hierarchy 
tags replaced actual words text  sequitur identifies middle
part sentence  sentiment would still favour abolition large block  part could
stand grammatical sentence  adjectival phrase house lords
appears distinct unit  labour  adjectival phrase precedes subject 
figure  e shows two bach chorales sequitur detected internal
repetitionsthe light gray boxes show two halves first chorale almost
identicaland repetitions chorales  denoted gray box second half

  

finevill manning   witten



n h e b e g n n n g g c r e e h e h e v e n n h e e r h

b

u c e n c e e n   e u c r l e c e u x e l e r r e

c

xx

n f n g c h u f g e h e l u n e e r e



labour sentiment would still favour abolition house lords

e

imperfect

perfect

figure   hierarchies various sequences  genesis      a  english   b  french   c  german 
 d  grammatical parse inferred sequence word classes   e  repetitions within
two chorales harmonized j s  bach 
second chorale  section white box occurs four halves  also  detecting repeated
motifs many chorales  sequitur identifies imperfect perfect cadences end
first second halves  respectively  general  sequitur capable making plausible
inferences lexical structure sequences  hierarchies produces aid comprehension
sequence 

   implementation issues
sequitur algorithm operates enforcing digram uniqueness rule utility constraints 
essential violation constraints detected efficiently  section
describe mechanisms fulfill requirement 
choice appropriate data structure depends kind operations need
performed modify grammar  sequitur are 
appending symbol rule s 
using existing rule 
creating new rule 
deleting rule 
appending symbol involves lengthening rule s  using existing rule involves substituting
non terminal symbol two symbols  thereby shortening rules containing digrams 
creating new rule involves creating new non terminal symbol left hand side 
  

fii nferring sequential structure sequences



b

c

b



b


cd
digram
bc
index
ab

figure   data structures rules digram index
inserting two new symbols right hand side  creating rule  substitutions made
existing rule replacing two digrams new non terminal symbol  deleting
rule involves moving contents replace non terminal symbol  lengthens rule
containing non terminal symbol  left hand side rule must deleted 
ensure rules lengthened shortened efficiently  sequitur represents rule
using doubly linked list whose start end connected single guard node  shown
two rules b figure    guard node serves attachment point left hand
side rule  remains constant even rule contents change  nonterminal symbol points rule heads  shown figure   pointer nonterminal symbol b rule head rule b  pointers  arrays necessary
accessing rules symbols  operations affect adjacent symbols rules headed
non terminal 
rule utility constraint demands rule deleted referred once 
rule associated reference count  incremented non terminal symbol
references rule created  decremented non terminal symbol deleted 
reference count falls one  rule deleted 
digram uniqueness constraint difficult enforce  new digram appears 
sequitur must search grammar occurrence it  one simple solution would
scan entire grammar time looking match  inefficient leads
quadratic time algorithm  better solution requires index efficient search 
data structure storing digram index must permit fast access efficient addition
deletion entries  hash table provides constant time access  adding deleting
entries requires little extra work  digram appears once  table need
contain pointer first symbol single matching digram grammar data structure 
shown figure    hash table consists simple array pointers  collisions
handled open addressing avoid allocation memory chaining requires  knuth 
      
every time new digram appears grammar  sequitur adds index  new
digram appears result two pointer assignments linking two symbols together doublylinked list  one forward pointer one back pointer   thus updating index
incorporated low level pointer assignments  digram disappears grammar
pointer assignment madethe pointer value overwritten assignment
represents digram longer exists 
demonstrate mechanism updating hash table new rule created  table
  shows example figure  a  addition contents digram index 
second c appended rule s  digram table shows bc already exists grammar 
rule bc created  creating link b c right hand side rule
updates entry index bc point new locationthe hash table contains
pointer symbol b start rule a  next  first bc removed  breaks link
b digram preceding symbol a  ab removed index 
  

finevill manning   witten

action

grammar

observe symbol c

abcdbc

change digrams

digram index

make new rule

abcdbc
bc

bc updated

 ab  bc  cd  db 

substitute bc

aadbc
bc

ab  cd removed 
aa  ad added

 bc  db  aa  ad 

substitute bc

aada
bc

db removed 
da added

 bc  da  aa  ad 

 ab  bc  cd  db 

table   updating digram index links made broken
breaks link c following d  cd removed index  next  replaces
bc  creating links a  well d  adding digrams index 
process continues  resulting correct index digram pointers  costing one
indexing operation per two pointer operations 
next  sequitur requires efficient strategy checking digram index  rechecking
entire grammar whenever symbol added infeasible  inefficient large portions
grammar unchanged since last check  fact  parts need checking
links made broken  is  actions affect
maintenance digram table performed  newly created digrams checked
index  course  every time link created  digram entered index 
time check duplicate  entry found already present attempting
add new digram index  duplicate digram detected appropriate
actions performed  therefore  one hash table lookup required accessing
updating digram index 

   computational complexity
section  show sequitur algorithm linear space time  complexity
proof amortized oneit put bound time required process one symbol 
rather bounds time taken whole sequence  processing time one symbol
fact large o  n    n number input symbols far  however 
pathological sequence produces worst case requires preceding o  n   symbols
involve formation matching rules 
basic idea proof two constraints effect reducing
action
 

new input symbol observed  append rule s 

 

 
 
 
 
 
 
 
 

time link made two symbols
new digram repeated elsewhere repetitions overlap 
occurrence complete rule 
replace new digram non terminal symbol heads rule 
otherwise 
form new rule replace digrams new non terminal symbol
otherwise 
insert digram index

 

  
  
  

time digram replaced non terminal symbol
either symbol non terminal symbol occurs elsewhere 
remove rule  substituting contents place non terminal symbol

table   sequitur algorithm

  

 
 

 

fii nferring sequential structure sequences

number symbols grammar  work done satisfying constraints bounded
compression achieved sequence  savings cannot exceed original size input
sequence  algorithm linear number input symbols 
table   gives pseudo code sequitur algorithm  line   deals new observations
sequence  lines     enforce digram utility constraint  lines      
enforce rule utility  on line appendix contains implementation sequitur java 
requires     lines algorithm 
numbers right table   identify main sections algorithm  proof
demonstrate bounds number times executes  action   appends
symbols rules performed exactly n times  every symbol input  link
creation triggers action    action   uses existing rule  action   forms new rule  action  
removes rule 
table   shows examples actions          associated savings grammar size 
savings calculated counting number symbols grammar
action  non terminal symbols head rules counted 
recreated based order rules occur  actions     actions
reduce number symbols  actions increase size grammar 
difference size input size grammar must equal number
times actions taken 
set stage  proceed proof  formally  let
n size input string 
size final grammar 
r number rules final grammar 
  number times new symbol seen  action    
  number times new digram seen  action    
  number times existing rule used  action    
  number times new rule formed  action    
  number times rule removed  action    
according reasoning above  reduction size grammar number times
actions     executed  is 
   
n   a    a  
next  number times new rule created  action    must bounded  two actions
affect number rules    creates rules     deletes them  number
rules final grammar must difference frequencies actions 
r   a  a  
equation  r known a  bounded equation        unknown  noting a   
number times new symbol seen  equal n  total work
action





saving

matching existing rule

 

   ab   
ab

   a   
ab

 

creating new rule

 

   ab   ab   

   a   a   
ab

 

deleting rule

 

   a   
ab

   ab   

 

table   reduction grammar size three grammar operations

  

finevill manning   witten

                    n        n o     r        
bound expression  note number rules must less number symbols
final grammar  rule contains least two symbols 
r   o 
also  expression     above 
a    n a    n 
consequently 
                     n    r o    a         n  a    
final operation bound action    checks duplicate digrams  searching
grammar done hash table lookup  assuming occupancy less than  say      gives
average lookup time bounded constant  knuth         occupancy assured
size sequence known advance  enlarging table recreating entries
whenever occupancy exceeds      number entries table number
digrams grammar  number symbols grammar minus number
rules grammar  symbols end rule form left hand side
digram  thus size hash table less size grammar  bounded
size input  means memory requirements algorithm linear 
practice  linear growth memory poses problem  one strategy currently
investigating break input small segments  form grammars them 
merge resulting grammar 
number times action   carried out  digram checked new
link created  links created actions            already shown
bounded  n  time required action   o n  
thus shown algorithm linear space time  however  claim must
qualified  based register model computation rather bitwise one 
assumed average lookup time hash table digrams bounded constant 
however  length input increases  number rules increases without bound 
unstructured  e g   random  input  digram table grow without bound  thus time
required execute hash function perform addressing constant 
increase logarithmically input size  proof ignores effect  assumes hash
function operations register based therefore constant time  practice     bit
architecture  linearity proof remains valid sequences around     symbols 
   bit architecture      symbols 

   exploring extremes
described sequitur algorithmically  characterize behavior variety
domains  section explores large small grammar given sequence length 
well determining minimum maximum amount work algorithm carry
amount work required process one symbol  figure   summarizes extreme
cases  giving part example sequence grammar results  bounds given
terms n  number symbols input 
deepest hierarchy formed depth o  n    example sequence
creates hierarchy shown figure  a  order hierarchy deepen every
rule  rule must contain non terminal symbol  furthermore  rule need longer two

  

fii nferring sequential structure sequences

symbols  therefore  produce deep hierarchy short string  rule one
terminal symbol longer one builds  order create rules  string
represented must appear two different contexts  otherwise rule incorporated
longer rule  one context deepest hierarchy  must participate  context
hierarchy  reduce size input string  appear rule s 
note every rule figure  a appears hierarchy rule s  repetition
sequence  one terminal symbol appended  producing new level hierarchy 
point including repetition length one  mth repetition length     
repetition gives rise mth rule  counting rule s   total length sequence
hierarchy depth therefore
n                      m        o m  
deepest hierarchy depth   o  n   
end spectrum  grammar shallowest hierarchy  shown
figure  b  rules apart rule s  grammar largest possible one
sequence given length  precisely rules formed it  sequence
gives rise one digram ever recurs  course  sequence alphabet
size     o      different digrams  bounds length sequence 
kind sequence produces worst case compression  repetitions 
therefore sequitur detects structure 
bound

example sequence

example grammar



deepest hierarchy

o n 

ababcabcdabcdeabcdef

abcddf
ab
b ac
c bd
ce

b

largest grammar 
shallowest hierarchy

n

aabacadae   bbcbdbe   

aabacadae   

c

smallest grammar

o log n 

aaaaaaaaaaaaaa   

dd
aa
b aa
c bb
cc



largest number rules

n  

aaaaababacacadad   

aabbccdd
aa
b ab
c ac
ad

e

maximum processing
one symbol

o n 

yzxyzwxyzvwxy

abwbvwxy
yz
b xa

f

greatest number rule
creations deletions

n new rules
n deleted rules

abcdeabcdeabcde   

aaa   
abcde

figure   extreme cases algorithm

  

finevill manning   witten

turning largest grammar smallest  figure  c depicts grammar formed
ordered sequence possibleone consisting entirely symbol  four
contiguous symbols appear  aaaa  rule b aa formed  another four appear 
rule contains bbbb  forming new rule c bb  every time number symbols doubles 
new rule created  hierarchy thus o log n  deep  grammar o log n  size 
represents greatest data compression possible  although necessary sequence
one symbol achieve logarithmic lower boundany recursive structure do 
produce grammar greatest number rules  rule include
terminal symbols  building hierarchy reduce number rules required cover
sequence given size  furthermore  rule longer two symbols occur
twice  therefore rule requires four symbols creation  maximum
number rules sequence length n n    shown figure  d 
discussed size grammars  consider effort involved
maintaining them  shown upper bound processing sequence linear
length sequence  however  still useful characterize amount processing
involved new symbol  figure  e shows sequence repetition built yz 
xyz  wxyz  forth  second occurrence wxyz appears  matches
possible w  x  y  z appears  yz matches rule a  xa matches rule b 
finally  sequitur forms new rule wb  cascading effect arbitrarily large
repetitions continue build right to left fashion  amount processing required
deal last z proportional depth deepest hierarchy  matching cascades
hierarchy  maximum time process one symbol therefore o  n    fact w 
x  fail match means require little time process  preserving overall linear
time bound 
although bound linear  sequences certainly differ proportion work sequence
length  sequence figure  b  repetitions exist grammar formed 
minimizes ratio  sequence figure  f  consists multiple repetitions multisymbol sequence  maximizes it  time repetition appears several rule deletions
creations match lengthens  fact  every symbol except incurs rule creation
subsequent deletion  o n  creations deletions  length repetition 
proportion symbols incur work   m  tends toward zero
repetition length approaches infinity 

   behavior practice
give idea sequitur behaves realistic sequences  turn artificial cases
sequence english text  figure  a plots number rules grammar number
input symbols         character english novel  shows increase
approximately linear  figure  b shows approximately linear growth total number
symbols grammar  growth number unique words text  shown
figure  c  high start drops toward end  zobel  et al         observed
much larger samples english text thatsurprisinglynew words continue appear fairly
constant rate  corresponding neologisms names  acronyms  typographical
errors  example  number rules grows linearly because  words
recognized  multi word phrases constructed  number phrases unbounded 

  

fii nferring sequential structure sequences

nearly linear growth number symbols grammar seems disappointing 
fact inevitable consequence information content english  since symbols end
text convey similar amount information symbols beginning  lower
bound achievable compression rate  english text  corresponds entropy
english 
equitur operates quicklyas shown figure  d          character novel
processed    seconds  rate        symbols per second    mb per minute  figure
illustrates sequiturs linear time behavior practice  sequence figure  b 
repetitions exist rules formed  fast process  indeed processed
rate         symbols per secondthree times faster novel  sequence figure  f 
consists multiple repetitions multi symbol sequence  slows performance       
symbols per seconda ten fold decrease fastest sequence  sequence figure  c 
consists many repetitions single character forms concise grammar  comes
       symbols per second  novel  measurements performed
silicon graphics indigo   
equitur effective data compression scheme outperforms schemes
achieve compression factoring repetition  approaches performance schemes


b

      

symbols grammar

rules grammar

     

     

     

      

      

     

 

 
 

c

      

             
input symbols

      



     

    

      

             
input symbols

      

 

      

             
input symbols

      

  

time  seconds 

vocabulary size

     

 

  

 

 

 
 

      

             
input symbols

      

figure   growth rates english text   a  rules grammar   b  symbols
grammar   c  vocabulary size input   d  time

  

finevill manning   witten

compress based probabilistic predictions  sequiturs implementation evaluation
compression scheme described nevill manning witten        

   related work
mentioned introduction  research resembles work wolff        
described sequitur  possible contrast wolffs system  mk    processes
sequence left right  forms chunk  equivalent sequitur rule  whenever
digram seen    times  happens  occurrences digram replaced
non terminal symbol  system either carries sequence  restarts
beginning  either case  digram frequencies discarded process starts over  worst
case algorithm corresponds sequence figure  f  long exact
repetitions  symbol repeated segment gives rise chunk  process starts
over  figure  f  length repetition linear length sequence 
number restarts length repetition  algorithm quadratic length
sequence  makes processing million symbol sequences impractical 
number systems  langley         stolcke omohundro         cook et al 
        form new grammar rules repeated sequences  merge rules generalize
grammars  however  operate different domainas input  expect set sentences
drawn language  rather single long sequence  allows make inferences
based directly comparing corresponding parts different sequences  furthermore  small
size training data means efficiency lesser concern  performance
algorithms measured ability accept test sentences language  reject
new sentences target languages  sequiturs case  one
sequence available  metric apply 
vanlehn ball        infer grammars sets sentences  algorithm
enforces three constraints grammars purpose making version space finite 
are      rule empty right side      rule one symbol right side 
symbol terminal      every non terminal appears derivation string 
constraints reminiscent sequitursfor example  third constraint weaker form
sequiturs rule utilitybut serve different purpose  sequitur  operational 
drive formation grammar  vanlehn balls work  make version space
tractable providing sensible restrictions form grammar  algorithm
search space 

   conclusion
paper presented equitur   algorithm identifying hierarchical structure
sequences  based idea abstracting subsequences occur rules
continuing operation recursively  algorithm works maintaining two constraints 
every digram grammar must unique  every rule must used once 
equitur operates incrementally and  subject caveat register model
computation used  linear space time  efficiency permitted application long
sequencesup    mbytein many different domains 
evaluated prediction accuracy equitur paper  evaluating
prediction accuracy fairly complex business  adequate simply give count
  

fii nferring sequential structure sequences

correct versus incorrect predictions  begs question likelihood
different ones occurring  prediction schemes assign probabilities predictions
might offer  judged discrepancy probabilistic predictions
true upcoming symbols  whole question accurate probabilistic prediction sequences
tantamount compression sequences  substantial field right  bell et al  
       fact evaluated sequiturs performance compression found vies
best compression algorithms  particularly large amount text available
 nevill manning witten         point present paper different one 
sequitur re represents sequence way exposes underlying structure  fair say
compression algorithm produces representation way perspicuous 
perhaps greatest drawback sequitur algorithm memory usage 
linear size grammar  linear memory complexity ordinarily considered intractable 
although practice equitur works well sequences rather impressive size 
clearly room approximate versions algorithm partition input re merge
grammars formed them  could perhaps applied recursively create algorithm
logarithmic memory requirements  conjecture  however  approximations
doubt turn useful practice  inevitably sacrifice property
digram uniqueness appealing feature original algorithm 

acknowledgments
grateful many detailed suggestions pat langley anonymous referees 

references
andreae  j h         thinking teachable machine  london  academic press 
angluin  d         inference reversible languages  journal association computing
machinery             
bell  t c   cleary  j g   witten  i h         text compression  englewood cliffs  nj 
prentice hall 
berwick  r c   pilato  s         learning syntax automata induction  machine learning 
       
cohen  a   ivry  r i   keele  s w         attention structure sequence learning 
journal experimental psychology              
cook  c m   rosenfeld  a     aronson  a          grammatical inference hill climbing 
informational sciences            
cypher  a   editor        watch do  programming demonstration  cambridge 
massachusetts  mit press 
gaines  b r         behaviour structure transformations uncertainty  international journal
man machine studies            
gold  m         language identification limit  information control             
johansson  s   leech  g   goodluck  h         manual information accompany
lancaster oslo bergen corpus british english  use digital computers 
oslo  department english  university oslo 

  

finevill manning   witten

knuth  d e         art computer programming    fundamental algorithms  addisonwesley 
laird  p    saul  r         discrete sequence prediction applications  machine learning
         
langley  p          simplicity representation change grammar induction  unpublished
manuscript  robotics laboratory  computer science department  stanford university 
stanford  ca 
nevill manning  c g    witten  i h  compression explanation using hierarchical grammars 
computer journal  press 
nevill manning  c g         inferring sequential structure  ph d  thesis  department
computer science  university waikato  new zealand 
nevill manning  c g   witten  i h    paynter  g w         browsing digital libraries 
phrase based approach  proc  second acm international conference digital
libraries          philadelphia  pa 
rabiner  l r  juang  b h         introduction hidden markov models  ieee assp
magazine            
stolcke  a     omohundro  s          inducing probabilistic grammars bayesian model
merging  proc  second international conference grammatical inference
applications          alicante  spain  springer verlag 
vanlehn  k     ball  w          version space approach learning context free grammars 
machine learning          
wharton  r  m          grammar enumeration inference  information control             

wolff  j g         algorithm segmentation artificial language analogue  british
journal psychology           
wolff  j g         discovery segments natural language  british journal psychology 
          
wolff  j g         language acquisition discovery phrase structure  language
speech                
wolff  j g         language acquisition  data compression generalization  language
communication             

  


