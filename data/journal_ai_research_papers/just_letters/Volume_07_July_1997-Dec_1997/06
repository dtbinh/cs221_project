journal artificial intelligence research                 

submitted       published      

storing indexing plan derivations
explanation based analysis retrieval failures
laurie h  ihrig
subbarao kambhampati

department computer science engineering
arizona state university
tempe  az           

ihrig asu edu
rao asu edu

abstract

case based planning  cbp  provides way scaling domain independent planning
solve large problems complex domains  replaces detailed lengthy search
solution retrieval adaptation previous planning experiences  general  cbp demonstrated improve performance generative  from scratch 
planning  however  performance improvements provides dependent adequate
judgements problem similarity  particular  although cbp may substantially reduce planning effort overall  subject mis retrieval problem  success cbp
depends retrieval errors relatively rare  paper describes design
implementation replay framework case based planner dersnlp ebl  dersnlp ebl extends current cbp methodology incorporating explanation based learning
techniques allow explain learn retrieval failures encounters 
techniques used refine judgements case similarity response feedback
wrong decision made  failure analysis used building case
library  addition repairing cases  large problems split stored
single goal subproblems  multi goal problems stored smaller cases fail
merged full solution  empirical evaluation approach demonstrates
advantage learning experienced retrieval failure 

   introduction
case based planning improves eciency plan generation taking advantage previous problem solving experiences  shown effective method scaling
domain independent planning solve large problems complex domains  kambhampati   hendler        veloso         cbp involves storing information particular
planning episodes problems successfully solved  information may include
goals achieved  world state conditions found relevant
achievement  final plan decisions taken arriving
plan  whenever new problem encountered  judgment made similarity
previous experiences  similar cases reused extended search
solution new problem  example  previous plan may transformed
skeletal plan refined new solution  friedland   iwasaki       
kambhampati   hendler        hanks   weld         multiple cases  corresponding
small subproblem  may combined extended solving single larger problem
 redmond        ram   francis         alternatively  plan derivations may replayed
c      ai access foundation morgan kaufmann publishers  rights reserved 

fiihrig   kambhampati

provide guidance new search process  veloso        ihrig   kambhampati      a  
cbp improves problem solving problems solved less time comparison
generative planning 
one challenging tasks cbp determining cases store
match cases new problem solving context  complex domain  unlikely
problem seen once  moreover  every problem solved
stored  library large cost associated retrieval may overshadow
gains provides  koehler        francis   ram         ultimately  would
retain library minimum number cases new problems
solved ecient retrieval adaptation cases stored  smyth  
keane         however  complex domains  planner s theory problem similarity
incomplete  barletta   mark         information relevant
features new situation determine stored case applicable  sometimes
new problem contain extra goals and or changed initial state conditions 
changes may mean solution cannot found consistent earlier
planning decisions made stored episode  planner cannot predict ahead time
previous choices wrong current situation  experience retrieval
error 
paper  introduce dersnlp ebl  derivational systematic nonlinear planner
  explanation based learning   cbp system priar  kambhampati   hendler 
      spa  hanks   weld        based sound complete domain independent
planner  dersnlp ebl deals mis retrieval problem allowing planner
learn planning failures may anticipate future errors  failure explanations
automatically generated search process used extending case
new problem solving situation  used building case library
addition repairing cases 
although earlier systems chef  hammond        exploited ebl techniques  use restricted reasoning correctness plans generated
case based planner  contrast  dersnlp ebl starts sound complete plan
synthesis strategy  emphasis improving performance base level
planner guidance retrieved cases  guidance considered succeed
leads planner search path leading solution new problem 
retrieval error occurs planner directed wrong path search
solution  is  path lead solution  dersnlp ebl extends current
cbp methodology ebl techniques employed automatic generation reasons retrieval failure  analytical failures occur leaf nodes
search tree explained terms subsets con icting plan constraints  leaf
node failure explanations regressed failing search paths form reason
retrieval failure 
dersnlp ebl builds indexes case library based failure analysis 
failure reason used construction new repairing case  example  retrieved
case fails due presence extra interacting goal covered retrieved
episodes  explanation failure formed identifies subset new input
goals negatively interacting  failure reason used construct new case
solves goals alone  failure analysis employed refining
   

fistoring indexing plan derivations

retriever

library

cases problem

planning
problem

storer

plan derivation
case failure reason

case based planner
replay extension recovery 

problem
solution

domain operators

figure    schematic diagram illustrating approach dersnlp ebl 
indexing case library censor retrieval failing case whenever
interacting goals present again  direct retriever new repairing case
avoids failure 
dersnlp ebl s failure based storage strategy limits size case library  library
size reduced splitting problems single goal subproblems  storing separately  large problems solved retrieval adaptation multiple
instances smaller cases  multi goal problems stored retrieved
cases fail merged extended full solution  describe empirical studies
demonstrate substantial improvements performance novel approach
multi case adaptation 
remainder paper organized follows  section   describes dersnlp ebl learns case failure improve case retrieval  reports
preliminary experiments testing learning component  section   provides ecient techniques used store  retrieve adapt multiple cases  describes experiments test
dersnlp ebl s method plan merging  section   describes evaluation full dersnlp ebl system solving large problems drawn complex domain  section  
relates work previous case based planners  including chef prodigy analogy 
section   provides summary 

   learning case failure
stated earlier  dersnlp ebl based complete correct domain independent
planning strategy  priar  kambhampati   hendler        spa  hanks   weld 
       implemented partial order planner  aspect differs statespace systems prodigy analogy  veloso   carbonell      a  veloso       
paris  bergmann   wilke         prodigy analogy  employs case adaptation
strategy  derivational replay stores planning experience form successful plan
derivations  previous decisions made earlier planning episodes become instructions
guide search process solving new problem  derivational replay includes
following elements  illustrated figure    veloso        veloso   carbonell      a  
facility within underlying planner generate trace derivation plan 
   

fiihrig   kambhampati

null
plan

skeletal
plan
e 

final
plan

x
e  x e  x
                                       depth limit
x

figure    multiple derivation traces  each sequence decisions shown figure
rectangles  used guide new search process  figure  solution
could reached backtracking skeletal plan  lies
outside new plan derivation  shown filled circles  
indexing storage derivation trace library previous cases  retrieval
multiple cases preparation solving new problem  finally  replay mechanism
planner employs retrieved plan derivations sequence instructions
guide new search process 
dersnlp ebl s methodology depends aspects common molgen
 friedland   iwasaki        priar  kambhampati   hendler         requires
eager case adaptation strategy  skeletal plan constructed contains
constraints added advice retrieved cases  constraints 
separate failure resulting previous guidance subsequent
planning effort  eager case adaptation  planning decisions encapsulated
retrieved cases greedily adopted decisions extended solve
extra goals covered  multiple retrieved plan derivations replayed sequence
produce skeletal plan contains recommended plan constraints 
planner returns from scratch planning previous decisions
retrieved cases visited  skeletal plan refined achieve
goals left open  previous work demonstrated effectiveness approach
plan space replay well advantage state space replay  ihrig   kambhampati 
    a      b  
eager case adaptation described extension first  skeletal plan
first extended search solution  and  extension fails  plan
backtracked over  discarding plan constraints added advice previous
episodes  general approach case adaptation therefore involves three distinct phases 
case replay  case extension  and  extension fails  recovery  search process
employed extending skeletal plan  planner constructs explanation
plan s failure becomes reason case retrieval failure  explanations formed
analytical failures occur leaf nodes directly skeletal plan  see
figure     analytical failure explained set inconsistent plan constraints 
failure explanations immediately regressed search paths encountered 
regressed explanations collected root tree form reason
   

fistoring indexing plan derivations

l 

l 

ob 

ld

ld

lp

lp

l 

ob 

l 

 b  new problem extra
goal

 a  previous plan

figure     a  plan accomplish transport single package  ob   destination
airport ld    b  new problem contains extra goal involves additional
transport ld second package  ob  
retrieval error  dersnlp ebl detects retrieval error occurred ways
refining skeletal plan tried  planner forced backtrack
plan  point failure reason fully constructed  performing skeletal plan
extension separate process prior recovery allows planner identify retrieval
error terms failure skeletal plan  construct reason failure 
reason communicated storer used augmenting library
new repairing case 
consider simple example illustrated figure   taken logistics
transportation domain shown figure    goal package ob  located
destination location ld  package initially location l    plane located
lp used transport package  figure  a illustrates previous plan
contains steps determine plane s route destination airport well steps
accomplish loading package right place along route  eagerly
replaying earlier step addition decisions new problem extra
package transport produces skeletal plan may readily extended include
loading unloading extra package long package lies along
route  however  new package old route  planner may able
solve extra goal without backtracking previous step addition decisions 
 see figure  b  
case failure reason shown figure    gives conditions future
replay case result failure  conditions refer presence
new problem set  c   negatively interacting goals  well initial state
conditions  contained e   summary information content failure reason is 
extra package transport destination location  package
destination location  inside plane  located plane s
route 
   

fiihrig   kambhampati

action
precond
add
delete

 load truck  o  t  l 
 at ob  o  l 
 at tr  t  l 
 inside tr  o  t 
 at ob  o  l 

action
precond
add
delete

 load plane  o  p  l 
 at ob  o  l 
 at pl  p  l 
 inside pl  o  p 
 at ob  o  l 

action
precond
add
delete

 unload truck  o  t  l 
 inside tr  o  t 
 at tr  t  l 
 at ob  o  l 
 inside tr  o  t 

action
precond
add
delete

 unload plane  o  p  li 
 inside pl  o  a 
 at pl  p  li 
 at ob  o  li 
 inside pl  o  a 

action
precond
add
delete
equals

 drive truck  t  li  lg 
 at tr  t  li 
 same city  li  lg 
 at tr  t  lg 
 at tr  t  li 
 not   li  lg  

action
precond
add
delete
equals

 fly plane  p  li  lg 
 is a airport  lg 
 at pl  p  li  
 at pl  p  lg 
 at pl  p  li 
 not   li  lg  

figure    specification logistics transportation domain adapted experiments
subsequent backtracking skeletal plan  planner continues search 
go find solution full problem one exists  new solution achieves
negatively interacting goals identified failure reason  moreover  since
goals represent subset problem goals  new derivation may used construct
case covering goals alone  dersnlp ebl stores new case directly beneath
failing case censor retrieval  ensure whenever failure reason
holds  for example  whenever extra package plane s route  
retriever directed away failing case toward case repairs failure 
position describe detail dersnlp ebl s eager derivation
replay strategy  well learns reasons underlying case failure 

    eager derivation replay

derivation trace contains sequence instructions representing choices lie
along derivation path leading root search tree final plan leaf
node  trace fitted context new search process validating choice
new context  replaying decision valid  order understand validation
process  must first describe decision steps planner takes arriving
solution planning problem  planning problem   tuple hi  g  ai 
complete description initial state  g description goal state 
set operators strips representation  fikes   nilsson         ground operator
sequence said solution planning problem executed initial
state  resulting state world satisfies goal 
dersnlp ebl refinement planner solves planning problem navigating
space potential solutions  represented partly constructed plan    syntactically 
   formal development refinement search semantics partial plans  refer reader
work kambhampati  knoblock  yang        

   

fistoring indexing plan derivations

case failure explanation 
c   f h at ob ob  ld   tg i  h at ob ob  ld   tg g
e   f hti     at ob ob  ld i  hti     inside pl ob   pl  i 
hti     at ob ob  l  i  hti     at ob ob  lp i g

figure    example case failure reason
plan space p seen set constraints  see below   semantically  partial
plan shorthand notation set ground operator sequences consistent
constraints  latter called candidate set partial plan  denoted
hhpii  particular  partial plan represented   tuple  hs   o  b  l  e   ci 
   set actions  step names  plan  mapped onto
operator domain theory  contains two dummy steps  ti whose effects
initial state conditions  tg whose preconditions input goals  g 
   b set codesignation  binding  non codesignation  prohibited binding  constraints variables appearing preconditions post conditions
operators represented plan steps   
   partial ordering relation   representing ordering constraints
steps  
   l set causal links form hs  p  s  s  s     
   e contains step effects  represented hs  ei     
   c set open conditions partial plan  tuple hp  si
p precondition step link supporting p l 
planning consists starting null plan  denoted p     whose candidate set
corresponds possible ground operator sequences  successively refining plan
adding constraints solution reached  planning decision represents choice
resolve existing aw plan  either open condition  unachieved
goal  threat causal link  understand choices validated
replay process useful think planning decision operator acting
partly constructed plan  possible choices available dersnlp ebl shown
figure   
planning decisions preconditions based existence aw
current active plan effects alter constraints eliminate
aw  example  precondition establishment choice specified terms
existence unachieved subgoal  effect addition causal link achieves
open condition  precondition resolution decision threat one step
clobbering existing causal link  threat resolved adding step ordering
either promotes demotes clobberer relative causal link 
   

fiihrig   kambhampati

type   establishment
kind   new step
preconditions
 
hp    s    c
effects
 
       fsg  
o      fs g  
b     b   unify p   p  
l   l   fhs  p s ig
e    e   effects
 s 
c   c   fhp    s  ig
  preconditions s 

type   establishment
kind   new link
preconditions
 
hp    s    c
effects
 
o       fs s  g  
b     b   unify p   p  
l    l   fhs p 
ig
c   c   fhp    s  ig

type   resolution
kind   promotion
preconditions
 
 
 

hs  p     l
ht   p   e
ft sg  fs tg   
effects  
    ft sg
 

 

 

type   resolution
kind   demotion
preconditions
 
 
 

hs  p     l
ht   p   e
ft sg  fs tg   
effects  
    fs tg
 

 

 

 

figure    planning decisions based active plan hs   o  b  l  e   ci effects alter constraints produce new current active plan
hs     o    b    l    e     c   i 
decision replayed  first compared current active plan determine whether precondition holds new context  invalid decisions  whose
preconditions don t match  skipped  establishment decisions ignored goals
achieve present open conditions current active plan  threat resolutions skipped threat present  previous choices justified
current situation used guidance direct new search process  replaying valid
decision involves selecting match decision children current active
plan  making child next plan refinement 
dersnlp ebl s eager derivation replay strategy replays applicable decisions
trace sequence  replay strategy contrasted
prodigy analogy  veloso        replay alternated from scratch planning
extra goals covered case  eager derivation replay previous decision
eagerly adopted justified current context  since invalid instructions
skipped  skeletal plan end result replay comparable product
fitting phase plan reuse  kambhampati   hendler        hanks   weld        
contrast plan reuse  derivation replay alter underlying planning strategy 
replay merely provides search control  directing search node visit next 
means dersnlp ebl inherits properties snlp  including soundness 
completeness  systematicity 
sample trace snlp s decision process shown figure    trace corresponds
simple problem logistics transportation domain  veloso        adapted
snlp figure    problem contains goal getting single package  ob  
designated airport  ld   derivation trace contains choices made along
path root search tree final plan leaf node  instructions contain
description decision taken basis justification new context 

    eager case extension recovery
decisions trace skipped replay known
priori unjustified  guarantee skeletal plan left
   

fistoring indexing plan derivations

goal    at ob ob  ld  
initial     is a airport ld    is a airport li   
 is a airport lp    at pl pl  lp  
 at ob ob  li      
name   g 
name   g 
type   start node
type   establishment
name   g 
kind   new link
type   establishment
new link      is a airport ld     
kind   new step
open cond    is a airport ld     
new step   unload pl ob   p  ld  
name   g 
new link      at ob ob  ld   goal 
type   establishment
open cond    at ob ob  ld   goal 
kind   new step
name   g 
new step   load pl ob  pl   a  
type   establishment
new link      inside pl ob  pl     
kind   new step
open cond    inside pl ob  pl     
new step   fly pl  p   a  ld  
name   g 
new link      at pl  p  ld     
type   establishment
open cond    at pl  p  ld     
kind   new link
name   g 
new link      at pl pl  li     
type   establishment
open cond    at pl pl   a     
kind   new step
name   g  
new step   fly pl  p   a   a  
type   resolution
new link      at pl  p   a     
kind   promotion
open cond    at pl  p   a     
unsafe link        at pl pl  li     
name   g 
effect       at pl pl  li   
type   establishment
name   g  
kind   new link
type   establishment
new link      at pl pl  lp     
kind   new link
open cond    at pl  p   a     
new link      at ob ob  li     
name   g 
open cond    at ob ob  li     
type   establishment
key abbreviations 
kind   new link
pl   plane
new link      is a airport li     
ob   object
open cond    is a airport  a     
final plan   fly pl pl  lp li   created  
 load pl ob  pl  li   created  
 fly pl pl  li ld   created  
 unload pl ob  pl  ld   created  
ordering steps                                           

figure    example solution trace dersnlp ebl

   

fiihrig   kambhampati

  dms    
 affi precond   fii  pff g add   fgig delete   fij jj   ig 
 afii precond   fii pfi g add   fgig delete   fij jj   ig 
 aff precond   fg add   fgff g delete   fpfi g   fgij ig 

figure    specification barrett weld s transformed dm  domain
ultimately refined solution current problem  without actually completing
search way predicting whether constraints left skeletal
plan consistent complete solution  whenever skeletal plan complete
 whenever extra goals unsatisfied initial state conditions  planner must
undergo planning effort extend plan possibility effort
may fail  necessitating recovery phase 
dersnlp ebl  skeletal plan extended first  prior recovery  plan
backtracked search process fails refine full solution new
problem  strategy requires depth limit placed search tree    otherwise
skeletal plan extension may continue indefinitely  planning algorithm becomes incomplete  eager extension strategy not  however  linked particular search method 
example  may used best first  depth first iterative deepening search 
different search methods used exploration subtree skeletal plan 
prior backtracking plan  skeletal plan found fail  recovery
phase initiated merely involves exploring siblings replayed path 
extension  recovery linked particular search strategy 

    analyzing failure case extension

order skeletal plan successfully extended achieve conditions left open 
sequence decisions adopted guidance previous trace must
concatenated choices arrive solution  occur  replayed
path must decision sequencable respect new problem  defined
follows 

definition    decision sequencable search path  search path contains sequence decisions decision sequencable respect new problem  hi     g    ai  
exist two decision sequences e e   e e    where   
decision sequencing operator  produce plan correct hi     g    ai 
one primary reasons replayed path may decision sequencable goal
interactions occur input goals new problem  particular  extra
goals achieved case may interact covered  making retrieved
case inapplicable  long recognized relative diculty problem solving
linked level interaction various input goals problem  korf 
      joslin   roach        barrett   weld        veloso   blythe        kambhampati 
   practice  limit actually bound placed number steps contained plan 

   

fistoring indexing plan derivations

ihrig    srivastava      a   goal interaction formalized korf        terms
problem search space  barrett weld        extend korf s analysis plan
space  plan space planner  order goals achieved crucial 
goals laboriously serializable state space planner  in exist goal
orderings goals may solved sequence  may trivially serializable
plan space planner  meaning goals solved order  
however  goals always trivially serializable plan space planner  veloso  
blythe         example  consider  dm   domain  barrett   weld        shown
figure    notice gff one set problem goals  true initially 
goal  gi   present set must achieved operator affi 
afii   means time case replayed previously solved goal  gi  
action afii   gff extra goal covered case  replay fail 
cbp  however  much concerned general properties
domain  properties particular search paths stored
case library  required input goals every problem trivially serializable
cbp beneficial planning performance  were  would
domains cbp effective  trivial serializability requirement since
necessary every plan every subset input goals consistent
solution full problem  particular plans retrieved
library concerned with 
even goals problem trivially serializable  replay may decision
sequencable  depending cases actually retrieved library 
  dm   domain  single goal cases retrieved solve gi action afii  
decision sequencable new multi goal problem contains
goal gff   however stored cases solved affi   replay cases
sequencable  fact  aim dersnlp ebl s learning component achieve
indexing within case library new problems encountered
planner may solved sequenced replay cases retrieved library 
next section describes dersnlp ebl able work towards objective
learning component learns replay failures 

    constructing reasons retrieval failure
dersnlp ebl constructs explanations retrieval failures use explanationbased learning techniques allow planner explain failures individual plans
planner s search space  leaf node plan represents analytical failure
contains set inconsistent constraints prevent plan refined
solution  analytical failure explained terms constraints  kambhampati  katukam    qu      b   leaf node failure explanations identify minimal set
constraints plan together inconsistent  dersnlp ebl forms explanations
analytical failures occur subtree directly skeletal plan 
regressed failing search paths collected root tree
form reason retrieval failure  see figure  a   regressed explanation terms
new problem specification  contains subset interacting goals  well initial
state conditions relevant goals 

   

fiihrig   kambhampati

null
plan

e  

   at ob ob  ld   tg  
 ti    at ob ob  ld    

e f  
df  
e f
df
e 

null
plan

   at ob ob  ld   tg  
 ti    at ob ob  ld   

skeletal
plan

df  
df

skeletal
plan

x

x
e 

x

e 

x

  ti    at ob ob  ld    tg  
  ti    at ob ob  ld   

 a  regression process

 b  detailed example

figure    path failure explanation root tree computed e     d      d    
 d f   e       
since plan failure explained subset constraints  failure explanations
represented manner plan itself  recall dersnlp ebl represents
plans   tuple  hs   o  b  l  e   ci  see section     explanation failure
occurring leaf node contains constraints contribute inconsistency 
inconsistencies appear new constraints added con ict existing
constraints  discussed section    dersnlp ebl makes two types decisions  establishment resolution  type decision may result plan failure  establishment
decision represents choice method achieving open condition  either
new existing step  adding causal link initial state  attempt
made achieve condition linking initial state effect  condition
satisfied initial state  plan contains contradiction  explanation
failure constructed identifies two con icting constraints 

h         fhti   p  sig  fhti    pig   i

precondition resolution decision threat causal link  dersnlp ebl
uses two methods resolving threat  promotion demotion  adds step
ordering plan  either decision adds ordering con icts existing
ordering  explanation failure identifies con ict 

h   fs s    s  sg            i

con icting constraints failure explanation regressed final
decision  results sorted according type form new regressed explanation 
process illustrated graphically figure  b  example  new link
initial state results failure  explanation  e  is 
h         fhti    at ob ob   ld    tg ig  fhti     at ob ob   ld ig   i
   

fistoring indexing plan derivations

e  regressed final decision  df   obtain new explanation  initial
state effect regresses itself  however  since link explanation added
decision  df   link regresses open condition precondition adding
link  new explanation  ef    therefore

h            fhti     at ob ob   ld ig  fh at ob ob   ld    tg igi

regression process continues failing path reaches root search
tree  paths subtree underneath skeletal plan failed 
failure reason root tree provides reason failure retrieved
cases  represents combined explanation path failures  case failure
reason contains aspects new problem responsible failure 
may contain subset problem goals  also  initial state effects
present leaf node explanation  present reason case failure   

    empirical evaluation utility case failure analysis

preliminary study conducted aim demonstrating advantage storing
retrieving cases basis experienced retrieval failure  domains chosen
randomly generated problems contained negatively interacting goals  planning
performance tested dersnlp ebl solving multi goal problems scratch
replay single cases covering smaller subset goals  replay performance
tested without case failure information 
      domains

experiments run problems drawn two domains  first artificial
domain    dms    originally described  barrett   weld        shown figure   
testing done problems randomly generated domain
restriction always contain goal gff   logistics transportation domain
 veloso        adopted second set experiments  eight packages one
airplane randomly distributed four cities  problem goals represented task
getting one packages single destination airport   fly operator augmented delete condition prevented planes visiting airport
once  meant replay failed extra package transported
previous route taken plane 
      retrieval strategy

cases initially retrieved basis static similarity metric takes
account goals covered case well relevant initial state
conditions  kambhampati        veloso         prior studies show reasonably
   dersnlp ebl s ebl component explains analytical failures  depth limit failures ignored 
means failure explanations formed sound case depth limit failure 
retriever may reject case applicable  rejecting applicable case may lead
storage duplicate cases larger library size  however  empirical work shown
practical importance reasons outlined section       
   comprehensive evaluation unbiased problem set see section   

   

fiihrig   kambhampati

effective metric  learning mode  cases retrieved basis  however 
mode  failure reasons attached case used censor retrieval 
time case retrieved learning mode  failure conditions
tested  failure reason satisfied new problem specification  retrieval
mechanism returned case replay  if  hand  failure reason found
true new problem context  case repaired failure retrieved 
following retrieval  problem solved replay retrieved case well
planning scratch 
      experimental setup

experiment consisted three phases  phase corresponding increase
problem size  goals randomly selected problem  and  case
logistics domain  initial state randomly varied problems  initial
training session took place start phase n     n goal problems solved
scratch  derivation trace stored library  following training 
testing session consisted generating problems manner additional
goal  time new  n     goal problem tried  attempt made retrieve
similar n goal problem library  testing session  case
similar new problem found previously failed  problem
solved learning  static from scratch modes  became part    problem
set  method  able evaluate improvements provided failurebased retrieval retrieval static metric alone ineffective  failure
conditions available 
      experimental results

results experiments shown tables      table entry represents
cumulative results obtained sequence    problems corresponding one phase
experiment  first row table   shows percentage problems correctly solved
within time limit      seconds   average solution length shown parentheses
logistics domain  solution length omitted   dms   since problems
generated within phase solution length   second third rows
table   contain respectively total number search nodes visited    test
problems  total cpu time  including case retrieval time  
results summarized figure     dersnlp ebl learning mode
able solve many multi goal problems two modes
substantially less time  case retrieval based case failure resulted performance
improvements increased problem size  comparable improvements
found retrieval based static similarity metric alone 
surprising since cases retrieved experienced least one earlier failure 
meant testing done cases likelihood failing retrieval
based static metric 
table   records three different measures ect effectiveness replay  first
percentage sequenced replay  recall replay trace considered
sequenced skeletal plan refined reach solution new problem 
   

fistoring indexing plan derivations

  dms  

static

scratch

learning

logistics
static

scratch

    
  
 

    
   
 

    
   
 

          
    
  

          
    
  

          
    
  

  solved
nodes
time sec 

    
   
 

    
   
  

    
   
 

          
    
   

          
     
   

          
     
   

  solved
nodes
time sec 

    
   
 

    
    
  

    
    
  

           
   
  

           
     
   

           
      
    

phase

learning

 solved
nodes
time sec 

    two goal

    three goal

    four goal

table    performance statistics   dms   logistics transportation domain  average
solution length shown parentheses next  solved logistics domain
only 

 a   dm  

 b  logistics

figure     replay performance   dms  and logistics transportation domain 
   

fiihrig   kambhampati

  dms  

logistics
learning
static

phase

learning

static

  seq
  der
  rep

    
   
    

  
  
  

   
   
   

   
   
   

  seq
  der
  rep

    
   
    

  
  
  

   
   
   

   
   
   

  seq
  der
  rep

    
   
    

  
  
  

    
   
    

   
   
   

two goal

three goal

four goal

table    measures effectiveness replay 
results point greater eciency replay learning mode    dm   domain 
replay entirely sequenced mode  transportation domain  retrieval based
failure always result sequenced replay  often static
mode 
greater effectiveness replay learning mode indicated two
measures contained subsequent two rows table    respectively  percentage plan refinements final derivation path formed guidance
replay    der   percentage total number plans created replay remain final derivation path    rep   case based planner learning
mode showed much greater improvements according measures  demonstrating relative effectiveness guiding retrieval learning component based
replay failures  results indicate dersnlp ebl s integration cbp ebl
promising approach extra interacting goals hinder success replay 
section   report thorough evaluation dersnlp ebl s learning component  conducted purpose investigating learning case failure
benefit planner solving random problems complex domain  evaluation implemented full case based planning system along novel case storage
adaptation strategies  next section  describe storage strategy
developed evaluation 

   improving case storage adaptation
aim case based planning eciently solve large problems complex domains 
complex domain means great variety problems encountered  problem size
 measured terms number goals  n  large  unlikely n goal
problem seen before  therefore advantage able store cases
covering smaller subsets goals  retrieve adapt multiple cases solving single
large problem 
   

fistoring indexing plan derivations

implementing strategy  decisions made goal combinations store  previous work within state space planning veloso        developed
approach reducing size library first transforming totally ordered plan
partially ordered graph  separating connected components graph  storing
subplans individually  goals interact respective plans must
interleaved order form complete solution stored together single case 
replay based plan space planner snlp  component subplan may
subdivided  since planner ability first piece plans together  later add step
orderings interleave subplans  kambhampati   chen        ihrig   kambhampati 
    a   replay smaller cases sequenced long individual subplans
may interleaved addition step orderings form full solution  plan space
planner therefore greater capability reducing size problems stored
library  and  consequence  number cases stored 
dersnlp ebl s storage strategy makes use plan space planners  ability piece
small plans together  add step orderings interleave plans  earlier approaches  priar  kambhampati   hendler         prodigy analogy  veloso 
      caplan  munoz avilla   weberskirch         cases stored cover
smaller subsets original set input goals achieved successful problem solving
episode  dersnlp ebl differs earlier approaches division goal
subsets based structure final plan alone  sequence events
making problem solving episode  new repairing case stored cases
retrieved library solving new problem fail extended new
solution  storer constructs new case based failure explanation obtained extension phase well new successful plan derivation obtained
recovery 
failure explanation identifies set negatively interacting goals responsible
failure  goals form subset input goals achieved new
solution  repairing case stored  new plan derivation stripped
decisions irrelevant achievement interacting goals  new case
covers negatively interacting goals 
note define negative interaction based failure skeletal plan 
interaction occurs set input goals cannot solved refining skeletal plan 
causing planner backtrack plan  moreover  cannot determine
whether two goals negatively interacting merely analyzing final solution 
include information planning failures encountered generating
solution  particular  final solution tell us whether additional goal
achieved extending replayed path  backtracking path  approaches
case storage determine goal interaction final plan alone  veloso       
munoz avilla   weberskirch        therefore ignore retrieval failures
encountered planning episode 
retrieval failures provide important guidance library may improved
avoid similar failures  dersnlp ebl  used dynamically improve storage
library addition new goal combinations  multi goal problems
stored retrieved cases corresponding single goal subproblems fail merged
   

fiihrig   kambhampati

case failure explanation 

c   fhgff  tg i  hg    tg ig
e   fhti   i  i  hti   pfi ig
figure     example case failure reason
extended new solution  repairing cases constructed achieve negatively
interacting goals responsible identified failure explanation 

    example negative interaction
figure    provides example explanation failure encountered solving
problem barrett weld s  dm   domain shown figure    problem contains
three goals  gff   g  g    attempted replay case solves
two goals  gff g    second case  achieves g    latter 
goal achieved action afi  represents incorrect operator choice
input goals problem include goal gff  
failure explanation shown figure    identifies subset interacting goals  made
g  gff   note interaction evident final plan shown figure    
plan  three input goals problem achieved connected
component  base storage solely plan graph represented successful plan 
three input goals stored single case  moreover  new problem
representing novel combination goals stored library  causing library
size increase exponentially problem size  example  suppose domain includes
goals  fgi j      ng gff   number problems size three
number   goal subsets n     goals  dersnlp ebl s strategy storing cases
based explanations retrieval failure result maximum  n     cases stored 
goal fgi j      ng appears two cases  one representing single goal problem
one representing two goal problem achieves gff  
storing negatively interacting goals multi goal problems may therefore result
substantial reduction size case library  represents tradeoff 
replayed cases must extended from scratch planning solve con icts
individual plans recommended separate cases  moreover  complex domains 
may goals interact positively may solved common
steps  ihrig   kambhampati        munoz avilla   weberskirch         goals
stored separate cases  replay may result unnecessary redundancy plan 
dersnlp ebl  positive interactions handled replay process itself 
merges subplans provided multiple cases  section     describe
merging accomplished  next section provides detail case storage
strategy implemented empirical study 
   

fistoring indexing plan derivations

ti

  

  

  

tg

figure     solution example problem 

    building case library
following deliberative strategy adopted building case library  new
problem contains n goals  first goal attempted  and  solved  case covering
goal alone stored library  problem solving continues increasing problem size
one goal time  example  problem attempted contained goal set 
g   hg    g         gi solved decision sequence di second decision
sequence  di     stored whenever di cannot replayed extended achieve next
goal gi     whenever replayed derivation path fails  recovery phase successful
producing new solution  explanation case retrieval failure used identify
subset negatively interacting input goals  n   hgj    gj  m i  responsible
failure  replayed path fails extended  backtracked reach solution
new problem  new successful derivation passed storer along
failure explanation  explanation used delete derivation decisions
relevant set negatively interacting goals  n   reduced derivation
stored library repairing case  alternatively  whenever next goal
set solved simple extension previous decision sequence  case
stored includes goal 
storage strategy entails two important properties      new case corresponds
either new single goal problem multi goal problem containing negatively interacting
goals      plan derivations arising single problem solving episode
different decision sequence stored library prefix another stored case 
case added library new problem solved extending
retrieved case  new cases stored previous decisions need
backtracked search new solution 
dersnlp ebl s strategy restricting multi goal cases goals
negatively interacting serves ameliorate mis retrieval problem  experience
planner problem solving  interactions discovered 
less likely planner backtrack replayed paths  aim
eventually library minimal number cases problems
encountered may achieved successfully merging multiple instances stored cases 
approach therefore retain cases based competence well performance
 smyth   keane        
      example dersnlp ebl s storage strategy

example multi goal problem stored  consider problem contained
figure    three packages  ob   ob  ob   transported
destination location  ld   initially goal set contains goal transporting ob  alone 
represented  at ob ob  ld    successful derivation stored case a 
second goal added set  since problem attempted achieves first
   

fiihrig   kambhampati

ob 



ob 

b
b

ld

b
lp

ob 

l 

figure     logistics transportation example illustrating multi case storage  figure
shows two plans produced two stored derivations  case achieves goal
single packages  ob   transported destination airport  ld   case
b achieves goal ob  ob  located airport 
goal decision sequence backtracked order solve
additional goal  second derivation  case b   stored  new derivation solves
mutually interacting goals   at ob ob  ld    at ob ob  ld    problem solving
continues addition third goal  goal solved simple extension
previous decision sequence  case stored includes goal  means
two cases stored library  case corresponding single goal problem
case b corresponding multi goal problem containing two negatively interacting goals 
multi goal problems stored problem goals mutually interacting 
is  individual derivations cannot sequenced extended solve
full problem 
dersnlp ebl s storage strategy  size library limited amount
interaction domain  example  negative interaction  single
goal cases stored  logistics transportation domain  potential
problem goals interact negatively  however  since significant percentage
non interacting goals  strategy reduces size library comparison one
multi goal problems successfully solved stored  storage
strategy represents tradeoff since effort must expended merging retrieved
cases full solution  see section      
      indexing basis replay failure

multi goal cases stored library censor retrieval corresponding
single goal subproblems  library organization differs earlier work stores
cases common fashion single level  first indexing case goals 
success conditions relevant goals  veloso        munoz avilla  
weberskirch         contrast  dersnlp ebl indexes cases discrimination
net similar one depicted figure     figure shows one fragment case
library includes cases solve single input goal  individual planning
episodes achieve goal represented one level lower net  labeled
   

fistoring indexing plan derivations

g 
input goals 

initial conditions 

 at ob ob  ld  
 at pl pl  lp 

 at ob ob  l  

g 

g 

derivation  
r 

failure reasons 

 at pl pl  lq 

derivation  
r 

g 

g 

derivation  

derivation  

figure     library fragment indexing stored cases solve single input goal   at ob
ob  ld   
relevant initial state conditions  otherwise known footprinted initial state  veloso 
       together  goal initial state conditions make static success conditions
cases first retrieved  one cases retrieved replay replay
fails  derivation corresponding extra interacting goals added library
indexed directly failing case  future retrievals case  failure
conditions checked see whether extra goals responsible failure present
conditions  so  retrieval process returns repairing case
achieves con icting goals  case failure reason thus used direct retrieval away
case repeat known failure  towards case avoids it 
one might question hierarchical organization instances failures due
interacting goals alone  store cases single level first indexing
case goals  conditions relevant goals  answer
lies need censor cases failure conditions satisfied  type error
found retrieving multiple cases  example  consider new problem
contains three goals  g    g  g    suppose goal g  negatively interacts
g  g    case retrieved library achieves g  g   
one goal  g    left open  however  case retrieved solves g  alone 
fail presence g    type retrieval error handled prioritizing
cases  repairing case stored subclass case failed  failing cases
annotated failure reason directs retriever case avoids
failure 
prioritizing cases basis negatively interacting goals alone sucient
capture retrieval failures may encountered  cases retrieved
basis partial match relevant initial state conditions  retrieval errors may
occur unmatched conditions  veloso         example  failure might
occur logistics transportation example extra package plane s
route  similar failure occur package moved plane s route  strategy
adopted deal types failure information annotate case
   

fiihrig   kambhampati

ob 

ob 



l 
ld

b b
b

b

b
lp

ob 

b

l 

figure     logistics transportation example illustrating multi case retrieval 
failure reason  whether extra goal unmatched initial state condition 
use failure reasons prioritize cases  ebl techniques employed
construction failure explanations may used types failures 
dersnlp ebl s method storing multi goal cases goals negatively interacting limits size case library  aspects dersnlp ebl s storage strategy
serve lower library size  planner always uses current library solving new
problems  new derivations stored applicable case 
retrieved cases fail  strategy avoids storage duplicate cases  may
entirely effective since soundness failure explanations guaranteed  failure
explanations sound  pointers repairing cases may eventually lead duplicate
case  causing library continue grow indefinitely  however  easily checked
putting depth limit number repairing cases discrimination net  also 
failures due interacting goals result unchecked growth library
since number interacting goals limited maximum problem size 
      detailed example case retrieval

example case retrieval illustrated figure     figure contains three subplans
corresponding two separate cases stored library  case achieves goal
single package  ob   located destination ld   case b achieves goal
ob  ob  located ld 
assume new problem attempted replay contains three
goals   at ob ob  ld    at ob ob  ld     at ob ob  ld    second goal negatively
interacts goals  retriever first attempt find case
solves first goal alone  case solves goal  however  case annotated
failure reason satisfied new problem situation  therefore censored
favor repairing case  case b   retriever returns case b  
one open goal covered  is   at ob ob  ld    seek case solves
goal alone  find case a  however  a s failure reason satisfied
new problem state rejected favor second copy b  which
call case b     solves problem transporting ob  ob  
two instances case b retrieved solve three goal problem 
case b case b     together cover new problem goals  dersnlp ebl replays
   

fistoring indexing plan derivations

figure     new linking opportunities indicated increase number siblings
step addition decision 
copies b sequence obtain solution full problem  thereby merging
respective subplans  notice  however  union plans contain redundant
steps  example  plans plane location l    section     describes
dersnlp ebl deals positive goal interactions 

    multi case merging

say two plans mergeable respect problem  hi    g    ai  exists
solution problem contains combined constraints 

definition    mergeability  plan p  achieving goal g  mergeable plan p 
goal g  respect problem  hi     g    ai   plan p   correct
hi    g    ai hhp  ii hhp ii hhp  ii   thus syntactically  p   contains constraints
p  p    

multi case replay accomplishes plan merging  may result lower quality plans
care taken avoid redundant step additions  ihrig   kambhampati        munozavilla   weberskirch         occur goals covered separate cases positively
interact may solved common steps  replaying case sequence
results unneeded steps plan   
multi case replay  open condition justification adding new step 
steps may added already exist plan due earlier replay another
case  first retrieved derivation replayed  none replayed step additions
result redundancy  however  subsequent goals solved replay
additional cases  step additions may unnecessary opportunities
linking open conditions achieve earlier established steps  planner
way determining priori steps may represented single step
plan   
dersnlp ebl s replay framework handles redundant step additions skipping
step addition establishments whenever open condition may achieved new link 
thus strengthens increases justification replaying step addition decisions
open condition longer basis validating decision  justification replay strengthened add condition new linking opportunities
   analogous decrease plan quality occurs state space plan reuse  sequencing macro operators
results state loops  minton      a  
   consider  example  domain plane may transport two packages one trip  not 
depending capacity 

   

fiihrig   kambhampati

dersnlp ebl

dersnlp ebl ij

             
    
    

              
    
    

replay
 solved
time sec 

scratch

replay

scratch

table    percentage problems solved  total cpu time seconds    problems
problems logistics transportation domain  average solution length
shown parentheses next  solved 
present  may detected increase number siblings prescribed
step addition choice  see figure      siblings stored step addition decision
recorded annotations derivation trace  new links available
contained within siblings  step addition decision skipped  replay 
alternative new links explored normal course plan refinement 
means step may eventually added new links fail 
increasing justification step addition decisions improves quality plans
terms number steps contain  example  case b b   would normally
produce subplans shown figure     cases replayed sequence
solving single problem  plans merged plane moves city
once  plan merging increasing justification replay accomplishes
retracting redundant action sequences  may cause planning failure  thus
deals action merging interactions defined  yang  nau    hendler        
next section describe empirical study testing effectiveness merging
strategy 
      empirical test dersnlp ebl s plan merging strategy

preliminary study conducted test effectiveness dersnlp ebl s method
plan merging replay  experiment compared dersnlp ebl
without increasing justification replay  experimental setup consisted training
dersnlp ebl set    randomly generated   goal training problems  testing
different set      goal test problems  initial state problem contained   
locations    post oces   airports     transport devices    planes   trucks  
training phase  planner solved problems stored successful plan derivations
case library  testing phase  planner retrieved multiple stored plan
derivations used guidance solving test problems  dersnlp ebl
tested    problems replay from scratch modes  replay either
 dersnlp ebl  without  dersnlp ebl ij  increased justification  results
shown table   
although overall performance poorer  quality plans terms number
steps improved dersnlp ebl s strategy increasing justification step addition  result suggests dersnlp ebl s method plan merging serves reduce
   

fistoring indexing plan derivations

redundancy plans produced multi case replay  recently  munoz avilla
weberskirch        tested non redundant merging strategy process planning domain found similar improvements plan size  next section describes
evaluation full dersnlp ebl system 

   experimental evaluation complete system

experiments reported section tested full dersnlp ebl system using
dynamic multi case storage retrieval strategy described section    aim
evaluate replay system complex domain  hypothesis performance
would improve problem solving experience negative interactions discovered
stored  addition  predicted dersnlp ebl s method storage would result
low library size low retrieval costs 
logistics transportation domain  veloso        become somewhat benchmark cbp literature  scaled version therefore chosen purpose 
tested large multi goal problems drawn domain shown figure   scaled
first      cities  size domain unusual current literature 

    experimental setup

experiment run phases  phase corresponding increase problem
size  thirty test problems size randomly generated  since possible
obtain truly random distribution within nonartificial domain  following strategy
adopted problem generation  first  initial state constructed fixing
number objects type contained domain description  example  first
experiment  six cities     locations within cities   six planes  six trucks 
initial state problem constructed first including filter conditions  nonachievable conditions   defined layout cities  example  condition  is a
airport ap   identified ap  airport  condition  same city ap  po   indicated
ap  po  located city  second  achievable  non filter  conditions present add clauses domain operators varied
problem choosing object constants randomly available restriction
two initial state conditions inconsistent  example  plane package
assigned single randomly chosen location  goals chosen among
achievable conditions manner  although attempt made create interacting goals  goal interaction common multi goal problems 
limit imposed number steps plan  meant multi goal problems often could solved concatenating subplans individual subgoals 
instances  planner could take advantage linking opportunities achieve multiple
goals common steps  meant often planner backtrack
derivation one goal order solve additional goal 
first experiment used   city domain run   phases  size
test problems  which ranged     goals  increased phase  prior
phase n experiment  case library emptied planner retrained
randomly generated problems size n  training problems solved attempting
single goal subproblems scratch  storing trace derivation solution
   

fiihrig   kambhampati

phase

 

  

 solved
time sec 

       
  

  solved
time sec 

logistics  best first

cpu limit     sec 
  
   

  

  

       
      

       
      

       
     

       
      

       
      

       
      

      
    

      
        

       
       

       
      

       
       

       
       

       
       

  solved
time sec 

      
    

      
      
      
              
                                                

       
        

  solved
time sec 

      
    

       
        

       
        

       
        

       
       

       
       

       
       

  solved
time sec 

  
     

       
       

       
       

       
       

       
       

                
              

  solved
time sec 

  
     

       
       

       
       

       
       

       
       

       
       

one goal

two goal

three goal

four goal

five goal

six goal

   

       
       

table    performance statistics logistics transportation domain  average solution
length shown parentheses next  solved  case retrieval time shown
parentheses next cpu time 
problem one already present library  successively adding extra
goal  multi goal problems stored retrieved cases used solving problem
failed  whenever problem could solved sequenced replay previous cases 
negatively interacting goals contained failure reason identified new
case achieving goals alone stored library  phase experiment 
planner tested    randomly generated test problems varying
amounts training  problems solved from scratch mode replay
multiple cases retrieved library constructed training 
second experiment tested planner complex    city domain employed stable case library formed dersnlp ebl trained        city    goal 
logistics transportation problems  library smaller problems used
planner tested larger     city  problems ranging      goals 

    experimental results

first experiment   city domain dersnlp ebl showed substantial improvements multi case replay evident results table    moreover  replay
performance improved problem solving experience  plans produced
showed slight increase number steps solutions obtained
from scratch mode  results plotted figure    graphs cumulative
cpu time test problems six experiments  figure illustrates cpu
time decreased number training problems solved  insert shows total cpu
   

fistoring indexing plan derivations

figure     replay performance logistics transportation domain increasing
amounts training  thirty problems tested problem size   
  goals   amount time needed solve test problems size
 including case retrieval time  shown problems solved scratch
 level    replay increasing levels training  after solving       
    randomly generated problems   insert shows amount time taken
solve test problems increasing amounts training  time limit
    seconds placed problem solving 

   

fiihrig   kambhampati

figure     replay performance logistics transportation domain scaled   
cities  case library formed     training problems    cities    goals 
solved  library used solving test sets containing larger
problems     cities       goals   none problems solved within
time limit      sec  from scratch mode  replay mode  average solution
length shown parentheses next problem size 

figure     replay performance logistics transportation  percentage test problems solved within time limit      sec  plotted number training
problems solved  percentage solved shown problems increasing size    
     goals  

   

fistoring indexing plan derivations

figure     figure shows size case library increased number training
problems solved  library size increases training problem size         
goals      shows number single goal subproblems contained   goal
training problems 
time  including case retrieval time  test problems six experiments 
evident insert  planning performance improves increased experience random
problems  however  relatively little experience     problems solved  enough show
significant performance improvements 
replay raised problem solving horizon  illustrated figure     effective
larger problem size  from scratch planning tends exceed time limit imposed
problem solving  figure    shows increase size library increasing
amounts training  figure indicates library size determined
amount interaction domain  opposed number training problems solved 
rate case library grows tapers higher planner trained
larger problems   
second experiment  library formed course training   goal problems
used solve larger problems       goals  complex domain     cities   see
figure      none larger problems solved from scratch mode within time
limit     sec     planner continued maximum time problems  indicated
figure linear increase cpu time  performance substantially better
replay  however  since library size relatively small  improvements planning
performance offset cost retrieving adapting previous cases  finding
suggests replay strategy employed experiments represents effective
method improving planning performance complex domains 
   opportunity interaction larger problems  example    goal problem could
contain   goals mutually interact  whereas   goal problem maximum   interacting goals 
   dersnlp ebl from scratch mode used best first strategy  replay  best first strategy biased
subtree replayed path explored first  siblings path 

   

fiihrig   kambhampati

action  put on  x  y  z 
precond  on  x  z 
 clear  x 
 clear  y 
add
 on  x  y 
 clear  z 
delete  on  x  z 
 clear  y 

action  new tower  x  z 
precond  on  x  z 
 clear  x 
add
delete

 on  x table 
 clear  z 
 on  x  z 

figure     specification blocks world domain adapted experiments 

    empirical comparison dersnlp ebl rule based ebl
case based planning explanation based learning offer two differing approaches improving performance planner  prior research  kambhampati        analyzed
tradeoffs  hybrid learning approach dersnlp ebl designed alleviate
drawbacks associated pure case based planning  rule based ebl  prior
work  ebl used construct generalized search control rules may
applied new problem solving situation  rules matched choice
point search process  dejong   mooney        minton      b  mostow   bhatnagar 
      kambhampati et al       b   approach known exhibit utility problem since
rule base grows rapidly increasing problem solving experience even small
number rules may result high total match cost  minton      b  tambe  newell   
rosenbloom        kambhampati        francis   ram         contrast  empirical
results discussed  see table    indicate dersnlp ebl low case retrieval
match cost 
demonstrate dersnlp ebl reduces match cost  conducted empirical study
compared performance ucpop ebl  rule based search control learning
framework  kambhampati et al       b   framework constructs reasons planning
failures manner similar dersnlp ebl  however  approach similar
minton      b  employs explanations construction search control
rules matched node search tree  planners tested
set problems ranging     goals randomly generated blocks
domain shown figure     testing performed set thirty problems
increasing amounts training 
illustrated figure     dersnlp ebl improved performance    training problems solved  ucpop ebl failed improve significantly  reason evident
ucpop ebl s match time  ucpop match  graphed figure     ucpop ebl 
time spent matching rules increases training  wiping improvements
may gained use rules  rules matched
choice point search tree  small number rules sucient substantially increase
total match cost 
   

fistoring indexing plan derivations

figure     total cpu time    blocks world problems increased amounts training 
possible improve performance rule based ebl reducing number
rules use utility monitoring strategies  gratch   dejong        
using sophisticated match algorithm  doorenbos         example  doorenbos
       employs improved rule matcher based rete algorithm  dersnlp ebl 
hand  aims alleviating utility problem reducing number times rules
matched  similar rule based ebl  learning component employed generate
rules  however  rules generated govern retrieval cases stored
library  compiled indexing structure  dersnlp ebl exhibits low
match cost applying retrieval rules one point search process  specifically 
retrieves cases start problem solving  case represents sequence
choices  a derivation path  thus providing global control opposed local  results
shown table   indicate cost retrieving cases significantly lower comparison
time spent problem solving 

   related work discussion
dersnlp ebl s storage strategy relies capability case based planner replay
multiple cases  covering small subset goals  add step orderings interleave respective plans  strategy differs earlier approaches priar
 kambhampati   hendler         prodigy analogy  veloso         paris  bergmann
  wilke         caplan  munoz avilla   weberskirch         division
goal subsets based structure final plan alone  sequence
events making problem solving episode  retrieval failures treated opportunity planner stores new repairing case  aspect similar
hammond s chef  hammond        learns improve retrieval strategy
based failures  despite surface similarity  important differences

   

fiihrig   kambhampati

transformational
priar
spa
mpa
plan space

state space
dersnlp

prodigy analogy
paris

derivational

figure     different approaches case based planning case adaptation accomplished underlying generative planner 
approach  dersnlp ebl learns case extension failures  whereas chef concentrates
learning execution failures  specifically  chef assumes incomplete domain model 
consisting stored cases  domain specific modification theory patches  given
new problem  chef retrieves previous case  modifies retrieved plan using domain
specific modification rules generate candidate solution current problem 
correctness solution tested respect external causal simulator
domain  solution found incorrect  explanation incorrectness  supplied
simulator  used modify case library censor retrieval case
similar situations future  effect improves correctness chef s domain
theory  contrast  dersnlp ebl assumes complete knowledge domain  form
domain operators  access sound complete plan synthesis strategy 
aim case based reasoning dersnlp ebl improve performance
base level planner  end  dersnlp ebl analyzes case extension failures predict
case cannot extended solve new problem 
fox leake        taken approach similar chef  use introspective reasoning explain failures find repairing cases  similar chef  introspective
reasoning used revise indexing case library  fox   leake        ram   cox 
       approaches employ domain specific techniques improve storage retrieval case library  munoz avilla   weberskirch        smyth   keane        
dersnlp ebl differs automatically generates new indices well defined
domain independent methodology  kambhampati et al       b  incorporated
underlying planning strategy 
since ebl employed explaining case failure well success  dersnlp ebl complements extends earlier approaches case retrieval  barletta   mark        kambhampati   hendler        hendler  stoffel    mulvehill        veloso        bergmann
  wilke        munoz avilla   weberskirch        ram   francis         although
   

fistoring indexing plan derivations

exhibits low retrieval match cost  cbp system  eciency may degrade larger domain size  dersnlp ebl s approach compatible others aimed
improving match cost  doorenbos        ram   francis        hendler et al         
example  mpa  ram   francis        built around retrieval engine performs
asynchronous memory retrieval  caper  hendler et al         uses structure matching
algorithm parallelizes process plan s success conditions represented
retrieval probe matched large knowledge base world facts  process
expands binary predicates match success conditions larger structure containing implicitly specified relations knowledge base  structure acts filter 
eliminating matches fail line probe 
dersnlp ebl similar case based systems employ complete correct
domain independent planner generate cases stored  hanks   weld        kambhampati   hendler        koehler        veloso        ram   francis         surveying
literature  possible distinguish approaches two orthogonal scales
shown figure     horizontal direction  cbp frameworks ranked
underlying planning strategy falls continuum whose end extremes represent
state space vs plan space dichotomy  towards state space end spectrum
prodigy analogy  employs means ends analysis  mea  planner  nolimit 
extend previous case  nolimit classed state space planner since applies
actions plan based current world state thereby advances world state 
priar framework  kambhampati   hendler        kambhampati        based
within nonlin  tate         nonlin creates plans hierarchical task reduction 
partial order  plan space  planner constructs plans protecting underlying causal structure  dersnlp ebl  extends case normal course
plan refinement defined underlying plan space strategy  however  dersnlp ebl
implemented within partial order  causal link planner  snlp  mcallester   rosenblitt 
      barrett   weld         aspect similar spa system developed
hanks weld        
different cbp systems may distinguished according case adaptation strategy  roughly categorized either transformational derivational
 carbonell        veloso   carbonell      b   according whether transform previous plan replay previous plan derivation  transformational strategies priar
spa  final plan product planning episode stored case
library  case retrieved plan fitted adapt new problem solving situation retracting irrelevant redundant subparts  early cbp systems  carbonell 
      hammond        employ transformational techniques adapt previous solution  causal link planners snlp ready made plan reuse since causal
structure employed plan adaptation part plan itself  priar spa
use plan s causal structure fitting plan new problem context 
extending fitted plan solve new problem  priar differs spa
employs extension first strategy  skeletal plan first refined addition
plan constraints undertaking retraction constraints  spa 
hand  alternates retraction plan constraints addition
new constraints  mpa  ram   francis        extends spa s transformational strategy
accomplish multi case retrieval adaptation 
   

fiihrig   kambhampati

mentioned earlier  derivational analogy case based planning technique
introduced carbonell  veloso   carbonell      b   model developed
veloso prodigy analogy  veloso         employed case fitting strategy called
derivational replay  case fitting based replay similar fitting plan reuse 
based plan s underlying causal structure  justification planning
decision stored derivation trace ects causal dependencies plan
steps  justified choices replayed solving new problem  replay thus serves
purpose retraction plan reuse  replay may advantage multi case
reuse since allows planner readily merge small subplans solve large problems 
dersnlp contrasted prodigy analogy employs case fitting
methodology called eager derivation replay  ihrig   kambhampati      a        
replay strategy  applicable cases replayed sequence returning fromscratch planning  eager replay simplifies replay process avoiding decision
alternate replay multiple cases  effectiveness approach dependent
underlying plan space planning strategy  ihrig   kambhampati      a   dersnlp s
eager case adaptation strategy allows case failure defined terms failure
single node search tree  particular  case failure defined failure
skeletal plan  contains constraints adopted advice
previous cases  eager case adaptation means explanations case failure may
constructed use ebl techniques developed explain
analytical failures occurring planner s search space 

   summary conclusion
paper described design implementation case based planner 
dersnlp ebl  dersnlp ebl framework represents integration eager case adaptation failure based ebl  ebl techniques employed building case library
basis experienced retrieval failures  approach improves earlier treatments case retrieval  barletta   mark        kambhampati   hendler        ihrig  
kambhampati      a  veloso   carbonell      a   partial order case based planner 
dersnlp ability solve large problems retrieving multiple instances smaller
subproblems merging cases sequenced replay  ihrig   kambhampati 
    a   dersnlp ebl framework extends approach use new ebl
techniques employed construction case library  techniques
used explain plan merging failure identify set negatively interacting goals 
library augmented new repairing case covering interacting goals 
dersnlp ebl s method storing multi goal cases goals negatively interacting results small library size low retrieval costs  however  multi case adaptation
involves tradeoff since effort expended merging multiple instances stored cases 
dersnlp ebl accomplishes merging increasing justification replay step addition decisions  strategy avoids addition redundant steps goals positively
interact  dersnlp ebl therefore aimed domains logistics transportation
domain significant amount positive interaction  aimed domains
negative interaction  course futile spend effort explaining case
failure none encountered 
   

fistoring indexing plan derivations

section   describes evaluation overall eciency storage retrieval
strategy solving large problems complex domain  dersnlp ebl shows improvement planning performance offsets added cost entailed
retrieving failure conditions  amount improvement provided replay shown
experiments seen lower bound since random problem distribution
may mean less problem similarity found real world problems 
conclusion  paper described novel approach integrating explanationbased learning techniques case based planning  approach aimed issues
associated pure case based planning  rule based ebl  particular 
addresses mis retrieval problem cbp  well utility problem  results
demonstrate eager case adaptation combined dersnlp ebl s dynamic case
retrieval effective method improving planning performance 

acknowledgements
authors wish thank amol d  mali  eric lambrecht  eric parker  anonymous
reviewers helpful comments earlier versions paper  thanks due
terry zimmerman providing insight ucpop ebl  research supported
part nsf research initiation award iri          nsf young investigator award
iri          arpa planning initiative grants f         c       phase ii 
f         c       phase iii  

references

barletta  r     mark  w          explanation based indexing cases  proceedings
aaai    
barrett  a     weld  d          partial order planning  evaluating possible eciency gains 
artificial intelligence             
bergmann  r     wilke  w          building refining abstract planning cases change
representation language   journal artificial intelligence research            
carbonell  j          learning analogy  formulating generalizing plans past
experience  michalski  r   carbonell  j     mitchell  t   eds    machine learning 
artificial intelligence approach  vol     palo alto  ca  tioga press 
dejong  g     mooney  r          explanation based learning  alternative view  machine learning                 
doorenbos  r          production matching large learning systems  ph d  thesis 
computer science department  carnegie mellon university 
fikes  r     nilsson  n          new approach application theorem proving
problem solving  artificial intelligence             
fox  s     leake  d          using introspective reasoning refine indexing  proceedings
ijcai    
   

fiihrig   kambhampati

francis  a     ram  s          comparative utility analysis case based reasoning
control rule learning systems  proceedings  th european conference
machine learning  ecml    
friedland  p     iwasaki  y          concept implementation skeletal plans 
journal automated reasoning                 
gratch  j     dejong  g          composer  probabilistic solution utility problem
speed up learning  proceedings aaai    
hammond  k          explaining repairing plans fail  artificial intelligence     
        
hanks  s     weld  d          domain independent algorithm plan adaptation  journal
artificial intelligence research             
hendler  j   stoffel  k     mulvehill  a          high performance support case based
planning applications  technological achievements arpa rome laboratory
planning initiative  advanced planning technology  aaai press 
ihrig  l     kambhampati  s       a   derivation replay partial order planning 
proceedings aaai    
ihrig  l     kambhampati  s       b   plan space vs state space planning reuse
replay  tech  rep          department computer science engineering  arizona
state university  available http   rakaposhi eas asu edu yochan html 
ihrig  l     kambhampati  s          design implementation replay framework
based partial order planner  proceedings aaai    
joslin  d     roach  j          theoretical analysis conjunctive goal problems  artificial
intelligence             
kambhampati  s          utility tradeoffs incremental modification reuse plans 
proceedings aaai spring symposium computational considerations supporting
incremental modification reuse 
kambhampati  s          exploiting causal structure control retrieval refitting
plan reuse  computational intelligence     
kambhampati  s     chen  j          relative utility ebg based plan reuse partial ordering vs total ordering planning  proceedings aaai     pp           washington 
d c 
kambhampati  s     hendler  j  a          validation structure based theory plan
modification reuse  artificial intelligence              
kambhampati  s   ihrig  l     srivastava  b       a   candidate set based analysis
subgoal interactions conjunctive goal planning  proceedings  rd intl  conf 
ai planning systems 
   

fistoring indexing plan derivations

kambhampati  s   katukam  s     qu  y       b   failure driven dynamic search control
partial order planners  explanation based approach  artificial intelligence     
        
kambhampati  s   knoblock  c     yang  q          planning refinement search 
unified framework evaluating design tradeoffs partial order planning  artificial
intelligence              
koehler  j          avoiding pitfalls case based planning  proceedings  nd intl 
conf  ai planning systems 
korf  r          planning search  qualitative approach  artificial intelligence     
      
mcallester  d     rosenblitt  d          systematic nonlinear planning  proceedings
aaai    
minton  s       a   issues design operator composition systems  proceedings
international conference machine learning 
minton  s       b   quantitative results concerning utility explanation based learning  artificial intelligence              
mostow  j     bhatnagar  n          failsafe  oor planner uses ebg learn
failures  proceedings ijcai    
munoz avilla  h     weberskirch  f          planning manufacturing workpieces
storing  indexing replaying planning decisions  proceedings  rd intl 
conf  ai planning systems  aaai press 
munoz avilla  h     weberskirch  f          case study mergeability cases
partial order planner  proceedings  th european conf  planning 
ram  a     cox  m          introspecive reasoning using meta explanations multistrategy learning  michalski  r     tecuci  g   eds    machine learning  multistrategy
approach vol  iv  morgan kaufmann 
ram  s     francis  a          multi plan retrieval adaptation experience based
agent  leake  d  b   ed    case based reasoning  experiences  lessons  future
directions  aaai press the mit press 
redmond  m          distributed cases case based reasoning facilitating use multiple
cases  proceedings aaai    
smyth  b     keane  m          remembering forget  competence preserving deletion
policy cbr  proceedings ijcai    
tambe  n   newell  a     rosenbloom  p          problem expensive chunks
solution restricting expressiveness  machine learning             
tate  a          generating project networks  proceedings ijcai    
   

fiihrig   kambhampati

veloso  m          planning learning analogical reasoning  springer verlag  number
    lecture notes artificial intelligence 
veloso  m     blythe  j          linkability  examining causal link commitments partialorder planning  proceedings  nd intl  conf  ai planning systems 
veloso  m     carbonell  j       a   derivational analogy prodigy  automating case
acquisition  storage utilization  machine learning              
veloso  m     carbonell  j       b   toward scaling machine learning  case study
derivational analogy prodigy  minton  s   ed    machine learning methods
planning  morgan kaufmann 
yang  q   nau  d     hendler  j          merging separately generated plans restricted
interactions  computational intelligence                 

   


