journal of artificial intelligence research                  

submitted        published      

and or multi valued decision diagrams  aomdds 
for graphical models
robert mateescu

mateescu   paradise   caltech   edu

electrical engineering department
california institute of technology
pasadena  ca        usa

rina dechter

dechter   ics   uci   edu

donald bren school of information and computer science
university of california irvine
irvine  ca        usa

radu marinescu

r   marinescu    c   ucc   ie

cork constraint computation centre
university college cork  ireland

abstract
inspired by the recently introduced framework of and or search spaces for graphical models  we propose to augment multi valued decision diagrams  mdd  with and nodes  in order
to capture function decomposition structure and to extend these compiled data structures to general weighted graphical models  e g   probabilistic models   we present the and or multi valued
decision diagram  aomdd  which compiles a graphical model into a canonical form that supports polynomial  e g   solution counting  belief updating  or constant time  e g  equivalence of
graphical models  queries  we provide two algorithms for compiling the aomdd of a graphical
model  the first is search based  and works by applying reduction rules to the trace of the memory
intensive and or search algorithm  the second is inference based and uses a bucket elimination
schedule to combine the aomdds of the input functions via the the apply operator  for both
algorithms  the compilation time and the size of the aomdd are  in the worst case  exponential in
the treewidth of the graphical model  rather than pathwidth as is known for ordered binary decision
diagrams  obdds   we introduce the concept of semantic treewidth  which helps explain why
the size of a decision diagram is often much smaller than the worst case bound  we provide an
experimental evaluation that demonstrates the potential of aomdds 

   introduction
the paper extends decision diagrams into and or multi valued decision diagrams  aomdds 
and shows how graphical models can be compiled into these data structures  the work presented in
this paper is based on two existing frameworks      and or search spaces for graphical models
and     decision diagrams 
    and or search spaces
and or search spaces  dechter   mateescu      a      b        have proven to be a unifying
framework for various classes of search algorithms for graphical models  the main characteristic is
the exploitation of independencies between variables during search  which can provide exponential
speedups over traditional search methods that can be viewed as traversing an or structure  the
c
    
ai access foundation  all rights reserved 

fim ateescu   d echter   m arinescu

and nodes capture problem decomposition into independent subproblems  and the or nodes represent branching according to variable values  and or spaces can accommodate dynamic variable
ordering  however most of the current work focuses on static decomposition  examples of and or
search trees and graphs will appear later  for example in figures   and   
the and or search space idea was originally developed for heuristic search  nilsson        
in the context of graphical models  and or search  dechter   mateescu        was also inspired
by search advances introduced sporadically in the past three decades for constraint satisfaction and
more recently for probabilistic inference and for optimization tasks  specifically  it resembles the
pseudo tree rearrangement  freuder   quinn               that was adapted subsequently for distributed constraint satisfaction by collin  dechter  and katz              and more recently by
modi  shen  tambe  and yokoo         and was also shown to be related to graph based backjumping  dechter         this work was extended by bayardo and miranker        and bayardo and
schrag        and more recently applied to optimization tasks by larrosa  meseguer  and sanchez
        another version that can be viewed as exploring the and or graphs was presented recently for constraint satisfaction  terrioux   jegou      b  and for optimization  terrioux   jegou 
    a   similar principles were introduced recently for probabilistic inference  in algorithm recursive conditioning  darwiche        as well as in value elimination  bacchus  dalmao    pitassi 
    b      a   and are currently at the core of the most advanced sat solvers  sang  bacchus 
beame  kautz    pitassi        
    decision diagrams
decision diagrams are widely used in many areas of research  especially in software and hardware
verification  clarke  grumberg    peled        mcmillan         a bdd represents a boolean
function by a directed acyclic graph with two terminal nodes  labeled   and     and every internal
node is labeled with a variable and has exactly two children  low for   and high for    if isomorphic
nodes were not merged  we would have the full search tree  also called shannon tree  which is the
usual full tree explored by a backtracking algorithm  the tree is ordered if variables are encountered
in the same order along every branch  it can then be compressed by merging isomorphic nodes
 i e   with the same label and identical children   and by eliminating redundant nodes  i e   whose
low and high children are identical   the result is the celebrated reduced ordered binary decision
diagram  or obdd for short  introduced by bryant         however  the underlying structure is
or  because the initial shannon tree is an or tree  if and or search trees are reduced by node
merging and redundant nodes elimination we get a compact search graph that can be viewed as a
bdd representation augmented with and nodes 
    knowledge compilation for graphical models
in this paper we combine the two ideas  creating a decision diagram that has an and or structure  thus exploiting problem decomposition  as a detail  the number of values is also increased
from two to any constant  in the context of constraint networks  decision diagrams can be used to
represent the whole set of solutions  facilitating solutions count  solution enumeration and queries
on equivalence of constraint networks  the benefit of moving from or structure to and or is in
a lower complexity of the algorithms and size of the compiled structure  it typically moves from
being bounded exponentially in pathwidth pw   which is characteristic to chain decompositions or
linear structures  to being exponentially bounded in treewidth w   which is characteristic of tree
   

fiand or m ulti  valued d ecision d iagrams  aomdd s   for g raphical m odels

structures  bodlaender   gilbert         it always holds that w  pw and pw  w  log n 
where n is the number of variables of the model   in both cases  the compactness result achieved in
practice is often far smaller than what the bounds suggest 
a decision diagram offers a compilation of a propositional knowledge base  an extension of
the obdds was provided by algebraic decision diagrams  add   bahar  frohm  gaona  hachtel 
macii  pardo    somenzi         where the terminal nodes are not just   or    but take values from
an arbitrary finite domain  the knowledge compilation approach has become an important research
direction in automated reasoning in the past decade  selman   kautz        darwiche   marquis 
      cadoli   donini         typically  a knowledge representation language is compiled into a
compact data structure that allows fast responses to various queries  accordingly  the computational
effort can be divided between an offline and an online phase where most of the work is pushed
offline  compilation can also be used to generate compact building blocks to be used by online
algorithms multiple times  macro operators compiled during or prior to search can be viewed in
this light  korf   felner         while in graphical models the building blocks are the functions
whose compact compiled representations can be used effectively across many tasks 
as one example  consider product configuration tasks and imagine a user that chooses sequential options to configure a product  in a naive system  the user would be allowed to choose any valid
option at the current level based only on the initial constraints  until either the product is configured 
or else  when a dead end is encountered  the system would backtrack to some previous state and
continue from there  this would in fact be a search through the space of possible partial configurations  needless to say  it would be very unpractical  and would offer the user no guarantee of
finishing in a limited time  a system based on compilation would actually build the backtrack free
search space in the offline phase  and represent it in a compact manner  in the online phase  only
valid partial configurations  i e   that can be extended to a full valid configuration  are allowed  and
depending on the query type  response time guarantees can be offered in terms of the size of the
compiled structure 
numerous other examples  such as diagnosis and planning problems  can be formulated as
graphical models and could benefit from compilation  palacios  bonet  darwiche    geffner       
huang   darwiche      a   in diagnosis  compilation can facilitate fast detection of possible faults
or explanations for some unusual behavior  planning problems can also be formulated as graphical
models  and a compilation would allow swift adjustments according to changes in the environment 
probabilistic models are one of the most used types of graphical models  and the basic query is to
compute conditional probabilities of some variables given the evidence  a compact compilation of a
probabilistic model would allow fast response to queries that incorporate evidence acquired in time 
for example  two of the most important tasks for bayesian networks are computing the probability
of the evidence  and computing the maximum probable explanation  mpe   if some of the model
variables become assigned  evidence   these tasks can be performed in time linear in the compilation size  which in practice is in many cases smaller than the upper bound based on the treewidth or
pathwidth of the graph  formal verification is another example where compilation is heavily used
to compare equivalence of circuit design  or to check the behavior of a circuit  binary decision
diagram  bdd   bryant        is arguably the most widely known and used compiled structure 
the contributions made in this paper to knowledge compilation in general and to decision diagrams in particular are the following 
   we formally describe the and or multi valued decision diagram  aomdd  and prove it
to be a canonical representation for constraint networks  given a pseudo tree 
   

fim ateescu   d echter   m arinescu

   we extend the aomdd to general weighted graphical models 
   we give a compilation algorithm based on and or search  that saves the trace of a memory
intensive search and then reduces it in one bottom up pass 
   we present the apply operator that combines two aomdds and show that its complexity is
at most quadratic in the input  but never worse than exponential in the treewidth 
   we give a scheduling order for building the aomdd of a graphical model starting with
the aomdds of its functions which is based on a variable elimination algorithm  this
guarantees that the complexity is at most exponential in the induced width  treewidth  along
the ordering 
   we show how aomdds relate to various earlier and recent compilation frameworks  providing a unifying perspective for all these methods 
   we introduce the semantic treewidth  which helps explain why compiled decision diagrams
are often much smaller than the worst case bound 
   we provide an experimental evaluation of the new data structure 
the structure of the paper is as follows  section   provides preliminary definitions  a description
of binary decision diagrams and the bucket elimination algorithm  section   gives an overview of
and or search spaces  section   introduces the aomdd and discusses its properties  section
  describes a search based algorithm for compiling the aomdd  section   presents a compilation
algorithm based on a bucket elimination schedule and the apply operation  section   proves that
the aomdd is a canonical representation for constraint networks given a pseudo tree  and section
  extends the aomdd to weighted graphical models and proves their canonicity  section   ties
the canonicity to the new concept of semantic treewidth  section    provides an experimental
evaluation  section    presents related work and section    concludes the paper  all the proofs
appear in an appendix 

   preliminaries
notations a reasoning problem is defined in terms of a set of variables taking values from finite
domains and a set of functions defined over these variables  we denote variables or subsets of
variables by uppercase letters  e g   x  y         and values of variables by lower case letters  e g  
x  y          sets are usually denoted by bold letters  for example x    x            xn   is a set of
variables  an assignment  x    x            xn   xn   can be abbreviated as x    hx    x  i         
hxn   xn i  or x    x            xn    for a subset of variables y  dy denotes the cartesian product of
the domains of variables in y  the projection of an assignment x    x            xn   over a subset y
is denoted by xy or x y   we will also denote by y   y  or y for short  the assignment of values
to variables in y from their respective domains  we denote functions by letters f   g  h etc   and the
scope  set of arguments  of the function f by scope f   
    graphical models
d efinition    graphical model  a graphical model m is a   tuple  m   hx  d  f  i  where 
   

fiand or m ulti  valued d ecision d iagrams  aomdd s   for g raphical m odels

   x    x            xn   is a finite set of variables 
   d    d            dn   is the set of their respective finite domains of values 
   f    f            fr   is a set of positive real valued discrete functions  i e   their domains can
be listed   each defined over a subset of variables si  x  called its scope  and denoted by
scope fi   
q p
    is a combination operator   e g               product  sum  join   that can take as
input two  or more  real valued discrete functions  and produce another real valued discrete
function 
the graphical model represents the combination of all its functions  ri   fi  
several examples of graphical models appear later  for example  figure   shows a constraint
network and figure   shows a belief network 
in order to define the equivalence of graphical models  it is useful to introduce the notion of
universal graphical model that is defined by a single function 
d efinition    universal equivalent graphical model  given a graphical model m
 
hx  d  f    i the universal equivalent model of m is u m    hx  d  f     fi f  fi    i 
two graphical models are equivalent if they represent the same function  namely  if they have
the same universal model 
d efinition    weight of a full and a partial assignment  given a graphical model m  
hx  d  fi  the weight of a full assignment x    x            xn   is defined by w x   
f f f  x scope f      given a subset of variables y  x  the weight of a partial assignment
y is the combination of all the functions whose scopes are included in y  denoted by fy   evaluated
at the assigned values  namely  w y    f fy f  y scope f     
consistency for most graphical models  the range of the functions has a special zero value  
that is absorbing relative to the combination operator  e g   multiplication   combining anything
with   yields a    the   value expresses the notion of inconsistent assignments  it is a primary
concept in constraint networks but can also be defined relative to other graphical models that have a
  element 
d efinition    consistent partial assignment  solution  given a graphical model having a  
element  a partial assignment is consistent if its cost is non zero  a solution is a consistent assignment to all the variables 
d efinition    primal graph  the primal graph of a graphical model is an undirected graph that
has variables as its vertices and an edge connects any two variables that appear in the scope of the
same function 
the primal graph captures the structure of the knowledge expressed by the graphical model  in
particular  graph separation indicates independency of sets of variables given some assignments to
other variables  all of the advanced algorithms for graphical models exploit the graphical structure 
by using a heuristically good elimination order  a tree decomposition or some similar method  we
will use the concept of pseudo tree  which resembles the tree rearrangements introduced by freuder
and quinn        
   the combination operator can also be defined axiomatically  shenoy        

   

fim ateescu   d echter   m arinescu

e

a

a

d

e

b

d
f

b

g

f

c

g
c

 a  graph coloring problem

 b  constraint graph

figure    constraint network
d efinition    pseudo tree  a pseudo tree of a graph g    x  e  is a rooted tree t having the
same set of nodes x  such that every arc in e is a backarc in t  a path in a rooted tree starts at the
root and ends at one leaf  two nodes can be connected by a backarc only if there exists a path that
contains both  
we use the common concepts and parameters from graph theory  that characterize the connectivity of the graph  and how close it is to a tree or to a chain  the induced width of a graphical model
governs the complexity of solving it by bucket elimination  dechter         and was also shown to
bound the and or search graph when memory is used to cache solved subproblems  dechter  
mateescu        
d efinition    induced graph  induced width  treewidth  pathwidth  an ordered graph is a
pair  g  d   where g     x            xn    e  is an undirected graph  and d    x            xn   is an
ordering of the nodes  the width of a node in an ordered graph is the number of neighbors that
precede it in the ordering  the width of an ordering d  denoted w d   is the maximum width over
all nodes  the induced width of an ordered graph  w  d   is the width of the induced ordered graph
obtained as follows  for each node  from last to first in d  its preceding neighbors are connected
in a clique  the induced width of a graph  w   is the minimal induced width over all orderings 
the induced width is also equal to the treewidth of a graph  the pathwidth pw of a graph is the
treewidth over the restricted class of orderings that correspond to chain decompositions 
various reasoning tasks  or queries can be defined over graphical models  those can be defined formally using marginalization operators such as projection  summation and minimization 
however  since our goal is to present a compilation of a graphical model which is independent of
the queries that can be posed on it  we will discuss tasks in an informal manner only  for more
information see the work of kask  dechter  larrosa  and dechter        
throughout the paper  we will use two examples of graphical models  constraint networks
and belief networks  in the case of constraint networks  the functions can be understood as relations  in other words  the functions  also called constraints  can take only two values          or
 f alse  true   a   value indicates that the corresponding assignment to the variables is inconsistent  not allowed   and a   value indicates consistency  belief networks are an example of the more
general case of graphical models  also called weighted graphical models   the functions in this case
are conditional probability tables  so the values of a function are real numbers in the interval        

   

fiand or m ulti  valued d ecision d iagrams  aomdd s   for g raphical m odels

example   figure   a  shows a graph coloring problem that can be modeled by a constraint network  given a map of regions  the problem is to color each region by one of the given colors  red 
green  blue   such that neighboring regions have different colors  the variables of the problems
are the regions  and each one has the domain  red  green  blue   the constraints are the relation
different between neighboring regions  figure   b  shows the constraint graph  and a solution
 a red  b blue  c green  d green  e blue  f blue  g red  is given in figure   a   a more
detailed example will be given later in example   
propositional satisfiability a special case of a csp is propositional satisfiability  sat   a formula  in conjunctive normal form  cnf  is a conjunction of clauses             t   where a clause
is a disjunction of literals  propositions or their negations   for example      p  q  r  is
a clause  where p   q and r are propositions  and p   q and r are literals  the sat problem
is to decide whether a given cnf theory has a model  i e   a truth assignment to its propositions
that does not violate any clause  propositional satisfiability  sat  can be defined as a csp  where
propositions correspond to variables  domains are         and constraints are represented by clauses 
for example the clause  a  b  is a relation over its propositional variables that allows all tuples
over  a  b  except  a      b      
cost networks an immediate extension of constraint networks are cost networks where the set
of functions are real valued cost functions  and the primary task is optimization  also  gai nets
 generalized additive independence  fishburn        can be used to represent utility functions  an
example of cost functions will appear in figure    
d efinition
p   cost network  combinatorial optimization  a cost network is a   tuple 
hx  d  c  i  where x is a set of variables x    x            xn    associated with a set of
discrete valued domains  d    d            dn    and a set of cost functions c    c            cr    each
ci is a real valued function defined on a subset of variables si  x  the combination operator  is
p
  the reasoning problem is to find a minimum cost solution 

belief networks  pearl        provide a formalism for reasoning about partial beliefs under conditions of uncertainty  they are defined by a directed acyclic graph over vertices representing random
variables of interest  e g   the temperature of a device  the gender of a patient  a feature of an object  the occurrence of an event   the arcs signify the existence of direct causal influences between
linked variables quantified by conditional probabilities that are attached to each cluster of parentschild vertices in the network 
q
d efinition    belief networks  a belief network  bn  is a graphical model p   hx  d  pg   i 
where x    x            xn   is a set of variables over domains d    d            dn    given a directed acyclic graph g over x as nodes  pg    p            pn    where pi    p  xi   pa  xi      
are conditional probability tables  cpts for short  associated with each xi   where pa xi   are the
parents of xi in the
qacyclic graph g  a belief network represents a probability distribution over x 
p  x            xn     ni   p  xi  xpa xi      an evidence set e is an instantiated subset of variables 
when formulated as a graphical model  functions in f denote conditional probability tables
and the scopes of these functions are determined by the directed acyclic graph g  each function
q
fi ranges over variable xi and its parents in g  the combination operator is product      
the primal graph of a belief network  viewed as an undirected model  is called a moral graph  it
connects any two variables appearing in the same cpt 
   

fim ateescu   d echter   m arinescu

a season

sprinkler b

watering d

a

c rain

b

f wetness

d

g slippery

c

f

g

 a  directed acyclic graph

 b  moral graph

figure    belief network
example   figure   a  gives an example of a belief network over   variables  and figure   b 
shows its moral graph   the example expresses the causal relationship between variables season
 a   the configuration of an automatic sprinkler system  b   the amount of rain expected
 c   the amount of manual watering necessary  d   the wetness of the pavement  f   and
whether or not the pavement is slippery  g   the belief network expresses the probability distribution p  a  b  c  d  f  g    p  a   p  b a   p  c a   p  d b  a   p  f  c  b   p  g f   
another example of a belief network and cpts appears in figure   
the two most popular tasks for belief networks are defined below 
d efinition     belief updating  most probable explanation  mpe   given a belief network
and evidence e  the belief updating task is to compute the posterior marginal probability of variable
xi   conditioned on the evidence  namely 
x

bel xi   xi     p  xi   xi   e    

n
y

p  xk   e xpak   

  x       xi   xi        xn   e e xi  xi   k  

where  is a normalization constant  the most probable explanation  mpe  task is to find a
complete assignment which agrees with the evidence  and which has the highest probability among
all such assignments  namely  to find an assignment  xo            xon   such that
p  xo            xon     maxx       xn

n
y

p  xk   e xpak   

k  

    binary decision diagrams review
decision diagrams are widely used in many areas of research to represent decision processes  in
particular  they can be used to represent functions  due to the fundamental importance of boolean
functions  a lot of effort has been dedicated to the study of binary decision diagrams  bdds  
which are extensively used in software and hardware verification  clarke et al         mcmillan 
       the earliest work on bdds is due to lee         who introduced the binary decision program  that can be understood as a linear representation of a bdd  e g   a depth first search ordering
of the nodes   where each node is a branching instruction indicating the address of the next instruction for both the   and the   value of the test variable  akers        presented the actual graphical
   

fiand or m ulti  valued d ecision d iagrams  aomdd s   for g raphical m odels

a
 
 
 
 
 
 
 
 

b
 
 
 
 
 
 
 
 

c
 
 
 
 
 
 
 
 

f abc 
 
 
 
 
 
 
 
 

a

a

b

c

c

 

c

 

 a  table

 

b

b

 

 

b

 

 

b

c

 

 

 b  unordered tree

c

 

 

c

 

 

c

 

 

 

 c  ordered tree

figure    boolean function representations
representation and further developed the bdd idea  however  it was bryant        that introduced
what is now called the ordered binary decision diagram  obdd   he restricted the order of variables along any path of the diagram  and presented algorithms  most importantly the apply procedure  that combines two obdds by an operation  that have time complexity at most quadratic in the
sizes of the input diagrams  obdds are fundamental for applications with large binary functions 
especially because in many practical cases they provide very compact representations 
a bdd is a representation of a boolean function  given b           a boolean function
f   bn  b  has n arguments  x         xn   which are boolean variables  and takes boolean
values 
example   figure   a  shows a table representation of a boolean function of three variables  this
explicit representation is the most straightforward  but also the most costly due to its exponential
requirements  the same function can also be represented by a binary tree  shown in figure   b  
that has the same exponential size in the number of variables  the internal round nodes represent
the variables  the solid edges are the    or high  value  and the dotted edges are the    or low  value 
the leaf square nodes show the value of the function for each assignment along a path  the tree
shown in   b  is unordered  because variables do not appear in the same order along each path 
in building an obdd  the first condition is to have variables appear in the same order  a b c 
along every path from root to leaves  figure   c  shows an ordered binary tree for our function 
once an order is imposed  there are two reduction rules that transform a decision diagram into an
equivalent one 
    isomorphism  merge nodes that have the same label and the same children 
    redundancy  eliminate nodes whose low and high edges point to the same node  and connect
parent of removed node directly to child of removed node 
applying the two reduction rules exhaustively yields a reduced obdd  sometimes denoted
robdd  we will just use obdd and assume that it is completely reduced 
example   figure   a  shows the binary tree from figure   c  after the isomorphic terminal nodes
 leaves  have been merged  the highlighted nodes  labeled with c  are also isomorphic  and figure
  b  shows the result after they are merged  now  the highlighted nodes labeled with c and b are
redundant  and removing them gives the obdd in figure   c  
    bucket elimination review
bucket elimination  be   dechter        is a well known variable elimination algorithm for inference in graphical models  we will describe it using the terminology for constraint networks  but be
   

fim ateescu   d echter   m arinescu

a

a

b

b

c

c

c

 

 

a

b

c

b

c

c

 

 a  isomorphic nodes

b

c

 

 

 b  redundant nodes

 

 c  obdd

figure    reduction rules
a 

a
c  ac 
c  ab 
c  abe 

b

c

c  bcd 

h  a 

b 

c  ab 

e 

c  abe 

a

h  ab 

h  ab 

ab bucket b
ab

abe

c 
e

d

 a  constraint network

d 

c  ac 

h  bc 

bucket a

a

bucket e

ab

abc bucket c
bc

bcd bucket d

c   bcd 

 b  be execution

 c  bucket tree

figure    bucket elimination
can also be applied to any graphical model  consider a constraint network r   hx  d  ci and an
ordering d    x    x            xn    the ordering d dictates an elimination order for be  from last to
first  each variable is associated with a bucket  each constraint from c is placed in the bucket of its
latest variable in d  buckets are processed from xn to x  by eliminating the bucket variable  the
constraints residing in the bucket are joined together  and the bucket variable is projected out  and
placing the resulting constraint  also called message  in the bucket of its latest variable in d  after
its execution  be renders the network backtrack free  and a solution can be produced by assigning
variables along d  be can also produce the solutions count if marginalization is done by summation
 rather than projection  over the functional representation of the constraints  and join is substituted
by multiplication 
be also constructs a bucket tree  by linking the bucket of each xi to the destination bucket of
its message  called the parent bucket   a node in the bucket tree typically has a bucket variable  a
collection of constraints  and a scope  the union of the scopes of its constraints   if the nodes of the
bucket tree are replaced by their respective bucket variables  it is easy to see that we obtain a pseudo
tree 
example   figure   a  shows a network with four constraints  figure  b  shows the execution of
bucket elimination along d    a  b  e  c  d   the buckets are processed from d to a   figure
  c  shows the bucket tree  the pseudo tree corresponding to the order d is given in fig    a  
   the representation in figure   reverses the top down bucket processing described in earlier papers  dechter        

   

fiand or m ulti  valued d ecision d iagrams  aomdd s   for g raphical m odels

procedure generatepseudotree g  d 
 
 
 
 
 

input   graph g    x  e   order d    x            xn  
output   pseudo tree t
make x  the root of t
condition on x   eliminate x  and its incident edges from g   let g            gp be the resulting connected
components of g
for i     to p do
ti   generatepseudotree  gi   d gi  
make root of ti a child of x 

  return t

    orderings and pseudo trees
given an ordering d  the structural information captured in the primal graph through the scopes
of the functions f    f            fr   can be used to create the unique pseudo tree that corresponds
to d  mateescu   dechter         this is precisely the bucket tree  or elimination tree   that is
created by be  when variables are processed in reverse d   the same pseudo tree can be created by
conditioning on the primal graph  and processing variables in the order d  as described in procedure
generatepseudotree  in the following  d gi is the restriction of the order d to the nodes of
the graph gi  

   overview of and or search space for graphical models
the and or search space is a recently introduced  dechter   mateescu      a      b       
unifying framework for advanced algorithmic schemes for graphical models  its main virtue consists in exploiting independencies between variables during search  which can provide exponential
speedups over traditional search methods oblivious to problem structure  since and or mdds
are based on and or search spaces we need to provide a comprehensive overview for the sake of
completeness 
    and or search trees
the and or search tree is guided by a pseudo tree of the primal graph  the idea is to exploit
the problem decomposition into independent subproblems during search  assigning a value to a
variable  also known as conditioning   is equivalent in graph terms to removing that variable  and its
incident edges  from the primal graph  a partial assignment can therefore lead to the decomposition
of the residual primal graph into independent components  each of which can be searched  or solved 
separately  the pseudo tree captures precisely all these decompositions given an order of variable
instantiation 
d efinition     and or search tree of a graphical model  given a graphical model m  
hx  d  fi  its primal graph g and a pseudo tree t of g  the associated and or search tree
has alternating levels of or and and nodes  the or nodes are labeled xi and correspond to
variables  the and nodes are labeled hxi   xi i  or simply xi   and correspond to value assignments 
the structure of the and or search tree is based on t   the root is an or node labeled with the
root of t   the children of an or node xi are and nodes labeled with assignments hxi   xi i that

   

fim ateescu   d echter   m arinescu

a

a

b

 

b

b

 
e

e

 

c

d

 
c

   

e

 

 

d
   

 a  pseudo tree

   

 
c

e

 

 

d

d

   

   

   

 
c

e

 

 

d

d

   

   

   

c
 

 

d

d

d

   

   

   

 b  search tree

figure    and or search tree
are consistent with the assignments along the path from the root  the children of an and node
hxi   xi i are or nodes labeled with the children of variable xi in the pseudo tree t  
example   figure   shows an example of an and or search tree for the graphical model given in
figure   a   assuming all tuples are consistent  and variables are binary valued  when some tuples
are inconsistent  some of the paths in the tree do not exist  figure   a  gives the pseudo tree that
guides the search  from top to bottom  as indicated by the arrows  the dotted arcs are backarcs
from the primal graph  figure   b  shows the and or search tree  with the alternating levels of
or  circle  and and  square  nodes  and having the structure indicated by the pseudo tree 
the and or search tree can be traversed by a depth first search algorithm  thus using linear
space  it was already shown  freuder   quinn        bayardo   miranker        darwiche       
dechter   mateescu      a        that 
t heorem   given a graphical model m over n variables  and a pseudo tree t of depth m  the
size of the and or search tree based on t is o n k m    where k bounds the domains of variables 
a graphical model of treewidth w has a pseudo tree of depth at most w log n  therefore it has an

and or search tree of size o n k w log n   
the and or search tree expresses the set of all possible assignments to the problem variables
 all solutions   the difference from the traditional or search space is that a solution is no longer a
path from root to a leaf  but rather a tree  defined as follows 
d efinition     solution tree  a solution tree of an and or search tree contains the root node 
for every or node  it contains one of its child nodes and for each of its and nodes it contains all
its child nodes  and all its leaf nodes are consistent 
    and or search graph
the and or search tree may contain nodes that root identical subproblems  these nodes are said
to be unifiable  when unifiable nodes are merged  the search space becomes a graph  its size
becomes smaller at the expense of using additional memory by the search algorithm  the depth first
search algorithm can therefore be modified to cache previously computed results  and retrieve them
when the same nodes are encountered again  the notion of unifiable nodes is defined formally next 

   

fiand or m ulti  valued d ecision d iagrams  aomdd s   for g raphical m odels

d efinition     minimal and or graph  isomorphism  two and or search graphs g and g 
are isomorphic if there exists a one to one mapping  from the vertices of g to the vertices of g 
such that for any vertex v  if  v    v     then v and v   root identical subgraphs relative to   an
and or graph is called minimal if all its isomorphic subgraphs are merged  isomorphic nodes
 that root isomorphic subgraphs  are also said to be unifiable 
it was shown by dechter and mateescu        that 
t heorem   a graphical model m has a unique minimal and or search graph relative to a
pseudo tree t  
the minimal and or graph of a graphical model g relative to a pseudo tree t is denoted by
mt  g   note that the definition of minimality used in the work of dechter and mateescu       
is based only on isomorphism reduction  we will extend it here by also including the elimination
of redundant nodes  the previous theorem only shows that given an and or graph  the merge
operator has a fixed point  which is the minimal and or graph  we will show in this paper that
the aomdd is a canonical representation  namely that any two equivalent graphical models can
be represented by the same unique aomdd given that they accept the same pseudo tree  and the
aomdd is minimal in terms of number of nodes 
some unifiable nodes can be identified based on their contexts  we can define graph based
contexts for both or nodes and and nodes  just by expressing the set of ancestor variables in t
that completely determine a conditioned subproblem  however  it can be shown that using caching
based on or contexts makes caching based on and contexts redundant and vice versa  so we will
only use or caching  any value assignment to the context of x separates the subproblem below x
from the rest of the network 
d efinition     or context  given a pseudo tree t of an and or search space 
context x     x        xp   is the set of ancestors of x in t   ordered descendingly  that are connected in the primal graph to x or to descendants of x 
d efinition     context unifiable or nodes  given an and or search graph  two or nodes n 
and n  are context unifiable if they have the same variable label x and the assignments of their
contexts is identical  namely  if   is the partial assignment of variables along the path to n    and
  is the partial assignment of variables along the path to n    then their restriction to the context of
x is the same     context x       context x   
the depth first search algorithm that traverses the and or search tree  can be modified to
traverse a graph  if enough memory is available  we could allocate a cache table for each variable x 
the scope of the table being context x   the size of the cache table for x is therefore the product
of the domains of variables in its context  for each variable x  and for each possible assignment
to its context  the corresponding conditioned subproblem is solved only once and the computed
value is saved in the cache table  and whenever the same context assignment is encountered again 
the value of the subproblem is retrieved from the cache table  such an algorithm traverses what is
called the context minimal and or graph 
d efinition     context minimal and or graph  the context minimal and or graph is obtained from the and or search tree by merging all the context unifiable or nodes 
   

fim ateescu   d echter   m arinescu

r

f

g

b

  

c

a
j

k

 c 

h

 c 

l

 ck 

a

 ch 

n

 ckl 

b

 cha 

o

 ckln 

p

 cko 

h
e
c

d

l

e

 chab 

r

 hab 

j

 chae 

f

 ar 

d

 cej 

g

 af 

m

 cd 

k
m
n
p
o

 a  primal graph

 b  pseudo tree
c

 

 

k

h

k

 

 

 

 

l

l

l

l

h

 

 

a

 

a

 

a

a

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

n

n

n

n

n

n

n

n

b

b

b

b

b

b

b

b

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

o

o

o

o

o

o

o

o

o

o

o

o

o

o

o

o

 

e

 

 

e

e

e

 

 

e

e

e

 

 

e

e

e

e

 

 

e

e

e

e

 

e

 

 

 

r

r

r

 

 

r

r

r

r

 

r

                                                               
                   
p

p

p

p

p

p

p

                                           

                               

p
j

j

j

j

j

j

j

j

j

j

j

j

j

j

j

j

                               
                                                               

d

d

d

d

               

d

d

d

f

f

f

f

               

d

               

g

g

g

g

               
m

m

m

m

               

 c  context minimal graph

figure    and or search graph
it was already shown  bayardo   miranker        dechter   mateescu      a        that 
t heorem   given a graphical model m  its primal graph g and a pseudo tree t   the size of the
context minimal and or search graph based on t   and therefore the size of its minimal and or

search graph  is o n k wt  g     where wt  g  is the induced width of g over the depth first traversal
of t   and k bounds the domain size 

example   lets look at the impact of caching on the size of the search space by examining a larger
example  figure   a  shows a graphical model with binary variables and figure   b  a pseudo tree
that drives the and or search  the context of each node is given in square brackets  the context
minimal graph is given in figure   c   note that it is far smaller than the and or search tree 
which has          and nodes at the level of m alone  because m is at depth   in the pseudo tree  
the shaded rectangles show the size of each cache table  equal to the number of or nodes that
appear in each one  a cache entry is useful whenever there are more than one incoming edges into
the or node  incidentally  the caches that are not useful  namely or nodes with only one incoming
arc   are called dead caches  darwiche         and can be determined based only on the pseudo
   

fiand or m ulti  valued d ecision d iagrams  aomdd s   for g raphical m odels

tree inspection  therefore a cache table need not be allocated for them  the context minimal graph
can also explain the execution of be along the same pseudo tree  or  equivalently  along its depth
first traversal order   the buckets are the shaded rectangles  and the processing is done bottom up 
the number of possible assignments to each bucket equals the number of and nodes that appear
in it  the message scope is identical to the context of the bucket variable  and the message itself is
identical to the corresponding cache table  for more details on the relationship between and or
search and be see the work of mateescu and dechter        
    weighted and or graphs
in the previous subsections we described the structure of the and or trees and graphs  in order
to use them to solve a reasoning task  we need to define a way of using the input function values
during the traversal of an and or graph  this is realized by placing weights  or costs  on the
or to and arcs  dictated by the function values  only the functions that are relevant contribute to
an or to and arc weight  and this is captured by the buckets relative to the pseudo tree 
d efinition     buckets relative to a pseudo tree  given a graphical model m   hx  d  f  i
and a pseudo tree t   the bucket of xi relative to t   denoted bt  xi    is the set of functions whose
scopes contain xi and are included in patht  xi    which is the set of variables from the root to xi
in t   namely 
bt  xi      f  f xi  scope f    scope f    patht  xi    

a function belongs to the bucket of a variable xi iff its scope has just been fully instantiated
when xi was assigned  combining the values of all functions in the bucket  for the current assignment  gives the weight of the or to and arc 
d efinition     or to and weights  given an and or graph of a graphical model m  the
weight w n m   xi   xi   of arc  n  m  where xi labels n and xi labels m  is the combination of
all the functions in bt  xi   assigned by values along the current path to the and node m  m  
formally  w n m   xi   xi     f bt  xi   f  asgn m   scope f     
d efinition     weight of a solution tree  given a weighted and or graph of a graphical model
m  and given a solution tree t having the or to and set of arcs arcs t   the weight of t is defined
by w t    earcs t  w e  
example   we start with the more straightforward case of constraint networks  since functions
only take values   or    and the combination is by product  join of relations   it follows that any orto and arc can only have a weight of   or    an example is given in figure    figure   a  shows
a constraint graph    b  a pseudo tree for it  and   c  the four relations that define the constraint
problem  figure   d  shows the and or tree that can be traversed by a depth first search algorithm
that only checks the consistency of the input functions  i e   no constraint propagation is used  
similar to the obdd representation  the or to and arcs with a weight of   are denoted by dotted
lines  and the tree is not unfolded below them  since it will not contain any solution  the arcs with
a weight of   are drawn with solid lines 
   

fim ateescu   d echter   m arinescu

a
b
c

a

d

f

b

e

 a  constraint graph
a
 
 
 
 
 
 
 
 

b
 
 
 
 
 
 
 
 

b
 
 
 
 
 
 
 
 

c rabc
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

c
 
 
 
 
 
 
 
 

c

e

d

f

 b  pseudo tree

d rbcd
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

a
 
 
 
 
 
 
 
 

b
 
 
 
 
 
 
 
 

e rabe
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

a
 
 
 
 
 
 
 
 

e
 
 
 
 
 
 
 
 

f raef
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 c  relations
a

 

 

 

 

b

b

 

 

 
 

 
c

c

e

 
 

 
c

e

c

e

e

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

d

d

d

f

 

   

   

 

 

 

 

 

 

 

 
 

f

d

f

   

   

 

 

 

 

 

 

 

 

d

d

f

f

   

 

 

 

 

 

 

 

 

 

 

 

 

 
 

 
 

 d  and or tree

figure    and or search tree for constraint networks
example   figure   shows a weighted and or tree for a belief network  figure   a  shows the
directed acyclic graph  and the dotted arc bc added by moralization  figure   b  shows the pseudo
tree  and   c  shows the conditional probability tables  figure   d  shows the weighted and or
tree 
as we did for constraint networks  we can move from weighted and or search trees to
weighted and or search graphs by merging unifiable nodes  in this case the arc labels should be
also considered when determining unifiable subgraphs  this can yield context minimal weighted
and or search graphs and minimal weighted and or search graphs 

   and or multi valued decision diagrams  aomdds 
in this section we begin describing the contributions of this paper  the context minimal and or
graph  definition     offers an effective way of identifying some unifiable nodes during the execution of the search algorithm  namely  context unifiable nodes are discovered based only on their
paths from the root  without actually solving their corresponding subproblems  however  merging based on context is not complete  which means that there may still exist unifiable nodes in
the search graph that do not have identical contexts  moreover  some of the nodes in the context
   

fiand or m ulti  valued d ecision d iagrams  aomdd s   for g raphical m odels

p a 

a

a
 
 

a

p b   a 

p a 
  
  

a
 
 

p c   a 
a
 
 

b  
  
  

b  
  
  

p d   b c 

b
b

b
 
 
 
 

c

e
e

c
d

d

 a  belief network

c
 
 
 
 

p e   a b 
d  
  
  
  
  

d  
  
  
  
  

c  
  
  

c  
  
  

 b  pseudo tree

a
 
 
 
 

b
 
 
 
 

e  
  
  
  
  

e  
  
  
  
  

 c  cpts

a

  

  

 

 

b

b

  
 

 

c

  
 

e

  

  

  

 

 

 

d

  
 

 

d

  
 

  
 

  

  

  

 

 

 

d

  
 

  
 

c

 

e

  

  

  

 

 

 

d

d

     
 

 

e

c

  

  

 

 

e

  

  

  

  

  

 

 

  
 

c

  

  

  

 

 

 

d

  
 

d

  
 

  
 

  
 

d

     
 

 

  
 

 d  weighted and or tree

figure    weighted and or search tree for belief networks
minimal and or graph may be redundant  for example when the set of solutions rooted at variable xi is not dependant on the specific value assigned to xi  this situation is not detectable based
on context   this is sometimes termed as interchangeable values or symmetrical values  as
overviewed earlier  dechter and mateescu            a  defined the complete minimal and or
graph which is an and or graph whose unifiable nodes are all merged  and dechter and mateescu
       also proved the canonicity for non weighted graphical models 
in this paper we propose to augment the minimal and or search graph with removing redundant variables as is common in obdd representation as well as adopt notational conventions
common in this community  this yields a data structure that we call and or bdd  that exploits
decomposition by using and nodes  we present the extension over multi valued variables yielding
and or mdd or aomdd and define them for general weighted graphical models  subsequently
we present two algorithms for compiling the canonical aomdd of a graphical model  the first is
search based  and uses the memory intensive and or graph search to generate the context minimal
and or graph  and then reduces it bottom up by applying reduction rules  the second is inferencebased  and uses a bucket elimination schedule to combine the aomdds of initial functions by
apply operations  similar to the apply for obdds   as we will show  both approaches have the
same worst case complexity as the and or graph search with context based caching  and also the
same complexity as bucket elimination  namely time and space exponential in the treewidth of the

problem  o n k w    the benefit of each of these generation schemes will be discussed 

   

fim ateescu   d echter   m arinescu

a

a

 

 a  obdd

 



k

 b  mdd

figure     decision diagram nodes  or 
a

a

 







 a  aobdd

 

k







 b  aomdd

figure     decision diagram nodes  and or 
    from and or search graphs to decision diagrams
an and or search graph g of a graphical model m   hx  d  f  i represents the set of all
possible assignments to the problem variables  all solutions and their costs   in this sense  g can
be viewed as representing the function f   fi f fi that defines the universal equivalent graphical
model u m   definition     for each full assignment x    x            xn    if x is a solution expressed
by the tree tx   then f  x    w tx     earcs tx   w e   definition      otherwise f  x       the
assignment is inconsistent   the solution tree tx of a consistent assignment x can be read from g
in linear time by following the assignments from the root  if x is inconsistent  then a dead end is
encountered in g when attempting to read the solution tree tx   and f  x       therefore  g can be
viewed as a decision diagram that determines the values of f for every complete assignment x 
we will now see how we can process an and or search graph by reduction rules similar to
the case of obdds  in order to obtain a representation of minimal size  in the case of obdds 
a node is labeled with a variable name  for example a  and the low  dotted line  and high  solid
line  outgoing arcs capture the restriction of the function to the assignments a     or a      to
determine the value of the function  one needs to follow either one or the other  but not both  of the
outgoing arcs from a  see figure    a    the straightforward extension of obdds to multi valued
variables  multi valued decision diagrams  or mdds  was presented by srinivasan  kam  malik 
and brayton         and the node structure that they use is given in figure    b   each outgoing arc
is associated with one of the k values of variable a 
in this paper we generalize the obdd and mdd representations demonstrated in figures    a 
and    b  by allowing each outgoing arc to be an and arc  an and arc connects a node to a set of
nodes  and captures the decomposition of the problem into independent components  the number of
and arcs emanating from a node is two in the case of aobdds  figure    a    or the domain size
of the variable in the general case  figure    b    for a given node a  each of its k and arcs can
connect it to possibly different number of nodes  depending on how the problem decomposes based
on each particular assignment of a  the and arcs are depicted by a shaded sector that connects
the outgoing lines corresponding to the independent components 

   

fiand or m ulti  valued d ecision d iagrams  aomdd s   for g raphical m odels

a
 



 



k





 a  nonterminal meta node

 

 

 b  terminal meta node  

 c  terminal meta node  

figure     meta nodes
we define the and or decision diagram representation based on and or search graphs  we
find that it is useful to maintain the semantics of figure    especially when we need to express the
redundancy of nodes  and therefore we introduce the meta node data structure  which defines small
portions of any and or graph  based on an or node and its and children 
d efinition     meta node  a meta node u in an and or search graph can be either      a
terminal node labeled with   or    or     a nonterminal node  that consists of an or node labeled
x  therefore var u    x  and its k and children labeled x            xk that correspond to the value
assignments of x  each and node labeled xi stores a list of pointers to child meta nodes  denoted
by u childreni   in the case of weighted graphical models  the and node xi also stores the or toand arc weight w x  xi   
the rectangle in figure    a  is a meta node for variable a  that has a domain of size k  note
that this is very similar to figure     with the small difference that the information about the value of
a that corresponds to each outgoing and arc is now stored in the and nodes of the meta node  we
are not showing the weights in that figure  a larger example of an and or graph with meta nodes
appears later in figure    
the terminal meta nodes play the role of the terminal nodes in obdds  the terminal metanode    shown in figure    b   indicates inconsistent assignments  while the terminal meta node   
shown in figure    c  indicates consistent ones 
any and or search graph can now be viewed as a diagram of meta nodes  simply by grouping
or nodes with their and children  and adding the terminal meta nodes appropriately 
once we have defined the meta nodes  it is easier to see when a variable is redundant with respect to the outcome of the function based on the current partial assignment  a variable is redundant
if any of its assignments leads to the same set of solutions 
d efinition     redundant meta node  given a weighted and or search graph g represented
with meta nodes  a meta node u with var u    x and  d x     k is redundant iff 
 a  u children            u childrenk and
 b  w x  x              w x  xk   
an and or graph g  that contains a redundant meta node u  can be transformed into an equivalent graph g   by replacing any incoming arc into u with its common list of children u children   
absorbing the common weight w x  x    by combination into the weight of the parent meta node
corresponding to the incoming arc  and then removing u and its outgoing arcs from g  the
value x   x  is picked here arbitrarily  because they are all isomorphic  if u is the root of the
   

fim ateescu   d echter   m arinescu

procedure redundancyreduction
  and or graph g  redundant meta node u  with var u    x  list of meta node parents of u 
denoted by p arents u  
output   reduced and or graph g after the elimination of u 
  if p arents u  is empty then
 
return independent and or graphs rooted by meta nodes in u children    and constant w x  x   
input

  forall v  p arents u   assume var v     y   do
 
forall i               d y     do
 
if u  v childreni then
 
v childreni  v childreni    u 
 
v childreni  v childreni  u children 
 
w y  yi    w y  yi    w x  x   
  remove u
   return reduced and or graph g

procedure isomorphismreduction
  and or graph g  isomorphic meta nodes u and v  list of meta node parents of u  denoted by
p arents u  
output   reduced and or graph g after the merging of u and v 
forall p  p arents u  do
if u  p childreni then
p childreni  p childreni    u 
p childreni  p childreni   v 

input

 
 
 
 

  remove u
  return reduced and or graph g

graph  then the common weight w x  x    has to be stored separately as a constant  procedure
redundancyreduction formalizes the redundancy elimination 
d efinition     isomorphic meta nodes  given a weighted and or search graph g represented
with meta nodes  two meta nodes u and v having var u    var v    x and  d x     k are
isomorphic iff 
 a  u childreni   v childreni i              k  and
 b  wu  x  xi     wv  x  xi   i              k    where wu   wv are the weights of u and v  
procedure isomorphismreduction formalizes the process of merging isomorphic metanodes  naturally  the and or graph obtained by merging isomorphic meta nodes is equivalent to
the original one  we can now define the and or multi valued decision diagram 
d efinition     aomdd  an and or multi valued decision diagram  aomdd  is a weighted
and or search graph that is completely reduced by isomorphic merging and redundancy removal 
namely 
    it contains no isomorphic meta nodes  and
    it contains no redundant meta nodes 

   

fiand or m ulti  valued d ecision d iagrams  aomdd s   for g raphical m odels

a

a

 k

 

b

c

 

d

 

k

z


 

 

z

k



y

c



d

y

 b  after eliminating the b
meta node

 a  fragment of an aomdd

figure     redundancy reduction
a
 

a

 k

 

 

k

b
 

c

 

d

 

 

c


 

b

k

 

e

 



k

c


k

 


k

 

y

d

 a  fragment of an aomdd

 

k

e



y

 b  after merging the isomorphic c meta nodes

figure     isomorphism reduction
example    figure    shows an example of applying the redundancy reduction rule to a portion
of an aomdd  on the left side  in figure    a   the meta node of variable b is redundant  we
dont show the weights of the or to and arcs  to avoid cluttering the figure   any of the values
            k  of b will lead to the same set of meta nodes  c  d          y   which are coupled in an and
arc  therefore  the meta node of b can be eliminated  the result is shown in figure    b   where
the meta nodes  c  d          y  and z are coupled in an and arc outgoing from a     
in figure    we show an example of applying the isomorphism reduction rule  in this case  the
meta nodes labeled with c in figure    a  are isomorphic  again  we omit the weights   the result
of merging them is shown in figure    b  
examples of aomdds appear in figures        and     note that if the weight on an or toand arc is zero  then the descendant is the terminal meta node    namely  the current path is a
dead end  cannot be extended to a solution  and is therefore linked directly to   

   using and or search to generate aomdds
in section     we described how we can transform an and or graph into an aomdd by applying
reduction rules  in section     we describe the explicit algorithm that takes as input a graphi   

fim ateescu   d echter   m arinescu

cal model  performs and or search with context based caching to obtain the context minimal
and or graph  and in section     we give the procedure that applies the reduction rules bottom
up to obtain the aomdd 
    algorithm and or s earch  aomdd
algorithm    called and or s earch  aomdd  compiles a graphical model into an aomdd 
a memory intensive  with context based caching  and or search is used to create the context minimal and or graph  see definition      the input to and or s earch  aomdd is a graphical
model m and a pseudo tree t   that also defines the or context of each variable 
each variable xi has an associated cache table  whose scope is the context of xi in t   this
ensures that the trace of the search is the context minimal and or graph  a list denoted by lxi
 see line      is used for each variable xi to save pointers to meta nodes labeled with xi   these
lists are used by the procedure that performs the bottom up reduction  per layers of the and or
graph  one layer contains all the nodes labeled with one given variable   the fringe of the search
is maintained on a stack called open  the current node  either or or and node  is denoted by
n  its parent by p  and the current path by n   the children of the current node are denoted by
successors n   for each node n  the boolean attribute consistent n  indicates if the current path
can be extended to a solution  this information is useful for pruning the search space 
the algorithm is based on two mutually recursive steps  forward  beginning at line    and
backtrack  beginning at line      which call each other  or themselves  until the search terminates 
in the forward phase  the and or graph is expanded top down  the two types of nodes  and and
or  are treated differently according to their semantics 
before an or node is expanded  the cache table of its variable is checked  line     if the entry
is not null  a link is created to the already existing or node that roots the graph equivalent to the
current subproblem  otherwise  the or node is expanded by generating its and descendants  the
or to and weight  see definition     is computed in line     each value xi of xi is checked for
consistency  line      the least expensive check is to verify that the or to and weight is non zero 
however  the deterministic  inconsistent  assignments in m can be extracted to form a constraint
network  any level of constraint propagation can be performed in this step  e g   look ahead  arc
consistency  path consistency  i consistency etc    the computational overhead can increase  in the
hope of pruning the search space more aggressively  we should note that constraint propagation is
not crucial for the algorithm  and the complexity guarantees are maintained even if only the simple
weight check is performed  the consistent and nodes are added to the list of successors of n  line
     while the inconsistent ones are linked to the terminal   meta node  line     
an and node n labeled with hxi   xi i is expanded  line     based on the structure of the pseudo
tree  if xi is a leaf in t   then n is linked to the terminal   meta node  line      otherwise  an or
node is created for each child of xi in t  line     
the forward step continues as long as the current node is not a dead end and still has unevaluated
successors  the backtrack phase is triggered when a node has an empty set of successors  line     
note that  as each successor is processed  it is removed from the set of successors in line     when
the backtrack reaches the root  line      the search is complete  the context minimal and or graph
is generated  and the procedure b ottom u p r eduction is called 
when the backtrack step processes an or node  line      it saves a pointer to it in cache  and
also adds a pointer to the corresponding meta node to the list lxi   the consistent attribute of

   

fiand or m ulti  valued d ecision d iagrams  aomdd s   for g raphical m odels

algorithm    and or s earch   aomdd
input   m   hx  d  fi  pseudo tree t rooted at x    parents pai  or context  for every variable xi  
output   aomdd of m 
  forall xi  x do
initialize context based cache table cachexi  pai   with null entries
 
  create new or node t  labeled with xi   consistent t   true  push t on top of open
  while open     do
 
n  top open   remove n from open
   forward
 
successors n   
 
if n is an or node labeled with xi then
   or expand
if cachexi  asgn n   pai       null then
 
connect parent of n to cachexi  asgn n   pai   
 
   use the cached pointer
  
  
  
  
  
  
  
  
  
  

else
forall xi  di do
create new an d node t  labeled with hxi   xi i
w x  xi   

f  asgn n   pai   
f bt  xi  

if hxi   xi i is consistent with n then
consistent t   true
add t to successors n 
else
consistent t   f alse
make terminal   the only child of t

  
  
  
  
  
  
  
  

if n is an and node labeled with hxi   xi i then
if childrent  xi       then
make terminal   the only child of n
else
forall y  childrent  xi   do
create new or node t  labeled with y
consistent t   f alse
add t to successors n 

  
  
  
  
  
  

add successors n  to top of open
while successors n      do
let p be the parent of n
if n is an or node labeled with xi then
if xi    x  then
call bottomupreduction procedure

  
  
  
  
  
  

   constraint propagation

   and expand

   backtrack

   search is complete
   begin reduction to aomdd

cache asgn n   pai     n
add meta node of n to the list lxi
consistent p   consistent p   consistent n 
if consistent p     f alse then
remove successors p  from open
successors p   

  
  

if n is an and node labeled with hxi   xi i then
consistent p   consistent p   consistent n  

  
  

remove n from successors p 
np

   

   save in cache

   check if p is dead end

fim ateescu   d echter   m arinescu

procedure bottomupreduction
  a graphical model m   hx  d  fi  a pseudo tree t of the primal graph  rooted at x    context
minimal and or graph  and lists lxi of meta nodes for each level xi  
output   aomdd of m 
let d    x            xn   be the depth first traversal ordering of t
for i  n down to   do
let h be a hash table  initially empty
forall meta nodes n in lxi do
if h xi   n children            n childrenki   wn  xi   x             wn  xki   xki    returns a meta node
p then
merge n with p in the and or graph
input

 
 
 
 
 
 
 
 
 
  
  
  

else if n is redundant then
eliminate n from the and or graph
combine its weight with that of the parent
else
hash n into the table h 
h xi   n children            n childrenki   wn  xi   x             wn  xki   xki     n

   return reduced and or graph

the and parent p is updated by conjunction with consistent n   if the and parent p becomes
inconsistent  it is not necessary to check its remaining or successors  line      when the backtrack
step processes an and node  line      the consistent attribute of the or parent p is updated by
disjunction with consistent n  
the and or search algorithm usually maintains a value for each node  corresponding to a task
that is solved  we did not include values in our description because an aomdd is just an equivalent
representation of the original graphical model m  any task over m can be solved by a traversal
of the aomdd  it is however up to the user to include more information in the meta nodes  e g  
number of solutions for a subproblem  
    reducing the context minimal and or graph to an aomdd
procedure bottomupreduction processes the variables bottom up relative to the pseudo tree t  
we use the depth first traversal ordering of t  line     but any other bottom up ordering is as good 
the outer for loop  starting at line    goes through each level of the context minimal and or graph
 where a level contains all the or and and nodes labeled with the same variable  in other words it
contains all the meta nodes of that variable   for efficiency  and to ensure the complexity guarantees
that we will prove  a hash table  initially empty  is used for each level  the inner for loop  starting at
line    goes through all the metanodes of a level  that are also saved  or pointers to them are saved 
in the list lxi   for each new meta node n in the list lxi   in line   the hash table h is checked to
verify if a node isomorphic with n already exists  if the hash table h already contains a node p corresponding to the hash key  xi   n children            n childrenki   wn  xi   x             wn  xki   xki    
then p and n are isomorphic and should be merged  otherwise  if the new meta node n is redundant 
then it is eliminated from the and or graph  if none of the previous two conditions is met  then
the new meta node n is hashed into table h 

   

fiand or m ulti  valued d ecision d iagrams  aomdd s   for g raphical m odels

a
d

g

c

b

f

e

a

h

b
c
d

 a 

f
e

g

h

 b 

figure      a  constraint graph for c    c            c     where c    f  h  c    a  h 
c    a  b  g  c    f  g  c    b  f   c    a  e  c    c  e  c    c  d 
c    b  c   b  pseudo tree  bucket tree  for ordering d    a  b  c  d  e  f  g  h 

proposition   the output of procedure bottomupreduction is the aomdd of m along the
pseudo tree t   namely the resulting and or graph is completely reduced 
note that we explicated procedure bottomupreduction separately only for clarity  in practice  it can actually be included in algorithm and or s earch  aomdd  and the reduction rules
can be applied whenever the search backtracks  we can maintain a hash table for each variable  during the and or search  to store pointers to meta nodes  when the search backtracks out of an
or node  it can already check the redundancy of that meta node  and also look up in the hash table
to check for isomorphism  therefore  the reduction of the and or graph can be done during the
and or search  and the output will be the aomdd of m 
from theorem   and proposition   we can conclude 
t heorem   given a graphical model m and a pseudo tree t of its primal graph g  the aomdd

of m corresponding to t has size bounded by o n k wt  g    and it can be computed by algorithm

and or s earch  aomdd in time o n k wt  g     where wt  g  is the induced width of g over
the depth first traversal of t   and k bounds the domain size 

   using bucket elimination to generate aomdds
in this section we propose to use a bucket elimination  be  type algorithm to guide the compilation
of a graphical model into an aomdd  the idea is to express the graphical model functions as
aomdds  and then combine them with apply operations based on a be schedule  the apply is
very similar to that from obdds  bryant         but it is adapted to and or search graphs  it
takes as input two functions represented as aomdds based on the same pseudo tree  and outputs
the combination of initial functions  also represented as an aomdd based on the same pseudo tree 
we will describe it in detail in section     
we will start with an example based on constraint networks  this is easier to understand because
the weights on the arcs are all   or    and therefore are depicted in the figures by solid and dashed
lines  respectively 
example    consider the network defined by x    a  b          h   da           dh          and
the constraints  where  denotes xor   c    f h  c    ah  c    abg  c    f g 
   

fim ateescu   d echter   m arinescu

m 

a

m 
a

a
 

 

 

b
 

 

 

c
 

c
 

 

 

 

 

 

c
 

 

a

 

b

b

 

 

f

c
 

b
 

 

 

f
 

 

 

f
 

b

f

 

 

 

 

b

c
d
 

d

g

e
 

 

 

 

 

 

 

m 

g
 

 

h
 

 

 

 

d

e

 

m 

f

h
 

g

m 

m 

a
 

 

b

c

 

c
 

a

 

 

 

d
 

 

 

c

c
 

 

 

f

b

 

 

 

a

 

 

 

g

 

 

 

 

 

 

h
 

 

b

f
 

g
 

 

f

f

 

f
 

 

a

b
 

b
 

e

d
 

 

b

a

 

h

 

h
 

 

f
 

c

   

 

 

 

m 

c 

c

 

e

 

c

d
 

 

 

 

e

d

 

c
 

 

 

 

 

 

g

 

 

 

 

c

a

   

c 

c 

 

 

 

 

 

 

 

 

b

h

   

 

a
 

 

h

 

g

e

c 

 

 

a

 

g
 

g

f

f
 

b

g

h

m 

m 

 

b

   

c 

m 

a

a

 

e

e

 

 

c 

m 

a
 

d

d

d

m 

m 
 

   

 
m 

c 

 

h
 

 

f

 

f

   

   

g

c 

c 

h

figure     execution of be with aomdds
a
 

a

 

b
 

b
 

 

b

 

b

c
c
 

c
 

 

c
 

 

c
 

 

f
 

 

f
 

 

f
 

 

c

 

 

d

 

d

e

d
 

d
 

 

e
 

 

g
 

 

g
 

 

h
 

 

c

c

f

 

d

d

e

f

h
 

d

e

f

f

f

 

g

g

g

g

h

 

d

 

h

 

 a 

g

 

 b 

figure      a  the final aomdd   b  the obdd corresponding to d
c    b  f   c    a  e  c    c  e  c    c  d  c    b  c  the constraint graph is
shown in figure    a   consider the ordering d    a  b  c  d  e  f  g  h   the pseudo tree  or
bucket tree  induced by d is given in fig     b   figure    shows the execution of be with aomdds
along ordering d  initially  the constraints c  through c  are represented as aomdds and placed
in the bucket of their latest variable in d  the scope of any original constraint always appears on a

   

fiand or m ulti  valued d ecision d iagrams  aomdd s   for g raphical m odels

algorithm    be aomdd
  graphical model m   hx  d  fi  where x    x            xn    f    f            fr     order
d    x            xn  
output   aomdd representing if fi
  t   generatepseudotree g  d  
  for i    to r do
   place functions in buckets
 
place gfaomdd
in
the
bucket
of
its
latest
variable
in
d
i
input

  for i  n down to   do
message xi    g aomdd
 
 
while bucket xi       do
 
pick gfaomdd from bucket xi   
 
 
  

   process buckets
   initialize with aomdd of    
   combine aomdds in bucket of xi

bucket xi    bucket xi      gfaomdd   
message xi    apply message xi    gfaomdd  
add message xi   to the bucket of the parent of xi in t

   return message x   

path from root to a leaf in the pseudo tree  therefore  each original constraint is represented by an
aomdd based on a chain  i e   there is no branching into independent components at any point  
the chain is just the scope of the constraint  ordered according to d  for bi valued variables  the
original constraints are represented by obdds  for multiple valued variables they are mdds  note
that we depict meta nodes  one or node and its two and children  that appear inside each gray
node  the dotted edge corresponds to the   value  the low edge in obdds   the solid edge to the
  value  the high edge   we have some redundancy in our notation  keeping both and value nodes
and arc types  dotted arcs from   and solid arcs from    
the be scheduling is used to process the buckets in reverse order of d  a bucket is processed
by joining all the aomdds inside it  using the apply operator  however  the step of elimination
of the bucket variable is omitted because we want to generate the full aomdd  in our example 
the messages m    c     c  and m    c     c  are still based on chains  therefore they are
obdds  note that they contain the variables h and g  which have not been eliminated  however 
the message m    c     m     m  is not an obdd anymore  we can see that it follows the
structure of the pseudo tree  where f has two children  g and h  some of the nodes corresponding
to f have two outgoing edges for value   
the processing continues in the same manner  the final output of the algorithm  which coincides
with m    is shown in figure    a   the obdd based on the same ordering d is shown in fig 
   b   notice that the aomdd has    nonterminal nodes and    edges  while the obdd has   
nonterminal nodes and    edges 
    algorithm be aomdd
algorithm    called be aomdd  creates the aomdd of a graphical model by using a be schedule for apply operations  given an order d of the variables  first a pseudo tree is created based on
 
the primal graph  each initial function fi is then represented as an aomdd  denoted by gfaomdd
i
and placed in its bucket  to obtain the aomdd of a function  the scope of the function is ordered
according to d  a search tree  based on a chain  that represents fi is generated  and then reduced
by procedure bottomupreduction  the algorithm proceeds exactly like be  with the only difference that the combination of functions is realized by the apply algorithm  and variables are not
   

fim ateescu   d echter   m arinescu

eliminated but carried over to the destination bucket  the messages between buckets are initialized
with the dummy aomdd of    denoted by g aomdd   which is neutral for combination 
in order to create the compilation of a graphical model based on and or graphs  it is necessary
to traverse the and or graph top down and bottom up  this is similar to the inward and outward
message passing in a tree decomposition  note that be aomdd describes the bottom up traversal
explicitly  while the top down phase is actually performed by the apply operation  when two
aomdds are combined  after the top chain portion of their pseudo tree is processed  the remaining
independent branches are attached only if they participate in the newly restricted set of solutions 
this amounts to an exchange of information between the independent branches  which is equivalent
to the top down phase 
    the aomdd apply operation
we will now describe how to combine two aomdds  the apply operator takes as input two
aomdds representing functions f  and f  and returns an aomdd representing f   f   
in obdds the apply operator combines two input diagrams based on the same variable ordering 
likewise  in order to combine two aomdds we assume that their pseudo trees are identical  this
condition is satisfied by any two aomdds in the same bucket of be aomdd  however  we
present here a version of apply that is more general  by relaxing the previous condition from
identical to compatible pseudo trees  namely  there should be a pseudo tree in which both can be
embedded  in general  a pseudo tree induces a strict partial order between the variables where a
parent node always precedes its child nodes 
d efinition     compatible pseudo trees  a strict partial order d     x       over a set x is
consistent with a strict partial order d     y       over a set y  if for all x    x   x  y  if
x     x  then x     x    two partial orders d  and d  are compatible iff there exists a partial
order d that is consistent with both  two pseudo trees are compatible iff the partial orders induced
via the parent child relationship  are compatible 
for simplicity  we focus on a more restricted notion of compatibility  which is sufficient when
using a be like schedule for the apply operator to combine the input aomdds  as described in
section     the apply algorithm that we will present can be extended to the more general notion
of compatibility 
d efinition     strictly compatible pseudo trees  a pseudo tree t  having the set of nodes x 
can be embedded in a pseudo tree t having the set of nodes x if x   x and t  can be obtained
from t by deleting each node in x   x  and connecting its parent to each of its descendents  two
pseudo trees t  and t  are strictly compatible if there exists t such that both t  and t  can be
embedded in t  
algorithm apply  algorithm    takes as input one node from gfaomdd and a list of nodes from
ggaomdd   initially  the node from gfaomdd is its root node  and the list of nodes from ggaomdd is in fact
also made of just one node  which is its root  we will sometimes identify an aomdd by its root
node  the pseudo trees tf and tg are strictly compatible  having a target pseudo tree t  
the list of nodes from ggaomdd always has a special property  there is no node in it that can be the
ancestor in t of another  we refer to the variable of the meta node   therefore  the list z            zm
   

fiand or m ulti  valued d ecision d iagrams  aomdd s   for g raphical m odels

apply  v    z            zm  
input   aomdds gfaomdd with nodes vi and ggaomdd with nodes zj   based on strictly compatible pseudo
trees tf   tg that can be embedded in t  
var v    is an ancestor of all var z             var zm   in t  
var zi   and var zj   are not in ancestor descendant relation in t   i    j 
output   v    z          zm    based on t  
if h   v    z            zm      null then return h   v    z            zm   
   is in cache
if  any of v    z            zm is    then return  
if  v       then return  
if  m      then return v 
   nothing to combine
create new nonterminal meta node u
var u   var v     call it xi   with domain di    x            xki    
for j    to ki do
u childrenj  
   children of the j th and node of u
   assign weight from v 
wu  xi   xj    wv   xi   xj  
if    m      and  var v      var z      xi     then
temp children  z   childrenj
   combine input weights
wu  xi   xj    wv   xi   xj    wz   xi   xj  

algorithm   

 
 
 
 
 
 
 
 
 
  
  
  
  
  

else

  
  
  
  
  

group nodes from v   childrenj  temp children in several  v     z             z r  
for each  v     z             z r   do
y  apply v     z             z r  
if  y      then
u childrenj     break

  
  

temp children   z            zm  

else
u childrenj  u childrenj   y 

  
  
  

if  u children            u childrenki   and  wu  xi   x              wu  xi   xki    then
promote wu  xi   x    to parent
return u children 
   redundancy

  
  

if  h   xi   u children            u childrenki   wu  xi   x             wu  xki   xki       null  then
return h   xi   u children            u childrenki   wu  xi   x             wu  xki   xki   
   isomorphism

   let h   v    z            zm     u
   let h   xi   u children            u childrenki   w u  xi   x             w u  xki   xki      u
   return u

   add u to h 
   add u to h 

from g expresses a decomposition with respect to t   so all those nodes appear on different branches 
we will employ the usual techniques from obdds to make the operation efficient  first  if one of
the arguments is    then we can safely return    second  a hash table h  is used to store the nodes
that have already been processed  based on the nodes  v    z            zr    therefore  we never need
to make multiple recursive calls on the same arguments  third  a hash table h  is used to detect
isomorphic nodes  this is typically split in separate tables for each variable  if at the end of the
recursion  before returning a value  we discover that a meta node with the same variable  the same
children and the same weights has already been created  then we dont need to store it and we simply
return the existing node  and fourth  if at the end of the recursion we discover that we created a
redundant node  all the children are the same and all the weights are the same   then we dont store
it  and return instead one of its identical lists of children  and promote the common weight 
   

fim ateescu   d echter   m arinescu

a
 
 
 
 
 
 
 
 

b
 
 
 
 
 
 
 
 

c
 
 
 
 
 
 
 
 

f abc 
 
 
 
 
 
 
 
 

a
 
 
 
 
 
 
 
 

a
b
c

a

a 
 

 

c

a 

 

 

a 

b 

a 

b 

 

b

b

d

d

 

d
 

d

c

a
 

 

 

a

a b 
b

 

b 

a

 

b
 

 

 

g abc 
 
 
 
 
 
 
 
 

a
 

 

 

d
 
 
 
 
 
 
 
 

b 
 

b

a 

b
 
 
 
 
 
 
 
 

 

b 

 

b

a b 

b 

 

 

c
 

b 

 

a b 

 

a 

 

 

d

b 
 

 

b
 

 

d

b 
 

 

 

 

figure     example of apply operation
note that v  is always an ancestor of all z            zm in t   we consider a variable in t to be an
ancestor of itself  a few self explaining checks are performed in lines      line   is specific for
multiplication  and needs to be changed for other combination operations  the algorithm creates a
new meta node u  whose variable is var v      xi  recall that var v    is highest  closest to root 
in t among v    z            zm   then  for each possible value of xi   line    it starts building its list of
children 
one of the important steps happens in line     there are two lists of meta nodes  one from
each original aomdd f and g  and we will refer only to their variables  as they appear in t   each
of these lists has the important property mentioned above  that its nodes are not ancestors of each
other  the union of the two lists is grouped into maximal sets of nodes  such that the highest node
in each set is an ancestor of all the others  it follows that the root node in each set belongs to one of
the original aomdd  say v   is from f   and the others  say z             z r are from g  as an example 
suppose t is the pseudo tree from fig     b   and the two lists are  c  g  h  from f and  e  f  
from g  the grouping from line    will create  c  e  and  f   g  h   sometimes  it may be the
case that a newly created group contains only one node  this means there is nothing more to join
in recursive calls  so the algorithm will return  via line    the single node  from there on  only one
of the input aomdds is traversed  and this is important for the complexity of apply  discussed
below 
example    figure    shows the result of combining two boolean functions by an and operation
 or product   the input functions f and g are represented by aomdds based on chain pseudo
trees  while the results is based on the pseudo tree that expresses the decomposition after variables
a and b are instantiated  the apply operator performs a depth first traversal of the two input
aomdds  and generates the resulting aomdd based on the output pseudo tree  similar to the
case of obdds  a function or an aomdd can be identified by its root meta node  in this example
the input meta nodes have labels  a    a    b    b    etc    the output meta node labeled by a  b  is
   

fiand or m ulti  valued d ecision d iagrams  aomdd s   for g raphical m odels

the root of a diagram that represents the function obtained by combining the functions rooted by a 
and b   
    complexity of apply and be aomdd
we now provide a characterization of the complexity of apply  based on different criteria  the
following propositions are inspired by the results that govern obdd apply complexity  but are
adapted for pseudo tree orderings 
an aomdd along a pseudo tree can be regarded as a union of regular mdds  each restricted
to a full path from root to a leaf in the pseudo tree  let t be such a path in t   based on the
definition of strictly compatible pseudo trees  t has corresponding paths tf in tf and tg in tg  
the mdds from f and g corresponding to tf and tg can be combined using the regular mdd
apply  this process can be repeated for every path t   the resulting mdds  one for each path in t
need to be synchronized on their common parts  on the intersection of the paths   the algorithm we
proposed does all this processing at once  in a depth first search traversal over the inputs  based on
our construction  we can give a first characterization of the complexity of aomdd apply as being
governed by the complexity of mdd apply 
proposition   let             l be the set of paths in t enumerated from left to right and let gfi and
ggi be the mdds restricted to path i   then the size of the output of aomdd apply
by
p
p is bounded
i     g i    n  max  g i     g i    the time complexity is also bounded by
i     g i   
 g
 g
i
g
g
g
i f
i f
f
n  maxi  gfi     ggi   
a second characterization of the complexity can be given  similar to the mdd case  in terms of
total number of nodes of the inputs 
proposition   given two aomdds gfaomdd and ggaomdd based on strictly compatible pseudo trees 
the size of the output of apply is at most o   gfaomdd      ggaomdd    
we can further detail the previous proposition as follows  given aomdds gfaomdd and ggaomdd  
based on compatible pseudo trees tf and tg and the common pseudo tree t   we define the intersection pseudo tree tf g as being obtained from t by the following two steps      mark all the
subtrees whose nodes belong to either tf or tg but not to both  the leaves of each subtree should be
leaves in t        remove the subtrees marked in step     from t   steps     and     are applied just
once  that is  not recursively   the part of aomdd gfaomdd corresponding to the variables in tf g
is denoted by gff g   and similarly for ggaomdd it is denoted by ggf g  
proposition   the time complexity of
 gfaomdd      ggaomdd    

apply

and the size of the output are o  gff g     ggf g    

we now turn to the complexity of the be aomdd algorithm  each bucket has an associated
bucket pseudo tree  the top chain of the bucket pseudo tree for variable xi contains all and only
the variables in context xi    for any other variables that appear in the bucket pseudo tree  their
associated buckets have already been processed  the original functions that belong to the bucket
of xi have their scope included in context xi    and therefore their associated aomdds are based
   

fim ateescu   d echter   m arinescu

on chains  any other functions that appear in bucket of xi are messages received from independent branches below  therefore  any two functions in the bucket of xi only share variables in the
context xi    which forms the top chain of the bucket pseudo tree  we can therefore characterize
the complexity of apply in terms of treewidth  or context size of a bucket variable 
proposition   given two aomdds in the same bucket of be aomdd  the time and space complexity of the apply between them is at most exponential in the context size of the bucket variable
 namely the number of the variables in the top chain of the bucket pseudo tree  
we can now bound the complexity of be aomdd and the output size 
t heorem   the space complexity of be aomdd and the size of the output aomdd are

o n k w    where n is the number of variables  k is the maximum domain size and w is the treewidth

of the bucket tree  the time complexity is bounded by o r k w    where r is the number of initial
functions 

   aomdds are canonical representations
it is well known that obdds are canonical representations of boolean functions given an ordering
of the variables  bryant         namely a strict ordering of any cnf specification of the same
boolean function will yield an identical obdd  and this property extends to mdds  srinivasan
et al          the linear ordering of the variables defines a chain pseudo tree that captures the
structure of the obdd or mdd  in the case of aobdds and aomdds  the canonicity is with
respect to a pseudo tree  transitioning from total orders  that correspond to a linear ordering  to
partial orders  that correspond to a pseudo tree ordering   on the one hand we gain the ability to have
a more compact compiled structure  but on the other hand canonicity is no longer with respect to
all equivalent graphical models  but only relative to those graphical models that are consistent with
the pseudo tree that is used  specifically  if we start from a strict ordering we can generate a chain
aomdd that will be canonical relative to all equivalent graphical models  if however we want to
exploit additional decomposition we can use a partial ordering captured by a pseudo tree and create
a more compact aomdd  this aomdd however is canonical relative to those equivalent graphical
models that can accept the same pseudo tree that guided the aomdd  in general  aomdd can be
viewed as a more flexible framework for compilation that allows both partial and total orderings 
canonicity is restricted to a subset of graphical models whose primal graph agrees with the partial
order but it is relevant to a larger set of orderings which are consistent with the pseudo tree 
in the following subsection we discuss the canonicity of aomdd for constraint networks  the
case of general weighted graphical models is discussed in section   
    aomdds for constraint networks are canonical representations
the case of constraint networks is more straightforward  because the weights on the or to and
arcs can only be   or    we will show that any equivalent constraint networks  that admit the same
pseudo tree t   have the same aomdd based on t   we start with a proposition that will help prove
the main theorem 
proposition   let f be a function  not always zero  defined by a constraint network over x  given
a partition  x            xm   of the set of variables x  namely  xi  xj      i    j  and x  
   

fiand or m ulti  valued d ecision d iagrams  aomdd s   for g raphical m odels

i
i
m
i   x    if f   f          fm and f   g          gm   such that scope fi     scope gi     x for
all i              m   then fi   gi for all i              m   namely  if f can be decomposed over the
given partition  then the decomposition is unique 

we are now ready to show that aomdds for constraint networks are canonical representations
given a pseudo tree 
t heorem    aomdds are canonical for a given pseudo tree  given a constraint network  and
a pseudo tree t of its constraint graph  there is a unique  up to isomorphism  aomdd that represents it  and it has the minimal number of meta nodes 
a constraint network is defined by its relations  or functions   there exist equivalent constraint
networks that are defined by different sets of functions  even having different scope signatures 
however  equivalent constraint networks define the same function  and we can ask if the aomdd
of different equivalent constraint networks is the same  the following corollary can be derived
immediately from theorem   
corollary   two equivalent constraint networks that admit the same pseudo tree t have the same
aomdd based on t  

   canonical aomdds for weighted graphical models
theorem   ensures that the aomdd is canonical for constraint networks  namely for functions that
can only take the values   or    the proof relied on the fact that the or to and weights can only
be   or    and on proposition   that ensured the unique decomposition of a function defined by a
constraint network 
in this section we turn to general weighted graphical models  we can first observe that proposition   is no longer valid for general functions  this is because the valid solutions  having strictly
positive weight  can have their weight decomposed in more than one way into a product of positive
weights 
therefore we raise the issue of recognizing nodes that root and or graphs that represent the
same universal function  even though the graphical representation is different  we will see that the
aomdd for a weighted graphical model is not unique under the current definitions  but we can
slightly modify them to obtain canonicity again  we have to note that canonicity of aomdds for
weighted graphical models  e g   belief networks  is far less crucial than in the case of obdds that
are used in formal verification  even more than that  sometimes it may be useful not to eliminate
the redundant nodes  in order to maintain a simpler semantics of the and or graph that represents
the model 
the loss of canonicity of aomdd for weighted graphical models can happen because of the
weights on the or to and arcs  and we suggest a possible way of re enforcing it if a more compact
and canonical representation is needed 
example    figure    shows a weighted graphical model  defined by two  cost  functions 
f  m  a  b  and g m  b  c   assuming the order  m a b c   figure    shows the and or search
tree on the left  the arcs are labeled with function values  and the leaves show the value of the
corresponding full assignment  which is the product of numbers on the arcs of the path   we can
   

fim ateescu   d echter   m arinescu

a

m
 
 
 
 
 
 
 
 

m
a

m

b
b
c

c

a
 
 
 
 
 
 
 
 

b f m a b 
 
  
 
 
 
  
 
 
 
 
 
  
 
 
 
 

m
 
 
 
 
 
 
 
 

b
 
 
 
 
 
 
 
 

c g m b c 
 
 
 
 
 
  
 
  
 
 
 
  
 
 
 
 

figure     weighted graphical model
m
 

 

 

 

a

a

a

a

 

 

b

 

b

 

  

 

 

 

 

 

c

c

 

 

 

     

  
 

c

 

 

 

 

 

     

     

  
 

 

b

 

  

 

c

  

 

b

  

 

m

c

b

 

 

 

c

c

 

  

 

 

 

  

 

 

 

 

 

 

 

 

 

     

     

     

 

b

  

 

  

 

 

 

 

 

 

c

 
 

     

 

 

 

  
 

b

 
 

c

 

 

b

 

c

  

     

 

  

 

 

 

 

 

c

c

  

 

  

 

 

 

 

 

 

 

     

figure     and or search tree and context minimal graph

see that either value of m    or    gives rise to the same function  because the leaves in the two
subtrees have the same values   however  the two subtrees can not be identified as representing the
same function by the usual reduction rules  the right part of the figure shows the context minimal
graph  which has a compact representation of each subtree  but does not share any of their parts 
what we would like in this case is to have a method of recognizing that the left and right subtrees
corresponding to m     and m     represent the same function  we can do this by normalizing
the values in each level  and processing bottom up  in figure    left  the values on the or to and
arcs have been normalized  for each or variable  and the normalization constant was promoted
up to the or value  in figure    right  the normalization constants are promoted upwards again
by multiplication  this process does not change the value of each full assignment  and therefore
produces equivalent graphs 
we can see already that some of the nodes labeled by c can now be merged  producing the graph
in figure    on the left  continuing the same process we obtain the aomdd for the weighted graph 
shown in figure    on the right 
we can define the aomdd of a weighted graphical model as follows 
d efinition     aomdd of weighted graphical model  the aomdd of a weighted graphical
model is an and or graph  with meta nodes  such that      for each meta node  its weights sum to
       the root meta node has a constant associated with it      it is completely reduced  namely it
has no isomorphic meta nodes  and no redundant meta nodes 

   

fiand or m ulti  valued d ecision d iagrams  aomdd s   for g raphical m odels

m
m

 

 

a

a

 

 

b

 

b

b

  

 

  

 

 

 

 

 

 
   
 

   

     

 

 

     

   

 

 

 

 

 

 

 

     

 

 

 

    

 

 

   

    

 

 

 

 

    

 

 

b

    

     

 

    

 

c

   

 

b

    

c

     

 

b

    

   c
   

a

b

  

   c

 

a
 

b

 
 

   c

c

 

 

    

 

 

c

    

c

   

 

   

 

    

 

 

    
 

figure     normalizing values bottom up
   

m

   
 

m

   

 
 

a

 

a
a

 

 

b

  
 

 

b

   

   

 

 

 

b

  
 

  
 

b

   

   

 

 

c

   
 

 

    
 

       

 

 

b

  

b

      

 

       

 

 

c

   

       

       

      

 

 

c

    

   

 

 

c

   
 

    
 

    
 

figure     aomdd for the weighted graph
the procedure of transforming a weighted and or graph into an aomdd is very similar to
procedure b ottom u p r eduction from section    the only difference is that when a new layer
is processed  first the meta node weights are normalized and promoted to the parent  and then the
procedure continues as usual with the reduction rules 
t heorem   given two equivalent weighted graphical models that accept a common pseudo tree
t   normalizing arc values together with exhaustive application of reduction rules yields the same
and or graph  which is the aomdd based on t  
finite precision arithmetic the implementation of the algorithm described in this section may
prove to be challenging on machines that used finite precision arithmetic  since the weights are
real valued  the repeated normalization may lead to precision errors  one possible approach  which
we also used in our experiments  is to define some  tolerance  for some user defined sufficiently
small   and consider the weights to be equal if they are within  of each other 

   semantic treewidth
a graphical model m represents a universal function f   fi   the function f may be represented
by different graphical models  given a particular pseudo tree t   that captures some of the structural
information of f   we are interested in all the graphical models that accept t as a pseudo tree  namely
their primal graphs only contain edges that are backarcs in t   since the size of the aomdd for f
based on t is bounded in the worst case by the induced width of the graphical model along t   we
define the semantic treewidth to be 
   

fim ateescu   d echter   m arinescu

 
a

 

 

b
c

c

o
b

o

 

 

a

 

 

o
o

c
d

a

o

d

b

 

o

a b
   
   
   
   
   
   

o
o

 a  the two solutions

a c
   
   
   
   
   
   
   
   

a d
   
   
   
   
   
   
   
   
   
   

d
b c
   
   
   
   
   
   

b d
   
   
   
   
   
   
   
   

c d
   
   
   
   
   
   

 b  first model

a

a b
   
   

b

c

b c
   
   

d

c d
   
   

 c  second model

figure     the   queen problem
d efinition     semantic treewidth  the semantic treewidth of a graphical model m relative
to a pseudo tree t denoted by swt  m   is the smallest treewidth taken over all models r that
are equivalent to m  and accept the pseudo tree t   formally  it is defined by swt  m   
minr u r  u m  wt  r   where u m  is the universal function of m  and wt  r  is the induced
width of r along t   the semantic treewidth of a graphical model  m  is the minimal semantic
treewidth over all the pseudo trees that can express its universal function 
computing the semantic treewidth can be shown to be np hard  
t heorem   computing the semantic treewidth of a graphical model m is np hard 
theorem   shows that computing the semantic treewidth is hard  and it is likely that the actual
complexity is even higher  however  the semantic treewidth can explain why sometimes the minimal
and or graph or obdd are much smaller than the exponential in treewidth or pathwidth upper
bounds  in many cases  there could be a huge disparity between the treewidth of m and the semantic
treewidth along t  
example    figure    a  shows the two solutions of the   queen problem  the problem is expressed by a complete graph of treewidth    given in figure    b   figure    c  shows an equivalent
problem  i e   that has the same set of solutions   which has treewidth    the semantic treewidth of
the   queen problem is   
based on the fact that an aomdd is a canonical representation of the universal function of a
graphical model  we can conclude that the size of the aomdd is bounded exponentially by the
semantic treewidth along the pseudo tree  rather than the treewidth of the given graphical model
representation 
proposition   the size of the aomdd of a graphical model m is bounded by o n k swt  m    
where n is the number of variables  k is the maximum domain size and swt  m  is the semantic
treewidth of m along the pseudo tree t  
   we thank david eppstein for the proof 

   

fiand or m ulti  valued d ecision d iagrams  aomdd s   for g raphical m odels

a
a

b

b

c

c

b

m

d

d

c

n

d

p

 

 

 a  obdd representation

 b  primal graph with hidden
variables m  n and p  

figure     the parity function
example    consider a constraint network on n variables such that every two variables are constrained by equality  x   y    one graph representation is a complete graph  another is a chain
and another is a tree  if the problem is specified as a complete graph  and if we use a linear order 
the obdd will have a linear size because there exists a representation having a pathwidth of  
 rather than n  
while the semantic treewidth can yield a much better upper bound on the aomdd  it can also
be a very bad bound  it is well known that the parity function on n variables has a very compact 
chain like obdd representation  yet  the only constraint network representation of a parity function
is the function itself  namely a complete graph on all the variables   whose treewidth and semantic
treewidth is its number of variables  n  the obdd representation of the parity function suggests
that the addition of hidden variables can simplify its presentation  we show an example in figure
    on the left side  in figure    a  we have the obdd representation of the parity function for
four binary variables  a graphical model would represent this function by a complete graph on the
four variables  however  we could add the extra variables m  n and p in figure    b   sometimes
called hidden variables  that can help decompose the model  in this case m can form a constraint
together with a and b such that m represents the parity of a and b  namely m     if a  b     
where  is the parity  xor  operator  similarly  n would capture the parity of m and c  and p
would capture the parity of n and d  and would also give the parity of the initial four variables 
the two structures are surprisingly similar  it would be interesting to study further the connection
between hidden variables and compact aobdds  but we leave this for future work 

    experimental evaluation
our experimental evaluation is in preliminary stages  but the results we have are already encouraging  we ran the search based compile algorithm  by recording the trace of the and or search  and
then reducing the resulting and or graph bottom up  in these results we only applied the reduction by isomorphism and still kept the redundant meta nodes  we implemented our algorithms in
c   and ran all experiments on a    ghz intel core   duo with  gb of ram  running windows 

   

fim ateescu   d echter   m arinescu

     benchmarks
we tested the performance of the search based compilation algorithm on random bayesian networks  instances from the bayesian network repository and a subset of networks from the uai  
inference evaluation dataset 
random bayesian networks the random bayesian networks were generated using parameters
 n  k  c  p   where n is the number of variables  k is the domain size  c is the number of conditional
probability tables  cpts  and p is the number of parents in each cpt  the structure of the network
was created by randomly picking c variables out of n and  for each  randomly picking p parents from
their preceding variables  relative to some ordering  the remaining n  c variables are called root
nodes  the entries of each probability table were generated randomly using a uniform distribution 
and the table was then normalized  it is also possible to control the amount of determinism in the
network by forcing a percentage det of the cpts to have only   and   entries 
bayesian network repository the bayesian network repository  contains a collection of belief
networks extracted from various real life domains which are often used for benchmarking probabilistic inference algorithms 
uai   inference evaluation dataset the uai      inference evaluation dataset  contains a
collection of random as well as real world belief networks that were used during the first uai     
inference evaluation contest  for our purpose we selected a subset of networks which were derived
from the iscas   digital circuits benchmark   iscas   circuits are a common benchmark used
in formal verification and diagnosis  each of these circuits was converted into a bayesian network
by removing flip flops and buffers in a standard way  creating a deterministic conditional probability
table for each gate  and putting uniform distributions on the input signals 
     algorithms
we consider two search based compilation algorithms  denoted by aomdd bcp and aomddsat  respectively  that reduce the context minimal and or graph explored via isomorphism  while
exploiting the determinism  if any  present in the network  the approach we take for handling the
determinism is based on unit resolution over a cnf encoding  i e   propositional clauses  of the zero
probability tuples of the cpts  the idea of using unit resolution during search for bayesian networks was first explored by allen and darwiche         aomdd bcp is conservative and applies
only unit resolution at each node in the search graph  whereas aomdd sat is more aggressive and
detects inconsistency by running a full sat solver  we used the zchaff sat solver  moskewicz 
madigan  zhao  zhang    malik        for both unit resolution as well as full satisfiability  for
comparison  we also ran an or version of aomdd bcp  called mdd bcp 
for reference we also report results obtained with the ace  compiler  ace compiles a bayesian
network into an arithmetic circuit  ac  and then uses the ac to answer multiple queries with respect to the network  an arithmetic circuit is a representation that is equivalent to and or graphs
 mateescu   dechter         each time ace compiler is invoked  it uses one of two algorithms
as the basis for compilation  first  if an elimination order can be generated for the network having
  
  
  
  

http   www cs huji ac il compbio repository 
http   ssli ee washington edu bilmes uai  inferenceevaluation
available at  http   www fm vslib cz kes asic iscas 
available at  http   reasoning cs ucla edu ace

   

fiand or m ulti  valued d ecision d iagrams  aomdd s   for g raphical m odels

network

 w   h 

 n  k 

ace
 nodes time

mdd w  bcp
aomdd w  bcp
aomdd w  sat
 meta  cm or  time
 meta  cm or 
time  meta  cm or 
time
bayesian network repository
alarm
               
                                
   
   
    
   
   
    
cpcs  
                
            
               
                  
    
cpcs   
                
           
                                     
cpcs   b                                 
diabetes
                                
hailfinder                 
          
     
     
          
     
    
mildew
                              
                                              
mm
                  
           
               
                        
munin 
                                 
munin 
                                 
munin 
                                 
pathfinder                  
                                    
                                     
pigs
                              
                                                
water
                
                                                 
                  
    
uai   evaluation dataset
bn   
                 
          
                                           
bn   
                 
           
                                                    
bn   
                 
          
                                           
bn   
                 
           
                                              
bn   
                 
                                                  
          
     
    
bn   
                 
                             
     
     
          
     
    
bn   
                 
                             
     
     
    
   
     
    
bn   
                 
                             
     
     
          
     
    
bn   
                 
                             
     
     
          
     
    
bn   
                 
          
     
          
     
     
    
   
   
    
bn   
                 
                             
     
     
    
   
     
    
bn   
                 
                                              
                        
bn   
                 
                             
     
     
          
     
    
bn   
                 
                             
            
          
     
    
bn   
                 
          
               
                        
bn   
                 
          
                        
   
     
    
positive random bayesian networks  n     k    p    c    
r    
                
           
               
                  
    
r    
                
           
               
                  
    
r    
                
           
               
                  
    
r    
                
           
     
     
          
     
    
r    
                
            
               
                  
    
r    
                
            
               
                  
    
r    
                
           
               
                  
    
r    
                
           
               
                  
    
r    
                
           
     
     
          
     
    
r     
                
           
     
     
          
     
    
deterministic random bayesian networks  n      k    p    c     and det       of the cpts containing only   and   entries
r   d                      
           
               
                        
r   d                                   
               
                        
r   d                                   
                                             
r   d                                   
               
                        
r   d                                   
                                             
r   d                                   
                                             
r   d                                   
                                             
r   d                      
           
               
                        
r   d                                   
               
                        
r   d                                    
               
                        

table    results for experiments with    bayesian networks from   problem classes  w  
treewidth  h   depth of pseudo tree  n   number of variables  k   domain size  time
given in seconds  bold types highlight the best results across rows 

   

fim ateescu   d echter   m arinescu

sufficiently small induced width  then tabular variable elimination will be used as the basis  this
algorithm is similar to the one discussed by chavira and darwiche         but uses tables to represent factors rather than adds  if the induced width is large  then logical model counting will be
used as the basis  tabular variable elimination is typically efficient when width is small but cannot
handle networks when the width is larger  logical model counting  on the other hand  incurs more
overhead than tabular variable elimination  but can handle many networks having larger treewidth 
both tabular variable elimination and logical model counting produce acs that exploit local structure  leading to efficient online inference  when logical model counting is invoked  it proceeds
by encoding the bayesian network into a cnf  chavira   darwiche        chavira  darwiche   
jaeger         simplifying the cnf  compiling the cnf into a d dnnf  and then extracting the ac
from the compiled d dnnf  a dtree over the cnf clauses drives the compilation step 
in all our experiments we report the compilation time in seconds  time   the number of or
nodes in the context minimal graph explored   cm   the number of meta nodes of the resulting
aomdd   meta   as well as the size of the ac compiled by ace   nodes   for each network we
specify the number of variables  n   domain size  k   induced width  w   and pseudo tree depth  h  
a   stands for exceeding the  gb memory limit by the respective algorithm  the best performance
points are highlighted 
     evaluation on bayesian networks
table   reports the results obtained for experiments with    bayesian networks  the aomdd
compilers as well as ace used the min fill heuristic  kjaerulff        to construct the guiding
pseudo tree and dtree  respectively 
       bayesian n etworks r epository
we see that ace is overall the fastest compiler on this domain  outperforming both aomdd bcp
and aomdd sat with up to several orders of magnitude  e g   mildew  pigs   however  the
diagrams compiled by ace and aomdd bcp  resp  aomdd sat  are comparable in size  in
some cases  aomdd bcp and aomdd sat were able to compile much smaller diagrams than
ace  for example  the diagram produced by aomdd bcp for the mildew network is    times
smaller than the one compiled by ace  in principle the output produced by ace and aomdd
should be similar if both are guided by the same pseudo tree dtree  our scheme should be viewed
as a compilation alternative which     extends decision diagrams and     mimics traces of search
properties that may make this representation accessible  the or compiler mdd bcp was able
to compile only   out of the    test instances  but their sizes were far larger than those produced
by aomdd bcp  for instance  on the pathfinder network  aomdd bcp outputs a decision
diagram almost   orders of magnitude smaller than mdd bcp 
       uai   dataset
for each of the uai   dataset instances we picked randomly    variables and instantiated as
evidence  we see that ace is the best performing compiler on this dataset  aomdd bcp is
competitive with ace in terms of compile time only on   out the    test instances  aomdd sat
is able to compile the smallest diagrams for   networks only  e g   bn     bn     bn     bn    
bn     bn      as before  the difference in size between the compiled data structures produces
by mdd bcp and aomdd bcp is up to   orders of magnitude in favor of the latter 
   

fiand or m ulti  valued d ecision d iagrams  aomdd s   for g raphical m odels

       r andom n etworks
the problem instances denoted by r     through r      were generated from a class of random
belief networks with parameters  n       k      p      c        similarly  the instances denoted
by r   d     through r   d      belong to a class with parameters  n        k      p      c  
     in the latter case  det       of the cpts are deterministic  namely they contain only   and
  probability tuples  these test instances were compiled without any evidence  we see that on this
domain aomdd bcp aomdd sat were able to compile the smallest diagrams  which were on
average about   times smaller than those produced by ace  however  ace was again the fastest
compiler  notice that the or compiler mdd bcp ran out of memory in all test cases 
     the impact of variable ordering
as theory dictates  the aomdd size is influenced by the quality of the guiding pseudo tree  in
addition to the min fill heuristic we also considered the hypergraph heuristic which constructs the
pseudo tree by recursively decomposing the dual hypergraph associated with the graphical model 
this idea was also explored by darwiche        for constructing dtrees that guide ace 
since both the min fill and hypergraph partitioning heuristics are randomized  namely ties are
broken randomly   the size of the aomdd guided by the resulting pseudo tree may vary significantly from one run to the next  figure    displays the aomdd size using hypergraph and min fill
based pseudo trees for   networks selected from table    over    independent runs  we also record
the average induced width and depth obtained for the pseudo trees  see the header of each plot in
figure      we see that the two heuristics do not dominate each other  namely the variance in output
size is quite significant in both cases 
     memory usage
table   shows the memory usage  in mbytes  of ace  aomdd bcp and aomdd sat  respectively  on the bayesian networks from table    we see that in some cases the aomdd based compilers require far less memory than ace  for example  on the mildew network  both aomddbcp and aomdd sat use about    mb of memory to compile the and or decision diagram 
while ace requires as much as     mb of memory  moreover  the compiled aomdd has in this
case about one order of magnitude fewer nodes than that constructed by ace  when comparing the
two and or search based compilers  we observe that on networks with a significant amount of
determinism  such as those from the uai   evaluation dataset  aomdd sat uses on average two
times less memory than aomdd bcp  the most dramatic savings in memory usage due to the aggressive constraint propagation employed by aomdd sat compared with aomdd bcp can be
seen on the bn    network  in this case  the difference in memory usage between aomdd sat
and aomdd bcp is about   orders of magnitude in favor of the former 

    related work
the related work can be viewed along two directions      the work related to the and or search
idea for graphical models and     the work related to compilation for graphical models that exploits
problem structure 
an extensive discussion for     was provided in the previous work of dechter and mateescu
        since this is not the focus of the paper  we just mention that the and or idea was origi   

fim ateescu   d echter   m arinescu

figure     effect of variable ordering 

   

fiand or m ulti  valued d ecision d iagrams  aomdd s   for g raphical m odels

network

ace
aomdd w  bcp
aomdd w  sat
 nodes memory  mb   nodes memory  mb   nodes memory  mb 
bayesian network repository
alarm
     
    
   
      
   
      
cpcs  
       
           
             
      
cpcs   
      
    
     
            
      
cpcs   b          
      
diabetes
         
      
hailfinder
     
    
     
            
      
mildew
       
             
              
       
mm
      
             
             
      
munin 
         
      
munin 
         
      
munin 
         
n a
pathfinder
      
     
     
            
      
pigs
       
             
               
       
water
      
             
              
      
uai   evaluation dataset
bn   
     
n a        
             
      
bn   
      
n a          
               
       
bn   
     
n a        
             
      
bn   
      
n a        
               
      
bn   
     
n a
      
            
      
bn   
     
n a
     
            
      
bn   
     
n a
     
      
   
      
bn   
     
n a
     
            
      
bn   
     
n a
     
            
      
bn   
     
n a
     
      
   
      
bn   
     
n a
     
      
   
      
bn   
     
n a
      
             
      
bn   
     
n a
     
            
      
bn   
     
n a
     
            
      
bn   
     
n a
      
             
      
bn   
     
n a        
      
   
      
positive random bayesian networks with parameters  n     k    p    c    
r    
      
           
             
      
r    
      
           
             
      
r    
      
           
             
      
r    
      
    
     
            
      
r    
       
           
             
      
r    
       
           
             
      
r    
      
           
             
      
r    
      
           
             
      
r    
      
    
     
            
      
r     
      
    
     
            
      
deterministic random bayesian networks with parameters  n      k    p    c    
r   d    
      
           
             
      
r   d            
            
             
      
r   d            
             
              
      
r   d            
            
             
      
r   d            
             
              
      
r   d            
             
              
      
r   d            
             
              
      
r   d    
      
            
             
      
r   d            
           
             
      
r   d             
            
             
      

table    memory usage in mbytes of ace  aomdd bcp and aomdd sat on the    bayesian
networks from table    bold types highlight the best performance across rows  the n a
indicates that the respective memory usage statistic was not available from aces output 

   

fim ateescu   d echter   m arinescu

nally developed for heuristic search  nilsson         as mentioned in the introduction  the and or
search for graphical models is based on a pseudo tree that spans the graph of the model  similar to
the tree rearrangement of freuder and quinn               the idea was adapted for distributed
constraint satisfaction by collin et al               and more recently by modi et al          and was
also shown to be related to graph based backjumping  dechter         this work was extended by
bayardo and miranker         bayardo and schrag        and more recently applied to optimization tasks by larrosa et al          another version that can be viewed as exploring the and or
graphs was presented recently for constraint satisfaction  terrioux   jegou      b  and for optimization  terrioux   jegou      a   similar principles were introduced recently for probabilistic
inference  in algorithm recursive conditioning  darwiche        as well as in value elimination
 bacchus et al       b      a   and are currently at the core of the most advanced sat solvers  sang
et al         
for direction      there are various lines of related research  the formal verification literature 
beginning with the work of bryant        contains a very large number of papers dedicated to the
study of bdds  however  bdds are in fact or structures  the underlying pseudo tree is a chain 
and do not take advantage of the problem decomposition in an explicit way  the complexity bounds
for obdds are based on pathwidth rather than treewidth 
as noted earlier  the work of bertacco and damiani        on disjoint support decomposition
 dsd  is related to and or bdds in various ways  the main common aspect is that both approaches show how structure decomposition can be exploited in a bdd like representation  dsd
is focused on boolean functions and can exploit more refined structural information that is inherent to boolean functions  in contrast  and or bdds assume only the structure conveyed in the
constraint graph  and are therefore more broadly applicable to any constraint expression and also
to graphical models in general  they allow a simpler and higher level exposition that yields graphbased bounds on the overall size of the generated aomdd  the full relationship between these two
formalisms should be studied further 
mcmillan        introduced the bdd trees  along with the operations for combining them  for
 w
circuits of bounded tree width  bdd trees have a linear space upper bound of o  g  w     where
 g  is the size of the circuit g  typically linear in the number of variables  and w is the treewidth  this
bound hides some very large constants to claim the linear dependence on  g  when w is bounded 
however  mcmillan maintains that when the input function is a cnf expression bdd trees have
the same bounds as and or bdds  namely they are exponential in the treewidth only 
to sketch just a short comparison between mcmillans bdd trees and aommds  consider an
example where we have a simple pseudo tree with root   left child  and right child   each of
these nodes may stand for a set of variables  in bdd trees  the assignments to  are grouped into
equivalence classes according to the cofactors generated by them on the remaining  and   for
example assignments   and   are equivalent if they generate the same function on  and   the
node  can be represented by a bdd whose leaves are the cofactors  the same is done for   the
node  is then represented by a matrix of bdds  where each column corresponds to a cofactor of 
and each line to a cofactor of   by contrast  an aomdd represents the node  as a bdd whose
leaves are the cofactors  the number of distinct functions on  and   and then each cofactor is the
root of a decomposition  an and node  between  and   moreover  the representations of   as
descendants of different cofactor of   are shared as much as possible and the same goes for   this
is only a high level description  that becomes slightly more complicated when redundant nodes are
eliminated  but the idea remains the same 
   

fiand or m ulti  valued d ecision d iagrams  aomdd s   for g raphical m odels

the and or structure restricted to propositional theories is very similar to deterministic decomposable negation normal form  d dnnf   darwiche   marquis        darwiche         more
recently  huang and darwiche      b  used the trace of the dpll algorithm to generate an obdd 
and compared with the typical formal verification approach of combining the obdds of the input
function according to some schedule  the structures that were investigated in that case are still or 
this idea is extended in our present work by the and or search compilation algorithm 
mcallester  collins  and pereira        introduced the case factor diagrams  cfd   which subsume markov random fields of bounded tree width and probabilistic context free grammars  pcfg  
cfds are very much related to the and or graphs  the cfds target the minimal representation 
by exploiting decomposition  similar to and nodes  but also by exploiting context sensitive information and allowing dynamic ordering of variables based on context  cfds do not eliminate the
redundant nodes  and part of the cause is that they use zero suppression  there is no claim about
cfds being canonical forms  and also no description of how to combine two cfds 
there are numerous variants of decision diagrams that are designed to represent integer valued
or real valued functions  for a comprehensive view we refer the reader to the survey of drechsler
and sieling         algebraic decision diagrams  adds   bahar et al         provide a compilation for general real valued rather than boolean functions  their main drawback is that their
size increases very fast if the number of terminals becomes large  there are several approaches
that try to alleviate this problem  however the structure that they capture is still or  and they
do not exploit decomposition  some alternatives introduce edge values  or weights  that enable
more subgraph sharing  edge valued binary decision diagrams  evbdds   lai   sastry       
use additive weights  and when multiplicative weights are also allowed they are called factored
evbdds  fevbdds   tafertshofer   pedram         another type of bdds called k bmds
 drechsler  becker    ruppertz        also use integer weights  both additive and multiplicative
in parallel  adds have also been extended to affine adds  sanner   mcallester         through
affine transformations that can achieve more compression  the result was shown to be beneficial
for probabilistic inference algorithms  such as tree clustering  but they still do not exploit the and
structure 
more recently  independently and in parallel to our work on and or graphs  dechter   mateescu      a      b   fargier and vilarem        and fargier and marquis              proposed the compilation of csps into tree driven automata  which have many similarities to our work 
their main focus is the transition from linear automata to tree automata  similar to that from or
to and or   and the possible savings for tree structured networks and hyper trees of constraints
due to decomposition  their compilation approach is guided by a tree decomposition while ours is
guided by a variable elimination based algorithms  and it is well known that bucket elimination
and cluster tree decomposition are in principle the same  dechter   pearl        
wilson        extended obdds to semi ring bdds  the semi ring treatment is restricted to
the or search spaces  but allows dynamic variable ordering  it is otherwise very similar in aim and
scope to our aomdd  when restricting the aomdd to or graphs only  the two are closely related 
except that we express bdds using the shenoy shafer axiomatization that is centered on the two
operation of combination and marginalization rather then on the semi ring formulation  minimality
in the formulation of wilson        is more general allowing merging nodes having different values
and therefore it can capture symmetries  called interchangeability  
another framework very similar to aomdds  that we became aware of only recently  is probabilistic decision graphs  pdg  of jaeger         this work preceded most of the relevant work
   

fim ateescu   d echter   m arinescu

we discussed above  fargier   vilarem        wilson        and went somewhat unnoticed  perhaps due to notational and cultural differences  it is however similar in motivation  framework and
proposed algorithms  we believe our and or framework is more accessible  we define the framework over multi valued domains  provide greater details in algorithms and complexity analysis 
make an explicit connection with search frameworks  fully address the issues of canonicity as well
as provide an empirical demonstration  in particular  the claim of canonicity for pdgs is similar to
the one we make for aomdds of weighted models  in that it is relative to the trees  or forests  that
can represent the given probability distribution 
there is another line of research by drechsler and his group  e g  zuzek  drechsler    thornton 
       who use and or graphs for boolean function representation  that may seem similar to our
approach  however  the semantics and purpose of their and or graphs are different  they are
constructed based on the technique of recursive learning and are used to perform boolean reasoning 
i e  to explore the logic consequences of a given assumption based on the structure of the circuit 
especially to derive sets of implicants  the meaning of and and or in their case is related to
the meaning of the gates functions  while in our case the meaning is not related to the semantic of
the functions  the and or enumeration tree that results from a circuit according to zuzek et al 
       is not related to the and or decomposition that we discuss 

    conclusion
we propose the and or multi valued decision diagram  aomdd   which emerges from the study
of and or search spaces for graphical models  dechter   mateescu      a      b  mateescu  
dechter        dechter   mateescu        and ordered binary decision diagrams  obdds   bryant 
       this data structure can be used to compile any graphical model 
graphical models algorithms that are search based and compiled data structures such as bdds
differ primarily by their choices of time vs  memory  when we move from regular or search
space to an and or search space the spectrum of algorithms available is improved for all time
vs  memory decisions  we believe that the and or search space clarifies the available choices
and helps guide the user into making an informed selection of the algorithm that would fit best the
particular query asked  the specific input function and the available computational resources 
the contribution of our work is      we formally describe the aomdd and prove that it is a
canonical representation of a constraint network      we extend the aomdd to general weighted
graphical models      we give a compilation algorithm based on and or search  that saves the
trace of a memory intensive search  the context minimal and or graph   and then reduces it
in one bottom up pass      we describe the apply operator that combines two aomdds by an
operation and show that its complexity is quadratic in the input  but never worse than exponential
in the treewidth      we give a scheduling order for building the aomdd of a graphical model
starting with the aomdds of its functions which is based on a variable elimination algorithm 
this guarantees that the complexity is at most exponential in the induced width  treewidth  along the
ordering      we show how aomdds relate to various earlier and recent compilation frameworks 
providing a unifying perspective for all these methods      we introduce the semantic treewidth 
which helps explain why compiled decision diagrams are often much smaller than the worst case
bound  finally      we provide a preliminary empirical demonstration of the power of the current
scheme 

   

fiand or m ulti  valued d ecision d iagrams  aomdd s   for g raphical m odels

acknowledgments
this work was done while robert mateescu and radu marinescu were at the university of california  irvine  the authors would like to thank the anonymous reviewers for their constructive
suggestions to improve the paper  david eppstein for a useful discussion of complexity issues  and
lars otten and natasha flerova for comments on the final version of the manuscript  this work was
supported by the nsf grants iis         and iis          and the initial part by the radcliffe fellowship            through the partner program   with harvard undergraduate student john cobb 

appendix
proof of proposition  
consider the level of variable xi   and the meta nodes in the list lxi   after one pass through the
meta nodes in lxi  the inner for loop   there can be no two meta nodes at the level of xi in the
and or graph that are isomorphic  because they would have been merged in line    also  during
the same pass through the meta nodes in lxi all the redundant meta nodes in lxi are eliminated
in line    processing the meta nodes in the level of xi will not create new redundant or isomorphic
meta nodes in the levels that have been processed before  it follows that the resulting and or
graph is completely reduced   
proof of theorem  
the bound on the size follows directly from theorem    the aomdd size can only be smaller than

the size of the context minimal and or graph  which is bounded by o n k wt  g     to prove the
time bound  we have to rely on the use of the hash table  and the assumption that an efficient implementation allows an access time that is constant  the time bound of and or s earch  aomdd

is o n k wt  g     from theorem    because it takes time linear in the output  we assume here that
no constraint propagation is performed during search   procedure b ottom u p r eduction  procedure    takes time linear in the size of the context minimal and or graph  therefore  the aomdd

can be computed in time o n k wt  g     and the result is the same for the algorithm that performs
the reduction during the search   
proof of proposition  
the complexity of obdd  and mdd  apply is known to be quadratic in the input  namely  the
number of nodes in the output is at most the product of number of nodes in the input  therefore  the
number of nodes that can appear along one path in the output aomdd can be at most the product
of the number of nodes in each input  along the same path   gfi     ggi    summing over all the paths
in t gives the result   
proof of proposition  
the argument is identical to the case of mdds  the recursive calls in apply lead to combinations
of one node from gfaomdd and one node from ggaomdd  rather than a list of nodes   the number of
total possible such combinations is o   gfaomdd      ggaomdd      
proof of proposition  
the recursive calls of apply can generate one meta node in the output for each combination of
   

fim ateescu   d echter   m arinescu

nodes from gff g and ggf g   lets look at combinations of nodes from gff g and ggaomdd   ggf g  
the meta nodes from ggaomdd   ggf g that can participate in such combinations  lets call this set a 
are only those from levels  of variables  right below tf g   this is because of the mechanics of the
recursive calls in apply  whenever a node from f that belongs to gff g is combined with a node
from g that belongs to a  line    of apply expands the node from f   and the node  or nodes  from
a remain the same  this will happen until there are no more nodes from f that can be combined
with the node  or nodes  from a  and at that point apply will simply copy the remaining portion of
its output from ggaomdd   the size of a is therefore proportional to   ggf g    because it is the layer
of metanodes immediately below ggf g    a similar argument is valid for the symmetrical case  and
there are no combinations between nodes in ggaomdd   ggf g and ggaomdd   ggf g   the bound follows
from all these arguments   
proof of proposition  
the apply operation works by constructing the output aomdd from root to leaves  it first creates a
meta node for the root variable  and then recursively creates its children metanodes by using apply
on the corresponding children of the input  the worst case that can happen is when the output is
not reduced at all  and a recursive call is made for each possible descendant  this corresponds to an
unfolding of the full and or search tree based on the context variables  which is exponential in
the context size  when the apply finishes the context variables  and arrives at the first branching in
the bucket pseudo tree  the remaining branches are independent  similar to the case of obdds 
where one function occupies a single place in memory  the apply can simply create a link to
the corresponding branches of the inputs  this is what happens in line   in the apply algorithm  
therefore  the time and space complexity is at most exponential in the context size   
proof of theorem  
the space complexity is governed by that of be  since an aomdd never requires more space than

that of a full exponential table  or a tree   it follows that be aomdd only needs space o n k w   
the size of the output aomdd is also bounded  per layers  by the number of assignments to the
context of that layer  namely  by the size of the context minimal and or graph   therefore 

because context size is bounded by treewidth  it follows that the output has size o n k w    the
time complexity follows from proposition    and from the fact that the number of functions in a
bucket cannot exceed r  the original number of functions 
 
proof of proposition  
it suffices to prove the proposition for m      the general result can then be obtained by induction 
it is essential that the function is defined by a constraint network  i e   the values are only   or    
and that the function takes value   at least for one assignment  the value   denotes consistent assignments  solutions   while   denotes inconsistent assignments  suppose f   f  f    lets denote
by x a full assignment to x  and by x  and x  the projection of x over x  and x    respectively  we
can write x   x  x   concatenation of partial assignments   it follows that f  x    f   x     f   x    
therefore  if f  x       it must be that f   x        and f   x         we claim that for any x   
f   x        only if there exists some x  such that f  x  x         suppose by contradiction that there
exist some x  such that f   x        and f  x  x        for any other x    since f is not always zero 

   

fiand or m ulti  valued d ecision d iagrams  aomdd s   for g raphical m odels

it follows that f  is not always zero  and therefore there must be some x  for which f   x        
this leads to a contradiction  and therefore the functions f  and f  are uniquely defined by f    
proof of theorem  
the proof is by structural induction over the depth of the pseudo tree t   it follows the canonicity
proofs for obdds  bryant        and mdds  srinivasan et al          but extends them from linear
orderings to tree orderings that capture function decomposition according to the pseudo tree t   the
depth of t   along each of its paths from root to a leaf  is actually the size of the dependency set  or
the set of variables on which the value of the function depends  remember that the aomdd is an
and or graph that is completely reduced  we will use the word function  denoted by f   to refer
to the universal relation  or its characteristic function  defined by the constraint network 
assume the depth of t is    this means that the function does not depend on any variable 
and must be one of the constants   or    suppose the function is the constant    then  it must be
that the aomdd does not contain the terminal meta node    since all the nodes must be reachable
along some path  and it would mean that the function can also evaluate to    suppose the aomdd
contains a nonterminal meta node  say labeled with x  where x can take k different values  it must
be that all the k children meta nodes of x are the terminal meta node    if there are more than one
terminal    then the aomdd is not completely reduced  if there is only one    it follows that the
meta node labeled with x is redundant  therefore  from all the above  it follows that the aomdd
representing the constant   is made of only the terminal    this is unique  and contains the smallest
number of nodes  a similar argument applies for the constant   
now  suppose that the statement of the theorem holds for any constraint network that admits a
pseudo tree of depth strictly smaller than p  and that we have a constraint network with a pseudo
tree of depth equal to p  where p      let x be the root of t   having domain  x            xk    we
denote by fi   where i              k   the functions defined by the restricted constraint network for
x   xi   namely fi   f  x xi   let y            ym be the children of x in t   suppose we have two
aomdds of f   denoted by g and g     we will show that these two and or graphs are isomorphic 
the functions fi can be decomposed according to the pseudo tree t when the root x is removed 
this can in fact be a forest of independent pseudo trees  they do not share any variables   rooted by
y            ym   based on proposition    there is a unique decomposition fi   fiy          fiym   for all
y
i              k   based on the induction hypothesis  each of the function fi j has a unique aomdd 
in the and or graphs g and g     if we look at the subgraphs descending from x   xi   they both are
completely reduced and define the same function  fi   therefore there exists an isomorphic mapping
i between them  let v be the root metanode of g and v   the root of g     we claim that g and g   are
isomorphic according to the following mapping 
  
v 
if u   v 
 u   
i  u   if u is in the subgraph rooted by hx  xi i 
to prove this  we have to show that  is well defined  and that it is an isomorphic mapping 
if a meta node u in g is contained in both subgraphs rooted by hx  xi i and hx  xj i  then the
and or graphs rooted by i  u  and j  u  are isomorphic to the one rooted at u  and therefore to
each other  since g   is completely reduced  it does not contain isomorphic subgraphs  and therefore
i  u    j  u   therefore  is well defined 
we can now show that  is a bijection  to show that it is one to one  assume two distinct metanodes u  and u  in g  with  u       u     then  the subgraphs rooted by u  and u  are isomorphic
   

fim ateescu   d echter   m arinescu

to the subgraph rooted by  u     and therefore to each other  since g is completely reduced  it must
be that u    u    the fact that  is onto and is an isomorphic mapping follows from its definition and
from the fact that each i is onto and the only new node is the root meta node  since the aomdds
only contain one root meta node  more than one root would lead to the conclusion that the root
meta nodes are isomorphic and should be merged   we conclude that g and g   are isomorphic 
finally  we can show that among all the and or graphs representing f   the aomdd has
minimal number of meta nodes  suppose g is an and or graph that represents f   with minimal
number of meta nodes  but without being an aomdd  namely  it is not completely reduced  any
reduction rule would transform g into an and or graph with smaller number of meta nodes 
leading to a contradiction  therefore  g must be the unique aomdd that represents f    
proof of corollary  
the proof of theorem   did not rely on the scopes that define the constraint network  as long as the
network admits the decomposition induced by the pseudo tree t   the universal function defined by
the constraint network will always have the same aomdd  and therefore any constraint network
equivalent to it that admits t will also have the same aomdd   
proof of theorem  
the constant that is associated with the root is actually the sum of the weights of all solutions  this
can be derived from the definition of the weighted aomdd  the weights of each meta node are
normalized  they sum to     therefore the values computed for each or node by and or search
is always    when the task is computing
p the sum of all solution weights   therefore  the constant
of the weighted aomdd is always x w x  regardless of the graphical model  we will prove that
weighted aomdds are canonical for functions that are normalized 
assume we have two different weighted aomdds  denoted by g   and g     for the same normalized function f   let the root variable be a  with the domain  a            ak    let x denote a full
assignment to all the variables  similar to the above argument for the root constant 
p because all
the meta nodes have normalized weights  it follows that w   a  a      w   a  a      x a a  f  x  
the superscript of w  and w  indicates the aomdd  and the summation is over all possible assignments restricted to a   a    it follows that the root meta nodes are identical  for each value of the
root variable  the restricted functions represented in g   and g   are identical  and we will recursively
apply the same argument as above 
however  for the proof to be complete  we have to discuss the case when a restricted function
is decomposed into independent functions  according to the pseudo tree  suppose there are two
independent components  rooted by b and c  if one of them is the   function  it follows that the
entire function is    we will prove that the meta nodes of b in g   and g   are identical  if b has only
one value b  extendable to a solution  its weight must be   in both meta nodes  so the meta nodes
are identical  if b has more than one value  suppose without loss of generality that the weights are
different for the first value b    and
w   b  b      w   b  b    

   

since f       there must be a value c   c  such that b   b    c   c  can be extended to a full
solution  the sum of the weights of all these possible extensions is
x
f  x    w   b  b     w   c  c      w   b  b     w   c  c    
   
x b b   c c 

   

fiand or m ulti  valued d ecision d iagrams  aomdd s   for g raphical m odels

from equations   and   and the fact that the weight are non zero  it follows that
w   c  c      w   c  c    

   

from equation    the fact that b has more than one value and the fact that the weights of b are
normalized  it follows that there should be a value b  such that
w   b  b      w   b  b    

   

from equations   and    it follows that
w   b  b     w   c  c      w   b  b     w   c  c    

   

however  both sides of
p the equation   represent the sum of weights of all solutions when b  
b    c   c    namely x b b   c c  f  x   leading to a contradiction  therefore  it must be that
equation   is false  continuing the same argument for all values of b  it follows that the metanodes of b are identical  and similarly the meta nodes of c are identical 
if the decomposition has more than two components  the same argument applies  when b is the
first component and c is a meta variable that combines all the other components 
 
proof of theorem  
consider the well known np complete problem of    coloring  given a graph g  is there a
  coloring of g  namely  can we color its vertices using only three colors  such that any two
adjacent vertices have different colors  we will reduce    coloring to the problem of computing
the semantic treewidth of a graphical model  let h be a graph that is   colorable  and has a nontrivial semantic treewidth  it is easy to build examples for h  if g is   colorable  then g  h is
also   colorable and will have a non trivial semantic treewidth  because adding g will not simplify
the task of describing the colorings of h  however  if g is not   colorable  then g  h is also not
  colorable  and will have a semantic treewidth of zero   
proof of proposition  
since aomdds are canonical representations of graphical models  it follows that the graphical
model for which the actual semantic treewidth is realized will have the same aomdd as m  and
therefore the aomdd is bounded exponentially in the semantic treewidth   

references
akers  s          binary decision diagrams  ieee transactions on computers  c               
allen  d     darwiche  a          new advances in inference by recursive conditioning  in proceedings of the nineteenth conference on uncertainty in artificial intelligence  uai     pp 
    
bacchus  f   dalmao  s     pitassi  t       a   algorithms and complexity results for  sat and
bayesian inference  in proceedings of the   th annual ieee symposium on foundations of
computer science  focs     pp         
   

fim ateescu   d echter   m arinescu

bacchus  f   dalmao  s     pitassi  t       b   value elimination  bayesian inference via backtracking search  in proceedings of the nineteenth conference on uncertainty in artificial
intelligence  uai     pp       
bahar  r   frohm  e   gaona  c   hachtel  g   macii  e   pardo  a     somenzi  f          algebraic decision diagrams and their applications  in ieee acm international conference on
computer aided design  iccad     pp         
bayardo  r     miranker  d          a complexity analysis of space bound learning algorithms for
the constraint satisfaction problem  in proceedings of the thirteenth national conference on
artificial intelligence  aaai     pp         
bayardo  r  j     schrag  r  c          using csp look back techniques to solve real world sat
instances  in proceedings of the fourteenth national conference on artificial intelligence
 aaai     pp         
bertacco  v     damiani  m          the disjunctive decomposition of logic functions  in
ieee acm international conference on computer aided design  iccad     pp       
bodlaender  h  l     gilbert  j  r          approximating treewidth  pathwidth and minimum
elimination tree height  tech  rep   utrecht university 
bryant  r  e          graph based algorithms for boolean function manipulation  ieee transactions on computers             
cadoli  m     donini  f  m          a survey on knowledge compilation  ai communications 
                
chavira  m     darwiche  a          compiling bayesian networks with local structure  in
proceedings of the nineteenth international joint conference on artificial intelligence  ijcai     pp           
chavira  m     darwiche  a          compiling bayesian networks using variable elimination 
in proceedings of the twentieth international joint conference on artificial intelligence  ijcai     pp           
chavira  m   darwiche  a     jaeger  m          compiling relational bayesian networks for exact
inference  international journal of approximate reasoning               
clarke  e   grumberg  o     peled  d          model checking  mit press 
collin  z   dechter  r     katz  s          on the feasibility of distributed constraint satisfaction 
in proceedings of the twelfth international conference of artificial intelligence  ijcai    
pp         
collin  z   dechter  r     katz  s          self stabilizing distributed constraint satisfaction  the
chicago journal of theoretical computer science       special issue on self stabilization 
darwiche  a          recursive conditioning  artificial intelligence                

   

fiand or m ulti  valued d ecision d iagrams  aomdd s   for g raphical m odels

darwiche  a          a logical approach to factoring belief networks  in proceedings of the
eighth international conference on principles of knowledge representation and reasoning
 kr     pp         
darwiche  a     marquis  p          a knowledge compilation map  journal of artificial intelligence research  jair              
dechter  r          constraint networks  encyclopedia of artificial intelligence         
dechter  r          bucket elimination  a unifying framework for reasoning  artificial intelligence 
          
dechter  r     mateescu  r          and or search spaces for graphical models  artificial intelligence                  
dechter  r     mateescu  r       a   mixtures of deterministic probabilistic networks and their
and or search space  in proceedings of the twentieth conference on uncertainty in artificial intelligence  uai     pp         
dechter  r     mateescu  r       b   the impact of and or search spaces on constraint satisfaction and counting  in proceedings of the tenth international conference on principles and
practice of constraint programming  cp     pp         
dechter  r     pearl  j          tree clustering for constraint networks  artificial intelligence     
       
drechsler  r   becker  b     ruppertz  s          k bmds  a new data structure for verification 
in proceedings of the      european conference on design and test  ed tc     pp     
drechsler  r     sieling  d          binary decision diagrams in theory and practice  international
journal on software tools for technology transfer  sttt                
fargier  h     marquis  p          on the use of partially ordered decision graphs in knowledge
compilation and quantified boolean formulae  in proceedings of the twenty first national
conference on artificial intelligence  aaai     pp       
fargier  h     marquis  p          on valued negation normal form formulas  in proceedings of the
twentieth international joint conference on artificial intelligence  ijcai     pp         
fargier  h     vilarem  m          compiling csps into tree driven automata for interactive solving  constraints               
fishburn  p  c          utility theory for decision making  wiley  newyork 
freuder  e  c     quinn  m  j          taking advantage of stable sets of variables in constraint
satisfaction problems  in proceedings of the ninth international joint conference on artificial
intelligence  ijcai     pp           
freuder  e  c     quinn  m  j          the use of lineal spanning trees to represent constraint
satisfaction problems  tech  rep         university of new hampshire  durham 
   

fim ateescu   d echter   m arinescu

huang  j     darwiche  a       a   on compiling system models for faster and more scalable diagnosis  in proceedings of the   th national conference on artificial intelligence  aaai    
pp         
huang  j     darwiche  a       b   dpll with a trace  from sat to knowledge compilation 
in proceedings of the nineteenth international joint conference on artificial intelligence
 ijcai     pp         
jaeger  m          probabilistic decision graphs   combining verification and ai techniques for
probabilistic inference  international journal of uncertainty  fuzziness and knowledgebased systems           
kask  k   dechter  r   larrosa  j     dechter  a          unifying cluster tree decompositions for
reasoning in graphical models  artificial intelligence                    
kjaerulff  u          triangulation of graph based algorithms giving small total state space  tech 
rep   university of aalborg  denmark 
korf  r     felner  a          disjoint pattern database heuristics  artificial intelligence           
    
lai  y  t     sastry  s          edge valued binary decision for multi level hierarchical verification 
in proceedings of the twenty nineth design automation conference  pp         
larrosa  j   meseguer  p     sanchez  m          pseudo tree search with soft constraints  in
proceedings of the european conference on artificial intelligence  ecai     pp         
lee  c          representation of switching circuits by binary decision programs  bell system
technical journal             
mateescu  r     dechter  r          the relationship between and or search and variable elimination  in proceedings of the twenty first conference on uncertainty in artificial intelligence
 uai     pp         
mateescu  r     dechter  r          and or multi valued decision diagrams  aomdds  for
weighted graphical models  in proceedings of the twenty third conference on uncertainty
in artificial intelligence  uai     pp         
mcallester  d   collins  m     pereira  f          case factor diagrams for structured probabilistic
modeling  in proceedings of the twentieth conference on uncertainty in artificial intelligence  uai     pp         
mcmillan  k  l          symbolic model checking  kluwer academic 
mcmillan  k  l          hierarchical representation of discrete functions with application to model
checking  in computer aided verification  pp       
modi  p  j   shen  w   tambe  m     yokoo  m          adopt  asynchronous distributed constraint optimization with quality guarantees  artificial intelligence              

   

fiand or m ulti  valued d ecision d iagrams  aomdd s   for g raphical m odels

moskewicz  m   madigan  c   zhao  y   zhang  l     malik  s          chaff  engineering an
efficient sat solver  in proceedings of the thirty eighth design automation conference  pp 
       
nilsson  n  j          principles of artificial intelligence  tioga  palo alto  ca 
palacios  h   bonet  b   darwiche  a     geffner  h          pruning conformant plans by counting models on compiled d dnnf representations  in proceedings of the   th international
conference on planning and scheduling  icaps     pp         
pearl  j          probabilistic reasoning in intelligent systems  morgan kaufmann 
sang  t   bacchus  f   beame  p   kautz  h     pitassi  t          combining component caching
and clause learning for effective model counting  in proceedings of the seventh international
conference on theory and applications of satisfiability testing  sat    
sanner  s     mcallester  d          affine algebraic decision diagrams  aadds  and their application to structured probabilistic inference  in proceedings of the nineteenth international
joint conference on artificial intelligence  ijcai     pp           
selman  b     kautz  h          knowledge compilation and theory approximation  journal of the
acm                
shenoy  p          valuation based systems for bayesian decision analysis  operations research 
           
srinivasan  a   kam  t   malik  s     brayton  r  k          algorithms for discrete function
manipulation  in international conference on cad  pp       
tafertshofer  p     pedram  m          factored edge valued binary decision diagrams  formal
methods in system design                  
terrioux  c     jegou  p       a   bounded backtracking for the valued constraint satisfaction
problems  in proceedings of the ninth international conference on principles and practice
of constraint programming  cp     pp         
terrioux  c     jegou  p       b   hybrid backtracking bounded by tree decomposition of constraint networks  artificial intelligence            
wilson  n          decision diagrams for the computation of semiring valuations  in proceedings
of the nineteenth international joint conference on artificial intelligence  ijcai     pp 
       
zuzek  a   drechsler  r     thornton  m          boolean function representation and spectral
characterization using and or graphs  integration  the vlsi journal             

   

fi