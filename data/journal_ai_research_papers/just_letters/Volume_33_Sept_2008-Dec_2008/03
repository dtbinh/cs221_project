journal artificial intelligence research                  

submitted        published      

and or multi valued decision diagrams  aomdds 
graphical models
robert mateescu

mateescu   paradise   caltech   edu

electrical engineering department
california institute technology
pasadena  ca        usa

rina dechter

dechter   ics   uci   edu

donald bren school information computer science
university california irvine
irvine  ca        usa

radu marinescu

r   marinescu    c   ucc   ie

cork constraint computation centre
university college cork  ireland

abstract
inspired recently introduced framework and or search spaces graphical models  propose augment multi valued decision diagrams  mdd  nodes  order
capture function decomposition structure extend compiled data structures general weighted graphical models  e g   probabilistic models   present and or multi valued
decision diagram  aomdd  compiles graphical model canonical form supports polynomial  e g   solution counting  belief updating  constant time  e g  equivalence
graphical models  queries  provide two algorithms compiling aomdd graphical
model  first search based  works applying reduction rules trace memory
intensive and or search algorithm  second inference based uses bucket elimination
schedule combine aomdds input functions via apply operator 
algorithms  compilation time size aomdd are  worst case  exponential
treewidth graphical model  rather pathwidth known ordered binary decision
diagrams  obdds   introduce concept semantic treewidth  helps explain
size decision diagram often much smaller worst case bound  provide
experimental evaluation demonstrates potential aomdds 

   introduction
paper extends decision diagrams and or multi valued decision diagrams  aomdds 
shows graphical models compiled data structures  work presented
paper based two existing frameworks      and or search spaces graphical models
    decision diagrams 
    and or search spaces
and or search spaces  dechter   mateescu      a      b        proven unifying
framework various classes search algorithms graphical models  main characteristic
exploitation independencies variables search  provide exponential
speedups traditional search methods viewed traversing structure 
c
    
ai access foundation  rights reserved 

fim ateescu   echter   arinescu

nodes capture problem decomposition independent subproblems  nodes represent branching according variable values  and or spaces accommodate dynamic variable
ordering  however current work focuses static decomposition  examples and or
search trees graphs appear later  example figures     
and or search space idea originally developed heuristic search  nilsson        
context graphical models  and or search  dechter   mateescu        inspired
search advances introduced sporadically past three decades constraint satisfaction
recently probabilistic inference optimization tasks  specifically  resembles
pseudo tree rearrangement  freuder   quinn               adapted subsequently distributed constraint satisfaction collin  dechter  katz              recently
modi  shen  tambe  yokoo         shown related graph based backjumping  dechter         work extended bayardo miranker        bayardo
schrag        recently applied optimization tasks larrosa  meseguer  sanchez
        another version viewed exploring and or graphs presented recently constraint satisfaction  terrioux   jegou      b  optimization  terrioux   jegou 
    a   similar principles introduced recently probabilistic inference  algorithm recursive conditioning  darwiche        well value elimination  bacchus  dalmao    pitassi 
    b      a   currently core advanced sat solvers  sang  bacchus 
beame  kautz    pitassi        
    decision diagrams
decision diagrams widely used many areas research  especially software hardware
verification  clarke  grumberg    peled        mcmillan         bdd represents boolean
function directed acyclic graph two terminal nodes  labeled       every internal
node labeled variable exactly two children  low   high    isomorphic
nodes merged  would full search tree  called shannon tree 
usual full tree explored backtracking algorithm  tree ordered variables encountered
order along every branch  compressed merging isomorphic nodes
 i e   label identical children   eliminating redundant nodes  i e   whose
low high children identical   result celebrated reduced ordered binary decision
diagram  obdd short  introduced bryant         however  underlying structure
or  initial shannon tree tree  and or search trees reduced node
merging redundant nodes elimination get compact search graph viewed
bdd representation augmented nodes 
    knowledge compilation graphical models
paper combine two ideas  creating decision diagram and or structure  thus exploiting problem decomposition  detail  number values increased
two constant  context constraint networks  decision diagrams used
represent whole set solutions  facilitating solutions count  solution enumeration queries
equivalence constraint networks  benefit moving structure and or
lower complexity algorithms size compiled structure  typically moves
bounded exponentially pathwidth pw   characteristic chain decompositions
linear structures  exponentially bounded treewidth w   characteristic tree
   

fiand or ulti  valued ecision iagrams  aomdd   g raphical odels

structures  bodlaender   gilbert         it always holds w pw pw w log n 
n number variables model   cases  compactness result achieved
practice often far smaller bounds suggest 
decision diagram offers compilation propositional knowledge base  extension
obdds provided algebraic decision diagrams  add   bahar  frohm  gaona  hachtel 
macii  pardo    somenzi         terminal nodes      take values
arbitrary finite domain  knowledge compilation approach become important research
direction automated reasoning past decade  selman   kautz        darwiche   marquis 
      cadoli   donini         typically  knowledge representation language compiled
compact data structure allows fast responses various queries  accordingly  computational
effort divided offline online phase work pushed
offline  compilation used generate compact building blocks used online
algorithms multiple times  macro operators compiled prior search viewed
light  korf   felner         graphical models building blocks functions
whose compact compiled representations used effectively across many tasks 
one example  consider product configuration tasks imagine user chooses sequential options configure product  naive system  user would allowed choose valid
option current level based initial constraints  either product configured 
else  dead end encountered  system would backtrack previous state
continue there  would fact search space possible partial configurations  needless say  would unpractical  would offer user guarantee
finishing limited time  system based compilation would actually build backtrack free
search space offline phase  represent compact manner  online phase 
valid partial configurations  i e   extended full valid configuration  allowed 
depending query type  response time guarantees offered terms size
compiled structure 
numerous examples  diagnosis planning problems  formulated
graphical models could benefit compilation  palacios  bonet  darwiche    geffner       
huang   darwiche      a   diagnosis  compilation facilitate fast detection possible faults
explanations unusual behavior  planning problems formulated graphical
models  compilation would allow swift adjustments according changes environment 
probabilistic models one used types graphical models  basic query
compute conditional probabilities variables given evidence  compact compilation
probabilistic model would allow fast response queries incorporate evidence acquired time 
example  two important tasks bayesian networks computing probability
evidence  computing maximum probable explanation  mpe   model
variables become assigned  evidence   tasks performed time linear compilation size  practice many cases smaller upper bound based treewidth
pathwidth graph  formal verification another example compilation heavily used
compare equivalence circuit design  check behavior circuit  binary decision
diagram  bdd   bryant        arguably widely known used compiled structure 
contributions made paper knowledge compilation general decision diagrams particular following 
   formally describe and or multi valued decision diagram  aomdd  prove
canonical representation constraint networks  given pseudo tree 
   

fim ateescu   echter   arinescu

   extend aomdd general weighted graphical models 
   give compilation algorithm based and or search  saves trace memory
intensive search reduces one bottom pass 
   present apply operator combines two aomdds show complexity
quadratic input  never worse exponential treewidth 
   give scheduling order building aomdd graphical model starting
aomdds functions based variable elimination algorithm 
guarantees complexity exponential induced width  treewidth  along
ordering 
   show aomdds relate various earlier recent compilation frameworks  providing unifying perspective methods 
   introduce semantic treewidth  helps explain compiled decision diagrams
often much smaller worst case bound 
   provide experimental evaluation new data structure 
structure paper follows  section   provides preliminary definitions  description
binary decision diagrams bucket elimination algorithm  section   gives overview
and or search spaces  section   introduces aomdd discusses properties  section
  describes search based algorithm compiling aomdd  section   presents compilation
algorithm based bucket elimination schedule apply operation  section   proves
aomdd canonical representation constraint networks given pseudo tree  section
  extends aomdd weighted graphical models proves canonicity  section   ties
canonicity new concept semantic treewidth  section    provides experimental
evaluation  section    presents related work section    concludes paper  proofs
appear appendix 

   preliminaries
notations reasoning problem defined terms set variables taking values finite
domains set functions defined variables  denote variables subsets
variables uppercase letters  e g   x  y         values variables lower case letters  e g  
x  y          sets usually denoted bold letters  example x    x            xn   set
variables  assignment  x    x            xn   xn   abbreviated x    hx    x  i         
hxn   xn i  x    x            xn    subset variables y  dy denotes cartesian product
domains variables y  projection assignment x    x            xn   subset
denoted xy x y   denote    or short  assignment values
variables respective domains  denote functions letters f   g  h etc  
scope  set arguments  function f scope f   
    graphical models
efinition    graphical model  graphical model   tuple    hx  d  f  i  where 
   

fiand or ulti  valued ecision iagrams  aomdd   g raphical odels

   x    x            xn   finite set variables 
      d            dn   set respective finite domains values 
   f    f            fr   set positive real valued discrete functions  i e   domains
listed   defined subset variables si x  called scope  denoted
scope fi   
q p
   combination operator   e g            product  sum  join   take
input two  or more  real valued discrete functions  produce another real valued discrete
function 
graphical model represents combination functions  ri    
several examples graphical models appear later  example  figure   shows constraint
network figure   shows belief network 
order define equivalence graphical models  useful introduce notion
universal graphical model defined single function 
efinition    universal equivalent graphical model  given graphical model
 
hx  d  f    universal equivalent model u m    hx  d  f     fi f     i 
two graphical models equivalent represent function  namely 
universal model 
efinition    weight full partial assignment  given graphical model  
hx  d  fi  weight full assignment x    x            xn   defined w x   
f f f  x scope f      given subset variables x  weight partial assignment
combination functions whose scopes included  denoted fy   evaluated
assigned values  namely  w y    f fy f  y scope f     
consistency graphical models  range functions special zero value  
absorbing relative combination operator  e g   multiplication   combining anything
  yields      value expresses notion inconsistent assignments  primary
concept constraint networks defined relative graphical models
  element 
efinition    consistent partial assignment  solution  given graphical model  
element  partial assignment consistent cost non zero  solution consistent assignment variables 
efinition    primal graph  primal graph graphical model undirected graph
variables vertices edge connects two variables appear scope
function 
primal graph captures structure knowledge expressed graphical model 
particular  graph separation indicates independency sets variables given assignments
variables  advanced algorithms graphical models exploit graphical structure 
using heuristically good elimination order  tree decomposition similar method 
use concept pseudo tree  resembles tree rearrangements introduced freuder
quinn        
   combination operator defined axiomatically  shenoy        

   

fim ateescu   echter   arinescu

e







e

b


f

b

g

f

c

g
c

 a  graph coloring problem

 b  constraint graph

figure    constraint network
efinition    pseudo tree  pseudo tree graph g    x  e  rooted tree
set nodes x  every arc e backarc  a path rooted tree starts
root ends one leaf  two nodes connected backarc exists path
contains both  
use common concepts parameters graph theory  characterize connectivity graph  close tree chain  induced width graphical model
governs complexity solving bucket elimination  dechter         shown
bound and or search graph memory used cache solved subproblems  dechter  
mateescu        
efinition    induced graph  induced width  treewidth  pathwidth  ordered graph
pair  g  d   g     x            xn    e  undirected graph     x            xn  
ordering nodes  width node ordered graph number neighbors
precede ordering  width ordering d  denoted w d   maximum width
nodes  induced width ordered graph  w  d   width induced ordered graph
obtained follows  node  last first d  preceding neighbors connected
clique  induced width graph  w   minimal induced width orderings 
induced width equal treewidth graph  pathwidth pw graph
treewidth restricted class orderings correspond chain decompositions 
various reasoning tasks  queries defined graphical models  defined formally using marginalization operators projection  summation minimization 
however  since goal present compilation graphical model independent
queries posed it  discuss tasks informal manner only 
information see work kask  dechter  larrosa  dechter        
throughout paper  use two examples graphical models  constraint networks
belief networks  case constraint networks  functions understood relations  words  functions  also called constraints  take two values         
 f alse  true     value indicates corresponding assignment variables inconsistent  not allowed     value indicates consistency  belief networks example
general case graphical models  also called weighted graphical models   functions case
conditional probability tables  values function real numbers interval        

   

fiand or ulti  valued ecision iagrams  aomdd   g raphical odels

example   figure   a  shows graph coloring problem modeled constraint network  given map regions  problem color region one given colors  red 
green  blue   neighboring regions different colors  variables problems
regions  one domain  red  green  blue   constraints relation
different neighboring regions  figure   b  shows constraint graph  solution
 a red  b blue  c green  d green  e blue  f blue  g red  given figure   a  
detailed example given later example   
propositional satisfiability special case csp propositional satisfiability  sat   formula conjunctive normal form  cnf  conjunction clauses               clause
disjunction literals  propositions negations   example     p q r 
clause  p   q r propositions  p   q r literals  sat problem
decide whether given cnf theory model  i e   truth assignment propositions
violate clause  propositional satisfiability  sat  defined csp 
propositions correspond variables  domains         constraints represented clauses 
example clause  a b  relation propositional variables allows tuples
 a  b  except  a      b      
cost networks immediate extension constraint networks cost networks set
functions real valued cost functions  primary task optimization  also  gai nets
 generalized additive independence  fishburn        used represent utility functions 
example cost functions appear figure    
efinition
p   cost network  combinatorial optimization  cost network   tuple 
hx  d  c  i  x set variables x    x            xn    associated set
discrete valued domains     d            dn    set cost functions c    c            cr   
ci real valued function defined subset variables si x  combination operator 
p
  reasoning problem find minimum cost solution 

belief networks  pearl        provide formalism reasoning partial beliefs conditions uncertainty  defined directed acyclic graph vertices representing random
variables interest  e g   temperature device  gender patient  feature object  occurrence event   arcs signify existence direct causal influences
linked variables quantified conditional probabilities attached cluster parentschild vertices network 
q
efinition    belief networks  belief network  bn  graphical model p   hx  d  pg   i 
x    x            xn   set variables domains    d            dn    given directed acyclic graph g x nodes  pg    p            pn    pi    p  xi   pa  xi      
conditional probability tables  cpts short  associated xi   pa xi  
parents xi
qacyclic graph g  belief network represents probability distribution x 
p  x            xn     ni   p  xi  xpa xi      evidence set e instantiated subset variables 
formulated graphical model  functions f denote conditional probability tables
scopes functions determined directed acyclic graph g  function
q
ranges variable xi parents g  combination operator product     
primal graph belief network  viewed undirected model  called moral graph 
connects two variables appearing cpt 
   

fim ateescu   echter   arinescu

season

sprinkler b

watering



c rain

b

f wetness



g slippery

c

f

g

 a  directed acyclic graph

 b  moral graph

figure    belief network
example   figure   a  gives example belief network   variables  figure   b 
shows moral graph   example expresses causal relationship variables season
 a   configuration automatic sprinkler system  b   amount rain expected
 c   amount manual watering necessary  d   wetness pavement  f  
whether pavement slippery  g   belief network expresses probability distribution p  a  b  c  d  f  g    p  a  p  b a  p  c a  p  d b  a  p  f  c  b  p  g f   
another example belief network cpts appears figure   
two popular tasks belief networks defined below 
efinition     belief updating  probable explanation  mpe   given belief network
evidence e  belief updating task compute posterior marginal probability variable
xi   conditioned evidence  namely 
x

bel xi   xi     p  xi   xi   e   

n


p  xk   e xpak   

  x       xi   xi        xn   e e xi  xi   k  

normalization constant  probable explanation  mpe  task find
complete assignment agrees evidence  highest probability among
assignments  namely  find assignment  xo            xon  
p  xo            xon     maxx       xn

n


p  xk   e xpak   

k  

    binary decision diagrams review
decision diagrams widely used many areas research represent decision processes 
particular  used represent functions  due fundamental importance boolean
functions  lot effort dedicated study binary decision diagrams  bdds  
extensively used software hardware verification  clarke et al         mcmillan 
       earliest work bdds due lee         introduced binary decision program  understood linear representation bdd  e g   depth first search ordering
nodes   node branching instruction indicating address next instruction     value test variable  akers        presented actual graphical
   

fiand or ulti  valued ecision iagrams  aomdd   g raphical odels


 
 
 
 
 
 
 
 

b
 
 
 
 
 
 
 
 

c
 
 
 
 
 
 
 
 

f abc 
 
 
 
 
 
 
 
 





b

c

c

 

c

 

 a  table

 

b

b

 

 

b

 

 

b

c

 

 

 b  unordered tree

c

 

 

c

 

 

c

 

 

 

 c  ordered tree

figure    boolean function representations
representation developed bdd idea  however  bryant        introduced
called ordered binary decision diagram  obdd   restricted order variables along path diagram  presented algorithms  most importantly apply procedure  combines two obdds operation  time complexity quadratic
sizes input diagrams  obdds fundamental applications large binary functions 
especially many practical cases provide compact representations 
bdd representation boolean function  given b           boolean function
f   bn b  n arguments  x      xn   boolean variables  takes boolean
values 
example   figure   a  shows table representation boolean function three variables 
explicit representation straightforward  costly due exponential
requirements  function represented binary tree  shown figure   b  
exponential size number variables  internal round nodes represent
variables  solid edges    or high  value  dotted edges    or low  value 
leaf square nodes show value function assignment along path  tree
shown   b  unordered  variables appear order along path 
building obdd  first condition variables appear order  a b c 
along every path root leaves  figure   c  shows ordered binary tree function 
order imposed  two reduction rules transform decision diagram
equivalent one 
    isomorphism  merge nodes label children 
    redundancy  eliminate nodes whose low high edges point node  connect
parent removed node directly child removed node 
applying two reduction rules exhaustively yields reduced obdd  sometimes denoted
robdd  use obdd assume completely reduced 
example   figure   a  shows binary tree figure   c  isomorphic terminal nodes
 leaves  merged  highlighted nodes  labeled c  isomorphic  figure
  b  shows result merged  now  highlighted nodes labeled c b
redundant  removing gives obdd figure   c  
    bucket elimination review
bucket elimination  be   dechter        well known variable elimination algorithm inference graphical models  describe using terminology constraint networks 
   

fim ateescu   echter   arinescu





b

b

c

c

c

 

 



b

c

b

c

c

 

 a  isomorphic nodes

b

c

 

 

 b  redundant nodes

 

 c  obdd

figure    reduction rules
a 


c  ac 
c  ab 
c  abe 

b

c

c  bcd 

h  a 

b 

c  ab 

e 

c  abe 



h  ab 

h  ab 

ab bucket b
ab

abe

c 
e



 a  constraint network

d 

c  ac 

h  bc 

bucket a



bucket e

ab

abc bucket c
bc

bcd bucket d

c   bcd 

 b  execution

 c  bucket tree

figure    bucket elimination
applied graphical model  consider constraint network r   hx  d  ci
ordering    x    x            xn    ordering dictates elimination order be  last
first  variable associated bucket  constraint c placed bucket
latest variable d  buckets processed xn x  eliminating bucket variable  the
constraints residing bucket joined together  bucket variable projected out 
placing resulting constraint  also called message  bucket latest variable d 
execution  renders network backtrack free  solution produced assigning
variables along d  produce solutions count marginalization done summation
 rather projection  functional representation constraints  join substituted
multiplication 
constructs bucket tree  linking bucket xi destination bucket
message  called parent bucket   node bucket tree typically bucket variable 
collection constraints  scope  the union scopes constraints   nodes
bucket tree replaced respective bucket variables  easy see obtain pseudo
tree 
example   figure   a  shows network four constraints  figure  b  shows execution
bucket elimination along    a  b  e  c  d   buckets processed a   figure
  c  shows bucket tree  pseudo tree corresponding order given fig    a  
   representation figure   reverses top bucket processing described earlier papers  dechter        

   

fiand or ulti  valued ecision iagrams  aomdd   g raphical odels

procedure generatepseudotree g  d 
 
 
 
 
 

input   graph g    x  e   order    x            xn  
output   pseudo tree
make x  root
condition x   eliminate x  incident edges g   let g            gp resulting connected
components g
    p
ti   generatepseudotree  gi   d gi  
make root ti child x 

  return

    orderings pseudo trees
given ordering d  structural information captured primal graph scopes
functions f    f            fr   used create unique pseudo tree corresponds
 mateescu   dechter         precisely bucket tree  or elimination tree  
created  when variables processed reverse d   pseudo tree created
conditioning primal graph  processing variables order d  described procedure
generatepseudotree  following  d gi restriction order nodes
graph gi  

   overview and or search space graphical models
and or search space recently introduced  dechter   mateescu      a      b       
unifying framework advanced algorithmic schemes graphical models  main virtue consists exploiting independencies variables search  provide exponential
speedups traditional search methods oblivious problem structure  since and or mdds
based and or search spaces need provide comprehensive overview sake
completeness 
    and or search trees
and or search tree guided pseudo tree primal graph  idea exploit
problem decomposition independent subproblems search  assigning value
variable  also known conditioning   equivalent graph terms removing variable  and
incident edges  primal graph  partial assignment therefore lead decomposition
residual primal graph independent components  searched  or solved 
separately  pseudo tree captures precisely decompositions given order variable
instantiation 
efinition     and or search tree graphical model  given graphical model  
hx  d  fi  primal graph g pseudo tree g  associated and or search tree
alternating levels nodes  nodes labeled xi correspond
variables  nodes labeled hxi   xi  or simply xi   correspond value assignments 
structure and or search tree based   root node labeled
root   children node xi nodes labeled assignments hxi   xi

   

fim ateescu   echter   arinescu





b

 

b

b

 
e

e

 

c



 
c

   

e

 

 


   

 a  pseudo tree

   

 
c

e

 

 





   

   

   

 
c

e

 

 





   

   

   

c
 

 







   

   

   

 b  search tree

figure    and or search tree
consistent assignments along path root  children node
hxi   xi nodes labeled children variable xi pseudo tree  
example   figure   shows example and or search tree graphical model given
figure   a   assuming tuples consistent  variables binary valued  tuples
inconsistent  paths tree exist  figure   a  gives pseudo tree
guides search  top bottom  indicated arrows  dotted arcs backarcs
primal graph  figure   b  shows and or search tree  alternating levels
 circle   square  nodes  structure indicated pseudo tree 
and or search tree traversed depth first search algorithm  thus using linear
space  already shown  freuder   quinn        bayardo   miranker        darwiche       
dechter   mateescu      a        that 
heorem   given graphical model n variables  pseudo tree depth m 
size and or search tree based o n k    k bounds domains variables 
graphical model treewidth w pseudo tree depth w log n  therefore

and or search tree size o n k w log n   
and or search tree expresses set possible assignments problem variables
 all solutions   difference traditional search space solution longer
path root leaf  rather tree  defined follows 
efinition     solution tree  solution tree and or search tree contains root node 
every node  contains one child nodes nodes contains
child nodes  leaf nodes consistent 
    and or search graph
and or search tree may contain nodes root identical subproblems  nodes said
unifiable  unifiable nodes merged  search space becomes graph  size
becomes smaller expense using additional memory search algorithm  depth first
search algorithm therefore modified cache previously computed results  retrieve
nodes encountered again  notion unifiable nodes defined formally next 

   

fiand or ulti  valued ecision iagrams  aomdd   g raphical odels

efinition     minimal and or graph  isomorphism  two and or search graphs g g 
isomorphic exists one one mapping vertices g vertices g 
vertex v   v    v     v v   root identical subgraphs relative  
and or graph called minimal isomorphic subgraphs merged  isomorphic nodes
 that root isomorphic subgraphs  said unifiable 
shown dechter mateescu        that 
heorem   graphical model unique minimal and or search graph relative
pseudo tree  
minimal and or graph graphical model g relative pseudo tree denoted
mt  g   note definition minimality used work dechter mateescu       
based isomorphism reduction  extend including elimination
redundant nodes  previous theorem shows given and or graph  merge
operator fixed point  minimal and or graph  show paper
aomdd canonical representation  namely two equivalent graphical models
represented unique aomdd given accept pseudo tree 
aomdd minimal terms number nodes 
unifiable nodes identified based contexts  define graph based
contexts nodes nodes  expressing set ancestor variables
completely determine conditioned subproblem  however  shown using caching
based contexts makes caching based contexts redundant vice versa 
use caching  value assignment context x separates subproblem x
rest network 
efinition     or context  given pseudo tree and or search space 
context x     x        xp   set ancestors x   ordered descendingly  connected primal graph x descendants x 
efinition     context unifiable nodes  given and or search graph  two nodes n 
n  context unifiable variable label x assignments
contexts identical  namely    partial assignment variables along path n   
  partial assignment variables along path n    restriction context
x same     context x       context x   
depth first search algorithm traverses and or search tree  modified
traverse graph  enough memory available  could allocate cache table variable x 
scope table context x   size cache table x therefore product
domains variables context  variable x  possible assignment
context  corresponding conditioned subproblem solved computed
value saved cache table  whenever context assignment encountered again 
value subproblem retrieved cache table  algorithm traverses
called context minimal and or graph 
efinition     context minimal and or graph  context minimal and or graph obtained and or search tree merging context unifiable nodes 
   

fim ateescu   echter   arinescu

r

f

g

b

  

c


j

k

 c 

h

 c 

l

 ck 



 ch 

n

 ckl 

b

 cha 



 ckln 

p

 cko 

h
e
c



l

e

 chab 

r

 hab 

j

 chae 

f

 ar 



 cej 

g

 af 



 cd 

k

n
p


 a  primal graph

 b  pseudo tree
c

 

 

k

h

k

 

 

 

 

l

l

l

l

h

 

 



 



 





 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

n

n

n

n

n

n

n

n

b

b

b

b

b

b

b

b

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

































 

e

 

 

e

e

e

 

 

e

e

e

 

 

e

e

e

e

 

 

e

e

e

e

 

e

 

 

 

r

r

r

 

 

r

r

r

r

 

r

                                                               
                   
p

p

p

p

p

p

p

                                           

                               

p
j

j

j

j

j

j

j

j

j

j

j

j

j

j

j

j

                               
                                                               









               







f

f

f

f

               



               

g

g

g

g

               








               

 c  context minimal graph

figure    and or search graph
already shown  bayardo   miranker        dechter   mateescu      a        that 
heorem   given graphical model m  primal graph g pseudo tree   size
context minimal and or search graph based   therefore size minimal and or

search graph  o n k wt  g     wt  g  induced width g depth first traversal
  k bounds domain size 

example   lets look impact caching size search space examining larger
example  figure   a  shows graphical model binary variables figure   b  pseudo tree
drives and or search  context node given square brackets  context
minimal graph given figure   c   note far smaller and or search tree 
         nodes level alone  because depth   pseudo tree  
shaded rectangles show size cache table  equal number nodes
appear one  cache entry useful whenever one incoming edges
node  incidentally  caches useful  namely nodes one incoming
arc   called dead caches  darwiche         determined based pseudo
   

fiand or ulti  valued ecision iagrams  aomdd   g raphical odels

tree inspection  therefore cache table need allocated them  context minimal graph
explain execution along pseudo tree  or  equivalently  along depth
first traversal order   buckets shaded rectangles  processing done bottom up 
number possible assignments bucket equals number nodes appear
it  message scope identical context bucket variable  message
identical corresponding cache table  details relationship and or
search see work mateescu dechter        
    weighted and or graphs
previous subsections described structure and or trees graphs  order
use solve reasoning task  need define way using input function values
traversal and or graph  realized placing weights  or costs 
or to and arcs  dictated function values  functions relevant contribute
or to and arc weight  captured buckets relative pseudo tree 
efinition     buckets relative pseudo tree  given graphical model   hx  d  f 
pseudo tree   bucket xi relative   denoted bt  xi    set functions whose
scopes contain xi included patht  xi    set variables root xi
  namely 
bt  xi      f f xi scope f    scope f   patht  xi    

function belongs bucket variable xi iff scope fully instantiated
xi assigned  combining values functions bucket  current assignment  gives weight or to and arc 
efinition     or to and weights  given and or graph graphical model m 
weight w n m   xi   xi   arc  n  m  xi labels n xi labels m  combination
functions bt  xi   assigned values along current path node m   
formally  w n m   xi   xi     f bt  xi   f  asgn m   scope f     
efinition     weight solution tree  given weighted and or graph graphical model
m  given solution tree or to and set arcs arcs t   weight defined
w t    earcs t  w e  
example   start straightforward case constraint networks  since functions
take values      combination product  join relations   follows orto and arc weight      example given figure    figure   a  shows
constraint graph    b  pseudo tree it    c  four relations define constraint
problem  figure   d  shows and or tree traversed depth first search algorithm
checks consistency input functions  i e   constraint propagation used  
similar obdd representation  or to and arcs weight   denoted dotted
lines  tree unfolded them  since contain solution  arcs
weight   drawn solid lines 
   

fim ateescu   echter   arinescu


b
c





f

b

e

 a  constraint graph

 
 
 
 
 
 
 
 

b
 
 
 
 
 
 
 
 

b
 
 
 
 
 
 
 
 

c rabc
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

c
 
 
 
 
 
 
 
 

c

e



f

 b  pseudo tree

rbcd
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 


 
 
 
 
 
 
 
 

b
 
 
 
 
 
 
 
 

e rabe
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 


 
 
 
 
 
 
 
 

e
 
 
 
 
 
 
 
 

f raef
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 c  relations


 

 

 

 

b

b

 

 

 
 

 
c

c

e

 
 

 
c

e

c

e

e

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 







f

 

   

   

 

 

 

 

 

 

 

 
 

f



f

   

   

 

 

 

 

 

 

 

 





f

f

   

 

 

 

 

 

 

 

 

 

 

 

 

 
 

 
 

 d  and or tree

figure    and or search tree constraint networks
example   figure   shows weighted and or tree belief network  figure   a  shows
directed acyclic graph  dotted arc bc added moralization  figure   b  shows pseudo
tree    c  shows conditional probability tables  figure   d  shows weighted and or
tree 
constraint networks  move weighted and or search trees
weighted and or search graphs merging unifiable nodes  case arc labels
considered determining unifiable subgraphs  yield context minimal weighted
and or search graphs minimal weighted and or search graphs 

   and or multi valued decision diagrams  aomdds 
section begin describing contributions paper  context minimal and or
graph  definition     offers effective way identifying unifiable nodes execution search algorithm  namely  context unifiable nodes discovered based
paths root  without actually solving corresponding subproblems  however  merging based context complete  means may still exist unifiable nodes
search graph identical contexts  moreover  nodes context
   

fiand or ulti  valued ecision iagrams  aomdd   g raphical odels

p a 




 
 



p b   a 

p a 
  
  


 
 

p c   a 

 
 

b  
  
  

b  
  
  

p d   b c 

b
b

b
 
 
 
 

c

e
e

c




 a  belief network

c
 
 
 
 

p e   a b 
d  
  
  
  
  

d  
  
  
  
  

c  
  
  

c  
  
  

 b  pseudo tree


 
 
 
 

b
 
 
 
 

e  
  
  
  
  

e  
  
  
  
  

 c  cpts



  

  

 

 

b

b

  
 

 

c

  
 

e

  

  

  

 

 

 



  
 

 



  
 

  
 

  

  

  

 

 

 



  
 

  
 

c

 

e

  

  

  

 

 

 





     
 

 

e

c

  

  

 

 

e

  

  

  

  

  

 

 

  
 

c

  

  

  

 

 

 



  
 



  
 

  
 

  
 



     
 

 

  
 

 d  weighted and or tree

figure    weighted and or search tree belief networks
minimal and or graph may redundant  example set solutions rooted variable xi dependant specific value assigned xi  this situation detectable based
context   sometimes termed interchangeable values symmetrical values 
overviewed earlier  dechter mateescu            a  defined complete minimal and or
graph and or graph whose unifiable nodes merged  dechter mateescu
       proved canonicity non weighted graphical models 
paper propose augment minimal and or search graph removing redundant variables common obdd representation well adopt notational conventions
common community  yields data structure call and or bdd  exploits
decomposition using nodes  present extension multi valued variables yielding
and or mdd aomdd define general weighted graphical models  subsequently
present two algorithms compiling canonical aomdd graphical model  first
search based  uses memory intensive and or graph search generate context minimal
and or graph  reduces bottom applying reduction rules  second inferencebased  uses bucket elimination schedule combine aomdds initial functions
apply operations  similar apply obdds   show  approaches
worst case complexity and or graph search context based caching 
complexity bucket elimination  namely time space exponential treewidth

problem  o n k w    benefit generation schemes discussed 

   

fim ateescu   echter   arinescu





 

 a  obdd

 



k

 b  mdd

figure     decision diagram nodes  or 




 







 a  aobdd

 

k







 b  aomdd

figure     decision diagram nodes  and or 
    and or search graphs decision diagrams
and or search graph g graphical model   hx  d  f  represents set
possible assignments problem variables  all solutions costs   sense  g
viewed representing function f   f defines universal equivalent graphical
model u m   definition     full assignment x    x            xn    x solution expressed
tree tx   f  x    w tx     earcs tx   w e   definition      otherwise f  x       the
assignment inconsistent   solution tree tx consistent assignment x read g
linear time following assignments root  x inconsistent  dead end
encountered g attempting read solution tree tx   f  x       therefore  g
viewed decision diagram determines values f every complete assignment x 
see process and or search graph reduction rules similar
case obdds  order obtain representation minimal size  case obdds 
node labeled variable name  example a  low  dotted line  high  solid
line  outgoing arcs capture restriction function assignments         
determine value function  one needs follow either one  but both 
outgoing arcs  see figure    a    straightforward extension obdds multi valued
variables  multi valued decision diagrams  mdds  presented srinivasan  kam  malik 
brayton         node structure use given figure    b   outgoing arc
associated one k values variable a 
paper generalize obdd mdd representations demonstrated figures    a 
   b  allowing outgoing arc arc  arc connects node set
nodes  captures decomposition problem independent components  number
arcs emanating node two case aobdds  figure    a    domain size
variable general case  figure    b    given node a  k arcs
connect possibly different number nodes  depending problem decomposes based
particular assignment a  arcs depicted shaded sector connects
outgoing lines corresponding independent components 

   

fiand or ulti  valued ecision iagrams  aomdd   g raphical odels


 



 



k





 a  nonterminal meta node

 

 

 b  terminal meta node  

 c  terminal meta node  

figure     meta nodes
define and or decision diagram representation based and or search graphs 
find useful maintain semantics figure    especially need express
redundancy nodes  therefore introduce meta node data structure  defines small
portions and or graph  based node children 
efinition     meta node  meta node u and or search graph either     
terminal node labeled          nonterminal node  consists node labeled
x  therefore var u    x  k children labeled x            xk correspond value
assignments x  node labeled xi stores list pointers child meta nodes  denoted
u childreni   case weighted graphical models  node xi stores or toand arc weight w x  xi   
rectangle figure    a  meta node variable a  domain size k  note
similar figure     small difference information value
corresponds outgoing arc stored nodes meta node 
showing weights figure  larger example and or graph meta nodes
appears later figure    
terminal meta nodes play role terminal nodes obdds  terminal metanode    shown figure    b   indicates inconsistent assignments  terminal meta node   
shown figure    c  indicates consistent ones 
and or search graph viewed diagram meta nodes  simply grouping
nodes children  adding terminal meta nodes appropriately 
defined meta nodes  easier see variable redundant respect outcome function based current partial assignment  variable redundant
assignments leads set solutions 
efinition     redundant meta node  given weighted and or search graph g represented
meta nodes  meta node u var u    x  d x     k redundant iff 
 a  u children            u childrenk
 b  w x  x              w x  xk   
and or graph g  contains redundant meta node u  transformed equivalent graph g   replacing incoming arc u common list children u children   
absorbing common weight w x  x    combination weight parent meta node
corresponding incoming arc  removing u outgoing arcs g 
value x   x  picked arbitrarily  isomorphic  u root
   

fim ateescu   echter   arinescu

procedure redundancyreduction
  and or graph g  redundant meta node u  var u    x  list meta node parents u 
denoted p arents u  
output   reduced and or graph g elimination u 
  p arents u  empty
 
return independent and or graphs rooted meta nodes u children    constant w x  x   
input

  forall v p arents u   assume var v      
 
forall              d y    
 
u v childreni
 
v childreni v childreni    u 
 
v childreni v childreni u children 
 
w y  yi   w y  yi   w x  x   
  remove u
   return reduced and or graph g

procedure isomorphismreduction
  and or graph g  isomorphic meta nodes u v  list meta node parents u  denoted
p arents u  
output   reduced and or graph g merging u v 
forall p p arents u 
u p childreni
p childreni p childreni    u 
p childreni p childreni  v 

input

 
 
 
 

  remove u
  return reduced and or graph g

graph  common weight w x  x    stored separately constant  procedure
redundancyreduction formalizes redundancy elimination 
efinition     isomorphic meta nodes  given weighted and or search graph g represented
meta nodes  two meta nodes u v var u    var v    x  d x     k
isomorphic iff 
 a  u childreni   v childreni             k 
 b  wu  x  xi     wv  x  xi               k    where wu   wv weights u v  
procedure isomorphismreduction formalizes process merging isomorphic metanodes  naturally  and or graph obtained merging isomorphic meta nodes equivalent
original one  define and or multi valued decision diagram 
efinition     aomdd  and or multi valued decision diagram  aomdd  weighted
and or search graph completely reduced isomorphic merging redundancy removal 
namely 
    contains isomorphic meta nodes 
    contains redundant meta nodes 

   

fiand or ulti  valued ecision iagrams  aomdd   g raphical odels





 k

 

b

c

 



 

k

z


 

 

z

k





c







 b  eliminating b
meta node

 a  fragment aomdd

figure     redundancy reduction

 



 k

 

 

k

b
 

c

 



 

 

c


 

b

k

 

e

 



k

c


k

 


k

 





 a  fragment aomdd

 

k

e





 b  merging isomorphic c meta nodes

figure     isomorphism reduction
example    figure    shows example applying redundancy reduction rule portion
aomdd  left side  figure    a   meta node variable b redundant  we
dont show weights or to and arcs  avoid cluttering figure   values
            k  b lead set meta nodes  c  d          y   coupled
arc  therefore  meta node b eliminated  result shown figure    b  
meta nodes  c  d          y  z coupled arc outgoing     
figure    show example applying isomorphism reduction rule  case 
meta nodes labeled c figure    a  isomorphic  again  omit weights   result
merging shown figure    b  
examples aomdds appear figures            note weight or toand arc zero  descendant terminal meta node    namely  current path
dead end  cannot extended solution  therefore linked directly   

   using and or search generate aomdds
section     described transform and or graph aomdd applying
reduction rules  section     describe explicit algorithm takes input graphi   

fim ateescu   echter   arinescu

cal model  performs and or search context based caching obtain context minimal
and or graph  section     give procedure applies reduction rules bottom
obtain aomdd 
    algorithm and or s earch  aomdd
algorithm    called and or s earch  aomdd  compiles graphical model aomdd 
memory intensive  with context based caching  and or search used create context minimal and or graph  see definition      input and or s earch  aomdd graphical
model pseudo tree   defines or context variable 
variable xi associated cache table  whose scope context xi  
ensures trace search context minimal and or graph  list denoted lxi
 see line      used variable xi save pointers meta nodes labeled xi  
lists used procedure performs bottom reduction  per layers and or
graph  one layer contains nodes labeled one given variable   fringe search
maintained stack called open  current node  either node  denoted
n  parent p  current path n   children current node denoted
successors n   node n  boolean attribute consistent n  indicates current path
extended solution  information useful pruning search space 
algorithm based two mutually recursive steps  forward  beginning line   
backtrack  beginning line      call  or themselves  search terminates 
forward phase  and or graph expanded top down  two types nodes 
or  treated differently according semantics 
node expanded  cache table variable checked  line     entry
null  link created already existing node roots graph equivalent
current subproblem  otherwise  node expanded generating descendants 
or to and weight  see definition     computed line     value xi xi checked
consistency  line      least expensive check verify or to and weight non zero 
however  deterministic  inconsistent  assignments extracted form constraint
network  level constraint propagation performed step  e g   look ahead  arc
consistency  path consistency  i consistency etc    computational overhead increase 
hope pruning search space aggressively  note constraint propagation
crucial algorithm  complexity guarantees maintained even simple
weight check performed  consistent nodes added list successors n  line
     inconsistent ones linked terminal   meta node  line     
node n labeled hxi   xi expanded  line     based structure pseudo
tree  xi leaf   n linked terminal   meta node  line      otherwise 
node created child xi  line     
forward step continues long current node dead end still unevaluated
successors  backtrack phase triggered node empty set successors  line     
note that  successor processed  removed set successors line    
backtrack reaches root  line      search complete  context minimal and or graph
generated  procedure b ottom u p r eduction called 
backtrack step processes node  line      saves pointer cache 
adds pointer corresponding meta node list lxi   consistent attribute

   

fiand or ulti  valued ecision iagrams  aomdd   g raphical odels

algorithm    and or earch   aomdd
input     hx  d  fi  pseudo tree rooted x    parents pai  or context  every variable xi  
output   aomdd m 
  forall xi x
initialize context based cache table cachexi  pai   null entries
 
  create new node t  labeled xi   consistent t  true  push top open
  open   
 
n top open   remove n open
   forward
 
successors n 
 
n node labeled xi
   or expand
cachexi  asgn n   pai       null
 
connect parent n cachexi  asgn n   pai   
 
   use cached pointer
  
  
  
  
  
  
  
  
  
  

else
forall xi di
create new node t  labeled hxi   xi
w x  xi  

f  asgn n   pai   
f bt  xi  

hxi   xi consistent n
consistent t  true
add successors n 
else
consistent t  f alse
make terminal   child

  
  
  
  
  
  
  
  

n node labeled hxi   xi
childrent  xi     
make terminal   child n
else
forall childrent  xi  
create new node t  labeled
consistent t  f alse
add successors n 

  
  
  
  
  
  

add successors n  top open
successors n    
let p parent n
n node labeled xi
xi    x 
call bottomupreduction procedure

  
  
  
  
  
  

   constraint propagation

   and expand

   backtrack

   search complete
   begin reduction aomdd

cache asgn n   pai    n
add meta node n list lxi
consistent p  consistent p  consistent n 
consistent p     f alse
remove successors p  open
successors p 

  
  

n node labeled hxi   xi
consistent p  consistent p  consistent n  

  
  

remove n successors p 
np

   

   save cache

   check p dead end

fim ateescu   echter   arinescu

procedure bottomupreduction
  graphical model   hx  d  fi  pseudo tree primal graph  rooted x    context
minimal and or graph  lists lxi meta nodes level xi  
output   aomdd m 
let    x            xn   depth first traversal ordering
n  
let h hash table  initially empty
forall meta nodes n lxi
h xi   n children            n childrenki   wn  xi   x             wn  xki   xki    returns meta node
p
merge n p and or graph
input

 
 
 
 
 
 
 
 
 
  
  
  

else n redundant
eliminate n and or graph
combine weight parent
else
hash n table h 
h xi   n children            n childrenki   wn  xi   x             wn  xki   xki    n

   return reduced and or graph

parent p updated conjunction consistent n   parent p becomes
inconsistent  necessary check remaining successors  line      backtrack
step processes node  line      consistent attribute parent p updated
disjunction consistent n  
and or search algorithm usually maintains value node  corresponding task
solved  include values description aomdd equivalent
representation original graphical model m  task solved traversal
aomdd  however user include information meta nodes  e g  
number solutions subproblem  
    reducing context minimal and or graph aomdd
procedure bottomupreduction processes variables bottom relative pseudo tree  
use depth first traversal ordering  line     bottom ordering good 
outer loop  starting line    goes level context minimal and or graph
 where level contains nodes labeled variable  words
contains meta nodes variable   efficiency  ensure complexity guarantees
prove  hash table  initially empty  used level  inner loop  starting
line    goes metanodes level  saved  or pointers saved 
list lxi   new meta node n list lxi   line   hash table h checked
verify node isomorphic n already exists  hash table h already contains node p corresponding hash key  xi   n children            n childrenki   wn  xi   x             wn  xki   xki    
p n isomorphic merged  otherwise  new meta node n redundant 
eliminated and or graph  none previous two conditions met 
new meta node n hashed table h 

   

fiand or ulti  valued ecision iagrams  aomdd   g raphical odels




g

c

b

f

e



h

b
c


 a 

f
e

g

h

 b 

figure      a  constraint graph c    c            c     c    f h  c    h 
c    b g  c    f g  c    b f   c    e  c    c e  c    c d 
c    b c   b  pseudo tree  bucket tree  ordering    a  b  c  d  e  f  g  h 

proposition   output procedure bottomupreduction aomdd along
pseudo tree   namely resulting and or graph completely reduced 
note explicated procedure bottomupreduction separately clarity  practice  actually included algorithm and or s earch  aomdd  reduction rules
applied whenever search backtracks  maintain hash table variable  and or search  store pointers meta nodes  search backtracks
node  already check redundancy meta node  look hash table
check isomorphism  therefore  reduction and or graph done
and or search  output aomdd m 
theorem   proposition   conclude 
heorem   given graphical model pseudo tree primal graph g  aomdd

corresponding size bounded o n k wt  g    computed algorithm

and or s earch  aomdd time o n k wt  g     wt  g  induced width g
depth first traversal   k bounds domain size 

   using bucket elimination generate aomdds
section propose use bucket elimination  be  type algorithm guide compilation
graphical model aomdd  idea express graphical model functions
aomdds  combine apply operations based schedule  apply
similar obdds  bryant         adapted and or search graphs 
takes input two functions represented aomdds based pseudo tree  outputs
combination initial functions  represented aomdd based pseudo tree 
describe detail section     
start example based constraint networks  easier understand
weights arcs      therefore depicted figures solid dashed
lines  respectively 
example    consider network defined x    a  b          h   da           dh         
constraints  where denotes xor   c    f h  c    ah  c    abg  c    f g 
   

fim ateescu   echter   arinescu

m 



m 



 

 

 

b
 

 

 

c
 

c
 

 

 

 

 

 

c
 

 



 

b

b

 

 

f

c
 

b
 

 

 

f
 

 

 

f
 

b

f

 

 

 

 

b

c

 



g

e
 

 

 

 

 

 

 

m 

g
 

 

h
 

 

 

 



e

 

m 

f

h
 

g

m 

m 


 

 

b

c

 

c
 



 

 

 


 

 

 

c

c
 

 

 

f

b

 

 

 



 

 

 

g

 

 

 

 

 

 

h
 

 

b

f
 

g
 

 

f

f

 

f
 

 



b
 

b
 

e


 

 

b



 

h

 

h
 

 

f
 

c

   

 

 

 

m 

c 

c

 

e

 

c


 

 

 

 

e



 

c
 

 

 

 

 

 

g

 

 

 

 

c



   

c 

c 

 

 

 

 

 

 

 

 

b

h

   

 


 

 

h

 

g

e

c 

 

 



 

g
 

g

f

f
 

b

g

h

m 

m 

 

b

   

c 

m 





 

e

e

 

 

c 

m 


 







m 

m 
 

   

 
m 

c 

 

h
 

 

f

 

f

   

   

g

c 

c 

h

figure     execution aomdds

 



 

b
 

b
 

 

b

 

b

c
c
 

c
 

 

c
 

 

c
 

 

f
 

 

f
 

 

f
 

 

c

 

 



 



e


 


 

 

e
 

 

g
 

 

g
 

 

h
 

 

c

c

f

 





e

f

h
 



e

f

f

f

 

g

g

g

g

h

 



 

h

 

 a 

g

 

 b 

figure      a  final aomdd   b  obdd corresponding
c    b f   c    e  c    c e  c    c d  c    b c  constraint graph
shown figure    a   consider ordering    a  b  c  d  e  f  g  h   pseudo tree  or
bucket tree  induced given fig     b   figure    shows execution aomdds
along ordering d  initially  constraints c  c  represented aomdds placed
bucket latest variable d  scope original constraint always appears

   

fiand or ulti  valued ecision iagrams  aomdd   g raphical odels

algorithm    be aomdd
  graphical model   hx  d  fi  x    x            xn    f    f            fr     order
   x            xn  
output   aomdd representing
    generatepseudotree g  d  
    r
   place functions buckets
 
place gfaomdd


bucket


latest
variable



input

  n  
message xi   g aomdd
 
 
bucket xi     
 
pick gfaomdd bucket xi   
 
 
  

   process buckets
   initialize aomdd    
   combine aomdds bucket xi

bucket xi   bucket xi      gfaomdd   
message xi   apply message xi    gfaomdd  
add message xi   bucket parent xi

   return message x   

path root leaf pseudo tree  therefore  original constraint represented
aomdd based chain  i e   branching independent components point  
chain scope constraint  ordered according d  bi valued variables 
original constraints represented obdds  multiple valued variables mdds  note
depict meta nodes  one node two children  appear inside gray
node  dotted edge corresponds   value  the low edge obdds   solid edge
  value  the high edge   redundancy notation  keeping value nodes
arc types  dotted arcs   solid arcs    
scheduling used process buckets reverse order d  bucket processed
joining aomdds inside it  using apply operator  however  step elimination
bucket variable omitted want generate full aomdd  example 
messages m    c     c  m    c     c  still based chains  therefore
obdds  note contain variables h g  eliminated  however 
message m    c     m     m  obdd anymore  see follows
structure pseudo tree  f two children  g h  nodes corresponding
f two outgoing edges value   
processing continues manner  final output algorithm  coincides
m    shown figure    a   obdd based ordering shown fig 
   b   notice aomdd    nonterminal nodes    edges  obdd   
nonterminal nodes    edges 
    algorithm be aomdd
algorithm    called be aomdd  creates aomdd graphical model using schedule apply operations  given order variables  first pseudo tree created based
 
primal graph  initial function represented aomdd  denoted gfaomdd

placed bucket  obtain aomdd function  scope function ordered
according d  search tree  based chain  represents generated  reduced
procedure bottomupreduction  algorithm proceeds exactly be  difference combination functions realized apply algorithm  variables
   

fim ateescu   echter   arinescu

eliminated carried destination bucket  messages buckets initialized
dummy aomdd    denoted g aomdd   neutral combination 
order create compilation graphical model based and or graphs  necessary
traverse and or graph top bottom up  similar inward outward
message passing tree decomposition  note be aomdd describes bottom traversal
explicitly  top phase actually performed apply operation  two
aomdds combined  top chain portion pseudo tree processed  remaining
independent branches attached participate newly restricted set solutions 
amounts exchange information independent branches  equivalent
top phase 
    aomdd apply operation
describe combine two aomdds  apply operator takes input two
aomdds representing functions f  f  returns aomdd representing f  f   
obdds apply operator combines two input diagrams based variable ordering 
likewise  order combine two aomdds assume pseudo trees identical 
condition satisfied two aomdds bucket be aomdd  however 
present version apply general  relaxing previous condition
identical compatible pseudo trees  namely  pseudo tree
embedded  general  pseudo tree induces strict partial order variables
parent node always precedes child nodes 
efinition     compatible pseudo trees  strict partial order d     x       set x
consistent strict partial order d     y       set y  x    x  x y 
x     x  x     x    two partial orders d  d  compatible iff exists partial
order consistent both  two pseudo trees compatible iff partial orders induced
via parent child relationship  compatible 
simplicity  focus restricted notion compatibility  sufficient
using schedule apply operator combine input aomdds  as described
section     apply algorithm present extended general notion
compatibility 
efinition     strictly compatible pseudo trees  pseudo tree t  set nodes x 
embedded pseudo tree set nodes x x  x t  obtained
deleting node x   x  connecting parent descendents  two
pseudo trees t  t  strictly compatible exists t  t 
embedded  
algorithm apply  algorithm    takes input one node gfaomdd list nodes
ggaomdd   initially  node gfaomdd root node  list nodes ggaomdd fact
made one node  root  sometimes identify aomdd root
node  pseudo trees tf tg strictly compatible  target pseudo tree  
list nodes ggaomdd always special property  node
ancestor another  we refer variable meta node   therefore  list z            zm
   

fiand or ulti  valued ecision iagrams  aomdd   g raphical odels

apply  v    z            zm  
input   aomdds gfaomdd nodes vi ggaomdd nodes zj   based strictly compatible pseudo
trees tf   tg embedded  
var v    ancestor var z             var zm    
var zi   var zj   ancestor descendant relation      j 
output   v   z        zm    based  
h   v    z            zm      null return h   v    z            zm   
   cache
 any v    z            zm    return  
 v       return  
 m      return v 
   nothing combine
create new nonterminal meta node u
var u  var v     call xi   domain di    x            xki    
j   ki
u childrenj
   children j th node u
   assign weight v 
wu  xi   xj   wv   xi   xj  
   m       var v      var z      xi    
temp children z   childrenj
   combine input weights
wu  xi   xj   wv   xi   xj   wz   xi   xj  

algorithm   

 
 
 
 
 
 
 
 
 
  
  
  
  
  

else

  
  
  
  
  

group nodes v   childrenj temp children several  v     z             z r  
 v     z             z r  
apply v     z             z r  
 y     
u childrenj    break

  
  

temp children  z            zm  

else
u childrenj u childrenj  y 

  
  
  

 u children            u childrenki    wu  xi   x              wu  xi   xki   
promote wu  xi   x    parent
return u children 
   redundancy

  
  

 h   xi   u children            u childrenki   wu  xi   x             wu  xki   xki       null 
return h   xi   u children            u childrenki   wu  xi   x             wu  xki   xki   
   isomorphism

   let h   v    z            zm     u
   let h   xi   u children            u childrenki   w u  xi   x             w u  xki   xki      u
   return u

   add u h 
   add u h 

g expresses decomposition respect   nodes appear different branches 
employ usual techniques obdds make operation efficient  first  one
arguments    safely return    second  hash table h  used store nodes
already processed  based nodes  v    z            zr    therefore  never need
make multiple recursive calls arguments  third  hash table h  used detect
isomorphic nodes  typically split separate tables variable  end
recursion  returning value  discover meta node variable 
children weights already created  dont need store simply
return existing node  fourth  end recursion discover created
redundant node  all children weights same   dont store
it  return instead one identical lists children  promote common weight 
   

fim ateescu   echter   arinescu


 
 
 
 
 
 
 
 

b
 
 
 
 
 
 
 
 

c
 
 
 
 
 
 
 
 

f abc 
 
 
 
 
 
 
 
 


 
 
 
 
 
 
 
 


b
c



a 
 

 

c

a 

 

 

a 

b 

a 

b 

 

b

b





 


 



c


 

 

 



a b 
b

 

b 



 

b
 

 

 

g abc 
 
 
 
 
 
 
 
 


 

 

 


 
 
 
 
 
 
 
 

b 
 

b

a 

b
 
 
 
 
 
 
 
 

 

b 

 

b

a b 

b 

 

 

c
 

b 

 

a b 

 

a 

 

 



b 
 

 

b
 

 



b 
 

 

 

 

figure     example apply operation
note v  always ancestor z            zm   consider variable
ancestor itself  self explaining checks performed lines      line   specific
multiplication  needs changed combination operations  algorithm creates
new meta node u  whose variable var v      xi recall var v    highest  closest root 
among v    z            zm   then  possible value xi   line    starts building list
children 
one important steps happens line     two lists meta nodes  one
original aomdd f g  refer variables  appear  
lists important property mentioned above  nodes ancestors
other  union two lists grouped maximal sets nodes  highest node
set ancestor others  follows root node set belongs one
original aomdd  say v   f   others  say z             z r g  example 
suppose pseudo tree fig     b   two lists  c  g  h  f  e  f  
g  grouping line    create  c  e   f   g  h   sometimes  may
case newly created group contains one node  means nothing join
recursive calls  algorithm return  via line    single node  on  one
input aomdds traversed  important complexity apply  discussed
below 
example    figure    shows result combining two boolean functions operation
 or product   input functions f g represented aomdds based chain pseudo
trees  results based pseudo tree expresses decomposition variables
b instantiated  apply operator performs depth first traversal two input
aomdds  generates resulting aomdd based output pseudo tree  similar
case obdds  function aomdd identified root meta node  example
input meta nodes labels  a    a    b    b    etc    output meta node labeled a  b 
   

fiand or ulti  valued ecision iagrams  aomdd   g raphical odels

root diagram represents function obtained combining functions rooted a 
b   
    complexity apply be aomdd
provide characterization complexity apply  based different criteria 
following propositions inspired results govern obdd apply complexity 
adapted pseudo tree orderings 
aomdd along pseudo tree regarded union regular mdds  restricted
full path root leaf pseudo tree  let path   based
definition strictly compatible pseudo trees  corresponding paths tf tf tg tg  
mdds f g corresponding tf tg combined using regular mdd
apply  process repeated every path   resulting mdds  one path
need synchronized common parts  on intersection paths   algorithm
proposed processing once  depth first search traversal inputs  based
construction  give first characterization complexity aomdd apply
governed complexity mdd apply 
proposition   let             l set paths enumerated left right let gfi
ggi mdds restricted path   size output aomdd apply

p
p bounded
   g   n max  g    g    time complexity bounded
   g  
 g
 g

g
g
g
f
f
f
n maxi  gfi    ggi   
second characterization complexity given  similar mdd case  terms
total number nodes inputs 
proposition   given two aomdds gfaomdd ggaomdd based strictly compatible pseudo trees 
size output apply o   gfaomdd     ggaomdd    
detail previous proposition follows  given aomdds gfaomdd ggaomdd  
based compatible pseudo trees tf tg common pseudo tree   define intersection pseudo tree tf g obtained following two steps      mark
subtrees whose nodes belong either tf tg  the leaves subtree
leaves        remove subtrees marked step       steps         applied
 that is  recursively   part aomdd gfaomdd corresponding variables tf g
denoted gff g   similarly ggaomdd denoted ggf g  
proposition   time complexity
 gfaomdd      ggaomdd    

apply

size output o  gff g    ggf g    

turn complexity be aomdd algorithm  bucket associated
bucket pseudo tree  top chain bucket pseudo tree variable xi contains
variables context xi    variables appear bucket pseudo tree 
associated buckets already processed  original functions belong bucket
xi scope included context xi    therefore associated aomdds based
   

fim ateescu   echter   arinescu

chains  functions appear bucket xi messages received independent branches below  therefore  two functions bucket xi share variables
context xi    forms top chain bucket pseudo tree  therefore characterize
complexity apply terms treewidth  context size bucket variable 
proposition   given two aomdds bucket be aomdd  time space complexity apply exponential context size bucket variable
 namely number variables top chain bucket pseudo tree  
bound complexity be aomdd output size 
heorem   space complexity be aomdd size output aomdd

o n k w    n number variables  k maximum domain size w treewidth

bucket tree  time complexity bounded o r k w    r number initial
functions 

   aomdds canonical representations
well known obdds canonical representations boolean functions given ordering
variables  bryant         namely strict ordering cnf specification
boolean function yield identical obdd  property extends mdds  srinivasan
et al          linear ordering variables defines chain pseudo tree captures
structure obdd mdd  case aobdds aomdds  canonicity
respect pseudo tree  transitioning total orders  that correspond linear ordering 
partial orders  that correspond pseudo tree ordering   one hand gain ability
compact compiled structure  hand canonicity longer respect
equivalent graphical models  relative graphical models consistent
pseudo tree used  specifically  start strict ordering generate chain
aomdd canonical relative equivalent graphical models  however want
exploit additional decomposition use partial ordering captured pseudo tree create
compact aomdd  aomdd however canonical relative equivalent graphical
models accept pseudo tree guided aomdd  general  aomdd
viewed flexible framework compilation allows partial total orderings 
canonicity restricted subset graphical models whose primal graph agrees partial
order relevant larger set orderings consistent pseudo tree 
following subsection discuss canonicity aomdd constraint networks 
case general weighted graphical models discussed section   
    aomdds constraint networks canonical representations
case constraint networks straightforward  weights or to and
arcs      show equivalent constraint networks  admit
pseudo tree   aomdd based   start proposition help prove
main theorem 
proposition   let f function  always zero  defined constraint network x  given
partition  x            xm   set variables x  namely  xi xj        j  x  
   

fiand or ulti  valued ecision iagrams  aomdd   g raphical odels




i   x    f   f        fm f   g        gm   scope fi     scope gi     x
            m     gi             m   namely  f decomposed
given partition  decomposition unique 

ready show aomdds constraint networks canonical representations
given pseudo tree 
heorem    aomdds canonical given pseudo tree  given constraint network 
pseudo tree constraint graph  unique  up isomorphism  aomdd represents it  minimal number meta nodes 
constraint network defined relations  or functions   exist equivalent constraint
networks defined different sets functions  even different scope signatures 
however  equivalent constraint networks define function  ask aomdd
different equivalent constraint networks same  following corollary derived
immediately theorem   
corollary   two equivalent constraint networks admit pseudo tree
aomdd based  

   canonical aomdds weighted graphical models
theorem   ensures aomdd canonical constraint networks  namely functions
take values      proof relied fact or to and weights
     proposition   ensured unique decomposition function defined
constraint network 
section turn general weighted graphical models  first observe proposition   longer valid general functions  valid solutions  having strictly
positive weight  weight decomposed one way product positive
weights 
therefore raise issue recognizing nodes root and or graphs represent
universal function  even though graphical representation different  see
aomdd weighted graphical model unique current definitions 
slightly modify obtain canonicity again  note canonicity aomdds
weighted graphical models  e g   belief networks  far less crucial case obdds
used formal verification  even that  sometimes may useful eliminate
redundant nodes  order maintain simpler semantics and or graph represents
model 
loss canonicity aomdd weighted graphical models happen
weights or to and arcs  suggest possible way re enforcing compact
canonical representation needed 
example    figure    shows weighted graphical model  defined two  cost  functions 
f  m  a  b  g m  b  c   assuming order  m a b c   figure    shows and or search
tree left  arcs labeled function values  leaves show value
corresponding full assignment  which product numbers arcs path  
   

fim ateescu   echter   arinescu




 
 
 
 
 
 
 
 






b
b
c

c


 
 
 
 
 
 
 
 

b f m a b 
 
  
 
 
 
  
 
 
 
 
 
  
 
 
 
 


 
 
 
 
 
 
 
 

b
 
 
 
 
 
 
 
 

c g m b c 
 
 
 
 
 
  
 
  
 
 
 
  
 
 
 
 

figure     weighted graphical model

 

 

 

 









 

 

b

 

b

 

  

 

 

 

 

 

c

c

 

 

 

     

  
 

c

 

 

 

 

 

     

     

  
 

 

b

 

  

 

c

  

 

b

  

 



c

b

 

 

 

c

c

 

  

 

 

 

  

 

 

 

 

 

 

 

 

 

     

     

     

 

b

  

 

  

 

 

 

 

 

 

c

 
 

     

 

 

 

  
 

b

 
 

c

 

 

b

 

c

  

     

 

  

 

 

 

 

 

c

c

  

 

  

 

 

 

 

 

 

 

     

figure     and or search tree context minimal graph

see either value       gives rise function  because leaves two
subtrees values   however  two subtrees identified representing
function usual reduction rules  right part figure shows context minimal
graph  compact representation subtree  share parts 
would case method recognizing left right subtrees
corresponding         represent function  normalizing
values level  processing bottom up  figure    left  values or to and
arcs normalized  variable  normalization constant promoted
value  figure    right  normalization constants promoted upwards
multiplication  process change value full assignment  therefore
produces equivalent graphs 
see already nodes labeled c merged  producing graph
figure    left  continuing process obtain aomdd weighted graph 
shown figure    right 
define aomdd weighted graphical model follows 
efinition     aomdd weighted graphical model  aomdd weighted graphical
model and or graph  meta nodes  that      meta node  weights sum
       root meta node constant associated it      completely reduced  namely
isomorphic meta nodes  redundant meta nodes 

   

fiand or ulti  valued ecision iagrams  aomdd   g raphical odels




 

 





 

 

b

 

b

b

  

 

  

 

 

 

 

 

 
   
 

   

     

 

 

     

   

 

 

 

 

 

 

 

     

 

 

 

    

 

 

   

    

 

 

 

 

    

 

 

b

    

     

 

    

 

c

   

 

b

    

c

     

 

b

    

   c
   



b

  

   c

 


 

b

 
 

   c

c

 

 

    

 

 

c

    

c

   

 

   

 

    

 

 

    
 

figure     normalizing values bottom
   



   
 



   

 
 



 




 

 

b

  
 

 

b

   

   

 

 

 

b

  
 

  
 

b

   

   

 

 

c

   
 

 

    
 

       

 

 

b

  

b

      

 

       

 

 

c

   

       

       

      

 

 

c

    

   

 

 

c

   
 

    
 

    
 

figure     aomdd weighted graph
procedure transforming weighted and or graph aomdd similar
procedure b ottom u p r eduction section    difference new layer
processed  first meta node weights normalized promoted parent 
procedure continues usual reduction rules 
heorem   given two equivalent weighted graphical models accept common pseudo tree
  normalizing arc values together exhaustive application reduction rules yields
and or graph  aomdd based  
finite precision arithmetic implementation algorithm described section may
prove challenging machines used finite precision arithmetic  since weights
real valued  repeated normalization may lead precision errors  one possible approach 
used experiments  define  tolerance  user defined sufficiently
small   consider weights equal within other 

   semantic treewidth
graphical model represents universal function f     function f may represented
different graphical models  given particular pseudo tree   captures structural
information f   interested graphical models accept pseudo tree  namely
primal graphs contain edges backarcs   since size aomdd f
based bounded worst case induced width graphical model along  
define semantic treewidth be 
   

fim ateescu   echter   arinescu

 


 

 

b
c

c


b



 

 



 

 




c








b

 



b
   
   
   
   
   
   




 a  two solutions

c
   
   
   
   
   
   
   
   


   
   
   
   
   
   
   
   
   
   


b c
   
   
   
   
   
   

b
   
   
   
   
   
   
   
   

c
   
   
   
   
   
   

 b  first model



b
   
   

b

c

b c
   
   



c
   
   

 c  second model

figure       queen problem
efinition     semantic treewidth  semantic treewidth graphical model relative
pseudo tree denoted swt  m   smallest treewidth taken models r
equivalent m  accept pseudo tree   formally  defined swt  m   
minr u r  u m  wt  r   u m  universal function m  wt  r  induced
width r along   semantic treewidth graphical model  m  minimal semantic
treewidth pseudo trees express universal function 
computing semantic treewidth shown np hard  
heorem   computing semantic treewidth graphical model np hard 
theorem   shows computing semantic treewidth hard  likely actual
complexity even higher  however  semantic treewidth explain sometimes minimal
and or graph obdd much smaller exponential treewidth pathwidth upper
bounds  many cases  could huge disparity treewidth semantic
treewidth along  
example    figure    a  shows two solutions   queen problem  problem expressed complete graph treewidth    given figure    b   figure    c  shows equivalent
problem  i e   set solutions   treewidth    semantic treewidth
  queen problem   
based fact aomdd canonical representation universal function
graphical model  conclude size aomdd bounded exponentially
semantic treewidth along pseudo tree  rather treewidth given graphical model
representation 
proposition   size aomdd graphical model bounded o n k swt  m    
n number variables  k maximum domain size swt  m  semantic
treewidth along pseudo tree  
   thank david eppstein proof 

   

fiand or ulti  valued ecision iagrams  aomdd   g raphical odels




b

b

c

c

b







c

n



p

 

 

 a  obdd representation

 b  primal graph hidden
variables m  n p  

figure     parity function
example    consider constraint network n variables every two variables constrained equality  x      one graph representation complete graph  another chain
another tree  problem specified complete graph  use linear order 
obdd linear size exists representation pathwidth  
 rather n  
semantic treewidth yield much better upper bound aomdd 
bad bound  well known parity function n variables compact 
chain like obdd representation  yet  constraint network representation parity function
function  namely complete graph variables   whose treewidth semantic
treewidth number variables  n  obdd representation parity function suggests
addition hidden variables simplify presentation  show example figure
    left side  figure    a  obdd representation parity function
four binary variables  graphical model would represent function complete graph
four variables  however  could add extra variables m  n p figure    b   sometimes
called hidden variables  help decompose model  case form constraint
together b represents parity b  namely     b     
parity  xor  operator  similarly  n would capture parity c  p
would capture parity n d  would give parity initial four variables 
two structures surprisingly similar  would interesting study connection
hidden variables compact aobdds  leave future work 

    experimental evaluation
experimental evaluation preliminary stages  results already encouraging  ran search based compile algorithm  recording trace and or search 
reducing resulting and or graph bottom up  results applied reduction isomorphism still kept redundant meta nodes  implemented algorithms
c   ran experiments    ghz intel core   duo  gb ram  running windows 

   

fim ateescu   echter   arinescu

     benchmarks
tested performance search based compilation algorithm random bayesian networks  instances bayesian network repository subset networks uai  
inference evaluation dataset 
random bayesian networks random bayesian networks generated using parameters
 n  k  c  p   n number variables  k domain size  c number conditional
probability tables  cpts  p number parents cpt  structure network
created randomly picking c variables n and  each  randomly picking p parents
preceding variables  relative ordering  remaining n c variables called root
nodes  entries probability table generated randomly using uniform distribution 
table normalized  possible control amount determinism
network forcing percentage det cpts     entries 
bayesian network repository bayesian network repository  contains collection belief
networks extracted various real life domains often used benchmarking probabilistic inference algorithms 
uai   inference evaluation dataset uai      inference evaluation dataset  contains
collection random well real world belief networks used first uai     
inference evaluation contest  purpose selected subset networks derived
iscas   digital circuits benchmark   iscas   circuits common benchmark used
formal verification diagnosis  circuits converted bayesian network
removing flip flops buffers standard way  creating deterministic conditional probability
table gate  putting uniform distributions input signals 
     algorithms
consider two search based compilation algorithms  denoted aomdd bcp aomddsat  respectively  reduce context minimal and or graph explored via isomorphism 
exploiting determinism  if any  present network  approach take handling
determinism based unit resolution cnf encoding  i e   propositional clauses  zero
probability tuples cpts  idea using unit resolution search bayesian networks first explored allen darwiche         aomdd bcp conservative applies
unit resolution node search graph  whereas aomdd sat aggressive
detects inconsistency running full sat solver  used zchaff sat solver  moskewicz 
madigan  zhao  zhang    malik        unit resolution well full satisfiability 
comparison  ran version aomdd bcp  called mdd bcp 
reference report results obtained ace  compiler  ace compiles bayesian
network arithmetic circuit  ac  uses ac answer multiple queries respect network  arithmetic circuit representation equivalent and or graphs
 mateescu   dechter         time ace compiler invoked  uses one two algorithms
basis compilation  first  elimination order generated network
  
  
  
  

http   www cs huji ac il compbio repository 
http   ssli ee washington edu bilmes uai  inferenceevaluation
available at  http   www fm vslib cz kes asic iscas 
available at  http   reasoning cs ucla edu ace

   

fiand or ulti  valued ecision iagrams  aomdd   g raphical odels

network

 w   h 

 n  k 

ace
 nodes time

mdd w  bcp
aomdd w  bcp
aomdd w  sat
 meta  cm or  time
 meta  cm or 
time  meta  cm or 
time
bayesian network repository
alarm
               
                                
   
   
    
   
   
    
cpcs  
                
            
               
                  
    
cpcs   
                
           
                                     
cpcs   b                                 
diabetes
                                
hailfinder                 
          
     
     
          
     
    
mildew
                              
                                              
mm
                  
           
               
                        
munin 
                                 
munin 
                                 
munin 
                                 
pathfinder                  
                                    
                                     
pigs
                              
                                                
water
                
                                                 
                  
    
uai   evaluation dataset
bn   
                 
          
                                           
bn   
                 
           
                                                    
bn   
                 
          
                                           
bn   
                 
           
                                              
bn   
                 
                                                  
          
     
    
bn   
                 
                             
     
     
          
     
    
bn   
                 
                             
     
     
    
   
     
    
bn   
                 
                             
     
     
          
     
    
bn   
                 
                             
     
     
          
     
    
bn   
                 
          
     
          
     
     
    
   
   
    
bn   
                 
                             
     
     
    
   
     
    
bn   
                 
                                              
                        
bn   
                 
                             
     
     
          
     
    
bn   
                 
                             
            
          
     
    
bn   
                 
          
               
                        
bn   
                 
          
                        
   
     
    
positive random bayesian networks  n     k    p    c    
r    
                
           
               
                  
    
r    
                
           
               
                  
    
r    
                
           
               
                  
    
r    
                
           
     
     
          
     
    
r    
                
            
               
                  
    
r    
                
            
               
                  
    
r    
                
           
               
                  
    
r    
                
           
               
                  
    
r    
                
           
     
     
          
     
    
r     
                
           
     
     
          
     
    
deterministic random bayesian networks  n      k    p    c     det       cpts containing     entries
r   d                      
           
               
                        
r   d                                   
               
                        
r   d                                   
                                             
r   d                                   
               
                        
r   d                                   
                                             
r   d                                   
                                             
r   d                                   
                                             
r   d                      
           
               
                        
r   d                                   
               
                        
r   d                                    
               
                        

table    results experiments    bayesian networks   problem classes  w  
treewidth  h   depth pseudo tree  n   number variables  k   domain size  time
given seconds  bold types highlight best results across rows 

   

fim ateescu   echter   arinescu

sufficiently small induced width  tabular variable elimination used basis 
algorithm similar one discussed chavira darwiche         uses tables represent factors rather adds  induced width large  logical model counting
used basis  tabular variable elimination typically efficient width small cannot
handle networks width larger  logical model counting  hand  incurs
overhead tabular variable elimination  handle many networks larger treewidth 
tabular variable elimination logical model counting produce acs exploit local structure  leading efficient online inference  logical model counting invoked  proceeds
encoding bayesian network cnf  chavira   darwiche        chavira  darwiche   
jaeger         simplifying cnf  compiling cnf d dnnf  extracting ac
compiled d dnnf  dtree cnf clauses drives compilation step 
experiments report compilation time seconds  time   number
nodes context minimal graph explored   cm   number meta nodes resulting
aomdd   meta   well size ac compiled ace   nodes   network
specify number variables  n   domain size  k   induced width  w   pseudo tree depth  h  
  stands exceeding  gb memory limit respective algorithm  best performance
points highlighted 
     evaluation bayesian networks
table   reports results obtained experiments    bayesian networks  aomdd
compilers well ace used min fill heuristic  kjaerulff        construct guiding
pseudo tree dtree  respectively 
       bayesian n etworks r epository
see ace overall fastest compiler domain  outperforming aomdd bcp
aomdd sat several orders magnitude  e g   mildew  pigs   however 
diagrams compiled ace aomdd bcp  resp  aomdd sat  comparable size 
cases  aomdd bcp aomdd sat able compile much smaller diagrams
ace  example  diagram produced aomdd bcp mildew network    times
smaller one compiled ace  principle output produced ace aomdd
similar guided pseudo tree dtree  scheme viewed
compilation alternative     extends decision diagrams     mimics traces search
properties may make representation accessible  compiler mdd bcp able
compile      test instances  sizes far larger produced
aomdd bcp  instance  pathfinder network  aomdd bcp outputs decision
diagram almost   orders magnitude smaller mdd bcp 
       uai   dataset
uai   dataset instances picked randomly    variables instantiated
evidence  see ace best performing compiler dataset  aomdd bcp
competitive ace terms compile time      test instances  aomdd sat
able compile smallest diagrams   networks  e g   bn     bn     bn     bn    
bn     bn      before  difference size compiled data structures produces
mdd bcp aomdd bcp   orders magnitude favor latter 
   

fiand or ulti  valued ecision iagrams  aomdd   g raphical odels

       r andom n etworks
problem instances denoted r     r      generated class random
belief networks parameters  n       k      p      c        similarly  instances denoted
r   d     r   d      belong class parameters  n        k      p      c  
     latter case  det       cpts deterministic  namely contain  
  probability tuples  test instances compiled without evidence  see
domain aomdd bcp aomdd sat able compile smallest diagrams 
average   times smaller produced ace  however  ace fastest
compiler  notice compiler mdd bcp ran memory test cases 
     impact variable ordering
theory dictates  aomdd size influenced quality guiding pseudo tree 
addition min fill heuristic considered hypergraph heuristic constructs
pseudo tree recursively decomposing dual hypergraph associated graphical model 
idea explored darwiche        constructing dtrees guide ace 
since min fill hypergraph partitioning heuristics randomized  namely ties
broken randomly   size aomdd guided resulting pseudo tree may vary significantly one run next  figure    displays aomdd size using hypergraph min fill
based pseudo trees   networks selected table       independent runs  record
average induced width depth obtained pseudo trees  see header plot
figure      see two heuristics dominate other  namely variance output
size quite significant cases 
     memory usage
table   shows memory usage  in mbytes  ace  aomdd bcp aomdd sat  respectively  bayesian networks table    see cases aomdd based compilers require far less memory ace  example  mildew network  aomddbcp aomdd sat use    mb memory compile and or decision diagram 
ace requires much     mb memory  moreover  compiled aomdd
case one order magnitude fewer nodes constructed ace  comparing
two and or search based compilers  observe networks significant amount
determinism  uai   evaluation dataset  aomdd sat uses average two
times less memory aomdd bcp  dramatic savings memory usage due aggressive constraint propagation employed aomdd sat compared aomdd bcp
seen bn    network  case  difference memory usage aomdd sat
aomdd bcp   orders magnitude favor former 

    related work
related work viewed along two directions      work related and or search
idea graphical models     work related compilation graphical models exploits
problem structure 
extensive discussion     provided previous work dechter mateescu
        since focus paper  mention and or idea origi   

fim ateescu   echter   arinescu

figure     effect variable ordering 

   

fiand or ulti  valued ecision iagrams  aomdd   g raphical odels

network

ace
aomdd w  bcp
aomdd w  sat
 nodes memory  mb   nodes memory  mb   nodes memory  mb 
bayesian network repository
alarm
     
    
   
      
   
      
cpcs  
       
           
             
      
cpcs   
      
    
     
            
      
cpcs   b          
      
diabetes
         
      
hailfinder
     
    
     
            
      
mildew
       
             
              
       
mm
      
             
             
      
munin 
         
      
munin 
         
      
munin 
         
n a
pathfinder
      
     
     
            
      
pigs
       
             
               
       
water
      
             
              
      
uai   evaluation dataset
bn   
     
n a        
             
      
bn   
      
n a          
               
       
bn   
     
n a        
             
      
bn   
      
n a        
               
      
bn   
     
n a
      
            
      
bn   
     
n a
     
            
      
bn   
     
n a
     
      
   
      
bn   
     
n a
     
            
      
bn   
     
n a
     
            
      
bn   
     
n a
     
      
   
      
bn   
     
n a
     
      
   
      
bn   
     
n a
      
             
      
bn   
     
n a
     
            
      
bn   
     
n a
     
            
      
bn   
     
n a
      
             
      
bn   
     
n a        
      
   
      
positive random bayesian networks parameters  n     k    p    c    
r    
      
           
             
      
r    
      
           
             
      
r    
      
           
             
      
r    
      
    
     
            
      
r    
       
           
             
      
r    
       
           
             
      
r    
      
           
             
      
r    
      
           
             
      
r    
      
    
     
            
      
r     
      
    
     
            
      
deterministic random bayesian networks parameters  n      k    p    c    
r   d    
      
           
             
      
r   d            
            
             
      
r   d            
             
              
      
r   d            
            
             
      
r   d            
             
              
      
r   d            
             
              
      
r   d            
             
              
      
r   d    
      
            
             
      
r   d            
           
             
      
r   d             
            
             
      

table    memory usage mbytes ace  aomdd bcp aomdd sat    bayesian
networks table    bold types highlight best performance across rows  n a
indicates respective memory usage statistic available aces output 

   

fim ateescu   echter   arinescu

nally developed heuristic search  nilsson         mentioned introduction  and or
search graphical models based pseudo tree spans graph model  similar
tree rearrangement freuder quinn               idea adapted distributed
constraint satisfaction collin et al               recently modi et al         
shown related graph based backjumping  dechter         work extended
bayardo miranker         bayardo schrag        recently applied optimization tasks larrosa et al          another version viewed exploring and or
graphs presented recently constraint satisfaction  terrioux   jegou      b  optimization  terrioux   jegou      a   similar principles introduced recently probabilistic
inference  algorithm recursive conditioning  darwiche        well value elimination
 bacchus et al       b      a   currently core advanced sat solvers  sang
et al         
direction      various lines related research  formal verification literature 
beginning work bryant        contains large number papers dedicated
study bdds  however  bdds fact structures  the underlying pseudo tree chain 
take advantage problem decomposition explicit way  complexity bounds
obdds based pathwidth rather treewidth 
noted earlier  work bertacco damiani        disjoint support decomposition
 dsd  related and or bdds various ways  main common aspect approaches show structure decomposition exploited bdd like representation  dsd
focused boolean functions exploit refined structural information inherent boolean functions  contrast  and or bdds assume structure conveyed
constraint graph  therefore broadly applicable constraint expression
graphical models general  allow simpler higher level exposition yields graphbased bounds overall size generated aomdd  full relationship two
formalisms studied further 
mcmillan        introduced bdd trees  along operations combining them 
 w
circuits bounded tree width  bdd trees linear space upper bound o  g  w    
 g  size circuit g  typically linear number variables  w treewidth 
bound hides large constants claim linear dependence  g  w bounded 
however  mcmillan maintains input function cnf expression bdd trees
bounds and or bdds  namely exponential treewidth only 
sketch short comparison mcmillans bdd trees aommds  consider
example simple pseudo tree root   left child right child  
nodes may stand set variables  bdd trees  assignments grouped
equivalence classes according cofactors generated remaining  
example assignments     equivalent generate function  
node represented bdd whose leaves cofactors  done  
node represented matrix bdds  column corresponds cofactor
line cofactor   contrast  aomdd represents node bdd whose
leaves cofactors  the number distinct functions   cofactor
root decomposition  an node    moreover  representations  as
descendants different cofactor   shared much possible goes  
high level description  becomes slightly complicated redundant nodes
eliminated  idea remains same 
   

fiand or ulti  valued ecision iagrams  aomdd   g raphical odels

and or structure restricted propositional theories similar deterministic decomposable negation normal form  d dnnf   darwiche   marquis        darwiche        
recently  huang darwiche      b  used trace dpll algorithm generate obdd 
compared typical formal verification approach combining obdds input
function according schedule  structures investigated case still or 
idea extended present work and or search compilation algorithm 
mcallester  collins  pereira        introduced case factor diagrams  cfd   subsume markov random fields bounded tree width probabilistic context free grammars  pcfg  
cfds much related and or graphs  cfds target minimal representation 
exploiting decomposition  similar nodes  exploiting context sensitive information allowing dynamic ordering variables based context  cfds eliminate
redundant nodes  part cause use zero suppression  claim
cfds canonical forms  description combine two cfds 
numerous variants decision diagrams designed represent integer valued
real valued functions  comprehensive view refer reader survey drechsler
sieling         algebraic decision diagrams  adds   bahar et al         provide compilation general real valued rather boolean functions  main drawback
size increases fast number terminals becomes large  several approaches
try alleviate problem  however structure capture still or 
exploit decomposition  alternatives introduce edge values  or weights  enable
subgraph sharing  edge valued binary decision diagrams  evbdds   lai   sastry       
use additive weights  multiplicative weights allowed called factored
evbdds  fevbdds   tafertshofer   pedram         another type bdds called k bmds
 drechsler  becker    ruppertz        use integer weights  additive multiplicative
parallel  adds extended affine adds  sanner   mcallester        
affine transformations achieve compression  result shown beneficial
probabilistic inference algorithms  tree clustering  still exploit
structure 
recently  independently parallel work and or graphs  dechter   mateescu      a      b   fargier vilarem        fargier marquis              proposed compilation csps tree driven automata  many similarities work 
main focus transition linear automata tree automata  similar
and or   possible savings tree structured networks hyper trees constraints
due decomposition  compilation approach guided tree decomposition
guided variable elimination based algorithms  well known bucket elimination
cluster tree decomposition principle  dechter   pearl        
wilson        extended obdds semi ring bdds  semi ring treatment restricted
search spaces  allows dynamic variable ordering  otherwise similar aim
scope aomdd  restricting aomdd graphs only  two closely related 
except express bdds using shenoy shafer axiomatization centered two
operation combination marginalization rather semi ring formulation  minimality
formulation wilson        general allowing merging nodes different values
therefore capture symmetries  called interchangeability  
another framework similar aomdds  became aware recently  probabilistic decision graphs  pdg  jaeger         work preceded relevant work
   

fim ateescu   echter   arinescu

discussed  fargier   vilarem        wilson        went somewhat unnoticed  perhaps due notational cultural differences  however similar motivation  framework
proposed algorithms  believe and or framework accessible  define framework multi valued domains  provide greater details algorithms complexity analysis 
make explicit connection search frameworks  fully address issues canonicity well
provide empirical demonstration  particular  claim canonicity pdgs similar
one make aomdds weighted models  relative trees  or forests 
represent given probability distribution 
another line research drechsler group  e g  zuzek  drechsler    thornton 
       use and or graphs boolean function representation  may seem similar
approach  however  semantics purpose and or graphs different 
constructed based technique recursive learning used perform boolean reasoning 
i e  explore logic consequences given assumption based structure circuit 
especially derive sets implicants  meaning case related
meaning gates functions  case meaning related semantic
functions  and or enumeration tree results circuit according zuzek et al 
       related and or decomposition discuss 

    conclusion
propose and or multi valued decision diagram  aomdd   emerges study
and or search spaces graphical models  dechter   mateescu      a      b  mateescu  
dechter        dechter   mateescu        ordered binary decision diagrams  obdds   bryant 
       data structure used compile graphical model 
graphical models algorithms search based compiled data structures bdds
differ primarily choices time vs  memory  move regular search
space and or search space spectrum algorithms available improved time
vs  memory decisions  believe and or search space clarifies available choices
helps guide user making informed selection algorithm would fit best
particular query asked  specific input function available computational resources 
contribution work is      formally describe aomdd prove
canonical representation constraint network      extend aomdd general weighted
graphical models      give compilation algorithm based and or search  saves
trace memory intensive search  the context minimal and or graph   reduces
one bottom pass      describe apply operator combines two aomdds
operation show complexity quadratic input  never worse exponential
treewidth      give scheduling order building aomdd graphical model
starting aomdds functions based variable elimination algorithm 
guarantees complexity exponential induced width  treewidth  along
ordering      show aomdds relate various earlier recent compilation frameworks 
providing unifying perspective methods      introduce semantic treewidth 
helps explain compiled decision diagrams often much smaller worst case
bound  finally      provide preliminary empirical demonstration power current
scheme 

   

fiand or ulti  valued ecision iagrams  aomdd   g raphical odels

acknowledgments
work done robert mateescu radu marinescu university california  irvine  authors would thank anonymous reviewers constructive
suggestions improve paper  david eppstein useful discussion complexity issues 
lars otten natasha flerova comments final version manuscript  work
supported nsf grants iis         iis          initial part radcliffe fellowship            through partner program   harvard undergraduate student john cobb 

appendix
proof proposition  
consider level variable xi   meta nodes list lxi   one pass
meta nodes lxi  the inner loop   two meta nodes level xi
and or graph isomorphic  would merged line    also 
pass meta nodes lxi redundant meta nodes lxi eliminated
line    processing meta nodes level xi create new redundant isomorphic
meta nodes levels processed before  follows resulting and or
graph completely reduced   
proof theorem  
bound size follows directly theorem    aomdd size smaller

size context minimal and or graph  bounded o n k wt  g     prove
time bound  rely use hash table  assumption efficient implementation allows access time constant  time bound and or s earch  aomdd

o n k wt  g     theorem    takes time linear output  we assume
constraint propagation performed search   procedure b ottom u p r eduction  procedure    takes time linear size context minimal and or graph  therefore  aomdd

computed time o n k wt  g     result algorithm performs
reduction search   
proof proposition  
complexity obdd  and mdd  apply known quadratic input  namely 
number nodes output product number nodes input  therefore 
number nodes appear along one path output aomdd product
number nodes input  along path   gfi    ggi    summing paths
gives result   
proof proposition  
argument identical case mdds  recursive calls apply lead combinations
one node gfaomdd one node ggaomdd  rather list nodes   number
total possible combinations o   gfaomdd     ggaomdd      
proof proposition  
recursive calls apply generate one meta node output combination
   

fim ateescu   echter   arinescu

nodes gff g ggf g   lets look combinations nodes gff g ggaomdd   ggf g  
meta nodes ggaomdd   ggf g participate combinations  lets call set a 
levels  of variables  right tf g   mechanics
recursive calls apply  whenever node f belongs gff g combined node
g belongs a  line    apply expands node f   node  or nodes 
remain same  happen nodes f combined
node  or nodes  a  point apply simply copy remaining portion
output ggaomdd   size therefore proportional   ggf g    because layer
metanodes immediately ggf g    similar argument valid symmetrical case 
combinations nodes ggaomdd   ggf g ggaomdd   ggf g   bound follows
arguments   
proof proposition  
apply operation works constructing output aomdd root leaves  first creates
meta node root variable  recursively creates children metanodes using apply
corresponding children input  worst case happen output
reduced all  recursive call made possible descendant  corresponds
unfolding full and or search tree based context variables  exponential
context size  apply finishes context variables  arrives first branching
bucket pseudo tree  remaining branches independent  similar case obdds 
one function occupies single place memory  apply simply create link
corresponding branches inputs  this happens line   apply algorithm  
therefore  time space complexity exponential context size   
proof theorem  
space complexity governed be  since aomdd never requires space

full exponential table  or tree   follows be aomdd needs space o n k w   
size output aomdd bounded  per layers  number assignments
context layer  namely  size context minimal and or graph   therefore 

context size bounded treewidth  follows output size o n k w   
time complexity follows proposition    fact number functions
bucket cannot exceed r  original number functions 
 
proof proposition  
suffices prove proposition      general result obtained induction 
essential function defined constraint network  i e   values      
function takes value   least one assignment  value   denotes consistent assignments  solutions     denotes inconsistent assignments  suppose f   f  f    lets denote
x full assignment x  x  x  projection x x  x    respectively 
write x   x  x   concatenation partial assignments   follows f  x    f   x    f   x    
therefore  f  x       must f   x        f   x         claim x   
f   x        exists x  f  x  x         suppose contradiction
exist x  f   x        f  x  x        x    since f always zero 

   

fiand or ulti  valued ecision iagrams  aomdd   g raphical odels

follows f  always zero  therefore must x  f   x        
leads contradiction  therefore functions f  f  uniquely defined f    
proof theorem  
proof structural induction depth pseudo tree   follows canonicity
proofs obdds  bryant        mdds  srinivasan et al          extends linear
orderings tree orderings capture function decomposition according pseudo tree  
depth   along paths root leaf  actually size dependency set 
set variables value function depends  remember aomdd
and or graph completely reduced  use word function  denoted f   refer
universal relation  characteristic function  defined constraint network 
assume depth    means function depend variable 
must one constants      suppose function constant    then  must
aomdd contain terminal meta node    since nodes must reachable
along path  would mean function evaluate    suppose aomdd
contains nonterminal meta node  say labeled x  x take k different values  must
k children meta nodes x terminal meta node    one
terminal    aomdd completely reduced  one    follows
meta node labeled x redundant  therefore  above  follows aomdd
representing constant   made terminal    unique  contains smallest
number nodes  similar argument applies constant   
now  suppose statement theorem holds constraint network admits
pseudo tree depth strictly smaller p  constraint network pseudo
tree depth equal p  p      let x root   domain  x            xk   
denote               k   functions defined restricted constraint network
x   xi   namely   f  x xi   let y            ym children x   suppose two
aomdds f   denoted g g     show two and or graphs isomorphic 
functions decomposed according pseudo tree root x removed 
fact forest independent pseudo trees  they share variables   rooted
y            ym   based proposition    unique decomposition   fiy        fiym  

            k   based induction hypothesis  function j unique aomdd 
and or graphs g g     look subgraphs descending x   xi  
completely reduced define function    therefore exists isomorphic mapping
them  let v root metanode g v   root g     claim g g  
isomorphic according following mapping 
 
v 
u   v 
 u   
 u   u subgraph rooted hx  xi i 
prove this  show well defined  isomorphic mapping 
meta node u g contained subgraphs rooted hx  xi hx  xj i 
and or graphs rooted  u  j  u  isomorphic one rooted u  therefore
other  since g   completely reduced  contain isomorphic subgraphs  therefore
 u    j  u   therefore well defined 
show bijection  show one to one  assume two distinct metanodes u  u  g   u       u     then  subgraphs rooted u  u  isomorphic
   

fim ateescu   echter   arinescu

subgraph rooted  u     therefore other  since g completely reduced  must
u    u    fact onto isomorphic mapping follows definition
fact onto new node root meta node  since aomdds
contain one root meta node  more one root would lead conclusion root
meta nodes isomorphic merged   conclude g g   isomorphic 
finally  show among and or graphs representing f   aomdd
minimal number meta nodes  suppose g and or graph represents f   minimal
number meta nodes  without aomdd  namely  completely reduced 
reduction rule would transform g and or graph smaller number meta nodes 
leading contradiction  therefore  g must unique aomdd represents f    
proof corollary  
proof theorem   rely scopes define constraint network  long
network admits decomposition induced pseudo tree   universal function defined
constraint network always aomdd  therefore constraint network
equivalent admits aomdd   
proof theorem  
constant associated root actually sum weights solutions 
derived definition weighted aomdd  weights meta node
normalized  they sum     therefore values computed node and or search
always    when task computing
p sum solution weights   therefore  constant
weighted aomdd always x w x  regardless graphical model  prove
weighted aomdds canonical functions normalized 
assume two different weighted aomdds  denoted g   g     normalized function f   let root variable a  domain  a            ak    let x denote full
assignment variables  similar argument root constant 
p
meta nodes normalized weights  follows w   a  a      w   a  a      x a a  f  x  
superscript w  w  indicates aomdd  summation possible assignments restricted   a    follows root meta nodes identical  value
root variable  restricted functions represented g   g   identical  recursively
apply argument above 
however  proof complete  discuss case restricted function
decomposed independent functions  according pseudo tree  suppose two
independent components  rooted b c  one   function  follows
entire function    prove meta nodes b g   g   identical  b
one value b  extendable solution  weight must   meta nodes  meta nodes
identical  b one value  suppose without loss generality weights
different first value b   
w   b  b      w   b  b    

   

since f       must value c   c  b   b    c   c  extended full
solution  sum weights possible extensions
x
f  x    w   b  b    w   c  c      w   b  b    w   c  c    
   
x b b   c c 

   

fiand or ulti  valued ecision iagrams  aomdd   g raphical odels

equations     fact weight non zero  follows
w   c  c      w   c  c    

   

equation    fact b one value fact weights b
normalized  follows value b 
w   b  b      w   b  b    

   

equations      follows
w   b  b    w   c  c      w   b  b    w   c  c    

   

however  sides
p equation   represent sum weights solutions b  
b    c   c    namely x b b   c c  f  x   leading contradiction  therefore  must
equation   false  continuing argument values b  follows metanodes b identical  similarly meta nodes c identical 
decomposition two components  argument applies  b
first component c meta variable combines components 
 
proof theorem  
consider well known np complete problem    coloring  given graph g 
  coloring g  namely  color vertices using three colors  two
adjacent vertices different colors  reduce    coloring problem computing
semantic treewidth graphical model  let h graph   colorable  nontrivial semantic treewidth  easy build examples h  g   colorable  g h
  colorable non trivial semantic treewidth  adding g simplify
task describing colorings h  however  g   colorable  g h
  colorable  semantic treewidth zero   
proof proposition  
since aomdds canonical representations graphical models  follows graphical
model actual semantic treewidth realized aomdd m 
therefore aomdd bounded exponentially semantic treewidth   

references
akers  s          binary decision diagrams  ieee transactions computers  c               
allen  d     darwiche  a          new advances inference recursive conditioning  proceedings nineteenth conference uncertainty artificial intelligence  uai     pp 
    
bacchus  f   dalmao  s     pitassi  t       a   algorithms complexity results  sat
bayesian inference  proceedings   th annual ieee symposium foundations
computer science  focs     pp         
   

fim ateescu   echter   arinescu

bacchus  f   dalmao  s     pitassi  t       b   value elimination  bayesian inference via backtracking search  proceedings nineteenth conference uncertainty artificial
intelligence  uai     pp       
bahar  r   frohm  e   gaona  c   hachtel  g   macii  e   pardo  a     somenzi  f          algebraic decision diagrams applications  ieee acm international conference
computer aided design  iccad     pp         
bayardo  r     miranker  d          complexity analysis space bound learning algorithms
constraint satisfaction problem  proceedings thirteenth national conference
artificial intelligence  aaai     pp         
bayardo  r  j     schrag  r  c          using csp look back techniques solve real world sat
instances  proceedings fourteenth national conference artificial intelligence
 aaai     pp         
bertacco  v     damiani  m          disjunctive decomposition logic functions 
ieee acm international conference computer aided design  iccad     pp       
bodlaender  h  l     gilbert  j  r          approximating treewidth  pathwidth minimum
elimination tree height  tech  rep   utrecht university 
bryant  r  e          graph based algorithms boolean function manipulation  ieee transactions computers             
cadoli  m     donini  f  m          survey knowledge compilation  ai communications 
                
chavira  m     darwiche  a          compiling bayesian networks local structure 
proceedings nineteenth international joint conference artificial intelligence  ijcai     pp           
chavira  m     darwiche  a          compiling bayesian networks using variable elimination 
proceedings twentieth international joint conference artificial intelligence  ijcai     pp           
chavira  m   darwiche  a     jaeger  m          compiling relational bayesian networks exact
inference  international journal approximate reasoning               
clarke  e   grumberg  o     peled  d          model checking  mit press 
collin  z   dechter  r     katz  s          feasibility distributed constraint satisfaction 
proceedings twelfth international conference artificial intelligence  ijcai    
pp         
collin  z   dechter  r     katz  s          self stabilizing distributed constraint satisfaction 
chicago journal theoretical computer science       special issue self stabilization 
darwiche  a          recursive conditioning  artificial intelligence                

   

fiand or ulti  valued ecision iagrams  aomdd   g raphical odels

darwiche  a          logical approach factoring belief networks  proceedings
eighth international conference principles knowledge representation reasoning
 kr     pp         
darwiche  a     marquis  p          knowledge compilation map  journal artificial intelligence research  jair              
dechter  r          constraint networks  encyclopedia artificial intelligence         
dechter  r          bucket elimination  unifying framework reasoning  artificial intelligence 
          
dechter  r     mateescu  r          and or search spaces graphical models  artificial intelligence                  
dechter  r     mateescu  r       a   mixtures deterministic probabilistic networks
and or search space  proceedings twentieth conference uncertainty artificial intelligence  uai     pp         
dechter  r     mateescu  r       b   impact and or search spaces constraint satisfaction counting  proceedings tenth international conference principles
practice constraint programming  cp     pp         
dechter  r     pearl  j          tree clustering constraint networks  artificial intelligence     
       
drechsler  r   becker  b     ruppertz  s          k bmds  new data structure verification 
proceedings      european conference design test  ed tc     pp     
drechsler  r     sieling  d          binary decision diagrams theory practice  international
journal software tools technology transfer  sttt                
fargier  h     marquis  p          use partially ordered decision graphs knowledge
compilation quantified boolean formulae  proceedings twenty first national
conference artificial intelligence  aaai     pp       
fargier  h     marquis  p          valued negation normal form formulas  proceedings
twentieth international joint conference artificial intelligence  ijcai     pp         
fargier  h     vilarem  m          compiling csps tree driven automata interactive solving  constraints               
fishburn  p  c          utility theory decision making  wiley  newyork 
freuder  e  c     quinn  m  j          taking advantage stable sets variables constraint
satisfaction problems  proceedings ninth international joint conference artificial
intelligence  ijcai     pp           
freuder  e  c     quinn  m  j          use lineal spanning trees represent constraint
satisfaction problems  tech  rep         university new hampshire  durham 
   

fim ateescu   echter   arinescu

huang  j     darwiche  a       a   compiling system models faster scalable diagnosis  proceedings   th national conference artificial intelligence  aaai    
pp         
huang  j     darwiche  a       b   dpll trace  sat knowledge compilation 
proceedings nineteenth international joint conference artificial intelligence
 ijcai     pp         
jaeger  m          probabilistic decision graphs   combining verification ai techniques
probabilistic inference  international journal uncertainty  fuzziness knowledgebased systems           
kask  k   dechter  r   larrosa  j     dechter  a          unifying cluster tree decompositions
reasoning graphical models  artificial intelligence                    
kjaerulff  u          triangulation graph based algorithms giving small total state space  tech 
rep   university aalborg  denmark 
korf  r     felner  a          disjoint pattern database heuristics  artificial intelligence           
    
lai  y  t     sastry  s          edge valued binary decision multi level hierarchical verification 
proceedings twenty nineth design automation conference  pp         
larrosa  j   meseguer  p     sanchez  m          pseudo tree search soft constraints 
proceedings european conference artificial intelligence  ecai     pp         
lee  c          representation switching circuits binary decision programs  bell system
technical journal             
mateescu  r     dechter  r          relationship and or search variable elimination  proceedings twenty first conference uncertainty artificial intelligence
 uai     pp         
mateescu  r     dechter  r          and or multi valued decision diagrams  aomdds 
weighted graphical models  proceedings twenty third conference uncertainty
artificial intelligence  uai     pp         
mcallester  d   collins  m     pereira  f          case factor diagrams structured probabilistic
modeling  proceedings twentieth conference uncertainty artificial intelligence  uai     pp         
mcmillan  k  l          symbolic model checking  kluwer academic 
mcmillan  k  l          hierarchical representation discrete functions application model
checking  computer aided verification  pp       
modi  p  j   shen  w   tambe  m     yokoo  m          adopt  asynchronous distributed constraint optimization quality guarantees  artificial intelligence              

   

fiand or ulti  valued ecision iagrams  aomdd   g raphical odels

moskewicz  m   madigan  c   zhao  y   zhang  l     malik  s          chaff  engineering
efficient sat solver  proceedings thirty eighth design automation conference  pp 
       
nilsson  n  j          principles artificial intelligence  tioga  palo alto  ca 
palacios  h   bonet  b   darwiche  a     geffner  h          pruning conformant plans counting models compiled d dnnf representations  proceedings   th international
conference planning scheduling  icaps     pp         
pearl  j          probabilistic reasoning intelligent systems  morgan kaufmann 
sang  t   bacchus  f   beame  p   kautz  h     pitassi  t          combining component caching
clause learning effective model counting  proceedings seventh international
conference theory applications satisfiability testing  sat    
sanner  s     mcallester  d          affine algebraic decision diagrams  aadds  application structured probabilistic inference  proceedings nineteenth international
joint conference artificial intelligence  ijcai     pp           
selman  b     kautz  h          knowledge compilation theory approximation  journal
acm                
shenoy  p          valuation based systems bayesian decision analysis  operations research 
           
srinivasan  a   kam  t   malik  s     brayton  r  k          algorithms discrete function
manipulation  international conference cad  pp       
tafertshofer  p     pedram  m          factored edge valued binary decision diagrams  formal
methods system design                  
terrioux  c     jegou  p       a   bounded backtracking valued constraint satisfaction
problems  proceedings ninth international conference principles practice
constraint programming  cp     pp         
terrioux  c     jegou  p       b   hybrid backtracking bounded tree decomposition constraint networks  artificial intelligence            
wilson  n          decision diagrams computation semiring valuations  proceedings
nineteenth international joint conference artificial intelligence  ijcai     pp 
       
zuzek  a   drechsler  r     thornton  m          boolean function representation spectral
characterization using and or graphs  integration  vlsi journal             

   


