journal artificial intelligence research                  

submitted       published      

computational logic foundations kgp agents
antonis kakas

antonis ucy ac cy

department computer science  university cyprus
   kallipoleos str   p o  box      cy      nicosia  cyprus

paolo mancarella

paolo mancarella unipi it

dipartimento di informatica  universita di pisa
largo b  pontecorvo            pisa  italy

fariba sadri

fs doc ic ac uk

department computing  imperial college london
south kensington campus  london sw  az  uk

kostas stathis

kostas cs rhul ac uk

department computer science  royal holloway
university london  egham  surrey tw    ex  uk

francesca toni

ft doc ic ac uk

department computing  imperial college london
south kensington campus  london sw  az  uk

abstract
paper presents computational logic foundations model agency called
kgp  knowledge  goals plan  model  model allows specification
heterogeneous agents interact other  exhibit proactive
reactive behaviour allowing function dynamic environments adjusting
goals plans changes happen environments  kgp provides highly
modular agent architecture integrates collection reasoning physical capabilities  synthesised within transitions update agents state response reasoning 
sensing acting  transitions orchestrated cycle theories specify order
transitions executed taking account dynamic context agent
preferences  well selection operators providing inputs transitions 

   introduction
widely acknowledged concept agency provides convenient powerful
abstraction describe complex software entities acting certain degree autonomy
accomplish tasks  often behalf user  wooldridge         agent context
understood software component capabilities reacting  planning
 inter  acting achieve goals environment situated  paper 
present model agency  called kgp  knowledge  goals plan   model
hierarchical highly modular  allowing independent specifications collection
reasoning physical capabilities  used equip agent intelligent decision making
adaptive behaviour  model particularly suited open  dynamic environments
agents adapt changes environment function
circumstances information incomplete 
c
    
ai access foundation  rights reserved 

fikakas  mancarella  sadri  stathis   toni

development kgp model originally motivated existing gap modal logic specifications  rao   georgeff        bdi agents  bratman  israel   
pollack        implementation  for example see issues raised rao        
another motivation development kgp comes participation socs
project  socs         need agent model satisfies several requirements  specifically  aimed agent model rich enough allow
intelligent  adaptive heterogeneous behaviour  formal could lent well
formal analysis  implementable way implementation sufficiently
close formal specification allow verification  although several models agency
proposed  none satisfies requirements once 
bridge gap specification implementation kgp model based
computational logic  cl   focus work extend synthesise number
useful computational logic techniques produce formal executable specifications
agents  purpose  model integrates abductive logic programming  alp   kakas 
kowalski    toni         logic programming priorities  kakas  mancarella    dung 
      prakken   sartor        constraint logic programming  jaffar   maher        
techniques explored right  modular integration
within kgp model explores extensions each  well providing high level agent
reasoning capabilities 
kgp model provides hierarchical architecture agents  specifies collection
modular knowledge bases  formalised cl  knowledge bases support collection reasoning capabilities  planning  reactivity  goal decision 
given formal specifications  model includes specification physical capabilities 
comprising sensing actuating  capabilities utilised within transitions 
model state agent changes result reasoning  sensing acting 
transitions use selection operators providing inputs  control component  called
cycle theory  formalised cl  specifies order transitions executed  depending environment  state agent  preferences agent 
cycle theory takes agent control beyond one size fits all approach used
agent models  allows us specify agents different preferences profiles behaviour  sadri   toni         particular  whereas majority existing agent models
rely upon observe plan act  means cycle theory model behaviours
observe revise goals planact observe plan sense action preconditions act
observe plan act plan act  provide one example cycle theory  refer
normal  allowing behaviours depending different circumstances  the environment agent situated preferences   note that  respect
agent models  kgp model allows agents revise goals life time 
observing environment according two modalities  active passive observation 
agent built kgp architecture dynamically determines goals  plans  partially  achieve goals  interleaves planning action executions making
observations environment receiving messages agents  adapts
goals plans new information receives  changes observes  generates appropriate reactions 
number publications already described aspects  an initial version of 
kgp agents  precursor overall model described kakas  mancarella 
   

ficomputational logic foundations kgp agents

sadri  stathis  toni      b   planning component presented mancarella 
sadri  terreni  toni         cycle theory developed kakas  mancarella 
sadri  stathis  toni      a  implementation discussed stathis et al 
        yip  forth  stathis  kakas         bracciali  endriss  demetriou 
kakas  lu  stathis         paper  provide full formal specification
components kgp model  thus offering complete technical account
kgp one place  providing full formal specification  adjusted
developed model  particular  notion state definition novel 
reasoning capabilities simplified added  physical
capabilities extended  to include actuating  formally defined  transitions
selection operators formally defined full 
rest paper structured follows  sections     give outline
model review background information necessary full description 
sections            respectively  describe internal state kgp agents  reasoning physical capabilities  transitions  section   describe selection
operators used cycle theory described section    following
detailed description kgp agents illustrate model series examples
section     compare model others literature section     finally 
conclude paper section    

   kgp model  outline
section give overview kgp agent model components 
provide informal examples functioning  model relies upon
internal  or mental  state  holding agent knowledge base  beliefs   goals  desires  plans  intentions  
set reasoning capabilities 
set physical capabilities 
set transition rules  defining state agent changes  defined
terms capabilities 
set selection operators  enable provide appropriate inputs transitions 
cycle theory  providing control deciding transitions applied
when 
model defined modular fashion  different activities encapsulated
within different capabilities transitions  control separate module 
model hierarchical structure  depicted figure   
    internal state
tuple hkb    f  c  i  where 
   

fikakas  mancarella  sadri  stathis   toni

cycle
theory

transitions




selection
operators


e
reasoning

capabilities

physical capabilities

figure    graphical overview kgp model
kb  holds beliefs agent external world situated
 including past communications   well record actions already
executed 
f forest trees whose nodes goals  may executable not 
tree forest gives hierarchical presentation goals  tree represents
construction plan root tree  set leaves tree f
forms currently chosen plan achieving root tree  executable goals
actions may physical  communicative  sensing  simplicity  assume
actions atomic duration  non executable goals may
mental sensing  non executable mental goals may children  forming
 partial  plans them  actions children tree f  goal
associated time variable  implicitly existentially quantified within overall
state serves two purposes      indicating time goal achieved 
instantiated goal achieved appropriate time      providing
unique identifier goal  remainder paper  often use
following terminology goals f  want emphasise role and or
nature  roots trees f referred top level goals  executable
goals referred actions  non executable goals top level
goals referred sub goals  top level goals classified reactive
non reactive  explained later    note top level  reactive  goals
may actions 
   roughly speaking  reactive goals generated response observations  e g  communications received
agents changes environment  example repair plans already
generated  non reactive goals  hand  chosen desires agent 

   

ficomputational logic foundations kgp agents

c temporal constraint store  namely set constraint atoms given
underlying constraint language  constrain time variables goals f 
example  may specify time window time action
instantiated  execution time 
set equalities instantiating time variables time constants  example 
time variables actions instantiated action execution time  records
instantiations kept  
    reasoning capabilities
kgp supports following reasoning capabilities 
planning  generates plans mental goals given input  plans consist
temporally constrained sub goals actions designed achieving input goals 
reactivity  used provide new reactive top level goals  reaction
perceived changes environment current plans held agent 
goal decision  used revise non reactive top level goals  adapting
agents state changes environment 
identification preconditions identification effects actions  used
determine appropriate sensing actions checking whether actions may safely
executed  if preconditions known hold  whether recently executed
actions successful  by checking known effects hold  
temporal reasoning  allows agent reason evolving environment 
make predictions properties  including non executable goals  holding
environment  based  partial  information agent acquires lifetime 
constraint solving  allows agent reason satisfiability
temporal constraints c  
concrete realisation kgp model provide paper  chosen
realise capabilities various extensions logic programming paradigm 
particular  use  conventional  logic programming identification preconditions
effects  abductive logic programming constraints  see section      planning 
reactivity temporal reasoning  logic programming priorities  see section     
goal decision 
    physical capabilities
addition reasoning capabilities  kgp agent equipped physical capabilities  linking agent environment  consisting
sensing capability  allowing agent observe properties hold
hold  agents executed actions 
actuating capability  executing  physical communicative  actions 
   

fikakas  mancarella  sadri  stathis   toni

    transitions
state hkb    f  c  agent evolves applying transition rules  employ
capabilities follows 
goal introduction  gi   possibly changing top level goals f  using goal
decision 
plan introduction  pi   possibly changing f c using planning 
reactivity  re   possibly changing reactive top level goals f c  using
reactivity capability 
sensing introduction  si   possibly introducing new sensing actions f checking
preconditions actions already f 
passive observation introduction  poi   updating kb  recording unsolicited information coming environment  using sensing 
active observation introduction  aoi   possibly updating kb    recording
outcome  actively sought  sensing actions  using sensing 
action execution  ae   executing types actions consequence updating
kb    using actuating 
state revision  sr   possibly revising f  using temporal reasoning constraint solving 
    cycle selection operators
behaviour agent given application transitions sequences  repeatedly
changing state agent  sequences determined fixed cycles behaviour  conventional agent architectures  rather reasoning cycle theories 
cycle theories define preference policies order application transitions 
may depend environment internal state agent  rely upon
use selection operators detecting transitions enabled inputs
be  follows 
action selection inputs ae  selection operator uses temporal reasoning
constraint solving capabilities 
goal selection inputs pi  selection operator uses temporal reasoning
constraint solving capabilities 
effect selection inputs aoi  selection operator uses identification
effect reasoning capability 
precondition selection inputs si  selection operator uses identification
preconditions  temporal reasoning constraint solving capabilities 
   

ficomputational logic foundations kgp agents

provision declarative control agents form cycle theories highly
novel feature model  could  principle  imported agent systems 
concrete realisation kgp model provide paper  chosen
realise cycle theories framework logic programming priorities
constraints  see section      use goal decision 
relationships capabilities  transitions selection operators
summarised tables       below  table     indicates capabilities  rows 
used transitions selection operators  table   indicates selection
operators used compute possible inputs transitions cycle theory 

sensing
actuating
  plan
  pre
  gd
  react
  t r
  cs
  ef f

ae
x
x

transitions
aoi gi p oi
x
x

pi



sr

si

selection operators
fgs fas fes fp

x
x

x

x
x

x
x

x
x
x

x
x

x

x
x

x

table    tabular overview use capabilities transitions selection operators 
here    plan     pre     gd     react     t r     cs   ef f   stand for  respectively 
planning  identification preconditions  goal decision  reactivity  temporal reasoning  constraint solving identification effects  reasoning  capabilities 
fgs   fas   fes   fp stand for  respectively  goal  action  effect precondition
selection operators 

ae
fgs
fas
fes
fp

aoi

gi

p oi

pi
x



sr

si

x
x
x

table    tabular overview connections selection operators transitions 
required cycle theory  here  fgs   fas   fes   fp stand for  respectively 
goal  action  effect precondition selection operators 
provide components  though  introduce informally scenario
examples used illustrate technical details kgp agent
   

fikakas  mancarella  sadri  stathis   toni

model throughout paper  full  formal presentation well additional
examples given throughout paper section    
    examples
draw examples ubiquitous computing scenario call san
vincenzo scenario  presented de bruijn stathis        summarised follows 
businessman travels work purposes italy and  order make trip easier 
carries personal communicator  namely device hybrid mobile phone
pda  device businessmans kgp agent  agent considered
personal service agent  mamdani  pitt    stathis         or psa short 
provides proactive information management flexible connectivity smart services
available global environment within businessman travels within 
      setting  
businessmans psa requests san vincenzo station agent  svs  arrival time
train tr   rome  svs information answers
refusal  later  svs receives information arrival time tr   train
central office agent  co  psa requests arrival time tr   again  svs
accept request provide information 
first example requires one use reactivity capability model rules interaction transition  a  achieve interaction amongst agents   b  specify
dynamic adjustments agents behaviour changes  allowing different reactions
request  depending current situation agent  here  interaction
form negotiation resources amongst agents  resources items information 
thus  current situation agents amounts resources information agents
currently own 
example requires combination transitions re  poi  ae achieve
expected agents behaviours  follows 
   psa makes initial request applying ae
   svs becomes aware request performing poi  and changing kb  accordingly 
   svs decides reply refusal performing  and adding corresponding
action plan f 
   svs utters refusal performing ae
   svs becomes aware  poi  arrival time  modifying kb  accordingly 
   psa makes second request applying ae
   svs decides reply requested information performing  and adding
corresponding action plan f  communicates information
performing ae 
   

ficomputational logic foundations kgp agents

sequence transitions given so called normal cycle theory
see section   
      setting  
preparation businessmans next trip  psa aims getting plane ticket
madrid denver well obtaining visa usa  one possible way buy plane
tickets internet  buying tickets way usually possible 
destinations  depending whether airlines flying destinations sell tickets
internet not  without internet connection  psa currently
connection  information denver indeed destination tickets
bought online  plans buy ticket internet nonetheless  conditionally 
checks conditions executing planned action  successfully buying
ticket  psa focuses second goal  obtaining visa  achieved
applying usa embassy madrid  application requires address
usa  address obtained arranging hotel denver 
example illustrates form partial planning adopted kgp model
 where non executable sub goals well actions may part plans  shows
combination transition pi si ae allows psa agent deal partial
information  generate conditional plans plans several layers  follows 
   psa initially equipped top level goals get ticket denver
obtain visa  through earlier application gi 
   pi first goal  psa adds partial plan f  buying ticket online
subject sub goals internet connection available online
tickets bought denver  sub goals sensing goals
   si  sensing actions added f evaluate sensing sub goals environment
   sensing actions executed ae  and kb  modified accordingly 
   depending sensed values sensing sub goals buying action may
may executed ae  let us assume remainder example
action executed
   sr applied eliminate actions  since already executed   subgoals top level goal getting ticket denver  since achieved 
   pi remaining top level goal obtaining visa  psa adds plan fill
application form  action  acquiring residence address denver  sub goal 
   action cannot executed  psa knows businessman resident
usa  pi introduces plan sub goal booking hotel  action 
subgoal acquiring residence address denver
   ae executes booking action
   

fikakas  mancarella  sadri  stathis   toni

    ae executes action applying visa
    sr eliminates actions  since already executed   sub goal toplevel goal getting visa  since achieved  

   background
section give necessary background reasoning capabilities cycle
theory kgp agents  namely 
constraint logic programming  pervasive whole model 
abductive logic programming  heart planning  reactivity temporal
reasoning capabilities 
logic programming priorities  heart goal decision capability
cycle theories 
    constraint logic programming
constraint logic programming  clp   jaffar   maher        extends logic programming
constraint predicates processed ordinary logic programming predicates 
defined rules  checked satisfiability simplified means built in 
black box constraint solver  predicates typically used constrain values
variables conclusion rule take  together unification
treated via equality constraint predicate   kgp model  constraints used
determine value time variables  goals actions  suitable temporal
constraint theory 
clp framework defined structure   consisting domain d    set
constraint predicates includes equality  together assignment relations
d    constraint predicate  clp  constraints built first order
formulae usual way primitive constraints form c t            tn   c
constraint predicate symbol t            tn terms constructed domain  d    
values  rules constraint logic program  p   take form rules
conventional logic programming given
h l            ln
h  ordinary  atom  l            ln literals  n    literals positive  namely
ordinary atoms  negative  namely form b  b ordinary atom 
constraint atoms    negation symbol indicates negation failure  first
introduced clark         variables h li implicitly universally quantified 
scope entire rule  h called head  or conclusion  l            ln called
body  or conditions  rule form above  n      rule called fact 
valuation    set variables mapping variables domain
d    natural extension maps terms d     valuation   set
variables appearing set constraints c  called   solution c iff c  obtained
applying c  satisfied  i e  c evaluates true given interpretation
   

ficomputational logic foundations kgp agents

constraint predicates terms  denoted     c  set c called   solvable
  satisfiable  denoted     c  iff least one   solution  i e      c
valuation  
one way give meaning constraint logic program p consider grounding program herbrand base possible valuations  d    
constraint variables  rule  ground constraints c body evaluated true rule kept constraints c dropped  otherwise whole
rule dropped  let ground p   resulting ground program  meaning p
given meaning   lp ground p    many different possible
choices  kakas  kowalski    toni         resulting overall semantics constraint
logic program p referred   lp       precisely  given constraint logic
program p conjunction n c  where n conjunction non constraint literals
c conjunction constraint atoms   remainder paper write
p   lp     n c
denote exists ground substitution variables n c that 
    c
ground p     lp n  
    abductive logic programming constraints
abductive logic program constraints tuple h   p  a  ii where 
  structure section    
p constraint logic program  namely set rules form
h l            ln
section    
set abducible predicates language p   predicates
occurring head clause p  without loss generality  see  kakas et al  
        atoms whose predicate abducible referred abducible atoms
simply abducibles 
set integrity constraints  is  set sentences language p  
integrity constraints kgp model implicative form
l            ln a         n        
li literals  as case rules      aj atoms  possibly special
atom f alse   disjunction a        referred head constraint
conjunction l            ln referred body  variables integrity
constraint implicitly universally quantified outside  except variables
occurring head  implicitly existentially quantified scope
head itself 
   n      l            ln represents special atom true 

   

fikakas  mancarella  sadri  stathis   toni

given abductive logic program constraints h   p  a  ii formula  query 
q   implicitly existentially quantified  conjunction literals language
p   purpose abduction find  possibly minimal  set  ground  abducible
atoms which  together p   entails  an appropriate ground instantiation of  q 
respect notion entailment language p equipped with 
extension p satisfies  see  kakas et al         possible notions
integrity constraint satisfaction   here  notion entailment combined
semantics   lp       discussed section     
formally  given query q  set  possibly non ground  abducible atoms 
set c  possibly non ground  constraints  pair    c  abductive answer  with
constraints  q  respect abductive logic program constraints h   p  a  ii 
iff groundings variables q    c     c  holds
 i  p   lp     q 
 ii  p   lp     i  i e  b h i  p   lp     b p   lp     h 
here  plays role earlier informal description abductive answer  note
that   ii   integrity constraints classical implications 
note that  representing knowledge abductive logic program  one needs
decide go logic program  integrity constraints
abducibles  intuitively  integrity constraints normative need
enforced  making sure head holds whenever body  by condition  ii 
above   whereas logic programming rules enable  help abducibles  derivation
given goals  by condition  i  above   finally  abducibles chosen amongst literals
cannot derived means logic programming rules  paper  represent reactive constraints  that condition action rules forcing reactive behaviour
agents  integrity constraints  thus extent addressing knowledge representation challenge posed abductive logic programming imposing sort structure
abductive logic programs use 
notion abductive answer extended take account initial set
 possibly non ground  abducible atoms   initial set  possibly non ground 
constraint atoms c    extension  abductive answer q  respect
 h   p  a  ii      c   
pair    c 
 i        
 ii  c c       
 iii        c c    abductive answer q respect h   p  a  ii  in
earlier sense  
worth noticing abductive answer    c  query true respect
 h   p  a  ii      c   
   

ficomputational logic foundations kgp agents

read fact abducibles     along constraints
c  c  guarantee overall consistency respect integrity constraints given
i  used specification capabilities kgp agents 
remainder paper  simplicity  omit   abductive logic
programs  written simply triples hp  a  ii  addition  abductive logic
programs present kgp variants core event calculus  kowalski   sergot 
       define section       
    logic programming priorities
purposes paper  logic program priorities constraint structure
   referred   consists four parts 
 i  low level basic part p   consisting logic program constraints  rule
p assigned name  term  e g  one rule could
n x      p x  q x     r y  
name n x    naming ground instance rule 
 ii  high level part h  specifying conditional  dynamic priorities amongst rules p
h  e g  one priority could
h x    m x  n x  c x 
read   some instance of  condition c x  holds   the corresponding instance of  rule named m x  given higher priority  the
corresponding instance of  rule named n x   rule named h x  
 iii  auxiliary part a  constraint logic program defining  auxiliary  predicates
occurring conditions rules p  h conclusions rule
p h 
 iv  notion incompatibility which  purposes  assumed given
set rules defining predicate incompatible    e g 
incompatible p x   p   x  
read  instance literal p x  incompatible corresponding
instance literal p   x   assume incompatibility symmetric always
includes r incompatible r two rule names r  s  refer
set incompatibility rules i 
concrete lpp framework equipped notion entailment  denote   pr   defined top underlying logic programming constraints
semantics   lp       defined differently different approaches lpp
share following pattern  given logic program priorities   hp  h  a  ii
conjunction ground  non auxiliary  atoms    pr iff
 i  exists subset p   basic part p p     lp      
   

fikakas  mancarella  sadri  stathis   toni

 ii  p   preferred wrt h subset p    p derives  under   lp      
conclusion incompatible  wrt i   
framework way specifying meant one sub theory p  
preferred another sub theory p      example  existing literature  kakas et al  
      prakken   sartor        kowalski   toni        kakas   moraitis           pr
defined via argumentation  approach adopt  relying notion
admissible argument sub theory  i  consistent  does incompatible
conclusions   ii  whose rules lower priority  respect high level
part h theory  sub theory incompatible conclusions
it  precise definition sets rules compared matter
choice specific framework lpp 
given concrete definition admissible sub theories  preference entailment 
  pr   given by 
 i  exists  maximal  admissible sub theory       lp      
 ii  incompatible exist admissible sub theory
        lp      
first condition satisfied say theory credulously prefers possibly prefers   conditions satisfied say
theory sceptically prefers  

   state kgp agents
section define formally concept state kgp agent  introduce
notation use rest paper order refer state components 
necessary  try exemplify discussion simple examples 
    preliminaries
kgp model assume  possibly infinite  vocabularies of 
fluents  indicated f  f           
action operators  indicated a  a          
time variables  indicated             
time constants  indicated t  t                         standing natural numbers  we
often use constant indicate current time 
names agents  indicated c  c           
constants  ones mentioned above  normally indicated lower case
letters  e g  r  r         
   

ficomputational logic foundations kgp agents

given constraint language  including constraint predicates                  respect structure    e g  natural numbers  equipped notion
constraint satisfaction      see section      
assume set fluents partitioned two disjoint sets 
mental fluents  intuitively representing properties agent able plan
satisfied  observed 
sensing fluents  intuitively representing properties control
agent observed sensing external environment 
example  problem f ixed resource may represent mental fluents  namely
properties  given  problem fixed  given  resource obtained  whereas request accepted connection may represent sensing fluents  namely
properties request  given  resource accepted  given 
connection active  note important distinguish mental sensing
fluents treated differently control agent  mental fluents need
planned for  whereas sensing fluents observed  clarified later
paper 
assume set action operators partitioned three disjoint sets 
physical action operators  representing actions agent performs order
achieve specific effect  typically causes changes environment 
communication action operators  representing actions involve communications
agents 
sensing action operators  representing actions agent performs establish
whether fluent  either sensing fluent expected effect action 
holds environment  whether agent performed action 
example  sense connection on    action literal representing act sensing whether network connection time   do clear table    action literal representing physical action removing every item given table 
tell c    c    request r     d    action literal representing communication action
expresses agent c  requesting agent c  resource r  within dialogue
identifier d  time    
fluent action operator associated arity  assume arity
greater equal    one argument  the last one  convention  always
time point given fluent holds given action takes place  time point
may time variable time constant  given fluent f arity n      refer
f  s            sn    x  f  s            sn    x   si constant x time
variable time constant  timed  fluent literals     given fluent literal    denote  
   role dialogue identifier become clearer section     intuitively  used link
communication actions occurring within dialogue 
   note represents classical negation  negation failure occurs model within
knowledge bases agents  supporting reasoning capabilities cycle theory  negations
state understood classical negations 

   

fikakas  mancarella  sadri  stathis   toni

complement  namely f  s            sn    x    f  s            sn    x   f  s            sn    x 
  f  s            sn    x   examples fluent literals resource pen     representing
certain resource pen obtained time   well  the ground 
on box  table       representing time     a certain  box  a certain 
table 
note assume fluent literals ground except time parameter 
allow us keep notation simpler highlight crucial role played
time parameter  given simplification  often denote timed fluent literals simply
  x  
given action operator arity n      refer a s            sn    x   si
constant x time variable time constant   timed  action literal  similarly
case fluent literals  simplicity  assume timed action literals
ground except possibly time  hence  often denote timed action literals
a x  
adopt special syntax sensing actions  always form  x
either time variable time constant  
sense f  x   f fluent 
sense c   a  x   c name agent action operator 
first case  sensing action allows agent inspect external environment
order check whether fluent f holds time x sensing  second
case  sensing action allows agent determine whether  time x  another agent c
performed action a 
define formally concept state hkb    f  c  agent 
    forest  f
node tree f is 
either non executable goal  namely  non ground  timed fluent literal 
executable goal  namely  non ground  timed action literal 
example tree f given figure    p  given problem
agent  c    needs fix getting two resources r  r    agent
already decided get r  agent c  already planned ask c 
communication action tell c    c    request r     d       example  san vincenzo
scenario  p  may transfer airport needs arranged  r  may taxi  c 
taxi company  needed transportation train station  finally r  may
train ticket 
note time variable non executable goals      actions a     any tree
in  f understood variable existentially quantified within whole state
agent  whenever goal action introduced within state  time variable
understood distinguished  fresh variable  serving identifier 
   

ficomputational logic foundations kgp agents

problem f ixed p      





ppp

pp


p

pp
pp

resource r       

resource r       

tell c    c    request r     d     

figure    example tree f
indicated section    roots trees referred top level goals  executable
goals often called simply actions  non executable goals may top level goals subgoals  example  figure    node identifier   top level goal  nodes
identifiers       sub goals node identifier   action 
notation     given forest f tree f 
node n   parent n     children n     ancestors n     siblings n    
descendents n     indicate parent node n   children n  
etc  leaf  n    value true n leaf   false otherwise 
node n f  parent n  f   children n  f   ancestors n  f   siblings n  f  
descendents n  f   leaf  n  f  indicate parent n    tree f
n occurs  etc   t unique  due uniqueness time variable identifying
nodes  
nodes t   represent set nodes   nodes f  represent set

nodes f    f nodes t   
again  indicated section    top level goal tree f either
reactive non reactive  see  section    reactive top level goals introduced state transition whereas non reactive top level goals introduced gi transition  example  f agent c  may consist tree
figure    root non reactive goal  well tree root reactive goal  action 
   

fikakas  mancarella  sadri  stathis   toni

tell c    c    accept request r     d         action may reply  planned agent c   
request resource r  agent c   for example  san vincenzo scenario  r 
may meeting requested colleague  
notation     given forest f
rootsr  f   resp  rootsnr  f   denote set reactive  resp  non reactive 
top level goals f
nodesr  f   resp  nodesnr  f   denote subset nodes f  consisting nodes
trees whose root rootsr  f   resp  rootsnr  f  
r f   resp  nr f   stands reactive  resp  non reactive  part f  namely
set trees f whose root rootsr  f   resp  rootsnr  f   
trivially  r f  nr f  disjoint  f  r f  nr f  
    temporal constraint store  c
set constraint atoms  referred temporal constraints  given underlying
constraint language  temporal constraints refer time constants well time variables
associated goals  currently previously  state 
example  given forest tree figure    c may contain              
indicating top level goal  of fixing problem p   needs achieved within time
interval                           indicating resources r  r  need acquired
top level goal deemed achieved          indicating
agent needs ask agent c  first  note need impose    
executed order  namely c may contain neither                
    agents dynamic knowledge base  kb 
kb  set logic programming facts state agent  recording actions
executed  by agent others  time execution  well
properties  i e  fluents negation  observed time
observation  formally  facts following forms 
executed a  t  a t  ground action literal  meaning action
executed agent time t 
observed    t    t  ground fluent literal  meaning   observed
hold time t 
observed c  a t     t  c agents name  different name agent
whose state defining  t  time constants  a t     ground  action
literal  means given agent observed time agent c
executed action time t     
   see that  construction  always case t  t  note time executed
actions  t    time observation  t  typically different concrete implementation
kgp model  depend  example  time execution transitions within
operational trace agent 

   

ficomputational logic foundations kgp agents

note facts kb  variable free  time variables occur them  facts
first kind record actions executed agent itself  facts
second kind record observations made agent environment  excluding actions
executed agents  represented instead facts third kind 
example  action labelled   figure   executed  by ae transition 
time   executed tell c    c    request r     d      added kb    moreover  if 
time    c  observes  e g  transition poi  resource r    observation
observed have resource r        added kb    finally  kb  may contain
observed c    tell c    c    request r     d          
represent agent c  become aware  time    agent c  requested 
earlier time    resource r  c   
    instantiation time variables 
time variable occurring non executable goal      action a    f
instantiated time constant  e g  action execution time   actual instantiation
  recorded component state agent  example  action
labelled   figure   executed time          added  
use allows one record instantiation time variables
time keeping different goals fluent distinguished  clearly  time
variable exists one equality    
notation     given time variable   denote     time constant t  any 
   
worth pointing valuation temporal constraint c c always
take equalities account  namely  ground valuation temporal
variables c must agree temporal variables assigned  
example  given          c                  suitable valuation 
whereas       not 

   reasoning capabilities
section  give detailed specifications various reasoning capabilities  specified within framework ordinary logic programming  for temporal reasoning
identification preconditions effects   abductive logic programming constraints  section      planning reactivity   logic programming priorities
constraints  section      goal decision   constraint programming  section     
constraint solving  
reasoning capabilities defined means notion entailment respect
appropriate knowledge base  and time point now  appropriate   follows 
   

fikakas  mancarella  sadri  stathis   toni

  t r kbt r temporal reasoning  kbt r constraint logic program
variant framework event calculus  ec  reasoning actions 
events changes  kowalski   sergot           
  now
plan kbplan planning  kbplan abductive logic program
constraints  extending kbt r  
  now
react kbreact reactivity  kbreact extension kbplan   incorporating additional integrity constraints representing reactive rules 
  pre kbpre   kbpre logic program contained kbt r  
  ef f kbef f   kbef f logic program contained kbt r  
  now
gd kbgd   kbgd logic program priorities constraints 
constraint solving capability defined terms entailment   cs
basically     defined section     
    temporal reasoning  planning  reactivity  identification preconditions
effects  ec based capabilities
reasoning capabilities specified within framework event calculus
 ec  reasoning actions  events changes  kowalski   sergot         below 
first give core ec show use define various capabilities
section 
      preliminaries  core event calculus
nutshell  ec allows one write meta logic programs talk objectlevel concepts fluents  events  that interpret action operators      time points 
main meta predicates formalism are 
holds at f      fluent f holds time  
clipped t    f  t      fluent f clipped  from holding holding  times
t  t   
declipped t    f  t      fluent f declipped  from holding holding 
times t  t   
initially f     fluent f holds initial time  say time   
happens o      operation happens time  
initiates o  t  f     fluent f starts hold operation time  
   sophisticated  abductive logic programming version   t r kbt r given bracciali
kakas        
   section use original event calculus terminology events instead operators 
rest paper 

   

ficomputational logic foundations kgp agents

terminates o  t  f     fluent f ceases hold operation time  
roughly speaking  last two predicates represent cause effects links operations fluents modelled world  use meta predicate
precondition o  f     fluent f one preconditions executability
operation o 
fluent literals agents state mapped onto ec follows  ec like representation fluent literal f      resp  f      agents state atom holds at f   
 resp  holds at f      moreover  arguments time variable need
considered  ec representation fluent literal f  x            xn      resp  f  x            xn     
holds at f  x            xn       resp  holds at f  x            xn        
similarly  action literals state agent represented ec
straightforward way  given action literal a    ec representation happens a    
arguments time considered  e g  a x            xn      ec representation given happens a x          xn      
remainder paper  abuse terminology  sometimes refer
f  x            xn   f  x            xn   interchangeably fluent literals fluents  although
strictly speaking fluent literals   a x          xn   interchangeably action
literals action operators  although strictly speaking action literals  
ec allows one represent wide variety phenomena  including operations
indirect effects  non deterministic operations  concurrent operations  shanahan        
core ec use paper consists two parts  domain independent rules
domain dependent rules  basic domain independent rules  directly borrowed
original ec  are 
holds at f  t   
holds at f  t   
holds at f   
holds at f   
clipped t    f  t   
declipped t    f  t   

happens o  t     initiates o  t    f   
t    t    clipped t    f  t   
happens o  t     terminates o  t    f   
t    t    declipped t    f  t   
initially f      t  clipped    f   
initially f      t  declipped    f   
happens o     terminates o  t  f    t    t 
happens o     initiates o  t  f    t    t 

domain dependent rules define initiates  terminates  initially  e g  case
setting       section     may
initiates tell c  svs  inf orm q  i   d   t  inf o svs  q  i  
holds at trustworthy c    
initially have inf o svs  arrival tr     i 
   note write holds at f  x            xn      instead holds at f  x            xn       done e g 
shanahan        want reason object level properties true false
environment  use within meta level axioms event calculus  see below  implement
persistence 

   

fikakas  mancarella  sadri  stathis   toni

initially trustworthy co  
namely  action agent c providing information concerning query q
agent svs  the san vincenzo station agent  initiates agent svs information
q  provided c trustworthy  moreover  initially agent co  the central office
agent  trustworthy  agent svs information arrival time tr   
conditions rule defining initiates seen preconditions effects
operator tell take place  preconditions executability operators specified
means set rules  facts  defining predicate precondition  e g 
precondition tell svs  c  inf orm q  i   d   inf o svs  q  i  
namely precondition agent svs inform agent c q svs indeed
information q 
notice presence language fluents negation  e g  f f  
poses problem inconsistencies  i e  may case holds at f  t 
holds at f  t  derived axioms set events  i e  given set
happens atoms   however  easily shown never case  provided
domain dependent part contain two conflicting statements form
initially f   initially f   since inconsistencies cannot caused except initial
time point  see e g  miller   shanahan        p       
remainder paper assume domain dependent part always
consistent agents 
allow agents draw conclusions contents kb    represents
narrative part agents knowledge  add domain independent rules
following bridge rules 
holds at f  t   
holds at f  t   
happens o   
happens o   

observed f  t     t  t    clipped t    f  t   
observed f  t     t  t    declipped t    f  t   
executed o   
observed    o t     

notice bridge rules make explicit translation state representation
ec representation fluents actions mentioned earlier section 
note assume fluent holds time observed hold 
choice dictated rationale observations considered reasoned
upon moment agent makes them  hand  actions agents
effect time executed    
introduced ability reason narratives events observations 
need face problem inconsistency due conflicting observations  e g  agent
may observe fluent negation hold time  done
   time action unknown observation time  last rule may replaced
happens o    observed    o      
namely value fluent changed according observations moment observations
made 

   

ficomputational logic foundations kgp agents

set initially atoms  assume external world consistent
too  i e  never happen observed f  t  observed f  t  belong kb   
fluent f time point t 
however  still need cope frame consistency problem  arises  e g 
given observations observed f  t  observed f  t        t    issue analogous
case two different events happen time point initiate
terminate fluent  original ec suitable axioms predicates clipped
declipped added  given above  avoid fluent negation holding
time happening two events time  adopt
similar solution cope observations  namely adding following two axioms
domain independent part 
clipped t    f  t   
declipped t    f  t   

observed f     t    t 
observed f     t    t 

solution may naive circumstances sophisticated solutions may
adopted  e g  one proposed bracciali kakas        
      temporal reasoning
temporal reasoning capability invoked components kgp model
 namely goal decision capability  state revision transition selection operators  see section    prove disprove given  possibly temporally
constrained  fluent literal holds  respect given theory kbt r   purposes
paper kbt r ec theory composed domain independent domaindependent parts given section        narrative part given kb    then 
given state s  fluent literal      possibly empty set    temporal constraints c 
temporal reasoning capability   t r defined
  t r      c iff kbt r   lp     holds at      c 
example  given ec formulation section       setting       section     
state   hkb    f  c  agent svs contains
kb     observed co  tell co  svs  inf orm arrival tr          d            
  t r inf o svs  arrival tr                
      planning
number abductive variants ec proposed literature deal
planning problems  e g  one proposed shanahan        here  propose novel
variant  somewhat inspired e language  kakas   miller         allow situated
agents generate partial plans dynamic environment 
refer kbplan   hpplan   aplan   iplan abductive logic program where 
    remainder paper sets seen conjunctions  appropriate 

   

fikakas  mancarella  sadri  stathis   toni

aplan    assume holds  assume happens   namely consider two abducible predicates  corresponding assuming fluent holds action occurs  respectively  certain time point 
pplan obtained adding core ec axioms narrative given kb 
following rules
happens o    assume happens o   
holds at f    assume holds f   
iplan contains following set integrity constraints
holds at f     holds at f    f alse
assume happens o     precondition o  p   holds at p   
assume happens o     executed o     time now t        
integrity constraints iplan prevent generation  partial  plans
unfeasible  first integrity constraint makes sure plan generated entails
fluent negation hold time  second integrity constraint makes
sure that  plan requires action occur certain time point  goal
enforcing preconditions action hold time point taken account
plan  means that  preconditions already known hold 
plan need accommodate actions guarantee hold time
execution action  finally  last integrity constraint forces assumed unexecuted
actions plan executable future  predicate time now    meant
return current time 
worth recalling that  concrete situations  pplan iplan contain domaindependent rules constraints  domain dependent rules may needed define
initiates  terminates  initially precondition  may contain additional
rules integrity constraints expressing ramifications  e g 
holds at f    holds at f            holds at fn    
specific fluents domain  moreover  integrity constraints may represent
specific properties actions fluents domain  example  domain dependent
constraint could express two actions type cannot executed time 
e g 
holds at tell c  x  accept request r   d     
holds at tell c  x  ref use request r   d     f alse
intuitively  constructing  partial  plan goal  that given leaf node
current forest  amounts identifying actions sub goals allowing achieve
goal  assuming nodes forest  executable non executable 
feasible  concretely  abductive logic program kbplan supports partial planning
follows  whenever plan given goal requires agent execute action  a    say 
corresponding atom assume happens a    assumed  amounts intending
execute action  at concrete time instantiating    hand 
plan given goal requires plan sub goal       say  corresponding atom
assume holds      may assumed  amounts setting requirement
planning needed sub goal itself  notice total plans taken
account  atoms form assume holds      ever generated 
   

ficomputational logic foundations kgp agents

kb
formally  let kbplan
plan  time now now    time constant  intuitively  time planning capability invoked   then  planning capability
    
  now
plan specified follows

let   hkb    f  c  state  g        mental goal labeling leaf node
tree f  let
ca    assume happens a        a      nodes f   
cg    assume holds                     nodes f           

    ca cg
c    c  
then 
s  g   now
plan  xs   c 
iff
xs    a        assume happens a                    assume holds           
    c   
   c  abductive answer holds at       wrt  kbplan
 
 
abductive answer exists  s  g   now
 



used


indicate
failure
plan
 i e  abductive answer exists  

example  consider setting       section      domain dependent part
kbplan agent psa  looking businessman scenario  contains
initiates buy ticket online f rom  o   t  ticket f rom  o  
precondition buy ticket online f rom  o   available connection 
precondition buy ticket online f rom  o   available destination t o  
goal g ticket madrid  denver     assume f consists single tree
consisting solely root g  thus ca   cg       then  s  g   now
plan  xs   c 
xs    buy ticket online madrid  denver      
available connection        available destination denver        
c                              now  
      reactivity
capability supports reasoning reacting stimuli external environment
well decisions taken planning 
knowledge base kbreact supporting reactivity adopt extension knowledge
base kbplan follows  kbreact   hpreact   areact   ireact
preact   pplan
    simplicity present case planning single goals only 

   

fikakas  mancarella  sadri  stathis   toni

areact   aplan
ireact   iplan rr
rr set reactive constraints  form
body reaction  c

reaction either assume holds         t   timed fluent literal 
assume happens a     a t   timed action literal    
body non empty conjunction items form  where   x  timed fluent
literal a x  timed action literal  x  
 i  observed        
 ii  observed c  a t           
 iii  executed a      
 iv  holds at        
 v  assume holds        
 vi  happens a      
 vii  assume happens a      
 viii  temporal constraints  some of  t        
contains least one item one  i    ii   iii  
c temporal constraints  some of  t          
integrity constraints abductive logic programming  variables body
implicitly universally quantified whole reactive constraint  variables
reaction  c occurring body implicitly existentially quantified righthand
side reactive constraint    
notice body must contain least trigger  i e  condition evaluated
kb    intuitively  reactive constraint body reaction  c interpreted
follows   some instantiation of  observations body hold kb   some
corresponding instantiation of  remaining conditions body hold   the appropriate instantiation of  reaction  associated  the appropriate instantiation of 
    below  abuse notation  use notions timed fluent action literals liberally
allow non ground  even though defined timed fluent action literals ground
except possibly time parameter 
    strictly speaking  syntactically reactive constraints integrity constraints  due presence
conjunction  represented    rather disjunction head   however  reactive constraint
body reaction  c transformed integrity constraint body n ew new clause
n ew reaction  c preact   thus  abuse notation  treat reactive constraints
integrity constraints 

   

ficomputational logic foundations kgp agents

temporal constraints c  added f c  respectively  notice reaction
abducible planning performed reactivity capability 
theory kb
formally  let kbreact
react  time now now    time
constant  intuitively  time capability invoked   then  reactivity capability   now
react specified follows  let   hkb    f  c  state  let

ca    assume happens a      a    nodesnr  f   
cg    assume holds             nodesnr  f  

    ca cg
c    c  
then 
  now
react  xs   c 
iff
xs    a      assume happens a              assume holds       
    c   
   c  abductive answer query true wrt  kbreact
 
 

abductive answer exists    react   used indicate failure
 i e  abductive answer exists  

example  consider setting       section      kbplan given sections      
       let rr agent svs consist of 
observed c  tell c  svs  request q   d         holds at have inf o svs  q  i    
assume happens tell svs  c  inf orm q  i   d           
observed c  tell c  svs  request q   d         holds at no inf o svs  q    
assume happens tell svs  c  ref use q   d           
then  given        hkb    f  c 
kb     observed co  tell co  svs  inf orm arrival tr          d            
observed psa  tell psa  svs  request arrival tr      d            
obtain
  now
react   tell svs  psa  inf orm arrival tr          d             
      identification preconditions
capability used kgp agents determine preconditions executability
actions planned for  preconditions defined domain dependent
part ec means set rules form precondition o  f    representing
fluent f precondition executability action action operator  see
        let kbpre subset kbt r containing rules defining precondition      
   

fikakas  mancarella  sadri  stathis   toni

identification preconditions capability   pre specified follows  given state
  hkb    f  c  timed action literal a   
s  a      pre cs
iff
cs  

v

        kbpre   lp precondition a         

      identification effects
capability used kgp agents determine effects actions already
executed  order check whether actions successful  note
actions may unsuccessful could executed  executed
expected effect  possible situations agent
full knowledge environment situated 
effects defined domain dependent part ec means set
rules defining predicates initiates terminates  let kbef f theory consisting
domain dependent domain independent parts ec  well narrative
part kb    then  identification effects   ef f specified follows  given state
  hkb    f  c  action operator a t  
s  a t    ef f  
iff
    f kbef f   lp initiates a  t  f  
    f kbef f   lp terminates a  t  f  
    constraint solving
constraint solving capability simply defined terms structure  
    notion presented section      namely  given state   hkb    f  c 
set constraints c 
  cs c iff     c c 
exists total valuation s    cs c iff exists total valuation
    c c 
    goal decision
goal decision reasoning capability allows agent decide  given time point 
 non reactive  top level goals pursued  go generate
plans aiming achieving them  generated goals goals current preferred
interest interest may change time 
    assume

v

     true 

   

ficomputational logic foundations kgp agents

goal decision capability operates according theory  kbgd   agent
represents goal preference policy  kbgd includes kbt r thus dynamic  observed
knowledge  kb    current state agent  kbgd expressed variant lpp
described section      whereby rules lower basic part p lpp theory
form  t possibly empty sequence variables  
n       g     b t    c t  

time variable  existentially quantified scope head rule
member  
variables except universally quantified scope rule 
head g     rule consists fluent literal conjoined  possibly
empty  set temporal constraints  represented h      c    i 
b t   non empty conjunction literals set auxiliary predicates
include atoms form holds at           t     timed fluent literal 
atom time now t      variables         
conditions rule constrained  possibly empty  temporal constraints
c t   
rule represents ground instances total valuation
variables satisfies constraints c t    ground instance named
corresponding ground instance n      intuitively  conditions one rule
satisfied time grounds variable    current time
capability applied  goal head rule sanctioned one goals
agent would possibly prefer achieve time  decision whether
goal indeed preferred would depend high level strategy part h kbgd  
containing priority rules  described section      rules lower part
rules h  priority rules include temporal atoms form
holds at        atom time now t      conditions 
accommodate form rules need extend notion incompatibility
defined conclusions h      c    i  simplify notation 
remainder often write h      ci instead h      c    i 
incompatibility defined different ways  example   relatively  weak
notion incompatibility given follows  two pairs h         c  h         c 
incompatible iff every valuation c  c  satisfied  ground
instances                 incompatible  stronger notion would require
sufficient one valuation exist makes corresponding ground
literals incompatible 
theory kb
let us denote kbgd
gd  time now now    time
constant  then  goal decision capability    now
gd   defined directly terms
preference entailment    pr   lpp  see section       follows 
given state   hkb    f  c  i 
  now
gd gs
   

fikakas  mancarella  sadri  stathis   toni


gs    g    g            gn    n    gi   h i  i    ci              n
iff gs maximal set

kbgd
  pr h         c        h n  n    cn i 

means new set goals gs generated currently  sceptically  preferred
goal preference policy represented kbgd current information kb   
note two goals gs necessarily compatible other  two
special cases sceptically preferred goals time now  first one
concerns case goals currently sanctioned  lower part 
kbgd     now
gd returns empty set goals  n       second special
case occurs least two goals separately credulously preferred
goals incompatible other    now
gd   used
indicate failure identifying new goals pursued 
example  consider san vincenzo scenario psa agent needs decide whether return home recharge battery  agents goals categorised
assigned priority according category possibly factors  kbgd
expressing given follows 
low level part contains rules 

n rh        hreturn home              i
holds at f inished work    
holds at at home    
time now t   
t       
n rb        hrecharge battery              i
holds at low battery    
time now t   
t       
auxiliary part contains  addition kbt r kb    following rules
specify category goal relative urgency categories 

typeof  return home  required 
typeof  recharge battery  operational 
urgent wrt type operational  required 

   

ficomputational logic foundations kgp agents

incompatibility part consists
incompatible return home t    recharge battery t   
namely  two goals pairwise incompatible  i e  agent one
goals time 
high level part contains following priority rule 

gd pref  x      n x    n y    typeof  x  xt   
typeof  y    
urgent wrt type xt    
then      current state   hkb    f  c  finished work
away home hold  by temporal reasoning  time now 
  now
gd  hreturn home             i  
suppose instead kb  contains observed low battery      then  using weak
notion incompatibility  requiring
every   cs               
holds incompatible return home      recharge battery     
have 
  now
gd  hreturn home             i  hrecharge battery             i  
indeed                    incompatible return home     recharge battery    
hold  however  using stronger notion incompatibility  requiring
exists   cs               
holds incompatible return home      recharge battery     
have 
  now
gd  hrecharge battery             i  
suppose kbgd contains second operational goal hreplace part             i
sanctioned rule lower part time      stronger
form incompatibility goal decision capability     return
operational goals credulously preferred none sceptically preferred 
   

fikakas  mancarella  sadri  stathis   toni

   physical capabilities
addition reasoning capabilities defined far  agent equipped
physical capabilities allow experience world situated  world
consists agents and or objects provide environment agents
interact communicate 
identify two types physical capabilities  sensing actuating  representing
capabilities abstract away sensors actuators agent would
typically rely upon access affect environment  assume
sensors actuators part agents body  classify implementation
issue  stathis et al         
physical sensing capability models way agent interacts external
environment order inspect it  e g  find whether fluent holds
given time  hand  physical actuating capability models way
agent interacts external environment order affect it  physically executing
actions 
represent sensing physical capability agent function form 
sensing l  t    l 
where 
l  possibly empty  set
fluent literals f  
terms form c    meaning agent c performed action a  
sensed concrete time t 
l   possibly empty  set elements s 
s  term f   v  f fluent v  true  f alse   meaning fluent f
observed value v  namely true f alse  time t 

s  term form c   a t     c agent name action 
meaning agent c performed action time t   
note physical sensing requires time stamp specify time
applied within transitions  note that  given non empty set l  sensing l  t  may
partial  e g  fluent f l  neither f   true l    f   f alse l   
similarly  represent physical actuating capability function
actuating as  t    as 
where 
set action literals  a         n      agent instructs body
actuate time t 
   

ficomputational logic foundations kgp agents

as  subset actions body actually managed perform 
meaning action belonging belonging as  physical
actuators agents body able perform current situation  worth
pointing action belongs as  necessarily mean effects
successfully reached  indeed  preconditions executed
action  i  may wrongly believed agent true execution time  as
agents may interfered them   ii  agent may unaware
preconditions  example  confirmed availability  agent may
booked hotel sending e mail   i  agent booked last available
room meanwhile   ii  agent provide credit card number secure
booking  words  beliefs agent  as held kb    may incorrect and or
incomplete 
section   section   below  see aoi  active observation introduction 
used check effects actions  identified fes effect selection operator 
turn using   ef f reasoning capability  actions executed  moreover  si
 sensing introduction  used check preconditions actions  identified fp
precondition selection operator  turn using   pre reasoning capability 
executed  make sure actions indeed executable  overall  following
cases may occur 
action belongs as  executed
preconditions held time execution effects hold environment execution 
preconditions wrongly believed hold time execution  because
agent partial knowledge environment kbplan incorrect 
consequence effects hold execution 
preconditions known hold time execution  e g 
agent observed planned hold 
time  replan  consequence effects hold execution 
action belongs   as  executed  the body could execute
it  
actuating physical capability check preconditions effects  left
capabilities called within transitions and or transition invoking
actuating  show below  before  way body carry actions
implementation issue  stathis et al         

   transitions
kgp model relies upon state transitions gi  pi  re  si  poi  aoi  ae  sr  defined
using following representation
 t 

hkb    f  c 
x

 
 
 
 
hkb    f   c  
   

fikakas  mancarella  sadri  stathis   toni

name transition  hkb    f  c  agents state transition applied  x input transition  time application
transition  hkb     f     c       revised state  resulting application transition input x time state hkb    f  c  i  please note transitions
modify components state  also  transitions  namely gi 
re  poi  sr  input x always empty omitted  transitions
 namely pi  si  aoi  ae  input always non empty  see section    selected
appropriate selection operator  see section    
define transition formally  defining hkb     f     c       i  note
assume transition takes care possible renaming time variables output
capabilities  if capability used transition   order guarantee
goal action forest univocally identified time variable 
    goal introduction
transition takes empty input  calls goal decision capability determine
new  non reactive  top level goals agent  capability returns set goals 
means circumstances possibly changed preferred top level goals
agent transition reflect changing forest new state
consist one tree new  non reactive  goal  hand  goal decision
capability return  non reactive  goals  namely returns   state left
unchanged  as  although goals current state longer sceptically preferred
may still credulously preferred and  since others replace them 
agent carry current plans achieve them 
 gi 

hkb    f  c 

hkb    f     c    

where  given   hkb    f  c 
 i    now
gd  
f    f
c    c
 ii  otherwise    now
gd gs gs     
f   defined follows 
nr f        tg      hg     gs  tg    tree consisting solely
root g   
r f         
c      t c   h   ci gs 
transition drops  top level  goals become semantically irrelevant  due
changed circumstances agent changes environment   replaces
new relevant goals  see  section      goals dropped
   

ficomputational logic foundations kgp agents

book keeping activities state revision  sr  transition  transition
never add set goals 
note that  gi replace whole forest old state new forest 
possible agent looses valuable information achieving goals 
one new preferred goals agent  or equivalent to  current goal 
effect though minimized calling  in cycle theory  gi transition
certain times  e g  current goals achieved timed out  alternatively 
earlier formalisation gi transition could modified that  case  ii  
goals gs already occur  modulo temporal variables associated temporal
constraints  roots  non reactive  trees f  trees kept f     simple way
characterise  some of  goals follows  let

xs    hg     c       

hg     ci gs 
g      rootsnr  f 
  cs c iff   cs  c c          

gs     hg     ci  

hg     c      xs 

new constraints goals gs  equivalent old constraints c  example 
gs may contain
g   hhave ticket madrid  denver               i
ticket madrid  denver      rootsnr  f  c            
then  g definitely belongs gs    let
newc  

 

c         

h  t c      ixs

case  ii  redefined follows  using definitions xs  gs  newc 
 ii    otherwise    now
gd gs gs      then  case   cs c newc 
f   c   defined earlier case  ii   otherwise  if   cs c newc  
f   defined follows 
nr f        tg      hg     gs   gs    f xs 
tg    tree consisting solely root g   
f xs  set trees f roots goals form g     
hg           xs
r f         
c     c  t c   h   ci gs   gs    newc 
note keep temporal constraints state  prior application gi 
force variables new goals remain state gi rewritten
using old identifiers goals 
   

fikakas  mancarella  sadri  stathis   toni

    reactivity
transition takes empty input  calls reactivity capability order determine
new top level reactive goals state  if any   leaving non reactive part unchanged 
new reactive goals exist  reactive part new state empty 
hkb    f  c 

hkb    f     c    

 re 
where  given   hkb    f  c  i 
 i    now
react  
f   defined follows 
r f         
nr f       nr f 
c    c

 ii  otherwise    now
react  x s  c  
f   defined follows 
nr f       nr f 
r f        tx      x    x s 
tx    tree consisting solely root x   
c    c c
note asymmetry case  ii  gi case  ii  re  gi
eliminates reactive goals case  whereas leaves non reactive goals unchanged 
indeed  reactive goals may due choice specific non reactive goals 
latter change former need re evaluated  instead  non reactive goals affected
newly acquired reactive goals  that outcome enforcing reactive rules  
note case  ii   similarly gi  replaces whole  reactive  forest
old state new  reactive  forest  possible agent loses valuable
information achieving reactive goals  one new reactive goals
 or equivalent to  current goal  variant case  ii  re  mirroring
variant given earlier gi using   cs well  defined avoid problem 
    plan introduction
transition takes input non executable goal state  that selected
goal selection operator  see section    produces new state calling agents
planning capability  selected goal mental goal  simply introducing new
sensing action  goal sensing goal 
 pi 

hkb    f  c 
g

 
 
hkb    f   c  

g input goal  selected planning tree f  thus leaf  see
section   
   

ficomputational logic foundations kgp agents

f      f    t   g leaf    n ew
c    c c
n ew c obtained follows  hkb    f  c  i 
 i  g mental goal  let s  g   now
plan p   then 
either p  
n ew    t   c      
p    x s  c 
n ew    t       obtained adding element x
child g 
 ii  g        sensing goal  child goal g   
n ew    t        a node labelled by  sense        new child g 
 here   new time variable 
c         
 iii  g        sensing goal  root  
n ew    t         tree consisting solely root  labelled by  sense       
 here   new time variable 
c         
    sensing introduction
transition takes input set fluent literals preconditions actions
state produces new state adding sensing actions leaves  appropriate 
trees forest component  note that  si invoked  input fluent literals
selected precondition selection operator  chosen amongst preconditions
actions already known true  see section    
 si 

hkb    f  c 
sp

 
 
hkb    f   c  

sp non empty set preconditions actions  in form pairs precondition 
action  trees f  where  given that 
  n ew    h      a  sense       i   h      ai sp   fresh variable 
  addsibling t   a  sa  denotes tree obtained adding elements sa new
siblings tree leaf  a   

f     f    t   leaf  a    h      ai sp s 
 addsibling t   a  sa    leaf  a   
sa    sense        h      a  sense        i n ew  
c     c         h        sense        i n ew 
   

fikakas  mancarella  sadri  stathis   toni

basically  fluent literal selected precondition selection operator
precondition action a  new sensing action added sibling a 
constraint expressing sensing action must performed added
current set temporal constraints 
    passive observation introduction
transition updates kb  adding new observed facts reflecting changes environment  observations deliberately made agent  rather 
forced upon agent environment  observations may properties
form positive negative fluents  for example battery running out  actions
performed agents  for example messages addressed agent  
hkb    f  c 

hkb     f  c 

 poi 
where  sensing   now    l 
kb     kb 

 observed f  now    f   true l 
 observed f  now    f   f alse l 
 observed c  a t   now    c   a t  l  
    active observation introduction
transition updates kb  adding new facts deliberately observed agent 
seeks establish whether given fluents hold given time  fluents
selected effect selection operator  see section    given input transition 
whereas poi decided agent  the agent interrupted forced
observation environment   aoi deliberate  moreover  poi may observe fluents
actions  whereas aoi considers fluents  that effects actions executed
agent  see section   section    
 aoi 

hkb    f  c 
sf

 
hkb    f  c 

sf    f            fn    n      set fluents selected actively sensed  by
effect selection operator   and  sensing sf s  now    l 
kb     kb 
 observed f  now    f   true l 
 observed f  now    f   f alse l  
    action execution
transition updates kb    recording execution actions agent  actions
executed selected action selection operator  see section    prior
transition  given input transition 
   

ficomputational logic foundations kgp agents

 ae 

hkb    f  c 
sas

hkb     f  c   

sas non empty set actions selected execution  by action selection
operator  
let subset non sensing actions sas subset sensing
actions sas 
let sensing s     now    l         f   sense f    s 
let sensing s      now    l           c     sense c   a    s 
let actuating a    now    a     a     a   a    a  
then 
kb     kb 
 executed a  now    a    
 observed f  now    f   true l   
 observed f  now    f   f alse l   
 observed c  a t   now    c   a t  l  
  cs c   sense c   a    s 

          a    sas a    
      sense f    sas  f     l   
      c   a t  l     cs c   sense c   a    s  
    state revision
sr transition revises state removing timed out goals actions goals
actions become obsolete one ancestors already believed
achieved  make use following terminology 
notation     given state s  timed fluent literal       timed fluent literal action
operator x     time point now 
achieved s        now  stands
exists total valuation s    cs   t r     
timed out s  x     now  stands
exists total valuation s    cs   now 
   

fikakas  mancarella  sadri  stathis   toni

then  specification transition follows 
 sr 

hkb    f  c 

hkb    f     c 

f   set trees f pruned nodes f     biggest subset
nodes f  consisting goals actions x    tree f  here  
hkb    f  c  i  
 i  timed out s  x     now  
 ii  x action operator  case executed x  t  kb      t   

 iii  x fluent literal  achieved s  x     now  
 iv  every y      siblings x     f 
either y      siblings x     f     
y        siblings x     f    
fluent literal achieved s  y       now  
action literal executed y  t  kb       

 v  x sensing action operator  x      sense      
either exists a      siblings x     f       precondition  i e 
s  a        pre cs        cs      c 
exists        siblings x     f       sensing fluent  
  c 
 vi  x    top level goal parent x     f    p p nodes f     
conditions specify sr keeps trees forest state  intuitively  conditions may understood terms prevent remaining
trees 
condition  i  removes timed out goals actions 
condition  ii  removes actions already executed 
condition  iii  removes goals already achieved 
condition  iv  removes goals actions whose siblings already timed
thus deleted  condition  i  
condition  v  removes sensing actions preconditions actions
deleted sensing goals deleted 
condition  vi  recursively removes actions goals whose ancestors removed 
following example illustrates sr used provide adjustment agents
goals plans light newly acquired information 
   

ficomputational logic foundations kgp agents

    setting  
agent psa goal museum ticket  state run  museum
businessman wants visit  plan buy ticket  executing plan psa
observes european heritage day  ehd short   via appropriate message
another agent mus  representing museum   stating state run museums
europe give free tickets anybody walking day  then  psas goal
already achieved goal plan deleted state 
let agents initial state hkb    f  c  with 
        kb 
f

   t  

c                         
consists top level goal g    have ticket       two children 
g    money     a    buy ticket      

  

assuming kbt r contains
initiates ehd  t  have ticket  
initiates buy o   t  have o  
precondition buy o   money  
remaining knowledge bases play useful role purposes
example  therefore considered empty  message museum
agent mus added kb  via poi  e g  time    following form 
observed mus  ehd       
i e  time   observed time   mus announced state run museums
europe free day  then  via sr  time   say  g    g  a  eliminated
f  g  already achieved 

   selection operators
kgp model relies upon selection operators 
fgs  goal selection  used provide input pi transition  
fp  precondition selection  used provide input si transition  
fes  effect selection  used provide input aoi transition  
fas  action selection  used provide input ae transition  
    g  a  reactive not  matter example 

   

fikakas  mancarella  sadri  stathis   toni

selection operators defined terms  some the  capabilities  namely temporal
reasoning  identification preconditions effects constraint solving  
high level description  selection operators seen returning set
items given initial set satisfy certain number conditions  example 
given state hkb    f  c  i  goal selection operator returns set non executable
goals trees f satisfy conditions  precondition selection operator returns
set pairs  consisting  i  timed fluent literal precondition
action tree f  ii  action  satisfying conditions  effect
selection operator returns set fluent literals effects actions already
executed  as recorded kb    satisfy conditions  action selection operator
returns set actions trees f satisfy conditions 
selection operators formally defined below 
    goal selection
informally  set conditions goal selection operator follows  given state
  hkb    f  c  time point t  set goals selected fgs singleton set
consisting non executable goal g tree f time t 
   g timed out 
   ancestor g timed out 
   child ancestor g timed out 
   neither g  ancestor g tree f already achieved 
   g leaf
intuitively  condition   ensures g already timed out  conditions     impose
g belongs still feasible plan top level goal f  condition   makes
sure considering g wasteful 
note that  already mentioned section        simplicity select single goal 
formally  given state   hkb    f  c  time point t  let g s  t  set
non executable goals      nodes f  that 
   timed out s        t 
   timed out s  g  t  g ancestors       f  
   timed out s  x  t  x nodes f  x child p
ancestors       f 
   achieved s  g  t  g        ancestors       f 
   leaf  g  f 
then  g s  t        
fgs  s  t     g  g g s  t  
otherwise  fgs  s  t       
   

ficomputational logic foundations kgp agents

    effect selection
informally  set conditions effect selection operator follows  given state
  hkb    f  c  time point t  fes selects fluents f f f one
effects action a    recently executed 
note f  or f   may occur f could  observable 
effect executed action  necessarily goal action
contributes achieving  example  order check whether internet connection
available  agent may want observe access skype network even though
really interested opening browser  as needs browser order perform
booking online  
formally  given state   hkb    f  c  time point now  set  timed 
fluents selected fes set  timed  fluents f     action
operator
   executed a  t    kb    t      t    now  sufficiently
small number  that left parameter here  
   s  a      ef f        f     f  
    action selection
informally  set conditions action selection operator follows  given state
  hkb    f  c  time point t  set actions selected fas defined
follows  let x  s  t  set actions trees f that 
   executed 
   ancestor timed out 
   child ancestor timed out 
   ancestor already satisfied 
   precondition known false 
   already executed 
fas  s  t  x  s  t  actions fas  s  t  executable concurrently
t 
intuitively  conditions     impose belongs still feasible plan toplevel goals f  note condition   definition x  s  t  logically redundant 
re imposed definition fas  s  t   however  condition serves first
filter thus useful practice 
formally  given state   hkb    f  c  i  time point t  set actions
selected fas defined follows  let x  s  t  set actions a    occurring
leaves trees f that 
   

fikakas  mancarella  sadri  stathis   toni

   exists total valuation s    cs   t 
   timed out s  g  t  g ancestors a     f  
   timed out s  x  t  x children g  f  g ancestors a     f  
   achieved s  g  t  g ancestors a     f  
   let s  a      pre cs cs                 n     
n                   n exists total valuation s    cs
    t r  i     
   exists t    t  executed a  t    kb   
formalisation condition   allows instances action
executed  then 
fas  s  t     a                 m    x  s  t 
 where     exists total valuation variables c
s    cs             t 
note definition action selection operator extended take
account notion urgency respect temporal constraints  however 
extension beyond scope work 
    precondition selection
informally  set conditions precondition selection operator follows  given
state   hkb    f  c  time point t  set preconditions  of actions
f  selected fp set pairs hc  ai  timed  preconditions c actions
nodes f  that 
   c precondition
   c known true t 
   one actions could selected execution fas would called
current time 
reason selection operator returns pairs  rather simply preconditions 
transition si  makes use outputs selection operator  needs
know actions associated preconditions  si introduces sensing
actions precondition returned place sensing actions siblings
associated actions f  seen section     
formally  given state   hkb    f  c  time point t  set preconditions
actions selected fp set pairs hc  ai  timed  preconditions c actions
nodes f  that 
     a     s  a      pre cs c conjunct cs 
   

ficomputational logic foundations kgp agents

   exists total valuation variables c s    cs  
  t r c 
   x  s  t   x  s  t  defined section     

   cycle theory
behaviour kgp agents results application transitions sequences 
repeatedly changing state agent  sequences fixed priori 
conventional agent architectures  determined dynamically reasoning
declarative cycle theories  giving form flexible control  cycle theories given
framework logic programming priorities  lpp  discussed section   
    formalisation cycle theories 
use following new notations 
 s  x      t  represent application transition time state given
input x resulting state    
 s  x  represent transition potentially chosen next transition
state s  input x 
recall that  transitions  x may empty set     indicated section   
formally  cycle theory tcycle consists following parts 
initial part tinitial   determines possible transitions agent could
perform starts operate  concretely  tinitial consists rules form
 s    x  c s    x 
refer via name r  t  s    x   rules sanction that  conditions
c hold initial state s  initial transition could   applied state
s  input x  example  rule
r  gi  s          gi s        empty f orest s   
sanctions initial transition gi  forest initial state s 
empty 
note c s    x  may empty  and  non empty  c s    x  may refer
current time via condition time now t   example  rule
r  p  s    g    p i s    g  gs   fgs  s    t   gs        g gs  time now t 
sanctions initial transition pi  forest initial state s 
contains goal planned current time  in goal
selection operator picks goal  
basic part tbasic determines possible transitions following given transitions 
consists rules form
   s     x      s  x      t   ec s     x    
   

fikakas  mancarella  sadri  stathis   toni

refer via name rt  t    s     x      rules sanction that  transition executed  starting time state resulting state    
conditions ec evaluated   satisfied  transition   could
next transition applied     input x       ec enabling conditions
determine   applied   determine input x      
via calls selection operators  initial part tcycle   ec may empty
and  not  may refer current time  example  rule
rae p  s     g    p i s     g  ae s  as      t  
gs   fgs  s     t     gs        g gs  time now t   
sanctions pi follow ae current time goal
current state selected goal selection function 
behaviour part tbehaviour contains rules describing dynamic priorities amongst
rules tbasic tinitial   rules tbehaviour form
rt  t    s  x     rt  t     s  x      bc s  x     x     
          refer via name ptt       recall rt  t     
rt  t        names of  rules tbasic tinitial   note that  abuse notation 
could   case one rule used specify priority first
transition take place  words  priority rules tinitial  
rules tbehaviour sanction that  transition   conditions bc hold 
prefer next transition        conditions bc behaviour
conditions give behavioural profile agent  example  rule

pgit
    rt  gi  s      rt  t    s  x  empty f orest s 

sanctions gi preferred transition transition
results state empty forest  components tcycle  
conditions bc may refer current time 
auxiliary part including definitions predicates occurring enabling
behaviour conditions 
incompatibility part  effect expressing one  instance a  transition
chosen one time 
hence  tcycle lpp theory where   i  p   tinitial tbasic    ii  h   tbehaviour  
    operational trace
cycle theory tcycle agent responsible behaviour  induces
operational trace agent  namely  typically infinite  sequence transitions
t   s    x    s    t             ti  si    xi   si   ti    ti    si   xi     si     ti           

    note order determine   possible transition   rule earlier form 
one needs know applied resulted state     conveyed
choice name  rt  t    s     x      words  using prolog notation  could represented
rule    s     x                  ec s     x      thus  rule markovian 

   

ficomputational logic foundations kgp agents

s  given initial state 
   ti given clock system  ti   ti i   
 tcycle tbasic    time now t       pr t   s    x    
 
 tcycle tinitial    ti  si    xi   si   ti    time now ti        pr ti    si   xi    
namely  non final  transition sequence followed preferred transition 
specified tcycle   if  stage  preferred transition determined   pr
unique  choose one arbitrarily 
    normal cycle theory
normal cycle theory concrete example cycle theory  specifying pattern
operation agent prefers follow sequence transitions allows achieve
goals way matches expected normal behaviour  examples possible
cycle theories found literature  kakas  mancarella  sadri  stathis    toni 
      sadri   toni        
basically  normal agent first introduces goals  if none start with  via gi 
reacts them  via re  repeats process planning them  via pi 
executing  part of  chosen plans  via ae  revising state  via sr  goals
dealt  successfully revised away   point agent returns introducing
new goals via gi repeating process  whenever process agent
interrupted via passive observation  via poi  chooses introduce new goals via
gi  take account changes environment  whenever actions
unreliable  sense preconditions definitely need checked 
agent senses  via si  executing action  whenever actions
unreliable  sense effects definitely need checked  agent actively
introduces actions aim sensing effects  via aoi  executed
original actions  initially agent equipped goals  would plan
straightaway pi 
full definition normal cycle theory given appendix  used
provide control examples next section  here  note that  although normal
cycle theory based classic observe plan act cycle agent control  generalises
several ways giving flexibility agent behaviour adapt changing
environment  example  goals agent need fixed dynamically
changed depending newly acquired information  let us illustrates feature
brief example here  suppose current state agent contains top level nonreactive goal hreturn home             i poi occurs adds observation
observed low battery     time    subsequent gi transition generated normal
cycle theory introduces new goal hrecharge battery             i which  depending
details kbgd   either replaces previous goal adds additional goal 
normal cycle theory next choose pi transition new urgent
goal recharging battery 
   

fikakas  mancarella  sadri  stathis   toni

    examples
section revisit examples introduced section     used throughout
paper illustrate various components kgp model  overall  aim
illustrate interplay transitions  interplay provides variety
behaviours afforded kgp model  including reaction observations  generation
execution conditional plans  dynamic adjustment goals plans 
unless specified differently  assume tcycle normal cycle theory
presented section      provide domain dependent definition auxiliary
part tcycle explicitly  required 
     setting   formalised
formalise initial state  knowledge bases behaviour svs setting  
described section       
       initial state
simplicity  observations  goals plan svs assumed empty
initially  concretely let  initial  state svs
kb       
f

    

c     
    

       knowledge bases
following section        formulate reactivity knowledge base agent svs terms
utterances query ref  ref use  inf orm inspired fipa specifications communicative acts  fipa      a      b   however  although use names
communicative acts fipa specification  adopt mentalistic
svs formulated
semantic interpretation terms pre  post conditions  thus  kbreact
as 
observed c  tell c  svs  query ref  q   d         holds at have inf o q  i    
assume happens tell svs  c  inf orm q  i   d           
observed c  tell c  svs  query ref  q   d         holds at no inf o q    
assume happens tell svs  c  ref use q   d           
assume happens tell svs  c  inf orm q  i   d     
assume happens tell svs  c  ref use q   d      
f alse
assume happens a     executable a  f alse
executable tell svs  c  s  d   c    svs
   

ficomputational logic foundations kgp agents

initially no inf o arrival tr    
precondition tell svs  c  inf orm q  i   d   inf o q  i  
initiates tell c  svs  inf orm q  i   d   t  inf o q  i  
terminates tell c  svs  inf orm q  i   d   t  inf o q  
       behaviour
illustrate behaviour psa assume agent requests svs 
time    say  arrival time tr    svs receives request psa time   arrival
time tr    via poi time   svs records kb   
observed psa  tell psa  svs  query ref  arrival tr      d        
dialogue identifier  then  via re  time    say  svs modifies state
adding f tree rooted action a  answer psa  action a  refusal
represented as 
a    tell svs  psa  ref use arrival tr      d    
temporal constraint     added c 
refusal action generated via reactivity capability svs
information requested arrival time  svs executes planned action a  time
    say  via ae transition  instantiating execution time  adding following record
kb   
executed tell svs  psa  ref use arrival tr      d       
updating adding      it 
suppose svs makes two observations follows  time    svs receives
information arrival time      tr   train co  via poi  svs records
kb      
observed co  tell co  svs  inf orm arrival tr          d             
assume time    svs receives another request psa arrival
time tr   and  via poi  svs records kb   
observed psa  tell psa  svs  query ref  arrival tr      d             
new dialogue identifier d     leads different answer svs query
psa  svs adds action state answer psa arrival time  done
via re  say time     new tree added f rooted  reactive  action
tell svs  psa  inf orm arrival tr          d         
new temporal constraint        added c 
via ae  svs executes action  instantiating execution time     say  adding
following record
    d  identifier dialogue within utterance performed  would typically
different earlier d 

   

fikakas  mancarella  sadri  stathis   toni

executed tell svs  psa  inf orm arrival tr          d         
kb    adding         
eventually  sr clear planned  and executed  actions f component
state svs 
     setting   formalised
formalise initial state  knowledge bases behaviour psa setting  
described section       
       initial state
let us assume initially state psa follows 
kb       
f

   t    t   

c                   
    
t  t  consist goals  respectively  
g    ticket madrid  denver     
g    visa usa      
       knowledge bases
psa
plan goal g    kbplan
contains 

initiates buy ticket online f rom  o   t  ticket f rom  o  
precondition buy ticket online f rom  o   available connection 
precondition buy ticket online f rom  o   available destination t o   
psa
plan goal g    kbplan
contains 

initiates apply visa usa   t  visa usa  
precondition apply visa usa   address usa  
initiates book hotel l   t  address usa   holds in l  usa     
       behaviour
pi called state  time    say  generates partial plan goal 
changing state follows  goal g  acquires three children t    are 
g     available connection      
g     available destination denver       
a     buy ticket online madrid  denver       
also  consequently  set temporal constraints updated to 
c                                                        
   

ficomputational logic foundations kgp agents

action a   generated action initiates goal g    moreover  every plan
generated must satisfy integrity constraints kbplan   particular  precondition
actions tree already hold must generated sub goals tree 
g   g   generated tree above 
via transition si  following sensing actions added t  siblings
action a       
a     sense available connection      
a     sense available destination denver       
constraints
                 
added c 
then  via ae  two sensing actions executed  before original action a    
kb  updated result sensing follows  suppose two actions
executed time    consider first action senses fluent available connection 
fluent confirmed physical sensing capability  i e  available connection   true
x
sensing  available connection  available destination        x 
observed available connection     added kb    hand 
available connection   f alse
x above  observed available connection     added kb    cases
       added  
neither cases occurs  i e  sensing capability cannot confirm either
available connection available connection  fact added kb    similarly
precondition  available destination  let us assume step ae 
kb  becomes
observed available connection    
observed available destination denver     
ae execute original action a     note agent might decide execute
action even one preconditions known satisfied sensing 
g  achieved  sr eliminate a     a     a     g     g   state 
resulting state  f    t     pi called  say time    results generating
partial plan g    changing state t  root g  children
a     apply visa usa      
g     address usa      
                 added c  then  pi  say time    introduces
a     book hotel denver      
    assume auxiliary part tcycle contains rule
unreliable pre as  buy ticket online       

   

fikakas  mancarella  sadri  stathis   toni

child g   t    adding         c  then  ae time   executes a     adding
kb    ae time   executes a     updating kb    finally  sr eliminates
actions goals t  returns empty f state 

    related work
many proposals exist models architectures individual agents based computational logic foundations  see e g  survey fisher  bordini  hirsch    torroni 
       proposals based logic programming  example impact  arisha  ozcan  ross  subrahmanian  eiter    kraus        subrahmanian  bonatti  dix 
eiter  kraus  ozcan    ross         aaa  balduccini   gelfond        baral   gelfond 
       dali  costantini   tocchio         minerva  leite  alferes    pereira        
golog  levesque  reiter  lesperance  lin    scherl         indigolog  de giacomo 
levesque    sardina         proposals based modal logic first order logic
approaches  example bdi model  bratman et al         rao   georgeff       
extensions deal normative reasoning  broersen  dastani  hulstijn  huang   
van der torre         agent   shoham         agentspeak  rao        variants 
 apl  hindriks  de boer  van der hoek    meyer        variants  dastani  hobo 
  meyer        
high level comparison similarities objectives existing
computational logic models agency kgp  aim specifying knowledgerich agents certain desirable behaviours  similarities finer
details kgp model related work  well differences 
feature kgp which  best knowledge  novel declarative
context sensitive specification agents cycle  avoid static cycle control
 rao   georgeff        rao         kgp relies upon cycle theory determines 
run time  given circumstances individual profile agent  next
step be  cycle theory sensitive solicited unsolicited information
agent receives environment  helps agent adapt behaviour
changes experiences  approach closest work  apl  hindriks
et al         extended dastani  de boer  dignum  meyer         provides
meta programming constructs specifying cycle agent goal selection 
plan expansion  execution  well if then else while loop statements  unlike
imperative constructs  apl  kgp uses set selection operators extended
model different behaviours types agents  flexible ordering transitions
obtained using preference reasoning transitions applied specific
point time  preferences may change according external events changes
knowledge agent 
another central distinguishing feature kgp model  comparison existing
models  including based logic programming  modular integration within
single framework abductive logic programming  temporal reasoning  constraint logic
programming  preference reasoning based logic programming priorities  order
support diverse collection capabilities  one specified declaratively
equipped provably correct computational counterpart  see bracciali 
   

ficomputational logic foundations kgp agents

demetriou  endriss  kakas  lu  mancarella  sadri  stathis  terreni    toni       
detailed discussion  
compared existing logic programming approaches kgp two main similarities
minerva  leite et al          architecture exploits computational logic
gives declarative operational semantics agents  unlike kgp  minerva
agent consists several specialised  possibly concurrent  sub agents performing various
tasks  relies upon mdlp  multidimensional dynamic logic programming   leite et al  
       mdlp basic knowledge representation mechanism agent minerva 
based extension answer set programming explicit rules updating
agents knowledge base  kgp instead integrate abductive logic programming
logic programming priorities combined temporal reasoning 
closely related work kgp logic based agent architecture reasoning
agents baral gelfond         architecture assumes state agents
environment described set fluents evolve time terms transitions
labelled actions  agent assumed capable correctly observing state
environment  performing actions  remembering history happened
it  agents knowledge base consists action description part specifying internal
agent transitions  domain specific generic kgp  knowledge
base contains agent observes environment including actions 
kgps kb    temporal aspects agent transitions specified action
language al implemented a prolog  language logic programs answerset programming semantics  answer sets domain specific programs specified al
correspond plans kgp hypothetical narratives abductive event calculus 
control agent based static observe think act cycle  instance kgp
cycle theories  recent refined account overall approach given rise
aaa architecture  see  balduccini   gelfond        overview 
dali  costantini   tocchio        logic programming language designed executable specification logical agents  kgp  dali attempts provide constructs
represent reactivity proactivity agent using extended logic programs  dali
agent contains reactive rules  events  actions aimed interacting external
environment  behaviour  in terms reactivity proactivity  dali agent triggered
different event types  external  internal  present  past events  events
actions time stamped record occur  external events
observations kgp  past events past observations  however  kgp
support internal events instead idea transitions called cycle
theory trigger reactive proactive behaviour 
indigolog  de giacomo et al         high level programming language robots
intelligent agents supports  kgp  on line planning  sensing plan execution
dynamic incompletely known environments  member golog family
languages  levesque et al         use situation calculus theory action perform
reasoning required executing program  instead kgp model rely
abductive logic programming logic programming priorities combined temporal reasoning  instead situation calculus kgp use event calculus
temporal reasoning  use event calculus prerequisite model
interrap  muller  fischer    pischel         replaced another temporal
   

fikakas  mancarella  sadri  stathis   toni

reasoning framework  needed  apart difference use situation event calculi  indigolog goals cannot decided dynamically  whereas
kgp model change dynamically according specifications goal decision
capability 
obvious similarity kgp model bdi model  bratman et al  
      given correspondence kgps knowledge  goals plan bdis
beliefs  desires intentions  respectively  apart fact bdi model
based modal logic  kgp knowledge  beliefs bdi  partitioned modules 
support various reasoning capabilities  kgp tries bridge gap
specification practical implementation agent  gap criticized
bdi rao         developed agentspeak l  language  computational
model agentspeak l  formally studied dinverno luck        
recent implementations agentspeak interpreter incorporated jason
platform  bordini   hubner         kgp implementation prosocs  bracciali
et al          jason implementation seeks narrow gap specification
executable bdi agent programs  jason extends bdi new features belief
revision  alechina  bordini  hubner  jago    logan        
particular line work bdi padgham lambrix         investigate
notion capability integrated bdi logic rao georgeff        
bdi agent reason capabilities  capability work
informally understood ability act rationally towards achieving particular goal 
sense abstract plan type believed achieve goal  formally 
bdi logic rao georgeff extended incorporate modality capabilities
constrains agent goals intentions compatible agent believes
capabilities  set compatibility axioms presented detailing semantic
conditions capture desired inter relationships among agents beliefs  capabilities 
goals  intentions  work summarises extensions bdi model
implemented adapting bdi interpreter include capabilities  arguing
benefits extension original bdi interpreter rao georgeff        
kgp capabilities equate reasoning capabilities agent allow agent
plan actions given state  react incoming observations  decide upon
goals adopt  however  kgp  use capabilities level agents
domain specific knowledge guide agent determining whether rational
adopt particular goal 
issue separation specification implementation exists
kgp model agent   shoham         later refinement placa  thomas 
       two differences kgp agent  placa explicit
links exist kgp model amongst goals  in structuring forest
agent state  richer theories kgp specify priorities amongst potential
goals restricted temporal orderings  explicit links exploited
revising goals state  via revision transition  light new information
passage time 
boid architecture  broersen et al         extends well known bdi model  rao
  georgeff        obligations  thus giving rise four main components representing
agent  beliefs  obligations  intentions desires  focus boid find ways
   

ficomputational logic foundations kgp agents

resolving conflicts amongst components  order define agent types 
including well known types agent theories realistic  selfish  social simple
minded agents  agent types differ give different priorities rules
four components  instance  simple minded agent gives higher priority
intentions  compared desires obligations  whereas social agent gives higher priority
obligations desires  use priorities propositional logic formulae specify
four components agent types 
existing kgp model already resolves conflicts boid tries address  example  conflict belief prior intention  means
intended action longer executed due changes environment 
kgp agent notice give higher priority belief prior
intention  allowing agent effect retract intended action and  time permitting 
replan goals  kgp model includes notion priority used goal
decision capability cycle theory controls behaviour agent 
kgp model extended deal normative concepts  extended model
known n kgp  sadri  stathis    toni         n kgp common boid
seeks extend kgp addition obligations  n kgp model
extends notion priorities incorporating amongst different types goals
actions  detailed comparison n kgp related work presented sadri  stathis 
toni        
features included approaches absent
kgp model  bdi and  so  impact system  arisha et al         subrahmanian
et al         allow agents knowledge bases representations knowledge
agents  systems allow agents degree introspection
ability reason agents beliefs reasoning  kgp model date
include features  impact allows incorporation legacy systems  possibly using diverse languages  richer knowledge base language including
deontic concepts probabilities  similarly   apl  system based combination
imperative logic programming languages  includes optimisation component
absent kgp  component  apl includes rules identify given
situation agent pursuing suboptimal plan  help agent find better way
achieving goals   apl includes additional functionalities learning  van
otterlo  wiering  dastani    meyer         model currently support 
 apl  dastani et al         extension  apl goals goal plan rules well
external internal events   apl customisable  via graphical interface  cycle
fixed customised 

    conclusions
presented computational logic foundations kgp model agency 
model allows specification heterogeneous agents interact other 
exhibit proactive reactive behaviour allowing function dynamic
environments adjusting goals plans changes happen environments  kgp incorporates highly modular agent architecture integrates collection
   

fikakas  mancarella  sadri  stathis   toni

reasoning sensing capabilities  synthesised within transitions  orchestrated cycle
theories take account dynamic context agent preferences 
formal specification kgp components within computational logic
major advantage facilitating formal analysis model direct verifiable
implementation  formal analysis started sadri toni        
give formal analysis kgp agents exploring effectiveness terms goal
achievement  reactive awareness  impact reasoning capabilities towards
progress goal achievement  implementation precursor model  described
kakas et al       b   already developed within prosocs platform
stathis et al         upon provably correct computational counterparts defined
component model given kakas et al       b   concrete choices
computational counterparts described bracciali et al          resulting
development framework allows deployment testing functionality earlier
variant kgp agents  deployment agents relies upon agent template designed
stathis et al          builds upon previous work head body metaphor
described steiner et al         haugeneder et al          mind body architecture introduced bell        recently used huang  eliens  de bra        
development platform applied number practical applications  and 
particular  ambient intelligence stathis toni         also  sadri       
provided guidelines specifying applications using kgp agents  future work includes implementing deploying revised kgp model given paper  envisage
pose limited conceptual challenges  able capitalise experience
implementing deploying precursor model 
sadri  stathis  toni        explored precursor kgp agent
model augmented normative features allowing agents reason
choose social personal goals  prohibitions obligations  would
interesting continue work finalised kgp model given paper 
sadri toni        developed number different profiles behaviour 
defined terms specific cycle theories  formally proved advantages given
circumstances  would interesting explore dimension further  characterise
different agent personalities provide guidance  formal properties 
type personality needed applications 
future work includes extending model incorporate  i  reasoning capabilities  including knowledge revision  e g  inductive logic programming  
sophisticated forms temporal reasoning  including identifying explanations unexpected
observations   ii  introspective reasoning reasoning beliefs agents 
 iii  experimentation model via implementation   iv  development
concurrent implementation 

acknowledgments
work supported eu fet global computing initiative  within socs
project  ist              wish thank colleagues socs useful discussions
development kgp  grateful chitta baral anonymous
referees helpful comments earlier version paper 
   

ficomputational logic foundations kgp agents

appendix a  normal cycle theory
give main parts normal tcycle   exclude others  example
definitions incompatible auxiliary part  including definitions predicates
empty f orest  unreliable pre etc  details see  kakas et al         
tinitial   consists following rules 
r  gi  s          gi s        empty f orest s   
r  ae  s    as    ae s    as  empty non executable goals s       fas  s    t  
       time now t 
r  p  s    g    p i s    g  gs   fgs  s    t   gs        g gs  time now t 
tbasic   consists following rules 
rules deciding might follow ae transition follows 
rae p  s     g    p i s     g  ae s  as      t   gs   fgs  s     t     gs       
g gs  time now t   
 
 
rae ae  s       ae s     as    ae s  as      t   as    fas  s     t    
as         time now t   
rae aoi  s     f s    aoi s     f s  ae s  as      t   f   fes  s     t    
f        time now t   
rae sr  s       sr s         ae s  as      t 
rae gi  s           gi s         ae s  as      t 
namely  ae could followed another ae  pi  aoi  sr 
gi  poi 
rules deciding might follow sr follows
rsr p  s     g    p i s     g  sr s          t   gs   fgs  s     t     gs        g gs 
time now t   
rsr gi  s           gi s         sr s          t   gs   fgs  s     t     gs      
time now t   
 
rsr ae  s   as    ae s     as  sr s          t     fgs  s     t           
time now t   
namely  sr followed pi gi ae  depending whether
goals plan state 
rules deciding might follow pi follows
rp i ae  s     as    ae s     as  p i s  g      t     fas  s     t           
time now t   
 
rp i si  s   p s    si s     p s  p i s  g      t   p   fp  s     t     p        time now t   
second rule allow possibility sensing preconditions action
execution 
rules deciding might follow gi follows
rgi re  s           re s         gi s          t 
rgi p  s     g    p i s     g  gi s          t   gs   fgs  s     t     gs        g gs 
time now t   
namely  gi followed pi  goals plan for 
rules deciding might follow follows
   

fikakas  mancarella  sadri  stathis   toni

rre p  s     g    p i s     g  re s          t   gs   fgs  s     t     gs        g gs 
time now t   
rre si  s     p s    si s     p s  re s          t   p   fp  s     t     p       
time now t   
rules deciding might follow si follows
rsi ae  s     as    ae s     as  si s  p s      t     fas  s     t           
time now t   
 
rsi sr  s         sr s         si s  p s      t 
rules deciding might follow aoi follows
raoi ae  s     as    ae s     as  aoi s  f s      t     fas  s     t           
time now t   
 
raoi sr  s         sr s         aoi s  f s      t 
raoi si  s     p s    si s     p s  aoi s  f s      t   p   fp  s     t     p       
time now t   
rules deciding might follow poi follows
rp oi gi  s           gi s         p oi s          t 
tbehaviour   consists following rules 
gi given higher priority trees state 

pgit
    rt  gi  s      rt  t    s  x  empty f orest s 
transitions t           gi  possibly    indicating
trees initial state agent  gi first transition  
gi given higher priority poi 
p oi   r
 
 
pgit
p oi gi  s       rp oi t  s       
transitions    gi 
gi  transition given higher priority 
gi
pret
  rgi re  s      rgi t  s  x 
transitions    re 
re  transition pi given higher priority 
ppre
  rre p  s  g  rre t  s  x 
transitions    p i 
pi  transition ae given higher priority  unless actions
actions selected execution whose preconditions unreliable need checking 
case si given higher priority 
pi
paet
  rp i ae  s  as  rp i t  s  x  unreliable pre as 
transitions    ae 
pi
  rp i si  s  p s  rp i ae  s  as  unreliable pre as 
psiae
si  transition ae given higher priority
si
  rsi ae  s  as  rsi t  s  x 
paet
transitions    ae 
ae  transition ae given higher priority
actions execute state  case either aoi sr given higher
priority  depending whether actions unreliable  sense
effects need checking  not 
   

ficomputational logic foundations kgp agents

ae
paet
  rae ae  s  as  rae t  s  x 
transitions    ae  note that  definition tbasic   transition ae applicable
still actions executed state 
ae
ae
paoit
  rae aoi  s  f s  rae t  s  x   bcaoi t
 s  f s  t   time now t 
ae
transitions    aoi  behaviour condition bcaoi t  s  f s  t  defined  in
auxiliary part  by 
ae
bcaoi t
 s  f s  t  empty executable goals s  t   unreliable ef f ect s  t 
similarly  have 
ae  s  t   time now t 
ae
  rae sr  s      rae t  s  x   bcsr t
psrt
transitions    sr where 
ae  s  t  empty executable goals s  t   unreliable ef f ect s  t 
bcsr t
here  assume auxiliary part tcycle specifies whether given set actions
contains unreliable action  sense expressed unreliable ef f ect  defines
predicate empty executable goals 

sr  transition pi higher priority 
ppsr
  rsr p  s  g  rsr t  s  x  
transitions    p i 
note that  definition tbasic   transition pi applicable still goals
plan state  actions goals left state  rule rgi t
would apply 
initial state pi given higher priority 
pp    r  p  s  g  r  t  s  x 
transitions    p i  note that  definition tinitial below  transition pi
applicable initially goals plan initial state 

   

fikakas  mancarella  sadri  stathis   toni

references
alechina  n   bordini  r  h   hubner  j  f   jago  m     logan  b          belief revision
agentspeak agents  nakashima  h   wellman  m  p   weiss  g     stone  p 
 eds     th international joint conference autonomous agents multiagent
systems  aamas        pp            hakodate  japan  acm 
arisha  k  a   ozcan  f   ross  r   subrahmanian  v  s   eiter  t     kraus  s         
impact  platform collaborating agents  ieee intelligent systems         
     
balduccini  m     gelfond  m          aaa architecture  overview  aaai
spring symposium architectures intelligent theory based agents  aita    
baral  c     gelfond  m          reasoning agents dynamic domains  logic based
artificial intelligence  pp          kluwer academic publishers  norwell  ma  usa 
bell  j          planning theory practical rationality  proceedings aaai  
fall symposium rational agency  pp      aaai press 
bordini  r  h     hubner  j  f          bdi agent programming agentspeak using jason
 tutorial paper   toni  f     torroni  p   eds    computational logic multiagent systems   th international workshop  clima vi  lecture notes computer
science  pp          springer 
bracciali  a     kakas  a          frame consistency  reasoning explanations 
proceedings   th international workshop non monotonic reasoning
 nmr       whistler bc  canada 
bracciali  a   demetriou  n   endriss  u   kakas  a  c   lu  w   mancarella  p   sadri  f  
stathis  k   terreni  g     toni  f          kgp model agency global
computing  computational model prototype implementation  priami  c    
quaglia  p   eds    global computing  pp          rovereto  italy  springer 
bracciali  a   endriss  u   demetriou  n   kakas  a  c   lu  w     stathis  k         
crafting mind prosocs agents  applied artificial intelligence               
    
bratman  m   israel  d     pollack  m          plans resource bounded practical reasoning  computational intelligence    
broersen  j   dastani  m   hulstijn  j   huang  z     van der torre  l          boid
architecture  conficts beliefs  obligations  intentions desires  proceedings fifth international conference autonomous agents  agents        pp 
     acm press  montreal  canada 
clark  k  l          negation failure  gallaire  h     minker  j   eds    logic
data bases  pp          plenum press 
costantini  s     tocchio  a          dali logic programming agent oriented language  alferes  j  j     leite  j  a   eds    proceedings  th european conference logics artificial intelligence   jelia        vol       lecture notes
computer science  pp          springer 
   

ficomputational logic foundations kgp agents

dastani  m   de boer  f   dignum  f     meyer  j  j          programming agent deliberation  approach illustrated using  apl language  autonomous agents
mult agent systems  aamas     pp         australia 
dastani  m   hobo  d     meyer  j  j          practical extensions agent programming
languages  proceedings sixth international joint conference autonomous
agents multiagent systems  aamas     acm press 
de bruijn  o     stathis  k          socio cognitive grids  net universal human
resource  kameas  a     streitz  n   eds    proceedings conference tales
disappearing computer  pp          santorini  cti press 
de giacomo  g   levesque  h  j     sardina  s          incremental execution guarded
theories  acm transactions computational logic                
dinverno  m     luck  m          engineering agentspeak l   formal computational
model  j  log  comput                 
fipa communicative act library specification      a   experimental specification
xc     h  foundation intelligent physical agents  http   www fipa org 
fipa query interaction protocol      b   experimental specification xc     f  foundation intelligent physical agents  http   www fipa org 
fisher  m   bordini  r   hirsch  b     torroni  p          computational logics agents 
road map current technologies future trends  computational intelligence 
             
haugeneder  h   steiner  d     mccabe  f          imagine  framework building
multi agent systems  deen  s  m   ed    proceedings      international
working conference cooperating knowledge based systems  ckbs      pp    
    dake centre  university keele  uk 
hindriks  k  v   de boer  f  s   van der hoek  w     meyer  j  c          agent programming  apl  autonomous agents multi agent systems               
huang  z   eliens  a     de bra  p          architecture web agents  proceedings
euromedia    scs 
jaffar  j     maher  m          constraint logic programming  survey  journal logic
programming                
kakas  a  c   kowalski  r  a     toni  f          role abduction logic programming  gabbay  d  m   hogger  c  j     robinson  j  a   eds    handbook logic
artificial intelligence logic programming  vol     pp          oxford university
press 
kakas  a  c   mancarella  p     dung  p  m          acceptability semantics logic
programs  proceedings eleventh international conference logic programming  pp          cambridge  ma  usa  mit press 
kakas  a  c     miller  r          simple declarative language describing narratives
actions  logic programming     
   

fikakas  mancarella  sadri  stathis   toni

kakas  a  c     moraitis  p          argumentation based decision making autonomous
agents  rosenschein  j  s   sandholm  t   wooldridge  m     yokoo  m   eds   
proceedings second international joint conference autonomous agents
multiagent systems  aamas        pp          melbourne  victoria  acm press 
kakas  a   mancarella  p   sadri  f   stathis  k     toni  f          declarative agent
control  leite  j     torroni  p   eds    clima v  computational logic multiagent systems  vol       lecture notes artificial intelligence  lnai   pp    
     springer verlag 
kakas  a  c   kowalski  r  a     toni  f          abductive logic programming  j  log 
comput                 
kakas  a  c   mancarella  p   sadri  f   stathis  k     toni  f       a   declarative agent
control  leite  j  a     torroni  p   eds    computational logic multi agent systems   th international workshop  clima v  vol       lecture notes computer
science  pp         springer 
kakas  a  c   mancarella  p   sadri  f   stathis  k     toni  f       b   kgp model
agency  de mantaras  r  l     saitta  l   eds    proceedings   th eureopean
conference artificial intelligence  ecai        pp        ios press 
kowalski  r  a     sergot  m          logic based calculus events  new generation
computing              
kowalski  r     toni  f          abstract argumentation  artificial intelligence law
journal  special issue logical models argumentation                   kluwer
academic publishers 
leite  j  a   alferes  j  j     pereira  l  m          min erva  dynamic logic programming agent architecture  intelligent agents viii   th international workshop 
atal       seattle  wa  usa  revised papers  vol       lecture notes artificial intelligence  pp         
levesque  h  j   reiter  r   lesperance  y   lin  f     scherl  r  b          golog 
logic programming language dynamic domains  journal logic programming 
               
mamdani  e  h   pitt  j     stathis  k          connected communities standpoint
multi agent systems  new generation computing                 
mancarella  p   sadri  f   terreni  g     toni  f          planning partially situated
agents  leite  j  a     torroni  p   eds    computational logic multi agent systems   th international workshop  clima v  vol       lecture notes computer
science  pp          springer 
miller  r     shanahan  m          alternative formulations event calculus 
kakas  a  c     sadri  f   eds    computational logic  logic programming
beyond   essays honour robert a  kowalski  vol       lecture notes
computer science  pp          springer 
muller  j   fischer  k     pischel  m          pragmatic bdi architecture  huhns 
m  n     singh  m  p   eds    readings agents  pp          morgan kaufmann
publishers 
   

ficomputational logic foundations kgp agents

padgham  l     lambrix  p          formalisations capabilities bdi agents  autonomous agents multi agent systems                 
prakken  h     sartor  g          system defeasible argumentation  defeasible
priorities  international conference formal applied practical reasoning 
springer lecture notes ai       pp         
prakken  h     sartor  g          argument based extended logic programming defeasible priorities  journal applied non classical logics              
rao  a  s          agentspeak l   bdi agents speak logical computable language 
van hoe  r   ed    agents breaking away   th european workshop modelling
autonomous agents multi agent world  maamaw    eindhoven  netherlands  january              proceedings  vol       lecture notes computer
science  pp        springer verlag 
rao  a  s     georgeff  m  p          modeling rational agents within bdi architecture 
fikes  r     sandewall  e   eds    proceedings knowledge representation
reasoning  kr r      pp          morgan kaufmann publishers 
rao  a  s     georgeff  m  p          modeling rational agents within bdi architecture 
huhns  m  n     singh  m  p   eds    readings agents  pp          morgan
kaufmann publishers  san francisco  ca  usa 
rao  a  s     georgeff  m  p          abstract architecture rational agents  nebel 
b   rich  c     r swartout  w   eds     rd international conference principles
knowledge representation reasoning  kr     pp          cambridge  ma 
usa  morgan kaufmann 
sadri  f          using kgp model agency design applications  tutorial paper  
toni  f     torroni  p   eds    computational logic multi agent systems   th
international workshop  clima vi  vol       lecture notes computer science 
pp          springer 
sadri  f   stathis  k     toni  f          normative kgp agents  computational   mathematical organization theory                   
sadri  f     toni  f          variety behaviours profiles logic based agents 
toni  f     torroni  p   eds    computational logic multi agent systems   th
international workshop  clima vi  vol       lecture notes computer science 
pp          springer 
sadri  f     toni  f          formal analysis kgp agents  fisher  m   van der hoek 
w   konev  b     lisitsa  a   eds    logics artificial intelligence    th european
conference  jelia       vol       lecture notes computer science  pp     
     springer 
shanahan  m          solving frame problem  mit press 
shanahan  m          prediction deduction explanation abduction  proceedings
  th international joint conference artificial intelligence  pp           
shoham  y          agent oriented programming  artificial intelligence               
   

fikakas  mancarella  sadri  stathis   toni

socs         societies computees  computational logic model description 
analysis verification global open societies heterogeneous computees 
http   lia deis unibo it research socs  
stathis  k   child  c   lu  w     lekeas  g  k          agents environments 
tech  rep  technical report ist      city     dn i a   socs consortium       
ist      city     dn i a  
stathis  k   kakas  a   lu  w   demetriou  n   endriss  u     bracciali  a         
prosocs  platform programming software agents computational logic 
muller  j     petta  p   eds    proceedings agent theory agent implementation  at ai   emcsr     session m   pp          vienna  austria 
stathis  k     toni  f          ambient intelligence using kgp agents  markopoulos  p  
eggen  b   aarts  e  h  l     crowley  j  l   eds    ambient intelligence  proceedings
second european symposium  eusai       vol       lecture notes computer
science  pp          springer 
steiner  d  e   haugeneder  h     mahling  d          collaboration knowledge bases
via knowledge based collaboration  deen  s  m   ed    ckbs    proceedings
international working conference cooperating knowledge based systems  pp 
        springer verlag 
subrahmanian  v  s   bonatti  p   dix  j   eiter  t   kraus  s   ozcan  f     ross  r         
heterogeneous agent systems  mit press aaai press  cambridge  ma  usa 
thomas  s  r          placa agent programming language  wooldridge  m  j    
jennings  n  r   eds    intelligent agents  pp          berlin  springer verlag 
van otterlo  m   wiering  m   dastani  m     meyer  j  j          characterization
sapient agents  hexmoor  h   ed    international conference integration
knowledge intensive multi agent systems  kimas      pp          boston  massachusetts  ieee 
wooldridge  m          introduction multiagent systems  john wiley   sons 
yip  a   forth  j   stathis  k     kakas  a  c          software anatomy kgp agent 
gleizes  m  p   kaminka  g  a   nowe  a   ossowski  s   tuyls  k     verbeeck  k 
 eds    eumas        proceedings third european workshop multi agent
systems  pp          koninklijke vlaamse academie van belie voor wetenschappen
en kunsten 

   


