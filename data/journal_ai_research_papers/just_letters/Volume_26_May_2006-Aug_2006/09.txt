journal of artificial intelligence research                  

submitted        published     

clause term resolution and learning in the evaluation of
quantified boolean formulas
enrico giunchiglia
massimo narizzano
armando tacchella

giunchiglia unige it
mox dist unige it
tac dist unige it

dist   universita di genova
viale causa           genova  italy

abstract
resolution is the rule of inference at the basis of most procedures for automated reasoning  in these procedures  the input formula is first translated into an equisatisfiable
formula in conjunctive normal form  cnf  and then represented as a set of clauses  deduction starts by inferring new clauses by resolution  and goes on until the empty clause is
generated or satisfiability of the set of clauses is proven  e g   because no new clauses can
be generated 
in this paper  we restrict our attention to the problem of evaluating quantified boolean
formulas  qbfs   in this setting  the above outlined deduction process is known to be
sound and complete if given a formula in cnf and if a form of resolution  called qresolution  is used  we introduce q resolution on terms  to be used for formulas in disjunctive normal form  we show that the computation performed by most of the available
procedures for qbfs based on the davis logemann loveland procedure  dll  for propositional satisfiability corresponds to a tree in which q resolution on terms and clauses
alternate  this poses the theoretical bases for the introduction of learning  corresponding
to recording q resolution formulas associated with the nodes of the tree  we discuss the
problems related to the introduction of learning in dll based procedures  and present
solutions extending state of the art proposals coming from the literature on propositional
satisfiability  finally  we show that our dll based solver extended with learning  performs
significantly better on benchmarks used in the      qbf solvers comparative evaluation 

   introduction
resolution  robinson        is the rule of inference at the basis of most procedures for
automated reasoning  see  e g   fermuller  leitsch  hustadt    tammet        bachmair  
ganzinger         in these procedures  the input formula is first translated into an equisatisfiable formula in conjunctive normal form  cnf  and then represented as a set of clauses 
deduction starts by inferring new clauses by resolution  and goes on until the empty clause is
generated or satisfiability of the set of clauses is proven  e g   because no new clauses can be
generated  here we restrict our attention to the problem of evaluating quantified boolean
formulas  qbfs   in this setting  the above outlined deduction process is known to be sound
and complete if given a formula in cnf and if a form of resolution  called q resolution 
is used  kleine buning  karpinski    flogel         however  most of the available decision
procedures for qbfs are based on and extend the davis logemann loveland procedure
 dll   davis  logemann    loveland        for propositional satisfiability  sat   in the
c
    
ai access foundation  all rights reserved 

figiunchiglia  narizzano   tacchella

propositional case  it is well known that the computation performed by dll corresponds
to a specific form of resolution called regular tree resolution  see  e g   urquhart        
in this paper we introduce q resolution on terms  to be used for formulas in disjunctive
normal form  we show that the computation performed by dll based decision procedures
for qbfs corresponds to a tree in which q resolution on terms and clauses alternate  such
correspondence poses the theoretical bases for the introduction of learning  corresponding
to recording q resolution formulas associated with the nodes of the tree  in particular 
recording q resolutions on clauses generalizes the popular nogood learning from constraint satisfaction and sat literatures  see  e g   dechter        bayardo  jr    schrag 
       each nogood corresponds to a set of assignments falsifying the input formula  and
it is useful for pruning assignments to the existential variables  recording q resolutions on
terms corresponds to good learning  each good corresponds to a set of assignments satisfying the input formula  and it is useful for pruning assignments to the universal variables 
we discuss the problems related to the introduction of learning in dll based procedures for
qbfs  and present solutions extending state of the art proposals coming from the literature
on sat  to show the effectiveness of learning for the qbfs evaluation problem  we have
implemented it in qube  a state of the art qbf solver  using qube  we have done some
experimental tests on several real world qbfs  corresponding to planning  rintanen       
castellini  giunchiglia    tacchella        and circuit verification  scholl   becker       
abdelwaheb   basin        problems  which are our two primary application domains of
interest  the results witness the effectiveness of learning 
the paper is structured as follows  we first review the basics of quantified boolean
logic  at the same time introducing some terminology and notation that will be used
throughout the paper  in section    we introduce clause and term resolution  and their
relation to dll based decision procedures for qbfs  then  in section    we introduce both
nogood and good learning  and then we show how they can be effectively integrated in dll
based decision procedures for qbfs  the implementation and the experimental results are
presented in section    the paper ends with the conclusions and some related work 
this paper builds on and extends in many ways our aaai paper  giunchiglia  narizzano    tacchella         with respect to that paper  here  i  we introduce clause and
term resolution   ii  we show the correspondence between clause term q resolution and the
computation tree searched by dll based decision procedures   iii  on the basis of such
correspondence  we extend the basic backtracking search procedure  first with backjumping
and then with learning  and we prove their soundness and completeness   iv  we discuss the
implementation in qube providing many more details  and  v  we present the results of a
much broader and detailed experimental analysis 
from here on  we simply write resolution for q resolution 

   quantified boolean logic
consider a set p of symbols  a variable is an element of p  a literal is a variable or the
negation of a variable  in the following  for any literal l 
  l  is the variable occurring in l  and
 l is the negation of l if l is a variable  and it is  l  otherwise 
   

ficlause term resolution and learning for quantified boolean formulas

for the sake of simplicity  we consider only formulas in negation normal form  nnf  
thus  for us  a propositional formula is a combination of literals using the k ary  k    
connectives   for conjunctions  and   for disjunctions   in the following  we use true and
false as abbreviations for the empty conjunction and the empty disjunction respectively 
a qbf is an expression of the form
   q  z  q  z        qn zn 

 n    

   

where
 every qi     i  n  is a quantifier  either existential  or universal  
 z            zn are distinct variables  and
  is a propositional formula in z            zn  
for example 
x  yx    x   y  x      y  x      x     x   y    y  x      

   

is a qbf 
in      q  z        qn zn is the prefix and  is the matrix  we also say that a literal l is
existential if  l  belongs to the prefix  and it is universal otherwise  finally  in      we
define
 the level of a variable zi   to be     the number of expressions qj zj qj   zj   in the
prefix with j  i and qj    qj    
 the level of a literal l  to be the level of  l  
for example  in     x  is existential and has level    y is universal and has level    x  is
existential and has level   
the value or semantics of a qbf  can be defined recursively as follows 
   if the prefix is empty  then  is evaluated according to the truth tables of propositional
logic 
   if  is x   is true if and only if x is true or x is true 
   if  is y   is true if and only if both y and y are true 
if  is     and l is a literal with  l    zi   l is the qbf
 whose matrix is obtained from  by substituting
 zi with true and z i with false if l   zi   and
 zi with false and z i with true if l   z i  
 whose prefix is q  z  q  z        qi  zi  qi   zi         qn zn  
it is easy to see that if  is a qbf without universal quantifiers  the problem of determining
the value of  reduces to the sat problem 
two qbfs are equivalent if they are either both true or both false 
   

figiunchiglia  narizzano   tacchella

   resolution and dll based decision procedures for qbfs
in this section we first introduce clause term resolution and dll based decision procedures
for qbfs  and then we show the correspondence between the two 
    clause and term resolution
according to our definition of qbf  the matrix can be any combination of conjunctions
and disjunctions of literals  however  using common clause form transformations based on
renaming first used by tseitin         it is possible to perform a linear time conversion
from an arbitrary qbf into an equivalent one with the matrix in conjunctive normal form
 cnf   these conversions are based on the fact that any qbf     is equivalent to
q  z  q  z        qn zn x  x      x   

 n    

where
  is a propositional formula but not a literal 
 x is a variable distinct from z    z            zn   and
  x   is the propositional formula obtained from  substituting one or more occurrences of  with x 
thus  if  is
  x   y    y  x    
then it follows that     is equivalent to
x  yx  x    x   y  x      y  x      x   x      x   y  x      y  x   x    

   

thanks to such conversions  we can restrict our attention to qbfs with the matrix
in cnf  and represent the matrix of each formula as a set of clauses to be interpreted
conjunctively  where a clause is a finite set of literals to be interpreted disjunctively  further 
we assume that each clause is non tautological and minimal  a clause is tautological if it
contains both a variable and its negation  a clause c is minimal if the literals in c with
minimum level are existential  the minimal form of a clause c is the clause obtained from
c by deleting the universal literals which cause c to be non minimal  for instance  in
     all the clauses are non tautological and minimal  our assumption that clauses are
non tautological and minimal is not a restriction  as the following theorem states 
theorem   let  be a qbf with the matrix in cnf  let   be the qbf obtained from 
by
   eliminating tautological clauses  and
   replacing each non tautological and non minimal clause with its minimal form 
 and   are equivalent 
   

ficlause term resolution and learning for quantified boolean formulas

proof  clearly  tautological clauses can be eliminated from  and the result is an equivalent
qbf  let c    l            ln   ln             lm   be a non tautological and non minimal clause in 
in which ln             lm are the universal literals in c   min c      n   m   further  without
loss of generality  we assume that the level of li is less than or equal to the level of li    
   i   m  then   has the form  p  m 
      q   l           ln          ln            lm  qm   zm         qp zp   l            ln   ln             lm           
standing for
      q   l           ln          ln            lm  qm   zm         qp zp   l          ln  ln           lm      
then  by applying standard rules for quantifiers   can be rewritten as
      q   l           ln          ln            lm    l          ln  ln           lm    qm   zm         qp zp   
equivalent to
      q   l           ln          ln             lm   l       ln ln        lm   lm  qm   zm         qp zp   
equivalent to
      q   l           ln          ln             l          ln  ln           lm      lm  qm   zm         qp zp   
equivalent to
      q   l           ln          ln            lm  qm   zm         qp zp   l          ln  ln           lm       
i e   the qbf obtained from  by deleting lm from the clause c  by iterating the above
reasoning process  all the literals in c   min c  can be eliminated from c  and hence the
thesis 

from here on  a qbf is in cnf if and only if the matrix is a conjunction of clauses 
and each clause is both minimal and non tautological  if we represent the matrix of a qbf
as a set of clauses 
 the empty clause    stands for false 
 the empty set of clauses    stands for true 
 the formula      is equivalent to false 
 the qbf     is written as
x  yx  x    x    y  x      y  x      x    x      x    y  x      y  x    x     

   

clause resolution  kleine buning et al         is similar to an ordinary resolution where
only existential literals can be matched  more precisely  clause resolution  on a literal l  is
the rule
c 
c 
   
min c 
where
   

figiunchiglia  narizzano   tacchella

 c  
 c  
 c  
 c  

 x    y  x   
 y  x   
 x    x   
 x    y  x   

input
input
input
input

formula
formula
formula
formula

 c  
 c  
 c  
 c  

 x   
 x    y 
 x   
  

from
from
from
from

 c   
 c   
 c   
 c   

 c  
 c  
 c  
 c  

table    a clause resolution deduction showing that     is false  the prefix is x  yx  x   

 l is an existential literal 
 c    c  are two clauses such that  l  l    c   c     and for no literal l     l   l    l    
 c   c    
 c is  c   c       l  l  
c  and c  are the antecedents  and min c  is the resolvent of the rule 
theorem     kleine buning et al          clause resolution is a sound and complete
proof system for deciding qbfs in cnf  a qbf in cnf is true if and only if the empty
clause is not derivable by clause resolution 
for instance  the fact that     is false follows from the deduction in table   
alternatively to the cnf conversion  we could have converted     into a qbf with the
matrix in disjunctive normal form  dnf   again in linear time  on the basis that any qbf
     is equivalent to
q  z  q  z        qn zn y  y      y   

 n     

assuming  is a propositional formula but not a literal  and that y is a variable distinct
from z    z            zn  
a simple recursive application of the above equivalence to     leads to the following
equivalent qbf 
x  yx  y  y  y  y  y  y    y   y   y   
 y    x      y    y    y    x   
 y    y    y    x   
 y    x      y    y   
 y    y   y   
 y    x      y    y 
 y    y    y    x     

   

given a qbf with the matrix in dnf  we can represent the matrix as a set of terms
to be interpreted disjunctively  where a term is a finite set of literals to be interpreted
conjunctively  further  we can assume that each term is non contradictory and minimal  a
term is contradictory if it contains both a variable and its negation  a term t is minimal
if the literals in t with minimum level are universal  the minimal form of a term t is the
term obtained from t by deleting the existential literals which cause t to be non minimal 
all the terms in     are non contradictory and minimal  analogously to what we have said
before for qbfs in cnf  if  is a qbf in dnf then we can assume that all the terms are
non contradictory and minimal without loss of generality 
   

ficlause term resolution and learning for quantified boolean formulas

theorem   let  be a qbf with the matrix in dnf  let   be the qbf obtained from 
by
   eliminating contradictory terms  and
   replacing each non contradictory and non minimal term with its minimal form 
 and   are equivalent 
proof  analogous to the proof of theorem   



as before  from here on  a qbf is in dnf if and only if the matrix is a disjunction of
terms  and each term is both minimal and non contradictory 
we can introduce term resolution  on a literal l  which consists of the rule
t 
t 
min t  
where
 l is an universal literal 
 t    t  are two terms such that  l  l    t   t     and for no literal l     l   l    l    
 t   t    
 t is  t   t       l  l  
t  and t  are the antecedents  and min t   is the resolvent of the rule 
theorem   term resolution is a sound and complete proof system for deciding qbfs in
dnf  a qbf in dnf is true if and only if the empty term is derivable by term resolution 
proof  the fact that term resolution is a sound and complete proof system follows from
the soundness and completeness of clause resolution 
let  be a set of sets of literals  and    q  z  q  z        qn zn  be a qbf in which  is
interpreted as a set of clauses  without loss of generality we can assume that each clause
in  is non tautological and minimal  then the following chain of equivalences holds 
there exists a deduction  of the empty clause from  using clause resolution
if and only if
 is false
if and only if
the qbf    q  z  q  z        qn zn  in which  is interpreted as a set of terms is true
if and only if
 is a deduction of the empty term from  using term resolution 
in the above chain of equivalences  q is  if q     and is  if q    



as an example of a term resolution deduction of the empty term  consider the qbf  
x  yx  x    x   y  x      y  x      x   x      x   y  x      y  x   x    
   

figiunchiglia  narizzano   tacchella

i e   the qbf obtained from     by simultaneously replacing  with    with    with  
and  with   then  the deduction in table   is also a deduction of the empty term from
 using term resolution 
if the qbf  is not in dnf but in cnf then term resolution cannot be applied  and
thus term resolution is not sufficient for proving the truth or falsity of   however  if we
also have the following model generation rule

min t  
where
  is the matrix of   and
 t is a non contradictory term such that for each clause c    c  t     
we get a sound and complete proof system for qbfs in cnf  intuitively  the model generation rule allows us to start from the minimal form of terms which propositionally entail
the matrix of the input formula 
theorem   term resolution and model generation is a sound and complete proof system
for deciding qbfs in cnf  a qbf in cnf is true if and only if the empty term is derivable
by term resolution and model generation 
proof  given a qbf  in cnf with matrix   by the model generation rule we can derive
a set  of terms of the form min t   such that
 each term t is a non contradictory and such that for each clause c    c  t     
and
 the disjunction of all the terms in  is propositionally logically equivalent to  
let   be the qbf in dnf obtained by substituting  with  in    and   have the
same value  hence the thesis thanks to theorem   


    dll based decision procedures for qbfs
given what we have said so far  an arbitrary qbf  can be converted  in linear time  into
an equivalent qbf in cnf  because of this  from here to the end of the paper  we restrict
our attention to qbfs in such format  with this assumption  if  is     and l is a literal
with  l    zi   we redefine l to be the qbf
 whose matrix is obtained from  by removing the clauses c with l  c  and by
removing l from the other clauses  and
 whose prefix is q  z  q  z        qi  zi  qi   zi         qn zn  
   

ficlause term resolution and learning for quantified boolean formulas

further  we extend the notation to sequence of literals  if    l    l            lm  m       is
defined as          l   l          lm  
consider a qbf  
a simple procedure for determining the value of  starts with the empty assignment 
and recursively extends the current assignment  with z and or z  where z is a heuristically
chosen variable at the highest level in    until either the empty clause or the empty set of
clauses are produced in    on the basis of the values of  z and  z   the value of  can
be determined according to the semantics of qbfs  the value of  is the value of   
cadoli  giovanardi  giovanardi and schaerf        introduced various improvements to
this basic procedure 
the first improvement is that we can directly conclude about the value of  if the
matrix of  contains a contradictory clause  lemma     in cadoli et al          a clause
c is contradictory if it contains no existential literal  an example of a contradictory clause
is the empty clause 
the second improvement allows us to directly extend  with l if l is unit or monotone
in   lemmas               in cadoli et al          in      a literal l is 
 unit if l is existential and for some m    
 a clause  l  l            lm   belongs to   and
 each literal li     i  m  is universal and has a level lower than the level of l 
 monotone or pure if
 either l is existential  l does not belong to any clause in   and l occurs in  
 or l is universal  l does not belong to any clause in   and l occurs in  
for example  in a qbf of the form
      x  yx          x    y    x            
both x  and x  are unit  in the qbf
y  x  y  x    y     y    x      x    y     x     
the only monotone literals are y  and x   
with such improvements  the resulting procedure  called q dll  is essentially the one
presented in the work of cadoli  giovanardi  and schaerf         which extends dll in
order to deal with qbfs  figure   is a simple  recursive presentation of it  in the figure 
given a qbf  
   false is returned if a contradictory clause is in the matrix of   line     otherwise
   true is returned if the matrix of  is empty  line     otherwise
   at line     is recursively extended to   l if l is unit  and we say that l has been
assigned as unit   otherwise
   

figiunchiglia  narizzano   tacchella

  function q dll    
 
if  ha contradictory clause is in the matrix of  i  return false 
 
if  hthe matrix of  is emptyi  return true 
 
if  hl is unit in  i  return q dll     l  
 
if  hl is monotone in  i  return q dll     l  
 
l    ha literal at the highest level in  i 
 
if  hl is existentiali  return q dll     l  or q dll     l  
 
else return q dll     l  and q dll     l  
figure    the algorithm of q dll 
   at line     is recursively extended to   l if l is monotone  and we say that l has been
assigned as monotone   otherwise
   a literal l at the highest level is chosen and
 if l is existential  line      is extended to   l first  and we say that l has been
assigned as left split   if the result is false    l is tried and returned  and in
this case we say that l has been assigned as right split  
 otherwise  line     l is universal   is extended to   l first  and we say that l
has been assigned as left split   if the result is true    l is tried and returned
 and in this case we say that l has been assigned as right split  
theorem   q dll     returns true if  is true  and false otherwise 
proof  trivial consequence of lemmas                    in the work of cadoli  giovanardi 
giovanardi  and schaerf        and of the semantics of qbfs 

given what we have said so far  it is clear that q dll evaluates  by generating a
semantic tree  robinson        in which each node corresponds to an invocation of q dll
and thus to an assignment   for us 
 an assignment  for a qbf   is a possibly empty sequence    l    l            lm  m    
of literals such that for each li in   li is unit  or monotone  or at the highest level in
l   l       li   
 the  semantic  tree representing a run of q dll on  is the tree
 having a node  for each call to q dll      and
 an edge connecting any two nodes  and   l  where l is a literal 
any tree representing a run of q dll has at least the node  
as an example of a run of q dll  consider the qbf      for simplicity  assume that
the literal returned at line   in figure   is the negation of the first variable in the prefix
which occurs in the matrix of the qbf under consideration  then  the tree searched by
q dll when  is     can be represented as in figure    in the figure 
   

ficlause term resolution and learning for quantified boolean formulas

    x    y  x      x    y  x      y  x      y  x    x      x    x      
 x    hx    li  x   
  y  x      y  x      y  x    x      x    x    

 x    hx    ri  x   
  y  x      y  x      y  x    x      x    x    

hy  ri  x   
hy  li  y 
hy  li  y 
hy  ri  x   
hx    pi y   x    y  x   hx    ui x   
hx    pi y   x    y  x   hx    ui x   
      y  x   
 y      y 
 y  x   hx    ui y  x     y      y 
      x    x   

figure    the tree generated by q dll for      the matrix of     is shown at the root
node  and the prefix is x  yx  x    u  p  l  r stand for unit  pure  left
split  right split respectively  and have the obvious meaning 

 each node is labeled with the literal assigned by q dll in order to extend the assignment built so far  thus  the assignment corresponding to a node is the sequence
of labels in the path from the root to the node  for instance  the assignment corresponding to the node with label x  is x    y  x   
 when literals are assigned as unit or monotone  the corresponding nodes are aligned
one below the other  further for each assigned literal l  we also show whether l
has been assigned as unit  monotone  left or right split by marking it as u  p  l  r
respectively 
 when l has been assigned as a left or right split  we also show the matrix of  l  
where  is the sequence of literals assigned before l 
 when the node  is a leaf  then the matrix of  is either empty  in which case we
write    below the node   or it contains a contradictory clause  in which case we
write      below the node  
considering figure    it is easy to see that q dll would correctly return false  meaning that      and thus also      is false 
    resolution and dll based decision procedures for qbfs
the well known correspondence in sat between semantic trees and resolution  see  e g  
urquhart        gives us the starting point for our analysis  aimed to establish a correspondence between q dll and clause term resolution 
consider a qbf   let  be the tree explored by q dll for evaluating  
for the time being  assume that we are dealing with a sat problem  i e    does not
contain universal quantifiers  then  q dll reduces to dll  and if  is false then we can
use  to generate a clause resolution deduction of the empty clause from   the basic idea
is to associate with each node  of  a clause c which is  falsified  i e   such that for each
   

figiunchiglia  narizzano   tacchella

literal l  c  l is in    we say that a literal l is in or has been assigned by l            lm if and
only if l   l            lm     more precisely 
 with every leaf  of   we associate an arbitrarily selected clause in the matrix of
 which is  falsified  at least one such clause exists because  contains the empty
clause 
 if c is the clause associated with a node   l  then
   if l   c then c is also the clause associated with   notice that if l is monotone
in  then l   c 
   if l  c and l is unit in  then the clause associated with  is the resolvent of
c and an arbitrarily selected clause of  which causes l to be unit in   
   if l  c and l is not unit in  then we have to consider the clause c   associated
with the node   l  if l   c   then c   is the clause associated with   as in the
first case   if l  c     the clause associated with  is the resolvent of c and c    
lemma   let  be a qbf without universal quantifiers  let  be the tree searched by
q dll      let  be an assignment for   if  is false  then the clause associated with
the node  of 
 is  falsified  and
 does not contain existential literals whose negation has been assigned as monotone
in  
proof  let s be the set of assignments in  which extend   clearly  for each assignment
   s    is false   does not contain universal quantifiers   on s  we define the partial
order relation  according to which two assignments   and    in s are such that      
if and only if   extends      clearly  is well founded and the minimal elements are the
assignments extending  and corresponding to the leaves of  
if   extends  and is a leaf of   then   contains a contradictory clause c  since
 does not contain universal quantifiers  c is    falsified and is associated with the node
    clearly  c does not contain existential literals whose negation has been assigned as
monotone 
by induction hypothesis  for each assignment          l     in s we have a    falsified
clause not containing existential literals whose negation has been assigned as monotone 
we have to show the thesis for      there are three cases 
   l has been assigned as unit  let c  be the clause associated with      l  by induction
hypothesis  the thesis holds for c    if c  does not contain l  the thesis trivially follows 
otherwise  the clause associated with    is the resolvent c of c  with a clause c 
that causes l to be unit in      c  is      l falsified and it does not contain existential
literals whose negation has been assigned as monotone  c   c   c     l  l  and thus
the thesis trivially holds 
   l has been assigned as monotone  in this case the clause c associated with    is the
same clause associated with      l  by induction hypothesis c does not contain l and
thus c is     falsified 
   

ficlause term resolution and learning for quantified boolean formulas

   l is a split  in this case we have a clause c  associated with      l and a clause c 
associated with      l  the thesis holds for both c  and c  by induction hypothesis 
if c  does not contain l  then the clause associated with    is c  and the thesis
trivially holds  otherwise  if c  does not contain l  then the clause associated with
   is c  and again the thesis trivially holds  otherwise  the clause associated with   
is c   c     l  l  and again the thesis trivially holds 

theorem   let  be a false qbf without universal quantifiers  the tree searched by qdll     corresponds to a clause resolution deduction of the empty clause 
proof  let  be a sequence of clauses obtained by listing the clauses in the matrix of 
according to an arbitrary order  followed by the clauses associated with the internal nodes
of the tree  searched by q dll      assuming  is visited in post order  clearly   is
a deduction   is a deduction of the empty clause because the node  has an associated
 falsified clause  lemma     i e   the empty clause 

the theorem points out the close correspondence between the computation of q dll
and clause resolution  assuming the input formula is false and that it does not contain
universal quantifiers  if the input formula does not contain universal quantifiers but is true 
still the tree explored by q dll before generating the path ending with the empty matrix
corresponds to a sequence of clause resolutions  one for each maximal subtree whose leaves
 are such that  contains an empty clause 
if we no longer assume that the input formula  does not contain universal quantifiers 
and consider the case in which  is an arbitrary qbf  the situation gets more complicated 
also because of the possibility of assigning unit literals which are not at the highest level 
so  we now assume that if a literal l is assigned as unit at a node   then l is at the highest
level in   
then  if the input formula  is false  we can again use the tree  searched by q dll to
generate a clause resolution deduction of the empty clause  the construction is analogous
to the one described before  the only difference is that we have to restrict our attention
to the minimal false subtree of   i e   the tree obtained from  by deleting the subtrees
starting with a left split on a universal literal  these subtrees are originated from wrong
choices when deciding which branch to explore first  in the minimal false subtree   of  
all the leaves terminate with the empty clause  and we can associate with each node of   a
clause exactly in the same way described above for the sat case  for instance  if  is     
then q dll assigns unit literals only when they are at the highest level  figure   shows
the minimal false subtree of q dlls computation  and the associated clause resolution
deduction of the empty clause  in the figure 
 the clause associated with each node is written in red and to the right of the node
itself 
 when a node corresponds to the assignment of a unit literal l  a clause of  which
causes l to be unit at that node  used in the corresponding clause resolution  is written
in red and to the left of the node 
   

figiunchiglia  narizzano   tacchella

    x    y  x      x    y  x      y  x      y  x    x      x    x      
 x    hx    li  x   
  y  x      y  x      y  x    x      x    x    

 x    hx    ri  x   
  y  x      y  x      y  x    x      x    x    

hy  ri  x   
 x    y  x   hx    ui x   
 y  x   hx    ui y  x   
      x    x   

hy  ri  x   
 x    y  x   hx    ui x   
      y  x   

figure    the clause resolution corresponding to the tree generated by q dll for      the
prefix is x  yx  x   

lemma   let  be a false qbf  let  be the minimal false subtree of the tree searched by
q dll     and assume that for each node   l in   if l is unit in  then l is also at the
highest level in    let  be an assignment for   if  is false  then the clause associated
with the node  of 
 is  falsified  and
 does not contain existential literals whose negation has been assigned as monotone
in  
proof  trivial extension of the proof of lemma    the assumption that for each node   l
in   if l is unit in  then l is at the highest level in    ensures that each clause associated
with a node  of  is  falsified 


theorem   let  be a false qbf  let  be the minimal false subtree of the tree searched
by q dll     and assume that for each node   l in   if l is unit in  then l is also at
the highest level in    then  corresponds to a clause resolution deduction of the empty
clause 
proof  given lemma    the proof is analogous to the one of theorem   



regardless of whether the input formula is true or false  the tree explored by q dll
may contain  exponentially many  subtrees whose nodes  are such that  is false  the
procedure described above  allows us to associate a clause resolution deduction with each
of such subtrees 
if the input formula  is true  the situation is simpler because so far we do not have unit
universal literals  and we can use the tree  searched by q dll to generate a deduction
of the empty term from   intuitively  the process is analogous to the one described when
 is false  except that the leaves of our term resolution deduction are terms corresponding
to the assignments computed by q dll and entailing the matrix of   in details 
   

ficlause term resolution and learning for quantified boolean formulas

 first  we have to restrict our attention to the minimal true subtree of   i e   the tree
obtained from  by deleting the subtrees starting with a left split on an existential
literal  analogously to the the case in which  is false  each leaf in a minimal true
subtree of  terminates with the empty matrix 
 second  we associate with each node  a term  represented as a set  as follows 
 the term associated with each leaf is a minimal term min t   in which t  
   does not contain universal literals assigned as monotone 
   has to propositionally entail the matrix  i e   for each clause c in the matrix
of   t  c      and
   has to be a subset of the literals in   i e   t   l   l is in   
 if t is the term associated with a node   l  then
   if l   t then t is the term associated with the node   notice that if l is
either existential or both universal and monotone in    then l   t  
   if l  t then we have to consider also the term t   associated with the node
  l  if l   t   then t   is the term associated with   as in the first case   if
l  t     the term associated with  is the resolvent of t and t    
it is easy to see that the term t associated with a node  is  entailed  each literal in t
is also in  
lemma   let  be a true qbf  let  be the minimal true subtree of the tree searched by
q dll      let  be an assignment for   if  is true  then the term associated with
the node  of 
 is  entailed  and
 does not contain universal literals assigned as monotone 
proof  analogous to the proof of lemma   



theorem   let  be a true qbf  let  the minimal true subtree of the tree searched by
q dll      then  corresponds to a model generation and term resolution deduction of
the empty term 
proof  let  be the sequence of terms obtained by listing the terms associated with the
nodes of  visited in post order  clearly   is a model generation and term resolution deduction   is a deduction of the empty term because the node  has an associated  entailed
term  lemma     i e   the empty term 

as before  regardless of whether the input formula is true or false  the tree explored
by q dll may contain  exponentially many  subtrees whose nodes are associated with
   for the sake of efficiency  it is also important that the term t satisfies other properties  however  they
are not necessary for the time being  and will be discussed in the next section 

   

figiunchiglia  narizzano   tacchella

    x    y  x      x    y  x      y  x      y  x    x      x    x      
 x    hx    ri  x   
 x    hx    li  x   
  y  x      y  x      y  x    x      x    x       y  x      y  x      y  x    x      x    x    
hy  li  y 
hx    pi y 
 y  x        y 

hy  li  y 
hx    pi y 
 y  x        y 

figure    the term resolutions corresponding to the tree generated by q dll for      the
prefix is x  yx  x   

    x    y  x      x    y  x      y  x      y  x    x      x    x      
 x    hx    li  x   
  y  x      y  x      y  x    x      x    x    

 x    hx    ri  x   
  y  x      y  x      y  x    x      x    x    

hy  li  y 
hy  li  y 
hy  ri  x   
hy  ri  x   
hx    pi y   x    y  x   hx    ui x   
hx    pi y   x    y  x   hx    ui x   
 y  x        y 
      y  x   
 y  x   hx    ui y  x     y  x        y 
      x    x   

figure    the resolution corresponding to the tree generated by q dll for      the prefix
is x  yx  x   

assignments  with  being true  the above described procedure allows us to associate
a term resolution deduction with each of such subtrees  for instance  if  is     there are
two maximal such subtrees  having roots x    y and x    y  the associated deductions are
represented in figure    in the figure 
 we represent also the nodes along the path from the root to the subtrees 
 the term associated with each node is written in green and to the right of the node
itself 
 if  is a leaf  a non contradictory term t entailing the matrix and whose minimal
form min t   is associated with   is written in green and to the left of  
merging the trees in figures   and   we obtain the whole tree of deductions corresponding to the search tree explored by q dll  represented in figure    in which clause and
term resolutions are intermixed 
   

ficlause term resolution and learning for quantified boolean formulas

now we consider the case in which the input qbf  is false and we no longer assume
that literals are assigned as unit only if they are at the highest level  we restrict our
attention to the minimal false subtree  of the tree searched by q dll      then  the
procedure described above for associating a clause with each node of  may no longer work 
for one thing  given a leaf   there may be no  falsified clauses in the matrix of the input
formula  however  we are guaranteed about the existence of a  contradicted clause in the
matrix of the input formula  a clause c is  contradicted if 
 for each literal l in c  l is not in   and
 for each existential literal l in c  l is in  
as long as we can associate with each node  of  a  contradicted clause  either belonging
to the matrix of  or obtained by clause resolution   corresponds to a clause resolution
deduction of the empty clause  indeed the clause associated with the root of  has to be
empty  remember that the resolvent of a clause resolution is in minimal form   thus  the
obvious solution is to try to associate
   with each leaf  a  contradicted clause in the input formula  and
   with each internal node  a  contradicted clause obtained by resolving input clauses
and or previously deduced clauses along the same lines outlined before 
in some cases the process runs smoothly  consider for instance  a qbf of the form 
x  x  yx    x    x      x    x      x    y  x            

   

then  if we assume that a split on x  occurs first  the following path will be explored  we
are using the same conventions of figure    
hx    li
hx    ui
hx    ui
    

   

and the clause associated with each node are 
hx    li
 x    x    hx    ui
 x    x    hx    ui
    

 x   
 x   
 y  x   
 x    y  x   

where we see that 
   the clause associated with the leaf    x    x    x  is not  falsified but is  contradicted 
and
   with respect to the definition of contradictory clause given in section      it is clear that a clause c is
contradictory if and only if it is  contradicted  further  for any qbf  and assignment   there exists
a  contradicted clause in the matrix of   if and only if  contains a  contradicted clause  if and only
if  contains a contradictory clause 

   

figiunchiglia  narizzano   tacchella

  function rec c resolve   c    c    l   
 
s     l   l  c    l  c    
 
if  s     return c resolve c    c    
 
l     han existential literal in c  with level  than the level of all the literals in c   i 
 
c    ha clause in  which causes l  to be unit in     where     l  is a prefix of i 
 
c     c resolve c    c  
 
return rec c resolve   c    c    l    
figure    the algorithm of rec c resolve 
   we are able to associate with each node  a  contradicted clause 
unfortunately  in some cases things do not run so smoothly  i e   it may not be possible
to associate a clause to an internal node by a simple single resolution between input and or
previously deduced clauses  indeed  some clause resolutions may be blocked because of
universal variables occurring both as y and y in the clauses to be used for the resolution 
consider for instance a qbf of the form  obtained from     by replacing the clause  x    x   
with  x    y  x     
x  x  yx    x    x      x    y  x      x    y  x            

   

then      would be still a valid path  and the corresponding clause resolutions would be 
hx    li
 x    x    hx    ui
 x    y  x    hx    ui      
      x    y  x   

    

where it is not possible to perform the clause resolution associated with the node having
label hx    ui  as in the example  a clause resolution     may be blocked only because of
some blocking universal literal l
 with both l and l not in   and
 with l  c  and l  c   
since both c  and c  are in minimal form  this is only possible if both c  and c  contain
an existential literal l 
 having level less than or equal to the level of all the other literals in the clause  and
 assigned as unit 
then  the obvious solution is to get rid  e g   of the blocking literals l in c  by resolving
away from c  the existential literals with a level lower than the level of l 
this is the idea behind the procedure rec c resolve in figure    in the figure  we
assume that
    is the input qbf 
   

ficlause term resolution and learning for quantified boolean formulas

     l is an assignment 
   l is an existential literal which is either unit or at the highest level in   
   c  is a clause containing l  in minimal form and   l contradicted 
   c  is a clause containing l  in minimal form and   l contradicted  further  if l is unit
in    then c  is a clause which causes l to be unit in   
   c resolve c    c    returns the resolvent of the clause resolution between the two
clauses c  and c   
from here on  if h  c    c    l  i satisfies the first   of the above conditions  we say that
the pair hc    c  i is to be   l rec c resolved  in    given two clauses hc    c  i to be
  l rec c resolved 
   the set s of universal literals blocking the clause resolution between c  and c  is
computed  line    
   if s is empty  then we can simply return the resolvent between c  and c   line    
otherwise
   we pick an existential literal l  in c  having minimum level in c   line     l  has
been assigned as unit earlier in the search  and we consider a clause c which caused
l  to be assigned as unit  line     if c  is the resolvent between c  and c  line    
rec c resolve   c    c    l    is returned  line    
if hc    c  i are to be   l rec c resolved in   rec c resolve   c    c    l    returns a minimal clause which is  contradicted and without existential literals whose negation has been
assigned as monotone in   this is formally stated by the following lemma 
lemma   let c  and c  be two clauses such that hc    c  i is to be   l rec c resolved in
a qbf   rec c resolve   c    c    l    terminates and returns a clause
 in minimal form and  contradicted  and
 which does not contain existential literals whose negation has been assigned as monotone in  
the proof of the lemma is quite long and it is reported in the appendix 
assuming that the input qbf  is false  the construction of the deduction of the empty
clause  associated with the minimal false subtree  of the tree searched by q dll  is the
following 
 with every leaf  of   we associate a clause c in the input formula which is contradicted 
 if c is the clause associated with a node   l  then
   if l   c or if l is universal then c is the clause associated with the parent of
  l  i e   with the node   notice that if l is existential and monotone in  then
l   c 
   

figiunchiglia  narizzano   tacchella

   if l  c and l is unit in  then the clause associated with the node  is the
result of rec c resolve   c  c     l     where c   is a clause of  which causes l
to be unit in   
   if l  c  l is existential and not unit in    then we have to consider also the
clause c   associated with the node   l  if l   c   then c   is the clause associated
with   as in the first case   if l  c     the clause associated with the node  is
the result of rec c resolve   c  c     l    
in our example  if  is     and with reference to the deduction in       the blocked resolution is the one associated with the node x    x    x    rec c resolve    x    y  x      x    y  x     x    x    x   
   at line    resolves  x    y  x    and  x    x     and the resolvent c  is min  x    x    y    
 x    x     and
   the following recursive call to rec c resolve    x    x      x    y  x     x    x    x    at line  
returns  x    y  x    
thus  the clause associated with each node are 
hx    li
 x    x    hx    ui
 x    y  x    hx    ui
    

 x   
 x   
 x    y  x   
 x    y  x   

notice that  with reference to figure    the choice of eliminating the blocking literals
in c  while maintaining c  invariant  is arbitrary  indeed  we could eliminate the blocking
literals in c  and maintain c  invariant  in the case of the deduction in       this amounts
to eliminate the universal literal y in  x    y  x     by resolving this clause with  x    x    on
x    we get the resolvent  x    x     which leads to the following legal deduction 
hx    li
 x    x    hx    ui
 from  x    y  x      x    x      x    x    hx    ui
    

 x   
 x   
 x    y  x   
 x    y  x   

lemma   let  be a false qbf  let  be the minimal false subtree of the tree searched by
q dll      let  be an assignment for   if  is false  then the clause associated with
the node  of 
 is in minimal form and  contradicted  and
 does not contain existential literals whose negation has been assigned as monotone
in  
proof  by construction  each clause associated with a leaf  of  is  contradicted  we
now show that also the clause c associated with an internal node  of  is  contradicted 
assuming that the clause c   associated with its child   l is   l contradicted  if  has also a
child   l  we also assume that the clause c    associated with its child   l is   l contradicted 
   

ficlause term resolution and learning for quantified boolean formulas

   if l   c   or if l is universal then c   c     hence  c is in minimal form  since l   c  
or l is universal  c   is   l contradicted if and only if c   is  contradicted  the thesis
follows because c   c    
   if l  c   and l is unit in  then c  rec c resolve   c     c      l     where c    is a
clause of  which causes l to be unit in    the thesis follows from lemma   
   if l  c  l is existential and not unit in    then we have to consider also the clause
c   associated with the node   l  assuming l  c    otherwise we would be in the first
case   the clause associated with  is the result of rec c resolve   c  c     l     as in
the previous case  the thesis follows from lemma   

theorem    let  be a false qbf  let  be the minimal false subtree of the tree searched
by q dll      then  corresponds to a clause resolution deduction of the empty clause 
proof  given lemma    the proof is analogous to the one of theorem   



   backjumping and learning in dll based procedures for qbfs
in this section we first show that computing the resolvent associated with each node allows
to backjump some branches while backtracking  subsection       then  we show that
learning resolvents allows to prune the search tree in branches different from the ones in
which resolvents were computed and learned  subsection      
    conflict and solution directed backjumping
the procedure described in section     uses a standard backtracking schema whenever the
empty clause  resp  matrix  is generated  q dll will backtrack up to the first existential
 resp  universal  literal assigned as left split  for instance  given the qbf
y  x  y  x  x    y    y    x      y    y     x    x      y    x    x    
 y     x    x      y     y    x      y     y    x      y     x    y     x     

    

the tree searched by q dll is represented in figure    where we use the same conventions
as in section   
in the      work of giunchiglia  narizzano  and tacchella         it is shown that the
exploration of some branches is not necessary  in particular  if  is the input qbf and  is
an assignment  we show how it is possible to compute a reason for the  un satisfiability
of  while backtracking  intuitively speaking  a reason for the result of  is a subset  of
the literals in  such that for any other assignment  
 which assigns to true or false the same literals assigned by   i e   such that   l   
l is in         l    l is in     and
 which extends   i e   such that    l   l is in      
   

figiunchiglia  narizzano   tacchella

  
  y    y    x      y    y     x    x      y    x    x    
 y     x    x      y     y    x      y     y    x      y     x    y     x    
 y    hy     li y    
  y    x      y     x    x      x    x    
hy     li y    
 y     y     x   hx    ui y    
 y     x    x   hx    ui y    
 y     x    x        y    

hy    ri  
  x    x      y    x      y    x      x    y     x    

hy    ri
  x    x      x    x    
hx    li
hx    ui
  

hx    li  
 y     x    x   hx    ui  
hy     pi  
 y     y    x   hx    ui  
      y     y    x   

hx    ri
hx    pi
hy     pi
hx    ui
    

figure    the resolution corresponding to the tree generated by q dll for       the prefix
is y  x  y  x  x   

  is equivalent to    then  by computing reasons  we can avoid to right split on a
literal l if l is not in the reason  assigning l to false would not change the result  the
resulting procedure is a generalization to qbf of the popular conflict directed backjumping
 cbj   prosser      b   but also introduces the concept of solution directed backjumping
 sbj   for avoiding useless splits on universal variables 
in a later paper  giunchiglia  narizzano  and tacchella        show how it is possible
to optimize the computation of reasons  in particular  in that paper  it is shown that
 assuming  is unsatisfiable  we can consider reasons being a subset of the existential
literals in   while
 assuming  is satisfiable  we can consider reasons being a subset of the universal
literals in  
apart from these optimizations  the tree searched by the procedures described in the former
and latter papers is the same  and  in the case of       the exploration of the branches
starting with hy    ri  hx    ri will be skipped  see figure    
we now show that the computation of the resolutions corresponding to q dll allows
to avoid the exploration of some branches pretty as much as cbj and sbj do  in the case
of the qbf       the branches being skipped will be the same skipped by cbj and sbj 
the key point is to think about q dll as a procedure producing a clause  resp  term 
deduction of the empty clause  resp  term   proving that  is unsatisfiable  resp  satisfiable  
then  according to the rules we use for associating a deduction to the tree searched by qdll  we have that 
 if c is the clause associated with a node   l and l   c  then the clause associated
with the node  is c  even if l is existential and it has been assigned as left split 
   

ficlause term resolution and learning for quantified boolean formulas

  function q dll bj    
 
if  ha clause c is  contradictedi 
 
return c 
 
if  hthe matrix of  is emptyi  return modelgenerate   
 
if  hl is unit in  i 
 
c    ha clause in the matrix of  which causes l to be unit in  i 
 
w r    q dll bj     l  
 
if  hw r is a termi or l   w r  return w r 
 
return rec c resolve   w r  c  l    
 
if  hl is monotone in  i  return q dll bj     l  
  
l    ha literal at the highest level in  i 
  
w r    q dll bj     l  
  
if  hl is existentiali and  hw r is a termi or l   w r   return w r 
  
if  hl is universali and  hw r is a clausei or l   w r   return w r 
  
w r     q dll bj     l  
  
if  hl is existentiali and  hw r  is a termi or l   w r     return w r   
  
if  hl is universali and  hw r  is a clausei or l   w r     return w r   
  
if  hl is existentiali  return rec c resolve   w r    w r  l    
  
return t resolve w r    w r  l    
figure    the algorithm of q dll bj 
 analogously  if t is the term associated with a node   l and l   t   then the term
associated with the node  is t   even if l is universal and it has been assigned as left
split 
the above rules do not take into account the clause term associated with the node   l  and
thus there is no need to explore the branch starting with   l 
consider for example figure    in which we use the standard conventions and  e g   write
the clause  resp  term  associated with each node  in red  resp  green  to the right of
the node  with reference to the figure  it is clear that considering the term  y     associated
with the node y     y     there is no need to explore the branch starting with hy    ri in order to
associate a y    entailed term with the node y     similarly  considering the empty clause   
associated with the node y    x    there is again no need to explore the branch starting with
hx    ri in order to associate a y   contradicted clause with the node y   
the procedure q dll bj     in figure   incorporates these ideas  in the figure 
 modelgenerate   returns the minimal form of a non contradictory and  entailed
term t such that
 for each clause c    c  t      and
 for each universal literal l in  assigned as monotone  l   t  
 rec c resolve   c    c    l    is as in figure   
   

figiunchiglia  narizzano   tacchella

 t resolve t    t    returns the resolvent of the term resolution between the two terms
t  and t   
the behavior q dll bj can be illustrated in a few words by saying that q dll bj    
computes and returns the clause term that would be associated with the node  in the tree
explored by q dll  in particular  assuming
 that w r is the clause  resp  term  returned by q dll bj     l  
 that l is existential  resp  universal   and
 that l has been assigned as left split 
q dll bj     does not explore the branch starting with   l if l   w r  resp  l   w r  
see line     resp  line     in q dll bj 
so far  with reference to figure    we can interpret the clause  resp  term  in red
 resp  green  to the right of a node  as the value returned by q dll bj      then 
considering the term  y     associated with the node y     y     q dll bj does not explore the
branch starting with hy    ri  similarly  considering the empty clause    associated with the
node y    x    q dll bj again does not explore the branch starting with hx    ri 
theorem    q dll bj     returns the empty clause if  is false  and the empty term
if  is true 
proof  sketch  it is enough to notice that 
 if a node  has associated a clause c  then c is  contradicted  and c is the result
of a sequence of clause resolutions 
 if a node  has associated a term t   then t is  entailed  and t is the result of a
sequence of model generations and term resolutions 
then  as in the previous section 
 if the empty clause is associated with the initial node   then  is false 
 if the empty term is associated with the initial node   then  is true 



    learning
learning is a well known technique in sat for avoiding the useless traversal of branches  in
sat  learning amounts to storing  clause  resolvents associated with the nodes of the tree
explored by dll  these resolvents are called nogoods and can be simply added to the set
of input clauses 
in the case of qbfs  the situation is different and more complicated  indeed  we have
two types of resolutions  term and clause   and while the resolvents of clause resolutions
can be added conjunctively to the matrix  the resolvents of term resolutions  that we will
call goods  have to be considered as in disjunction to the matrix 
in practice  we have to handle three sets of formulas 
   

ficlause term resolution and learning for quantified boolean formulas

 a set  of terms corresponding to the goods learned during the search 
 a set  of clauses corresponding to the matrix of the input qbf  and
 a set  of clauses corresponding to the nogoods learned during the search 
formally  if  is a qbf of the form      a qbf  extended with learning  eqbf  is an
expression of the form
q  z        qn zn h    i
 n    
    
where
  is a set of terms  also called goods  to be interpreted disjunctively  each good is
obtained by model generation and or term resolution from  
  is a set of clauses  also called nogoods  to be interpreted conjunctively  each nogood
is obtained by clause resolution from  
clearly 
q  z        qn zn     
and
q  z        qn zn     
are equivalent to     
initially  and  are the empty set  and  is the input set of clauses  as the search
proceeds 
 nogoods are determined while backtracking from a contradiction  i e   on an assignment  and  is unsatisfiable  and are possibly added to   and
 goods are determined while backtracking from a solution  i e   on an assignment 
and  is satisfiable  and are possibly added to  
in the following  we will use the term constraints when we want to refer to goods and
nogoods indifferently 
consider an eqbf       because of the constraints in  and or   the search can be
pruned considerably  indeed  while descending the search tree  any literal can be assigned
as long as we are guaranteed that we can reconstruct a valid clause term deduction while
backtracking of the empty clause term  the availability of already derived clauses terms
allows to prune the search because of the constraints in  or   given an assignment  
if there exists a  contradicted clause c    resp  a  satisfied term t    we can stop
the search and return c  resp  t    a term t is  satisfied if
 for each literal l in t   l is not in   and
 for each universal literal l in t   l is in  
clearly  a  entailed term is also  satisfied  further  we can extend the notion of unit to
take into account the constraints in  and or   a literal l is
 unit in a eqbf      if
   

figiunchiglia  narizzano   tacchella

  function rec resolve   w    w    l   
 
s     l   l  w    l  w    
 
if  s     return resolve w    w    
 
l     ha literal in w  with level  than the level of all the literals in w   i 
 
w    ha constraint in  which causes l  to be unit in     where     l  is a prefix of i 
 
w     resolve w    w   
 
return rec resolve   w    w    l    
figure    the algorithm of rec resolve 
 either l is existential and for some m    
 a clause  l  l            lm   belongs to  or   and
 each expression  li       i  m  occurs at the right of  l  in the prefix of
     
 or l is universal and for some m    
 a term  l  l            lm   belongs to   and
 each expression  li       i  m  occurs at the right of  l  in the prefix of
     
as for the definition of monotone literals  the crucial property that has to be ensured when
dealing with eqbfs  is that an existential  resp  universal  literal l assigned as monotone
in   l should never enter in a nogood  resp  good  associated with a node extending   l 
this is guaranteed by defining a literal l as monotone or pure if and only if 
 either l is existential and l does not belong to any constraint in    
 or l is universal and l does not belong to any constraint in    
because of the possibility of assigning also universal literals as unit  it may be the case
that some term resolutions may be blocked because of some existential literals l and l  each
occurring in one of the terms to be used in the antecedents of the term resolution  however 
the procedure rec c resolve presented in in subsection     can be easily generalized to
work also for the case in which the constraints to be resolved are terms  the result is the
procedure rec resolve   w    w    l    in figure    where it is assumed that
    is an eqbf 
   there are various ways to guarantee that an existential literal l assigned as monotone in   l does not
enter in a nogood associated with a node extending   l  another one is to
 keep the definition of existential monotone literal unchanged  an existential literal can be assigned
as monotone in      if l does not belong to any clause in   and
 update  to  or proceed in the search as if  has been updated to      c   c    l  c  
analogously for universal monotone literals  see the work of giunchiglia  narizzano and tacchella      a  for more details and possibilities  including a discussion about the interaction between the
monotone rule and learning 

   

ficlause term resolution and learning for quantified boolean formulas

     l is an assignment 
   l is an existential  resp  universal  literal which is either unit or at the highest level
in   
   w  is a clause  resp  term  containing l  resp  l   in minimal form and   l contradicted
 resp    l satisfied  
   w  is a clause  resp  term  containing l  resp  l   in minimal form and   l contradicted
 resp    l satisfied   further  if l is unit in    then w  is a clause  resp  term  which
causes l to be unit in   
   for each existential  resp  universal  literal l  assigned as unit in     l    with     l  a
prefix of   l  there has to be a clause  resp  term  in  which causes l  to be unit in
    
   resolve w    w    returns c resolve w    w     resp  t resolve w    w     
if h  w    w    l  i satisfy the first   of the above   conditions  we say that the pair hw    w  i
is to be   l rec resolved  in   
in the above  if  is       l is defined as the eqbf obtained from  by
 removing from  and   resp    the clauses c  resp  terms t   with l  c  resp 
l  t    and by removing l  resp  l  from the other clauses in     resp  terms in
   and
 removing q l  from the prefix 
if    l    l            lm  m       is defined as          l   l          lm  
if hw    w  i are to be   l rec resolved in   rec resolve   w    w    l    returns a
constraint in minimal form and  contradicted or  satisfied  as stated by the following
lemma 
lemma   let w  and w  be two clauses  resp  terms  such that hw    w  i is to be   lrec resolved in a eqbf   rec resolve   w    w    l    terminates and returns a minimal
clause  resp  term  which
 is  contradicted  resp   satisfied   and
 does not contain existential literals whose negation has been  resp  universal literals
which have been  assigned as monotone in  
proof  sketch  the proof is equal to  resp  analogous to  the proof of lemma   if l is
existential  resp  universal  

the procedure q dll ln      incorporates the above new definitions and ideas  and
is represented in figure     considering the figure 
 the definition of modelgenerate   can be relaxed with respect to the definition provided in subsection     in order to return the minimal form of a non contradictory
and  satisfied term t such that
   

figiunchiglia  narizzano   tacchella

         
         
  function q dll ln     
 
q    hthe prefix of i 
 
    hthe matrix of i 
 
if  ha  contradicted clause c is in   i 
 
return c 
 
if  ha  satisfied term t is in i 
 
return t  
 
if  hthe matrix of  is emptyi  return modelgenerate   
  
if  hl is unit in  qh    i  i 
  
w    ha constraint in      which causes l to be unit in  qh    i  i 
  
w r    q dll ln      l  
  
if  hl is existentiali and  hw r is a termi or l   w r   return w r 
  
if  hl is universali and  hw r is a clausei or l   w r   return w r 
  
w r    rec resolve qh    i  w r  w  l    
  
learn   w r  
  
return w r 
  
if  hl is monotone in  qh    i  i  return q dll ln      l  
  
l    ha literal at the highest level in  i 
  
w r    q dll ln      l  
  
if  hl is existentiali and  hw r is a termi or l   w r   return w r 
  
if  hl is universali and  hw r is a clausei or l   w r   return w r 
  
w r     q dll ln      l  
  
if  hl is existentiali and  hw r  is a termi or l   w r     return w r   
  
if  hl is universali and  hw r  is a clausei or l   w r     return w r   
  
w r    rec resolve qh    i  w r    w r  l    
  
learn   w r  
  
return w r 
figure     the algorithm of q dll ln 
 for each clause c    c  t      and
 for each universal literal l in  assigned as monotone  l   t  
 learn   w r  updates the set of goods and nogoods according to a given policy  here
we simply assume that learn   w r  updates  and  to   and   respectively  and
that   and   satisfy the following conditions 
   is a subset of    w r  if w r is a term  and of  otherwise 
   is a subset of    w r  if w r is a clause  and of  otherwise  and
 for each existential  resp  universal  literal l assigned as unit in an initial prefix
    l of        resp      still contains a clause  resp  term  that causes l to
be assigned as unit in  qh        i    
   

ficlause term resolution and learning for quantified boolean formulas

with reference to figure    this last condition is necessary in order to guarantee the
existence of a constraint w satisfying the condition at line   
the above conditions on learn   w r  are very general and ensure the soundness and
completeness of q dll ln 
theorem    q dll ln     returns the empty clause if  is false  and the empty term
if  is true 
proof  analogous to the proof of theorem    



to understand the benefits of learning  assume the input qbf is      the corresponding
eqbf is
x  yx  x  h      x    y  x      y  x      x    x      x    y  x      y  x    x        i 
and the search proceeds as in figure    with the first path leading to the empty matrix 
which starts the term resolution process  assuming the term min  y  x        y  is added
to the set of goods before checking the value of x   y   as soon as x  is assigned to true 
 y is detected to be unit and it is correspondingly assigned  and
 the path corresponding to the assignment x    y is not explored 
as this example shows   good  learning can avoid the useless exploration of some branches
that would be explored with a backtracking or backjumping schema  indeed  we have been
assuming that the deduced term is learned while backtracking  a policy according to which
learn   w r  simply adds w r
 to  if w r is clause  and
 to  otherwise 
can be easily implemented  however  such simple policy may easily lead to store an exponential number of goods and or nogoods  notice that we have a call to learn   w r  for
each literal assigned as unit or right split   thus  practical implementations incorporate
policies guaranteed to be space bounded  i e   ones that store a polynomial number of goods
and nogoods at most  in sat  the three most popular space bounded learning schemes are 
 size learning of order n  dechter         a nogood is added to  if and only if its
cardinality is less or equal to n  once added  it is never deleted 
 relevance learning of order n  ginsberg         given a current assignment   a
nogood c is always added to   and then it is deleted from  as soon as the number
of literals l in c and with l    is bigger than n 
 unique implication point  uip  based learning  marques silva   sakallah         a
nogood c is stored if and only if c contains only one literal at the maximum decision
level  given an assignment   the decision level of a literal l in  is the number of
splits done before l in   with uip based learning  the set  of added clauses is
periodically inspected and clauses are deleted according to various criteria 
   

figiunchiglia  narizzano   tacchella

thus  in size learning  once a nogood is stored  it is never deleted  in relevance and uip
based learning  nogoods are dynamically added and deleted depending on the current assignment  see the work of bayardo        for more details related to size and relevance
learning  including their complexity analysis   and the work of zhang  madigan  moskewicz
and malik        for a discussion of various uip based learning mechanisms for sat  size 
relevance  uip based learning are just a few of the various possibilities for limiting the
number of stored clauses  and each one can be generalized in various ways when considering
qbfs instead of sat formulas  in the next section  we will present the particular learning
schema that we implemented in qube 

   implementation and experimental analysis
in this section we first describe in some details the implementation of nogood and good
learning in qube  and then we report on some experimental analysis conducted in order to
evaluate the  separate  benefits of nogood and good learning  but also the relative efficiency
of our solver when compared to other state of the art qbf solvers 
    implementation in qube
to evaluate the benefits deriving from learning  we have implemented both good and nogood learning in qube  qube is a qbf solver based on search which  on non random
instances  compares well with respect to other state of the art solvers based on search  like
semprop  letz         yquaffle  zhang   malik      a   i e   the best solvers based
on search on non random instances according to  le berre  simon    tacchella        
see  giunchiglia  narizzano    tacchella      c  for more details 
besides learning  the version of qube that we used features
 efficient detection of unit and monotone literals using lazy data structures as in  gent 
giunchiglia  narizzano  rowley    tacchella        
 a branching strategy that exploits information gleaned from the input formula initially 
and leverages the information extracted in the learning phase 
see  giunchiglia  narizzano    tacchella      b  for a description of these characteristics 
as for learning  the computation of nogoods and goods corresponding to the internal
nodes of the search tree is carried out by doing clause and term resolution between a
working reason which is initialized when backtracking starts  and the reasons stored
while descending the search tree
 for each unit literal  the stored reason is a constraint in which the literal is unit 
 for each literal assigned as right split  the stored reason is the constraint computed
while backtracking on the left branch 
 for monotone literals  the way working reasons are initialized ensures that existential
 resp  universal  monotone literals never belong to a working reason computed while
backtracking from a contradiction  resp  solution  
   

ficlause term resolution and learning for quantified boolean formulas

assume that    l    l            lm is the assignment corresponding to the leaf under consideration  considering the problem of initializing the working reason  the way we do it in
qube is to
 return a  contradicted clause in the matrix of the input qbf or in the set of learned
nogoods  if we have a contradiction  and
 compute the minimal form of a  satisfied prime implicant of the matrix which contains as few universal literals as possible  if we have a solution 
in the second case  the computation of a prime implicant is important in order to have short
reasons  while having as few as possible universal literals is important in order to backjump
nodes  the above requirements are met by recursively removing irrelevant literals from the
set of literals in   starting from the universals ones  given a set s of literals  we say that
a literal is irrelevant in s if for each clause c in the matrix with l  c there exists another
literal l  in s with l  v
 c  if prime   is the set of literals being the result of the recursive
procedure  the term prime  
 is satisfied by  
 is a prime implicant of the matrix of the input qbf 
 is such that there does not exist another term satisfying the first two properties and
with a smaller  under set inclusion  set of universal literals 
in order to further reduce the number of universal literals in the initial goods  we take
advantage of the fact that the assignment  may be partial  for some literal l it may be
the case that neither l nor l is in   then  we can use the existential literals not in  
and with level lower than the level of all the universal literals in  assigned as left split  in
order to further reduce the number of universals in prime    in fact  for any sequence  
of literals extending  with existential literals  the set of universals in prime     is a subset
of prime    for instance  considering the qbf      if    y     y    x    x    then
 prime   is  y     y    x    x     and
 if we extend  to       x  then prime     is  x    y    x    x    
finally  when evaluating which universal literals in  are irrelevant  we follow the reverse
order in which they have been assigned  in order to try to backjump as high as possible in
the search tree 
as we said in the previous section  besides the problem of setting the initial working
reason  another problem with learning is that unconstrained storage of clauses  resp  terms 
obtained by the reasons of conflicts  resp  solutions  may lead to an exponential memory
blow up  in practice  it is necessary to introduce criteria
   for limiting the constraints that have to be learned  and or
   for unlearning some of them 
   

figiunchiglia  narizzano   tacchella

the implementation of learning in qube works as follows  assume that we are backtracking
on a literal l assigned at decision level n  the constraint corresponding to the reason for
the current conflict  resp  solution  is learned only if the following conditions are satisfied 
   l is existential  resp  universal   and
   all the assigned literals in the reason except l  are at a decision level strictly lower
than n  and
   there are no open universal  resp  existential  literals in the reason that are before l
in the prefix 
notice that these three conditions ensure that l is unit in the constraint corresponding
to the reason  once qube has learned the constraint  it backjumps to the node at the
maximum decision level among the literals in the reason  excluding l  we say that l is
a unique implication point  uip  and therefore the lookback in qube is uip based 
notice that our definition of uip generalizes to qbf the concepts first described by silva
and sakallah        and used in the sat solver grasp  on a sat instance  qube lookback
scheme behaves similarly to the   uip learning scheme used in zchaff  and described
in zhang et al          even if qube is guaranteed to learn at most one clause  resp  term 
per each conflict  resp  solution   still the number of learned constraints may blow up  as
the number of backtracks can be exponential  to stop this course  qube scans periodically
the set of learned constraints in search of those that became irrelevant  i e   clauses  resp 
terms  where the number of open literals exceeds a parameter n  corresponding to the
relevance order  thus  our implementation uses uip based learning to decide when to store
a constraint  and a relevance based criteria to decide when to forget a constraint  in the
experimental analysis presented in the next subsection  the parameter n has been set to   
and the set of learned constraints is scanned every      nodes 
besides the above learning mechanism  our current version of qube features lazy data
structures for unit literal detection and propagation  as described in gent et al         
monotone literal fixing  as described in giunchiglia et al       a   and a variable state independent decaying sum heuristic  vsids   as introduced in sat by moskewicz  madigan 
zhao  zhang    malik         as in sat  the basic ideas of our heuristic are to  i  initially
rank literals on the basis of the occurrences in the matrix   ii  increment the weight of the
literals in the learned constraints  and  iii  periodically divide by a constant the weight of
each literal 
    experimental results
to evaluate the effectiveness of our implementation  we considered the     formal verification and planning benchmarks that constituted part of the      qbf solvers comparative
evaluation        of these instances comes from verification problems  described in scholl
  becker        abdelwaheb   basin         and the remaining are from planning domains  described in rintanen        castellini  giunchiglia    tacchella         we start
our analysis considering qube with and without learning enabled  both versions of qube
   with respect to the non random instances used in the      qbf comparative evaluation  our test set
does not include the qbf encodings of the modal k formulas submitted by pan and vardi        

   

ficlause term resolution and learning for quantified boolean formulas

figure     effectiveness of learning  qube versus qube cbj sbj   cpu time  left  and
number of backtracks on the instances solved by both solvers  right  

compute goods and nogoods in order to backjump over irrelevant existential and universal
branching nodes  they differ in the treatment of the computed goods and nogoods 
 when learning is enabled  qube records both goods and nogoods 
 when learning is disabled  qube records neither nogoods nor goods 
we call the two versions qube cln sln  and qube cbj sbj  respectively  in order to
specify the type of look back used by the two systems  notice that we did not consider
qube with backtracking  i e   the version which computes neither nogoods nor goods and
performs simple chronological backtracking  because it is not competitive with the other
solvers 
all the experiments were run on a farm of identical pcs  each one equipped with a
pentium       ghz processor   gb of ram  running linux debian  sarge   finally 
each system had a timeout value of    s per instance 
figure    left shows the performances of qube cln sln  versus qube cbj sbj   in
the plot  the x axis is the cpu time of qube cln sln  and the y axis is the cpu time of
qube cbj sbj   a plotted point hx  yi represents a benchmark on which qube cln sln 
and qube cbj sbj  take x and y seconds respectively   for convenience  we also plot the
points hx  xi  each representing the benchmarks solved by qube cln sln  in x seconds 
the first observation is that learning pays off 
   in principle  one point hx  yi could correspond to many benchmarks solved by qube cln sln  and
qube cbj sbj  in x and y seconds respectively  however  in this and in the other scatter diagrams that
we present  each point  except for the point h        i  representing the instances on which both solvers
time out  corresponds to a single instance in most cases 

   

figiunchiglia  narizzano   tacchella

figure     effectiveness of learning with a random heuristic  qube rnd cln sln     versus qube rnd cbj sbj      cpu time  left  and number of backtracks on the
instances solved by both solvers  right  

 qube cln sln   resp  qube cbj sbj   is able to solve     resp     instances that
are not solved by qube cbj sbj   resp  qube cln sln    and
 among the instances solved by both solvers  qube cln sln   resp  qube cbj sbj  
is at least one order of magnitude faster than qube cbj sbj   resp  qube cln sln  
on     resp     instances 
in order to have an implementation quality independent measure of the pruning introduced
by learning  the right plot in the figure shows the number of backtracks  i e   the number
of solutions and conflicts found  of qube cbj sbj  versus qube cln sln  on the    
problems solved by both systems  here a plotted point hx  yi represents a benchmark
that is solved by qube cln sln  and qube cbj sbj  performing x and y backtracks
respectively  as it can be seen  learning substantially prunes the search space  there is no
point below the diagonal  meaning that it is never the case that qube cbj sbj  performs
less backtracks than qube cln sln    still  learning has some overhead  and thus the
pruning caused by learning not always pays off in terms of speed  as proved by the few
points below the diagonal in the left plot 
the above experimental data are not entirely satisfactory for two reasons 
first  learning and the heuristic are tightly coupled in qube  whenever qube learns a
constraint  it also increments the score of the literals in it  in qube cbj sbj  no constraint
   this does not imply that the tree searched by qube cln sln  is a subtree of the tree searched by
qube cbj sbj   indeed  the literal selected at each branching node by the two systems is not guaranteed
to be the same 

   

ficlause term resolution and learning for quantified boolean formulas

figure     effectiveness of conflict learning 
qube rnd cln sln     versus
qube rnd cbj sln      cpu time  left  and number of conflict backtracks on
the instances solved by both solvers  right  

is ever learned  as a consequence  in qube cbj sbj    i  literals are initially sorted on the
basis of their occurrences in the input qbf  and  ii  the score of each literal is periodically
halved until it becomes    when all the literals have score    then literals at the same prefix
level are chosen according to their lexicographic order 
second  independently from the heuristic being used  a plot showing the performances of
qube with and without learning  does not say which of the two learning schemes  conflict 
solution  is effective  gent   rowley        
to address the first problem  we consider qube with a random heuristic  i e   a heuristic
which randomly selects a literal among those at the maximum level and not yet assigned 
we call the resulting systems qube rnd cln sln  and qube rnd cbj sbj  respectively 
as the names suggest  the first has learning enabled  while in the second learning has been
disabled  because of the randomness  we run each solver   times on each instance  then 
we define qube rnd cln sln  i  to be the system whose performances are  on a each
instance  the i th best among the   results obtained by running qube rnd cln sln  on
that instance  qube rnd cbj sbj  i  is defined analogously 
figure    shows the cpu time  left  and number of backtracks on the solved instances
 right  of qube rnd cln sln     and qube rnd cbj sbj      from the plots  it is easy
to see that qube rnd cln sln     is faster than qube rnd cbj sbj     in most cases 
to witness this fact
 qube rnd cln sln   resp  qube rnd cbj sbj   is able to solve     resp     instances that are not solved by qube cbj sbj   resp  qube   and
   

figiunchiglia  narizzano   tacchella

figure     effectiveness of solution learning 
qube rnd cln sln     versus
qube rnd cln sbj      cpu time  left  and number of solution backtracks on the instances solved by both solvers  right  

 among the instances solved by both solvers  qube  resp  qube cbj sbj   is at least
one order of magnitude faster than qube cbj sbj   resp  qube  on     resp    
instances 
still  it is no longer the case that enabling learning always causes a reduction in the number
of backtracks  this can be because of the different literals selected at each branching node 
but also because pruning a node may prevent a long backjump  prosser      a  which
would cause a vast reduction of the search space  interestingly  comparing with the results
in figure     it seems that with a random heuristic learning becomes more important  this
fact witnesses also in our setting the well known tension between look ahead and look back
techniques  a smart look ahead makes the look back less important  and viceversa 
to address the second problem  we considered the systems qube rnd cbj sln  and
qube rnd cln sbj   i e   the systems obtained from qube rnd cln sln  by disabling
conflict learning and solution learning respectively  as usual  each system was run   times
on each instance  and qube rnd cbj sln  i  and qube rnd cln sbj  i      i    
are defined as before  the left plots in figures    and    show the performances of
qube rnd cln sln     versus qube rnd cbj sln     and qube rnd cln sbj     respectively  we also measured the number of backtracks  however  in order to better
highlight the pruning due to conflict  resp  solution  learning  the right plot in figure   
 resp      shows the number of conflict  resp  solution  backtracks of qube rnd cbj sln    
 resp  qube rnd cln sbj       from the plots  we see that both conflict and solution
learning prune the search space and pay off  in each plot  there are only a few points
well below the diagonal  comparing the two left plots  we also see that  on the test set
   

ficlause term resolution and learning for quantified boolean formulas

qube rnd cln sln    
qube rnd cln sln    
qube rnd cln sln    
qube rnd cln sln    
qube rnd cln sln    
qube rnd cbj sbj    
qube rnd cbj sbj    
qube rnd cbj sbj    
qube rnd cbj sbj    
qube rnd cbj sbj    
qube rnd cbj sln    
qube rnd cbj sln    
qube rnd cbj sln    
qube rnd cbj sln    
qube rnd cbj sln    
qube rnd cln sbj    
qube rnd cln sbj    
qube rnd cln sbj    
qube rnd cln sbj    
qube rnd cln sbj    

 
   
   
   
   
   
   
   
   
  
   
   
   
   
  
   
   
   
   
   

 
 
 
   
   
   
   
   
   
   
  
   
   
   
   
  
   
   
   
   

 
   
   
 
 
  
  
  
  
  
   
  
  
  
 
   
  
  
  
 


 
 
 
 
  
  
  
  
  
 
  
  
  
  
 
  
  
  
  


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

   
 
 
  
  
  
  
  
  
  
  
  
  
  
  
 
  
  
  
  

    
  
  
 
 
  
 
 
 
 
  
  
 
 
 
  
  
 
 
 

to
  
  
  
  
  
   
   
   
   
  
  
   
   
   
  
  
   
   
   

table    comparison among various versions of qube  each row compares a system written in the first column with respect to qube rnd cln sln     taken as reference 
if a is qube rnd cln sln     and b is a solver in the first column  then the other
columns report the number of problems that     a and b solve in the same
time     a and b solve but a takes less time than b     a and b solve but a
takes more time than b    a solves while b does not    a does not solve
while b does      a and b do not solve       both a and b solve but on
which a is at least one order of magnitude faster        both a and b solve
but on which a is at least one order of magnitude slower  to  b does not solve 
the number of timeouts for qube rnd cln sln     is    
that we considered  solution learning helps in solving problems more than conflict learning 
qube rnd cbj sln     times out on     while qube rnd cln sbj     times out on     
on the other hand  the two right plots suggest that conflict learning prunes more than solution learning  but this conclusion is not correct  indeed  each plot shows either the number
of conflicts or the number of solutions  pruning a node  no matter whether existential or
universal  may avoid finding  exponentially many  solutions and or conflicts  in particular 
given that all the instances are in cnf and thus have the form
      yx  x        xn 
 n     pruning any variable not in  x    x            xn   has the potential to prune  n conflicts 
   

figiunchiglia  narizzano   tacchella

some further and more detailed quantitative information about the cpu times is reported in table    from the last column in the table we see that  if we indicate with to s 
the number of timeouts of system s  then  for each i                  
to qube rnd cln sln  i    

to qube rnd cbj sln  i  
  to qube rnd cbj sbj  i   
to qube rnd cln sbj  i  

the above gives an indication of the capacity of the solvers  i e   of their ability to solve
problems  in order to get an indication of their productivity  i e   considering the problems
that they solve  their ability to solve them quickly  we can consider the number fs s  being
the difference between the       and      columns  the lower fs s  is  the better
s is  here again we have
fs qube rnd cln sln  i    

fs qube rnd cbj sln  i  
  fs qube rnd cbj sbj  i  
fs qube rnd cln sbj  i  

for i                   from the above  it is clear that both conflict and solution learning
allow to improve on capacity and productivity  our experimental results thus seem to
contradict the negative results reported in gents and rowleys work        for solution
based look back mechanisms  however  those results are not comparable with ours  given
the different mechanisms implemented by the respective solvers  e g   for computing the
initial solution and for monotone literal fixing   and the different experimental setting  e g  
the testset  

   conclusions and related work
this paper is based on and extends  giunchiglia et al         which introduces nogood and
good learning for qbfs satisfiability  here we show the correspondence between the computation trees searched by dll based qbf solvers and clause term resolution deductions 
nogoods and goods are the clauses and terms respectively in the resolution deductions 
under this perspective  learning simply amounts to storing nogoods and goods  we show
how to incorporate nogoods and goods learning in dll based qbf solvers by considering
eqbfs  qbfs extended with learning   and then illustrate by means of examples that the
computation of nogoods and goods 
 allows for solution and conflict directed backjumping in the spirit of  giunchiglia et al  
             and
 if stored  allows for pruning branches in other parts of the search tree 
we present a high level description of algorithms incorporating such ideas  and formally
prove their soundness and completeness  we also discuss the problems related to effective
implementations in dll based qbf solvers  and present  in some details  our implementation in qube  a state of the art qbf solver  the experimental analysis shows that qube
enhanced with nogood and good learning is more effective  when considering a selection of
nonrandom problems consisting of planning and formal verification benchmarks  we also
show that qube is competitive with respect to the state of the art 
   

ficlause term resolution and learning for quantified boolean formulas

as we already said  our work builds on  giunchiglia et al          other papers dealing
with learning in qbfs satisfiability are  letz          zhang   malik      a  and  gent  
rowley         in particular  in  letz        conflict and solution learning are called lemma
and model caching  the paper also proposes a technique based on model caching for dealing with qbfs having variable independent subformulas  zhang and malik      a  propose
conflict learning  which is then extended to solution learning in zhang   malik      b   in
the second paper  terms are called cubes  gent and rowley        introduce a new form
of solution learning  this new technique revisits less solutions than standard techniques 
but the experimental results reported in the paper are not positive  all these works share
the same intuitions and thus propose similar techniques  though it is difficult to establish
a precise relation among these works due to the differences in the terminology and or the
different level of detail in the presentations   we believe that the main differences are at the
implementation level  i e   in the way solution and conflict learning have been implemented 
it is therefore quite difficult if not impossible to compare the different alternatives  without
re implementing or recasting the different learning mechanisms or even the different solvers
in a common framework  indeed  the specific learning mechanism implemented within a
solver may be motivated by the other characteristics of the solver  e g   by the data structures being used or by the heuristic  for instance  watched data structures  used  e g   in
qube  yquaffle but not in semprop  allow for more efficient detection and propagation of unit and pure literals  gent et al          as a consequence  solvers with watched
data structures may profitably maintain huge databases for goods and nogoods  for solvers
with standard data structures  the costs involved in managing such huge databases may
overwhelm the advantages  considering each of these solvers as a whole  the experimental
analysis conducted in  giunchiglia et al       c  shows that our solver qube compares
well with respect to semprop and yquaffle on the     formal verification and planning
benchmarks that we considered also in this paper 

acknowledgments
we would like to thank ian gent and andrew rowley for discussions related to the subject
of this paper  and the anonymous reviewers for their suggestions and corrections  this work
has been partially supported by miur 

appendix a  proof of lemma  
the proof is by well founded induction  thus  the steps we follow are 
   the definition of a well founded order on tuples hc    c    l  i 
   the proof that the thesis holds for the minimal elements of the partial order  and
   assuming that the thesis holds for all the tuples hc    c    l  i such that hc    c    l  i 
hc    c    l  i  the proof that the thesis holds also for hc    c    l  i 
   for instance  in  letz        zhang   malik      b  but also in our initial work  giunchiglia et al  
       the method used for computing the initial working reason corresponding to a solution  procedure
modelgenerate in figure     is not detailed 

   

figiunchiglia  narizzano   tacchella

we have deliberately omitted what are the properties that the elements of the tuples
hc    c    l  i in the partial order have to satisfy  indeed  the standard assumption would be
that c  and c  be two clauses such that hc    c  i is to be   l rec c resolved  however 
this is not sufficient  indeed  it may happen that starting from two clauses hc    c  i to be
  l rec c resolved  line numbers refer to figure   
   the set  l   l  c    l  c    l is universal  is not empty  see line    
   the clause c  computed as in line   of figure   is not   l contradicted  and thus
   the tuple hc    c    l  i is not an element of the partial order 
to better understand the problem  consider the following simple example 
x  y  x  y  x  x    x      x    y    x      y     x      x    y     x      x    y    x    x     

    

for this qbf  
   x    x    y    x    x  is an assignment producing a contradictory clause 
   h x    y    x    x     x    y     x   i are to be x    x    y    x    x   rec c resolved 
   rec c resolve    x    y    x    x      x    y     x     x    x    x    y    x    x    
 a  causes a call to rec c resolve    x    y    y    x      x    y     x     x    x    x    y    x    x    
in which the clause c     x    y    y    x    is not x    x    y    x    x   contradicted  but
 b  returns the clause  y     x    which is x    x    y    x    x   contradicted  as expected 
the fact that the universal literal y  which causes c  not to be x    x    y    x    x   contradicted
does not appear in the clause returned by rec c resolve is due to the following two facts 
   y  has a lower level than the blocking literal y    and
   the negation of all the existential literals in c  with a level lower than y  are assigned
before y  in x    x    y    x    x   
to formally define these notions  we need some additional notation  first  consider a
given clause c    resc   c    is the set of literals in c  with a level lower than a literal
blocking the resolution between c  and c    formally 
resc   c       l   l  c    l   blockingc   c   level l    level l     
where
 for each literal l  level l  is the prefix level of l  and
 blockingc     is the function defined by
blockingc   c       l   l  c    l  c    l is universal 
let  be an assignment  we say that a clause c  is  contradictable  with respect to
c    if
   

ficlause term resolution and learning for quantified boolean formulas

   for each existential literal l in c    l is in  
   for each universal literal l in c    if l is in  then
 a  l  resc   c     and
 b  for each existential literal l  in c    if level l      level l  then l  is to the left of l
in  
clearly  if a clause is  contradicted then it is also  contradictable  considering the qbf
      the clause  x    y    y    x    is not x    x    y    x    x   contradicted  but is x    x    y    x    x  contradictable  with respect to  x    y     x     
our well founded order and induction will be on the set of tuples hc    c    l  i in which
c  is   l contradictable  as a preliminary step  we first define the well founded order on
literals according to which l   l   if and only if either l    l   or both l  and l   are in  and
l  has been assigned before l   in   i e   l  is to the left of l   in   
we extend the partial order relation  from literals to clauses  i  in minimal form   ii 
containing l  and  iii    l contradictable  by saying that for two such clauses c  and c   
c   c  if
 either c    c   
e
e
e
e
  
 
  
 or l    rese
c   c    resc   c    l   resc   c    resc   c    l  l   where resc   c   
is the subset of existential literals in resc   c     and similarly for rese
c   c    

the above order is well founded  and the minimal elements are such that resc   c   or 
equivalently  blockingc   c   is empty 
finally  consider the set w of tuples hc    c    l  i such that
     l is an assignment 
   l is an existential literal which is either unit or at the highest level in   
   c  is a clause containing l  in minimal form and   l contradictable with respect to
c   
   c  contains l  is in minimal form and is   l contradicted  further  if l is unit in   
then c  is a clause which causes l to be unit in   
on such set  we define a well founded order according to which hc    c    l  i  hc    c    l  i
if c   c   
now consider the procedure rec c resolve in figure    we prove by well founded
induction that  for each tuple hc    c    l  i  w   rec c resolve   c    c    l    terminates
and returns a clause c in minimal form and  contradicted  at the end  we will also show
that if we further assume that c  is   l contradicted  and not simply   l contradictable  
then c does not contain existential literals whose negation has been assigned as monotone
in  
in the base case  c  is such that resc   c    is empty  hence  for each universal literal
l  c    l is not in  and thus c  is   l contradicted  since resc   c    is empty  the set s
computed at line   is empty and thus rec c resolve   c    c    l    terminates returning
   

figiunchiglia  narizzano   tacchella

the resolvent c of c  and c    clearly c is in minimal form  and it is easy to show that c
is  contradicted 
for the step case  by induction hypothesis  we have that the thesis holds for rec cresolve   c    c    l    and we have to show that it holds also for rec c resolve   c    c    l    
assuming hc    c    l  i  hc    c    l  i  if the set resc   c    is empty  then see the base case 
assume that resc   c    is not empty  and thus that also blockingc   c    is not empty 
from here on  let l  be a literal in blockingc   c    with the highest level  l  is not in 
because l    resc   c    and c  is   l contradictable  l  is not in  because l   c  and c 
is   l contradicted  further  level l      level l   to see why  consider the only two possible
cases 
   l is unit in    since l   c    and c  is a clause which causes l to be unit in    it
must be level l      level l      level l  
   l is at the highest level in    since both l  and l  are not in  and l is at the highest
level in    level l     level l   on the other hand  level l       level l  because l  is
universal and l is existential 
since c  is in minimal form  there exists an existential literal l   such that l    c    l   is
in   and with level l       level l      level l   from here on  let l  be an existential literal
in c   not necessarily distinct from l     with level less than or equal to the level of all the
literals in c   see line     since
level l      level l      level l 

    

and l  is in   because c  is   l contradictable   it follows that l  has been assigned as unit 
and thus there exists a clause c in  which causes l  to be unit in     where     l  is an
initial prefix of   see line    
consider the set
blockingc  c       l   l  c    l  c  l is universal  
blockingc  c    is empty  in fact  for each universal literal l    c
 if level l       level l    then l     c  since c  is in minimal form 
 if level l       level l    then l    l    assume that l    c    since c  is   l contradictable 
l   l     however  l    l  and l   l   is not possible because l     l    l  is existential
and l   is universal  
since blockingc  c    is empty  we can resolve c and c  on l    obtaining
c    min  c   c     l    l    
as resolvent  c  is in minimal form and it contains l 
to show that c   c  it remains to be showed that c  is   l contradictable  indeed 
for each existential literal l in c    l is in   while for the universal literals in c    consider
the two cases 
   

ficlause term resolution and learning for quantified boolean formulas

   blockingc   c    is not empty  in this case  l   blockingc   c     this is an easy
consequence of the following facts 
 a  for each literal l    blockingc   c   level l       level l     l    c  by definition of
blockingc   c   hence l   is not in  because c  is   l contradicted  and therefore
level l       level l     and thus the thesis  see       
 b  blockingc   c       blockingc   c   blockingc   c  c  and thus  blockingc   c   
blockingc   c     blockingc   c       c  c        l    l     c     i e   the literals in
blockingc   c     blockingc   c  and not in blockingc   c    are those that have
been omitted because of the minimal form of c   
 c  blockingc   c    is not empty 
since l   blockingc   c     the literals in resc   c    which are also in c    also belong
to resc   c     i e  
resc   c     resc   c     c   
    
now consider a universal literal l    c   c    if l   is in  then
 a  l    resc   c    because c  is   l contradictable  and hence l    resc   c   
 see       
 b  for each existential literal l    in c    if level l        level l     then l     l   because
c  is   l contradictable 
 c  for each existential literal l       l  in c  l     l     in fact  level l      level l     
l   l   because c  is   l contradictable  and for each existential literal l       l  
c  l     l   
finally  consider a universal literal l    c  c    if l   is in  then level l       level l   
and hence
 a  l    resc   c    because level l      level l     see        and
 b  for each existential literal l     c    if level l        level l     then l     c and hence
l     l    
   blockingc   c    is empty  let m be the lowest among the level of the literals in c   
level l      m since l    c    then  for each universal literal l    c    l   is not in   i e  
c  is   l contradicted  in fact  assume that there exists a universal literal l    c  in
  then  level l       m and either l    c  or l    c  consider the first case l    c   
then  l    resc   c    because c  is   l contradictable  and then level l       level l    
but this is not possible because level l       m and level l      m  consider the case
l    c  then  level l       level l    and hence level l       level l     see       which is
again not possible 
since c   c    hc    c    l  i  hc    c    l  i  we can conclude by induction hypothesis that
rec c resolve   c    c    l    returns a clause in minimal form and  contradicted 
   

figiunchiglia  narizzano   tacchella

now we make the further assumption that the input clause c  is   l contradicted 
then  c  does not contain existential literals whose negation has been assigned as monotone  and the same holds for c  and for each clause c used at line    hence  rec cresolve   c    c    l    returns a clause without existential literals whose negation has been
assigned as monotone in  

references
abdelwaheb  a     basin  d          bounded model construction for monadic second order
logics  in   th international conference on computer aided verification  cav    
no       in lecture notes in computer science  pp         chicago  usa  springerverlag 
bachmair  l     ganzinger  h          resolution theorem proving  in robinson  a    
voronkov  a   eds    handbook of automated reasoning  vol  i  chap     pp       
elsevier science 
bayardo  jr   r  j     schrag  r  c          using csp look back techniques to solve
real world sat instances  in proceedings of the   th national conference on artificial intelligence and  th innovative applications of artificial intelligence conference
 aaai    iaai      pp          menlo park  aaai press 
bayardo  jr   roberto j     miranker  d  p          a complexity analysis of space bounded
learning algorithms for the constraint satisfaction problem  in proceedings of the
thirteenth national conference on artificial intelligence and the eighth innovative
applications of artificial intelligence conference  pp          menlo park  aaai
press   mit press 
cadoli  m   schaerf  m   giovanardi  a     giovanardi  m          an algorithm to evaluate
quantified boolean formulae and its experimental evaluation  journal of automated
reasoning             
cadoli  m   giovanardi  a     schaerf  m          an algorithm to evaluate quantified
boolean formulae  in proceedings of the   th national conference on artificial intelligence  aaai     and of the   th conference on innovative applications of artificial
intelligence  iaai      pp          menlo park  aaai press 
castellini  c   giunchiglia  e     tacchella  a          improvements to sat based conformant planning  in proc  ecp 
castellini  c   giunchiglia  e     tacchella  a          sat based planning in complex
domains  concurrency  constraints and nondeterminism  artificial intelligence                  
davis  m   logemann  g     loveland  d  w          a machine program for theorem
proving  communication of acm                
de la tour  t  b          minimizing the number of clauses by renaming  in proc  of the
  th conference on automated deduction  pp          springer verlag 
dechter  r          enhancement schemes for constraint processing  backjumping  learning 
and cutset decomposition  artificial intelligence                 
   

ficlause term resolution and learning for quantified boolean formulas

fermuller  c  g   leitsch  a   hustadt  u     tammet  t          resolution decision procedures  in robinson  a     voronkov  a   eds    handbook of automated reasoning 
vol  ii  chap      pp            elsevier science b v 
gent  i   giunchiglia  e   narizzano  m   rowley  a     tacchella  a          watched data
structures for qbf solvers  in giunchiglia  e     tacchella  a   eds    theory and
applications of satisfiability testing   th international conference  sat       santa
margherita ligure  italy  may           selected revised papers  vol       of lecture
notes in computer science  pp        springer 
gent  i  p     rowley  a  g          solution learning and solution directed backjumping revisited  tech  rep  apes          apes research group  available from
http   www dcs st and ac uk apes apesreports html 
ginsberg  m  l          dynamic backtracking  journal of artificial intelligence research 
        
giunchiglia  e   narizzano  m     tacchella  a          backjumping for quantified boolean
logic satisfiability  in proc  of the international joint conference on artificial intelligence  ijcai      
giunchiglia  e   narizzano  m     tacchella  a          learning for quantified boolean
logic satisfiability  in proceedings of the eighteenth national conference on artificial
intelligence and fourteenth conference on innovative applications of artificial intelligence  july      august          edmonton  alberta  canada  aaai press       
pp         
giunchiglia  e   narizzano  m     tacchella  a          backjumping for quantified boolean
logic satisfiability  artificial intelligence             
giunchiglia  e   narizzano  m     tacchella  a       a   monotone literals and learning
in qbf reasoning  in tenth international conference on principles and practice of
constraint programming  cp       pp         
giunchiglia  e   narizzano  m     tacchella  a       b   qbf reasoning on real world instances  in theory and applications of satisfiability testing   th international conference  sat       vancouver  bc  canada  may              revised selected papers 
pp         
giunchiglia  e   narizzano  m     tacchella  a       c   qube    an efficient qbf solver  in
 th international conference on formal methods in computer aided design  fmcad
      pp         
kleine buning  h   karpinski  m     flogel  a          resolution for quantified boolean
formulas  information and computation                
le berre  d   simon  l     tacchella  a          challenges in the qbf arena  the sat  
evaluation of qbf solvers  in sixth international conference on theory and applications of satisfiability testing  sat        vol       of lncs  springer verlag 
letz  r          lemma and model caching in decision procedures for quantified boolean
formulas  in proceedings of tableaux       lnai       pp          springer 
   

figiunchiglia  narizzano   tacchella

marques silva  j  p     sakallah  k  a          grasp   a new search algorithm for
satisfiability  in proceedings of ieee acm international conference on computeraided design  pp         
moskewicz  m  w   madigan  c  f   zhao  y   zhang  l     malik  s          chaff  engineering an efficient sat solver  in proceedings of the   th design automation
conference  dac     pp         
pan  g     vardi  m  y          optimizing a bdd based modal solver  in automated
deduction   cade       th international conference on automated deduction miami
beach  fl  usa  july      august          proceedings  pp       
plaisted  d     greenbaum  s          a structure preserving clause form translation 
journal of symbolic computation            
prosser  p       a   domain filtering can degrade intelligent backjumping search  in proceedings of the   th international joint conference on artificial intelligence  ijcai   vol    pp         
prosser  p       b   hybrid algorithms for the constraint satisfaction problem  computational intelligence                
rintanen  j          constructing conditional plans by a theorem prover  journal of artificial intelligence research             
robinson  a          a machine oriented logic based on the resolution principle  journal
of the acm               
robinson  a          the generalized resolution principle  in machine intelligence  vol    
pp        oliver and boyd  edinburgh 
scholl  c     becker  b          checking equivalence for partial implementations  in
proceedings of the   th design automation conference  dac     pp         
tseitin  g          on the complexity of proofs in propositional logics  seminars in mathematics    
urquhart  a          the complexity of propositional proofs  the bulletin of symbolic
logic                
zhang  l   madigan  c  f   moskewicz  m  w     malik  s          efficient conflict driven
learning in a boolean satisfiability solver  in international conference on computeraided design  iccad     pp         
zhang  l     malik  s       a   conflict driven learning in a quantified boolean satisfiability solver  in proceedings of international conference on computer aided design
 iccad    
zhang  l     malik  s       b   towards a symmetric treatment of satisfaction and conflicts
in quantified boolean formula evaluation  in proceedings of the eighth international
conference on principles and practice of constraint programming  pp         

   

fi