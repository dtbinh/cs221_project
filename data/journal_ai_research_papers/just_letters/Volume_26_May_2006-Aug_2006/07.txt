journal of artificial intelligence research                  

submitted        published      

engineering benchmarks for planning  the domains used in the
deterministic part of ipc  
jorg hoffmann

hoffmann   mpi   sb   mpg   de

max planck institute for computer science 
saarbrucken  germany

stefan edelkamp

stefan   edelkamp   cs   uni   dortmund   de

fachbereich informatik 
universitat dortmund  germany

sylvie thiebaux

s ylvie  t hiebaux   anu   edu   au

national ict australia   computer sciences laboratory 
the australian national university  canberra  australia

roman englert

roman  e nglert   telekom   de

deutsche telekom laboratories 
berlin  germany

frederico dos santos liporace

liporace   inf  puc   rio   br

departamento de informatica  puc rio 
rio de janeiro  brazil

sebastian trug

trueg   informatik   uni   freiburg   de

institut fur informatik 
universitat freiburg  germany

abstract
in a field of research about general reasoning mechanisms  it is essential to have appropriate
benchmarks  ideally  the benchmarks should reflect possible applications of the developed technology  in ai planning  researchers more and more tend to draw their testing examples from the
benchmark collections used in the international planning competition  ipc   in the organization
of  the deterministic part of  the fourth ipc  ipc    the authors therefore invested significant effort
to create a useful set of benchmarks  they come from five different  potential  real world applications of planning  airport ground traffic control  oil derivative transportation in pipeline networks 
model checking safety properties  power supply restoration  and umts call setup  adapting and
preparing such an application for use as a benchmark in the ipc involves  at the time  inevitable
 often drastic  simplifications  as well as careful choice between  and engineering of  domain encodings  for the first time in the ipc  we used compilations to formulate complex domain features
in simple languages such as strips  rather than just dropping the more interesting problem constraints in the simpler language subsets  the article explains and discusses the five application
domains and their adaptation to form the pddl test suites used in ipc    we summarize known
theoretical results on structural properties of the domains  regarding their computational complexity
and provable properties of their topology under the h  function  an idealized version of the relaxed
plan heuristic   we present new  empirical  results illuminating properties such as the quality of
the most wide spread heuristic functions  planning graph  serial planning graph  and relaxed plan  
the growth of propositional representations over instance size  and the number of actions available
to achieve each fact  we discuss these data in conjunction with the best results achieved by the
different kinds of planners participating in ipc   

c
    
ai access foundation  all rights reserved 

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

   introduction
today  to a large extent the research discipline of ai planning is concerned with improving the performance of domain independent generative planning systems  a domain independent generative
planning system  planner  must be able to fully automatically find plans  solution sequences in
declaratively specified transition systems  the simplest planning formalism is deterministic planning  there  a planner is given as input a set of state variables  often just booleans  called facts  
an initial state  a value assignment to the variables   a goal  a formula   and a set of actions  with a
precondition formula describing applicability  and with an effect specifying how the action changes
the state   a plan is a time stamped sequence of actions that maps the initial state into a state that
satisfies the goal  this sort of formalism is called deterministic since the initial state is fully specified and the effects of the actions are non ambiguous  both restrictions may be weakened to obtain
non deterministic and probabilistic planning 
performance of planners is measured by testing them on benchmark example instances of the
planning problem  the best algorithm at any point in time is  generally  considered to be the one
that solves these examples most efficiently  in particular  this is the idea in the international planning competition  ipc   a biennial event aimed at showcasing the capabilities of current planning
systems 
the first ipc took place in       so at the time of writing there were four such events  providing details about the ipc is beyond the scope of this paper  and we refer the reader to the overview
articles written by the organizers of the respective ipc editions  mcdermott        bacchus       
long   fox        hoffmann   edelkamp         in particular  hoffmann and edelkamp       
provide details about the  th ipc  such as overall organization  different tracks  evaluation  participating planners  and results  basic information is included in this paper  so the reader should be
able to follow the main discussion without a detailed background  the language used to describe
planning problems in the ipc is called pddl  planning domain definition language  it was introduced by mcdermott        for the first ipc  ipc    in       a subset of the language was
selected by bacchus        for ipc   in       the language was extended with temporal and numerical constructs by fox and long        to form the language pddl    for ipc   in       it was
further extended with two additional constructs  timed initial literals and derived predicates  by
hoffmann and edelkamp        to form the language pddl    for ipc   in      
since  even in its simplest forms  ai planning is a computationally hard problem  no system
can work efficiently in all problem instances  bylander        helmert         thus  it is of crucial importance what kinds of examples are used for testing  today  more and more  ai planning
researchers draw their testing examples from the collections used in the ipc  this makes the ipc
benchmarks a very important instrument for the field  in the organization of the deterministic part
of the  th ipc  there was also a probabilistic part  see younes  littman  weissman    asmuth 
       the authors therefore invested considerable effort into creating a set of useful benchmarks
for planning 
the very first question to answer is what precisely is meant here by the word useful  this is
not an easy question  there is no widely accepted mathematical definition for deciding whether a
set of benchmarks should be considered useful  there are  however  widely accepted intuitions of
when this is the case  benchmarks should be 
   oriented at applications  a benchmark should reflect an application of the technology developed in the field 
   

fie ngineering b enchmarks

for

p lanning

   diverse in structure  a set of benchmarks should cover different kinds of structure  rather
than re state very similar tasks 
the first of these is usually considered particularly important  indeed  ai planning has frequently been criticized for its obsession with toy examples  in recent years  the performance of
state of the art systems has improved dramatically  and with that more realistic examples have come
within reach  we made another step in this direction by orienting most of the ipc   benchmarks at
application domains  while traditionally planning benchmarks were more or less fantasy products
created having some real scenario in mind   we took actual  possible  applications of planning
technology  and turned them into something suitable for the competition  we considered five different application domains  airport ground traffic control  airport   oil derivative transportation in
pipeline networks  pipesworld   model checking safety properties  promela   power supply restoration  psr   and setup of mobile communication in umts  umts   of course  in the adaptation of
an application for use in the ipc  simplifications need to be made  we will get back to this below 
diverse structure of benchmarks has traditionally been given less attention than realism  but
we believe that it is no less important  the structure underlying a testing example determines the
performance of the applied solving mechanism  this is particularly true for solving mechanisms
whose performance rises and falls with the quality of a heuristic they use  hoffmanns             
      results suggest that much of the spectacular performance of modern heuristic search planners
is due to structural similarities between most of the traditional planning benchmarks  while this
does not imply that modern heuristic search planners arent useful  it certainly shows that in the
creation of benchmarks there is a risk of introducing a bias towards one specific way of solving
them  in selecting the benchmark domains for ipc    we tried to cover a range of intuitively very
different kinds of problem structure  we will get back to this below 
on the one hand  a creator of planning benchmarks has the noble goal of realistic  and structurally diverse  benchmark domains  on the other hand  he she has the more pragmatic goal to
come up with a version representation of the benchmarks that can be attacked with existing planning systems  given the still quite restricted capabilities of systems  obviously the two goals are in
conflict  to make matters worse  there isnt an arbitrarily large supply of planning applications that
are publicly available  and or whose developers agree to have their application used as the basis of
a benchmark  for the ipc organizer  on top of all this  the final benchmarks must be accessible for
a large enough number of competing systems  which means they must be formulated in a language
understood by those systems  further  the benchmarks must show differences between the scalability of planners  i e   they must not be too easy or too hard  thus straddling the boundary of current
system capabilities 
the solution to the above difficulties  at least our solution in the organization of ipc    involved a slow tedious interleaved process of contacting application developers  choosing domains 
exploring domain versions  and engineering domain version representations  this article presents 
motivates  and discusses our choice of benchmark domains for ipc    it explains the engineering
processes that led to the finally used domain versions and instances  further  we report about 
and present some new data determining certain structural properties of the resulting benchmarks
 more details below   the main contribution of the work is the set of benchmarks  provided in
   of course  there are exceptions to this rule  one important one  in our context here  is the satellite domain  used in
ipc    that we further refined for use in ipc    more on this later 

   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

ipc     the contributions of this article are  first  providing the necessary documentation of these
benchmarks  second  describing the technical processes used in their creation  third  providing an
extensive discussion of the structural properties of the benchmarks  apart from these more technical contributions  we believe that our work has value as an example of a large scale attempt at
engineering a useful set of benchmarks for classical planning 
it is difficult to make any formal claim about our created set of benchmarks  such as that they
are in some way better than the previous benchmarks  when working on this  our intent was to
overcome certain shortcomings of many benchmarks  though one would be hard pressed to come
up with a formal proof that such improvements were indeed made  after all  judging the quality of
a set of benchmarks is a rather complex matter guided mostly by intuitions  and  worse  personal
opinions   what we did was  do our best to create as realistic  structurally diverse  and accessible
benchmarks as possible for ipc    our belief is that we succeeded in doing so  the benchmarks
definitely differ in certain ways from most of the previous benchmarks  we think that most of these
differences are advantageous  we will discuss this at the places where we point out the differences 
regarding realism of the benchmarks  as pointed out above  the main step we took was to design
benchmarks top down  i e   start from actual possible applications of planning technology  and
turn them into something suitable for the competition  rather than the more traditional bottomup approach of just artificially creating a domain with some real scenario in mind  of course 
for modelling an application in pddl  particularly for modelling it in a way making it suitable
for use in the ipc  simplifications need to be made  in some cases  e g   airport ground traffic
control  the simplifications were not overly drastic  and preserved the overall properties and intuitive
structure of the domain  but in other cases  e g   oil derivative transportation in pipeline networks 
the simplifications we needed to make were so drastic that these domains could just as well have
been created in the traditional bottom up way  still  even if greatly simplified  a domain generated
top down has a better chance to capture some structure relevant in a real application  moreover 
a top down domain has the advantage that since it is derived from a real application  it provides
a clear guideline towards more realism  the future challenge is to make planners work on more
realistic encodings of the application  in the previous competitions  the only domains generated
top down in the above sense were the elevator domain used in ipc    koehler   schuster       
bacchus         and the satellite and rovers domains used in ipc    long   fox        
regarding diverse structure of the benchmarks  in contrast to the previous competitions  in the
ipc   domains there is no common theme underlying many of the benchmarks  in ipc      out
of   domains were variants of transportation  in ipc      out of   domains were variants of transportation  in ipc      out of   domains were variants of transportation  and   were about gathering
data in space  some of the variants are in fact very interesting in their use of constructs such
as locked locations  fuel units  road map graphs  stackable objects  and complex side constraints 
however  there is certainly an intuitive similarity in the structure and relationships in the domains 
to some extent this similarity is even automatically detectable  long   fox         not so in ipc   airport ground traffic control  oil derivative transportation in pipeline networks  model checking
safety properties  power supply restoration  and umts call setup are rather different topics  at
   the benchmarks can be downloaded from the ipc   web page at http   ipc icaps conference org 
   consider for example the movie domain used in ipc    all instances of this domain  no matter what their size is 
share the same space of reachable states  the only thing that increases is the connectivity between states  i e  the
number of actions that have the same effect  still one can argue that movie is a useful benchmark  in the sense that it
can highlight systems approaches that have have no difficulties in attacking such problem characteristics 

   

fie ngineering b enchmarks

for

p lanning

most one could claim that airport ground traffic control and umts call setup both have a scheduling nature  we will see  however  that the ipc   version of airport ground traffic control allows
considerably more freedom than classical scheduling formulations  making it a pspace complete
decision problem  the particulars of the domains will be overviewed in section   
approaching structure from a more formal point of view is more difficult  it is largely unclear
what  precisely  the relevant structure in a planning domain instance is  in a general sense  while
hoffmann                    provides one possible definition  search space surface topology under a certain heuristic function  there are many other possible options  in particular  hoffmanns
results are relevant only for heuristic search planners that generate their heuristic functions based on
the ignoring delete lists relaxation  mcdermott              bonet  loerincs    geffner       
bonet   geffner        hoffmann   nebel         for lack of a better formal handle  we used
hoffmanns definitions to qualify the structure of the domains  the selected domains cover different regions of hoffmanns planning domain taxonomy  in particular they lie in regions that
have less coverage in the traditional benchmarks  because they are interesting in the context of
the paper at hand  we summarize hoffmanns        results for    domains including all domains
used in the previous competitions  we also summarize helmerts      b  results on the computational complexity of satisficing and optimal planning in the ipc   domains  it turns out that their
complexity covers a wide range  the widest possible range  for propositional planning formalisms
 from pspace hard to polynomial  we finally provide some new data to analyze the structural
relationships and differences between the domains  amongst other things  for each instance  we
measure  the number of  parallel and sequential  steps needed to achieve the goal  estimated by the
smallest plan found by any ipc   participant  the same number as estimated by planning graphs
and relaxed plans  and the distribution of the number of possible achieving actions for each fact 
the results are examined in a comparison between the different domains  taking into account the
runtime performance exhibited by the different kinds of planners in ipc   
apart from realism and diverse structure  our main quest in the creation of the ipc   benchmarks
was to promote their accessibility  applications are  typically  if they can be modelled at all in
pddl  most naturally modelled using rather complex language constructs such as time  numeric
variables  logical formulas  and conditional effects  most existing systems handle only subsets of
this  in fact more than half of the systems entered into ipc    precisely     out of     could handle
only the simple strips language  or slight extensions of it   in the previous competitions  as done
for example in the elevator  satellite  and rovers domains  this was handled simply by dropping
the more interesting domain constraints in the simpler languages  i e   by removing the respective
language constructs from the domain instance descriptions  in contrast  for the first time in the ipc 
we compiled as much of the domain semantics as possible down into the simpler language formats 
such a compilation is hard  sometimes impossible  to do  it can be done for adl constructs  as
well as for the two new constructs introduced for the ipc   language pddl     derived predicates
and timed initial literals  we implemented  and applied  compilation methods for all these cases 
   strips  stanford research institute problem solver  is the name of the simplest and at the same time most widespread planning language  in the form of the language used today  the state variables are all boolean  formulas are
conjunctions of positive atoms  action effects are either atomic positive  make a fact true add it  or atomic negative
 make a fact false delete it   fikes   nilsson         the languages selected for ipc    bacchus         from which
pddl    and pddl    are derived  were strips and adl  adl is a prominent  more expressive  alternative
to strips  extending it with arbitrary first order formulas as preconditions and goal  and with conditional effects 
i e   effects that occur only if their individual effect condition  a first order formula  is met in the state of execution
 pednault        

   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

the compilations serve to preserve more of the original domain structure  in the simpler language
classes  for example  the strips version of the elevator domain in ipc   is so simplified from the
original adl version that it bears only marginal similarity to real elevator control  in particular 
the planner can explicitly tell passengers to get into or out of the lift   in contrast  our strips
formulation of the airport ground traffic domain is  semantically  identical to our adl formulation
 it expresses the same things  but in a more awkward fashion 
the compiled domain versions were offered to the competitors as alternative domain version formulations  yielding a   step hierarchy for each domain  that is  each domain in ipc  
could contain several different domain versions  differing in terms of the number of domain constraints properties considered  within each domain version  there could be several domain version formulations  differing in terms of the language used to formulate the  same  semantics  the
competitors could choose  within each version  whichever formulation their planners could handle
best handle at all  and the results within the domain version were then evaluated together  this
way  we intended to make the competition as accessible as possible while at the same time keeping
the number of separation lines in the data  the number of distinctions that need to be made when
evaluating the data  at an acceptable level 
we are  of course  aware that encoding details can have a significant impact on system performance   particularly  when compiling adl to strips  in most cases we had to revert to fully
grounded encodings  while this certainly isnt desirable  we believe it to be an acceptable price to
pay for the benefit of accessibility  most current systems ground the operators out as a pre process
anyway  in cases where we considered the compiled domain formulations too different from the
original ones to allow for a fair comparison  typically because plan length increased significantly
due to the compilation  the compiled formulation was posed to the competitors as a separate domain version 
the article is organized as follows  the main body of text contains general information  in
section    we give a detailed explanation of the compilation methods we used  in section    we give
a summary of the domains  each with a short application description  our motivation for including
the domain  a brief explanation of the main simplifications made  and a brief explanation of the
different domain versions and formulations  in section    we summarize hoffmanns        and
helmerts      b  theoretical results on the structure of the ipc   domains  section    we provide
our own empirical analysis of structural properties  section   discusses what was achieved  and
provides a summary of the main issues left open  for each of the ipc   domains  we include a
separate section in appendix a  providing detailed information on the application  its adaptation
for ipc    its domain versions  the example instances used  and future directions  although these
details are in an appendix  we emphasize that this is not because they are of secondary importance 
on the contrary  they describe the main body of work we did  the presentation in an appendix
seems more suitable since we expect the reader to  typically  examine the domains in detail in a
selective and non chronological manner 
   the passengers wont get in  out  at floors other than their origin  destination   however  with explicit control  the
planner can choose to not let someone in  out   the more accurate encoding is via conditional effects of the action
stopping the lift at a floor 
   a very detailed account of such matters is provided by howe and dahlman        

   

fie ngineering b enchmarks

for

p lanning

   pddl compilations
we used three kinds of compilation methods 
 adl to simple adl  strips with conditional effects  or strips 
 pddl with derived predicates to pddl without them 
 pddl with timed initial literals to pddl without them 
we consider these compilation methods in this order  explaining  for each  how the compilation
works  what the main difficulties and their possible solutions are  and giving an outline of how we
used the compilation in the competition  note that adl  simple adl  and strips are subsets
of pddl  each of the compilation methods was published elsewhere already  see the citations in
the text   this section serves as an overview article  since a coherent summary of the techniques 
and their behavior in practice  has not appeared elsewhere in the literature 
    compilations of adl to simple adl and strips
adl constructs can be compiled away with methods first proposed by gazen and knoblock        
suppose we are given a planning instance with constant  object  set c  initial state i  goal g  and
operator set o  each operator o has a precondition pre o   and conditional effects e  taking the form
con e   add e   del e  where add e  and del e  are lists of atoms  preconditions  effect conditions 
and g are first order logic formulas  effect conditions are t ru e for unconditional effects   since
the domain of discourse  the set of constants  is finite  the formulas can be equivalently transformed into propositional logic 
    quantifiers are turned into conjunctionsvand disjunctions  simply by expanding
w them with the
available objects  x    x  turns into cc  c  and x    x  turns into cc  c   iterate
until no more quantifiers are left 
since strips allows only conjunctions of positive atoms  some further transformations are necessary 
    formulas are brought into negation normal form       turns into    and     
turns into     iterate until negation is in front of atoms only 
    for each x that occurs in a formula  introduce a new predicate not x  set not x  i iff
x   i  for all effects e  set not x  add e  iff x  del e  and not x  del e  iff x  add e  
in all formulas  replace x with not x  iterate until no more negations are left 
    transform all formulas into dnf                   turns into                  
                  iterate until no more conjunctions occur above disjunctions  if an
operator precondition pre o  has n     disjuncts  then create n copies of o each with one
disjunct as precondition  if an effect condition con e  has n     disjuncts  then create n
copies of e each with one disjunct as condition  if g has n     disjuncts  then introduce a
new fact goal reached  set g    goal reached  and create n new operators each with one
disjunct as precondition and a single unconditional effect adding goal reached 

   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

  action move
 parameters
  a   airplane  t   airplanetype  d    direction  s   s    segment  d    direction 
 precondition
 and  has type  a  t   is moving  a   not     s   s     facing  a  d    can move  s   s   d  
 move dir  s   s   d    at segment  a  s  
 not  exists   a    airplane   and  not     a   a    blocked  s   a     
 forall   s   segment   imply  and  is blocked  s  t  s   d    not     s  s      not  occupied  s     
 effect
 and  occupied  s    blocked  s   a   not  occupied  s     not  at segment  a  s     at segment  a  s  
 when  not  is blocked  s   t  s   d     not  blocked  s   a   
 when  not     d   d     and  not  facing  a  d     facing  a  d    
 forall   s   segment   when  is blocked  s  t  s   d    blocked  s  a   
 forall   s   segment   when
 and  is blocked  s  t  s   d    not     s  s     not  is blocked  s  t  s   d    
 not  blocked  s  a      

figure    an operator from airport ground traffic control 
as an illustrative example  consider the operator description in figure    taken from our domain
encoding airport ground traffic control  this operator moves an airplane from one airport segment
to another  consider specifically the precondition formula  not  exists   a    airplane   and  not   
 a   a    blocked  s   a       saying that no airplane different from  a is allowed to block segment
 s   the segment we are moving into  say the set of airplanes is a            an   then step     will
turn the formula into  not  or  and  not    a   a    blocked  s  a            and  not    an  a    blocked  s 
an       step     yields  and  or    a   a   not  blocked  s  a             or    an  a   not  blocked  s  an      
step     yields  and  or    a   a   not blocked  s  a            or    an  a   not blocked  s  an      step     
finally  will  naively  transform this into  or  and    a   a           an  a          and  not blocked  s  a   
       not blocked  s  an      i e   more mathematically notated 
 
 
x 
x    a 

 a   not blocked  s  a           an  a   not blocked  s  an   

in words  transforming the formula into a dnf requires enumerating all n vectors of atoms where
each vector position i is selected from one of the two possible atoms regarding airplane ai   this
yields an exponential blow up to a dnf with  n disjuncts  the dnf is then split up into its single
disjuncts  each one yielding a new copy of the operator 
the reader will have noticed that an exponential blow up is also inherent in compilation step
     where each quantifier may be expanded to  c  sub formulas  and k nested quantifiers will
be expanded to  c k sub formulas  obviously  in general there is no way around either of the
blow ups  other than to deal with more complex formulas than allowed in strips  in practice 
however  these blow ups can typically be dealt with reasonably well  thanks to the relative simplicity
of operator descriptions  and the frequent occurrence of static predicates  explained shortly  if
quantifiers arent deeply nested  like in figure    then the blow up inherent in step     does not
matter  transformation to dnf is more often a problem  like in our example here  the key
to successful application of the compilation in practice  at least as far as our personal experience
goes  is the exploitation of static predicates  this idea is described  for example  by koehler and
   

fie ngineering b enchmarks

for

p lanning

hoffmann         static predicates arent affected by any operator effect  such predicates can be
easily found  and their truth value is fully determined by the initial state as soon as they are fully
instantiated  in the above transformation through step      the operator parameters are still variables 
and even if we knew that   is  of course  a static predicate  this would not help us because we
wouldnt know what  a is  if we instantiate  a  however  then  in each such instantiation of
the operator  the     a   a  atoms trivialize to true or false  and the large dnf collapses
v
to the single conjunction a     a  airplane  not blocked  s   a    where a is our instantiation of
 a  similarly  the expansion of quantifiers is often made much easier by first instantiating the
operator parameters  and then inserting true or false for any static predicate as soon as its
parameters are grounded  inserting true or false often simplifies the formulas significantly
once this information is propagated upwards  e g   a disjunction with a true element becomes
true itself  
assuming our compilation succeeded thus far  after steps     to     are processed we are down to
a strips description with conditional effects  i e   the actions still have conditional effects con e  
add e   del e  where con e  is a conjunction of atoms  this subset of adl has been termed
simple adl by fahiem bacchus  who used it for the encoding of one of the versions of the
elevator domain used in ipc    i e  the      competition   we can now choose to leave it in
this language  necessitating a planning algorithm that can deal with conditional effects directly 
several existing planning systems  for example ff  hoffmann   nebel        and ipp  koehler 
nebel  hoffmann    dimopoulos         do this  it is a sensible approach since  as nebel       
proved  conditional effects cannot be compiled into strips without either an exponential blowup in the task description  or a linear increase in plan length  one might suspect here that  like
with steps     and     above  the exponential blow up can mostly be avoided in practice  the
airport move operator in figure   provides an example of this  all effect conditions are static and so
the conditional effects disappear completely once we instantiate the parameters  which is another
good reason for doing instantiation prior to the compilation  however  the conditional effects do not
disappear in many other  even very simple  natural domains  consider the following effect  taken
from the classical briefcaseworld domain 
 forall   o   when  in  o   and  at  o  to   not  at  o  from     

the effect says that any object  o that is currently in the briefcase moves along with the briefcase 
obviously  the effect condition is not static  and the outcome of the operator will truly depend on the
contents of the briefcase  note that the forall here means that we actually have a set of  distinct 
conditional effects  one for each object 
there are basically two known methods to compile conditional effects away  corresponding to
the two options left open by nebels        result  the first option is to enumerate all possible
combinations of effect outcomes  which preserves plan length at the cost of an exponential blow up
in description size  exponential in the number of different conditional effects of any single action 
consider the above briefcaseworld operator  and say that the object set is o            on   for every
subset o           o k of o            on   o k             o n being the complement of the subset  we get a distinct
operator with a precondition that contains all of 
 in o            in o k    not in o k            not in o n  

where the effect on the objects is 
 at o    to         at o k  to   not  at o    from          not  at o k  from  
   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

in other words  the operator can be applied  only  if exactly o           o k are in the briefcase  and it
moves exactly these objects  since  in deterministic planning as considered here  there never is
uncertainty about what objects are inside the briefcase and what are not  exactly one of the new
operators can be applied whenever the original operator can be applied  so the compilation method
preserves the size  nodes  and form  edges  of the state space  however  we wont be able to do the
transformation  or the planner wont be able to deal with the resulting task  if n grows beyond  say 
maximally              often  real world operators contain more distinct conditional effects than that 
the alternative method  first proposed by nebel         is to introduce artificial actions and
facts that enforce  after each application of a normal action  an effect evaluation phase during
which all conditional effects of the action must be tried  and those whose condition is satisfied
must be applied  for the above briefcaseworld example  this would look as follows  first  the
conditional effect gets removed  a new fact evaluate effects is inserted into the add list  and a
new fact normal is inserted into the precondition and delete list  then we have  n new operators 
two for each object oi   one means move along oi   the other means leave oi   the former has
in oi   in its precondition  the latter not in oi    the former has  at oi  to  and  not  at oi
 from  in its effect  both have evaluate effects in their precondition  and a new fact tried oi 
as an add effect  there is a final new operator that stops the evaluation  whose precondition is the
conjunction of evaluate effects and tried o            tried on   whose add effect is normal  and
whose delete effect is evaluate effects  if the conditional effects of several operators are compiled
away with this method  then the evaluate effects and tried oi  facts are made specific to each
operator  normal can remain a single fact used by all the operators  if an effect has k     facts in
its condition  then k leave oi  actions must be created  each having the negation of one of the facts
in its precondition 
nebels        method increases plan length by the number of distinct conditional effects of
the operators  note that this is not benign if there are  say  more than    such effects  to a search
procedure that recognizes what the new constructs do  the search space essentially remains the
same as before the compilation  but  while the artificial constructs can easily be deciphered for
what they are by a human  this is not necessarily true  is likely to not be the case  for a computer
that searches with some general purpose search procedure  just as an example  in a naive forward
search space there is now a choice of how to order the application of the conditional effects  which
could be avoided by enforcing some order with yet more artificial constructs   probably more
importantly  standard search heuristics are unlikely to recognize the nature of the constructs  for
example  without delete lists it suffices to achieve all of tried o            tried on  just once  and
later on apply only those conditional effects that are needed 
we conclude that if it is necessary to eliminate conditional effects  whenever feasible  one should
compile conditional effects away with the first method  enumerating effect outcomes  we did so in
ipc    we took ffs pre processor  that implements the transformation steps     to     above  and
extended it with code that compiles conditional effects away  optionally by either of the two described methods  we call the resulting tool adl strips   in most cases where we had a domain
version formulated in adl  we used adl strips to generate a strips formulation of that domain
version  in one case  a version of power supply restoration  we also generated a simple adl
   executables of adl strips can be downloaded from the ipc   web page at http   ipc icaps conference org  there is
also a download of a tool named ground  based on the code of the mips system  edelkamp      b   that takes in
the full syntax of pddl     hoffmann   edelkamp        and puts out a grounded representation  we did not have
to use the tool in ipc   since the temporal and numeric planners all had their own pre processing steps implemented  

   

fie ngineering b enchmarks

for

p lanning

formulation  in all cases but one  enumerating effect outcomes was feasible  the single exception was another version of power supply restoration where we were forced to use nebels       
method  details of this process  and exceptions where we did not use adl strips but some more
domain specific method  are described in the sections on the individual domains in appendix a 
    compilations of derived predicates
there are several proposals in the literature as to how to compile derived predicates away  under certain restrictions on their form or their use in the rest of the domain description  gazen  
knoblock        garagnani         a compilation scheme that works in general has been proposed
by thiebaux  hoffmann  and nebel               thiebaux et al  also proved that there is no compilation scheme that works in general and that does not  in the worst case  involve an exponential
blow up in either the domain description size or in the length of the plans  note here that exponential refers also to the increase in plan length  not just to the description blow up  unlike the
compilation of conditional effects discussed above  this makes the compilation of derived predicates a rather difficult task  in ipc    compilation schemes oriented at the approaches taken by
gazen and knoblock         and thiebaux et al                were used  we detail this below 
first  let us explain what derived predicates are  and how the compilations work 
derived predicates are predicates that are not affected by any of the operators  but whose truth
value can be derived by a set of derivation rules  these rules take the form  x   p  x   the
basic intuition is that  if  x  is satisfied for an instantiation c of the variable vector x  then p  c 
can be concluded  more formally  the semantics of the derivation rules are defined by negation as
failure  starting with the empty extension  instances of p  c  are derived until a fixpoint is reached 
the instances that lie outside the fixpoint are assumed to be false  consider the following example 
  derived  trans  x  y   or  edge  x  y    exists   z   and  edge  x  z   trans  z  y     

this derivation rule defines the transitive closure over the edges in a graph  this is a very typical
application of derived predicates  for example  above in the blocksworld is naturally formalized
by such a predicate  in our power supply restoration domain  transitive closure models the power
flow over the paths in a network of electric lines  obviously  the pairs  x and  y that are not
transitively connected are those that do not appear in the fixpoint  negation as failure 
matters become interesting when we think about how derived predicates are allowed to refer to
each other  and how they may be used in the rest of the task description  some important distinctions
are  can a derived predicate appear in the antecedent of a derivation rule  can a derived predicate
appear negated in the antecedent of a derivation rule  can a derived predicate appear negated in an
action precondition or the goal 
if derived predicates do not appear in the antecedents of derivation rules  then they are merely
non recursive macros  serving as syntactic sugar  one can simply replace the derived predicates
with their definitions   if a derived predicate p appears negated in the  negation normal form of the 
antecedent of a derivation rule for predicate q  then the fixpoints of p and q can not be computed
in an interleaved way  the extension of q may differ depending on the order in which the individual
instances are derived  say the rule for p is a x   p  x   where a is a basic predicate  and the rule
for q is p  x   q x   say we have objects a and b  and our current state satisfies  only  a a  
   if the derived predicates are recursive but cycle free  they can be replaced with their definitions but that may incure
an exponential blow up 

   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

computing the derived predicates in an interleaved way  we may derive a a   p  a   a b  
q b   and stop  we may also derive p  a   q a   a b   q b   a a   p  a   there is
a non monotonic behavior  making it non trivial to define what the extension of b is  to keep
things simple  after all the extensions of the derived predicates must be computed in every new
world state  thiebaux et al               propose to simply order q after p   that is  we compute
p s extension first and then compute q based on that  generalized  one ends up with a semantics
corresponding to that of stratified logic programs  apt  blair    walker         in the context of
ipc    i e   in pddl     hoffmann   edelkamp         for the sake of simplicity the use of negated
derived predicates in the antecedents of derivation rules was not allowed 
whether or not derived predicates appear negated in action preconditions or the goal makes
a difference for gazen and knoblocks        compilation scheme  the idea in that scheme is
to simply replace derivation rules with actions  each rule  x   p  x  is replaced with a new
operator with parameters x  precondition  x  and  add  effect p  x   actions that can influence the
truth value of   that affect any of the atoms mentioned in   delete all instances of p   in words 
the new actions allow the derivation of p   and if a normal action is applied that may influence the
value of p   then the extension of p is re initialized 
if derived predicates are not used negated  then gazen and knoblocks        compilation
scheme works  however  say p  c  is contained in some action precondition  in the compiled
version  the planner can achieve this precondition simply by not applying the derivation rule  the
action  that adds p  c   that is  the planner now has a choice of what predicate instances to derive 
which of course is not the same as the negation as failure semantics  the reader may at this point
wonder why we do not compile the negations away first  and thereafter use gazen and knoblocks
       compilation  the problem there would be the need for inverse derivation rules that work
with the negation as failure semantics  it is not clear how this should be done  say  for example  we
want to define the negated version of the  trans  x  y  predicate above  one would be tempted to
just take the negation of the derivation rule antecedent 
  derived  not trans  x  y   and  not edge  x  y   forall   z   or  not edge  x  z   not trans  z  y     

this does not work  however  say every node in the graph has at least one adjacent edge  starting
with an empty extension of  not trans  x  y   not a single instantiation can be derived  given any
x and y between which there is no edge  for those z that have an edge to x we would have to have
 not trans z y  in the first place 
one possible solution to the above difficulties is to extend gazen and knoblocks        compilation with constructs that force the planner to compute the entire extension of the derived predicates
before resuming normal planning  a full description of this  dealing with arbitrary derivation rules 
is described by thiebaux et al                in a nutshell  the compilation works as follows  one
introduces flags saying if one is in normal or in fixpoint mode  normal actions invoke the fixpoint mode if they affect any predicates relevant to the derivation rules  in fixpoint mode  an action
can be applied that has one conditional effect for each derivation rule  if the effect condition is true 
and the respective derived predicate instance is false  then that predicate instance is added  plus a
flag changes made  another action tests whether there has been a fixpoint  if changes made is
true  then the action just resets it to false  if changes made is false  then the action switches back
to normal mode  to reduce the domain to strips  after this compilation of derived predicates  the
negations and conditional effects must be compiled away with the techniques explained earlier 

   

fie ngineering b enchmarks

for

p lanning

one would imagine that thiebaux et al s              compilation  making use of rather complicated constructs  tends to confuse domain independent search techniques  indeed  thiebaux
et al               report that even a completely naive explicit treatment of derived predicates in
ff performs a lot better  in some benchmark domains  than the standard version of ff applied to
the compiled benchmarks  gazen and knoblocks        compilation makes use of less artificial
constructs  and is thus preferable whenever it can safely be applied  note  however  that both compilations imply a potentially exponential blow up in plan length  exponential in the arity of the derived
predicates  the worst case is that every action affects the derivation rules  and every re computation
of the extension of the derived predicates has to go through all those predicates instantiations  in
such a situation  between every pair of normal actions the planner has to apply on the order of  c a
actions  where a is the maximum arity of any derived predicate  while a is typically very small
 power supply restoration is the only domain we are aware of that features a derived predicate
with more than two  four  namely  arguments  even a plan length increase linear in the number of
objects can mean a quite significant decrease in planner performance 
of the ipc   benchmarks  derived predicates occur  only  in power supply restoration  appendix a    and model checking safety properties  appendix a     for the latter  where the derived
predicates do not occur negated  stefan edelkamp encoded a domain version without derived predicates by hand  using a method along the lines of the one described by gazen and knoblock        
for power supply restoration  where derived predicates do occur negated  we used a variation of the
method described by thiebaux et al                in both cases  due to the increase in plan length
we considered the resulting domain formulation too different from the original formulation to be directly compared with it  in terms of planner performance  so the compiled formulations were posed
to the competitors as distinct domain versions  instead of alternative domain version formulations 
indeed  just as we expected  planner results in ipc   were much worse for the compiled encodings 
    compilations of timed initial literals
timed initial literals are literals that are known to become true at time points pre specified in the
initial state  such literals can be compiled into durational pddl relatively easily  at the cost of
the plan length and the domain description size blowing up linearly in the number of timed initial
literals  the compilation was proposed and brought to our attention by fox  long  and halsey
        the idea is to use a wrapper action that must be applied before any other action  and
whose duration is the occurrence time of the last timed initial literal  the planner must also apply
a sequence of literal actions that achieve all the timed initial literals by order of occurrence 
the durations being the time intervals between the occurrences  when the wrapper action has
terminated  the literal actions can no longer be applied  so the planner is forced to apply them all
in direct sequence  this suffices to encode the desired semantics  consider the following example 
  init
 at    have to work  
 at     not  have to work   
 at     bar open  
 at     not  bar open    

to encode this in standard durational pddl  the wrapper will be 
  action wrapper
   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

 parameters   
 duration     duration    
 condition
 at start  no wrapper  
 effect
 and  at start  not  no wrapper   
 at start  wrapper started  
 at start  wrapper active  
 at start  literal   started  
 at end  not  wrapper active     

here  no wrapper ensures only one wrapper action is executed  wrapper started is inserted into
the precondition of every normal action and thus ensures that the wrapper is started before any other
action is executed  wrapper active will be a precondition of the literal actions  precisely  these
will be 
  action literal  
 parameters   
 duration     duration   
 condition
 and  over all  wrapper active  
 over all  literal   started   
 effect
 and  at end  not  literal   started   
 at end  literal   started  
 at end  have to work    
  action literal  
 parameters   
 duration     duration    
 condition
 and  over all  wrapper active  
 over all  literal   started   
 effect
 and  at end  not  literal   started   
 at end  literal   started  
 at end  not  have to work   
 at end  bar open    
  action literal  
 parameters   
 duration     duration   
 condition
 and  over all  wrapper active  
 over all  literal   started   
 effect
 and  at end  not  literal   started   
 at end  not  bar open   
 at end  literals done    

   

fie ngineering b enchmarks

for

p lanning

the fact literals done will be made a goal  so the planner must actually apply the literal actions 
note that we need only three of these actions here  since two of the timed initial literals  no
longer having to work and the opening of the bar  are scheduled to occur at the same time  note
also that  as with nebels        compilation of conditional effects and thiebaux et al s       
      compilation of derived predicates  the compiled encoding is likely to be confusing for domain
independent search methods 
many of the ipc   domains made use of timed initial literals  in some versions  to encode
various kinds of time windows  see appendix a   we compiled these domain versions into pure
 durational  pddl as above  and provided the resulting encodings as additional domain versions 
due to the increase in the number of actions needed for the plans  we figured that the compilation
constructs were too much of a change for direct comparison  indeed  as with the derived predicates 
planner results in ipc   were much worse for the domain versions compiled in this way 

   a summary of the domains
in this section we provide a brief summary of the ipc   domains  for each domain  we provide  a
short description of the application  our motivation for inclusion of the domain  a brief explanation
of the main simplifications made for ipc    and a brief explanation of the different domain versions
and formulations used in ipc    we proceed in alphabetical order 
    airport
we had a contact person for this application domain  wolfgang hatzack  who has been working in
this application area for several years  the domain was adapted for ipc   by jorg hoffmann and
sebastian trug
application  the task here is to control the ground traffic at an airport  timed travel routes must be
assigned to the airplanes so that they reach their targets  there is inbound and outbound traffic  the
former are airplanes that must take off  the latter are airplanes that have just landed and have to park 
the main problem constraint is  of course  to ensure the safety of the airplanes  this means to avoid
collisions  and also to prevent airplanes from entering the unsafe zones behind large airplanes that
have their engines running  the optimization criterion is to minimize the summed up travel time  on
the surface of the airport  of all airplanes   there usually are standard routes  i e   routes that any
airplane must take when outbound from a certain parking area  or inbound from a certain runway 
the reason for introducing such routes is to reduce complexity for human ground controllers  since
significant computer support is not yet available at real airports  solving instances optimally  the
corresponding decision problem  is pspace hard without standard routes  helmert      b  and
np complete if all routes are standardized  hatzack   nebel         in the latter case  we have a
pure scheduling problem  in the former case  complicated  but unrealistic  airport traffic situations
can lead to exponentially long solutions  see section     
motivation  our main motivation for including this domain was that we were able to model the
application quite accurately  and  in particular  to generate quite realistic instances  in fact  we
were able to generate instances based on a real airport  this was made possible by our contact
to wolfgang hatzack  who completed a phd about this application  hatzack         apart from
   an alternative criterion would be to minimize the summed up squared delay of all airplanes  this is in the interest
of the airlines  minimizing summed up travel time is in the interest of the airport  neither of the two can be easily
modelled in pddl     as we discuss in simplifications  below 

   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

developing domain specific solutions  hatzack   nebel         he developed a realistic simulation
tool  which he kindly supplied to us for the purpose of generating the ipc   domain versions and test
instances  sebastian trug implemented options inside the simulator that allowed it  at any point in
time during the simulation of traffic flow  to output the current traffic situation in pddl format  the
simulator included the real airports frankfurt  zurich  and munich  frankfurt and zurich proved too
large for our purposes  but we were able to devise competition instances based on munich airport 
simplifications  we had to make two simplifications  the first amounts to a discretization of space
 location  on the airport  making the domain amenable to pddl style discrete actions  with a
continuous space representation  one would need actions with a continuous choice of how far to
move  while the discretization loses precision  we believe that it does not distort the nature of
the problem too much  due to the amount of expected conflicting traffic at different points in the
airport  which is high only at parking positions  it is relatively easy to choose a discretization 
with segments of different length  that is precise and small enough at the same time  our second
simplification is more severe  we had to drop the original optimization criterion  which is very
awkward to express in current pddl  to model the travel times of the airplanes  one needs access
to the times at which the plans wait  i e   do nothing    we are not aware of a way to express this
in current pddl  the ipc   committee voted against the introduction of an additional language
construct  a look at the clock  since that didnt seem relevant anywhere else  another option
would be to introduce explicit waiting actions  which causes a lot of trouble because  similar to
continuous space  there must be a continuous choice of how long to wait  in the end  we decided
to just drop the criterion for now  and ask the planners to optimize standard makespan instead   
corresponding to the arrival time of the last airplane  meaning  arrival at the destination in the
airport   this is not ideal  but a reasonable optimization criterion  no planning system participating
in ipc    with the single exception of lpg td  gerevini  saetti    serina         was able to take
account of general optimization criteria other than the built in ones  like makespan   we did not use
full standard routes  thus allowing the airplanes a choice of where to move  we did use standards
for some routes  particularly the regions near runways in large airports  for one thing  this served
to keep large airports manageable for the pddl encoding and planners  for another thing  it seems
a good compromise of exploiting the capabilities of computers while at the same time remaining
close to existing practice 
versions and formulations  we generated four versions of the airport domain  a non temporal
one  a temporal one  a temporal one with time windows  where the fact that planes will land in the
future and block certain runways is modeled using timed initial literals  and the latter version  but
with timed initial literals compiled away  in all versions  the constraints ensuring airplane safety
are modelled with adl logical formulas  a compilation of these into partially grounded strips
provides  in each version  an alternative formulation  each domain version has one adl formulation
and one strips formulation 
    pipesworld
frederico liporace has been working in this application area for several years  he submitted a paper
on an early domain version to the workshop on the competition at icaps    the domain was
adapted for ipc   by frederico liporace and jorg hoffmann 
    the same difficulty arises in the modelling of delay  for which one must also compute the travel times 
    makespan  in planning  means the amount of time from the start of the plan until the last action stops executing 

   

fie ngineering b enchmarks

for

p lanning

application  here the task is to control the flow of different oil derivatives through a pipeline
network  so that certain product amounts are transported to their destinations  pipeline networks
are graphs consisting of areas  nodes  and pipes  edges   where the pipes can differ in length  the
available actions are to pump liquid into ends of pipes  with the effect that the liquid at the other end
of the pipe gets ejected  the application is rich in additional constraints  like  constraints on what
types of products may interface within a pipe  restricted tankage space in areas  and deadlines for
arrival of products 
motivation  our main motivation for including this domain was its original structure  if one inserts
something into a pipe at one end  something possibly completely different comes out of the pipe
at its other end  in this way  changing the position of one object directly results in changing the
position of several other objects  namely  all objects inside the affected pipeline  this is not the
case in any other transportation domain we are aware of  in fact it is more reminiscent of complicated
single player games such as rubiks cube  indeed  the strong interaction between objects can lead
to several subtle phenomena  for example  there are instances where any solution must pump liquid
through a ring of pipeline segments in a cyclic fashion 
simplifications  we had to severely simplify this domain in order to be able to solve reasonably
complex instances with current planners  most importantly  our encoding is heavily based on assuming a smallest indivisible unit of liquid  a batch  every amount of liquid in the encoding is modelled
in terms of a number of batches  to capture the continuous nature of the real application  this means
that one has to choose batch size in a trade off between encoding size and accuracy  the trade off
is less well behaved than the one in airport  choosing segments sizes  since the unit size cannot
be made flexible  every batch may pass through every pipeline  and so the smallest batch governs
the discretization of all pipelines  this is in contrast to airport  where segments may vary in size 
as another important simplification  we used personalized goals  i e  the goals referred to specific
batch objects rather than to product amounts  this serves to avoid large disjunctions enumerating
all possible combinations of individual batches  the simplifications are quite severe and indeed
it seems unlikely that a realistic representation of pipesworld  in particular with real valued product amounts instead of batches  could be solved efficiently by planners without introducing more
specialized language constructs  a sort of queue data structure  into pddl  see appendix a     
versions and formulations  we created six different versions of pipesworld  four versions with  
without temporal actions  and with without tankage restrictions  respectively  one temporal version
without tankage restrictions but with arrival deadlines for the goal batches  one version identical to
the last one except that timed initial literals were compiled away 
    promela
this domain was created for ipc   by stefan edelkamp 
application  here the task is to validate properties in systems of communicating processes  often
communication protocols   encoded in the promela language  promela  process meta language 
is the input language of the model checker spin  holzmann         the language is loosely based
on dijkstras guarded command language  borrowing some notation from hoares csp language 
one important property check is to detect deadlock states  where none of the processes can apply
a transition  for example  a process may be blocked when trying to read data from an empty
communication channel  edelkamp      a  developed an automatic translation from promela into
pddl  which was extended to generate the competition examples 

   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

motivation  our main motivation for including this domain was to further promote and make visible the important connection between planning and model checking  model checking  clarke 
grumberg    peled        itself is an automated formal method that basically consists of three
phases  modeling  specification and checking  in the first two phases both the system and the correctness specification are modeled using some formalism  the last step automatically checks if the
model satisfies its specification  roughly speaking  this step analyzes the state space of the model to
check the validity of the specification  especially in concurrent systems  where several components
interact  state spaces grow exponentially in the size of the components of the system  there are two
main research branches in model checking  explicit state model checking  as implemented in spin 
exploits automata theory and stores each explored state individually  while symbolic model checking
describes sets of states and their properties using binary decision diagrams  bdds  or other efficient
representations for boolean formulas 
checking the validity of a reachability property  a property that asks if a system state with a certain property is reachable  is very similar to the question of plan existence  the use of model checking approaches to solve planning problems has been explored in some depth  e g  by cimatti  roveri 
and traverso         bertoli  cimatti  roveri  and traverso         lago  pistore  and traverso
        kvarnstrom  doherty  and haslum         bacchus and kabanza         holldobler and
stor         fourman         edelkamp      b   dierks         kabanza and thiebaux        
however  not much has been done in the inverse direction  applying planners to model checking
problems  running ipc   planners on planning encodings of promela specifications is a first step
in doing just that 
the promela domain also contributes unusual structural properties to our domain set  the computational complexity and local search topology are quite different as will be discussed in section   
simplifications  the main simplification we had to make was to use very simple example classes
of communicating processes  as pddl models refer to fixed length state vectors  we could not
include process construction calls  we therefore only considered active processes  i e   processes
that are called only once at initialization time  pddl also does not support temporally extended
goals  so we had to consider reachability properties only  moreover  by the prototypical nature of
our language compiler  many features of promela such as rendezvous communication were not supported  although we have limited support of shared variables  during the competition we chose
simple message passing protocols only  and while we experimented with other reachability properties  the pddl goals in the competition event were on deadlock detection only  concretely  the
ipc   instances come from two toy examples used in the area of model checking  the well known
dining philosophers problem  and an optical telegraph problem which can be viewed as a
version of dining philosophers where the philosophers have a complex inner life  exchanging data
between the two hands  each of which is a separate process   in both  the goal is to reach a deadlock
state 
versions and formulations  we created eight different versions of the domain  they differ by the
promela example class encoded  two options   by whether or not they use numeric variables in the
encoding  and by whether or not they use derived predicates in the encoding  the four encodings
of each promela example class are semantically equivalent in the sense that there is a   to   correspondence between plans  we decided to make them different versions  rather than formulations 
because derived predicates make a large difference in plan length  and numeric variables make a
large difference in applicability of planning algorithms systems  the translation from promela to

   

fie ngineering b enchmarks

for

p lanning

pddl makes use of adl constructs  so each domain version contains one adl formulation and
one  fully grounded  compiled strips formulation 
    psr
sylvie thiebaux and others have worked on this application domain  the domain was adapted for
ipc   by sylvie thiebaux and jorg hoffmann 
application  the task in psr  power supply restoration  is to reconfigure a faulty power distribution network so as to resupply customers affected by the faults  the network consists of electric
lines connected by switches and fed via a number of power sources that are equipped with circuitbreakers  when faults occur  the circuit breakers of the sources feeding the faulty lines open to
protect the network  leaving not only these lines but also many healthy ones un supplied  the network needs to be reconfigured by opening and closing switches and circuit breakers in such a way
as to resupply the healthy portions  unreliable fault sensors and switches lead to uncertainty about
the state of the network  furthermore  breakdown costs that depend on various parameters need to
be optimized under constraints on the capacity of sources and lines  the application is a topic of ongoing interest in the field of power distribution  and has been investigated by the ai community for
a long time  including from an ai planning standpoint  thiebaux  cordier  jehl    krivine       
thiebaux   cordier        bertoli  cimatti  slaney    thiebaux        bonet   thiebaux        
motivation  our motivation for including psr was twofold  first  it is a well researched interesting
application domain  second  it has an original structure rarely found in previous benchmarks  the
most natural encoding models the power propagation using recursive derived predicates that compute the transitive closure of the connectivity relation in the network  in contrast with most other
planning benchmarks  the number of actions needed in an optimal plan does not necessarily grow
with instance size  the available actions are to alter the position of switches  and even in a large
network altering the position of just a few switches may suffice for reconfiguration  the difficult
question to answer is  which switches 
simplifications  three major simplifications had to be made  first  for deterministic planning we
had to assume that the network state is fully observable  i e   that the initial state description is
complete  and that the actions always succeed  second  we ignored all numerical and optimization
aspects of psr  third  we used personalized goals in the sense that the lines to be supplied are named
explicitly in the goal  note that  even in this simplified form  the domain exhibits the structure
explained above 
versions and formulations  we created four domain versions  differing primarily by size and
available formulations  the most natural domain formulation is in adl with derived predicates 
though we experimented with many combinations of pddl encodings and compilation strategies 
the size of the instances that we could compile into simpler languages was quite restricted  precisely 
the versions are  a large version in adl plus derived predicates  a middle version that we
could devise also in simple adl plus derived predicates and in strips plus derived predicates 
a middle compiled version in adl  identical to the middle version except that the derived
predicates were compiled away  and a small version in pure strips  the instances in the latter
domain version had to be particularly small  since it was extremely difficult to come up with an
encoding in pure strips that did not either yield prohibitively long plans  or prohibitively large
pddl descriptions  in fact  to obtain the small version we applied a pre computation step  bertoli
et al         that obviates the need for reasoning about power propagation and  consequently  the

   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

need for derived predicates  in the resulting tasks  opening or closing a switch directly  without the
detour to power propagation  affects other parts of the network  thus the planner no longer needs
to compute the flow of power through the network  but is left with the issue of how to configure that
flow 
    satellite
this domain was introduced by long and fox        for ipc    it was adapted for ipc   by jorg
hoffmann  the domain comes from a nasa space application  where satellites have to take images
of spatial phenomena  our motivation for inclusion in ipc   was that the domain is applicationoriented in a similar sense to the new domains  also  we wanted to have some immediate comparison between the performance achieved at ipc    and that achieved at ipc    on top of the   domain
versions used in ipc    we added   new versions  introducing additional time windows  formulated
alternatively with timed initial literals or their compilation  for the sending of data to earth 
    settlers
this domain was also introduced by long and fox        for ipc    the task is to build up an
infrastructure in an unsettled area  involving the building of housing  railway tracks  sawmills  etc 
the distinguishing feature of the domain is that most of the domain semantics are encoded in numeric variables  this makes the domain an important benchmark for numeric planning  for that
reason  and because at ipc   no participant could solve any but the smallest instances  we included
the domain into ipc    no modification was made except that we compiled away some universally
quantified preconditions in order to improve accessibility 
    umts
roman englert has been working in this application area for several years  the domain was adapted
for ipc   by stefan edelkamp and roman englert 
application  the third generation of mobile communication  the so called umts  holma  
toskala         makes available a broad variety of applications for mobile terminals  with that
comes the challenge to maintain several applications on one terminal  first  due to limited resources  radio bearers have restrictions in the quality of service  qos  for applications  second  the
cell setup for the execution of several mobile applications may lead to unacceptable waiting periods
for the user  third  the qos may be insufficient during the call setup in which case the execution
of the mobile application is shut down  thus arises the call setup problem for several mobile applications  the main requirement is  of course  to do the setup in the minimum possible amount of
time  this is a  pure  scheduling problem that necessitates ordering and optimizing the execution of
the modules needed in the setup  as for many scheduling problems  finding some  not necessarily
optimal  solution is trivial  the main challenge is to find good quality solutions  optimal ones ideally 
motivation  our main motivation for modelling this pure scheduling problem as a planning domain
was that there is a strong industrial need for flexible solution procedures for the umts call setup 
due to the rapidly evolving nature of the domain  particularly of the sorts of mobile applications that
are available  the ideal solution would be to just put an automatic planner on the mobile device 
and let it compute the optimized schedules on the fly  in that sense  umts call setup is a very
natural and promising field for real world application of automatic planners  this is also interesting

   

fie ngineering b enchmarks

for

p lanning

in the sense that scheduling problems have so far not been central to competitive ai planning  so
our domain serves to advertise the usefulness of pddl for addressing certain kinds of scheduling
problems 
simplifications  the setup model we chose only considers coarse parts of the network environment
that are present when umts applications are invoked  action duration is fixed rather than computed
based on the network traffic  the inter operational restrictions between different concurrent devices
were also neglected  we considered plausible timings for the instances rather than real application
data from running certain applications on a umts device  we designed the domain for up to
   applications on a single device  this is a challenge for optimal planners computing minimum
makespan solutions  but not so much a challenge for satisficing planners 
versions and formulations  we created six domain versions  these arise from two groups with
three versions each  the first group  the standard umts domain  comes with or without timing
constraints  the latter can be represented either using timed initial literals  or their compilation  as
before  we separated these two options into different domain versions  rather than domain version
formulations  due to the increase in plan size  the second group of domain versions has a similar
structure  the only difference is that each of the three domain versions includes an additional flaw
action  with a single step  that action achieves one needed fact  where  normally  several steps are
required  however  the action is useless in reality because it deletes another fact that is needed  and
that cannot be re achieved  the flaw action was added to see what happens when we intentionally
stressed planners  beside increasing the branching factor  the flaw action does look useful from the
perspective of a heuristic function that ignores the delete lists 

   known  theoretical  results on domain structure
in this section  we start our structural analysis of the ipc   domains by summarizing some known
results from the literature  helmert      b  analyzes the domains from a perspective of domainspecific computational complexity  hoffmann        analyzes all domains used in the ipcs so far 
plus some standard benchmarks from the literature  identifying topological properties of the search
space surface under the relaxed plan heuristic that was introduced with the ff system  hoffmann
  nebel         and variants of which are used in many modern planning systems  both studies are
exclusively concerned with purely propositional  non temporal strips and adl  planning  in
what follows  by the domain names we refer to the respective  non temporal  domain versions   
    computational complexity
helmert      b  has studied the complexity of plan existence and bounded plan existence for the
ipc   benchmark problems  plan existence asks whether a given planning task is solvable  bounded
plan existence asks whether a given planning task is solvable with no more than a given number of
actions  helmert established the following results 
in airport  both plan existence and bounded plan existence are pspace complete  even when
all aircraft are inbound and just need to taxi to and park at their goal location  the map is planar
and symmetric  and the safety constraints simply prevent planes from occupying adjacent segments 
    the umts domain  which has only temporal versions  is not treated in either of the studies  as for computational
complexity  it is easy to see that deciding plan existence is in p and deciding bounded plan existence  optimizing
makespan  is np complete for umts  topological properties of the relaxed plan heuristic havent yet been defined
for a temporal setting 

   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

the proof is by reduction from the sliding tokens puzzle  where a set of tokens must reach a goal
assignment to the vertices of a graph  by moving to adjacent vertices while ensuring that no two
tokens ever find themselves on adjacent vertices  the length of optimal sequential plans can be
exponential in the number of tokens  and so likewise in the airport domain  even parallel plans can
only be shorter by a linear amount  since each plane can move at most once per time step  the proof
for the sliding tokens puzzle is quite complicated because it involves construction of instances
with exponentially long optimal plans  as one would expect  the constructions used are more than
unlikely to occur on a real airport  this is in particular true for the necessary density of conflicting
traffic on the graph structure  we consider this interesting since it makes airport a benchmark
with an extremely high worst case complexity  but with a much more good natured typical case
behavior  typically  there is ample space in an airport for  comparatively  few airplanes moving
across it 
in pipesworld  whether with or without tankage  both plan existence and bounded plan existence are np hard  it is unknown whether they are in np  however  the np hardness proof is by
reduction from sat with at most four literals per clause and where each variable occurs in at most
  clauses  such a sat instance is reduced to a network in a way so that parts of the network  variable subnetworks  represent the choice of an assignment for each of the variables  and other parts
 clause subnetworks  represent the satisfaction of each of the clauses  the content of areas and pipes
are initialized with batches in a way so that interface restrictions will guarantee that a goal area is
reached by a certain batch in each clause subnetwork iff the clause is satisfied by the assignment 
for general promela planning  as defined by edelkamp      a   both plan existence and bounded
plan existence are pspace complete  the pspace hardness proof is by reduction from the halting problem in space restricted turing machines  tm   the cells of the machines tape are each
mapped onto a process and a queue of unit capacity  the states of the tm form the set of promela
messages  the tms alphabet form the set of promela states in all processes  and the promela transitions encode the tms transitions  it can be shown that the tm halts iff the promela task reaches
a deadlock 
dining philosophers  on the other hand  has a particular structure where there is one process per
philosopher  all with the same transition graph  optimal plans can be generated in linear time in the
number of philosophers by making a constant number of transitions to reach the same known state
in each of the graphs  similar considerations apply to optical telegraph 
psr tasks can also be solved optimally in polynomial time  but this requires a rather complex
algorithm  all plans start with the wait action which opens all circuit breakers affected by a fault  in
their simplest form  optimal plans will follow by prescribing a series of actions opening all switches
connecting a feedable line to a faulty one  this is necessary but also sufficient to ensure that the
network is in a safe state in which no faulty line can be re supplied  then a minimal set of devices
 disjoint from the previous one  must be closed so as to resupply the rest of the network  this can
be achieved by generating a minimal spanning tree for the healthy part of the network  which can
be done in polynomial time 
figure   gives an overview of these results and summarizes helmerts        results for other
standard benchmarks  the domain set displayed is the same set as investigated by hoffmann        
with a few minor differences explained shortly  blocksworld no arm  briefcaseworld  ferry  fridge 
simple tsp  and tireworld are traditional planning benchmarks that were never used in an ipc   
    blocksworld no arm is the version of blocksworld where blocks can be moved directly to their destination  without
referring to a robot arm  simple tsp was used by  fox   long        to demonstrate the potential of symmetry

   

fifor

p lanning

pspace

e ngineering b enchmarks

promela
airport

p

plan existence

np

pipesworld
mystery
mprime
miconicadl
freecell

tireworld
simpletsp
schedule
psr
opticaltelegraph
movie
gripper
fridge
ferry
diningphil 

zenotravel
satellite
rovers
miconicstrips
miconicsimple
logistics
grid
driverlog
depots
briefcaseworld
blocksworldnoarm
blocksworldarm

p

np

pspace

bounded plan existence

figure    an overview of helmerts results on the computational complexity of the benchmarks 
the ipc   benchmarks are assembly  grid  gripper  logistics  movie  mprime  and mystery  the
ipc   benchmarks are blocksworld arm  freecell  logistics  miconic adl  miconic simple 
miconic strips  miconic is schindler lifts name for the elevator domain   and schedule  the
ipc   benchmarks are depots  driverlog  freecell  rovers  satellite  and zenotravel  the ipc  
benchmarks are displayed in bold face  including the  hypothetical  general promela domain 
the table in figure   is organized along two axes  where the x axis shows the complexity of
deciding bounded plan existence  and the y axis shows the complexity of deciding  unbounded  plan
existence  membership in a table entry means  for the np and pspace rows and columns  that the
respective problem is complete for the respective complexity class  an exception is the pipesworld
domain  for which  as stated above  it is still unknown whether the two decision problems are also
members of np  the assembly domain is not displayed since  there  helmert        proved only
the existence of exponentially long optimal plans  showing that plan generation can be quite hard in
the domain  the table sectors above the diagonal are crossed out because unbounded plan existence
can be polynomially reduced to bounded plan existence  just set the bound to  n   where n is the
number of distinct actions  or  in adl  the number of distinct conditional effects 
the most striking new feature of ipc   is the introduction of pspace complete benchmark
domains  filling in the top right corner of figure    thus  the benchmarks cover all four inhabited
sectors of the table  of the previous ipcs  each of ipc   and ipc   cover three sectors  all inhabited
detection  one simply has to visit n nodes  using a move action that can be applied between any two nodes  so that
any permutation of the nodes is an optimal tour  hoffmann        also investigates the towers of hanoi domain 

   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

sectors except the top right corner  and the ipc   benchmarks cover only two sectors  namely 
bounded plan existence is np complete for all these domains  and all the domains except freecell
have a polynomial time algorithm deciding unbounded plan existence 
the ipc   benchmarks are exceptional in further aspects not visible in figure    most particularly  as explained above  the polynomial decision algorithm for psr is highly non obvious  such
benchmarks are important since  on the one hand  they in principle allow planners to provide efficient solutions  while  on the other hand  necessitating that they employ interesting techniques for
doing so    schedule is the only other polynomial benchmark for which bounded plan generation
requires a non obvious algorithm  for all the other    domains in the left bottom and middle bottom
sectors of the table  the polynomial algorithms  deciding bounded or unbounded plan existence 
are completely trivial  mostly just addressing one subgoal at a time 
as was pointed out already  a final exception lies in the extraordinarily large difference between
worst case and typical case behavior in airport  as we will see in section    even fully automated
methods  the ipc   planners  are  at least for unbounded plan existence  generation   quite efficient
in typical instances of this domain  while large differences between worst case and typical case
behavior are not unusual  we believe that the extent of this phenomenon in airport really is unusual 
for example  planners tend to find psr much harder than airport 
    the topology of h 
hoffmann        considers the state spaces  the forward search spaces  of strips and adl tasks
taken from standard benchmark domains  he defines  given such a task and a world state s  h   s 
to be the length of a shortest possible relaxed plan  or  if there is no relaxed plan  a relaxed plan
is a plan that achieves the goal from s if one assumes that the delete lists are all empty  computing
h   the corresponding decision problem  is np hard  bylander         many modern planners 
e g   hsp  bonet   geffner         ff  hoffmann   nebel         sgplan  wah   chen       
chen  hsu    wah         yahsp  vidal         and fast diagonally downward  helmert       
    a   can be interpreted as doing some sort of heuristic search with an approximation of h    plus
further techniques like problem decomposition  wah   chen         lookahead techniques  vidal 
       and additional different heuristic functions  helmert         in this context  a question of
great practical interest is the quality of the underlying heuristic function in the addressed domains 
heuristic quality can be measured in terms of topological properties of the search space surface 
how many local minima are there  how large are they  what about flat regions  hoffmann       
investigates these questions for the h  function  for which topological properties of the search space
surface can be proven 
hoffmann defines topological phenomena following frank  cheeseman  and stutz         he
identifies several parameters that show particularly interesting behavior in planning benchmarks  a
dead end is a world state that is reachable from the initial state but from which the goal state cannot
be reached  an unrecognized dead end is a dead end s for which h   s      the exit distance
from a state s is the length of a shortest path in the state space leading from s to some other state s   
so that h   s    h   s     and s  has a direct neighbor state s   with h   s       h   s     that is  the
exit distance from s is the number of steps we need to go from s in order to find a better state  s     
    in helmerts        words  i think that domains that can be solved in polynomial time but where polynomial
algorithms are not obvious are extraordinarily interesting  deterministic psr definitely is a domain of that kind
with regard to optimization  np hard problems cannot be solved without strong reliance on search  but polynomial
problems can  if the planners capture the important concepts 

   

fie ngineering b enchmarks

for

p lanning

minus   since the distance to s  is measured  here  s  plays the role of an exit state as used by
frank et al          a state lies on a local minimum if all paths to an exit have a temporary increase
in the heuristic value  otherwise the state lies on a bench  the maximal local minimum exit distance
 mlmed   for a state space  is the maximum over the exit distances of all states lying on local minima
in the state space  similarly  the maximal bench exit distance  mbed  is the maximum over the exit
distances of all states lying on benches  the core results of hoffmanns        investigation are
displayed in figure   

blocksworldarm
depots
driverlog

pipesworld
psr

rovers
opticaltelegraph

mystery
mprime
miconicadl
freecell
assembly
airport

mbed    c

mlmed    c

hanoi    
blocksworldnoarm    
fridge    
briefcaseworld    
grid    

logistics      
ferry      
gripper      
undirected

tireworld      
satellite      
zenotravel      
miconicsimple      
miconicstrips      
movie      
simpletsp      
harmless

diningphil         
schedule      

recognized

unrecognized

figure    an overview of hoffmanns results on the topology of h  in the benchmarks 
the x axis in figure   corresponds to properties regarding dead ends  the y axis corresponds to
properties regarding the exit distance from local minima and benches  the domains are assigned to
the appropriate table sectors  classes of domains  depending on the worst case behavior possible
in them  in more detail  the meaning of the table is the following  a state space is undirected if
every transition  action  can be directly inverted  the state space is harmless if such an inversion
is not possible  but there are no dead ends anyway  recognized means that there are dead ends  but
h  is  for all of them  unrecognized means that there is at least one unrecognized dead end  a
domain falls into the class of its worst case instance  for example  if there is a single instance whose
state space contains a single unrecognized dead end  then the domain is considered unrecognized 
the results are proved  i e   if a domain is  for example  considered harmless  then this means that
provably no instance of the domain contains any dead ends 
on the y axis in figure    the distinction lines correspond to the existence or non existence of
constant upper bounds on the maximal local minimum exit distance  upper line  and on the maximal
bench exit distance  lower line   note that constant upper bounds on the maximal local minimum
exit distance exist in all domains below the upper line  in the domains below the lower line  both
bounds exist    by constant  it is meant here that the bound is valid for every instance of the
    this presentation assumes that the domains with bounded bench exit distance are a subset of those with bounded
local minimum exit distance  this is not true in general  but does hold in all the considered benchmark domains 

   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

domain  regardless of its size  the actual bounds proved are displayed in brackets  local minimum
bound precedes bench bound in the cases where there are both  the right bottom part of the table
is crossed out since unrecognized dead ends have infinite exit distance and so these domain classes
are empty   
the obvious intuition behind figure   is that there is a transition from easy to hard  for
planning systems based on heuristic search approximating h   as one moves from the left bottom
side to the top right side of the table  indeed  the table does  in that sense  coincide very well with
the empirical behavior of  at least  the ff system  note how extreme the topological behavior is
in many domains  if the upper bound on the local minimum exit distance is   then this means that
there are no local minima at all  this is the case in    of the    investigated domains  in several
domains  such as the widely used logistics benchmark  on top of that a single step suffices to reach
an exit from benches  hoffmann        shows that ff would be polynomial in the bottom classes
of the table  provided with an oracle computing h   
considering the table from a perspective of benchmark development  one notices that particularly the older benchmarks tend to lie on the left bottom side  consider for example ferry  briefcaseworld  fridge  simple tsp  and tireworld  the distribution of the ipc   benchmarks  gripper 
logistics  movie  grid  assembly  mystery  and mprime  is somewhat extreme  the first four in
our list here belong to the most simple classes  the last three belong to the hardest class  until today 
the mystery and mprime domains are amongst those causing planners the most trouble   in the
ipc   benchmarks  logistics  blocksworld arm  miconic strips  miconic simple  schedule 
freecell  and miconic adl  again  we have many simple and a few very challenging domains 
the most notable exceptions in that respect are blocksworld arm  on the left top side of the table 
and schedule  which does contain dead ends and local minima  in the ipc   benchmarks  the distribution starts to get more varied  the domains  zenotravel  satellite  depots  driverlog  rovers 
and freecell  span three of the four top classes in the table  plus one of the bottom classes  the
ipc   domains  shown in bold face  obviously continue this development  the only two of them
sharing a class are pipesworld and psr    they continue the emphasis on spanning the top classes
in the table  the only new domain in one of the bottom classes is dining philosophers  and that is
highly exceptional in that is has an exceedingly large bound  making the bound practically useless
for exploitation in planning    the satellite domain adopted from the ipc   benchmarks serves to
represent  a more interesting instance of  the easier classes  note that satellite is so simple here
because we are talking about the strips version  which drops the more challenging problem constraints formulated with numeric variables  the airport domain is exceptional in the top right class
in that  again  its worst case  its place in figure    differs a lot from its typical case  a dead
end in airport is a situation where two airplanes completely block each others paths    of course 
practical airports are designed in a way so that this doesnt usually happen  as mentioned earlier 
there usually are  non overlapping  as far as possible  standard routes  and the only place where
blocking can occur is in densely populated areas near parking positions 
    one could skip unrecognized dead ends from the definition of the maximum exit distances  but hoffmann       
argues that this is un intuitive  plus making things unnecessarily complicated 
    actually  pipesworld is invertible in the sense that every two step sequence  starting and ending a pumping operation 
can be directly undone  it is considered harmless here since the single actions cannot be inverted 
    indeed  h  is a very bad heuristic in dining philosophers  it basically comes down to counting the number of
unsatisfied goals 
    the relaxed plan can use free space in between the planes to make them move across each other 

   

fie ngineering b enchmarks

for

p lanning

   new  empirical  results on domain structure
we now provide an empirical analysis of various structural parameters of the ipc   domains  for the
sake of readability and conciseness  we focus on the non temporal domain versions only  for most
types of data we measure  the results for the temporal domain versions are quite similar  to some
extent  this is visible in the tables showing numbers of actions and facts  for all domain versions  in
the individual domain descriptions in appendix a 
our empirical analysis is aimed at highlighting further characteristics of  and differences between  the ipc   domains  apart from focussing on more practical parameters  the analysis has 
compared to the theoretical results cited in the previous section  the big advantage that it tells us
something about the actual instances run in the competition  note that the choice of instances can
make a huge difference  for example  as stated earlier  a real world airport is not very likely to have
exponentially long plans  and neither is it likely to provoke many dead end situations  where possible at all  the instances used in ipc   were chosen to be relatively realistic  details in appendix a  
the analysis is structured into three sub sections  section     shows how  in the individual
domains  the size of the grounded encoding grows over instance size  section     assesses the
correspondence between the quality of standard heuristic functions  and the runtime achieved in
ipc    section      finally  assesses the fact connectivity over instance size  meaning the number
of choices one has to achieve each fact  and the number of actions a fact is required for 
    encoding size
all current strips and adl planners  as far as the authors are aware  ground all parameters
and variables in a pre process  ending up with a task representation consisting of ground facts and
ground actions  an obvious question to ask is how large these grounded encodings are  figure  
shows our data  numbers of facts and actions plotted over instance size for  selected versions of  the
different domains  the numbers are measured using ffs pre processor  this filters out static facts
 facts that are not added or deleted by any action  and unreachable actions  meaning actions that
do not appear in a relaxed planning graph  a planning graph without mutex reasoning  for the initial
state  hoffmann   nebel         formulas are compiled into simple strips like conjunctions of
facts  along the lines of gazen and knoblock        as outlined in section   
      

 e   
airport
pipesworld
dining philosophers
optical telegraph
psr small
psr large
satellite
umts

     

airport
pipesworld
dining philosophers
optical telegraph
psr small
psr large
satellite
umts

      

nr  actions

nr  facts

     
    

    

   
   

  

  
 

  

  

  

  
  
nr  instance

  

  

  

  

 

  

  

  

  
  
nr  instance

  

  

  

  

 a 
 b 
figure    numbers of  a  ground facts and  b  ground actions  plotted over instance number  in
selected versions of the ipc   domains 
   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

in all cases except umts  that has only temporal versions   the domain version selected for
figure   is non temporal  let us consider the domains one by one  in airport  there is just one
non temporal version  the plots in figure    a  and  b  show us quite nicely how the instances are
scaled  with sharp drops in the curves corresponding to steps to a new underlying airport  precisely 
instances   to      to       to        to     and    to    are based on growing airports  respectively 
and within each airport the number of travelling airplanes grows from just   or   until up to     in
instance      for example  from instance    to instance    we step from one half of munich airport 
with    airplanes  to the full munich airport  with just   airplanes 
in pipesworld  there are two non temporal versions  with and without tankage restrictions  figure   shows data for the former  which is the more challenging one  the ipc   planners fared much
worse on it   without tankage restrictions  there are slightly fewer facts  and about a factor of     fewer actions  the pipesworld instances are scaled in a similar way as the airport ones  five
growing pipeline networks each feature a growing number of travelling liquid batches  the networks underlie the instances   to        to        to        to     and    to     respectively 
corresponding drops can be observed when stepping from instance    to     and  less significantly 
when stepping from    to    or from    to     a major difference to airport is visible in the
much more crippled nature  featuring much more variance  of the curve for the number of actions 
this is because  in airport  few objects move on a big spacious structure  while  in pipesworld 
many objects move within a rather dense space    this fundamental difference between airport and
pipesworld also manifests itself in that the order of curves is reversed for the numbers of facts and
actions  in airport  extraordinarily many facts are required to describe the huge airport structure 
while in pipesworld there are fewer facts for a smaller structure  but many more actions describing
how things move along that structure  as stated earlier  in pipesworld  different objects affect each
others position when moving 
in the promela domains  dining philosophers and optical telegraph  the data for the domain
versions with and without derived predicates are identical  if a derivation rule deriving a fact is
counted as an action achieving the fact  the main difference to what we have seen before lies in
the extremely smooth scaling  both domains have just a single size parameter  and the numbers of
ground facts and actions grow as linear functions in that parameter  the functions for optical telegraph being about an order of magnitude higher than those for dining philosophers  the curves for
optical telegraph stop at instance    because after that we were not able to compute the grounded
representation  too much time and memory were needed in the simplification of precondition formulas  note that this is not an artifact of our data presentation  but rather constitutes a serious
limitation to any planner that tries to perform such pre processing 
in psr  the most interesting domain versions are small  since that could be formulated in
strips  and large  since that goes up to instances of a realistic size  in the largest instances  that
is   as the name small suggests  the numbers are quite small  to be able to compile into strips 
as indicated earlier we had to make the instances very small    essentially the same compilation
problem is also visible in the curves for large  that have a huge number of ground facts and actions
in relatively early instances already  the curves stop at instance    because beyond that  simplifying
    how much the objects can or cannot move affects also the number of ground actions due to the mentioned filtering
of unreachable actions 
    the only notable exception is instance nr      where the number of actions peaks to       this is due to an exceedingly complex goal formula  with      disjuncts in its dnf  of which each yields an extra goal achievement action 
c f  section   

   

fie ngineering b enchmarks

for

p lanning

formulas becomes extremely costly  in both versions  we note a high degree of variance both in the
numbers of facts and actions  which somewhat corresponds to the huge degree of variance to be
observed for planner performance in this domain  see figure     part of this variance  at least
the pace of the oscillations if not their amplitude  can be explained by the way the instances are
scaled  for a given number of sources  the instance size   we generated instances with an increasing
minimal number of switches originally fed by a given source  and for a given number of switches 
we generated instances with an increasing percentage of faulty lines ranging from     to     
intuitively  the larger the number of switches per source  the larger and harder we expect the instance
to be  furthermore  the percentage of faulty lines tends to induce an easy hard easy pattern  if most
lines are faulty  only a small part of the network can be resupplied and only a few devices need
to be switched  similarly  if a very few faulty lines exist  most of the network can be resupplied
with a few switching operations  with an intermediate percentage  the effects of the actions become
more complex  they are conditioned on the positions of many other switches  and so the instances
become critically constrained and harder to solve 
in satellite  the main observation to be made is the extremely steep ascent of the curves after
instance     particularly the growth to extremely high numbers of actions  there are two reasons for
this  first  one action in satellite  take image  has   parameters and is reachable for almost any
combination of objects with the correct types  most of the time  actions have only   or   parameters  
second  the size of the instances themselves grows very sharply beyond instance     which  simply 
is because instances    to     as used in ipc    correspond to the    instances posed in ipc   to
challenge the hand tailored planners 
we do not consider settlers here to ease readability of the graphs  and since that domain is
quite obviously exceptional anyway  in that it relies almost completely on numeric variables  for
umts  figure   shows data for the plain domain version without time windows and flaw action 
the obvious characteristic is that the numbers of facts and actions are constants  this is true for all
domain versions  the numbers vary only slightly  the reason is that  the way the umts instances
are scaled  every instance describes the same applications and requirements  what changes is  only 
the goal  specifying what applications actually need to be set up  independent of this effect of the
particular scaling method used  we can observe that the numbers of facts and actions are relatively
low  around only     even in the largest instances  where all the applications must be set up  and
the plans contain all the actions 
    quality of heuristics  and runtime
in this section  we measure the length of the best  sequential and parallel  plans found by any
planner  the  sequential and parallel  plan length estimates returned by the most common heuristic
functions  and the runtime taken by the planners  precisely  for the optimal planners  we measure 
 the optimal makespan  as found by the ipc   parallel optimal planners  planners optimizing
makespan  
 the length of a standard plan graph  blum   furst         i e   the index of the first plan
graph layer that contains the goals without mutexes 
 the best runtime taken by any parallel optimal planner in ipc   
 the optimal sequential plan length  as found by the ipc   sequential optimal planners 
   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

 the length of a serialized plan graph  where any pair of non noop actions is made mutex 
 the best runtime taken by any sequential optimal planner in ipc   
for the satisficing planners  we measure 
 the best  shortest  plan length  as found by any planner in ipc   
 the length of a relaxed plan for the initial state  an action sequence that solves the task if one
assumes all delete lists are empty  computed with ff  hoffmann   nebel         
 the best runtime taken by any satisficing planner in ipc   
our main goal will be to identify characteristic behavior of domains  and to identify characteristic
effects of heuristic quality on performance  the reader will note that  in our selection of measurements  we make several simplifying assumptions  optimal planners are not exclusively based on
plan graph estimates  satisficing planners are not exclusively based on relaxed plan estimates  further  some of the satisficing planners minimize makespan  not sequential plan length  we chose to
not take account of the latter since there is no potentially over estimating  non admissible  heuristic
specifically estimating parallel plan length  to the best of our knowledge  all satisficing planners
minimizing makespan actually use a heuristic estimating the number of remaining actions  and employ some method to greedily arrange the chosen actions as a parallel plan  that said  we do not
wish to imply that our simplifying assumptions are safe in the sense that we do not lose important
information  the simplifying assumptions are necessary to make the analysis and its presentation
feasible  the data we show definitely do capture many crucial aspects of ipc   heuristic quality and
planner runtime  we show data for the individual domains  proceeding in alphabetical order  the
 ipc    runtime results were obtained on a linux machine running two pentium   cpus at  ghz 
with   gb main memory  time and memory cutoffs were    minutes and   gb  per instance 
consider figure    showing data for the airport domain  note that the y axis has two different
meanings  runtime on the left hand side  and number of  parallel or sequential  plan steps on the
right hand side  the same applies to all figures below in this sub section  for airport  we observe
a clear correlation between quality of plan length estimation  and runtime  for the optimal parallel
planners  figure    a   this is best observed between instances nr     and     there  the difference
between makespan and its estimate by the plan graph grows  and with it grows the achieved runtime 
on an exponential scale  it may look like a counter example that  for instance nr      where the plan
graph estimate is exact  coincides with the real makespan   the runtime does not get lower again 
note however  that instance    is based on a much larger airport than the previous instances  from
instance    onwards  the only instances solved by any parallel planner have an exact plan graph
estimate  for the optimal sequential planners  figure    b   we get a similar behavior between
instances nr     and     the behavior is also very strong in instances nr     and     while the plan
length grows a lot from    to     the serial plan graph becomes a little shorter  correspondingly  the
runtime goes up by two orders of magnitude  the same is true for instances    and    
for the satisficing planners  in figure    c   the most striking observation is that the length of the
real plan coincides  in all instances  exactly with the length of the relaxed plan  for the respective
initial state   this is actually quite easy to explain  an optimal plan moves the airplanes in a way
so that they never block their paths  the same plan is optimal even when ignoring the delete lists 
moving the airplanes without blocking is always possible at the start  the situation changes only
   

fie ngineering b enchmarks

    

  

for

p lanning

     

   

optimal makespan
plangraph
best parallel runtime

optimal nractions
serialplangraph
best sequential runtime
   

  

    

   
   
  

  

 

  

  

nr  steps

  

runtime  sec  

   

  

nr  steps

runtime  sec  

   

  
 
  
  

   
   

  

    

  

 
 

  

  

  

  

  

  

  

  

    

 

  

 

  

  

  

  

nr  instance

nr  instance

 a 

 b 
    

  

  

  

  

  

   
best nractions
relaxedplan
best runtime
   

   

  

   

   

 

nr  steps

runtime  sec  

   

   
   
   

    

 
 

  

  

  

  

  

  

  

  

  

nr  instance

 c 
figure    airport domain  plots of  parallel  plan length  its heuristic estimation  and runtime  for
 a  optimal parallel planners   b  optimal sequential planners  and  c  satisficing planners 
when a wrong decision was made  so that additional moves have become necessary  in reality  but
not without delete lists  to avoid a blocking situation  apart from this  figure   shows quite nicely
that the runtime taken corresponds very closely to the length of the plan found  note that the latter
is huge      in the largest instance 
in the pipesworld domain  there are two non temporal domain versions  with without tankage
restrictions  i e   restrictions on the amount of liquid that can be stored in any of the network areas 
figure   shows our data for the version without such restrictions  the observations to be made in the
other domain version are similar  except that both sorts of planners scale much worse  thus providing
us with less data  for the optimal planners  figure    a  and  b   the most striking difference with
the airport domain in figure    a  and  b  is that the quality of even the parallel plan graph heuristic
is very bad  it underestimates the real makespan to a much larger extent than it does in airport  the
underestimation grows with instance size  and  naturally  the runtime grows as well  note that the
planners fail to scale much earlier than in figure    a  and  b   there is one slight exception to the
rule that a poorer heuristic estimate leads to a longer runtime  from instance number    to     the
optimal sequential plan length grows from    to     the length of the serial plan graph remains   
and the runtime drops from      to     secs 

   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

    

  

     

  

optimal makespan
plangraph
best parallel runtime

optimal nractions
serialplangraph
best sequential runtime
  

  

    

   
  
  

 

 

  

  

nr  steps

  

runtime  sec  

  

  

nr  steps

runtime  sec  

   

  
 
 
 

   
   

 

    

 

 
 

  

  

  

  

  

  

  

  

    

 

  

 

  

  

  

  

nr  instance

nr  instance

 a 

 b 
  

  

  

  

  

  

   
best nractions
relaxedplan
best runtime
   

   
 

  

nr  steps

runtime  sec  

   

  
   
  

  

    

 
 

  

  

  

  

  

  

  

  

  

nr  instance

 c 
figure    pipesworld domain without tankage restrictions  plots of  parallel  plan length  its heuristic estimation  and runtime  for  a  optimal parallel planners   b  optimal sequential planners  and  c  satisficing planners 
similarly to the situation for the optimal planners  for the satisficing planners  figure    c  
the main difference from figure    c  is the much worse quality of the heuristic function  the
relaxed plan length now differs greatly from the length of the real plans found  particularly for the
larger instances  very curiously  despite the worse quality of the heuristic  the runtimes are much
lower  the longest time taken for any instance is below    seconds  this goes to show  first  the
shortcomings of our analysis here  we give the heuristic quality only for the initial state  which may
differ a lot from the situation in the rest of the state space  for example  in airport a planner using
relaxed plans may get lost in huge dead ends when a wrong decision was made early on  second 
of course  other techniques that the satisficing planners use are also relevant  the runtime data in
figure    b  are exclusively due to sgplan  wah   chen        and yahsp  vidal         whose
problem decomposition greedy lookahead techniques appear to work extremely well in this domain 
all other satisficing planners perform much worse  failing to solve the largest instances  we note
that in pipesworld  the overall runtime curves  for all planners  are characteristically very jagged
and show considerable variance in comparison to  e g   airport  this information gets lost in the
best of presentation chosen for our figures here  it seems to be that hardness in this domain comes

   

fie ngineering b enchmarks

for

p lanning

from interactions too subtle to be seen with the rather high level parameters measured here  we reiterate that the domain version with tankage restrictions is much more challenging to the planners 
the only planner getting anywhere close to the largest instances being yahsp 
     

    

 

   

optimal makespan
plangraph
best parallel runtime
optimal nractions
serialplangraph
best sequential runtime

    

best nractions
relaxedplan
best runtime
   

   

  

   
   
   

nr  steps

runtime  sec  

   
nr  steps

runtime  sec  

   

  
   
 
  

   

 
 

  

  

  

  

  

  

  

    

  

 
 

nr  instance

  

  

  

  

  

  

  

  

nr  instance

 a 
 b 
figure    dining philosophers domain without derived predicates  plots of  parallel  plan length 
its heuristic estimation  and runtime  for  a  optimal planners and  b  satisficing planners 
figure   shows our data for promela dining philosophers without derived predicates  we do not
show two separate figures for the optimal planners since the curves are quite easy to read  from even
a quick glance  one sees that the domain has a very characteristic behavior different from the other
domains  the optimal makespan  plan graph length  and serial plan graph length are all constant
across instance size  in contrast  the optimal sequential plan length grows as a linear function of
size  note the logarithmic scale of the right hand side y axis in figure    a   which we had to use
to make the figure  the values of the other plan step measures  readable  the best plans found
by the satisficing planners are optimal  i e   the nractions data are identical on both sides of the
figure  in figure    a   we once again see the effect of heuristic quality on search performance 
the parallel planners scale as a linear function in instance size  while the sequential planners  for
whom the heuristic function becomes worse and worse  scale highly exponentially  the latter might
also be true for the satisficing planners  it is a bit hard to tell since the solved instances are solved
extremely quickly  the reason why no instance with index higher than    is solved is that  for these
instances  similarly to what we discussed above  section       simplifying precondition formulas
became prohibitively costly  so these instances were available in adl only  the only two satisficing
planners that scaled well in dining philosophers  without derived predicates  were sgplan and
yahsp  neither of which could handle the adl formulation of the domain  similarly  from
the optimal planners only satplan   and optiplan scaled well  and neither could handle the
adl formulation  note that the inability of planners to handle formulas without pre simplification
techniques thus constitutes a serious limitation 
in optical telegraph without derived predicates  no figure shown  the observations are similar
to the ones in figure    except that the planners scale much worse  most particularly  the optimal
sequential planners solve only the single smallest instance  and the best satisficing runtime is clearly
exponential in instance size  taking over      seconds to solve instance number     in the promela
domain versions with derived predicates  there are no results for optimal planners since none of
them could handle derived predicates  the observations for the satisficing planners are similar to
   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

the above  nractions grows as a linear function of instance size  relaxed plan length grows as a
linear function with significantly lower gradient  the planners are very fast in dining philosophers
but need a lot of time         sec  to solve the largest optical telegraph instances  some of which
remain unsolved   we omit the results for the promela domain versions using numeric variables 
since only two planners participated in these domain versions 
    

  

    

  

optimal makespan
plangraph
best parallel runtime

optimal nractions
serialplangraph
best sequential runtime
  

  

   

   
  

 

  

  

  

  

 

nr  steps

  

runtime  sec  

  

nr  steps

runtime  sec  

  
  

  
  
   

   
 

 

    

 
 

  

  

  

  

  

  

  

  

    

  

 
 

  

  

  

nr  instance

  

  

  

  

  

  

nr  instance

 a 

 b 

  

  
best nractions
relaxedplan
best runtime

    

  
best nractions
relaxedplan
best runtime

  

  
  
   
  

nr  steps

runtime  sec  

  
  

  

  

   

nr  steps

  
  

runtime  sec  

 

  
  
 
  
  
 

    

 
 

  

  

  

  

  

  

  

  

   

  

 
 

nr  instance

  

  

  

  

  

  

  

  

  

nr  instance

 c 
 d 
figure    psr domain  plots of  parallel  plan length  its heuristic estimation  and runtime  for  a 
parallel optimal planners in psr small  strips version    b  sequential optimal planners in psr small   c  satisficing planners in psr small  and  d  satisficing planners
in psr large  featuring adl and derived predicates  
figure   shows our results for the psr domain  figure    a    b  and  c  show plots for the domain version psr small  which comes in pure strips and was addressed by all ipc   planners 
figure    d  shows plots for psr large  which comes in adl with derived predicates and was
addressed by four satisficing planners only  we do not show data for psr middle compiled and
psr middle  in the former  just two satisficing planners participated  in the latter  six satisficing
planners participated  but they all scaled quite well on these less challenging instances so the results
are less interesting than those for psr large 

   

fie ngineering b enchmarks

for

p lanning

first  note that all curves in psr small show a large amount of zig zagging  which is quite
unusual and which cannot simply be accounted for by the way the instances are scaled    consider
figure    a   the main observation to be made is that the real optimal makespan is much larger than
its estimation by a plan graph  particularly in the larger instances  still  the optimal parallel planners
are quite efficient  at least in that they can solve all the instances  the runtime data are entirely due
to satplan    whose search techniques are apparently quite efficient in this domain even with
a bad plan graph lower bound  the other optimal planners are all at least one order of magnitude
slower  and cant solve some of the largest instances  for example  none can solve instances    and
    as for the optimal sequential planners in figure    b   the results are pretty similar except that
the runtime scaling is somewhat worse  for both kinds of optimal planners  the runtime is clearly
correlated with the length of the optimal plans  which  since the plan graph bounds are almost
constant  coincides with the difference between the real plan length and its estimate 
in figure    c   we observe that the relaxed plan is a very bad estimator of plan length in psr
small  at least for the respective initial states   but that the planners solve all instances quite efficiently anyway  the runtime data are entirely due to yahsp and fast downward  particularly
fast downward is extremely efficient  showing only a very slight increase of runtime over instance
size  being the only satisficing planner capable of solving instances    and     note that yahsp
 vidal        uses powerful techniques besides a relaxed plan heuristic  and that fast downward
 helmert        uses a more involved  and apparently more powerful  in this case  heuristic function  note also that  at least in terms of solved instances  optimal and satisficing planners are 
unusually  equally good  or bad  in this domain  exactly one of each group solves all instances  all
other planners cannot solve instances    and     the difficulty the planners are experiencing in
this domain is also remarkable since the instances  or at least their grounded encodings  are actually
very small when compared to the instances of the other domains  c f  figure    this indicates that
the domain has some fundamental characteristic that is not yet captured very well by the search
heuristics techniques of  most of  the planners  which nicely complements what we said about the
non obvious polynomial algorithm for psr in section     
in figure    d   we see that the relaxed plan  computed with the version of ff handling derived
predicates  see thiebaux et al               is a rather useless estimator in the psr domain when
expressed in the most natural way using adl and derived predicates  the relaxed plan constantly
contains   steps  meaning that the over approximation of the semantics of derived predicates makes
the initial state look like a goal state  the same happens in psr middle  while the situation may be
different in other parts of the state space  the heuristic value is not constantly    this  apparently 
causes serious trouble for all satisficing planners except fast downward  no planner except fast
downward can solve an instance higher than number     fast downward seems to profit  again 
from its more involved heuristic function  reaching its scaling limit at instance number    
in the satellite domain  which has many temporal and some numeric domain versions  we select 
for our presentation here  the single pure strips version  in figure    a  and  b   we observe that 
like pipesworld and promela  and unlike airport and psr  satellite is a domain where a serial
plan graph provides much worse heuristic values  for sequential planning  than a parallel planning
graph  for parallel planning   over the few instances solved by the optimal planners  parallel plan
length and  serial or parallel  plan graph length do not grow much  while sequential plan length
does  consequently  the sequentially optimal planners scale much worse than the parallel ones 
    the same is true for the runtime curves of the individual planners  in fact  the planners even disagree widely about
which instances are solved easily and which take a lot of time 

   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

    

  

     

  

optimal makespan
plangraph
best parallel runtime

optimal nractions
serialplangraph
best sequential runtime
  
    

   

  
  

 

  
nr  steps

runtime  sec  

 

nr  steps

runtime  sec  

   
 

  

  
  

 
 
 

   

  
   
 

    

 
 

  

  

  

  

  

    

  

 
 

  

  

  

nr  instance

nr  instance

 a 

 b 
   

  

  

  

   
best nractions
relaxedplan
best runtime

   
   

  

   
 

   

nr  steps

runtime  sec  

   

   
   
   
   
  
    

 
 

  

  

  

  

  

  

nr  instance

 c 
figure    satellite domain  plots of  parallel  plan length  its heuristic estimation  and runtime  for
 a  optimal parallel planners   b  optimal sequential planners  and  c  satisficing planners 
in figure    a   we can also nicely see how  during instances           the parallel plan length
does a down up movement           over the constant parallel plan graph length      resulting in a
movement of pretty much the same shape  on a logarithmic scale   of the best parallel runtime 
in figure    c   we observe that  like in airport and unlike in any of the other domains  the
relaxed plans for the initial states have almost the same length as the real plans  there is actually
a slight over estimation most of the time   as we have seen earlier  c f  section      hoffmann
       has shown that  for satellite  the relaxed plan length is  in fact  bound to be close to real plan
length for all states  in contrast to airport  where unrecognized dead ends are possible in principle  
indeed  satellite is very easy to tackle for almost all of the satisficing planners in ipc    while the
runtime shown in figure    c  appears non trivial  remember that these instances are huge  see in
particular the number of ground actions in figure    b   up to instance     most satisficing ipc  
planners could solve each instance within a minute 
we skip the settlers domain since that relies almost exclusively on numeric variables to encode
the domain semantics  which makes it rather incomparable with the other domains  figure    shows
our data for the umts domain  this has only temporal and numeric versions  half of which feature
also time windows  we consider the versions without time windows  figure     a  and  b  concern

   

fie ngineering b enchmarks

     

   
optimal makespan
plangraph
best parallel runtime

for

   

  
best nractions
relaxedplan
best runtime

   

    

p lanning

  

   
  

   
  

   

  

  

nr  steps

   

runtime  sec  

   

temporal makespan

runtime  sec  

   

  

   
  
 

   
  

   
   

   
 

  

  

  

  

  

  

  

  

    

  

 
 

  

  

  

nr  instance

  

  

  

  

  

  

nr  instance

 a 

 b 

    

   
optimal makespan
plangraph
best parallel runtime

 

  
best nractions
relaxedplan
best runtime

   

  

   

  

   
   

   

  
   
  

nr  steps

   

runtime  sec  

  

temporal makespan

runtime  sec  

  
   

  
   
 

  

   

  

   
   

   
 

  

  

  

  
  
nr  instance

  

  

  

    

  

 
 

  

  

  

  
  
nr  instance

  

  

  

  

 c 
 d 
figure     umts domain  plots of  durational  plan length  its heuristic estimation  and runtime 
for  a  optimal  b  satisficing planners in plain temporal version   c  optimal  d  satisficing planners in temporal version with flaw action 
the plain domain version  figure     c  and  d  is with flaw action  let us first consider the optimal
planners  on the left hand side of the overall figure  the only optimal planners that could tackle this
domain  i e   the domains syntax  were tp  and hspa  haslum   geffner         these are
makespan minimizing planners  and so there are no data for sequentially optimal planners  which
wouldnt make a lot of sense in the temporal setting anyway   the plangraph curves in figure   
 a  and  c  correspond to the makespan estimation delivered for the initial state by tp s temporal
numeric extension of that heuristic  for the effect of heuristic quality on runtime  we observe once
again a very strong correlation  in figure     a   up to instance    the makespan estimate is very
close to the real makespan  most of the time  the two actually coincide  and the runtimes are
very good  starting from instance     the real makespan makes a sudden leap upwards that is not
followed by the estimation  and the runtimes shoot upwards  the phenomenon is also very clear
in instances             where the makespan estimation exhibits a good  bad  good pattern  and
the runtime does just the same  in figure     c   the very same sort of behavior can be observed 
meaning in particular that the flaw action does not have an effect on makespan and its estimation by
tp   in fact  the makespan and its estimation are exactly the same in all instances solved in both
domain versions  as contained implicitly in the latter sentence  the flaw action does affect runtime

   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

and with it the set of solved instances  the runtime with the flaw action is consistently more than
a factor of   larger than without the flaw action  in the most challenging instances the planners fail
when the flaw action is present  this decrease in performance is presumably due to the larger state
space incurred by the flaw action 
consider the satisficing planners  figure     b  and  d   we first observe that  once more  we
are facing a very individual and characteristic behavior  and that the domain is no challenge at all to
the satisficing planners  the latter shows that the domain is not a useful benchmark for satisficing
planners  it also shows once again how heterogeneous our benchmark set is  while it is common that
satisficing planners are faster than optimal ones  except in psr  there is no other domain where
that picture is as extreme as in umts  as stated earlier  the domain is a pure scheduling problem 
and obviously the satisficing planners provide runtime efficient greedy solutions to that problem   
looking at the plots in a little more detail  we find in figure     b  that the sequential plan length  the
plans found are optimal  is a simple stepwise linear function in these instances  and that relaxed plan
length for the initial state coincides once again with the real plan length  which isnt a surprise given
the excellent runtimes of the satisficing planners  and the fact that this is a scheduling domain   in a
sequentialized schedule no harmful delete effects occur   this picture changes a lot in figure     d  
the real plan length stays basically the same  is increased by a constant of     but the relaxed plan
length becomes a lot shorter due to the flaw action  the satisficing planners are unaffected  largely
keeping their excellent runtime behavior  apparently  these planners incorporate some technique
for recognizing the uselessness of the flaw action  this can be done with simple domain analysis
techniques   and getting rid of its influence  this suspicion is confirmed by the fact that there is one
satisficing planner that does get affected by the flaw action in the way one should expect  crikey 
a heuristic search forward state space planner using a relaxed plan heuristic  solves each task within
   seconds without the flaw action  but sometimes takes over      seconds with the flaw action 
let us briefly summarize the overall observations 
 in the presented data  most of the time the performance of the planners correlates well with
the quality of the relevant heuristic function  the most notable exceptions to this rule  as far
as can be observed in our data here  are fast downward in psr large  where relaxed plans
are pretty much devoid of information  and sgplan and yahsp  to some extent also fast
downward  in pipesworld  where relaxed plans provide poor estimates and all other planners
experience  much more  serious difficulties 
 usually  here and in the known benchmarks in general  satisficing planners are several orders
of magnitude faster than optimal ones  exceptions here are psr  where both groups perform
almost equally  and umts  where the satisficing planners hardly need any time at all 
 usually  here and in the known benchmarks in general  parallel plan graph length is a much
better estimator of parallel plan length than serial plan graph length is of sequential plan
length  the exceptions here are airport  where there is often a huge difference between
the lengths of the two kinds of plan graphs  and  to some extent  psr small  where the
difference between parallel and sequential plan length is not very big  note that none of our
domains is purely sequential  i e  some parallelism is possible in all of them 
    in terms of quality of the solutions found  the satisficing planners also do reasonably well  for example  lpg td 
which minimizes makespan in this domain  finds  with its version optimized for speed  plans that take maximally
    more time than the optimal ones found by tp   for the version of lpg td optimized for plan quality  this goes
down to    

   

fie ngineering b enchmarks

for

p lanning

 usually  here and in the known benchmarks in general  there is a considerable difference
between the length of a relaxed plan for the initial state  and the length of a real plan for
the initial state  exceptions here are airport  satellite  and umts  where both lengths are
identical or nearly so 
 usually  here and in the known benchmarks in general  the largest instances that can be solved
within the given particular time and memory     minutes and  gb  have plans with around a
hundred steps or more  psr is exceptional in that fast downward is the only planner able to
find a plan with more than     namely  with     steps 
it once again indicates the diversity of the ipc   domains that almost every one of them appears at
least once in the exceptions listed here  the only domains that dont appear there are the promela
domains and pipesworld  this is a sort of exception in itself  meaning that these domains contribute
the more typical benchmark behaviors to the overall set 
we take the existence of some of the mentioned distinguishing features as evidence that the
ipc   domains indeed have several novel aspects  besides being oriented at applications and being
structurally diverse  in particular  the behavior of the psr domain stands out from what one typically observes  note here that  while it is typically easy to construct artificial domains that provoke
some unusual behavior  the domains we have here are oriented at applications  and so the exhibited behavior  particularly that of the psr domain  is not only unusual  but also relevant in a very
concrete sense 
    fact connectivity
we conclude our empirical analysis with some data aimed at assessing a sort of connectivity of the
facts  for each fact p  we measure the number of adders  actions that have p in their add list  in the
adl case  that have an effect with p in its adds list   this gives an indication of the branching factor
 action choices  that comes with the fact  we further measure the number of requirers  actions
that have p in their precondition  in the adl case  that have an effect with p in its condition   this
gives an indication of how central a fact is to the task  for a given planning task  we measure the
parameters of the distribution of adders p  and requirers p   over the set of facts p  the minimum
 min   mean  mean   maximum  max   and standard deviation  dev   within domain versions  we
plot these data over instance size  number  
the data are too abstract to allow deep conclusions about reasons for planner performance  but
we are able to highlight some more characteristic features of the domains  in particular  we will see
that these abstract measurements behave more characteristically different in the ipc   domains than
in the ipc   domains  figure    shows our plots for the ipc   domains airport  pipesworld  dining
philosophers  and satellite  the picture for psr is relatively complicated and shown separately in
figure     settlers is left out because it is exceptional  the picture for umts is extremely simple 
and explained in the text below 
consider figure     a   the  non temporal  airport domain  the min curves are not shown
since they are constantly    is pushing back airplane  is never added since pushback requests  of
outbound traffic  are not modelled  occupied segment  is only required in its negation  the max
curves are step functions since they follow the size of the underlying airports  is moving airplane 
has as many adders as there are segments  since start up engine can be done at any segment  ispushing back airplane  is required by every such action  leading to the overall similar form of

   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

    

     
 adders  max
 adders  mean
 adders  deviation
 requirers  max
 requirers  mean
 requirers  deviation

   

    

  

   

 

  

   

 adders  max
 adders  mean
 adders  deviation
 adders  min
 requirers  max
 requirers  mean
 requirers  deviation
 requirers  min

 
 

  

  

  

  

  

  

  

  

  

 

  

  

  

nr  instance

  

  

  

  

  

  

nr  instance

 a 

 b 

    

    
 adders  max
 adders  mean
 adders  deviation
 requirers  max
 requirers  mean
 requirers  deviation

 adders  max
 adders  mean
 adders  deviation
 requirers  max
 requirers  mean
 requirers  deviation

   

   

  

  

 

 
 

  

  

  

  
nr  instance

  

  

  

  

 

  

  

  
nr  instance

  

  

  

 c 
 d 
figure     distributions of the numbers of actions adding a fact  and of actions requiring a fact 
in selected versions of some ipc   domains   a  airport   b  pipesworld   c  dining
philosophers   d  satellite 
the max requirers curve  the mean adders curve is flattened because all facts other than ismoving airplane  are added only at certain places on the airport  the mean requirers curve  interestingly  shows a similar downwards step behavior as the numbers of facts and actions shown
in figure    the reason lies in the not occupied facts  that exist for every segment  and that are
needed in every action moving an  any  airplane across the segment  the number of these facts
increases with the number of airplanes  since there are many of these facts  they have a strong
influence on the mean  there is not much of a correspondence to runtime in the data  other than the
trivial one that both tend to grow with instance size 
data for pipesworld  no tankage non temporal  are shown in figure     b   several observations
can be made     the max and mean curves clearly follow the scaling pattern  with growing traffic
on the   growing underlying networks     the min curves are non zero     there is a characteristic
difference between the curves up to instance     and afterwards     the curves for adders and
requirers almost  but not exactly  coincide  apart from    which is also present in the airport data 
these observations clearly distinguish pipesworld from all the other domains  as for observation
   sometimes in the larger instances the min number of adders does drop to    this is due to
interactions in more complex networks  where certain configurations inside pipes are true initially

   

fie ngineering b enchmarks

for

p lanning

but can not be re achieved later on  some of these interactions are recognized by the reachability
pre process made by ff for actions  c f  the explanation in section      observation   is due to
a large contrast between the smallest network and all larger ones  the smallest network has only
unitary pipelines  containing just a single batch   the others have pipelines of at least length   
observation   is particularly at odds with all the other domains  where there are large differences
between adders and requirers  in fact  measuring the distribution of the difference between adders
and requirers  we found that these numbers  not only their distribution parameters  are extremely
close together  in instance     where the max adders is      and max requirers is       the max of
the difference is     with a mean of      and dev of       in pipesworld with tankage restrictions 
the phenomenon is somewhat less extreme but still there  another characteristic is the enormously
large max number of adders and requirers  about an order of magnitude larger than in the other
domains  the max adders and requirers come from do normal facts  which control the status of
individual pipelines  and are affected by each action moving some combination of batches through
the respective pipeline  all other facts depend on only single batches  not combinations of them  
which flattens the mean curves by two orders of magnitude  regarding runtime  as mentioned
earlier  in pipesworld the scaling pattern does not have a clear correlation with runtime  neither
does the fact connectivity we measure here 
consider the promela domain in figure     c   data shown for dining philosophers with derived
predicates  once again  the extreme characteristics of the domain are recognizable at first glance 
the data for dining philosophers without derived predicates are identical  the data for optical telegraph differ only in that the numbers are higher  the min curves are both    the adders are constant 
the requirers are linear  there exist facts without adders due to an oddity in the encoding  where
certain start up transitions put the forks on the table in the first place  the facts without requirers are
blocked philosopher  which are only needed for the goal  the number of adders does not depend
on the instance size due to the very static sort of domain structure  where size increases the number
of parallel processes  philosophers   but the form of the processes stays fixed  and every process
interacts with exactly two other processes  the number of requirers is linear  non constant  in particular  due to a technicality of the encoding  where activating  requesting  and performing
 executing  a transition requires all communication channels to be in neutral state  so the respective
flags are required by all transitions  and that number of course grows over size  all other facts are
required only locally  resulting in the much lower  easily two orders of magnitude  mean  as one
would expect in a domain with such a simple scaling pattern  planner performance is pretty much a
function of size 
data for satellite  strips version  are shown in figure     d   the most characteristic feature 
in comparison to the other domains  is the extremely smooth and parallel close together growth of
the curves  the only curve that stands out a little is max requirers  max adders is due to pointing satellite  direction  facts that can be added when turning there from any other direction  max
requirers is due to power on instrument  facts  which are needed for every take image with the
instrument  which can be done in every combination of direction and image mode supported by
the instrument  note that  in contrast to the other domains where the max curves are about two
orders of magnitude higher than the mean  here max requirers is only one order of magnitude
above all the other curves  and these other curves are all roughly of the same order  the min curves
are not shown since they are constantly   for adders  power on instrument  is only added by
switch on instrument   and constantly   for requirers  have image direction  is only needed

   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

for the goal  the runtime performance of the ipc   planners scales relatively smoothly with size in
satellite  like our parameters here do 
in umts  all the parameters are constants  this is another consequence of the aforementioned
scaling pattern  where the number of specified applications is the same in all instances  and what
changes is  only  the goal  specifying which of the applications shall actually be scheduled  precisely  in the plain domain version  the number of adders is   for all facts  nicely showing the
scheduling domain characteristic where there is no choice of how to accomplish tasks  but only
about when to accomplish them  this is another illustration of why the satisficing planners find this
domain trivial  whereas an optimal planner like tp   haslum   geffner        can spend a long
time searching for the optimal schedule  the number of requirers is minimum    maximum    mean
      standard deviation       in the domain version with flaw action  the most notable difference
is that now max adders is    due to the alternative provided by the flaw action  min is now   
mean      deviation       it is interesting to note in this context that  as mentioned above  in this
domain version there is a satisficing planner  crikey  that experiences serious trouble 
     

     
max
mean
deviation

max
mean
deviation

    
    

 adders

 required

   
   

  

  
 

   

 
 

  

  

  

  

  

  

  

  

  

 

  

  

  

nr  instance

  

  

  

  

  

  

nr  instance

 a 

 b 

  

    
max
mean
deviation

max
mean
deviation

  

  

 required

 adders

   
  

  

  
  

 

 

 
 

  

  

  

  
nr  instance

  

  

  

  

  

 

  

  

  

  
  
nr  instance

  

  

  

  

 c 
 d 
figure     distributions of the numbers of actions adding a fact  and of actions requiring a fact  in
psr small and large   a  adders small   b  requirers small   c  adders large 
 d  requirers large 
data for psr are shown in figure     here  we show plots for adders and requirers separately
because that makes them much more readable  since the data contain some particularly interesting
   

fie ngineering b enchmarks

for

p lanning

phenomena  we show it for two domain versions  small and large  the most obvious feature in
small  figure     a  and  b   is  once again  the huge amount of variance in the data  the clearly
discernible peaks in the curves  instance nrs              and     coincide with the peaks in size
as measured by numbers of facts and actions in figure    we also note that there is a very large
range of values  spanning four orders of magnitude  even though the instances are  except number
    all very small in comparison to the other domains shown in figure    the minimum numbers of
adders and requirers are constantly    updated breaker  is added only by a wait breaker  action 
not closed breaker  is only needed if one wants to close it    regarding the maximum adders and
requirers  in instance     which has by far the highest        total number of actions  max adders
       is due to the goal reached fact  i e   to the      disjuncts in the dnf of the goal formula 
max requirers        is due to do normal  which is a flag needed for every goal reached action 
plus the actions opening or closing breakers  we remark that the same facts are responsible for all
of the peaks in the curves  i e   the same happens also in instances         and    
it is highly characteristic for psr small that the max numbers of adders and requirers approach and sometimes exceed two thirds of the total number of actions  this is not the case for any
other domain  not even for any other domain version of psr  see below   the intuitive reason lies
in one of the pre compilation steps that we employed in order to be able to formulate reasonably
large psr instances in pure strips  the compilation step  bertoli et al         removes network
reasoning  and with it  the need for derived predicates  by basically enumerating the breaker configurations and their effects on the flow of current in the network  the result is a very dense structure
where each end of the network directly affects every other end  explaining the very high degree of
fact connectivity  in particular explaining the extremely complex goal formulas in the four peak
cases mentioned above 
the pre compilation step is also the key to understanding the huge difference between the behavior in small  and in large  the latter is shown in figure     c  and  d   there  the max
adders curve is a small linear function  note the non logarithmic scale of the y axis  in spite of the
 mostly  much larger numbers of actions  for example  the instance with the highest number       
of actions and derivation rules is number     where the max number of adders is     less than half a
percent of the total number of actions  in the natural high level domain encoding that we have here 
the flow of current through the network is modelled as the transitive closure over derivation rules
that each propagate current based on the local status of the network  so in particular the breaker
configurations and their effects on the flow of current are implicit in the structure of the network 
once again  in psr large  the min curves are constantly   for both adders and requirers  notaffected breaker  is the negation of a derived predicate  needed as precondition of open and close
actions   which isnt added by an inverse rule  but given its meaning through the negation as failure
semantics of derived predicates  fed line  is only required for the goal  the mean and dev of the
adders are completely flattened by the numerous       out of       in instance     upstream x y 
facts  true if there is currently a path open from a side of node x to a side of node y  that are added
only by a local derivation rule that relies on the same predicate for the neighbors of y  similarly to
satellite  the max number of requirers is generally a lot larger than the max number of adders  for
example      vs     in instance     where max requirers is due to a fact closed device  that is
required in derivation rules talking about pairs of devices  in instance          of the      actions
are such rules  there are    devices 
    sometimes there are   minimum requirers due to an artificial goal reached fact  introduced to get rid of complex
goal formulas  c f  section   

   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

    

    
 adders  max
 adders  mean
 adders  deviation
 requirers  max
 requirers  mean
 requirers  deviation

 adders  max
 adders  mean
 adders  deviation
 requirers  max
 requirers  mean
 requirers  deviation

   

   

  

  

 

 
 

 

 

 

  

  

  

  

  

  

 

 

 

 

nr  instance

  

  

  

  

  

  

  
  
nr  instance

  

  

  

  

nr  instance

 a 

 b 

     

    
 adders  max
 adders  mean
 adders  deviation
 requirers  max
 requirers  mean
 requirers  deviation

 adders  max
 adders  mean
 adders  deviation
 requirers  max
 requirers  mean
 requirers  deviation

    
   

   

  
  

 

 
 

 

 

 

  
  
nr  instance

  

  

  

  

 

 

 

 

 c 
 d 
figure     distributions of the numbers of actions adding a fact  and of actions requiring a fact  in
the strips versions of the ipc   domains except freecell and satellite   a  depots   b 
driverlog   c  rovers   d  zenotravel 
to sum up the sub section  the data are  generally  too abstract to be really tightly interconnected
with the performance exhibited by planners  on the other hand  certain characteristics are visible 
most particularly  in pipesworld  the numbers of adders and requirers are almost identical  in
promela  the adders are constant and the requirers are linear  in satellite  all curves are very close
together  in psr small there is a lot of variance  and the max numbers of adders and requirers
approach and sometimes exceed two thirds of the total number of actions  in contrast  in psr
large the max adders decline to less than half a percent of the total number of actions  in umts 
all the parameters are constant  except for psr and umts  these phenomena are somewhat hard
to interpret  if nothing else  they certainly show us that the domains have some rather different
characteristics  interestingly  the differences are not as significant for the ipc   benchmarks shown
in figure     clearly  the behavior is not as characteristically diverse as what we have just seen for
the ipc   domains  for all the four domains in figure     we basically observe mostly parallel lines
that are pretty close together except for the max lines  which are about an order of magnitude higher
than the others  the only striking feature is the zig zag nature of the curves in depots  this is due
to the scaling pattern  in the smallest instances  the number of crates  blocks  grows continually up
to    crates in instance    thereafter  there come blocks of   instances each  of which the first has  

   

fie ngineering b enchmarks

for

p lanning

crates  the second    crates  and the third    crates  across the blocks  other instance size parameters
grow   this means that the zig zag shape of the curves corresponds exactly to the zig zag shape of
the crate numbers 
note that the behavior of the plots in figure    is similar to the behavior of the plot for satellite
in figure     d   in particular for the first    instances  these were the instances posed to the fully
automated planners in ipc    as also shown in figure     the only ipc   domain that truly stands
out in terms of the behavior of these curves is freecell    there  we observe a phenomenon similar
to that of the pipesworld in figure     b   where the curves for adders and requirers almost coincide 
the phenomenon is a little weaker than in pipesworld  in the largest freecell instance  number    
the max of  both  adders and requirers is       while the max of the difference is      with a mean
of       and dev of        for comparison  in the largest pipesworld instance  max adders is      
max requirers is       and the max of the difference is     with a mean of      and dev of      
to sum up the overall empirical analysis  the data certainly dont solve the mystery of what is
behind the performance of every planner in every domain  and instance   they do  however  provide
some interesting insights about how instances are scaled in the domains  about certain subtleties and
peculiarities of their encodings  and about how standard heuristic methods  and groups of planners 
react to them  we can observe large characteristic differences between the domains  in that sense the
results nicely complement the technical descriptions in appendix a  as well as the known theoretical
results from section   

   conclusion
in a field of research about general reasoning mechanisms  such as ai planning  it is essential to
have useful benchmarks  benchmarks that reflect possible applications of the developed technology 
and that help drive research into new and fruitful directions  in the development of the benchmark
domains and instances for ipc    the authors have invested significant effort into creating such a set
of useful benchmarks for ai planning 
as explained in the introduction  the three main goals we tried to achieve were    realism    
structural diversity  and    accessibility of the benchmarks  it is debatable to what extent these goals
were achieved  to some extent  this is inherent in the conflicting nature of the goals  accessibility
of a benchmark  formulation in as simple as possible pddl dialects  is obviously in conflict with
realism  structural diversity is also in conflict with realism since  in the time window available to
create a competition benchmark set  there may not be  and has not been  in our case  a large set
of suitable applications to choose from  one must make do with whats available  we stressed
on realism since the lack of realism was traditionally considered as one of the main weaknesses
of ai planning  achieving just structural diversity and accessibility would  in fact  have been
comparatively easy  see also below   that said  to adapt the applications for the ipc we had to
make many significant simplifications  still  having derived the domains from applications  one can
expect that they capture some important features even after simplification  on top of that  there is a
clear path towards more realism 
we believe that the domains constitute the best possible compromise for ipc    to name the
most distinguishing features of the domain set 
    it somehow makes sense that its precisely this domain that stands out  as it is also intuitively different from the other
domains  most notably  deciding plan existence in freecell is np hard while it is easy in the other domains  c f 
section     

   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

   airport  pipesworld  psr  and umts are derived directly from applications  promela is a
special case since the model checking instances we could encode are very simplistic   this
was previously the case only for the elevator domain  ipc    and the rovers and satellite
domains  ipc    
   the complexity of satisficing and optimal planning in the strips domain versions covers
the entire range p  np  and pspace  deciding  bounded  plan existence is in p for psr
and pspace complete for airport and general promela  we are not aware of a previous
pspace complete strips benchmark  the polynomial algorithm for finding plans in psr
is  in contrast to those for all the other strips benchmarks with such algorithms  quite nontrivial 
   in hoffmanns        taxonomy of domain classes with different h  topology  the ipc  
domains lie in classes with sparse coverage by previous benchmarks  in particular  none of
our new domains has nearly as simple a topology as proved by hoffmann for most of the
traditional benchmarks  when taking into account that pipesworld actions can be inverted in
 not one but  two steps  each of the domains lies in a different class of hoffmanns taxonomy 
covering more classes     than any previous ipc benchmark set        and   for ipc    ipc   
and ipc    respectively   dining philosophers is exceptional in that it lies in a simple class
but doesnt have a simple topology  airport is exceptional in that it lies in a very hard class
but is typically  in real world instances  easy 
   the behavior of the different kinds of planners in ipc   shows a lot of very characteristic
patterns in the individual domains  in airport  sheer size is the main obstacle  in pipesworld 
particularly with tankage restrictions  the known heuristic functions do very badly  in the
promela domains  the main obstacle is  in a lot of cases  the impossibility of compiling the
pddl description into a fully grounded simpler representation  in psr  there is an extremely
large amount of variance  and optimal planners perform just as well  or poorly  as satisficing
planners  in umts  satisficing planners need no time at all 
   at a very abstract level that just looks at the numbers of actions adding needing each fact  the
behavior of the domains is more characteristically diverse than that of the ipc   domains 
   last but not least  the strips versions of our domains preserve much more of the original
domain structure than what was previously the case  the ipc   strips version of elevator is
hardly an elevator problem anymore  and the ipc   strips versions of satellite and rovers
are devoid of all of the more interesting problem constraints  in contrast  the strips versions
of airport and promela are semantically identical to the adl versions  and the psr strips
version  while pre compiled a lot  still preserves much of the original difficulty of the domain
 judging  e g   by the behavior of the ipc   planners in it  
feature   is  obviously  a point for realism  features   to   are points for diverse structure  particularly feature   shows how the domains pose very different challenges to  current  planning
technology  feature   is a point for realism combined with accessibility  we would like to stress
that accessibility in this respect is really quite important  of the    planners entered into ipc    only
  could handle  some  adl features  our compilation approach enabled us to confront the other   
planners with reasonably realistic problems  that said  it certainly is debatable what role strips
   

fie ngineering b enchmarks

for

p lanning

plays or should play for the community  some people may say that many of the core algorithms 
e g   planning graphs  blum   furst        and relaxed plan heuristics  mcdermott        bonet
  geffner        hoffmann   nebel         have been invented in strips  others may say that
the focus on strips like languages and algorithms distracts us from considering temporal and numerical problems of a truly different nature  this notwithstanding  strips is still the most widely
used language among the research community  this cannot be ignored by competition organizers 
having pointed out the advantages of our benchmark set  we should also point out a few of the
disadvantages  as explained in detail in the individual sections in appendix a  we had to make
many simplifications in order to make the applications fit for use in ipc    to some extent  whether
or not the simplifications preserve the original domain structure is a debatable matter  we feel
that our airport encoding is very close to the real physical thing  not being able to represent
the real optimization criterion is bad  but ameliorated by the fact that  out of    planners  only a
single one  lpg td  could actually deal with user defined optimization criteria    in pipesworld 
the simplifications are more severe  the ipc   domain still resembles some of the core difficulties 
but is more reminiscent of a  complicated  toy example than of software that could be used to control
real pipelines  the promela examples go to show that toy examples in the model checking area are
not any better than the traditional toy examples in planning  in psr  removing the uncertainty and
the numerical optimization renders the ipc   domain unsuitable for practical use 
of course  the domain set is not exhaustive  meaning that there presumably are numerous applications whose essential structure is not similar to any of the ipc   domains  some examples that
spring to mind are action choice in autonomous robots  detecting security holes in computer networks  boddy  gohde  haigh    harp         and online manufacturing  ruml  do    fromherz 
       as for structural diversity  it would be easy to construct a set of artificial domains that
explore more of the possible extreme cases  such domains would probably be completely infeasible for current planners  thus posing very strong challenges  just think of  for example  rubiks
cube  sokoban  or rintanens        purely randomly generated instance distributions  then again 
such a domain set would be devoid of realism  at some point during the preparation of ipc    we
considered introducing a separate class of domains  called diverse structure  which would have
contained domains of this sort  we decided to not do so since the competition event was already
very large without it  also  we felt that our applications were already quite diverse on the structural
side  as pointed out above  several theoretical and empirical phenomena suggest that the latter is
indeed the case 
during our work  we experienced various successes and failures in accurately formulating our
application domains in pddl  people have asked us if  through this  we obtained a picture of how
suitable pddl is  in its current form  to formulate applications  and in what sorts of domains it
works well  the answer is  we dont feel like we obtained many insights into these matters that
are particularly deep or havent been known before  a few lessons learned are these  first and
foremost  formulating an application in strips takes a huge amount of engineering expertise unless
one just drops all problem constraints  some simplifications are unavoidable  second  the discrete
nature of action instantiations in all previous ipc pddl dialects seriously impedes formulation
of domains with continuous aspects  a discretization must be chosen  which is sometimes easy
 airport  and sometimes very hard  pipesworld  to do  a good way out seems to be to adopt the
duration inequalities suggested by fox and long         third  the community should pay more
    this is a good example of a case where pddl has been moving faster than the actual planning technology 

   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

attention to lifted encodings  and how to deal with them in modern planning algorithms  one lesson
from our compilation activities is that grounding out all parameters is often simply not possible
 promela  psr   since compiling away adl constructs is often not feasible without grounding  c f 
section     this is also very relevant in the adl strips context  as a final lesson  we  the ai
planning community  are still  mostly  far away from as is applicability of planners in the real world 
but we are on the right track 
to conclude  we spent significant time and effort creating a useful set of planning benchmarks
for ipc    we hope that they will become standard benchmarks in the coming years 

acknowledgements  we would like to thank the competitors for their detailed comments about
bugs found in our domains  and we would like to thank malte helmert for various useful tools that
helped remove some of these bugs 
we further thank malte helmert for providing us with his  yet unpublished  at the time of
writing  results on computational complexity  helmert            b   we thank patrik haslum
for providing us with the tp  temporal numerical plan graph estimates of makespan in the umts
domain  we are indebted to the anonymous reviewers  and very much to david smith and maria
fox  whose detailed and extensive comments contributed greatly to the development of this paper 
we finally thank david smith for his extensive advice on language  including some corrections even
for these very acknowledgements 
jorg hoffmann thanks wolfgang hatzack for his support in the development of the airport
domain and benchmark instances 
frederico dos santos liporace is supported by conselho nacional de desenvolvimento cientfico
e tecnologico  brazil  he would like to acknowledge the support of his phd supervisor  ruy milidiu  in the development of the pipesworld application 
sylvie thiebaux thanks piergiorgio bertoli  blai bonet  and john slaney for their contributions
to the development of the psr domain and instances  she also would like to acknowledge the
support of national ict australia  nicta is funded through the australian governments backing
australias ability initiative  in part through the australian research council 

appendix a  detailed domain descriptions
we now provide detailed descriptions of all the domains  in alphabetical order  each section  except
those for the satellite and settlers domains  which were adapted from the ipc    is organized in
sub sections as follows  we first give an outline of the application domain  we then explain the
main adaptations made to model the application as a pddl domain in ipc    we explain the ipc  
domain structure  i e   the domain versions and their formulations as used in ipc    and we explain
how we generated the example instances for the ipc   test suites  finally  we discuss possible future
extensions 
a   airport
we had a contact person for this application domain  wolfgang hatzack  who has been working in
this application area for several years  the domain was adapted for ipc   by jorg hoffmann and
sebastian trug 

   

fie ngineering b enchmarks

for

p lanning

a     a pplication d omain
the task is to control the ground traffic on an airport  timed travel routes must be assigned to
the airplanes so that they reach their targets  there is inbound and outbound traffic  the former
are airplanes that must take off  reach a certain runway   the latter are airplanes that have just
landed and have to get parked  reach a certain parking position   the main problem constraint is 
of course  to ensure the safety of the airplanes  this means to avoid collisions  and also to prevent
airplanes from entering the unsafe zones behind large airplanes that have their engines running  the
optimization criterion is to minimize the summed up travel time  on the surface of the airport  of
all airplanes    there usually are standard routes  i e   routes that any airplane outbound from a
certain park position area  or inbound from a certain runway  must take  the reason for introducing
such routes is  simply  the sheer complexity of managing the situation otherwise  without significant
computer support  which is as yet not available on real airports   we will see below that whether or
not standard routes are present makes a big difference also computationally 
the airplanes move on the airport infrastructure  which consists of runways  taxiways  and
parking positions  the runways and taxiways are sub divided into smaller segments  the position
of an airplane is given by the segment it is currently located in  plus its direction and the more
precise position within the segment  several airplanes can be in the segment at the same time 
airplanes are generally divided into three categories  light  medium  and heavy  which classify
them according to their engine exhaust  jet blast   an airplane that has to be moved is either inbound or out bound  in bound airplanes have recently landed and are on their way from the runway
to a parking position  usually a gate  out bound airplanes are ready for departure  meaning they
are on their way to the departure runway  since airplanes cannot move backwards  they need to be
pushed back from the gate onto the taxiway  where they start up their engines  some airports also
provide different park positions that allow an airplane to start its engines directly 
to ensure safety  an airplane must not get too close to the back of another airplane whose engines
are running  how far the safety distance has to be depends on the category  jet blast  of the second
airplane 
the ground controller  the planner  has to communicate to the airplanes which ways they
shall take and when to stop  while such guidance can be given purely reactively  it pays off to base
decisions on anticipating the future  otherwise it may happen that airplanes block each other and
need more time than necessary to reach their destinations on the airport  the objective is  as said 
to minimize the overall summed up traveling times of all airplanes 
as instances of the domain  one considers the traffic situation at some given point in time  with
a time horizon of  say  one hour  if new airplanes are known to land during given time slots inside
the time horizon  then during these time slots the respective runways are considered blocked  and
the planner has to make sure these runways are free at these times  of course  because the situation
changes continually  new planes have to be moved and plans cannot be executed as intended   continuous re planning  i e   consideration of the domain instance describing the new traffic situation  is
necessary  solving instances optimally  the corresponding decision problem  is pspace complete
without standard routes  helmert      b  and np complete if all routes are standardized  hatzack
  nebel         in the latter case  we have a pure scheduling problem  in the former case  compli    this criterion is what the airport wants to minimize  in order to maximize its throughput  from the point of view of
the airlines  it would be better to minimize delay  e g   by minimizing the summed up squared delay of all airplanes 
the two criteria may be in conflict  neither of the two can be easily modelled in pddl     see below 

   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

cated  highly unrealistic  of course  airport topologies can lead to exponentially long solutions  c f 
section     
a     ipc   pddl a daptation
the pddl encoding  as well as our example instance generation process  see below  is based on
software by wolfgang hatzack  namely on a system called astras  airport surface ground traffic
simulator  this is a software package that was originally designed to be a training platform for
airport controllers  astras provides a two dimensional view of the airport  allowing the user to
control the airplanes by means of point and click  astras can also simulate the traffic flow on an
airport over the course of a specified time window 
we made three simplifications  one of them benign  to the airport model  as for the benign
simplification  we did not model park positions where the airplane can start up its engines directly 
without being pushed back to the taxiway first  while it is not difficult to model such park positions
in pddl  they seldom occur in reality and so are not very relevant to the application  our first
more important simplification was to assume a somewhat cruder notion of airplane locatedness  by
requiring that only a single airplane can be located in a segment at any time  that is  we use the
term segment with the meaning of a smallest indivisible unit of space  to minimize the loss of
precision   some of  the original segments were sub divided into several new smaller segments 
the safety distance behind the back of an airplane whose engines are running is then also measured
in terms of a number of segments  while this discretization makes us lose precision  we believe that
it does not distort the nature of the problem too much  due to the amount of expected conflicting
traffic at different points on the airport  high only near parking positions   it is relatively easy to
choose a discretization  with segments of different length  that is precise and small enough at the
same time    the last simplification is more severe  we had to give up on the real optimization
criterion  we say more on this rather strong simplification below  we did not use full standard
routes  thus allowing the airplanes a choice of where to move  we did use standards for some
routes  particularly the regions near runways in large airports  for one thing  this served to keep
large airports manageable for the pddl encoding and planners  for another thing  it seems a good
compromise at exploiting the capabilities of computers while at the same time keeping close to
traditions at airports  we get back to this matter in section a     
the full pddl description of our domain encoding can be downloaded from the ipc   web page
at http   ipc icaps conference org   briefly  the encoding works as follows  the available actions are
to pushback  move a plane away backwards from a parking position   to startup the engines 
to move between segments  to park  turning off the engines   and to takeoff  which amounts
to removing the plane from the airport   the semantics of these actions are encoded based on
predicates defining the current state of the airplane  at any point in time  an airplane is either
moving  pushed  parked  or airborne  an airplane always occupies one segment and  if its engines
are running  may block several other segments depending on the size of the occupied segment
and the category of the airplane  the action preconditions ensure that blocked segments are never
occupied by another airplane  in the initial state  each plane is either parked  or moving  a parked
plane can be pushed back  and after starting up its engines  it is moving  a moving airplane can
    the need for smallest indivisible units  of space  in this case  is a fundamental consequence of the discrete nature of
pddl     some more on this is said in section a     

   

fie ngineering b enchmarks

for

p lanning

either move from its current segment to a neighboring segment  park  at a parking position  or
take off  on a runway 
as an example  have a look at the pddl encoding of the  non durational  move action  one
of the preconditions was used as an example in section   already  
  action move
 parameters
  a   airplane  t   airplanetype  d    direction  s   s    segment  d    direction 
 precondition
 and  has type  a  t   is moving  a   not     s   s     facing  a  d    can move  s   s   d  
 move dir  s   s   d    at segment  a  s  
 not  exists   a    airplane   and  not     a   a    blocked  s   a     
 forall   s   segment   imply  and  is blocked  s  t  s   d    not     s  s      not  occupied  s     
 effect
 and  occupied  s    blocked  s   a   not  occupied  s     not  at segment  a  s     at segment  a  s  
 when  not  is blocked  s   t  s   d     not  blocked  s   a   
 when  not     d   d     and  not  facing  a  d     facing  a  d    
 forall   s   segment   when  is blocked  s  t  s   d    blocked  s  a   
 forall   s   segment   when
 and  is blocked  s  t  s   d    not     s  s     not  is blocked  s  t  s   d    
 not  blocked  s  a      

the six parameters  which is a lot compared to most of the usual benchmarks  do not cause
a prohibitive explosion in instantiations since there is a lot of restriction through static predicates 
airplane  a moves  its type  category  is  t  it is at segment  s  facing in direction  d   and
will be at  s  facing in direction  d  after the move  direction here is a very simple concept
that just says which end of the segment the airplane is facing  of course  moves from  s   d 
to  s   d  are only possible as specified by the  static  topology of the airport  can move 
move dir   the first of the two more complex preconditions says that  s  must not currently
be blocked by any airplane other than  a itself  the second complex precondition makes sure
that  after the move   a will not block a segment that is currently occupied  by another airplane 
necessarily    is blocked  s  t  s   d   is a static predicate that is true iff  s is endangered 
blocked  if a plane of type  t is at  s w facing direction  d   the effects should be selfexplanatory  they simply update the at  occupied  and blocked information  the only effect
that looks a little complicated  the last one  says that those segments that were blocked before the
move  but are no longer blocked after the move  become un blocked  note that the conditions of all
conditional effects are static  so the conditions disappear once the parameter instantiation is chosen 
in durational pddl  the actions take time according to some simple computations  the time
taken to move across a segment depends  naturally  on the segment length and the speed  we
assumed that airplanes move at the same speed regardless of their category  the time taken to start
up the engines is proportional to the number of engines  the other actions have some fixed duration 
if some planes are known to land in the near future  blocking runways  then we model the
blocking during these time windows using timed initial literals  respectively their compilation into
artificial  temporal  pddl constructs  the timed literals are simply instances of the usual blocked
predicate  becoming true when the respective time window starts  and becoming false again when it
ends 
we were not able to model the real optimization criterion of airport ground traffic control  the
standard criterion in pddl is to minimize the execution time  i e   makespan  of the plan  in our
   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

encoding of the domain this comes down to minimizing the arrival time  meaning  arrival at the
destination on the airport  of the last airplane  but the real objective is  as said above  to minimize
the overall summed up travel time of all airplanes  there appears to be no good way of modeling
this criterion in current pddl  the difficulty lies in accessing the waiting times of the planes  i e 
the times at which they stay on a segment waiting for some other plane to pass   
the only way  we could think of  to get access to the waiting times  in current pddl  is to
introduce an explicit waiting action  but then one must be able to tell the planner  i e   to encode in
the action  how long the plane is supposed to wait  one option is to use the duration inequalities
proposed by fox and long         there the action imposes only some constraints on its duration 
and the planner can has to choose the actual duration of the action  at each point where it is used in
the plan  as an additional  rational valued  parameter  the potential disadvantage of this approach
is that the choice of the waiting time introduces  in principle  an infinite branching factor into the
state space  and may thus make the problem much harder for automated planners  moreover  duration inequalities were not put to use in ipc    and were not a part of pddl     when not using
duration inequalities  the only way to encode the requested waiting time into the action is to use
a discretization of time  one can then introduce new objects representing every considered time
interval  and give the waiting action a parameter ranging over these objects  apart from the loss
of precision involved in the discretization  this approach is also likely to cause huge performance
problems for automated planners  as an alternative way out  we considered introducing a special
current time variable into pddl     returning the time of its evaluation in the plan execution 
using such a look at the clock  one could make each plane record its arrival time  and thus formulate the true optimization criterion without any major changes to the domain structure  the ipc  
organizing committee decided against the introduction of a current time variable as it seemed to
be problematic from an algorithmic point of view  it implies a commitment to precise time points
at planning time   and didnt seem to be very relevant anywhere except in airport 
all in all  the ipc   pddl encoding of the airport domain is realistic except for the optimization criterion  which demands to minimize maximal arrival time  makespan  instead of summed
up travel time  it remains to remark that all but one  lpg td  of the ipc   planners ignored the
optimization criterion anyway  also  minimizing the latest arrival time does appear a useful  if not
ideal  objective 
a     ipc   d omain s tructure
the airport domain versions used in ipc   are non temporal  temporal  temporal timewindows 
and temporal timewindows compiled  the first of these versions is  as the name suggests  nondurational pddl  in the second version  actions take time as explained above  the third and fourth
versions also consider runways blocked in the future by planes known to land during given time
windows  the third version encodes these time windows using timed initial literals  the fourth
version uses those literals compilation into standard temporal pddl constructs  c f  section   
in all the domain versions  the problem constraints are modeled using adl  i e   complex preconditions and conditional effects  we compiled the adl encodings to strips with domainspecific software implemented for this purpose  we grounded out most  not all  of the operator
parameters  precisely  all the parameters except  for each action  the one giving the name of the
    modelling summed up  squared  delay of all airplanes  the optimization criterion for airlines  would pose essentially
the same difficulty  it also involves computing the arrival time  in order to compute the delay  

   

fie ngineering b enchmarks

version
non temporal
non temporal
temporal
temporal
temporal tw
temporal tw
temporal twc
temporal twc

formulation
adl
strips
adl
strips
adl
strips
adl
strips

for

max  op
 
    
 
    
 
    
  
    

p lanning

max  act
          
             
          
             
         
             
         
             

table    overview over the different domain versions and formulations of airport  abbreviations used  temporal tw for temporal timewindows  temporal twc for temporaltimewindows compiled  max  op is the maximum number of  parameterized  pddl
operators for any instance  max  act is the maximum number of ground actions for any
instance  for the adl formulations  the set of ground actions could not be generated for
the largest instances  data are shown for the largest instances that could be handled  data
in parentheses are collected before ffs reachability pre process  see text  
affected individual airplane  once all the other parameters are fixed  the formulas and conditional
effects can be simplified to the usual strips constructs  each airport domain version contains
the original adl formulation  as well as its compilation to strips  the result of the grounding
process depends on the specific airport considered in the instance  and on the set of airplanes that
are travelling  so  in the strips formulations  to each instance there is an individual domain file
 the same applies to all strips compilations in the other domains described later  
the domain versions  as well as the blow up incurred by the compilation  are overviewed in
table      the numbers shown in the table indicate numbers of pddl operators  and numbers
of grounded actions  for each domain version formulation  the maximum such number of any
instance is shown  note that  in the adl formulations except temporal timewindows compiled 
there is just a single domain file so the number of operators is identical for all instances  in the
strips formulations  the number of operators is high because  as explained  most of the operator
parameters are grounded  the difference in the number of ground actions between the strips and
the adl formulations is because  with our automated software  we were not able to generate the
ground actions in the larger adl instances  the data shown are for the largest instances that we
could handle  the numbers shown in parentheses refer to the situation before ffs reachability
pre process  as said before  this builds a relaxed planning graph for the initial state  and removes all
actions that do not appear in that graph  the difference between the numbers inside and outside of
the parentheses indicates how much this simple pre process helps  we see that it helps quite a lot
here  pruning almost half of the actions  which would never become applicable  in a forward search
at least  but which blow up the representation regardless of what algorithm is used  
    the instantiation process is  of course  planner dependent  similarly as before in section    our data are based on
ffs pre processor  we extended that pre processor  precisely  the one of metric ff  hoffmann         to deal with
temporal constructs 

   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

a     ipc   e xample i nstances
the airport example instances were generated by sebastian trug  with an implementation based on
the aforementioned airport simulation tool astras  five scaling airport topologies were designed 
and used as the basis for the instance generation  the airports are named minimal  mintoy 
toy  half muc  and muc  the smallest of these airports is the smallest possible airport
astras can handle  the two largest airports correspond to one half of munich airport  muc   and
to the full muc airport  figure    shows sketches of the minimal airport  and of the muc
airport 

 a 

 b 
figure     the smallest  a   and the largest  b  of the ipc   airport topologies  park position
segments are marked in black  e g   at the top of part  a    while the segments airplanes
can takeoff from are marked in white  e g   at the left bottom side of part  a    the lines
show the road network on the airport  topology  b  corresponds to muc airport 
sebastian trug implemented pddl instance generation software inside astras  during a simulation of the traffic flow on an airport  if desired by the user the software exports the current traffic
situation in the various pddl encodings explained above  the simulator was run with the different
airports  and    scaling traffic situations were exported    on minimal    on mintoy     on
toy     on half muc  and    on muc   for each airport  the instances scale in terms of the
number of travelling airplanes  the largest instance features    planes to be moved to their destinations on munich airport  with    planes landing in the future to be considered  in the respective
domain versions   this can be considered a realistically sized traffic situation  at this airport 

   

fie ngineering b enchmarks

for

p lanning

a     f uture w ork
it remains to explore how to relax some of the simplifications we had to make  most importantly 
how to overcome the discrete model of space  locatedness   and how to model the real optimization
criterion  our difficulties with both are  as partly described above already  mostly due to the discrete
nature of pddl     which does not allow a continuous choice in the instantiation of an action  such
a continuous choice would be the most natural way of saying how far a plane will be moving and
how long it will be waiting  so the best way to go about this direction is  probably  to assume
the duration inequalities proposed by fox and long         together with the numeric variables
already contained in pddl     this should be easy on the modelling side  the main problem
is probably on the technology side  i e   to develop planners that can deal efficiently with such
continuous choice points  at the time of ipc    as said  continuous choice appeared too much to
demand from the planners 
one interesting topic for future work arises if one restricts the airplanes completely to standard
routes  i e   leaves them no choice at all of what route to take to their destination  as said  first 
this is usually done at real airports  for the sheer complexity of managing the situation otherwise 
without significant computer support  which is as yet not available at real airports   second  in ipc  we made only limited use of this feature  to retain some of the flexibility that could be offered
by automatized methods  third  the restriction turns the pspace complete ground traffic control
problem into a pure  np complete  hatzack   nebel         scheduling problem  where the only
question is when the planes move across what segment  one could exploit this to create a much
more concise pddl encoding  the restricted problem comes down to resolving all conflicts that
arise when two planes need to cross the same airport segment  one could thus try to not encode in
pddl the physical airport  but only the conflicts and their possible solutions  ideally in connection
with the real optimization criterion  it can be expected that planners will be much more efficient in
such a simpler and more concisely encoded problem 
a   pipesworld
frederico liporace has been working in this application area for several years  he submitted a paper
on an early domain version to the workshop on the competition at icaps    the domain was
adapted for ipc   by frederico liporace and jorg hoffmann 
a     a pplication d omain
pipelines play an important role in the transportation of petroleum and its derivatives  since it is
the most effective way to transport large volumes over large distances  the application domain
we consider here deals with complex problems that arise when transporting oil derivative products
through a multi commodity pipeline system  note that  while there are many planning benchmarks
dealing with variants of transportation problems  transporting oil derivatives through a pipeline
system has a very different and characteristic kind of structure  since it uses stationary carriers
whose cargo moves rather than the more usual moving carriers of stationary cargo  in particular 
changing the position of one object directly results in changing the position of several other objects 
this is less reminiscent of transportation domains than of complicated single player games such as
rubics cube  it can lead to several subtle phenomena  for example  it may happen that a solution
must reverse the flow of liquid through a pipeline segment several times  it may also happen that

   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

liquid must be pumped through a ring of pipeline segments in a cyclic fashion  to achieve the goal
 we will see an example of this later  
in more detail  the application domain is the following  a pipeline network is a graph of operational areas connected by pipeline segments  operational areas may be harbors  distribution centers
or refineries  these may be connected by one or more pipeline segments  the oil derivatives are
moved between the areas through the pipelines 
there can be different types of petroleum derivative products  each area has a set of tanks
that define the storage capacity for each product type  each pipeline segment has a fixed volume
and speed  the volume depends on the segments length and cross section diameter  and the speed
depends on the power of the pumps that move the contents  a segment may be uni directional  i e 
only usable for transportation in one direction 
pipeline segments are always pressurized  that is  they must be always completely filled with
petroleum derivative products  because of that  the only way to move a pipeline segments contents
is by pumping some amount of product from an adjacent area into the segment  this operation
results  assuming incompressible fluids  in the same amount of a possibly different product being
received in the area at the other end of the segment 
the pumping operations can only be executed if they do not violate any interface or tanking
constraints  as for the former  distinct products have direct contact inside the pipeline segment  so
it is unavoidable that there is some loss due to the mixture in the interface between them  these
interface losses are a major concern in pipeline operation  because the mixed products can not be
simply discarded  they must pass through a special treatment that may involve sending them back to
a refinery  and that may require the use of special tanks  the severity of interface losses depends on
the products that interface inside the pipeline segment  if two product types are known to generate
high interface losses  the pipeline plan must not place them adjacently into the segment  such a pair
of product types is said to have an interface restriction 
tanking constraints are limits on the product amounts that can be stored in an area  arising from
the respective tank capacities  such constraints may effectively block a pipeline segment  if there is
no room in the receiving area to store the product that would leave the segment in the process of a
pumping operation 
the task in the application is to bring certain amounts of products to the areas in which they are
required  i e  one has to find a plan of pumping operations that shifts the positions of the product
amounts in a way so that the goal specifications are met  sometimes there is a deadline specifying
when  at the latest  a product amount has to arrive at its destination area  it may also be the case that
an area  typically  a refinery  is known to produce some given amount of a product at a given point
in time  and that the plan must make sure that there is enough tank space available at the respective
area to store the new product amount  similarly  an area  typically  a harbor or a distribution center 
may be known to consume some given amount of a product at a given point in time  thereby freeing
the respective amount of tank space 
a     ipc   pddl a daptation
the main adaptations made in the pddl encoding are unitary batches  split pumping operations 
and personalized goals  see below for the latter   the term batch is used in the oil pipeline
industry to refer to an amount of a product that must be transported through the pipeline  batches
are thus associated with a single product and have predefined volume  batches are also indivisible 

   

fie ngineering b enchmarks

for

p lanning

when a batch bi is pumped from an area aj into a segment sj k   it is not possible for another batch
to be pumped from aj into sj k until all of bi s volume is pumped  of course  in reality the product
amount in a batch is a rational number  using such a numeric encoding in ipc   seemed completely
infeasible due to complications in the modeling  and the expected capabilities of the participating
planners  see section a       instead  we based the encoding on the concept of what we called
unitary batches  these are the smallest considered  indivisible  portions of product  the pumping
operations refer to unitary batches  the pipeline segments volumes and the volumes of tanks are
also defined in terms of unitary batches  when encoding a real world instance of the domain  the
actual volume associated with a unitary batch is a choice variable  smaller unitary batches decrease
the rounding error in the pddl encoding  at the cost of a larger encoding size  note that  like the
smallest units of space in the airport domain  this is a discretization the need for which is due to the
non continuous nature of actions in pddl     we get back to this in section a     
we modeled pipe segments in a directional fashion  i e  there is a default direction assigning
one area the from role  and the other area the to role  the pumping operations accordingly
distinguish between push actions  which move liquid in the respective segments default direction 
and pop actions  which move liquid in the opposite direction  this is simply a technical device to
enable the encoding of the pipe segment contents through predicates defining the first and last
batches in the segments  as well as a successor relation   the push and the pop actions receive
 amongst other things  as arguments the pipeline segment whose contents are being moved  and the
batch that is being inserted into the segment  the batch that leaves the segment depends on the
segment content before the action is executed  figure    shows an example 



a 




























b 



a 




















































b 




b 












































b 

















































































































b 

a 

fi

fi


fi

fi


fi

fi


fi

fi


fi


fi


fi


fi


fi


fi


b 
fi


































b 

a 

fi
















b 

























b 





















































































































 

b 





b 












b 



 b 

 a 
a 

 

 

 

 

 

 

 

 

 

 

 

 

 

 
 

 
 

b 
 

 

 
 

 
 

 
 

 
 

 
 

 

 
 

 
 

 

 
 

 
 

 
 

b 

 
 

a 
























b 




 

 


 

 


 

 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

b 
 
 

 
 

 
 

 
 

 
 

 

 
 
 

 
 

 

 
 






































 


 


 

b 

 

 

 

 

 

 

 

 

 


 

 
 

 

b 

p 

 


 


 



ff



ff



ff



ff



ff



ff



ff



ff



ff



ff



ff



ff

 
 

p 
p 

 c 

figure     a small example  a  plays the from role  the fill pattern for each batch represents
its product   a  shows the initial state   b  shows state  a  after a push operation with
b  being inserted into the segment   c  shows state  b  after a pop operation with b 
being inserted into the segment 
apart from the pipe segment and the batch being inserted  the push and pop actions have
to take several more parameters regarding  e g   product types and tank slots  in particular  in order
to be able to update the segment contents correctly  the actions also need parameters giving the
respective first  last  and second last batch in the current contents of the segment  thus such an
action has four parameters ranging over batches  yielding at least n  ground instances of the action
when there are n  unitary  batches in the considered task  we found that this made the domain
   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

completely infeasible for any planning system that grounded out the actions  since many unitary
batches are needed to encode even relatively small pipesworld examples  such planners typically
died in the pre processing phase already    we avoided this phenomenon by splitting the actions
into two parts  a start action taking as batch parameters only the inserted batch and the first batch
in the pipe  and an end action taking as batch parameters only the last and second last batches in
the pipe  to make this more concrete  here is the split push action 
  action push start
 parameters
  pipe   pipe  batch atom in   batch atom  from area   area  to area   area
 first batch atom   batch atom  product batch atom in   product
 product first batch   product 
 precondition
 and  normal  pipe   first  first batch atom  pipe   connect  from area  to area  pipe 
 on  batch atom in  from area   not unitary  pipe 
 is product  batch atom in  product batch atom in 
 is product  first batch atom  product first batch 
 may interface  product batch atom in  product first batch  
 effect
 and  push updating  pipe   not  normal  pipe    first  batch atom in  pipe 
 not  first  first batch atom  pipe    follow  first batch atom  batch atom in 
 not  on  batch atom in  from area    
  action push end
 parameters
  pipe   pipe  from area   area  to area   area  last batch atom   batch atom
 next last batch atom   batch atom 
 precondition
 and  push updating  pipe   last  last batch atom  pipe   connect  from area  to area  pipe 
 not unitary  pipe   follow  last batch atom  next last batch atom  
 effect
 and  not  push updating  pipe    normal  pipe 
 not  follow  last batch atom  next last batch atom  
 last  next last batch atom  pipe   not  last  last batch atom  pipe  
 on  last batch atom  to area   

the constructs should be largely self explanatory  the static predicates used are  connect 
encoding the topology of the network  is product  encoding the types of liquid  may interface 
encoding the interface restrictions    not unitary  saying whether or not a pipe segment contains
just one batch  in which case the push and pop actions are much simpler and need not be
split  the first and last elements in the pipe are identical   the predicates normal and pushupdating ensure  in the obvious way  that the two parts of the split action can only be used as
intended  finally  on  first  follow  and last encode where the relevant batches are  the
role of on should be clear  it just encodes locatedness in areas  as for the pipe contents  they are
modelled in a queue like fashion  with a head first  a tail last  and a successor function follow 
the two parts of the push action update this representation accordingly 
    matters may be easier for planning systems that do not ground out actions in a pre process  this didnt affect our
design decision here since the large majority of systems around at the time of ipc   did employ such a pre process 
    note here that we do not model the interface loss for those products that may interface 

   

fie ngineering b enchmarks

for

p lanning

we did not encode uni directional pipe segments  i e  for all segments both push and pop
actions are available in the ipc   encodings  we modeled tankage restrictions with simple constructs involving tank slots located in areas  each slot having the capacity to store one unitary batch
of some given product type  that is  the push and pop actions now also specify what tank slot
the inserted outgoing batch comes from is inserted into  for simple examples regarding interface
and tankage restrictions  re consider figure     if the storage capacity for p  in a  is equal to zero 
then the transition from state  a  to state  b  becomes invalid  if we forbid the interface between p 
and p    then the transition from state  b  to state  c  becomes invalid 
pipe segment speed can be easily taken account of  in durational pddl   if the speed of a
segment is s  then simply assign the push pop actions regarding that segment a duration proportional to  s    in the ipc   encoding  each start end action takes exactly that time  while the
non split actions regarding length   segments take time  s   
in reality  as outlined above the goals refer to amounts of product requested to be at certain
destination areas  with our encoding based on batches  formulating such a goal would mean to introduce a potentially large disjunction of conjunctive goals  if one wants to say  e g   that three unitary batches of product p are requested in area a  then the needed goal condition is the disjunction
w
 b   b   b   b  atb  a    atb  a    atb  a  of the respective conjunctive goal for all three subsets
 b    b    b    of the batches b of type p   to avoid exponential blow ups of this kind  in our encoding
we used personalized goals instead  referring to specific batches instead of product amounts  basically  this comes down to pre selecting one of the  b    b    b    subsets in the above disjunction   
one could also avoid the blow up by replacing the disjunction with an existential quantification  but
that step would be undone in the compilation to strips anyway 
deadlines on the arrival of batches are  in durational pddl  easily modeled by their compilation
to timed initial literals  for each goal deadline there is a literal saying that the respective batch can
still be ejected from the end of a pipe segment  the literal is initially true  and becomes false at
the time of the deadline  as described above  in the application there can also be pre specified time
points at which an area produces or consumes a given amount of a product  we did not model this
in the ipc   domain  see also section a      
as mentioned above  the structure of the pipesworld domain can lead to several subtle phenomena in the possible plans  an example where plans have to perform a cyclic sequence of pumping
operations is depicted in figure     the goal is to place b  in a   the shortest plan is the following  for readability  in the action parameters only the batches going into and out of the pipes are
shown      push s    b  b      pop s    b  b      pop s    b  b      push s    b  b     
push s    b  b      pop s    b  b      push s    b  b      push s    b  b   observe that
this plan contains two cyclic patterns  action   inserts b  into s    actions         then form a
cycle  s      s      s      that brings b  into a   thereafter  action   inserts b  into s    and actions
        form another cycle  s      s      s      bringing b  to its goal position a    
    note that a bad choice of  b    b    b    can make the task harder to solve  we are  however  currently investigating the computational complexity of different variants of the pipesworld  and our preliminary results suggest that
allowing disallowing personalized goals does not affect the complexity 
    note that the need for such cyclic patterns is not an oddity introduced by our encoding  it is something that may  but
is probably not very likely to  happen in reality  like in the example  it becomes necessary if there isnt enough liquid
in an origin area  here  a  and a   to push the needed amount of liquid  here  b   through to its destination 

   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

a 
s   
b 
a 

b 
s    b 

b 

s   
b 
b 

b 
s   
a 

b 

a 

s   

figure     an example where cycling is required to achieve the goal  place b  in a    pipe segment
si  j is directed from ai to aj 
version
notankage nontemporal
notankage temporal
notankage temporal d
notankage temporal dc
tankage nontemporal
tankage temporal

formulation
strips
strips
strips
strips
strips
strips

max  op
 
 
 
 
 
 

max  act
             
             
           
           
               
               

table    overview over the different domain versions of pipesworld  abbreviations used 
temporal d for temporal deadlines  temporal dc for deadlines compiled  max  op
is the maximum number of  parameterized  pddl operators for any instance  max  act
is the maximum number of ground actions for any instance  data in parentheses are collected before ffs reachability pre process  see text  

a     ipc   d omain s tructure
the pipesworld domain versions used in ipc   are notankage nontemporal  tankage nontemporal 
notankage temporal  tankage temporal  notankage temporal deadlines  and notankage temporaldeadlines compiled  all versions include interface restrictions  the versions with tankage in
their name include tankage restrictions  in the versions with temporal in their name  actions take
different amounts of time depending on the pipeline segment that is being moved  as explained
above  the versions with deadlines in their name include deadlines on the arrival of the goal
batches  one of these versions models the deadlines using timed initial literals  in the other version
 naturally  with compiled in its name  these literals are compiled into artificial  temporal  pddl
constructs  none of the encodings uses any adl constructs  and of each version there is just one
 strips  formulation 
the domain versions and numbers of ground actions are overviewed in table    as before 
the data were measured using  a temporal extension of  ffs pre processor  the numbers shown

   

fie ngineering b enchmarks

for

p lanning

in parentheses refer to the situation before that pre processors reachability pre process  which
builds a relaxed planning graph for the initial state and removes all actions that do not appear in
that graph  we can observe that the numbers of ground actions are very low in the domain versions
with deadlines  and extremely high in the versions with tankage restrictions  the former is simply
because  due to the complicated generation process  explained in the next sub section   examples
with deadlines were generated only up to a smaller size  the latter  high numbers of actions in
the presence of tankage restriction  is due to the additional blow up incurred by the choice of tank
slots from which to draw in which to put the batches  we note that the effect of the reachability
pruning is relatively moderate  in particular much lower than  e g   in airport  c f  section a     
a     ipc   e xample i nstances
the pipesworld example instances were generated by frederico liporace  in a process going from
random generators to xml files to pddl files    five scaling network topologies were designed
and used as the basis for the instance generation  figure    shows the network topologies  as well
as a real world network topology for comparison  as one can see  the largest network topology
used in ipc   is not quite yet in the same ballpark as the real network  but neither is it trivially
small in comparison  the volumes for pipeline segments that connect the same areas in the realworld example are not necessarily the same because the segments may have different cross section
diameters 
for the domain versions without tankage restrictions and deadlines  for each of the network
topologies    scaling random instances were generated  within a network  the instances scaled
in terms of the total number of batches and the number of batches with a goal location  for the
instances featuring tankage restrictions or deadlines  the generation process was more complicated
because we wanted to make sure to obtain only solvable instances  for the tankage restriction examples  we ran mips  edelkamp      b  on the respective notankage instances  with incrementally
growing tankage    we chose each instance at a random point between the first instance solved by
mips  and the maximum needed tankage  enough tankage in each area to accommodate all instance
batches   some instances could not be solved by mips even when given several days of runtime 
and for these we inserted the maximum tankage  for the deadline examples  we ran mips on the
corresponding instances without deadlines  then arranged the deadline for each goal batch at a random point in the interval between the arrival time of the batch in mipss plan  and the end time of
mipss plan  the instances not solved by mips were left out 
a     c urrent

and

f uture w ork

there is ongoing work on developing a pipesworld specific solver  named plumber  milidiu   dos
santos liporace      a  milidiu   dos santos liporace      b   plumber incorporates a pipeline
simulator  domain specific heuristics  and procedures for reducing the branching factor by symmetry
elimination  it also lets the user choose between different search strategies  such as enforced hill
climbing  hoffmann   nebel        and learning real time a  korf         currently it is being
extended to support temporal planning as well 
    the same xml file is mapped into different pddl files depending on the kind of encoding used  there was a lot of
trial and error before we came up with the final ipc   encoding 
    mips was a convenient choice since it is one of our own planners  and can also deal with temporal constructs 

   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

a 

a 

s 
  

 

 

  
s 

s 
  

  
s 

 

a 
a 

network  

 

a 

network  

a 

 

 

  
s 

s 
  

a 

s   
a 

a 

a 
network  

 

  

   

a 

 

   

 

s   

  

s   
a 

a 

  

   

ba 

  

 

s 

ut  

rc 

  

 

 

  
  

  

s 

tb  

 

s   
a 

  

network  
ba 

 

sz  

  

a 

a 

a 

rd 

   

  

gu 

  

s   
a 

   

  

network  

 

rv 

  

a 

 

s   

  

ga 

  
s 

s 
  

rp 

 

  
  
 

 a 

  

  

 
 

sb 

 

rb 

 

 b 

figure     the ipc   pipesworld network topologies  a   and a real network topology  b   the
segment volumes in the latter are annotated in    m  units 

the availability of this solver will enable the extension of the pipesworld benchmark  since it
will be easier to overcome the aforementioned difficulties in generating large feasible instances  we
hope to be able to generate feasible instances for real world pipeline topologies  like the one shown
in figure    
in addition to generating larger instances  the pipesworld benchmark may be extended in many
ways to make it closer to the real application scenario  the relevant possible extensions include 
 defining some pipeline segments with a single flow direction  that is  segments where only
push or pop actions are allowed  note that this introduces dead ends critical choices into
the problem 
 un personalized goals  this could be accomplished  e g   by imposing the desired tank volume for the goal products in the respective areas  the planner then also has to decide which
batches will be used to bring the tank volume up to the desired level 
 modeling production and consumption of products at pre specified points in time  as described above 

   

fie ngineering b enchmarks

for

p lanning

 using rational numbers to model tank capacities and current volumes  instead of the encoding
based on unitary tank slots  apart from being a more precise model of the real world  when
combined with rational valued batch sizes  see below   such an encoding would avoid unnecessary symmetries that currently arise from the availability of several non distinguishable
tank slots  in the same area  for the same product  
the most important shortcoming of our encoding is the use of unitary batches  it would be much
more appropriate to base the encoding on product amounts given by real numbers  one problematic
aspect of such an encoding is that it would  most naturally  demand a continuous choice of how
much liquid to pump into a pipeline  like in airport  c f  section a       such a choice could
naturally be modelled using fox and longs        duration inequalities  but it is unclear how to
develop planners that can deal with these reasonably well  unlike in airport  implementing such
a choice is not the end of the difficulties on the modelling side  how to model the continuous
contents of a pipeline  the number of distinct regions of liquid in the pipeline can grow arbitrarily
high  in principle  one solution might be to fix some upper bound  and simply disallow a pumping
operation if it would result in too many distinct regions  this may be a bearable loss of precision 
given the upper bound is high enough  but even then  it is bound to be awkward to correctly update
the contents of the pipeline when some amount x of product is pushed in  the number of different
products leaving the pipe depends on x  an option here may be to use a complicated construct of
conditional effects 
all in all  our impression is that pipeline scheduling wont be realistically modelled in pddl 
and successfully solved with planners  unless one introduces into the language a data structure
suitable for modelling the contents of pipes  basically  this would be queues whose elements are
annotated with real numbers  and whose basic operations are the usual push and pop  the
semantics of the pipes could then be explicitly computed inside the planner  rather than awkwardly
modelled using language constructs that are likely to disturb a general search mechanism 
a   promela
this domain was created for ipc   by stefan edelkamp 
a     a pplication d omain
before dropping into the promela domain  we briefly recall its origin 
the model checker spin  holzmann        targets efficient software verification  it has been
used to trace logical design errors in distributed systems design  such as operating systems  data
communications protocols  switching systems  concurrent algorithms  railway signaling protocols 
etc  the tool checks the logical consistency of a specification  spin reports on deadlocks  unspecified receptions and identifies race conditions  and unwarranted assumptions about the relative speeds
of processes  spin  starting with version    provides support for the use of embedded c code as
part of model specifications  this makes it possible to directly verify implementation level software
specifications  using spin as a driver and as a logic engine to verify high level temporal properties  spin works on the fly  which means that it avoids the need to construct a global state graph
as a prerequisite for the verification of system properties  spin supports property checking in linear temporal logic  ltl   ltl expresses state trajectory constraints  using temporal modalities like

   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

eventually  always  and until     spin uses specific mechanisms for specifying deadlock freeness
and other safety properties  in addition to general ltl specifications  to explore the state space an
ordinary or a nested search algorithm is applied  depending on whether or not a state based  a k a 
safety  property is to be verified 
promela is spins input specification language  its computational model is that of asynchronous
communicating finite state machines  promela allows to define classes of finite processes  a special
process called init is started first and usually governs the instantiation of the other processes of the
system  as it is possible for a process to invoke another one  promela allows modeling systems with
dynamic creation of state components  communication in promela is achieved via shared variables
and message channels  two kind of message channels are distinguished for synchronous and asynchronous communication  an asynchronous channel is basically a fifo queue  while synchronous
channels imply rendezvous communication in which a transition of the system involves two processes  one reading a message from the channel and another sending a message to it  here  we
consider only asynchronous communication  the body of each process class is basically a sequence
of statements  each statement is interpreted as a transition of the process  typical statements include assignments  numerical and boolean expressions and channel operations  promela also allows
to define atomic regions  whose are a sequence of transitions that should be treated as an atomic
action  they can be interpreted as weighted transitions whose costs are the number of steps within
the regions   
for ipc    we used two example communication protocols formulated in promela  dijkstras
dining philosophers problem  and the so called optical telegraph protocol  we briefly describe
the latter protocol in section a      to illustrate the promela language  let us consider the dining
philosophers problem  where n philosophers sit around a table to have lunch  there are n plates 
one for each philosopher  and n forks located to the left and to the right of each plate  since two
forks are required to eat the spaghetti on the plates  not all philosopher can eat at a time  moreover 
no communication except taking and releasing the forks is allowed  the task is to devise a local
strategy for each philosopher that lets all philosophers eventually eat  the simplest solution to
access the left fork followed by the right one  has an obvious problem  if all philosophers wait for
the second fork to be released there is no possible progress  a deadlock has occurred 
it is not difficult and probably insightful to derive a bottom up pddl encoding for the dining
philosophers domain  using actions like eat  wait and think  our motivation  however  was to come
up with a top down encoding  starting from a promela specification  automatically translating it into
pddl 
the deadlock model of the dining philosophers is specified in promela as shown in figure    
the first lines define some macros and declare the array of n boolean variables that represent the
availability of the forks  the following lines define the behavior of a process of type philosopher 
the process iterates indefinitely in an endless loop  do  with one unique entry marked by symbol
    statements are separated by a semicolon  the first transition left fork consists of the send
operation of tag fork to channel left  which itself is a macro to address forks with the current
process id pid  it represents the availability of the left fork of the philosopher  the access transition left fork can be executed only if reading tag fork from channel left is successful  the
    note that some fragments of ltl are likely to be included into the pddl language for the next international planning
competition  gerevini   long       
    further documentation for the promela specification language can be found on the web site for spin at
http   netlib bell labs com netlib spin whatispin html

   

fie ngineering b enchmarks

for

p lanning

 define max philosophers n
mtype fork
 define left forks  pid 
 define right forks   pid      max philosophers 
chan forks max philosophers        of bit 
active  max philosophers  proctype philosopher  
 
left fork 
do
  left fork       try to get left fork   
right fork     try to get right fork   
   eat      
left fork  right fork    release forks   
   meditation      
od
 
figure     promela specification for a model of the dining philosophers problem 
next transition right fork is similar to the first  while the last two ones sends tag fork back to
the channels left and right 
a     ipc   pddl a daptation
model checking and action planning are closely related  c f  section    while a model checker
searches for a counterexample in the form of a sequence of transitions to falsify a given specification  a planner searches for a sequence of actions that satisfies a given goal  in both cases  the
basic models  strips planning  kripke structures   refer to implicit graphs  where the nodes are
annotated with atomic propositions 
for automatically generating a pddl model from the promela syntax we wrote a compiler  edelkamp      a   it is restricted to safety properties  especially deadlocks  but assertions
and global invariances are not difficult to obtain  we also concentrated on models with a fixed number of processes  since most of the models of communication protocols adhere to this restriction   
the compiler does not parse the promela code itself  but takes as the input the intermediate
representation of the problem that is generated by the spin validation tool     figure    shows
the textual automata representation for the philosopher process  in this case  the value n has been
initialized with    philosophers  while this file contains almost all necessary information for the
    the dynamic creation of processes with pddl would require a language extension for dynamic object creation 
this extension was dismissed since it would involve heavy changes to existing planner technology  and its relevance
 beyond promela  is unclear 
    more precisely  the promela input file was taken  the corresponding c file was generated  the verifier was compiled
and the executable was run with option  d 

   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

translation  the number of processes and queues  i e   message channels  as well as the queue capacities had to be read from the original promela input file    
proctype philosopher
state     trans      state   line       forks  pid  fork
state     trans      state   line       forks  pid  fork
state     trans      state   line       forks    pid         fork
state     trans      state   line       forks  pid  fork
state     tras      state   line       forks    pid         fork
figure     automata representation for the model of the    dining philosophers problem 
to derive a suitable pddl encoding of the domain  each process is represented by a finite state
automata  hence  the propositional encoding simulates the automaton  some propositional atoms
true in the initial state of one process in the running example problem is shown in figure     a     

 is a process philosopher   philosopher 
 at process philosopher   state   
 trans philosopher trans   state   state   
 trans philosopher trans   state   state   
 trans philosopher trans   state   state   
 trans philosopher trans   state   state   
 trans philosopher trans   state   state   

 is a queue forks   queue   
 queue head forks   qs   
 queue tail forks   qs   
 queue next queue   qs   qs   
 queue head msg forks   empty 
 queue size forks   zero 
 settled forks   

 a 

 b 

 writes philosopher   forks   trans     trans msg trans   fork 
 reads philosopher   forks   trans     trans msg trans   fork 
 reads philosopher   forks   trans     trans msg trans   fork 
 writes philosopher   forks   trans     trans msg trans   fork 
 c 
figure     propositional encoding of one philosophers process  a   propositional encoding of a
 single cell  communication channel  b   connecting communication to local state transitions  c  
the encoding of the communication structure represents channels as graphs  the pddl encoding additionally exploits a cyclic embedding of a queue into an array  more formally  each  fifo 
channel q is represented by a structure gq    sq   headq   tailq   q   messq  contq    with sq being
the set of queue cells  headq   tailq  sq being the head and tail cells of q  messq  m sq   being
    to avoid conflicts with pre compiler directives  we first invoked the c compiler with command line option  e  which
only executes the pre compiler 
    here we use transition ids  in the competition a less accessible textual representation of the label was chosen 

   

fie ngineering b enchmarks

for

p lanning

the vector of messages in q  m is the set of all messages   contq  ir sq   being the vector of
variable values in q and q   sq  sq being the successor relation for q  if sq   s             s k 
then  s i     s  i      mod k   explicitly modeling head and tail positions in the queue trades
space for time  since queue updates reduce to constant time 
a queue is either empty  or full  if both pointers refer to the same queue state  as a special case 
very simple queues  as in our example  may consist of only one queue state  so the successor bucket
of queue state   is the queue state   itself  in this case the grounded propositional encoding includes
operators where the add and the delete lists share an atom  we here make the standard assumption
that deletion is done first  the propositional atoms for one queue and the adaption of two queues to
one process are exemplified in figure     b  and  c  
queue content  shared and local variables are modeled by pddl fluents  the only difference of
local variables compared to shared ones is the restricted visibility scope  so that local variables are
prefixed with the process they appear in  the two benchmark protocols we selected for ipc   rely
on pure message passing  so that no numerical state variables there are involved  this allowed us to
supply a propositional model for all problems 
  action activate trans
 parameters   p   process  pt   proctype  t   transition  s   s    state 
 precondition  and  forall   q   queue   settled  q    trans  pt  t  s   s  
 is a process  p  pt   at process  p  s    pending  p  
 effect  and  activate  p  t   not  pending  p     
figure     testing if a transition is enabled and activating it 
our pddl domain encoding uses seven operators  named activate trans  queue read 
queue write  advance queue head  advance empty queue tail  advance non empty queue tail  and
process trans  the activation of a process is shown in figure     here we see that a pending process
is activated  if all queues are settled and there is a transition that matches the current process state 
briefly  the operators encode the protocol semantics as follows  operator activate trans activates
a transition in a process of a given type from local state s  to s    the operator sets the predicate
activate  this boolean flag is a precondition of the queue read and queue write actions  which set
propositions that initialize the reading writing of a message  for queue q in an activated transition
querying message m  this corresponds to the promela expression q m  respectively q m  after the
read write operation has been initialized  the queue update operators must be applied  i e  advancequeue head  advance empty queue tail  or advance non empty queue tail as appropriate  as the
names indicate  these operators respectively update the head and the tail positions  as needed to
implement the requested read write operation  the operators also set a settled flag  which is a
precondition of every queue access action  action process trans can then be applied  it executes the
transition from local state s  to s    i e  sets the new local process state and re sets the flags 
if the stored message does not match the query  or the queue capacity is either too small or too
large  then the active local state transition will block  if all active transitions in a process block  the
process itself will block  if all processes are blocked  we have a deadlock in the system  detection
of such deadlocks is implemented  in different domain versions  either as a collection of specifically
engineered actions or  more elegantly  as a set of derived predicates  in both cases one can infer 
along the lines of argumentation outlined above  that a process the entire system is blocked  the
   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

  derived  blocked trans  p   process  t   transition 
 exists   q   queue 
 exists   m   message 
 exists   n   number 
 and  activate  p  t   reads  p  q  t   settled  q 
 trans msg  t  m   queue size  q  n   is zero  n      
  derived  blocked  p   process 
 exists   s   state 
 exists   pt   proctype 
 and  at process  p  s   is a process  p  pt 
 forall   t   transition 
 or  blocked trans  p  t   forall   s    state   not  trans  pt  t  s  s          

figure     derivation of a deadlock 
goal condition that makes the planners detect the deadlocks in the protocols is simply a conjunction
of atoms requiring that all processes are blocked  as an example of the derivation rules for derived
predicates  the pddl description for the derivation of a deadlock based on blocked read accesses is
shown in figure    
a     ipc   d omain s tructure
for each of the two benchmark protocols in ipc    we created three different domain versions 
derivedpredicates  which contains derived predicates to infer deadlocks  plain  a purely propositional specification with specific actions that have to be applied to establish the deadlock  the later
actions are basically the gazen and knoblock        compilation of derived predicates  c f  section     fluents an alternative to the latter with numerical state variables that encodes the size of
the queues and the messages used to access their contents  we also made a version called fluentsderivedpredicates  the obvious combination  but none of the ipc   competitors participated in there 
so we omit it herein  within each domain version  there is one formulation that includes the adl
constructs quantification  disjunctive preconditions  and negated preconditions  in those domain
versions without fluents  another formulation is in pure strips  obtained from the respective adl
encodings using the adl strips compiler  which can not handle numeric variables   unfortunately 
some of the larger problem instances lead to strips files that were too big to be stored on disk
 remember that adl strips grounds out all operator parameters   these too large instances were  of
course  left out of the respective test suites 
we kept fluent domains as separated domain versions  rather than domain version formulations 
in order be able to compare propositional and numerical exploration efficiencies  and to emphasize
that fluent variables are essential in real world model checking and should be treated separately 
the domain versions and numbers of operators and ground actions are overviewed in table   
consider the rows in the table from top to bottom  as before  times in parentheses are values
before ffs reachability pre process  which builds a relaxed planning graph for the initial state
and removes all actions that do not appear in that graph  the strips formulation is fully grounded
using the adl strips program  derived from ffs pre processor  c f  section     this is both the

   

fie ngineering b enchmarks

version
optical telegraph
optical telegraph
optical telegraph dp
optical telegraph dp
optical telegraph fluents
philosophers
philosophers
philosophers dp
philosophers dp
philosophers fluents

formulation
strips
adl
strips dp
adl dp
adl
strips
adl
strips dp
adl dp
adl

for

p lanning

max  op
    
  
    
  
  
   
  
    
  
  

max  act
           
           
           
           
           
         
         
           
           
         

table    overview over the different domain versions of promela  abbreviations used  dp derived predicates  max  op is the maximum number of  parameterized  pddl operators
for any instance  max  act is the maximum number of ground actions for any instance 
data in parentheses are collected before ffs reachability pre process  see text   derivation rules  ground derivation rules  are counted as operators  ground actions  

reason why the number of operators is the same as the number of ground actions  and why ffs preprocess  identical to the one run by adl strips  has no effect  in the adl formulation  we see that
the reachability pruning reduces the number of actions by a factor of almost    similar to the airport
domain  c f  section a       the picture for the next two domain versions  with derived predicates 
is very similar  in fact  since  consistently with the data in section    we count derivation rules as
actions  the data are identical  the only reason why it is not identical in table   is that  using derived
predicates instead of operators  ffs pre processor scales to larger instances  presumably  due to
some unimportant implementation detail   in the next domain version  formulated with numeric
variables  ffs pre processor scales even worse  however  even in instances with the same number
of telegraphs  there are less ground actions than before  due to the more different encoding  the
observations to be made in dining philosophers are exactly the same  only with different numbers 
the only notable difference is that the effect of ffs reachability pruning is weaker  yielding only a
slight decrease in the number of actions in the versions without fluents  and no decrease at all in the
version with fluents  apparently  the more complex process structure of optical telegraph leads to
more useless action instances 
a     ipc   e xample i nstances
as said  we have selected two simple communication protocols as benchmarks for ipc    the encoding of the dining philosopher problem as described above  and the so called optical telegraph
protocol  holzmann        
the optical telegraph protocol involves n pairs of communicating processes  each pair featuring an up and a down process  such a pair can go through a fairly long  heavily interactive 
sequence of operations  implementing the possible data exchange between the two stations  before
data are exchanged  various initializing steps must be taken to ensure the processes are working
synchronously  most importantly  each process writes a token into a control channel  queue  at
   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

the beginning of the sequence  and reads the token out again at the end  this causes a deadlock
situation because there are only n control channels  each of which is accessed by two processes 
when every pair of up down processes has occupied just one control channel  the overall system is
blocked 
in both the dining philosopher and the optical telegraph benchmark  the instances scale via a
single parameter  the number of philosophers and the number of control stations  respectively  we
scaled that parameter from   to    for the competition instances  the promela models of the benchmarks are distributed together with our experimental model checking tool hsf spin  edelkamp 
leue    lluch lafuente         that extends spin with heuristic search strategies to improve error
detection 
a     f uture w ork
in general terms  we see the promela planning benchmark as another important step towards exploiting synergies between the research areas of planning and model checking  giunchiglia   traverso 
       for example  complement to recent progress in planning  explicit directed model checking
in the domain of protocol validation  edelkamp et al         and symbolic directed model checking
in the domain of hardware validation  reffel   edelkamp        has led to drastic improvements
to state of the art model checkers  this and other work  e g    yang   dill        bloem  ravi 
  somenzi         show that in model checking there is a growing interest in guided exploration 
mostly to find errors faster than blind state space enumeration algorithms  with the compilation of
the promela domain model  an alternative option of applying heuristic search to model checking
problems is available  more work is needed to understand when planning heuristics work or fail in
model checking benchmarks 
we strongly believe that both communities will profit from a wide spread availability of techniques that represent model checking problems in pddl  this allows a direct comparison of exploration efficiencies  based on the design of the promela domain  suitable pddl domain encodings of
two further expressive model checking input languages  graph transformation systems  edelkamp 
jabbar    lluch lafuente        and petri nets  edelkamp   jabbar         have been proposed 
the encodings exploit the expressive power of pddl as well as the efficiency of current planners 
as a result  state of the art planners are often faster compared to model checkers in these benchmarks 
a   psr
sylvie thiebaux and others have worked on this application domain  the domain was adapted for
ipc   by sylvie thiebaux and jorg hoffmann 
a     a pplication d omain
the power supply restoration  psr  domain we consider here is derived from an application investigated by sylvie thiebaux and others  thiebaux et al         thiebaux   cordier         psr
deals with reconfiguring a faulty power distribution system to resupply customers affected by the
faults  this is a topic of ongoing interest in the field of power distribution 
in more detail  a power distribution system  see figure      is viewed as a network of electric lines connected by switches and fed via a number of power sources that are equipped with
circuit breakers  switches and circuit breakers have two possible positions  open or closed  and are
   

fie ngineering b enchmarks

for

p lanning

figure     sample power distribution system  sources circuit breakers  e g   cb   are represented
by large squares  and switches  e g   sd   by small squares  open switches  e g   sd  
are white  the area fed by cb  is boxed  gray and dark are used to distinguish adjacent
areas fed by different sources

connected to at most two lines  there is no restriction on the connectivity of lines  some extremities
of which can also be connected to earth  when the circuit breaker of a power source is closed  the
power flows from the source to the lines downstream  until the flow is stopped by an open switch 
the switches are used to appropriately configure the network and their position is initially set so
that each line is fed by exactly one source 
due to bad weather conditions  permanent faults can affect one or more lines of the network 
when a power source feeds a faulty line  the circuit breaker fitted to this source opens to protect the
rest of the network from overloads  this leaves all the lines fed by the source without power  the
problem consists in planning a sequence of switching operations  opening or closing switches and
circuit breakers  bringing the network into a configuration where a maximum of non faulty lines
are resupplied  for instance  suppose that line l   becomes faulty  this leads the circuit breaker
cb  to open and the boxed area to be without power  a possible restoration plan would be the
following  open switches sd   and sd   to isolate the faulty line  then close sd   to have source
cb  resupply l    and finally re close cb  to resupply the others 
in the original psr problem  thiebaux   cordier         the maximal capacity of sources and
lines  as well as the load requested by customers are taken into account  the plan must optimize
various numerical parameters such as breakdown costs  power margins  and distance to the initial
configuration  subject to the capacity constraints  furthermore  due to the fault sensors and switches
being unreliable  the location of the faults and the current network configuration are only partially
observable  when optimizing  this leads to a complex tradeoff between acting to resupply lines and
acting  intrusively  to reduce uncertainty 

   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

a     ipc   pddl a daptation
in the pddl adaptation  we benefited from contributions by piergiorgio bertoli  blai bonet  alessandro cimatti  and john slaney  bertoli et al         bonet   thiebaux         compared to the
original psr domain described above  the ipc   version underwent   major adaptations  firstly 
the ipc deals with fully observable domains  hence  while partial observability in psr is a crucial
issue  thiebaux et al         bertoli et al         bonet   thiebaux         the ipc version assumes
complete observability  secondly  given the difficulty of encoding even the basic problem  we chose
to ignore the numerical and optimization aspects of psr  capacities  power margins           thirdly 
the ipc   version is set up as a pure goal achievement problem  where the goal specifies a set of
lines that must be  re  supplied  we considered a more realistic goal asking the planner to supply
any line that can be  however  we were unable to compile this goal into strips in reasonable
space  and opted for the simpler goal to keep the strips formulation as consistent as possible with
others 
our highest level and most natural ipc   encoding of psr involves adl constructs and derived
predicates  briefly  the encoding works as follows  psr problem instances specify     the network
topology  i e   the objects in the network and their connections  the lines  the switching devices  that
is  the switches and the sources circuit breakers  two side constants side  and side  to denote the
two connection points of a switching device  and the connection relations between those objects  
    the initial configuration  i e   the initial positions  open closed  of the switching devices  and    
the modes  faulty or not  of the various lines  among those  only the devices positions can change 
a number of other predicates are derived from these basic ones  they model the propagation of the
current into the network with a view to determining which lines are currently fed and which sources
are affected by a fault  i e  feed a fault  the closed world assumption semantics of pddl   
derived predicates is exactly what is needed to elegantly encode such relations  these require a
recursive traversal of the network paths which is naturally represented as the transitive closure of
the connection relation of the network  the most complex of these derived predicates  upstream 
requires four parameters  two of which  however can only take two possible values  and expresses
that the power flows from one of the two sides of some device  side  sx of device  x  to one of the
sides of another  side  sy of device  y  this happens when the side of  x which is opposite to  sx is
directly connected to  sy  via some line   or if there exists some closed device  z one side of which
is upstream of  sx and the other side of which is connected to  sy 
  derived  upstream  x   device  sx   side  y   device  sy   side 
 and  closed  x 
 or  and     sx side    con  x side   y  sy  
 and     sx side    con  x side   y  sy  
 exists   z   device 
 and  closed  z 
 or  and  con  z side   y  sy   upstream  x  sx  z side   
 and  con  z side   y  sy   upstream  x  sx  z side         
from upstream  it is relatively easy to define predicates stating whether a given line is fed or a given
source is affected 

   

fie ngineering b enchmarks

for

p lanning

the goal in a problem instance asks that given lines be fed and all sources be unaffected   
the available actions are closing and opening a switching device  their effect is simply to set the
device position as requested  in addition  there is an action wait  which models the event of circuitbreakers opening when they become affected  wait is applicable when an affected source exists 
and is the only applicable action in that case  the open and close actions require as a precondition
that no source is affected   this  together with the goal  ensures that the wait action is applied as
soon as a source is affected  the effect of the wait action is to open all the affected circuit breakers 
concretely  the wait and close actions are as follows  note that open is similar to close and that earth
is treated as a device whose position cannot be changed by the actions  
  action close
 parameters   x   device 
 precondition  and  not     x earth  
 not  closed  x  
 forall   b   device   not  affected  b    
 effect  closed  x  
  action wait
 parameters   
 precondition  exists   b   device   affected  b  
 effect  forall   b   device   when  affected  b   not  closed  b     
it would have been possible to encode the opening of affected breakers as a conditional effect of the
close action  however  this would have required more complex derived predicates with an additional
device as parameter and a conditional flavor  specifying  e g   whether or not a circuit breaker would
be affected if we were to close that device 
a     ipc   d omain s tructure
we used four domain versions of psr in ipc    primarily  these versions differ by the size of
the problem instances encoded  the instance size determined in what languages we were able
to formulate the domain version  we tried to generate instances of size appropriate to evaluate
current planners  i e  we scaled the instances from push over for everybody to impossibly hard
for current automated planners  where we got our intuitions by running a version of ff enhanced
to deal with derived predicates  the largest instances are of the kind of size one typically encounters
in the real world  more on the instance generation process is said in section a     
the domain versions are named    large     middle     middle compiled  and    small 
version   has the single formulation adl derivedpredicates  version   has the formulations adlderivedpredicates  simpleadl derivedpredicates  and strips derivedpredicates  version   has the
single formulation adl  and version   has the single formulation strips  the formulation names simply give the language used  version   contains the largest instances  versions   and   contain  the
same  medium instances  and version   contains the smallest instances  the adl derivedpredicates
    note that after the circuit breaker of an affected source opens  this source is not affected any more  as it does not feed
any line  then  if the circuit breaker is closed again  the source will stay unaffected unless it re starts feeding a faulty
line 

   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

version
large
middle
middle
middle
middle compiled
small

formulation
adl dp
adl dp
simple adl dp
strips dp
adl
strips

max  op
 
 
    
    
 
    

max  act
            
           
           
           
       
           

table    overview over the different domain versions and formulations of psr  abbreviations used 
dp derived predicates  max  op is the maximum number of  parameterized  pddl
operators for any instance  max  act is the maximum number of ground actions for any
instance  data in parentheses are collected before ffs reachability pre process  see
text   derivation rules  ground derivation rules  are counted as operators  ground actions  

formulation is inspired by bonet and thiebaux         it makes use of derived predicates as explained above  and of adl constructs in the derived predicate  action  and goal definitions  in the
simpleadl derivedpredicates and strips derivedpredicates formulations  all adl constructs  except
conditional effects in the simpleadl case  are compiled away  the resulting fully grounded encodings are significantly larger than the original  while on the other hand the length of plans remains
nearly unaffected     the pure adl formulation is obtained from the adl derivedpredicates formulation by compiling derived predicates away  using the method described by thiebaux et al        
       while there is no significant increase in the domain size  the compilation method can lead to
an increase in plan length that is exponential in the arity of the derived predicates  no compilation
method can avoid such a blow up in the worst case  see thiebaux et al                indeed  in
our particular psr example instances  we observed a considerable blow up in plan length  we felt
that this blow up was too much to allow for a useful direct comparison of data generated for adlderivedpredicates as opposed to adl  and we separated the adl formulation out into domain version
  as listed above 
the strips domain formulation proved quite a challenge  all the    or so schemes we considered for compiling both derived predicates and adl constructs away led to either completely
unmanageable domain descriptions or completely unmanageable plans  the problem is that feasible compilations of derived predicates create new actions with highly conditional effects  and that
compiling those away is impractical  we therefore adopted a different fully grounded encoding inspired by bertoli et al          the encoding is generated from a description of the problem instance
by a tool performing the reasoning about power propagation  in the resulting tasks  the effects of the
close actions directly specify which circuit breakers open as a result of closing a switch in a given
network configuration  no derived predicates are needed  and consequently the strips encoding
is much simpler and only refers to the positions of the devices and not to the lines  faults  or connections  nevertheless  we were still only able to formulate comparatively small instances in strips 
without a prohibitive blow up in the encoding size 
    the only variation is due to the fact that the existential precondition of the wait action causes the compilation to split
this action into as many wait actions as circuit breakers

   

fie ngineering b enchmarks

for

p lanning

the domain versions  formulations  and their respective numbers of operators and ground actions  are shown in figure    data in parentheses are collected before ffs reachability preprocess  building a relaxed planning graph for the initial state and removing all actions that do not
appear in that graph  in the encodings using adl and derived predicates  this reduces the number of ground actions by a factor of around    for only adl  the factor is much smaller  for the
other encodings  no reduction at all is obtained  simply due to the fact that these encodings are obtained with adl strips  which uses the same pruning process  some interesting observations can be
made in the middle versions and formulations  the data shown there correspond to the largest
instance that ffs pre processor could handle in all versions formulations  to enable direct comparison  we see that  for formulation in simple adl and strips  we need to introduce some more
ground actions  we also see that  curiously  in the compilation of derived predicates  compilation to
middle compiled   the number of ground actions decreases dramatically  the reason for this lies
in that these data count ground derivation rules as ground actions  and in the subtleties of the compilation of derived predicates  in the middle formulations  almost all ground actions are in fact
ground derivation rules  these are compiled away for middle compiled following thiebaux et al 
              introducing a single action that has one distinct conditional effect for each derivation rule  c f  section    which just means that the complexity of thousands of derivation rules is
replaced with the complexity of an action with thousands of conditional effects 
a     ipc   e xample i nstances
due to contractual agreements  we were unable to use real data in the competition  instead  psr
instances were randomly generated using randomnet  a special purpose tool implemented by john
slaney 
power distribution networks often have a mesh able structure exploited radially  the path taken
by the power of each source forms a tree whose nodes are switches and whose arcs are electric
lines  terminal switches connect the various trees together  randomnet takes as input the number of
sources  a percentage of faulty lines  and a range of parameters for controlling tree depth  branching 
and tree adjacency  whose default values are representative of real networks  randomnet randomly
generates a network topology and a set of faulty lines  these are turned into the various pddl
encodings above by a tool called net pddl  implemented by piergiorgio bertoli and sylvie thiebaux 
net pddl computes the set of all lines that can be supplied  and makes this the goal 
the instances we generated make use of randomnet default settings  with two exceptions to
create problems of increasing difficulty  the first is that the maximal depth of the trees takes a range
of values up to twice the default  the larger this value  the harder the problem  the second is that
the percentage of faulty lines ranges from     to      problems at the middle of the range are harder
on average  those at the bottom of the range are more realistic 
each instance suite contains    instances  the small instances feature between   to   sources 
the middle instances feature up to    sources  and the large instances feature up to     sources 
the large instances are of a size typical for real world instances  or even larger  the example in
figure    is representative of a difficult instance in the middle set 
a     f uture w ork
while psr has been around for some time as a benchmark for planning under uncertainty  we expect
that the work done in the framework of ipc   will facilitate its acceptance as one of the standard

   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

benchmarks for planning  to this end  we have developed a psr resource web page giving access
to the relevant papers  data  and tools  net pddl  randomnet             one aspect of future work is to
complete and maintain this website  making available a number of already existing tools  such as
sydre  thiebaux et al          a domain specific system for the full psr problem  and matt grays
net jpeg which graphically displays networks generated by randomnet 
considering future ipcs  there is potential for extending the pddl encoding to take the numerical and optimization aspects of the benchmark into account  pddl like encodings of the partially
observable version of the benchmark exist  bonet   thiebaux        and are ready to be used in a
future edition of the probabilistic part of the ipc   
a   satellite
the satellite domain was introduced in ipc   by long and fox         it is motivated by a nasa
space application  a number of satellites have to take images of a number of spatial phenomena 
obeying constraints such as data storage space and fuel usage  in ipc    there were   versions of the
domain  corresponding to different levels of the language pddl     strips  numeric  simpletime
 action durations are constants   time  action durations are expressions in static variables   and
complex  durations and numerics  i e  the union of numeric and time  
the adaptation of the satellite domain for ipc   was done by jorg hoffmann  all ipc   domain
versions and example instances were re used  except simpletime  like in the other ipc   domains 
we didnt want to introduce an extra version distinction just for the difference between constant
durations and static durations  on top of the ipc   versions    new domain versions were added 
the idea was to make the domain more realistic by additionally introducing time windows for the
sending of the image data to earth  i e  to antennas that are visible for satellites only during certain
periods of time  according to derek long  the lack of such time windows was the main shortcoming
of the ipc   domain   
we extended the ipc   time domain version to two ipc   domain versions  time timewindows
and time timewindows compiled  we extended the ipc   complex domain version to the two ipc  
domain versions complex timewindows and complex timewindows compiled  in all cases  we introduced a new action for the sending of data to an antenna  an antenna can receive data of only
a single satellite at a time  an antenna is visible for only subsets of the satellites for certain time
periods  and the sending of an image takes time proportional to the size of the image  the time
windows were modelled using timed initial literals  and in the  compiled domain versions  these
literals were compiled into artificial pddl constructs  none of the domain versions uses adl
constructs  so of all versions there is only a single  strips  formulation 
the instances were generated as follows  our objectives were to clearly demonstrate the effect
of additional time windows  and to produce solvable instances only  to accomplish the former  we
re used the ipc   instances  so that the only difference between  e g   time and time timewindows 
lies in the additional time window constructs  to ensure solvability  we implemented a tool that read
the plans produced by one of the ipc   participants  namely tlplan  and then arranged the time
windows so that the input plan was suitable to solve the enriched instance  it is important to note
    the page is available at http   rsise anu edu au thiebaux benchmarks pds
    the probabilistic part of ipc   did not feature partially observable domains 
    we have learned in the meantime that the lack of time windows for the gathering of data is also  or even more 
essential  often  due to occlusion by other objects or due to the rotation of the earth  targets are visible only during
very restricted periods of time  this probably constitutes one of the most important future directions for this domain 

   

fie ngineering b enchmarks

for

p lanning

here that the time windows were not arranged to exactly meet the times extracted from the ipc  
plan  rather  we introduced one time window per each   take image actions  made the antenna
visible during that time window for only the respective   satellites  and let the image size for each
individual image be a random value within a certain range where the time window was   times as
long as the sending time resulting from the maximum possible size 
of course  the above generation process is arranged rather arbitrarily  and the resulting instances
might be a long way away from the typical characteristics of the satellite problem as it occurs in
the real world  while this isnt nice  it is the best we could do without inside knowledge of the
application domain  and it has the advantage that the enriched instances are solvable  and directly
comparable to the ipc   ones 
in the new domain versions derived from complex  we also introduced utilities for the time
window inside which an image is sent to earth  for each image  the utility is either the same for all
windows  or it decreases monotonically with the start time of the window  or it is random within
a certain interval  each image was put randomly into one of these classes  and the optimization
requirement is to minimize a linear combination of makespan  fuel usage  and summed up negated
image utility 
a   settlers
the settlers domain was introduced in ipc   by long and fox         it makes extensive use of
numeric variables  these variables carry most of the domain semantics  which is about building up
an infrastructure in an unsettled area  involving the building of housing  railway tracks  sawmills 
etc  the domain was included into ipc   in order to pose a challenge for the numeric planners 
the other domains mostly do not make much use of numeric variables  other than computing the
 static  durations of actions    we used the exact same domain file and example instances as in
ipc    except that we removed some universally quantified preconditions to improve accessibility
for planners  the quantifiers ranged over domain constants only so they could easily be replaced by
conjunctions of atoms 
a   umts
roman englert has been working in this application area for several years  the domain was adapted
for ipc   by stefan edelkamp and roman englert 
a     a pplication d omain
probably the best known feature of umts  universal mobile telecommunication standard  is
higher bit rate  holma   toskala         packet switched connections can reach up to   mega
bit per second  mbps  in the optimal case  compared to existing mobile networks  umts provides
a new and important feature  namely the negotiation of quality of service  qos  and of transfer
properties  the attributes that define the characteristics of the transfer are throughput  transfer delay  and data error rate  umts bearers have to be generic in order to provide good support for
existing applications and the evolution of new applications  applications and services are divided
    note that  to some extent  this is just because the numeric values were abstracted away in the pddl encoding 
mostly  in airport and pipesworld  c f  sections a     and a      in order to obtain a discrete encoding suitable for
pddl    style actions 

   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

class

constraints

examples

conversational
preserve time
relation between
information flow
on the stream 
conversational
pattern  low delay 
voice  video
telephony  
video games

streaming
preserve time
relation between
information
entities of the
stream

interactive
request response pattern 
preserve data
integrity

background
undefined
delay 
preserve
data
integrity

streaming
multimedia

web browsing 
network games

background
download
of e mails

table    umts quality of service classes and their characteristics 
into four traffic classes by their qos  ts             holma   toskala         the traffic classes 
their fundamental characteristics  and examples for applications are summarized in table   
the main distinguishing factor between these classes is how delay sensitive the traffic is  the
conversational class is very delay sensitive  approximately    ms time preservation   and the background class has no defined maximum delay 
the umts call set up can be modularized using the perspective of intelligent software agents
 appleby   steward        busuioc         since agents are logical units and enable a discrete
perspective of the continuous signaling process  the call set up is partitioned into the following
modules that are executed in sequential order  englert        
trm the initial step is the initiation of an application on the mobile and the determination of the
required resources for the execution  the resources of the mobile like display and memory are
checked by the terminal resource management  trm  and allocated  if possible  otherwise 
the execution is aborted 
ct the wireless connection to the radio network is initiated via the dedicated control channel of
gsm  holma   toskala         in case of success  the transmission of ready for service
is transferred via the node b to the mobile in order to ensure the connection timing  ct  for
bearer service availability 
am the information of the mobile like location and data handling capabilities is sent to the application server in the internet  cf  aeei   the transmission can be done comfortably by a
so called service agent  farjami  gorg    bell        that is controlled by the agent management  am  in the cnd  the advantage of a service agent is  that in case of failure  e g  
network resources are not sufficiently available  the agent can negotiate with the terminals
agent about another qos class or different quality parameters 
aeem a service agent with the required qos class for the execution of the application and with
parameters of the mobile application is sent from the mobiles agent execution environment
mobile  aeem  to the application server in the internet  cf  aeei  
rrc the radio resource controller  rrc  provisions allocates the required qos by logical resources from the mac level in the radio bearer  holma   toskala        
   

fie ngineering b enchmarks

for

p lanning

rab then  the bearer resources are supplied on the physical level from the radio access bearer
 rab  from the cnd and the call flow is set up by mapping the logical qos parameters and
the physical qos resources together 
aeei the agent execution environment internet  aeei  establishes the data transfer from the
core network to a pdn  e g   internet  and sends a service agent  controlled by am  to the
application in the pdn in order to ensure the qos for the application 
bs finally  the bearer service  bs  for the execution of the mobile application is established with
the required radio bearer resources with qos  messages are sent to the modules trm and
aeei to start the execution of the application 
these modules are executed in sequential order to set up a call for the execution of mobile
applications  two modules  aeem and aeei  have to be executed in time windows in order to
ensure that the agents are life in the network  however  two constraints have been added  first  the
intra application constraint  where modules from one application are ordered  second  the interapplication constraint  where modules with same names from different applications cannot be executed in parallel in order to ensure that the required resources are available 
a     ipc   pddl a daptation
besides action duration  the domain encodes scheduling types of resources     consuming some
amount at action initialization time and releasing the same amount at action ending time  scheduling
types of resources have not been used in planning benchmarks before  and the good news is that
temporal pddl     level    is capable of expressing them  in fact we used a similar encoding to
the one that we found for job  and flow shop problems  as one feature  actions are defined to
temporarily produce rather than to temporarily consume resources  as current pddl has no way
of stating such resource constraints explicitly  planners that want to exploit that knowledge have to
look for a certain patterns of increase decrease effects to recognize them  additionally  the resource
modeling of our umts adaptation is constrained to the most important parameters  in total      in
real networks several hundred parameters are applied 
in umts  two subsequent actions can both check and update the value of some resources  e g  
has mobile cpu  at their starting  resp  ending  time points as far as the start  resp  ending  events
are separated by  time steps  where  is minimum slack time required between two dependent
events  when modeling renewable resources with an over all construct the invariant condition of
the action has to check  what the at start event did change  we decided that this is not the best choice
for a proper temporal action  consequently  the temporal actions require resources to be available
before adding the amount used 
finally  the time windows for the two agent based modules are defined using the average execution times of the modules  the average times are estimated based on signaling durations of the
umts network  holma   toskala        
resources may be renewable or consumable  an example for a renewable resource is the keyboard of the mobile  it can be used to input data for several applications  consumable resources are
    the terminology for resources in planning and scheduling varies  in job shop scheduling  a machine is resource 
while in planning such a machine would be a domain object  in pddl  renewable and consumable resources are
both modeled using numerical fluents and are not per se distinguished 

   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

mobile cpu
d available
e balance
mobile channels
 available
num mobiles
num calls
mobile storage
logical channels
cell update
handover
active set up
ggsn bitrate
max no pdp
max no apn

used with x per cent per application
partition of the display  e g   ticker and chess
energy balance of mobile accumulator
used for data transfer
number of mobiles which are tractable
by a node b
mobile network load for a node b
memory on s im at card
number of logical channels available in the cn
report ue location into rnc
handover required to get a higher bit rate
update connection
capacity  kbit s  from ggsn to pdn
max  no  of packet data protocols per mobile
max  access point names  apn  per mobile

table    scheduling types of resources in the umts call set up 
released after action execution  the resources that are realized in the experiments are summarized
in table    see  gpp       for a complete list of resources for the umts call set up  
the pddl representation of the planning domain is based on the eight modules for the umts
call set up  there are eight operators corresponding to these eight modules  let us consider  as an
example  the bs action  that is  the final action that can be used to establish the predicate bs ok 
it is defined as follows 
  durative action bs
 parameters
  a new   application  m   mobile  l   list  ms   ms    message  a   agent 
 duration
    duration  time bs  a new  
 condition
 and  at start  initiated  a new  m  
 at start  aeei ok  a new  m  l  a  
 at start  qos params  a new  l  
 at start  message trm  m  ms   
 at start  message aeei  a new  ms    
 effect
 and  at end  iu bearer  a new  m  l    at end  bs ok  a new  m  l  a     

the action has as preconditions the successful execution of the module aeei during the call
set up  the satisfaction of the required qos class parameters  denoted as list l   and the transfered
messages of the set up status to the application in the mobile and the pdn  the resources are already
allocated by the preceding modules  as effect the bearer and the network connection for the mobile
application are set up 
   

fie ngineering b enchmarks

for

p lanning

the initiation of an application starts in the mobile with the trm  afterwards  the ct in the
and is asked for a ready for service signal  in the core of the call set up is the radio access bearer
procedure in the cnd  let us consider the latter in more detail  as first step the logical resources
must be allocated  rrc   e g   the required number of channels must be provided by the logical
level in the radio bearer and later these logical resources are mapped to the physical channels  the
pddl rrc action looks as follows 
  durative action rrc
 parameters
  a new   application  m   mobile  l   list  a   agent 
 duration
    duration  time rrc  a new  
 condition
 and  at start  ct ok  a new  m  l  
 at start  aeem ok  a new  m  l  a  
 at start      has logical channels 
    max logical channels   app channels  a new  m    
 at start      has cell update      max cell update      
 at start     has handover   max handover   
 at start     has active set up   max active set up    
 effect
 and  at start  increase  has logical channels   app channels  a new  m   
 at end  decrease  has logical channels   app channels  a new  m   
 at start  increase  has cell update     
 at end  decrease  has cell update     
 at start  increase  has handover     
 at end  decrease  has handover     
 at start  increase  has active set up     
 at end  decrease  has active set up     
 at end  rrc ok  a new  m  l  a    

if the requested qos class is not available  then the fact rab ok is not true and a service
agent must be sent to the mobile in order to negotiate with the application or user for weaker qos
requirements  in case of success the predicate rab ok is true and the connection to the pdn must
be checked  finally  the goal predicate bs can be fulfilled if all resources are available 
a     ipc   d omain s tructure
as used in ipc    the umts domain has six versions  the first three are  temporal  a domain
version with no timing constraints  temporal timewindows  a domain version with pddl    timed
initial facts  and temporal timewindows compiled  a domain version with a pddl    wrapper encoding for the timed initial literals  the second domain version set flaw temporal  flaw temporaltimewindows  and flaw temporal timewindows compiled  includes the following flaw action 
  durative action flaw
parameters
  a new   application  m   mobile  l   list  a   agent 
 duration     duration   
 condition
   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

version
temporal
temporal tw
temporal twc
flaw temporal
flaw temporal tw
flaw temporal twc

formulation
strips temporal
strips temporal tw
strips temporal
strips temporal
strips temporal tw
strips temporal

max  op
 
 
  
 
 
  

max  act
         
         
         
         
         
         

table    overview over the different domain versions of umts  abbreviations used  temporaltw for temporal timewindows  temporal twc for temporal timewindows compiled 
max  op is the maximum number of  parameterized  pddl operators for any instance 
max  act is the maximum number of ground actions for any instance  data in parentheses are collected before ffs reachability pre process  see text  

 and  at start  initiated  a new  m  
 at start  qos params  a new  l  
 at start  trm ok  a new  m  l   
 effect
 and  at end  rab ok  a new  m  l  a  
 at start  not  initiated  a new  m     

this action offers a shortcut to the rab ok predicate  but can not be used in a real solution
because it deletes the initiated predicate  but the action can be used in heuristic functions
based on ignoring the negative effects  in that sense  the action encodes a flaw that may disturb
the heuristic techniques used in modern planners  to determine that the action is not useful  negative interactions have to be considered  the idea of flaw is practically motivated in order to see
how heuristic planners react to it  in its standard form  the domain is not a big challenge to such
planners  as we have seen in section    all domain versions have one formulation  namely stripsfluents temporal  where numerical fluents  but   except typing   no adl constructs are used  in all
instances  the plan objective is to minimize makespan 
the domain versions and numbers of operators and ground actions are overviewed in table    as
with many of the empirical data for umts that we have seen before  the data are quite exceptional 
and at the same time easy to interpret  first  similar to what we have seen in section      the data
are actually constant across all instances within each domain version  which is once again due to the
fact that the instances scale only in their specification of what applications need actually be started 
second  the numbers of operators and actions do not differ between the versions with and without
time windows  they increase somewhat  through the additional artificial actions  if we compile
timed initial literals away  c f  section     they also increase somewhat  of course  if we introduce
the flaw action  third  the most striking observation is the huge effect of ffs reachability preprocessor  building a relaxed planning graph for the initial state and removing all actions that do not
appear in that graph  this is due to the technical subtleties of the encoding  where the restrictions
on feasible action instantiations are  partly  implicit in the possible action sequences  rather than
explicit in the static predicates 

   

fie ngineering b enchmarks

for

p lanning

a     ipc   e xample i nstances
the umts call set up domain has the following challenges for the planning task  englert   cremers        
real time  can plans for the execution of mobile applications be generated in an appropriate time 
planning has to be done with a maximum duration that does not exceed the umts call set up
time 
completeness  is it possible to generate the plan  i e  does planning result in an  optimal  plan for
the required applications that minimizes the waiting period until all applications are started 
the pddl structure of the basic problem for the discrete umts call set up  ducs  domain is
the following 
 define  problem ducs domain basic version 
  domain ducs domain basic version
  objects ms  ms    message
a  a  a  a  a  a  a  a  a  a     application
m  m  m  m  m  m  m  m  m  m     mobile
l  l  l  l  l  l  l  l  l  l     list
ae   agent 
  init     time trm a           time ct a      
    time am a           time aeem a      
    time rrc a            time rab a      
    time aeei a           time bs a      
     
 location m      types
 authentification m  
     
    has mobile cpu        current status
       
  goal  and  bs ok a  m  l  ae           

first in this pddl description come the objects for the applications and the mobiles  then
come the durations of the modules depending on the applications  e g   the module trm requires
less time for a news ticker than for a chess game  since the latter requires more terminal resources
than the ticker  the current status of the resources is initialized  finally  the goal is defined  the
bearer establishment for the execution start of the initiated mobile applications  the total execution
time should be minimized 
for ipc   the time windows are varied with small perturbations in order to generate different
instances  the perturbations are motivated by the average execution times of the modules in a radio
network according to the load  furthermore  the number of applications to be set up is varied from  
up to     the domains assume that the applications run on one mobile terminal  however  they can
also be distributed to several mobile terminals  there are    different instances per domain version 
a     f uture w ork
the umts domain is not a big challenge for modern heuristic  i e  hsp ff lpg style  planners
because these planners are satisficing  potentially return sub optimal plans   the objective in umts
   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

is to minimize the execution time  and if one ignores that objective then the task trivializes  to
the optimal planners  umts is a realistic challenge  the domain is already relatively realistically
modelled  except for the left out additional constraints on the  many  less important resources  it
remains to be seen if  when introducing all these resources  planner  in particular optimal planner 
performance gets degraded  an option in this case may be to introduce explicit language constructs
for the different types  renewable and consumable  of resources 
in the future the following two challenges shall be investigated  first  the negotiation of umts
quality of service  qos  parameters could be considered  assume a video application on a mobile
terminal is initiated  but the bearer resources are not sufficiently available  then the qos has to be
negotiated between the terminal and the bearer  this leads to the planning of a negotiation during
the plan execution for the already initiated applications 
second  the approach for the optimization of the umts call set up can be applied to the wireless
lan registration  the challenge is to transfer the qos parameters  since the current wireless lan
standard        b  does not contain qos  this demerit can be solved by applying an additional
service level that addresses qos 

references
 gpp          g partnership project  www  gpp org 
appleby  s     steward  t          mobile software agents for control in telecommunication
networks  chap     in hayzelden  a  bigham  j   eds    software agents for future telecommunication systems  springer 
apt  k   blair  h     walker  a          towards a theory of declarative knowledge  in foundations
of deductive databases and logic programming  pp         morgan kaufmann 
bacchus  f     kabanza  f          using temporal logics to express search control knowledge for
planning  artificial intelligence              
bacchus  f          subset of pddl for the aips     planning competition  the aips    planning competition comitee  available at http   www cs toronto edu aips     pddl subset ps 
bacchus  f          the aips   planning competition  the ai magazine              
bertoli  p   cimatti  a   roveri  m     traverso  p          planning in nondeterministic domains
under partial observability via symbolic model checking   in nebel  nebel        
bertoli  p   cimatti  a   slaney  j     thiebaux  s          solving power supply restoration problems with planning via symbolic model checking  in proceedings of the   th european
conference on artificial intelligence  ecai      pp         lyon  france  wiley 
biundo  s   myers  k     rajan  k   eds     icaps            proceedings of the   th international conference on automated planning and scheduling  icaps      monterey  ca  usa 
morgan kaufmann 
bloem  r   ravi  k     somenzi  f          symbolic guided search for ctl model checking  in
conference on design automation  dac   pp       
blum  a  l     furst  m  l          fast planning through planning graph analysis  artificial
intelligence                  

   

fie ngineering b enchmarks

for

p lanning

boddy  m   gohde  j   haigh  t     harp  s          course of action generation for cyber security
using classical planning   in biundo et al   biundo  myers    rajan         pp       
bonet  b     geffner  h          planning as heuristic search  artificial intelligence          
    
bonet  b   loerincs  g     geffner  h          a robust and fast action selection mechanism for
planning  in proceedings of the   th national conference of the american association for
artificial intelligence  aaai      pp          mit press 
bonet  b     thiebaux  s          gpt meets psr  in giunchiglia  e   muscettola  n     nau 
d   eds    proceedings of the   th international conference on automated planning and
scheduling  icaps      pp          trento  italy  morgan kaufmann 
busuioc  m          distributed intelligent agents   a solution for the management of complex
telecommunications services  chap    in hayzelden  a  bigham  j   eds    software agents
for future telecommunication systems  springer 
bylander  t          the computational complexity of propositional strips planning  artificial
intelligence                 
cesta  a     borrajo  d   eds            recent advances in ai planning   th european conference
on planning  ecp     toledo  spain  springer verlag 
chen  y   hsu  c     wah  b          sgplan  subgoal partitioning and resolution in planning 
in edelkamp  s   hoffmann  j   littman  m     younes  h   eds    proceedings of the  th
international planning competition  whistler  bc  canada  jpl 
chien  s   kambhampati  r     knoblock  c   eds     aips            proceedings of the  th
international conference on artificial intelligence planning systems  aips      aaai press 
menlo park 
cimatti  a   roveri  m     traverso  p          automatic obdd based generation of universal
plans in non deterministic domains  in proceedings of the   th national conference of the
american association for artificial intelligence  aaai      pp          madison  wi  mit
press 
clarke  e  m   grumberg  o     peled  d  a          model checking  mit press 
dierks  h          finding optimal plans for domains with restricted continuous effects with uppaal cora  in icaps workshop on verification and validation of model based planning and
scheduling systems 
edelkamp  s       a   promela planning  in workshop on model checking software  spin   lecture notes in computer science  pp          springer 
edelkamp  s       b   taming numbers and durations in the model checking integrated planning
system  journal of artificial intelligence research             
edelkamp  s     jabbar  s          action planning for directed model checking of petri nets 
electronic notes in theoretical computer science              
edelkamp  s   jabbar  s     lluch lafuente  a          action planning for graph transition systems  in icaps workshop on verification and validation of model based planning and
scheduling systems  pp       
   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

edelkamp  s   leue  s     lluch lafuente  a          directed explicit state model checking in the
validation of communication protocols  international journal on software tools for technology              
englert  r          planning to optimize the umts call set up for the execution of mobile applications  int  journal of applied artificial intelligence               
englert  r     cremers  a  b          configuration of applications for the  rd generation mobile
communication  in ki workshop on ai in planning  scheduling  configuration and design
 puk   vienna  austria 
farjami  p   gorg  c     bell  f          advanced service provisioning based on mobile agents 
computer communications               
fikes  r  e     nilsson  n          strips  a new approach to the application of theorem proving
to problem solving  artificial intelligence            
fourman  m  p          propositional planning  in aips workshop on model theoretic approaches
to planning 
fox  m   long  d     halsey  k          an investigation into the expressive power of pddl    
in saitta  l   ed    proceedings of the   th european conference on artificial intelligence
 ecai      valencia  spain  wiley 
fox  m     long  d          the detection and exploitation of symmetry in planning problems 
in pollack  m   ed    proceedings of the   th international joint conference on artificial
intelligence  ijcai      pp          stockholm  sweden  morgan kaufmann 
fox  m     long  d          pddl     an extension to pddl for expressing temporal planning
domains  journal of artificial intelligence research            
frank  j   cheeseman  p     stutz  j          when gravity fails  local search topology  journal of
artificial intelligence research            
garagnani  m          a correct algorithm for efficient planning with preprocessed domain axioms 
in research and development in intelligent systems xvii  springer verlag 
gazen  b  c     knoblock  c          combining the expressiveness of ucpop with the efficiency
of graphplan   in steel    alami  steel   alami         pp         
gerevini  a     long  d          plan constraints and preferences  the aips    planning competition comitee  available at http   zeus ing unibs it ipc   pddl ipc  pdf 
gerevini  a   saetti  a     serina  i          an approach to temporal planning and scheduling in
domains with predictable exogenous events  journal of artificial intelligence research     
       
giunchiglia  f     traverso  p          planning as model checking  in biundo  s     fox  m 
 eds    recent advances in ai planning   th european conference on planning  ecp    
lecture notes in artificial intelligence  pp       durham  uk  springer verlag 
haslum  p     geffner  h          heuristic planning with time and resources   in cesta    borrajo
 cesta   borrajo         pp         
hatzack  w          entwicklung und auswertung von algorithmen zur autonomen verkehrskoordinierung und konfliktauflsung an flughfen  ph d  thesis  university of freiburg  freiburg 
germany 
   

fie ngineering b enchmarks

for

p lanning

hatzack  w     nebel  b          the operational traffic control problem  computational complexity and solutions   in cesta    borrajo  cesta   borrajo         pp       
helmert  m          complexity results for standard benchmark domains in planning  artificial
intelligence              
helmert  m          a planning heuristic based on causal graph analysis   in koenig et al   koenig 
zilberstein    koehler         pp         
helmert  m         personal communication 
helmert  m       a   the fast downward planning system  journal of artificial intelligence research      accepted for publication 
helmert  m       b   new complexity results for classical planning benchmarks  in long  d    
smith  s   eds    proceedings of the   th international conference on automated planning
and scheduling  icaps      pp        the english lake district  uk  morgan kaufmann 
hoffmann  j          local search topology in planning benchmarks  an empirical analysis   in
nebel  nebel         pp         
hoffmann  j          local search topology in planning benchmarks  a theoretical analysis  in
ghallab  m   hertzberg  j     traverso  p   eds    proceedings of the  th international conference on artificial intelligence planning and scheduling  aips      pp         toulouse 
france  morgan kaufmann 
hoffmann  j          the metric ff planning system  translating ignoring delete lists to numeric
state variables  journal of artificial intelligence research             
hoffmann  j          where ignoring delete lists works  local search topology in planning benchmarks  journal of artificial intelligence research             
hoffmann  j     edelkamp  s          the deterministic part of ipc    an overview  journal of
artificial intelligence research             
hoffmann  j     nebel  b          the ff planning system  fast plan generation through heuristic
search  journal of artificial intelligence research             
holldobler  s     stor  h  p          solving the entailment problem in the fluent calculus using
binary decision diagrams  in icaps workshop on model theoretic approaches to planning 
holma  h     toskala  a          wcdma for umts   radio access for  rd generation mobile
communications  wiley   sons 
holzmann  g          the spin model checker   primer and reference manual  addison wesley 
holzmann  g  j          design and validation of computer protocols  prentice hall 
howe  a     dahlman  e          a critical assessment of benchmark comparison in planning 
journal of artificial intelligence research          
kabanza  f     thiebaux  s          search control in planning for temporally extended goals   in
biundo et al   biundo et al          pp         
koehler  j     hoffmann  j          on the instantiation of adl operators involving arbitrary
first order formulas  in ecai workshop on new results in planning  scheduling and design 

   

fih offmann   e delkamp  t hi ebaux   e nglert  l iporace   t r ug

koehler  j   nebel  b   hoffmann  j     dimopoulos  y          extending planning graphs to an
adl subset   in steel    alami  steel   alami         pp         
koehler  j     schuster  k          elevator control as a planning problem   in chien et al   chien 
kambhampati    knoblock         pp         
koenig  s   zilberstein  s     koehler  j   eds     icaps            proceedings of the   th international conference on automated planning and scheduling  icaps      whistler  canada 
morgan kaufmann 
korf  r  e          real time heuristic search  artificial intelligence             
kvarnstrom  j   doherty  p     haslum  p          extending talplanner with concurrency and
ressources  in horn  w   ed    proceedings of the   th european conference on artificial
intelligence  ecai      pp          berlin  germany  wiley 
lago  u  d   pistore  m     traverso  p          planning with a language for extended goals 
in proceedings of the   th national conference of the american association for artificial
intelligence  aaai      pp          edmonton  al  mit press 
long  d     fox  m          automatic synthesis and use of generic types in planning   in chien
et al   chien et al          pp         
long  d     fox  m          the  rd international planning competition  results and analysis 
journal of artificial intelligence research          
mcdermott  d          a heuristic estimator for means ends analysis in planning  in proceedings
of the  rd international conference on artificial intelligence planning systems  aips     
pp          aaai press  menlo park 
mcdermott  d          the pddl planning domain definition language  the aips    planning competition comitee  available at http   ls  www cs uni dortmund de  edelkamp ipc  docs pddl ps gz 
mcdermott  d          the      ai planning systems competition  the ai magazine              
mcdermott  d  v          using regression match graphs to control search in planning  artificial
intelligence                   
milidiu  r  l     dos santos liporace  f       a   plumber  a pipeline transportation planner  in
international workshop on harbour and maritime simulation  hms   pp         rio de
janeiro  brazil 
milidiu  r  l     dos santos liporace  f       b   pipesworld  applying planning systems to
pipeline transportation  in proceedings of the international pipeline conference  ipc   pp 
       
nebel  b   ed     ijcai            proceedings of the   th international joint conference on artificial intelligence  ijcai      seattle  washington  usa  morgan kaufmann 
nebel  b          on the compilability and expressive power of propositional planning formalisms 
journal of artificial intelligence research             
pednault  e  p          adl  exploring the middle ground between strips and the situation
calculus  in brachman  r   levesque  h  j     reiter  r   eds    principles of knowledge
representation and reasoning  proceedings of the  st international conference  kr      pp 
        toronto  on  morgan kaufmann 
   

fie ngineering b enchmarks

for

p lanning

reffel  f     edelkamp  s          error detection with directed symbolic model checking  in world
congress on formal methods  fm   pp         
rintanen  j          phase transitions in classical planning  an experimental study   in koenig et al 
 koenig et al          pp         
ruml  w   do  m     fromherz  m          on line planning and scheduling for high speed manufacturing   in biundo et al   biundo et al          pp       
steel  s     alami  r   eds            recent advances in ai planning   th european conference on
planning  ecp     vol       of lecture notes in artificial intelligence  toulouse  france 
springer verlag 
thiebaux  s     cordier  m  o          supply restoration in power distribution systems  a
benchmark for planning under uncertainty   in cesta    borrajo  cesta   borrajo         pp 
     
thiebaux  s   cordier  m  o   jehl  o     krivine  j  p          supply restoration in power distribution systems  a case study in integrating model based diagnosis and repair planning 
in horvitz  e     jensen  f  v   eds    proceedings of the   th international conference on
uncertainty in ai  uai      pp          portland  oregon  usa  morgan kaufmann 
thiebaux  s   hoffmann  j     nebel  b          in defense of pddl axioms   in gottlob  g   ed   
proceedings of the   th international joint conference on artificial intelligence  ijcai     
pp          acapulco  mexico  morgan kaufmann 
thiebaux  s   hoffmann  j     nebel  b          in defense of pddl axioms  artificial intelligence 
              
ts               rd generation partnership project  technical specification group service and
system aspects  qos concept and architecture  release     ts         v        gpp 
vidal  v          a lookahead strategy for heuristic search planning   in koenig et al   koenig et al  
       pp         
wah  b     chen  y          subgoal partitioning and global search for solving temporal planning
problems in mixed space  international journal of artificial intelligence tools            
    
yang  c  h     dill  d  l          validation with guided search of the state space  in conference
on design automation  dac   pp         
younes  h   littman  m   weissman  d     asmuth  j          the first probabilistic track of the
international planning competition  journal of artificial intelligence research            

   

fi