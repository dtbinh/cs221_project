journal artificial intelligence research                  

submitted        published      

engineering benchmarks planning  domains used
deterministic part ipc  
jorg hoffmann

hoffmann   mpi   sb   mpg   de

max planck institute computer science 
saarbrucken  germany

stefan edelkamp

stefan   edelkamp   cs   uni   dortmund   de

fachbereich informatik 
universitat dortmund  germany

sylvie thiebaux

ylvie  t hiebaux   anu   edu   au

national ict australia   computer sciences laboratory 
australian national university  canberra  australia

roman englert

roman  e nglert   telekom   de

deutsche telekom laboratories 
berlin  germany

frederico dos santos liporace

liporace   inf  puc   rio   br

departamento de informatica  puc rio 
rio de janeiro  brazil

sebastian trug

trueg   informatik   uni   freiburg   de

institut fur informatik 
universitat freiburg  germany

abstract
field research general reasoning mechanisms  essential appropriate
benchmarks  ideally  benchmarks reflect possible applications developed technology  ai planning  researchers tend draw testing examples
benchmark collections used international planning competition  ipc   organization
 the deterministic part of  fourth ipc  ipc    authors therefore invested significant effort
create useful set benchmarks  come five different  potential  real world applications planning  airport ground traffic control  oil derivative transportation pipeline networks 
model checking safety properties  power supply restoration  umts call setup  adapting
preparing application use benchmark ipc involves  time  inevitable
 often drastic  simplifications  well careful choice between  engineering of  domain encodings  first time ipc  used compilations formulate complex domain features
simple languages strips  rather dropping interesting problem constraints simpler language subsets  article explains discusses five application
domains adaptation form pddl test suites used ipc    summarize known
theoretical results structural properties domains  regarding computational complexity
provable properties topology h  function  an idealized version relaxed
plan heuristic   present new  empirical  results illuminating properties quality
wide spread heuristic functions  planning graph  serial planning graph  relaxed plan  
growth propositional representations instance size  number actions available
achieve fact  discuss data conjunction best results achieved
different kinds planners participating ipc   

c
    
ai access foundation  rights reserved 

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

   introduction
today  large extent research discipline ai planning concerned improving performance domain independent generative planning systems  domain independent generative
planning system  planner  must able fully automatically find plans  solution sequences
declaratively specified transition systems  simplest planning formalism deterministic planning  there  planner given input set state variables  often booleans  called facts  
initial state  a value assignment variables   goal  a formula   set actions  with
precondition formula describing applicability  effect specifying action changes
state   plan time stamped sequence actions maps initial state state
satisfies goal  sort formalism called deterministic since initial state fully specified effects actions non ambiguous  restrictions may weakened obtain
non deterministic probabilistic planning 
performance planners measured testing benchmark example instances
planning problem  best algorithm point time is  generally  considered one
solves examples efficiently  particular  idea international planning competition  ipc   biennial event aimed showcasing capabilities current planning
systems 
first ipc took place       time writing four events  providing details ipc beyond scope paper  refer reader overview
articles written organizers respective ipc editions  mcdermott        bacchus       
long   fox        hoffmann   edelkamp         particular  hoffmann edelkamp       
provide details  th ipc  overall organization  different tracks  evaluation  participating planners  results  basic information included paper  reader
able follow main discussion without detailed background  language used describe
planning problems ipc called pddl  planning domain definition language  introduced mcdermott        first ipc  ipc          subset language
selected bacchus        ipc         language extended temporal numerical constructs fox long        form language pddl    ipc        
extended two additional constructs  timed initial literals derived predicates 
hoffmann edelkamp        form language pddl    ipc        
since  even simplest forms  ai planning computationally hard problem  system
work efficiently problem instances  bylander        helmert         thus  crucial importance kinds examples used testing  today  more  ai planning
researchers draw testing examples collections used ipc  makes ipc
benchmarks important instrument field  organization deterministic part
 th ipc  there probabilistic part  see younes  littman  weissman    asmuth 
       authors therefore invested considerable effort creating set useful benchmarks
planning 
first question answer precisely meant word useful 
easy question  widely accepted mathematical definition deciding whether
set benchmarks considered useful  are  however  widely accepted intuitions
case  benchmarks be 
   oriented applications benchmark reflect application technology developed field 
   

fie ngineering b enchmarks



p lanning

   diverse structure set benchmarks cover different kinds structure  rather
re state similar tasks 
first usually considered particularly important indeed  ai planning frequently criticized obsession toy examples  recent years  performance
state of the art systems improved dramatically  realistic examples come
within reach  made another step direction orienting ipc   benchmarks
application domains  traditionally planning benchmarks less fantasy products
created real scenario mind   took actual  possible  applications planning
technology  turned something suitable competition  considered five different application domains  airport ground traffic control  airport   oil derivative transportation
pipeline networks  pipesworld   model checking safety properties  promela   power supply restoration  psr   setup mobile communication umts  umts   course  adaptation
application use ipc  simplifications need made  get back below 
diverse structure benchmarks traditionally given less attention realism 
believe less important  structure underlying testing example determines
performance applied solving mechanism  particularly true solving mechanisms
whose performance rises falls quality heuristic use  hoffmanns             
      results suggest much spectacular performance modern heuristic search planners
due structural similarities traditional planning benchmarks 
imply modern heuristic search planners arent useful  certainly shows
creation benchmarks risk introducing bias towards one specific way solving
them  selecting benchmark domains ipc    tried cover range intuitively
different kinds problem structure  get back below 
one hand  creator planning benchmarks noble goal realistic  structurally diverse  benchmark domains  hand  he she pragmatic goal
come version representation benchmarks attacked existing planning systems  given still quite restricted capabilities systems  obviously two goals
conflict  make matters worse  isnt arbitrarily large supply planning applications
publicly available  and or whose developers agree application used basis
benchmark  ipc organizer  top this  final benchmarks must accessible
large enough number competing systems  means must formulated language
understood systems  further  benchmarks must show differences scalability planners  i e   must easy hard  thus straddling boundary current
system capabilities 
solution difficulties  least solution organization ipc    involved slow tedious interleaved process contacting application developers  choosing domains 
exploring domain versions  engineering domain version representations  article presents 
motivates  discusses choice benchmark domains ipc    explains engineering
processes led finally used domain versions instances  further  report about 
present new data determining certain structural properties resulting benchmarks
 more details below   main contribution work set benchmarks  provided
   course  exceptions rule  one important one  context here  satellite domain  used
ipc    refined use ipc    later 

   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

ipc     contributions article are  first  providing necessary documentation
benchmarks  second  describing technical processes used creation  third  providing
extensive discussion structural properties benchmarks  apart technical contributions  believe work value example large scale attempt
engineering useful set benchmarks classical planning 
difficult make formal claim created set benchmarks 
way better previous benchmarks  working this  intent
overcome certain shortcomings many benchmarks  though one would hard pressed come
formal proof improvements indeed made  all  judging quality
set benchmarks rather complex matter guided mostly intuitions  and  worse  personal
opinions   was  best create realistic  structurally diverse  accessible
benchmarks possible ipc    belief succeeded so  benchmarks
definitely differ certain ways previous benchmarks  think
differences advantageous  discuss places point differences 
regarding realism benchmarks  pointed above  main step took design
benchmarks top down  i e   start actual possible applications planning technology 
turn something suitable competition rather traditional bottomup approach artificially creating domain real scenario mind  course 
modelling application pddl  particularly modelling way making suitable
use ipc  simplifications need made  cases  e g   airport ground traffic
control  simplifications overly drastic  preserved overall properties intuitive
structure domain  cases  e g   oil derivative transportation pipeline networks 
simplifications needed make drastic domains could well
created traditional bottom up way  still  even greatly simplified  domain generated
top down better chance capture structure relevant real application  moreover 
top down domain advantage since derived real application  provides
clear guideline towards realism  future challenge make planners work
realistic encodings application  previous competitions  domains generated
top down sense elevator domain used ipc    koehler   schuster       
bacchus         satellite rovers domains used ipc    long   fox        
regarding diverse structure benchmarks  contrast previous competitions 
ipc   domains common theme underlying many benchmarks  ipc     
  domains variants transportation  ipc        domains variants transportation  ipc        domains variants transportation    gathering
data space  variants fact interesting use constructs
locked locations  fuel units  road map graphs  stackable objects  complex side constraints 
however  certainly intuitive similarity structure relationships domains 
extent similarity even automatically detectable  long   fox         ipc   airport ground traffic control  oil derivative transportation pipeline networks  model checking
safety properties  power supply restoration  umts call setup rather different topics 
   benchmarks downloaded ipc   web page http   ipc icaps conference org 
   consider example movie domain used ipc    instances domain  matter size is 
share space reachable states  thing increases connectivity states  i e 
number actions effect  still one argue movie useful benchmark  sense
highlight systems approaches have have difficulties attacking problem characteristics 

   

fie ngineering b enchmarks



p lanning

one could claim airport ground traffic control umts call setup scheduling nature  see  however  ipc   version airport ground traffic control allows
considerably freedom classical scheduling formulations  making pspace complete
decision problem  particulars domains overviewed section   
approaching structure formal point view difficult  largely unclear
what  precisely  relevant structure planning domain instance is  general sense 
hoffmann                    provides one possible definition search space surface topology certain heuristic function many possible options  particular  hoffmanns
results relevant heuristic search planners generate heuristic functions based
ignoring delete lists relaxation  mcdermott              bonet  loerincs    geffner       
bonet   geffner        hoffmann   nebel         lack better formal handle  used
hoffmanns definitions qualify structure domains  selected domains cover different regions hoffmanns planning domain taxonomy  particular lie regions
less coverage traditional benchmarks  interesting context
paper hand  summarize hoffmanns        results    domains including domains
used previous competitions  summarize helmerts      b  results computational complexity satisficing optimal planning ipc   domains  turns
complexity covers wide range widest possible range  propositional planning formalisms
pspace hard polynomial  finally provide new data analyze structural
relationships differences domains  amongst things  instance 
measure  number  parallel sequential  steps needed achieve goal  estimated
smallest plan found ipc   participant  number estimated planning graphs
relaxed plans  distribution number possible achieving actions fact 
results examined comparison different domains  taking account
runtime performance exhibited different kinds planners ipc   
apart realism diverse structure  main quest creation ipc   benchmarks
promote accessibility  applications are  typically  modelled
pddl  naturally modelled using rather complex language constructs time  numeric
variables  logical formulas  conditional effects  existing systems handle subsets
this  fact half systems entered ipc    precisely         could handle
simple strips language  slight extensions it   previous competitions  done
example elevator  satellite  rovers domains  handled simply dropping
interesting domain constraints simpler languages  i e   removing respective
language constructs domain instance descriptions  contrast  first time ipc 
compiled much domain semantics possible simpler language formats 
compilation hard  sometimes impossible  do  done adl constructs 
well two new constructs introduced ipc   language pddl     derived predicates
timed initial literals  implemented  applied  compilation methods cases 
   strips  stanford research institute problem solver  name simplest time widespread planning language  form language used today  state variables boolean  formulas
conjunctions positive atoms  action effects either atomic positive  make fact true add it  atomic negative
 make fact false delete it   fikes   nilsson         languages selected ipc    bacchus        
pddl    pddl    derived  strips adl  adl prominent  expressive  alternative
strips  extending arbitrary first order formulas preconditions goal  conditional effects 
i e   effects occur individual effect condition  a first order formula  met state execution
 pednault        

   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

compilations serve preserve original domain structure  simpler language
classes  example  strips version elevator domain ipc   simplified
original adl version bears marginal similarity real elevator control particular 
planner explicitly tell passengers get lift   contrast  strips
formulation airport ground traffic domain is  semantically  identical adl formulation
expresses things  awkward fashion 
compiled domain versions offered competitors alternative domain version formulations  yielding   step hierarchy domain  is  domain ipc  
could contain several different domain versions  differing terms number domain constraints properties considered  within domain version  could several domain version formulations  differing terms language used formulate  same  semantics 
competitors could choose  within version  whichever formulation planners could handle
best handle all  results within domain version evaluated together 
way  intended make competition accessible possible time keeping
number separation lines data number distinctions need made
evaluating data acceptable level 
are  course  aware encoding details significant impact system performance   particularly  compiling adl strips  cases revert fully
grounded encodings  certainly isnt desirable  believe acceptable price
pay benefit accessibility  current systems ground operators pre process
anyway  cases considered compiled domain formulations different
original ones allow fair comparison typically plan length increased significantly
due compilation compiled formulation posed competitors separate domain version 
article organized follows  main body text contains general information 
section    give detailed explanation compilation methods used  section    give
summary domains  short application description  motivation including
domain  brief explanation main simplifications made  brief explanation
different domain versions formulations  section    summarize hoffmanns       
helmerts      b  theoretical results structure ipc   domains  section    provide
empirical analysis structural properties  section   discusses achieved 
provides summary main issues left open  ipc   domains  include
separate section appendix a  providing detailed information application  adaptation
ipc    domain versions  example instances used  future directions  although
details appendix  emphasize secondary importance 
contrary  describe main body work did  presentation appendix
seems suitable since expect reader to  typically  examine domains detail
selective non chronological manner 
   passengers wont get  out  floors origin  destination   however  explicit control 
planner choose let someone  out   accurate encoding via conditional effects action
stopping lift floor 
   detailed account matters provided howe dahlman        

   

fie ngineering b enchmarks



p lanning

   pddl compilations
used three kinds compilation methods 
adl simple adl  strips conditional effects  strips 
pddl derived predicates pddl without them 
pddl timed initial literals pddl without them 
consider compilation methods order  explaining  each  compilation
works  main difficulties possible solutions are  giving outline
used compilation competition  note adl  simple adl  strips subsets
pddl  compilation methods published elsewhere already  see citations
text   section serves overview article  since coherent summary techniques 
behavior practice  appeared elsewhere literature 
    compilations adl simple adl strips
adl constructs compiled away methods first proposed gazen knoblock        
suppose given planning instance constant  object  set c  initial state i  goal g 
operator set o  operator precondition pre o   conditional effects e  taking form
con e   add e   del e  add e  del e  lists atoms  preconditions  effect conditions 
g first order logic formulas  effect conditions ru e unconditional effects   since
domain discourse set constants finite  formulas equivalently transformed propositional logic 
    quantifiers turned conjunctionsvand disjunctions  simply expanding
w
available objects  x    x  turns cc  c  x    x  turns cc  c   iterate
quantifiers left 
since strips allows conjunctions positive atoms  transformations necessary 
    formulas brought negation normal form      turns    
turns   iterate negation front atoms only 
    x occurs formula  introduce new predicate not x  set not x iff
x   i  effects e  set not x add e  iff x del e  not x del e  iff x add e  
formulas  replace x not x  iterate negations left 
    transform formulas dnf                turns              
               iterate conjunctions occur disjunctions 
operator precondition pre o  n     disjuncts  create n copies one
disjunct precondition  effect condition con e  n     disjuncts  create n
copies e one disjunct condition  g n     disjuncts  introduce
new fact goal reached  set g    goal reached  create n new operators one
disjunct precondition single unconditional effect adding goal reached 

   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

  action move
 parameters
  a   airplane  t   airplanetype  d    direction  s   s    segment  d    direction 
 precondition
 and  has type  a  t   is moving  a   not     s   s     facing  a  d    can move  s   s   d  
 move dir  s   s   d    at segment  a  s  
 not  exists   a    airplane   and  not     a   a    blocked  s   a     
 forall   s   segment   imply  and  is blocked  s  t  s   d    not     s  s      not  occupied  s     
 effect
 and  occupied  s    blocked  s   a   not  occupied  s     not  at segment  a  s     at segment  a  s  
 when  not  is blocked  s   t  s   d     not  blocked  s   a   
 when  not     d   d     and  not  facing  a  d     facing  a  d    
 forall   s   segment   when  is blocked  s  t  s   d    blocked  s  a   
 forall   s   segment   when
 and  is blocked  s  t  s   d    not     s  s     not  is blocked  s  t  s   d    
 not  blocked  s  a      

figure    operator airport ground traffic control 
illustrative example  consider operator description figure    taken domain
encoding airport ground traffic control  operator moves airplane one airport segment
another  consider specifically precondition formula  not  exists   a    airplane   and  not   
 a   a    blocked  s   a       saying airplane different  a allowed block segment
 s   segment moving into  say set airplanes a              step    
turn formula  not  or  and  not    a   a    blocked  s  a            and  not     a    blocked  s 
      step     yields  and  or    a   a   not  blocked  s  a             or     a   not  blocked  s       
step     yields  and  or    a   a   not blocked  s  a            or     a   not blocked  s       step     
finally   naively  transform  or  and    a   a            a          and  not blocked  s  a   
       not blocked  s       i e   mathematically notated 
 
 
x 
x    a 

 a   not blocked  s  a            a   not blocked  s    

words  transforming formula dnf requires enumerating n vectors atoms
vector position selected one two possible atoms regarding airplane ai  
yields exponential blow up dnf  n disjuncts  dnf split single
disjuncts  one yielding new copy operator 
reader noticed exponential blow up inherent compilation step
     quantifier may expanded  c  sub formulas  k nested quantifiers
expanded  c k sub formulas  obviously  general way around either
blow ups  deal complex formulas allowed strips  practice 
however  blow ups typically dealt reasonably well  thanks relative simplicity
operator descriptions  frequent occurrence static predicates  explained shortly 
quantifiers arent deeply nested  figure    blow up inherent step    
matter  transformation dnf often problem example here  key
successful application compilation practice  least far personal experience
goes  exploitation static predicates  idea described  example  koehler
   

fie ngineering b enchmarks



p lanning

hoffmann         static predicates arent affected operator effect  predicates
easily found  truth value fully determined initial state soon fully
instantiated  transformation step      operator parameters still variables 
even knew    of course  static predicate  would help us
wouldnt know  a is  instantiate  a  however  then  instantiation
operator      a   a  atoms trivialize true false  large dnf collapses
v
single conjunction     a  airplane  not blocked  s   a    instantiation
 a  similarly  expansion quantifiers often made much easier first instantiating
operator parameters  inserting true false static predicate soon
parameters grounded  inserting true false often simplifies formulas significantly
information propagated upwards  e g   disjunction true element becomes
true itself  
assuming compilation succeeded thus far  steps         processed
strips description conditional effects  i e   actions still conditional effects con e  
add e   del e  con e  conjunction atoms  subset adl termed
simple adl fahiem bacchus  used encoding one versions
elevator domain used ipc    i e       competition   choose leave
language  necessitating planning algorithm deal conditional effects directly 
several existing planning systems  example  hoffmann   nebel        ipp  koehler 
nebel  hoffmann    dimopoulos         this  sensible approach since  nebel       
proved  conditional effects cannot compiled strips without either exponential blowup task description  linear increase plan length  one might suspect that 
steps         above  exponential blow up mostly avoided practice 
airport move operator figure   provides example this  effect conditions static
conditional effects disappear completely instantiate parameters another
good reason instantiation prior compilation  however  conditional effects
disappear many other  even simple  natural domains  consider following effect  taken
classical briefcaseworld domain 
 forall   o   when  in  o   and  at  o  to   not  at  o  from     

effect says object  o currently briefcase moves along briefcase 
obviously  effect condition static  outcome operator truly depend
contents briefcase  note forall means actually set  distinct 
conditional effects  one object 
basically two known methods compile conditional effects away  corresponding
two options left open nebels        result  first option enumerate possible
combinations effect outcomes  preserves plan length cost exponential blow up
description size exponential number different conditional effects single action 
consider briefcaseworld operator  say object set o              every
subset o           o k o              o k             o n complement subset  get distinct
operator precondition contains of 
 in o            in o k    not in o k            not in o n  

effect objects is 
 at o    to         at o k  to   not  at o    from          not  at o k  from  
   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

words  operator applied  only  exactly o           o k briefcase 
moves exactly objects  since  in deterministic planning considered here  never
uncertainty objects inside briefcase not  exactly one new
operators applied whenever original operator applied  compilation method
preserves size  nodes  form  edges  state space  however  wont able
transformation  planner wont able deal resulting task  n grows beyond  say 
maximally              often  real world operators contain distinct conditional effects that 
alternative method  first proposed nebel         introduce artificial actions
facts enforce  application normal action  effect evaluation phase
conditional effects action must tried  whose condition satisfied
must applied  briefcaseworld example  would look follows  first 
conditional effect gets removed  new fact evaluate effects inserted add list 
new fact normal inserted precondition delete list   n new operators 
two object oi   one means move along oi   means leave oi   former
in oi   precondition  latter not in oi    former  at oi  to   not  at oi
 from  effect  evaluate effects precondition  new fact tried oi
add effect  final new operator stops evaluation  whose precondition
conjunction evaluate effects tried o            tried on   whose add effect normal 
whose delete effect evaluate effects  conditional effects several operators compiled
away method  evaluate effects tried oi facts made specific
operator  normal remain single fact used operators  effect k     facts
condition  k leave oi actions must created  negation one facts
precondition 
nebels        method increases plan length number distinct conditional effects
operators  note benign are  say     effects  search
procedure recognizes new constructs do  search space essentially remains
compilation  but  artificial constructs easily deciphered
human  necessarily true  is likely case  computer
searches general purpose search procedure  example  naive forward
search space choice order application conditional effects  which
could avoided enforcing order yet artificial constructs   probably
importantly  standard search heuristics unlikely recognize nature constructs 
example  without delete lists suffices achieve tried o            tried on once 
later apply conditional effects needed 
conclude necessary eliminate conditional effects  whenever feasible  one
compile conditional effects away first method  enumerating effect outcomes 
ipc    took ffs pre processor  implements transformation steps         above 
extended code compiles conditional effects away  optionally either two described methods  call resulting tool adl strips   cases domain
version formulated adl  used adl strips generate strips formulation domain
version  one case  version power supply restoration  generated simple adl
   executables adl strips downloaded ipc   web page http   ipc icaps conference org 
download tool named ground  based code mips system  edelkamp      b   takes
full syntax pddl     hoffmann   edelkamp        puts grounded representation  we
use tool ipc   since temporal numeric planners pre processing steps implemented  

   

fie ngineering b enchmarks



p lanning

formulation  cases one  enumerating effect outcomes feasible  single exception another version power supply restoration forced use nebels       
method  details process  exceptions use adl strips
domain specific method  described sections individual domains appendix a 
    compilations derived predicates
several proposals literature compile derived predicates away  certain restrictions form use rest domain description  gazen  
knoblock        garagnani         compilation scheme works general proposed
thiebaux  hoffmann  nebel               thiebaux et al  proved compilation scheme works general not  worst case  involve exponential
blow up either domain description size length plans  note exponential refers increase plan length  description blow up  unlike
compilation conditional effects discussed above  makes compilation derived predicates rather difficult task  ipc    compilation schemes oriented approaches taken
gazen knoblock         thiebaux et al                used  detail below 
first  let us explain derived predicates are  compilations work 
derived predicates predicates affected operators  whose truth
value derived set derivation rules  rules take form  x  p  x  
basic intuition that   x  satisfied instantiation c variable vector x  p  c 
concluded  formally  semantics derivation rules defined negation
failure  starting empty extension  instances p  c  derived fixpoint reached 
instances lie outside fixpoint assumed false  consider following example 
  derived  trans  x  y   or  edge  x  y    exists   z   and  edge  x  z   trans  z  y     

derivation rule defines transitive closure edges graph  typical
application derived predicates  example  blocksworld naturally formalized
predicate  power supply restoration domain  transitive closure models power
flow paths network electric lines  obviously  pairs  x  y
transitively connected appear fixpoint negation failure 
matters become interesting think derived predicates allowed refer
other  may used rest task description  important distinctions
are  derived predicate appear antecedent derivation rule  derived predicate
appear negated antecedent derivation rule  derived predicate appear negated
action precondition goal 
derived predicates appear antecedents derivation rules  merely
non recursive macros  serving syntactic sugar  one simply replace derived predicates
definitions   derived predicate p appears negated  negation normal form the 
antecedent derivation rule predicate q  fixpoints p q computed
interleaved way  extension q may differ depending order individual
instances derived  say rule p a x  p  x   basic predicate  rule
q p  x  q x   say objects b  current state satisfies  only  a a  
   derived predicates recursive cycle free  replaced definitions may incure
exponential blow up 

   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

computing derived predicates interleaved way  may derive a a  p  a   a b 
q b   stop  may derive p  a  q a   a b  q b   a a  p  a  
non monotonic behavior  making non trivial define extension b is  keep
things simple extensions derived predicates must computed every new
world state thiebaux et al               propose simply order q p   is  compute
p extension first compute q based that  generalized  one ends semantics
corresponding stratified logic programs  apt  blair    walker         context
ipc    i e   pddl     hoffmann   edelkamp         sake simplicity use negated
derived predicates antecedents derivation rules allowed 
whether derived predicates appear negated action preconditions goal makes
difference gazen knoblocks        compilation scheme  idea scheme
simply replace derivation rules actions  rule  x  p  x  replaced new
operator parameters x  precondition  x   add  effect p  x   actions influence
truth value affect atoms mentioned delete instances p   words 
new actions allow derivation p   normal action applied may influence
value p   extension p re initialized 
derived predicates used negated  gazen knoblocks        compilation
scheme works  however  say p  c  contained action precondition  compiled
version  planner achieve precondition simply applying derivation rule
action adds p  c   is  planner choice predicate instances derive 
course negation failure semantics  reader may point
wonder compile negations away first  thereafter use gazen knoblocks
       compilation  problem would need inverse derivation rules work
negation failure semantics  clear done  say  example 
want define negated version  trans  x  y  predicate above  one would tempted
take negation derivation rule antecedent 
  derived  not trans  x  y   and  not edge  x  y   forall   z   or  not edge  x  z   not trans  z  y     

work  however  say every node graph least one adjacent edge  starting
empty extension  not trans  x  y   single instantiation derived  given
x edge  z edge x would
 not trans z y  first place 
one possible solution difficulties extend gazen knoblocks        compilation constructs force planner compute entire extension derived predicates
resuming normal planning  full description this  dealing arbitrary derivation rules 
described thiebaux et al                nutshell  compilation works follows  one
introduces flags saying one normal fixpoint mode  normal actions invoke fixpoint mode affect predicates relevant derivation rules  fixpoint mode  action
applied one conditional effect derivation rule  effect condition true 
respective derived predicate instance false  predicate instance added  plus
flag changes made  another action tests whether fixpoint  changes made
true  action resets false  changes made false  action switches back
normal mode  reduce domain strips  compilation derived predicates 
negations conditional effects must compiled away techniques explained earlier 

   

fie ngineering b enchmarks



p lanning

one would imagine thiebaux et al s              compilation  making use rather complicated constructs  tends confuse domain independent search techniques  indeed  thiebaux
et al               report even completely naive explicit treatment derived predicates
performs lot better  benchmark domains  standard version applied
compiled benchmarks  gazen knoblocks        compilation makes use less artificial
constructs  thus preferable whenever safely applied  note  however  compilations imply potentially exponential blow up plan length  exponential arity derived
predicates  worst case every action affects derivation rules  every re computation
extension derived predicates go predicates instantiations 
situation  every pair normal actions planner apply order  c a
actions  maximum arity derived predicate  typically small
power supply restoration domain aware features derived predicate
two  four  namely  arguments even plan length increase linear number
objects mean quite significant decrease planner performance 
ipc   benchmarks  derived predicates occur  only  power supply restoration  appendix a    model checking safety properties  appendix a     latter  derived
predicates occur negated  stefan edelkamp encoded domain version without derived predicates hand  using method along lines one described gazen knoblock        
power supply restoration  derived predicates occur negated  used variation
method described thiebaux et al                cases  due increase plan length
considered resulting domain formulation different original formulation directly compared it  terms planner performance  compiled formulations posed
competitors distinct domain versions  instead alternative domain version formulations 
indeed  expected  planner results ipc   much worse compiled encodings 
    compilations timed initial literals
timed initial literals literals known become true time points pre specified
initial state  literals compiled durational pddl relatively easily  cost
plan length domain description size blowing linearly number timed initial
literals  compilation proposed brought attention fox  long  halsey
        idea use wrapper action must applied action 
whose duration occurrence time last timed initial literal  planner must apply
sequence literal actions achieve timed initial literals order occurrence 
durations time intervals occurrences  wrapper action
terminated  literal actions longer applied  planner forced apply
direct sequence  suffices encode desired semantics  consider following example 
  init
 at    have to work  
 at     not  have to work   
 at     bar open  
 at     not  bar open    

encode standard durational pddl  wrapper be 
  action wrapper
   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

 parameters   
 duration     duration    
 condition
 at start  no wrapper  
 effect
 and  at start  not  no wrapper   
 at start  wrapper started  
 at start  wrapper active  
 at start  literal   started  
 at end  not  wrapper active     

here  no wrapper ensures one wrapper action executed  wrapper started inserted
precondition every normal action thus ensures wrapper started
action executed  wrapper active precondition literal actions  precisely 
be 
  action literal  
 parameters   
 duration     duration   
 condition
 and  over  wrapper active  
 over  literal   started   
 effect
 and  at end  not  literal   started   
 at end  literal   started  
 at end  have to work    
  action literal  
 parameters   
 duration     duration    
 condition
 and  over  wrapper active  
 over  literal   started   
 effect
 and  at end  not  literal   started   
 at end  literal   started  
 at end  not  have to work   
 at end  bar open    
  action literal  
 parameters   
 duration     duration   
 condition
 and  over  wrapper active  
 over  literal   started   
 effect
 and  at end  not  literal   started   
 at end  not  bar open   
 at end  literals done    

   

fie ngineering b enchmarks



p lanning

fact literals done made goal  planner must actually apply literal actions 
note need three actions here  since two timed initial literals
longer work opening bar scheduled occur time  note
that  nebels        compilation conditional effects thiebaux et al s       
      compilation derived predicates  compiled encoding likely confusing domain
independent search methods 
many ipc   domains made use timed initial literals  in versions  encode
various kinds time windows  see appendix a   compiled domain versions pure
 durational  pddl above  provided resulting encodings additional domain versions 
due increase number actions needed plans  figured compilation
constructs much change direct comparison  indeed  derived predicates 
planner results ipc   much worse domain versions compiled way 

   summary domains
section provide brief summary ipc   domains  domain  provide 
short description application  motivation inclusion domain  brief explanation
main simplifications made ipc    brief explanation different domain versions
formulations used ipc    proceed alphabetical order 
    airport
contact person application domain  wolfgang hatzack  working
application area several years  domain adapted ipc   jorg hoffmann
sebastian trug
application  task control ground traffic airport  timed travel routes must
assigned airplanes reach targets  inbound outbound traffic 
former airplanes must take off  latter airplanes landed park 
main problem constraint is  course  ensure safety airplanes  means avoid
collisions  prevent airplanes entering unsafe zones behind large airplanes
engines running  optimization criterion minimize summed travel time  on
surface airport  airplanes   usually standard routes  i e   routes
airplane must take outbound certain parking area  inbound certain runway 
reason introducing routes reduce complexity human ground controllers  since
significant computer support yet available real airports  solving instances optimally  the
corresponding decision problem  pspace hard without standard routes  helmert      b 
np complete routes standardized  hatzack   nebel         latter case 
pure scheduling problem  former case  complicated unrealistic airport traffic situations
lead exponentially long solutions  see section     
motivation  main motivation including domain able model
application quite accurately  and  particular  generate quite realistic instances  fact 
able generate instances based real airport  made possible contact
wolfgang hatzack  completed phd application  hatzack         apart
   alternative criterion would minimize summed squared delay airplanes  interest
airlines  minimizing summed travel time interest airport  neither two easily
modelled pddl     discuss simplifications  below 

   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

developing domain specific solutions  hatzack   nebel         developed realistic simulation
tool  kindly supplied us purpose generating ipc   domain versions test
instances  sebastian trug implemented options inside simulator allowed it  point
time simulation traffic flow  output current traffic situation pddl format 
simulator included real airports frankfurt  zurich  munich  frankfurt zurich proved
large purposes  able devise competition instances based munich airport 
simplifications  make two simplifications  first amounts discretization space
 location  airport  making domain amenable pddl style discrete actions 
continuous space representation  one would need actions continuous choice far
move  discretization loses precision  believe distort nature
problem much  due amount expected conflicting traffic different points
airport  high parking positions  relatively easy choose discretization
segments different length precise small enough time  second
simplification severe  drop original optimization criterion 
awkward express current pddl  model travel times airplanes  one needs access
times plans wait  i e   nothing    aware way express
current pddl  ipc   committee voted introduction additional language
construct  look clock  since didnt seem relevant anywhere else  another option
would introduce explicit waiting actions  causes lot trouble because  similar
continuous space  must continuous choice long wait  end  decided
drop criterion now  ask planners optimize standard makespan instead   
corresponding arrival time last airplane  meaning  arrival destination
airport   ideal  reasonable optimization criterion  planning system participating
ipc    single exception lpg td  gerevini  saetti    serina         able take
account general optimization criteria built in ones  like makespan   use
full standard routes  thus allowing airplanes choice move  use standards
routes  particularly regions near runways large airports  one thing  served
keep large airports manageable pddl encoding planners  another thing  seems
good compromise exploiting capabilities computers time remaining
close existing practice 
versions formulations  generated four versions airport domain  non temporal
one  temporal one  temporal one time windows  fact planes land
future block certain runways modeled using timed initial literals  latter version 
timed initial literals compiled away  versions  constraints ensuring airplane safety
modelled adl logical formulas  compilation partially grounded strips
provides  version  alternative formulation  domain version one adl formulation
one strips formulation 
    pipesworld
frederico liporace working application area several years  submitted paper
early domain version workshop competition icaps    domain
adapted ipc   frederico liporace jorg hoffmann 
    difficulty arises modelling delay  one must compute travel times 
    makespan  planning  means amount time start plan last action stops executing 

   

fie ngineering b enchmarks



p lanning

application  task control flow different oil derivatives pipeline
network  certain product amounts transported destinations  pipeline networks
graphs consisting areas  nodes  pipes  edges   pipes differ length 
available actions pump liquid ends pipes  effect liquid end
pipe gets ejected  application rich additional constraints  like  constraints
types products may interface within pipe  restricted tankage space areas  deadlines
arrival products 
motivation  main motivation including domain original structure  one inserts
something pipe one end  something possibly completely different comes pipe
end  way  changing position one object directly results changing
position several objects namely  objects inside affected pipeline 
case transportation domain aware of  fact reminiscent complicated
single player games rubiks cube  indeed  strong interaction objects lead
several subtle phenomena  example  instances solution must pump liquid
ring pipeline segments cyclic fashion 
simplifications  severely simplify domain order able solve reasonably
complex instances current planners  importantly  encoding heavily based assuming smallest indivisible unit liquid  batch  every amount liquid encoding modelled
terms number batches  capture continuous nature real application  means
one choose batch size trade off encoding size accuracy  trade off
less well behaved one airport  choosing segments sizes  since unit size cannot
made flexible  every batch may pass every pipeline  smallest batch governs
discretization pipelines  contrast airport  segments may vary size 
another important simplification  used personalized goals  i e  goals referred specific
batch objects rather product amounts  serves avoid large disjunctions enumerating
possible combinations individual batches  simplifications quite severe indeed
seems unlikely realistic representation pipesworld  particular real valued product amounts instead batches  could solved efficiently planners without introducing
specialized language constructs sort queue data structure pddl  see appendix a     
versions formulations  created six different versions pipesworld  four versions  
without temporal actions  with without tankage restrictions  respectively  one temporal version
without tankage restrictions arrival deadlines goal batches  one version identical
last one except timed initial literals compiled away 
    promela
domain created ipc   stefan edelkamp 
application  task validate properties systems communicating processes  often
communication protocols   encoded promela language  promela  process meta language 
input language model checker spin  holzmann         language loosely based
dijkstras guarded command language  borrowing notation hoares csp language 
one important property check detect deadlock states  none processes apply
transition  example  process may blocked trying read data empty
communication channel  edelkamp      a  developed automatic translation promela
pddl  extended generate competition examples 

   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

motivation  main motivation including domain promote make visible important connection planning model checking  model checking  clarke 
grumberg    peled        automated formal method basically consists three
phases  modeling  specification checking  first two phases system correctness specification modeled using formalism  last step automatically checks
model satisfies specification  roughly speaking  step analyzes state space model
check validity specification  especially concurrent systems  several components
interact  state spaces grow exponentially size components system  two
main research branches model checking  explicit state model checking  implemented spin 
exploits automata theory stores explored state individually  symbolic model checking
describes sets states properties using binary decision diagrams  bdds  efficient
representations boolean formulas 
checking validity reachability property  property asks system state certain property reachable  similar question plan existence  use model checking approaches solve planning problems explored depth  e g  cimatti  roveri 
traverso         bertoli  cimatti  roveri  traverso         lago  pistore  traverso
        kvarnstrom  doherty  haslum         bacchus kabanza         holldobler
stor         fourman         edelkamp      b   dierks         kabanza thiebaux        
however  much done inverse direction  applying planners model checking
problems  running ipc   planners planning encodings promela specifications first step
that 
promela domain contributes unusual structural properties domain set  computational complexity local search topology quite different discussed section   
simplifications  main simplification make use simple example classes
communicating processes  pddl models refer fixed length state vectors  could
include process construction calls  therefore considered active processes  i e   processes
called initialization time  pddl support temporally extended
goals  consider reachability properties only  moreover  prototypical nature
language compiler  many features promela rendezvous communication supported  although limited support shared variables  competition chose
simple message passing protocols only  experimented reachability properties  pddl goals competition event deadlock detection only  concretely 
ipc   instances come two toy examples used area model checking  well known
dining philosophers problem  optical telegraph problem viewed
version dining philosophers philosophers complex inner life  exchanging data
two hands  each separate process   both  goal reach deadlock
state 
versions formulations  created eight different versions domain  differ
promela example class encoded  two options   whether use numeric variables
encoding  whether use derived predicates encoding  four encodings
promela example class semantically equivalent sense   to   correspondence plans  decided make different versions  rather formulations 
derived predicates make large difference plan length  numeric variables make
large difference applicability planning algorithms systems  translation promela

   

fie ngineering b enchmarks



p lanning

pddl makes use adl constructs  domain version contains one adl formulation
one  fully grounded  compiled strips formulation 
    psr
sylvie thiebaux others worked application domain  domain adapted
ipc   sylvie thiebaux jorg hoffmann 
application  task psr  power supply restoration  reconfigure faulty power distribution network resupply customers affected faults  network consists electric
lines connected switches fed via number power sources equipped circuitbreakers  faults occur  circuit breakers sources feeding faulty lines open
protect network  leaving lines many healthy ones un supplied  network needs reconfigured opening closing switches circuit breakers way
resupply healthy portions  unreliable fault sensors switches lead uncertainty
state network  furthermore  breakdown costs depend various parameters need
optimized constraints capacity sources lines  application topic ongoing interest field power distribution  investigated ai community
long time  including ai planning standpoint  thiebaux  cordier  jehl    krivine       
thiebaux   cordier        bertoli  cimatti  slaney    thiebaux        bonet   thiebaux        
motivation  motivation including psr twofold  first  well researched interesting
application domain  second  original structure rarely found previous benchmarks 
natural encoding models power propagation using recursive derived predicates compute transitive closure connectivity relation network  contrast
planning benchmarks  number actions needed optimal plan necessarily grow
instance size  available actions alter position switches  even large
network altering position switches may suffice reconfiguration  difficult
question answer is  switches 
simplifications  three major simplifications made  first  deterministic planning
assume network state fully observable  i e   initial state description
complete  actions always succeed  second  ignored numerical optimization
aspects psr  third  used personalized goals sense lines supplied named
explicitly goal  note that  even simplified form  domain exhibits structure
explained above 
versions formulations  created four domain versions  differing primarily size
available formulations  natural domain formulation adl derived predicates 
though experimented many combinations pddl encodings compilation strategies 
size instances could compile simpler languages quite restricted  precisely 
versions are  large version adl plus derived predicates  middle version
could devise simple adl plus derived predicates strips plus derived predicates 
middle compiled version adl  identical middle version except derived
predicates compiled away  small version pure strips  instances latter
domain version particularly small  since extremely difficult come
encoding pure strips either yield prohibitively long plans  prohibitively large
pddl descriptions  fact  obtain small version applied pre computation step  bertoli
et al         obviates need reasoning power propagation and  consequently 

   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

need derived predicates  resulting tasks  opening closing switch directly without
detour power propagation affects parts network  thus planner longer needs
compute flow power network  left issue configure
flow 
    satellite
domain introduced long fox        ipc    adapted ipc   jorg
hoffmann  domain comes nasa space application  satellites take images
spatial phenomena  motivation inclusion ipc   domain applicationoriented similar sense new domains  also  wanted immediate comparison performance achieved ipc    achieved ipc    top   domain
versions used ipc    added   new versions  introducing additional time windows  formulated
alternatively timed initial literals compilation  sending data earth 
    settlers
domain introduced long fox        ipc    task build
infrastructure unsettled area  involving building housing  railway tracks  sawmills  etc 
distinguishing feature domain domain semantics encoded numeric variables  makes domain important benchmark numeric planning 
reason  ipc   participant could solve smallest instances  included
domain ipc    modification made except compiled away universally
quantified preconditions order improve accessibility 
    umts
roman englert working application area several years  domain adapted
ipc   stefan edelkamp roman englert 
application  third generation mobile communication  so called umts  holma  
toskala         makes available broad variety applications mobile terminals 
comes challenge maintain several applications one terminal  first  due limited resources  radio bearers restrictions quality service  qos  applications  second 
cell setup execution several mobile applications may lead unacceptable waiting periods
user  third  qos may insufficient call setup case execution
mobile application shut down  thus arises call setup problem several mobile applications  main requirement is  course  setup minimum possible amount
time   pure  scheduling problem necessitates ordering optimizing execution
modules needed setup  many scheduling problems  finding some  necessarily
optimal  solution trivial  main challenge find good quality solutions  optimal ones ideally 
motivation  main motivation modelling pure scheduling problem planning domain
strong industrial need flexible solution procedures umts call setup 
due rapidly evolving nature domain  particularly sorts mobile applications
available  ideal solution would put automatic planner mobile device 
let compute optimized schedules on the fly  sense  umts call setup
natural promising field real world application automatic planners  interesting

   

fie ngineering b enchmarks



p lanning

sense scheduling problems far central competitive ai planning 
domain serves advertise usefulness pddl addressing certain kinds scheduling
problems 
simplifications  setup model chose considers coarse parts network environment
present umts applications invoked  action duration fixed rather computed
based network traffic  inter operational restrictions different concurrent devices
neglected  considered plausible timings instances rather real application
data running certain applications umts device  designed domain
   applications single device  challenge optimal planners computing minimum
makespan solutions  much challenge satisficing planners 
versions formulations  created six domain versions  arise two groups
three versions each  first group  standard umts domain  comes without timing
constraints  latter represented either using timed initial literals  compilation 
before  separated two options different domain versions  rather domain version
formulations  due increase plan size  second group domain versions similar
structure  difference three domain versions includes additional flaw
action  single step  action achieves one needed fact  where  normally  several steps
required  however  action useless reality deletes another fact needed 
cannot re achieved  flaw action added see happens intentionally
stressed planners  beside increasing branching factor  flaw action look useful
perspective heuristic function ignores delete lists 

   known  theoretical  results domain structure
section  start structural analysis ipc   domains summarizing known
results literature  helmert      b  analyzes domains perspective domainspecific computational complexity  hoffmann        analyzes domains used ipcs far 
plus standard benchmarks literature  identifying topological properties search
space surface relaxed plan heuristic introduced system  hoffmann
  nebel         variants used many modern planning systems  studies
exclusively concerned purely propositional non temporal strips adl planning 
follows  domain names refer respective  non temporal  domain versions   
    computational complexity
helmert      b  studied complexity plan existence bounded plan existence
ipc   benchmark problems  plan existence asks whether given planning task solvable  bounded
plan existence asks whether given planning task solvable given number
actions  helmert established following results 
airport  plan existence bounded plan existence pspace complete  even
aircraft inbound need taxi park goal location  map planar
symmetric  safety constraints simply prevent planes occupying adjacent segments 
    umts domain  temporal versions  treated either studies  computational
complexity  easy see deciding plan existence p deciding bounded plan existence  optimizing
makespan  np complete umts  topological properties relaxed plan heuristic havent yet defined
temporal setting 

   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

proof reduction sliding tokens puzzle  set tokens must reach goal
assignment vertices graph  moving adjacent vertices ensuring two
tokens ever find adjacent vertices  length optimal sequential plans
exponential number tokens  likewise airport domain  even parallel plans
shorter linear amount  since plane move per time step  proof
sliding tokens puzzle quite complicated involves construction instances
exponentially long optimal plans  one would expect  constructions used
unlikely occur real airport  particular true necessary density conflicting
traffic graph structure  consider interesting since makes airport benchmark
extremely high worst case complexity  much good natured typical case
behavior  typically  ample space airport  comparatively  airplanes moving
across it 
pipesworld  whether without tankage  plan existence bounded plan existence np hard  unknown whether np  however  np hardness proof
reduction sat four literals per clause variable occurs
  clauses  sat instance reduced network way parts network  variable subnetworks  represent choice assignment variables  parts
 clause subnetworks  represent satisfaction clauses  content areas pipes
initialized batches way interface restrictions guarantee goal area
reached certain batch clause subnetwork iff clause satisfied assignment 
general promela planning  defined edelkamp      a   plan existence bounded
plan existence pspace complete  pspace hardness proof reduction halting problem space restricted turing machines  tm   cells machines tape
mapped onto process queue unit capacity  states tm form set promela
messages  tms alphabet form set promela states processes  promela transitions encode tms transitions  shown tm halts iff promela task reaches
deadlock 
dining philosophers  hand  particular structure one process per
philosopher  transition graph  optimal plans generated linear time
number philosophers making constant number transitions reach known state
graphs  similar considerations apply optical telegraph 
psr tasks solved optimally polynomial time  requires rather complex
algorithm  plans start wait action opens circuit breakers affected fault 
simplest form  optimal plans follow prescribing series actions opening switches
connecting feedable line faulty one  necessary sufficient ensure
network safe state faulty line re supplied  minimal set devices
 disjoint previous one  must closed resupply rest network 
achieved generating minimal spanning tree healthy part network 
done polynomial time 
figure   gives overview results summarizes helmerts        results
standard benchmarks  domain set displayed set investigated hoffmann        
minor differences explained shortly  blocksworld no arm  briefcaseworld  ferry  fridge 
simple tsp  tireworld traditional planning benchmarks never used ipc   
    blocksworld no arm version blocksworld blocks moved directly destination  without
referring robot arm  simple tsp used  fox   long        demonstrate potential symmetry

   

fifor

p lanning

pspace

e ngineering b enchmarks

promela
airport

p

plan existence

np

pipesworld
mystery
mprime
miconicadl
freecell

tireworld
simpletsp
schedule
psr
opticaltelegraph
movie
gripper
fridge
ferry
diningphil 

zenotravel
satellite
rovers
miconicstrips
miconicsimple
logistics
grid
driverlog
depots
briefcaseworld
blocksworldnoarm
blocksworldarm

p

np

pspace

bounded plan existence

figure    overview helmerts results computational complexity benchmarks 
ipc   benchmarks assembly  grid  gripper  logistics  movie  mprime  mystery 
ipc   benchmarks blocksworld arm  freecell  logistics  miconic adl  miconic simple 
miconic strips  miconic schindler lifts name elevator domain   schedule 
ipc   benchmarks depots  driverlog  freecell  rovers  satellite  zenotravel  ipc  
benchmarks displayed bold face  including  hypothetical  general promela domain 
table figure   organized along two axes  x axis shows complexity
deciding bounded plan existence  axis shows complexity deciding  unbounded  plan
existence  membership table entry means  np pspace rows columns 
respective problem complete respective complexity class  exception pipesworld
domain  which  stated above  still unknown whether two decision problems
members np  assembly domain displayed since  there  helmert        proved
existence exponentially long optimal plans  showing plan generation quite hard
domain  table sectors diagonal crossed unbounded plan existence
polynomially reduced bounded plan existence set bound  n   n
number distinct actions  or  adl  number distinct conditional effects 
striking new feature ipc   introduction pspace complete benchmark
domains  filling top right corner figure    thus  benchmarks cover four inhabited
sectors table  previous ipcs  ipc   ipc   cover three sectors inhabited
detection  one simply visit n nodes  using move action applied two nodes 
permutation nodes optimal tour  hoffmann        investigates towers hanoi domain 

   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

sectors except top right corner ipc   benchmarks cover two sectors namely 
bounded plan existence np complete domains  domains except freecell
polynomial time algorithm deciding unbounded plan existence 
ipc   benchmarks exceptional aspects visible figure    particularly  explained above  polynomial decision algorithm psr highly non obvious 
benchmarks important since  one hand  principle allow planners provide efficient solutions  while  hand  necessitating employ interesting techniques
so    schedule polynomial benchmark bounded plan generation
requires non obvious algorithm     domains left bottom middle bottom
sectors table  polynomial algorithms deciding bounded unbounded plan existence
completely trivial  mostly addressing one subgoal time 
pointed already  final exception lies extraordinarily large difference
worst case typical case behavior airport  see section    even fully automated
methods  the ipc   planners  are  least unbounded plan existence  generation   quite efficient
typical instances domain  large differences worst case typical case
behavior unusual  believe extent phenomenon airport really unusual 
example  planners tend find psr much harder airport 
    topology h 
hoffmann        considers state spaces  the forward search spaces  strips adl tasks
taken standard benchmark domains  defines  given task world state s  h   s 
length shortest possible relaxed plan  relaxed plan  relaxed plan
plan achieves goal one assumes delete lists empty  computing
h   the corresponding decision problem  np hard  bylander         many modern planners 
e g   hsp  bonet   geffner          hoffmann   nebel         sgplan  wah   chen       
chen  hsu    wah         yahsp  vidal         fast diagonally downward  helmert       
    a   interpreted sort heuristic search approximation h    plus
techniques problem decomposition  wah   chen         lookahead techniques  vidal 
       additional different heuristic functions  helmert         context  question
great practical interest quality underlying heuristic function addressed domains 
heuristic quality measured terms topological properties search space surface 
many local minima there  large they  flat regions  hoffmann       
investigates questions h  function  topological properties search space
surface proven 
hoffmann defines topological phenomena following frank  cheeseman  stutz        
identifies several parameters show particularly interesting behavior planning benchmarks 
dead end world state reachable initial state goal state cannot
reached  unrecognized dead end dead end h   s      exit distance
state length shortest path state space leading state s   
h   s    h   s     s  direct neighbor state s   h   s       h   s     is 
exit distance number steps need go order find better state  s     
    helmerts        words  think domains solved polynomial time polynomial
algorithms obvious extraordinarily interesting  deterministic psr definitely domain kind
regard optimization  np hard problems cannot solved without strong reliance search  polynomial
problems can  planners capture important concepts 

   

fie ngineering b enchmarks



p lanning

minus   since distance s  measured  here  s  plays role exit state used
frank et al          state lies local minimum paths exit temporary increase
heuristic value  otherwise state lies bench  maximal local minimum exit distance
 mlmed   state space  maximum exit distances states lying local minima
state space  similarly  maximal bench exit distance  mbed  maximum exit
distances states lying benches  core results hoffmanns        investigation
displayed figure   

blocksworldarm
depots
driverlog

pipesworld
psr

rovers
opticaltelegraph

mystery
mprime
miconicadl
freecell
assembly
airport

mbed    c

mlmed    c

hanoi    
blocksworldnoarm    
fridge    
briefcaseworld    
grid    

logistics      
ferry      
gripper      
undirected

tireworld      
satellite      
zenotravel      
miconicsimple      
miconicstrips      
movie      
simpletsp      
harmless

diningphil         
schedule      

recognized

unrecognized

figure    overview hoffmanns results topology h  benchmarks 
x axis figure   corresponds properties regarding dead ends  y axis corresponds
properties regarding exit distance local minima benches  domains assigned
appropriate table sectors classes domains depending worst case behavior possible
them  detail  meaning table following  state space undirected
every transition  action  directly inverted  state space harmless inversion
possible  dead ends anyway  recognized means dead ends 
h  them  unrecognized means least one unrecognized dead end 
domain falls class worst case instance  example  single instance whose
state space contains single unrecognized dead end  domain considered unrecognized 
results proved  i e   domain is  example  considered harmless  means
provably instance domain contains dead ends 
y axis figure    distinction lines correspond existence non existence
constant upper bounds maximal local minimum exit distance  upper line  maximal
bench exit distance  lower line   note constant upper bounds maximal local minimum
exit distance exist domains upper line domains lower line 
bounds exist    constant  meant bound valid every instance
    presentation assumes domains bounded bench exit distance subset bounded
local minimum exit distance  true general  hold considered benchmark domains 

   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

domain  regardless size  actual bounds proved displayed brackets  local minimum
bound precedes bench bound cases both  right bottom part table
crossed since unrecognized dead ends infinite exit distance domain classes
empty   
obvious intuition behind figure   transition easy hard
planning systems based heuristic search approximating h  one moves left bottom
side top right side table  indeed  table does  sense  coincide well
empirical behavior of  least  system  note extreme topological behavior
many domains  upper bound local minimum exit distance   means
local minima all  case       investigated domains  several
domains  widely used logistics benchmark  top single step suffices reach
exit benches  hoffmann        shows would polynomial bottom classes
table  provided oracle computing h   
considering table perspective benchmark development  one notices particularly older benchmarks tend lie left bottom side  consider example ferry  briefcaseworld  fridge  simple tsp  tireworld  distribution ipc   benchmarks gripper 
logistics  movie  grid  assembly  mystery  mprime somewhat extreme  first four
list belong simple classes  last three belong hardest class  until today 
mystery mprime domains amongst causing planners trouble  
ipc   benchmarks logistics  blocksworld arm  miconic strips  miconic simple  schedule 
freecell  miconic adl again  many simple challenging domains 
notable exceptions respect blocksworld arm  left top side table 
schedule  contain dead ends local minima  ipc   benchmarks  distribution starts get varied  domains zenotravel  satellite  depots  driverlog  rovers 
freecell span three four top classes table  plus one bottom classes 
ipc   domains  shown bold face  obviously continue development  two
sharing class pipesworld psr    continue emphasis spanning top classes
table  new domain one bottom classes dining philosophers 
highly exceptional exceedingly large bound  making bound practically useless
exploitation planning    satellite domain adopted ipc   benchmarks serves
represent  a interesting instance of  easier classes  note satellite simple
talking strips version  drops challenging problem constraints formulated numeric variables  airport domain exceptional top right class
that  again  worst case place figure   differs lot typical case  dead
end airport situation two airplanes completely block others paths    course 
practical airports designed way doesnt usually happen  mentioned earlier 
usually non overlapping  far possible standard routes  place
blocking occur densely populated areas near parking positions 
    one could skip unrecognized dead ends definition maximum exit distances  hoffmann       
argues un intuitive  plus making things unnecessarily complicated 
    actually  pipesworld invertible sense every two step sequence  starting ending pumping operation 
directly undone  considered harmless since single actions cannot inverted 
    indeed  h  bad heuristic dining philosophers  basically comes counting number
unsatisfied goals 
    relaxed plan use free space planes make move across other 

   

fie ngineering b enchmarks



p lanning

   new  empirical  results domain structure
provide empirical analysis various structural parameters ipc   domains 
sake readability conciseness  focus non temporal domain versions only 
types data measure  results temporal domain versions quite similar 
extent  visible tables showing numbers actions facts  domain versions 
individual domain descriptions appendix a 
empirical analysis aimed highlighting characteristics of  differences between  ipc   domains  apart focussing practical parameters  analysis
compared theoretical results cited previous section big advantage tells us
something actual instances run competition  note choice instances
make huge difference example  stated earlier  real world airport likely
exponentially long plans  neither likely provoke many dead end situations  possible all  instances used ipc   chosen relatively realistic  details appendix a  
analysis structured three sub sections  section     shows how  individual
domains  size grounded encoding grows instance size  section     assesses
correspondence quality standard heuristic functions  runtime achieved
ipc    section      finally  assesses fact connectivity instance size  meaning number
choices one achieve fact  number actions fact required for 
    encoding size
current strips adl planners  far authors aware  ground parameters
variables pre process  ending task representation consisting ground facts
ground actions  obvious question ask large grounded encodings are  figure  
shows data  numbers facts actions plotted instance size  selected versions of 
different domains  numbers measured using ffs pre processor  filters static facts
facts added deleted action unreachable actions  meaning actions
appear relaxed planning graph  a planning graph without mutex reasoning  initial
state  hoffmann   nebel         formulas compiled simple strips like conjunctions
facts  along lines gazen knoblock        outlined section   
      

 e   
airport
pipesworld
dining philosophers
optical telegraph
psr small
psr large
satellite
umts

     

airport
pipesworld
dining philosophers
optical telegraph
psr small
psr large
satellite
umts

      

nr  actions

nr  facts

     
    

    

   
   

  

  
 

  

  

  

  
  
nr  instance

  

  

  

  

 

  

  

  

  
  
nr  instance

  

  

  

  

 a 
 b 
figure    numbers  a  ground facts  b  ground actions  plotted instance number 
selected versions ipc   domains 
   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

cases except umts  that temporal versions   domain version selected
figure   non temporal  let us consider domains one one  airport  one
non temporal version  plots figure    a   b  show us quite nicely instances
scaled  sharp drops curves corresponding steps new underlying airport  precisely 
instances                               based growing airports  respectively 
within airport number travelling airplanes grows         in
instance      example  instance    instance    step one half munich airport 
   airplanes  full munich airport    airplanes 
pipesworld  two non temporal versions  without tankage restrictions  figure   shows data former  challenging one  the ipc   planners fared much
worse it   without tankage restrictions  slightly fewer facts  factor     fewer actions  pipesworld instances scaled similar way airport ones  five
growing pipeline networks feature growing number travelling liquid batches  networks underlie instances                                   respectively 
corresponding drops observed stepping instance        and  less significantly 
stepping              major difference airport visible
much crippled nature  featuring much variance  curve number actions 
because  airport  objects move big spacious structure  while  pipesworld 
many objects move within rather dense space    fundamental difference airport
pipesworld manifests order curves reversed numbers facts
actions  airport  extraordinarily many facts required describe huge airport structure 
pipesworld fewer facts smaller structure  many actions describing
things move along structure  stated earlier  pipesworld  different objects affect
others position moving 
promela domains  dining philosophers optical telegraph  data domain
versions without derived predicates identical  derivation rule deriving fact
counted action achieving fact  main difference seen lies
extremely smooth scaling  domains single size parameter  numbers
ground facts actions grow linear functions parameter functions optical telegraph order magnitude higher dining philosophers  curves
optical telegraph stop instance    able compute grounded
representation much time memory needed simplification precondition formulas  note artifact data presentation  rather constitutes serious
limitation planner tries perform pre processing 
psr  interesting domain versions small  since could formulated
strips  large  since goes instances realistic size  in largest instances 
is   name small suggests  numbers quite small able compile strips 
indicated earlier make instances small    essentially compilation
problem visible curves large  huge number ground facts actions
relatively early instances already  curves stop instance    beyond that  simplifying
    much objects cannot move affects number ground actions due mentioned filtering
unreachable actions 
    notable exception instance nr      number actions peaks       due exceedingly complex goal formula       disjuncts dnf  yields extra goal achievement action 
c f  section   

   

fie ngineering b enchmarks



p lanning

formulas becomes extremely costly  versions  note high degree variance
numbers facts actions  somewhat corresponds huge degree variance
observed planner performance domain  see figure     part variance  least
pace oscillations amplitude  explained way instances
scaled  given number sources  the instance size   generated instances increasing
minimal number switches originally fed given source  given number switches 
generated instances increasing percentage faulty lines ranging         
intuitively  larger number switches per source  larger harder expect instance
be  furthermore  percentage faulty lines tends induce easy hard easy pattern 
lines faulty  small part network resupplied devices need
switched  similarly  faulty lines exist  network resupplied
switching operations  intermediate percentage  effects actions become
complex conditioned positions many switches instances
become critically constrained harder solve 
satellite  main observation made extremely steep ascent curves
instance     particularly growth extremely high numbers actions  two reasons
this  first  one action satellite  take image    parameters reachable almost
combination objects correct types  most time  actions     parameters  
second  size instances grows sharply beyond instance    which  simply 
instances        used ipc    correspond    instances posed ipc  
challenge hand tailored planners 
consider settlers ease readability graphs  since domain
quite obviously exceptional anyway  relies almost completely numeric variables 
umts  figure   shows data plain domain version without time windows flaw action 
obvious characteristic numbers facts actions constants  true
domain versions  numbers vary slightly  reason that  way umts instances
scaled  every instance describes applications requirements  changes  only 
goal  specifying applications actually need set up  independent effect
particular scaling method used  observe numbers facts actions relatively
low around     even largest instances  applications must set up 
plans contain actions 
    quality heuristics  runtime
section  measure length best  sequential parallel  plans found
planner   sequential parallel  plan length estimates returned common heuristic
functions  runtime taken planners  precisely  optimal planners  measure 
optimal makespan  found ipc   parallel optimal planners  planners optimizing
makespan  
length standard plan graph  blum   furst         i e   index first plan
graph layer contains goals without mutexes 
best runtime taken parallel optimal planner ipc   
optimal sequential plan length  found ipc   sequential optimal planners 
   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

length serialized plan graph  pair non noop actions made mutex 
best runtime taken sequential optimal planner ipc   
satisficing planners  measure 
best  shortest  plan length  found planner ipc   
length relaxed plan initial state  an action sequence solves task one
assumes delete lists empty  computed  hoffmann   nebel         
best runtime taken satisficing planner ipc   
main goal identify characteristic behavior domains  identify characteristic
effects heuristic quality performance  reader note that  selection measurements  make several simplifying assumptions  optimal planners exclusively based
plan graph estimates  satisficing planners exclusively based relaxed plan estimates  further  satisficing planners minimize makespan  sequential plan length  chose
take account latter since potentially over estimating  non admissible  heuristic
specifically estimating parallel plan length  best knowledge  satisficing planners
minimizing makespan actually use heuristic estimating number remaining actions  employ method greedily arrange chosen actions parallel plan  said 
wish imply simplifying assumptions safe sense lose important
information  simplifying assumptions necessary make analysis presentation
feasible  data show definitely capture many crucial aspects ipc   heuristic quality
planner runtime  show data individual domains  proceeding alphabetical order 
 ipc    runtime results obtained linux machine running two pentium   cpus  ghz 
  gb main memory  time memory cutoffs    minutes   gb  per instance 
consider figure    showing data airport domain  note axis two different
meanings  runtime left hand side  number  parallel sequential  plan steps
right hand side  applies figures sub section  airport  observe
clear correlation quality plan length estimation  runtime  optimal parallel
planners  figure    a   best observed instances nr         there  difference
makespan estimate plan graph grows  grows achieved runtime 
exponential scale  may look counter example that  instance nr      plan
graph estimate exact  coincides real makespan   runtime get lower again 
note however  instance    based much larger airport previous instances 
instance    onwards  instances solved parallel planner exact plan graph
estimate  optimal sequential planners  figure    b   get similar behavior
instances nr         behavior strong instances nr         plan
length grows lot        serial plan graph becomes little shorter  correspondingly 
runtime goes two orders magnitude  true instances       
satisficing planners  figure    c   striking observation length
real plan coincides  instances  exactly length relaxed plan  for respective
initial state   actually quite easy explain  optimal plan moves airplanes way
never block paths  plan optimal even ignoring delete lists 
moving airplanes without blocking always possible start  situation changes
   

fie ngineering b enchmarks

    

  



p lanning

     

   

optimal makespan
plangraph
best parallel runtime

optimal nractions
serialplangraph
best sequential runtime
   

  

    

   
   
  

  

 

  

  

nr  steps

  

runtime  sec  

   

  

nr  steps

runtime  sec  

   

  
 
  
  

   
   

  

    

  

 
 

  

  

  

  

  

  

  

  

    

 

  

 

  

  

  

  

nr  instance

nr  instance

 a 

 b 
    

  

  

  

  

  

   
best nractions
relaxedplan
best runtime
   

   

  

   

   

 

nr  steps

runtime  sec  

   

   
   
   

    

 
 

  

  

  

  

  

  

  

  

  

nr  instance

 c 
figure    airport domain  plots  parallel  plan length  heuristic estimation  runtime 
 a  optimal parallel planners   b  optimal sequential planners   c  satisficing planners 
wrong decision made  additional moves become necessary reality 
without delete lists avoid blocking situation  apart this  figure   shows quite nicely
runtime taken corresponds closely length plan found  note latter
huge      largest instance 
pipesworld domain  two non temporal domain versions  with without tankage
restrictions  i e   restrictions amount liquid stored network areas 
figure   shows data version without restrictions  observations made
domain version similar  except sorts planners scale much worse  thus providing
us less data  optimal planners  figure    a   b   striking difference
airport domain figure    a   b  quality even parallel plan graph heuristic
bad  underestimates real makespan much larger extent airport 
underestimation grows instance size  and  naturally  runtime grows well  note
planners fail scale much earlier figure    a   b   one slight exception
rule poorer heuristic estimate leads longer runtime  instance number       
optimal sequential plan length grows        length serial plan graph remains   
runtime drops          secs 

   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

    

  

     

  

optimal makespan
plangraph
best parallel runtime

optimal nractions
serialplangraph
best sequential runtime
  

  

    

   
  
  

 

 

  

  

nr  steps

  

runtime  sec  

  

  

nr  steps

runtime  sec  

   

  
 
 
 

   
   

 

    

 

 
 

  

  

  

  

  

  

  

  

    

 

  

 

  

  

  

  

nr  instance

nr  instance

 a 

 b 
  

  

  

  

  

  

   
best nractions
relaxedplan
best runtime
   

   
 

  

nr  steps

runtime  sec  

   

  
   
  

  

    

 
 

  

  

  

  

  

  

  

  

  

nr  instance

 c 
figure    pipesworld domain without tankage restrictions  plots  parallel  plan length  heuristic estimation  runtime   a  optimal parallel planners   b  optimal sequential planners   c  satisficing planners 
similarly situation optimal planners  satisficing planners  figure    c  
main difference figure    c  much worse quality heuristic function 
relaxed plan length differs greatly length real plans found  particularly
larger instances  curiously  despite worse quality heuristic  runtimes much
lower  longest time taken instance    seconds  goes show  first 
shortcomings analysis here  give heuristic quality initial state  may
differ lot situation rest state space  example  airport planner using
relaxed plans may get lost huge dead ends wrong decision made early on  second 
course  techniques satisficing planners use relevant  runtime data
figure    b  exclusively due sgplan  wah   chen        yahsp  vidal         whose
problem decomposition greedy lookahead techniques appear work extremely well domain 
satisficing planners perform much worse  failing solve largest instances  note
pipesworld  overall runtime curves  for planners  characteristically jagged
show considerable variance comparison to  e g   airport  information gets lost
best of presentation chosen figures here  seems hardness domain comes

   

fie ngineering b enchmarks



p lanning

interactions subtle seen rather high level parameters measured here  reiterate domain version tankage restrictions much challenging planners 
planner getting anywhere close largest instances yahsp 
     

    

 

   

optimal makespan
plangraph
best parallel runtime
optimal nractions
serialplangraph
best sequential runtime

    

best nractions
relaxedplan
best runtime
   

   

  

   
   
   

nr  steps

runtime  sec  

   
nr  steps

runtime  sec  

   

  
   
 
  

   

 
 

  

  

  

  

  

  

  

    

  

 
 

nr  instance

  

  

  

  

  

  

  

  

nr  instance

 a 
 b 
figure    dining philosophers domain without derived predicates  plots  parallel  plan length 
heuristic estimation  runtime   a  optimal planners  b  satisficing planners 
figure   shows data promela dining philosophers without derived predicates 
show two separate figures optimal planners since curves quite easy read  even
quick glance  one sees domain characteristic behavior different
domains  optimal makespan  plan graph length  serial plan graph length constant
across instance size  contrast  optimal sequential plan length grows linear function
size  note logarithmic scale right hand side axis figure    a   use
make figure  the values plan step measures  readable  best plans found
satisficing planners optimal  i e   nractions data identical sides
figure  figure    a   see effect heuristic quality search performance 
parallel planners scale linear function instance size  sequential planners 
heuristic function becomes worse worse  scale highly exponentially  latter might
true satisficing planners  bit hard tell since solved instances solved
extremely quickly  reason instance index higher    solved that 
instances  similarly discussed  section       simplifying precondition formulas
became prohibitively costly  instances available adl only  two satisficing
planners scaled well dining philosophers  without derived predicates  sgplan
yahsp neither could handle adl formulation domain  similarly 
optimal planners satplan   optiplan scaled well  neither could handle
adl formulation  note inability planners handle formulas without pre simplification
techniques thus constitutes serious limitation 
optical telegraph without derived predicates  no figure shown  observations similar
ones figure    except planners scale much worse  particularly  optimal
sequential planners solve single smallest instance  best satisficing runtime clearly
exponential instance size  taking      seconds solve instance number     promela
domain versions derived predicates  results optimal planners since none
could handle derived predicates  observations satisficing planners similar
   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

above  nractions grows linear function instance size  relaxed plan length grows
linear function significantly lower gradient  planners fast dining philosophers
need lot time         sec  solve largest optical telegraph instances  some
remain unsolved   omit results promela domain versions using numeric variables 
since two planners participated domain versions 
    

  

    

  

optimal makespan
plangraph
best parallel runtime

optimal nractions
serialplangraph
best sequential runtime
  

  

   

   
  

 

  

  

  

  

 

nr  steps

  

runtime  sec  

  

nr  steps

runtime  sec  

  
  

  
  
   

   
 

 

    

 
 

  

  

  

  

  

  

  

  

    

  

 
 

  

  

  

nr  instance

  

  

  

  

  

  

nr  instance

 a 

 b 

  

  
best nractions
relaxedplan
best runtime

    

  
best nractions
relaxedplan
best runtime

  

  
  
   
  

nr  steps

runtime  sec  

  
  

  

  

   

nr  steps

  
  

runtime  sec  

 

  
  
 
  
  
 

    

 
 

  

  

  

  

  

  

  

  

   

  

 
 

nr  instance

  

  

  

  

  

  

  

  

  

nr  instance

 c 
 d 
figure    psr domain  plots  parallel  plan length  heuristic estimation  runtime   a 
parallel optimal planners psr small  strips version    b  sequential optimal planners psr small   c  satisficing planners psr small   d  satisficing planners
psr large  featuring adl derived predicates  
figure   shows results psr domain  figure    a    b   c  show plots domain version psr small  comes pure strips addressed ipc   planners 
figure    d  shows plots psr large  comes adl derived predicates
addressed four satisficing planners only  show data psr middle compiled
psr middle  former  two satisficing planners participated  latter  six satisficing
planners participated  scaled quite well less challenging instances results
less interesting psr large 

   

fie ngineering b enchmarks



p lanning

first  note curves psr small show large amount zig zagging  quite
unusual cannot simply accounted way instances scaled    consider
figure    a   main observation made real optimal makespan much larger
estimation plan graph  particularly larger instances  still  optimal parallel planners
quite efficient  least solve instances  runtime data entirely due
satplan    whose search techniques apparently quite efficient domain even
bad plan graph lower bound  optimal planners least one order magnitude
slower  cant solve largest instances  example  none solve instances   
    optimal sequential planners figure    b   results pretty similar except
runtime scaling somewhat worse  kinds optimal planners  runtime clearly
correlated length optimal plans  which  since plan graph bounds almost
constant  coincides difference real plan length estimate 
figure    c   observe relaxed plan bad estimator plan length psr
small  at least respective initial states   planners solve instances quite efficiently anyway  runtime data entirely due yahsp fast downward  particularly
fast downward extremely efficient  showing slight increase runtime instance
size  satisficing planner capable solving instances        note yahsp
 vidal        uses powerful techniques besides relaxed plan heuristic  fast downward
 helmert        uses involved  and apparently powerful  case  heuristic function  note that  least terms solved instances  optimal satisficing planners are 
unusually  equally good  or bad  domain  exactly one group solves instances 
planners cannot solve instances        difficulty planners experiencing
domain remarkable since instances  least grounded encodings  actually
small compared instances domains  c f  figure    indicates
domain fundamental characteristic yet captured well search
heuristics techniques  most of  planners nicely complements said
non obvious polynomial algorithm psr section     
figure    d   see relaxed plan  computed version handling derived
predicates  see thiebaux et al               rather useless estimator psr domain
expressed natural way using adl derived predicates  relaxed plan constantly
contains   steps  meaning over approximation semantics derived predicates makes
initial state look goal state  happens psr middle  situation may
different parts state space heuristic value constantly   this  apparently 
causes serious trouble satisficing planners except fast downward  planner except fast
downward solve instance higher number     fast downward seems profit  again 
involved heuristic function  reaching scaling limit instance number    
satellite domain  many temporal numeric domain versions  select 
presentation here  single pure strips version  figure    a   b   observe that 
pipesworld promela  unlike airport psr  satellite domain serial
plan graph provides much worse heuristic values  for sequential planning  parallel planning
graph  for parallel planning   instances solved optimal planners  parallel plan
length  serial parallel  plan graph length grow much  sequential plan length
does  consequently  sequentially optimal planners scale much worse parallel ones 
    true runtime curves individual planners  fact  planners even disagree widely
instances solved easily take lot time 

   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

    

  

     

  

optimal makespan
plangraph
best parallel runtime

optimal nractions
serialplangraph
best sequential runtime
  
    

   

  
  

 

  
nr  steps

runtime  sec  

 

nr  steps

runtime  sec  

   
 

  

  
  

 
 
 

   

  
   
 

    

 
 

  

  

  

  

  

    

  

 
 

  

  

  

nr  instance

nr  instance

 a 

 b 
   

  

  

  

   
best nractions
relaxedplan
best runtime

   
   

  

   
 

   

nr  steps

runtime  sec  

   

   
   
   
   
  
    

 
 

  

  

  

  

  

  

nr  instance

 c 
figure    satellite domain  plots  parallel  plan length  heuristic estimation  runtime 
 a  optimal parallel planners   b  optimal sequential planners   c  satisficing planners 
figure    a   nicely see how  instances           parallel plan length
down up movement           constant parallel plan graph length      resulting
movement pretty much shape logarithmic scale  best parallel runtime 
figure    c   observe that  airport unlike domains 
relaxed plans initial states almost length real plans  there actually
slight over estimation time   seen earlier  c f  section      hoffmann
       shown that  satellite  relaxed plan length is  fact  bound close real plan
length states  in contrast airport  unrecognized dead ends possible principle  
indeed  satellite easy tackle almost satisficing planners ipc   
runtime shown figure    c  appears non trivial  remember instances huge  see
particular number ground actions figure    b   instance     satisficing ipc  
planners could solve instance within minute 
skip settlers domain since relies almost exclusively numeric variables encode
domain semantics  makes rather incomparable domains  figure    shows
data umts domain  temporal numeric versions  half feature
time windows  consider versions without time windows  figure     a   b  concern

   

fie ngineering b enchmarks

     

   
optimal makespan
plangraph
best parallel runtime



   

  
best nractions
relaxedplan
best runtime

   

    

p lanning

  

   
  

   
  

   

  

  

nr  steps

   

runtime  sec  

   

temporal makespan

runtime  sec  

   

  

   
  
 

   
  

   
   

   
 

  

  

  

  

  

  

  

  

    

  

 
 

  

  

  

nr  instance

  

  

  

  

  

  

nr  instance

 a 

 b 

    

   
optimal makespan
plangraph
best parallel runtime

 

  
best nractions
relaxedplan
best runtime

   

  

   

  

   
   

   

  
   
  

nr  steps

   

runtime  sec  

  

temporal makespan

runtime  sec  

  
   

  
   
 

  

   

  

   
   

   
 

  

  

  

  
  
nr  instance

  

  

  

    

  

 
 

  

  

  

  
  
nr  instance

  

  

  

  

 c 
 d 
figure     umts domain  plots  durational  plan length  heuristic estimation  runtime 
 a  optimal  b  satisficing planners plain temporal version   c  optimal  d  satisficing planners temporal version flaw action 
plain domain version  figure     c   d  flaw action  let us first consider optimal
planners  left hand side overall figure  optimal planners could tackle
domain i e   domains syntax tp  hspa  haslum   geffner        
makespan minimizing planners  data sequentially optimal planners  which
wouldnt make lot sense temporal setting anyway   plangraph curves figure   
 a   c  correspond makespan estimation delivered initial state tp s temporal
numeric extension heuristic  effect heuristic quality runtime  observe
strong correlation  figure     a   instance    makespan estimate
close real makespan time  two actually coincide runtimes
good  starting instance     real makespan makes sudden leap upwards
followed estimation  runtimes shoot upwards  phenomenon clear
instances             makespan estimation exhibits good  bad  good pattern 
runtime same  figure     c   sort behavior observed 
meaning particular flaw action effect makespan estimation
tp   fact  makespan estimation exactly instances solved
domain versions  contained implicitly latter sentence  flaw action affect runtime

   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

set solved instances  runtime flaw action consistently
factor   larger without flaw action  challenging instances planners fail
flaw action present  decrease performance presumably due larger state
space incurred flaw action 
consider satisficing planners  figure     b   d   first observe that  more 
facing individual characteristic behavior  domain challenge
satisficing planners  latter shows domain useful benchmark satisficing
planners  shows heterogeneous benchmark set is  common
satisficing planners faster optimal ones except psr domain
picture extreme umts  stated earlier  domain pure scheduling problem 
obviously satisficing planners provide runtime efficient greedy solutions problem   
looking plots little detail  find figure     b  sequential plan length  the
plans found optimal  simple stepwise linear function instances  relaxed plan
length initial state coincides real plan length isnt surprise given
excellent runtimes satisficing planners  fact scheduling domain   in
sequentialized schedule harmful delete effects occur   picture changes lot figure     d  
real plan length stays basically  is increased constant     relaxed plan
length becomes lot shorter due flaw action  satisficing planners unaffected  largely
keeping excellent runtime behavior  apparently  planners incorporate technique
recognizing uselessness flaw action  this done simple domain analysis
techniques   getting rid influence  suspicion confirmed fact one
satisficing planner get affected flaw action way one expect  crikey 
heuristic search forward state space planner using relaxed plan heuristic  solves task within
   seconds without flaw action  sometimes takes      seconds flaw action 
let us briefly summarize overall observations 
presented data  time performance planners correlates well
quality relevant heuristic function  notable exceptions rule far
observed data fast downward psr large  relaxed plans
pretty much devoid information  sgplan yahsp  to extent fast
downward  pipesworld  relaxed plans provide poor estimates planners
experience  much more  serious difficulties 
usually  known benchmarks general  satisficing planners several orders
magnitude faster optimal ones  exceptions psr groups perform
almost equally umts satisficing planners hardly need time all 
usually  known benchmarks general  parallel plan graph length much
better estimator parallel plan length serial plan graph length sequential plan
length  exceptions airport often huge difference
lengths two kinds plan graphs and  extent  psr small
difference parallel sequential plan length big  note none
domains purely sequential  i e  parallelism possible them 
    terms quality solutions found  satisficing planners reasonably well  example  lpg td 
minimizes makespan domain  finds  version optimized speed  plans take maximally
    time optimal ones found tp   version lpg td optimized plan quality  goes
   

   

fie ngineering b enchmarks



p lanning

usually  known benchmarks general  considerable difference
length relaxed plan initial state  length real plan
initial state  exceptions airport  satellite  umts  lengths
identical nearly so 
usually  known benchmarks general  largest instances solved
within given particular time memory     minutes  gb  plans around
hundred steps more  psr exceptional fast downward planner able
find plan     namely      steps 
indicates diversity ipc   domains almost every one appears
least exceptions listed here  domains dont appear promela
domains pipesworld  sort exception itself  meaning domains contribute
typical benchmark behaviors overall set 
take existence mentioned distinguishing features evidence
ipc   domains indeed several novel aspects  besides oriented applications
structurally diverse  particular  behavior psr domain stands one typically observes  note that  typically easy construct artificial domains provoke
unusual behavior  domains oriented applications  exhibited behavior  particularly psr domain  unusual  relevant
concrete sense 
    fact connectivity
conclude empirical analysis data aimed assessing sort connectivity
facts  fact p  measure number adders  actions p add list  in
adl case  effect p adds list   gives indication branching factor
action choices comes fact  measure number requirers  actions
p precondition  in adl case  effect p condition  
gives indication central fact task  given planning task  measure
parameters distribution adders p  requirers p   set facts p  minimum
 min   mean  mean   maximum  max   standard deviation  dev   within domain versions 
plot data instance size  number  
data abstract allow deep conclusions reasons planner performance 
able highlight characteristic features domains  particular  see
abstract measurements behave characteristically different ipc   domains
ipc   domains  figure    shows plots ipc   domains airport  pipesworld  dining
philosophers  satellite  picture psr relatively complicated shown separately
figure     settlers left exceptional  picture umts extremely simple 
explained text below 
consider figure     a    non temporal  airport domain  min curves shown
since constantly    is pushing back airplane  never added since pushback requests  of
outbound traffic  modelled  occupied segment  required negation  max
curves step functions since follow size underlying airports  is moving airplane 
many adders segments  since start up engine done segment  ispushing back airplane  required every action  leading overall similar form

   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

    

     
 adders  max
 adders  mean
 adders  deviation
 requirers  max
 requirers  mean
 requirers  deviation

   

    

  

   

 

  

   

 adders  max
 adders  mean
 adders  deviation
 adders  min
 requirers  max
 requirers  mean
 requirers  deviation
 requirers  min

 
 

  

  

  

  

  

  

  

  

  

 

  

  

  

nr  instance

  

  

  

  

  

  

nr  instance

 a 

 b 

    

    
 adders  max
 adders  mean
 adders  deviation
 requirers  max
 requirers  mean
 requirers  deviation

 adders  max
 adders  mean
 adders  deviation
 requirers  max
 requirers  mean
 requirers  deviation

   

   

  

  

 

 
 

  

  

  

  
nr  instance

  

  

  

  

 

  

  

  
nr  instance

  

  

  

 c 
 d 
figure     distributions numbers actions adding fact  actions requiring fact 
selected versions ipc   domains   a  airport   b  pipesworld   c  dining
philosophers   d  satellite 
max requirers curve  mean adders curve flattened facts ismoving airplane  added certain places airport  mean requirers curve  interestingly  shows similar downwards step behavior numbers facts actions shown
figure    reason lies not occupied facts  exist every segment 
needed every action moving  any  airplane across segment  number facts
increases number airplanes  since many facts  strong
influence mean  much correspondence runtime data 
trivial one tend grow instance size 
data pipesworld  tankage non temporal  shown figure     b   several observations
made     max mean curves clearly follow scaling pattern  growing traffic
  growing underlying networks     min curves non zero     characteristic
difference curves instance     afterwards     curves adders
requirers almost  but exactly  coincide  apart    present airport data 
observations clearly distinguish pipesworld domains  observation
   sometimes larger instances min number adders drop    due
interactions complex networks  certain configurations inside pipes true initially

   

fie ngineering b enchmarks



p lanning

re achieved later interactions recognized reachability
pre process made actions  c f  explanation section      observation   due
large contrast smallest network larger ones  smallest network
unitary pipelines  containing single batch   others pipelines least length   
observation   particularly odds domains  large differences
adders requirers  fact  measuring distribution difference adders
requirers  found numbers  not distribution parameters  extremely
close together  instance     max adders      max requirers       max
difference     mean      dev       pipesworld tankage restrictions 
phenomenon somewhat less extreme still there  another characteristic enormously
large max number adders requirers  order magnitude larger
domains  max adders requirers come do normal facts  control status
individual pipelines  affected action moving combination batches
respective pipeline  facts depend single batches  not combinations them  
flattens mean curves two orders magnitude  regarding runtime  mentioned
earlier  pipesworld scaling pattern clear correlation runtime  neither
fact connectivity measure here 
consider promela domain figure     c   data shown dining philosophers derived
predicates  again  extreme characteristics domain recognizable first glance 
data dining philosophers without derived predicates identical  data optical telegraph differ numbers higher  min curves    adders constant 
requirers linear  exist facts without adders due oddity encoding 
certain start up transitions put forks table first place  facts without requirers
blocked philosopher  needed goal  number adders depend
instance size due static sort domain structure  size increases number
parallel processes  philosophers   form processes stays fixed  every process
interacts exactly two processes  number requirers linear  non constant  particular  due technicality encoding  activating  requesting  performing
 executing  transition requires communication channels neutral state  respective
flags required transitions  number course grows size  facts
required locally  resulting much lower  easily two orders magnitude  mean  one
would expect domain simple scaling pattern  planner performance pretty much
function size 
data satellite  strips version  shown figure     d   characteristic feature 
comparison domains  extremely smooth parallel close together growth
curves  curve stands little max requirers  max adders due pointing satellite  direction  facts added turning direction  max
requirers due power on instrument  facts  needed every take image
instrument  done every combination direction image mode supported
instrument  note that  contrast domains max curves two
orders magnitude higher mean  max requirers one order magnitude
curves  curves roughly order  min curves
shown since constantly   adders power on instrument  added
switch on instrument  constantly   requirers have image direction  needed

   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

goal  runtime performance ipc   planners scales relatively smoothly size
satellite  parameters do 
umts  parameters constants  another consequence aforementioned
scaling pattern  number specified applications instances 
changes  only  goal  specifying applications shall actually scheduled  precisely  plain domain version  number adders   facts  nicely showing
scheduling domain characteristic choice accomplish tasks 
accomplish them  another illustration satisficing planners find
domain trivial  whereas optimal planner tp   haslum   geffner        spend long
time searching optimal schedule  number requirers minimum    maximum    mean
      standard deviation       domain version flaw action  notable difference
max adders   due alternative provided flaw action  min   
mean      deviation       interesting note context that  mentioned above 
domain version satisficing planner  crikey  experiences serious trouble 
     

     
max
mean
deviation

max
mean
deviation

    
    

 adders

 required

   
   

  

  
 

   

 
 

  

  

  

  

  

  

  

  

  

 

  

  

  

nr  instance

  

  

  

  

  

  

nr  instance

 a 

 b 

  

    
max
mean
deviation

max
mean
deviation

  

  

 required

 adders

   
  

  

  
  

 

 

 
 

  

  

  

  
nr  instance

  

  

  

  

  

 

  

  

  

  
  
nr  instance

  

  

  

  

 c 
 d 
figure     distributions numbers actions adding fact  actions requiring fact 
psr small large   a  adders small   b  requirers small   c  adders large 
 d  requirers large 
data psr shown figure     here  show plots adders requirers separately
makes much readable  since data contain particularly interesting
   

fie ngineering b enchmarks



p lanning

phenomena  show two domain versions  small large  obvious feature
small  figure     a   b   is  again  huge amount variance data  clearly
discernible peaks curves  instance nrs                  coincide peaks size
measured numbers facts actions figure    note large
range values  spanning four orders magnitude  even though instances  except number
    small comparison domains shown figure    minimum numbers
adders requirers constantly    updated breaker  added wait breaker  action 
not closed breaker  needed one wants close it    regarding maximum adders
requirers  instance     far highest        total number actions  max adders
       due goal reached fact  i e        disjuncts dnf goal formula 
max requirers        due do normal  flag needed every goal reached action 
plus actions opening closing breakers  remark facts responsible
peaks curves  i e   happens instances            
highly characteristic psr small max numbers adders requirers approach sometimes exceed two thirds total number actions  case
domain  even domain version psr  see below   intuitive reason lies
one pre compilation steps employed order able formulate reasonably
large psr instances pure strips  compilation step  bertoli et al         removes network
reasoning  and it  need derived predicates  basically enumerating breaker configurations effects flow current network  result dense structure
end network directly affects every end  explaining high degree
fact connectivity  particular explaining extremely complex goal formulas four peak
cases mentioned above 
pre compilation step key understanding huge difference behavior small  large  latter shown figure     c   d   there  max
adders curve small linear function note non logarithmic scale axis spite
 mostly  much larger numbers actions  example  instance highest number       
actions derivation rules number     max number adders     less half
percent total number actions  natural high level domain encoding here 
flow current network modelled transitive closure derivation rules
propagate current based local status network  particular breaker
configurations effects flow current implicit structure network 
again  psr large  min curves constantly   adders requirers  notaffected breaker  negation derived predicate  needed precondition open close
actions   isnt added inverse rule  given meaning negation failure
semantics derived predicates  fed line  required goal  mean dev
adders completely flattened numerous             instance     upstream x y 
facts  true currently path open side node x side node y  added
local derivation rule relies predicate neighbors y  similarly
satellite  max number requirers generally lot larger max number adders 
example      vs     instance     max requirers due fact closed device 
required derivation rules talking pairs devices  instance               actions
rules     devices 
    sometimes   minimum requirers due artificial goal reached fact  introduced get rid complex
goal formulas  c f  section   

   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

    

    
 adders  max
 adders  mean
 adders  deviation
 requirers  max
 requirers  mean
 requirers  deviation

 adders  max
 adders  mean
 adders  deviation
 requirers  max
 requirers  mean
 requirers  deviation

   

   

  

  

 

 
 

 

 

 

  

  

  

  

  

  

 

 

 

 

nr  instance

  

  

  

  

  

  

  
  
nr  instance

  

  

  

  

nr  instance

 a 

 b 

     

    
 adders  max
 adders  mean
 adders  deviation
 requirers  max
 requirers  mean
 requirers  deviation

 adders  max
 adders  mean
 adders  deviation
 requirers  max
 requirers  mean
 requirers  deviation

    
   

   

  
  

 

 
 

 

 

 

  
  
nr  instance

  

  

  

  

 

 

 

 

 c 
 d 
figure     distributions numbers actions adding fact  actions requiring fact 
strips versions ipc   domains except freecell satellite   a  depots   b 
driverlog   c  rovers   d  zenotravel 
sum sub section  data are  generally  abstract really tightly interconnected
performance exhibited planners  hand  certain characteristics visible 
particularly  pipesworld  numbers adders requirers almost identical 
promela  adders constant requirers linear  satellite  curves close
together  psr small lot variance  max numbers adders requirers
approach sometimes exceed two thirds total number actions  contrast  psr
large max adders decline less half percent total number actions  umts 
parameters constant  except psr umts  phenomena somewhat hard
interpret  nothing else  certainly show us domains rather different
characteristics  interestingly  differences significant ipc   benchmarks shown
figure     clearly  behavior characteristically diverse seen
ipc   domains  four domains figure     basically observe mostly parallel lines
pretty close together except max lines  order magnitude higher
others  striking feature zig zag nature curves depots  due
scaling pattern  smallest instances  number crates  blocks  grows continually
   crates instance    thereafter  come blocks   instances each  first  

   

fie ngineering b enchmarks



p lanning

crates  second    crates  third    crates  across blocks  instance size parameters
grow   means zig zag shape curves corresponds exactly zig zag shape
crate numbers 
note behavior plots figure    similar behavior plot satellite
figure     d   particular first    instances  instances posed fully
automated planners ipc    shown figure     ipc   domain truly stands
terms behavior curves freecell    there  observe phenomenon similar
pipesworld figure     b   curves adders requirers almost coincide 
phenomenon little weaker pipesworld  largest freecell instance  number    
max  both  adders requirers       max difference      mean
      dev        comparison  largest pipesworld instance  max adders      
max requirers       max difference     mean      dev      
sum overall empirical analysis  data certainly dont solve mystery
behind performance every planner every domain  and instance   do  however  provide
interesting insights instances scaled domains  certain subtleties
peculiarities encodings  standard heuristic methods  groups planners 
react them  observe large characteristic differences domains  sense
results nicely complement technical descriptions appendix a  well known theoretical
results section   

   conclusion
field research general reasoning mechanisms  ai planning  essential
useful benchmarks  benchmarks reflect possible applications developed technology 
help drive research new fruitful directions  development benchmark
domains instances ipc    authors invested significant effort creating set
useful benchmarks ai planning 
explained introduction  three main goals tried achieve    realism    
structural diversity     accessibility benchmarks  debatable extent goals
achieved  extent  inherent conflicting nature goals  accessibility
benchmark formulation simple possible pddl dialects obviously conflict
realism  structural diversity conflict realism since  time window available
create competition benchmark set  may  and been  case  large set
suitable applications choose from  one must make whats available  stressed
realism since lack realism traditionally considered one main weaknesses
ai planning achieving structural diversity accessibility would  fact 
comparatively easy  see below   said  adapt applications ipc
make many significant simplifications  still  derived domains applications  one
expect capture important features even simplification  top that 
clear path towards realism 
believe domains constitute best possible compromise ipc    name
distinguishing features domain set 
    somehow makes sense precisely domain stands out  intuitively different
domains  notably  deciding plan existence freecell np hard easy domains  c f 
section     

   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

   airport  pipesworld  psr  umts derived directly applications  promela
special case since model checking instances could encode simplistic  
previously case elevator domain  ipc    rovers satellite
domains  ipc    
   complexity satisficing optimal planning strips domain versions covers
entire range p  np  pspace deciding  bounded  plan existence p psr
pspace complete airport general promela  aware previous
pspace complete strips benchmark  polynomial algorithm finding plans psr
is  contrast strips benchmarks algorithms  quite nontrivial 
   hoffmanns        taxonomy domain classes different h  topology  ipc  
domains lie classes sparse coverage previous benchmarks  particular  none
new domains nearly simple topology proved hoffmann
traditional benchmarks  taking account pipesworld actions inverted
 not one but  two steps  domains lies different class hoffmanns taxonomy 
covering classes     previous ipc benchmark set          ipc    ipc   
ipc    respectively   dining philosophers exceptional lies simple class
doesnt simple topology  airport exceptional lies hard class
typically  in real world instances  easy 
   behavior different kinds planners ipc   shows lot characteristic
patterns individual domains  airport  sheer size main obstacle  pipesworld 
particularly tankage restrictions  known heuristic functions badly 
promela domains  main obstacle is  lot cases  impossibility compiling
pddl description fully grounded simpler representation  psr  extremely
large amount variance  optimal planners perform well  or poorly  satisficing
planners  umts  satisficing planners need time all 
   abstract level looks numbers actions adding needing fact 
behavior domains characteristically diverse ipc   domains 
   last least  strips versions domains preserve much original
domain structure previously case  ipc   strips version elevator
hardly elevator problem anymore  ipc   strips versions satellite rovers
devoid interesting problem constraints  contrast  strips versions
airport promela semantically identical adl versions  psr strips
version  pre compiled lot  still preserves much original difficulty domain
 judging  e g   behavior ipc   planners it  
feature   is  obviously  point realism  features     points diverse structure  particularly feature   shows domains pose different challenges  current  planning
technology  feature   point realism combined accessibility  would stress
accessibility respect really quite important     planners entered ipc   
  could handle  some  adl features  compilation approach enabled us confront   
planners reasonably realistic problems  said  certainly debatable role strips
   

fie ngineering b enchmarks



p lanning

plays play community  people may say many core algorithms 
e g   planning graphs  blum   furst        relaxed plan heuristics  mcdermott        bonet
  geffner        hoffmann   nebel         invented strips  others may say
focus strips like languages algorithms distracts us considering temporal numerical problems truly different nature  notwithstanding  strips still widely
used language among research community  cannot ignored competition organizers 
pointed advantages benchmark set  point
disadvantages  explained detail individual sections appendix a  make
many simplifications order make applications fit use ipc    extent  whether
simplifications preserve original domain structure debatable matter  feel
airport encoding close real physical thing  able represent
real optimization criterion bad  ameliorated fact that     planners 
single one  lpg td  could actually deal user defined optimization criteria    pipesworld 
simplifications severe  ipc   domain still resembles core difficulties 
reminiscent  complicated  toy example software could used control
real pipelines  promela examples go show toy examples model checking area
better traditional toy examples planning  psr  removing uncertainty
numerical optimization renders ipc   domain unsuitable practical use 
course  domain set exhaustive  meaning presumably numerous applications whose essential structure similar ipc   domains  examples
spring mind action choice autonomous robots  detecting security holes computer networks  boddy  gohde  haigh    harp         online manufacturing  ruml  do    fromherz 
       structural diversity  would easy construct set artificial domains
explore possible extreme cases  domains would probably completely infeasible current planners  thus posing strong challenges  think of  example  rubiks
cube  sokoban  rintanens        purely randomly generated instance distributions  again 
domain set would devoid realism  point preparation ipc   
considered introducing separate class domains  called diverse structure  would
contained domains sort  decided since competition event already
large without it  also  felt applications already quite diverse structural
side  pointed above  several theoretical empirical phenomena suggest latter
indeed case 
work  experienced various successes failures accurately formulating
application domains pddl  people asked us if  this  obtained picture
suitable pddl is  current form  formulate applications  sorts domains
works well  answer is  dont feel obtained many insights matters
particularly deep havent known before  lessons learned these  first
foremost  formulating application strips takes huge amount engineering expertise unless
one drops problem constraints  simplifications unavoidable  second  discrete
nature action instantiations previous ipc pddl dialects seriously impedes formulation
domains continuous aspects  discretization must chosen  sometimes easy
 airport  sometimes hard  pipesworld  do  good way seems adopt
duration inequalities suggested fox long         third  community pay
    good example case pddl moving faster actual planning technology 

   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

attention lifted encodings  deal modern planning algorithms  one lesson
compilation activities grounding parameters often simply possible
 promela  psr   since compiling away adl constructs often feasible without grounding  c f 
section     relevant adl strips context  final lesson   the ai
planning community  still  mostly  far away as is applicability planners real world 
right track 
conclude  spent significant time effort creating useful set planning benchmarks
ipc    hope become standard benchmarks coming years 

acknowledgements  would thank competitors detailed comments
bugs found domains  would thank malte helmert various useful tools
helped remove bugs 
thank malte helmert providing us yet unpublished  time
writing results computational complexity  helmert            b   thank patrik haslum
providing us tp  temporal numerical plan graph estimates makespan umts
domain  indebted anonymous reviewers  much david smith maria
fox  whose detailed extensive comments contributed greatly development paper 
finally thank david smith extensive advice language  including corrections even
acknowledgements 
jorg hoffmann thanks wolfgang hatzack support development airport
domain benchmark instances 
frederico dos santos liporace supported conselho nacional de desenvolvimento cientfico
e tecnologico  brazil  would acknowledge support phd supervisor  ruy milidiu  development pipesworld application 
sylvie thiebaux thanks piergiorgio bertoli  blai bonet  john slaney contributions
development psr domain instances  would acknowledge
support national ict australia  nicta funded australian governments backing
australias ability initiative  part australian research council 

appendix a  detailed domain descriptions
provide detailed descriptions domains  alphabetical order  section  except
satellite settlers domains  adapted ipc    organized
sub sections follows  first give outline application domain  explain
main adaptations made model application pddl domain ipc    explain ipc  
domain structure  i e   domain versions formulations used ipc    explain
generated example instances ipc   test suites  finally  discuss possible future
extensions 
a   airport
contact person application domain  wolfgang hatzack  working
application area several years  domain adapted ipc   jorg hoffmann
sebastian trug 

   

fie ngineering b enchmarks



p lanning

a     pplication omain
task control ground traffic airport  timed travel routes must assigned
airplanes reach targets  inbound outbound traffic  former
airplanes must take  reach certain runway   latter airplanes
landed get parked  reach certain parking position   main problem constraint is 
course  ensure safety airplanes  means avoid collisions  prevent
airplanes entering unsafe zones behind large airplanes engines running 
optimization criterion minimize summed travel time  on surface airport 
airplanes    usually standard routes  i e   routes airplane outbound
certain park position area  inbound certain runway  must take  reason introducing
routes is  simply  sheer complexity managing situation otherwise  without significant
computer support  which yet available real airports   see whether
standard routes present makes big difference computationally 
airplanes move airport infrastructure  consists runways  taxiways 
parking positions  runways taxiways sub divided smaller segments  position
airplane given segment currently located in  plus direction
precise position within segment several airplanes segment time 
airplanes generally divided three categories  light  medium  heavy  classify
according engine exhaust  jet blast   airplane moved either inbound out bound  in bound airplanes recently landed way runway
parking position  usually gate  out bound airplanes ready departure  meaning
way departure runway  since airplanes cannot move backwards  need
pushed back gate onto taxiway  start engines  airports
provide different park positions allow airplane start engines directly 
ensure safety  airplane must get close back another airplane whose engines
running  far safety distance depends category  jet blast  second
airplane 
ground controller planner communicate airplanes ways
shall take stop  guidance given purely reactively  pays base
decisions anticipating future  otherwise may happen airplanes block
need time necessary reach destinations airport  objective is  said 
minimize overall summed traveling times airplanes 
instances domain  one considers traffic situation given point time 
time horizon of  say  one hour  new airplanes known land given time slots inside
time horizon  time slots respective runways considered blocked 
planner make sure runways free times  course  situation
changes continually  new planes moved plans cannot executed intended   continuous re planning  i e   consideration domain instance describing new traffic situation 
necessary  solving instances optimally  the corresponding decision problem  pspace complete
without standard routes  helmert      b  np complete routes standardized  hatzack
  nebel         latter case  pure scheduling problem  former case  compli    criterion airport wants minimize  order maximize throughput  point view
airlines  would better minimize delay  e g   minimizing summed squared delay airplanes 
two criteria may conflict  neither two easily modelled pddl     see below 

   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

cated  highly unrealistic  course  airport topologies lead exponentially long solutions  c f 
section     
a     ipc   pddl daptation
pddl encoding  as well example instance generation process  see below  based
software wolfgang hatzack  namely system called astras  airport surface ground traffic
simulator  software package originally designed training platform
airport controllers  astras provides two dimensional view airport  allowing user
control airplanes means point click  astras simulate traffic flow
airport course specified time window 
made three simplifications  one benign  airport model  benign
simplification  model park positions airplane start engines directly 
without pushed back taxiway first  difficult model park positions
pddl  seldom occur reality relevant application  first
important simplification assume somewhat cruder notion airplane locatedness 
requiring single airplane located segment time  is  use
term segment meaning smallest indivisible unit space  minimize loss
precision   some of  original segments sub divided several new smaller segments 
safety distance behind back airplane whose engines running measured
terms number segments  discretization makes us lose precision  believe
distort nature problem much  due amount expected conflicting
traffic different points airport  high near parking positions   relatively easy
choose discretization segments different length precise small enough
time    last simplification severe  give real optimization
criterion  say rather strong simplification below  use full standard
routes  thus allowing airplanes choice move  use standards
routes  particularly regions near runways large airports  one thing  served keep
large airports manageable pddl encoding planners  another thing  seems good
compromise exploiting capabilities computers time keeping close
traditions airports  get back matter section a     
full pddl description domain encoding downloaded ipc   web page
http   ipc icaps conference org   briefly  encoding works follows  available actions
pushback  move plane away backwards parking position   startup engines 
move segments  park  turning engines   takeoff  which amounts
removing plane airport   semantics actions encoded based
predicates defining current state airplane  point time  airplane either
moving  pushed  parked  airborne  airplane always occupies one segment and  engines
running  may block several segments depending size occupied segment
category airplane  action preconditions ensure blocked segments never
occupied another airplane  initial state  plane either parked  moving  parked
plane pushed back  starting engines  moving  moving airplane
    need smallest indivisible units  of space  case  fundamental consequence discrete nature
pddl     said section a     

   

fie ngineering b enchmarks



p lanning

either move current segment neighboring segment  park parking position
take runway 
example  look pddl encoding  non durational  move action  one
preconditions used example section   already  
  action move
 parameters
  a   airplane  t   airplanetype  d    direction  s   s    segment  d    direction 
 precondition
 and  has type  a  t   is moving  a   not     s   s     facing  a  d    can move  s   s   d  
 move dir  s   s   d    at segment  a  s  
 not  exists   a    airplane   and  not     a   a    blocked  s   a     
 forall   s   segment   imply  and  is blocked  s  t  s   d    not     s  s      not  occupied  s     
 effect
 and  occupied  s    blocked  s   a   not  occupied  s     not  at segment  a  s     at segment  a  s  
 when  not  is blocked  s   t  s   d     not  blocked  s   a   
 when  not     d   d     and  not  facing  a  d     facing  a  d    
 forall   s   segment   when  is blocked  s  t  s   d    blocked  s  a   
 forall   s   segment   when
 and  is blocked  s  t  s   d    not     s  s     not  is blocked  s  t  s   d    
 not  blocked  s  a      

six parameters lot compared usual benchmarks cause
prohibitive explosion instantiations since lot restriction static predicates 
airplane  a moves  type  category   t  segment  s  facing direction  d  
 s  facing direction  d  move  direction simple concept
says end segment airplane facing  course  moves  s   d 
 s   d  possible specified static topology airport  can move 
move dir   first two complex preconditions says  s  must currently
blocked airplane  a itself  second complex precondition makes sure
that  move   a block segment currently occupied  by another airplane 
necessarily    is blocked  s  t  s   d   static predicate true iff  s endangered
blocked plane type  t  s w facing direction  d   effects selfexplanatory  simply update at  occupied  blocked information  effect
looks little complicated last one says segments blocked
move  longer blocked move  become un blocked  note conditions
conditional effects static  conditions disappear parameter instantiation chosen 
durational pddl  actions take time according simple computations  time
taken move across segment depends  naturally  segment length speed 
assumed airplanes move speed regardless category  time taken start
engines proportional number engines  actions fixed duration 
planes known land near future  blocking runways  model
blocking time windows using timed initial literals  respectively compilation
artificial  temporal  pddl constructs  timed literals simply instances usual blocked
predicate  becoming true respective time window starts  becoming false
ends 
able model real optimization criterion airport ground traffic control 
standard criterion pddl minimize execution time  i e   makespan  plan 
   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

encoding domain comes minimizing arrival time  meaning  arrival
destination airport  last airplane  real objective is  said above  minimize
overall summed travel time airplanes  appears good way modeling
criterion current pddl  difficulty lies accessing waiting times planes  i e 
times stay segment waiting plane pass   
way  we could think of  get access waiting times  current pddl 
introduce explicit waiting action  one must able tell planner  i e   encode
action  long plane supposed wait  one option use duration inequalities
proposed fox long         action imposes constraints duration 
planner can has choose actual duration action  point used
plan  additional  rational valued  parameter  potential disadvantage approach
choice waiting time introduces  principle  infinite branching factor
state space  may thus make problem much harder automated planners  moreover  duration inequalities put use ipc    part pddl     using
duration inequalities  way encode requested waiting time action use
discretization time  one introduce new objects representing every considered time
interval  give waiting action parameter ranging objects  apart loss
precision involved discretization  approach likely cause huge performance
problems automated planners  alternative way out  considered introducing special
current time variable pddl     returning time evaluation plan execution 
using look clock  one could make plane record arrival time  thus formulate true optimization criterion without major changes domain structure  ipc  
organizing committee decided introduction current time variable seemed
problematic algorithmic point view  it implies commitment precise time points
planning time   didnt seem relevant anywhere except airport 
all  ipc   pddl encoding airport domain realistic except optimization criterion  demands minimize maximal arrival time makespan instead summed
travel time  remains remark one  lpg td  ipc   planners ignored
optimization criterion anyway  also  minimizing latest arrival time appear useful  if
ideal  objective 
a     ipc   omain tructure
airport domain versions used ipc   non temporal  temporal  temporal timewindows 
temporal timewindows compiled  first versions is  name suggests  nondurational pddl  second version  actions take time explained above  third fourth
versions consider runways blocked future planes known land given time
windows  third version encodes time windows using timed initial literals  fourth
version uses literals compilation standard temporal pddl constructs  c f  section   
domain versions  problem constraints modeled using adl  i e   complex preconditions conditional effects  compiled adl encodings strips domainspecific software implemented purpose  grounded operator
parameters  precisely  parameters except  action  one giving name
    modelling summed  squared  delay airplanes  optimization criterion airlines  would pose essentially
difficulty  involves computing arrival time  in order compute delay  

   

fie ngineering b enchmarks

version
non temporal
non temporal
temporal
temporal
temporal tw
temporal tw
temporal twc
temporal twc

formulation
adl
strips
adl
strips
adl
strips
adl
strips



max  op
 
    
 
    
 
    
  
    

p lanning

max  act
          
             
          
             
         
             
         
             

table    overview different domain versions formulations airport  abbreviations used  temporal tw temporal timewindows  temporal twc temporaltimewindows compiled  max  op maximum number  parameterized  pddl
operators instance  max  act maximum number ground actions
instance  adl formulations  set ground actions could generated
largest instances  data shown largest instances could handled  data
parentheses collected ffs reachability pre process  see text  
affected individual airplane  parameters fixed  formulas conditional
effects simplified usual strips constructs  airport domain version contains
original adl formulation  well compilation strips  result grounding
process depends specific airport considered instance  set airplanes
travelling  so  strips formulations  instance individual domain file
 the applies strips compilations domains described later  
domain versions  well blow up incurred compilation  overviewed
table      numbers shown table indicate numbers pddl operators  numbers
grounded actions  domain version formulation  maximum number
instance shown  note that  adl formulations except temporal timewindows compiled 
single domain file number operators identical instances 
strips formulations  number operators high because  explained  operator
parameters grounded  difference number ground actions strips
adl formulations because  automated software  able generate
ground actions larger adl instances  data shown largest instances
could handle  numbers shown parentheses refer situation ffs reachability
pre process  said before  builds relaxed planning graph initial state  removes
actions appear graph  difference numbers inside outside
parentheses indicates much simple pre process helps  see helps quite lot
here  pruning almost half actions  which would never become applicable  forward search
least  blow representation regardless algorithm used  
    instantiation process is  course  planner dependent  similarly section    data based
ffs pre processor  extended pre processor  precisely  one metric ff  hoffmann         deal
temporal constructs 

   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

a     ipc   e xample nstances
airport example instances generated sebastian trug  implementation based
aforementioned airport simulation tool astras  five scaling airport topologies designed 
used basis instance generation  airports named minimal  mintoy 
toy  half muc  muc  smallest airports smallest possible airport
astras handle  two largest airports correspond one half munich airport  muc  
full muc airport  figure    shows sketches minimal airport  muc
airport 

 a 

 b 
figure     smallest  a   largest  b  ipc   airport topologies  park position
segments marked black  e g   top part  a    segments airplanes
takeoff marked white  e g   left bottom side part  a    lines
show road network airport  topology  b  corresponds muc airport 
sebastian trug implemented pddl instance generation software inside astras  simulation traffic flow airport  desired user software exports current traffic
situation various pddl encodings explained above  simulator run different
airports     scaling traffic situations exported    minimal    mintoy    
toy     half muc     muc   airport  instances scale terms
number travelling airplanes  largest instance features    planes moved destinations munich airport     planes landing future considered  in respective
domain versions   considered realistically sized traffic situation  airport 

   

fie ngineering b enchmarks



p lanning

a     f uture w ork
remains explore relax simplifications make  importantly 
overcome discrete model space  locatedness   model real optimization
criterion  difficulties are  partly described already  mostly due discrete
nature pddl     allow continuous choice instantiation action 
continuous choice would natural way saying far plane moving
long waiting  best way go direction is  probably  assume
duration inequalities proposed fox long         together numeric variables
already contained pddl     easy modelling side  main problem
probably technology side  i e   develop planners deal efficiently
continuous choice points  time ipc    said  continuous choice appeared much
demand planners 
one interesting topic future work arises one restricts airplanes completely standard
routes  i e   leaves choice route take destination  said  first 
usually done real airports  sheer complexity managing situation otherwise 
without significant computer support  which yet available real airports   second  ipc  made limited use feature  retain flexibility could offered
automatized methods  third  restriction turns pspace complete ground traffic control
problem pure  np complete  hatzack   nebel         scheduling problem 
question planes move across segment  one could exploit create much
concise pddl encoding  restricted problem comes resolving conflicts
arise two planes need cross airport segment  one could thus try encode
pddl physical airport  conflicts possible solutions  ideally connection
real optimization criterion  expected planners much efficient
simpler concisely encoded problem 
a   pipesworld
frederico liporace working application area several years  submitted paper
early domain version workshop competition icaps    domain
adapted ipc   frederico liporace jorg hoffmann 
a     pplication omain
pipelines play important role transportation petroleum derivatives  since
effective way transport large volumes large distances  application domain
consider deals complex problems arise transporting oil derivative products
multi commodity pipeline system  note that  many planning benchmarks
dealing variants transportation problems  transporting oil derivatives pipeline
system different characteristic kind structure  since uses stationary carriers
whose cargo moves rather usual moving carriers stationary cargo  particular 
changing position one object directly results changing position several objects 
less reminiscent transportation domains complicated single player games
rubics cube  lead several subtle phenomena  example  may happen solution
must reverse flow liquid pipeline segment several times  may happen

   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

liquid must pumped ring pipeline segments cyclic fashion  achieve goal
 we see example later  
detail  application domain following  pipeline network graph operational areas connected pipeline segments  operational areas may harbors  distribution centers
refineries  may connected one pipeline segments  oil derivatives
moved areas pipelines 
different types petroleum derivative products  area set tanks
define storage capacity product type  pipeline segment fixed volume
speed  volume depends segments length cross section diameter  speed
depends power pumps move contents  segment may uni directional  i e 
usable transportation one direction 
pipeline segments always pressurized  is  must always completely filled
petroleum derivative products  that  way move pipeline segments contents
pumping amount product adjacent area segment  operation
results  assuming incompressible fluids  amount possibly different product
received area end segment 
pumping operations executed violate interface tanking
constraints  former  distinct products direct contact inside pipeline segment 
unavoidable loss due mixture interface them 
interface losses major concern pipeline operation  mixed products
simply discarded  must pass special treatment may involve sending back
refinery  may require use special tanks  severity interface losses depends
products interface inside pipeline segment  two product types known generate
high interface losses  pipeline plan must place adjacently segment  pair
product types said interface restriction 
tanking constraints limits product amounts stored area  arising
respective tank capacities  constraints may effectively block pipeline segment 
room receiving area store product would leave segment process
pumping operation 
task application bring certain amounts products areas
required  i e  one find plan pumping operations shifts positions product
amounts way goal specifications met  sometimes deadline specifying
when  latest  product amount arrive destination area  may case
area  typically  refinery  known produce given amount product given point
time  plan must make sure enough tank space available respective
area store new product amount  similarly  area  typically  harbor distribution center 
may known consume given amount product given point time  thereby freeing
respective amount tank space 
a     ipc   pddl daptation
main adaptations made pddl encoding unitary batches  split pumping operations 
personalized goals  see latter   term batch used oil pipeline
industry refer amount product must transported pipeline  batches
thus associated single product predefined volume  batches indivisible 

   

fie ngineering b enchmarks



p lanning

batch bi pumped area aj segment sj k   possible another batch
pumped aj sj k bi volume pumped  course  reality product
amount batch rational number  using numeric encoding ipc   seemed completely
infeasible due complications modeling  expected capabilities participating
planners  see section a       instead  based encoding concept called
unitary batches  smallest considered indivisible portions product  pumping
operations refer unitary batches  pipeline segments volumes volumes tanks
defined terms unitary batches  encoding real world instance domain 
actual volume associated unitary batch choice variable  smaller unitary batches decrease
rounding error pddl encoding  cost larger encoding size  note that 
smallest units space airport domain  discretization need due
non continuous nature actions pddl     get back section a     
modeled pipe segments directional fashion  i e  default direction assigning
one area role  area role  pumping operations accordingly
distinguish push actions  move liquid respective segments default direction 
pop actions  move liquid opposite direction  simply technical device
enable encoding pipe segment contents predicates defining first last
batches segments  as well successor relation   push pop actions receive
 amongst things  arguments pipeline segment whose contents moved 
batch inserted segment  batch leaves segment depends
segment content action executed  figure    shows example 



a 




























b 



a 




















































b 




b 












































b 

















































































































b 

a 







































b 



































b 

a 


















b 

























b 























































































































b 





b 












b 



 b 

 a 
a 

 

 

 

 

 

 

 

 

 

 

 

 

 

 
 

 
 

b 
 

 

 
 

 
 

 
 

 
 

 
 

 

 
 

 
 

 

 
 

 
 

 
 

b 

 
 

a 
























b 




 

 


 

 


 

 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

b 
 
 

 
 

 
 

 
 

 
 

 

 
 
 

 
 

 

 
 














































b 

 

 

 

 

 

 

 

 

 




 
 

 

b 

p 

 























































 
 

p 
p 

 c 

figure     small example  a  plays role  fill pattern batch represents
product   a  shows initial state   b  shows state  a  push operation
b  inserted segment   c  shows state  b  pop operation b 
inserted segment 
apart pipe segment batch inserted  push pop actions
take several parameters regarding  e g   product types tank slots  particular  order
able update segment contents correctly  actions need parameters giving
respective first  last  second last batch current contents segment  thus
action four parameters ranging batches  yielding least n  ground instances action
n  unitary  batches considered task  found made domain
   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

completely infeasible planning system grounded actions  since many unitary
batches needed encode even relatively small pipesworld examples  planners typically
died pre processing phase already    avoided phenomenon splitting actions
two parts  start action taking batch parameters inserted batch first batch
pipe  end action taking batch parameters last second last batches
pipe  make concrete  split push action 
  action push start
 parameters
  pipe   pipe  batch atom in   batch atom  from area   area  to area   area
 first batch atom   batch atom  product batch atom in   product
 product first batch   product 
 precondition
 and  normal  pipe   first  first batch atom  pipe   connect  from area  to area  pipe 
 on  batch atom in  from area   not unitary  pipe 
 is product  batch atom in  product batch atom in 
 is product  first batch atom  product first batch 
 may interface  product batch atom in  product first batch  
 effect
 and  push updating  pipe   not  normal  pipe    first  batch atom in  pipe 
 not  first  first batch atom  pipe    follow  first batch atom  batch atom in 
 not  on  batch atom in  from area    
  action push end
 parameters
  pipe   pipe  from area   area  to area   area  last batch atom   batch atom
 next last batch atom   batch atom 
 precondition
 and  push updating  pipe   last  last batch atom  pipe   connect  from area  to area  pipe 
 not unitary  pipe   follow  last batch atom  next last batch atom  
 effect
 and  not  push updating  pipe    normal  pipe 
 not  follow  last batch atom  next last batch atom  
 last  next last batch atom  pipe   not  last  last batch atom  pipe  
 on  last batch atom  to area   

constructs largely self explanatory  static predicates used are  connect 
encoding topology network  is product  encoding types liquid  may interface 
encoding interface restrictions    not unitary  saying whether pipe segment contains
one batch case push pop actions much simpler need
split  the first last elements pipe identical   predicates normal pushupdating ensure  obvious way  two parts split action used
intended  finally  on  first  follow  last encode relevant batches are 
role clear  encodes locatedness areas  pipe contents 
modelled queue like fashion  head first  tail last  successor function follow 
two parts push action update representation accordingly 
    matters may easier planning systems ground actions pre process  didnt affect
design decision since large majority systems around time ipc   employ pre process 
    note model interface loss products may interface 

   

fie ngineering b enchmarks



p lanning

encode uni directional pipe segments  i e  segments push pop
actions available ipc   encodings  modeled tankage restrictions simple constructs involving tank slots located areas  slot capacity store one unitary batch
given product type is  push pop actions specify tank slot
inserted outgoing batch comes from is inserted into  simple examples regarding interface
tankage restrictions  re consider figure     storage capacity p  a  equal zero 
transition state  a  state  b  becomes invalid  forbid interface p 
p    transition state  b  state  c  becomes invalid 
pipe segment speed easily taken account  in durational pddl   speed
segment s  simply assign push pop actions regarding segment duration proportional  s    in ipc   encoding  start end action takes exactly time 
non split actions regarding length   segments take time  s   
reality  outlined goals refer amounts product requested certain
destination areas  encoding based batches  formulating goal would mean introduce potentially large disjunction conjunctive goals  one wants say  e g   three unitary batches product p requested area a  needed goal condition disjunction
w
 b   b   b   b  atb  a   atb  a   atb  a  respective conjunctive goal three subsets
 b    b    b    batches b type p   avoid exponential blow ups kind  encoding
used personalized goals instead  referring specific batches instead product amounts  basically  comes pre selecting one  b    b    b    subsets disjunction   
one could avoid blow up replacing disjunction existential quantification 
step would undone compilation strips anyway 
deadlines arrival batches are  durational pddl  easily modeled compilation
timed initial literals  goal deadline literal saying respective batch
still ejected end pipe segment  literal initially true  becomes false
time deadline  described above  application pre specified time
points area produces consumes given amount product  model
ipc   domain  see section a      
mentioned above  structure pipesworld domain lead several subtle phenomena possible plans  example plans perform cyclic sequence pumping
operations depicted figure     goal place b  a   shortest plan following  for readability  action parameters batches going pipes
shown      push s    b  b      pop s    b  b      pop s    b  b      push s    b  b     
push s    b  b      pop s    b  b      push s    b  b      push s    b  b   observe
plan contains two cyclic patterns  action   inserts b  s    actions         form
cycle  s      s      s      brings b  a   thereafter  action   inserts b  s    actions
        form another cycle  s      s      s      bringing b  goal position a    
    note bad choice  b    b    b    make task harder solve  are  however  currently investigating computational complexity different variants pipesworld  preliminary results suggest
allowing disallowing personalized goals affect complexity 
    note need cyclic patterns oddity introduced encoding  something may  but
probably likely to  happen reality  example  becomes necessary isnt enough liquid
origin area  here  a  a   push needed amount liquid  here  b   destination 

   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

a 
s   
b 
a 

b 
s    b 

b 

s   
b 
b 

b 
s   
a 

b 

a 

s   

figure     example cycling required achieve goal  place b  a    pipe segment
si  j directed ai aj 
version
notankage nontemporal
notankage temporal
notankage temporal d
notankage temporal dc
tankage nontemporal
tankage temporal

formulation
strips
strips
strips
strips
strips
strips

max  op
 
 
 
 
 
 

max  act
             
             
           
           
               
               

table    overview different domain versions pipesworld  abbreviations used 
temporal d temporal deadlines  temporal dc deadlines compiled  max  op
maximum number  parameterized  pddl operators instance  max  act
maximum number ground actions instance  data parentheses collected ffs reachability pre process  see text  

a     ipc   omain tructure
pipesworld domain versions used ipc   notankage nontemporal  tankage nontemporal 
notankage temporal  tankage temporal  notankage temporal deadlines  notankage temporaldeadlines compiled  versions include interface restrictions  versions tankage
name include tankage restrictions  versions temporal name  actions take
different amounts time depending pipeline segment moved  explained
above  versions deadlines name include deadlines arrival goal
batches  one versions models deadlines using timed initial literals  version
 naturally  compiled name  literals compiled artificial  temporal  pddl
constructs  none encodings uses adl constructs  version one
 strips  formulation 
domain versions numbers ground actions overviewed table    before 
data measured using  a temporal extension of  ffs pre processor  numbers shown

   

fie ngineering b enchmarks



p lanning

parentheses refer situation pre processors reachability pre process 
builds relaxed planning graph initial state removes actions appear
graph  observe numbers ground actions low domain versions
deadlines  extremely high versions tankage restrictions  former simply
because  due complicated generation process  explained next sub section   examples
deadlines generated smaller size  latter high numbers actions
presence tankage restriction due additional blow up incurred choice tank
slots draw in put batches  note effect reachability
pruning relatively moderate  particular much lower than  e g   airport  c f  section a     
a     ipc   e xample nstances
pipesworld example instances generated frederico liporace  process going
random generators xml files pddl files    five scaling network topologies designed
used basis instance generation  figure    shows network topologies  well
real world network topology comparison  one see  largest network topology
used ipc   quite yet ballpark real network  neither trivially
small comparison  volumes pipeline segments connect areas realworld example necessarily segments may different cross section
diameters 
domain versions without tankage restrictions deadlines  network
topologies    scaling random instances generated  within network  instances scaled
terms total number batches number batches goal location 
instances featuring tankage restrictions deadlines  generation process complicated
wanted make sure obtain solvable instances  tankage restriction examples  ran mips  edelkamp      b  respective notankage instances  incrementally
growing tankage    chose instance random point first instance solved
mips  maximum needed tankage  enough tankage area accommodate instance
batches   instances could solved mips even given several days runtime 
inserted maximum tankage  deadline examples  ran mips
corresponding instances without deadlines  arranged deadline goal batch random point interval arrival time batch mipss plan  end time
mipss plan  instances solved mips left out 
a     c urrent



f uture w ork

ongoing work developing pipesworld specific solver  named plumber  milidiu   dos
santos liporace      a  milidiu   dos santos liporace      b   plumber incorporates pipeline
simulator  domain specific heuristics  procedures reducing branching factor symmetry
elimination  lets user choose different search strategies  enforced hill
climbing  hoffmann   nebel        learning real time a  korf         currently
extended support temporal planning well 
    xml file mapped different pddl files depending kind encoding used  lot
trial error came final ipc   encoding 
    mips convenient choice since one planners  deal temporal constructs 

   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

a 

a 

s 
  

 

 

  
s 

s 
  

  
s 

 

a 
a 

network  

 

a 

network  

a 

 

 

  
s 

s 
  

a 

s   
a 

a 

a 
network  

 

  

   

a 

 

   

 

s   

  

s   
a 

a 

  

   

ba 

  

 

s 

ut  

rc 

  

 

 

  
  

  

s 

tb  

 

s   
a 

  

network  
ba 

 

sz  

  

a 

a 

a 

rd 

   

  

gu 

  

s   
a 

   

  

network  

 

rv 

  

a 

 

s   

  

ga 

  
s 

s 
  

rp 

 

  
  
 

 a 

  

  

 
 

sb 

 

rb 

 

 b 

figure     ipc   pipesworld network topologies  a   real network topology  b  
segment volumes latter annotated    m  units 

availability solver enable extension pipesworld benchmark  since
easier overcome aforementioned difficulties generating large feasible instances 
hope able generate feasible instances real world pipeline topologies  one shown
figure    
addition generating larger instances  pipesworld benchmark may extended many
ways make closer real application scenario  relevant possible extensions include 
defining pipeline segments single flow direction  is  segments
push pop actions allowed  note introduces dead ends critical choices
problem 
un personalized goals  could accomplished  e g   imposing desired tank volume goal products respective areas  planner decide
batches used bring tank volume desired level 
modeling production consumption products pre specified points time  described above 

   

fie ngineering b enchmarks



p lanning

using rational numbers model tank capacities current volumes  instead encoding
based unitary tank slots  apart precise model real world  when
combined rational valued batch sizes  see below   encoding would avoid unnecessary symmetries currently arise availability several non distinguishable
tank slots  in area  product  
important shortcoming encoding use unitary batches  would much
appropriate base encoding product amounts given real numbers  one problematic
aspect encoding would  naturally  demand continuous choice
much liquid pump pipeline  airport  c f  section a       choice could
naturally modelled using fox longs        duration inequalities  unclear
develop planners deal reasonably well  unlike airport  implementing
choice end difficulties modelling side  model continuous
contents pipeline  number distinct regions liquid pipeline grow arbitrarily
high  principle  one solution might fix upper bound  simply disallow pumping
operation would result many distinct regions  may bearable loss precision 
given upper bound high enough  even then  bound awkward correctly update
contents pipeline amount x product pushed in  number different
products leaving pipe depends x  option may use complicated construct
conditional effects 
all  impression pipeline scheduling wont realistically modelled pddl 
successfully solved planners  unless one introduces language data structure
suitable modelling contents pipes  basically  would queues whose elements
annotated real numbers  whose basic operations usual push pop 
semantics pipes could explicitly computed inside planner  rather awkwardly
modelled using language constructs likely disturb general search mechanism 
a   promela
domain created ipc   stefan edelkamp 
a     pplication omain
dropping promela domain  briefly recall origin 
model checker spin  holzmann        targets efficient software verification 
used trace logical design errors distributed systems design  operating systems  data
communications protocols  switching systems  concurrent algorithms  railway signaling protocols 
etc  tool checks logical consistency specification  spin reports deadlocks  unspecified receptions identifies race conditions  unwarranted assumptions relative speeds
processes  spin  starting version    provides support use embedded c code
part model specifications  makes possible directly verify implementation level software
specifications  using spin driver logic engine verify high level temporal properties  spin works on the fly  means avoids need construct global state graph
prerequisite verification system properties  spin supports property checking linear temporal logic  ltl   ltl expresses state trajectory constraints  using temporal modalities

   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

eventually  always  until     spin uses specific mechanisms specifying deadlock freeness
safety properties  addition general ltl specifications  explore state space
ordinary nested search algorithm applied  depending whether state based  a k a 
safety  property verified 
promela spins input specification language  computational model asynchronous
communicating finite state machines  promela allows define classes finite processes  special
process called init started first usually governs instantiation processes
system  possible process invoke another one  promela allows modeling systems
dynamic creation state components  communication promela achieved via shared variables
message channels  two kind message channels distinguished synchronous asynchronous communication  asynchronous channel basically fifo queue  synchronous
channels imply rendezvous communication transition system involves two processes  one reading message channel another sending message it  here 
consider asynchronous communication  body process class basically sequence
statements  statement interpreted transition process  typical statements include assignments  numerical boolean expressions channel operations  promela allows
define atomic regions  whose sequence transitions treated atomic
action  interpreted weighted transitions whose costs number steps within
regions   
ipc    used two example communication protocols formulated promela  dijkstras
dining philosophers problem  so called optical telegraph protocol  briefly describe
latter protocol section a      illustrate promela language  let us consider dining
philosophers problem  n philosophers sit around table lunch  n plates 
one philosopher  n forks located left right plate  since two
forks required eat spaghetti plates  philosopher eat time  moreover 
communication except taking releasing forks allowed  task devise local
strategy philosopher lets philosophers eventually eat  simplest solution
access left fork followed right one  obvious problem  philosophers wait
second fork released possible progress  deadlock occurred 
difficult probably insightful derive bottom up pddl encoding dining
philosophers domain  using actions eat  wait think  motivation  however  come
top down encoding  starting promela specification  automatically translating
pddl 
deadlock model dining philosophers specified promela shown figure    
first lines define macros declare array n boolean variables represent
availability forks  following lines define behavior process type philosopher 
process iterates indefinitely endless loop  do  one unique entry marked symbol
    statements separated semicolon  first transition left fork consists send
operation tag fork channel left  macro address forks current
process id pid  represents availability left fork philosopher  access transition left fork executed reading tag fork channel left successful 
    note fragments ltl likely included pddl language next international planning
competition  gerevini   long       
    documentation promela specification language found web site spin
http   netlib bell labs com netlib spin whatispin html

   

fie ngineering b enchmarks



p lanning

 define max philosophers n
mtype fork
 define left forks  pid 
 define right forks   pid      max philosophers 
chan forks max philosophers        bit 
active  max philosophers  proctype philosopher  
 
left fork 

  left fork       try get left fork   
right fork     try get right fork   
   eat      
left fork  right fork    release forks   
   meditation      
od
 
figure     promela specification model dining philosophers problem 
next transition right fork similar first  last two ones sends tag fork back
channels left right 
a     ipc   pddl daptation
model checking action planning closely related  c f  section    model checker
searches counterexample form sequence transitions falsify given specification  planner searches sequence actions satisfies given goal  cases 
basic models  strips planning  kripke structures   refer implicit graphs  nodes
annotated atomic propositions 
automatically generating pddl model promela syntax wrote compiler  edelkamp      a   restricted safety properties  especially deadlocks  assertions
global invariances difficult obtain  concentrated models fixed number processes  since models communication protocols adhere restriction   
compiler parse promela code itself  takes input intermediate
representation problem generated spin validation tool     figure    shows
textual automata representation philosopher process  case  value n
initialized    philosophers  file contains almost necessary information
    dynamic creation processes pddl would require language extension dynamic object creation 
extension dismissed since would involve heavy changes existing planner technology  relevance
 beyond promela  unclear 
    precisely  promela input file taken  corresponding c file generated  verifier compiled
executable run option  d 

   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

translation  number processes queues  i e   message channels  well queue capacities read original promela input file    
proctype philosopher
state     trans      state   line       forks  pid  fork
state     trans      state   line       forks  pid  fork
state     trans      state   line       forks    pid         fork
state     trans      state   line       forks  pid  fork
state     tras      state   line       forks    pid         fork
figure     automata representation model    dining philosophers problem 
derive suitable pddl encoding domain  process represented finite state
automata  hence  propositional encoding simulates automaton  propositional atoms
true initial state one process running example problem shown figure     a     

 is a process philosopher   philosopher 
 at process philosopher   state   
 trans philosopher trans   state   state   
 trans philosopher trans   state   state   
 trans philosopher trans   state   state   
 trans philosopher trans   state   state   
 trans philosopher trans   state   state   

 is a queue forks   queue   
 queue head forks   qs   
 queue tail forks   qs   
 queue next queue   qs   qs   
 queue head msg forks   empty 
 queue size forks   zero 
 settled forks   

 a 

 b 

 writes philosopher   forks   trans     trans msg trans   fork 
 reads philosopher   forks   trans     trans msg trans   fork 
 reads philosopher   forks   trans     trans msg trans   fork 
 writes philosopher   forks   trans     trans msg trans   fork 
 c 
figure     propositional encoding one philosophers process  a   propositional encoding
 single cell  communication channel  b   connecting communication local state transitions  c  
encoding communication structure represents channels graphs  pddl encoding additionally exploits cyclic embedding queue array  formally   fifo 
channel q represented structure gq    sq   headq   tailq   q   messq  contq    sq
set queue cells  headq   tailq sq head tail cells q  messq m sq  
    avoid conflicts pre compiler directives  first invoked c compiler command line option  e 
executes pre compiler 
    use transition ids  competition less accessible textual representation label chosen 

   

fie ngineering b enchmarks



p lanning

vector messages q  m set messages   contq ir sq   vector
variable values q q   sq sq successor relation q  sq   s             s k 
 s i     s  i      mod k   explicitly modeling head tail positions queue trades
space time  since queue updates reduce constant time 
queue either empty  or full  pointers refer queue state  special case 
simple queues  as example  may consist one queue state  successor bucket
queue state   queue state   itself  case grounded propositional encoding includes
operators add delete lists share atom  make standard assumption
deletion done first  propositional atoms one queue adaption two queues
one process exemplified figure     b   c  
queue content  shared local variables modeled pddl fluents  difference
local variables compared shared ones restricted visibility scope  local variables
prefixed process appear in  two benchmark protocols selected ipc   rely
pure message passing  numerical state variables involved  allowed us
supply propositional model problems 
  action activate trans
 parameters   p   process  pt   proctype  t   transition  s   s    state 
 precondition  and  forall   q   queue   settled  q    trans  pt  t  s   s  
 is a process  p  pt   at process  p  s    pending  p  
 effect  and  activate  p  t   not  pending  p     
figure     testing transition enabled activating it 
pddl domain encoding uses seven operators  named activate trans  queue read 
queue write  advance queue head  advance empty queue tail  advance non empty queue tail 
process trans  activation process shown figure     see pending process
activated  queues settled transition matches current process state 
briefly  operators encode protocol semantics follows  operator activate trans activates
transition process given type local state s  s    operator sets predicate
activate  boolean flag precondition queue read queue write actions  set
propositions initialize reading writing message  queue q activated transition
querying message m  corresponds promela expression q m  respectively q m 
read write operation initialized  queue update operators must applied  i e  advancequeue head  advance empty queue tail  advance non empty queue tail appropriate 
names indicate  operators respectively update head tail positions  needed
implement requested read write operation  operators set settled flag 
precondition every queue access action  action process trans applied  executes
transition local state s  s    i e  sets new local process state re sets flags 
stored message match query  queue capacity either small
large  active local state transition block  active transitions process block 
process block  processes blocked  deadlock system  detection
deadlocks implemented  different domain versions  either collection specifically
engineered actions or  elegantly  set derived predicates  cases one infer 
along lines argumentation outlined above  process the entire system blocked 
   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

  derived  blocked trans  p   process  t   transition 
 exists   q   queue 
 exists   m   message 
 exists   n   number 
 and  activate  p  t   reads  p  q  t   settled  q 
 trans msg  t  m   queue size  q  n   is zero  n      
  derived  blocked  p   process 
 exists   s   state 
 exists   pt   proctype 
 and  at process  p  s   is a process  p  pt 
 forall   t   transition 
 or  blocked trans  p  t   forall   s    state   not  trans  pt  t  s  s          

figure     derivation deadlock 
goal condition makes planners detect deadlocks protocols simply conjunction
atoms requiring processes blocked  example derivation rules derived
predicates  pddl description derivation deadlock based blocked read accesses
shown figure    
a     ipc   omain tructure
two benchmark protocols ipc    created three different domain versions 
derivedpredicates  contains derived predicates infer deadlocks  plain  purely propositional specification specific actions applied establish deadlock  the later
actions basically gazen knoblock        compilation derived predicates  c f  section     fluents alternative latter numerical state variables encodes size
queues messages used access contents  made version called fluentsderivedpredicates  obvious combination  none ipc   competitors participated there 
omit herein  within domain version  one formulation includes adl
constructs quantification  disjunctive preconditions  negated preconditions  domain
versions without fluents  another formulation pure strips  obtained respective adl
encodings using adl strips compiler  which handle numeric variables   unfortunately 
larger problem instances lead strips files big stored disk
 remember adl strips grounds operator parameters   too large instances were 
course  left respective test suites 
kept fluent domains separated domain versions  rather domain version formulations 
order able compare propositional numerical exploration efficiencies  emphasize
fluent variables essential real world model checking treated separately 
domain versions numbers operators ground actions overviewed table   
consider rows table top bottom  before  times parentheses values
ffs reachability pre process  builds relaxed planning graph initial state
removes actions appear graph  strips formulation fully grounded
using adl strips program  derived ffs pre processor  c f  section    

   

fie ngineering b enchmarks

version
optical telegraph
optical telegraph
optical telegraph dp
optical telegraph dp
optical telegraph fluents
philosophers
philosophers
philosophers dp
philosophers dp
philosophers fluents

formulation
strips
adl
strips dp
adl dp
adl
strips
adl
strips dp
adl dp
adl



p lanning

max  op
    
  
    
  
  
   
  
    
  
  

max  act
           
           
           
           
           
         
         
           
           
         

table    overview different domain versions promela  abbreviations used  dp derived predicates  max  op maximum number  parameterized  pddl operators
instance  max  act maximum number ground actions instance 
data parentheses collected ffs reachability pre process  see text   derivation rules  ground derivation rules  counted operators  ground actions  

reason number operators number ground actions  ffs preprocess identical one run adl strips effect  adl formulation  see
reachability pruning reduces number actions factor almost    similar airport
domain  c f  section a       picture next two domain versions  derived predicates 
similar  fact  since  consistently data section    count derivation rules
actions  data identical  reason identical table   that  using derived
predicates instead operators  ffs pre processor scales larger instances  presumably  due
unimportant implementation detail   next domain version  formulated numeric
variables  ffs pre processor scales even worse  however  even instances number
telegraphs  less ground actions before  due different encoding 
observations made dining philosophers exactly same  different numbers 
notable difference effect ffs reachability pruning weaker  yielding
slight decrease number actions versions without fluents  decrease
version fluents  apparently  complex process structure optical telegraph leads
useless action instances 
a     ipc   e xample nstances
said  selected two simple communication protocols benchmarks ipc    encoding dining philosopher problem described above  so called optical telegraph
protocol  holzmann        
optical telegraph protocol involves n pairs communicating processes  pair featuring process  pair go fairly long  heavily interactive 
sequence operations  implementing possible data exchange two stations 
data exchanged  various initializing steps must taken ensure processes working
synchronously  importantly  process writes token control channel  queue 
   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

beginning sequence  reads token end  causes deadlock
situation n control channels  accessed two processes 
every pair up down processes occupied one control channel  overall system
blocked 
dining philosopher optical telegraph benchmark  instances scale via
single parameter  number philosophers number control stations  respectively 
scaled parameter      competition instances  promela models benchmarks distributed together experimental model checking tool hsf spin  edelkamp 
leue    lluch lafuente         extends spin heuristic search strategies improve error
detection 
a     f uture w ork
general terms  see promela planning benchmark another important step towards exploiting synergies research areas planning model checking  giunchiglia   traverso 
       example  complement recent progress planning  explicit directed model checking
domain protocol validation  edelkamp et al         symbolic directed model checking
domain hardware validation  reffel   edelkamp        led drastic improvements
state of the art model checkers  work  e g    yang   dill        bloem  ravi 
  somenzi         show model checking growing interest guided exploration 
mostly find errors faster blind state space enumeration algorithms  compilation
promela domain model  alternative option applying heuristic search model checking
problems available  work needed understand planning heuristics work fail
model checking benchmarks 
strongly believe communities profit wide spread availability techniques represent model checking problems pddl  allows direct comparison exploration efficiencies  based design promela domain  suitable pddl domain encodings
two expressive model checking input languages  graph transformation systems  edelkamp 
jabbar    lluch lafuente        petri nets  edelkamp   jabbar         proposed 
encodings exploit expressive power pddl well efficiency current planners 
result  state of the art planners often faster compared model checkers benchmarks 
a   psr
sylvie thiebaux others worked application domain  domain adapted
ipc   sylvie thiebaux jorg hoffmann 
a     pplication omain
power supply restoration  psr  domain consider derived application investigated sylvie thiebaux others  thiebaux et al         thiebaux   cordier         psr
deals reconfiguring faulty power distribution system resupply customers affected
faults  topic ongoing interest field power distribution 
detail  power distribution system  see figure      viewed network electric lines connected switches fed via number power sources equipped
circuit breakers  switches circuit breakers two possible positions  open closed 
   

fie ngineering b enchmarks



p lanning

figure     sample power distribution system  sources circuit breakers  e g   cb   represented
large squares  switches  e g   sd   small squares  open switches  e g   sd  
white  area fed cb  boxed  gray dark used distinguish adjacent
areas fed different sources

connected two lines  restriction connectivity lines  extremities
connected earth  circuit breaker power source closed 
power flows source lines downstream  flow stopped open switch 
switches used appropriately configure network position initially set
line fed exactly one source 
due bad weather conditions  permanent faults affect one lines network 
power source feeds faulty line  circuit breaker fitted source opens protect
rest network overloads  leaves lines fed source without power 
problem consists planning sequence switching operations  opening closing switches
circuit breakers  bringing network configuration maximum non faulty lines
resupplied  instance  suppose line l   becomes faulty  leads circuit breaker
cb  open boxed area without power  possible restoration plan would
following  open switches sd   sd   isolate faulty line  close sd   source
cb  resupply l    finally re close cb  resupply others 
original psr problem  thiebaux   cordier         maximal capacity sources
lines  well load requested customers taken account  plan must optimize
various numerical parameters breakdown costs  power margins  distance initial
configuration  subject capacity constraints  furthermore  due fault sensors switches
unreliable  location faults current network configuration partially
observable  optimizing  leads complex tradeoff acting resupply lines
acting  intrusively  reduce uncertainty 

   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

a     ipc   pddl daptation
pddl adaptation  benefited contributions piergiorgio bertoli  blai bonet  alessandro cimatti  john slaney  bertoli et al         bonet   thiebaux         compared
original psr domain described above  ipc   version underwent   major adaptations  firstly 
ipc deals fully observable domains  hence  partial observability psr crucial
issue  thiebaux et al         bertoli et al         bonet   thiebaux         ipc version assumes
complete observability  secondly  given difficulty encoding even basic problem  chose
ignore numerical optimization aspects psr  capacities  power margins           thirdly 
ipc   version set pure goal achievement problem  goal specifies set
lines must  re  supplied  considered realistic goal asking planner supply
line be  however  unable compile goal strips reasonable
space  opted simpler goal keep strips formulation consistent possible
others 
highest level natural ipc   encoding psr involves adl constructs derived
predicates  briefly  encoding works follows  psr problem instances specify     network
topology  i e   objects network connections  the lines  switching devices 
is  switches sources circuit breakers  two side constants side  side  denote
two connection points switching device  connection relations objects  
    initial configuration  i e   initial positions  open closed  switching devices     
modes  faulty not  various lines  among those  devices positions change 
number predicates derived basic ones  model propagation
current network view determining lines currently fed sources
affected fault  i e  feed fault  closed world assumption semantics pddl   
derived predicates exactly needed elegantly encode relations  require
recursive traversal network paths naturally represented transitive closure
connection relation network  complex derived predicates  upstream 
requires four parameters  two which  however take two possible values  expresses
power flows one two sides device  side  sx device  x  one
sides another  side  sy device  y  happens side  x opposite  sx
directly connected  sy  via line   exists closed device  z one side
upstream  sx side connected  sy 
  derived  upstream  x   device  sx   side  y   device  sy   side 
 and  closed  x 
 or  and     sx side    con  x side   y  sy  
 and     sx side    con  x side   y  sy  
 exists   z   device 
 and  closed  z 
 or  and  con  z side   y  sy   upstream  x  sx  z side   
 and  con  z side   y  sy   upstream  x  sx  z side         
upstream  relatively easy define predicates stating whether given line fed given
source affected 

   

fie ngineering b enchmarks



p lanning

goal problem instance asks given lines fed sources unaffected   
available actions closing opening switching device  effect simply set
device position requested  addition  action wait  models event circuitbreakers opening become affected  wait applicable affected source exists 
applicable action case  the open close actions require precondition
source affected   this  together goal  ensures wait action applied
soon source affected  effect wait action open affected circuit breakers 
concretely  wait close actions follows  note open similar close earth
treated device whose position cannot changed actions  
  action close
 parameters   x   device 
 precondition  and  not     x earth  
 not  closed  x  
 forall   b   device   not  affected  b    
 effect  closed  x  
  action wait
 parameters   
 precondition  exists   b   device   affected  b  
 effect  forall   b   device   when  affected  b   not  closed  b     
would possible encode opening affected breakers conditional effect
close action  however  would required complex derived predicates additional
device parameter conditional flavor  specifying  e g   whether circuit breaker would
affected close device 
a     ipc   omain tructure
used four domain versions psr ipc    primarily  versions differ size
problem instances encoded  instance size determined languages able
formulate domain version  tried generate instances size appropriate evaluate
current planners  i e  scaled instances push over everybody impossibly hard
current automated planners  got intuitions running version enhanced
deal derived predicates  largest instances kind size one typically encounters
real world  instance generation process said section a     
domain versions named    large     middle     middle compiled     small 
version   single formulation adl derivedpredicates  version   formulations adlderivedpredicates  simpleadl derivedpredicates  strips derivedpredicates  version  
single formulation adl  version   single formulation strips  formulation names simply give language used  version   contains largest instances  versions     contain  the
same  medium instances  version   contains smallest instances  adl derivedpredicates
    note circuit breaker affected source opens  source affected more  feed
line  then  circuit breaker closed again  source stay unaffected unless re starts feeding faulty
line 

   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

version
large
middle
middle
middle
middle compiled
small

formulation
adl dp
adl dp
simple adl dp
strips dp
adl
strips

max  op
 
 
    
    
 
    

max  act
            
           
           
           
       
           

table    overview different domain versions formulations psr  abbreviations used 
dp derived predicates  max  op maximum number  parameterized  pddl
operators instance  max  act maximum number ground actions
instance  data parentheses collected ffs reachability pre process  see
text   derivation rules  ground derivation rules  counted operators  ground actions  

formulation inspired bonet thiebaux         makes use derived predicates explained above  adl constructs derived predicate  action  goal definitions 
simpleadl derivedpredicates strips derivedpredicates formulations  adl constructs  except
conditional effects simpleadl case  compiled away  resulting fully grounded encodings significantly larger original  hand length plans remains
nearly unaffected     pure adl formulation obtained adl derivedpredicates formulation compiling derived predicates away  using method described thiebaux et al        
       significant increase domain size  compilation method lead
increase plan length exponential arity derived predicates  no compilation
method avoid blow up worst case  see thiebaux et al                indeed 
particular psr example instances  observed considerable blow plan length  felt
blow much allow useful direct comparison data generated adlderivedpredicates opposed adl  separated adl formulation domain version
  listed above 
strips domain formulation proved quite challenge     schemes considered compiling derived predicates adl constructs away led either completely
unmanageable domain descriptions completely unmanageable plans  problem feasible compilations derived predicates create new actions highly conditional effects 
compiling away impractical  therefore adopted different fully grounded encoding inspired bertoli et al          encoding generated description problem instance
tool performing reasoning power propagation  resulting tasks  effects
close actions directly specify circuit breakers open result closing switch given
network configuration  derived predicates needed  consequently strips encoding
much simpler refers positions devices lines  faults  connections  nevertheless  still able formulate comparatively small instances strips 
without prohibitive blow up encoding size 
    variation due fact existential precondition wait action causes compilation split
action many wait actions circuit breakers

   

fie ngineering b enchmarks



p lanning

domain versions  formulations  respective numbers operators ground actions  shown figure    data parentheses collected ffs reachability preprocess  building relaxed planning graph initial state removing actions
appear graph  encodings using adl derived predicates  reduces number ground actions factor around    adl  factor much smaller 
encodings  reduction obtained  simply due fact encodings obtained adl strips  uses pruning process  interesting observations
made middle versions formulations  data shown correspond largest
instance ffs pre processor could handle versions formulations  enable direct comparison  see that  formulation simple adl strips  need introduce
ground actions  see that  curiously  compilation derived predicates  compilation
middle compiled   number ground actions decreases dramatically  reason lies
data count ground derivation rules ground actions  subtleties compilation derived predicates  middle formulations  almost ground actions fact
ground derivation rules  compiled away middle compiled following thiebaux et al 
              introducing single action one distinct conditional effect derivation rule  c f  section    means complexity thousands derivation rules
replaced complexity action thousands conditional effects 
a     ipc   e xample nstances
due contractual agreements  unable use real data competition  instead  psr
instances randomly generated using randomnet  special purpose tool implemented john
slaney 
power distribution networks often mesh able structure exploited radially  path taken
power source forms tree whose nodes switches whose arcs electric
lines  terminal switches connect various trees together  randomnet takes input number
sources  percentage faulty lines  range parameters controlling tree depth  branching 
tree adjacency  whose default values representative real networks  randomnet randomly
generates network topology set faulty lines  turned various pddl
encodings tool called net pddl  implemented piergiorgio bertoli sylvie thiebaux 
net pddl computes set lines supplied  makes goal 
instances generated make use randomnet default settings  two exceptions
create problems increasing difficulty  first maximal depth trees takes range
values twice default  larger value  harder problem  second
percentage faulty lines ranges          problems middle range harder
average  bottom range realistic 
instance suite contains    instances  small instances feature     sources 
middle instances feature    sources  large instances feature     sources 
large instances size typical real world instances  even larger  example
figure    representative difficult instance middle set 
a     f uture w ork
psr around time benchmark planning uncertainty  expect
work done framework ipc   facilitate acceptance one standard

   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

benchmarks planning  end  developed psr resource web page giving access
relevant papers  data  tools  net pddl  randomnet             one aspect future work
complete maintain website  making available number already existing tools 
sydre  thiebaux et al          domain specific system full psr problem  matt grays
net jpeg graphically displays networks generated randomnet 
considering future ipcs  potential extending pddl encoding take numerical optimization aspects benchmark account  pddl like encodings partially
observable version benchmark exist  bonet   thiebaux        ready used
future edition probabilistic part ipc   
a   satellite
satellite domain introduced ipc   long fox         motivated nasa
space application  number satellites take images number spatial phenomena 
obeying constraints data storage space fuel usage  ipc      versions
domain  corresponding different levels language pddl     strips  numeric  simpletime
 action durations constants   time  action durations expressions static variables  
complex  durations numerics  i e  union numeric time  
adaptation satellite domain ipc   done jorg hoffmann  ipc   domain
versions example instances re used  except simpletime ipc   domains 
didnt want introduce extra version distinction difference constant
durations static durations  top ipc   versions    new domain versions added 
idea make domain realistic additionally introducing time windows
sending image data earth  i e  antennas visible satellites certain
periods time according derek long  lack time windows main shortcoming
ipc   domain   
extended ipc   time domain version two ipc   domain versions  time timewindows
time timewindows compiled  extended ipc   complex domain version two ipc  
domain versions complex timewindows complex timewindows compiled  cases  introduced new action sending data antenna  antenna receive data
single satellite time  antenna visible subsets satellites certain time
periods  sending image takes time proportional size image  time
windows modelled using timed initial literals   compiled domain versions 
literals compiled artificial pddl constructs  none domain versions uses adl
constructs  versions single  strips  formulation 
instances generated follows  objectives clearly demonstrate effect
additional time windows  produce solvable instances only  accomplish former 
re used ipc   instances  difference between  e g   time time timewindows 
lies additional time window constructs  ensure solvability  implemented tool read
plans produced one ipc   participants  namely tlplan  arranged time
windows input plan suitable solve enriched instance  important note
    page available http   rsise anu edu au thiebaux benchmarks pds
    probabilistic part ipc   feature partially observable domains 
    learned meantime lack time windows gathering data also  even more 
essential  often  due occlusion objects due rotation earth  targets visible
restricted periods time  probably constitutes one important future directions domain 

   

fie ngineering b enchmarks



p lanning

time windows arranged exactly meet times extracted ipc  
plan  rather  introduced one time window per   take image actions  made antenna
visible time window respective   satellites  let image size
individual image random value within certain range time window   times
long sending time resulting maximum possible size 
course  generation process arranged rather arbitrarily  resulting instances
might long way away typical characteristics satellite problem occurs
real world  isnt nice  best could without inside knowledge
application domain  advantage enriched instances solvable  directly
comparable ipc   ones 
new domain versions derived complex  introduced utilities time
window inside image sent earth  image  utility either
windows  decreases monotonically start time window  random within
certain interval  image put randomly one classes  optimization
requirement minimize linear combination makespan  fuel usage  summed negated
image utility 
a   settlers
settlers domain introduced ipc   long fox         makes extensive use
numeric variables  variables carry domain semantics  building
infrastructure unsettled area  involving building housing  railway tracks  sawmills 
etc  domain included ipc   order pose challenge numeric planners
domains mostly make much use numeric variables  computing
 static  durations actions    used exact domain file example instances
ipc    except removed universally quantified preconditions improve accessibility
planners  quantifiers ranged domain constants could easily replaced
conjunctions atoms 
a   umts
roman englert working application area several years  domain adapted
ipc   stefan edelkamp roman englert 
a     pplication omain
probably best known feature umts  universal mobile telecommunication standard 
higher bit rate  holma   toskala         packet switched connections reach   mega
bit per second  mbps  optimal case  compared existing mobile networks  umts provides
new important feature  namely negotiation quality service  qos  transfer
properties  attributes define characteristics transfer throughput  transfer delay  data error rate  umts bearers generic order provide good support
existing applications evolution new applications  applications services divided
    note that  extent  numeric values abstracted away pddl encoding 
mostly  in airport pipesworld  c f  sections a     a      order obtain discrete encoding suitable
pddl    style actions 

   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

class

constraints

examples

conversational
preserve time
relation
information flow
stream 
conversational
pattern  low delay 
voice  video
telephony  
video games

streaming
preserve time
relation
information
entities
stream

interactive
request response pattern 
preserve data
integrity

background
undefined
delay 
preserve
data
integrity

streaming
multimedia

web browsing 
network games

background
download
e mails

table    umts quality service classes characteristics 
four traffic classes qos  ts             holma   toskala         traffic classes 
fundamental characteristics  examples applications summarized table   
main distinguishing factor classes delay sensitive traffic is 
conversational class delay sensitive  approximately    ms time preservation   background class defined maximum delay 
umts call set up modularized using perspective intelligent software agents
 appleby   steward        busuioc         since agents logical units enable discrete
perspective continuous signaling process  call set up partitioned following
modules executed sequential order  englert        
trm initial step initiation application mobile determination
required resources execution  resources mobile display memory
checked terminal resource management  trm  allocated  possible  otherwise 
execution aborted 
ct wireless connection radio network initiated via dedicated control channel
gsm  holma   toskala         case success  transmission ready service
transferred via node b mobile order ensure connection timing  ct 
bearer service availability 
information mobile location data handling capabilities sent application server internet  cf  aeei   transmission done comfortably
so called service agent  farjami  gorg    bell        controlled agent management  am  cnd  advantage service agent is  case failure  e g  
network resources sufficiently available  agent negotiate terminals
agent another qos class different quality parameters 
aeem service agent required qos class execution application
parameters mobile application sent mobiles agent execution environment
mobile  aeem  application server internet  cf  aeei  
rrc radio resource controller  rrc  provisions allocates required qos logical resources mac level radio bearer  holma   toskala        
   

fie ngineering b enchmarks



p lanning

rab then  bearer resources supplied physical level radio access bearer
 rab  cnd call flow set up mapping logical qos parameters
physical qos resources together 
aeei agent execution environment internet  aeei  establishes data transfer
core network pdn  e g   internet  sends service agent  controlled am 
application pdn order ensure qos application 
bs finally  bearer service  bs  execution mobile application established
required radio bearer resources qos  messages sent modules trm
aeei start execution application 
modules executed sequential order set up call execution mobile
applications  two modules  aeem aeei  executed time windows order
ensure agents life network  however  two constraints added  first 
intra application constraint  modules one application ordered  second  interapplication constraint  modules names different applications cannot executed parallel order ensure required resources available 
a     ipc   pddl daptation
besides action duration  domain encodes scheduling types resources     consuming
amount action initialization time releasing amount action ending time  scheduling
types resources used planning benchmarks before  good news
temporal pddl     level    capable expressing them  fact used similar encoding
one found job  flow shop problems  one feature  actions defined
temporarily produce rather temporarily consume resources  current pddl way
stating resource constraints explicitly  planners want exploit knowledge
look certain patterns increase decrease effects recognize them  additionally  resource
modeling umts adaptation constrained important parameters  in total     
real networks several hundred parameters applied 
umts  two subsequent actions check update value resources  e g  
has mobile cpu  starting  resp  ending  time points far start  resp  ending  events
separated time steps  minimum slack time required two dependent
events  modeling renewable resources construct invariant condition
action check  start event change  decided best choice
proper temporal action  consequently  temporal actions require resources available
adding amount used 
finally  time windows two agent based modules defined using average execution times modules  average times estimated based signaling durations
umts network  holma   toskala        
resources may renewable consumable  example renewable resource keyboard mobile  used input data several applications  consumable resources
    terminology resources planning scheduling varies  job shop scheduling  machine resource 
planning machine would domain object  pddl  renewable consumable resources
modeled using numerical fluents per se distinguished 

   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

mobile cpu
d available
e balance
mobile channels
 available
num mobiles
num calls
mobile storage
logical channels
cell update
handover
active set up
ggsn bitrate
max no pdp
max no apn

used x per cent per application
partition display  e g   ticker chess
energy balance mobile accumulator
used data transfer
number mobiles tractable
node b
mobile network load node b
memory s im at card
number logical channels available cn
report ue location rnc
handover required get higher bit rate
update connection
capacity  kbit s  ggsn pdn
max  no  packet data protocols per mobile
max  access point names  apn  per mobile

table    scheduling types resources umts call set up 
released action execution  resources realized experiments summarized
table    see  gpp       complete list resources umts call set up  
pddl representation planning domain based eight modules umts
call set up  eight operators corresponding eight modules  let us consider 
example  bs action  is  final action used establish predicate bs ok 
defined follows 
  durative action bs
 parameters
  a new   application  m   mobile  l   list  ms   ms    message  a   agent 
 duration
    duration  time bs  a new  
 condition
 and  at start  initiated  a new  m  
 at start  aeei ok  a new  m  l  a  
 at start  qos params  a new  l  
 at start  message trm  m  ms   
 at start  message aeei  a new  ms    
 effect
 and  at end  iu bearer  a new  m  l    at end  bs ok  a new  m  l  a     

action preconditions successful execution module aeei call
set up  satisfaction required qos class parameters  denoted list l   transfered
messages set up status application mobile pdn  resources already
allocated preceding modules  effect bearer network connection mobile
application set up 
   

fie ngineering b enchmarks



p lanning

initiation application starts mobile trm  afterwards  ct
asked ready for service signal  core call set up radio access bearer
procedure cnd  let us consider latter detail  first step logical resources
must allocated  rrc   e g   required number channels must provided logical
level radio bearer later logical resources mapped physical channels 
pddl rrc action looks follows 
  durative action rrc
 parameters
  a new   application  m   mobile  l   list  a   agent 
 duration
    duration  time rrc  a new  
 condition
 and  at start  ct ok  a new  m  l  
 at start  aeem ok  a new  m  l  a  
 at start      has logical channels 
    max logical channels   app channels  a new  m    
 at start      has cell update      max cell update      
 at start     has handover   max handover   
 at start     has active set up   max active set up    
 effect
 and  at start  increase  has logical channels   app channels  a new  m   
 at end  decrease  has logical channels   app channels  a new  m   
 at start  increase  has cell update     
 at end  decrease  has cell update     
 at start  increase  has handover     
 at end  decrease  has handover     
 at start  increase  has active set up     
 at end  decrease  has active set up     
 at end  rrc ok  a new  m  l  a    

requested qos class available  fact rab ok true service
agent must sent mobile order negotiate application user weaker qos
requirements  case success predicate rab ok true connection pdn must
checked  finally  goal predicate bs fulfilled resources available 
a     ipc   omain tructure
used ipc    umts domain six versions  first three are  temporal  domain
version timing constraints  temporal timewindows  domain version pddl    timed
initial facts  temporal timewindows compiled  domain version pddl    wrapper encoding timed initial literals  second domain version set flaw temporal  flaw temporaltimewindows  flaw temporal timewindows compiled  includes following flaw action 
  durative action flaw
parameters
  a new   application  m   mobile  l   list  a   agent 
 duration     duration   
 condition
   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

version
temporal
temporal tw
temporal twc
flaw temporal
flaw temporal tw
flaw temporal twc

formulation
strips temporal
strips temporal tw
strips temporal
strips temporal
strips temporal tw
strips temporal

max  op
 
 
  
 
 
  

max  act
         
         
         
         
         
         

table    overview different domain versions umts  abbreviations used  temporaltw temporal timewindows  temporal twc temporal timewindows compiled 
max  op maximum number  parameterized  pddl operators instance 
max  act maximum number ground actions instance  data parentheses collected ffs reachability pre process  see text  

 and  at start  initiated  a new  m  
 at start  qos params  a new  l  
 at start  trm ok  a new  m  l   
 effect
 and  at end  rab ok  a new  m  l  a  
 at start  not  initiated  a new  m     

action offers shortcut rab ok predicate  used real solution
deletes initiated predicate  action used heuristic functions
based ignoring negative effects  sense  action encodes flaw may disturb
heuristic techniques used modern planners  determine action useful  negative interactions considered  idea flaw practically motivated order see
heuristic planners react it  standard form  domain big challenge
planners  seen section    domain versions one formulation  namely stripsfluents temporal  numerical fluents    except typing   adl constructs used 
instances  plan objective minimize makespan 
domain versions numbers operators ground actions overviewed table   
many empirical data umts seen before  data quite exceptional 
time easy interpret  first  similar seen section      data
actually constant across instances within domain version  due
fact instances scale specification applications need actually started 
second  numbers operators actions differ versions without
time windows  increase somewhat  additional artificial actions  compile
timed initial literals away  c f  section     increase somewhat  course  introduce
flaw action  third  striking observation huge effect ffs reachability preprocessor  building relaxed planning graph initial state removing actions
appear graph  due technical subtleties encoding  restrictions
feasible action instantiations are  partly  implicit possible action sequences  rather
explicit static predicates 

   

fie ngineering b enchmarks



p lanning

a     ipc   e xample nstances
umts call set up domain following challenges planning task  englert   cremers        
real time  plans execution mobile applications generated appropriate time 
planning done maximum duration exceed umts call set up
time 
completeness  possible generate plan  i e  planning result  optimal  plan
required applications minimizes waiting period applications started 
pddl structure basic problem discrete umts call set up  ducs  domain
following 
 define  problem ducs domain basic version 
  domain ducs domain basic version
  objects ms  ms    message
a  a  a  a  a  a  a  a  a  a     application
m  m  m  m  m  m  m  m  m  m     mobile
l  l  l  l  l  l  l  l  l  l     list
ae   agent 
  init     time trm a           time ct a      
    time am a           time aeem a      
    time rrc a            time rab a      
    time aeei a           time bs a      
     
 location m      types
 authentification m  
     
    has mobile cpu        current status
       
  goal  and  bs ok a  m  l  ae           

first pddl description come objects applications mobiles 
come durations modules depending applications  e g   module trm requires
less time news ticker chess game  since latter requires terminal resources
ticker  current status resources initialized  finally  goal defined 
bearer establishment execution start initiated mobile applications  total execution
time minimized 
ipc   time windows varied small perturbations order generate different
instances  perturbations motivated average execution times modules radio
network according load  furthermore  number applications set varied  
    domains assume applications run one mobile terminal  however 
distributed several mobile terminals     different instances per domain version 
a     f uture w ork
umts domain big challenge modern heuristic  i e  hsp ff lpg style  planners
planners satisficing  potentially return sub optimal plans   objective umts
   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

minimize execution time  one ignores objective task trivializes 
optimal planners  umts realistic challenge  domain already relatively realistically
modelled  except left out additional constraints  many  less important resources 
remains seen if  introducing resources  planner  in particular optimal planner 
performance gets degraded  option case may introduce explicit language constructs
different types  renewable consumable  resources 
future following two challenges shall investigated  first  negotiation umts
quality service  qos  parameters could considered  assume video application mobile
terminal initiated  bearer resources sufficiently available  qos
negotiated terminal bearer  leads planning negotiation
plan execution already initiated applications 
second  approach optimization umts call set up applied wireless
lan registration  challenge transfer qos parameters  since current wireless lan
standard        b  contain qos  demerit solved applying additional
service level addresses qos 

references
 gpp          g partnership project  www  gpp org 
appleby  s     steward  t          mobile software agents control telecommunication
networks  chap     hayzelden  a  bigham  j   eds    software agents future telecommunication systems  springer 
apt  k   blair  h     walker  a          towards theory declarative knowledge  foundations
deductive databases logic programming  pp         morgan kaufmann 
bacchus  f     kabanza  f          using temporal logics express search control knowledge
planning  artificial intelligence              
bacchus  f          subset pddl aips     planning competition  aips    planning competition comitee  available http   www cs toronto edu aips     pddl subset ps 
bacchus  f          aips   planning competition  ai magazine              
bertoli  p   cimatti  a   roveri  m     traverso  p          planning nondeterministic domains
partial observability via symbolic model checking   nebel  nebel        
bertoli  p   cimatti  a   slaney  j     thiebaux  s          solving power supply restoration problems planning via symbolic model checking  proceedings   th european
conference artificial intelligence  ecai      pp         lyon  france  wiley 
biundo  s   myers  k     rajan  k   eds     icaps            proceedings   th international conference automated planning scheduling  icaps      monterey  ca  usa 
morgan kaufmann 
bloem  r   ravi  k     somenzi  f          symbolic guided search ctl model checking 
conference design automation  dac   pp       
blum  a  l     furst  m  l          fast planning planning graph analysis  artificial
intelligence                  

   

fie ngineering b enchmarks



p lanning

boddy  m   gohde  j   haigh  t     harp  s          course action generation cyber security
using classical planning   biundo et al   biundo  myers    rajan         pp       
bonet  b     geffner  h          planning heuristic search  artificial intelligence          
    
bonet  b   loerincs  g     geffner  h          robust fast action selection mechanism
planning  proceedings   th national conference american association
artificial intelligence  aaai      pp          mit press 
bonet  b     thiebaux  s          gpt meets psr  giunchiglia  e   muscettola  n     nau 
d   eds    proceedings   th international conference automated planning
scheduling  icaps      pp          trento  italy  morgan kaufmann 
busuioc  m          distributed intelligent agents   solution management complex
telecommunications services  chap    hayzelden  a  bigham  j   eds    software agents
future telecommunication systems  springer 
bylander  t          computational complexity propositional strips planning  artificial
intelligence                 
cesta  a     borrajo  d   eds            recent advances ai planning   th european conference
planning  ecp     toledo  spain  springer verlag 
chen  y   hsu  c     wah  b          sgplan  subgoal partitioning resolution planning 
edelkamp  s   hoffmann  j   littman  m     younes  h   eds    proceedings  th
international planning competition  whistler  bc  canada  jpl 
chien  s   kambhampati  r     knoblock  c   eds     aips            proceedings  th
international conference artificial intelligence planning systems  aips      aaai press 
menlo park 
cimatti  a   roveri  m     traverso  p          automatic obdd based generation universal
plans non deterministic domains  proceedings   th national conference
american association artificial intelligence  aaai      pp          madison  wi  mit
press 
clarke  e  m   grumberg  o     peled  d  a          model checking  mit press 
dierks  h          finding optimal plans domains restricted continuous effects uppaal cora  icaps workshop verification validation model based planning
scheduling systems 
edelkamp  s       a   promela planning  workshop model checking software  spin   lecture notes computer science  pp          springer 
edelkamp  s       b   taming numbers durations model checking integrated planning
system  journal artificial intelligence research             
edelkamp  s     jabbar  s          action planning directed model checking petri nets 
electronic notes theoretical computer science              
edelkamp  s   jabbar  s     lluch lafuente  a          action planning graph transition systems  icaps workshop verification validation model based planning
scheduling systems  pp       
   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

edelkamp  s   leue  s     lluch lafuente  a          directed explicit state model checking
validation communication protocols  international journal software tools technology             
englert  r          planning optimize umts call set up execution mobile applications  int  journal applied artificial intelligence               
englert  r     cremers  a  b          configuration applications  rd generation mobile
communication  ki workshop ai planning  scheduling  configuration design
 puk   vienna  austria 
farjami  p   gorg  c     bell  f          advanced service provisioning based mobile agents 
computer communications              
fikes  r  e     nilsson  n          strips  new approach application theorem proving
problem solving  artificial intelligence            
fourman  m  p          propositional planning  aips workshop model theoretic approaches
planning 
fox  m   long  d     halsey  k          investigation expressive power pddl    
saitta  l   ed    proceedings   th european conference artificial intelligence
 ecai      valencia  spain  wiley 
fox  m     long  d          detection exploitation symmetry planning problems 
pollack  m   ed    proceedings   th international joint conference artificial
intelligence  ijcai      pp          stockholm  sweden  morgan kaufmann 
fox  m     long  d          pddl     extension pddl expressing temporal planning
domains  journal artificial intelligence research            
frank  j   cheeseman  p     stutz  j          gravity fails  local search topology  journal
artificial intelligence research            
garagnani  m          correct algorithm efficient planning preprocessed domain axioms 
research development intelligent systems xvii  springer verlag 
gazen  b  c     knoblock  c          combining expressiveness ucpop efficiency
graphplan   steel    alami  steel   alami         pp         
gerevini  a     long  d          plan constraints preferences  aips    planning competition comitee  available http   zeus ing unibs it ipc   pddl ipc  pdf 
gerevini  a   saetti  a     serina  i          approach temporal planning scheduling
domains predictable exogenous events  journal artificial intelligence research     
       
giunchiglia  f     traverso  p          planning model checking  biundo  s     fox  m 
 eds    recent advances ai planning   th european conference planning  ecp    
lecture notes artificial intelligence  pp       durham  uk  springer verlag 
haslum  p     geffner  h          heuristic planning time resources   cesta    borrajo
 cesta   borrajo         pp         
hatzack  w          entwicklung und auswertung von algorithmen zur autonomen verkehrskoordinierung und konfliktauflsung flughfen  ph d  thesis  university freiburg  freiburg 
germany 
   

fie ngineering b enchmarks



p lanning

hatzack  w     nebel  b          operational traffic control problem  computational complexity solutions   cesta    borrajo  cesta   borrajo         pp       
helmert  m          complexity results standard benchmark domains planning  artificial
intelligence              
helmert  m          planning heuristic based causal graph analysis   koenig et al   koenig 
zilberstein    koehler         pp         
helmert  m         personal communication 
helmert  m       a   fast downward planning system  journal artificial intelligence research      accepted publication 
helmert  m       b   new complexity results classical planning benchmarks  long  d    
smith  s   eds    proceedings   th international conference automated planning
scheduling  icaps      pp        english lake district  uk  morgan kaufmann 
hoffmann  j          local search topology planning benchmarks  empirical analysis  
nebel  nebel         pp         
hoffmann  j          local search topology planning benchmarks  theoretical analysis 
ghallab  m   hertzberg  j     traverso  p   eds    proceedings  th international conference artificial intelligence planning scheduling  aips      pp         toulouse 
france  morgan kaufmann 
hoffmann  j          metric ff planning system  translating ignoring delete lists numeric
state variables  journal artificial intelligence research             
hoffmann  j          ignoring delete lists works  local search topology planning benchmarks  journal artificial intelligence research             
hoffmann  j     edelkamp  s          deterministic part ipc    overview  journal
artificial intelligence research             
hoffmann  j     nebel  b          planning system  fast plan generation heuristic
search  journal artificial intelligence research             
holldobler  s     stor  h  p          solving entailment problem fluent calculus using
binary decision diagrams  icaps workshop model theoretic approaches planning 
holma  h     toskala  a          wcdma umts   radio access  rd generation mobile
communications  wiley   sons 
holzmann  g          spin model checker   primer reference manual  addison wesley 
holzmann  g  j          design validation computer protocols  prentice hall 
howe  a     dahlman  e          critical assessment benchmark comparison planning 
journal artificial intelligence research          
kabanza  f     thiebaux  s          search control planning temporally extended goals  
biundo et al   biundo et al          pp         
koehler  j     hoffmann  j          instantiation adl operators involving arbitrary
first order formulas  ecai workshop new results planning  scheduling design 

   

fih offmann   e delkamp  hi ebaux   e nglert  l iporace   r ug

koehler  j   nebel  b   hoffmann  j     dimopoulos  y          extending planning graphs
adl subset   steel    alami  steel   alami         pp         
koehler  j     schuster  k          elevator control planning problem   chien et al   chien 
kambhampati    knoblock         pp         
koenig  s   zilberstein  s     koehler  j   eds     icaps            proceedings   th international conference automated planning scheduling  icaps      whistler  canada 
morgan kaufmann 
korf  r  e          real time heuristic search  artificial intelligence             
kvarnstrom  j   doherty  p     haslum  p          extending talplanner concurrency
ressources  horn  w   ed    proceedings   th european conference artificial
intelligence  ecai      pp          berlin  germany  wiley 
lago  u  d   pistore  m     traverso  p          planning language extended goals 
proceedings   th national conference american association artificial
intelligence  aaai      pp          edmonton  al  mit press 
long  d     fox  m          automatic synthesis use generic types planning   chien
et al   chien et al          pp         
long  d     fox  m           rd international planning competition  results analysis 
journal artificial intelligence research          
mcdermott  d          heuristic estimator means ends analysis planning  proceedings
 rd international conference artificial intelligence planning systems  aips     
pp          aaai press  menlo park 
mcdermott  d          pddl planning domain definition language  aips    planning competition comitee  available http   ls  www cs uni dortmund de  edelkamp ipc  docs pddl ps gz 
mcdermott  d               ai planning systems competition  ai magazine              
mcdermott  d  v          using regression match graphs control search planning  artificial
intelligence                   
milidiu  r  l     dos santos liporace  f       a   plumber  pipeline transportation planner 
international workshop harbour maritime simulation  hms   pp         rio de
janeiro  brazil 
milidiu  r  l     dos santos liporace  f       b   pipesworld  applying planning systems
pipeline transportation  proceedings international pipeline conference  ipc   pp 
       
nebel  b   ed     ijcai            proceedings   th international joint conference artificial intelligence  ijcai      seattle  washington  usa  morgan kaufmann 
nebel  b          compilability expressive power propositional planning formalisms 
journal artificial intelligence research             
pednault  e  p          adl  exploring middle ground strips situation
calculus  brachman  r   levesque  h  j     reiter  r   eds    principles knowledge
representation reasoning  proceedings  st international conference  kr      pp 
        toronto  on  morgan kaufmann 
   

fie ngineering b enchmarks



p lanning

reffel  f     edelkamp  s          error detection directed symbolic model checking  world
congress formal methods  fm   pp         
rintanen  j          phase transitions classical planning  experimental study   koenig et al 
 koenig et al          pp         
ruml  w   do  m     fromherz  m          on line planning scheduling high speed manufacturing   biundo et al   biundo et al          pp       
steel  s     alami  r   eds            recent advances ai planning   th european conference
planning  ecp     vol       lecture notes artificial intelligence  toulouse  france 
springer verlag 
thiebaux  s     cordier  m  o          supply restoration power distribution systems
benchmark planning uncertainty   cesta    borrajo  cesta   borrajo         pp 
     
thiebaux  s   cordier  m  o   jehl  o     krivine  j  p          supply restoration power distribution systems case study integrating model based diagnosis repair planning 
horvitz  e     jensen  f  v   eds    proceedings   th international conference
uncertainty ai  uai      pp          portland  oregon  usa  morgan kaufmann 
thiebaux  s   hoffmann  j     nebel  b          defense pddl axioms   gottlob  g   ed   
proceedings   th international joint conference artificial intelligence  ijcai     
pp          acapulco  mexico  morgan kaufmann 
thiebaux  s   hoffmann  j     nebel  b          defense pddl axioms  artificial intelligence 
              
ts               rd generation partnership project  technical specification group service
system aspects  qos concept architecture  release     ts         v        gpp 
vidal  v          lookahead strategy heuristic search planning   koenig et al   koenig et al  
       pp         
wah  b     chen  y          subgoal partitioning global search solving temporal planning
problems mixed space  international journal artificial intelligence tools            
    
yang  c  h     dill  d  l          validation guided search state space  conference
design automation  dac   pp         
younes  h   littman  m   weissman  d     asmuth  j          first probabilistic track
international planning competition  journal artificial intelligence research            

   


