journal artificial intelligence research                  

submitted        published     

clause term resolution learning evaluation
quantified boolean formulas
enrico giunchiglia
massimo narizzano
armando tacchella

giunchiglia unige it
mox dist unige it
tac dist unige it

dist   universita di genova
viale causa           genova  italy

abstract
resolution rule inference basis procedures automated reasoning  procedures  input formula first translated equisatisfiable
formula conjunctive normal form  cnf  represented set clauses  deduction starts inferring new clauses resolution  goes empty clause
generated satisfiability set clauses proven  e g   new clauses
generated 
paper  restrict attention problem evaluating quantified boolean
formulas  qbfs   setting  outlined deduction process known
sound complete given formula cnf form resolution  called qresolution  used  introduce q resolution terms  used formulas disjunctive normal form  show computation performed available
procedures qbfs based davis logemann loveland procedure  dll  propositional satisfiability corresponds tree q resolution terms clauses
alternate  poses theoretical bases introduction learning  corresponding
recording q resolution formulas associated nodes tree  discuss
problems related introduction learning dll based procedures  present
solutions extending state of the art proposals coming literature propositional
satisfiability  finally  show dll based solver extended learning  performs
significantly better benchmarks used      qbf solvers comparative evaluation 

   introduction
resolution  robinson        rule inference basis procedures
automated reasoning  see  e g   fermuller  leitsch  hustadt    tammet        bachmair  
ganzinger         procedures  input formula first translated equisatisfiable formula conjunctive normal form  cnf  represented set clauses 
deduction starts inferring new clauses resolution  goes empty clause
generated satisfiability set clauses proven  e g   new clauses
generated  restrict attention problem evaluating quantified boolean
formulas  qbfs   setting  outlined deduction process known sound
complete given formula cnf form resolution  called q resolution 
used  kleine buning  karpinski    flogel         however  available decision
procedures qbfs based extend davis logemann loveland procedure
 dll   davis  logemann    loveland        propositional satisfiability  sat  
c
    
ai access foundation  rights reserved 

figiunchiglia  narizzano   tacchella

propositional case  well known computation performed dll corresponds
specific form resolution called regular tree resolution  see  e g   urquhart        
paper introduce q resolution terms  used formulas disjunctive
normal form  show computation performed dll based decision procedures
qbfs corresponds tree q resolution terms clauses alternate 
correspondence poses theoretical bases introduction learning  corresponding
recording q resolution formulas associated nodes tree  particular 
recording q resolutions clauses generalizes popular nogood learning constraint satisfaction sat literatures  see  e g   dechter        bayardo  jr    schrag 
       nogood corresponds set assignments falsifying input formula 
useful pruning assignments existential variables  recording q resolutions
terms corresponds good learning  good corresponds set assignments satisfying input formula  useful pruning assignments universal variables 
discuss problems related introduction learning dll based procedures
qbfs  present solutions extending state of the art proposals coming literature
sat  show effectiveness learning qbfs evaluation problem 
implemented qube  state of the art qbf solver  using qube  done
experimental tests several real world qbfs  corresponding planning  rintanen       
castellini  giunchiglia    tacchella        circuit verification  scholl   becker       
abdelwaheb   basin        problems  two primary application domains
interest  results witness effectiveness learning 
paper structured follows  first review basics quantified boolean
logic  time introducing terminology notation used
throughout paper  section    introduce clause term resolution 
relation dll based decision procedures qbfs  then  section    introduce
nogood good learning  show effectively integrated dll
based decision procedures qbfs  implementation experimental results
presented section    paper ends conclusions related work 
paper builds extends many ways aaai paper  giunchiglia  narizzano    tacchella         respect paper   i  introduce clause
term resolution   ii  show correspondence clause term q resolution
computation tree searched dll based decision procedures   iii  basis
correspondence  extend basic backtracking search procedure  first backjumping
learning  prove soundness completeness   iv  discuss
implementation qube providing many details   v  present results
much broader detailed experimental analysis 
on  simply write resolution q resolution 

   quantified boolean logic
consider set p symbols  variable element p  literal variable
negation variable  following  literal l 
 l  variable occurring l 
l negation l l variable   l  otherwise 
   

ficlause term resolution learning quantified boolean formulas

sake simplicity  consider formulas negation normal form  nnf  
thus  us  propositional formula combination literals using k ary  k   
connectives  for conjunctions   for disjunctions   following  use true
false abbreviations empty conjunction empty disjunction respectively 
qbf expression form
  q  z  q  z        qn zn

 n   

   


every qi    n  quantifier  either existential universal  
z            zn distinct variables 
propositional formula z            zn  
example 
x  yx    x  x     y x     x    x  y   y x      

   

qbf 
     q  z        qn zn prefix matrix  say literal l
existential  l  belongs prefix  universal otherwise  finally      
define
level variable zi       number expressions qj zj qj   zj  
prefix j qj    qj    
level literal l  level  l  
example      x  existential level    universal level    x 
existential level   
value semantics qbf defined recursively follows 
   prefix empty  evaluated according truth tables propositional
logic 
   x  true x true x true 
   y  true true 
    l literal  l    zi   l qbf
whose matrix obtained substituting
zi true z false l   zi  
zi false z true l   z  
whose prefix q  z  q  z        qi  zi  qi   zi         qn zn  
easy see qbf without universal quantifiers  problem determining
value reduces sat problem 
two qbfs equivalent either true false 
   

figiunchiglia  narizzano   tacchella

   resolution dll based decision procedures qbfs
section first introduce clause term resolution dll based decision procedures
qbfs  show correspondence two 
    clause term resolution
according definition qbf  matrix combination conjunctions
disjunctions literals  however  using common clause form transformations based
renaming first used tseitin         possible perform linear time conversion
arbitrary qbf equivalent one matrix conjunctive normal form
 cnf   conversions based fact qbf     equivalent
q  z  q  z        qn zn x  x    x   

 n   


propositional formula literal 
x variable distinct z    z            zn  
 x   propositional formula obtained substituting one occurrences x 
thus 
  x  y   y x    
follows     equivalent
x  yx  x    x  x     y x     x  x     x  x     y x  x    

   

thanks conversions  restrict attention qbfs matrix
cnf  represent matrix formula set clauses interpreted
conjunctively  clause finite set literals interpreted disjunctively  further 
assume clause non tautological minimal  clause tautological
contains variable negation  clause c minimal literals c
minimum level existential  minimal form clause c clause obtained
c deleting universal literals cause c non minimal  instance 
     clauses non tautological minimal  assumption clauses
non tautological minimal restriction  following theorem states 
theorem   let qbf matrix cnf  let   qbf obtained

   eliminating tautological clauses 
   replacing non tautological non minimal clause minimal form 
  equivalent 
   

ficlause term resolution learning quantified boolean formulas

proof  clearly  tautological clauses eliminated result equivalent
qbf  let c    l            ln   ln             lm   non tautological non minimal clause
ln             lm universal literals c   min c     n   m   further  without
loss generality  assume level li less equal level li    
    m  then  form  p m 
      q   l           ln          ln            lm  qm   zm         qp zp   l            ln   ln             lm           
standing
      q   l           ln          ln            lm  qm   zm         qp zp   l        ln ln         lm     
then  applying standard rules quantifiers  rewritten
      q   l           ln          ln            lm    l        ln ln         lm   qm   zm         qp zp   
equivalent
      q   l           ln          ln             lm   l       ln ln        lm   lm  qm   zm         qp zp   
equivalent
      q   l           ln          ln             l        ln ln         lm     lm  qm   zm         qp zp   
equivalent
      q   l           ln          ln            lm  qm   zm         qp zp   l        ln ln         lm      
i e   qbf obtained deleting lm clause c  iterating
reasoning process  literals c   min c  eliminated c  hence
thesis 

on  qbf cnf matrix conjunction clauses 
clause minimal non tautological  represent matrix qbf
set clauses 
empty clause    stands false 
empty set clauses    stands true 
formula      equivalent false 
qbf     written
x  yx  x    x    y  x      y  x      x    x      x    y  x      y  x    x     

   

clause resolution  kleine buning et al         similar ordinary resolution
existential literals matched  precisely  clause resolution  on literal l 
rule
c 
c 
   
min c 

   

figiunchiglia  narizzano   tacchella

 c  
 c  
 c  
 c  

 x    y  x   
 y  x   
 x    x   
 x    y  x   

input
input
input
input

formula
formula
formula
formula

 c  
 c  
 c  
 c  

 x   
 x    y 
 x   
  






 c   
 c   
 c   
 c   

 c  
 c  
 c  
 c  

table    clause resolution deduction showing     false  prefix x  yx  x   

l existential literal 
c    c  two clauses  l  l   c  c     literal l     l   l    l   
 c  c    
c  c  c       l  l  
c  c  antecedents  min c  resolvent rule 
theorem     kleine buning et al          clause resolution sound complete
proof system deciding qbfs cnf  qbf cnf true empty
clause derivable clause resolution 
instance  fact     false follows deduction table   
alternatively cnf conversion  could converted     qbf
matrix disjunctive normal form  dnf   linear time  basis qbf
     equivalent
q  z  q  z        qn zn y  y    y   

 n    

assuming propositional formula literal  variable distinct
z    z            zn  
simple recursive application equivalence     leads following
equivalent qbf 
x  yx  y  y  y  y  y  y    y  y  y   
 y   x     y   y   y   x   
 y   y   y   x   
 y   x     y   y   
 y   y  y   
 y   x     y   y 
 y   y   y   x     

   

given qbf matrix dnf  represent matrix set terms
interpreted disjunctively  term finite set literals interpreted
conjunctively  further  assume term non contradictory minimal 
term contradictory contains variable negation  term minimal
literals minimum level universal  minimal form term
term obtained deleting existential literals cause non minimal 
terms     non contradictory minimal  analogously said
qbfs cnf  qbf dnf assume terms
non contradictory minimal without loss generality 
   

ficlause term resolution learning quantified boolean formulas

theorem   let qbf matrix dnf  let   qbf obtained

   eliminating contradictory terms 
   replacing non contradictory non minimal term minimal form 
  equivalent 
proof  analogous proof theorem   



before  on  qbf dnf matrix disjunction
terms  term minimal non contradictory 
introduce term resolution  on literal l  consists rule
t 
t 
min t  

l universal literal 
t    t  two terms  l  l   t  t     literal l     l   l    l   
 t  t    
 t  t       l  l  
t  t  antecedents  min t   resolvent rule 
theorem   term resolution sound complete proof system deciding qbfs
dnf  qbf dnf true empty term derivable term resolution 
proof  fact term resolution sound complete proof system follows
soundness completeness clause resolution 
let set sets literals    q  z  q  z        qn zn qbf
interpreted set clauses  without loss generality assume clause
non tautological minimal  following chain equivalences holds 
exists deduction empty clause using clause resolution

false

qbf   q  z  q  z        qn zn interpreted set terms true

deduction empty term using term resolution 
chain equivalences  q q     q    



example term resolution deduction empty term  consider qbf  
x  yx  x    x  x     y x     x  x     x  x     y x  x    
   

figiunchiglia  narizzano   tacchella

i e   qbf obtained     simultaneously replacing      
  then  deduction table   deduction empty term
using term resolution 
qbf dnf cnf term resolution cannot applied 
thus term resolution sufficient proving truth falsity   however 
following model generation rule

min t  

matrix  
non contradictory term clause c   c     
get sound complete proof system qbfs cnf  intuitively  model generation rule allows us start minimal form terms propositionally entail
matrix input formula 
theorem   term resolution model generation sound complete proof system
deciding qbfs cnf  qbf cnf true empty term derivable
term resolution model generation 
proof  given qbf cnf matrix   model generation rule derive
set terms form min t  
term non contradictory clause c   c     

disjunction terms propositionally logically equivalent  
let   qbf dnf obtained substituting    
value  hence thesis thanks theorem   


    dll based decision procedures qbfs
given said far  arbitrary qbf converted  in linear time 
equivalent qbf cnf  this  end paper  restrict
attention qbfs format  assumption      l literal
 l    zi   redefine l qbf
whose matrix obtained removing clauses c l c 
removing l clauses 
whose prefix q  z  q  z        qi  zi  qi   zi         qn zn  
   

ficlause term resolution learning quantified boolean formulas

further  extend notation sequence literals    l    l            lm  m    
defined          l   l          lm  
consider qbf  
simple procedure determining value starts empty assignment
recursively extends current assignment z and or z  z heuristically
chosen variable highest level   either empty clause empty set
clauses produced   basis values  z  z   value
determined according semantics qbfs  value value  
cadoli  giovanardi  giovanardi schaerf        introduced various improvements
basic procedure 
first improvement directly conclude value
matrix contains contradictory clause  lemma     cadoli et al          clause
c contradictory contains existential literal  example contradictory clause
empty clause 
second improvement allows us directly extend l l unit monotone
 lemmas               cadoli et al               literal l is 
unit l existential   
clause  l  l            lm   belongs  
literal li    m  universal level lower level l 
monotone pure
either l existential  l belong clause   l occurs  
l universal  l belong clause   l occurs  
example  qbf form
      x  yx          x    y    x            
x  x  unit  qbf
y  x  y  x    y     y    x      x        x     
monotone literals y  x   
improvements  resulting procedure  called q dll  essentially one
presented work cadoli  giovanardi  schaerf         extends dll
order deal qbfs  figure   simple  recursive presentation it  figure 
given qbf  
   false returned contradictory clause matrix  line     otherwise
   true returned matrix empty  line     otherwise
   line    recursively extended   l l unit  and say l
assigned unit   otherwise
   

figiunchiglia  narizzano   tacchella

  function q dll    
 
 ha contradictory clause matrix i  return false 
 
 hthe matrix emptyi  return true 
 
 hl unit i  return q dll     l  
 
 hl monotone i  return q dll     l  
 
l    ha literal highest level i 
 
 hl existentiali  return q dll     l  q dll     l  
 
else return q dll     l  q dll     l  
figure    algorithm q dll 
   line    recursively extended   l l monotone  and say l
assigned monotone   otherwise
   literal l highest level chosen
l existential  line     extended   l first  and say l
assigned left split   result false    l tried returned  and
case say l assigned right split  
otherwise  line     l universal  extended   l first  and say l
assigned left split   result true    l tried returned
 and case say l assigned right split  
theorem   q dll     returns true true  false otherwise 
proof  trivial consequence lemmas                    work cadoli  giovanardi 
giovanardi  schaerf        semantics qbfs 

given said far  clear q dll evaluates generating
semantic tree  robinson        node corresponds invocation q dll
thus assignment   us 
assignment  for qbf   possibly empty sequence   l    l            lm  m   
literals li   li unit  monotone  highest level
l   l       li   
 semantic  tree representing run q dll tree
node call q dll     
edge connecting two nodes   l  l literal 
tree representing run q dll least node  
example run q dll  consider qbf      simplicity  assume
literal returned line   figure   negation first variable prefix
occurs matrix qbf consideration  then  tree searched
q dll     represented figure    figure 
   

ficlause term resolution learning quantified boolean formulas

    x    y  x      x    y  x      y  x      y  x    x      x    x      
 x    hx    li  x   
  y  x      y  x      y  x    x      x    x    

 x    hx    ri  x   
  y  x      y  x      y  x    x      x    x    

hy  ri  x   
hy  li  y 
hy  li  y 
hy  ri  x   
hx    pi y   x    y  x   hx    ui x   
hx    pi y   x    y  x   hx    ui x   
      y  x   
 y      y 
 y  x   hx    ui y  x     y      y 
      x    x   

figure    tree generated q dll      matrix     shown root
node  prefix x  yx  x    u  p  l  r stand unit  pure  left
split  right split respectively  obvious meaning 

node labeled literal assigned q dll order extend assignment built far  thus  assignment corresponding node sequence
labels path root node  instance  assignment corresponding node label x  x    y  x   
literals assigned unit monotone  corresponding nodes aligned
one other  assigned literal l  show whether l
assigned unit  monotone  left right split marking u  p  l  r
respectively 
l assigned left right split  show matrix  l  
sequence literals assigned l 
node leaf  matrix either empty  in case
write    node   contains contradictory clause  in case
write      node  
considering figure    easy see q dll would correctly return false  meaning      and thus      false 
    resolution dll based decision procedures qbfs
well known correspondence sat semantic trees resolution  see  e g  
urquhart        gives us starting point analysis  aimed establish correspondence q dll clause term resolution 
consider qbf   let tree explored q dll evaluating  
time being  assume dealing sat problem  i e  
contain universal quantifiers  then  q dll reduces dll  false
use generate clause resolution deduction empty clause   basic idea
associate node clause c  falsified  i e  
   

figiunchiglia  narizzano   tacchella

literal l c  l    we say literal l assigned l            lm
l  l            lm     precisely 
every leaf   associate arbitrarily selected clause matrix
 falsified  least one clause exists contains empty
clause 
c clause associated node   l 
   l   c c clause associated   notice l monotone
l   c 
   l c l unit clause associated resolvent
c arbitrarily selected clause causes l unit  
   l c l unit consider clause c   associated
node   l  l   c   c   clause associated  as
first case   l c     clause associated resolvent c c    
lemma   let qbf without universal quantifiers  let tree searched
q dll      let assignment   false  clause associated
node
 falsified 
contain existential literals whose negation assigned monotone
 
proof  let set assignments extend   clearly  assignment
  s    false   contain universal quantifiers   s  define partial
order relation according two assignments          
  extends      clearly well founded minimal elements
assignments extending corresponding leaves  
  extends leaf     contains contradictory clause c  since
contain universal quantifiers  c    falsified associated node
    clearly  c contain existential literals whose negation assigned
monotone 
induction hypothesis  assignment          l       falsified
clause containing existential literals whose negation assigned monotone 
show thesis      three cases 
   l assigned unit  let c  clause associated      l  induction
hypothesis  thesis holds c    c  contain l  thesis trivially follows 
otherwise  clause associated    resolvent c c  clause c 
causes l unit      c       l falsified contain existential
literals whose negation assigned monotone  c   c  c     l  l  thus
thesis trivially holds 
   l assigned monotone  case clause c associated   
clause associated      l  induction hypothesis c contain l
thus c     falsified 
   

ficlause term resolution learning quantified boolean formulas

   l split  case clause c  associated      l clause c 
associated      l  thesis holds c  c  induction hypothesis 
c  contain l  clause associated    c  thesis
trivially holds  otherwise  c  contain l  clause associated
   c  thesis trivially holds  otherwise  clause associated   
c  c     l  l  thesis trivially holds 

theorem   let false qbf without universal quantifiers  tree searched qdll     corresponds clause resolution deduction empty clause 
proof  let sequence clauses obtained listing clauses matrix
according arbitrary order  followed clauses associated internal nodes
tree searched q dll      assuming visited post order  clearly 
deduction  deduction empty clause node associated
 falsified clause  lemma     i e   empty clause 

theorem points close correspondence computation q dll
clause resolution  assuming input formula false contain
universal quantifiers  input formula contain universal quantifiers true 
still tree explored q dll generating path ending empty matrix
corresponds sequence clause resolutions  one maximal subtree whose leaves
contains empty clause 
longer assume input formula contain universal quantifiers 
consider case arbitrary qbf  situation gets complicated 
possibility assigning unit literals highest level 
so  assume literal l assigned unit node   l highest
level  
then  input formula false  use tree searched q dll
generate clause resolution deduction empty clause  construction analogous
one described before  difference restrict attention
minimal false subtree   i e   tree obtained deleting subtrees
starting left split universal literal  subtrees originated wrong
choices deciding branch explore first  minimal false subtree    
leaves terminate empty clause  associate node  
clause exactly way described sat case  instance      
q dll assigns unit literals highest level  figure   shows
minimal false subtree q dlls computation  associated clause resolution
deduction empty clause  figure 
clause associated node written red right node
itself 
node corresponds assignment unit literal l  clause
causes l unit node  used corresponding clause resolution  written
red left node 
   

figiunchiglia  narizzano   tacchella

    x    y  x      x    y  x      y  x      y  x    x      x    x      
 x    hx    li  x   
  y  x      y  x      y  x    x      x    x    

 x    hx    ri  x   
  y  x      y  x      y  x    x      x    x    

hy  ri  x   
 x    y  x   hx    ui x   
 y  x   hx    ui y  x   
      x    x   

hy  ri  x   
 x    y  x   hx    ui x   
      y  x   

figure    clause resolution corresponding tree generated q dll     
prefix x  yx  x   

lemma   let false qbf  let minimal false subtree tree searched
q dll     assume node   l   l unit l
highest level   let assignment   false  clause associated
node
 falsified 
contain existential literals whose negation assigned monotone
 
proof  trivial extension proof lemma    assumption node   l
  l unit l highest level   ensures clause associated
node  falsified 


theorem   let false qbf  let minimal false subtree tree searched
q dll     assume node   l   l unit l
highest level   corresponds clause resolution deduction empty
clause 
proof  given lemma    proof analogous one theorem   



regardless whether input formula true false  tree explored q dll
may contain  exponentially many  subtrees whose nodes false 
procedure described above  allows us associate clause resolution deduction
subtrees 
input formula true  situation simpler far unit
universal literals  use tree searched q dll generate deduction
empty term   intuitively  process analogous one described
false  except leaves term resolution deduction terms corresponding
assignments computed q dll entailing matrix   details 
   

ficlause term resolution learning quantified boolean formulas

first  restrict attention minimal true subtree   i e   tree
obtained deleting subtrees starting left split existential
literal  analogously case false  leaf minimal true
subtree terminates empty matrix 
second  associate node term  represented set  follows 
term associated leaf minimal term min t    
   contain universal literals assigned monotone 
   propositionally entail matrix  i e   clause c matrix
  c     
   subset literals   i e    l   l   
term associated node   l 
   l   term associated node   notice l
either existential universal monotone   l    
   l consider term   associated node
  l  l       term associated  as first case  
l     term associated resolvent    
easy see term associated node  entailed  literal
 
lemma   let true qbf  let minimal true subtree tree searched
q dll      let assignment   true  term associated
node
 entailed 
contain universal literals assigned monotone 
proof  analogous proof lemma   



theorem   let true qbf  let minimal true subtree tree searched
q dll      corresponds model generation term resolution deduction
empty term 
proof  let sequence terms obtained listing terms associated
nodes visited post order  clearly  model generation term resolution deduction  deduction empty term node associated  entailed
term  lemma     i e   empty term 

before  regardless whether input formula true false  tree explored
q dll may contain  exponentially many  subtrees whose nodes associated
   sake efficiency  important term satisfies properties  however 
necessary time being  discussed next section 

   

figiunchiglia  narizzano   tacchella

    x    y  x      x    y  x      y  x      y  x    x      x    x      
 x    hx    ri  x   
 x    hx    li  x   
  y  x      y  x      y  x    x      x    x       y  x      y  x      y  x    x      x    x    
hy  li  y 
hx    pi y 
 y  x        y 

hy  li  y 
hx    pi y 
 y  x        y 

figure    term resolutions corresponding tree generated q dll     
prefix x  yx  x   

    x    y  x      x    y  x      y  x      y  x    x      x    x      
 x    hx    li  x   
  y  x      y  x      y  x    x      x    x    

 x    hx    ri  x   
  y  x      y  x      y  x    x      x    x    

hy  li  y 
hy  li  y 
hy  ri  x   
hy  ri  x   
hx    pi y   x    y  x   hx    ui x   
hx    pi y   x    y  x   hx    ui x   
 y  x        y 
      y  x   
 y  x   hx    ui y  x     y  x        y 
      x    x   

figure    resolution corresponding tree generated q dll      prefix
x  yx  x   

assignments true  described procedure allows us associate
term resolution deduction subtrees  instance     
two maximal subtrees  roots x    x    y  associated deductions
represented figure    figure 
represent nodes along path root subtrees 
term associated node written green right node
itself 
leaf  non contradictory term entailing matrix whose minimal
form min t   associated   written green left  
merging trees figures     obtain whole tree deductions corresponding search tree explored q dll  represented figure    clause
term resolutions intermixed 
   

ficlause term resolution learning quantified boolean formulas

consider case input qbf false longer assume
literals assigned unit highest level  restrict
attention minimal false subtree tree searched q dll      then 
procedure described associating clause node may longer work 
one thing  given leaf   may  falsified clauses matrix input
formula  however  guaranteed existence  contradicted clause
matrix input formula  clause c  contradicted if 
literal l c  l  
existential literal l c  l  
long associate node  contradicted clause  either belonging
matrix obtained clause resolution  corresponds clause resolution
deduction empty clause  indeed clause associated root
empty  remember resolvent clause resolution minimal form   thus 
obvious solution try associate
   leaf  contradicted clause input formula 
   internal node  contradicted clause obtained resolving input clauses
and or previously deduced clauses along lines outlined before 
cases process runs smoothly  consider instance  qbf form 
x  x  yx    x    x      x    x      x    y  x            

   

then  assume split x  occurs first  following path explored  we
using conventions figure    
hx    li
hx    ui
hx    ui
    

   

clause associated node are 
hx    li
 x    x    hx    ui
 x    x    hx    ui
    

 x   
 x   
 y  x   
 x    y  x   

see that 
   clause associated leaf   x    x    x   falsified  contradicted 

   respect definition contradictory clause given section      clear clause c
contradictory  contradicted  further  qbf assignment   exists
 contradicted clause matrix   contains  contradicted clause 
contains contradictory clause 

   

figiunchiglia  narizzano   tacchella

  function rec c resolve   c    c    l   
 
    l   l c    l c    
 
 s     return c resolve c    c    
 
l     han existential literal c  level level literals c   i 
 
c    ha clause causes l  unit         l  prefix i 
 
c     c resolve c    c  
 
return rec c resolve   c    c    l    
figure    algorithm rec c resolve 
   able associate node  contradicted clause 
unfortunately  cases things run smoothly  i e   may possible
associate clause internal node simple single resolution input and or
previously deduced clauses  indeed  clause resolutions may blocked
universal variables occurring clauses used resolution 
consider instance qbf form  obtained     replacing clause  x    x   
 x    y  x     
x  x  yx    x    x      x    y  x      x    y  x            

   

then      would still valid path  corresponding clause resolutions would be 
hx    li
 x    x    hx    ui
 x    y  x    hx    ui      
      x    y  x   

    

possible perform clause resolution associated node
label hx    ui  example  clause resolution     may blocked
blocking universal literal l
l l  
l c  l c   
since c  c  minimal form  possible c  c  contain
existential literal l 
level less equal level literals clause 
assigned unit 
then  obvious solution get rid  e g   blocking literals l c  resolving
away c  existential literals level lower level l 
idea behind procedure rec c resolve figure    figure 
assume
   input qbf 
   

ficlause term resolution learning quantified boolean formulas

     l assignment 
   l existential literal either unit highest level  
   c  clause containing l  minimal form   l contradicted 
   c  clause containing l  minimal form   l contradicted  further  l unit
  c  clause causes l unit  
   c resolve c    c    returns resolvent clause resolution two
clauses c  c   
on  h  c    c    l  satisfies first   conditions  say
pair hc    c    l rec c resolved  in    given two clauses hc    c 
  l rec c resolved 
   set universal literals blocking clause resolution c  c 
computed  line    
   empty  simply return resolvent c  c   line    
otherwise
   pick existential literal l  c  minimum level c   line     l 
assigned unit earlier search  consider clause c caused
l  assigned unit  line     c  resolvent c  c  line    
rec c resolve   c    c    l    returned  line    
hc    c    l rec c resolved   rec c resolve   c    c    l    returns minimal clause  contradicted without existential literals whose negation
assigned monotone   formally stated following lemma 
lemma   let c  c  two clauses hc    c    l rec c resolved
qbf   rec c resolve   c    c    l    terminates returns clause
minimal form  contradicted 
contain existential literals whose negation assigned monotone  
proof lemma quite long reported appendix 
assuming input qbf false  construction deduction empty
clause  associated minimal false subtree tree searched q dll 
following 
every leaf   associate clause c input formula contradicted 
c clause associated node   l 
   l   c l universal c clause associated parent
  l  i e   node   notice l existential monotone
l   c 
   

figiunchiglia  narizzano   tacchella

   l c l unit clause associated node
result rec c resolve   c  c     l     c   clause causes l
unit  
   l c  l existential unit   consider
clause c   associated node   l  l   c   c   clause associated
 as first case   l c     clause associated node
result rec c resolve   c  c     l    
example      reference deduction       blocked resolution one associated node x    x    x    rec c resolve    x    y  x      x    y  x     x    x    x   
   line    resolves  x    y  x     x    x     resolvent c  min  x    x    y    
 x    x    
   following recursive call rec c resolve    x    x      x    y  x     x    x    x    line  
returns  x    y  x    
thus  clause associated node are 
hx    li
 x    x    hx    ui
 x    y  x    hx    ui
    

 x   
 x   
 x    y  x   
 x    y  x   

notice that  reference figure    choice eliminating blocking literals
c  maintaining c  invariant  arbitrary  indeed  could eliminate blocking
literals c  maintain c  invariant  case deduction       amounts
eliminate universal literal  x    y  x     resolving clause  x    x   
x    get resolvent  x    x     leads following legal deduction 
hx    li
 x    x    hx    ui
 from  x    y  x      x    x      x    x    hx    ui
    

 x   
 x   
 x    y  x   
 x    y  x   

lemma   let false qbf  let minimal false subtree tree searched
q dll      let assignment   false  clause associated
node
minimal form  contradicted 
contain existential literals whose negation assigned monotone
 
proof  construction  clause associated leaf  contradicted 
show clause c associated internal node  contradicted 
assuming clause c   associated child   l   l contradicted 
child   l  assume clause c    associated child   l   l contradicted 
   

ficlause term resolution learning quantified boolean formulas

   l   c   l universal c   c     hence  c minimal form  since l   c  
l universal  c     l contradicted c    contradicted  thesis
follows c   c    
   l c   l unit c  rec c resolve   c     c      l     c   
clause causes l unit   thesis follows lemma   
   l c  l existential unit   consider clause
c   associated node   l  assuming l c    otherwise would first
case   clause associated result rec c resolve   c  c     l    
previous case  thesis follows lemma   

theorem    let false qbf  let minimal false subtree tree searched
q dll      corresponds clause resolution deduction empty clause 
proof  given lemma    proof analogous one theorem   



   backjumping learning dll based procedures qbfs
section first show computing resolvent associated node allows
backjump branches backtracking  subsection       then  show
learning resolvents allows prune search tree branches different ones
resolvents computed learned  subsection      
    conflict solution directed backjumping
procedure described section     uses standard backtracking schema whenever
empty clause  resp  matrix  generated  q dll backtrack first existential
 resp  universal  literal assigned left split  instance  given qbf
y  x  y  x  x    y    y    x      y        x    x      y    x    x    
 y     x    x      y     y    x      y     y    x      y     x        x     

    

tree searched q dll represented figure    use conventions
section   
     work giunchiglia  narizzano  tacchella         shown
exploration branches necessary  particular  input qbf
assignment  show possible compute reason  un satisfiability
backtracking  intuitively speaking  reason result subset
literals assignment  
assigns true false literals assigned  i e     l   
l         l    l    
extends  i e    l   l      
   

figiunchiglia  narizzano   tacchella

  
  y    y    x      y        x    x      y    x    x    
 y     x    x      y     y    x      y     y    x      y     x        x    
 y    hy     li y    
  y    x      y     x    x      x    x    
hy     li y    
 y         x   hx    ui y    
 y     x    x   hx    ui y    
 y     x    x        y    

hy    ri  
  x    x      y    x      y    x      x        x    

hy    ri
  x    x      x    x    
hx    li
hx    ui
  

hx    li  
 y     x    x   hx    ui  
hy     pi  
 y     y    x   hx    ui  
      y     y    x   

hx    ri
hx    pi
hy     pi
hx    ui
    

figure    resolution corresponding tree generated q dll       prefix
y  x  y  x  x   

  equivalent   then  computing reasons  avoid right split
literal l l reason  assigning l false would change result 
resulting procedure generalization qbf popular conflict directed backjumping
 cbj   prosser      b   introduces concept solution directed backjumping
 sbj   avoiding useless splits universal variables 
later paper  giunchiglia  narizzano  tacchella        show possible
optimize computation reasons  particular  paper  shown
assuming unsatisfiable  consider reasons subset existential
literals  
assuming satisfiable  consider reasons subset universal
literals  
apart optimizations  tree searched procedures described former
latter papers same  and  case       exploration branches
starting hy    ri  hx    ri skipped  see figure    
show computation resolutions corresponding q dll allows
avoid exploration branches pretty much cbj sbj do  case
qbf       branches skipped skipped cbj sbj 
key point think q dll procedure producing clause  resp  term 
deduction empty clause  resp  term   proving unsatisfiable  resp  satisfiable  
then  according rules use associating deduction tree searched qdll  that 
c clause associated node   l l   c  clause associated
node c  even l existential assigned left split 
   

ficlause term resolution learning quantified boolean formulas

  function q dll bj    
 
 ha clause c  contradictedi 
 
return c 
 
 hthe matrix emptyi  return modelgenerate   
 
 hl unit i 
 
c    ha clause matrix causes l unit i 
 
w r    q dll bj     l  
 
 hw r termi l   w r  return w r 
 
return rec c resolve   w r  c  l    
 
 hl monotone i  return q dll bj     l  
  
l    ha literal highest level i 
  
w r    q dll bj     l  
  
 hl existentiali  hw r termi l   w r   return w r 
  
 hl universali  hw r clausei l   w r   return w r 
  
w r     q dll bj     l  
  
 hl existentiali  hw r  termi l   w r     return w r   
  
 hl universali  hw r  clausei l   w r     return w r   
  
 hl existentiali  return rec c resolve   w r    w r  l    
  
return t resolve w r    w r  l    
figure    algorithm q dll bj 
analogously  term associated node   l l     term
associated node   even l universal assigned left
split 
rules take account clause term associated node   l 
thus need explore branch starting   l 
consider example figure    use standard conventions and  e g   write
clause  resp  term  associated node red  resp  green  right
node  reference figure  clear considering term  y     associated
node         need explore branch starting hy    ri order
associate    entailed term node     similarly  considering empty clause   
associated node y    x    need explore branch starting
hx    ri order associate y   contradicted clause node y   
procedure q dll bj     figure   incorporates ideas  figure 
modelgenerate   returns minimal form non contradictory  entailed
term
clause c   c     
universal literal l assigned monotone  l    
rec c resolve   c    c    l    figure   
   

figiunchiglia  narizzano   tacchella

t resolve t    t    returns resolvent term resolution two terms
t  t   
behavior q dll bj illustrated words saying q dll bj    
computes returns clause term would associated node tree
explored q dll  particular  assuming
w r clause  resp  term  returned q dll bj     l  
l existential  resp  universal  
l assigned left split 
q dll bj     explore branch starting   l l   w r  resp  l   w r  
see line     resp  line     q dll bj 
far  reference figure    interpret clause  resp  term  red
 resp  green  right node value returned q dll bj      then 
considering term  y     associated node         q dll bj explore
branch starting hy    ri  similarly  considering empty clause    associated
node y    x    q dll bj explore branch starting hx    ri 
theorem    q dll bj     returns empty clause false  empty term
true 
proof  sketch  enough notice that 
node associated clause c  c  contradicted  c result
sequence clause resolutions 
node associated term    entailed  result
sequence model generations term resolutions 
then  previous section 
empty clause associated initial node   false 
empty term associated initial node   true 



    learning
learning well known technique sat avoiding useless traversal branches 
sat  learning amounts storing  clause  resolvents associated nodes tree
explored dll  resolvents called nogoods simply added set
input clauses 
case qbfs  situation different complicated  indeed 
two types resolutions  term clause   resolvents clause resolutions
added conjunctively matrix  resolvents term resolutions  that
call goods  considered disjunction matrix 
practice  handle three sets formulas 
   

ficlause term resolution learning quantified boolean formulas

set terms corresponding goods learned search 
set clauses corresponding matrix input qbf 
set clauses corresponding nogoods learned search 
formally  qbf form      qbf extended learning  eqbf 
expression form
q  z        qn zn h   
 n   
    

set terms  called goods  interpreted disjunctively  good
obtained model generation and or term resolution  
set clauses  called nogoods  interpreted conjunctively  nogood
obtained clause resolution  
clearly 
q  z        qn zn    

q  z        qn zn    
equivalent     
initially empty set  input set clauses  search
proceeds 
nogoods determined backtracking contradiction  i e   assignment unsatisfiable  possibly added  
goods determined backtracking solution  i e   assignment
satisfiable  possibly added  
following  use term constraints want refer goods
nogoods indifferently 
consider eqbf       constraints and or   search
pruned considerably  indeed  descending search tree  literal assigned
long guaranteed reconstruct valid clause term deduction
backtracking empty clause term  availability already derived clauses terms
allows prune search constraints   given assignment  
exists  contradicted clause c  resp   satisfied term   stop
search return c  resp     term  satisfied
literal l   l  
universal literal l   l  
clearly   entailed term  satisfied  further  extend notion unit
take account constraints and or   literal l
unit eqbf     
   

figiunchiglia  narizzano   tacchella

  function rec resolve   w    w    l   
 
    l   l w    l w    
 
 s     return resolve w    w    
 
l     ha literal w  level level literals w   i 
 
w    ha constraint causes l  unit         l  prefix i 
 
w     resolve w    w   
 
return rec resolve   w    w    l    
figure    algorithm rec resolve 
either l existential   
clause  l  l            lm   belongs  
expression  li      m  occurs right  l  prefix
     
l universal   
term  l  l            lm   belongs  
expression  li      m  occurs right  l  prefix
     
definition monotone literals  crucial property ensured
dealing eqbfs  existential  resp  universal  literal l assigned monotone
  l never enter nogood  resp  good  associated node extending   l 
guaranteed defining literal l monotone pure if 
either l existential l belong constraint  
l universal l belong constraint  
possibility assigning universal literals unit  may case
term resolutions may blocked existential literals l l 
occurring one terms used antecedents term resolution  however 
procedure rec c resolve presented subsection     easily generalized
work case constraints resolved terms  result
procedure rec resolve   w    w    l    figure    assumed
   eqbf 
   various ways guarantee existential literal l assigned monotone   l
enter nogood associated node extending   l  another one
keep definition existential monotone literal unchanged  existential literal assigned
monotone      l belong clause  
update  or proceed search updated to     c   c   l c  
analogously universal monotone literals  see work giunchiglia  narizzano tacchella      a  details possibilities  including discussion interaction
monotone rule learning 

   

ficlause term resolution learning quantified boolean formulas

     l assignment 
   l existential  resp  universal  literal either unit highest level
 
   w  clause  resp  term  containing l  resp  l   minimal form   l contradicted
 resp    l satisfied  
   w  clause  resp  term  containing l  resp  l   minimal form   l contradicted
 resp    l satisfied   further  l unit   w  clause  resp  term 
causes l unit  
   existential  resp  universal  literal l  assigned unit     l        l 
prefix   l  clause  resp  term  causes l  unit
   
   resolve w    w    returns c resolve w    w     resp  t resolve w    w     
h  w    w    l  satisfy first     conditions  say pair hw    w 
  l rec resolved  in   
above        l defined eqbf obtained
removing  resp    clauses c  resp  terms   l c  resp 
l    removing l  resp  l  clauses  resp  terms
  
removing q l  prefix 
  l    l            lm  m     defined          l   l          lm  
hw    w    l rec resolved   rec resolve   w    w    l    returns
constraint minimal form  contradicted  satisfied  stated following
lemma 
lemma   let w  w  two clauses  resp  terms  hw    w    lrec resolved eqbf   rec resolve   w    w    l    terminates returns minimal
clause  resp  term 
 contradicted  resp   satisfied  
contain existential literals whose negation  resp  universal literals
been  assigned monotone  
proof  sketch  proof equal  resp  analogous to  proof lemma   l
existential  resp  universal  

procedure q dll ln      incorporates new definitions ideas 
represented figure     considering figure 
definition modelgenerate   relaxed respect definition provided subsection     order return minimal form non contradictory
 satisfied term
   

figiunchiglia  narizzano   tacchella

        
        
  function q dll ln     
 
q    hthe prefix i 
 
   hthe matrix i 
 
 ha  contradicted clause c i 
 
return c 
 
 ha  satisfied term i 
 
return  
 
 hthe matrix emptyi  return modelgenerate   
  
 hl unit  qh    i  i 
  
w    ha constraint causes l unit  qh    i  i 
  
w r    q dll ln      l  
  
 hl existentiali  hw r termi l   w r   return w r 
  
 hl universali  hw r clausei l   w r   return w r 
  
w r    rec resolve qh    i  w r  w  l    
  
learn   w r  
  
return w r 
  
 hl monotone  qh    i  i  return q dll ln      l  
  
l    ha literal highest level i 
  
w r    q dll ln      l  
  
 hl existentiali  hw r termi l   w r   return w r 
  
 hl universali  hw r clausei l   w r   return w r 
  
w r     q dll ln      l  
  
 hl existentiali  hw r  termi l   w r     return w r   
  
 hl universali  hw r  clausei l   w r     return w r   
  
w r    rec resolve qh    i  w r    w r  l    
  
learn   w r  
  
return w r 
figure     algorithm q dll ln 
clause c   c     
universal literal l assigned monotone  l    
learn   w r  updates set goods nogoods according given policy 
simply assume learn   w r  updates     respectively 
    satisfy following conditions 
  subset  w r  w r term  otherwise 
  subset  w r  w r clause  otherwise 
existential  resp  universal  literal l assigned unit initial prefix
    l      resp      still contains clause  resp  term  causes l
assigned unit  qh        i    
   

ficlause term resolution learning quantified boolean formulas

reference figure    last condition necessary order guarantee
existence constraint w satisfying condition line   
conditions learn   w r  general ensure soundness
completeness q dll ln 
theorem    q dll ln     returns empty clause false  empty term
true 
proof  analogous proof theorem    



understand benefits learning  assume input qbf      corresponding
eqbf
x  yx  x  h      x    y  x      y  x      x    x      x    y  x      y  x    x        i 
search proceeds figure    first path leading empty matrix 
starts term resolution process  assuming term min  y  x        y  added
set goods checking value x   y   soon x  assigned true 
detected unit correspondingly assigned 
path corresponding assignment x    explored 
example shows   good  learning avoid useless exploration branches
would explored backtracking backjumping schema  indeed 
assuming deduced term learned backtracking  policy according
learn   w r  simply adds w r
w r clause 
otherwise 
easily implemented  however  simple policy may easily lead store exponential number goods and or nogoods  notice call learn   w r 
literal assigned unit right split   thus  practical implementations incorporate
policies guaranteed space bounded  i e   ones store polynomial number goods
nogoods most  sat  three popular space bounded learning schemes are 
size learning order n  dechter         nogood added
cardinality less equal n  added  never deleted 
relevance learning order n  ginsberg         given current assignment  
nogood c always added   deleted soon number
literals l c l   bigger n 
unique implication point  uip  based learning  marques silva   sakallah        
nogood c stored c contains one literal maximum decision
level  given assignment   decision level literal l number
splits done l   uip based learning  set added clauses
periodically inspected clauses deleted according various criteria 
   

figiunchiglia  narizzano   tacchella

thus  size learning  nogood stored  never deleted  relevance uip
based learning  nogoods dynamically added deleted depending current assignment  see work bayardo        details related size relevance
learning  including complexity analysis   work zhang  madigan  moskewicz
malik        discussion various uip based learning mechanisms sat  size 
relevance  uip based learning various possibilities limiting
number stored clauses  one generalized various ways considering
qbfs instead sat formulas  next section  present particular learning
schema implemented qube 

   implementation experimental analysis
section first describe details implementation nogood good
learning qube  report experimental analysis conducted order
evaluate  separate  benefits nogood good learning  relative efficiency
solver compared state of the art qbf solvers 
    implementation qube
evaluate benefits deriving learning  implemented good nogood learning qube  qube qbf solver based search which  non random
instances  compares well respect state of the art solvers based search 
semprop  letz         yquaffle  zhang   malik      a   i e   best solvers based
search non random instances according  le berre  simon    tacchella        
see  giunchiglia  narizzano    tacchella      c  details 
besides learning  version qube used features
efficient detection unit monotone literals using lazy data structures  gent 
giunchiglia  narizzano  rowley    tacchella        
branching strategy exploits information gleaned input formula initially 
leverages information extracted learning phase 
see  giunchiglia  narizzano    tacchella      b  description characteristics 
learning  computation nogoods goods corresponding internal
nodes search tree carried clause term resolution
working reason initialized backtracking starts  reasons stored
descending search tree
unit literal  stored reason constraint literal unit 
literal assigned right split  stored reason constraint computed
backtracking left branch 
monotone literals  way working reasons initialized ensures existential
 resp  universal  monotone literals never belong working reason computed
backtracking contradiction  resp  solution  
   

ficlause term resolution learning quantified boolean formulas

assume   l    l            lm assignment corresponding leaf consideration  considering problem initializing working reason  way
qube
return  contradicted clause matrix input qbf set learned
nogoods  contradiction 
compute minimal form  satisfied prime implicant matrix contains universal literals possible  solution 
second case  computation prime implicant important order short
reasons  possible universal literals important order backjump
nodes  requirements met recursively removing irrelevant literals
set literals   starting universals ones  given set literals  say
literal irrelevant clause c matrix l c exists another
literal l  l  v
c  prime   set literals result recursive
procedure  term prime  
satisfied  
prime implicant matrix input qbf 
exist another term satisfying first two properties
smaller  under set inclusion  set universal literals 
order reduce number universal literals initial goods  take
advantage fact assignment may partial  literal l may
case neither l l   then  use existential literals  
level lower level universal literals assigned left split 
order reduce number universals prime    fact  sequence  
literals extending existential literals  set universals prime     subset
prime    instance  considering qbf            y    x    x   
prime    y     y    x    x    
extend       x  prime      x    y    x    x    
finally  evaluating universal literals irrelevant  follow reverse
order assigned  order try backjump high possible
search tree 
said previous section  besides problem setting initial working
reason  another problem learning unconstrained storage clauses  resp  terms 
obtained reasons conflicts  resp  solutions  may lead exponential memory
blow up  practice  necessary introduce criteria
   limiting constraints learned  and or
   unlearning them 
   

figiunchiglia  narizzano   tacchella

implementation learning qube works follows  assume backtracking
literal l assigned decision level n  constraint corresponding reason
current conflict  resp  solution  learned following conditions satisfied 
   l existential  resp  universal  
   assigned literals reason except l  decision level strictly lower
n 
   open universal  resp  existential  literals reason l
prefix 
notice three conditions ensure l unit constraint corresponding
reason  qube learned constraint  backjumps node
maximum decision level among literals reason  excluding l  say l
unique implication point  uip  therefore lookback qube uip based 
notice definition uip generalizes qbf concepts first described silva
sakallah        used sat solver grasp  sat instance  qube lookback
scheme behaves similarly   uip learning scheme used zchaff  and described
zhang et al          even qube guaranteed learn one clause  resp  term 
per conflict  resp  solution   still number learned constraints may blow up 
number backtracks exponential  stop course  qube scans periodically
set learned constraints search became irrelevant  i e   clauses  resp 
terms  number open literals exceeds parameter n  corresponding
relevance order  thus  implementation uses uip based learning decide store
constraint  relevance based criteria decide forget constraint 
experimental analysis presented next subsection  parameter n set   
set learned constraints scanned every      nodes 
besides learning mechanism  current version qube features lazy data
structures unit literal detection propagation  as described gent et al         
monotone literal fixing  as described giunchiglia et al       a   variable state independent decaying sum heuristic  vsids   as introduced sat moskewicz  madigan 
zhao  zhang    malik         sat  basic ideas heuristic  i  initially
rank literals basis occurrences matrix   ii  increment weight
literals learned constraints   iii  periodically divide constant weight
literal 
    experimental results
evaluate effectiveness implementation  considered     formal verification planning benchmarks constituted part      qbf solvers comparative
evaluation        instances comes verification problems  described scholl
  becker        abdelwaheb   basin         remaining planning domains  described rintanen        castellini  giunchiglia    tacchella         start
analysis considering qube without learning enabled  versions qube
   respect non random instances used      qbf comparative evaluation  test set
include qbf encodings modal k formulas submitted pan vardi        

   

ficlause term resolution learning quantified boolean formulas

figure     effectiveness learning  qube versus qube cbj sbj   cpu time  left 
number backtracks instances solved solvers  right  

compute goods nogoods order backjump irrelevant existential universal
branching nodes  differ treatment computed goods nogoods 
learning enabled  qube records goods nogoods 
learning disabled  qube records neither nogoods goods 
call two versions qube cln sln  qube cbj sbj  respectively  order
specify type look back used two systems  notice consider
qube backtracking  i e   version computes neither nogoods goods
performs simple chronological backtracking  competitive
solvers 
experiments run farm identical pcs  one equipped
pentium       ghz processor   gb ram  running linux debian  sarge   finally 
system timeout value    s per instance 
figure    left shows performances qube cln sln  versus qube cbj sbj  
plot  x axis cpu time qube cln sln  y axis cpu time
qube cbj sbj   plotted point hx  yi represents benchmark qube cln sln 
qube cbj sbj  take x seconds respectively   convenience  plot
points hx  xi  representing benchmarks solved qube cln sln  x seconds 
first observation learning pays off 
   principle  one point hx  yi could correspond many benchmarks solved qube cln sln 
qube cbj sbj  x seconds respectively  however  scatter diagrams
present  point  except point h        i  representing instances solvers
time out  corresponds single instance cases 

   

figiunchiglia  narizzano   tacchella

figure     effectiveness learning random heuristic  qube rnd cln sln     versus qube rnd cbj sbj      cpu time  left  number backtracks
instances solved solvers  right  

qube cln sln   resp  qube cbj sbj   able solve     resp     instances
solved qube cbj sbj   resp  qube cln sln   
among instances solved solvers  qube cln sln   resp  qube cbj sbj  
least one order magnitude faster qube cbj sbj   resp  qube cln sln  
    resp     instances 
order implementation quality independent measure pruning introduced
learning  right plot figure shows number backtracks  i e   number
solutions conflicts found  qube cbj sbj  versus qube cln sln     
problems solved systems  plotted point hx  yi represents benchmark
solved qube cln sln  qube cbj sbj  performing x backtracks
respectively  seen  learning substantially prunes search space 
point diagonal  meaning never case qube cbj sbj  performs
less backtracks qube cln sln    still  learning overhead  thus
pruning caused learning always pays terms speed  proved
points diagonal left plot 
experimental data entirely satisfactory two reasons 
first  learning heuristic tightly coupled qube  whenever qube learns
constraint  increments score literals it  qube cbj sbj  constraint
   imply tree searched qube cln sln  subtree tree searched
qube cbj sbj   indeed  literal selected branching node two systems guaranteed
same 

   

ficlause term resolution learning quantified boolean formulas

figure     effectiveness conflict learning 
qube rnd cln sln     versus
qube rnd cbj sln      cpu time  left  number conflict backtracks
instances solved solvers  right  

ever learned  consequence  qube cbj sbj    i  literals initially sorted
basis occurrences input qbf   ii  score literal periodically
halved becomes    literals score    literals prefix
level chosen according lexicographic order 
second  independently heuristic used  plot showing performances
qube without learning  say two learning schemes  conflict 
solution  effective  gent   rowley        
address first problem  consider qube random heuristic  i e   heuristic
randomly selects literal among maximum level yet assigned 
call resulting systems qube rnd cln sln  qube rnd cbj sbj  respectively 
names suggest  first learning enabled  second learning
disabled  randomness  run solver   times instance  then 
define qube rnd cln sln  i  system whose performances are 
instance  i th best among   results obtained running qube rnd cln sln 
instance  qube rnd cbj sbj  i  defined analogously 
figure    shows cpu time  left  number backtracks solved instances
 right  qube rnd cln sln     qube rnd cbj sbj      plots  easy
see qube rnd cln sln     faster qube rnd cbj sbj     cases 
witness fact
qube rnd cln sln   resp  qube rnd cbj sbj   able solve     resp     instances solved qube cbj sbj   resp  qube  
   

figiunchiglia  narizzano   tacchella

figure     effectiveness solution learning 
qube rnd cln sln     versus
qube rnd cln sbj      cpu time  left  number solution backtracks instances solved solvers  right  

among instances solved solvers  qube  resp  qube cbj sbj   least
one order magnitude faster qube cbj sbj   resp  qube      resp    
instances 
still  longer case enabling learning always causes reduction number
backtracks  different literals selected branching node 
pruning node may prevent long backjump  prosser      a 
would cause vast reduction search space  interestingly  comparing results
figure     seems random heuristic learning becomes important 
fact witnesses setting well known tension look ahead look back
techniques  smart look ahead makes look back less important  viceversa 
address second problem  considered systems qube rnd cbj sln 
qube rnd cln sbj   i e   systems obtained qube rnd cln sln  disabling
conflict learning solution learning respectively  usual  system run   times
instance  qube rnd cbj sln  i  qube rnd cln sbj  i       
defined before  left plots figures       show performances
qube rnd cln sln     versus qube rnd cbj sln     qube rnd cln sbj     respectively  measured number backtracks  however  order better
highlight pruning due conflict  resp  solution  learning  right plot figure   
 resp      shows number conflict  resp  solution  backtracks qube rnd cbj sln    
 resp  qube rnd cln sbj       plots  see conflict solution
learning prune search space pay off  plot  points
well diagonal  comparing two left plots  see that  test set
   

ficlause term resolution learning quantified boolean formulas

qube rnd cln sln    
qube rnd cln sln    
qube rnd cln sln    
qube rnd cln sln    
qube rnd cln sln    
qube rnd cbj sbj    
qube rnd cbj sbj    
qube rnd cbj sbj    
qube rnd cbj sbj    
qube rnd cbj sbj    
qube rnd cbj sln    
qube rnd cbj sln    
qube rnd cbj sln    
qube rnd cbj sln    
qube rnd cbj sln    
qube rnd cln sbj    
qube rnd cln sbj    
qube rnd cln sbj    
qube rnd cln sbj    
qube rnd cln sbj    

 
   
   
   
   
   
   
   
   
  
   
   
   
   
  
   
   
   
   
   

 
 
 
   
   
   
   
   
   
   
  
   
   
   
   
  
   
   
   
   

 
   
   
 
 
  
  
  
  
  
   
  
  
  
 
   
  
  
  
 


 
 
 
 
  
  
  
  
  
 
  
  
  
  
 
  
  
  
  


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

   
 
 
  
  
  
  
  
  
  
  
  
  
  
  
 
  
  
  
  

    
  
  
 
 
  
 
 
 
 
  
  
 
 
 
  
  
 
 
 


  
  
  
  
  
   
   
   
   
  
  
   
   
   
  
  
   
   
   

table    comparison among various versions qube  row compares system written first column respect qube rnd cln sln     taken reference 
qube rnd cln sln     b solver first column 
columns report number problems that     b solve
time     b solve takes less time b     b solve
takes time b    solves b not    solve
b does      b solve       b solve
least one order magnitude faster        b solve
least one order magnitude slower  to  b solve 
number timeouts qube rnd cln sln        
considered  solution learning helps solving problems conflict learning 
qube rnd cbj sln     times     qube rnd cln sbj     times     
hand  two right plots suggest conflict learning prunes solution learning  conclusion correct  indeed  plot shows either number
conflicts number solutions  pruning node  no matter whether existential
universal  may avoid finding  exponentially many  solutions and or conflicts  particular 
given instances cnf thus form
      yx  x        xn
 n    pruning variable  x    x            xn   potential prune  n conflicts 
   

figiunchiglia  narizzano   tacchella

detailed quantitative information cpu times reported table    last column table see that  indicate to s 
number timeouts system s  then                  
to qube rnd cln sln  i    

to qube rnd cbj sln  i  
  to qube rnd cbj sbj  i   
to qube rnd cln sbj  i  

gives indication capacity solvers  i e   ability solve
problems  order get indication productivity  i e   considering problems
solve  ability solve quickly  consider number fs s 
difference            columns  lower fs s  is  better
is 
fs qube rnd cln sln  i    

fs qube rnd cbj sln  i  
  fs qube rnd cbj sbj  i  
fs qube rnd cln sbj  i  

                 above  clear conflict solution learning
allow improve capacity productivity  experimental results thus seem
contradict negative results reported gents rowleys work        solution
based look back mechanisms  however  results comparable ours  given
different mechanisms implemented respective solvers  e g   computing
initial solution monotone literal fixing   different experimental setting  e g  
testset  

   conclusions related work
paper based extends  giunchiglia et al         introduces nogood
good learning qbfs satisfiability  show correspondence computation trees searched dll based qbf solvers clause term resolution deductions 
nogoods goods clauses terms respectively resolution deductions 
perspective  learning simply amounts storing nogoods goods  show
incorporate nogoods goods learning dll based qbf solvers considering
eqbfs  qbfs extended learning   illustrate means examples
computation nogoods goods 
allows solution conflict directed backjumping spirit  giunchiglia et al  
            
stored  allows pruning branches parts search tree 
present high level description algorithms incorporating ideas  formally
prove soundness completeness  discuss problems related effective
implementations dll based qbf solvers  present  in details  implementation qube  state of the art qbf solver  experimental analysis shows qube
enhanced nogood good learning effective  considering selection
nonrandom problems consisting planning formal verification benchmarks 
show qube competitive respect state art 
   

ficlause term resolution learning quantified boolean formulas

already said  work builds  giunchiglia et al          papers dealing
learning qbfs satisfiability  letz          zhang   malik      a   gent  
rowley         particular   letz        conflict solution learning called lemma
model caching  paper proposes technique based model caching dealing qbfs variable independent subformulas  zhang malik      a  propose
conflict learning  which extended solution learning zhang   malik      b  
second paper  terms called cubes  gent rowley        introduce new form
solution learning  new technique revisits less solutions standard techniques 
experimental results reported paper positive  works share
intuitions thus propose similar techniques  though difficult establish
precise relation among works due differences terminology and or
different level detail presentations   believe main differences
implementation level  i e   way solution conflict learning implemented 
therefore quite difficult impossible compare different alternatives  without
re implementing recasting different learning mechanisms even different solvers
common framework  indeed  specific learning mechanism implemented within
solver may motivated characteristics solver  e g   data structures used heuristic  instance  watched data structures  used  e g  
qube  yquaffle semprop  allow efficient detection propagation unit pure literals  gent et al          consequence  solvers watched
data structures may profitably maintain huge databases goods nogoods  solvers
standard data structures  costs involved managing huge databases may
overwhelm advantages  considering solvers whole  experimental
analysis conducted  giunchiglia et al       c  shows solver qube compares
well respect semprop yquaffle     formal verification planning
benchmarks considered paper 

acknowledgments
would thank ian gent andrew rowley discussions related subject
paper  anonymous reviewers suggestions corrections  work
partially supported miur 

appendix a  proof lemma  
proof well founded induction  thus  steps follow are 
   definition well founded order tuples hc    c    l  i 
   proof thesis holds minimal elements partial order 
   assuming thesis holds tuples hc    c    l  hc    c    l 
hc    c    l  i  proof thesis holds hc    c    l  i 
   instance   letz        zhang   malik      b  initial work  giunchiglia et al  
       method used computing initial working reason corresponding solution  procedure
modelgenerate figure     detailed 

   

figiunchiglia  narizzano   tacchella

deliberately omitted properties elements tuples
hc    c    l  partial order satisfy  indeed  standard assumption would
c  c  two clauses hc    c    l rec c resolved  however 
sufficient  indeed  may happen starting two clauses hc    c 
  l rec c resolved  line numbers refer figure   
   set  l   l c    l c    l universal  empty  see line    
   clause c  computed line   figure     l contradicted  thus
   tuple hc    c    l  element partial order 
better understand problem  consider following simple example 
x  y  x  y  x  x    x      x    y    x      y     x      x        x      x    y    x    x     

    

qbf  
   x    x    y    x    x  assignment producing contradictory clause 
   h x    y    x    x     x        x   i x    x    y    x    x   rec c resolved 
   rec c resolve    x    y    x    x      x        x     x    x    x    y    x    x    
 a  causes call rec c resolve    x    y    y    x      x        x     x    x    x    y    x    x    
clause c     x    y    y    x    x    x    y    x    x   contradicted 
 b  returns clause  y     x    x    x    y    x    x   contradicted  expected 
fact universal literal y  causes c  x    x    y    x    x   contradicted
appear clause returned rec c resolve due following two facts 
   y  lower level blocking literal y   
   negation existential literals c  level lower y  assigned
y  x    x    y    x    x   
formally define notions  need additional notation  first  consider
given clause c    resc   c    set literals c  level lower literal
blocking resolution c  c    formally 
resc   c       l   l c    l  blockingc   c   level l    level l     

literal l  level l  prefix level l 
blockingc     function defined
blockingc   c       l   l c    l c    l universal 
let assignment  say clause c   contradictable  with respect
c   
   

ficlause term resolution learning quantified boolean formulas

   existential literal l c    l  
   universal literal l c    l
 a  l resc   c    
 b  existential literal l  c    level l      level l  l  left l
 
clearly  clause  contradicted  contradictable  considering qbf
      clause  x    y    y    x    x    x    y    x    x   contradicted  x    x    y    x    x  contradictable  with respect  x        x     
well founded order induction set tuples hc    c    l 
c    l contradictable  preliminary step  first define well founded order
literals according l  l   either l    l   l  l  
l  assigned l    i e   l  left l     
extend partial order relation literals clauses  i  minimal form   ii 
containing l   iii    l contradictable  saying two clauses c  c   
c  c 
either c    c   
e
e
e
e
  
 
  
l   rese
c   c    resc   c    l  resc   c    resc   c    l l   resc   c   
subset existential literals resc   c     similarly rese
c   c    

order well founded  minimal elements resc   c   or 
equivalently  blockingc   c   empty 
finally  consider set w tuples hc    c    l 
     l assignment 
   l existential literal either unit highest level  
   c  clause containing l  minimal form   l contradictable respect
c   
   c  contains l  minimal form   l contradicted  further  l unit  
c  clause causes l unit  
set  define well founded order according hc    c    l  hc    c    l 
c  c   
consider procedure rec c resolve figure    prove well founded
induction that  tuple hc    c    l  w   rec c resolve   c    c    l    terminates
returns clause c minimal form  contradicted  end  show
assume c    l contradicted  and simply   l contradictable  
c contain existential literals whose negation assigned monotone
 
base case  c  resc   c    empty  hence  universal literal
l c    l thus c    l contradicted  since resc   c    empty  set
computed line   empty thus rec c resolve   c    c    l    terminates returning
   

figiunchiglia  narizzano   tacchella

resolvent c c  c    clearly c minimal form  easy show c
 contradicted 
step case  induction hypothesis  thesis holds rec cresolve   c    c    l    show holds rec c resolve   c    c    l    
assuming hc    c    l  hc    c    l  i  set resc   c    empty  see base case 
assume resc   c    empty  thus blockingc   c    empty 
on  let l  literal blockingc   c    highest level  l 
l    resc   c    c    l contradictable  l  l  c  c 
  l contradicted  further  level l      level l   see why  consider two possible
cases 
   l unit   since l  c    c  clause causes l unit  
must level l      level l      level l  
   l highest level   since l  l  l highest
level   level l    level l   hand  level l       level l  l 
universal l existential 
since c  minimal form  exists existential literal l   l   c    l  
  level l       level l      level l   on  let l  existential literal
c   not necessarily distinct l     level less equal level
literals c   see line     since
level l      level l      level l 

    

l   because c    l contradictable   follows l  assigned unit 
thus exists clause c causes l  unit         l 
initial prefix  see line    
consider set
blockingc  c       l   l c    l c  l universal  
blockingc  c    empty  fact  universal literal l   c
level l       level l    l     c  since c  minimal form 
level l       level l    l   l    assume l   c    since c    l contradictable 
l  l     however  l   l  l  l   possible l     l    l  existential
l   universal  
since blockingc  c    empty  resolve c c  l    obtaining
c    min  c  c     l    l    
resolvent  c  minimal form contains l 
show c  c  remains showed c    l contradictable  indeed 
existential literal l c    l   universal literals c    consider
two cases 
   

ficlause term resolution learning quantified boolean formulas

   blockingc   c    empty  case  l  blockingc   c     easy
consequence following facts 
 a  literal l   blockingc   c   level l       level l     l   c  definition
blockingc   c   hence l   c    l contradicted  therefore
level l       level l     thus thesis  see       
 b  blockingc   c       blockingc   c   blockingc   c  c  thus  blockingc   c   
blockingc   c     blockingc   c       c c        l    l    c     i e   literals
blockingc   c    blockingc   c  blockingc   c   
omitted minimal form c   
 c  blockingc   c    empty 
since l  blockingc   c     literals resc   c    c    belong
resc   c     i e  
resc   c    resc   c    c   
    
consider universal literal l   c  c    l  
 a  l   resc   c    c    l contradictable  hence l   resc   c   
 see       
 b  existential literal l    c    level l        level l     l    l  
c    l contradictable 
 c  existential literal l       l  c  l    l     fact  level l      level l     
l  l   c    l contradictable  existential literal l       l 
c  l    l   
finally  consider universal literal l   c c    l   level l       level l   
hence
 a  l   resc   c    level l      level l     see       
 b  existential literal l    c    level l        level l     l    c hence
l    l    
   blockingc   c    empty  let lowest among level literals c   
level l      since l    c    then  universal literal l   c    l     i e  
c    l contradicted  fact  assume exists universal literal l   c 
  then  level l       either l   c  l   c  consider first case l   c   
then  l   resc   c    c    l contradictable  level l       level l    
possible level l       level l      m  consider case
l   c  then  level l       level l    hence level l       level l     see      
possible 
since c  c    hc    c    l  hc    c    l  i  conclude induction hypothesis
rec c resolve   c    c    l    returns clause minimal form  contradicted 
   

figiunchiglia  narizzano   tacchella

make assumption input clause c    l contradicted 
then  c  contain existential literals whose negation assigned monotone  holds c  clause c used line    hence  rec cresolve   c    c    l    returns clause without existential literals whose negation
assigned monotone  

references
abdelwaheb  a     basin  d          bounded model construction monadic second order
logics    th international conference computer aided verification  cav    
no       lecture notes computer science  pp         chicago  usa  springerverlag 
bachmair  l     ganzinger  h          resolution theorem proving  robinson  a    
voronkov  a   eds    handbook automated reasoning  vol  i  chap     pp       
elsevier science 
bayardo  jr   r  j     schrag  r  c          using csp look back techniques solve
real world sat instances  proceedings   th national conference artificial intelligence  th innovative applications artificial intelligence conference
 aaai    iaai      pp          menlo park  aaai press 
bayardo  jr   roberto j     miranker  d  p          complexity analysis space bounded
learning algorithms constraint satisfaction problem  proceedings
thirteenth national conference artificial intelligence eighth innovative
applications artificial intelligence conference  pp          menlo park  aaai
press   mit press 
cadoli  m   schaerf  m   giovanardi  a     giovanardi  m          algorithm evaluate
quantified boolean formulae experimental evaluation  journal automated
reasoning             
cadoli  m   giovanardi  a     schaerf  m          algorithm evaluate quantified
boolean formulae  proceedings   th national conference artificial intelligence  aaai       th conference innovative applications artificial
intelligence  iaai      pp          menlo park  aaai press 
castellini  c   giunchiglia  e     tacchella  a          improvements sat based conformant planning  proc  ecp 
castellini  c   giunchiglia  e     tacchella  a          sat based planning complex
domains  concurrency  constraints nondeterminism  artificial intelligence                  
davis  m   logemann  g     loveland  d  w          machine program theorem
proving  communication acm                
de la tour  t  b          minimizing number clauses renaming  proc 
  th conference automated deduction  pp          springer verlag 
dechter  r          enhancement schemes constraint processing  backjumping  learning 
cutset decomposition  artificial intelligence                 
   

ficlause term resolution learning quantified boolean formulas

fermuller  c  g   leitsch  a   hustadt  u     tammet  t          resolution decision procedures  robinson  a     voronkov  a   eds    handbook automated reasoning 
vol  ii  chap      pp            elsevier science b v 
gent  i   giunchiglia  e   narizzano  m   rowley  a     tacchella  a          watched data
structures qbf solvers  giunchiglia  e     tacchella  a   eds    theory
applications satisfiability testing   th international conference  sat       santa
margherita ligure  italy  may           selected revised papers  vol       lecture
notes computer science  pp        springer 
gent  i  p     rowley  a  g          solution learning solution directed backjumping revisited  tech  rep  apes          apes research group  available
http   www dcs st and ac uk apes apesreports html 
ginsberg  m  l          dynamic backtracking  journal artificial intelligence research 
        
giunchiglia  e   narizzano  m     tacchella  a          backjumping quantified boolean
logic satisfiability  proc  international joint conference artificial intelligence  ijcai      
giunchiglia  e   narizzano  m     tacchella  a          learning quantified boolean
logic satisfiability  proceedings eighteenth national conference artificial
intelligence fourteenth conference innovative applications artificial intelligence  july      august          edmonton  alberta  canada  aaai press       
pp         
giunchiglia  e   narizzano  m     tacchella  a          backjumping quantified boolean
logic satisfiability  artificial intelligence             
giunchiglia  e   narizzano  m     tacchella  a       a   monotone literals learning
qbf reasoning  tenth international conference principles practice
constraint programming  cp       pp         
giunchiglia  e   narizzano  m     tacchella  a       b   qbf reasoning real world instances  theory applications satisfiability testing   th international conference  sat       vancouver  bc  canada  may              revised selected papers 
pp         
giunchiglia  e   narizzano  m     tacchella  a       c   qube    efficient qbf solver 
 th international conference formal methods computer aided design  fmcad
      pp         
kleine buning  h   karpinski  m     flogel  a          resolution quantified boolean
formulas  information computation                
le berre  d   simon  l     tacchella  a          challenges qbf arena  sat  
evaluation qbf solvers  sixth international conference theory applications satisfiability testing  sat        vol       lncs  springer verlag 
letz  r          lemma model caching decision procedures quantified boolean
formulas  proceedings tableaux       lnai       pp          springer 
   

figiunchiglia  narizzano   tacchella

marques silva  j  p     sakallah  k  a          grasp   new search algorithm
satisfiability  proceedings ieee acm international conference computeraided design  pp         
moskewicz  m  w   madigan  c  f   zhao  y   zhang  l     malik  s          chaff  engineering efficient sat solver  proceedings   th design automation
conference  dac     pp         
pan  g     vardi  m  y          optimizing bdd based modal solver  automated
deduction   cade       th international conference automated deduction miami
beach  fl  usa  july      august          proceedings  pp       
plaisted  d     greenbaum  s          structure preserving clause form translation 
journal symbolic computation            
prosser  p       a   domain filtering degrade intelligent backjumping search  proceedings   th international joint conference artificial intelligence  ijcai   vol    pp         
prosser  p       b   hybrid algorithms constraint satisfaction problem  computational intelligence                
rintanen  j          constructing conditional plans theorem prover  journal artificial intelligence research             
robinson  a          machine oriented logic based resolution principle  journal
acm               
robinson  a          generalized resolution principle  machine intelligence  vol    
pp        oliver boyd  edinburgh 
scholl  c     becker  b          checking equivalence partial implementations 
proceedings   th design automation conference  dac     pp         
tseitin  g          complexity proofs propositional logics  seminars mathematics    
urquhart  a          complexity propositional proofs  bulletin symbolic
logic                
zhang  l   madigan  c  f   moskewicz  m  w     malik  s          efficient conflict driven
learning boolean satisfiability solver  international conference computeraided design  iccad     pp         
zhang  l     malik  s       a   conflict driven learning quantified boolean satisfiability solver  proceedings international conference computer aided design
 iccad    
zhang  l     malik  s       b   towards symmetric treatment satisfaction conflicts
quantified boolean formula evaluation  proceedings eighth international
conference principles practice constraint programming  pp         

   


