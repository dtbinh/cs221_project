journal of artificial intelligence research                  

submitted        published      

temporal planning using subgoal partitioning and
resolution in sgplan
yixin chen

chen cse wustl edu

department of computer science and engineering
washington university in st louis
st louis  mo       usa

benjamin w  wah
chih wei hsu

wah manip crhc uiuc edu
chsu manip crhc uiuc edu

department of electrical and computer engineering
and the coordinated science laboratory
university of illinois at urbana champaign
urbana  il       usa

abstract
in this paper  we present the partitioning of mutual exclusion  mutex  constraints in
temporal planning problems and its implementation in the sgplan  planner  based on
the strong locality of mutex constraints observed in many benchmarks of the fourth international planning competition  ipc    we propose to partition the constraints of a
planning problem into groups based on their subgoals  constraint partitioning leads to
significantly easier subproblems that are similar to the original problem and that can
be efficiently solved by the same planner with some modifications to its objective function  we present a partition and resolve strategy that looks for locally optimal subplans in
constraint partitioned temporal planning subproblems and that resolves those inconsistent
global constraints across the subproblems  we also discuss some implementation details of
sgplan    which include the resolution of violated global constraints  techniques for handling producible resources  landmark analysis  path finding and optimization  search space
reduction  and modifications of metric ff when used as a basic planner in sgplan    last 
we show results on the sensitivity of each of these techniques in quality time trade offs
and experimentally demonstrate that sgplan  is effective for solving the ipc  and ipc 
benchmarks 

   introduction
in this paper  we present an innovative partition and resolve strategy and its implementation in sgplan  for solving temporal planning problems in pddl     our strategy partitions the mutual exclusion  mutex  constraints of a temporal planning problem by its
subgoals into subproblems  solves the subproblems individually using a modified metric ff
planner  and resolves those violated global constraints iteratively across the subproblems 
we evaluate various heuristics for resolving global constraints and demonstrate the performance of sgplan  in solving the benchmarks of the third  ipc   and the fourth  ipc  
international planning competitions 
most general and popular methods for solving large planning problems  such as systematic search  heuristic search  and transformation methods  can be viewed as the recursive
c
    
ai access foundation  all rights reserved 

fichen  wah    hsu

p 
variable
partitioning
ordered by
heuristic
functions

a

b

c

sp   sa  sb  sc

variables 

a  search space partitioning

a 

                          
                          
                          
                          
                          
                          
                          
                          
                          
                          
                          
                          
                          
                          
                       
                       
                       
                       
                       
                       
                       
                       
                       
                       
                       
                       
a 

a 

b  complete and heuristic searches

figure    search space partitioning branches on variable assignments in order to decompose p into a disjunction    of subproblems with disjoint search spaces  the
complexity of each subproblem is similar to that of p  

partitioning of a search space into independent subproblems and the iterative evaluation
of the subproblems until a feasible solution is found  at each level of application of the
approach  a problem or a subproblem is decomposed by partitioning its variable space into
a disjunction    of subspaces  figure  a   to reduce the search complexity  the approach is
often combined with intelligent backtracking that employs variable value ordering to order
the subproblems generated  that pre filters partial inconsistent assignments to eliminate
infeasible subproblems  and that prunes subproblems using bounds computed by relaxation
or approximation 
search space partitioning can be directly applied on a planning problem or on a transformed version of the problem  direct methods include complete and heuristic searches  as
is illustrated in figure  b  these methods partition a search space recursively by branching
on assigned variables  selection of actions   the difference between a complete search and
a heuristic search is that the former enumerates all subspaces systematically  whereas the
latter prioritizes subspaces by a heuristic function and evaluates them selectively  examples of complete planners include ucpop  penberethy   weld         graphplan  blum
  furst         stan  long   fox         propplan  fourman         system r  lin 
       sipe    wilkins         o plan   tate  drabble    kirby         zeno  penberethy
  weld         talplanner  doherty   kvarnstrm         and shop   nau  muoz avila 
cao  lotem    mitchell         examples of heuristic planners include hsp  bonet  
geffner         ff  hoffmann   nebel         altalt  nigenda  nguyen    kambhampati         grt  refanidis   vlahavas         mo grt  refanidis   vlahavas        
aspen  chien  rabideau  knight  sherwood  engelhardt  mutz  estlin  smith  fisher 
barrett  stebbins    tran         metric ff  hoffmann   nebel         grt r  refanidis
  vlahavas         lpg  gerevini   serina         mips  edelkamp         sapa  subbarao   kambhampati         and europa  jonsson  morris  muscettola    rajan        
in contrast  in a transformation approach  a problem is first transformed into a satisfiability
or an optimization problem  before the transformed problem is solved by a sat or integer
programming solver that employs search space partitioning  notable planners using this
   

fitemporal planning using subgoal partitioning and resolution

     

p 
run time

    

g
a

b

c

   
  
 
   

airport nt   
pipesworld nt nt   

    

sp   sa  sb  sc   sg

 

a  constraint partitioning

 
 
 
 
number of subgoals in a subproblem

b  exponential behavior in solution time

figure    constraint partitioning decomposes p into a conjunction    of subproblems
with disjoint constraints but possibly overlapping search spaces  and a set of
global constraints  g  to be resolved  since the complexity of each subproblem is
substantially smaller than that of p   it leads to an exponential decrease in solution
time by metric ff on two ipc  benchmarks  airport nontemp    and
pipesworld notankage nontemp     when the number of subgoals in
a subproblem is decreased from   to   

approach include satplan  kautz   selman         blackbox  kautz   selman        
ilp plan  kautz   walser         and lpsat  wolfman   weld        
one of the limitations of search space partitioning is that the complexity of a problem
is not dramatically reduced through partitioning  although pruning and ordering strategies can make the search more efficient by not requiring the search of every subspace  the
aggregate complexity of finding a solution to one of the subproblems is the same as that of
the original problem 
in this paper  we study a constraint partitioning approach that decomposes the constraints of a planning problem into a conjunction    of subproblems with disjoint constraints but possibly overlapping search spaces  figure  a   the concept of constraints on
planning problems studied in this paper is precisely defined in section      informally  a
 mutex  constraint refers to the condition under which two actions can overlap with each
other in their execution  since all the constraints must be satisfied  all the subproblems
must be solved in order to solve the original problem 
by decomposing the constraints of a problem into subproblems and by solving each
independently  a subproblem will require significantly less time to solve because it is much
more relaxed than the original problem  as an illustration  figure  b shows the exponential
decrease in solution time when the number of subgoals in a subproblem is reduced linearly 
here  a subgoal is a collection of conjuncts in a conjunctive top level goal of the problem  for
both of the ipc  instances evaluated  the run time is more than      seconds when there
are five subgoals in a subproblem and less than one second when there is one  hence  the
aggregate complexity of solving all the decomposed subproblems is exponentially smaller
than that of the original problem 
   

fichen  wah    hsu

s 

p 

  
  
  
  

  
  
  
  
  
  
  
  
  
  
  
  

   
   
   
   
   
   
   
   
  
  
s 
      
  
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   

  
  
  
  

p 

   
   
   
   

  
  
  
  

  
  
  
  

   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   

s 
  
  
   
   
      
  
   
   
   
   
   

  
  
  
  

p 

  
  
  
  

s 

  
  
  
  

  
  
  
  
  
  
  
  

  
  
  
  

  
  
  
  

figure    partitioning the constraints of a planning problem along its temporal horizon into
three stages requires finding suitable intermediate states s  and s  in order to
connect the subplans in the three stages together  s  and s  are  respectively 
the initial and the final states 

constraint partitioning  however  leads to global constraints across subproblems  sg
in figure  a  that need to be resolved  these global constraints include those that span
across common variables in multiple subproblems  such as those that relate two actions
in different subproblems  since these constraints may not be satisfied after solving the
subproblems independently  the subproblems may need to be solved multiple times in order
to resolve any violated global constraints 
in general  violated global constraints across subproblems cannot be efficiently resolved
by brute force enumeration because the search space for the global constraints is defined
by the cartesian product of the search spaces across the subproblems and is exponentially
large  dynamic programming cannot be applied because global constraints may span across
multiple subproblems  this means that a partial feasible plan that dominates another
partial feasible plan in one subproblem will fail to execute when the dominating plan violates
a global constraint in another subproblem 
to address the resolution of violated global constraints  we summarize in section   the
theory of extended saddle points developed in our previous work  wah   chen         by
choosing a suitable neighborhood  the theory allows a mixed integer nonlinear programming problem  minlp  to be partitioned into subproblems that are related by a necessary
condition on the global constraints  further  a necessary condition on each subproblem
significantly prunes the cartesian product of the search spaces across the subproblems in
which inconsistent global constraints are to be resolved 
in addition to the efficient resolution of violated global constraints  the success of our
approach depends on a strong locality of the constraints with respect to the actions they
relate  we have observed informally in our previous work a strong locality of the constraints  based on this strong locality  we have studied two alternatives for partitioning
the constraints  partitioning them by time  wah   chen        chen   wah        and
partitioning them by subgoals  wah   chen              
the idea of partitioning a planning problem by time is to partition its constraints by
their temporal bindings into stages  to find an overall feasible plan  a planner will need
to find a subplan from the initial to the final states of each stage that satisfy the local as
well as the global constraints  where the final state of one stage will be the initial state of
   

fitemporal planning using subgoal partitioning and resolution

the next stage  for example  after partitioning the horizon into three stages  figure     the
planner assigns some values to the intermediate states s  and s    solves each subproblem
individually  and perturbs s  and s  to look for another solution if feasible subplans cannot
be found in any of the stages 
a major drawback of partitioning a planning problem by its temporal horizon is that
constraint resolutions may have to sequentially propagate through multiple stages  we have
found that the partitioning of the constraints in pddl    benchmarks along their temporal
horizon often leads to many global constraints that only relate states in adjacent stages 
as a result  when a violated subgoal is caused by an incorrect assignment of states in an
early stage of the horizon  the resolution of the incorrect assignment will have to propagate
sequentially through the stages  oftentimes  the propagation of such information may cause
a search to get stuck in an infeasible point for an extended period of time  wah   chen 
       to this end  an expensive enumeration of the final state in each stage  s  and s  in
figure    may be needed in order to resolve the inconsistencies 
a second approach we have studied in our previous work is to partition the constraints
of a planning problem by their subgoals  wah   chen               after evaluating the
subproblems  any inconsistent global constraints among them are first identified  and the
subproblems are re evaluated until all the global constraints are satisfied  partitioning by
subgoals eliminates the need of selecting a final state for each subproblem because the
initial and the final states of each subgoal are known  using this approach  our previous
work has shown improvements in time and quality over the mips planner in solving some
ipc  benchmarks 
with respect to the second approach  we have made four main contributions in this
paper 
first  we quantitatively evaluate in section     the locality of constraints of all ipc 
benchmarks as well as benchmarks from the blocksworld domain and the depots domain 
our results show that constraint partitioning by subgoals consistently leads to a lower
fraction of initial active global constraints than constraint partitioning by time  our results
also explain why constraint partitioning does not work well on some domains  such as
blocksworld and depots 
second  we incorporate metric ff  hoffmann        as our basic planner in sgplan 
and sgplan      instead of mips as in our previous work  wah   chen         this change
is non trivial because it requires significant extensions of metric ff in order to handle the
new features in pddl    beyond those in pddl     these extensions include the support
of temporal planning  the handling of derived predicates and timed initial literals  and the
handling of wrappers for timed initial literals  section      
third  we describe new techniques for improving search efficiency in the global  and
local level architectures of our partition and resolve approach  section       these include
the handling of producible resources  section       subgoal level decomposition using landmark analysis  path finding and path optimization  section       and subgoal level planning
using search space reduction  section       we explain their integration in our planners and
analyze their effectiveness 
last  we study in section     trade offs between solution time and quality in our heuristics for updating the penalties of violated global constraints  these trade offs allow us to
generate plans either of better quality but more time  sgplan       or of lower quality but
   

fichen  wah    hsu

less time  sgplan     the optimization of quality requires the estimation of the makespan
of multiple subplans by an enhanced pert algorithm  section       in our previous work
on constraint partitioning by subgoals  wah   chen         we have focused only on minimizing the planning time  without optimizing quality  violated global constraints are often
easier to resolve because a planner can always delay one or more actions in order to avoid
such constraints  finally  we compare in section   the performance of our planners with
respect to that of other planners 

   locality of mutex constraints in temporal planning
in this section  we define the mutex constraints of planning problems  based on the structure
of these constraints in ipc  benchmarks  we show that constraint partitioning by subgoals
leads to constraints that can be localized better than constraint partitioning by time 
    representation of mutex constraints
by following standard notations and definitions in the literature  hoffmann   nebel       
garrido  fox    long         we summarize in this section the basic definitions of mutex
constraints used in this paper 
definition    a planning problem t    o  f  i  g  is a quadruple  where o is the set of
possible actions in t   f is the set of all facts  i is the set of initial facts  and g is the set
of goal facts 
 

definition    a state s   f         fns is a subset of facts in f that are true 
definition    a strips action a  o is associated with the following attributes 
a  pre a   a set of facts that define the preconditions of action a 
b  add a   a set of facts that define the add effects of a  and
c  del a   a set of facts that define the delete effects of a 
the resulting state of applying action a to state s is defined as 
  s
 s add a   del a  if pre a   s
result s  a   
s
if pre a    s 

   

the resulting state of applying a sequence of actions a         an to s is recursively defined
as 
result s   a         an      result result s   a         an      an   

   

next  we extend our action model to temporal planning  for durative actions supported
in pddl     a precondition fact can be effective at the beginning  at the end  or during the
entire duration of an action  whereas an add effect or a delete effect can be effective only
at the beginning or at the end of an action 
definition    a temporal action a  o is associated with the following attributes 
a  s a  and e a  define  respectively  the start time and the end time of a 
   

fitemporal planning using subgoal partitioning and resolution

action
active mutexes
pre a   

add a   

a 

pre a   

a 

a 

a 
del a   

add a   

a 
a 

a 
del a   

pre a   

del a   

time

figure    an example temporal plan  where active mutexes between actions are shown as
dashed lines  and inactive mutexes as dotted lines 

b  the preconditions can be divided into three types  prestart  a   the set of initial
preconditions to be held at s a   preend  a   the set of final preconditions to be held at e a  
and preoverall  a   the set of invariant preconditions over an open interval  s a   e a   
c  there are two types of add effects  addstart  a   the set of initial add effects to be
asserted at s a   and addend  a   the set of final add effects to be asserted at e a  
d  there are two type of delete effects  delstart  a   the set of initial delete effects to be
asserted at s a   and delend  a   the set of final delete effects to be asserted at e a  
definition    a temporal plan p    a    a         am   is a list of m temporal actions  where
ai has been assigned start time s ai   and end time e ai   
figure   illustrates a temporal plan of seven actions  in each action  we indicate  where
appropriate  its preconditions  add effects  and delete effects 
concurrent actions in a plan must be arranged in such a way that observes mutual
exclusions  mutexes   the notion of mutex was first proposed in graphplan  blum   furst 
       it was defined for a planning graph  which is a level by level constraint graph that
alternates between a fact level and an action level  mutex relationships in a planning graph
can be classified into transient  level dependent  and persistent  level independent   blum
  furst         a mutex is transient if it exists only in certain levels of the graph and
vanishes as more levels of the graph are built  in contrast  a mutex is persistent if it holds
at every level until the fix point level  the last level of the graph  is achieved  in this paper 
we only consider level independent  persistent mutex relationships  as transient mutexes are
exclusively used for searches in graphplan 
actions a and b are marked as persistently mutual exclusive when one of the following
occurs 
   

fichen  wah    hsu

a  actions a and b have persistent competing needs   in which competing needs are
represented by the persistent mutex of the preconditions of a and those of b 
b  they have persistent inconsistent effects  when one action deletes an add effect of
the other 
c  they have persistent interference  when one action deletes a precondition of the other 
two facts p and q are persistently mutual exclusive if all possible ways of making p true
are persistently exclusive with all possible ways of making q true  that is  each action a
having p as an add effect  p  add a   is persistently mutual exclusive with each action
b having q as an add effect  q  add b    for simplicity  in the rest of this paper  mutex
actions and facts refer to the corresponding persistent mutex actions and facts 
given a temporal plan  a mutex relationship can be active or inactive  for example 
actions a  and a  in figure   have an active mutex because the two actions overlap in their
execution and have persistent interference  however  a  and a  have an inactive mutex
because they do not overlap in their execution 
based on the above discussion  the conditions for an active mutex to occur between two
actions a and b can be summarized in four cases  garrido et al         
a  actions a and b start together  and there is a nonempty intersection between their
initial preconditions  resp  add effects  and their initial delete effects  resp  delete effects  
b  actions a and b end together  and there is a nonempty intersection between their
final preconditions  resp  add effects  and their final delete effects  resp  delete effects  
c  action a ends when b starts  and there is a nonempty intersection between the final
delete effects  resp  delete effects  add effects  and preconditions  of a and the initial add
effects  resp  preconditions  delete effects  and delete effects  of b 
d  action a starts  resp  ends  during the execution of b  and there is a nonempty intersection between the initial  resp  final  delete effects of a and the invariant preconditions
of b 
while the conditions above are introduced to prevent two mutually exclusive actions
from executing simultaneously  there may be actions that block the propagation of facts
 no op action  and that cause unsupported actions later  such a condition can be detected
by looking for actions that delete some existing facts in the current plan  with respect to
conditions for mutex due to competing needs  we do not need to represent them explicitly
because mutexes due to competing needs must accompany the other two types of mutex 
when two preconditions are mutually exclusive due to competing needs  the two action
sequences of making them true are also mutually exclusive  as example  the active mutex
between a  and a  in figure   is due to competing needs and is caused by the active mutex
between a  and a   
the mutex constraints studied in this paper are not in closed form  instead  each is
defined by a discrete procedural function that checks if a pair of actions meet one of the four
conditions above  the inputs to the function are the start time and the end time of each
action  which are continuous in temporal problems and discrete in propositional problems 
   the terms competing needs  inconsistent effects  and interference were originally proposed for
graphplan  blum   furst        

   

fitemporal planning using subgoal partitioning and resolution

  
  
  
  

  
  
  
  
  
  
  
  

  
  
  
  

  
  
  
  

  
  
  
  
           
           
  
  
           
           
  
  
           
           
           
           
   
   
           
           
   
   

  
  
  
  

subproblem  

  
  
  
  

  
  
  
  

subproblem  

  
  
  
  
           
           
  
  
           
           
  
  
           
           
           
           
  
  
           
           
  
  

  
  
  
  

  
  
  
  

  
  
  
  

  
  
  
  

  
  
  
  

  
  
  
  

  
  
  
  

  
  
  
  

  
  
  
  
  
  
  
  

  
  
  
  

  
  
  
  
  
  
  
  

  
  
  
  

  
  
  
  

  
  
  
  

subproblem  

  
  
  
  

  
  
  
  

  
  
  
  

  
  
  
  
  
  
  
  

  
  
  
  
  
  
  
  

  
  
  
  

a     mutex constraints among actions b  partitioning the mutex constraints by subgoals
figure    mutex constraints in the ipc  airport temp   instance  each rectangular
box represents an action  and a line joining two actions represents a mutex constraint  that may be inactive   most constraints     out of    or      are local
constraints after partitioning them by subgoals  global mutex constraints are
shown in dashed lines in  b  

    locality of mutex constraints
in this section  we evaluate the partitioning of mutex constraints for some planning benchmarks  our analysis shows the strong locality of these constraints when they are partitioned
by subgoals as compared to the case when they are partitioned by time  we do not study
other criteria for partitioning because they may lead to subproblems whose initial and final states are not specified  such subproblems will be hard to solve by existing planners
because they may require a systematic enumeration of their initial and final states when
finding feasible plans 
figure  a shows the    mutex constraints in a solution plan to the fourth instance of the
ipc  airport temp domain  the instance involves moving three planes in an airport
to designated gates  each rectangular box in the figure represents an action  whereas a line
joining two actions represents a mutex constraint  that may be inactive   figure  b shows
the partitioning of the constraints into three subproblems  each involving the movement of
one plane  we show local constraints  those that are relevant to the actions in one subproblem  in solid lines and global constraints relating those actions in different subproblems in
dashed lines  it is clear that a majority       of the constraints are local after partitioning
them by subgoals 
to demonstrate the localization of mutex constraints when partitioned by subgoals  we
analyze all the ipc  instances  we first modify the original metric ff planner  hoffmann 
      in order to support the new features in pddl     such as temporal actions and derived
predicates  for each instance  we use the modified planner to find an initial subplan for
each of the subproblems  we then find all the mutexes among the actions  including active
and inactive ones  finally  we compute the number of global constraints related to actions
   

firga g

   
   
   
 

   

   
   
   
 

rga g

   
   
   
 

   

rga g

   
   
   
 

                              
instance id

 

rg t
rg g

   

rga g

   
   
   
 
                              
instance id

f  umts temp

   
   
 

 

 

 

   

rg t
rg g

   

rga g

   
   
   
 
 

 

  
  
instance id

g  depots time

  

  

  

   
   
   
 

                    
instance id

   

 
    
instance id

rg t
rg g
rga g

   

                           
instance id

d  satellite time
global constraint fraction

global constraint fraction

d  psr small
   

   

c  promela opticaltelegraph

rg t
rg g

   

rg t
rg g
rga g

   

 

global constraint fraction

b  pipesworld notankagenontemp

rg t
rg g

   

rga g

   

                              
instance id

global constraint fraction

global constraint fraction

   

rg t
rg g

   

                              
instance id

a  airport temp

global constraint fraction

rg t
rg g

   

e  settler
global constraint fraction

   

global constraint fraction

global constraint fraction

chen  wah    hsu

  

   

rg t
rg g

   

rga g

   
   
   
 
 

 

  
  
instance id

  

  

h  blocksworld

figure    variations of rg t   rg g   and rga g across the instances of seven ipc  domain
variants as well as the instances of the depots time domain variant from
ipc  and those of the blocksworld domain from ipc    the latter two domains
are deemed difficult for constraint partitioning  

in different subplans  as well as the number of initial active global constraints based on the
subplan evaluated for each subproblem  as a comparison  we also evaluate the partitioning
of the constraints by their temporal horizon 
figure   illustrates the results for seven ipc  domain variants  as well as the blocksworld
domain from ipc  and the depots time variant from ipc   table   further summarizes
the average statistics across all the instances in each ipc  domain variant and those of the
blocksworld domain and the depots domain variants  for each instance in partitioning
by time  we use the modified metric ff planner to find an initial plan  set the number of
temporal stages to be the same as the number of subgoals  and partition the horizon of the
solution plan evenly into multiple stages  we then count the number of local constraints
in each stage and the number of global constraints relating actions in different stages  for
each instance  let nc be the total number of mutex constraints  ngt be the number of global
constraints under constraint partitioning by time  ngg be the number of global constraints
   

fitemporal planning using subgoal partitioning and resolution

table    average rg t   rg g   rga g across the instances of ipc  domains as well as the depots
domain from ipc  and the blocksworld domain from ipc    the latter two are
deemed difficult for constraint partitioning   boxed numbers are less than     
domain variant

r g t

r g g

airport nontemp
airport temp
airport temp timewindows
airport temp timewindows co
pipesworld notankage nontemp
pipesworld notankage temp
pipesworld notankage temp deadline
pipesworld tankage nontemp
pipesworld tankage temp
pipesworld notankage temp deadline co
promela optical telegraph
promela optical telegraph dp
promela optical telegraph fl
promela philosopher
promela philosopher dp
promela philosopher fl
psr small
psr middle
psr middle co
psr large
satellite strips
satellite time
satellite time timewindows
satellite time timewindows co
satellite numeric
satellite complex
satellite complex timewindows
satellite complex timewindows co
settlers
umts temp
umts temp timewindows
umts temp timewindows co
umts flaw temp
umts flaw temp timewindows
umts flaw temp timewindows co
depots strips
depots simpletime
depots numeric
depots time
blocksworld

     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     

     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
      
     
     
     
     
     
     
     
     

   

r
 ga g
      
      
      
      
      
      
      
      
     
      
      
      
      
      
      
      
     
      
      
      
      
      
      
      
      
      
      
      
     
      
      
      
      
      
      
     
     
     
     
     

fichen  wah    hsu

g be the number of initial active global
under constraint partitioning by subgoals  and nga
constraints under constraint partitioning by subgoals  we then compute the following ratios 

ngt
  fraction of global constraints under constraint partitioning by time 
nc
ngg
rg g  
  fraction of global constraints under constraint partitioning by subgoals 
nc
g
nga
rga g  
  fraction of initial active global constraints under subgoal partitioning 
nc

rg t  

with respect to instances in the ipc  domains  the results show that constraint partitioning by subgoals leads to a lower rg g than rg t   that the fractions do not vary significantly 
and that rga g is small for most instances  except for psr small and settlers  rga g
is consistently less than      this behavior is important because only active constraints will
need to be resolved during planning  and the number of such constraints should decrease
as planning progresses  we describe in section     two strategies for reducing the number
active global constraints in planning 
the behavior is worse for the instances in the blocksworld domain and the depots domain variants  in these two domains  rga g is consistently high  over      when constraints
are partitioned by subgoals  the reason is that the actions in different subgoals of each
instance are highly related  making it more difficult to cluster the constraints and leading
to a larger fraction of global constraints  we evaluate the performance of our approach on
these two domains in section   

   constraint partitioning using penalty formulations
given a constrained formulation of a planning problem  we summarize in this section our
theory of extended saddle points in mixed space  wah   chen        that the design of
our planners is based upon 
    the extended saddle point condition
consider the following minlp with variable z    x  y   x  rv and y  dw  
 pm    

min
z

subject to

f  z  

   

h z      and g z     

where f is continuous and differentiable with respect to x  and g    g            gr  t and h  
 h            hm  t are general functions that are not necessarily continuous and differentiable 
these assumptions are important because the constraints in our planners are procedural
functions not in closed form  we further assume that f is lower bounded  while g and h
can be unbounded 
the goal of solving pm is to find a constrained local minimum z     x   y    with
respect to nm  z     the mixed neighborhood of z    because the results have been published
earlier  wah   chen         we only summarize some high level concepts without the
precise formalism 
   

fitemporal planning using subgoal partitioning and resolution

a mixed neighborhood nm  z   z    x  y   in mixed space rv  dw is 




fi 
fi

 fi 
fi
   
nm  z     x   y  x  nc  x    x  y   y  nd  y   

definition   

where nc  x     x   kx  xk   and      is the continuous neighborhood of x  and the
discrete neighborhood nd  y  is a finite user defined set of points  y   dw   
definition    point z  is a clmm   a constrained local minimum of pm with respect to
points in nm  z     if z  is feasible and f  z     f  z  for all feasible z  nm  z    
definition   

the penalty function of pm with penalty vectors   rm and   rr is 
lm  z        f  z    t  h z      t max    g z   

   

next  we define informally a constraint qualification condition needed in the main theorem  wah   chen         consider a feasible point z     x   y    and a neighboring point
z     x   p   y    under an infinitely small perturbation along direction p   x in the x subspace  when the constraint qualification condition is satisfied at z    it means that there is
no  
p such that the rates of change of all equality and active inequality constraints between
z  and z  are zero  to see why this is necessary  assume that f  z  at z  decreases along p  and
that all equality and active inequality constraints at z  have zero rates of change between z 
and z    in this case  it is not possible to find some finite penalty values for the constraints
at z  in such a way that leads to a local minimum of the penalty function at z  with respect
to z    hence  if the above scenario were true for some p  at z    then it is not possible to
have a local minimum of the penalty function at z    in short  constraint qualification at
z  requires at least one equality or active inequality constraint to have a non zero rate of
change along each direction  
p at z  in the x subspace 
theorem    necessary and sufficient espc on clmm of pm  wah   chen        
assuming z   rv  dw of pm satisfies the constraint qualification condition  then z  is a
clmm of pm iff there exist finite     and      that satisfies the following extended
saddle point condition  espc  
lm  z         lm  z            lm  z        

   

for any     and       and for all z  nm  z       rm   and   rr  
note that     can be satisfied under rather loose conditions because it only requires
any  and   that are larger than some critical  and     the theorem is important
because it establishes a one to one correspondence between a clmm z  of pm and an esp
 extended saddle point  of the corresponding unconstrained penalty function in     when the
penalties are sufficiently large  the theorem also leads to an easy way for finding clmm  
since an esp is a local minimum of      but not the converse   z  can be found by gradually
increasing the penalties of those violated constraints in     and by repeatedly finding the
local minima of     until a feasible solution to pm is obtained  this is possible because
there exist many algorithms for locating the local minima of unconstrained functions 
   

fichen  wah    hsu

    the partitioned extended saddle point condition
an important feature of the espc in theorem   is that the condition can be partitioned
in such a way that each subproblem implementing a partitioned condition can be solved by
looking for any  and   that are larger than  and    
consider pt   a version of pm whose constraints can be partitioned into n subproblems 
 pt    

min
z

subject to
and

j z 
h t   z t       
h z      

g t   z t     
g z    

 local constraints 

   

 global constraints  

subproblem t  t              n   of pt has local state vector z t     z   t           zut  t  t of ut
mixed variables  where n
t   z t    z  here  z t  includes all variables that appear in any of
 t 
 t 
the mt local equality constraint functions h t     h            hmt  t and the rt local inequal t 
 t 
ity constraint functions g t     g            grt  t   since the partitioning is by constraints 
z             z n   may overlap with each other  h    h            hp  t and g    g            gq  t
are global constraint functions of z  we assume that j is continuous and differentiable with
respect to its continuous variables  that f is lower bounded  and that g  h  g  and h are
general functions that can be discontinuous  non differentiable  and unbounded 
we first define np  z   the mixed neighborhood of z for pt   and decompose the espc
in     into a set of necessary conditions that collectively are sufficient  each partitioned
condition is then satisfied by finding the local esp of a subproblem  and any violated global
constraints are resolved by using appropriate penalties 
np  z   the mixed neighborhood of z for a partitioned problem  is 

n
n  fi
 
 
fi
 t 
 fi 

np  z   
np  z   
  z t   
z fi z  t   nm  z t   and zi   zi zi 

definition   

t  

   

t  

where nm  z t   is the mixed neighborhood of z t  

intuitively  np  z  is separated into n neighborhoods  where the tth neighborhood perturbs only the variables in z t  while leaving those variables in z z t  unchanged 
without showing the details  we can consider pt as a minlp and apply theorem   to
derive the espc of pt   we then decompose the espc into n necessary conditions  one for
each subproblem  and an overall necessary condition on the global constraints across the
subproblems  we first define the penalty function for subproblem t 
definition     let  z         t  h z    t max    g z   be the sum of the transformed
p
global constraint functions weighted by their penalties  where                 p  t  r and
q
                q  t  r are the penalty vectors for the global constraints  then the penalty
function for pt in     and the corresponding penalty function in subproblem t are defined
as follows 

n 
x
t  t 
t
 t 
lm  z            j z   
 t   h  z t       t  max    g  z t     z          
t  

m  z   t    t         j z     t t  h t   z t       t t max    g t   z t       z           
   

fitemporal planning using subgoal partitioning and resolution

m

where  t        t           mt  t  t  r t and  t        t           rt  t  t  r
penalty vectors for the local constraints in subproblem t 

rt

are the

theorem    partitioned necessary and sufficient espc on clmm of pt  wah   chen 
       given np  z   the espc in     can be rewritten into n     necessary conditions that 
collectively  are sufficient 
m  z     t    t            m  z     t     t             m  z   t     t                 
lm  z                lm  z                       

for any  t     t       t     t               and          and for all
m
r
p
q
 t 
z  np  z      t   r t    t   r t     r     r   and t              n  
theorem   shows that the original espc in theorem   can be partitioned into n necessary conditions in      and an overall necessary condition in      on the global constraints
across the subproblems  the partitioned condition in subproblem t can be satisfied by
finding the esps in that subproblem  because finding an esp is equivalent to solving a
minlp  we can reformulate the search in subproblem t as the solution of the following
optimization problem 


 t 
pt
j z     t  h z      t max    g z  
    
 
min
z t 

subject to

h t   z t      

and g t   z t      
 t 

the weighted sum of global constraint functions in the objective of pt is important because
it leads to points that minimize the violations of global constraints  when  t and  t are
 t 
large enough  solving pt will lead to points  if they exist  that satisfy the global constraints 
in short  finding solutions of pt that satisfy     can be reduced to solving multiple
subproblems  where      can be solved by an existing solver with some modifications of the
objective function to be optimized  and to the reweighting of violated global constraints
defined by      
    formulation of partitioned planning subproblems in pddl   
for a pddl    planning problem solved in this paper  a solution plan is specified by the
start time and the end time of each action a  o  hence  its variable vector is z  
 s a   e a  where a  o   its objective function j z  optimized depends on the makespan
 or the number of actions for propositional domains  of plan z  and its constraints are the
mutex constraints defined in section     


h ai   aj     mutex s ai    e ai    s aj    e aj       
ai   aj  o 
    
here  mutex is a binary procedure for checking whether ai and aj satisfy the mutex conditions defined in section      it returns one if the conditions are satisfied and zero otherwise 
when the constraints are partitioned by their subgoals into n subproblems g         gn  
variable z is partitioned into n subsets z          z n    where z t  includes the start time
   

fichen  wah    hsu



   

pt

x
lm z           to find   and  

 minz    j z     t  h z      t max    g z  
 
subject to h    z         and g     z       



 n 
pt

t
t
 minz n  j z      h z      max    g z  
 
subject to h n   z n        and g  n   z n      

a  partitioned search to look for points that satisfy      and     
   procedure partition and resolve pt  
  
         
  
repeat
   increase the penalties of violated global constraints until maximum bounds i and i   
  
for i     to p do if  hi  z       and i   i   then increase i by  end if end for 
  
for j     to q do if  gj  z     and j   j   then increase j by  end if end for 
   inner loop for solving the n subproblems   
  
for t     to n do apply an existing solver to solve      end for 
  
until   i   i for all hi  z       and j   j for all gj  z      or  a clmm of pt is found  
   end procedure

b  implementation for finding a clmm of pt that satisfies      and     
figure    the partition and resolve procedure to look for a clmm of pt  

and the end time of those actions of gt   the local constraints are those mutex constraints
that relate the actions within a subproblem  and the global constraints are those that relate
the actions across subproblems 
 t 
for pt defined for gt   the objective is to find a feasible plan z t  that satisfies the
constraints for gt   while minimizing an objective function biased by the violated global
constraints 


 t 
pt
 

min
z t 

subject to

j z   

n
x
k  
k  t

t k  mt k

h t   ai   aj      

    

ai   aj  z t  

where j z  is defined later in section      here  mt k is the number of global constraints
between the actions in z t  and those in z k  
mt k  

x

h at   ak   

    

at z t 
ak z k 
k  t

to limit the number of penalties while characterizing the priorities among the subproblems 
we have assigned a single penalty t k for each pair of subproblems gt and gk   instead of a
penalty for each global constraint between gt and gk  
   

fisubgoal level planning

global level planning

temporal planning using subgoal partitioning and resolution

plan
evaluation

techniques
studied

penalty value
update strategy

globalconstraint
resolution

global constraints on subgoals

g 

p   

g 

producible
resources
gn

pn  

p  c 

pn cn

constraint
partitioning
by subgoals

landmark
analysis

temporal
engine
modified metricff

derived
predicates
engine

temporal
engine

derivedpredicates
engine
searchspace
reduction

searchspace
reduction

figure    sgplan    a planner implementing the partition and resolve procedure in figure   

    the partition and resolve procedure
figure   presents the partition and resolve procedure for finding points that satisfy the
conditions in theorem    using fixed  and  specified in the outer loop  the inner loop
of subproblem t in figure  b solves      by an existing solver  which results in an esp
that satisfies       this is possible because      is a well defined minlp  after solving the
n subproblems  the penalties on the violated global constraints are increased in the outer
loop  the process is repeated until a clmm to pt has been found or when  and  exceed
their maximum bounds 
the procedure in figure   may generate fixed points of     that do not satisfy      and
      this happens because an esp is a local minimum of      but not the converse   one
way to escape from such fixed points is to allow periodic decreases of  and   the goal of
these decreases is to lower the barrier in the penalty function in order for local descents
in the inner loop to escape from an infeasible region  note that  and  should be decreased
gradually in order to help the search escape from such infeasible regions  once  and 
reach their minimum thresholds  they can be scaled up  and the search is repeated 
   

fichen  wah    hsu

   system architecture of sgplan 
figure   shows the design of sgplan  that implements the partition and resolve procedure 
the procedure alternates between global level planning and subgoal level planning  in this
section  we describe those techniques implemented in the global level  while leaving the
discussion of techniques in the subgoal level to the next section 
    the partition and resolve process in sgplan 
at the global level  sgplan  partitions a planning problem into n subproblems  g         gn  
where gt corresponds to the tth subgoal  it then orders the subproblems  evaluates each
using techniques in subgoal level planning  identifies those violated global constraints  and
updates their penalties in order to bias the search in the next iteration towards resolving
them  in sgplan    we have adopted an implementation in lpg     gerevini   serina 
      for detecting persistent mutexes 
the partition and resolve process can be understood as calculating subplans separately
and then merging them into a consistent plan  its goals are to optimize multiple subplans
and to ensure their consistency after merging  prior work on plan merging focuses on
merging redundant actions and on finding an optimal composed plan  in particular  foulser 
li  and yang        have developed algorithms for merging feasible classic plans into more
efficient ones  a complete evaluation on plan merging algorithms for classical domains has
been conducted by yang         tsamardinos  pollack  and horty        have extended
the concept to domains with temporal constraints  because plan merging is not a means
for making an infeasible plan feasible  it is different from our approach that aims to resolve
inconsistencies in terms of mutexes among subplans 
an alternative view about our resolution approach is the reuse and modification of
subplans into a consistent plan  plan reuse systems adapt existing plans into new initial states and goals  the approach is demonstrated in spa  hanks   weld        and
priar  kambhampati   hendler        that show improvements in efficiency in many
domains  the major difference between current plan reuse approaches and our partitionand resolve process is that we generate candidate subproblems based on the partitioning
of mutex constraints  whereas traditional methods reuse plans that are generated by other
means  since the assumption of conservative plan modification in existing methods is not
always achievable  it may be necessary to replan if a feasible plan candidate cannot be
found  in some cases  it may be more expensive than planning from scratch  this is the
reason why complexity analysis and empirical study cannot prove plan reuse approaches
to have consistent improvements over planing from scratch  nebel   koehler         in
contrast  our approach augments the search of each subproblem by explicitly penalizing
global inconsistencies and by forcing its solution towards resolving the global constraints 
our partition and resolve approach is different from incremental planning  koehler  
hoffmann        that uses a goal agenda  in incremental planning  a planner maintains
a set of target facts  adds goal states incrementally into the target set  and extends the
solution by using the new target set  because a goal state must always be satisfied once
it has been achieved  the ordering of goal states is important in order to avoid un doing
a previously achieved goal state when planning the current goal state  if invalidations do
occur  then the planning task at that point is more complex than just the planning of one
   

fitemporal planning using subgoal partitioning and resolution

goal state  in contrast  sgplan  tries to achieve only one subgoal at a time and allows
other subgoals to be invalidated in the process  moreover  for each subgoal  we do not need
to start from the ending state of the previous subgoal as in incremental learning  and there
is no need to pre order the subgoals in order to avoid invalidations  we show in section  
that the performance of sgplan  is not sensitive to the order of evaluating the subgoals 
    resolving violated global constraints
in this section  we present two penalty update strategies for resolving violated global constraints  these constraints are identified after finding a subplan for each subproblem independently 
sgplan  first initializes the penalties of all global constraints when it starts  in the first
iteration  sgplan  solves each subproblem individually  without considering their global
constraints  it then combines all the subplans into an integrated plan in order to determine the initial active global constraints across the subproblems  in subsequent iterations 
sgplan  finds a local feasible plan for each subproblem  while minimizing the global objective and the weighted sum of violated global constraints  at the end of each iteration 
sgplan  increases the penalty of a violated global constraint in proportion to its violation 
the process ends when all the constraints are satisfied 
we have designed two strategies for updating the penalty of global constraints  the
sgplan  that participated in ipc  sets very large initial penalty values and updates them
by rate   whereas sgplan    studied in this paper sets the initial penalty values to zero 
 
    for sgplan   
   
  
   
t k  
t k   t k     mt k  
              
    
 
 for sgplan      
  

here  t k is the penalty for the global constraints between gt and gk in the th iteration 
mt k is as defined in          is a large initial value  and  is a parameter for controlling the
rate of penalty updates  in our experiments  we set          and        
figure   illustrates the planning process of sgplan  on the airport temp    instance  given the three subproblems in this instance  sgplan  first evaluates each subproblem once in the first iteration in order to determine the initial active global constraints  the
figure shows  respectively  the subplans and the active global constraints after evaluating
each of the three subproblems in the second iteration  the strategy is effective for reducing
the number of active global constraints quickly from    in the beginning to zero in just one
iteration 
the penalty update strategy in sgplan  may lead to longer makespans because it uses
large initial penalty values in order to reduce the number of violated global constraints
quickly  hence  the subplans found may have poor temporal concurrency  to address this
issue  we have implemented a new strategy for sgplan    in      that sets the initial penalty
values to zero 
figure    illustrates the time quality trade offs of sgplan  and sgplan    when used to
solve nine representative instances of the ipc   the blocksworld  and the depots domains 
because the number of active global constraints changes after evaluating each subproblem 
we plot the progress on the remaining number of active global constraints with respect
to the total number of subproblems evaluated  the results show that both planners can
   

fichen  wah    hsu

 
 
 
   
 
   
 
 
 
 
  
 
 
 
 
 
 
 
 
  
 
 
 
 
  
 
 
 
 
 
 
 
 
 
  
 
   
 
 
 
 
 
 
 
 
 
 
 
 

g 

 
 
 
 
   
 
 
   
 
 

g 

 
 
 
 

 
 
 
 

 
 
 
 

 
 
 
 

  
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
 
 
 
  
 
 

 
 
 
 

 
 
 
 

 
 
 
 
 
 
 
 

 
 
 
 
   
 
 

 
 
 
 

 
 
 
 

g 

 
 
 
 
 
 
 
 

 
 
 
 

a  at the start of iteration  
 
 
 
   
 
   
 
 
 
 
 
 
 
 
 
 
   
 
 
 
   
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  
 
   
 
 
 
 
 
 
   
 
 
 
 
 
 
 
 

 
 
 
 

 
 
 
 

 
 
 
 

 
 
 
 
 
 
 
 
  
 
 

 
 
 
 

 
 
 
   
 
 
 
 
 
 
 

 
 
 
 

 
 
 
 

 
 
 
  
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 

 
 
 
 

 
 
 
 
 
 
 
 

 
 
 
 

 
 
 
 

 
 
 
 

 
 
 
 

 
 
 
 

 
 
 
 
 
 
   
 
 
 
 

 
 
 
   
 
   
 
 
 
 
 
 
 
 
 
   
 
  
 
   
 
 
 
  
 
 
 
 
 
 
 
 
 
  
 
   
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 

 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
   
 
 
   
 
 
  
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
 
 
  
 
 
 

 
 
 
 

 
 
 
 

 
 
 
 
 
 
 
 

 
 
 
 
   
 
 

g 

 
 
 
 
 
 
   
 
 
 
 
 
 
 
 

g 

 
 
 
 

 
 
 
 
 
 
 
 

 
 
 
 

 
 
 
 

g 

b  after solving subproblem g 
 
 
 
   
 
   
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  
 
 
 
 
  
   
 
 
  
 
   
 
 
 
 
 
 
   
 
 
 
 

g 

g 

 
 
 
 
 
 
   
 
 
 
 

 
 
 
 

 
 
 
 

 
 
 
 

 
 
 
 

g 

 
 
 
 

c  after solving subproblem g 

 
 
 
 
 
 
 
 
  
 
 

 
 
 
 

 
 
 
   
 
 
 
 
 
 
 

 
 
 
 

 
 
 
 

 
 
 
  
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 

 
 
 
 

 
 
 
 

 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 

g 

g 

 
 
 
 
 
 
   
 
 
 
 
 
 
 
 

g 

 
 
 
 

d  after solving subproblem g 

figure    the planning process of the ipc  version of sgplan  in the second iteration in
solving the airport temp    instance  each box corresponds to an action
in a subplan  whereas each arrow corresponds to an active global constraint  by
placing more emphasis on violated global constraints  the number of violated
constraints is quickly reduced at the expense of a longer makespan 

resolve the remaining number of active global constraints in almost a linear fashion  and
that sgplan  is generally faster for resolving the active global constraints but generates
plans of worse quality  in our detailed experimental results in section    we show that
sgplan    generally leads to plans of better quality 
both planners  however  have difficulty when solving the pipesworld notankagetemp deadline    instance  figure   c   for this domain  sgplan  cannot solve any
instances  whereas sgplan    can solve eight instances                         and      although the fraction of initial active global constraints out of all constraints is only     
on average  table     both planners may get stuck at some infeasible solutions and cannot make progress afterward  the reason is that the basic planner in both sgplan  and
sgplan    does not have enough backtracking to generate new candidate subplans for each
subproblem  hence  the basic planner keeps generating the same subplan at some point 
regardless of how the violated constraints are penalized 
    handling producible resources
in some planning problems  there may be facts that can be made true and numerical
resources that can be produced anytime when needed  for example  in the settlers domain 
   

fi  
  
 
 

  

sgplang  q       
sgplang   q       

  
  
  
  
  
 

                               

 

total   of subproblems evaluated

   
  
 
  

  

  

  

  

   
  
  
  
  
  
  
  
  
  
 

  

  
 
 
 
 
 
  

  

  

  

total   of subproblems evaluated

g  umts temp   

  

  

 

  

  

  

  

  

  

  

total   of subproblems evaluated

  

  
  
  
  
  
  
  
  
 
 

sgplang  q        
sgplang   q        

                             

total   of subproblems evaluated

total   of subproblems evaluated

e  satellite time   
  of active global constraints

  of active global constraints

sgplang  q         
sgplang   q        

  

  

                                

d  promela opticaltelegraph   
  

  

sgplang  q        
sgplang   q        

total   of subproblems evaluated

  

  

  of active global constraints

  of active global constraints

  of active global constraints

   

  

  

sgplang  q n a 
sgplang   q n a 

total   of subproblems evaluated

sgplang  q        
sgplang   q        

   

  

  
  
  
  
  
  
  
  
  
 
 

b  pipesworld notankage  c  pipesworld notankagenontemp   
temp deadline   

a  airport temp   
   

  of active global constraints

sgplang  q        
sgplang   q        

  

  

  of active global constraints

  

  of active global constraints

  of active global constraints

temporal planning using subgoal partitioning and resolution

sgplang  q       
sgplang   q       

  
  
  
  
  
  
 
  

  

  

  

  

total   of subproblems evaluated

h  blocksworld     

  

f  settlers   
   
   
   
   
   
   
  
  
  
  
 

sgplang  q        
sgplang   q        

  

  

  

  

  

  

  

total   of subproblems evaluated

i  depots time   

figure     resolution of active global constraints in nine benchmark instances by the original penalty update strategy in sgplan  and the new penalty update strategy
in sgplan      the x axis includes the number of subproblems evaluated  each
corresponding to a subgoal  in the first iteration in order to determine the initial
active global constraints 

coal can always be produced in a mine  we define these producible logical and numerical
resources as follows 
a  a fact is producible if it is an add effect of either an action without preconditions or
an action whose preconditions are always producible 
b  a numerical resource is producible if it is increased by either an action without
preconditions or an action whose preconditions are always producible 
the planning tasks will be significantly easier if producible facts and resources can
be detected in the preprocessing phase and be made available during planning  by first
identifying all those facts and resources  sgplan  derives a relaxed initial state by setting
all producible facts to be true and all producible numerical resources to be large enough 
every time a producible fact is turned false  it is made true again  after finding a feasible
plan from the relaxed initial state  sgplan  removes the unused numerical resources in the
   

fichen  wah    hsu

initial state and plans again  the process is repeated until there are no redundant initial
resources  at that point  sgplan  inserts the necessary actions at the beginning of the plan
to generate the minimum initial producible resources needed 
for example  suppose timber is detected to be a producible resource as one can always
fell some trees to get more timber  sgplan  will initially set a large number  say      units 
of timber available  after solving the problem  suppose there are     units left unused  it
reduces the initial timber to     units and plans again  this process is repeated until
either there is no unused timber at the final state or the problem becomes unsolvable after
reducing the initial resource 
note that the approach may incur some redundant actions for producing unused resources  as the optimal amount of resources needed cannot be predicted ahead of time 

   subgoal level planning
at the subgoal level  sgplan  applies landmark analysis to further partition a subproblem 
performs path finding and optimization  carries out subspace reduction analysis to prune
irrelevant facts and actions in the subproblem  and calls a modified metric ff planner to
solve the subproblem 
    subgoal level decomposition techniques
a  landmark analysis  first proposed by porteous  sebastia  and hoffmann  porteous 
sebastia    hoffmann         landmark analysis allows a large planning problem to be
decomposed into a series of simpler subproblems  given the initial state  it aims to find
some intermediate facts that must be true in any feasible plan for reaching the goal state 
for example  assume that object o is to be delivered from a to d  and that the only path
from a to d is a  b  c  d  then at  o  b  and at  o  c  are both landmark facts 
since any feasible plan must make them true before reaching goal state at  o  d  
because a planning problem is first partitioned by its subgoals into subproblems  we
only apply landmark analysis on each subproblem in order to find the intermediate facts for
reaching the corresponding subgoal  landmark analysis is important in sgplan  because
it allows each subproblem to be further decomposed into simpler subproblems that can be
solved easily 
in each subproblem  we find landmarks by a relaxed planning approach  given a planning subproblem t    o  f  i  g   we first construct a relaxed planning graph from the
initial state i by ignoring the delete effects of actions  we force each f  f in each level of
the graph to be false  even if it were made true by some actions   as a result  all the actions
preconditioned by f will be pruned  if there exists a goal fact in g that cannot be reached
when f is false  then f is a landmark fact and must be reached in any plan for the relaxed
problem  after finding the partial order of the landmarks  sgplan  builds a sequential
list of subproblems joined by the landmarks found and applies the basic planner to solve
each subproblem in order  note that because landmark analysis is expensive  sgplan  only
detects landmarks once at the beginning and not in every iteration 
the landmarks found in the relaxed planning graph are necessary because any solution
plan of the original problem is also a solution plan of the relaxed problem  hence  any
feasible plan for the original problem must reach each landmark found by the relaxed ap   

fitemporal planning using subgoal partitioning and resolution

initial state
on b   a  

on b  a  

last b   s   

on b  a  

on b  a  

on b   a  

last b  s   
first b  s   

last b   s   

on b  a  

on b  a  

last b  s   

last b  s   

last b  s   

on b   a  

on b  a  

last b  s   

on b   a  

on b  a  

on b  a  

first b  s   

first b   s   

on b   a  

first b   s   

on b  a  

on b  a  

on b  a  

on b   a  

first b  s   

on b  a  

on b  a  

on b  a  

goal state

figure     landmarks and their partial orders for the pipesworld notankagenontemp    instance 
proach at least once  however  the landmarks found are not sufficient because we test goal
reachability by a relaxed approach  and there may exist some undetected landmarks even
when every fact has been tested 
figure    shows all the landmarks found in the ipc  pipesworld notankagenontemp    instance  when considering the first goal fact on  b    a    last  b    s   
is not only its landmark but also the landmarks for on  b    a   and f irst  b    s    
this means that last  b    s    must be ordered before on  b    a   and f irst  b    s    
in this way  we can decompose the subproblem for on  b    a   into   smaller tasks that
must be carried out in sequence  namely  last  b    s     on  b    a    f irst  b    s    
and on  b    a   
b  landmarks identified by path finding  landmark analysis may sometimes produce
very few landmark facts for decomposing a subproblem  for example  most of the gates
along a path in an airport instance will not be identified as landmark facts  that is 
must visit points  because there are usually multiple paths for the given source and destination  consider the airport topology in figure   a in which the goal is to move a 
from sg  to sg   because there are two alternative paths and none of the facts in
at  a   sg    at  a   sg         at  a   sg   has to be true before reaching sg   we cannot detect any landmark facts 
to identify more landmark facts for decomposing a subproblem  we have developed
in sgplan  a new path finding technique  the technique is based on the concept of fact
groups that has been used by some existing planners  such as mips  edelkamp        and
downward  helmert   richter         a fact group includes a group of mutually exclusive
facts in which only one can be true at any time  and typically involves the multiple possible
states of an object  for the example airport instance discussed above  a fact group includes
the different locations that a  can be at 


fg  
at  a   sg    at  a   sg         at  a   sg    at  a   sg    
    
   

fichen  wah    hsu

at  a   sg  

at  a   sg  

at  a   sg  

at  a   sg  

at  a   sg  

at  a   sg  

at  a   sg  

at  a   sg  

at  a   sg  

at  a   sg  

at  a   sg   at  a   sg  

at  a   sg  

at  a   sg   at  a   sg  

a  transition graph of fg

at  a   sg  

b  path finding

figure     illustration of the transition graph of fact group fg and the path finding algorithm  shaded nodes in  b  are new landmark facts detected by path finding 

in sgplan    we have adopted an approach in mips based on an analysis of static mutex
groups for finding fact groups of subgoal facts 
we apply path finding on subproblem gt when none or a few landmarks have been
detected by landmark analysis  assuming the subgoal to be reached is gt   we first find the
fact group it belongs to  in the previous example  the subgoal is gt   at  a   g    and the
fact group is fg in      
for each fact group with two or more facts  we determine their transition relations by
constructing a directed graph  given two facts f  and f  in the fact group  we add an edge
from f  to f  if there exists an action a such that f  is a precondition of a and f  is an
add effect of a  which implies that f  is a delete effect of a since f  and f  are mutually
exclusive   figure   a illustrates the transition graph for the airport example discussed
above 
last  to find a path  we look for all the facts that are immediate predecessors of gt in
the graph  we arbitrarily select one as a must visit landmark and disable the others  we
then perform a landmark analysis from the initial fact to gt   this analysis will return more
landmark facts 
in our example airport instance  at  a   sg   and at  a   sg   are the two immediate
predecessor facts of subgoal gt   at  a   sg    if we disable at  a   sg   in the landmark
analysis  then there will only be one path from at  a   sg   to gt   and at  a   sg   
at  a   sg    and at  a   sg   will be detected as landmark facts  figure   b illustrates
this process 
c  path optimization is used to find better landmark facts for problems with timed
initial literals or numerical effects  it is invoked when there is a deadline or when there
is a dynamically changing numerical resource that appears in the preconditions of actions 
these conditions are satisfied in the ipc  satellite instances where the technique is found
to be most useful 
the technique works by choosing a path that optimizes the time duration or the usage
of a numerical resource when there are multiple paths of different quality  and by setting
those nodes along the optimal path as landmark facts  given a subproblem trying to reach
subgoal gt   we construct a transition graph for the fact group of gt and apply dijkstras
algorithm to find the shortest path from the initial fact to gt   the weight on each edge is
either a time duration for problems with time windows  or the usage of a numerical resource
   

fitemporal planning using subgoal partitioning and resolution

 

g 

a 

a 
a 

g 

time

a 
a 

a 
s 

g 
s 
s 
s 

s 

s 

s 

figure     generating multiple starting states for subproblem g    given the initial state
s  and si   i                 the state when action ai is finished  sgplan  calls the
basic planner to generate a local subplan from each starting state and picks the
first one that improves the objective in      

for problems with numerical preconditions  we then set the facts along the optimal path as
landmark facts and force the planner to choose this path over others  the landmarks along
the optimal path allows us to further decompose the problem into subproblems 
there are two limitations in our current implementation of path optimization  first 
since there needs to be a path from the initial fact to the goal fact in the transition graph 
we cannot apply the technique if the initial and the goals facts are disconnected  second 
we have studied the case of only one dynamically changing numerical resource that appears
in the preconditions of actions and have not studied the optimization of multiple numerical
resources 
    subgoal level planning techniques
a  evaluating multiple subplans for a subproblem  in finding a local feasible subplan for a
subproblem that improves the objective in       sgplan  generates a number of subplans
from multiple starting states  since no active global constraints exist between two identical
subplans  we generate multiple starting states for a given subproblem by applying all possible prefix actions from each of the other subproblems  for example  given the six actions
planned in g  and g  in figure     there are six possible starting states when developing a
subplan for g    for each starting state  sgplan  calls the basic planner to generate a local
feasible subplan and accepts the subplan if it improves the objective in       if no better
subplans can be found from all possible starting states  sgplan  leaves the local subplan
unchanged and moves on to the next subproblem 
b  search space reduction  before solving a partitioned subproblem  we can often eliminate in its search space many irrelevant actions that are related to only facts and subgoals
in other subproblems  such reductions are not useful in planning problems that are not
partitioned because all their actions are generally relevant 
   

fichen  wah    hsu

as an example  consider a transportation domain whose goal is to move packages 
drivers  and trucks to various locations from an initial configuration  suppose in a problem instance  the goal set is  at  d   s    at  t    s    at  p    s    at  p    s    for two
packages p   and p    one driver d   one truck t    and two locations s  and s   without partitioning  all the actions are relevant for resolving the subgoals  in contrast  after
partitioning  the actions for moving p   around are irrelevant in the subproblem of resolving at  p    s   and can be eliminated  similarly  those actions for moving p   or p   are
irrelevant in the subproblem of resolving at  d   s   
we have designed a backward relevance analysis to eliminate some irrelevant actions
in a subproblem before solving it by the basic planner  in the analysis  we maintain an
open list of unsupported facts  a close list of relevant facts  and a relevance list of relevant
actions  in the beginning  the open list contains only the subgoal facts of the subproblem 
and the relevance list is empty  in each iteration  for each fact in the open list  we find all
the actions that support the fact and not already in the relevance list  we then add these
actions to the relevance list and add the action preconditions that are not in the close list
to the open list  we move a fact from the open list to the close list when it is processed 
the analysis ends when the open list is empty  at that point  the relevance list will contain
all possible relevant actions  this analysis takes polynomial time 
note that our relevance analysis is not complete when it stops  since the relevance list
may still contain some irrelevant actions  for example  we can further reduce the relevance
list by a forward analysis and by finding all applicable actions from the initial states before
the backward analysis  however  further analysis may not be cost effective for reducing the
overhead in planning 
our reduction method belongs to a family of heuristics proposed by nebel  dimopoulos
and koehler         since we select all possible supporting actions when processing a fact 
our approach is indeed the one that selects the union over all elements in the possibility
set according to their classification  while we conservatively reduce the irrelevant information  there are a number of tighter reductions that can approximately minimize the use of
initial facts  nebel et al          however  these aggressive heuristics may not be solution
preserving or solution length preserving 
    modified metric ff basic planner
after decomposing a subproblem associated with a subgoal into smaller subproblems bounded
by landmark facts  sgplan  solves each subproblem identified  or the original subproblem
in case no landmark facts have been identified  by a modified metric ff planner  our modifications consist of two components  the adaptation of the original metric ff  hoffmann 
      in order to entertain the new features in pddl     and the support of planning when
the mutex constraints are partitioned  in fact  a lot of our efforts for embedding metric ff
in sgplan  were spent on the first component 
the original metric ff can only solve problems in pddl    with propositional actions
but does not support any temporal features  we have extended the parser of metric ff to
support the full pddl    syntax and the definition of actions from atomic logical to durational temporal  the planning process has also been extended from sequential propositional
planning to parallel temporal planning  specifically  we have extended sequential actions of
   

fitemporal planning using subgoal partitioning and resolution

fixed
subproblems

g 
     

components of objective function
in     
estimated makespan te

gt 
gt  

pn

     

k  
k  t

gn

t k m
e t k

weighted sum of global mutex
constraint violations

gt
current plan

heuristic value  z t   of original metric ff

relaxed plan

figure     temporal planning in a partitioned search context incorporates in the objective
function in      a makespan te estimated by an enhanced pert algorithm and
the heuristic value of the metric ff planner 
atomic length in the original metric ff to actions with predefined durations that can be
scheduled in parallel 
we have extended metric ff to support a new feature called derived predicates introduced in pddl     derived predicates define axioms whose facts are derived by a set of
precondition facts  for example  in a domain with boxes  if a is above b and b is above
c  then a derived predicate of a above c can be generated  derived predicates can only
appear in preconditions and goals but not in effects  in our modified metric ff  we have
implemented a technique proposed in mips      edelkamp        for handling derived
predicates  we encode any derived predicate d as a special action a  where the precondition
facts of a are the preconditions facts of d  the add effects of a are the derived facts of d 
and the delete effect of a is empty  during planning  all the derived predicate actions
are included in the relaxed plan  however  the heuristic function computed in metric ff
only counts the number of real actions in the relaxed plan but not the number of derivedpredicate actions  and only real actions are considered as candidates for forward expansion
in any state  in any state  we expand the set of true facts by applying all applicable derived
predicates iteratively until we reach a fixed point state where no more true facts can be
added 
the second component of the modifications in metric ff involves the support of a
partitioned search context when solving a subproblem  say gt   in this case  metric ff needs
to incorporate in its objective an aggregate state of all schedulable actions in g         gn
in the planning of actions in gt   referring to figure     the aggregate state is represented
by an estimated makespan te of all the actions that is evaluated by an enhanced pert
algorithm 
pert was originally developed to generate a parallel plan by scheduling an action
as early as possible until it is blocked by a dependency or a mutex relation  previous
pert algorithms detect a propositional conflict between two actions by checking if one
action adds deletes anothers precondition  and detect a numerical conflict when two actions
modify the same numerical variable  in the latter case  two actions would not be allowed
   

fichen  wah    hsu

to overlap in their execution when they consume the same resource  even when the total
amount required does not exceed the amount available  obviously  the resulting schedule
will be suboptimal 
we have developed an enhanced pert algorithm that considers resource constraints
in its schedule  the algorithm assigns an action as early as possible as long as there
are no propositional conflicts or no violations on numerical resource constraints  besides
maintaining operator dependency as in the original pert  we also keep track of changes
on numerical variables  our algorithm is greedy because it schedules all applicable actions
as early as possible without backtracking 
in general  pert can schedule a valid sequential plan into a parallel plan without mutex
conflicts  however  our enhanced pert may generate a parallel plan with mutex conflicts 
the reason is that each subproblem is solved from the initial state and not sequentially
from the state of the previous subproblem  hence  when actions from multiple subplans are
combined  one action may delete the precondition of another and causes a mutex conflict  as
an example  consider the sequential plans of two subproblems g  and g  that are scheduled
from the initial state in the blocksworld domain  a  move  a  b  and move  b  c  
and b  move  d  e  and move  e  c   where move  x  y  places x on top of y  with a
precondition clear  y   y is clear with nothing on it   in this example  pert cannot
generate a parallel plan with no mutex conflict between move  e  c  and move  b  c  
regardless of how these two actions are scheduled  the conflict occurs because each action
deletes the clear  c  precondition of the other 
the modified metric ff planner carries out a search that heuristically looks for plans
to minimize      rewritten as follows 



pn




n
e t k
minz t   z t     k   t k m
x
k  t


min j z   
t j m
e t j  
pn

z t 
e

j  
e t k
minz t   z t      t   k   t k m
j  t

k  t

 for sgplan   
    
 for sgplan      

where  z t   is the heuristic value of the original metric ff when solving gt   m
e t k is the
estimated number of active mutexes between the plan for gk and a relaxed plan for gt
obtained by ignoring the delete effects of unscheduled actions  te is the makespan estimated
by the enhanced pert algorithm after composing the relaxed plan of gt and the plans of
the other subproblems  t k is a penalty value dynamically updated in global level planning 
and  is a constant fixed at         although the search does not guarantee optimality  it
can always resolve global mutual exclusion constraints between  say z t  and z k   because
it can move one subplan backward in order to avoid overlapping with another conflicting
subplan when the penalty t k is large enough 
in our implementation of      in the modified metric ff planner  we have set  in
sgplan    to be very small so that the penalty term due to the makespan will not dominate
the other terms  in fact  since  te is much smaller than one in all the test problems  its main
purpose is to break ties among those states with very close heuristic values  on the other
hand  our implementation of      in sgplan  in ipc  does not include te in its objective
function  as a result  it focuses on eliminating mutual exclusion conflicts and tends to
generate plans of a longer makespan 
   

fitemporal planning using subgoal partitioning and resolution

   procedure sgplan problem file 
  
parse problem file and instantiate all facts and actions 
  
detect and encode timed initial literals  til  
  
detect and encode derived predicates 
  
detect til wrappers and translate them into regular tils 
  
detect producible resources 
  
if  there are producible resources  then set them to the maximum possible end if 
  
repeat
  
for each subgoal fact in the goal list do
   
call search space reduction to eliminate irrelevant actions 
   
call basic planner  modified metric ff  to reach the subgoal 
   
if  the basic planner times out  then
   
perform landmark analysis to generate a list of subproblems 
   
for each subproblem in the list do
   
call basic planner to solve the subproblem 
   
if  solution is not found in the time limit  then
   
if  problem has til or numerical fluents  then perform path optimization
   
else perform path finding to further decompose the subproblem end if 
   
call basic planner to solve each decomposed subproblem 
   
end if
   
end for
   
end if
   
end for
   
evaluate plan z and update penalty values of violated global constraints 
   
until feasible solution plan has been found or time limit has been exceeded 
   
if   new solution found      there are unused producible resources   then
   
reduce the initial producible resources and goto step   
   
end if
    end procedure

figure     the high level pseudo code common for both sgplan  and sgplan     

in general  embedding a basic planner in our partition and resolve framework requires
some modifications to the objective function of the basic planner in order to implement
      hence  it cannot be done without the source code of the basic planner 
    putting all the pieces together
figure    shows the high level code that is common for both sgplan  and sgplan      the
preprocessing phase parses the problem file and instantiates all the facts and actions  line
    detects and encodes timed initial literals  til  and derived predicates  if any  lines  
and     translates the problem into a regular til problem if the problem is a compiled til
problem  line     and detects producible resources and sets them to always available  lines
  and    
the major loop is between lines   and     for each subgoal  sgplan  uses search space
reduction to eliminate irrelevant actions  line     and solves it using the basic planner
 line      if the basic planner fails to find a feasible plan within a time limit       node
   

fichen  wah    hsu

table    summary of useful techniques for each domain variant  a check mark indicates
that a technique is found to be useful for a domain variant or a class of domain
variants 

domain variant
airport  
airport temp timewindows co
pipesworld  
promela  
promela   dp
psr small
psr middle
psr middle co
psr large
satellite strips
satellite time
satellite numeric
satellite complex
satellite time timewindows
satellite time timewindows co
settlers
umts temp
umts temp timewindows
umts temp timewindows co
umts flaw temp
umts flaw temp timewindows
umts flaw temp timewindows co

sg























lm




pf




po

til

til w

dp

pr

sr

































keys sg  subgoal partitioning
lm  landmark analysis
pf 
path finding
po  path optimization
til  timed initial literals handling til w  til wrapper detection
dp  derived predicates handling pr  producible resources
sr 
search space reduction

expansions in metric ff   sgplan  aborts the run of metric ff and tries to decompose the
problem further  it first applies landmark analysis to decompose and solve the subproblem
 lines         if it is unsuccessful in solving the subproblem  it tries path optimization for
numerical and til problems  line     or path finding  line     to further partition the
subproblem  after all the subgoals have been evaluated  it composes the solution  evaluates
the global constraints  and updates the penalty values  line      finally  if a new solution
has been found and there are unused producible resources  it reduces the initial producible
resources  lines        and repeats the major loop again 

   sensitivity analysis of techniques in sgplan 
in this section we describe our ablation study of the various techniques in sgplan  in order
to test their effectiveness  table   lists the techniques that are most useful for each ipc 
domain variant  we defer the discussion on the performance improvement of sgplan   
over sgplan  to section   
   

fitemporal planning using subgoal partitioning and resolution

for all the airport variants  the useful techniques include subgoal partitioning  landmark analysis  and path finding  in addition  til wrapper detection is needed for the
timewindows co variant  as an ablation study  we applied sgplan  with subgoal
partitioning alone  in this case  sgplan  can solve     out of the             instances
and cannot solve those numbered higher than     namely  p    p    etc    the reason
is that those subproblems without landmark analysis and path finding are so large that
metric ff has difficulty in solving them  in contrast  sgplan  with landmark analysis and
path finding can solve             instances 
for all the pipesworld variants  the useful techniques include subgoal partitioning  landmark analysis  path finding  and search space reduction  although search space reduction
can slightly reduce the run time by      on average  landmark analysis and path finding
has more significant effects on performance  sgplan  without landmark analysis and path
finding can only solve     out of the           instances  whereas sgplan  with landmark
analysis and path finding can solve     instances        landmark analysis and path finding also leads to    average improvement on run time for those instances that both versions
can solve 
for the promela domain  only subgoal partitioning is found to be useful  besides applying
derived predicate handling for the corresponding variants 
for all the psr variants except psr small  search space reduction is particularly
useful in addition to subgoal partitioning  for these three variants  sgplan  with searchspace reduction can solve  respectively          and    instances  whereas sgplan  without
search space reduction can solve  respectively         and   instances  in addition  the average run time improvements due to search space reduction are  respectively               
       for the psr small variant  search space reduction has no significant effects on
both run time and solution quality  last  derived predicate handling is important for psrmiddle  which is encoded using derived predicates 
in the satellite domain  only subgoal partitioning is found to be useful for solving the
time  strips  and complex variants  for the numeric  time timewindows 
and time timewindows co variants  landmark analysis and path optimization are
also useful  for these three variants  sgplan  can solve  respectively          and    
instances  whereas sgplan  without landmark analysis and path optimization can solve 
respectively          and    instances 
for the settlers domain  subgoal partitioning as well as techniques for handling producible resources are important for solving all but one of the instances   the eighth instance
is infeasible   without detecting producible resources  sgplan  can only solve nine out of
the    instances 
for the umts domain  only subgoal partitioning is found to be useful  besides applying
til handling and til wrapper detection for the corresponding variants  landmark analysis
does not help in this domain and can detect none or very few landmark facts in each of the
    instances  also  search space reduction can only prune a few facts and has little effects
on performance 
we have also studied the effects of subgoal ordering in sgplan    on eighteen representative variants from all ipc  domains as well as the depots domain  figure      for each
instance  we test sgplan    using five random subgoal orders and normalize its run time
 resp  quality  with respect to the corresponding measure when sgplan    is run using
   

fichen  wah    hsu

airport  nontemp  temp
pipesworld  notankage nontemp  notankage temp
promela  opt telegraph  opt telgraph dp  phil  phil dp
psr  small  middle
satellite  strips  time
settlers  settlers
umts  temp  flaw temp
depots  strips  simpletime  time

normalized quality

  

 

   
    

   

 

  

   

normalized run time
figure     run time quality distribution of sgplan    run using different random subgoal
orders on selected ipc  and the depots domain variants  the results are normalized with respect to the run time and quality of sgplan    run using the default
subgoal order   performance values larger than one are better for sgplan      

the original order in the problem definition  here we use makespan as our quality measure
for temporal domains and the number of actions for propositional domains  even when an
objective is specified in the problem definition  
the results show that the performance of sgplan    is quite insensitive to subgoal ordering for the airport  promela  settlers  and umts domains  however  there are significant
variations in run time and quality for the pipesworld and psr domains  although there is
no definitive trend that a random subgoal order is better  for the depots domain  there
exist some smaller variations in both run time and quality  a common feature among the
pipesworld  psr  and depots domains is that they all have intensive subgoal interactions 
which make them more sensitive to the order in which subgoals are evaluated  for example 
   

fitemporal planning using subgoal partitioning and resolution

in the psr middle variant  the number of subgoals is large  and different subgoals are
highly related by derived predicates  last  we note that using the original subgoal order
leads to better run time and quality in the satellite domain  the reason is that the original
order can avoid unnecessary subgoal invalidations when finding local feasible subplans  since
the starting states are generated by applying prefix subplans of other subgoals 
because there is no clear advantage of using random subgoal orders over the original
subgoal order  sgplan  and sgplan    use the original subgoal order in their implementations 

   experimental results
in this section  we experimentally compare the performance of sgplan    sgplan     their
differences are in      and       and other planners in solving the ipc  and ipc  benchmark
suites as well as the blocksworld domain from ipc   each suite contains multiple domains 
with several variants in each  those variants in ipc  address the different features of
pddl     which include versions on strips  strips with dp  derived predicates   temporal  temporal with til  deadlines   numeric  and complex  temporal and numeric   a
complete description of each variant and its problem files can be found at the web site of
each of the competitions 
all runs were carried out an amd athlon mp     pc with redhat linux as  and
  gbyte main memory unless otherwise noted  following the rules of ipc   all random
planners set a fixed random seed  once and for all  throughout their experiments  moreover 
all planners must be fully automated  run with the same parameter setting for all the
instances attempted  and execute under a cpu time limit of    minutes and a main memory
limit of   gbytes 
table   summarizes the performance of sgplan    sgplan      downward  helmert  
richter         lpg td speed     with a seed of       and yahsp       we use makespan
as the quality metric for temporal domains and the number of actions for propositional domains  since the code for downward is unavailable  we report its ipc  results after adjusting
its run times by a factor governed by the difference in speeds between the computer used
in the ipc  competition and the computer used for sgplan      likewise  we were unable
to evaluate downward on the ipc  and ipc  benchmarks 
table   does not include results on those domain variants that a target planner cannot
handle  for example  lpg td speed cannot solve all the compiled domains and does
not support some grammatical features in psr large and the two fluents variants in
the promela domain  and yahsp cannot handle derived predicates  in contrast  both
sgplan  and sgplan    were designed to solve all the variants except the rovers time
variant with dynamic durations  note that since the satellite and the settlers domains
exist in both the ipc  and ipc  benchmarks  the table does not include those results on
   the url for the competitions are http   ls  www cs uni dortmund de  edelkamp ipc    for
ipc   http   planning cis strath ac uk competition  for ipc   and http   www cs toronto 
edu aips      for ipc  
   the object code of lpg td was downloaded from http   zeus ing unibs it lpg register lpg td 
html  while the object code of yahsp     was downloaded from http   www cril univ artois fr 
 vidal yahsp yahsp linux x   gz  the object code of downward was unavailable for testing at the
time when this paper was revised 

   

fichen  wah    hsu

the ipc  settlers domain and some variants of the ipc  satellite domain that have been
reported for ipc  
table   
performance comparison between sgplan    and other planners 
in the
table comparing sgplan    and sgplan    the four missing variants  pipesworldnotankage temp deadlines co  promela optical telegraph fluents dp 
promela philosophers fluents dp  and rovers time  cannot be solved by both
planners  in the table comparing sgplan    and lpg td speed  all the missing variants except rovers time cannot be solved by lpg td speed  for the rovers time variant 
only lpg td speed can solve all the instances but the other planners cannot  in the tables
comparing sgplan      downward  and yahsp  all the missing variants cannot be solved by the
target planners compared 
domain variant

instances solvable by both  fb  
fi
fq
ft
fw fwt fwq

fn

all instances
fg
fu
fb

comparison between sgplan    and sgplan 
airport nontemp
         
airport temp
         
airport temp timewindows
         
airport temp timewindows co
         
pipesworld notankage nontemp
         
pipesworld notankage temp
         
pipesworld tankage nontemp
         
pipesworld tankage temp
         
pipesworld notankage temp dead
         
promela optical telegraph
         
promela optical telegraph dp
         
promela optical telegraph fluents          
promela philosophers
         
promela philosophers dp
         
promela philosophers fluents
         
psr small
         
psr middle
         
psr middle co
         
psr large
         
satellite strips
         
satellite time
         
satellite time timewindows
         
satellite time timewindows co
         
satellite numeric
         
satellite complex
         
satellite complex timewindows
         
satellite complex timewindows co
         
settlers
         
umts temp
         
umts temp timewindows
         
umts temp timewindows co
         
umts flaw temp
         
umts flaw temp timewindows
         
umts flaw temp timewindows co
         
depots strips
         
continued      

   

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

fitemporal planning using subgoal partitioning and resolution

table     continued 
domain variant
depots simpletime
depots time
depots numeric
driverlog strips
driverlog simpletime
driverlog time
driverlog numeric
driverlog hardnumeric
freecell strips
rovers strips
rovers simpletime
rovers numeric
satellite simpletime
satellite hardnumeric
zenotravel strips
zenotravel simpletime
zenotravel time
zenotravel numeric
blocksworld

instances solvable by both  fb  
fi
fq
ft
fw fwt fwq
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

fn

all instances
fg
fu
fb

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

comparison between sgplan    and lpg td speed
airport nontemp
airport temp
airport temp timewindows
pipesworld notankage nontemp
pipesworld notankage temp
pipesworld tankage nontemp
pipesworld tankage temp
pipesworld notankage temp dead
promela optical telegraph
promela optical telegraph dp
promela philosophers
promela philosophers dp
psr small
psr middle
satellite strips
satellite time
satellite time timewindows
satellite numeric
satellite complex
satellite complex timewindows
settlers
umts temp
umts temp timewindows
umts flaw temp
umts flaw temp timewindows
depots strips
depots simpletime
depots time
depots numeric
driverlog strips

         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
continued      

   

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

fichen  wah    hsu

table     continued 
instances solvable by both  fb  
fi
fq
ft
fw fwt fwq

domain variant
driverlog simpletime
driverlog time
driverlog numeric
driverlog hardnumeric
freecell strips
rovers strips
rovers simpletime
rovers numeric
satellite simpletime
satellite hardnumeric
zenotravel strips
zenotravel simpletime
zenotravel time
zenotravel numeric
blocksworld

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

fn

all instances
fg
fu
fb

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    

comparison between sgplan    and downward
airport nontemp
pipesworld notankage nontemp
pipesworld tankage nontemp
promela optical telegraph
promela optical telegraph dp
promela philosophers
promela philosophers dp
psr small
psr middle
psr large
satellite strips

    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    

comparison between sgplan    and yahsp
airport nontemp
pipesworld notankage nontemp
pipesworld tankage nontemp
promela optical telegraph
promela philosophers
psr small
satellite strips
depots strips
driverlog strips
freecell strips
rovers strips
zenotravel strips
blocksworld

    
    
    
    
    
    
    
    
    
    
    
    
    

   

    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    

fitemporal planning using subgoal partitioning and resolution

keys   tn   qn  
 tg   qg  
fb
fi
fq
ft
fw
fwt
fwq
fn
fg
fu

 run time  quality  of sgplan   
 run time  quality  of the target planner compared
fraction solved by both sgplan    and the target planner
 fb   fi   fq   ft   fw   fwt   fwq      fn  fg  fu  
fraction that tn  tg and qn  qg  sgplan    has better or the same run time and quality 
fraction that tn   tg and qn   qg  sgplan    has worse run time but better quality 
fraction that tn   tg and qn   qg  sgplan    has worse quality but better run time 
fraction that tn   tg and qn   qg  sgplan    has worse run time and worse quality 
fraction that tn   tg and qn   qg  sgplan    has worse run time but the same quality 
fraction that tn   tg and qn   qg  sgplan    has worse quality but the same run time 
fraction solved by sgplan    but not by the target planner
fraction solved by the target planner but not by sgplan   
fraction unsolved by both sgplan    and the target planner

figures       further plot the time quality trade offs when the run time  resp  quality  of
the target planner is normalized with respect to the corresponding measure of sgplan    for
all instances solvable by both planners  in each graph  we also list six percentages computed
by normalizing fi   ft   fq   fw   fwt   and fwq with respect to fb  defined in table    for all
the domains evaluated 
in the airport domain  sgplan    improves over or has the same performance as sgplan 
in terms of run time and quality for a majority         of the instances  figure   a   in
the nontemp variant  the solution files  not shown  show that sgplan    cannot solve
six  fg   fu        in table    of the seven largest instances  number    to      whereas
downward  the leading planner for this variant  can solve all    instances  sgplan    has
difficulty with these instances because the partitioned subproblems are too large to be evaluated by the embedded metric ff planner  this is also the reason for sgplan    to be
worse than downward and lpg in terms of run time on the larger instances  an obvious
solution is to employ a more efficient basic planner when it becomes available  in fact 
this is one of the strengths of our partition and resolve approach  another solution is to
partition the subproblems further and to reduce their complexity to an extent that they can
be handled by our modified metric ff planner  the design of such partitioning methods is
still open at this time 
in the pipesworld domain  sgplan    has significant improvements over sgplan  in
terms of makespan on the notankage temp and tankage temp variants  figure   b   these improvements are due to the minimization of the estimated makespan
 te  in       however  no improvements were found on the notankage nontemp and
tankage nontemp variants because      does not have a term that corresponds to the
number of actions for the non temporal variants  with respect to other planners  sgplan   
can solve more instances in the notankage nontemp  notankage temp  and
tankage temp variants  fn  fg    for all the corresponding rows in table     and
has consistently the shortest solution time in the notankage temp and tankagetemp variants  for the notankage nontemp and tankage nontemp variants  yahsp  however  can solve the most number of instances and has the shortest solution time in most cases  although it tends to produce longer plans  last  as is discussed
in section      sgplan    is not competitive in the pipesworld notankage tempdeadline variant because it can only solve eight of the    instances 
   

fichen  wah    hsu

 

     

    

    

    

    

    
    

 

 

     

    

    
    

 

normalized quality

normalized quality

     

    
     

    

     

    

    

    

   

 

 

small
middle
large
middle co

    

     

    

    

     

    

    
    

  

 

normalized run time

c  promela

d  psr

normalized quality

normalized quality

 

     

     

     
    

strips
time timewindow co
complex
complex timewindows
time timewindows
numeric
time
complex timewindows co

   
    

    

    

   

 

 

settlers

     

    

    

    

    
   

  

 

  

normalized run time

e  satellite

f  settlers
  

     

normalized quality

 

normalized quality

    

     

normalized run time

 

 

normalized run time

  

 

  

b  pipesworld
 

optical telegraph dp
optical telegraph
philosophers
optical telegraph fluents
philosophers fluents
philosophers dp

    
 e   

    

 

normalized run time

a  airport

 

    

   

normalized run time

 

     

     

normalized quality

normalized quality

     

 

 
notankage nontemp
notankage temp
tankage temp
tankage nontemp

temp
nontemp
temp timewindows co
temp timewindows

     

    
    

    

temp
flaw temp timewindows co
temp timewindows co
temp timewindows
flaw temp timewindows
flaw temp

    

    
   

 

 

     

    

    

     

depots strips
depots simpletime
depots time
depots numeric
blocksworld

   
     

  

normalized run time

     

    

   

    

 

  

   

    

     

normalized run time

g  umts

h  depots   blocksworld

figure     run time quality of sgplan  on each instance normalized with respect to the
corresponding run time quality of sgplan    on the same instance for all instances solvable by both planners   performance values larger than one are
better for sgplan      
   

fitemporal planning using subgoal partitioning and resolution

temp
nontemp
temp timewindows

     

 

  

     

normalized quality

normalized quality

 

     

     

    

notankage nontemp
notankage temp
tankage temp
tankage nontemp
notankage temp deadlines

     

    

 

    
    

    
    

    

   

 

  

   

    

    

   

 

normalized run time

      

    

    

    

    

 

    

small
middle

  

normalized quality

normalized quality

optical telegraph dp
optical telegraph
philosophers
philosophers dp

    
   

   

b  pipesworld

    

 

  

normalized run time

a  airport
 

     

  

   

    

 

     

     

    

    

    

 e   

     

    

normalized run time

    

   

 

  

   

normalized run time

c  promela

d  psr

 

 

settlers

     

 

normalized quality

normalized quality

     

    
     
strips
complex
complex timewindows
time timewindows
numeric
time

    

    
   

    

 

  

   

    

 

     

    

     

    

    
    

     

    

     

normalized quality

normalized quality

   

    

f  settlers
     

     

 

     
    

    

    

   

  

  

temp
temp timewindows
flaw temp timewindows
flaw temp

    
    

 

normalized run time

e  satellite
 

    

   

normalized run time

 

  

   

normalized run time

 

     

    
     

    

depots strips
depots simpletime
depots time
depots numeric
blocksworld

   
     

    

   

    

 

  

   

normalized run time

g  umts

h  depots   blocksworld

figure     run time quality of lpg td speed on each instance normalized with respect
to the corresponding run time quality of sgplan    on the same instance for all
instances solvable by both planners   performance values larger than one are
better for sgplan      
   

fichen  wah    hsu

    

 

 

nontemp

     

normalized quality

normalized quality

 

     

     

notankage nontemp
tankage nontemp

    

 

    

    
    

    
   

     

    

     
    

    

 

  

   

 

normalized run time

a  airport
optical telegraph dp
philosophers dp

    

 

      

    

    
   

    

    

    

 

  

   

 

small
middle
large

     

     

    

    

     

    
 e   

     

normalized run time

normalized quality

 

    

   

    

 

  

   

normalized run time

c  promela
 

   

b  pipesworld
 

normalized quality

normalized quality

 

  

normalized run time

d  psr

strips

     

     

    

    

    

    
   

    

 

  

   

normalized run time

e  satellite

figure     run time quality of downward on each instance normalized with respect to
the corresponding run time quality of sgplan    on the same instance for all
instances solvable by both planners   performance values larger than one are
better for sgplan      

in the promela domain  sgplan    has no improvements over sgplan  in terms of quality
but improves in terms of run time on instances that both can solve for four of the six variants
 worse in the optical telegraph fluents and philosophers fluents vari   

fitemporal planning using subgoal partitioning and resolution

 

nontemp

notankage nontemp
tankage nontemp

     

 

     

normalized quality

normalized quality

  

     

     

    

    

    
    

   

 

  

   

 

     

     

     

    

    

     

    

   

normalized run time

optical telegraph
philosophers

     

normalized quality

normalized quality

 

     

    

    

    

    
   

 

  

 

     

    

    

     

    
     

   

    

    

  

d  psr
  

     

     

normalized quality

normalized quality

 

normalized run time

strips

    

    
    

    

   

c  promela

 

    

small

normalized run time
 

   

b  pipesworld
 

    

  

normalized run time

a  airport
 

    

 

    

   

    

    

 

  

   

normalized run time

 

     

     

    

    

    

depots strips
blocksworld
   
     
    

   

    

 

  

   

    

normalized run time

e  satellite

f  depots   blocksworld

figure     run time quality of yahsp on each instance normalized with respect to the corresponding run time quality of sgplan    on the same instance for all instances
solvable by both planners   performance values larger than one are better for
sgplan      

ants   sgplan    can solve the most number of instances in the optical telegraphfluents  philosophers  philosophers dp  and philosophers fluents
   

fichen  wah    hsu

variants when compared to lpg td speed  downward  and yahsp  further  it is the
fastest planner in three of the variants but is slightly slower than yahsp in the philosophers variant  figures   c    c  and   c   in the optical telegraph and opticaltelegraph dp variants  the organizer of ipc  provided two versions  one written in
pure strips and another in adl  however  there are only     resp       instances in
strips and     resp       instances in adl for the optical telegraph  resp  
optical telegraph dp  variant  there are more instances available in adl because adl is space efficient in its problem representation  whereas instances in strips
require large files   for example  the file size of optical telegraph    is    kbytes
in adl and     mbytes in strips   since sgplan    and sgplan  cannot handle adl at
this time  they only solved those instances in pure strips in these two variants  they were
able to solve all the instances available in strips and were the fastest in all these instances 
however  downward can handle instances in adl and was able to solve more instances in
these two variants  we plan to extend sgplan    to directly support adl in the future 
note that both sgplan    and sgplan  always find plans of the same or better quality
for the instances solved in the optical telegraph  optical telegraph dp 
philosophers  and philosophers dp variants when compared to the other three
planners  edelkamp   hoffmann        
sgplan    is the only planner that can solve some instances of all four variants of the
psr domain  since psr is a pure propositional domain  sgplan    is unable to improve the
solution quality over sgplan    nevertheless  the quality of sgplan    is consistently better
than all the other three planners  fi  fq  fwt   ft  fw  fwq for all the corresponding rows
in table     in the small variant  sgplan    and lpg have comparable run times and
cannot solve the few largest instances  like the airport domain  sgplan    has difficulty
with the few largest instances because its basic planner cannot handle the partitioned
subproblems  in the middle variant  sgplan      lpg  and downward can solve all   
instances  the situation in the middle co and large variants are similar to that in the
optical telegraph and the optical telegraph dp variants of the promela
domain  in these variants  downward can handle directly the adl format  but sgplan   
must expand the adl syntax to pure strips and exhausted its memory when evaluating
the larger instances  we plan to address this issue in the future 
in the satellite domain  sgplan    has significant improvements in quality over sgplan   
in fact  sgplan    generates solutions of better quality than all the other planners for most
instances and can solve the most number of instances in seven variants  in the eighth
variant  time   it was not able to solve the few largest instances because its memory
usage exceeded   gbytes  in all the variants except strips  sgplan    is faster than the
other three planners  in the strips variant  yahsp is the fastest because it can generate
multiple actions instead of a single action in each search step  however  it finds slightly
longer plans when compared to those of sgplan     
in the settlers domain  sgplan    does not improve the solution quality over sgplan 
because  as discussed earlier       does not have a term that corresponds to the number of
actions for non temporal variants  sgplan    can solve all the instances except the eighth
instance  which we learned from the ipc  organizers that it is an infeasible instance  it
is also the fastest among all the planners  but generates longer plans than those of lpgtd speed  this is due to its iterative scheme for reducing producible resources  because
   

fitemporal planning using subgoal partitioning and resolution

table    summary on number of instances solved by the five planners compared    means
that it is not clear whether the domain can be solved because the object code was
not available for testing  and  means that the planner does not support the
language features in the benchmark  
domain
sgplan    sgplan  lpg td speed downward yahsp
airport
   
   
   
  
  
pipesworld
   
   
   
  
  
promela
   
   
  
  
  
psr
   
   
  
   
  
ipc 
satellite
   
   
   
  
  
settlers
  
  
  


umts
   
   
   


total
    
    
   
   
   
depots
  
  
  
 
  
driverlog
  
  
  
 
  
freecell
  
  
  
 
  
rovers
  
  
  
 
  
ipc 
satellite
  
  
  


zenotravel
  
  
  
 
  
total
   
   
   
 
  
ipc  blocksworld
  
  
  
 
  
overall
    
    
    
   
   
the optimal amount of resources cannot be found ahead of time  sgplan    may incur some
redundant actions for producing unused resources 
in the umts domain  sgplan    can solve all the instances in all the six variants and
is the fastest in four of them  moreover  its makespans are greatly improved over those of
sgplan  by incorporating te in the modified heuristic function of metric ff  although its
improvements in makespan over lpg td speed are small for all the variants  sgplan     
however  is slower than lpg td speed in the flaw and flaw til variants  its performance degradation in these variants is attributed to the flawed actions that can lead to
overly optimistic heuristic values for relaxed plan based planners  edelkamp   hoffmann 
      like metric ff 
for the ipc  depots domain  sgplan    has better quality than lpg td speed and
yahsp in the strips and numeric variants  whereas the makespan of sgplan    is
worse than that of lpg td speed for a majority of the instances in the time and
simpletime variants  lpg td speed is also faster than sgplan    for a majority of
the instances  fq   fw   fwt   fi   ft   fwq for all the corresponding rows in table    
due to the large fraction of initial active global constraints  the performance of subgoal
partitioning in sgplan    is unsatisfactory in this domain 
for the remaining ipc  domains  sgplan    generally improves sgplan  in quality
besides the freecell domain which is in strips  except for the satellite domain where
lpg td speed performs better  sgplan    generates solutions with better quality for
   

fichen  wah    hsu

most of the instances  further  sgplan    is faster than lpg td speed for more than
half of the instances  although the difference in run times among the planners on these
relatively easy instances is usually insignificant 
in the blocksworld domain  sgplan    generally finds solutions with a smaller number of
actions than those of sgplan    lpg td speed  and yahsp  however  sgplan    is much
slower than lpg td speed on many instances because it needs more time for resolving
the large fraction of initial active global constraints  figure   h  

   conclusions and future work
we have presented in this paper the partition and resolve approach and its application in
sgplan    a planner that won the first prize in the suboptimal temporal metric track and
the second prize in the suboptimal propositional track in ipc   table   summarizes the
number of instances solved by the top planners in ipc  as well as sgplan      the results
show that constraint partitioning employed by our planners is effective for solving a majority
of the problems in the two competitions 
our approach is based on the observation that the fraction of active mutex constraints
across subgoals for a majority of the instances in ipc  and ipc  is very small  this observation allows us to partition the search into largely independent subproblems and to limit
the amount of backtracking when resolving those violated global constraints across subproblems  the improvements are also attributed to a combination of techniques introduced
for reducing the search space and for handling the new features in pddl    
in the future  we plan to study other partitioning techniques that can better exploit the
constraint structure of planning domains  in particular  we will study fine grain partitioning
in order to address cases with a larger fraction of global constraints  and develop search
strategies for solving problems with difficult to satisfy global constraints and deadlines 
we also plan to extend our method to planning under uncertainty and to support more
expressive modeling language features 

acknowledgments
the research in this paper is supported by national science foundation grant iis          

references
blum  a  l     furst  m  l          fast planning through planning graph analysis  artificial
intelligence             
bonet  b     geffner  h          planning as heuristic search  artificial intelligence  special
issue on heuristic search          
chen  y     wah  b  w          automated planning and scheduling using calculus of variations in discrete space  in proc  intl conf  on automated planning and scheduling 
pp      
chien  s   rabideau  g   knight  r   sherwood  r   engelhardt  b   mutz  d   estlin  t  
smith  b   fisher  f   barrett  t   stebbins  g     tran  d          aspen   au   

fitemporal planning using subgoal partitioning and resolution

tomating space mission operations using automated planning and scheduling  in proc 
spaceops  space operations organization 
doherty  p     kvarnstrm  j          talplanner  an empirical investigation of a temporal
logic based forward chaining planner   in proc  sixth intl workshop on temopral
logic based forword chaining planner  pp        aips 
edelkamp  s          mixed propositional and numerical planning in the model checking
integrated planning system  in proc  workshop on planning for temporal domains 
aips 
edelkamp  s          pddl    planning in the model checking integrated environment  in
uk planning and scheduling special interest group  plansig   glasgow 
edelkamp  s     hoffmann  j          classical part   th international planning competition 
http   ls  www cs uni dortmund de  edelkamp ipc    
foulser  d  e   li  m     yang  q          theory and algorithms for plan merging   artificial
intelligence                   
fourman  m  p          propositional planning  in proc  workshop on model theoretic
approaches to planning  aips 
garrido  a   fox  m     long  d          a temporal planning system for durative actions
of pddl     in proc  of european conf  on artificial intelligence  pp         
gerevini  a     serina  i          lpg  a planner based on local search for planning graphs
with action costs  in proc  of the sixth int  conf  on ai planning and scheduling  pp 
      morgan kaufman 
hanks  s     weld  d  s          a domain independent algorithm for plan adaptation   j 
of artificial intelligence research            
helmert  m     richter  s          fast downward   making use of causal dependencies in
the problem representation  in proc  ipc   icaps  pp       
hoffmann  j          the metric ff planning system  translating ignoring delete lists to
numeric state variables  journal of artificial intelligence research             
hoffmann  j     nebel  b          the ff planning system  fast plan generation through
heuristic search  j  of artificial intelligence research             
jonsson  a  k   morris  p  h   muscettola  n     rajan  k          planning in interplanetary space  theory and practice  in proc   nd intl nasa workshop on planning
and scheduling for space  nasa 
kambhampati  s     hendler  j  a          a validation structure based theory of plan
modification and reuse   artificial intelligence                 
kautz  h     selman  b          pushing the envelope  planning  propositional logic  and
stochastic search  in proc    th national conference on artificial intelligence  pp 
          aaai 
kautz  h     selman  b          unifying sat based and graph based planning  in proc 
intl joint conf  on artificial intelligence  ijcai 
   

fichen  wah    hsu

kautz  h     walser  j  p          integer optimization models of ai planning problems 
the knowledge engineering review                 
koehler  j     hoffmann  j          on reasonable and forced goal ordering and their use
in an agenda driven planning algorithm  j  of ai research             
lin  f          a planner called r  ai magazine       
long  d     fox  m          efficient implementation of the plan graph in stan  j  of ai
research 
nau  d   muoz avila  h   cao  y   lotem  a     mitchell  s          total order planning
with partially ordered subtasks  in proc  intl joint conf  on artificial intelligence 
pp          ijcai 
nebel  b   dimopoulos  y     koehler  j          ignoring irrelevant facts and operators in
plan generation  in proc  european conf  on planning  pp         
nebel  b     koehler  j          plan reuse versus plan generation  a theoretical and
empirical analysis   artificial intelligence                   
nigenda  r  s   nguyen  x     kambhampati  s          altalt  combining the advantages
of graphplan and heuristic state search  tech  rep   arizona state university 
penberethy  j     weld  d          ucpop  a sound  complete  partial order planner
for adl  in proc   rd intl conf  on principles of knowledge representation and
reasoning  pp          kr inc 
penberethy  j     weld  d          temporal planning with continuous change  in proc 
  th national conf  on ai  pp            aaai 
porteous  j   sebastia  l     hoffmann  j          on the extraction  ordering  and usage
of landmarks in planning  in proc  european conf  on planning  pp       
refanidis  i     vlahavas  i          the grt planner  ai magazine       
refanidis  i     vlahavas  i          the mo grt system  heuristic planning with multiple
criteria  in proc  workshop on planning and scheduling with multiple criteria  aips 
subbarao  m  b  d     kambhampati  s          sapa  a domain independent heuristic
metric temporal planner  tech  rep   arizona state university 
tate  a   drabble  b     kirby  r          o plan   an open architecture for command 
planning and control  intelligent scheduling         
tsamardinos  i   pollack  m  e     horty  j  f          merging plans with quantitative
temporal constraints  temporally extended actions  and conditional branches   in proc 
intl conf  on ai planning and scheduling  aips   pp         
wah  b     chen  y          constraint partitioning in penalty formulations for solving
temporal planning problems  artificial intelligence                  
wah  b  w     chen  y          partitioning of temporal planning problems in mixed space
using the theory of extended saddle points  in proc  ieee intl conf  on tools with
artificial intelligence  pp         
   

fitemporal planning using subgoal partitioning and resolution

wah  b  w     chen  y          subgoal partitioning and global search for solving temporal
planning problems in mixed space  intl j  of artificial intelligence tools             
    
wilkins  d          can ai planners solve practical problems   computational intelligence 
       
wolfman  s     weld  d          combining linear programming and satisfiability solving
for resource planning  the knowledge engineering review         
yang  q          intelligent planning  a decomposition and abstraction based approach 
springer verlag  london  uk 

   

fi