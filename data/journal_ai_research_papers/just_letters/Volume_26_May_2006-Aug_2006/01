journal artificial intelligence research                

submitted       published     

planning graph heuristics belief space search
daniel bryce
subbarao kambhampati 

dan   bryce   asu   edu
rao   asu   edu

department computer science engineering
ira a  fulton school engineering
arizona state university  brickyard suite    
    south mill avenue  tempe  az      

david e  smith

de   smith   email   arc   nasa   gov

nasa ames research center
intelligent systems division  ms      
moffett field  ca           

abstract
recent works conditional planning proposed reachability heuristics improve
planner scalability  many lack formal description properties distance estimates 
place previous work context extend work heuristics conditional planning 
provide formal basis distance estimates belief states  give definition
distance belief states relies aggregating underlying state distance measures 
give several techniques aggregate state distances associated properties  many existing
heuristics exhibit subset properties  order provide standardized comparison
present several generalizations planning graph heuristics used single planner 
compliment belief state distance estimate framework investigating efficient planning
graph data structures incorporate bdds compute effective heuristics 
developed two planners serve test beds investigation  first  caltalt 
conformant regression planner uses a  search  second  p d  conditional
progression planner uses ao  search  show relative effectiveness heuristic
techniques within planners  compare performance planners several
state art approaches conditional planning 

   introduction
ever since cgp  smith   weld        sgp  weld  anderson    smith        series planners developed tackling conformant conditional planning problems including
gpt  bonet   geffner         c plan  castellini  giunchiglia    tacchella         pksplan  petrick   bacchus         frag plan  kurien  nayak    smith         mbp  bertoli  cimatti  roveri 
  traverso      b   kacmbp  bertoli   cimatti         cff  hoffmann   brafman        
yka  rintanen      b   several planners extensions heuristic state space planners
search space belief states  where belief state set possible states   without
full observability  agents need belief states capture state uncertainty arising starting
uncertain state executing actions uncertain effects known state  focus
first type uncertainty  agent starts uncertain state deterministic actions 
seek strong plans  agent reach goal certainty despite partially known
state  many aforementioned planners find strong plans  heuristic search planners
c
    
ai access foundation  rights reserved 

fib ryce   k ambhampati     mith

currently among best  yet foundation constitutes good distance based heuristic
belief space adequately investigated 
belief space heuristics  intuitively  argued heuristic merit belief state depends
least two factorsthe size belief state  i e   uncertainty current state  
distance individual states belief state destination belief state  question
course compute measures effective  many approaches estimate
belief state distances terms individual state state distances states two belief
states  either lack effective state state distances ways aggregate state distances 
instance mbp planner  bertoli et al       b  counts number states current belief
state  amounts assuming state distance unit cost  planning state
done independently  gpt planner  bonet   geffner        measures state state distances
exactly takes maximum distance  assuming states belief state positively interact 
heuristic computation substrates  characterize several approaches estimating belief state
distance describing terms underlying state state distances  basis investigation adapting classical planning reachability heuristics measure state distances
developing state distance aggregation techniques measure interaction plans states
belief state  take three fundamental approaches measure distance two belief
states  first approach involve aggregating state distance measures  rather use
classical planning graph compute representative state distance  second retains distinctions
individual states belief state using multiple planning graphs  akin cgp  smith
  weld         compute many state distance measures aggregated  third
employs new planning graph generalization  called labelled uncertainty graph  lu g  
blends first two measure single distance two belief states  techniques discuss types heuristics compute special emphasis relaxed
plans  present several relaxed plan heuristics differ terms employ state distance aggregation make stronger assumptions states belief state co achieve
goal action sequences independent  positively interact  negatively interact 
motivation first three planning graph techniques measuring belief state
distances try minimal extension classical planning heuristics see work us 
noticing use classical planning heuristics ignores distinctions states belief
state may provide uninformed heuristics  move second approach possibly
build exponentially many planning graphs get better heuristic  multiple planning
graphs extract heuristic graph aggregate get belief state distance
measure  assume states belief state independent  aggregate measures
summation  or  assume positively interact use maximization  however 
show  relaxed plans give us unique opportunity measure positive interaction
independence among states essentially taking union several relaxed plans  moreover 
mutexes play role measuring negative interactions states  despite utility
robust ways aggregate state distances  still faced exponential blow
number planning graphs needed  thus  third approach seeks retain ability measure
interaction state distances avoid computing multiple graphs extracting heuristics
each  idea condense symbolically represent multiple planning graphs single
planning graph  called labelled uncertainty graph  lu g   loosely speaking  single graph
unions causal support information present multiple graphs pushes disjunction 
  

fip lanning g raph h euristics b elief pace earch

describing sets possible worlds  i e   initial literal layers   labels  planning graph
vertices present multiple graphs  redundant representation avoided 
instance action present multiple planning graphs would present
lu g labelled indicate applicable planning graph projection
possible world  describe extract heuristics lu g make implicit
assumptions state interaction without explicitly aggregating several state distances 
ideally  planning graph techniques considers every state belief state compute
heuristics  belief states grow size could become uninformed costly  example 
single classical planning graph ignores distinctions possible states heuristic
based multiple graphs leads construction planning graph state  one way
keep costs base heuristics subset states belief state  evaluate
effect sampling cost heuristics  single graph sample single
state multiple graphs lu g sample percent states  evaluate
state sampling show appropriate  find dependent compute
heuristics states 
standardized evaluation heuristics  issue evaluating effectiveness heuristic techniques many architectural differences planners use heuristics  quite hard
pinpoint global effect assumptions underlying heuristics performance 
example  gpt outperformed mbpbut questionable whether credit efficiency attributable differences heuristics  differences search engines  mbp uses
bdd based search   interest paper systematically evaluate spectrum approaches
computing heuristics belief space planning  thus implemented heuristics similar
gpt mbp use compare new heuristics developed around notion
overlap  multiple world positive interaction independence   implemented heuristics
within two planners  conformant altalt planner  caltalt  partially observable nondeterministic planner  p d   p handle search non deterministic actions 
bulk paper discuss deterministic actions  general action formulation 
pointed smith weld         translated initial state uncertainty  alternatively 
section     discuss direct approach reason non deterministic actions
heuristics 
external evaluation  although main interest paper evaluate relative advantages spectrum belief space planning heuristics normalized setting  compare
performance best heuristics work current state art conformant
conditional planners  empirical studies show planning graph based heuristics provide effective guidance compared cardinality heuristics well reachability heuristic used gpt
cff  planners competitive bdd based planners mbp yka 
graphplan based ones cgp sgp  notice planners gain scalability
heuristics retain reasonable quality solutions  unlike several planners compare
against 
rest paper organized follows  first present caltalt p planners
describing state action representations well search algorithms  understand
search guidance planners  discuss appropriate properties heuristic measures
belief space planning  follow description three planning graph substrates used
compute heuristics  carry empirical evaluation next three sections  describing
  

fib ryce   k ambhampati     mith

test setup  presenting standardized internal comparison  finally comparing several
state art planners  end related research  discussion  prospects future work 
various concluding remarks 

   belief space planners
planning formulation uses regression search find strong conformant plans progression
search find strong conformant conditional plans  strong plan guarantees finite
number actions executed many possible initial states  resulting states goal
states  conformant plans special case plan conditional plan branches 
classical planning  conditional plans general case plans structured graph
include conditional actions  i e  actions causative observational effects  
presentation  restrict conditional plans dags  conceptual reason
cannot general graphs  plan quality metric maximum plan path length 
formulate search space belief states  technique described bonet geffner
        planning problem p defined tuple d  bsi   bsg   domain
description  bsi initial belief state  bsg goal belief state  consisting states
satisfying goal   domain tuple f  a  f set fluents set
actions 
logical formula representation  make extensive use logical formulas f represent
belief states  actions  lu g labels  first explain conventions  refer every
fluent f either positive literal negative literal  either denoted l 
discussing literal l  opposite polarity literal denoted l  thus l   at location   
l   at location    reserve symbols denote logical false true  respectively 
throughout paper define conjunction empty set equivalent   disjunction
empty set  
logical formulas propositional sentences comprised literals  disjunction  conjunction 
negation  refer set models formula f m f    consider disjunctive normal
   conjunctive normal form f    f    dnf seen
form logical formula f    f
disjunction constituents conjunction literals  alternatively cnf
seen conjunction clauses c disjunction literals   find useful
think dnf cnf represented sets disjunctive set constituents conjunctive set
clauses  refer complete representation  f   formula f dnf every
constituent case state model f  
belief state representation  world state  s  represented complete interpretation
fluents  refer states possible worlds  belief state bs set states symbolically represented propositional formula f   state set states represented
belief state bs m bs   equivalently    bs 
pedagogical purposes  use bomb toilet clogging sensing problem 
btcs  running example paper   btcs problem includes two packages  one
  readily related  specifically constituent contains k  f   literals 
   easy see m f    f
corresponding   f  k models 
   aware negative publicity associated b t problems fact handle interesting
problems difficult reachability uncertainty  e g  logistics rovers   simplify discussion
choose small problem 

  

fip lanning g raph h euristics b elief pace earch

contains bomb  toilet dunk packages defuse potential
bombs  goal disarm bomb allowable actions dunking package
toilet  dunkp   dunkp    flushing toilet becomes clogged dunking  flush  
using metal detector sense package contains bomb  detectmetal   fluents encoding
problem denote bomb armed  arm  not  bomb package  inp   inp  
not  toilet clogged  clog  not  consider conformant variation btcs 
called btc  detectmetal action 
belief state representation btcs initial condition  clausal representation is 
 bsi     arm clog  inp  inp    inp  inp   
constituent representation is 

 bs
     arm clog inp  inp    arm clog inp  inp   
goal btcs clausal constituent representation 

 bsg      bs
g     arm 
however  goal complete representation 
 bsg      arm clog inp  inp    arm clog inp  inp  
 arm clog inp  inp    arm clog inp  inp  
 arm clog inp  inp    arm clog inp  inp  
 arm clog inp  inp    arm clog inp  inp   
last four states  disjuncts  complete representation unreachable  consistent
goal description 
action representation  represent actions causative observational effects 
actions described tuple e  a    a    a  e  a  execution precondition 
 a  set causative effects   a  set observations  execution precondition 
e  a   conjunction literals must hold action executable  action executable  apply set causative effects find successor states apply observations
partition successor states observational classes 
causative effect j  a   a  conditional effect form j  a    j  a  
antecedent j  a  consequent j  a  conjunction literals  handle disjunction
e  a  j  a  replicating respective action effect different conditions 
loss generality assume conjunctive preconditions  however  cannot split disjunction
effects  disjunction effect amounts representing set non deterministic outcomes  hence
allow disjunction effects thereby restricting deterministic effects  convention
   a  unconditional effect  equivalent conditional effect    a     
way obtain observations execute action observations  observation
formula oj  a   a  possible sensor reading  example  action observes
truth values two fluents p q defines  a     p q  p q  p q  p q   differs
slightly conventional description observations conditional planning literature 
works  e g   rintanen      b  describe observation list observable formulas 
define possible sensor readings boolean combinations formulas  directly define
possible sensor readings  illustrated example  note convention helpful
problems boolean combinations observable formulas never sensor readings 
causative sensory actions example btcs problem are 
  

fib ryce   k ambhampati     mith

dunkp   e   clog         clog      inp    arm        
dunkp   e   clog         clog      inp    arm        
flush  e            clog        
detectmetal  e            o    inp   o    inp   
    regression
perform regression caltalt planner find conformant plans starting goal
belief state regressing non deterministically relevant actions  action  without
observations  relevant regressing belief state  i  unconditional effect consistent
every state belief state  ii  least one effect consequent contains literal present
constituent belief state  first part relevance requires every state successor
belief state actually reachable predecessor belief state second ensures
action helps support successor 
following pednault         regressing belief state bs action a  conditional
effects  involves finding execution  causation  preservation formulas  define regression
terms clausal representation  generalized arbitrary formulas  regression
belief state conjunction regression clauses  bs   formally  result bs
regressing belief state bs action defined as  




bs   regress bs  a     a 




  a  l  ip  a  l  

c bs  lc

execution formula   a   execution precondition e  a   must hold bs
applicable 
causation formula   a  l   literal l w r t effects  a  action defined
weakest formula must hold state l holds bs  intuitive meaning
l already held bs   antecedent  a  must held bs make l hold bs 
formally  a  l  defined as 

 a 
 a  l    l
i li  a 

preservation formula  ip  a  l   literal l w r t  effects  a  action defined
formula must true l violated effect  a   intuitive
meaning antecedent every effect inconsistent l could held bs  
formally ip  a  l  defined as 
ip  a  l   



 a 

i li  a 

regression formalized mbp planner  cimatti   roveri        symbolic
pre image computation bdds  bryant         formulation syntactically different 
approaches compute result 
   note bs may clausal form regression  especially action multiple conditional effects  

  

fip lanning g raph h euristics b elief pace earch

bsg
flush

bs 
flush

bs 
flush

bs 

dunkp 

bs 

dunkp 

bs 
dunkp 

bs 

dunkp 

bs 
dunkp 

bs 

dunkp 

bs 

figure    illustration regression search path conformant plan bt c problem 
    caltalt
caltalt planner uses regression operator generate children a  search  regression
terminates search node expansion generates belief state bs logically entailed
initial belief state bsi   plan sequence actions regressed bsg obtain
belief state entailed bsi  
example  btc problem  figure    have 
bs   regress bsg   dunkp     clog  arm inp   
first clause execution formula second clause causation formula
conditional effect dunkp  arm 
regressing bs  flush gives 
bs    regress bs    flush     arm inp   
bs    execution precondition flush   causation formula clog    
 arm inp   comes persistence causation formula 
finally  regressing bs  dunkp  gives 
bs    regress bs    dunkp     clog  arm inp  inp   
terminate bs  bsi    bs    plan dunkp   flush  dunkp  
    progression
progression handle causative effects observations  general  progressing
action belief state bs generates set successor belief states b  set belief
states b empty action applicable bs  bs
   e  a   
progression belief state bs action best understood union result
applying model bs fact implement bdd images  mbp planner
  

fib ryce   k ambhampati     mith

 bertoli et al       b   since compute progression two steps  first finding causative successor  second partitioning successor observational classes  explain steps separately 
causative successor bs found progressing belief state bs causative effects
action a  action applicable  causative successor disjunction causative
progression  progressc   state bs a 



  bs
   e  a 



bs   progressc  bs  a   
sm bs  progressc  s  a    otherwise
progression action state conjunction every literal persists  no
applicable effect consequent contains negation literal  every literal given
effect  an applicable effect consequent contains literal  


  progressc  s  a   

l ls
j s  j  a 
lj  a 



l
l j

s  j  a 
lj  a 

l


applying observations action results set successors b  set found  in
progresss   individually taking conjunction sensor reading oj  a  causative
successor bs   applying observations  a  belief state bs results set b belief
states  defined as 

  bs  



 bs  
   a   
b   progresss  bs   a   



j

 bs  bs    a  bs     otherwise
full progression computed as 
b   progress bs  a    progresss  progressc  bs  a   a  
    p
use top ao  search  nilsson         p planner generate conformant
conditional plans  search graph  nodes belief states hyper edges actions 
need ao  applying action observations belief state divides belief state
observational classes  use hyper edges actions actions observations
several possible successor belief states  must included solution 
ao  search consists two repeated steps  expand current partial solution 
revise current partial solution  search ends every leaf node current solution
belief state satisfies goal better solution exists  given heuristic function   expansion involves following current solution unexpanded leaf node generating children 
revision dynamic programming update node current solution selects best
hyper edge  action   update assigns action minimum cost start best solution
rooted given node  cost node cost best action plus average cost
children  the nodes connected best action   expanding leaf node  children
applied actions given heuristic value indicate estimated cost 
  

fip lanning g raph h euristics b elief pace earch

main differences formulation ao  nilsson       
allow cycles search graph  update costs nodes average rather
summation  use weighted estimate future cost  first difference ensure plans
strong  there finite number steps goal   second guide search toward plans
lower average path cost  third bias search trust heuristic function 
define plan quality metric  maximum plan path length  differently metric search
minimizes two reasons  first  easier compare competing planners
measure plan quality metric  second  search tends efficient using average
instead maximum cost actions children  using average instead maximum 
measured cost plan lower means likely search shallower search graph
prove solution best solution 
conformant planning  using actions without observations  special case ao  search 
similar a  search  hyper edges represent actions singletons  leading
single successor belief state  consider btc problem  btcs without detectmetal action 
future cost  heuristic value  set zero every search node  show search graph
figure   conformant example well conditional example  described shortly 
expand initial belief state progressing applicable actions  get 
b     bs       progress bsi   dunkp  
    inp  inp  clog arm   inp  inp  clog arm  

b     bs       progress bsi   dunkp  
    inp  inp  clog arm   inp  inp  clog arm   
since clog already holds every state initial belief state  applying flush bsi leads
bsi creating cycle  hence  hyper edge flush added search graph bsi  
assign cost zero bs   bs     update internal nodes best solution  add
dunkp  best solution rooted bsi  whose cost one  
expand leaf nodes best solution  single node bs     applicable actions 
applicable action flush  get 
b     bs       progress bs     flush 
    inp  inp  clog arm   inp  inp  clog arm   
assign cost zero bs   update best solution  choose flush best action
bs    whose cost one   choose dunkp  best action bsi  whose cost
one   dunkp  chosen bsi successor bs   cost zero  opposed
bs   cost one 
expanding leaf node bs   applicable action  flush  get 
b     bs       progress bs     flush 
    inp  inp  clog arm   inp  inp  clog arm   
update bs    to cost zero  bs    to cost one   choose flush best
action bs     root node bsi two children  cost one  arbitrarily choose
dunkp  best action 
expand bs   relevant actions get bsg dunkp  action  dunkp  creates
cycle back bs   added search graph  solution leaf
nodes terminal  required terminal belief state contains subset
  

fib ryce   k ambhampati     mith

bsi
dunkp 

detect
metal

dunkp 

 inp 

inp 

b 

b 

bs  

b 

bs  

bs  

flush

flush

b 

b 

bs  

dunkp 

dunkp 
dunkp 

dunkp 

b 

bs  
dunkp 

bs  

b 

bs  

bs  

dunkp 

bsg

figure    illustration progression search conformant plan  bold dashed edges  conditional plan  bold solid edges  btcs problem 

states bsg   case terminal belief state contains exactly states bsg   cost
solution three because  revision  bs   cost one  sets bs   cost
two  however  means bsi cost three best action dunkp   instead 
revision sets best action bsi dunkp  cost currently two 
expand bs   dunkp  find successor bsg   dunkp  creates cycle
back bs   added search graph  second valid solution
contains unexpanded leaf nodes  revision sets cost bs   one  bs   two 
bsi three  since solutions starting bsi equal cost  meaning cheaper
solutions   terminate plan dunkp   flush  dunkp   shown bold dashed lines
figure   
example search conditional plan p d  consider btcs example whose
search graph shown figure    expanding initial belief state  get 
b     bs       progress bsi   dunkp   
b     bs       progress bsi   dunkp   

b     bs     bs       progress bsi  detectmetal 
   inp  inp  clog arm  inp  inp  clog arm  
leaf nodes assigned cost zero  dunkp  chosen arbitrarily best
solution rooted bsi cost solution identical  cost including
hyper edge average cost children plus cost  cost using detectmetal        
         thus  root bsi cost one 
  

fip lanning g raph h euristics b elief pace earch

conformant problem expand bs     giving child cost zero bs   cost
one  changes best solution bsi use dunkp   expand bs     giving child
cost zero cost one  choose detectmetal start best solution bsi
gives bsi cost one  using either dunk action would give bsi cost two 
expand first child detectmetal  bs     dunkp  get 
 inp  inp  clog arm  
goal state  dunkp  get 
b     bs       progress bs    dunkp      inp  inp  clog arm  
expand second child  bs     dunkp  get 
 inp  inp  clog arm  
goal state dunkp  get 
b     bs       progress bs    dunkp      inp  inp  clog arm  
none new belief states equivalent bsg   two entail bsg  
treat terminal connecting hyper edges actions bsg   choose
dunkp  dunkp  best actions bs   bs   respectively set cost node
one  turn sets cost using detectmetal bsi                  terminate
plan cost equal possible plans starting bsi leaf nodes
satisfy goal  plan shown bold solid lines figure   

   belief state distance
caltalt p planners need guide search node expansion heuristics
estimate plan distance dist bs  bs   two belief states bs bs   convention  assume bs precedes bs  i e   progression bs search node bs goal
belief state  regression bs initial belief state bs search node   simplicity 
limit discussion progression planning  since strong plan  executed bs  ensures
every state m bs  transition state m bs    define plan distance
bs bs number actions needed transition every state m bs 
state m bs    naturally  strong plan  actions used transition state s  m bs 
may affect transition another state s  m bs   usually degree positive
negative interaction s  s  ignored captured estimating plan distance   following explore perform estimates using several intuitions
classical planning state distance heuristics 
start example search scenario figure    three belief states bs   containing states s   s      bs   containing state s      bs   containing states s   s     
goal belief state bs    two progression search nodes bs  bs    want
expand search node smallest distance bs  estimating dist bs    bs    denoted
bold  dashed line dist bs    bs    denoted bold  solid line  assume
estimates state distance measures dist s    denoted light dashed
solid lines numbers  state distances represented numbers action sequences 
example  use following action sequences illustration 
   interaction states captures notion actions performed transition one state goal may interfere
 negatively interact  aid  positively interact  transitioning states goals states 

  

fib ryce   k ambhampati     mith

bs 
s  

bs 

  
 

s  

s  

 
 

bs 

s  

 

s  

  

figure    conformant plan distance estimation belief space
dist s     s         a    a      a      a    a     
dist s     s         a    a      a     
dist s     s         a    a      a    a    a      a    a      a     
sequence may several actions step  instance  dist s     s     a 
a  first step  total eight actions sequence meaning distance
eight  notice example includes several state distance estimates  found
classical planning techniques  many ways use similar ideas estimate belief
state distance addressed issue belief states containing several states 
selecting states distance estimation  exists considerable body literature estimating plan distance states classical planning  bonet   geffner        nguyen 
kambhampati    nigenda        hoffmann   nebel         would apply estimate plan distance two belief states  say bs  bs    identify four possible
options using state distance estimates compute distance belief states bs 
bs   
sample state pair  sample single state bs  single state bs   
whose plan distance used belief state distance  example  might sample s  
bs  s   bs    define dist bs    bs      dist s     s     
aggregate states  form aggregate states bs  bs  measure plan
distance  aggregate state union literals needed express belief state formula 
  

fip lanning g raph h euristics b elief pace earch

define as 
s bs   



l

l ls s bs 

since possible express belief state formula every literal  e g   using  q q  p
express belief state p true   assume reasonably succinct representation 
robdd  bryant         quite possible aggregate states inconsistent  many classical planning techniques  such planning graphs  require consistent states  example  aggregate states would compute belief state distance
dist bs    bs      dist s bs     s bs     
choose subset states  choose set states  e g   random sampling 
bs  set states bs    compute state distances pairs states
sets  upon computing state distances  aggregate state distances  as
describe shortly   example  might sample s   s   bs  s  
bs    compute dist s     s     dist s     s      aggregate state distances
define dist bs    bs    
use states  use states bs  bs    and  similar sampling subset
states  above   compute distances state pairs aggregate distances 
former two options computing belief state distance reasonably straightforward  given
existing work classical planning  latter two options compute multiple state distances 
multiple state distances two details require consideration order obtain
belief state distance measure  following treat belief states contain states
appropriately replaced subset chosen states 
first issue state distances may needed  since state bs 
needs reach state bs    consider distance state bs  state
bs    however  dont necessarily need distance every state bs  every state
bs    explore assumptions state distances need computed section     
second issue  arises computing state distances  need aggregate
state distances belief state distance  notice popular state distance estimates
used classical planning typically measure aggregate costs state features  literals   since
planning belief space  wish estimate belief state distance aggregate cost
belief state features  states   section      examine several choices aggregating state
distances discuss captures different types state interaction  section     
conclude summary choices make order compute belief state distances 
    state distance assumptions
choose compute multiple state distances two belief states bs bs  
whether considering states sampling subsets  state distances important 
given state bs need know distance every state bs
state bs need transition one state bs   two assumptions make
states reached bs help us define two different belief state distance measures
terms aggregate state distances 
  

fib ryce   k ambhampati     mith

optimistically assume earlier states m bs  reach closest
later states m bs    assumption compute distance as 
dist bs  bs     ffsm bs 

min

m bs  

dist s    

assume earlier states m bs  reach later state
m bs    aggregate distance minimum  assumption compute distance as 
dist bs  bs    

min

m bs  

ffsm bs  dist s    

represents aggregation technique  several discuss shortly  
throughout rest paper use first definition belief state distance
relatively robust easy compute  drawback treats earlier states
independent fashion  flexible allowing earlier states transition different later states 
second definition measures dependencies earlier states  restricts reach
later state  second may sometimes accurate  misinformed cases
earlier states cannot reach later state  i e   measure would infinite  
pursue second method may return distance measures infinite
fact finite 
see section    discuss computing measures planning graphs 
implicitly find state bs closest state bs   enumerate
states minimization term first belief state distance  above   part reason
  rather actual states 

compute distance terms constituents  bs
also  consider constituents bs   discuss sampling belief states include distance computation sample bs  avoid explicit aggregation
using lu g  describe several choices understand implicit assumptions made
heuristics computed lu g 
    state distance aggregation
aggregation function plays important role measure distance belief
states  compute one state distance measure  either exhaustively sampling
subset  as previously mentioned   must combine measures means  denoted ff 
range options taking state distances aggregating belief state
distance  discuss several assumptions associated potential measures 
positive interaction states  positive interaction assumes difficult state bs
requires actions help transition states bs state bs  
example  means assume actions used transition s   s   help us
transition s   s    assuming state bs  transitions closest state bs    
inspecting action sequences  see positively interact need actions a 
a    need know action sequences assume positive interaction
define aggregation maximization numerical state distances 
dist bs  bs    

max

min

sm bs  m bs  

dist s    
  

fip lanning g raph h euristics b elief pace earch

belief state distances dist bs    bs      max min         min           
dist bs    bs      max min              case prefer bs  bs   
state distance admissible sample belief states  assuming positive
interaction admissible 
independence states  independence assumes state bs requires actions
different states bs order reach state bs   previously  found
positive interaction action sequences transition s   s   s   s  
shared actions a  a    independence sequences
first contains a    a    a    second contains a    again  need
know action sequences assume independence define aggregation
summation numerical state distances 

min dist s    
dist bs  bs    


sm bs  m bs  

example  dist bs    bs      min          min            dist bs    bs     
min             case preference bs  bs   
notice using cardinality belief state  m bs   measure dist bs  bs  
special case assuming state independence  s  dist s         use cardinality measure distance example  dist bs    bs       m bs         
dist bs    bs       m bs          cardinality prefer bs  bs 
better knowledge bs   
overlap states  overlap assumes positive interaction independence
actions used states bs reach state bs   intuition
actions often used multiple states bs simultaneously count
actions once  example  computed dist bs    bs    assuming positive
interaction  noticed action sequences dist s     s     dist s     s    
used a  a    aggregate sequences would count a  a 
potentially overlap  however  truly combining action sequences
maximal overlap plan merging problem  kambhampati  ihrig    srivastava        
difficult planning  since ultimate intent compute heuristics 
take simple approach merging action sequences  introduce plan merging
operator picks step align sequences unions aligned
steps  use size resulting action sequence measure belief state distance 
dist bs  bs     sm bs 

min

m bs  

dist s    

depending type search  define differently  assume sequences used
progression search start time used regression end time 
thus  progression sequences aligned first step union steps 
regression sequences aligned last step union 
example  progression dist s     s     dist s     s         a    a      a      a    a    
  a    a      a         a    a    a      a    a      a    a     align sequences
first steps  union step  notice resulting sequence seven actions  giving
  

fib ryce   k ambhampati     mith

dist bs    bs         whereas defining maximum gave distance five summation gave distance eight  compared overlap  positive interaction tends
estimate distance  independence tends estimate distance  see empirical evaluation  in section       accounting overlap provides accurate
distance measures many conformant planning domains 
negative interaction states  negative interaction states appear example
transitioning state s   state s   makes difficult  or even impossible  transition
state s   state s     could happen performing action a  s   conflicts action
a  s     say bs  cannot reach bs  possible action sequences start
s   s     respectively  end m bs    negatively interact 
two ways negative interactions play role belief state distances  negative interactions allow us prove impossible belief state bs reach belief state
bs   meaning dist bs  bs       potentially increase distance finite
amount  use first  extreme  notion negative interaction computing
cross world mutexes  smith   weld        prune belief states search 
cannot prune belief state  use one aforementioned techniques aggregate
state distances  such  provide concrete definition measure negative
interaction 
explore ways adjust distance measure negative interactions 
mention possibilities  work classical planning  nguyen et al         
penalize distance measure dist bs    bs    reflect additional cost associated serializing conflicting actions  additionally conditional planning  conflicting actions
conditioned observations execute plan branch  distance
measure uses observations would reflect added cost obtaining observations 
well change cost associated introducing plan branches  e g   measuring average
branch cost  
techniques belief state distance estimation terms state distances provide
basis use multiple planning graphs  show empirical evaluation
measures affect planner performance differently across standard conformant conditional
planning domains  quite costly compute several state distance measures  understanding aggregate state distances sets foundation techniques develop
lu g  already mentioned  lu g conveniently allows us implicitly aggregate state
distances directly measure belief state distance 
    summary methods distance estimation
since explore several methods computing belief state distances planning graphs  provide summary choices must consider  listed table    column headed
choice  containing possible options below  order columns reflects order
consider options 
section covered first two columns relate selecting states belief
states distance computation  well aggregating multiple state distances belief state
distance  test options choices empirical evaluation 
  

fip lanning g raph h euristics b elief pace earch

state
selection
single
aggregate
subset


state distance
aggregation
  interaction
independence
overlap
  interaction

planning
graph
sg
mg
lu g

mutex
type
none
static
dynamic
induced

mutex
worlds

intersect
cross

heuristic
max
sum
level
relaxed plan

table    features belief state distance estimation 
next section expand upon aggregate distance measures well
discuss remaining columns table    present type planning graph  single
planning graph  sg   multiple planning graphs  m g   labelled uncertainty graph  lu g  
within planning graph describe several types mutex  including static  dynamic 
induced mutexes  additionally  type mutex computed respect different
possible worlds means mutex involves planning graph elements  e g   actions 
exist world  i e   mutexes computed within planning graph single
state   across worlds  i e   mutexes computed planning graphs different states 
two methods  denoted intersect cross   finally  compute many different heuristics
planning graphs measure state distances max  sum  level  relaxed plan  focus
discussion planning graphs  same world mutexes  relaxed plan heuristics next
section  cross world mutexes heuristics described appendices 

   heuristics
section discusses use planning graph heuristics measure belief state distances 
cover several types planning graphs extent used compute
various heuristics  begin brief background planning graphs 
planning graphs  planning graphs serve basis belief state distance estimation  planning graphs initially introduced graphplan  blum   furst        representing optimistic  compressed version state space progression tree  compression lies unioning
literals every state subsequent steps initial state  optimism relates underestimating number steps takes support sets literals  by tracking subset
infeasible tuples literals   graphplan searches compressed progression  or planning graph 
achieves goal literals level two goal literals marked infeasible  search
tries find actions support top level goal literals  find actions support chosen
actions reaching first graph level  basic idea behind using planning graphs
search heuristics find first level planning graph literal state
appears  index level lower bound number actions needed achieve
state literal  techniques estimating number actions required
achieve sets literals  planning graphs serve way estimate reachability state literals discriminate goodness different search states  work generalizes
literal estimations belief space search considering graphplan cgp style planning
graphs plus new generalization planning graphs  called lu g 
planners cgp  smith   weld        sgp  weld et al         adapt graphplan
idea compressing search space planning graph using multiple planning graphs  one
  

fib ryce   k ambhampati     mith

overlap

n distances

hmg
rpu

hlug
rp

state distance aggregation

cff

independence

positive
interaction

none

h card
mbp
kacmbp
yka

hmg
s rp

gpt

hmg
m rp

h 
ng

 

hsg
rp
u
hsg
rp
sg

mg

lug

planning graph type

figure    taxonomy heuristics respect planning graph type state distance aggregation  blank entries indicate combination meaningless possible 

possible world initial belief state  cgp sgp search planning graphs 
similar graphplan  find conformant conditional plans  work paper seeks
apply idea extracting search heuristics planning graphs  previously used state space
search  nguyen et al         hoffmann   nebel        bonet   geffner        belief space
search 
planning graphs belief space  section proceeds describing four classes heuristics
estimate belief state distance n g  sg  g  lu g  n g heuristics techniques existing
literature based planning graphs  sg heuristics techniques based single
classical planning graph  g heuristics techniques based multiple planning graphs  similar
used cgp  lu g heuristics use new labelled planning graph  lu g combines
advantages sg g reduce representation size maintain informedness  note
include observations planning graph structures sgp  weld et al  
      would  however include feature future work  conditional planning formulation directly uses planning graph heuristics ignoring observations  results show
still gives good performance 
figure   present taxonomy distance measures belief space  taxonomy
includes related planners  whose distance measures characterized section 
related planners listed n g group  despite fact actually use planning graphs 
clearly fall one planning graph categories  figure shows
  

fip lanning g raph h euristics b elief pace earch

different substrates  horizontal axis  used compute belief state distance aggregating
state state distances various assumptions  vertical axis   combinations
considered make sense impossible  reasons omissions
discussed subsequent sections  wealth different heuristics one
compute using planning graphs  concentrate relaxed plans proven
effective classical planning previous studies  bryce   kambhampati        
provide additional descriptions heuristics max  sum  level appendix a 
example  illustrate computation heuristic  use example derived btc
called courteous btc  cbtc  courteous package dunker disarm bomb
leave toilet unclogged  discourteous person left toilet clogged  initial
belief state cbtc clausal representation is 
 bsi     arm clog  inp  inp    inp  inp   
goal is 
 bsg     clog arm 
optimal action sequences reach bsg bsi are 
flush  dunkp   flush  dunkp   flush 

flush  dunkp   flush  dunkp   flush 
thus optimal heuristic estimate distance bsi bsg   regression 
h  bsg       either plan five actions 
use planning graphs progression regression search  regression search
heuristic estimates cost current belief state w r t  initial belief state progression
search heuristic estimates cost goal belief state w r t  current belief state  thus 
regression search planning graph s  built  projected  possible worlds
initial belief state  progression search need built search node 
introduce notation bsi denote belief state find heuristic measure  bsp
denote belief state used construct initial layer planning graph s  
following subsections describe computing heuristics regression  generalized
progression changing bsi bsp appropriately 
previous section discussed two important issues involved heuristic computation 
sampling states include computation using mutexes capture negative interactions
heuristics  directly address issues section  deferring discussion
respective empirical evaluation sections           heuristics computed
decided set states use  whether sampling not  also  previously
mentioned  consider sampling states belief state bsp implicitly
find closest states bsi without sampling  explore computing mutexes planning
graphs regression search  use mutexes determine first level planning graph
goal belief state reachable  via level heuristic described appendix a  extract
relaxed plan starting level  level heuristic level belief
state reachable  prune regressed belief state 
proceed describing various substrates used computing belief space distance estimates  within describe prospects various types world aggregation  addition
heuristics  mention related work relevant areas 
  

fib ryce   k ambhampati     mith

    non planning graph based heuristics  n g 
group many heuristics planners n g group using sg  g 
lu g planning graphs  mention group mean
using planning graphs form 
aggregation  breadth first search uses simple heuristic  h  heuristic value set
zero  mention heuristic gauge effectiveness search substrates
relative improvements gained using heuristics 
positive interaction aggregation  gpt planner  bonet   geffner        measures belief
state distance maximum minimum state state distance states source
destination belief states  assuming optimistic reachability mentioned section    gpt measures
state distances exactly  terms minimum number transitions state space  taking
maximum state state distance akin assuming positive interaction states current
belief state 
independence aggregation  mbp planner  bertoli et al       b   kacmbp planner  bertoli
  cimatti         yka planner  rintanen      b   comparable hcard heuristic measure
belief state distance assuming every state state distance one  taking summation
state distances  i e  counting number states belief state   measure useful
regression goal belief states partially specified contain many states consistent
goal formula many states consistent goal formula reachable
initial belief state  throughout regression  many unreachable states removed
predecessor belief states inconsistent preconditions regressed action 
thus  belief states reduce size regression cardinality may indicate
closer initial belief state  cardinality useful progression belief states
become smaller  agent knowledge easier reach goal state 
cbtc  hcard  bsg       bsg four states consistent complete representation 
 bsg      inp  inp clog arm   inp  inp  clog arm 
 inp  inp  clog arm   inp  inp  clog arm  
notice  may uninformed bsg two states  bsg   reachable 
like   inp  inp  clog arm   n packages  would  n  unreachable
states represented  bsg    counting unreachable states may overestimate distance estimate
need plan them  general  addition problem counting unreachable states  cardinality accurately reflect distance measures  instance  mbp reverts
breadth first search classical planning problems state distance may large small
still assigns value one 
overlap aggregation  rintanen        describes n distances generalize belief state
distance measure gpt consider maximum n tuple state distance  measure involves 
n sized tuple states belief state  finding length actual plan transition
n tuple destination belief state  maximum n tuple distance taken distance
measure 
example  consider belief state four states  n equal two  would define
six belief states  one size two subset four states  belief states
find real plan  take maximum cost plans measure distance original
  

fip lanning g raph h euristics b elief pace earch

l 

a 

e 

l 

a 

e 

l 

inp 

inp 

inp 

inp 

inp 

inp 

inp 

inp 

inp 

inp 

inp 

inp 
dunkp 

  dunkp  
  dunkp  

arm
dunkp 
arm

arm

  dunkp  
  dunkp  

clog

clog

clog
flush

  flush 

clog

arm

flush

  flush 

clog

figure    single planning graph cbtc  relaxed plan components bold  mutexes omitted 

four state belief state  n one  computing measure gpt  n
equal size belief state directly solving planning problem  costly
compute measure large values n  informed accounts overlap
negative interactions 
cff planner  hoffmann   brafman        uses version relaxed planning graph
extract relaxed plans  relaxed plans measure cost supporting set goal literals
states belief state  addition traditional notion relaxed planning graph ignores
mutexes  cff ignores one antecedent literal conditional effects keep relaxed
plan reasoning tractable  cff relaxed plan capture overlap ignores subgoals
mutexes  way cff ensures goal supported relaxed problem encode
relaxed planning graph satisfiability problem  encoding satisfiable  chosen number
action assignments distance measure 
    single graph heuristics  sg 
simplest approach using planning graphs belief space planning heuristics use
classical planning graph  form initial literal layer projected belief state  could
either sample single state  denoted sg    use aggregate state  denoted sgu    example 
cbtc  see figure    assuming regression search bsp   bsi   initial level l 
planning graph sg  might be 
  

fib ryce   k ambhampati     mith

l     arm  clog  inp   inp  
sgu defined aggregate state s bsp   
l     arm  clog  inp   inp   inp   inp   
since two versions single planning graph identical semantics  aside initial
literal layer  proceed describing sgu graph point differences sg 
arise 
graph construction identical classical planning graphs  including mutex propagation 
stops two subsequent literal layers identical  level off   use planning graph formalism used ipp  koehler  nebel  hoffmann    dimopoulos        allow explicit representation conditional effects  meaning literal layer lk   action layer ak   effect
layer ek level k  persistence literal l  denoted lp   represented action
e  lp        lp     l  literal lk effect previous effect layer ek  contains
literal consequent  action action layer ak every one execution precondition
literals lk   effect effect layer ek associated action action layer ak
every one antecedent literals lk   using conditional effects planning graph avoids
factoring action conditional effects possibly exponential number non conditional
actions  adds extra planning graph layer per level  graph built  extract
heuristics 
aggregation  relaxed plans within single planning graph able measure 
optimistic assumptions  distance two belief states  relaxed plan represents
distance subset initial layer literals literals constituent belief
state  sgu   literals initial layer used support may hold
single state projected belief state  unlike sg    classical relaxed plan heuristic hsg
rp
finds set  possibly interfering  actions support goal constituent  relaxed plan rp
rp
rp
rp
rp
rp
subgraph planning graph  form  arp
    e    l         ab    eb    lb   
layers contains subset vertices corresponding layer planning graph 

formally  find relaxed plan support constituent  bs
  reached
sg
earliest graph  as found hlevel  bsi   heuristic appendix a   briefly  hsg
level  bsi  
returns first level b constituent bsi literals lb none marked
pair wise mutex  notice incorporate negative interactions heuristics 
start extraction level b  defining lrp
literals constituent used level
b
rp
heuristic  literal l lb   select supporting effect  ignoring mutexes  eb 
rp   prefer persistence literals effects supporting literals 
form subset eb 
rp
supporting set effects found  create arp
b  actions effect eb   
rp
rp added
needed preconditions actions antecedents chosen effects ab  eb 
list literals support lrp
b    algorithm repeats find needed actions
a    relaxed plans value summation number actions action layer 
literal persistence  denoted subscript p  treated action planning graph 
   single graph relaxed plan
relaxed plan include final computation   arp
j
heuristic computed
hsg
rp  bsi  

 

b 

j  

  

  arp
 
j

fip lanning g raph h euristics b elief pace earch

cbtc problem find relaxed plan sgu   shown figure   bold
edges nodes  since arm clog non mutex level two  use persistence
rp use persistence inp  
support clog dunkp  support arm lrp
    l 
sg
flush clog  thus  hrp  bsg       relaxed plan is 
   inp p   flush  
arp
 
e rp       inp p       flush   

   inp   clog  
lrp
 
   clogp   dunkp   
arp
 

e rp       clogp       dunkp    
   arm  clog  
lrp
 

relaxed plan use dunkp  dunkp  support arm  result arm
supported worlds  i e  supported state inp  holds initial
state   initial literal layer threw away knowledge inp  inp  holding different worlds 
relaxed plan extraction ignored fact arm needs supported worlds  even
sg  graph  see similar behavior reasoning single world 
single  unmodified classical planning graph cannot capture support possible worlds hence
explicit aggregation distance measures states  result  mention
aggregating states measure positive interaction  independence  overlap 
    multiple graph heuristics  m g 
single graph heuristics usually uninformed projected belief state bsp often corresponds multiple possible states  lack accuracy single graphs able
capture propagation multiple world support information  consider cbtc problem
projected belief state bsi using single graph sgu   dunkp  action
would say arm clog reached cost two  fact cost infinite
 since dunkp  support arm possible worlds   strong plan 
account lack support possible worlds sharpen heuristic estimate  set
multiple planning graphs considered  single graph  previously discussed 
multiple graphs similar graphs used cgp  smith   weld         lack
general cross world mutexes  mutexes computed within graph  i e  sameworld mutexes computed  construct initial layer l  graph different state
m bsp    multiple graphs  heuristic value belief state computed terms
graphs  unlike single graphs  compute different world aggregation measures
multiple planning graphs 
get informed heuristic considering states m bsp   
certain cases costly compute full set planning graphs extract relaxed plans 
describe computing full set planning graphs  later evaluate  in section     
effect computing smaller proportion these  single graph sg  extreme case
computing fewer graphs 
illustrate use multiple planning graphs  consider example cbtc  build two
graphs  figure    projected bsp   respective initial literal layers 
l      arm  clog  inp   inp  
l      arm  clog  inp   inp   

  

fib ryce   k ambhampati     mith

l 

inp 

a 

e 

inp 

a 

l 

inp 

e 

inp 

inp 
dunkp 

 

  dunkp  
  dunkp  

arm
clog

  dunkp  

arm
flush

  flush 

dunkp 

clog

flush

clog
inp 

inp 

inp 

inp 

l 

inp 

arm
arm

  dunkp  
  flush 

clog
clog
inp 

dunkp 

  dunkp  
  dunkp  

 

inp 

arm
arm
clog

  dunkp  

arm
flush

  flush 

dunkp 

clog

flush

clog

  dunkp  
  flush 

arm
clog
clog

figure    multiple planning graphs cbtc  relaxed plan components bolded  mutexes
omitted 

graph first possible world  arm comes dunkp  level   
graph second world  arm comes dunkp  level    thus  multiple
graphs show actions different worlds contribute support literal 
single planning graph sufficient aggregate state measures  following consider compute achievement cost belief state multiple graphs
aggregating state distances 
positive interaction aggregation  similar gpt  bonet   geffner         use worstg
case world represent cost belief state bsi using hm
mrp heuristic  difference
gpt compute heuristic planning graphs  compute plans state
space  heuristic account number actions used given world  assume
positive interaction across possible worlds 
g
hm
mrp heuristic computed finding relaxed plan rp planning graph  
exactly done single graph hsg
rp   difference unlike single graph relaxed
plan sgu   sg    initial levels planning graphs states  relaxed plan
reflect support needed world corresponding   formally 


b  

rp
g

  aj  
hm
mrp  bsi     max


j  

b level constituent bsg first reachable 
  

fip lanning g raph h euristics b elief pace earch

notice computing state distances states bsp bsi  
planning graph corresponds state bsp   extract single relaxed plan 
need enumerate states bsi find relaxed plan each  instead support
set literals one constituent bsi   constituent estimated minimum distance
state bsi first constituent reached  
g
cbtc  computing hm
mrp  bsg    figure    finds 
rp    
 
   inp p   flush  
arp
 

e rp        inp p       flush   
 
   inp   clog  
lrp
 
 
   clogp   dunkp   
arp
 

e rp        clogp       dunkp    

 
   arm  clog 
lrp
 

rp    
 
   inp p   flush  
arp
 

e rp        inp p       flush   

 
   inp   clog  
lrp
 
 
   clogp   dunkp   
arp
 

e rp        clogp       dunkp    

 
   arm  clog  
lrp
 

relaxed plan contains two actions taking maximum two relaxed plan values
g
gives hm
mrp  bsg        aggregation ignores fact must use different dunk actions
possible world 
g
independence aggregation  use hm
srp heuristic assume independence among
worlds belief state  extract relaxed plans exactly described previous heuristic
simply use summation rather maximization relaxed plan costs  formally 


 
b
rp
g

  aj  
hm
srp  bsi    


j  

b level constituent bsg first reachable 
g
mg
cbtc  computing hm
srp  bsg    find relaxed plans hmrp  bsg  
heuristic  sum values get           heuristic  aggregation ignores fact
use flush action possible worlds 
state overlap aggregation  notice two previous heuristics either taking
maximization accounting actions  taking summation possibly accounting
g
extra actions  present hm
rp u heuristic balance measure positive interaction
independence worlds  examining relaxed plans computed two previous heuristics
cbtc example  see relaxed plans extracted graph overlap 
 
 
notice  arp
arp
contain flush action irrespective package bomb
 
 
 
 
contains dunkp   arp
contains dunkp 
showing positive interaction  also  arp
 
 
  

fib ryce   k ambhampati     mith

showing independence  take layer wise union two relaxed plans  would
get unioned relaxed plan 
rpu  
u
   inp p   flush  
arp
 

e rpu       inp p       inp p       flush   
u
lrp
   inp   inp   clog  
 
u
   clogp   dunkp   dunkp   
arp
 

e rpu       clogp       dunkp       dunkp    
u
lrp
   arm  clog  
 

relaxed plans accounts actions possible worlds
actions differ  notice flush appears layer zero dunk actions
appear layer one 
order get union relaxed plans  extract relaxed plans  
two previous heuristics  computing heuristics regression search  start
last level  and repeat level  taking union sets actions relaxed plan
level another relaxed plan  relaxed plans end aligned  hence unioning levels
proceeds last layer relaxed plan create last layer rpu relaxed plan 
second last layer relaxed plan unioned on  progression search 
relaxed plans start aligned reflect start time  whereas regression
assume end time  summation number actions action
level unioned relaxed plan used heuristic value  formally 
g
hm
rp u  bsi    

b 


u
  arp
 
j

j  

b greatest level b constituent bsg first reachable 
cbtc  found rpu   counting number actions gives us heuristic value
g  bs       
hm
g
rp u
    labelled uncertainty graph heuristics  lu g 
multiple graph technique advantage heuristics aggregate costs multiple
worlds  disadvantage computing redundant information different graphs  c f 
g
figure    using every graph compute heuristics  c f hm
rp u    next approach addresses
limitations condensing multiple planning graphs single planning graph  called
labelled uncertainty graph  lu g   idea implicitly represent multiple planning graphs
collapsing graph connectivity one planning graph  use annotations  called labels    
retain information multiple worlds  could construct lu g generating
multiple graphs taking union  instead define direct construction procedure 
start manner similar unioned single planning graph  sgu   constructing initial
layer literals source belief state  difference lu g prevent
loss information multiple worlds keeping label literal records
worlds relevant  discuss  use simple techniques propagate
  

fip lanning g raph h euristics b elief pace earch

labels actions effects label subsequent literal layers  label propagation relies
expressing labels propositional formulas using standard propositional logic operations 
end product single planning graph labels graph elements  labels indicate
explicit multiple graphs  if build them  contain graph element 
trading planning graph structure space label storage space  choice bdds
represent labels helps lower storage requirements labels  worst case complexity
lu g equivalent g representation  lu gs complexity savings realized
projected possible worlds relevant actions completely disjoint  however 
often appear practice  space savings comes two ways      redundant representation actions literals avoided      labels facilitate non redundant representation
stored bdds  nice feature bdd package  brace  rudell    bryant        use
efficiently represents many individual bdds shared bdd leverages common substructure  hence  practice lu g contains information g much lower
construction usage costs 
section present construction lu g without mutexes  describe
introduce mutexes  finally discuss extract relaxed plans 
      l abel p ropagation
single graph multiple graphs  lu g based ip p  koehler et al        
planning graph  extend single graph capture multiple world causal support  present
multiple graphs  adding labels elements action a  effect e  literal l layers 
denote label literal l level k k  l   build lu g belief state bsp  
illustrate bsp   bsi cbtc example  label formula describing set states  in
bsp   graph element  optimistically  reachable  say literal l reachable
set states  described bs  k levels  bs    k  l   instance  say arm
reachable two levels l  contains arm bsi       arm   meaning models
worlds arm holds two levels superset worlds current belief state 
intuitive definition lu g planning graph skeleton  represents causal relations 
propagate labels indicate specific possible world support  show skeleton
cbtc figure    constructing graph skeleton largely follows traditional planning graph
semantics  label propagation relies simple rules  initial layer literal labelled 
indicate worlds bsp holds  conjunction literal bsp  
action labelled  indicate worlds execution preconditions co achieved 
conjunction labels execution preconditions  effect labelled  indicate
worlds antecedent literals actions execution preconditions co achieved 
conjunction labels antecedent literals label associated action  finally 
literals labelled  indicate worlds given effect  disjunction
labels effects previous level affect literal  following describe label
propagation detail work cbtc example 
initial literal layer  lu g initial layer consisting every literal non false   
label  initial layer label    l  literal l identical lbsp   representing states
bsp l holds  labels initial layer literals propagated actions
effects label next literal layer  describe shortly  continue propagation
label literal changes layers  condition referred level off 
  

fib ryce   k ambhampati     mith

l 

a 

e 

l 

a 

e 

l 

inp 

inp 

inp 

  inp 

  inp 

  inp 

inp 

inp 

inp 

  inp 

  inp 

dunkp 

  dunkp  
  dunkp  

dunkp 

  inp 
  arm

  dunkp  
  dunkp  

arm

arm

arm

clog

clog

clog

flush

  flush 

  clog

flush

  flush 

  clog

g
figure    lu g skeleton cbtc  mutexes  relaxed plan hlu
rp shown
bold 

lu g cbtc  shown figure    without labels   using bsp  bsi initial literal
layer 
l     inp   inp   inp   inp   clog  arm 
   inp        inp      arm clog inp  inp   
   inp        inp      arm clog inp  inp   
   clog       arm    bsp
notice inp  inp  labels indicating respective initial states hold 
clog arm bsp label hold states bsp  
action layer  previous literal layer lk computed  construct label action
layer ak   ak contains causative actions action set a  plus literal persistence  action
included ak label false  i e  k  a 
    label action level k  equivalent
extended label execution precondition 
k  a    k  e  a  
above  introduce notation extended labels k  f   formula f denote worlds
bsp reach f level k  say propositional formula f reachable bs
  

fip lanning g raph h euristics b elief pace earch

k levels bsi    k  f    since labels literals  substitute labels
literals literals formula get extended label formula  extended label
propositional formula f level k  defined 
k  f f     k  f   k  f   
k  f f     k  f   k  f   

k   f f      k  f f   
k   f f      k  f f   
k      bsp  
k      
k  l    k  l 
zeroth action layer cbtc is 
a     flush  inp p   inp p   inp p   inp p   clogp   armp  
   flush    bsp  
   inp p        inp p      arm clog inp  inp   
   inp p        inp p      arm clog inp  inp   
   clogp        armp     bsp
literal persistence label identical label corresponding literal
previous literal layer  flush action bsp label always applicable 
effect layer  effect layer ek depends literal layer lk action layer ak   ek
contains effect j  a  effect non false label  i e  k  j  a  
   
action effect must applicable world  label effect level k
conjunction label associated action extended label antecedent
k  j  a     k  a  k  j  a  
zeroth effect layer cbtc is 
e        flush      inp p       inp p       inp p   
   inp p       clogp       armp   
      flush     bsp
      inp p            inp p       arm clog inp  inp   
      inp p            inp p       arm clog inp  inp   
      clogp            armp      bsp
again  action layer  unconditional effect literal persistence label identical corresponding literal previous literal layer  unconditional effect flush
label identical label flush 
literal layer  literal layer lk depends previous effect layer ek    contains
literals non false labels  i e  k  l 
    effect j  a  ek  contributes label
literal l effect consequent contains literal l  label literal disjunction
labels effect previous effect layer gives literal 

k   j  a  
k  l   
j  a  lj  a  
j  a ek 

  

fib ryce   k ambhampati     mith

first literal layer cbtc is 
l     inp   inp   inp   inp   clog  clog  arm 
   inp        inp      arm clog inp  inp   
   inp        inp      arm clog inp  inp   
   clog       clog       arm    bsp
literal layer identical initial literal layer  except clog goes false
label  i e  existing layer  label bsp  
continue level one action layer l  indicate bsg reachable
bsp  arm
l     action layer one defined 
a     dunkp   dunkp   flush  inp p   inp p   inp p   inp p   clogp   armp   clogp  
   dunkp        dunkp        flush    bsp  
   inp p        inp p      arm clog inp  inp   
   inp p        inp p      arm clog inp  inp   
   clogp        armp        clogp     bsp
action layer similar level zero action layer  adds dunk actions
executable  add persistence clog  dunk action gets label identical
execution precondition label 
level one effect layer is 
e        dunkp       dunkp       dunkp       dunkp       flush      inp p   
   inp p       inp p       inp p       clogp       armp       clogp   
      dunkp            dunkp            flush     bsp
      dunkp       arm clog inp  inp   
      dunkp       arm clog inp  inp   
      inp p            inp p       arm clog inp  inp   
      inp p            inp p       arm clog inp  inp   
      clogp            armp            clogp      bsp
conditional effects dunk actions cbtc  figure    labels indicate
possible worlds give arm antecedents hold possible
worlds  example  conditional effect    dunkp   label found taking conjunction actions label bsp antecedent label    inp   obtain  arm clog inp 
inp   
finally  level two literal layer 
l     inp   inp   inp   inp   clog  clog  arm  arm 
   inp        inp      arm clog inp  inp   
   inp        inp      arm clog inp  inp   
   clog       clog       arm       arm    bsp
labels literals level   cbtc indicate arm reachable bsp label entailed bsp   label arm found taking disjunction
labels effects give it  namely   arm clog inp  inp   conditional
  

fip lanning g raph h euristics b elief pace earch

effect dunkp   arm clog inp  inp   conditional effect dunkp  
reduces bsp   construction could stop bsp entails label goal
k  armclog   k  arm  k  clog    bsp bsp   bsp   however  level occurs
next level change labels literals 
level occurs level three example  say bs  bs   
bsp   formula f reachable k steps bs    k  f    level k exists  f
reachable bs  level k  f reachable bs  first k
lower bound number parallel plan steps needed reach f bs  lower bound
similar classical planning max heuristic  nguyen et al          provide
informed heuristic extracting relaxed plan support f respect bs  described shortly 
      ame  w orld l abelled utexes
several types mutexes added lu g  start with  concentrate
evolve single possible world same world mutexes effective
well relatively easy understand  extend mutex propagation used
multiple graphs mutexes one planning graph  savings computing mutexes
lu g instead multiple graphs reduce computation mutex exits
several worlds  appendix b describe handle cross world mutexes  despite lack
effectiveness experiments conducted  cross world mutexes extend lu g compute
set mutexes found cgp  smith   weld        
same world mutexes represented single label  k  x    x     two elements
 actions  effect  literals   mutex holds elements x  x  worlds
   k  x    x     elements mutex world  assume label mutex
false   discuss labelled mutexes discovered propagated
actions  effect relations  literals 
using mutexes  refine means formula f reachable set
worlds bsp   must ensure every state bsp   exists state f reachable 
state f reachable state bsp two literals
mutex world bsp    k  s  
action  effect  literal layers multiple ways pair
elements become mutex  e g  interference competing needs   thus  mutex label pair
disjunction labelled mutexes found pair means 
action mutexes  same world action mutexes level k set labelled pairs actions 
pair labelled formula indicates set possible worlds actions
mutex  possible reasons mutex actions interference competing needs 

interference two actions a  interfere     unconditional effect consequent    a 
one inconsistent execution precondition e  a   other      vice versa 
additionally interfere     unconditional effect consequents    a     a  
inconsistent      execution preconditions e  a  e  a   inconsistent  mutex
exist possible world projections k  a      bsp   formally  interfere
  

fib ryce   k ambhampati     mith

one following holds 
       a  e  a    
    e  a     a    
       a     a    
    e  a  e  a    
competing needs two actions a  competing needs world pair literals
execution preconditions mutex world  worlds
mutex competing needs described by 


k  a  k  a  

k  l  l  

lj  a  l j  a  

formula find worlds pair execution preconditions l e  a   l
e  a   mutex actions reachable 
effect mutexes  effect mutexes set labelled pairs effects  pair labelled
formula indicates set possible worlds effects mutex  possible reasons
mutex effects associated action mutexes  interference  competing needs  induced effects 
mutex actions two effects  a   a   j  a    a   mutex worlds
associated actions mutex  k  a    
interference actions  two effects  a   j  a   interfere     consequent  a 
one inconsistent antecedent j  a   other      vice versa  additionally interfere     effect consequents  a  j  a   inconsistent     
antecedents  a  j  a   inconsistent  mutex exist possible world projections  label mutex k  i  a   j  a      bsp   formally   a  j  a  
interfere one following holds 
     a  j  a    
     a  j  a    
     a  j  a    
     a  j  a    
competing needs actions  two effects competing needs world pair
literals antecedents mutex world  worlds  a  j  a  
competing needs mutex are 
k  i  a   k  j  a   



k  l  l  

li  a  l j  a  

formula find worlds pair execution preconditions l  a   l
j  a   mutex actions reachable 
  

fip lanning g raph h euristics b elief pace earch

lk

lk p 
p

ek

ak

lk a 


h a 

lk h a  



lk p  q 
induced mutex worlds 

lk j a  h a  lk i a  



lk j a   h a  

lk q 
q
lk a 


j a 

lk r 
r

lk j a  
i a  induces j a  in 
lk i a  lk j a  

i a  lk i a  

figure    effect  a  induces effect j  a   j  a  mutex h  a     a  induced mutex
h  a   

induced induced effect j  a  effect  a  effect action
may execute time  effect induced another possible worlds
reachable  example  conditional effect action always induces
unconditional effect action 
induced mutexes  involving inducing effect  a   come induced effect
j  a  mutex another effect h  a    see figure     induced mutex
 a  effect h  a   mutex induced effect j  a   b  inducing effect
 a   label mutex conjunction label mutex k  j  a   h  a   
label induced effect j  a   additional discussion methodology behind
induced mutexes refer smith weld        

literal mutexes  literal mutexes set labelled pairs literals  pair labelled
formula indicates set possible worlds literals mutex  reason
mutex literals inconsistent support 
inconsistent support two literals inconsistent support possible world level k
two non mutex effects support literals world  label
literal mutex level k disjunction worlds inconsistent support 
worlds inconsistent support mutex l l are 
  

fib ryce   k ambhampati     mith





s i  a  j  a  e

k   
li  a  l j  a   
s  k   i  a  j  a   

meaning formula two literals mutex worlds
pairs effects support literals mutex s 
      lu g h euristics
heuristics computed lu g capture measures similar g heuristics 
exists new opportunity make use labels improve heuristic computation efficiency  single
planning graph sufficient state aggregation measured  mention
measures lu g 
positive interaction aggregation  unlike g heuristics  compute positive interaction
based relaxed plans lu g  g approach measure positive interaction across
state belief state compute multiple relaxed plans take maximum value  get
measure lu g would still need extract multiple relaxed plans  situation
trying avoid using lu g  graph construction overhead may lowered using
lu g  heuristic computation could take long  hence  compute relaxed plans
lu g measure positive interaction alone  compute relaxed plans measure
overlap  which measures positive interaction  
independence aggregation  positive interaction aggregation  need relaxed plan every
state projected belief state find summation costs  hence  compute
relaxed plans assume independence 
g
state overlap aggregation  relaxed plan extracted lu g get hlu
rp heuristic

g

g
resembles unioned relaxed plan hrp u heuristic  recall hrp u heuristic extracts
relaxed plan multiple planning graphs  one possible world  unions
set actions chosen level relaxed plans  lu g relaxed plan heuristic
similar counts actions positive interaction multiple worlds
accounts independent actions used subsets possible worlds  advantage
g
hlu
rp find actions single pass one planning graph 
trading cost computing multiple relaxed plans cost manipulating lu g
labels determine lines causal support used worlds  relaxed plan
want support goal every state bsp   need track states
bsp use paths planning graph  subgoal may several different  and possibly
overlapping  paths worlds bsp  
rp
rp
rp
rp
rp
rp
lu g relaxed plan set layers   arp
    e    l         ab    eb    lb    ar
rp
rp
set actions  er set effects  lr   set clauses  elements layers
labelled indicate worlds bsp chosen support  relaxed plan
g
extracted level b   hlu
level  bsi    i e   first level bsi reachable  described
appendix a  
please note extracting relaxed plan bsi terms clauses  literals  different sg g versions relaxed plans  previously found

  

fip lanning g raph h euristics b elief pace earch

constituent bsi first reached planning graph commit
one constituent  rationale possibly using different constituents
multiple graphs  condensed version multiple graphs still want able
support different constituents bsi different worlds  could use constituent representation bsi defining layers relaxed plan  choose clausal representation
bsi instead know support clause  however constituents
know need support one  but dont need know one  
relaxed plan  shown bold figure    bsi reach bsg cbtc listed follows 
   inp p   inp p   flush  
arp
 
rp
   inp p      arm clog inp  inp   
rp
   inp p      arm clog inp  inp   
rp
   flush    bsp  
e rp       inp p       inp p       flush   
 
rp
     inp p       arm clog inp  inp   
 
rp
     inp p       arm clog inp  inp   
rp
      flush     bsp  
   inp   inp   clog  
lrp
 
rp
   inp      arm clog inp  inp   
rp
   inp      arm clog inp  inp   
rp
   clog    bsp  
   dunkp   dunkp   clogp   
arp
 
rp
   dunkp      arm clog inp  inp   
rp
   dunkp      arm clog inp  inp   
rp
   clogp     bsp  
e rp       dunkp       dunkp       clogp    
 
rp
     dunkp       arm clog inp  inp   
 
rp
     dunkp       arm clog inp  inp   
rp
      clogp      bsp  
   arm  clog  
lrp
 
rp
   arm    bsp  
rp
   clog    bsp
start forming lrp
clauses  bsg    namely arm clog  label
 
clauses bsp need supported states belief state  next 
support clause lrp
relevant effects e  form e rp   clog use
 
persistence supports clog worlds described bsp  this example positive
interaction worlds   arm relevant effects respective   dunk action 
choose effects support arm need support arm worlds bsp  
effect gives support one world  this example independence worlds  
appropriate label indicating
insert actions associated chosen effect arp
 
  

fib ryce   k ambhampati     mith

worlds needed  general fewer worlds reachable  i e 
rp execution preconditions
always case rp
r       r      next form l 
actions arp
antecedents effects e rp   clog  inp   inp   labelled
 
worlds action effect needed them  fashion level two  support
literals level one  using persistence inp  inp   flush clog  stop here 
supported clauses level one 
general case  extraction starts level b bsi first reachable bsp  
rp
rp
rp contains clauses
first relaxed plan layers construct arp
b    eb    lb   lb
rp
c  bsi    labelled k  c    bsp  
choosing relevant effects
level r    r b  support clause lrp
r
rp   effect j  a  relevant reachable worlds
er  form er 
need support c  i e  r   j  a   rp
r  c 
   consequent gives literal l c 
clause  choose enough supporting effects chosen effect worlds
superset worlds need support clause  formally 









rp
rp
j

 c 
  

 
 a  
clrp


r
r 
r
j

 a  lj  a  

lc 
j  a er 

think supporting clause set worlds set cover problem effects cover
subsets worlds  algorithm cover worlds clause worlds effects variant
well known greedy algorithm set cover  cormen  leiserson    rivest         first
choose relevant persistence effects cover worlds  choose action effects cover
rp labelled new
new worlds  effect choose support added er 
rp
worlds covered c  clauses lr covered  form action layer arp
r 
rp   actions arp labelled indicate worlds
actions effect er 
r 
rp  
effects labelled er 
obtain next subgoal layer  lrp
r    adding literals execution preconditions
rp
rp   literal l lrp labelled indicate
actions ar  antecedents effects er 
r 
worlds action effect requires l  support literals lrp
r  fashion
 

continue

support
literals

effects 
insert
actions 

insert action effect
lrp
r
rp
preconditions supported literals l   
g
get relaxed plan  relaxed plan heuristic  hlu
rp  bsi    summation
number actions action layer  formally 
g
hlu
rp  bsi  

 

b 


  arp
 


i  
g
thus cbtc example hlu
rp  bsg        notice construct lu g
without mutexes cbtc reach goal two layers  included mutexes
lu g  would reach goal three layers  way use mutexes change
relaxed plan use mutexes influence relaxed plan extraction  mutexes help
identify belief state bsi reachable bsp  

  

fip lanning g raph h euristics b elief pace earch

problem

pddl parser
 ipc 
actions

belief
states

search engine
 hsp r  caltalt 
lao   pond 

heuristics

bdds
 cudd 

labels

 pond only 

planning
graph s 
 ipp 

figure    implementations caltalt p rely many existing technologies 
search engine guided heuristics extracted planning graphs 

   empirical evaluation  setup
section presents implementation caltalt p planners domains
use experiments  tests run linux x   machine     ghz p  processor
 gb ram timeout    minutes  caltalt p used heuristic weight
five the  respective  a  ao  searches  compare competing approaches  cgp 
sgp  gpt v      mbp v      kacmbp  yka  cff  several domains problems 
planners domain problem files compared planners found
online appendix 
    implementation
implementation caltalt uses several off the shelf planning software packages  figure  
shows diagram system architecture caltalt p d  caltalt extends
name altalt  relies limited subset implementation  components caltalt
ipc parser pddl      slightly extended allow uncertain initial conditions   hspr search engine  bonet   geffner         ipp planning graph  koehler et al         
cudd bdd package  brace et al         implement lu g labels  custom parts
implementation include action representation  belief state representation  regression operator 
heuristic calculation 
implementation p similar caltalt aside search engine 
state action representation  p uses ipp source code planning graphs  p
uses modified lao   hansen   zilberstein        source code eric hansen perform ao 
  

fib ryce   k ambhampati     mith

problem
rovers 
rovers 
rovers 
rovers 
rovers 
rovers 
logistics 
logistics 
logistics 
logistics 
logistics 
bt n 
btc n 
cubecenter n 
ring n 

initial
states
 
 
 
 
  
  
 
 
 
 
 
n
n
n 
n n

goal
literals
 
 
 
 
 
 
 
 
 
 
 
 
 
 
n

fluents
  
  
  
  
  
   
  
  
  
  
  
n  
n  
 n
 n

causative
actions
  
  
  
  
  
   
  
   
   
   
   
n
n  
 
 

observational
actions
      
      
      
      
      
      
      
      
      
      
      
   n 
   n 
 
 

optimal
parallel
     
     
      
      
     
     
     
     
     
     
     
     
 n      
  n     
 n  

optimal
serial
     
     
      
       
      
     
     
       
      
      
      
n  n   
 n    n   
  n     
 n  

table    features test domains problems   number initial states  number goal literals  number fluents  number causative actions  number observational actions 
optimal number parallel plan steps  optimal number serial plan steps  data conditional versions domains braces  plan lengths conditional plans maximum
conditional branch length 

search  cudd  brace et al         represent belief states actions  even deterministic
actions possible obtain cycles actions observations planning
belief space  p constructs search graph directed acyclic graph employing cyclechecking algorithm  adding hyper edge search graph creates cycle  hyper edge
cannot represent action strong plan hence added graph 
    domains
table   shows relative features different problems used evaluate approach  table shows number initial states  goal literals  fluents  actions  optimal
plan lengths  used guide gauge difficulty problems  well
performance 
conformant problems addition standard domains used conformant planningsuch
bomb in the toilet  ring  cube center  developed two new domains logistics
rovers  chose new domains difficult subgoals  many
plans varying length 
ring domain involves ring n rooms room connected two adjacent
rooms  room window open  closed  locked  goal every
window locked  initially  state possible could room window could
configuration  four actions  move right  move left  close window current
  

fip lanning g raph h euristics b elief pace earch

room  lock window current room  closing window works window
open  locking window works window closed  good conformant plan involves
moving one direction closing locking window room 
cube center domain involves three dimensional grid  cube  six actions
possible move two directions along dimension  dimension consists n possible
locations  moving direction along grid points leaves one
position  using phenomena  possible localize dimension repeatedly moving
direction  initially possible location cube goal reach
center  good conformant plan involves localizing corner moving center 
rovers domain conformant adaptation analogous domain classical planning
track international planning competition  long   fox         added uncertainty
initial state uses conditions determine whether image objective visible various
vantage points due weather  availability rock soil samples  goal upload
image objective rock soil sample data  thus conformant plan requires visiting
possible vantage points taking picture  plus visiting possible locations soil
rock samples draw samples 
first five rovers problems   waypoints  problems one four one
four locations  respectively  desired imaging objective possibly visible  at least one
work  dont know one   problem   adds rock soil samples part goal
several waypoints one obtained  again  dont know waypoint
right sample   problem   adds two waypoints  keeps goals problem
  changes possible locations rock soil samples  cases waypoints
connected tree structure  opposed completely connected 
logistics domain conformant adaptation classical logistics domain trucks
airplanes move packages  uncertainty initial locations packages  thus  actions
relating movement packages conditional effect predicated package
actually location  conformant version  drivers pilots cannot sense communicate packages actual whereabouts  problems scale adding packages cities 
logistics problems consist one airplane  cities airport  post office 
truck  airplane travel airports trucks travel within cities  first
problem two cities one package could start either post office  goal get
package second citys airport  second problem adds another package
possible starting points destination  third problem three cities
one package could post office reach third airport  fourth problem
adds second package third problem starting ending locations  fifth
problem three cities three packages  one two three post offices
reach different airports 
conditional problems conditional planning consider domains literature  bombin the toilet sensing bts  bomb in the toilet clogging sensing btcs 
extend conformant logistics rovers include sensory actions 
rovers problem allows rover  particular waypoint  sense availability image  soil  rock data location  locations collectable data expressed
one of constraints  rover deduce locations collectable data failing sense
possibilities 
  

fib ryce   k ambhampati     mith

logistics observations determine package location exists  observation
assumed made driver pilot particular location  since several drivers
pilot  different agents make observations  information gained agents assumed
automatically communicated others  planner agent knowledge  

   empirical evaluation  inter heuristic comparison
start comparing heuristic approaches within planners  next section  continue
describing planners  using best heuristics  compare state art
approaches  section intend validate claims belief space heuristics measure
overlap perform well across several domains  justify using lu g multiple
planning graphs applying mutexes improve heuristics regression pruning belief
states 
compare many techniques within caltalt p conformant planning domains  addition test heuristics p conditional domains  performance metrics include total planning time number search nodes expanded  additionally  discussing mutexes analyze planning graph construction time  proceed
showing heuristics perform caltalt various mutex computation schemes
lu g affect performance  present p performs different
heuristics conformant conditional domains  explore effect sampling proportion
worlds build sg    g  lu g graphs  compare heuristic estimates p
optimal plan length gauge heuristic accuracy  finish summary important
conclusions 
compute mutexes planning graphs caltalt planning graph s 
built search episode mutexes help prune inconsistent belief states encountered
regression search  abstain computing mutexes p progression
build new planning graphs search node want keep graph computation time low 
exception discussion sampling worlds construct planning graphs 
planning graphs constructed deterministically  means single graph unioned
single graph sgu   g lu g graphs built possible worlds 
    caltalt
results caltalt conformant rovers  logistics  bt  btc domains  terms
total time number expanded search nodes  presented table    show number
expanded nodes gives indication well heuristic guides planner  total
time captures amount time computing heuristic searching  high total time
high number search nodes indicates poor heuristic  high total time low number
search nodes indicates expensive informed heuristic 
discuss ring cube center domains caltalt cannot solve
even smallest instances  due implementation details planner performs poorly
domains actions several conditional effects hence scale  trouble stems
   problem may interesting investigate multi agent planning scenario  assuming global communication
 e g  radio dispatcher  

  

fip lanning g raph h euristics b elief pace earch

problem
rovers  
 
 
 
 
 
logistics  
 
 
 
 
bt  
  
  
  
  
  
  
  
  
btc  
  
  
  
  
  
  
  

h 
      
       

      

    
       

    
        

 

hcard
        

      

    
     
      
       
       
        
        
        
        
    
      
       
       
        
        
         
          

hsg
rp
     
       
        

     
       
       
         

    
       

    
        

 

g
hm
mrp
     
      
        
        

     
        
        

    
       

    
        

 

g
hm
rp u
     
       
       
       

      
        

    
      
       
       
        

    
      
       
       
        

 

lu g f x 

hrp
       
       
        
        

      
        
        
         

    
     
      
       
       
        
        
        
         
    
       
        
         

 

table    results caltalt conformant rovers  logistics  bt  btc  data total
time     expanded nodes  indicates time     minutes    indicates
attempt 

weak implementation bringing general propositional formulas  obtained regression
several conditional effects  cnf 
describe results left right table    comparing different planning graph
structures relaxed plans computed planning graph  start non planning
graph heuristics h  hcard   expected  h    breadth first search  perform well
large portion problems  shown large number search nodes inability scale
solve larger problems  notice hcard heuristic performance good bt
btc problems  this confirms results originally seen bertoli  cimatti    roveri      a  
however  hcard perform well rovers logistics problems size
belief state  planning  necessarily indicate belief state good plan 
part reason hcard works well domains measures knowledge  plans
domains largely based increasing knowledge  reason hcard performs poorly
domains finding causal support  which measure  important
knowledge domains 
  

fib ryce   k ambhampati     mith

next  single planning graph  sgu    caltalt reasonably well hsg
rp heuristic
rovers logistics domains  fails scale well bt btc domains  rovers
logistics comparatively fewer initial worlds bt btc problems  moreover
deterministic plans  assuming initial state real state  somewhat similar rovers
logistics  mostly independent bt btc  therefore  approximating fully observable plan single graph relaxed plan reasonable plans achieving goal
world high positive interaction  however  without high positive interaction heuristic
degrades quickly number initial worlds increases 
multiple planning graphs  caltalt able perform better rovers domain  takes
quite bit time logistics  bt  btc domains  rovers  capturing distance estimates
individual worlds aggregating means tends better aggregating
worlds computing single distance estimate  as single graph   logistics  part
reason computing multiple graphs costly computing mutexes
planning graphs  bt btc  total time increases quickly number planning
graphs  number relaxed plans every search node increase much problems get larger 
g
mg
comparing two multiple graph heuristics  caltalt namely hm
mrp hrp u  

g
see effect choices state distance aggregation  hmrp relaxed plan heuristic
aggregates state distances  found planning graph  taking maximum distance 
g
hm
rp u unions relaxed plans graph  counts number actions unioned
g
relaxed plan  single graph relaxed plan  hm
mrp relaxed plan essentially measures
one state state distance  thus  performance suffers bt btc domains  however  using
unioned relaxed plan heuristic  capture independence among multiple worlds
scale better bt btc  despite usefulness unioned relaxed plan  costly
compute scalability limited  turn lu g version measure 
lu g f x 

lu g  use hrp
heuristic caltalt  heuristic uses lu g
g
full cross world mutexes  denoted f x   similar hm
rp u heuristic  measuring overlap
important  improving speed computing heuristic tends improve scalability
caltalt  caltalt slower rovers btc domains using lu g  note
added cost computing cross world mutexes able improve
speed relaxing mutexes  describe shortly 
    mutexes
mutexes used help determine belief state unreachable  mutexes improve pruning
power heuristics accounting negative interactions  mutexes used improve
heuristics  reasonable compute subset mutexes  would know
mutexes cost effective number possible mutexes find
quite large 
use several schemes compute subset mutexes  schemes combine different
types mutexes types cross world checking  mutex types are  computing mutexes
 nx   computing static interference mutexes  stx   computing  stx  plus inconsistent support competing needs mutexes dynamic mutexes  dyx   computing  dyx  plus induced
mutexes full mutexes  fx   cross world checking  see appendix b  reduction schemes are 
g
   show hm
srp p d 

  

fiproblem
rovers  
 
 
 
 
 
logistics  
 
 
 
 
bt  
  
  
  
  
  
  
  
  
btc  
  
  
  
  
  
  
  

lu g n x 

hrp
          
         
           

        
             

      
       
         
          
           
            
            
            
              
      
       
         
          
           
            
             
             

lu g stx 

hrp
          
         
           

         
             

      
       
         
          
           
            
            
            
              
      
       
         
          
           
            
             
             

lu g dyx 

hrp
          
           
            
            
              

          
            
             
              

      
        
          
           
            
             
             
              
               
      
        
          
           
            

 

lu g f x 

hrp
          
           
            
            

         
            
            
              

      
        
          
           
            
             
             
              
               
      
          
            
              

 

lu g dyxsx 

hrp
          
           
            
            
             
              
         
           
            
            
             
      
        
          
           
            
             
             
              
               
      
        
          
           
            
             
              


lu g dyxix 

hrp
          
           
            
            
              
              
         
           
            
            
              
      
        
          
           
            
             
             
              
               
      
        
          
           
            
             
              


lu g f xsx 

hrp
          
           
            
            
             
              
         
           
            
            
             
      
        
          
           
            
             
             
              
               
      
        
          
           
            
             
              


lu g f xix 

hrp
          
           
            
            
              
              
         
           
            
            
              
      
        
          
           
            
             
             
              
               
      
         
            
              
               

 

p lanning g raph h euristics b elief pace earch

g
table    results caltalt using hlu
rp mutex schemes  data graph construction
time  ms  all time  ms    expanded nodes  indicates time     minutes 
  indicates attempt 

  

fib ryce   k ambhampati     mith

computing mutexes across same worlds  sx  computing mutexes across pairs worlds
intersection  conjunction  element labels  ix  
table   shows within caltalt  using relaxed plan heuristic changing way
compute mutexes lu g drastically alter performance  often  cross world mutexes
numerous building lu g takes much time  see could reduce graph
g
construction overhead without hindering performance  evaluated hlu
rp lug built
 a  considering cross world relations  schemes  nx    stx    dyx    fx    b 
same world relations schemes  dyx sx   fx sx    c  cross world relations
possible worlds pairs intersection elements labels  dyx ix   fx ix  
results show simpler problems bt btc benefit much advanced
computation mutexes beyond static interference  however  rovers logistics problems  advanced mutexes play larger role  mainly  interference  competing needs  inconsistent
support mutexes important  competing needs inconsistent support mutexes seem
large impact informedness guidance given lu g  scalability improves
here  induced mutexes dont improve search time much  add graph computation
time  possible reason induced mutexes dont help much domains actions
two effects  unconditional conditional effect  reducing cross world mutex
checking helps quite bit  seems checking same world mutexes sufficient
solve large problems  interestingly  g graphs compute same world interference  competing
needs  inconsistent support mutexes within graph  equating scenario  dyxsx   however  lug provides much faster construction time  evidenced lu gs ability
out scale g 
    p
show total time number expanded nodes p solving conformant
problems  including ring cube center  table    p solving conditional
problems table    caltalt show total time number expanded nodes
g
test  add hm
srp heuristic  implemented caltalt  takes summation
values relaxed plans extracted multiple planning graphs  compute mutexes
planning graphs used heuristics p mainly build planning
graphs search node  proceed first commenting performance p d 
different heuristics  conformant domains  discuss conditional domains 
conformant domains  p generally better caltalt  may attributed
part implementation level details  p makes use existing  highly optimized  bdd
package belief state generation progression  previously mentioned  caltalt relies
less optimized implementation belief state generation regression  see next
section  regression planners employ sophisticated implementation perform much better 
could still benefit heuristics  aside differences mention  see
similar trends performance various heuristics caltalt p d  namely 
n g sg heuristics limited ability help planner scale  g heuristics help
planner scale better costly  lu g provides best scalability  difference
g lu g especially pronounced cube center ring  size
initial belief state quite large instances scale  interestingly ring  breadth first
search single graph relaxed plan able scale due reduced heuristic computation time
  

fip lanning g raph h euristics b elief pace earch

problem
rovers  
 
 
 
 
 
logistics  
 
 
 
 
bt  
  
  
  
  
  
  
  
  
btc  
  
  
  
  
  
  
  
cubecenter  
 
 
 
  
  
ring  
 
 
 
 
 
 
 
  

h 
      
       
         

       

     
        

     
         

      
        
          

     
     
      
       
        
          
           
             


hcard
      
       
        
          

       

     
       

     
        

     
     
      
      
        
        
    
     
     
     
     
     
     
     
     

hsg
rp
     
      
        
          

      

     
         

     
         

     
         
           
            

     
     
       
        
          
           
            

 

g
hm
mrp
     
       
       
         
         
          
      
       
         
       
        
     
        

     
          

       
         

    
       
        

 

g
hm
srp
     
      
       
        
        
        
      
        
       
         
         
     
      
       
        
         
         

     
      

     
        
          

    
     
       
         

 

g
hm
rp u
     
      
       
       
        
        
     
       
       
         
          
     
      
       
        
         
         

     
      
       
        
         
          

       
        
           

    
      
        

 

g
hlu
rp
     
      
      
       
       
        
     
      
       
       
       
     
      
       
       
        
        
        
         
         
     
      
       
       
        
        
         
          
     
        
          
           
            

    
     
      
      
       
         
          

 

table    results p conformant rovers  logistics  bt  btc  cube center  ring 
data total time  ms    expanded nodes  indicates time   indicates
attempt 

low branching factor search  lu g able provide good search guidance  tends
take long time computing heuristics ring 
able compare choices aggregating distance measures reg
laxed plans multiple graphs  see taking maximum relaxed plans  hm
mrp  
assuming positive interaction among worlds useful logistics rovers  loses independence worlds bt btc domains  however  taking summation relaxed plan
  

fib ryce   k ambhampati     mith

problem
rovers  
 
 
 
 
 
logistics  
 
 
 
 
bt  
  
  
  
  
  
  
  
  
btc  
  
  
  
  
  
  
  

h 
      
        
        
         

       

     

     

 

hcard
      
      
      
      


     
      
      
      
      
       
        
         
         
     
      
      
      
      
       
        
        

hsg
rp
     
      
        
        

      

     
           

     
            

 

g
hm
mrp
     
      
      
       
         
         
      
       
       
       
         
     
      
       
        
         
         

     
       
        
        
         
         

 

g
hm
srp
     
      
      
       
         
         
      
       
       
       
         
     
      
       
        
         
         

     
       

 

g
hm
rp u
     
      
      
       
         
         
      
       
       
       
         
     
       
       
        
         

     
       
        
        
         

 

g
hlu
rp
     
      
      
      
        
         
      
       
       
       
         
     
      
       
       
        
        
         
          
          
     
      
       
       
        
        
          
          

table    results p conditional rovers  logistics  bts  btcs  data total time
 ms    expanded nodes  indicates time     minutes    indicates
attempt 

g
values different worlds  hm
srp able capture independence bt domain  notice
summation help p btc domain  overestimate
heuristic value nodes counting flush action world fact
g
needs done  i e  miss positive interaction   finally  using hm
rp u heuristic
well every domain  aside cost computing multiple graph heuristics 
account positive interaction independence taking overlap relaxed plans 
again  lu g relaxed plan  analogous multiple graph unioned relaxed plan  p
scales well measure overlap lower cost computing heuristic significantly 

main change see using p versus caltalt direction search
different  hcard heuristic performs unlike before  bt btc domains cardinality
work well progression size belief states change get closer
goal  it impossible ever know package contains bomb   however  regression
start belief state containing states consistent goal regressing actions limits
  

fip lanning g raph h euristics b elief pace earch

belief state states reach goal actions  thus regression
size belief states decreases  progression remains constant 
performance p conditional domains exhibits similar trends conformant domains  exceptions  conformant domains  g relaxed plans tend
outperform sg relaxed plan  lu g relaxed plan best overall  unlike conformant
g
domains  hm
mrp performs much better bts btcs bt btc partly
conditional plans lower average cost  hcard heuristic better bts btcs
bt btc belief states actually decrease size partitioned
sensory actions 
    sampling worlds
evaluations point considered effectiveness different heuristics  computed respect possible worlds belief state  would use many
possible worlds can  reduce computation cost hopefully still get reasonable
heuristics considering subset worlds  scheme considering subsets worlds
heuristics sample single world  sg     sample given percentage worlds
build multiple graphs  lu g 
mg
lu g
sampling approaches  use hsg
rp   hrp u   hrp relaxed plans  build
g lu g                         worlds belief state  sampled
randomly  figure     show total time taken  ms  solve every problem test set
    problems    domains   unsolved problem contributed    minutes total time 
comparison show previously mentioned heuristics  hsg
rp computed unioned single
u
graph sg   denoted unioned compared sampled single graph sg  denoted single 
g
lu g
hm
rp u hrp computed worlds denoted       total time heuristic
samples worlds averaged ten runs 
two major points see figure     first  hsg
rp heuristic much effective
 
u
computed sg versus sg   sg  less optimistic  builds
planning graph real world state  opposed union literals possible world states 
sgu   respecting state boundaries considering single state better ignoring
state boundaries naively consider possible states  however  seen g
lu g heuristics  respecting state boundaries considering several states much better 
bringing us second point 
see different performance using possible worlds build multiple graphs
compared lu g  better using fewer worlds build multiple graphs
become costly number worlds increases  contrast  performance
improves possible worlds use lu g  using possible worlds compute
heuristics good idea  takes efficient substrate exploit them 
    accuracy
heuristics account overlap possible worlds accurate
heuristics make assumption full positive interaction full independence  check
intuitions  compare heuristic estimates distance initial belief state
goal belief state heuristics used conformant problems solved p d  figure
   shows ratio heuristic estimate h bsi   optimal serial plan length h  bsi  
  

fib ryce   k ambhampati     mith

sg
mg
lug

  

  

  

  

 

 

 

 

 
unioned

single

   

   

   

   

   

    

figure     total time  hours  p solve conformant conditional problems
sampling worlds use heuristic computation 

several problems  points line  where ratio one  under estimates 
over estimates  problem instances shown optimal plan
length known 
g
mg

note domains hlu
rp hrp u heuristics close h   confirming

g

g

intuitions  interestingly  hsrp hmrp close h rovers logistics 
whereas former close bt btc problems  latter close cubecenter
ring  expected  assuming independence  using summation  tends over estimate 
assuming positive interaction  using maximization  tends under estimate  hsg
rp heuristic
tends under estimate  cases  cubecenter ring  gives value zero  because
initial state satisfies goal   hcard heuristic accurate bt btc 
under estimates rovers logistics  over estimates cube center ring 

accuracy heuristics cases disconnected run time performance 
instance hcard highly overestimates ring cube center  well domains
g
mg
exhibit special structure heuristic fast compute  hand  hlu
rp hrp u
  

fip lanning g raph h euristics b elief pace earch

     
    
   
  
 
   
    
     

 
 
 
 

 
  
 
 
 
 


 
 


 











 





        
 
 

 

  
 
   

 

 
 






 


  
  
      
     
 
  
 
 
  
 
        
 
 
 
 
 
  
  
 
  
  
  
  
  
  
 
  
  
  
 
hcard  
hsg
rp  

g
hmrp
 

g
hsrp
g
hm
rp u
g
hlu
rp

rv  rv  l 

l  b  

b   bc  
bc   c 
problem

c   r 

r  

figure     ratio heuristic estimates distance bsi bsg optimal plan length 
rv   rovers  l   logistics  b   bt  bc   btc  c   cube center  r   ring 

accurate many domains  suffer ring cube center costly
compute 
    inter heuristic conclusions
findings fall two main categories  one  effective estimates belief state distances
terms state state distances  two  exploit planning graphs support
computation distance measures 
comparing ways aggregate state distance measures compute belief state distances 
found measuring interaction single graph heuristics tends poorly guide planners 
measuring independence positive interaction worlds works well specific domains 
measuring overlap  i e  combination positive interaction independence  tends work well
large variety instances  studying accuracy heuristics found
cases accurate effective  however find accurate
best cases 
comparing graph structures provide basis belief state distance measures  found
heuristics extracted single graph fail systematically account independence positive interaction among different possible worlds  despite lack distance
measure  single graphs still identify structure domains rovers logistics 
accurately reflect belief state distances  multiple graphs reason reachability
world independently  accuracy comes cost computing lot redundant g structure limiting instances large belief states  reduce cost g structure
  

fib ryce   k ambhampati     mith

planner
caltalt
p
mbp
kacmbp
cgp
sgp
gpt
yka
cff

search space
belief space
belief space
belief space
belief space
planning graph
planning graph
belief space
belief space
belief space

search direction
backward
forward
forward backward
forward
backward
backward
forward
backward
forward

conditional






heuristic
planning graph
planning graph
cardinality
cardinality
planning graph
planning graph
state space plans
cardinality
planning graph

implementation
c
c
c
c
lisp
lisp
c
c
c

table    comparison planner features 
sampling worlds used construction  however planners able exhibit better scalability
considering worlds optimizing representation redundant structure
lu g  improvement scalability attributed lowering cost heuristic computation  retaining measures multiple state distances  lu g makes trade off using
exponential time algorithm evaluation labels instead building exponential number
planning graphs  trade off justified experiments 

   empirical evaluation  inter planner comparison
first compare caltalt p several planners conformant domains 
compare p conditional planners conditional domains  purpose
section identify advantages techniques state art planners  end
section discussion general conclusions drawn evaluation 
    conformant planning
although work aimed giving general comparison heuristics belief space planning 
present comparison best heuristics within caltalt p
leading approaches conformant planning  table   lists several features evaluated
planners  search space  search direction  whether conditional  type
heuristics  implementation language  note  since approach uses different planning
representation  bdds  graphplan  etc    even use heuristics  hard get
standardized comparison heuristic effectiveness  furthermore  planners use pddllike input syntax  mbp  kacmbp use ar encodings may give advantage
reducing number literals actions  gave mbp planners grounded
filtered action descriptions used caltalt p d  tried  report
results  giving mbp planners full set ground actions without filtering irrelevant actions 
appears mbp planners use sort action pre processing performance
much worse full grounded set actions  nevertheless  table   compares mbp  kacmbp 
lu g dyxsx 
g
gpt  cgp  yka  cff hrp
caltalt hlu
rp p respect
run time plan length 
mbp  mbp planner uses cardinality heuristic many cases overestimates plan distances
 as per implementation hcard    mbp uses regression search conformant plans 
progression search conditional plans  interesting note difficult problem
  

fip lanning g raph h euristics b elief pace earch

problem
rovers  
 
 
 
 
 
logistics  
 
 
 
 
bt  
  
  
  
  
  
  
  
  
btc  
  
  
  
  
  
  
  
cubecenter  
 
 
 
  
ring  
 
 
 
 
 
 

caltalt
lu g dyxsx 
hrp u
       
       
        
        
        
         
     
       
        
        
        
    
     
      
       
       
        
        
        
         
    
     
      
       
       
        
         
         


 

pond
g
hlu
rp
     
     
      
       
       
       
     
      
       
       
       
     
      
       
       
        
        
        
         
         
     
      
       
       
        
        
         
          
    
       
        
         
         
    
    
      
      
       
        
         

mbp

kacmbp

gpt

cgp

yka

cff

    
     
      
       
oom
      
    
      
      
       
oom
   
      
     
      
      
      
      
      
       
   
      
     
      
      
       
        
        
    
     
     
     
      
   
   
     
     
     
     
      

      
       
       
       
        

      
      
       
       
         
    
     
     
      
      
       
       
       
       
    
     
      
      
       
        
        
        
    
     
     
      
      
   
    
     
     
      
      
      

      
      
       
       
         

     
       
       
       
         
     
      
         

     
      
    
      
       
        
        
    
    
     
      
        

 

    
     
      
       
oom
    
     
     
      

    
     
      
       
       
       
       
        

   
        
       


 

      
       
       
       
       
        
      
      
        
        
         
   
    
     
     
      
      
      
      
       
    
     
      
       
       
       
         
         
   
    
     
     
      
   
   
     
     
      
      
      

    
    
     
     
     
     
    
     
     
     
     
   
     
       
       
        
        
         
         
         
    
     
       
        
         
         

     
        

      

 

lu g dyxsx 

g
table    results caltalt using hrp
  p using hlu
rp   mbp  kacmbp  gpt 
cgp  yka  cff conformant rovers  logistics  bt  btc  cube center  ring 
data total time     plan steps  indicates time     minutes   oom
indicates memory   gb     indicates attempt 

instances rovers logistics domains mbp kacmbp tend generate much longer
plans planners  mbp outperform p cases find
solutions certain instances  like rovers     likely heuristic  note
kacmbp mbp quite fast cube center ring domains  trouble
domains rovers logistics  illustrates heuristic modeling knowledge opposed
reachability well domains challenge uncertainty reachability 
  

fib ryce   k ambhampati     mith

optimal planners  optimal approaches  cgp gpt  tend scale well  despite
good solutions  cgp trouble constructing planning graphs parallel conformant plan
depth increases  cgp spends quite bit time computing mutexes  increases planning
cost plan lengths increase  cgp much better shallow parallel domains bt 
find one step plans dunk every package parallel 
gpt performs progression search guided heuristic measures cost fully
observable plans state space  gpt finds optimal serial plans effective size
search space increases  gpt fails scale search space becomes difficult
even compute heuristic  due larger state space well  
yka  yka  caltalt regression planner  search engine different yka
uses cardinality heuristic  yka performs well domains search engine
based bdds  notice difference progression regression comparing p
yka  similar trends found comparison p caltalt  additionally 
seems yka stronger regression search engine caltalt  p able better
yka rovers logistics domains  unclear whether search
direction heuristics 
cff  conformant ff  progression planner using relaxed plan similar lu g relaxed plan 
well rovers logistics domains uses highly optimized search
engine well cheap compute relaxed plan heuristic  however  cff well
bt  btc  cube center  ring problems many literals
entailed belief state  cff relies implicitly representing belief states terms literals
entailed belief state  initial belief state  action history 
literals entailed belief state  reasoning belief state requires
inference action history  another possible reason cff suffers encodings 
cube center ring domains naturally expressed multi valued state features 
transformation binary state features describe values must hold values
must hold  difficult cff conditional effect antecedents contain several
literals heuristic restricted considering one literal  may cff
choosing wrong literal simply enough literals get effective heuristics  however bt
btc used one literal effect antecedents cff still performs poorly 
    conditional planning
table   shows results testing conditional versions domains p d  mbp  gpt 
sgp  yka 
mbp  p planner similar mbp uses progression search  p
uses ao  search  whereas mbp binary used uses depth first and or search  depth
first search used mbp contributes highly sub optimal maximum length branches  as much
order magnitude longer p d   instance  plans generated mbp
rovers domain rover navigating back forth locations several times
anything useful  situation beneficial actual mission use  mbp tends scale
well p domains tested  possible reason performance mbp
logistics rovers domains sensory actions execution preconditions 
prevent branching early finding deterministic plan segments branch  experimented
  

fip lanning g raph h euristics b elief pace earch

problem
rovers  
 
 
 
 
 
logistics  
 
 
 
 
bt  
  
  
  
  
  
  
  
  
btc  
  
  
  
  
  
  
  

pond
g
hlu
rp
     
     
     
      
       
        
     
       
      
       
        
     
      
       
       
        
        
        
         
         
     
      
       
       
        
        
         
         

mbp

gpt

sgp

yka

       
       
        
        
        
oom
     
         
       
oom
   
      
oom
    
      
oom
 

      
      
      
        

      
       
      

     
         
oom
     
         

 

    
     

      

   
    
     
      
       
       
       
        

    

 

      
      
      
        

      


   
     
     
      
      
      
       
       
       
   
      
       
        
        
         
         
        

g
table    results p using hlu
rp   mbp  gpt  sgp  yka conditional rovers  logistics  bt  btc  data total time     maximum possible steps execution 
indicates time     minutes   oom indicates memory   gb    
indicates attempt 

mbp using sensory actions without execution preconditions able scale somewhat
better  plan quality much longer 
optimal planners  gpt sgp generate better solutions slowly  gpt better
rovers logistics problems exhibit positive interaction plans 
sgp well bt planning graph search well suited shallow  yet broad  highly
parallel  problems 
yka  see yka fares similar gpt rovers logistics  trouble scaling
reasons  think yka may trouble regression sensory actions
since able scale reasonably well conformant version domains  despite this 
yka proves well bt btc problems 
  

fib ryce   k ambhampati     mith

    empirical evaluation conclusions
internal comparisons heuristics within caltalt p d  well external comparisons several state art conformant conditional planners learned many
interesting lessons heuristics planning belief space 
distance based heuristics belief space search help control conformant conditional plan
length because  opposed cardinality  heuristics model desirable plan quality metrics 
planning graph heuristics belief space search scale better planning graph search
admissible heuristic search techniques 
planning graph heuristics presented  relaxed plans take account overlap
individual plans states source destination belief states
accurate tend perform well across many domains 
lug effective planning graph regression progression search heuristics 
regression search  planning graphs maintain same world mutexes provide best
trade off graph construction cost heuristic informedness 
sampling possible worlds construct planning graphs reduce computational cost 
considering worlds exploiting planning graph structure common possible worlds
 as lu g   efficient informed 
lug heuristics help conditional planner  p d  scale conditional domains 
despite fact heuristic computation model observation actions 

   related work   discussion
discuss connections several related works involve heuristics and or conditional planning first half section  second part section discuss extend
work directly handle non deterministic outcomes actions heuristic computation 
    related work
much interest conformant conditional planning traced cgp  smith   weld        
conformant version graphplan  blum   furst         sgp  weld et al          analogous
conditional version graphplan  graph search conducted several planning graphs 
constructed one possible initial states  recent work c plan  castellini
et al         frag plan  kurien et al         generalize cgp approach ordering
searches different worlds plan hardest satisfy world found first 
extended worlds  although caltalt p utilize planning graphs
similar cgp frag plan uses compute reachability estimates  search
conducted space belief states 
another strand work models conformant conditional planning search space
belief states  started genesereth nourbakhsh         concentrated formulating set admissible pruning conditions controlling search  heuristics
choosing among unpruned nodes  gpt  bonet   geffner        extended idea consider
  

fip lanning g raph h euristics b elief pace earch

simple form reachability heuristic  specifically  computing estimated cost belief state 
gpt assumes initial state fully observable  cost estimate done terms
reachability  with dynamic programming rather planning graphs   gpts reachability heuristic
g
similar hm
mrp heuristic estimate cost farthest  maximum distance  state looking deterministic relaxation problem  comparison gpt  caltalt
p seen using heuristics better job considering cost belief
state across various possible worlds 
another family planners search belief states mbp family plannersmbp
 bertoli et al       b   kacmbp  bertoli   cimatti         contrast caltalt similar p d  mbp family planners represent belief states terms binary decision
diagrams  action application modeled modifications bdds  mbp supports progression regression space belief states  kacmbp pure progression planner 
computing heuristic estimates  kacmbp pro actively reduces uncertainty belief
state preferring uncertainty reducing actions  motivation approach applying
cardinality heuristics belief states containing multiple states may give accurate enough direction search  reducing uncertainty seems effective idea  note  a 
domains may contain actions reduce belief state uncertainty  b  need uncertainty reduction may reduced heuristics effectively reason multiple
worlds  viz   multiple planning graph heuristics   nevertheless  could fruitful integrate knowledge goal ideas kacmbp reachability heuristics caltalt p
handle domains contain high uncertainty costly goals 
contrast domain independent approaches require models domain
physics  pksplan  petrick   bacchus        forward chaining knowledge based planner
requires richer domain knowledge  planner makes use several knowledge bases  opposed
single knowledge base taking form belief state  knowledge bases separate binary
multi valued variables  planning execution time knowledge 
yka  rintanen      b  regression conditional planner using bdds uses cardinality heuristic  recently rintanen developed related reachability heuristics consider
distances groups states  rely planning graphs  rintanen        
recently  closely related work heuristics constructing conformant
plans within cff planner  hoffmann   brafman         planner represents belief states
implicitly set known facts  action history  leading belief state   initial
belief state  cff builds planning graph forward set known literals goal literals
backwards initial belief state  planning graph  conditional effects restricted
single literals antecedent enable tractable   cnf reasoning  planning graph 
cff extracts relaxed plan represents supporting goal belief state states
initial belief state  biggest differences lu g cff technique
lu g reasons forward source belief state  assuming explicit  albeit symbolic  belief
state   lu g restrict number literals antecedents  result  lu g
lose causal information perform backward reasoning initial belief state 
handling uncertainty labels label propagation reminiscent related
de kleers assumption based truth maintenance system  atms   de kleer         atms
uses labels identify assumptions  contexts  particular statement holds  traditional
truth maintenance system requires extensive backtracking consistency enforcement identify
contexts  similarly  reason multiple possible worlds  contexts 
  

fib ryce   k ambhampati     mith

lug simultaneously  mg approach requires  backtracking  reproduction planning
graphs possible worlds 
finally  caltalt p related to  adaptation work reachability
heuristics classical planning  including altalt  nguyen et al           hoffmann   nebel 
      hsp r  bonet   geffner         caltalt conformant extension altalt uses
regression search  similar hsp r  guided planning graph heuristics  p similar
uses progression search planning graph heuristics 
    extension non deterministic actions
scope presentation evaluation restricted planning initial state uncertainty deterministic actions  planning graph techniques extended include
non deterministic actions type described rintanen      a   non deterministic actions
effects described terms set outcomes  simplicity  consider rintanens
conditionality normal form  actions set conditional effects  as before 
consequent mutually exclusive set conjunctions  outcomes  one outcome effect
result randomly  outline generalization single  multiple  labelled planning graphs
reason non deterministic actions 
single planning graphs  single planning graphs  built approximate belief states
sampled state  lend straight forward extension  single graph ignores
uncertainty belief state unioning literals sampling state form initial planning
graph layer  continuing single graph assumptions uncertainty  makes sense treat
non deterministic actions deterministic  similar approximate belief state set
literals form initial literal layer sample state  assume non deterministic effect
adds literals appearing effect samples outcome action deterministic
 i e  gives set literals   single graph relaxed plan heuristics thus remain unchanged 
multiple planning graphs  multiple planning graphs much conformant graphplan
 smith   weld         generalize splitting non determinism current belief state
multiple initial literal layers splitting outcomes non deterministic effects multiple
literal layers  idea root set new planning graphs level 
initial literal layer containing literals supported interpretation previous effect layer 
interpretations effect layer mean every possible set joint effect outcomes  set effect
outcomes possible two outcomes outcomes effect  relaxed plan extraction
still involves finding relaxed plan planning graph  however  since planning graph
split many times  in tree like structure  relaxed plan extracted path tree 
note technique likely scale exponential growth redundant
planning graph structure time  further  experiments cgp enough trouble initial
state uncertainty  expect able much better lu g 
labelled uncertainty graph  multiple planning graphs forced capture non
determinism splitting planning graphs initial literal layer 
literal layer follows least one non deterministic effect  saw lu g labels
capture non determinism drove us split initial literal layer multiple graphs 
such  labels took syntactic form describes subsets states source belief
state  order generalize labels capture non determinism resulting uncertain effects 
  

fip lanning g raph h euristics b elief pace earch

need extend syntactic form  objective label represent sources
uncertainty  arising source belief state effects  causally support labelled item 
introduce graph layer ok represent outcomes connect effects literals 
might seem natural describe labels outcomes terms affected literals 
lead trouble  problem literals effect outcomes describing states
different time literals projected belief state  further  outcome appears two
levels graph describing random event different times  using state literals describe
labels lead confusion random events  state uncertainty effect outcomes
distinct steps  causally support labelled item  pathological example effect
whose set outcomes matches one to one states source belief state  case 
using labels defined terms state literals cannot distinguish random event  the state
uncertainty effect uncertainty  described label 
two choices describing effect outcomes labels  choices introduce
new set label variables describe literal layer split  new variables used
describe effect outcomes labels confused variables describing initial state
uncertainty  first case  variables one to one matching original set
literals  thought time stamped literals  number variables add
label function order  f per level  the number fluent literals assuming boolean
fluents   second option describe outcomes labels new set fluents 
interpretation fluents matched particular outcome  case  add order
log  ok   variables  ok k th outcome layer  would actually lower many
outcomes deterministic effects need describe labels 
former approach likely introduce fewer variables lot non deterministic
effects affect quite literals  latter introduce fewer variables
relatively non deterministic effects whose outcomes fairly independent 
generalized labelling  still say item reachable source belief
state label entailed source belief state  even though adding
variables labels  implicitly adding fluents source belief state  example  say
add fluent v describe two outcomes effect  one outcome labelled v  v 
express source belief state bsp projected lu g new fluent
bsp  v v    bsp   item labelled bsp v entailed projected belief
state  i e  unreachable  one outcome causally supports it  outcomes support
item  reachable 
given notion reachability  determine level extract relaxed
plan  relaxed plan procedure change much terms semantics
extra graph layer outcomes  still ensure literals causally supported
worlds labelled relaxed plan  whether worlds initial state
uncertainty supporting non deterministic effects 

   conclusion
intent establishing basis belief state distance estimates  have 
discussed heuristic measures aggregate state distance measures capture positive
interaction  negative interaction  independence  overlap 
  

fib ryce   k ambhampati     mith

shown compute heuristic measures planning graphs provided empirical
comparisons measures 
found exploiting planning graph structure reduce cost considering possible
states belief state preferable sampling subset states heuristics 
shown labelled uncertainty graph capture support information multiple
graphs  reduces cost heuristic computation 
shown labelled uncertainty graph useful conformant planning and  without
considering observational actions knowledge  perform well conditional planning 
intent work provide formal basis measuring distance belief
states terms underlying state distances  investigated several ways aggregate state
distances reflect various assumptions interaction state state trajectories  best
measures turned measure positive interaction independence  call
overlap  saw planners using notion overlap tend well across large variety
domains tend accurate heuristics 
weve shown planning labelled uncertainty planning graph lu g  condensed
version multiple graphs useful encoding conformant reachability information  main
innovation idea labels labels attached literals  actions  effect relations 
mutexes indicate set worlds respective elements hold  experimental
results show lu g outperform multiple graph approach  comparison
approaches  weve able demonstrate utility structured reachability heuristics
controlling plan length boosting scalability conformant conditional planning 
intend investigate three additions work  first  incorporate sensing
knowledge heuristics  already promising results without using features
planning graphs  hope help approaches scale even better conditional
problems  second addition consider heuristics stochastic planning problems 
major challenges associate probabilities labels indicate likelihood
possible world integrate reasoning probabilistic action effects 
lastly  recently extended lu g within framework state agnostic planning
graphs  cushing   bryce         hope improve technique  state agnostic planning
graph essentially multiple source planning graph  analogy conventional planning
graph single source  planning graphs already multiple destination  generalization
state agnostic planning graph allows us compute distance measure pair
states belief states  lu g seeks avoid redundancy across multiple planning graphs
built states belief state  extended notion avoid redundancy planning
graphs built every belief state  shown state agnostic lu g  slu g 
built per search episode  as opposed lu g node  reduce heuristic computation
cost without sacrificing informedness 
acknowledgments would thank minh b  do  romeo sanchez  terry zimmermam 
satish kumar thittamaranahalli  cushing helpful discussions feedback  jussi rintanen help yka planner  piergiorgio bertoli help mbp planner 
work supported part nasa grants ncc       nag        nsf grant iis              nasa riacs ssrp  arcs foundation  ibm faculty award 
  

fip lanning g raph h euristics b elief pace earch

appendix a  additional heuristics
completeness  present additional heuristics adapted classical planning reason
belief state distances type planning graph  many heuristics appeared
previous work  bryce   kambhampati         show compute max  sum  level
heuristics single graph sg  multiple graphs g  labelled uncertainty graph lu g 
heuristics tend less effective relaxed plan heuristics  provide
reference  section    describe heuristics terms regression search 
a   single planning graph heuristics  sg 
like  relaxed plan single unmodified planning graph  cannot aggregate state distances
notion separate states lost forming initial literal layer  thus compute
heuristics aggregate state distances 
state aggregation 
max classical planning  maximum cost literal used get max heuristic  use
formulas describe belief states  take maximum cost clause cost
belief state find max heuristic hsg
max   maximum cost clause belief state 
respect single planning graph  is 
hsg
max  bsi    

max

c bsi  

cost c 

cost clause is 
cost c    min min k
lc k llk

find cheapest literal cost clause find maximum cost clause 
underestimate closest state current belief state 
sum classical planning sum heuristic  take sum hsg
sum costs
clauses belief state estimate belief state distance

cost c 
hsg
sum  bsi    
c bsi  

heuristic takes summation costs literals closest estimated state
belief state  inadmissible may single action support every
clause  could count clause 
level mutexes planning graph  compute level heuristic hsg
level
 without mutexes level heuristic equivalent max heuristic   level heuristic
maintains admissibility max heuristic improves lower bound considering
level planning graph literals constituent non pairwise mutex 

level heuristic computed taking minimum among  bs
   first level
 lev s   planning graph literals present none marked
pairwise mutex  formally 
hsg
level  bsi    

  

min

s bsi  

lev s 

fib ryce   k ambhampati     mith

a   multiple planning graph heuristics  m g 
similar various relaxed plan heuristics multiple graphs  compute max  sum 
level heuristic multiple planning graphs aggregate maximum
summation respectively measure positive interaction independence  reason cannot
aggregate individual graph heuristics measure overlap numbers  sets
actions  measuring overlap involves taking union heuristics graph union
numbers meaningful union action sets relaxed plans  before 
reason use multiple graphs state distance aggregation 
positive interaction aggregation 
g
max max heuristic hm
mmax computed multiple planning graphs measure posm
g
itive interaction hmmax heuristic  heuristic computes maximum cost clause
 bsi   graph   similar hsg
mmax  bsi   computed  takes
maximum  formally 
g

hm
mmax  bsi     max  hmax  bsi   


g
hm
mmax heuristic considers minimum cost  relevant literals belief state  those
reachable given possible world graph   get state measures  maximum
taken estimate accounts worst  i e   plan needed difficult
world achieve subgoals  

sum sum heuristic measures positive interaction multiple planning graphs
g
hm
msum   computes summation cost clauses  bsi   graph
takes maximum  formally 
g

hm
msum  bsi     max  hsum  bsi   


heuristic considers minimum cost  relevant literals belief state  those
reachable given possible worlds represented graph   get state measures 
g
hm
mmax   maximum taken estimate costly world 

g
mg
mg
level similar hm
mmax hmsum   hmlevel heuristic found first finding hlevel
graph get state distance measure  taking maximum across

graphs  hlevel  bsi   computed taking minimum among  bs
  

first level lev  s  planning graph literals present none
marked mutex  formally 

hlevel  bsi    

min

s bsi  

lev  s 



g
hm
mlevel  bsi     max hlevel  bsi   


note heuristic admissible  reasoning classical planning  first
level subgoals present non mutex underestimate true cost
state  holds graphs  taking maximum accounts difficult
  

fip lanning g raph h euristics b elief pace earch

world achieve constituent bsi thus provable underestimate h  
g
gpts max heuristic  bonet   geffner        similar hm
mlevel   computed
dynamic programming state space rather planning graphs 
independence aggregation  heuristics mentioned positive interaction aggregation
augmented take summation costs found individual planning graphs rather
g
mg
mg
maximum  denote as  hm
smax   hssum   hslevel   none heuristics
admissible action may used worlds  count cost every world
using summation 
a   labelled uncertainty graph  lu g 
max  sum  level heuristics lu g similar analogous multiple graph heuristics  main difference heuristics lu g much easier compute
positive interaction measures independence measures  reason positive interaction easier
compute find cost clause states belief state once  rather
multiple planning graphs  before  consider heuristics aggregate
state distances 
positive interaction aggregation 
g
max max heuristic hlu
mmax lu g finds maximum clause cost across clauses
current belief state bsi   cost clause first level becomes reachable 
formally 


g
hlu
mmax  bsi  

 

max

c bsi  


min

k bsp   k  c 

k

g
sum sum heuristic hlu
msum lu g sums individual levels clause
 bsi   first reachable  formally 


g
min
hlu
 bs
 
 
k

msum

c bsi  

k bsp   k  c 

g
level level heuristic hlu
mlevel index first level bsi reachable 
formally 
g
hlu
mlevel  bsi    

min

k bsp   k  bsi  



independence aggregation  heuristics mentioned positive interaction aggregation
augmented take summation costs state belief state  may inefficient
due fact lose benefit lu g evaluating heuristic state
bsp   rather states positive interaction aggregation  case
work similar multiple graph heuristic extraction  aside improved graph
construction time  positive interaction aggregation able implicitly calculate maximum
worlds heuristics  whereas sum heuristic need explicitly find
g
lu g
lu g
cost world  denote sum heuristics as  hlu
smax   hssum   hslevel  
  

fib ryce   k ambhampati     mith

appendix b  cross world mutexes
mutexes develop possible world two possible worlds 
described smith weld         cross world mutexes useful capture negative interactions belief state distance measures  mentioned section     representation crossworld mutexes requires another generalization labelling mutexes  world mutexes
require keeping one label mutex signify possible worlds mutex holds  extended representation keeps pair labels  one element mutex 
x possible world mutex x possible world   denote mutex pair
 k  x    s  k  x       
compute cross world mutexes several worlds elements x x   example  k  x    s  s  s  k  x     s  s    check cross world mutexes need
consider mutexes world pairs  s    s      s    s      s    s      s    s      s    s      s    s    
check mutexes intersection element labels k  x  k  x     s  s   
meaning cross world pairs check mutexes  s    s      s    s      s    s    
 s    s    
say formula f reachable projected belief state bsp   considering
cross world mutexes  every pair states bsp   f reachable  pair states
  f reachable    k  f   every pair constituents   f
   k  s      k  s    two literals either same world
mutex     mutex literals   across respective
worlds
    mutex pair literals l l   respectively
mutex  k  l   k  l       k  l     k  l   
computation cross world mutexes requires changes mutex formulas 
outlined next  major change check  instead single possible worlds s  pairs
possible worlds mutexes 
action mutexes  action mutexes hold actions executable different
possible worlds 
interference interference mutexes change cross world mutexes  except
pair labels  k  a    bsp   k  a     bsp    instead single label 
competing needs competing needs change mutexes cross world mutexes two
actions   worlds respectively  could competing  formally  crossworld competing needs mutex   k  a    s  k  a       exists worlds
if 
le  a  l e  a    k  l    s  k  l      
effect mutexes  effect mutexes hold effects occur different possible worlds 
interference effect interference mutexes change cross world mutexes  except
pair labels  k  i  a     bsp   k  j  a      bsp    instead single
label 
  

fip lanning g raph h euristics b elief pace earch

lk

lk p 
p


ek

ak

lk a 


h a 

lk h a  



 lk p   lk q  
induced mutex across worlds 


 lk j a  lk i a    lk h a   





 lk j a    lk h a   

lk q 
q
lk a 


j a 

lk r 
r

lk j a  
i a  induces j a  in 
lk i a  lk j a  

i a  lk i a  

figure     example cross world induced effect mutex 
competing needs effect competing needs mutexes change cross world mutexes
two effects  a  j  a    worlds respectively  could competing  formally 
cross world competing needs mutex  k  i  a     s  k  j  a        exists  a 
j  a   worlds if 
li  a  l j  a    k  l    s  k  l      
induced induced mutexes change slightly cross world mutexes  worlds one
effect induces another  remains same  mutex changes slightly 
j  a  k  j  a   mutex h  a   k  h  a      a  induces effect j  a 
possible worlds described k  i  a   k  j  a    induced mutex
 a  k  j  a   k  i  a   h  a   k  h  a     see figure     

literal mutexes  literal mutexes hold literals supported different possible worlds 
inconsistent support changes cross world mutexes  mutex  k  l    s  k  l      
holds l l  a   j  a   ek  l  a   l j  a   
mutex k   i  a     s  k   j  a        

  

fib ryce   k ambhampati     mith

references
bertoli  p     cimatti  a          improving heuristics planning search belief space 
proceedings aips   
bertoli  p   cimatti  a     roveri  m       a   heuristic search   symbolic model checking  
efficient conformant planning  proceedings ijcai   
bertoli  p   cimatti  a   roveri  m     traverso  p       b   planning nondeterministic domains
partial observability via symbolic model checking  proceedings ijcai   
blum  a     furst  m          fast planning planning graph analysis  proceedings
ijcai   
bonet  b     geffner  h          planning heuristic search  new results  proceedings
ecp   
bonet  b     geffner  h          planning incomplete information heuristic search belief
space  proceedings aips   
brace  k   rudell  r     bryant  r          efficient implementation bdd package  proceedings   th acm ieee design automation conference 
bryant  r          graph based algorithms boolean function manipulation  ieee transactions
computers  c               
bryce  d     kambhampati  s          heuristic guidance measures conformant planning 
proceedings icaps   
castellini  c   giunchiglia  e     tacchella  a          improvements sat based conformant
planning  proceedings ecp   
cimatti  a     roveri  m          conformant planning via symbolic model checking  journal
artificial intelligence research             
cormen  t  h   leiserson  c  e     rivest  r  l          introduction algorithms  mcgraw hill 
cushing  w     bryce  d          state agnostic planning graphs  proceedings aaai   
de kleer  j          assumption based tms  artificial intelligence                
genesereth  m  r     nourbakhsh  i  r          time saving tips problem solving incomplete information  proceedings aaai   
hansen  e     zilberstein  s          lao  heuristic search algorithm finds solutions
loops  artificial intelligence                
hoffmann  j     brafman  r          conformant planning via heuristic forward search  new
approach  proceedings icaps   
hoffmann  j     nebel  b          planning system  fast plan generation heuristic
search  journal artificial intelligence research             
kambhampati  s   ihrig  l     srivastava  b          candidate set based analysis subgoal
interactions conjunctive goal planning  proceedings aips   
koehler  j   nebel  b   hoffmann  j     dimopoulos  y          extending planning graphs
adl subset  proceedings ecp   
  

fip lanning g raph h euristics b elief pace earch

kurien  j   nayak  p     smith  d          fragment based conformant planning  proceedings
aips   
long  d     fox  m           rd international planning competition  results analysis 
journal artificial intelligence research          
nguyen  x   kambhampati  s     nigenda  r          planning graph basis deriving
heuristics plan synthesis state space csp search  artificial intelligence           
      
nilsson  n          principles artificial intelligence  morgan kaufmann 
pednault  e  p  d          synthesizing plans contain actions context dependent effects 
computational intelligence            
petrick  r     bacchus  f          knowledge based approach planning incomplete information sensing  proceedings aips   
rintanen  j       a   expressive equivalence formalisms planning sensing  proceedings icaps   
rintanen  j       b   product representation belief spaces planning partial observability 
proceedings ijcai   
rintanen  j          distance estimates planning discrete belief space  proceedings
aaai   
smith  d     weld  d          conformant graphplan  proceedings aaai   
weld  d   anderson  c     smith  d          extending graphplan handle uncertainty sensing
actions  proceedings aaai   

  


