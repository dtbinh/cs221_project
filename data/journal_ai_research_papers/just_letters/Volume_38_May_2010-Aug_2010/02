journal articial intelligence research                 

submitted        published      

bnb adopt 
asynchronous branch and bound dcop algorithm
william yeoh

wyeoh usc edu

computer science department 
university southern california 
los angeles  ca        usa

ariel felner

felner bgu ac il

information systems engineering 
deutsche telekom labs 
ben gurion university negev 
beer sheva         israel

sven koenig

skoenig usc edu

computer science department 
university southern california 
los angeles  ca        usa

abstract
distributed constraint optimization  dcop  problems popular way formulating
solving agent coordination problems  dcop problem problem several agents coordinate values sum resulting constraint costs minimal  often
desirable solve dcop problems memory bounded asynchronous algorithms  introduce branch and bound adopt  bnb adopt   memory bounded asynchronous dcop search
algorithm uses message passing communication framework adopt  modi  shen 
tambe    yokoo         well known memory bounded asynchronous dcop search algorithm 
changes search strategy adopt best first search depth first branch and bound
search  experimental results show bnb adopt finds cost minimal solutions one
order magnitude faster adopt variety large dcop problems fast
ncbb  memory bounded synchronous dcop search algorithm  dcop
problems  additionally  often desirable find bounded error solutions dcop problems
within reasonable amount time since finding cost minimal solutions np hard  existing bounded error approximation mechanism allows users specify absolute error bound
solution cost relative error bound often intuitive  thus  present two
new bounded error approximation mechanisms allow relative error bounds implement
top bnb adopt 

   introduction
distributed constraint optimization  dcop  problem consists agents  responsible taking
   assigning itself  value nite domain values  agents coordinate values 
subject constraints  two agents constrained share constraint 
constraint associated constraint cost  depends values constrained agents 
 complete  solution assignment values agents  partial solution assignment
values subset agents  solution cost  partial complete  solution sum
constraint costs constraints resulting given assignment values agents  solving
dcop problem optimally means nding solution minimal solution cost np hard  modi
et al         
formulating agent coordination problems constraint optimization  cop  problems  specic
type weighted constraint satisfaction problems  schiex  fargier    verfaillie        bistarelli 

c
    
ai access foundation  rights reserved 

fiyeoh  felner   koenig

a 

a 
a 

a 
a 

a 
a 

 a 

a 

a 
 
 
 
 
a 
 
 
 
 

a 
 
 
 
 
a 
 
 
 
 

constraint cost
 
 
  
 
constraint cost
 
 
 
 

 b 

a 
 
 
 
 
a 
 
 
 
 

a 
 
 
 
 
a 
 
 
 
 

constraint cost
 
  
  
 
constraint cost
 
 
  
 

 c 

figure    example dcop problem
montanari  rossi  schiex  verfaillie    fargier         general formulating
common constraint satisfaction problems  dechter         constraint satisfaction problems
constraints either satised unsatised  solving constraint satisfaction problem
means nding solution constraints satised  example application
scheduling jobs job shop  constraints express jobs performed
certain machines jobs performed jobs  could
potentially multiple solutions satisfy constraints  however  solutions might
desirable others  example  one might prefer solution shortest completion time 
unfortunately  constraint satisfaction problems cannot capture preferences  however  cop
problems able using constraint costs represent preferences 
dcop algorithms better suited compared cop algorithms problems naturally distributed  result  dcop algorithms applied coordinating unmanned
aerial vehicles  schurr  okamoto  maheswaran  scerri    tambe         scheduling meetings  maheswaran  tambe  bowring  pearce    varakantham      b  petcu   faltings      b  greenstadt 
grosz    smith        zivan        yeoh  varakantham    koenig         coordinating sensor networks  lesser  ortiz    tambe        zhang  xing  wang    wittenburg        modi et al        
jain  taylor  tambe    yokoo        stranders  farinelli  rogers    jennings        zivan  glinton 
  sycara         synchronizing trac lights  junges   bazzan         planning truck routes  ottens
  faltings        managing power distribution networks  kumar  faltings    petcu        
common visualize dcop problem constraint graph vertices
agents edges constraints  dcop algorithms operate pseudo tree 
spanning tree  completely connected  constraint graph property edges
constraint graph connect vertex one ancestor descendant vertices
constraint tree  freuder   quinn        bayardo   miranker         edge constraint
graph part pseudo tree backedge  agent c pseudo child agent
agent p agent c descendant agent agent p pseudo tree constrained
via backedge  similarly  agent p pseudo parent agent agent c  sibling subtrees represent
independent dcop subproblems  since two agents dierent sibling subtrees share constraint  
figure   a  shows constraint graph example dcop problem four agents
take value   value    figure   b  shows one possible pseudo tree assignments
values agents a  a  independent dcop subproblems  the dotted line backedge  
figure   c  shows constraint costs  example dcop problem  cost minimal solution
results agents take value    minimal solution cost    
    dcop algorithms
provide taxonomy dcop algorithms  figure   shows taxonomy  dcop algorithms
divided two groups  complete incomplete dcop algorithms  complete dcop algorithms nd cost minimal solutions incomplete dcop algorithms often faster typically
nd suboptimal solutions 
  

fibnb adopt  asynchronous branch and bound dcop algorithm

dcop algorithms

incomplete algorithms
e g   dba  dsa  mgm 
k optimal algorithms

complete algorithms

partially centralized algorithms
e g   optapo

fully decentralized
algorithms

search algorithms
e g   sbb  adopt 
ncbb  afb

inference algorithms
e g   dpop

figure    taxonomy dcop algorithms
      incomplete dcop algorithms
incomplete dcop algorithms typically use local search nd locally optimal solutions
thus potentially get trapped local minima  nevertheless  since solving dcop problems optimally
np hard  dcop algorithms desirable large dcop problems nding costminimal solutions might slow  dba  yokoo   hirayama         dsa  fitzpatrick   meertens 
       mgm  maheswaran  pearce    tambe      a  recent class k optimal dcop
algorithms  pearce   tambe        bowring  pearce  portway  jain    tambe        greenstadt 
      examples incomplete dcop algorithms 
      complete dcop algorithms
complete dcop algorithms generally divided two groups  namely partially centralized
fully decentralized dcop algorithms 
partially centralized dcop algorithms
partially centralized dcop algorithms allow agents transfer constraint information
   information regarding constraints involved in  central agent processing  optapo  mailler   lesser        example partially centralized dcop algorithm
uses cooperative mediation  certain agents act mediators solve overlapping dcop
subproblems centrally 
fully decentralized dcop algorithms
fully decentralized dcop algorithms central agents collect constraint information agents constrained them  rather  every agent access
constraint information  fully decentralized dcop algorithms generally divided two
groups  namely dcop inference search algorithms 
dcop inference algorithms  dcop inference algorithms typically use dynamic programming propagate aggregated constraint costs one agent another agent thus reduce
  

fiyeoh  felner   koenig

dcop
algorithm
sbb
adopt
ncbb
afb
bnb adopt

search
strategy
dfbnb
best first
dfbnb
dfbnb
dfbnb

agent
operation
sequential   synchronous
concurrent   asynchronous
sequential   synchronous
concurrent   asynchronous
concurrent   asynchronous

communication
point to point neighbors
point to point neighbors
point to point neighbors
broadcast agents
point to point neighbors

agent
ordering
chain
tree
tree
chain
tree

table    properties dcop search algorithms

dcop problem size one agent step  repeat procedure dcop
problem size reduced one agent solution space    space possible partial solutions  thus cannot reduced anymore  sole remaining agent sucient
knowledge nd cost minimal solution  dpop  petcu   faltings      b  example
dcop inference algorithm  number messages sent agents linear
number agents  however  memory requirements exponential induced
width dcop problem  induced width depends number backedges
pseudo tree  large number agents minus one constraint graph
fully connected every agent thus constrained every agent 
dcop search algorithms  dcop search algorithms use search strategies search
solution space nd cost minimal solution  adopt  modi et al         uses best rst
search  sbb  hirayama   yokoo         ncbb  chechetka   sycara         afb  gershman  meisels    zivan        new dcop search algorithm  bnb adopt  use
depth rst branch and bound search  memory requirements polynomial
number agents  however  number messages sent agents exponential
number agents 
therefore  groups fully decentralized dcop algorithms desirable dierent
conditions tradeo space  memory requirements  time  number messages
sent  
    motivation
describe motivation behind work 
      bnb adopt
study dcop search algorithms memory bounded  property important applications  sensor networks  every agent sensor xed amount
memory available  result  several dcop search algorithms  sbb  adopt  ncbb
afb  developed limitation mind  described earlier  memory requirements
polynomial number agents  table   shows properties dcop search algorithms well properties new dcop search algorithm  bnb adopt  describe
property detail justify properties bnb adopt 
search strategy  adopt uses best rst search search solution space  sbb 
ncbb afb use depth rst branch and bound  dfbnb  search  best rst search repeatedly searches next best partial solution nds cost minimal solution  next
best partial solution cost minimal partial solution among partial solutions
yet found  depth rst branch and bound search starts nding complete  but

  

fibnb adopt  asynchronous branch and bound dcop algorithm

often suboptimal  solution stores solution cost upper bound  continues
search solution whose solution cost less upper bound  stores solution
cost solution upper bound  search proceeds longer nd
solution whose solution cost less upper bound 
centralized search  known search problems depth bounded search trees
often solved faster depth rst branch and bound search memory bounded
best rst search memory bounded best rst search algorithms  rbfs  korf 
       need repeatedly reconstruct partial solutions purged memory  depthrst branch and bound search algorithms memory bounded suer
problem  zhang   korf         since dcop problems search problems depthbounded search trees  hypothesize depth rst branch and bound search might faster
best rst search  therefore  decided bnb adopt use depth rst branchand bound search 
agent operation  agents sbb ncbb operate sequentially  agents tokens
active agents remain idle  token holding agents done  pass
tokens remain idle  hand  agents adopt afb operate
concurrently    times   agents operate concurrently might able solve dcop
problems faster agents operate sequentially since former agents perform
potentially useful computation instead wait agents  therefore 
decided agents bnb adopt operate concurrently  agents sbb ncbb
operate synchronously  communication agents often form messages 
synchronous agents operate cycles  modi et al          cycle time required
agent process incoming messages queue send outgoing messages 
processed receiving agents next cycle  see section     details  
therefore  agents wait last agent done sending messages start
new cycle  hand  asynchronous agents  agents adopt afb 
able operate independently other  often increases robustness  silaghi 
landwehr    larrosa         example  synchronous agents aected single
communication link suers congestion small number asynchronous agents
aected  therefore decided agents bnb adopt operate asynchronously 
communication 
dcop search algorithms sbb  adopt ncbb restrict
communication agents share constraints  restriction motivated applications
sensor networks communication restricted neighboring agents sensors due
limited communication radius  neighboring sensors share constraints since need
coordinate sense areas near them  dcop search algorithms afb
restriction allow agents broadcast messages agents  decided
agents bnb adopt obey restrictions applications sensor networks
thus communicate neighboring agents 
agent ordering  dcop search algorithms mentioned start pre processing
step arranges agents pseudo tree  dcop search algorithms sbb
afb arrange agents chain  adopt ncbb arrange agents tree 
tree ordering capture independent dcop subproblems  represented sibling subtrees 
chain ordering not  dcop search algorithms operate trees thus
operate independent dcop subproblems independently  dcop search algorithms
operate chains not  therefore  decided bnb adopt arrange
agents tree 
adopt preferred properties mentioned except uses best rst search 
therefore introduce bnb adopt  memory bounded asynchronous dcop search algorithm
  

fiyeoh  felner   koenig

uses message passing communication framework adopt changes search strategy
adopt best rst search depth rst branch and bound search 
      bounded error approximations
solving dcop problems optimally np hard  makes advantageous allow users trade
solution cost smaller runtime  desirable error resulting solution
cost bounded provide guarantees solution cost  adopt is  best knowledge 
dcop search algorithm property  absolute error mechanism allows users
specify absolute error bound solution cost  example  solution cost
   larger minimal solution cost  however  often much desirable
specify relative error bound solution cost  example  solution cost
   percent larger minimal solution cost or  equivalently      times larger
minimal solution cost  cannot done absolute error mechanism without knowing
minimal solution cost priori  thus  propose two approximation mechanisms allow users
specify relative error bound solution cost  namely relative error mechanism
weighted heuristics mechanism  implement top bnb adopt  approximation
mechanisms allow bnb adopt nd solutions bounded errors faster cost minimal
solutions 
    experimental results
experimentally compare adopt  bnb adopt ncbb three dierent dcop problem
types  namely graph coloring problems  sensor network problems meeting scheduling problems 
results show bnb adopt one order magnitude faster  measured number
non concurrent constraint checks number cycles  adopt variety large
dcop problems  bnb adopt inferred faster sbb since adopt faster
sbb  modi et al          bnb adopt fast ncbb dcop
problems  results suboptimal variants bnb adopt show weighted heuristics
mechanism dominates absolute error mechanism relative error mechanism 
    article structure
article organized follows  formalize dcop problems section   describe
dcop search algorithm  bnb adopt  section    describe approximation mechanisms
allow bnb adopt nd solutions bounded error section    outline correctness
completeness proofs bnb adopt section    lastly  present experimental evaluations
section   conclusions section   

   dcop problems
section  formally dene distributed constraint optimization  dcop  problems describe
solution space 
    definition dcop problems
dcop problem dened following elements 
nite set agents    a    a           
set nite domains    dom a     dom a          dom an     dom ai   domain
possible oating point values agent ai a 

  

fibnb adopt  asynchronous branch and bound dcop algorithm

a 









 

 





b



a 

a 



b

c

 







 

a 
     

a 
 

  

a 
 

 

  

a 

a 
  

 

 

  

a 
 

 

a 
 

  

a 
 

c



  





 





g

e
h



e

f
j

k

 a 

g
l



f

h
n




p

q

j
r



k


u

v

 b 

figure    and or search tree
set binary constraints f    f    f         fm    constraint   dom ai   
dom ai    r    species non negative constraint cost function values
distinct agents ai  ai  share constraint 
denition assumes agent takes one value rather multiple values 
example  dierent value constraint involved in  dcop problems
commonly formulated agent responsible assignments values
multiple variables  however  exist techniques reduce dcop problems dcop
problems  burke   brown         thus  use terms agent variable interchangeably 
denition assumes constraints binary    two agents  rather n ary
   n agents   one able extend bnb adopt solve dcop problems nary constraints using techniques proposed extend adopt solve dcop
problems n ary constraints  modi et al          additionally  assume messages sent
agents delayed nite amount time never lost 
    search trees
solution space dcop problems visualized search trees  traditional search trees
or  synonymously  search trees  marinescu   dechter        assign values agents sequentially 
utilize fact values agents belong independent dcop subproblems
assigned sequentially  and or search trees based pseudo trees remedy
issue  marinescu   dechter         thus  use and or search trees refer
search trees article  depth bounded  twice  number agents 
figure   a  shows search tree based pseudo tree figure   b   figure   b 
labels node search tree identier allow us refer nodes easily  circular
nodes nodes  labeled upper case letters  correspond agents  example 
agent node c agent a    left branches nodes correspond agents taking value
  right branches correspond agents taking value    square nodes nodes
 labeled lower case letters  correspond partial solutions root node
nodes  example  partial solution node f   a         a         subtree rooted
node represents dcop subproblem assumes partial solution node 
example  subtree rooted node f represents dcop subproblem assigning values
agents a  a  given   a         a         number independent dcop subproblems
within dcop subproblem indicated number branches exiting node 
example  two branches exiting node f   indicating two independent dcop
subproblems  namely assigning values agents a  a    numbers nodes
delta costs nodes  delta cost node dened sum
constraint costs constraints partial solution involve agent parent node 

  

fiyeoh  felner   koenig

example  partial solution node v   a         a         a         two constraints
partial solution  namely constraint agents a  a    constraint cost   
constraint agents a  a    constraint cost    since parent
node node v node k agent a    delta cost node v    namely constraint cost
latter constraint  former constraint included since involve agent a   
solution cost partial solution node sum delta costs nodes
along branch root node node  example  solution cost partial
solution node v       sum delta costs nodes b  f v  example dcop
problem  cost minimal solution union partial solutions nodes v  all agents
take value     thus  minimal solution cost        sum delta costs nodes b  f  
v 

   bnb adopt
section  present branch and bound adopt  bnb adopt   describe bnbadopt modication adopt since approach requires readers in depth
understanding adopt  instead  give stand alone description bnb adopt requires
knowledge adopt  intention creating self contained hopefully easy to read
description 
    search strategies adopt bnb adopt
rst describe centralized versions search strategies adopt bnb adopt omit
technical details since described detail later sections 
      search strategy adopt
adopt  modi et al         popular dcop search algorithm  modi   ali        ali  koenig 
  tambe        bowring  tambe    yokoo        davin   modi        pecora  modi    scerri 
      choxi   modi        silaghi   yokoo        matsui  silaghi  hirayama  yokoo    matsuo 
      traverses search tree best rst search order  describe simplied version
best rst search  complete version found  marinescu   dechter         bestrst search maintains list initially contains child nodes root node 
repeatedly performs following operations  expands node smallest solution
cost list removing node list adding grandchild nodes
node list  example dcop problem  best rst search expands nodes
search tree figure   rst time following order  numbers parentheses
indicate solution costs partial solutions expanded nodes       b      f      c     
v                   
figure   shows simplied trace adopt example dcop problem  adopt terminates
fteen steps minimal solution cost     numbers nodes delta costs
r
nodes  lower bound lbx
r optimistic estimate minimal solution cost 
smallest underestimated solution cost  solutions  underestimated solution cost
solution sum delta costs nodes solution whose parent node
root node whose grandparent node expanded  example  underestimated
solution cost solution   a         a         a         a          node b expanded nodes f  
r
v expanded  upper bound u bx
r pessimistic estimate minimal solution
cost  solution cost solution smallest solution cost found far  adopt
r
r
terminates upper bound u bx
r larger lower bound lbx r   order
memory bounded  adopt maintains one branch search tree  shaded grey gure 
root node currently expanded node thus needs repeatedly reconstruct nodes

  

fibnb adopt  asynchronous branch and bound dcop algorithm

lbrxr    









b





b

c



c











g

e
h



e

f
j

k

g
l



f

h
n




p

q

r



k


u



v



 

 

a 

a 

 



j

a 

 
a 

       

a 
 

a 







              



a 

 
a 
 

       

  
  infinity

 

a 

a 
 



 
a 

              

 

a 





  
a 

a 

a 

           



a 

 

 
a 
 

a 

       

a 





a 

 

 
a 

       

a 
 

 

 

a 

a 





           





a 



a 

 
a 
 

       

  
  infinity

 

a 

a 

 

 

       

 

 





 

a 



a 
       

 

    
  infinity

 

 
a 

a 





a 

 

              

       

 





a 

 
a 
 

       

a 
 



a 

              

 
a 

 

a 

           





a 

 

              





a 

 

 
a 
 

a 

       

a 
 

       

 

a 





 

a 

              



a 

 
a 

       

 

  
a 

a 

              





 

 
a 

a 
       

 
a 

a 
 

  
a 

a 

              

 
a 

 

a 

 
a 

 

a 

a 

           

step   

figure    trace simplied memory bounded best first search  centralized adopt 

  

a 

           

    
    

 

a 

a 

           

step   

lbrxr
ubrxr

 
a 

 

a 

a 
 



a 

           

a 
 





 
a 

a  ubrxr   infinity



step   


a 

lbrxr     

 
a 

              

step   

  
a 





  
a 

a 

a 

           

a 
 



a 

    
  infinity
 

 

 

a 

step   

lbrxr
ubrxr

a 

a 

 
a 

a  ubrxr   infinity



           

 

a 

a 

lbrxr    

a 

a 
 



a 

  
a 



 
a 

              

a 

a 

           

 

a 



  



 

a 

a 
 



a 

  
  infinity

a 

a 

 
a 

step  

lbrxr
ubrxr

 

a 

a 

a  ubrxr   infinity



           

a 

a 



  
a 

 

  
a 

step   

lbrxr
ubrxr

 
a 

 

 

 



a 

           

a 
 





       

a 

lbrxr    

a 

a 

step  
a 

 
a 



 
a 

              

a 



 
a 

              





a 



  
a 

a 





  
a 

a 



 
a 

step  

a 

a 

a 

           

 

 



a 

           

 

a 

 

a 

a 

step  

a 
 





 

a 

a 
 



a 

 
a 

a  ubrxr   infinity



a  ubrxr   infinity



a 

              



 
a 

              

step  
lbrxr
ubrxr

  
a 

lbrxr    

 
a 

              



 



  
a 

a 





  
a 

a 

       

a 

step  

a 
 





 
a 

lbrxr    

  
  infinity

a 

lbrxr    





a 

step  

lbrxr
ubrxr

 

 



a 

a  ubrxr   infinity





 
a 

 



a 

           

a 

step  


 

a 

 
a 

step  

a 
 







 
a 

a  ubrxr   infinity





  
a 

a 

identifiers
lbrxr
ubrxr

lbrxr    

a  ubrxr   infinity



fiyeoh  felner   koenig

lbrxr    









b





b

c



c











g

e
h



e

f
j

k

g
l



f

h
n




p

q

r



k


u



v



 

 

a 

a 

 



j

a 

 
a 

       

a 
 

a 









a 

 
a 
 

       

  
  infinity

 

a 

a 

              

 





 
a 

              

 

a 



  
a 

a 

a 





a 



a 





a 

 

              

 

       

a 

a 





 



a 

 

a 

           





a 
       

 

 
a 

       

 



a 

 
a 
 

a 

       

a 
 



a 

              

 
a 

 

a 

a 

              



 

a 

           





a 

 

       

 





 

 
a 

a 

 
a 

       

a 
 

  
a 

 

a 

a 

              

 

a 

a 

           



 
a 

 

a  ubrxr     



  
a 

              

step  

a 

           

lbrxr     

 

a 

 

a 

a 



a 

a 

a 

step  

lbrxr     
ubrxr     

 

a 

 

a 

              

 



a 

           

a 
 



a 

  
a 

a  ubrxr     



 

a 

a 



  
a 



 



  



a 

           

lbrxr    

  
    
 

a 

 

a 

step  

lbrxr
ubrxr

 

a 

a 
 



a 

           

a 

a 

 

a 

              

step  

 

a 

 

 

a 

  
a 

a  ubrxr     



a 

a 
 



a 

lbrxr    
ubrxr     

 
a 

 



 
a 

              

a 



 
a 

a 
 





       

a 



  
a 

a 

step  


 
a 

lbrxr    

  
  infinity
 

a 



  
a 

a 

a 

step  

lbrxr
ubrxr

a 



 

 

       

  
    

a 

a 



 
a 

step  

lbrxr
ubrxr

 

a 



 
a 
 



a 

           

 

 



a 

           

a 
 





 

a 

a 

step  




step  

a 
 







 
a 

a  ubrxr   infinity



  
a 

a 

identifiers
lbrxr
ubrxr

lbrxr    

a  ubrxr   infinity



a 

           

step   





 
a 

 



a 

 
a 

a 
       

 
a 

a 
 

  
a 

a 

              

 
a 

 

a 

a 

           

step   

lbrxr     

a  ubrxr     









 
a 

 





 
a 

a 
       

 
a 

a 
 

  
a 

a 

              

 
a 

 

a 

a 

           

step   

figure    trace simplied depth first branch and bound search  centralized bnb adopt 
purged memory  example  step    adopt branch node f memory 
next node best rst search expands node c  adopt discards branch node f
step    steps      needs reconstruct discarded branch node f order
expand node v step   
      search strategy bnb adopt
describe simplied version depth rst branch and bound search  complete version
r
r
found  marinescu   dechter         use denitions lbx
r u bx r
described earlier figure    depth rst branch and bound search maintains stack initially
contains child nodes root node  expands node top

  

fibnb adopt  asynchronous branch and bound dcop algorithm

stack removing node stack performing following check  solution
r
cost node smaller upper bound u bx
r   prunes node repeats
operation  otherwise  adds grandchild nodes node top stack
r
repeats operation  terminates upper bound u bx
r larger lower bound
r
lbx r   depth rst branch and bound search add grandchild nodes expanded
node  and child nodes root node  decreasing order solution costs
instead random order top stack  ordering ensures depth rst branchand bound search expands grandchild node smallest solution cost rst  use
improvement throughout article  example dcop problem  depth rst branch andbound search expands nodes search tree following order  prunes
nodes brackets       c           j       g        h             n       k        m         l       
b      f      v          figure   shows trace depth rst branch and bound search
example dcop problem  memory bounded without repeatedly reconstruct nodes
purged memory expands nodes best rst search expand 
node j step    depth rst branch and bound search terminates twelve steps
minimal solution cost     three steps fewer adopt 
    description bnb adopt
provide incremental description bnb adopt  first  provide notations key
terms bnb adopt  then  describe bnb adopt updates bounds  adheres memory
limitations  performs depth rst search performs branch and bound  finally  introduce
enhanced nal version bnb adopt show pseudocode trace example
dcop problem 
      notation key terms
adopt following notation adopt describe bnb adopt 
v alinit a  dom a  initial value agent a 
cd a  set child pseudo child agents agent a 
c a  cd a  set child agents agent a 
pa a  parent agent agent except root agent 
p  a  set ancestor agents  including parent agent  agent a 
scp  a  p  a  set ancestor agents  including parent agent  agent
parent pseudo parent agents agent one  or more  descendant agents 
cp  a  scp  a  set ancestor agents  including parent agent  agent
parent pseudo parent agents agent a 
adopt following key terms adopt describe bnb adopt 
context  x   context x agent set values ancestor agents agent
a  context x r root agent r always equal    

delta cost     delta cost x
 d  sum constraint costs constraints
involve agent one ancestor agents  assumption agent
takes value ancestor agents take values context x   search tree 


x
 a  d   example 
 d  delta cost node partial solution x
a 
  a           delta cost node f figure   

  

fiyeoh  felner   koenig



gamma cost     gamma costs x
 d  x dened follows 



x
 d     x  d   



c
x
 a d 

   

cc a 

x
  

min


 x
 d  

ddom a 

   


agents a  values contexts x   thus  gamma cost x
 d  sum
constraint costs constraints involve agent one descendant agents  that
is  either agent one ancestor agents  agent one descendant
agents  descendant agent ancestor agent agent two descendant agents
agent a  minimized possible values descendant agents  assumption
agent takes value ancestor agents take values context x   search


 a  d  
tree  x
 d  gamma cost node partial solution x
a 

example    a           gamma cost node f figure    gamma cost x
sum
constraint costs constraints involve agent one descendant agents
minimized possible values agent descendant agents  assumption
ancestor agents agent take values context x   search tree 

gamma cost x
gamma cost node whose agent agent whose parent
a 
gamma cost node c
node partial solution x   example    a
      
figure    therefore  gamma cost node sum delta cost
gamma costs child nodes  gamma cost node minimum
gamma costs child nodes  example  gamma cost node f figure  
sum delta cost gamma costs nodes j k  gamma cost
node c figure   minimum gamma costs nodes e f  
r
solving dcop problem optimally means determine x
r root agent r or  equivalently 
r
gamma cost root node since x r minimal solution cost  dicult
agents cache information allows determine cost minimal solution 

      updating bounds
every agent bnb adopt stores updates several bounds gamma costs  namely
a c




lba c
x  d   lbx  d   lbx   ubx  d   u bx  d  u bx values d  child agents c

contexts x   maintaining following bound property 

lbx


lbx
 d 
a c
lbx  d 





x


x
 d 
c
x
 a d 


u bx


   




   
   


u bx
 d 
a c
ubx  d 

search tree 


lbx
u bx lower upper bounds  respectively   on gamma cost 
node whose agent agent whose parent node partial solution x  


lbx
 d  u bx  d  lower upper bounds  respectively   on gamma cost 
node partial solution x  a  d  
a c
lba c
x  d  ubx  d  lower upper bounds  respectively   on gamma cost 
node whose agent agent c whose parent node partial solution x  a  d  

  

fibnb adopt  asynchronous branch and bound dcop algorithm

a 
a 
a 
example  lb  a
u b  a
bounds node c figure    lb  a
   
      
      
      
a   a 
a   a 
a 
u b  a           bounds node f   lb  a           ub  a           bounds node j 
a 
a 
   a 
   a 
lba  a
     uba  a
     lb  a
u b  a
bounds node j  agent
      
      
       a      
       a      
a  maintains rst two bounds agent a  maintains last two bounds 
agent uses following update equations values d  child agents c
a c
a c
contexts x initialize bounds lba c
x  d  ubx  d   heuristic values hx  d 
a c
c
oating point numbers admissible thus satisfy   hx  d  x  a d   

a c
lba c
x  d     hx  d 

uba c
x  d 

  

   
   

agent uses repeatedly following update equations values d  child agents c 
contexts x contexts x c    x  a  d   tighten bounds 
a c
c
lba c
x  d     max lbx  d   lbx c  
a c


lbx
lbx  d 
 d     x  d   

   
   

cc a 

lbx
  

uba c
x  d    

u bx
 d 

  


u bx
  


min  lbx
 d  
ddom a 
c
min uba c
x  d   u bx c  


x
uba c
 d   
x  d 
cc a 

min


 u bx
 d  

ddom a 

    
    
    
    

updates maintain bound property improve bounds monotonically  is 
lower bounds monotonically non decreasing upper bounds monotonically nona


increasing   nite amount time  u bx
lbx agents contexts x  
r
r
bnb adopt terminates termination condition u bx r lbx r root agent r
r
r
r
r
satised  then  u bx
r lbx r bound property u bx r lbx r together imply
r
r
r
u bx r   x r   lbx r   dcop problem solved optimally 
figure   shows simplied trace updates  lower upper  bounds example
dcop problem  assume updates proceed sequentially leaf agents root
agent  due simplication  lower upper bounds node identical
gamma cost independent heuristic values  numbers nodes bounds 
two agents maintain bounds nodes except root node  gure shows bounds
parent agent maintains rather bounds child agent maintains  example 
number node b bounds agent a  rather agent a  maintains  bounds
child agent maintains computed taking minimum bounds child
nodes node  agents update bound node sum delta cost
bounds child nodes according update equations       update
bound node minimum bounds child nodes according update
equations        detailed description trace follows 
step    leaf agent a  updates bounds nodes g  h  k  l  o  p 
delta costs according update equations      bounds nodes d  f   h
   leaf agents use update equations  since child agents  sums child agents
 d    u b  d     d  leaf agents a  values contexts x  
evaluate    example  lbx

xa
xa

  

fiyeoh  felner   koenig





 



 







b



 

 



 



b

c



 

 



 

c











g

e
h



e

f
j

k

g
l



f

h
n




p

q

j
r



k


 



u



v



 

 
 

       

 
 

 
 

 

              

identifiers

 
 
 

 

           

step  

  



  

       

 

 
 

  
 

 

              

  
 

 

 

 

           

step  

  
  

  







  

  

  









 

  



 

 

  
       

  
 

 
 

  
 

 

              

  
 

 

 

 

           

step  

figure    simplied trace updates  lower upper  bounds
j minimum bounds child nodes according update equations   
    similarly  leaf agent a  updates bounds nodes i  j  m  n  q  r  u
v delta costs according update equations      bounds nodes
e  g  k minimum bounds child nodes according update
equations        bounds nodes k shown gure since
 yet  maintained agent a   
step    agent a  updates bounds nodes k maintains bounds
nodes leaf agents a  a  maintain according update equations  
    bounds nodes c f sum delta costs bounds
child nodes according update equations      bounds nodes b
c minimum bounds child nodes according update equations   
    bounds nodes b c shown gure since  yet 
maintained agent a   
step    agent a  updates bounds nodes b c maintains bounds
nodes agent a  maintains according update equations      
bounds nodes b sum delta costs bounds child
nodes according update equations      bounds node minimum
bounds child nodes according update equations        since
lower upper bounds node equal gamma cost  lower upper bounds
root node equal gamma cost  turn equal minimal solution
cost  propagation terminates three steps minimal solution cost    
      adhering memory limitations
description bnb adopt far assumes memory limitations  however  bnb adopt
memory bounded dcop search algorithm memory requirements per agent linear
number agents  describe bnb adopt adheres memory limitations
using techniques introduced adopt apply bnb adopt well 
simplied trace figure   assumes every agent maintains bounds values d 
child agents c contexts x   number contexts exponential depth
agent pseudo tree  example dcop problem  agent a  four dierent contexts
four dierent combinations values ancestor agents a  a    agent cannot maintain
  

fibnb adopt  asynchronous branch and bound dcop algorithm

exponential number bounds due memory limitations  therefore  every agent maintains
bounds one context given time  context stored variable x
agent a  size context linear number agents  number bounds
agent linear product domain cardinality number child agents 
thus  memory requirements per agent linear number agents domain
cardinality magnitude bounds  and variables  constant agent 
      performing depth first search
description bnb adopt far applies adopt well  however  bnb adopt uses
depth rst branch and bound search adopt uses best rst search  describe
bnb adopt implements depth rst search 
agents bnb adopt send messages similar adopt processes
dierently  send messages three dierent types  namely value  cost terminate
messages  start  every agent initializes context x   uses update equations                

   initialize bounds takes best value da    arg minddom a   lbx
 d    sends
value messages child agents cost message parent agent  repeatedly
waits incoming messages  processes them  possibly takes dierent value sends
value messages child agents cost message parent agent  description
three message types agents process follows 
value messages  agent context x value da sends value messages
child agents desired context x  a  da    context augmented
value  leaf agents child agents thus send value messages  value
messages thus propagate contexts pseudo tree 
agent receives value message  checks whether context identical
desired context value message  not  agent changes context
desired context value message  either case  executes common program
 see below  
cost messages  agent sends cost messages parent agent identity


a  context x bounds lbx
u bx   root agent parent
agent thus send cost messages  cost messages thus propagate bounds
pseudo tree 
agent receives cost message  checks whether context context
cost message compatible  two contexts compatible agent takes dierent
values two contexts  are  agent uses update equations     
bounds cost message improve bounds value message  either
case  executes common program  see below  
r
r
terminate messages  termination condition u bx
r lbx r satised 
root agent r sends terminate messages  without parameters  child agents
inform search complete terminates  agent receives
terminate message  sends terminate messages child agents terminates
well  leaf agents child agents thus send terminate messages 
terminate messages thus propagate pseudo tree agents terminate 

common program follows 
context change  agent changed context x   executes following statements 
uses update equations                    initialize bounds takes best

value da    arg minddom a   lbx
 d    sends value messages child agents
cost message parent agent 
  

fiyeoh  felner   koenig





 



 







b



 

 



 



b

c



 

 



 

c











g

e
h



e

f
j

k

g
l



f

h
n




p

q

j
r



k


 



u



v



 

 

 

       

 

x

 

x

x

x

x

x x

x x

x x

x x

x x

x x





 

  



 

identifiers

  

 
 

       

 

x

x

x

x

x x

x x

x x

x x

x x

x x

 





 

 



 

 



  



 

 



 

 



  

  







 

  

 

x x

x x

 

x
 

         

x

  



x

x

x

x

x x

x x

x x

x x





  

  

 

x x

x x

 

         

cycle  

x
x

x

x

x x

x x

x x

x x





  

  
 

       

 

x

x

x

x

x x

x x

x x

x x

x x

x x

 



  

 



  

 



  



  

 



  

 



  

x





  
       

x
 
 

  

 

x



x

x

 

 

 

 

x x

x x

x x

x x

x x

x x





x

  

x

x

x

x

 

x x

x x

x x

x x

x x

cycle  

 
 

 

 

x x          





 
x

  

x

x

x

x

 

x x

x x

x x

x x

x x

  
 

 

 

x x          

cycle  

  





  



  

  
  

x





 

x



cycle  



x

 

cycle  

 



x

 





 

  



x

 

cycle  

 



x
 

x

 

cycle  

 



x

 

cycle  

 



x

 

x

  

x

x

x

x

 

x x

x x

x x

x x

x x

  
 

 

 

x x          

cycle  

figure    trace updates lower bounds
context change  agent change context x   executes following




statements  u bx
lbx  d   value   context agent augmented
value cannot completed solution whose solution cost smaller solution

cost best solution found far context x    u bx
  agent thus takes


best value    arg minddom a   lbx  d    sends value messages child
agents cost message parent agent 
assume context x agent change  nite amount time 




u bx
agent takes best value repeats
lbx  d   value  


procedure  nite amount time  u bx
lbx  d  values d  implies





u bx lbx   agent takes every value u bx
lbx since lbx  d 

remains unchanged u bx monotonically non increasing agent changes value
dierent value  prevents agent changing value back


u bx
lbx   bnb adopt thus performs depth rst search  then  nite amount time 
r
r
r
r
r
r
r
u bx r lbx r bound property u bx
r lbx r together imply u bx r   x r   lbx r
root agent r  dcop problem solved optimally 
figures     show traces updates lower upper bounds  respectively 
example dcop problem  bnb adopt uses zero heuristic values  initial context every
   

fibnb adopt  asynchronous branch and bound dcop algorithm





inf



inf







b



inf

inf



inf



b

c



inf

inf



inf

c











g

e
h



e

f
j

k

g
l



f

h
n




p

q

j
r



inf



k


u



v



inf

inf
inf

       

 

x

inf

x

x

x

x

x x

x x

x x

x x

x x

x x





  

inf
 

       

 

x

x

x

x

x x

x x

x x

x x

x x

x x

cycle  

  



  



  

inf



  

inf



  



  

inf



  

inf



  

  





inf

  

 

x x

x x

inf

x
inf

         

x

  



x

x

x

x

x x

x x

x x

x x





  

  

 

x x

x x

 

         

cycle  

x
x

x

x

x x

x x

x x

x x





  

  
 

       

 

x

x

x

x

x x

x x

x x

x x

x x

x x

  



  

inf



  

inf



  



  

inf



  

inf



  

x





  
       

x
 
 

inf

inf

x



x

x

inf

inf

inf

inf

x x

x x

x x

x x

x x

x x





x

inf

x

x

x

x

inf

x x

x x

x x

x x

x x

cycle  

inf
inf

inf

inf

x x          





inf
x

inf

x

x

x

x

inf

x x

x x

x x

x x

x x

  
inf

 

 

x x          

cycle  

  





  



  

  
  

x





inf

x



cycle  



x

 

cycle  

  



x

 





inf

  



x

inf

cycle  

  



x
 

x

inf

cycle  

  

x

inf





 

  



inf

identifiers


x

inf

x

inf

x

x

x

x

inf

x x

x x

x x

x x

x x

  
inf

 

 

x x          

cycle  

figure    trace updates upper bounds
agent assigns value   ancestor agents agent  partition time cycles  agents
maintain bounds one context given time  nodes gures crossed
agent maintain bounds  nodes shaded partial solution equal
context agent parent node augmented value  example  agents
a    a  a  take value   cycle    agent a  takes value    context agent a 
    context agent a    a        contexts agents a  a    a         a        
description trace follows 
cycle    root agent a  initializes context x a      initializes lower bounds
nodes b    lbax a a         c    lbax a a           since uses zero heuristic values 
a 
updates lower bound node    lbx
a       sum delta cost      
lower bound node b       according update equations  updates lower bound
a 
node b    lbx
a       sum delta cost       lower bound node c      
a 
according update equations  updates lower bound node    lbx
a   
minimum lower bound node       lower bound node b       according
update equations  initializes upper bounds nodes b c innity  updates
upper bounds nodes a  b innity according update equations  takes

   

fiyeoh  felner   koenig

best value  take either value   value   since lower bounds nodes
b    takes value   sends value message child agent a   
agent a  initializes context x a    a         initializes lower bounds nodes d  e 
f g    updates lower bounds nodes c  b         respectively 
initializes upper bounds nodes d  e  f g innity  updates upper bounds
nodes c  b innity  bounds node b agent a  maintains shown
gures  takes best value    sends value messages child agents a 
a  sends cost message parent agent a   
leaf agent a  initializes context x a    a         a         updates lower bounds
nodes g h delta costs        respectively  since leaf agents child
agents  updates lower bound node     updates upper bounds nodes g
h delta costs        respectively  since leaf agents child agents 
updates upper bound node     bounds node leaf agent a  maintains
shown gures  takes best value   sends cost message
parent agent a   
leaf agent a  initializes context x a    a         a         updates lower bounds
nodes j delta costs      respectively  updates lower bound node e
   updates upper bounds nodes j delta costs      respectively 
updates upper bound node e    bounds node e leaf agent a  maintains
shown gures  takes best value   sends cost message
parent agent a   
summary  following messages sent cycle   
message  value    a         agent a  agent a   
message  value    a         a         agent a  agent a   
message  value    a         a         agent a  agent a   
message  cost  a      a              agent a  agent a   
message  cost  a      a         a                 agent a  agent a   
message  cost  a      a         a               agent a  agent a   
cycle    root agent a  receives cost message sent child agent a  cycle    since
context agent a         compatible context message      a         
improves bounds  updates bounds node b bounds message     
innity  respectively   updates bounds nodes a  b a  change value
a 
a 
      value da       still smaller
since lower bound node    lbx
a   d
a 
upper bound node    u bx a       sends value message child agent
a   
agent a  receives value message sent parent agent a  cycle    context
     a         remains unchanged since desired context message
     a          agent a  receives cost messages sent child agents a  a 
cycle    since context agent a       a         compatible contexts
messages      a         a          improves bounds  updates bounds node
bounds rst message           respectively  bounds node e
bounds second message         respectively   updates bounds nodes c 
a 
a 
       value
b  changes value since lower bound node c    lbx
a   d
a 
a 
     longer smaller upper bound node b    u bx a         takes
best value    sends value messages child agents a  a  sends cost message
parent agent a   

   

fibnb adopt  asynchronous branch and bound dcop algorithm

leaf agents a  a  receive value messages sent parent agent a  cycle   
contexts      a         a         remain unchanged since desired
context message      a         a          send cost messages
parent agent a   
summary  messages sent cycle   identical ones sent cycle   
except messages sent agent a    follows 
message  value    a         a         agent a  agent a   
message  value    a         a         agent a  agent a   
message  cost  a      a                agent a  agent a   
value messages dierent agent a  changed value      cost
message dierent agent a  changed bounds 
cycles      messages sent cycle   identical ones sent cycle   
except messages sent agents a  a    follows 
message  cost  a      a         a               agent a  agent a   
message  cost  a      a         a               agent a  agent a   
cost messages dierent agents a  a  changed contexts 
termination condition holds nite amount time upper bound node
a 
a 
   u bx
a        larger lower bound node    lbx a         root agent a 
sends terminate messages child agents  terminate messages propagate
pseudo tree agents terminate  bnb adopt terminates nine cycles
minimal solution cost    
      performing branch and bound
rene description bnb adopt explaining agents implement branchand bound search make bnb adopt faster  every agent bnb adopt maintains

variable threshold hx
  initializes innity  threshold root agent always
remains innity  every agent uses threshold pruning  meaning change
value earlier previously 
first change  agent change context x   previously executed following




statements  u bx
lbx  d   value   agent took best value 
sent value messages child agents cost message parent agent  now 





hx
lbx  d    agent takes best value  thus  min t hx   u bx  


lbx
 d
  


agent
takes


best
value

thus
potentially
changes

value 




earlier previously  min t hx
 
u
b
 


pruning
quantity 

xa
second change  agent context x value da sends value messages
child agents  previously contained desired context x  a  da   




value messages contain desired threshold min t hx
  u bx   x  d  

a c
c c a  c lbx  d   child agent c  agent c receives value message  sets
threshold desired threshold proceeds described earlier  desired



reaches
threshold set lower bound lbx
 d   agent value
c
pruning quantity  and agent thus potentially changes value  lower bound lbx
c
agent c reaches desired threshold  property veried follows 

   

fiyeoh  felner   koenig



c




lbx
c min t hx   u bx   x  d  




lba c
x  d  

    

c c a  c








lba c
x  d   min t hx   u bx   x  d  
a c





min t hx
  u bx   x  d   lb  d  
x




lba c
x  d  

    

c c a  c






lba c
x  d  

    

c c a  c



a c





min t hx
  u bx   x  d     lb  d    
x







min t hx
  u bx   x  d    




lba c
x  d  

    

c c a  c



lba c
x  d  

    

c c a 




min t hx
  u bx   lbx  d  

    

      enhancements
continue rene description bnb adopt explaining number additional enhancements  introduced adopt 
reduced contexts  agents use reduced contexts  subsets contexts
described previously  reduced context x a agent contains values ancestor
agents p scp  a   context x a described previously contains values



ancestor agents p p  a   agents use reduced contexts since x
  x x  d   
 
 
 

x a  d  values d  agents use reduced contexts need change
contexts thus initialize bounds less often receive value messages since
contexts often identical desired contexts value messages 
example dcop problem  reduced context agent a  contains values
agent a  rather values agents a  a    therefore  following pairs nodes
search tree actually node  nodes q  nodes j r  nodes u 
nodes n v 
value cost messages  agent sends value messages child agents 
previously contained desired context desired threshold  desired context
context agent augmented value  agent receives value message 
previously checked whether context identical desired context value
message  not  agent changed context desired context
value message  agents update contexts dierently reduce size
value messages  agent sends value messages child pseudo child agents
identity  value desired threshold  innity pseudo child agents 
agent receives value message  sets threshold desired threshold message
parent agent  checks whether value ancestor agent value
message recent value ancestor agent context  is 
agent changes value ancestor agent context value ancestor agent
value message  however  context agent contain values
parent pseudo parent agents values ancestor agents parent
pseudo parent agents one  or more  descendant agents  ancestor agents
constrained agent cannot send value messages agent  however 
send value messages pseudo child agents  least one descendant agent
agent  information propagates pseudo tree cost messages
reaches agent  agent receives cost message  checks whether
   

fibnb adopt  asynchronous branch and bound dcop algorithm

value ancestor agent context cost message recent
value ancestor agent context  is  agent changes value
ancestor agent context value ancestor agent context cost
message  example dcop problem simple allow us illustrate propagation
information pseudo tree  however  imagine new agent a  child agent
agent a  constrained agents a  a    context agent a  contains
value agent a  agent a  cannot send value messages agent a    however  agent
a  sends value messages agent a    agent a  changes value agent a  context
sends cost messages context agent a    changes value agent
a  context well 
agents need determine whether value agent value messages
contexts cost messages recent value agent contexts  every
agent therefore maintains counter ida increments whenever changes
value  therefore  larger id indicates recent value  values agents contexts
labeled ids  value messages contain identity sending agent 
value  id desired threshold 
bounds  whenever agent changes context x   previously initialized bounds
took best value   reduced  context child agent agent strict
subset  reduced  context agent since parent pseudo parent agents
agent might  parent or  pseudo parent agents child agent descendant
agents  context child agent c contain values agents whose values
changed context agent a  agent initialize lower bounds lba c
x  d 
upper bounds uba c
 d 

agent
c


values



takes


best
value 
agents
xa
use optimization need initialize bounds less often way 
example dcop problem  agent a  changes context   a          a         where
ids omitted simplicity   initialize lower bounds lbax a a     d  upper
bounds ubax a a     d  child agent a  values since context agent a 
contain value agent a   
additionally  agent changes context due cost message child agent c
new context x compatible context cost message  agent
a c
set lower bound lba c
x  d  upper bound ubx  d  agent c value agent
cost message bounds cost message takes best value 
agents use optimization bounds cost message informed
initialized bounds  example dcop problem simple allow us illustrate
optimization  however  imagine new agent a  child agent agent a 
constrained agents a  a    assume context agent a    a         a       
 where ids omitted simplicity  receives cost message agent
a  context   a         a         agent a  changes context   a         a         sets
   a 
   a 
lower bound lba  a
    upper bound uba  a
    bounds
       a      
       a      
cost message initializes bounds takes best value 

      pseudocode
figure   shows bnb adopt pseudocode every agent  pseudocode index
variables context since context implicitly given variable x   uses
predicate compatible x  x      a d id x  a  d  id  x  a  
    determines two
contexts x x compatible  is  agent takes two dierent values two contexts
 lines                     pseudocode uses procedure prioritymerge x  x  
executes x      a     id   x    a d id x  a        a     id   x    a d id x  a  

   

fiyeoh  felner   koenig

procedure start  
    
x      p  valinit p        p scp  a   
    
ida      
    
forall c c a   dom a 
    
initchild c  d  
    
initself    
    
backtrack   
    
loop forever
    
 message queue empty 
    
while message queue empty 
    
pop msg message queue 
    
received msg  
    
backtrack   
procedure initchild c  d 
    
lba c  d     ha c  d  
    
uba c  d      
procedure initself   

    
da    arg minddom a     d    cc a  lba c  d   


    
id    id     
    
h     
procedure backtrack  
    
forall dom a 
    
lb  d      d    cc a  lba c  d  

    
ub  d      d    cc a  uba c  d  

    
lb    minddom a   lb  d   
    
ub    minddom a   ub  d   
    
 lb  da   min t h   ub   
    
da    arg minddom a   lb  d    choose previous da possible  
    
new da chosen
    
ida    ida     
    
  a root ub lb   termination message received 
    
send terminate  c c a  
    
terminate execution 


    
send value  a  da   ida   min t h   ub    da   c c a  c lba c  da    c c a  


    
send value  a    id     c cd a    c a  
    
send cost  a  x   lb   ub   pa a  root 
procedure received value  p  dp   idp   h p  
    
x    x  
    
prioritymerge  p  dp   id p    x   
    
  compatible x   x   
    
forall c c a   dom a 
    
 p scp  c  
    
initchild c  d  
    
initself    
    
 p   pa a  
    
h    h p  
procedure received cost  c  x c   lb c   ub c  
    
x    x  
    
prioritymerge x c   x   
    
  compatible x   x   
    
forall c c a   dom a 
    
  compatible   p  dp   id p   x   p scp  c   x   
    
initchild c d  
    
 compatible x c   x   
    
lba c  d     max lba c  d   lb c   unique  a   d  id  x c   a 
    
uba c  d     min uba c  d   ub c   unique  a   d  id  x c   a 
    
  compatible x   x   
    
initself    
procedure received terminate 
    
record termination message received 

figure    pseudocode bnb adopt
id id      a  d  id  x    a  d  id  x  a   id   id    thus replaces values

   

fibnb adopt  asynchronous branch and bound dcop algorithm

agents context x recent values  available  agents context x  lines
       
code identical every agent except variable self variable points
agent itself  start  bnb adopt calls start   every agent  agent receives
value message ancestor agent  received handler value messages
called p ancestor agent  dp value ancestor agent  idp
id ancestor agent h p desired threshold agent ancestor agent
parent agent  and innity otherwise   line      agent receives cost message
child agent  received handler cost messages called c child
c
agent  x c context child agent  lb c lower bound lbx
c child agent
c
c
u b upper bound u bx c child agent  line      finally  agent receives
terminate message parent agent  received handler terminate
messages called without arguments  line     
bnb adopt uses message passing communication framework adopt
memory requirements  uses similar value  cost terminate messages 
similar strategy update context agent based value messages ancestor
agents cost messages child agents  semantics bounds
update equations update bounds  bnb adopt adopt use thresholds bnbadopt uses thresholds pruning adopt uses reconstruct partial solutions
purged memory  thus  bnb adopt uses dierent threshold initialization  line
     dierent desired threshold calculation  line     dierent termination condition  line     
bnb adopt diers adopt maintains ids agents use indicate
recency values labels values agents contexts ids 
      trace
figures       show traces updates lower upper bounds  respectively 
example dcop problem  table   shows trace update variables  bnb adopt
uses heuristic values hax a a              hax a a              hax a a              hax a a              hax a a            
hax a a             contexts x a  x a    heuristic values chosen hand  every
agent assigns value ancestor agents initial context    partition time
cycles figures     continue use conventions made context gures 
cycle    root agent a  initializes context x a      line     initializes lower bounds
nodes b    lbax a a         c    lbax a a         heuristic values      respectively
a 
 line      updates lower bound node    lbx
a       sum delta cost
      lower bound node b       according update equations  line     
a 
updates lower bound node b    lbx
a       sum delta cost      
lower bound node c       according update equations  line      updates
a 
lower bound node    lbx
a    minimum lower bound node      
lower bound node b       according update equations  line      initializes
upper bounds nodes b c innity  line      updates upper bounds nodes a 
b innity according update equations  lines         takes best
value   since lower bound node       smaller lower bound node b      
 line      initializes id ida     lines        initializes threshold h a  innity
 line     sends value messages child agent a  pseudo child agent a   lines   
    
agent a  initializes context x a    a            line     initializes lower bounds
nodes d  e  f g heuristic value    line      updates lower bounds nodes
c  b          respectively  lines         initializes upper bounds
nodes d  e  f g innity  line      updates upper bounds nodes c  b
innity  lines         bounds node b agent a  maintains shown
   

fiyeoh  felner   koenig

cycle
x a 
da 
id a 
h a 
lb a     
lb a     
lb a 
u b a     
u b a     
u b a 
lba   a     
lba   a     
uba   a     
uba   a     
x a 
da 
id a 
h a 
lb a     
lb a     
lb a 
u b a     
u b a     
u b a 
lba   a     
lba   a     
uba   a     
uba   a     
lba   a     
lba   a     
uba   a     
uba   a     
x a 
da 
id a 
h a 
lb a     
lb a     
lb a 
u b a     
u b a     
u b a 
x a 
da 
id a 
h a 
lb a     
lb a     
lb a 
u b a     
u b a     
u b a 

 

 

 

 

 

 

 

 

 

 
 

 
 
 



 
 


 a         
 
 

 
  
 



 
 


 
 


 a         
 a         
 
 

  
  
  
  
  
  
 a         
 
 

 
 
 
 
 
 

 
 

 
 
 



 
 


 a         
 
 

  
  
  
  

  
  
 
  

 
 
 

 a         
 a         
 
 

  
  
  
  
  
  
 a         
 
 

 
 
 
 
 
 

 
 

  
 
 
  

  
  
 
  

 a         
 
 

  
  
  
  

  
  
 
  

 
 
 

 a         
 a         
 
 
 
 
  
 
 
  
 
 a         
 
 
 
  
 
 
  
 
 

 
 

  
 
 
  

  
  
 
  

 a         
 
 
  
  
  
  
  
  
  
  
 
  
 
 
 
 
 
 a         
 a         
 
 
 
 
  
 
 
  
 
 a         
 
 
 
  
 
 
  
 
 

 
 

  
 
 
  

  
  
 
  

 a         
 
 
  
  
  
  
  
  
  
  
 
  
 
 
 
 
 
 a         
 a         
 
 
  
  
  
  
  
  
  
 a         
 
 
 
 
 
 
 
 
 

 
 

  
 
 
  

  
  
 
  

 a         
 
 
  
  
 
 



 
 


 
 
 
 
 a         
 a         
 
 
  
  
 
 
  
 
 
 a         
 
 
 
 
 
 
 
 
 

 
 

  
 
 
  

  
  
 
  

 a         
 
 
  
  
 
 
  

  
 
 
 

 
 
 
 
 a         
 a         
 
 
  
  
 
 
  
 
 
 a         
 
 
  
  
 
 
  
 
 

 
 

  
 
 
  
  
  
  
 
  
  
 a         
 
 
  
  
  
  
  
  
  
 
 
 
 
 
 
 
 
 a         
 a         
 
 
  
  
 
 
  
 
 
 a         
 
 
  
  
 
 
  
 
 

 
 

  
  
  
  
  
  
  
  
  
  
 a         
 
 
  
  
  
  
  
  
  
 
 
 
 
 
 
 
 
 a         
 a         
 
 
 
  
 
 
  
 
 
 a         
 
 
 
  
 
 
  
 
 

table    trace update variables bnb adopt

   

fibnb adopt  asynchronous branch and bound dcop algorithm





 



 







b



 

 



 



b

c



 

 



 

c











g

e
h



e

f
j

k

g
l



f

h
n




p

q

j
r



k


 



u



v



  

 

 

       

 

x

 

x

x

x

x

x x

x x

x x

x x

x x

x x





 

  



 

identifiers

  

  
 

       

 

x

x

x

x

x x

x x

x x

x x

x x

x x

 





  

 



  

 



  



  

 



  

 



  

  







  

  

 

x x

x x

 

x
 

         

x

  



x

x

x

x

x x

x x

x x

x x





  

  

 

x x

x x

 

         

cycle  

x
x

x

x

x x

x x

x x

x x





  

  
 

       

 

x

x

x

x

x x

x x

x x

x x

x x

x x

 



  

 



  

 



  



  

 



  

 



  

x





x

x

x

x

x x

x x

x x

  
x

 

x x     

 
 

 

 

x



 

 

x x

x x





x

  

x

x

x

x

 

x x

x x

x x

x x

x x

cycle  

 
 

 

 

x x          



 
x

  

x

x

x

x

 

x x

x x

x x

x x

x x

  
 

 

 

x x          

cycle  

  





  



  

  
  

x







 

x



cycle  



x

 

cycle  

 



x

 





 

  



x

 

cycle  

 



x
 

x

 

cycle  

 



x

 

cycle  

 



x

 

x

  

x

x

x

x

 

x x

x x

x x

x x

x x

  
 

 

 

x x          

cycle  

figure     trace update lower bounds bnb adopt
gure  takes best value    line      initializes id    lines       
initializes threshold innity  line     sends value messages child agents a 
a  cost message parent agent a   lines        
leaf agent a  initializes context x a    a            a            line     updates lower
bounds nodes g h delta costs        respectively  since leaf agents
child agents  line      updates lower bound node     line      updates
upper bounds nodes g h delta costs        respectively  since leaf agents
child agents  line      updates upper bound node     line     
bounds node leaf agent a  maintains shown gure  takes
best value    line      initializes id    lines        initializes threshold innity
 line     sends cost message parent agent a   line     
leaf agent a  initializes  reduced  context x a    a            line     updates lower
bounds nodes j delta costs      respectively  line      updates
lower bound node e    line      updates upper bounds nodes j
delta costs      respectively  line      updates upper bound node e    line
     bounds node e leaf agent a  maintains shown gure  takes

   

fiyeoh  felner   koenig





inf



inf







b



inf

inf



inf



b

c



inf

inf



inf

c











g

e
h



e

f
j

k

g
l



f

h
n




p

q

j
r



inf



k


u



v



inf

inf
inf

       

 

x

inf

x

x

x

x

x x

x x

x x

x x

x x

x x

  





inf
 

       

 

x

x

x

x

x x

x x

x x

x x

x x

x x

cycle  

  



  



  

inf



  

inf



  



  

inf



  

inf



  

  





inf

  

 

x x

x x

inf

x
inf

         

x

  



x

x

x

x

x x

x x

x x

x x





  

  

 

x x

x x

 

         

cycle  

x
x

x

x

x x

x x

x x

x x

  





  
 

       

 

x

x

x

x

x x

x x

x x

x x

x x

x x

  



  

inf



  

inf



  



  

inf



  

inf



  

x





x

x

x

x

x x

x x

x x

inf
x

inf

x x     

inf
 

 

 

x



inf

 

x x

x x





x

  

x

x

x

x

 

x x

x x

x x

x x

x x

cycle  

inf
 

inf

 

x x          

  

x

x

x

 

x x

x x

x x

x x

x x

  
 

 

 

x x          

cycle  

  





  



  

  
  

x





  
x

x





  

x



cycle  



x

 

cycle  

  



x

 





inf

  



x

inf

cycle  

  



x
 

x

inf

cycle  

  

x

inf





inf

  



inf

identifiers


x

inf

x

  

x

x

x

x

 

x x

x x

x x

x x

x x

  
 

 

 

x x          

cycle  

figure     trace update upper bounds bnb adopt
best value    line      initializes id    lines        initializes threshold
innity  line     sends cost message parent agent a   line     
summary  following messages sent cycle   
message  value  a            agent a  agent a   
message  value  a            agent a  agent a   
message  value  a            agent a  agent a   
message  value  a            agent a  agent a   
message  cost  a      a                 agent a  agent a   
message  cost  a      a            a                    agent a  agent a   
message  cost  a      a                  agent a  agent a   
cycle    root agent a  receives cost message sent child agent a  cycle    since
context agent a         compatible context message      a            
improves bounds  updates bounds node b bounds message     
innity  respectively   lines         updates bounds nodes a  b  lines        
   

fibnb adopt  asynchronous branch and bound dcop algorithm

a 
a 
change value since lower bound node    lbx
      value
a   d
a 
a 
a 
     still smaller pruning quantity    min t hx a    u bx a      min      
   sends value messages child agent a  pseudo child agent a   lines        

agent a  receives value message sent parent agent a  cycle    updates
context   a             a           since id agent a  context       smaller
id message        line      threshold      remains unchanged since
desired threshold      message  agent a  receives cost
messages sent child agents a  a  cycle    since context      a            compatible contexts messages      a            a             a            respectively  
improves bounds  updates bounds node bounds rst message
          respectively  bounds node e bounds second message     
   respectively   lines         updates bounds nodes c  b  lines        
a 
a 
       value da      
changes value since lower bound node c    lbx
a   d
a 
a 
longer smaller pruning quantity    min t hx a    u bx
a      min             
takes best value    line      increments id    lines         sends value messages
child agents a  a   lines        sends cost message parent agent a 
 line     
leaf agent a  receives value messages sent parent agent a  pseudo parent
agent a  cycle    updates context   a            a             a            a          
since ids agents a  a  context         respectively  smaller
ids messages         respectively   line      threshold      remains
unchanged since desired threshold      message  bounds
reinitialized since context compatible previous context  line      sends
cost message parent agent a   line     
leaf agent a  receives value message sent parent agent a  cycle    updates
contexts   a             a           since id agent a  context       smaller
id message        line      threshold      remains unchanged since
desired threshold      message  bounds reinitialized since
context compatible previous context  line      sends cost message
parent agent a   line     
summary  messages sent cycle   identical ones sent cycle   
except messages sent agents a    a  a    follows 
message  value  a             agent a  agent a   
message  value  a             agent a  agent a   
message  cost  a      a                    agent a  agent a   
message  cost  a      a            a                    agent a  agent a   
message  cost  a      a                  agent a  agent a   
value messages dierent agent a  changed value      cost
messages dierent agent a  changed bounds context agents a 
a  changed contexts 
cycles      messages sent cycle   identical ones sent cycle   
except messages sent agents a  a    follows 
message  cost  a      a            a                  agent a  agent a   
message  cost  a      a                  agent a  agent a   

   

fiyeoh  felner   koenig

cost messages dierent agents a  a  changed contexts 
termination conditions holds nite amount time upper bound node
a 
a 
   u bx
a        larger lower bound node    lbx a         line      root
agent a  sends terminate messages child agents  line      terminate
messages propagate pseudo tree  line     agents terminate  bnb adopt
terminates nine cycles minimal solution cost    

   bounded error approximations
section  present three approximation mechanisms allow bnb adopt trade
solution cost smaller runtime  bound error solution cost user dened
error bound  first  modify absolute error mechanism adopt  modi et al        
work bnb adopt  approximation mechanism allows users specify absolute error
bound solution cost  for example  solution cost    larger
minimal solution cost   however  often much desirable specify relative error bound
solution cost  for example  solution cost    percent larger
minimal solution cost or  equivalently      times larger minimal solution cost   cannot
done absolute error mechanism without knowing minimal solution cost priori 
thus  introduce two approximation mechanisms allow users specify relative error bound
solution cost  namely relative error mechanism weighted heuristics mechanism 
approximation mechanisms let root agent r  and root agent  maintain
limit limr   root agent uses limit way termination condition
r
r
approximation mechanisms updates dierently  termination condition u bx
r lbx r
r
r
line    pseudocode bnb adopt replaced u bx r lim   root agent updates
limit lines       pseudocode  outside preceding statement 
    absolute error mechanism
absolute error mechanism adopt requires user dened absolute error bound   b  
species solution cost b larger minimal solution cost 
approximation mechanism easily modied bnb adopt setting limit follows 
limr

  

r
b   lbx
r

    

bnb adoptaem resulting variant bnb adopt absolute error mechanism 
bnb adoptaem terminates upper bound root node  which equal solution
cost solution smallest solution cost found far  larger limit  which
equal absolute error bound b plus lower bound root node  lower
bound minimal solution cost   bnb adoptaem terminates solution cost
equal upper bound root node although minimal solution cost could small
lower bound root node  thus terminates solution cost b larger
minimal solution cost  figure    shows trace bnb adoptaem absolute error
bound b      example dcop problem  bnb adoptaem terminates three cycles
suboptimal solution cost     six cycles faster bnb adopt 
    relative error mechanism
often much desirable specify relative error bound solution cost rather
absolute error bound  fortunately  absolute error mechanism bnb adopt easily
changed relative error mechanism setting limit follows  relative error
   

fibnb adopt  asynchronous branch and bound dcop algorithm



 





lim       

ub     infinity



lim       

ub     infinity

 



 





 

 



 

 



  



 

 



 

 



  

 







 

  
 

       

 

x

x

  



 

 

x

x

x

x

x x

x x

x x

x x

x x

x x





  

  
 

       

 

x

x

 

 

x

x

x

x

x x

x x

x x

x x

x x

x x

cycle  





 
 

  



lim       

ub       

  

  

 

x x

x x

 

x
 

         

cycle  

x

x

x

x

x

x x

x x

x x

x x

cycle  

figure     trace update lower bounds bnb adoptaem b     


 





lim      

ub     infinity



lim       

ub     infinity

 



 





 

 



 

 



  



 

 



 

 



  

 







 

  
 

       

 

x

x

  



 

 

x

x

x

x

x x

x x

x x

x x

x x

x x





  

  
 

       

 

x

x

 

 

x

x

x

x

x x

x x

x x

x x

x x

x x

cycle  

cycle  





 
 

  



lim       

ub       

  

  

 

x x

x x

 

x
 

         

x

x

x

x

x

x x

x x

x x

x x

cycle  

figure     trace update lower bounds bnb adoptrem p    
mechanism requires user dened relative error bound   p   species solution
cost p times larger minimal solution cost 
limr

r
   p lbx
r

    

bnb adoptrem resulting variant bnb adopt relative error mechanism 
bnb adoptrem terminates upper bound root node  which equal solution
cost solution smallest solution cost found far  larger limit  which
equal relative error bound p times lower bound root node  lower
bound minimal solution cost   bnb adoptrem terminates solution cost
equal upper bound root node although minimal solution cost could small
lower bound root node  thus terminates solution cost p times
larger minimal solution cost  figure    shows trace bnb adoptrem relative
error bound p     example dcop problem  bnb adoptrem terminates three cycles
suboptimal solution cost     six cycles faster bnb adopt 
    weighted heuristics mechanism
second way implementing relative error bound bnb adopt since bnb adopt
uses admissible heuristic values  common practice context a  trade solution
cost smaller runtime using weighted heuristic values  pohl         derived
admissible heuristic values multiplying user dened weight   w    
resulting heuristic values inadmissible  a  longer guaranteed nd cost minimal
solutions guaranteed terminate solution cost w times larger
minimal solution cost  pohl         approximation mechanism easily modied
bnb adopt setting limit follows 
limr

  

   

r
lbx
r

    

fiyeoh  felner   koenig



 





lim      

ub     infinity



lim       

lim       

   uba    infinity



   uba      





 

  



  

  



  



 

  



  

  



  

  







 

  
 

       

 

x

x

  



 

 

x

x

x

x

x x

x x

x x

x x

x x

x x





  

  
 

       

 

x

x

 

x

x

x

x

x x

x x

x x

x x

x x

x x

cycle  

cycle  





  

  



 

  

  

  

 

x x

x x

 

x
 

         

x

x

x

x

x

x x

x x

x x

x x

cycle  

figure     trace update lower bounds bnb adoptw hm w    
initializing lower bounds lba c
x  d  follows 
lba c
x  d 

   w ha c
x  d 

    

agents a  values d  child agents c contexts x   bnb adoptw hm
resulting variant bnb adopt weighted heuristics mechanism  bnb adoptw hm
terminates upper bound root node  which equal solution cost solution
smallest solution cost found far  larger limit  which equal lower
bound root node  lower bound w times minimal solution cost   bnbadoptw hm terminates solution cost equal upper bound root node
although minimal solution cost could small lower bound root node divided
w  thus terminates solution cost w times larger minimal
solution cost  figure    shows trace bnb adoptw hm w     example dcop
problem  bnb adoptw hm terminates three cycles suboptimal solution cost    
six cycles faster bnb adopt 

   correctness completeness
section  prove correctness completeness bnb adopt suboptimal
variants  denitions  lemmata  theorems corollaries hold bnb adopt suboptimal variants except mentioned otherwise  therefore  agent uses following update
equation values d  child agents c contexts x initialize bounds lba c
x  d  
a c
lba c
x  d     w hx  d 

    

weight w oating point number satises   w   heuristic values
ha c
x  d  oating point numbers satisfy
c
  ha c
x  d  x  a d 

    

messages sent end cycle received beginning cycle  largest
duration time message sent time processed  largest duration
cycle 
lemma    two contexts x x arbitrary agent agree values ancestor


  x
agents p scp  a  agent a  x
 
proof  denition  x x  reduced  context contains values ancestor agents

sum constraint costs constraints
p scp  a  agent a  gamma cost x
   

fibnb adopt  asynchronous branch and bound dcop algorithm

involve agent one descendant agents minimized possible values agent
descendant agents  assumption ancestor agents agent take values

thus depends values ancestor agents  including
context x  gamma cost x
parent agent  agent parent pseudo parent agents agent one  or more 
descendant agents  is  values ancestor agents p scp  a  agent a  therefore 




  x
x
  similarly  x   x  
definition    contexts correct ids values agents contexts equal
ids agents  implies values agents contexts equal
values agents 
lemma    context x arbitrary agent change period time 


lower bounds lba c
x  d   lbx  d  lbx monotonically non decreasing upper
a c


bounds ubx  d   u bx  d  u bx monotonically non increasing period time
values dom a  child agents c c a  

proof  since context x change  delta values x
 d  constant bounds
 once initialized  updated according update equations       thus  lower bounds
monotonically non decreasing upper bounds monotonically non increasing 

lemma    value arbitrary ancestor agent p scp  a  arbitrary agent
change current time future time    a           
value agent p id context agent equal value agent p id 
respectively  time time t 
proof  assume value arbitrary ancestor agent p scp  a  arbitrary agent
change current time future time    a           
following two cases 
case    agent p parent pseudo parent agent agent a  sent value message
agent value id time     is  cycle took
value time since duration cycle larger    the
agents send value messages end every cycle   agent receives value message
time   since messages delivered nite delay   updates value
agent p id context time     since update done cycle
duration cycle larger   thus  value agent p id
context agent equal value agent p id  respectively 
time time           since agent p change
value time time t 
case    agent p parent pseudo parent agent agent a  one pseudo child
agents c descendant agent agent a  agent p sent value message agent c
value id time     agent c receives value message time    
updates value agent p id context sends cost message parent
agent pa c  updated context time        the agents send cost messages
end every cycle   agent pa c  receives cost message time        
updates value agent p id context sends cost message parent
agent pa pa c   updated context time            process continues
agent updates value agent p id context time   n       
n  a  number messages chain messages  thus  value agent p
id context agent equal value agent p id  respectively 
time time   n          a          since agent
p change value time time t 

   

fiyeoh  felner   koenig

corollary    values ancestor agents p scp  a  arbitrary agent
change current time future time    a            context
agent correct time time t 
c
c
c
lemma    lbx
c w x c w u bx c times child agents c c a  arbitrary
a c
a c
c
c
agent contexts x   lbx  d  w x
 a d  w ubx  d  times context
x agent a  values dom a  child agents c c a  

proof  prove lemma induction number times agent changes context
a c
updates bounds lba c
x  d  ubx  d  arbitrary value arbitrary child agent c
agent initializes bounds  conclusion lemma holds agent context
x initializes bounds since
a c
lba c
x  d    w hx  d 

 eq     

w

 eq     

c
x
 a d 


  w uba c
x  d 

 eq    

 unchanged new  context x agent  induction basis   assume lemma
holds agent changed context updated bounds number times  induction assumption   show holds agent changes context updates bounds one
time  induction step   following two cases  where split operations
receiving cost message two parts  
case    conclusion lemma holds agent changes context x x
receiving value cost message two contexts agree values
ancestor agents p scp  c  since agent change bounds thus
 d    lba c
lba c
x  d 
x
c
w x
 a d 

 induction assumption 

c
w x
 a d 
a c
ubx  d 
c
x
 a d 
c
x  a d 

 lemma   

 
uba c
 d 
x

 premise case 

 

 

 premise case 
 induction assumption 
 lemma   

receiving value cost message  since contexts x x agree values
ancestor agents p scp  c   
case    conclusion lemma holds agent updates bounds lba c
x  d 
a c
a c
a c


ubx  d  lbx  d  ubx  d   respectively  receiving cost message child
c
c
c
agent c bounds lbx
compatible context x
c u bx c context x
agent value since

   

fibnb adopt  asynchronous branch and bound dcop algorithm

a ca  d    max lba ca  d   lb c c  
lb
x
x
x
c
c
max w x
 a d    w x c  

 eq    
 induction assumption premise lemma 

c
c
  max w x
 a d    w x  a d   

 w
a ca  d 
ub
x

 lemma   

c
x
 a d 

c
  min uba c
x  d   u bx c  
c
c
min x
 a d    x c  

 eq     
 induction assumption premise lemma 

c
c
  min x
 a d    x  a d   

 

 lemma   

c
x
 a d 

receiving cost message  since contexts x  a  d  x c agree values
ancestor agents p scp  c   
a c
c
thus  lba c
x  d  w x  a d  w ubx  d  times values dom a  child
agents c c a  






lemma    lbx
 d  w x  d  w u bx  d  lbx w x w u bx times

values dom a  context x arbitrary agent a 

proof  prove lemma induction depth agent pseudo tree  lemma
holds leaf agent pseudo tree context x since


lbx
 d    x  d 

 eq    


x
 d 

x  d 

x
 d 

 eq    
 eq     

 

u bx
 d   
 

 eq    





values times  thus  lbx
 d    x  d  w x  d    w u bx  d  values
times  furthermore 


lbx
 

 


u bx


min


 lbx
 d  

 eq     

ddom a 

min


 x
 d  

 see above 

ddom a 


  x

  min

 eq    
 eq     


 u bx
 d  
ddom a 

 

min


 x
 d  

 see above 

ddom a 

  x


 eq    





times  thus  lbx
  x w x   w u bx times  induction basis   assume
lemma holds agents depth pseudo tree  induction assumption   show
holds agents depth   pseudo tree time update
bounds  induction step   lemma holds agent context x since

   

fiyeoh  felner   koenig





lbx
 d    x  d   

lba c
x  d 

 eq    

cc a 




x
 d   

c
w x
 a d 

 induction assumption lemma   

cc a 

w x
 d 


u bx
 d    x  d   

 eq    



uba c
x  d 

 eq     

cc a 




x
 d   

c
x
 a d 

 induction assumption lemma   

cc a 

  x
 d 

 eq    




thus  lbx
 d  w x  d  w u bx  d  times values dom a   furthermore 


lbx
 



min


 lbx
 d  

 eq     

ddom a 

min


 w x
 d  

 see above 

ddom a 

 w

min


 x
 d  

ddom a 


  w x


u bx


 


 eq    


min  u bx
 d  
ddom a 

min

 eq     


 x
 d  

 see above 

ddom a 


  x


 eq    




thus  lbx
w x w u bx times 

definition    potential agent context x

lbx
 d   



ddom a   w


u bx
 d 

lemma    context x arbitrary agent longer changes  potential
agent monotonically non increasing decreases positive constant every time
agent changes value 


proof  lower bounds lbx
 d  monotonically non decreasing upper bounds u bx  d 
monotonically non increasing values according lemma   since context x
agent longer changes  therefore  potential agent monotonically non increasing 


furthermore  agent changes value new value minddom a   lbx
 d     lbx  d 

 line      thus  lower bound lbx  d  must strictly increased time
agent changed value time changes value new value  thus 
potential decreased positive constant  namely smallest possible increase

lower bound lbx
 d   assume constraint costs  weights heuristic values integers 
then  smallest possible increase bounded one possible values

lbx
 d  combinations constraint costs weighted heuristic values  similar statement
holds constraint costs  weights heuristic values oating point numbers since
transformed integers multiplying suciently large integer 

lemma    agents change values nite number times 
   

fibnb adopt  asynchronous branch and bound dcop algorithm

proof  assume lemma hold choose agent changes value
innite number times whose ancestor agents p scp  a  change values nite
number times  then  exists time ancestor agents change values
longer  exists  later  time agent longer changes context x according
corollary    every time agent changes value afterwards  potential decreases
positive constant according lemma    towards minus innity  however  potential cannot


become negative since lbx
 d  w u bx  d  values according lemma   
contradiction  thus  agents change values nite number times 

lemma    bnb adopt suboptimal variants terminate earlier  u bx



lbx nite amount time agents contexts x  

proof  prove lemma induction depth agent pseudo tree  exists
time agent changes value longer according lemma    exists  later 
time contexts agents correct longer change according corollary    let
x context agent point time agents a  exists  even later 
a c




time bounds lba c
x  d   lbx  d   lbx   ubx  d   u bx  d  u bx longer change

agents a  values child agents c since     lower bounds lba c
x  d   lbx  d 
a c



lbx monotonically non decreasing upper bounds lbx  d   u bx  d  u bx

monotonically non increasing agents a  values child agents c according lemma






       lbx
 d  w x  d  w u bx  d  lbx w x w u bx agents
a c
a c
values according lemma        lbx  d  w ubx  d  agents a  values
child agents c according lemma       smallest possible increases lower bounds
smallest possible decreases upper bounds larger positive constant since
possible values bounds combinations constraint costs heuristic values 
explained detail proof lemma    consider rst cost message agent
sends time earliest time cost messages processed
receiving agents  lemma holds leaf agent pseudo tree context x since


lbx
 d    x  d 

  x
 d 

 eq    
 eq    



u bx
 d    x  d 

  x
 d 

 eq     
 eq    

values considered time  furthermore 

lbx
 

 


u bx


min


 lbx
 d  

min


 x
 d  

 eq     

ddom a 

 see above 

ddom a 


  x

  min

 eq    
 eq     


 u bx
 d  
ddom a 

 

min


 x
 d  

 see above 

ddom a 


  x


 eq    



considered time  thus  u bx
  lbx considered time  induction basis  
assume lemma holds agents depth pseudo tree considered time
 induction assumption   show holds agents depth   pseudotree considered time  induction step   agent context x

   

fiyeoh  felner   koenig



lbx
 d    x  d   



lba c
x  d 

 eq    

c
max lba c
x  d   lbx c  

 eq    

cc a 

  x
 d   



cc a 

x
 d   



c
lbx
c

cc a 




x
 d 

 



c
u bx
c

 induction assumption 

cc a 

x
 d   



c
min uba c
x  d   u bx c  

cc a 

 


x
 d 

 



uba c
x  d 

 eq     

cc a 

  u bx
 d 

 eq     


value considered time since bounds longer change  thus  u bx
 d 

 d 


value



considered
time 
since
agent



change

value

lbx





considered time  must hold lbx
 d 
 
min t
h
 
u
b
 
 line
   

lb

xa
xa
x  d   

minddom a   lbx
 d  
 line
    

rst
disjunct
implies






min t hx
  u bx   u bx

u bx
 d 

lbx  d 

 eq     
 see above 



  min t hx
  u bx  

 rst disjunct 

value d  contradiction  second disjunct implies


u bx
u bx  d 

lbx
 d 

 

min

 eq     
 see above 


 lbx
 d  

 second disjunct 

ddom a 


  lbx


 eq     



value thus u bx
lbx  

theorem    bnb adopt suboptimal variants terminate nite amount time 


proof  bnb adopt suboptimal variants terminate earlier  u bx
lbx
nite amount time agents contexts x according lemma   
r
r
r
r
particular  u bx
root agent r  limr   lbx
r lbx r lim
r bnb adopt
r
r

b

 

bnb adopt

limr   p lbx
bnb adoptw hm   limr   b   lbx
r
r
aem
p   bnb adoptrem according section    thus  termination condition
r
r
r
r
u bx
suboptimal
r lbx r bnb adopt termination condition u bx r lim
variants satised 
r
theorem    bnb adopt terminates minimal solution cost x
r 

   

fibnb adopt  asynchronous branch and bound dcop algorithm

proof  bnb adopt terminates nite amount time according theorem    solution
r
r
r
cost bnb adopt upper bound u bx
r root agent r  u bx r lbx r upon termination
r
r
r
according termination condition  w u bx r w x r lbx r according lemma   
r
r
r
therefore  u bx
r   x r   lbx r since w     
theorem    bnb adoptaem terminates solution cost bounded
r
user dened absolute error bound b plus minimal solution cost x
r 
proof  bnb adoptaem terminates nite amount time according theorem   
r
r
r
solution cost bnb adoptaem upper bound u bx
r root agent r  u bx r lim  
r
r
r
b   lbx r upon termination according termination condition  lbx r w x r according
r
r
lemma    therefore  u bx
r b   x r since w     
theorem    bnb adoptrem terminates solution cost bounded
r
user dened relative error bound p times minimal solution cost x
r 
proof  bnb adoptrem terminates nite amount time according theorem   
r
r
r
solution cost bnb adoptrem upper bound u bx
r root agent r  u bx r lim  
r
r
r
p lbx r upon termination according termination condition  lbx r w x r according
r
r
lemma    therefore  u bx
r p x r since w     
theorem    bnb adoptw hm terminates solution cost bounded
r
user dened weight w times minimal solution cost x
r 
proof  bnb adoptw hm terminates nite amount time according theorem   
r
r
r
solution cost bnb adoptw hm upper bound u bx
r root agent r  u bx r lim  
r
r
r
upon
termination
according


termination
condition 
lb

w


according

lbx
r
xr
xr
r
r
lemma    therefore  u bx

w


 
r
xr

   experimental evaluations
section  compare bnb adopt two memory bounded dcop search algorithms
restrict communication agents share constraints  namely adopt ncbb 
compare three suboptimal variants bnb adopt other  use distributed
dfs algorithm max degree heuristic  hamadi  bessiere    quinqueton        used
adopt construct pseudo trees  use dp   ali et al         used adopt
pre calculate heuristic values adopt bnb adopt  dp  solves relaxed version
given dcop problem  where backedges ignored  dynamic programming based approach 
ncbb calculates heuristic values search rather pre processing step 
    runtime metrics
use two common runtime metrics  namely non concurrent constraint checks  meisels  kaplansky 
razgon    zivan        cycles  modi et al         
non concurrent constraint checks  ncccs   ncccs weighted sum processing
communication time  every agent maintains counter n ccc   initialized
   agent assigns n ccc    n ccc     every time performs constraint check
account time takes perform constraint check  assigns n ccc   

max n ccc   n ccc   t  every time receives message agent account

time takes wait agent send message  n ccc   transmission time
message  t   use     simulate fast communication        simulate
slow communication  number ncccs largest counter value agent 

   

fiyeoh  felner   koenig

sensors
 
 

 

targets
 

 

 

 

 

 
  

  

  

  

constraints

unit

figure     example  allocating targets

figure     example  scheduling meetings

ncccs good runtime metric ratio processing communication time
estimated reliably 
cycles  cycles time slices  cycle time required agent process incoming
messages queue send outgoing messages  processed receiving
agents next cycle  thus  number cycles indicates length longest chain
messages agents  cycles good runtime metric communication time
much larger processing time  cycles become better better runtime metric
future since communication time expected remain relatively stable
processing time expected decrease  silaghi  lass  sultanik  regli  matsui    yokoo        
    dcop problem types
use three dcop problem types experiments  namely graph coloring problems  sensor
network problems meeting scheduling problems 
graph coloring  graph coloring problems involve coloring vertices graph  taking
restrictions colors adjacent vertices account  agents vertices 
domains colors  constraints adjacent vertices  vary
number vertices       constraint density    ratio number
constraints number agents     sparse graphs     dense graphs 
range constraint costs range      small range  range           large
range   agent always three possible values  average experimental results
   dcop problem instances randomly generated constraints randomly generated
integer constraint costs 
sensor network  sensor network problems involve assigning targets sensors sensor
network  taking restrictions availability sensors  restrictions number
sensors need track target priorities targets account 
agents targets  domains time slots tracked 
constraints adjacent targets  maheswaran et al       b   figure    shows sensor
network targets located grid target surrounded four sensors 
needed track target  vary number targets      
always use   time slots  cost assigning time slot target assigned
adjacent target innity  to precise             since sensor cannot track
targets time slot  cost targets tracked time
slot      costs range        average experimental results
   dcop problem instances randomly generated integer constraint costs 
meeting scheduling  meeting scheduling problems involve scheduling meetings
employees company  taking restrictions availability well priorities
account  agents meetings  domains time slots
held  constraints meetings share participants  maheswaran et al  
   

fibnb adopt  asynchronous branch and bound dcop algorithm

graph coloring  density    
communication cost    

graph coloring  density    
communication cost       

  e   
adopt
bnb adopt
ncbb

  e   

nccc

nccc

  e   

  e   
  e   

adopt
bnb adopt
ncbb

  e   
  e   
  e   

 

 

 

 

 

  

  

  

  

  

 

 

 

number vertices

 

 

 a 
graph coloring  density    

  

  

  

graph coloring  density    
communication cost    

  e   

adopt
bnb adopt
ncbb

nccc

  e   
cycles

  

 b 

  e   

  e   
adopt
bnb adopt
ncbb

  e   
  e   
  e   

  e   
 

 

 

 
 
     
number vertices

  

  

 

  

 

 

  

  

  

  

 d 

graph coloring  density    
communication cost       

  e   

  

number vertices

 c 

graph coloring  density    
  e   

cycles

adopt
bnb adopt
ncbb

  e   
nccc

  

number vertices

  e   
  e   
  e   

  e   
adopt
bnb adopt
ncbb

  e   
  e   

 

 

 

  

  

  

  

  

 

 

 

  

  

  

  

  

number vertices

number vertices

 e 

 f 

figure     experimental results comparing adopt  bnb adopt ncbb graph coloring
problems constraint costs ranging         

    b   figure    shows hierarchical organization   units supervisor three
subordinates  example  supervisor   three subordinates         unit 
assume possible meetings  one entire unit  e g                two parent child meetings
 e g              two sibling sibling meetings  e g               vary number
meetings      unit        units   always use   time slots  cost assigning
time slot meeting least one participant another meeting
time slot innity  to precise             since person cannot attend
one meeting time  cost non scheduled meeting      costs
range        average experimental results    dcop problem instances
randomly generated integer constraint costs 

   

fiyeoh  felner   koenig

  e   

graph coloring  density    
communication cost    

  e   
  e   
nccc

nccc

  e   

graph coloring  density    
communication cost       

  e   
adopt
bnb adopt
ncbb

  e   

  e   
adopt
bnb adopt
ncbb

  e   

  e   

  e   
   

    

     

                

   

range constraint costs

    

     

                

range constraint costs

 a 

 b 

graph coloring  density    
  e   

  e   

graph coloring  density    
communication cost    

nccc

cycles

  e   
  e   
adopt
bnb adopt
ncbb

  e   

  e   
  e   

adopt
bnb adopt
ncbb

  e   

  e   

  e   
   

    

     

                

   

range constraint costs

 c 

  e   

     

                

 d 

graph coloring  density    
communication cost       

graph coloring  density    
  e   

  e   

  e   
cycles

nccc

    

range constraint costs

  e   
  e   

adopt
bnb adopt
ncbb

  e   

  e   

adopt
bnb adopt
ncbb

  e   

  e   

  e   
   

    

     

                

range constraint costs

   

    

     

                

range constraint costs

 e 

 f 

figure     experimental results comparing adopt  bnb adopt ncbb graph coloring
problems    vertices

    experimental results  optimal dcop search algorithms
rst compare bnb adopt adopt ncbb  figure    shows experimental results
graph coloring problems constraint costs ranging           varied
number vertices  figure    shows experimental results graph coloring problems
   vertices  varied range constraint costs  figures    a c     a c  show
results coloring sparse graphs  figures    d f     d f  show results coloring
dense graphs  y axes log scale show runtimes ncccs cycles  dcop search
algorithms sparse graphs faster dense graphs because  example  larger
likelihood independent dcop subproblems sparse graphs  bnb adopt generally faster
ncbb sparse graphs dense graphs bnb adopt allows agents send
messages parent agents pseudo tree  along edges pseudo tree  ncbb

   

fibnb adopt  asynchronous branch and bound dcop algorithm

sensor network
communication cost       

  e   

  e   

  e   

  e   
nccc

nccc

sensor network
communication cost    

  e   
  e   

adopt
bnb adopt
ncbb

  e   

adopt
bnb adopt
ncbb

  e   
  e   
  e   

  e   

  e   
 

 

 

 

                       
number targets

 

 

 a 

 b 

sensor network

meeting scheduling
communication cost    

  e   

  e   
adopt
bnb adopt
ncbb

  e   
nccc

cycles

  e   
  e   
  e   

  e   
adopt
bnb adopt
ncbb

  e   

  e   

  e   
 

 

 

 

                       
number targets

 

 

 c 

  

  

  

meeting scheduling
  e   

  e   

  e   
cycles

  e   

  e   
adopt
bnb adopt
ncbb

  e   

 
          
number meetings

 d 

meeting scheduling
communication cost       

nccc

                       
number targets

  e   
adopt
bnb adopt
ncbb

  e   

  e   

  e   
 

 

 

 
          
number meetings

  

  

  

 e 

 

 

 

 
          
number meetings

  

  

  

 f 

figure     experimental results comparing adopt  bnb adopt ncbb sensor network
meeting scheduling problems

allows agents send messages pseudo parent agents  along backedges pseudotree   thus  agents ncbb receive updates faster agents bnb adopt  eect
prevalent dense graphs since backedges dense graphs  however  dierence
bnb adopt ncbb becomes negligible communication slow 
figure    shows bnb adopt least half order magnitude faster adopt
number vertices small  speedup adopt increases number vertices
gets larger dcop problems thus become complex  similarly  figure    shows
speedup adopt increases range constant costs increases dcop problems
thus become complex  however  adopt faster bnb adopt simple dcop
problems  example  adopt requires fewer cycles bnb adopt dcop problems
constraint costs ranging      figure    shows trend sensor network meeting
scheduling problems  reason behavior follows  adopt uses memory bounded best   

fiyeoh  felner   koenig

sensor network
communication cost    

  e   

sensor network
communication cost       

  e   

nccc

nccc

  e   
  e   
adopt

  e   

  e   
adopt

bnb adopt

bnb adopt

  e   

  e   
   

   

   
   
weight

   

 

   

   

 a 

   

 

   

 

 b 

sensor network
  e   

sensor network
unique contexts explored

  e   
no 
contexts

cycles

   
   
weight

  e   
adopt

adopt
bnb adopt

bnb adopt

  e   

  e   
   

   

   
   
weight

   

 

   

   

 c 

   
   
weight

 d 
sensor network
repeated contexts explored

no 
contexts

  e   
  e   

adopt
bnb adopt

  e   
  e   
   

   

   
   
weight

   

 

 e 

figure     experimental results cause speedup adopt bnb adopt
rst search thus exploits heuristic values well needs repeatedly reconstruct partial
solutions purged memory  especially heuristic values poorly informed  bnbadopt uses depth rst branch and bound search thus exploit heuristic values
quite well repeatedly reconstruct partial solutions  adopt thus
faster bnb adopt dcop problems well informed heuristic values  simple
dcop problems 
conrm intuition additional experiment sensor network problems four
targets dierent informedness heuristic values  use heuristic values cha c
x  d     
c    ha c
x  d  heuristic values calculated dp   used now  figures    a c 
show number ncccs dierent weights c  heuristic values well informed  large
weights   adopt indeed faster bnb adopt  since adopt relies heuristic
values bnb adopt  speedup adopt much larger bnb adopt
heuristic values get informed  figures    d     e  show number unique

   

fibnb adopt  asynchronous branch and bound dcop algorithm

   dierent  repeated contexts per agent dierent weights c  heuristic values
well informed  large weights   agents adopt explore fewer unique contexts agents bnbadopt since focused search  however  heuristic values poorly
informed  small weights   explore unique contexts  agents adopt explore many
repeated contexts agents bnb adopt since need reconstruct partial solutions
purged memory  agents bnb adopt explore repeated contexts even though
reconstruct partial solutions  reason behavior distributed nature
bnb adopt  example  assume context agent   a         a        next
context centralized variant bnb adopt would   a         a         where ids omitted
simplicity   agent updates context   a         a        receives message
agent a  takes value    agent updates context   a         a       
receives message agent a  takes value    thus  agent explores intermediate
context   a         a        centralized variant bnb adopt would explore  counts
repeated context agent explores context intentionally future  overall  bnb adopt
tends faster adopt heuristic values poorly informed  small weights   thus 
bnb adopt great potential dcop search algorithm since heuristic values often poorly
informed complex dcop problems  dcop problems large numbers agents  large
domains  large numbers constraints large ranges constraint costs 
    experimental results  suboptimal variants bnb adopt
compare three suboptimal variants bnb adopt other  experimental
setup identical one optimal dcop search algorithms  except follows  graph
coloring problems  number vertices     range constraint costs         
constraint density    sensor network problems  number targets    meeting
scheduling problems  number meetings     measure runtimes cycles   the results
ncccs similar   however  report normalized runtimes  is  runtimes divided
runtime nding cost minimal solution bnb adopt  thus  normalized runtime
     refers one quarter number cycles takes nd cost minimal solution
bnb adopt  similarly  report normalized solution costs  is  solution costs divided
minimal solution costs  thus  normalized solution cost     refers solution cost
two half times larger minimal solution cost  vary relative error bound  which
worst acceptable normalized solution cost           relative error bound p
bnb adoptrem w bnb adoptw hm   pre calculate minimal solution costs
set correct value b bnb adoptaem   example  minimal solution cost    
relative error bound      p       bnb adoptrem   w       bnb adoptw hm
b                     bnb adoptaem  
figure    a c  shows experimental results graph coloring problems  figure    a  shows
normalized solution costs three suboptimal variants increase relative error
bound increases  however  solution costs remain much smaller error bound 
example  normalized solution costs three suboptimal variants less      rather
   relative error bound    normalized solution costs bnb adoptaem
usually larger normalized solution costs bnb adoptrem relative error
r
r
bound  reason behavior bnb adoptaem terminates u bx
 
r lim
r
r
r
r
b   lbx r    p    x r   lbx r   x r minimal solution cost  thus  solution cost
r
r
r
bnb adoptaem u bx
r lbx r  p    x r larger minimal solution
r
r
r
cost  hand  bnb adoptrem terminates u bx
r lim   p lbx r   thus 
r
r
r
solution cost bnb adoptrem u bx r lbx r  p    lbx r larger
minimal solution cost  absolute error bound bnb adoptaem thus smaller
r
r
absolute error bound bnb adoptrem since x
r lbx r initially strictly greater
r
r
absolute error bound bnb adoptrem since x r   lbx
r search 

   

fiyeoh  felner   koenig

graph coloring
solution cost bnb adopt variants

graph coloring
computation time bnb adopt variants
    
normalized runtimes
 cycles 

normalized costs

    
    
    
    
    

weighted heuristics  whm 
absolute error  aem 
relative error  rem 

    
    
    
    

    

    
    
    
relative error bound

    

    

    
    
    
    

    

weighted heuristics  whm 
absolute error  aem 
relative error  rem 

    

    

    
    
    
relative error bound

 a 
graph coloring
performance bnb adopt variants

sensor network
performance bnb adopt variants
    

    

normalized runtimes
 cycles 

normalized runtimes
 cycles 

    

 b 

    
weighted heuristics  whm 
absolute error  aem 
relative error  rem 

    
    
    
    
    

    

    

    
    
    
normalized costs

    

    

    

weighted heuristics  whm 
absolute error  aem 
relative error  rem 

    
    
    
    
    

    

    

 c 

    
    
    
normalized costs

    

    

 d 
meeting scheduling
performance bnb adopt variants
normalized runtimes
 cycles 

    
    

weighted heuristics  whm 
absolute error  aem 
relative error  rem 

    
    
    
    
    

    

    
    
normalized costs

    

    

 e 

figure     experimental results comparing suboptimal variants bnb adopt
figure    b  shows normalized runtimes three suboptimal variants decrease
relative error bound increases  decrease almost   relative error bound     
therefore  three suboptimal variants terminate almost immediately nding rst solution 
normalized runtimes bnb adoptaem usually smaller normalized runtimes
bnb adoptrem relative error bound since bnb adoptaem terminate
suboptimal solution cost within absolute error bound yet within absolute error
bound bnb adoptrem absolute error bound bnb adoptaem strictly greater
absolute error bound bnb adoptrem   words  bnb adoptaem terminate
r
r
r
suboptimal solution cost  p    lbx
r   u bx r  p    x r bnb adoptrem
not 
figure    c  shows normalized runtimes needed achieve given normalized solution cost 
bnb adoptw hm terminates faster bnb adoptaem   turn terminates faster
bnb adoptrem   example  normalized runtime needed achieve normalized solu 

   

fibnb adopt  asynchronous branch and bound dcop algorithm

tion cost           bnb adoptw hm        bnb adoptaem      bnbadoptrem   thus  bnb adoptw hm suboptimal variant bnb adopt best
performance  figures    d e  show trend sensor network meeting scheduling problems 

   conclusions
article  introduced branch and bound adopt  bnb adopt   memory bounded
dcop search algorithm  bnb adopt uses message passing communication framework
adopt changes search strategy adopt best rst search depth rst branchand bound search make adopt faster taking advantage fact dcop problems
depth bounded search trees  properties bnb adopt similar adopt 
bnb adopt allows agents operate concurrently  in order decrease runtime  asynchronously  in order increase robustness   bnb adopt restricts communication agents
share constraints  in order restrictions applications sensor networks   finally 
bnb adopt orders agents pseudo tree  in order take advantage independent dcop
subproblems   experimental results showed bnb adopt nds cost minimal solutions
one order magnitude faster adopt variety large dcop problems fast
ncbb dcop problems  reason behavior following  agents
ncbb operate sequentially thus often idle  adopt construct fewer partial solutions
bnb adopt reconstruct partial solutions purged memory 
advantage adopt respect number constructed partial solutions decreases
disadvantage respect number reconstructed partial solutions increases heuristic
values become poorly informed  thus  bnb adopt great potential dcop search
algorithm since heuristic values often poorly informed complex dcop problems
dcop problems large numbers agents  large domains  large numbers constraints large
ranges constraint costs 
investigated three approximation mechanisms trade solution cost bnbadopt smaller runtime  namely absolute error mechanism adopt  resulting
bnb adoptaem    new relative error mechanism  resulting bnb adoptrem  
new weighted heuristics mechanism  resulting bnb adoptw hm    two new approximation mechanisms allow users specify relative error bound  often meaningful
absolute error bound  weighted heuristics mechanism dominated absolute error mechanism relative error mechanism experiments apply
dcop search algorithms well since benet using heuristic values focus
searches  yeoh  koenig    sun      b  
future  plan improve bnb adopt following ways  first  would
reduce number sent messages handle lost messages  second  would study
dierent pseudo tree arrangements  atlas   decker        sultanik  lass    regli       
pre processing techniques  matsui et al         aect eciency bnb adopt  finally 
would compare bnb adopt approximation mechanisms dcop algorithms 
including optapo  dpop variants  petcu   faltings      a        

acknowledgments
article extension two earlier publications  yeoh  felner    koenig      a  yeoh et al  
    b  contains additional expositions  examples proofs  thank anton chechetka
providing us implementation ncbb anonymous reviewers helpful
comments  research done ariel felner spent sabbatical university
southern california  visiting sven koenig  research partly supported u s  army

   

fiyeoh  felner   koenig

research laboratory  arl  u s  army research oce  aro  award sven koenig
grant w   nf            oce naval research  onr  award sven koenig grant
n                 national science foundation  nsf  award sven koenig grant
        israeli science foundation  isf  award ariel felner grants       
        views conclusions contained document authors
interpreted representing ocial policies  either expressed implied  sponsoring
organizations  agencies  companies u s  government 

references
ali  s   koenig  s     tambe  m          preprocessing techniques accelerating dcop
algorithm adopt  proceedings international joint conference autonomous
agents multiagent systems  aamas   pp           
atlas  j     decker  k          complete distributed constraint optimization method nontraditional pseudotree arrangements  proceedings international joint conference
autonomous agents multiagent systems  aamas   pp         
bayardo  r     miranker  d          space time trade o solving constraint satisfaction problems  proceedings international joint conference articial intelligence
 ijcai   pp         
bistarelli  s   montanari  u   rossi  f   schiex  t   verfaillie  g     fargier  h          semiring based
csps valued csps  basic properties comparison  constraints                
bowring  e   pearce  j   portway  c   jain  m     tambe  m          k optimal distributed
constraint optimization algorithms  new bounds algorithms  proceedings international joint conference autonomous agents multiagent systems  aamas   pp 
       
bowring  e   tambe  m     yokoo  m          multiply constrained distributed constraint optimization  proceedings international joint conference autonomous agents
multiagent systems  aamas   pp           
burke  d     brown  k          eciently handling complex local problems distributed constraint
optimisation  proceedings european conference articial intelligence  ecai   pp 
       
chechetka  a     sycara  k          no commitment branch bound search distributed
constraint optimization  proceedings international conference autonomous agents
multiagent systems  aamas   pp           
choxi  h     modi  p          distributed constraint optimization approach wireless network
optimization  proceedings aaai    workshop conguration  pp     
davin  j     modi  p          hierarchical variable ordering multiagent agreement problems 
proceedings international joint conference autonomous agents multiagent
systems  aamas   pp           
dechter  r   ed            constraint processing  morgan kaufmann 
fitzpatrick  s     meertens  l          distributed coordination anarchic optimization 
lesser  v   ortiz  c     tambe  m   eds    distributed sensor networks  multiagent
perspective  pp          kluwer 
freuder  e     quinn  m          taking advantage stable sets variables constraint satisfaction problems  proceedings international joint conference articial intelligence
 ijcai   pp           

   

fibnb adopt  asynchronous branch and bound dcop algorithm

gershman  a   meisels  a     zivan  r          asynchronous forward bounding distributed
cops  journal articial intelligence research           
greenstadt  r          overview privacy improvements k optimal dcop algorithms  extended abstract   proceedings international joint conference autonomous agents
multiagent systems  aamas   pp           
greenstadt  r   grosz  b     smith  m          ssdpop  improving privacy dcop
secret sharing  proceedings international joint conference autonomous agents
multiagent systems  aamas   pp           
hamadi  y   bessiere  c     quinqueton  j          distributed intelligent backtracking  proceedings european conference articial intelligence  ecai   pp         
hirayama  k     yokoo  m          distributed partial constraint satisfaction problem  proceedings international conference principles practice constraint programming
 cp   pp         
jain  m   taylor  m   tambe  m     yokoo  m          dcops meet real world  exploring
unknown reward matrices applications mobile sensor networks  proceedings
international joint conference articial intelligence  ijcai   pp         
junges  r     bazzan  a          evaluating performance dcop algorithms real world 
dynamic problem  proceedings international joint conference autonomous agents
multiagent systems  aamas   pp         
korf  r          linear space best rst search  articial intelligence               
kumar  a   faltings  b     petcu  a          distributed constraint optimization structured
resource constraints  proceedings international joint conference autonomous
agents multiagent systems  aamas   pp         
lesser  v   ortiz  c     tambe  m   eds            distributed sensor networks  multiagent
perspective  kluwer 
maheswaran  r   pearce  j     tambe  m       a   distributed algorithms dcop  graphical game based approach  proceedings international conference parallel
distributed computing systems  pdcs   pp         
maheswaran  r   tambe  m   bowring  e   pearce  j     varakantham  p       b   taking dcop
real world  ecient complete solutions distributed event scheduling  proceedings
international joint conference autonomous agents multiagent systems  aamas  
pp         
mailler  r     lesser  v          solving distributed constraint optimization problems using cooperative mediation  proceedings international joint conference autonomous agents
multiagent systems  aamas   pp         
marinescu  r     dechter  r          best rst and or search graphical models  proceedings
aaai conference articial intelligence  aaai   pp           
marinescu  r     dechter  r          and or branch and bound search combinatorial optimization graphical models  articial intelligence                        
matsui  t   silaghi  m   hirayama  k   yokoo  m     matsuo  h          directed soft arc consistency
pseudo trees  proceedings international joint conference autonomous agents
multiagent systems  aamas   pp           
meisels  a   kaplansky  e   razgon  i     zivan  r          comparing performance distributed
constraints processing algorithms  proceedings distributed constraint reasoning
workshop  pp       

   

fiyeoh  felner   koenig

modi  p     ali  s          distributed constraint reasoning unreliable communication 
zhang  w     sorge  v   eds    frontiers articial intelligence applications  vol      
pp          ios press 
modi  p   shen  w  m   tambe  m     yokoo  m          adopt  asynchronous distributed constraint optimization quality guarantees  articial intelligence                    
ottens  b     faltings  b          coordinating agent plans distributed constraint optimization  proceedings icaps    workshop multiagent planning 
pearce  j     tambe  m          quality guarantees k optimal solutions distributed constraint
optimization problems  proceedings international joint conference articial
intelligence  ijcai   pp           
pecora  f   modi  p     scerri  p          reasoning dynamically posting n ary constraints
adopt  proceedings distributed constraint reasoning workshop  pp       
petcu  a     faltings  b       a   approximations distributed optimization  proceedings
international conference principles practice constraint programming  cp   pp 
       
petcu  a     faltings  b       b   scalable method multiagent constraint optimization 
proceedings international joint conference articial intelligence  ijcai   pp      
     
petcu  a     faltings  b          odpop  algorithm open distributed constraint optimization  proceedings national conference articial intelligence  aaai   pp         
pohl  i          first results eect error heuristic search  machine intelligence    
       
pohl  i          avoidance  relative  catastrophe  heuristic competence  genuine dynamic
weighting computational issues heuristic problem solving  proceedings international joint conference articial intelligence  ijcai   pp       
schiex  t   fargier  h     verfaillie  g          valued constraint satisfaction problems  hard
easy problems  proceedings international joint conference articial intelligence
 ijcai   pp         
schurr  n   okamoto  s   maheswaran  r   scerri  p     tambe  m          evolution teamwork
model  sun  r   ed    cognition multi agent interaction  cognitive modeling
social simulation  pp          cambridge university press 
silaghi  m   landwehr  j     larrosa  j          asynchronous branch   bound a  diswcsps
heuristic function based consistency maintenance  zhang  w     sorge  v   eds   
frontiers articial intelligence applications  vol       pp        ios press 
silaghi  m   lass  r   sultanik  e   regli  w   matsui  t     yokoo  m          operation point
units distributed constraint solvers  proceedings distributed constraint reasoning
workshop  pp      
silaghi  m     yokoo  m          adopt ing  unifying asynchronous distributed optimization
asynchronous backtracking  autonomous agents multi agent systems                
stranders  r   farinelli  a   rogers  a     jennings  n          decentralised coordination mobile
sensors using max sum algorithm  proceedings international joint conference
articial intelligence  ijcai   pp         
sultanik  e   lass  r     regli  w          dynamic conguration agent organizations 
proceedings international joint conference articial intelligence  ijcai   pp     
    

   

fibnb adopt  asynchronous branch and bound dcop algorithm

yeoh  w   felner  a     koenig  s       a   bnb adopt  asynchronous branch and bound
dcop algorithm  proceedings international joint conference autonomous agents
multiagent systems  aamas   pp         
yeoh  w   koenig  s     sun  x       b   trading solution cost smaller runtime dcop
search algorithms  short paper   proceedings international joint conference
autonomous agents multiagent systems  aamas   pp           
yeoh  w   varakantham  p     koenig  s          caching schemes dcop search algorithms 
proceedings international joint conference autonomous agents multiagent
systems  aamas   pp         
yokoo  m     hirayama  k          distributed breakout algorithm solving distributed constraint
satisfaction problems  proceedings international conference multiagent systems
 icmas   pp         
zhang  w     korf  r          performance linear space search algorithms  articial intelligence 
               
zhang  w   xing  z   wang  g     wittenburg  l          analysis application distributed
constraint satisfaction optimization algorithms sensor networks  proceedings
international joint conference autonomous agents multiagent systems  aamas  
pp         
zivan  r          anytime local search distributed constraint optimization  proceedings
aaai conference articial intelligence  aaai   pp         
zivan  r   glinton  r     sycara  k          distributed constraint optimization large teams
mobile sensing agents  proceedings international conference intelligent agent
technology  iat   pp         

   


