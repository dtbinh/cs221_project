journal of articial intelligence research                 

submitted        published      

bnb adopt 
an asynchronous branch and bound dcop algorithm
william yeoh

wyeoh usc edu

computer science department 
university of southern california 
los angeles  ca        usa

ariel felner

felner bgu ac il

information systems engineering 
deutsche telekom labs 
ben gurion university of the negev 
beer sheva         israel

sven koenig

skoenig usc edu

computer science department 
university of southern california 
los angeles  ca        usa

abstract
distributed constraint optimization  dcop  problems are a popular way of formulating and
solving agent coordination problems  a dcop problem is a problem where several agents coordinate their values such that the sum of the resulting constraint costs is minimal  it is often
desirable to solve dcop problems with memory bounded and asynchronous algorithms  we introduce branch and bound adopt  bnb adopt   a memory bounded asynchronous dcop search
algorithm that uses the message passing and communication framework of adopt  modi  shen 
tambe    yokoo         a well known memory bounded asynchronous dcop search algorithm 
but changes the search strategy of adopt from best first search to depth first branch and bound
search  our experimental results show that bnb adopt finds cost minimal solutions up to one
order of magnitude faster than adopt for a variety of large dcop problems and is as fast
as ncbb  a memory bounded synchronous dcop search algorithm  for most of these dcop
problems  additionally  it is often desirable to find bounded error solutions for dcop problems
within a reasonable amount of time since finding cost minimal solutions is np hard  the existing bounded error approximation mechanism allows users only to specify an absolute error bound
on the solution cost but a relative error bound is often more intuitive  thus  we present two
new bounded error approximation mechanisms that allow for relative error bounds and implement
them on top of bnb adopt 

   introduction
a distributed constraint optimization  dcop  problem consists of agents  each responsible for taking
on    assigning itself  a value from its nite domain of values  the agents coordinate their values 
which are subject to constraints  two agents are constrained if they share a constraint  each
constraint has an associated constraint cost  which depends on the values of the constrained agents 
a  complete  solution is an assignment of values to all agents  and a partial solution is an assignment
of values to a subset of agents  the solution cost of a  partial or complete  solution is the sum of the
constraint costs of all constraints resulting from the given assignment of values to agents  solving a
dcop problem optimally means nding a solution with minimal solution cost and is np hard  modi
et al         
formulating agent coordination problems as constraint optimization  cop  problems  a specic
type of weighted constraint satisfaction problems  schiex  fargier    verfaillie        bistarelli 

c
    
ai access foundation  all rights reserved 

fiyeoh  felner   koenig

a 

a 
a 

a 
a 

a 
a 

 a 

a 

a 
 
 
 
 
a 
 
 
 
 

a 
 
 
 
 
a 
 
 
 
 

constraint cost
 
 
  
 
constraint cost
 
 
 
 

 b 

a 
 
 
 
 
a 
 
 
 
 

a 
 
 
 
 
a 
 
 
 
 

constraint cost
 
  
  
 
constraint cost
 
 
  
 

 c 

figure    example dcop problem
montanari  rossi  schiex  verfaillie    fargier         is more general than formulating them as the
more common constraint satisfaction problems  dechter         constraint satisfaction problems
have constraints that are either satised or unsatised  solving a constraint satisfaction problem
means nding a solution such that all constraints are satised  an example application is the
scheduling of jobs in a job shop  where constraints express that some jobs can only be performed
by certain machines and some jobs can only be performed after some other jobs  there could
potentially be multiple solutions that satisfy all constraints  however  some solutions might be more
desirable than others  for example  one might prefer the solution with the shortest completion time 
unfortunately  constraint satisfaction problems cannot capture these preferences  however  cop
problems are able to do so by using the constraint costs to represent the preferences 
dcop algorithms are better suited compared to cop algorithms for problems that are naturally distributed  as a result  dcop algorithms have been applied to coordinating unmanned
aerial vehicles  schurr  okamoto  maheswaran  scerri    tambe         scheduling meetings  maheswaran  tambe  bowring  pearce    varakantham      b  petcu   faltings      b  greenstadt 
grosz    smith        zivan        yeoh  varakantham    koenig         coordinating sensor networks  lesser  ortiz    tambe        zhang  xing  wang    wittenburg        modi et al        
jain  taylor  tambe    yokoo        stranders  farinelli  rogers    jennings        zivan  glinton 
  sycara         synchronizing trac lights  junges   bazzan         planning truck routes  ottens
  faltings        and managing power distribution networks  kumar  faltings    petcu        
it is common to visualize a dcop problem as a constraint graph where the vertices are the
agents and the edges are the constraints  most dcop algorithms operate on a pseudo tree  which
is a spanning tree of the  completely connected  constraint graph with the property that edges
in the constraint graph connect a vertex with one of its ancestor or descendant vertices in the
constraint tree  freuder   quinn        bayardo   miranker         an edge of the constraint
graph that is not part of the pseudo tree is a backedge  an agent c is a pseudo child agent of
agent p if agent c is a descendant agent of agent p in the pseudo tree and they are constrained
via a backedge  similarly  agent p is the pseudo parent agent of agent c  sibling subtrees represent
independent dcop subproblems  since no two agents in dierent sibling subtrees share a constraint  
figure   a  shows the constraint graph of an example dcop problem with four agents that can
each take on value   or value    figure   b  shows one possible pseudo tree where the assignments of
values to agents a  and a  are independent dcop subproblems  the dotted line is a backedge   and
figure   c  shows the constraint costs  for our example dcop problem  a cost minimal solution
results if all agents take on value    the minimal solution cost is    
    dcop algorithms
we now provide a taxonomy of dcop algorithms  figure   shows the taxonomy  dcop algorithms
are divided into two groups  complete and incomplete dcop algorithms  complete dcop algorithms nd cost minimal solutions while incomplete dcop algorithms are often faster but typically
nd suboptimal solutions 
  

fibnb adopt  an asynchronous branch and bound dcop algorithm

dcop algorithms

incomplete algorithms
e g   dba  dsa  mgm 
k optimal algorithms

complete algorithms

partially centralized algorithms
e g   optapo

fully decentralized
algorithms

search algorithms
e g   sbb  adopt 
ncbb  afb

inference algorithms
e g   dpop

figure    taxonomy of dcop algorithms
      incomplete dcop algorithms
incomplete dcop algorithms typically use local search to nd locally optimal solutions and can
thus potentially get trapped in local minima  nevertheless  since solving dcop problems optimally
is np hard  such dcop algorithms are desirable for large dcop problems where nding costminimal solutions might be slow  dba  yokoo   hirayama         dsa  fitzpatrick   meertens 
       mgm  maheswaran  pearce    tambe      a  and the more recent class of k optimal dcop
algorithms  pearce   tambe        bowring  pearce  portway  jain    tambe        greenstadt 
      are examples of incomplete dcop algorithms 
      complete dcop algorithms
complete dcop algorithms are generally divided into two groups  namely partially centralized and
fully decentralized dcop algorithms 
partially centralized dcop algorithms
partially centralized dcop algorithms allow some agents to transfer their constraint information
   information regarding the constraints that they are involved in  to a central agent for processing  optapo  mailler   lesser        is an example of a partially centralized dcop algorithm
that uses cooperative mediation  where certain agents act as mediators to solve overlapping dcop
subproblems centrally 
fully decentralized dcop algorithms
fully decentralized dcop algorithms do not have central agents that collect constraint information of other agents that are not constrained with them  rather  every agent has access to only
its own constraint information  fully decentralized dcop algorithms are generally divided into two
groups  namely dcop inference and search algorithms 
 dcop inference algorithms  dcop inference algorithms typically use dynamic programming to propagate aggregated constraint costs from one agent to another agent and thus reduce
  

fiyeoh  felner   koenig

dcop
algorithm
sbb
adopt
ncbb
afb
bnb adopt

search
strategy
dfbnb
best first
dfbnb
dfbnb
dfbnb

agent
operation
sequential   synchronous
concurrent   asynchronous
sequential   synchronous
concurrent   asynchronous
concurrent   asynchronous

communication
point to point with neighbors
point to point with neighbors
point to point with neighbors
broadcast to all agents
point to point with neighbors

agent
ordering
chain
tree
tree
chain
tree

table    properties of dcop search algorithms

the dcop problem size by one agent at each step  they repeat this procedure until the dcop
problem size is reduced to only one agent and the solution space    space of all possible partial solutions  thus cannot be reduced anymore  the sole remaining agent has then sucient
knowledge to nd a cost minimal solution  dpop  petcu   faltings      b  is an example
of a dcop inference algorithm  the number of messages sent between agents is only linear
in the number of agents  however  its memory requirements are exponential in the induced
width of the dcop problem  the induced width depends on the number of backedges in the
pseudo tree  it can be as large as the number of agents minus one if the constraint graph is
fully connected and every agent is thus constrained with every other agent 
 dcop search algorithms  dcop search algorithms use search strategies to search through
the solution space to nd a cost minimal solution  adopt  modi et al         uses best rst
search  and sbb  hirayama   yokoo         ncbb  chechetka   sycara         afb  gershman  meisels    zivan        and our new dcop search algorithm  bnb adopt  use
depth rst branch and bound search  their memory requirements are only polynomial in the
number of agents  however  the number of messages sent between agents can be exponential
in the number of agents 
therefore  both groups of fully decentralized dcop algorithms are desirable under dierent
conditions as there is a tradeo between space  memory requirements  and time  number of messages
sent  
    motivation
we now describe the motivation behind our work 
      bnb adopt
we study dcop search algorithms because they can be memory bounded  this property is important for applications  such as sensor networks  where every agent sensor has only a xed amount of
memory available  as a result  several dcop search algorithms  such as sbb  adopt  ncbb and
afb  were developed with this limitation in mind  as described earlier  their memory requirements
are polynomial in the number of agents  table   shows the properties of these dcop search algorithms as well as the properties of our new dcop search algorithm  bnb adopt  we now describe
each property in more detail and justify the properties of bnb adopt 
 search strategy  adopt uses best rst search to search the solution space  while sbb 
ncbb and afb use depth rst branch and bound  dfbnb  search  best rst search repeatedly searches for the next best partial solution until it nds a cost minimal solution  the next
best partial solution is the cost minimal partial solution among all partial solutions that have
not yet been found  depth rst branch and bound search starts by nding a complete  but

  

fibnb adopt  an asynchronous branch and bound dcop algorithm

often suboptimal  solution and stores its solution cost as the upper bound  it then continues
to search for a solution whose solution cost is less than the upper bound  it stores the solution
cost of this solution as the upper bound  and the search proceeds until it can no longer nd a
solution whose solution cost is less than the upper bound 
for centralized search  it is known that search problems with depth bounded search trees can
often be solved faster with depth rst branch and bound search than with memory bounded
best rst search because memory bounded best rst search algorithms  such as rbfs  korf 
       need to repeatedly reconstruct partial solutions that they purged from memory  depthrst branch and bound search algorithms are memory bounded but do not suer from this
problem  zhang   korf         since dcop problems are search problems with depthbounded search trees  we hypothesize that depth rst branch and bound search might be faster
than best rst search  therefore  we decided that bnb adopt should use depth rst branchand bound search 
 agent operation  agents of sbb and ncbb operate sequentially  only agents with tokens
are active while the other agents remain idle  once the token holding agents are done  they pass
their tokens on and then remain idle  on the other hand  agents of adopt and afb operate
concurrently    at all times   agents that operate concurrently might be able to solve dcop
problems faster than agents that operate sequentially since the former agents can perform
potentially useful computation instead of having to wait for other agents  therefore  we
decided that all agents of bnb adopt should operate concurrently  agents of sbb and ncbb
also operate synchronously  communication between agents is often in form of messages 
synchronous agents operate in cycles  modi et al          a cycle is the time required for an
agent to process all incoming messages in its queue and send all outgoing messages  which
are then processed by the receiving agents in the next cycle  see section     for more details  
therefore  all agents wait until the last agent is done sending its messages before they start
a new cycle  on the other hand  asynchronous agents  such as agents of adopt and afb 
are able to operate independently of each other  which often increases robustness  silaghi 
landwehr    larrosa         for example  all synchronous agents are aected if a single
communication link suers from congestion while only a small number of asynchronous agents
are aected  we therefore decided that agents of bnb adopt should operate asynchronously 
 communication 
dcop search algorithms such as sbb  adopt and ncbb restrict
communication to agents that share constraints  this restriction is motivated by applications
such as sensor networks where communication is restricted to neighboring agents sensors due
to their limited communication radius  neighboring sensors share constraints since they need
to coordinate to sense the areas near them  dcop search algorithms such as afb do not have
this restriction and allow agents to broadcast messages to all other agents  we decided that
agents of bnb adopt should obey the restrictions of applications such as sensor networks
and thus communicate only with neighboring agents 
 agent ordering  all dcop search algorithms mentioned above start with a pre processing
step that arranges the agents into a pseudo tree  dcop search algorithms such as sbb and
afb arrange the agents into a chain  while adopt and ncbb arrange the agents into a tree 
a tree ordering can capture independent dcop subproblems  represented as sibling subtrees 
while a chain ordering can not  dcop search algorithms that operate on trees can thus
operate on independent dcop subproblems independently  while dcop search algorithms
that operate on chains can not  therefore  we decided that bnb adopt should arrange
agents into a tree 
adopt has all preferred properties mentioned above except that it uses best rst search  we
therefore introduce bnb adopt  a memory bounded asynchronous dcop search algorithm that
  

fiyeoh  felner   koenig

uses the message passing and communication framework of adopt but changes the search strategy
of adopt from best rst search to depth rst branch and bound search 
      bounded error approximations
solving dcop problems optimally is np hard  which makes it advantageous to allow users to trade
o solution cost for a smaller runtime  it is also desirable to have the error of the resulting solution
cost be bounded to provide guarantees on the solution cost  adopt is  to the best of our knowledge 
the only dcop search algorithm with this property  its absolute error mechanism allows its users
to specify an absolute error bound on the solution cost  for example  that the solution cost should
be at most    larger than the minimal solution cost  however  it is often much more desirable to
specify a relative error bound on the solution cost  for example  that the solution cost should be
at most    percent larger than the minimal solution cost or  equivalently      times larger than the
minimal solution cost  this cannot be done with the absolute error mechanism without knowing
the minimal solution cost a priori  thus  we propose two approximation mechanisms that allow users
to specify a relative error bound on the solution cost  namely the relative error mechanism and the
weighted heuristics mechanism  and implement them on top of bnb adopt  these approximation
mechanisms allow bnb adopt to nd solutions with bounded errors faster than cost minimal
solutions 
    experimental results
we experimentally compare adopt  bnb adopt and ncbb on three dierent dcop problem
types  namely graph coloring problems  sensor network problems and meeting scheduling problems 
our results show that bnb adopt is up to one order of magnitude faster  measured in the number
of non concurrent constraint checks and the number of cycles  than adopt on a variety of large
dcop problems  bnb adopt can also be inferred to be faster than sbb since adopt is faster
than sbb  modi et al          bnb adopt is also as fast as ncbb on most of these dcop
problems  our results for the suboptimal variants of bnb adopt show that the weighted heuristics
mechanism dominates both the absolute error mechanism and relative error mechanism 
    article structure
this article is organized as follows  we formalize dcop problems in section   and describe our
dcop search algorithm  bnb adopt  in section    we describe approximation mechanisms that
allow bnb adopt to nd solutions with bounded error in section    we outline correctness and
completeness proofs of bnb adopt in section    lastly  we present our experimental evaluations
in section   and our conclusions in section   

   dcop problems
in this section  we formally dene distributed constraint optimization  dcop  problems and describe
their solution space 
    definition of dcop problems
a dcop problem is dened by the following elements 
 a nite set of agents a    a    a         an   
 a set of nite domains d    dom a     dom a          dom an     where dom ai   is the domain
of possible oating point values of agent ai  a  and

  

fibnb adopt  an asynchronous branch and bound dcop algorithm

a 

or

a

or

and

 

 

and

a

b

or

a 

a 

or

b

c

 

and

or

and

 

a 
     

a 
 

  

a 
 

 

  

a 

a 
  

 

 

  

a 
 

 

a 
 

  

a 
 

c

and

  

d

or

 

and

d

g

e
h

i

e

f
j

k

 a 

g
l

m

f

h
n

o

i
p

q

j
r

s

k
t

u

v

 b 

figure    and or search tree
 a set of binary constraints f    f    f         fm    where each constraint fi   dom ai    
dom ai     r     species its non negative constraint cost as a function of the values
of the distinct agents ai  and ai  that share the constraint 
the above denition assumes that each agent takes on one value rather than multiple values 
for example  a dierent value for each constraint that it is involved in  these dcop problems
are more commonly formulated as each agent being responsible for the assignments of values to
multiple variables  however  there exist techniques that reduce such dcop problems to our dcop
problems  burke   brown         thus  we use the terms agent and variable interchangeably  the
above denition also assumes that constraints are binary    between two agents  rather than n ary
   between n agents   one should be able to extend bnb adopt to solve dcop problems with nary constraints by using the same techniques that were proposed to extend adopt to solve dcop
problems with n ary constraints  modi et al          additionally  we assume that the messages sent
between agents can be delayed by a nite amount of time but are never lost 
    search trees
the solution space of dcop problems can be visualized with search trees  traditional search trees
or  synonymously  or search trees  marinescu   dechter        assign values to agents sequentially 
they do not utilize the fact that the values of agents that belong to independent dcop subproblems
do not have to be assigned sequentially  and or search trees are based on pseudo trees and remedy
this issue  marinescu   dechter         thus  we use and or search trees and refer to them as
search trees in this article  their depth is bounded by  twice  the number of agents 
figure   a  shows the search tree that is based on the pseudo tree in figure   b   figure   b 
labels each node of the search tree with an identier to allow us to refer to the nodes easily  circular
nodes are or nodes  labeled with upper case letters  and correspond to agents  for example  the
agent of node c is agent a    left branches of or nodes correspond to the agents taking on value
  and right branches correspond to the agents taking on value    square nodes are and nodes
 labeled with lower case letters  and correspond to the partial solutions from the root node to those
nodes  for example  the partial solution of node f is   a         a         the subtree rooted at an
and node represents the dcop subproblem that assumes the partial solution of the and node 
for example  the subtree rooted at node f represents the dcop subproblem of assigning values
to agents a  and a  given that   a         a         the number of independent dcop subproblems
within this dcop subproblem is indicated by the number of branches exiting the and node  for
example  there are two branches exiting node f   indicating that there are two independent dcop
subproblems  namely of assigning values to agents a  and a    the numbers in the and nodes
are the delta costs of the nodes  the delta cost of an and node is dened to be the sum of the
constraint costs of all constraints in its partial solution that involve the agent of its parent or node 

  

fiyeoh  felner   koenig

for example  the partial solution of node v is   a         a         a         there are two constraints in
this partial solution  namely the constraint between agents a  and a    which has constraint cost   
and the constraint between agents a  and a    which also has constraint cost    since the parent
node of node v is node k with agent a    the delta cost of node v is    namely the constraint cost of
the latter constraint  the former constraint is not included since it does not involve agent a    the
solution cost of a partial solution of an and node is the sum of the delta costs of all and nodes
along the branch from the root node to that node  for example  the solution cost of the partial
solution of node v       is the sum of the delta costs of nodes b  f and v  in our example dcop
problem  a cost minimal solution is the union of the partial solutions of nodes t and v  all agents
take on value     thus  the minimal solution cost        is the sum of the delta costs of nodes b  f  
t and v 

   bnb adopt
in this section  we present branch and bound adopt  bnb adopt   we do not describe bnbadopt as a modication of adopt since this approach requires the readers to have an in depth
understanding of adopt  instead  we give a stand alone description of bnb adopt that requires
no knowledge of adopt  with the intention of creating a self contained and hopefully easy to read
description 
    search strategies of adopt and bnb adopt
we rst describe centralized versions of the search strategies of adopt and bnb adopt and omit
technical details since these are described in more detail in later sections 
      search strategy of adopt
adopt  modi et al         is a popular dcop search algorithm  modi   ali        ali  koenig 
  tambe        bowring  tambe    yokoo        davin   modi        pecora  modi    scerri 
      choxi   modi        silaghi   yokoo        matsui  silaghi  hirayama  yokoo    matsuo 
      that traverses the search tree in a best rst search order  we now describe a simplied version
of best rst search  the complete version can be found in  marinescu   dechter         bestrst search maintains a list that initially contains only the child and nodes of the root node  it
repeatedly performs the following operations  it expands the and node with the smallest solution
cost in the list by removing that node from the list and adding the grandchild and nodes of that
node into the list  for our example dcop problem  best rst search expands the and nodes in the
search tree in figure   for the rst time in the following order  where the numbers in parentheses
indicate the solution costs of the partial solutions of the expanded nodes  a      b      f      c     
v      i      d     and t     
figure   shows a simplied trace of adopt on our example dcop problem  adopt terminates
after fteen steps with minimal solution cost     the numbers in the and nodes are the delta costs
r
of the nodes  the lower bound lbx
r is an optimistic estimate of the minimal solution cost  it is
the smallest underestimated solution cost  over all solutions  the underestimated solution cost of
a solution is the sum of the delta costs of all and nodes of that solution whose parent or node
is the root node or whose grandparent and node is expanded  for example  the underestimated
solution cost of the solution   a         a         a         a        is   if node b is expanded and nodes f   t
r
and v are not expanded  the upper bound u bx
r is a pessimistic estimate of the minimal solution
cost  it is the solution cost of the solution with the smallest solution cost found so far  adopt
r
r
terminates when the upper bound u bx
r is no larger than the lower bound lbx r   in order to be
memory bounded  adopt maintains only one branch of the search tree  shaded grey in the gure 
from the root node to the currently expanded node and thus needs to repeatedly reconstruct nodes

  

fibnb adopt  an asynchronous branch and bound dcop algorithm

lbrxr    

a

or

and

a

b

and

or

b

c

or

c

and

and

d

d

or

g

e
h

i

e

f
j

k

g
l

m

f

h
n

o

i
p

q

r

s

k
t

u

or

v

and

 

 

a 

a 

 

and

j

a 

 
a 

       

a 
 

a 

or

and

or

              

and

a 

 
a 
 

       

  
  infinity

 

a 

a 
 

or

 
a 

              

 

a 

or

and

  
a 

a 

a 

           

and

a 

 

 
a 
 

a 

       

a 

or

and

a 

 

 
a 

       

a 
 

 

 

a 

a 

and

or

           

or

and

a 

and

a 

 
a 
 

       

  
  infinity

 

a 

a 

 

 

       

 

 

and

or

 

a 

and

a 
       

 

    
  infinity

 

 
a 

a 

or

and

a 

 

              

       

 

or

and

a 

 
a 
 

       

a 
 

or

a 

              

 
a 

 

a 

           

or

and

a 

 

              

or

and

a 

 

 
a 
 

a 

       

a 
 

       

 

a 

and

or

 

a 

              

and

a 

 
a 

       

 

  
a 

a 

              

or

and

 

 
a 

a 
       

 
a 

a 
 

  
a 

a 

              

 
a 

 

a 

 
a 

 

a 

a 

           

step   

figure    trace of simplied memory bounded best first search  centralized adopt 

  

a 

           

    
    

 

a 

a 

           

step   

lbrxr
ubrxr

 
a 

 

a 

a 
 

and

a 

           

a 
 

and

or

 
a 

a  ubrxr   infinity

or

step   
or

a 

lbrxr     

 
a 

              

step   

  
a 

or

and

  
a 

a 

a 

           

a 
 

and

a 

    
  infinity
 

 

 

a 

step   

lbrxr
ubrxr

a 

a 

 
a 

a  ubrxr   infinity

or

           

 

a 

a 

lbrxr    

a 

a 
 

and

a 

  
a 

or

 
a 

              

a 

a 

           

 

a 

and

  

or

 

a 

a 
 

and

a 

  
  infinity

a 

a 

 
a 

step  

lbrxr
ubrxr

 

a 

a 

a  ubrxr   infinity

or

           

a 

a 

and

  
a 

 

  
a 

step   

lbrxr
ubrxr

 
a 

 

 

 

and

a 

           

a 
 

and

or

       

a 

lbrxr    

a 

a 

step  
a 

 
a 

or

 
a 

              

a 

or

 
a 

              

or

and

a 

and

  
a 

a 

or

and

  
a 

a 

or

 
a 

step  

a 

a 

a 

           

 

 

and

a 

           

 

a 

 

a 

a 

step  

a 
 

and

or

 

a 

a 
 

and

a 

 
a 

a  ubrxr   infinity

or

a  ubrxr   infinity

or

a 

              

or

 
a 

              

step  
lbrxr
ubrxr

  
a 

lbrxr    

 
a 

              

or

 

and

  
a 

a 

or

and

  
a 

a 

       

a 

step  

a 
 

and

or

 
a 

lbrxr    

  
  infinity

a 

lbrxr    

or

and

a 

step  

lbrxr
ubrxr

 

 

and

a 

a  ubrxr   infinity

and

or

 
a 

 

and

a 

           

a 

step  
or

 

a 

 
a 

step  

a 
 

and

or

or

 
a 

a  ubrxr   infinity

or

and

  
a 

a 

identifiers
lbrxr
ubrxr

lbrxr    

a  ubrxr   infinity

or

fiyeoh  felner   koenig

lbrxr    

a

or

and

a

b

and

or

b

c

or

c

and

and

d

d

or

g

e
h

i

e

f
j

k

g
l

m

f

h
n

o

i
p

q

r

s

k
t

u

or

v

and

 

 

a 

a 

 

and

j

a 

 
a 

       

a 
 

a 

or

and

or

and

a 

 
a 
 

       

  
  infinity

 

a 

a 

              

 

and

or

 
a 

              

 

a 

or

  
a 

a 

a 

and

or

a 

and

a 

or

and

a 

 

              

 

       

a 

a 

and

or

 

and

a 

 

a 

           

or

and

a 
       

 

 
a 

       

 

and

a 

 
a 
 

a 

       

a 
 

or

a 

              

 
a 

 

a 

a 

              

or

 

a 

           

or

and

a 

 

       

 

or

and

 

 
a 

a 

 
a 

       

a 
 

  
a 

 

a 

a 

              

 

a 

a 

           

or

 
a 

 

a  ubrxr     

and

  
a 

              

step  

a 

           

lbrxr     

 

a 

 

a 

a 

or

a 

a 

a 

step  

lbrxr     
ubrxr     

 

a 

 

a 

              

 

and

a 

           

a 
 

and

a 

  
a 

a  ubrxr     

and

 

a 

a 

and

  
a 

or

 

or

  

or

a 

           

lbrxr    

  
    
 

a 

 

a 

step  

lbrxr
ubrxr

 

a 

a 
 

and

a 

           

a 

a 

 

a 

              

step  

 

a 

 

 

a 

  
a 

a  ubrxr     

or

a 

a 
 

and

a 

lbrxr    
ubrxr     

 
a 

 

and

 
a 

              

a 

or

 
a 

a 
 

and

or

       

a 

or

  
a 

a 

step  
or

 
a 

lbrxr    

  
  infinity
 

a 

and

  
a 

a 

a 

step  

lbrxr
ubrxr

a 

or

 

 

       

  
    

a 

a 

and

 
a 

step  

lbrxr
ubrxr

 

a 

or

 
a 
 

and

a 

           

 

 

and

a 

           

a 
 

and

or

 

a 

a 

step  
or

or

step  

a 
 

and

or

and

 
a 

a  ubrxr   infinity

or

  
a 

a 

identifiers
lbrxr
ubrxr

lbrxr    

a  ubrxr   infinity

or

a 

           

step   

or

and

 
a 

 

and

a 

 
a 

a 
       

 
a 

a 
 

  
a 

a 

              

 
a 

 

a 

a 

           

step   

lbrxr     

a  ubrxr     

or

and

or

and

 
a 

 

and

or

 
a 

a 
       

 
a 

a 
 

  
a 

a 

              

 
a 

 

a 

a 

           

step   

figure    trace of simplied depth first branch and bound search  centralized bnb adopt 
that it purged from memory  for example  in step    adopt has the branch to node f in memory 
the next node that best rst search expands is node c  and adopt discards the branch to node f
in step    in steps   and    it then needs to reconstruct the discarded branch to node f in order to
expand node v in step   
      search strategy of bnb adopt
we now describe a simplied version of depth rst branch and bound search  the complete version
r
r
can be found in  marinescu   dechter         we use the same denitions of lbx
r and u bx r as
described earlier for figure    depth rst branch and bound search maintains a stack that initially
contains only the child and nodes of the root node  it expands the and node on top of the

  

fibnb adopt  an asynchronous branch and bound dcop algorithm

stack by removing that node from the stack and performing the following check  if the solution
r
cost of that node is no smaller than the upper bound u bx
r   it prunes that node and repeats the
operation  otherwise  it adds the grandchild and nodes of that node to the top of the stack and
r
repeats the operation  it terminates when the upper bound u bx
r is no larger than lower bound
r
lbx r   depth rst branch and bound search can add the grandchild and nodes of an expanded
and node  and the child and nodes of the root node  in decreasing order of their solution costs
instead of a random order to the top of the stack  this ordering ensures that depth rst branchand bound search expands the grandchild and node with the smallest solution cost rst  we use
this improvement throughout the article  for our example dcop problem  depth rst branch andbound search expands the and nodes in the search tree in the following order  where it prunes the
nodes in brackets  a      c      i      j       g        h        d      n       k        m         l       
b      f      v     and t      figure   shows a trace of depth rst branch and bound search for our
example dcop problem  it is memory bounded without having to repeatedly reconstruct nodes
that it purged from memory but expands some nodes that a best rst search does not expand  such
as node j in step    the depth rst branch and bound search terminates after twelve steps with
minimal solution cost     which is three steps fewer than adopt 
    description of bnb adopt
we now provide an incremental description of bnb adopt  first  we provide the notations and key
terms of bnb adopt  then  we describe how bnb adopt updates its bounds  adheres to memory
limitations  performs depth rst search and performs branch and bound  finally  we introduce our
enhanced nal version of bnb adopt and show both its pseudocode and its trace for our example
dcop problem 
      notation and key terms
we adopt the following notation from adopt to describe bnb adopt 
 v alinit a   dom a  is the initial value of agent a  a 
 cd a   a is the set of child and pseudo child agents of agent a  a 
 c a   cd a  is the set of child agents of agent a  a 
 pa a   a is the parent agent of agent a  a except for the root agent 
 p  a   a is the set of ancestor agents  including the parent agent  of agent a  a 
 scp  a   p  a  is the set of ancestor agents  including the parent agent  of agent a  a that
are parent or pseudo parent agents of agent a or one  or more  of its descendant agents  and
 cp  a   scp  a  is the set of ancestor agents  including the parent agent  of agent a  a
that are parent or pseudo parent agents of agent a 
we adopt the following key terms from adopt to describe bnb adopt 
 context  x   the context x a of agent a is the set of values of all ancestor agents of agent
a  the context x r of the root agent r is always equal to    
a
 delta cost     the delta cost x
a  d  is the sum of the constraint costs of all constraints
that involve both agent a and one of its ancestor agents  under the assumption that agent a
takes on value d and its ancestor agents take on the values in context x a   in the search tree 
a
a
x
  a  d   for example 
a  d  is the delta cost of the and node that has partial solution x
a 
  a           is the delta cost of node f in figure   

  

fiyeoh  felner   koenig

a
a
 gamma cost     the gamma costs x
a  d  and x a are dened as follows 

a
a
x
a  d     x a  d   



c
x
a  a d 

   

cc a 
a
x
a   

min

a
 x
a  d  

ddom a 

   

a
for all agents a  all values d and all contexts x a   thus  the gamma cost x
a  d  is the sum of
the constraint costs of all constraints that involve agent a or one of its descendant agents  that
is  either both agent a and one of its ancestor agents  both agent a and one of its descendant
agents  both a descendant agent and an ancestor agent of agent a or two descendant agents of
agent a  minimized over all possible values of its descendant agents  under the assumption that
agent a takes on value d and its ancestor agents take on the values in context x a   in the search
a
a
  a  d   for
tree  x
a  d  is the gamma cost of the and node that has partial solution x
a 
a
example    a           is the gamma cost of node f in figure    the gamma cost x
a is the sum
of the constraint costs of all constraints that involve agent a or one of its descendant agents
minimized over all possible values of agent a and its descendant agents  under the assumption
that the ancestor agents of agent a take on the values in context x a   in the search tree  the
a
gamma cost x
a is the gamma cost of the or node whose agent is agent a and whose parent
a 
is the gamma cost of node c in
and node has partial solution x a   for example    a
      
figure    therefore  the gamma cost of an and node is the sum of its delta cost and the
gamma costs of its child or nodes  and the gamma cost of an or node is the minimum of
the gamma costs of its child and nodes  for example  the gamma cost of node f in figure  
is the sum of its delta cost and the gamma costs of nodes j and k  and the gamma cost of
node c in figure   is the minimum of the gamma costs of nodes e and f  
r
solving a dcop problem optimally means to determine x
r for the root agent r or  equivalently 
r
the gamma cost of the root node since x r is the minimal solution cost  it is not dicult for the
agents to cache information that allows them to determine a cost minimal solution 

      updating the bounds
every agent a of bnb adopt stores and updates several bounds on the gamma costs  namely
a c
a
a
a
a
lba c
x a  d   lbx a  d   lbx a   ubx a  d   u bx a  d  and u bx a for all values d  all child agents c and all
a
contexts x   maintaining the following bound property 
a
lbx
a 
a
lbx
a  d 
a c
lbx a  d 




a
x
a
a
x
a  d 
c
x
a  a d 

a
 u bx
a

   




   
   

a
u bx
a  d 
a c
ubx a  d 

in the search tree 
a
a
 lbx
a and u bx a are lower and upper bounds  respectively   on the gamma cost  of the or
node whose agent is agent a and whose parent and node has partial solution x a  
a
a
 lbx
a  d  and u bx a  d  are lower and upper bounds  respectively   on the gamma cost  of the
and node that has partial solution x a   a  d   and
a c
 lba c
x a  d  and ubx a  d  are lower and upper bounds  respectively   on the gamma cost  of the
or node whose agent is agent c and whose parent and node has partial solution x a   a  d  

  

fibnb adopt  an asynchronous branch and bound dcop algorithm

a 
a 
a 
for example  lb  a
and u b  a
are bounds of node c in figure    lb  a
    and
      
      
      
a   a 
a   a 
a 
u b  a           are bounds of node f   and lb  a           and ub  a           are bounds of node j 
a 
a 
   a 
   a 
lba  a
     uba  a
     lb  a
and u b  a
are bounds of node j  but agent
      
      
       a      
       a      
a  maintains the rst two bounds while agent a  maintains the last two bounds 
each agent a uses the following update equations for all values d  all child agents c and all
a c
a c
contexts x a to initialize its bounds lba c
x a  d  and ubx a  d   where the heuristic values hx a  d  are
a c
c
oating point numbers that are admissible and thus satisfy    hx a  d   x a  a d   

a c
lba c
x a  d     hx a  d 

uba c
x a  d 

   

   
   

agent a then uses repeatedly the following update equations for all values d  all child agents c 
all contexts x a and all contexts x c    x a   a  d   to tighten the bounds 
a c
c
lba c
x a  d     max lbx a  d   lbx c  
 a c
a
a
lbx
lbx a  d 
a  d     x a  d   

   
   

cc a 
a
lbx
a   

uba c
x a  d    
a
u bx
a  d 

  

a
u bx
a   

a
min  lbx
a  d  
ddom a 
c
min uba c
x a  d   u bx c  

a
x
uba c
a  d   
x a  d 
cc a 

min

a
 u bx
a  d  

ddom a 

    
    
    
    

the updates maintain the bound property and improve the bounds monotonically  that is 
the lower bounds are monotonically non decreasing and the upper bounds are monotonically nona
a
a
increasing   after a nite amount of time  u bx
a  lbx a for all agents a and all contexts x  
r
r
bnb adopt terminates when its termination condition u bx r  lbx r for the root agent r is
r
r
r
r
satised  then  u bx
r  lbx r and the bound property u bx r  lbx r together imply that
r
r
r
u bx r   x r   lbx r   and the dcop problem is solved optimally 
figure   shows a simplied trace of the updates of the  lower and upper  bounds for our example
dcop problem  we assume that the updates proceed sequentially from the leaf agents to the root
agent  due to this simplication  the lower and upper bounds of each node are identical to its
gamma cost and independent of the heuristic values  the numbers in the nodes are their bounds 
two agents maintain the bounds of or nodes except for the root node  the gure shows the bounds
that the parent agent maintains rather than the bounds that the child agent maintains  for example 
the number in node b is the bounds that agent a  rather than agent a  maintains  the bounds
that the child agent maintains can be computed by taking the minimum of the bounds of the child
and nodes of the or node  agents update the bound of an and node to the sum of its delta cost
and the bounds of its child or nodes according to update equations   and     they update the
bound of an or node to the minimum of the bounds of its child and nodes according to update
equations    and     a more detailed description of the trace is as follows 
 step    leaf agent a  updates the bounds of and nodes g  h  k  l  o  p  s and t to their
delta costs according to update equations   and    and the bounds of or nodes d  f   h and
   leaf agents use the same update equations  since they do not have child agents  the sums over their child agents
a  d    u b a  d     a  d  for all leaf agents a  all values d and all contexts x a  
evaluate to    for example  lbx
a
xa
xa

  

fiyeoh  felner   koenig

a

or

 

or

 

or

and

a

b

and

 

 

and

 

or

b

c

or

 

 

or

 

c

and

d

or

and

d

g

e
h

i

e

f
j

k

g
l

m

f

h
n

o

i
p

q

j
r

s

k
t

 

and

u

or

v

and

 

 
 

       

 
 

 
 

 

              

identifiers

 
 
 

 

           

step  

  

or

  

       

 

 
 

  
 

 

              

  
 

 

 

 

           

step  

  
  

  

and

and

and

  

  

  

or

and

or

or

 

  

and

 

 

  
       

  
 

 
 

  
 

 

              

  
 

 

 

 

           

step  

figure    simplied trace of the updates of the  lower and upper  bounds
j to the minimum of the bounds of their child and nodes according to update equations   
and     similarly  leaf agent a  updates the bounds of and nodes i  j  m  n  q  r  u and
v to their delta costs according to update equations   and    and the bounds of or nodes
e  g  i and k to the minimum of the bounds of their child and nodes according to update
equations    and     the bounds of or nodes d to k are not shown in the gure since they
are not  yet  maintained by agent a   
 step    agent a  updates the bounds of or nodes d to k that it maintains to the bounds
of the same or nodes that leaf agents a  and a  maintain according to update equations  
and     the bounds of and nodes c to f to the sum of their delta costs and the bounds of their
child or nodes according to update equations   and    and the bounds of or nodes b and
c to the minimum of the bounds of their child and nodes according to update equations   
and     the bounds of or nodes b and c are not shown in the gure since they are not  yet 
maintained by agent a   
 step    agent a  updates the bounds of or nodes b and c that it maintains to the bounds
of the same or nodes that agent a  maintains according to update equations   and     the
bounds of and nodes a and b to the sum of their delta costs and the bounds of their child or
nodes according to update equations   and    and the bounds of or node a to the minimum
of the bounds of its child and nodes according to update equations    and     since the
lower and upper bounds of a node are equal to its gamma cost  the lower and upper bounds
of the root node are equal to its gamma cost  which in turn is equal to the minimal solution
cost  the propagation terminates after three steps with minimal solution cost    
      adhering to memory limitations
our description of bnb adopt so far assumes no memory limitations  however  bnb adopt is
a memory bounded dcop search algorithm with memory requirements per agent that are linear
in the number of agents  we now describe how bnb adopt adheres to these memory limitations
using techniques that were introduced for adopt but apply to bnb adopt as well 
the simplied trace in figure   assumes that every agent a maintains its bounds for all values d 
all child agents c and all contexts x a   the number of contexts can be exponential in the depth of the
agent in the pseudo tree  for our example dcop problem  agent a  has four dierent contexts for
the four dierent combinations of values of its ancestor agents a  and a    an agent cannot maintain
  

fibnb adopt  an asynchronous branch and bound dcop algorithm

an exponential number of bounds due to the memory limitations  therefore  every agent maintains
its bounds for only one context at any given time  this context is stored in the variable x a for
agent a  the size of the context is at most linear in the number of agents  the number of bounds of
an agent is now linear in the product of its domain cardinality and the number of its child agents 
thus  the memory requirements per agent are only linear in the number of agents if the domain
cardinality and the magnitude of the bounds  and the other variables  are constant for each agent 
      performing depth first search
our description of bnb adopt so far applies to adopt as well  however  bnb adopt uses
depth rst branch and bound search and adopt uses best rst search  we now describe how
bnb adopt implements depth rst search 
agents of bnb adopt send messages that are similar to that of adopt but processes them
dierently  they send messages of three dierent types  namely value  cost and terminate
messages  at the start  every agent a initializes its context x a   uses update equations                
a
and    to initialize its bounds and takes on its best value da    arg minddom a   lbx
a  d    it sends
value messages to all child agents and a cost message to its parent agent  it then repeatedly
waits for incoming messages  processes them  possibly takes on a dierent value and again sends
value messages to all child agents and a cost message to its parent agent  a description of the
three message types and how agents process them is as follows 
 value messages  an agent a with context x a and value da sends value messages to
all child agents with the desired context x a   a  da    which is its context augmented with its
value  leaf agents do not have child agents and thus do not send value messages  value
messages thus propagate contexts down the pseudo tree 
when an agent receives a value message  it checks whether its context is identical to the
desired context in the value message  if it is not  then the agent changes its context to the
desired context in the value message  in either case  it then executes the common program
 see below  
 cost messages  an agent a sends cost messages to its parent agent with its identity
a
a
a  its context x a and its bounds lbx
a and u bx a   the root agent does not have a parent
agent and thus does not send cost messages  cost messages thus propagate bounds up the
pseudo tree 
when an agent receives a cost message  it checks whether its context and the context in the
cost message are compatible  two contexts are compatible if no agent takes on dierent
values in the two contexts  if they are  then the agent uses update equations   to    with the
bounds in the cost message to improve its bounds for the value in the message  in either
case  it then executes the common program  see below  
r
r
 terminate messages  when the termination condition u bx
r  lbx r is satised 
the root agent r sends terminate messages  without parameters  to all child agents to
inform them that the search is complete and then terminates  when an agent receives such
a terminate message  it sends terminate messages to all child agents and terminates
as well  leaf agents do not have child agents and thus do not send terminate messages 
terminate messages thus propagate down the pseudo tree until all agents terminate 

the common program is as follows 
 context change  if an agent a changed its context x a   it executes the following statements 
it uses update equations                 and    to initialize its bounds and takes on its best
a
value da    arg minddom a   lbx
a  d    it then sends value messages to all child agents
and a cost message to its parent agent 
  

fiyeoh  felner   koenig

a

or

 

or

 

or

and

a

b

and

 

 

and

 

or

b

c

or

 

 

or

 

c

and

d

or

and

d

g

e
h

i

e

f
j

k

g
l

m

f

h
n

o

i
p

q

j
r

s

k
t

 

and

u

or

v

and

 

 

 

       

 

x

 

x

x

x

x

x x

x x

x x

x x

x x

x x

or

and

 

  

and

 

identifiers

  

 
 

       

 

x

x

x

x

x x

x x

x x

x x

x x

x x

 

or

and

 

 

and

 

 

and

  

or

 

 

or

 

 

or

  

  

and

or

and

 

  

 

x x

x x

 

x
 

         

x

  

and

x

x

x

x

x x

x x

x x

x x

or

and

  

  

 

x x

x x

 

         

cycle  

x
x

x

x

x x

x x

x x

x x

or

and

  

  
 

       

 

x

x

x

x

x x

x x

x x

x x

x x

x x

 

or

  

 

and

  

 

and

  

or

  

 

or

  

 

or

  

x

or

and

  
       

x
 
 

  

 

x

and

x

x

 

 

 

 

x x

x x

x x

x x

x x

x x

or

and

x

  

x

x

x

x

 

x x

x x

x x

x x

x x

cycle  

 
 

 

 

x x          

or

and

 
x

  

x

x

x

x

 

x x

x x

x x

x x

x x

  
 

 

 

x x          

cycle  

  

or

and

  

or

  

  
  

x

and

and

 

x

and

cycle  

or

x

 

cycle  

 

or

x

 

and

and

 

  

and

x

 

cycle  

 

or

x
 

x

 

cycle  

 

or

x

 

cycle  

 

or

x

 

x

  

x

x

x

x

 

x x

x x

x x

x x

x x

  
 

 

 

x x          

cycle  

figure    trace of the updates of the lower bounds
 no context change  if an agent a did not change its context x a   it executes the following
a
a
a
a
statements  if u bx
a  lbx a  d   for its value d   then the context of the agent augmented
with its value cannot be completed to a solution whose solution cost is smaller than the solution
a
cost of the best solution found so far for its context x a    u bx
a   and the agent thus takes on
a
a
its best value d    arg minddom a   lbx a  d    it then sends value messages to all child
agents and a cost message to its parent agent 
assume that the context x a of an agent a does not change  after a nite amount of time 
a
a
a
a
u bx
the agent then takes on its best value and repeats the
a  lbx a  d   for its value d  
a
a
procedure  after a nite amount of time  u bx
a  lbx a  d  for all values d  which implies that
a
a
a
a
a
u bx a  lbx a   the agent takes on every value d at most once until u bx
a  lbx a since lbx a  d 
a
remains unchanged and u bx a is monotonically non increasing once the agent changes its value
from d to a dierent value  which prevents the agent from changing its value back to d before
a
a
u bx
a  lbx a   bnb adopt thus performs depth rst search  then  after a nite amount of time 
r
r
r
r
r
r
r
u bx r  lbx r and the bound property u bx
r  lbx r together imply that u bx r   x r   lbx r
for the root agent r  and the dcop problem is solved optimally 
figures   and   show traces of the updates of the lower and upper bounds  respectively  for our
example dcop problem  bnb adopt uses the zero heuristic values  the initial context of every
   

fibnb adopt  an asynchronous branch and bound dcop algorithm

a

or

inf

or

inf

or

and

a

b

and

inf

inf

and

inf

or

b

c

or

inf

inf

or

inf

c

and

d

or

and

d

g

e
h

i

e

f
j

k

g
l

m

f

h
n

o

i
p

q

j
r

s

inf

and

k
t

u

or

v

and

inf

inf
inf

       

 

x

inf

x

x

x

x

x x

x x

x x

x x

x x

x x

or

and

  

inf
 

       

 

x

x

x

x

x x

x x

x x

x x

x x

x x

cycle  

  

or

  

or

  

inf

and

  

inf

and

  

or

  

inf

or

  

inf

or

  

  

or

and

inf

  

 

x x

x x

inf

x
inf

         

x

  

and

x

x

x

x

x x

x x

x x

x x

or

and

  

  

 

x x

x x

 

         

cycle  

x
x

x

x

x x

x x

x x

x x

or

and

  

  
 

       

 

x

x

x

x

x x

x x

x x

x x

x x

x x

  

or

  

inf

and

  

inf

and

  

or

  

inf

or

  

inf

or

  

x

or

and

  
       

x
 
 

inf

inf

x

and

x

x

inf

inf

inf

inf

x x

x x

x x

x x

x x

x x

or

and

x

inf

x

x

x

x

inf

x x

x x

x x

x x

x x

cycle  

inf
inf

inf

inf

x x          

or

and

inf
x

inf

x

x

x

x

inf

x x

x x

x x

x x

x x

  
inf

 

 

x x          

cycle  

  

or

and

  

or

  

  
  

x

and

and

inf

x

and

cycle  

or

x

 

cycle  

  

or

x

 

and

and

inf

  

and

x

inf

cycle  

  

or

x
 

x

inf

cycle  

  

x

inf

and

and

 

  

and

inf

identifiers
or

x

inf

x

inf

x

x

x

x

inf

x x

x x

x x

x x

x x

  
inf

 

 

x x          

cycle  

figure    trace of the updates of the upper bounds
agent assigns value   to all ancestor agents of the agent  we partition time into cycles  agents
maintain their bounds for only one context at any given time  nodes in the gures are crossed out if
their agent does not maintain their bounds  and nodes are shaded if their partial solution is equal
to the context of the agent of their parent or node augmented with its value  for example  agents
a    a  and a  take on value   in cycle    and agent a  takes on value    the context of agent a  is
    the context of agent a  is   a        and the contexts of agents a  and a  are   a         a         a
description of the trace is as follows 
 cycle    root agent a  initializes its context x a  to     it initializes the lower bounds of
nodes b    lbax a a         and c    lbax a a         to   since it uses the zero heuristic values  it
a 
updates the lower bound of node a    lbx
a       to the sum of its delta cost       and the
lower bound of node b       according to the update equations  it updates the lower bound
a 
of node b    lbx
a       to the sum of its delta cost       and the lower bound of node c      
a 
according to the update equations  it updates the lower bound of node a    lbx
a    to the
minimum of the lower bound of node a       and the lower bound of node b       according to
the update equations  it initializes the upper bounds of nodes b and c to innity  it updates
the upper bounds of nodes a  b and a to innity according to the update equations  it takes

   

fiyeoh  felner   koenig

on its best value  it can take on either value   or value   since the lower bounds of nodes a
and b are both    it takes on value   and sends a value message to its child agent a   
agent a  initializes its context x a  to   a         it initializes the lower bounds of nodes d  e 
f and g to    it updates the lower bounds of nodes c  d and b to      and    respectively  it
initializes the upper bounds of nodes d  e  f and g to innity  it updates the upper bounds
of nodes c  d and b to innity  the bounds of node b that agent a  maintains are not shown
in the gures  it takes on its best value    sends value messages to its child agents a  and
a  and sends a cost message to its parent agent a   
leaf agent a  initializes its context x a  to   a         a         it updates the lower bounds of
nodes g and h to their delta costs    and     respectively  since leaf agents do not have child
agents  it updates the lower bound of node d to     it updates the upper bounds of nodes g
and h to their delta costs    and     respectively  since leaf agents do not have child agents  it
updates the upper bound of node d to     the bounds of node d that leaf agent a  maintains
are not shown in the gures  it takes on its best value   and sends a cost message to its
parent agent a   
leaf agent a  initializes its context x a  to   a         a         it updates the lower bounds of
nodes i and j to their delta costs   and    respectively  it updates the lower bound of node e
to    it updates the upper bounds of nodes i and j to their delta costs   and    respectively  it
updates the upper bound of node e to    the bounds of node e that leaf agent a  maintains
are not shown in the gures  it takes on its best value   and sends a cost message to its
parent agent a   
in summary  the following messages are sent during cycle   
 message  value    a         from agent a  to agent a   
 message  value    a         a         from agent a  to agent a   
 message  value    a         a         from agent a  to agent a   
 message  cost  a      a              from agent a  to agent a   
 message  cost  a      a         a                 from agent a  to agent a    and
 message  cost  a      a         a               from agent a  to agent a   
 cycle    root agent a  receives the cost message sent by its child agent a  in cycle    since
the context of agent a         is compatible with the context in the message      a          it
improves its bounds  it updates the bounds of node b to the bounds in the message      and
innity  respectively   it updates the bounds of nodes a  b and a  it does not change its value
a 
a 
      for its value da       is still smaller than
since the lower bound of node a    lbx
a   d
a 
the upper bound of node a    u bx a       it sends a value message to its child agent
a   
agent a  receives the value message sent by its parent agent a  in cycle    its context
     a         remains unchanged since it is the same as the desired context in the message
     a          agent a  also receives the cost messages sent by its child agents a  and a 
in cycle    since the context of agent a       a         is compatible with the contexts in the
messages      a         a          it improves its bounds  it updates the bounds of node d to
the bounds in the rst message       and     respectively  and the bounds of node e to the
bounds in the second message      and    respectively   it updates the bounds of nodes c  d
a 
a 
       for its value
and b  it changes its value since the lower bound of node c    lbx
a   d
a 
a 
d      is no longer smaller than the upper bound of node b    u bx a         it takes on its
best value    sends value messages to its child agents a  and a  and sends a cost message
to its parent agent a   

   

fibnb adopt  an asynchronous branch and bound dcop algorithm

leaf agents a  and a  receive the value messages sent by their parent agent a  in cycle   
their contexts      a         a         remain unchanged since they are the same as the desired
context in the message      a         a          they send the same cost messages as before to
their parent agent a   
in summary  the messages sent during cycle   are identical to the ones sent during cycle   
except for the messages sent by agent a    which are as follows 
 message  value    a         a         from agent a  to agent a   
 message  value    a         a         from agent a  to agent a    and
 message  cost  a      a                from agent a  to agent a   
the value messages are dierent because agent a  changed its value from   to    the cost
message is dierent because agent a  changed its bounds 
 cycles      the messages sent during cycle   are identical to the ones sent during cycle   
except for the messages sent by agents a  and a    which are as follows 
 message  cost  a      a         a               from agent a  to agent a    and
 message  cost  a      a         a               from agent a  to agent a   
the cost messages are dierent because agents a  and a  changed their contexts  the
termination condition holds after a nite amount of time when the upper bound of node a
a 
a 
   u bx
a        is no larger than the lower bound of node a    lbx a         root agent a 
sends terminate messages to all child agents  and the terminate messages propagate
down the pseudo tree until all agents terminate  bnb adopt terminates after nine cycles
with minimal solution cost    
      performing branch and bound
we now rene our description of bnb adopt by explaining how the agents implement branchand bound search to make bnb adopt faster  every agent a of bnb adopt now also maintains
a
the variable threshold t hx
a   which it initializes to innity  the threshold of the root agent always
remains innity  every other agent uses its threshold for pruning  meaning that it can change its
value earlier than previously 
 first change  if an agent a did not change its context x a   it previously executed the following
a
a
a
a
statements  if u bx
a  lbx a  d   for its value d   then the agent took on its best value  it
then sent value messages to all child agents and a cost message to its parent agent  now  if
a
a
a
a
a
t hx
a  lbx a  d    then the agent also takes on its best value  thus  if min t hx a   u bx a   
a
a
lbx
 d
  
then
the
agent
takes
on
its
best
value
and
thus
potentially
changes
its
value 
which
a
a
a
is earlier than previously  min t hx
 
u
b
 
is
the
pruning
quantity 
a
xa
 second change  an agent a with context x a and value da sends value messages
to all its child agents  which previously contained only the desired context x a   a  da   
a
a
a
a
value messages now also contain the desired threshold min t hx
a   u bx a    x a  d   

a c a
c c a  c lbx a  d   for the child agent c  when agent c receives a value message  it sets
its threshold to the desired threshold and then proceeds as described earlier  the desired
a
a
a
reaches its
threshold is set such that the lower bound lbx
a  d   of agent a for its value d
c
pruning quantity  and agent a thus potentially changes its value  when the lower bound lbx
c
of agent c reaches the desired threshold  this property can be veried as follows 

   

fiyeoh  felner   koenig



c
a
a
a
a
lbx
c  min t hx a   u bx a    x a  d   



a
lba c
x a  d  

    

c c a  c



a
a
a
a
a
lba c
x a  d    min t hx a   u bx a    x a  d   
a c
a
a
a
a
a
 min t hx
a   u bx a    x a  d    lb a  d   
x



a
lba c
x a  d  

    

c c a  c





a
lba c
x a  d  

    

c c a  c



a c
a
a
a
a
a
min t hx
a   u bx a    x a  d     lb a  d    
x



a
a
a
a
min t hx
a   u bx a    x a  d    



a
lba c
x a  d  

    

c c a  c


a
lba c
x a  d  

    

c c a 
a
a
a
a
min t hx
a   u bx a    lbx a  d  

    

      further enhancements
we continue to rene our description of bnb adopt by explaining a number of additional enhancements  which were introduced for adopt 
 reduced contexts  the agents now use reduced contexts  which are subsets of the contexts
described previously  the reduced context x a of agent a contains the values of all ancestor
agents p  scp  a   while the context x a described previously contains the values of all
a
a
a
ancestor agents p  p  a   the agents can use reduced contexts since x
a   x a and x a  d   
 
 
 
a
x a  d  for all values d  agents now use reduced contexts because they need to change their
contexts and thus initialize their bounds less often when they receive value messages since
their contexts are then more often identical to the desired contexts in the value messages 
for our example dcop problem  the reduced context of agent a  contains the values of only
agent a  rather than the values of agents a  and a    therefore  the following pairs of nodes in
the search tree are actually the same node  nodes i and q  nodes j and r  nodes m and u  and
nodes n and v 
 value and cost messages  an agent sends value messages to all child agents  which
previously contained the desired context and the desired threshold  the desired context is the
context of the agent augmented with its value  when an agent receives a value message 
it previously checked whether its context is identical to the desired context in the value
message  if it was not  then the agent changed its context to the desired context in the
value message  agents now update their contexts dierently to reduce the size of the
value messages  an agent sends value messages to all child and pseudo child agents with
its identity  value and desired threshold  which is innity for its pseudo child agents  when an
agent receives a value message  it sets its threshold to the desired threshold if the message
is from its parent agent  it also checks whether the value of the ancestor agent in the value
message is more recent than the value of the ancestor agent in its context  if it is  then the
agent changes the value of the ancestor agent in its context to the value of the ancestor agent in
the value message  however  the context of an agent does not only contain the values of its
parent and pseudo parent agents but also the values of its ancestor agents that are the parent
or pseudo parent agents of one  or more  of its descendant agents  and ancestor agents that
are not constrained with the agent cannot send value messages to the agent  however  they
send value messages to their pseudo child agents  at least one of which is a descendant agent
of the agent  and the information then propagates up the pseudo tree with cost messages
until it reaches the agent  when an agent receives a cost message  it now checks whether
   

fibnb adopt  an asynchronous branch and bound dcop algorithm

the value of an ancestor agent in the context of the cost message is more recent than the
value of the ancestor agent in its context  if it is  then the agent changes the value of the
ancestor agent in its context to the value of the ancestor agent in the context of the cost
message  our example dcop problem is too simple to allow us to illustrate the propagation
of the information up the pseudo tree  however  imagine that a new agent a  is a child agent
of agent a  and is constrained with agents a  and a    the context of agent a  then contains
the value of agent a  but agent a  cannot send value messages to agent a    however  agent
a  sends value messages to agent a    agent a  changes the value of agent a  in its context
and sends cost messages with its context to agent a    which then changes the value of agent
a  in its context as well 
the agents now need to determine whether the value of an agent in value messages or in the
contexts of cost messages is more recent than the value of the agent in their contexts  every
agent a therefore now also maintains a counter ida and increments it whenever it changes its
value  therefore  a larger id indicates a more recent value  the values of agents in contexts
are now labeled with their ids  and value messages contain the identity of the sending agent 
its value  its id and the desired threshold 
 bounds  whenever an agent changes its context x a   it previously initialized its bounds and
took on its best value  the  reduced  context of a child agent of an agent can now be a strict
subset of the  reduced  context of the agent since the parent or some pseudo parent agents of
the agent might not be  parent or  pseudo parent agents of the child agent or its descendant
agents  if the context of child agent c does not contain the values of any agents whose values
changed in the context of agent a  then agent a does not initialize its lower bounds lba c
x a  d 
and upper bounds uba c
 d 
for
agent
c
and
all
values
d
before
it
takes
on
its
best
value 
agents
xa
use this optimization because they need to initialize their bounds less often this way  for our
example dcop problem  if agent a  changes its context from   a        to   a         where the
ids are omitted for simplicity   then it does not initialize its lower bounds lbax a a     d  and upper
bounds ubax a a     d  for child agent a  and all values d since the context of agent a  does not
contain the value of agent a   
additionally  if an agent a changes its context due to a cost message from its child agent c
and its new context x a is compatible with the context in the cost message  then agent a
a c
can set its lower bound lba c
x a  d  and upper bound ubx a  d  for agent c and the value d of agent
a in the cost message to the bounds in the cost message before it takes on its best value 
agents use this optimization because the bounds in the cost message are more informed than
the initialized bounds  our example dcop problem is too simple to allow us to illustrate this
optimization  however  imagine again that a new agent a  is a child agent of agent a  and is
constrained with agents a  and a    assume that the context of agent a  is   a         a       
 where the ids are again omitted for simplicity  and it receives a cost message from agent
a  with context   a         a         agent a  then changes its context to   a         a         sets
   a 
   a 
its lower bound lba  a
    and its upper bound uba  a
    to the bounds in the
       a      
       a      
cost message and initializes all other bounds before it takes on its best value 

      pseudocode
figure   shows the bnb adopt pseudocode of every agent  the pseudocode does not index
variables with the context since this context is implicitly given by the variable x a   it uses the
predicate compatible x  x       a d id x  a  d  id  x   a   a  d 
  d   that determines if two
contexts x and x  are compatible  that is  if no agent takes on two dierent values in the two contexts
 lines                and      the pseudocode also uses the procedure prioritymerge x  x    that
executes x       a   d   id    x     a d id x  a   a       a   d   id    x     a d id x  a  

   

fiyeoh  felner   koenig

procedure start  
    
x a      p  valinit p        p  scp  a   
    
ida      
    
forall c  c a   d  dom a 
    
initchild c  d  
    
initself    
    
backtrack   
    
loop forever
    
if  message queue is not empty 
    
while message queue is not empty 
    
pop msg o message queue 
    
when received msg  
    
backtrack   
procedure initchild c  d 
    
lba c  d     ha c  d  
    
uba c  d      
procedure initself   

    
da    arg minddom a    a  d    cc a  lba c  d   
a
a
    
id    id     
    
t h a     
procedure backtrack  
    
forall d  dom a  
    
lb a  d      a  d    cc a  lba c  d  

    
ub a  d      a  d    cc a  uba c  d  
a
    
lb    minddom a   lb a  d   
    
ub a    minddom a   ub a  d   
    
if  lb a  da    min t h a   ub a   
    
da    arg minddom a   lb a  d    choose the previous da if possible  
    
if a new da has been chosen
    
ida    ida     
    
if   a is root and ub a  lb a   or termination message received 
    
send terminate  to each c  c a  
    
terminate execution 


    
send value  a  da   ida   min t h a   ub a     a  da    c c a  c lba c  da    to each c  c a  
a
a
    
send value  a  d   id     to each c  cd a    c a  
    
send cost  a  x a   lb a   ub a   to pa a  if a is not root 
procedure when received value  p  dp   idp   t h p  
    
x     x a  
    
prioritymerge  p  dp   id p    x a   
    
if   compatible x    x a   
    
forall c  c a   d  dom a 
    
if  p  scp  c  
    
initchild c  d  
    
initself    
    
if  p   pa a  
    
t h a    t h p  
procedure when received cost  c  x c   lb c   ub c  
    
x     x a  
    
prioritymerge x c   x a   
    
if   compatible x    x a   
    
forall c  c a   d  dom a 
    
if   compatible   p  dp   id p    x    p  scp  c   x a   
    
initchild c d  
    
if  compatible x c   x a   
    
lba c  d     max lba c  d   lb c   for the unique  a   d  id   x c with a   a 
    
uba c  d     min uba c  d   ub c   for the unique  a   d  id   x c with a   a 
    
if   compatible x    x a   
    
initself    
procedure when received terminate 
    
record termination message received 

figure    pseudocode of bnb adopt
a  id  id       a  d  id   x    a  d  id  x   a   a  id   id    and thus replaces the values

   

fibnb adopt  an asynchronous branch and bound dcop algorithm

of agents in context x  with more recent values  if available  of the same agents in context x  lines
   and     
the code is identical for every agent except that the variable a is a self variable that points to
the agent itself  at the start  bnb adopt calls start   for every agent  when an agent a receives
a value message from an ancestor agent  then the when received handler for value messages
is called with p being the ancestor agent  dp being the value of the ancestor agent  idp being the
id of the ancestor agent and t h p being the desired threshold for agent a if the ancestor agent is
its parent agent  and innity otherwise   line      when agent a receives a cost message from a
child agent  then the when received handler for cost messages is called with c being the child
c
agent  x c being the context of the child agent  lb c being the lower bound lbx
c of the child agent
c
c
and u b being the upper bound u bx c of the child agent  line      finally  when agent a receives a
terminate message from its parent agent  then the when received handler for terminate
messages is called without any arguments  line     
bnb adopt uses the same message passing and communication framework as adopt and
has the same memory requirements  it uses similar value  cost and terminate messages 
a similar strategy to update the context of an agent based on value messages from its ancestor
agents and cost messages from its child agents  the same semantics for the bounds and the same
update equations to update these bounds  bnb adopt and adopt both use thresholds but bnbadopt uses the thresholds for pruning while adopt uses them to reconstruct partial solutions
that were purged from memory  thus  bnb adopt uses a dierent threshold initialization  line
     dierent desired threshold calculation  line     and dierent termination condition  line     
bnb adopt also diers from adopt in that it maintains ids that agents use to indicate the
recency of their values and labels the values of agents in contexts with their ids 
      trace
figures    and    show traces of the updates of the lower and upper bounds  respectively  for our
example dcop problem  and table   shows a trace of the update of all variables  bnb adopt
uses the heuristic values hax a a              hax a a              hax a a              hax a a              hax a a            
and hax a a             for all contexts x a  and x a    these heuristic values were chosen by hand  every
agent assigns the value of all its ancestor agents in its initial context to    we partition time into
cycles as in figures   and   and continue to use the conventions made in the context of those gures 
 cycle    root agent a  initializes its context x a  to     line     it initializes the lower bounds
of nodes b    lbax a a         and c    lbax a a         to their heuristic values   and    respectively
a 
 line      it updates the lower bound of node a    lbx
a       to the sum of its delta cost
      and the lower bound of node b       according to the update equations  line      it
a 
updates the lower bound of node b    lbx
a       to the sum of its delta cost       and the
lower bound of node c       according to the update equations  line      it updates the
a 
lower bound of node a    lbx
a    to the minimum of the lower bound of node a       and
the lower bound of node b       according to the update equations  line      it initializes the
upper bounds of nodes b and c to innity  line      it updates the upper bounds of nodes a 
b and a to innity according to the update equations  lines    and      it takes on its best
value   since the lower bound of node a       is smaller than the lower bound of node b      
 line      initializes its id ida  to    lines   and      initializes its threshold t h a  to innity
 line     and sends value messages to its child agent a  and pseudo child agent a   lines   
and     
agent a  initializes its context x a  to   a            line     it initializes the lower bounds of
nodes d  e  f and g to their heuristic value    line      it updates the lower bounds of nodes
c  d and b to       and    respectively  lines    and      it initializes the upper bounds of
nodes d  e  f and g to innity  line      it updates the upper bounds of nodes c  d and b
to innity  lines    and      the bounds of node b that agent a  maintains are not shown
   

fiyeoh  felner   koenig

cycle
x a 
da 
id a 
t h a 
lb a     
lb a     
lb a 
u b a     
u b a     
u b a 
lba   a     
lba   a     
uba   a     
uba   a     
x a 
da 
id a 
t h a 
lb a     
lb a     
lb a 
u b a     
u b a     
u b a 
lba   a     
lba   a     
uba   a     
uba   a     
lba   a     
lba   a     
uba   a     
uba   a     
x a 
da 
id a 
t h a 
lb a     
lb a     
lb a 
u b a     
u b a     
u b a 
x a 
da 
id a 
t h a 
lb a     
lb a     
lb a 
u b a     
u b a     
u b a 

 

 

 

 

 

 

 

 

 

 
 

 
 
 



 
 


 a         
 
 

 
  
 



 
 


 
 


 a         
 a         
 
 

  
  
  
  
  
  
 a         
 
 

 
 
 
 
 
 

 
 

 
 
 



 
 


 a         
 
 

  
  
  
  

  
  
 
  

 
 
 

 a         
 a         
 
 

  
  
  
  
  
  
 a         
 
 

 
 
 
 
 
 

 
 

  
 
 
  

  
  
 
  

 a         
 
 

  
  
  
  

  
  
 
  

 
 
 

 a         
 a         
 
 
 
 
  
 
 
  
 
 a         
 
 
 
  
 
 
  
 
 

 
 

  
 
 
  

  
  
 
  

 a         
 
 
  
  
  
  
  
  
  
  
 
  
 
 
 
 
 
 a         
 a         
 
 
 
 
  
 
 
  
 
 a         
 
 
 
  
 
 
  
 
 

 
 

  
 
 
  

  
  
 
  

 a         
 
 
  
  
  
  
  
  
  
  
 
  
 
 
 
 
 
 a         
 a         
 
 
  
  
  
  
  
  
  
 a         
 
 
 
 
 
 
 
 
 

 
 

  
 
 
  

  
  
 
  

 a         
 
 
  
  
 
 



 
 


 
 
 
 
 a         
 a         
 
 
  
  
 
 
  
 
 
 a         
 
 
 
 
 
 
 
 
 

 
 

  
 
 
  

  
  
 
  

 a         
 
 
  
  
 
 
  

  
 
 
 

 
 
 
 
 a         
 a         
 
 
  
  
 
 
  
 
 
 a         
 
 
  
  
 
 
  
 
 

 
 

  
 
 
  
  
  
  
 
  
  
 a         
 
 
  
  
  
  
  
  
  
 
 
 
 
 
 
 
 
 a         
 a         
 
 
  
  
 
 
  
 
 
 a         
 
 
  
  
 
 
  
 
 

 
 

  
  
  
  
  
  
  
  
  
  
 a         
 
 
  
  
  
  
  
  
  
 
 
 
 
 
 
 
 
 a         
 a         
 
 
 
  
 
 
  
 
 
 a         
 
 
 
  
 
 
  
 
 

table    trace of the update of all variables of bnb adopt

   

fibnb adopt  an asynchronous branch and bound dcop algorithm

a

or

 

or

 

or

and

a

b

and

 

 

and

 

or

b

c

or

 

 

or

 

c

and

d

or

and

d

g

e
h

i

e

f
j

k

g
l

m

f

h
n

o

i
p

q

j
r

s

k
t

 

and

u

or

v

and

  

 

 

       

 

x

 

x

x

x

x

x x

x x

x x

x x

x x

x x

or

and

 

  

and

 

identifiers

  

  
 

       

 

x

x

x

x

x x

x x

x x

x x

x x

x x

 

or

and

  

 

and

  

 

and

  

or

  

 

or

  

 

or

  

  

and

or

and

  

  

 

x x

x x

 

x
 

         

x

  

and

x

x

x

x

x x

x x

x x

x x

or

and

  

  

 

x x

x x

 

         

cycle  

x
x

x

x

x x

x x

x x

x x

or

and

  

  
 

       

 

x

x

x

x

x x

x x

x x

x x

x x

x x

 

or

  

 

and

  

 

and

  

or

  

 

or

  

 

or

  

x

or

and

x

x

x

x

x x

x x

x x

  
x

 

x x     

 
 

 

 

x

and

 

 

x x

x x

or

and

x

  

x

x

x

x

 

x x

x x

x x

x x

x x

cycle  

 
 

 

 

x x          

and

 
x

  

x

x

x

x

 

x x

x x

x x

x x

x x

  
 

 

 

x x          

cycle  

  

or

and

  

or

  

  
  

x

and

and

or

 

x

and

cycle  

or

x

 

cycle  

 

or

x

 

and

and

 

  

and

x

 

cycle  

 

or

x
 

x

 

cycle  

 

or

x

 

cycle  

 

or

x

 

x

  

x

x

x

x

 

x x

x x

x x

x x

x x

  
 

 

 

x x          

cycle  

figure     trace of the update of the lower bounds of bnb adopt
in the gure  it takes on its best value    line      initializes its id to    lines   and     
initializes its threshold to innity  line     and sends value messages to its child agents a 
and a  and a cost message to its parent agent a   lines        
leaf agent a  initializes its context x a  to   a            a            line     it updates the lower
bounds of nodes g and h to their delta costs    and     respectively  since leaf agents do not
have child agents  line      it updates the lower bound of node d to     line      it updates
the upper bounds of nodes g and h to their delta costs    and     respectively  since leaf agents
do not have child agents  line      it updates the upper bound of node d to     line      the
bounds of node d that leaf agent a  maintains are not shown in the gure  it takes on its
best value    line      initializes its id to    lines   and      initializes its threshold to innity
 line     and sends a cost message to its parent agent a   line     
leaf agent a  initializes its  reduced  context x a  to   a            line     it updates the lower
bounds of nodes i and j to their delta costs   and    respectively  line      it updates the
lower bound of node e to    line      it updates the upper bounds of nodes i and j to their
delta costs   and    respectively  line      it updates the upper bound of node e to    line
     the bounds of node e that leaf agent a  maintains are not shown in the gure  it takes

   

fiyeoh  felner   koenig

a

or

inf

or

inf

or

and

a

b

and

inf

inf

and

inf

or

b

c

or

inf

inf

or

inf

c

and

d

or

and

d

g

e
h

i

e

f
j

k

g
l

m

f

h
n

o

i
p

q

j
r

s

inf

and

k
t

u

or

v

and

inf

inf
inf

       

 

x

inf

x

x

x

x

x x

x x

x x

x x

x x

x x

  

or

and

inf
 

       

 

x

x

x

x

x x

x x

x x

x x

x x

x x

cycle  

  

or

  

or

  

inf

and

  

inf

and

  

or

  

inf

or

  

inf

or

  

  

or

and

inf

  

 

x x

x x

inf

x
inf

         

x

  

and

x

x

x

x

x x

x x

x x

x x

or

and

  

  

 

x x

x x

 

         

cycle  

x
x

x

x

x x

x x

x x

x x

  

or

and

  
 

       

 

x

x

x

x

x x

x x

x x

x x

x x

x x

  

or

  

inf

and

  

inf

and

  

or

  

inf

or

  

inf

or

  

x

or

and

x

x

x

x

x x

x x

x x

inf
x

inf

x x     

inf
 

 

 

x

and

inf

 

x x

x x

or

and

x

  

x

x

x

x

 

x x

x x

x x

x x

x x

cycle  

inf
 

inf

 

x x          

  

x

x

x

 

x x

x x

x x

x x

x x

  
 

 

 

x x          

cycle  

  

or

and

  

or

  

  
  

x

and

and

  
x

x

or

and

  

x

and

cycle  

or

x

 

cycle  

  

or

x

 

and

and

inf

  

and

x

inf

cycle  

  

or

x
 

x

inf

cycle  

  

x

inf

and

and

inf

  

and

inf

identifiers
or

x

inf

x

  

x

x

x

x

 

x x

x x

x x

x x

x x

  
 

 

 

x x          

cycle  

figure     trace of the update of the upper bounds of bnb adopt
on its best value    line      initializes its id to    lines   and      initializes its threshold to
innity  line     and sends a cost message to its parent agent a   line     
in summary  the following messages are sent during cycle   
 message  value  a            from agent a  to agent a   
 message  value  a            from agent a  to agent a   
 message  value  a            from agent a  to agent a   
 message  value  a            from agent a  to agent a   
 message  cost  a      a                 from agent a  to agent a   
 message  cost  a      a            a                    from agent a  to agent a    and
 message  cost  a      a                  from agent a  to agent a   
 cycle    root agent a  receives the cost message sent by its child agent a  in cycle    since
the context of agent a         is compatible with the context in the message      a             it
improves its bounds  it updates the bounds of node b to the bounds in the message      and
innity  respectively   lines         it updates the bounds of nodes a  b and a  lines        
   

fibnb adopt  an asynchronous branch and bound dcop algorithm

a 
a 
it does not change its value since the lower bound of node a    lbx
      for its value
a   d
a 
a 
a 
d      is still smaller than its pruning quantity    min t hx a    u bx a      min      
   it sends value messages to its child agent a  and pseudo child agent a   lines        

agent a  receives the value message sent by its parent agent a  in cycle    it updates its
context from   a           to   a           since the id of agent a  in its context       is smaller
than the id in the message        line      its threshold      remains unchanged since it
is the same as the desired threshold      in the message  agent a  also receives the cost
messages sent by its child agents a  and a  in cycle    since its context      a            is compatible with the contexts in the messages      a            a           and   a            respectively  
it improves its bounds  it updates the bounds of node d to the bounds in the rst message
      and     respectively  and the bounds of node e to the bounds in the second message     
and    respectively   lines         it updates the bounds of nodes c  d and b  lines         it
a 
a 
       for its value da       is
changes its value since the lower bound of node c    lbx
a   d
a 
a 
no longer smaller than its pruning quantity    min t hx a    u bx
a      min              it
takes on its best value    line      increments its id to    lines         sends value messages
to its child agents a  and a   lines        and sends a cost message to its parent agent a 
 line     
leaf agent a  receives the value messages sent by its parent agent a  and pseudo parent
agent a  in cycle    it updates its context from   a            a           to   a            a          
since the ids of agents a  and a  in its context      and    respectively  are smaller than
the ids in the messages      and    respectively   line      its threshold      remains
unchanged since it is the same as the desired threshold      in the message  its bounds are
not reinitialized since its context is compatible with its previous context  line      it sends
the same cost message as before to its parent agent a   line     
leaf agent a  receives the value message sent by its parent agent a  in cycle    it updates its
contexts from   a           to   a           since the id of agent a  in its context       is smaller
than the id in the message        line      its threshold      remains unchanged since it is
the same as the desired threshold      in the message  its bounds are not reinitialized since
its context is compatible with its previous context  line      it sends the same cost message
as before to its parent agent a   line     
in summary  the messages sent during cycle   are identical to the ones sent during cycle   
except for the messages sent by agents a    a  and a    which are as follows 
 message  value  a             from agent a  to agent a   
 message  value  a             from agent a  to agent a    and
 message  cost  a      a                    from agent a  to agent a   
 message  cost  a      a            a                    from agent a  to agent a    and
 message  cost  a      a                  from agent a  to agent a   
the value messages are dierent because agent a  changed its value from   to    the cost
messages are dierent because agent a  changed its bounds and its context and agents a  and
a  changed their contexts 
 cycles      the messages sent during cycle   are identical to the ones sent during cycle   
except for the messages sent by agents a  and a    which are as follows 
 message  cost  a      a            a                  from agent a  to agent a    and
 message  cost  a      a                  from agent a  to agent a   

   

fiyeoh  felner   koenig

the cost messages are dierent because agents a  and a  changed their contexts  the
termination conditions holds after a nite amount of time when the upper bound of node a
a 
a 
   u bx
a        is no larger than the lower bound of node a    lbx a         line      root
agent a  sends terminate messages to all child agents  line      and the terminate
messages propagate down the pseudo tree  line     until all agents terminate  bnb adopt
terminates after nine cycles with minimal solution cost    

   bounded error approximations
in this section  we present three approximation mechanisms that allow bnb adopt to trade o
solution cost for a smaller runtime  they bound the error on the solution cost by a user dened
error bound  first  we modify the absolute error mechanism of adopt  modi et al         to
work with bnb adopt  this approximation mechanism allows users to specify an absolute error
bound on the solution cost  for example  that the solution cost should be at most    larger than the
minimal solution cost   however  it is often much more desirable to specify a relative error bound on
the solution cost  for example  that the solution cost should be at most    percent larger than the
minimal solution cost or  equivalently      times larger than the minimal solution cost   this cannot
be done with the absolute error mechanism without knowing the minimal solution cost a priori 
thus  we introduce two approximation mechanisms that allow users to specify a relative error bound
on the solution cost  namely the relative error mechanism and the weighted heuristics mechanism 
all approximation mechanisms let the root agent r  and only the root agent  maintain the
limit limr   the root agent uses this limit in the same way in the termination condition for all
r
r
approximation mechanisms but updates it dierently  the termination condition u bx
r  lbx r on
r
r
line    of the pseudocode of bnb adopt is replaced with u bx r  lim   the root agent updates
the limit between lines    and    in the pseudocode  outside of the preceding if statement 
    absolute error mechanism
the absolute error mechanism of adopt requires a user dened absolute error bound    b   
that species that the solution cost should be at most b larger than the minimal solution cost  this
approximation mechanism can easily be modied for bnb adopt by setting the limit as follows 
limr

  

r
b   lbx
r

    

bnb adoptaem is the resulting variant of bnb adopt with the absolute error mechanism 
bnb adoptaem terminates once the upper bound of the root node  which is equal to the solution
cost of the solution with the smallest solution cost found so far  is no larger than the limit  which
is equal to the absolute error bound b plus the lower bound of the root node  which is a lower
bound on the minimal solution cost   bnb adoptaem terminates with a solution cost that is
equal to the upper bound of the root node although the minimal solution cost could be as small as
the lower bound of the root node  it thus terminates with a solution cost that is at most b larger
than the minimal solution cost  figure    shows a trace of bnb adoptaem with absolute error
bound b      for our example dcop problem  bnb adoptaem terminates after three cycles
with suboptimal solution cost     which is six cycles faster than bnb adopt 
    relative error mechanism
it is often much more desirable to specify a relative error bound on the solution cost rather than
an absolute error bound  fortunately  the absolute error mechanism of bnb adopt can easily
be changed to the relative error mechanism by setting the limit as follows  the relative error
   

fibnb adopt  an asynchronous branch and bound dcop algorithm

a

 

or

a

lim       
a
ub     infinity

a

lim       
a
ub     infinity

 

or

 

or

and

 

 

and

 

 

and

  

or

 

 

or

 

 

or

  

 

and

or

and

 

  
 

       

 

x

x

  

and

 

 

x

x

x

x

x x

x x

x x

x x

x x

x x

or

and

  

  
 

       

 

x

x

 

 

x

x

x

x

x x

x x

x x

x x

x x

x x

cycle  

or

and

 
 

  

and

lim       
a
ub       

  

  

 

x x

x x

 

x
 

         

cycle  

x

x

x

x

x

x x

x x

x x

x x

cycle  

figure     trace of the update of the lower bounds of bnb adoptaem with b     
a

 

or

a

lim      
a
ub     infinity

a

lim       
a
ub     infinity

 

or

 

or

and

 

 

and

 

 

and

  

or

 

 

or

 

 

or

  

 

and

or

and

 

  
 

       

 

x

x

  

and

 

 

x

x

x

x

x x

x x

x x

x x

x x

x x

or

and

  

  
 

       

 

x

x

 

 

x

x

x

x

x x

x x

x x

x x

x x

x x

cycle  

cycle  

or

and

 
 

  

and

lim       
a
ub       

  

  

 

x x

x x

 

x
 

         

x

x

x

x

x

x x

x x

x x

x x

cycle  

figure     trace of the update of the lower bounds of bnb adoptrem with p    
mechanism requires a user dened relative error bound    p    that species that the solution
cost should be at most p times larger than the minimal solution cost 
limr

r
   p  lbx
r

    

bnb adoptrem is the resulting variant of bnb adopt with the relative error mechanism 
bnb adoptrem terminates once the upper bound of the root node  which is equal to the solution
cost of the solution with the smallest solution cost found so far  is no larger than the limit  which
is equal to the relative error bound p times the lower bound of the root node  which is a lower
bound on the minimal solution cost   bnb adoptrem terminates with a solution cost that is
equal to the upper bound of the root node although the minimal solution cost could be as small as
the lower bound of the root node  it thus terminates with a solution cost that is at most p times
larger than the minimal solution cost  figure    shows a trace of bnb adoptrem with relative
error bound p     for our example dcop problem  bnb adoptrem terminates after three cycles
with suboptimal solution cost     which is six cycles faster than bnb adopt 
    weighted heuristics mechanism
there is a second way of implementing a relative error bound for bnb adopt since bnb adopt
uses admissible heuristic values  it is common practice in the context of a  to trade o solution
cost for a smaller runtime by using weighted heuristic values  pohl         which are derived from
admissible heuristic values by multiplying them with a user dened weight    w     the
resulting heuristic values can be inadmissible  a  is then no longer guaranteed to nd cost minimal
solutions but it is guaranteed to terminate with a solution cost that is at most w times larger than
the minimal solution cost  pohl         this approximation mechanism can easily be modied for
bnb adopt by setting the limit as follows 
limr

  

   

r
lbx
r

    

fiyeoh  felner   koenig

a

 

or

a

lim      
a
ub     infinity

a

lim       

lim       

   uba    infinity

or

   uba      

or

and

 

  

and

  

  

and

  

or

 

  

or

  

  

or

  

  

and

or

and

 

  
 

       

 

x

x

  

and

 

 

x

x

x

x

x x

x x

x x

x x

x x

x x

or

and

  

  
 

       

 

x

x

 

x

x

x

x

x x

x x

x x

x x

x x

x x

cycle  

cycle  

or

and

  

  

and

 

  

  

  

 

x x

x x

 

x
 

         

x

x

x

x

x

x x

x x

x x

x x

cycle  

figure     trace of the update of the lower bounds of bnb adoptw hm with w    
and by initializing the lower bounds lba c
x a  d  as follows 
lba c
x a  d 

   w  ha c
x a  d 

    

for all agents a  all values d  all child agents c and all contexts x a   bnb adoptw hm is the
resulting variant of bnb adopt with the weighted heuristics mechanism  bnb adoptw hm
terminates once the upper bound of the root node  which is equal to the solution cost of the solution
with the smallest solution cost found so far  is no larger than the limit  which is equal to the lower
bound of the root node  which is a lower bound on w times the minimal solution cost   bnbadoptw hm terminates with a solution cost that is equal to the upper bound of the root node
although the minimal solution cost could be as small as the lower bound of the root node divided
by w  it thus terminates with a solution cost that is at most w times larger than the minimal
solution cost  figure    shows a trace of bnb adoptw hm with w     for our example dcop
problem  bnb adoptw hm terminates after three cycles with suboptimal solution cost     which
is six cycles faster than bnb adopt 

   correctness and completeness
in this section  we prove the correctness and completeness of bnb adopt and its suboptimal
variants  all denitions  lemmata  theorems and corollaries hold for bnb adopt and its suboptimal variants except when mentioned otherwise  therefore  each agent a uses the following update
equation for all values d  all child agents c and all contexts x a to initialize its bounds lba c
x a  d  
a c
lba c
x a  d     w  hx a  d 

    

where the weight w is a oating point number that satises    w    and the heuristic values
ha c
x a  d  are oating point numbers that satisfy
c
   ha c
x a  d   x a  a d 

    

messages are sent at the end of a cycle and received in the beginning of a cycle   is the largest
duration between the time a message is sent and the time it is processed  and  is the largest duration
of a cycle 
lemma    if two contexts x and x  of an arbitrary agent a  a agree on the values of all ancestor
a
a
  x
agents p  scp  a  of agent a  then x
 
proof  by denition  x a  x is the  reduced  context that contains the values of all ancestor agents
a
is the sum of the constraint costs of all constraints that
p  scp  a  of agent a  the gamma cost x
   

fibnb adopt  an asynchronous branch and bound dcop algorithm

involve agent a or one of its descendant agents minimized over all possible values of agent a and its
descendant agents  under the assumption that the ancestor agents of agent a take on the values in
a
thus depends only on the values of the ancestor agents  including
context x  the gamma cost x
the parent agent  of agent a that are the parent or pseudo parent agents of agent a or one  or more 
of its descendant agents  that is  the values of all ancestor agents p  scp  a  of agent a  therefore 
a
a
a
a
  x
x
a   similarly  x    x a  
definition    contexts are correct i the ids of the values of all agents in the contexts are equal
to the ids of the agents  which implies that the values of all agents in the contexts are equal to the
values of the agents 
lemma    if the context x a of an arbitrary agent a  a does not change for a period of time 
a
a
then the lower bounds lba c
x a  d   lbx a  d  and lbx a are monotonically non decreasing and the upper
a c
a
a
bounds ubx a  d   u bx a  d  and u bx a are monotonically non increasing during that period of time
for all values d  dom a  and all child agents c  c a  
a
proof  since the context x a does not change  the delta values x
a  d  are constant and the bounds
 once initialized  are updated according to update equations   to     thus  the lower bounds are
monotonically non decreasing and the upper bounds are monotonically non increasing 

lemma    if the value of an arbitrary ancestor agent p  scp  a  of an arbitrary agent a  a does
not change between the current time t and a future time t with t  t    a             then the
value of agent p and its id in the context of agent a are equal to the value of agent p and its id 
respectively  between some time t and time t with t  t 
proof  assume that the value of an arbitrary ancestor agent p  scp  a  of an arbitrary agent a  a
does not change between the current time t and a future time t with t  t    a             there
are the following two cases 
 case    if agent p is a parent or pseudo parent agent of agent a  then it sent a value message
to agent a with its value and id at time t  t     that is  in the same cycle in which it took
on the value that it has at time t since the duration of that cycle is no larger than    the
agents send value messages at the end of every cycle   agent a receives the value message
by time t    since messages are delivered with nite delay   it then updates the value of
agent p and its id in its context by time t       since the update is done in the same cycle
and the duration of that cycle is no larger than   thus  the value of agent p and its id in
the context of agent a are equal to the value of agent p and its id  respectively  between some
time t and time t with t  t  t        t           t since agent p does not change
its value between time t and time t 
 case    if agent p is not a parent or pseudo parent agent of agent a  then one of its pseudo child
agents c is a descendant agent of agent a  agent p sent a value message to agent c with its
value and id at time t  t     agent c receives the value message by time t     it then
updates the value of agent p and its id in its context and sends a cost message to its parent
agent pa c  with its updated context by time t         the agents send cost messages at
the end of every cycle   agent pa c  receives the cost message by time t           it then
updates the value of agent p and its id in its context and sends a cost message to its parent
agent pa pa c   with its updated context by time t             this process continues until
agent a updates the value of agent p and its id in its context by time t   n         where
n   a  is the number of messages in the chain of messages  thus  the value of agent p and its
id in the context of agent a are equal to the value of agent p and its id  respectively  between
some time t and time t with t  t  t   n         t    a             t since agent
p does not change its value between time t and time t 

   

fiyeoh  felner   koenig

corollary    if the values of all ancestor agents p  scp  a  of an arbitrary agent a  a do not
change between the current time t and a future time t with t  t    a             then the context
of agent a is correct between some time t and time t with t  t 
c
c
c
lemma    if lbx
c  w  x c  w  u bx c at all times for all child agents c  c a  of an arbitrary
a c
a c
c
c
agent a and their contexts x   then lbx a  d   w  x
a  a d   w  ubx a  d  at all times for the context
x a of agent a  all values d  dom a  and all child agents c  c a  

proof  we prove the lemma by induction on the number of times that agent a changes its context
a c
or updates its bounds lba c
x a  d  and ubx a  d  for an arbitrary value d and an arbitrary child agent c
after agent a initializes its bounds  the conclusion of the lemma holds after agent a with context
x a initializes its bounds since
a c
lba c
x a  d    w  hx a  d 

 eq     

w

 eq     

c
x
a  a d 


  w  uba c
x a  d 

 eq    

for the  unchanged or new  context x a of agent a  induction basis   now assume that the lemma
holds after agent a changed its context or updated its bounds a number of times  induction assumption   we show that it then also holds after agent a changes its context or updates its bounds one
more time  induction step   there are the following two cases  where we split the operations after
receiving a cost message into two parts  
 case    the conclusion of the lemma holds when agent a changes its context from x a to x a
after receiving a value or cost message and the two contexts agree on the values of all
ancestor agents p  scp  c  since agent a then does not change its bounds and thus
 d    lba c
lba c
x a  d 
x a
c
 w  x
a  a d 

 induction assumption 

c
w  x
a  a d 
a c
ubx a  d 
c
x
a  a d 
c
x a  a d 

 lemma   

 
uba c
 d 
x a

 premise of case 

 

 

 premise of case 
 induction assumption 
 lemma   

after receiving the value or cost message  since contexts x a and x a agree on the values
of all ancestor agents p  scp  c   
 case    the conclusion of the lemma holds when agent a updates its bounds from lba c
x a  d  and
a c
a c
a c


ubx a  d  to lbx a  d  and ubx a  d   respectively  after receiving a cost message from some child
c
c
c
agent c with bounds lbx
that is compatible with its context x a
c and u bx c and context x
and in which agent a has value d since

   

fibnb adopt  an asynchronous branch and bound dcop algorithm

 a ca  d    max lba ca  d   lb c c  
lb
x
x
x
c
c
 max w  x
a  a d    w  x c  

 eq    
 induction assumption and premise of lemma 

c
c
  max w  x
a  a d    w  x a  a d   

 w
 a ca  d 
ub
x

 lemma   

c
x
a  a d 

c
  min uba c
x a  d   u bx c  
c
c
 min x
a  a d    x c  

 eq     
 induction assumption and premise of lemma 

c
c
  min x
a  a d    x a  a d   

 

 lemma   

c
x
a  a d 

after receiving the cost message  since contexts x a   a  d  and x c agree on the values of
all ancestor agents p  scp  c   
a c
c
thus  lba c
x a  d   w  x a  a d   w  ubx a  d  at all times for all values d  dom a  and all child
agents c  c a  
a
a
a
a
a
a
lemma    lbx
a  d   w  x a  d   w  u bx a  d  and lbx a  w  x a  w  u bx a at all times for
a
all values d  dom a  and the context x of an arbitrary agent a  a 

proof  we prove the lemma by induction on the depth of an agent in the pseudo tree  the lemma
holds for a leaf agent a in the pseudo tree with context x a since
a
a
lbx
a  d    x a  d 

 eq    

a
x
a  d 
a
x a  d 
a
x
a  d 

 eq    
 eq     

 
a
u bx
a  d   
 

 eq    

a
a
a
a
for all values d at all times  thus  lbx
a  d    x a  d   w  x a  d    w  u bx a  d  for all values d
at all times  furthermore 

a
lbx
a  

 

a
u bx
a

min

a
 lbx
a  d  

 eq     

ddom a 

min

a
 x
a  d  

 see above 

ddom a 

a
  x
a
  min

 eq    
 eq     

a
 u bx
a  d  
ddom a 

 

min

a
 x
a  d  

 see above 

ddom a 
a
  x
a

 eq    

a
a
a
a
at all times  thus  lbx
a   x a  w  x a   w  u bx a at all times  induction basis   now assume
that the lemma holds for all agents of depth d in the pseudo tree  induction assumption   we show
that it then also holds for all agents of depth d    in the pseudo tree each time after they update
their bounds  induction step   the lemma holds for agent a with context x a since

   

fiyeoh  felner   koenig



a
a
lbx
a  d    x a  d   

lba c
x a  d 

 eq    

cc a 



a
 x
a  d   

c
w  x
a  a d 

 induction assumption and lemma   

cc a 
a
 w  x
a  d 
a
a
u bx
a  d    x a  d   

 eq    



uba c
x a  d 

 eq     

cc a 



a
 x
a  d   

c
x
a  a d 

 induction assumption and lemma   

cc a 
a
  x
a  d 

 eq    

a
a
a
thus  lbx
a  d   w  x a  d   w  u bx a  d  at all times for all values d  dom a   furthermore 

a
lbx
a  



min

a
 lbx
a  d  

 eq     

ddom a 

min

a
 w  x
a  d  

 see above 

ddom a 

 w

min

a
 x
a  d  

ddom a 

a
  w  x
a
a
u bx
a

 


 eq    

a
min  u bx
a  d  
ddom a 

min

 eq     

a
 x
a  d  

 see above 

ddom a 

a
  x
a

 eq    

a
a
a
thus  lbx
a  w  x a  w  u bx a at all times 

definition    the potential of an agent a  a with context x a is
a
lbx
a  d   



ddom a   w

a
 u bx
a  d  

lemma    if the context x a of an arbitrary agent a  a no longer changes  then the potential of
the agent is monotonically non increasing and decreases by more than a positive constant every time
the agent changes its value 
a
a
proof  the lower bounds lbx
a  d  are monotonically non decreasing and the upper bounds u bx a  d 
are monotonically non increasing for all values d according to lemma   since the context x a of
agent a no longer changes  therefore  the potential of agent a is monotonically non increasing 
a
a
furthermore  agent a changes its value d to a new value only if minddom a   lbx
a  d     lbx a  d 
a
 line      thus  the lower bound lbx a  d  must have strictly increased between the time when the
agent changed its value to d and the time when it changes its value d to a new value  thus  its
potential has decreased by more than a positive constant  namely the smallest possible increase of the
a
lower bound lbx
a  d   assume that all constraint costs  weights and heuristic values are integers 
then  the smallest possible increase is bounded from below by one because the only possible values of
a
lbx
a  d  are combinations of all constraint costs and weighted heuristic values  a similar statement
holds if all constraint costs  weights and heuristic values are oating point numbers since they can
then all be transformed into integers by multiplying them with the same suciently large integer 

lemma    all agents change their values only a nite number of times 
   

fibnb adopt  an asynchronous branch and bound dcop algorithm

proof  assume that the lemma does not hold and choose an agent a that changes its value an
innite number of times but whose ancestor agents p  scp  a  change their values only a nite
number of times  then  there exists a time when the ancestor agents do not change their values
any longer  there exists a  later  time when agent a no longer changes its context x a according to
corollary    every time agent a changes its value afterwards  its potential decreases by more than
a positive constant according to lemma    towards minus innity  however  its potential cannot
a
a
become negative since lbx
a  d   w  u bx a  d  for all values d according to lemma    which is a
contradiction  thus  all agents change their values only a nite number of times 
a
lemma    if bnb adopt and its suboptimal variants do not terminate earlier  then u bx
a 
a
a
lbx a after a nite amount of time for all agents a  a and their contexts x  

proof  we prove the lemma by induction on the depth of an agent in the pseudo tree  there exists
a time when no agent changes its value any longer according to lemma    there exists a  later 
time when the contexts of all agents are correct and no longer change according to corollary    let
x a be the context of agent a at this point in time for all agents a  there exists an  even later 
a c
a
a
a
a
time when the bounds lba c
x a  d   lbx a  d   lbx a   ubx a  d   u bx a  d  and u bx a no longer change
a
for all agents a  all values d and all child agents c since     the lower bounds lba c
x a  d   lbx a  d  and
a c
a
a
a
lbx a are monotonically non decreasing and the upper bounds lbx a  d   u bx a  d  and u bx
a are
monotonically non increasing for all agents a  all values d and all child agents c according to lemma
a
a
a
a
a
a
       lbx
a  d   w  x a  d   w  u bx a  d  and lbx a  w  x a  w  u bx a for all agents a and
a c
a c
all values d according to lemma        lbx a  d   w  ubx a  d  for all agents a  all values d and all
child agents c according to lemma   and     the smallest possible increases of the lower bounds and
the smallest possible decreases of the upper bounds are larger than a positive constant since the
only possible values of the bounds are combinations of all constraint costs and heuristic values  as
explained in more detail in the proof of lemma    consider the rst cost message that each agent
sends after this time and the earliest time when all of these cost messages have been processed by
their receiving agents  the lemma holds for a leaf agent a in the pseudo tree with context x a since
a
a
lbx
a  d    x a  d 
a
  x
a  d 

 eq    
 eq    

a
a
u bx
a  d    x a  d 
a
  x
a  d 

 eq     
 eq    

for all values d after the considered time  furthermore 
a
lbx
a  

 

a
u bx
a

min

a
 lbx
a  d  

min

a
 x
a  d  

 eq     

ddom a 

 see above 

ddom a 

a
  x
a
  min

 eq    
 eq     

a
 u bx
a  d  
ddom a 

 

min

a
 x
a  d  

 see above 

ddom a 

a
  x
a

 eq    

a
a
after the considered time  thus  u bx
a   lbx a after the considered time  induction basis   now
assume that the lemma holds for all agents of depth d in the pseudo tree after the considered time
 induction assumption   we show that it then also holds for all agents of depth d    in the pseudotree after the considered time  induction step   for agent a with context x a

   

fiyeoh  felner   koenig

a
a
lbx
a  d    x a  d   



lba c
x a  d 

 eq    

c
max lba c
x a  d   lbx c  

 eq    

cc a 
a
  x
a  d   



cc a 
a
 x
a  d   



c
lbx
c

cc a 



a
x
a  d 

 



c
u bx
c

 induction assumption 

cc a 
a
 x
a  d   



c
min uba c
x a  d   u bx c  

cc a 

 

a
x
a  d 

 



uba c
x a  d 

 eq     

cc a 
a
  u bx
a  d 

 eq     

a
for its value d after the considered time since all bounds no longer change  thus  u bx
a  d  
a
 d 
for
its
value
d
after
the
considered
time 
since
agent
a
does
not
change
its
value
d after
lbx
a
a
a
a
a
the considered time  it must hold that lbx
 d 
 
min t
h
 
u
b
 
 line
   
or
lb
a
xa
xa
x a  d   
a
minddom a   lbx
 d  
 line
    
the
rst
disjunct
implies
that
a

a
a
a
min t hx
a   u bx a    u bx a
a
 u bx
a  d 
a
 lbx a  d 

 eq     
 see above 

a
a
  min t hx
a   u bx a  

 rst disjunct 

for its value d  which is a contradiction  the second disjunct implies that
a
a
u bx
a  u bx a  d 
a
 lbx
a  d 

 

min

 eq     
 see above 

a
 lbx
a  d  

 second disjunct 

ddom a 

a
  lbx
a

 eq     

a
a
for its value d and thus that u bx
a  lbx a  

theorem    bnb adopt and its suboptimal variants terminate after a nite amount of time 
a
a
proof  if bnb adopt and its suboptimal variants do not terminate earlier  then u bx
a  lbx a
after a nite amount of time for all agents a  a and their contexts x a according to lemma   
r
r
r
r
in particular  u bx
for the root agent r  where limr   lbx
r  lbx r  lim
r for bnb adopt
r
r
with
b

 
for
bnb adopt
and
limr   p  lbx
and bnb adoptw hm   limr   b   lbx
r
r
aem
with p    for bnb adoptrem according to section    thus  both the termination condition
r
r
r
r
u bx
of its suboptimal
r  lbx r of bnb adopt and the termination condition u bx r  lim
variants are satised 
r
theorem    bnb adopt terminates with the minimal solution cost x
r 

   

fibnb adopt  an asynchronous branch and bound dcop algorithm

proof  bnb adopt terminates after a nite amount of time according to theorem    the solution
r
r
r
cost of bnb adopt is the upper bound u bx
r of the root agent r  u bx r  lbx r upon termination
r
r
r
according to its termination condition  w  u bx r  w  x r  lbx r according to lemma   
r
r
r
therefore  u bx
r   x r   lbx r since w     
theorem    bnb adoptaem terminates with a solution cost that is bounded from above by the
r
user dened absolute error bound b plus the minimal solution cost x
r 
proof  bnb adoptaem terminates after a nite amount of time according to theorem    the
r
r
r
solution cost of bnb adoptaem is the upper bound u bx
r of the root agent r  u bx r  lim  
r
r
r
b   lbx r upon termination according to its termination condition  lbx r  w  x r according to
r
r
lemma    therefore  u bx
r  b   x r since w     
theorem    bnb adoptrem terminates with a solution cost that is bounded from above by the
r
user dened relative error bound p times the minimal solution cost x
r 
proof  bnb adoptrem terminates after a nite amount of time according to theorem    the
r
r
r
solution cost of bnb adoptrem is the upper bound u bx
r of the root agent r  u bx r  lim  
r
r
r
p  lbx r upon termination according to its termination condition  lbx r  w  x r according to
r
r
lemma    therefore  u bx
r  p  x r since w     
theorem    bnb adoptw hm terminates with a solution cost that is bounded from above by the
r
user dened weight w times the minimal solution cost x
r 
proof  bnb adoptw hm terminates after a nite amount of time according to theorem    the
r
r
r
solution cost of bnb adoptw hm is the upper bound u bx
r of the root agent r  u bx r  lim  
r
r
r
upon
termination
according
to
its
termination
condition 
lb

w


according
to
lbx
r
xr
xr
r
r
lemma    therefore  u bx

w


 
r
xr

   experimental evaluations
in this section  we compare bnb adopt to two other memory bounded dcop search algorithms
that also restrict communication to agents that share constraints  namely adopt and ncbb  we
also compare the three suboptimal variants of bnb adopt to each other  we use the distributed
dfs algorithm with the max degree heuristic  hamadi  bessiere    quinqueton        that is used
by adopt to construct the pseudo trees  we use dp   ali et al         that is used by adopt to
pre calculate the heuristic values for adopt and bnb adopt  dp  solves a relaxed version of the
given dcop problem  where backedges are ignored  with a dynamic programming based approach 
ncbb calculates its own heuristic values during the search rather than in a pre processing step 
    runtime metrics
we use two common runtime metrics  namely non concurrent constraint checks  meisels  kaplansky 
razgon    zivan        and cycles  modi et al         
 non concurrent constraint checks  ncccs   ncccs are a weighted sum of processing
and communication time  every agent a maintains a counter n ccc a   which is initialized
to    the agent assigns n ccc a    n ccc a     every time it performs a constraint check
to account for the time it takes to perform the constraint check  it assigns n ccc a   

max n ccc a   n ccc a   t  every time it receives a message from agent a to account for the

time it takes to wait for agent a to send the message  n ccc a   and the transmission time
of the message  t   we use t     to simulate fast communication and t        to simulate
slow communication  the number of ncccs then is the largest counter value of any agent 

   

fiyeoh  felner   koenig

sensors
 
 

 

targets
 

 

 

 

 

 
  

  

  

  

constraints

a unit

figure     example  allocating targets

figure     example  scheduling meetings

ncccs are a good runtime metric if the ratio of processing and communication time can be
estimated reliably 
 cycles  cycles are time slices  a cycle is the time required for an agent to process all incoming
messages in its queue and send all outgoing messages  which are then processed by the receiving
agents in the next cycle  thus  the number of cycles indicates the length of the longest chain
of messages between agents  cycles are a good runtime metric if the communication time is
much larger than the processing time  cycles will become a better and better runtime metric
in the future since the communication time is expected to remain relatively stable while the
processing time is expected to decrease  silaghi  lass  sultanik  regli  matsui    yokoo        
    dcop problem types
we use three dcop problem types in our experiments  namely graph coloring problems  sensor
network problems and meeting scheduling problems 
 graph coloring  graph coloring problems involve coloring the vertices of a graph  taking
restrictions between the colors of adjacent vertices into account  the agents are the vertices 
their domains are the colors  and the constraints are between adjacent vertices  we vary the
number of vertices from   to     the constraint density    the ratio between the number of
constraints and the number of agents  from    sparse graphs  to    dense graphs  and the
range of constraint costs from a range of   to    small range  to a range of   to         large
range   each agent always has three possible values  we average the experimental results over
   dcop problem instances with randomly generated constraints and randomly generated
integer constraint costs 
 sensor network  sensor network problems involve assigning targets to sensors in a sensor
network  taking restrictions in the availability of the sensors  restrictions in the number of
sensors that need to track each target and the priorities of the targets into account  the
agents are the targets  their domains are the time slots when they can be tracked  and the
constraints are between adjacent targets  maheswaran et al       b   figure    shows a sensor
network where the targets are located on a grid and each target is surrounded by four sensors 
all of which are needed to track the target  we vary the number of targets from   to     we
always use   time slots  the cost of assigning a time slot to a target that is also assigned to an
adjacent target is innity  to be precise             since the same sensor cannot track both
targets during the same time slot  the cost of targets that are not tracked during any time
slot is      all other costs are in the range of   to      we average the experimental results
over    dcop problem instances with randomly generated integer constraint costs 
 meeting scheduling  meeting scheduling problems involve scheduling meetings between the
employees of a company  taking restrictions in their availability as well as their priorities into
account  the agents are the meetings  their domains are the time slots when they can be
held  and the constraints are between meetings that share participants  maheswaran et al  
   

fibnb adopt  an asynchronous branch and bound dcop algorithm

graph coloring  density    
communication cost    

graph coloring  density    
communication cost       

  e   
adopt
bnb adopt
ncbb

  e   

nccc

nccc

  e   

  e   
  e   

adopt
bnb adopt
ncbb

  e   
  e   
  e   

 

 

 

 

 

  

  

  

  

  

 

 

 

number of vertices

 

 

 a 
graph coloring  density    

  

  

  

graph coloring  density    
communication cost    

  e   

adopt
bnb adopt
ncbb

nccc

  e   
cycles

  

 b 

  e   

  e   
adopt
bnb adopt
ncbb

  e   
  e   
  e   

  e   
 

 

 

 
 
     
number of vertices

  

  

 

  

 

 

  

  

  

  

 d 

graph coloring  density    
communication cost       

  e   

  

number of vertices

 c 

graph coloring  density    
  e   

cycles

adopt
bnb adopt
ncbb

  e   
nccc

  

number of vertices

  e   
  e   
  e   

  e   
adopt
bnb adopt
ncbb

  e   
  e   

 

 

 

  

  

  

  

  

 

 

 

  

  

  

  

  

number of vertices

number of vertices

 e 

 f 

figure     experimental results comparing adopt  bnb adopt and ncbb for graph coloring
problems with constraint costs ranging from   to       

    b   figure    shows a hierarchical organization with   units of a supervisor and its three
subordinates  for example  supervisor   has three subordinates      and    in each unit  we
assume ve possible meetings  one of the entire unit  e g                two parent child meetings
 e g        and       and two sibling sibling meetings  e g        and        we vary the number
of meetings from      unit  to       units   we always use   time slots  the cost of assigning
a time slot to a meeting that has at least one participant who has another meeting during the
same time slot is innity  to be precise             since the same person cannot attend more
than one meeting at a time  the cost of a non scheduled meeting is      all other costs are in
the range of   to      we average the experimental results over    dcop problem instances
with randomly generated integer constraint costs 

   

fiyeoh  felner   koenig

  e   

graph coloring  density    
communication cost    

  e   
  e   
nccc

nccc

  e   

graph coloring  density    
communication cost       

  e   
adopt
bnb adopt
ncbb

  e   

  e   
adopt
bnb adopt
ncbb

  e   

  e   

  e   
   

    

     

                

   

range of constraint costs

    

     

                

range of constraint costs

 a 

 b 

graph coloring  density    
  e   

  e   

graph coloring  density    
communication cost    

nccc

cycles

  e   
  e   
adopt
bnb adopt
ncbb

  e   

  e   
  e   

adopt
bnb adopt
ncbb

  e   

  e   

  e   
   

    

     

                

   

range of constraint costs

 c 

  e   

     

                

 d 

graph coloring  density    
communication cost       

graph coloring  density    
  e   

  e   

  e   
cycles

nccc

    

range of constraint costs

  e   
  e   

adopt
bnb adopt
ncbb

  e   

  e   

adopt
bnb adopt
ncbb

  e   

  e   

  e   
   

    

     

                

range of constraint costs

   

    

     

                

range of constraint costs

 e 

 f 

figure     experimental results comparing adopt  bnb adopt and ncbb for graph coloring
problems with    vertices

    experimental results  optimal dcop search algorithms
we rst compare bnb adopt to adopt and ncbb  figure    shows our experimental results
for graph coloring problems with constraint costs ranging from   to         where we varied the
number of vertices  while figure    shows our experimental results for graph coloring problems
with    vertices  where we varied the range of constraint costs  figures    a c  and    a c  show
the results for coloring sparse graphs  and figures    d f  and    d f  show the results for coloring
dense graphs  the y axes are in log scale and show the runtimes in ncccs or cycles  dcop search
algorithms on sparse graphs are faster than on dense graphs because  for example  there is a larger
likelihood of independent dcop subproblems in sparse graphs  bnb adopt is generally faster
than ncbb on sparse graphs but not on dense graphs because bnb adopt allows agents to send
messages only to their parent agents in the pseudo tree  along edges of the pseudo tree  but ncbb

   

fibnb adopt  an asynchronous branch and bound dcop algorithm

sensor network
communication cost       

  e   

  e   

  e   

  e   
nccc

nccc

sensor network
communication cost    

  e   
  e   

adopt
bnb adopt
ncbb

  e   

adopt
bnb adopt
ncbb

  e   
  e   
  e   

  e   

  e   
 

 

 

 

                       
number of targets

 

 

 a 

 b 

sensor network

meeting scheduling
communication cost    

  e   

  e   
adopt
bnb adopt
ncbb

  e   
nccc

cycles

  e   
  e   
  e   

  e   
adopt
bnb adopt
ncbb

  e   

  e   

  e   
 

 

 

 

                       
number of targets

 

 

 c 

  

  

  

meeting scheduling
  e   

  e   

  e   
cycles

  e   

  e   
adopt
bnb adopt
ncbb

  e   

 
          
number of meetings

 d 

meeting scheduling
communication cost       

nccc

                       
number of targets

  e   
adopt
bnb adopt
ncbb

  e   

  e   

  e   
 

 

 

 
          
number of meetings

  

  

  

 e 

 

 

 

 
          
number of meetings

  

  

  

 f 

figure     experimental results comparing adopt  bnb adopt and ncbb for sensor network
and meeting scheduling problems

allows agents also to send messages to their pseudo parent agents  along backedges of the pseudotree   thus  agents of ncbb receive updates faster than agents of bnb adopt  this eect is more
prevalent in dense graphs since there are more backedges in dense graphs  however  the dierence
between bnb adopt and ncbb becomes negligible when communication is slow 
figure    shows that bnb adopt is at least half an order of magnitude faster than adopt
when the number of vertices is small  the speedup over adopt increases as the number of vertices
gets larger and the dcop problems thus become more complex  similarly  figure    shows that the
speedup over adopt increases as the range of constant costs increases and the dcop problems
thus become more complex  however  adopt can be faster than bnb adopt for simple dcop
problems  for example  adopt requires fewer cycles than bnb adopt for dcop problems with
constraint costs ranging from   to    figure    shows the same trend for sensor network and meeting
scheduling problems  the reason for this behavior is as follows  adopt uses memory bounded best   

fiyeoh  felner   koenig

sensor network
communication cost    

  e   

sensor network
communication cost       

  e   

nccc

nccc

  e   
  e   
adopt

  e   

  e   
adopt

bnb adopt

bnb adopt

  e   

  e   
   

   

   
   
weight

   

 

   

   

 a 

   

 

   

 

 b 

sensor network
  e   

sensor network
unique contexts explored

  e   
no  of
contexts

cycles

   
   
weight

  e   
adopt

adopt
bnb adopt

bnb adopt

  e   

  e   
   

   

   
   
weight

   

 

   

   

 c 

   
   
weight

 d 
sensor network
repeated contexts explored

no  of
contexts

  e   
  e   

adopt
bnb adopt

  e   
  e   
   

   

   
   
weight

   

 

 e 

figure     experimental results on the cause of speedup for adopt and bnb adopt
rst search and thus exploits the heuristic values well but needs to repeatedly reconstruct partial
solutions that it purged from memory  especially if the heuristic values are poorly informed  bnbadopt uses depth rst branch and bound search and thus does not exploit the heuristic values
quite as well but does not have to repeatedly reconstruct partial solutions  adopt can thus be
faster than bnb adopt for dcop problems with well informed heuristic values  such as simple
dcop problems 
we conrm this intuition with an additional experiment on sensor network problems with four
targets and dierent informedness of heuristic values  we use the heuristic values cha c
x a  d  for     
c     where ha c
x a  d  are the heuristic values calculated by dp   as used until now  figures    a c 
show the number of ncccs for dierent weights c  when the heuristic values are well informed  large
weights   adopt can indeed be faster than bnb adopt  since adopt relies on the heuristic
values more than bnb adopt  the speedup of adopt is much larger than that of bnb adopt
as the heuristic values get more informed  figures    d  and    e  show the number of unique

   

fibnb adopt  an asynchronous branch and bound dcop algorithm

   dierent  and repeated contexts per agent for dierent weights c  when the heuristic values are
well informed  large weights   agents of adopt explore fewer unique contexts than agents of bnbadopt since they are more focused in their search  however  when the heuristic values are poorly
informed  small weights   they explore more unique contexts  agents of adopt explore many more
repeated contexts than agents of bnb adopt since they need to reconstruct partial solutions that
they purged from memory  agents of bnb adopt explore a few repeated contexts even though it
does not have to reconstruct partial solutions  the reason for this behavior is the distributed nature
of bnb adopt  for example  assume that the context of an agent is   a         a        and the next
context of a centralized variant of bnb adopt would be   a         a         where the ids are omitted
for simplicity   the agent updates its context to   a         a        when it receives the message from
agent a  that it takes on value    the agent then updates its context to   a         a        when it
receives the message from agent a  that it takes on value    thus  the agent explores the intermediate
context   a         a        that a centralized variant of bnb adopt would not explore  it counts as a
repeated context if the agent explores this context intentionally in the future  overall  bnb adopt
tends to be faster than adopt if the heuristic values are poorly informed  small weights   thus 
bnb adopt has great potential as a dcop search algorithm since heuristic values are often poorly
informed for complex dcop problems  such as dcop problems with large numbers of agents  large
domains  large numbers of constraints or large ranges of constraint costs 
    experimental results  suboptimal variants of bnb adopt
we now compare the three suboptimal variants of bnb adopt to each other  the experimental
setup is identical to the one for the optimal dcop search algorithms  except as follows  for graph
coloring problems  the number of vertices is     the range of constraint costs is   to        and the
constraint density is    for sensor network problems  the number of targets is    and for meeting
scheduling problems  the number of meetings is     we measure the runtimes in cycles   the results
for ncccs are similar   however  we report normalized runtimes  that is  the runtimes divided by
the runtime for nding a cost minimal solution with bnb adopt  thus  the normalized runtime
     refers to one quarter of the number of cycles that it takes to nd a cost minimal solution with
bnb adopt  similarly  we report normalized solution costs  that is  the solution costs divided by
the minimal solution costs  thus  the normalized solution cost     refers to a solution cost that is
two and a half times larger than the minimal solution cost  we vary the relative error bound  which
is the worst acceptable normalized solution cost  from     to      the relative error bound is p for
bnb adoptrem and w for bnb adoptw hm   we pre calculate the minimal solution costs to
set the correct value of b for bnb adoptaem   for example  if the minimal solution cost is     and
the relative error bound is      then p       for bnb adoptrem   w       for bnb adoptw hm
and b                       for bnb adoptaem  
figure    a c  shows our experimental results for graph coloring problems  figure    a  shows
that the normalized solution costs of all three suboptimal variants increase as the relative error
bound increases  however  the solution costs remain much smaller than the error bound  for
example  the normalized solution costs of all three suboptimal variants are less than      rather
than    when the relative error bound is    the normalized solution costs of bnb adoptaem are
usually larger than the normalized solution costs of bnb adoptrem for the same relative error
r
r
bound  the reason for this behavior is that bnb adoptaem terminates when u bx
 
r  lim
r
r
r
r
b   lbx r    p      x r   lbx r   where x r is the minimal solution cost  thus  the solution cost of
r
r
r
bnb adoptaem can be at most u bx
r  lbx r   p      x r larger than the minimal solution
r
r
r
cost  on the other hand  bnb adoptrem terminates when u bx
r  lim   p  lbx r   thus  the
r
r
r
solution cost of bnb adoptrem can be at most u bx r  lbx r   p      lbx r larger than the
minimal solution cost  the absolute error bound of bnb adoptaem is thus no smaller than the
r
r
absolute error bound of bnb adoptrem since x
r  lbx r but is initially strictly greater than
r
r
the absolute error bound of bnb adoptrem since x r   lbx
r during most of the search 

   

fiyeoh  felner   koenig

graph coloring
solution cost of bnb adopt variants

graph coloring
computation time of bnb adopt variants
    
normalized runtimes
 cycles 

normalized costs

    
    
    
    
    

weighted heuristics  whm 
absolute error  aem 
relative error  rem 

    
    
    
    

    

    
    
    
relative error bound

    

    

    
    
    
    

    

weighted heuristics  whm 
absolute error  aem 
relative error  rem 

    

    

    
    
    
relative error bound

 a 
graph coloring
performance of bnb adopt variants

sensor network
performance of bnb adopt variants
    

    

normalized runtimes
 cycles 

normalized runtimes
 cycles 

    

 b 

    
weighted heuristics  whm 
absolute error  aem 
relative error  rem 

    
    
    
    
    

    

    

    
    
    
normalized costs

    

    

    

weighted heuristics  whm 
absolute error  aem 
relative error  rem 

    
    
    
    
    

    

    

 c 

    
    
    
normalized costs

    

    

 d 
meeting scheduling
performance of bnb adopt variants
normalized runtimes
 cycles 

    
    

weighted heuristics  whm 
absolute error  aem 
relative error  rem 

    
    
    
    
    

    

    
    
normalized costs

    

    

 e 

figure     experimental results comparing the suboptimal variants of bnb adopt
figure    b  shows that the normalized runtimes of all three suboptimal variants decrease as the
relative error bound increases  they decrease to almost   when the relative error bound is about     
therefore  all three suboptimal variants terminate almost immediately after nding the rst solution 
the normalized runtimes of bnb adoptaem are usually smaller than the normalized runtimes of
bnb adoptrem for the same relative error bound since bnb adoptaem can terminate with a
suboptimal solution cost that is within its absolute error bound but not yet within the absolute error
bound of bnb adoptrem if the absolute error bound of bnb adoptaem is strictly greater than
the absolute error bound of bnb adoptrem   in other words  bnb adoptaem can terminate
r
r
r
with a suboptimal solution cost  p      lbx
r   u bx r   p      x r while bnb adoptrem can
not 
figure    c  shows the normalized runtimes needed to achieve a given normalized solution cost 
bnb adoptw hm terminates faster than bnb adoptaem   which in turn terminates faster than
bnb adoptrem   for example  the normalized runtime needed to achieve the normalized solu 

   

fibnb adopt  an asynchronous branch and bound dcop algorithm

tion cost      is about      for bnb adoptw hm        for bnb adoptaem and      for bnbadoptrem   thus  bnb adoptw hm is the suboptimal variant of bnb adopt with the best
performance  figures    d e  show the same trend for sensor network and meeting scheduling problems 

   conclusions
in this article  we introduced branch and bound adopt  bnb adopt   a memory bounded
dcop search algorithm  bnb adopt uses the message passing and communication framework
of adopt but changes the search strategy of adopt from best rst search to depth rst branchand bound search to make adopt faster by taking advantage of the fact that dcop problems have
depth bounded search trees  the other properties of bnb adopt are similar to those of adopt 
bnb adopt allows agents to operate concurrently  in order to decrease the runtime  and asynchronously  in order to increase robustness   bnb adopt restricts communication to agents that
share constraints  in order to t the restrictions of applications such as sensor networks   finally 
bnb adopt orders agents into a pseudo tree  in order to take advantage of independent dcop
subproblems   our experimental results showed that bnb adopt nds cost minimal solutions up
to one order of magnitude faster than adopt for a variety of large dcop problems and is as fast
as ncbb for most of these dcop problems  the reason for this behavior is the following  agents
of ncbb operate sequentially and are thus often idle  adopt can construct fewer partial solutions
than bnb adopt but has to reconstruct some partial solutions that it purged from memory  the
advantage of adopt with respect to the number of constructed partial solutions decreases and
its disadvantage with respect to the number of reconstructed partial solutions increases as heuristic
values become more poorly informed  thus  bnb adopt has great potential as a dcop search
algorithm since heuristic values are often poorly informed for complex dcop problems such as
dcop problems with large numbers of agents  large domains  large numbers of constraints or large
ranges of constraint costs 
we also investigated three approximation mechanisms that trade o the solution cost of bnbadopt for a smaller runtime  namely the absolute error mechanism from adopt  resulting in
bnb adoptaem    the new relative error mechanism  resulting in bnb adoptrem   and the
new weighted heuristics mechanism  resulting in bnb adoptw hm    the two new approximation mechanisms allow users to specify a relative error bound  which is often more meaningful than
an absolute error bound  the weighted heuristics mechanism dominated both the absolute error mechanism and the relative error mechanism in our experiments and should apply to other
dcop search algorithms as well since they all benet from using heuristic values to focus their
searches  yeoh  koenig    sun      b  
in the future  we plan to improve bnb adopt in the following ways  first  we would like to
reduce the number of sent messages and handle lost messages  second  we would like to study
how dierent pseudo tree arrangements  atlas   decker        sultanik  lass    regli        and
pre processing techniques  matsui et al         aect the eciency of bnb adopt  finally  we
would like to compare bnb adopt and its approximation mechanisms to other dcop algorithms 
including optapo  dpop and their variants  petcu   faltings      a        

acknowledgments
this article is an extension of two earlier publications  yeoh  felner    koenig      a  yeoh et al  
    b  and contains additional expositions  examples and proofs  we thank anton chechetka for
providing us with his implementation of ncbb and the anonymous reviewers for their helpful
comments  this research was done while ariel felner spent his sabbatical at the university of
southern california  visiting sven koenig  this research has been partly supported by a u s  army

   

fiyeoh  felner   koenig

research laboratory  arl  and u s  army research oce  aro  award to sven koenig under
grant w   nf            by a oce of naval research  onr  award to sven koenig under grant
n                 by a national science foundation  nsf  award to sven koenig under grant
        and by an israeli science foundation  isf  award to ariel felner under grants        and
        the views and conclusions contained in this document are those of the authors and should
not be interpreted as representing the ocial policies  either expressed or implied  of the sponsoring
organizations  agencies  companies or the u s  government 

references
ali  s   koenig  s     tambe  m          preprocessing techniques for accelerating the dcop
algorithm adopt  in proceedings of the international joint conference on autonomous
agents and multiagent systems  aamas   pp           
atlas  j     decker  k          a complete distributed constraint optimization method for nontraditional pseudotree arrangements  in proceedings of the international joint conference on
autonomous agents and multiagent systems  aamas   pp         
bayardo  r     miranker  d          on the space time trade o in solving constraint satisfaction problems  in proceedings of the international joint conference on articial intelligence
 ijcai   pp         
bistarelli  s   montanari  u   rossi  f   schiex  t   verfaillie  g     fargier  h          semiring based
csps and valued csps  basic properties and comparison  constraints                
bowring  e   pearce  j   portway  c   jain  m     tambe  m          on k optimal distributed
constraint optimization algorithms  new bounds and algorithms  in proceedings of the international joint conference on autonomous agents and multiagent systems  aamas   pp 
       
bowring  e   tambe  m     yokoo  m          multiply constrained distributed constraint optimization  in proceedings of the international joint conference on autonomous agents and
multiagent systems  aamas   pp           
burke  d     brown  k          eciently handling complex local problems in distributed constraint
optimisation  in proceedings of the european conference on articial intelligence  ecai   pp 
       
chechetka  a     sycara  k          no commitment branch and bound search for distributed
constraint optimization  in proceedings of the international conference on autonomous agents
and multiagent systems  aamas   pp           
choxi  h     modi  p          a distributed constraint optimization approach to wireless network
optimization  in proceedings of the aaai    workshop on conguration  pp     
davin  j     modi  p          hierarchical variable ordering for multiagent agreement problems 
in proceedings of the international joint conference on autonomous agents and multiagent
systems  aamas   pp           
dechter  r   ed            constraint processing  morgan kaufmann 
fitzpatrick  s     meertens  l          distributed coordination through anarchic optimization 
in lesser  v   ortiz  c     tambe  m   eds    distributed sensor networks  a multiagent
perspective  pp          kluwer 
freuder  e     quinn  m          taking advantage of stable sets of variables in constraint satisfaction problems  in proceedings of the international joint conference on articial intelligence
 ijcai   pp           

   

fibnb adopt  an asynchronous branch and bound dcop algorithm

gershman  a   meisels  a     zivan  r          asynchronous forward bounding for distributed
cops  journal of articial intelligence research           
greenstadt  r          an overview of privacy improvements to k optimal dcop algorithms  extended abstract   in proceedings of the international joint conference on autonomous agents
and multiagent systems  aamas   pp           
greenstadt  r   grosz  b     smith  m          ssdpop  improving the privacy of dcop with
secret sharing  in proceedings of the international joint conference on autonomous agents
and multiagent systems  aamas   pp           
hamadi  y   bessiere  c     quinqueton  j          distributed intelligent backtracking  in proceedings of the european conference on articial intelligence  ecai   pp         
hirayama  k     yokoo  m          distributed partial constraint satisfaction problem  in proceedings of the international conference on principles and practice of constraint programming
 cp   pp         
jain  m   taylor  m   tambe  m     yokoo  m          dcops meet the real world  exploring
unknown reward matrices with applications to mobile sensor networks  in proceedings of the
international joint conference on articial intelligence  ijcai   pp         
junges  r     bazzan  a          evaluating the performance of dcop algorithms in a real world 
dynamic problem  in proceedings of the international joint conference on autonomous agents
and multiagent systems  aamas   pp         
korf  r          linear space best rst search  articial intelligence               
kumar  a   faltings  b     petcu  a          distributed constraint optimization with structured
resource constraints  in proceedings of the international joint conference on autonomous
agents and multiagent systems  aamas   pp         
lesser  v   ortiz  c     tambe  m   eds            distributed sensor networks  a multiagent
perspective  kluwer 
maheswaran  r   pearce  j     tambe  m       a   distributed algorithms for dcop  a graphical game based approach  in proceedings of the international conference on parallel and
distributed computing systems  pdcs   pp         
maheswaran  r   tambe  m   bowring  e   pearce  j     varakantham  p       b   taking dcop to
the real world  ecient complete solutions for distributed event scheduling  in proceedings of
the international joint conference on autonomous agents and multiagent systems  aamas  
pp         
mailler  r     lesser  v          solving distributed constraint optimization problems using cooperative mediation  in proceedings of the international joint conference on autonomous agents
and multiagent systems  aamas   pp         
marinescu  r     dechter  r          best rst and or search for graphical models  in proceedings
of the aaai conference on articial intelligence  aaai   pp           
marinescu  r     dechter  r          and or branch and bound search for combinatorial optimization in graphical models  articial intelligence                        
matsui  t   silaghi  m   hirayama  k   yokoo  m     matsuo  h          directed soft arc consistency
in pseudo trees  in proceedings of the international joint conference on autonomous agents
and multiagent systems  aamas   pp           
meisels  a   kaplansky  e   razgon  i     zivan  r          comparing performance of distributed
constraints processing algorithms  in proceedings of the distributed constraint reasoning
workshop  pp       

   

fiyeoh  felner   koenig

modi  p     ali  s          distributed constraint reasoning under unreliable communication  in
zhang  w     sorge  v   eds    frontiers in articial intelligence and applications  vol      
pp          ios press 
modi  p   shen  w  m   tambe  m     yokoo  m          adopt  asynchronous distributed constraint optimization with quality guarantees  articial intelligence                    
ottens  b     faltings  b          coordinating agent plans through distributed constraint optimization  in proceedings of the icaps    workshop on multiagent planning 
pearce  j     tambe  m          quality guarantees on k optimal solutions for distributed constraint
optimization problems  in proceedings of the international joint conference on articial
intelligence  ijcai   pp           
pecora  f   modi  p     scerri  p          reasoning about and dynamically posting n ary constraints
in adopt  in proceedings of the distributed constraint reasoning workshop  pp       
petcu  a     faltings  b       a   approximations in distributed optimization  in proceedings of
the international conference on principles and practice of constraint programming  cp   pp 
       
petcu  a     faltings  b       b   a scalable method for multiagent constraint optimization  in
proceedings of the international joint conference on articial intelligence  ijcai   pp      
     
petcu  a     faltings  b          odpop  an algorithm for open distributed constraint optimization  in proceedings of the national conference on articial intelligence  aaai   pp         
pohl  i          first results on the eect of error in heuristic search  machine intelligence    
       
pohl  i          the avoidance of  relative  catastrophe  heuristic competence  genuine dynamic
weighting and computational issues in heuristic problem solving  in proceedings of the international joint conference on articial intelligence  ijcai   pp       
schiex  t   fargier  h     verfaillie  g          valued constraint satisfaction problems  hard and
easy problems  in proceedings of the international joint conference on articial intelligence
 ijcai   pp         
schurr  n   okamoto  s   maheswaran  r   scerri  p     tambe  m          evolution of a teamwork
model  in sun  r   ed    cognition and multi agent interaction  from cognitive modeling to
social simulation  pp          cambridge university press 
silaghi  m   landwehr  j     larrosa  j          asynchronous branch   bound and a  for diswcsps
with heuristic function based on consistency maintenance  in zhang  w     sorge  v   eds   
frontiers in articial intelligence and applications  vol       pp        ios press 
silaghi  m   lass  r   sultanik  e   regli  w   matsui  t     yokoo  m          the operation point
units of distributed constraint solvers  in proceedings of the distributed constraint reasoning
workshop  pp      
silaghi  m     yokoo  m          adopt ing  unifying asynchronous distributed optimization with
asynchronous backtracking  autonomous agents and multi agent systems                
stranders  r   farinelli  a   rogers  a     jennings  n          decentralised coordination of mobile
sensors using the max sum algorithm  in proceedings of the international joint conference
on articial intelligence  ijcai   pp         
sultanik  e   lass  r     regli  w          dynamic conguration of agent organizations  in
proceedings of the international joint conference on articial intelligence  ijcai   pp     
    

   

fibnb adopt  an asynchronous branch and bound dcop algorithm

yeoh  w   felner  a     koenig  s       a   bnb adopt  an asynchronous branch and bound
dcop algorithm  in proceedings of the international joint conference on autonomous agents
and multiagent systems  aamas   pp         
yeoh  w   koenig  s     sun  x       b   trading o solution cost for smaller runtime in dcop
search algorithms  short paper   in proceedings of the international joint conference on
autonomous agents and multiagent systems  aamas   pp           
yeoh  w   varakantham  p     koenig  s          caching schemes for dcop search algorithms 
in proceedings of the international joint conference on autonomous agents and multiagent
systems  aamas   pp         
yokoo  m     hirayama  k          distributed breakout algorithm for solving distributed constraint
satisfaction problems  in proceedings of the international conference on multiagent systems
 icmas   pp         
zhang  w     korf  r          performance of linear space search algorithms  articial intelligence 
               
zhang  w   xing  z   wang  g     wittenburg  l          an analysis and application of distributed
constraint satisfaction and optimization algorithms in sensor networks  in proceedings of the
international joint conference on autonomous agents and multiagent systems  aamas  
pp         
zivan  r          anytime local search for distributed constraint optimization  in proceedings of
the aaai conference on articial intelligence  aaai   pp         
zivan  r   glinton  r     sycara  k          distributed constraint optimization for large teams
of mobile sensing agents  in proceedings of the international conference on intelligent agent
technology  iat   pp         

   

fi