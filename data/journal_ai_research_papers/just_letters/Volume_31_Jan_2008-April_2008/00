journal artificial intelligence research               

submitted       published      

ini ax at  efficient weighted max sat solver
federico heras
javier larrosa
albert oliveras

fheras   lsi   upc   edu
larrosa   lsi   upc   edu
oliveras   lsi   upc   edu

technical university catalonia  lsi department
jordi girona             barcelona  spain 

abstract
paper introduce ini ax at  new max sat solver built top incorporates best current sat max sat techniques  handle hard clauses
 clauses mandatory satisfaction sat   soft clauses  clauses whose falsification penalized cost max sat  well pseudo boolean objective functions constraints 
main features are  learning backjumping hard clauses  resolution based substractionbased lower bounding  lazy propagation two watched literal scheme  empirical
evaluation comparing wide set solving alternatives broad set optimization benchmarks
indicates performance ini ax usually close best specialized alternative
and  cases  even better 
  

   introduction
max sat optimization version sat goal satisfy maximum number
clauses  considered one fundamental combinatorial optimization problems many important problems naturally expressed max sat  include academic problems
max cut max clique  well real problems domains routing  bioinformatics  scheduling
electronic markets 
long tradition theoretical work structural complexity  papadimitriou 
      approximability  karloff   zwick        max sat  work restricted
simplest case clauses equally important  i e   unweighted max sat 
fixed size  mainly binary ternary   practical point view  significant progress
made last   years  shen   zhang        larrosa   heras        larrosa  heras    de givry 
      xing   zhang        li  manya    planes               result  handful
new solvers deal  first time  instances involving hundreds variables 
main motivation work comes study max sat instances modelling realworld problems  usually encounter three features 
satisfaction clauses importance  clause needs
associated weight represents cost violation  extreme case 
often happens practice observed cha  iwama  kambayashi  miyazaki        
clauses whose satisfaction mandatory  usually modelled associating
high weight them 
literals appear randomly along clauses  contrary  easy identify
patterns  symmetries kinds structures 
c
    
ai access foundation  rights reserved 

fih eras   l arrosa     liveras

problems mandatory clauses reduce dramatically number feasible
assignments  optimization part problem plays secondary role  however 
problems mandatory clauses trivially satisfiable real difficulty lays
optimization part 
look current max sat solvers  find none robust three
features  instance  li et al s              solvers restricted formulas clauses
equally important  i e  unweighted max sat   shen zhangs        one restricted binary clauses  one described larrosa et al         seems efficient overconstrained
problems  i e   small fraction clauses simultaneously satisfied   one
alsinet  manya  planes        seems efficient slightly overconstrained problems  i e 
almost clauses satisfied   solver described argelich manya         developed parallel research described paper  handle mandatory clauses
one incorporates learning  seems perform well structured problems  however 
non mandatory clauses must weight  finally  approaches based translating
max sat instance sat instance solve sat solver seem effective
highly structured problems almost clauses mandatory  fu   malik        le berre 
      
paper introduce ini ax at  new weighted max sat solver incorporates
current best sat max sat techniques  build top ini    een   sorensson 
       borrows capability deal pseudo boolean problems ini  een
  sorensson        features processing mandatory clauses learning backjumping 
extended allowing deal weighted clauses  preserving two watched literal
lazy propagation method  main original contribution ini ax implements
novel efficient lower bounding technique  specifically  applies unit propagation
order detect disjoint subsets mutually inconsistent clauses done li et al         
simplifies problem following larrosa heras         heras larrosa         larrosa
et al         order increment lower bound  however  works clauses
accomplish specific patterns transformed  ini ax need define
patterns 
structure paper follows  section   provides preliminary definitions sat
section   presents state of the art solving techniques incorporated modern sat solver
ini at  then  section   presents preliminary definitions max sat section   overviews
ini ax at  that  sections     focus lower bounding additional features 
respectively  section   present benchmarks used empirical evaluation
report experimental results  finally  section   presents related work section    concludes
points possible future work 

   preliminaries sat
sequel x    x    x            xn   set boolean variables  literal either variable xi
negation xi   variable literal l refers noted var l   given literal l  negation l xi
l xi xi l xi   clause c disjunction literals  size clause  noted  c  
number literals has  set variables appear c noted var c   sometimes
associate subscript greek letter clause  e g   xi x j     order facilitate future references
clause 
 

fim ini ax at 



e fficient w eighted ax  sat olver

algorithm    dpll basic structure 
function search     boolean
 
initqueue     
 
loop
 
up     
 
conflict
 
analyzeconflict     
 
top conflict return f alse  
else
 
learnclause     
 
backjump     
 
  
  
  

else variables assigned return true  
else
l    selectliteral     
enqueue q  l   

assignment set literals containing variable negation  assignments
maximal size n called complete  otherwise called partial  given assignment  
variable x unassigned neither x x belong   similarly  literal l unassigned var l 
unassigned 
assignment satisfies literal iff belongs assignment  satisfies clause iff satisfies
one literals falsifies clause iff contains negation literals 
latter case say clause conflicting always happens empty clause  noted
   boolean formula f conjunctive normal form  cnf  set clauses representing
conjunction  model f complete assignment satisfies clauses f  
f model  call satisfiable  otherwise say unsatisfiable  moreover 
complete assignments satisfy f   say f tautology 
clauses size one called unit clauses simply units  formula contains unit l 
simplified removing clauses containing l removing l clauses
appears  application rule quiescence called unit propagation  up  well
recognized fundamental propagation technique current sat solvers 
another well known rule resolution  which  given formula containing two clauses
form  x a    x b   called clashing clauses   allows one add new clause  a b   called
resolvent  

   overview state of the art dpll based sat solvers
section overview architecture sat solvers based dpll  davis  logemann 
  loveland        procedure  procedure  currently regarded efficient complete
search procedure sat  performs systematic depth first search space assignments 
internal node associated partial assignment two successors obtained selecting
unassigned variable x extending current assignment x x  respectively 
visited node  new units derived due application unit propagation  up   leads
 

fih eras   l arrosa     liveras

algorithm    unit propagation 
function up q    conflict
 q contains non propagated literals 
  
l    getfirstnonpropagatedlit q   markaspropagated l   
  
foreach clause c l becomes unit falsified
  
c l becomes unit q enqueue q  q   
  
else c l becomes falsified return conflict  
return none  

conflicting clause  procedure backtracks  performing non chronological backtracking
clause learning  originally proposed silva sakallah        
algorithmic description dpll procedure appears algorithm    algorithm uses
propagation queue q contains units pending propagation contains representation
current assignment 
first  propagation queue q filled units contained original formula  line    
main loop starts line   iteration procedure charge propagating pending
units  line     conflicting clause found  line     conflict analyzed  line    result
new clause learned  i e  inferred recorded  line    
then  procedure backtracks  using propagation queue q undo assignment
exactly one literals learned clause becomes unassigned  line     one
backtrack still maintaining condition  advantageous  this commonly referred backjumping non chronological backtracking  see silva   sakallah        
leads conflict  new unassigned literal selected extend current partial assignment 
new literal added q  line     new iteration takes place 
procedure stops complete assignment found  line    top level conflict
found  line     first case  procedure returns true indicates model
found  second case returns f alse means model exists input
formula 
performance dpll based sat solvers greatly improved       sat
solver c haff  moskewicz  madigan  zhao  zhang    malik        incorporated two watched
literal scheme efficient unit propagation  first uip scheme  zhang  madigan  moskewicz 
  malik        clause learning cheap vsids branching heuristic  currently  stateof the art sat solvers  ini  een   sorensson         implement small variations
three features  following describe depth 
    unit propagation
aim unit propagation twofold  one hand  finds clauses become units
due current assignment  hand  detects whether clause become
conflicting  concrete procedure given algorithm    non propagated literals exist
q  picks oldest one l marks propagated  line      clauses containing l
may become falsified units traversed  we later describe clauses
detected   one clauses becomes unit q  enqueued q propagated later  line
 

fim ini ax at 



e fficient w eighted ax  sat olver

     procedure iterates units propagate conflicting clause
found  line     
two types literals q  decision literals algorithm heuristically
selected assigned branching point  lines       algorithm     consequence literals
added logical consequences previous decision literals  line     
ini uses non standard queue handle units pending propagation  unlike classical queues 
fetching element  removed  marked such  consequently  q formed
two sets elements  already propagated literals literals pending propagation 
advantage strategy execution point  q contains current assignment 
besides  propagated literals q divided decision levels  decision level contains
decision literal set related consequences  furthermore  literal l associated
original clause caused propagation noted l    clause usually referred
reason l  note decision literal l reason represented
ld  
example   consider formula   x  x       x  x       x  x       starting execution 
propagation queue empty q    k   use symbol k separate propagated literals  on
left  literals pending propagation  on right   literal x  selected  added
q  propagation queue contains q    kxd     propagate x  add two new
consequences x  x    propagation queue q    xd  kx      x      current
assignment  x    x    x     propagation x  x  add new literals q  becomes
q    xd    x      x    k 
x  decided  add new consequence x    propagation  q  

 x    x      x      xd    x    k   current assignment  x    x    x    x    x     note literals
propagated complete assignment found  note well q contains two
decision levels  first one formed literals x    x  x  second one formed
literals x  x   
      l azy data tructures  
mentioned  aim detect units conflicting clauses  taking account
process typically takes     total runtime sat solver  important
design efficient data structures 
first attempt use adjacency lists  literal  one keeps list clauses
literal appears  then  upon addition literal l assignment  clauses
containing l traversed  main drawback refinements detect efficiently
clause become unit  keeping counters indicating number unassigned
literals clause  involved considerable amount work upon backtracking 
method used ini two watched literal scheme introduced moskewicz et al 
        basic idea clause cannot unit conflicting  i  one satisfied literal
 ii  two unassigned literals 
algorithm keeps two special literals clause  called watched literals  initially
two unassigned literals  tries maintain invariant always one satisfied literal two
unassigned literals watched 
invariant may broken one two watched literals becomes falsified 
case  clause traversed looking another non false literal watch order restore
 

fih eras   l arrosa     liveras

invariant  one literal cannot found  clause declared true  unit conflicting depending value watched literal  hence  literal l added assignment 
clauses may become falsified unit  line    algorithm    clauses
l watched 
main advantage approach work clauses done upon
backtracking  however  main drawback way know many literals
unassigned given clause traversing literals  note information used
techniques two sided jeroslow branching heuristic  see section      
      r esolution r efutation rees  
detects conflict  unsatisfiable subset clauses f   determined using information provided q  since f   unsatisfiable  empty clause   derived f   via
resolution  resolution process called refutation  refutation unsatisfiable clause set
f   resolution refutation tree  or simply refutation tree  every clause used exactly
resolution process 
refutation tree built propagation queue q follows  let c  conflicting
clause  traverse q lifo  last first out  fashion clashing clause d  found 
resolution applied c  d    obtaining resolvent c    next  traversal q continues
clause d  clashes c  found  giving resolvent c  iterate process
resolvent obtain empty clause    importance refutation trees become
relevant section   
example   consider f     x       x  x       x  x       x  x  x       x  x  x       x  x      
apply unit propagation unit clause enqueued producing q    kx       x 
propagated q becomes  x    kx      x      x       that  literal x  propagated causing
clause become unit q becomes  x      x    kx      x      x       that  literal x 
propagated clause found conflicting  figure   a shows state q
propagation 
build refutation tree  starting tail q first clause clashing
conflicting clause   resolution generates resolvent x  x  x    first
clause clashing x    producing resolvent x  x    next clause clashing x 
resolution generates x    finally  resolve clause obtain   figure   b shows
resulting refutation tree 
    learning backjumping
learning backjumping best illustrated example  see silva   sakallah        zhang
et al         precise description  
example   consider formula   x  x       x  x       x  x       x  x  x      partial
assignment  x    x    x    x    x    x    leads conflict clause   suppose current
propagation queue q    xd    x      xd    x      xd    x    k  
example easy see decision xd  incompatible decision xd    incompatibility represented clause  x  x     similarly  consequence x  incompatible
decision xd  represented clause  x  x    
 

fim ini ax at 



e fficient w eighted ax  sat olver

f     x       x  x       x  x       x  x  x       x  x  x       x  x     

 x  x  x     x  x  x   
x    

x  x  x 

 x  x   

x    
x    

x  x 

 x  x   

x 

 x   

x    
x    

 
a 

b 

figure    graphical representation propagation queue q refutation tree example
   top  original formula f   left  propagation q step    arrows
indicate order resolving clauses selected  right  resolution tree
computed step   

clause learning implements different techniques used discover implicit incompatibilities adds formula  learned clauses accelerate subsequent search 
since increase potential future executions  however  observed
unrestricted clause learning impractical cases  recorded clauses consume memory
repeated recording may lead exhaustion   reason  current sat solvers incorporate
different clause deletion policies order remove learned clauses 
learned clauses used backjump presence would allowed unit propagation earlier decision level  case  say clause asserting backjumping
proceed going back level adding unit propagated literal  among several
automated ways generating asserting clauses  ini uses so called first unique implication point   uip   zhang et al         
    branching heuristic
branching occurs function selectliteral  algorithm     literals
propagate  function chooses one variable unassigned ones assigns value 
 

fih eras   l arrosa     liveras

importance branching heuristic well known  since different branching heuristic may
produce different sized search trees 
early branching heuristics include bohms heuristic  buro   buning         maximum ocurrences minimum sized clauses  mom   freeman        two sided jeroslow
wang heuristic  jeroslow   wang         heuristics try choose literal
assignment generate largest number implications satisfy clauses 
heuristics state dependent  is  use information state clauses given
current assignment  them  information number unassigned literals
clause  hence  implemented jointly data structures based adjacency lists since
keep information  instance  two sided jeroslow wang heuristic computes
literal l f following function 
j l   



  c 

cf
s t  lc

selects literal l maximizes function j l  
solvers become efficient  updating metrics state dependent heuristics dominates
execution time  hence ini uses slight modification state independent heuristic first
proposed moskewicz et al          heuristic  called variable state independent decaying
sum  vsids   selects literal appears frequently clauses  giving priority
recently learned clauses  advantage heuristic metrics updated
clauses learned  since occurs occasionally  computation low overhead 
vsids heuristic suits perfectly lazy data structures two watched literal scheme 

    weighted  max sat
weighted clause pair  c  w   c clause w integer representing cost
falsification  called weight  problem contains clauses must satisfied 
call clauses mandatory hard associate special weight    non mandatory
clauses called soft  weighted formula conjunctive normal form  wcnf  set
weighted clauses  model complete assignment satisfies mandatory clauses  cost
assignment sum weights clauses falsifies  given wcnf formula f  
weighted max sat problem finding model f minimum cost  cost
called optimal cost f   note formula contains mandatory clauses  weighted
max sat equivalent classical sat  clauses weight    so called
 unweighted  max sat problem  following  assume weighted max sat 
say weighted formula f   relaxation weighted formula f  noted f   v f  
optimal cost f   less equal optimal cost f  non models considered
cost infinity   say two weighted formulas f   f equivalent  noted f   f  
f   v f f v f    
max sat simplification rules transforms formula f equivalent  presumably simpler formula f     sat simplification rules  e g  unit propagation  tautology removal     
directly applied max sat restricted mandatory clauses  however  several specific max sat
simplification rules exist  larrosa et al          instance  formula contains clauses  c  u 
 c  v   replaced  c  u   v   contains clause  c      may removed 
contains unit  l      simplified removing  including soft  clauses containing l
 

fim ini ax at 



e fficient w eighted ax  sat olver

removing l clauses  including soft clauses  appears  application
rule quiescence natural extension unit propagation max sat 
empty clause may appear weighted formula  weight    clear
formula model  weight w      cost assignment include
weight  w obvious lower bound formula optimal cost  weighted empty clauses
interpretation terms lower bounds become relevant section   
shown larrosa et al          notion resolution extended weighted formulas
follows    


 a b  m  








 x a  u m  
 x b  w m  
  x a  u    x b  w  



 x b  m  






 x b  m 

b arbitrary disjunctions literals   min u  w  
 x a  u   x b  w  called prior clashing clauses   a b  m  called resolvent 
 x a  u m   x b  w m  called posterior clashing clauses   x b  m 
 x b  m  called compensation clauses  effect max sat resolution  classical
resolution  infer  namely  make explicit  connection b  however 
important difference classical resolution max sat resolution  former yields
addition new clause  max res transformation rule  namely  requires replacement
left hand clauses right hand clauses  reason cost prior clashing
clauses must substracted order compensate new inferred information  consequently 
max res better understood movement knowledge formula 
resolution rule max sat preserves equivalence     last two compensation clauses
may lose clausal form  following rule  larrosa et al         may needed recover it 

l    b     
cnf a l b  u   

  a l b  u   cnf a b  u     b     

example   apply weighted resolution following clauses   x  x         x  x  x       
obtain   x  x  x         x  x           x  x  x           x  x   x  x          x  x  x 
x         first clause simplified  second clause omitted weight
zero  fifth clause omitted tautology  fourth element clause
simple disjunction  hence  apply cnf rule obtain two new
clauses cnf x  x   x  x            x  x  x  x         x  x  x         note first new
clause tautology  therefore  obtain equivalent formula   x  x         x  x  x         x 
x  x        

   overview ini ax
ini ax weighted max sat solver built top ini    een   sorensson        
dpll based sat solver could used  ini   particularly wellsuited short open source code  besides  deal pseudo boolean constraints 
   empty clause represents tautology  special weight    relations      
         larrosa et al        

 

fih eras   l arrosa     liveras

algorithm    ini ax basic structure 
function search     integer
  
ub    localsearch    lb       
  
initqueue q   
  
loop
  
propagate    
  
hard conflict
analyzeconflict    
top level hard conflict return ub  
else
learnclause    
backjump    
  

  
  
  

  

else soft conflict
chronologicalbactrack    
end search return ub  
else variables assigned
ub    lb  
ub     return ub  
chronologicalbactrack    
end search return ub  
else
l    selectliteral    
enqueue q  l   

given wcnf formula  possibly containing hard soft clauses   ini ax returns
cost optimal model  or   model   achieved means branch andbound search  usually done solve optimization problems 
ini at  tree assignments traversed depth first manner  search point 
algorithm tries simplify current formula and  ideally  detect conflict  would mean
current partial assignment cannot successfully extended  ini ax distinguishes
two types conflicts  hard soft  hard conflicts indicate model extending
current partial assignment  namely  mandatory clauses cannot simultaneously satisfied  
hard conflicts detected taking account hard clauses using methods ini at 
hard conflict occurs  ini ax learns hard clause backjumps ini would
do  soft conflicts indicate current partial assignment cannot extended optimal
assignment  order identify soft conflicts  algorithm maintains two values search 
cost best model found far  upper bound ub optimal solution 
underestimation best cost achieved extending current partial assignment model  lower bound lb current subproblem 
soft conflict detected lb ub  means current assignment cannot lead
optimal model  soft conflict detected  algorithm backtracks chronologically  note
  

fim ini ax at 



e fficient w eighted ax  sat olver

algorithm    minimaxsat propagation 
function ms up     conflict
 q contains non propagated literals 
  
l    getfirstnonpropagatedlit q   markaspropagated l   
 
  
lb    lb  v  l  
  
lb ub return soft conflict  
   becomes unit falsified
  
foreach hard clause  c l 

  
 c l     becomes unit  q     enqueue q  q   
   becomes falsified return hard conflict  
  
else  c l 
u  becomes unit
  
foreach soft clause  c l 

  
 c l  u  becomes unit  q  u  v  q     v  q    u  

  
  
  
  
  

return none  
function propagate     conflict
c    ms up     
c   hard soft conflict return c  
improvelb     
lb ub return soft conflict  
return none  

one could backjump computing clause expressing reasons led lb ub 
however  presence lots soft clauses  approach ends creating many long
clauses affect negatively efficience solver hence decided perform
simple chronological backtracking 
want remark soft clause  c  w  w ub must satisfied optimal
assignment  therefore  following assume soft clauses automatically transformed hard clauses previous search  ones  soft clause promoted
hard one search 
algorithmic description ini ax presented algorithm    starting
search  good initial upper bound obtained local search method  line     may yield
identification new hard clauses  current implementation use u bcsat  tompkins   hoos        default parameters  selected local search algorithm irots  iterated
robust tabu search   smyth  hoos    stutzle         besides  lower bound initialized
zero  next  queue q initialized unit hard clauses resulting formula  line     
main loop starts line    iteration charge propagating pending literals
 line     and  conflict detected  attempting extension current partial assignment
 line      pending literals q propagated function propagate  line      may return hard soft conflict  hard conflict encountered  line     conflict analyzed 
new hard clause learned backjumping performed  done introduced section   
soft conflict encountered  line     chronological backtracking performed  conflict
found  line      literal heuristically selected added q propagation next iteration 
however  current assignment complete  line      upper bound updated  search stops
zero cost solution found  since cannot improved  line      else  chronological
backtracking performed  line      note backjumping leads termination top level hard
  

fih eras   l arrosa     liveras

conflict found  chronological backtracking leads termination two values first
assigned variable tried 
algorithm   describes propagation process  function propagate   uses array v  l 
accumulates weight soft clauses become unit l  namely  original
clauses  a l  w  current assignment falsifies a  clauses exists  assume
v  l       first all  performs max sat adapted form unit propagation  ms up  line     
ms up iterates non propagated literals l q  line      firstly  adding l assignment

may make set soft clauses falsified  since cost clauses kept v  l  
add lower bound  line      lower bound increment identifies soft conflict 
returned  line      then  hard clause becomes unit  corresponding literal added q
future propagation  line      finally  soft clause becomes unit clause  q  u   line     
weight u added v  q   line      process hard conflict detected  function
returns  lines         else  algorithm attempts detect soft conflict call procedure
improvelb  line      returns soft conflict found  line      next section
detailed description improvelb found  finally  conflict detected  function
returns none  line     

   lower bounding ini ax
following  consider arbitrary search state ini ax call
procedure improvelb  purpose section  search state characterized
current assignment  current assignment determines current subformula
original formula conditioned current assignment  clause contains literal part
current assignment  removed  besides  literals whose negation appear current
assignment removed clauses appear 
value lb maintained ini ax precisely aggregation costs
clauses become empty due current assignment  similarly  recall value
v  l  aggregation costs clauses become unit l due current
assignment  thus  current subformula contains     lb   l v  l   every l 
ini ax computes lower bound deriving new soft empty clauses     w 
resolution process  clauses added already existing clause     lb  producing
increment lower bound 
w   l  u m    l 
w
first step  improvelb replaces occurrence  l  u   l 
m       m   with   min u  w    amounts applying restricted version max sat resolution known unit neighborhood resolution  unr   larrosa et al         
produces immediate increment lower bound  i e   weight empty clause
line     illustrated following example 
example   consider current state           x         x         x         x         x  x         unr
would resolve clauses  x        x       replacing  x               all compensation clauses removed weight zero tautologies   two empty
clauses grouped                 unr would resolve clauses  x        x      
replacing  x               two empty clauses grouped                 so 
new equivalent formula           x         x         x  x        higher lower bound   
  

fim ini ax at 



e fficient w eighted ax  sat olver

algorithm    lower bounding ini ax
function sup     conflict
  
initqueue q   
 q contains non propagated literals 
l    getfirstnonpropagatedlit q   markaspropagated l   
  
foreach  hard soft  clause c l becomes unit falsified
c l becomes unit q enqueue q  q   
else c l becomes falsified return conflict  

  
  
  
  
  
  
  

return none  
procedure improvelb     lb
w  f
foreach  l  v    l 
w m       m     min  v  w   
replace  l  v m    l 
su p     con f lict
   buildtree    
   minimum weight among clauses  
condition applyresolution       
else lb    lb   m  remove weight clauses  

second step improvelb executes simulation unit propagation  sup  line    
soft clauses treated hard  first  sup adds q unit soft clauses  line
     then  new literals q propagated  new  hard soft  clauses become unit 
inserted q  line      sup yields conflict  means subset  soft
hard  clauses cannot simultaneously satisfied  showed section   q used
identify subset build refutation tree   improvelb computes tree  line     
take account weights clauses apply max sat resolution  section   
dictated   one see produce new clause     m   minimum
weight among clauses tree  line      means extension current partial
assignment unassigned variables cost least m 
important remark step max sat resolution process consider
minimum weight two clauses  rather minimum clauses
resolution tree  passed parameter line    
result resolution process replacement clauses leaves
    m  corresponding compensation clauses  function applyresolution line     
thus obtaining equivalent formula lower bound increment m  call procedure
resolution based lower bounding 
example   consider formula f     x          x  x          x  x          x  x  x          x 
x  x          x  x        
step    apply sup  initially  unit clause enqueued producing q    kx      
x  propagated q becomes  x    kx      x      x       literal x  propagated clause
becomes unit  producing q    x      x    kx      x      x       that  literal x  propagated
clause found conflicting  figure   a shows state q propagation 
  

fih eras   l arrosa     liveras

f     x          x  x          x  x          x  x  x          x  x  x          x  x        

 x  x  x        x  x  x      

x    






x    



x    

 x  x  x      
 x  x  x  x        x  x  x        x  x      
 x  x  x  x      
 x  x      

 x  x      

 x  x      



x    
x    

 x      

 

 x      

      

a 

b 

c 

f       x  x         x  x                 x  x  x         x  x  x  x         x  x  x  x       
f

  

    x  x         x  x  x         x  x               

figure    graphical representation ini ax lower bounding  top  original
current formula f   left  propagation q step    middle  structure
refutation tree computed simulation step    right 
effect actually executing max sat resolution  step     resulting formula f  
appears bellow  substraction based lower bounding performed  step   replaced
substraction weights  producing formula f     

step    build simulated refutation tree  starting tail q first clause clashing
conflicting clause   resolution generates resolvent x  x  x   
first clause clashing x    producing resolvent x  x    next clause clashing
x  resolution generates x    finally  resolve clause obtain   figure   b
shows resulting resolution tree 
step    apply max sat resolution  apply max sat resolution indicated refutation
tree computed step    figure   c graphically shows result process  leaf clauses
original  weighted  clauses involved resolution  internal node indicates resolution
step  resolvents appear junction edges  beside resolvent  inside box 
compensation clauses must added formula preserve equivalence  since
clauses used resolution must removed  resulting formula f   consists root
  

fim ini ax at 



e fficient w eighted ax  sat olver

tree          all compensation clauses clauses used refutation tree  is 
resulting formula f       x  x         x  x                 x  x  x         x  x  x  x         x 
x  x  x         soundness max sat resolution guarantees f f    
remark   transformations applied resolution based lower bounding passed
descendent nodes changes preserve equivalence  nevertheless  transformations
restored backtracking takes place 
alternative problem transformation resolution identify lower bound increment substract clauses would participated resolution
tree  procedure similar lower bound computed li et al         call
substraction based  line     lower bounding 
example   consider formula f previous example  steps     identical  however 
substraction based lower bounding would replace step   step   substracts weight  
clauses appear refutation tree adds        formula  result
f        x  x         x  x  x         x  x                 note f    v f  
remark   substractions applied substraction based lower bounding restored moving descendent node preserve equivalence 
increment lower bound either technique  procedure sup executed
again  may yield new lower bound increments  process repeated sup
detect conflict 
comparing two previous approaches  observe resolution based lower bounding
larger overhead  resolution steps need actually computed consequences
must added current formula removed upon backtracking  however  effort invested
transformation may well amortized increment obtained lower bound
becomes part current formula  discovered
descendent nodes search  hand  substraction based lower bounding
smaller overhead resolution needs actually computed  facilitates
context restoration upon backtracking 
ini ax incorporates two alternatives chooses apply one heuristically  lines        depending specific condition  line      observed resolution based
lower bounding seems effective resolution applied low arity clauses 
consequence  identification resolution tree  ini ax applies resolution based
lower bounding largest resolvent resolution tree arity strictly less    otherwise  applies substraction based lower bounding  see section   details 

   additional features ini ax
section overview important features ini ax at  namely use twowatched literal scheme  branching heuristic  use soft probing ini ax
deals pseudo boolean functions 
  

fih eras   l arrosa     liveras

    two watched literals
ini ax uses two watched literal scheme soft clauses  recall one main
advantages technique  applied pure sat problems  backtracking takes
place  work done clauses  unfortunately  case soft clauses restoration needs done  soft clause becomes unit literal l function ms up  weight
added v  l  clause eliminated  or marked eliminated  avoid reusing
lower bounding procedure  changes  well addition lb  restored
backtracking performed  however  note executions sup  simulation unit
propagation  clauses considered hard  case two watched literal scheme works
exactly sat solver hard soft clauses  inconsistency detected
sup stops literals propagate  initial state recovered 
situation restoring initial state completely overhead free 
    branching heuristic
ini ax incorporates two alternative branching heuristics  first one vsids heuristic  moskewicz et al         disregarding soft clauses  that is  ini default   heuristic
likely good structured problems learning backjumping play significant role 
well problems difficult find models  namely  satisfaction component
problem difficult optimization component   since heuristic disregards soft
clauses  likely ineffective problems easy find models difficulty
find optimal one prove optimality  extreme case  problems contain soft clauses  every complete assignment model  vsids heuristic blind therefore
completely useless 
overcome limitation vsids  ini ax incorporates weighted jeroslow
heuristic  heras   larrosa         extension sat jeroslow heuristic described
section    given weighted formula f  literal l f following function defined 
j l   



  c  w

 c w f
s t  lc

mandatory clauses assumed weight equal upper bound ub  heuristic
selects literal highest value j l   main disadvantage metrics need
updated visited node  combination two watched literal updating becomes
expensive seem pay general  thus  current implementation
heuristic  j l  values computed root node used throughout solving
process  found experiments heuristic good alternative problems
difficulty lies optimization part  e g  problems many models   ini ax
automatically changes vsids weighted jeroslow problem contain literal
l hard clauses l hard clauses l 
heuristics  literal l v  l    lb ub node search
tree  l selected literal l never assigned 
  

fim ini ax at 



e fficient w eighted ax  sat olver

    soft probing
probing well known sat technique allows formulation hypothetical scenarios  lynce
  silva         idea temporarily assume l hard unit clause execute unit
propagation  yields conflict  know model extending current assignment must
contain l  process iterated literals quiescence  exhaustive experiments
sat context indicate expensive probe search  le berre        lynce
  silva         normally done pre process order reduce initial number
branching points 
easily extend idea max sat  context  besides discovery unit hard
clauses  may used make explicit weighted unit clauses  call soft probing  sat 
idea temporarily assume l unit clause simulate unit propagation  i e   execute
sup     then  build resolution tree propagation queue q  clauses
hard  know l must added assignment  else  reproduce applying max m  minimum
sat resolution weighted clauses derive unit clause  l 
weight among clauses   unit soft clauses upfront makes future executions
improvelb much effective subsequent search  besides  derive  l  u 
w   generate via unit neighborhood resolution  see example    initial non trivial lower
 l 
bound min u  w   tested soft probing search preprocessing several
benchmarks  observed empirically soft probing preprocessing best option
sat 

example   consider formula f     x  x          x  x          x  x          assume x 
adding q execute sup conflict reached  obtain q    xd    x      x     
detect conflicting clause  clauses involved refutation tree      
resolving clauses results   x  x          x  x         x  x  x         x  x  x        
resolution previous resolvent produces  equivalent  formula f       x         x 
x  x         x  x  x        
    pseudo boolean functions
pseudo boolean optimization problem  pbo   barth        sheini   sakallah        een  
sorensson        form 
minimize nj   c j x j
subject nj   ai j l j bi            
x j         l j either x j   x j   c j   ai j bi non negative integers 
ini ax provided pbo instance  translates max sat formula follows  pseudo boolean constraint translated set hard clauses using ini    een
  sorensson         the algorithm heuristically decides appropriate translation choosing
among adders  sorters bdds   objective function translated set soft unit clauses 
summand c j x j becomes new soft unit clause  x j   c j    translation ini ax
executed usual 
  

fih eras   l arrosa     liveras

   empirical results
section present benchmarks solvers used empirical evaluation  then 
report experiments performed order adjust parameters ini ax at  finally 
comparison solvers presented 
    benchmarks encodings
good set problems fundamental show effectiveness new solvers 
following  present several problems explain encode weighted max sat 
      ax   k  sat
k sat cnf formula cnf formula clauses size k  generated random
unsatisfiable   sat   sat formulas cnfgen generator  solved corresponding
max sat problem  benchmarks  fixed number variables varied number
clauses  repeated 
      ax   cut
given graph g    v  e   cut defined subset vertices u v   size cut
number edges  vi   v j   vi u v j v u   max cut problem consists
finding cut maximum size  encoded max sat associating one variable xi
graph vertex  value true  respectively  false  indicates vertex vi belongs u  respectively 
v u    edge  vi   v j    two soft clauses  xi x j        xi x j       given complete
assignment  number violated clauses  e  size cut associated
assignment  experiments considered max cut instances extracted random graphs
   nodes varying number edges 
      ax   one
given satisfiable cnf formula  max one problem finding model maximum
number variables set true  problem encoded max sat considering
clauses original formula mandatory adding weighted unary clause  xi     
variable formula  note solving problem much harder solving usual sat
problem  search cannot stop soon model found  optimal model must
found optimality must proved  considered max one problem two types
cnf formula  random   sat instances     variables  generated cnfgen   structured
satisfiable instances coming      sat competition   
      inimum v ertex c overing



ax  c lique

given graph g    v  e   vertex covering set u v every edge  vi   v j   either
vi u v j u   size vertex covering  u    minimum vertex covering problem
consists finding covering minimal size  naturally formulated  weighted  maxsat  associate one variable xi graph vertex vi   value true  respectively  false  indicates
   a  van gelder ftp   dimacs rutgers edu pub challenge satisfiability contributed ucsc instances
   http   www satcompetition org      

  

fim ini ax at 



e fficient w eighted ax  sat olver

vertex vi belongs u  respectively  v u    binary hard  xi x j      edge
 vi   v j    specifies one two vertices covering
edge connecting them  unary clause  xi      variable xi   order specify
preferred add vertices u   simple way transform minimum vertex
coverings max cliques vice versa  fahle        
experiments  considered maximum clique instances extracted random graphs
    nodes varying number edges  considered    max clique instances
dimacs challenge   
      c ombinatorial auctions
combinatorial auction defined set goods g set bidders bid indivisible
subsets goods  bid defined subset requested goods gi g amount
money offered  bid taker  wants maximize revenue  must decide bids
accepted  note two bids request good  cannot jointly accepted  sandholm 
       max sat encoding  one variable xi associated bid  unit
clauses  xi   ui   indicating bid accepted loss profit ui   besides 
pair i  j conflicting bids  mandatory clause  xi x j      
experiments  used cats generator  k  leyton brown   shoham       
allows generate random instances inspired real world scenarios  particular  generated
instances regions  paths scheduling distributions  number goods fixed
   increased number bids  increasing number bids  instances become
constrained  namely  conflicting pairs bids  harder solve 
      iscellaneous
considered following sets instances widely used literature 
unsatisfiable instances  nd dimacs implementation challenge   considered
de givry  larrosa  meseguer  schiex        li et al          random   sat instances
 aim dubois   pigeon hole problem  hole  coloring problems  pret   observe
instances modelled unweighted max sat  i e  clauses weight    
max csp random instances generated using protocol specified larrosa schiex
       de givry  heras  larrosa  zytnicki         distinguish   different sets
problems  dense loose  dl   dense tight  dt   sparse loose  sl  sparse tight  st  
tight instances    variables loose instances    variables 
set contains    instances   values    instances   values per variable 
planning  cooper  cussat blanc  de roquemaurel    regnier        graph coloring  
structured instances taken weighted constraint satisfaction problem  wcsp  repository    
  
  
  
  

ftp   dimacs rutgers edu pub challenge graph benchmarks clique
http   mat gsia cmu edu challenge html
http   mat gsia cmu edu coloring   benchmarks
http   mulcyber toulouse inra fr plugins scmcvs cvsweb php benchs  cvsroot toolbar

  

fih eras   l arrosa     liveras

problems taken      pseudo boolean evaluation     logic synthesis  misc  garden  
routing  mpi  minimum prime implicant   mps  miplib   instances encoded
max sat specified previous section 
note max csp  planning graph coloring instances encoded max sat using
direct encoding  walsh        
    alternative solvers
compare ini ax several optimizers different communities  restricted
comparison freely available solvers  considered following ones 
axsatz  li et al         li  manya    planes         unweighted max sat solver 
best unweighted max sat solver      max sat evaluation 
ax  dpll  heras   larrosa        larrosa et al          weighted max sat solver 
part oolbar package  best solver weighted max sat second
best solver unweighted max sat      max sat evaluation 
oolbar  larrosa        larrosa   schiex        de givry et al               
state of the art weighted csp solver 
p ueblo      sheini   sakallah         pseudo boolean solver  ranked first
several categories      pseudo boolean evaluation 
inisat    een   sorensson         pseudo boolean solver translates problems sat solves minisat  ranked first several categories     
pseudo boolean evaluation 
instances taken pseudo boolean evaluation given original format
p ueblo inisat    instances translated max sat pbo partitioning
set clauses three sets  h contains mandatory clauses  c      w contains nonunary weighted clauses  c  u      u contains unary weighted clauses  l  u  
hard clause  c j      h pseudo boolean constraint c j    c j obtained
c j replacing   negated variables x   x  non unary weighted clause
 c j   u j   w pseudo boolean constraint c j   r j    c j computed before 
r j new variable that  set    trivially satisfies constraint  finally  objective
function minimize is 



u jr j  



u jl j

 l j  u j  u

 c j  u j  w

    experimental results
divide experiments two parts  purpose first part evaluate impact
different techniques ini ax set different parameters  since
techniques effective benchmarks useless even counterproductive others  brglez  li    stallman         aimed finding configuration ini ax
   http   www cril univ artois fr pb   

  

fim ini ax at 



e fficient w eighted ax  sat olver

performs reasonably well instances  purpose second part compare ax alternative solvers  since solvers specifically designed
type problems  expect ini ax outperform them  rather want
show robustness ini ax showing usually close performance
best alternative type problems 
results presented plots tables  regarding tables  first column contains name
set problems  second column shows number instances  remaining columns
report performance different solvers  cell contains average cpu time
solver required solve instances  solver could solve instances set 
number inside brackets indicates number solved instances average cpu time
takes account solved instances  cell contains dash  means instance could
solved within time limit  regarding plots  note legend goes accordance
performance solvers  time limit set     seconds instance 
solver  written c    implemented top inisat    een   sorensson        
executions made     ghz xeon computer linux  experiments random
instances  samples    instances plots report mean cpu time seconds 
    setting parameters ini ax
following evaluate order importance following techniques inside ini ax at  lower bounding  soft probing  branching heuristics  learning backjumping 
starting basic version guides search jeroslow branching heuristic
rest techniques deactivated  analyze one one  analysis studies one technique
incorporates previously analyzed ones corresponding tuned parameters 
three first experiments consider little challenging instances generated randomly
lower bounding plays fundamental role solve them  finally  consider structured instances
learning backjumping required solve them 
      l ower

bounding

experiment analyze impact resolution based lower bounding versus substractionbased lower bounding  well combined strategies  considered following combination
two techniques  sup detects inconsistency refutation tree computed 
look resolvent maximum size  size less equal parameter k 
resolution based lower bounding applied  otherwise substraction based lower bounding
applied  tested k                         note k     corresponds pure substraction based
lower bounding  and therefore similar approach li et al          k   corresponds
pure resolution based lower bounding 
results presented figure    seen  pure substraction based lower bounding k     always worst option  better results obtained k increases  however 
improvement stops  or nearly stops  k      k     significant improvement noticed  plot omits k     k     case clarity reasons  since higher values k may
produce new clauses higher size may cause overhead instances  set k    
rest experiments 
  

fih eras   l arrosa     liveras

 a  max   sat      variables

  
  

 b  max   sat     variables

k  
k  
k  
k  
k inf

cpu time

cpu time

  

 
 
                           

  
  
  
  
  
  
 

k  
k  
k  
k inf
k  

   

number clauses

   

   

   

   

   

number clauses

cpu time

 c  max cut     nodes
  
  
  
 
 
 
 
 
   

k  
k  
k  
k  
k inf

   

   

   

   

   

number nodes

figure    performance ini ax different mixed lower boundings  k               inf  

      oft

probing

second experiment  evaluate impact soft probing  preliminary experiments 
observed soft probing time consuming  decided limit soft probing
follows  initially  assign propagation level   variable probe  then  new literal
propagate assigned propagation level l     literal produces propagation
level l  limited probing propagate literals maximum propagation level m 
finally restricted   since gives best results  note propagation level
decision level 
compare three alternatives  probing node search  s   probing pre process
search  p  probing  n   results  figure    indicates probing
search worst option max   sat max   sat produces improvement
max cut  finally  probing preprocessing gives slightly improvement max   sat
best results max cut  note soft probing preprocessing max   sat effect
omitted plot  its results similar n   given results  decided include
soft probing preprocessing 
      j eroslow

branching heuristic

following experiment  evaluate importance weighted jeroslow heuristic  figure
  shows time difference ini ax jeroslow heuristic previous
two experiments  jeroslow  without heuristic  none   results indicates guiding search
jeroslow heuristic gives important speed ups  hence  maintain jeroslow heuristic
ini ax at 
  

fim ini ax at 



e fficient w eighted ax  sat olver

 a  max   sat      variables

cpu time

  
  

 b  max   sat     variables


n
p

cpu time

  

  
 
 
                           

  
  
  
  
  
  
  
 


n

   

number clauses

   

   

   

   

   

number clauses
 c  max cut     nodes

 

cpu time

 

n

p

 
 
 
 
   

   
   
   
number nodes

   

figure    performance ini ax without soft probing  probing preprocessing  p 
probing search  s  

      l earning  

backjumping

vsids

final experiment  evaluate importance learning backjumping  experiments use structured instances  since well known learning backjumping
useful type problems  besides  evaluate importance vsids heuristic
combination learning backjumping  recall heuristic specially designed
work cooperation learning  meaningless analyze effect itself 
table   reports results experiment  third column reports results without learning
backjumping lower bounding  probing jeroslow heuristic  none  
fourth column reports results adding learning backjumping previous version  learning  
fifth column reports results adding learning  backjumping changing jeroslow heuristic
vsids heuristic  vsids   results show ini ax without learning backjumping  none  clearly worst option  significant improvements obtained learning
backjumping  learning  added  finally  adding vsids heuristic  vsids  improve results specially routing instances  based results  incorporated learning
backjumping ini ax at 
regarding branching heuristic  problems literals appear hard clauses
polarities applies vsids heuristic  otherwise jeroslow heuristic computed
root search tree stated section    choice done starting
search 
  

fih eras   l arrosa     liveras

 a  max   sat      variables

  

 b  max   sat     variables
   

none
jeroslow

none
jeroslow

  
cpu time

cpu time

  

  
 

  
  
  

 
                           

 
   

number clauses

   

   

   

   

   

number clauses
 c  max cut     nodes

 
cpu time

 

none
jeroslow

 
 
 
 
                           
number nodes

figure    performance ini ax without heuristic  none  jeroslow heuristic
computed root node search tree  jeroslow  

problem
max one  col
max one cnt
max one dp
max one ezfact  
routing s 
routing s 

n  inst 
  
 
 
  
 
  

none

        
        
         
        


learning
     
      
     
    
    
         

vsids
     
    
     
    
    
        

figure    structured instances 
    comparison boolean optimizers
reporting results  omit solver cannot deal corresponding instances
technical reasons  e g  cannot deal weighted clauses  performs extremely bad
comparison others 
figure   contains plots results different benchmarks  plots b reports results
random unweighted max sat instances  p ueblo inisat   orders magnitude slower 
included graphics  max   sat  plot a   ini ax lays
ax  dpll axsatz  best option  max   sat  plot b  ini ax
clearly outperforms ax  dpll close axsatz  best 
max   sat max   sat axsatz   times faster ini ax at 
  

fim ini ax at 



e fficient w eighted ax  sat olver

plot c reports results random max cut instances  ini ax performs slightly better
axsatz  second alternative 
random max one  plot d  ini ax best solver far  almost instances
solved instantly p ueblo ax  dpll require    seconds difficult instances  inisat   performs poorly  results structured max one instances reported
figure    inisat   seems fastest general  ini ax close performance
p ueblo  note  however  p instances  ini ax system solving
instances 
plot e reports results random max clique instances  ini ax best solver 
order magnitude faster ax  dpll  second best option  p ueblo inisat  
perform poorly again  regarding structured dimacs instances  ini ax best
option  solves    instances within time limit  ax  dpll m inisat   p ueblo
solve           respectively 
plots f   g h present results combinatorial auctions following different distributions 
paths distribution  ini ax best solver  twice faster ax  dpll 
ranks second  regions distribution  ini ax best solver ax  dpll
second best solver requiring double time  paths regions distributions  p ueblo
inisat   perform poorly  scheduling distribution  inisat   best solver
ini ax ax  dpll one order magnitude slower 
results regarding unsatisfiable dimacs instances presented figure    note
instances optimum cost    hence  soon ini ax find solution cost   
clauses declared hard learning backjumping applied hard conflicts
arise  results indicate axsatz ax  dpll solve instance sets
 pret    aim      ini ax solves sets instances best times
them  except hole instances axsatz slightly faster  encode
problems advantageous way p ueblo inisat    is  decision problems
rather optimization problems solve instances similar times ini ax at 
planning instances  fig      p ueblo best solver  ini ax second best
solver  oolbar third last one inisat    surprising since oolbar
perform learning hard constraints  results regarding graph coloring instances
presented fig      observed  ini ax able solve one instance
oolbar  p ueblo inisat   solve many less instances  max csp problems
 fig      oolbar solves instances instantly p ueblo worst option unable
solve lot instances  ini ax clearly second best solver ini   third
best performing solver  note solve instances 
results regarding instances taken pseudo boolean evaluation found figure
    note first time max sat solver tested pseudo boolean instances 
results indicate solver consistently outperforms ini ax fairly
competitive p ueblo inisat   
results conclude ini ax robust weighted maxsat solver  competitive pure optimization problems problems lots
hard clauses and  sometimes  best option 
final remark  note ini ax almost previous benchmarks submitted second max sat evaluation       co located event tenth international conference theory applications satisfiability testing  hence  interested reader find
  

fih eras   l arrosa     liveras

 a  max   sat      variables
  
  

cpu time

max dpll
minimaxsat
maxsatz

  
cpu time

 b  max   sat     variables

  
  
 
                               

   
   
   
   
   
  
 

max dpll
minimaxsat
maxsatz

                           

number clauses

number clauses

 c  max cut     nodes

 

cpu time

max dpll
maxsatz
minimaxsat

  
cpu time

 d  max one  random   sat      variables

 
 
 
 
   

   

   

   

   

  
minisat 
  
pueblo
max dpll
  
minimaxsat
  
  
 
 
                                   

number edges

number hard clauses

 e  max clique      nodes
  

minisat 
pueblo
max dpll
minimaxsat

  

pueblo
minisat 
max dpll
minimaxsat

  
cpu time

  
cpu time

 f  c  auctions paths     goods
   

  
  

  
  
  

 

 
 

  

  

  

   

                                

connectivity    

number bids

 g  c  auctions scheduling     goods

cpu time

  
  

 h  c  auctions regions     goods
  

pueblo
max dpll
minimaxsat
minisat 

cpu time

  

  

  
  

minisat 
pueblo
max dpll
minimaxsat

 

  
 

 
   

                                
number bids

   

   

   

   

   

number bids

figure    plots different benchmarks  note order legend goes accordance
performance solvers 

exhaustive comparison  including instances solvers  second max sat evaluation      web page    results evaluation showed ini ax best
performing solver two four existing categories 
   http   www maxsat   udl es 

  

fim ini ax at 



n  inst 
  
 
 
 
 
 
 

problem
dubois
pret  
pret   
hole
aim  
aim   
aim   

e fficient w eighted ax  sat olver

ini ax
    
    
    
    
    
    
    

axsatz
         
     

    
    
    


ax  dpll
         
     

     
    
      


figure    unsatisfiable dimacs instances 

problem
 col  
 col   
 col   
 col   
cnt
dp
ezfact  

n  inst 
  
  
  
  
 
 
  

ini ax
    
    
     
     
    
     
    

p ueblo
    
    
     
     
    
       
    

inisat  
    
    
    
    
    
       
    

figure    structured max one instances 

problem
planning
graph coloring
max csp dl
max csp dt
max csp sl
max csp st

n  inst 
  
  
  
  
  
  

toolbar
    
         
    
    
    
    

ini ax
    
        
    
    
    
    

p ueblo
    
         
          

      


inisat  
    
        
    
    
    
    

figure     results wcsp max csp instances 

   related work
previous work done incorporating sat techniques inside max sat solver 
alsinet et al         presented lazy data structure detect clauses become unit  requires static branching heuristic  argelich manya      a  test different versions branch
bound procedure  one versions uses two watched literals  uses basic
lower bounding  conclude none previous approaches general use
two watched literals  far know  rest max sat solvers based adjacency
lists  therefore  presumably inefficient unit propagation  lynce   silva         par  

fih eras   l arrosa     liveras

problem
misc
logic synthesis
mpi
mps
routing

n  inst 
 
  
   
  
  

ini ax
       
        
          
        
         

p ueblo
       
        
          
        
    

inisat  
       
         
         
       
     

figure     results pseudo boolean instances 
ticularly presence long clauses  argelich manya      b  enhance max sat branch
bound procedure learning hard constraints  used combination simple lower bounding techniques  improved version presented argelich manya       
powerful lower bound  incorporate two watched literal scheme 
backjumping  etc  best knowledge  max sat solver incorporates backjumping 
note ini ax restricts backjumping occurrence hard conflicts  related works
integration backjumping techniques branch bound include work zivan
meisels        weighted csp  manquinho silva        pseudo boolean optimization 
nieuwenhuis oliveras        sat modulo theories 
max sat solvers use variations call substraction based lower bounding 
cases  search special patterns mutually inconsistent subsets clauses  shen  
zhang        xing   zhang        alsinet et al          efficiency reasons  patterns
always restricted small sets small arity clauses      clauses arity less     ini ax uses natural weighted extension approach proposed li et al         
first one able detect inconsistencies arbitrarily large sets arbitrarily large clauses 
idea call resolution based lower bounding inspired wcsp domain
 larrosa        larrosa   schiex        de givry et al               first proposed
max sat context larrosa heras        developed li et al          heras
larrosa         larrosa et al          works  special patterns fixed size
resolution trees executed  use simulated unit propagation allows ini ax
identify arbitrarily large resolution trees  following example  present two inconsistent
subsets clauses detected ini ax transformed equivalent formula
previous solvers cannot transform since limited specific patterns 
  x    w      x    w      x    w      x  x  x    w    
  x    w      x  x    w      x  x  x    w      x  x  x  x    w      x  x  x  x    w    
first case  ini ax replaces clauses     m    min w    w    w    w   
set compensation clauses  second case  ini ax replaces     m 
  min w    w    w    w    w    set compensation clauses  cases  equivalence
preserved  however  solvers literature detect inconsistent subset clauses
cannot transform problem equivalent one  li et al         simply cannot detect
 heras   larrosa        
probing method derive weighted unit clauses related   res cycle rule
heras larrosa        larrosa et al          failed literals li et al         
  

fim ini ax at 



e fficient w eighted ax  sat olver

singleton consistency csp  debruyne   bessiere         again  use simulated unit
propagation allows ini ax identify arbitrarily large resolution trees 

    conclusions future work
ini ax efficient robust max sat solver deal hard soft
clauses well pseudo boolean functions  incorporates best available techniques
type problems  performance similar best specialized solver  besides development ini ax combining  first time  known techniques different fields 
main original contribution paper novel lower bounding technique based resolution 
ini ax lower bounding combines clean elegant way approaches proposed last years  mainly based unit propagation based lower
bounding resolution based problem transformation  paper use information provided propagation queue  i  determine subset inconsistent clauses  ii  determine
simple ordering resolution applied increase lower bound generate
equivalent formula  however  necessarily best ordering so  easy see
different orderings may generate resolvents compensation clauses different arities  one
selects ordering generates smallest resolvents compensation clauses resulting
formula may presumably simpler  future work concerns study orderings  development vsids like heuristics soft clauses backjumping techniques soft conflicts 

acknowledgments
would thank niklas een niklas sorensson making inisat   code publicly
available  grateful anonymous referees helpful suggestions improving
paper 
work partially supported spanish ministry education science
projects tin           c       heras larrosa  tin            oliveras  

references
alsinet  t   manya  f     planes  j          improved exact solvers weighted max sat 
proceedings sat    vol       lncs  pp          springer 
argelich  j     manya  f       a   exact max sat solvers over constrained problems  j 
heuristics                  
argelich  j     manya  f       b   learning hard constraints max sat  proceedings
csclp    vol       lncs  pp       springer 
argelich  j     manya  f          partial max sat solvers clause learning  proceedings
sat    vol       lncs  pp        springer 
barth  p          davis putnam based enumeration algorithm linear pseudo boolean optimization  research report mpi i           max planck institut fur informatik  im stadtwald  d       saarbrucken  germany 
brglez  f   li  x     stallman  m          role skeptic agent testing benchmarking
sat algorithms  proceedings sat    pp         
  

fih eras   l arrosa     liveras

buro  m     buning  h  k          report sat competition  bulletin european
association theoretical computer science             
cha  b   iwama  k   kambayashi  y     miyazaki  s          local search algorithms partial
maxsat  proceedings aaai    pp          mit press 
cooper  m   cussat blanc  s   de roquemaurel  m     regnier  p          soft arc consistency
applied optimal planning  proceedings cp    vol       lncs  pp         
springer 
davis  m   logemann  g     loveland  g          machine program theorem proving  communications acm            
de givry  s   heras  f   larrosa  j     zytnicki  m          existential arc consistency  getting
closer full arc consistency weighted csps  proceedings   th ijcai  pp       
professional book center 
de givry  s   larrosa  j   meseguer  p     schiex  t          solving max sat weighted csp 
proceedings cp    vol       lncs  pp          springer 
debruyne  r     bessiere  c          practicable filtering techniques constraint satisfaction problem  proceedings icjai    pp          morgan kaufmann 
een  n     sorensson  n          extensible sat solver  proceedings sat    vol      
lncs  pp          springer 
een  n     sorensson  n          translating pseudo boolean constraints sat  journal
satisfiability  boolean modeling computation         
fahle  t          simple fast  improving branch and bound algorithm maximum clique 
proceedings esa    vol       lncs  pp          springer 
freeman  j  w          improvements propositional satisfiability search algorithms  ph d 
thesis  university pennsylvania 
fu  z     malik  s          solving partial max sat problem  proceedings sat   
vol       lncs  pp          springer 
heras  f     larrosa  j          new inference rules efficient max sat solving  proceedings
  th aaai  aaai press 
jeroslow  r  g     wang  j          solving propositional satisfiability problems  annals mathematics artificial intelligence            
k  leyton brown  m  p     shoham  y          towards universal test suite combinatorial
auction algorithms  proceedings acm conference electronic commerce    pp 
     
karloff  h  j     zwick  u              approximation algorithm max  sat   focs 
pp         
larrosa  j     heras  f          resolution max sat relation local consistency
weighted csps  proceedings ijcai    pp          professional book center 
larrosa  j   heras  f     de givry  s          logical approach efficient max sat solving 
artificial intelligence  appear 
  

fim ini ax at 



e fficient w eighted ax  sat olver

larrosa  j     schiex  t          quest best form local consistency weighted
csp  proceedings   th ijcai  pp         
larrosa  j          node arc consistency weighted csp  proceedings aaai    pp 
      aaai press 
le berre  d          exploiting real power unit propagation lookahead  proceedings
lics workshop theory applications satisfiability testing 
le berre  d          sat j project max sat   http   www sat j org  
li  c   manya  f     planes  j          exploiting unit propagation compute lower bounds
branch bound max sat solvers  proceedings cp    vol       lncs  pp 
       
li  c   manya  f     planes  j          new inference rules max sat  journal artificial
intelligence research  appear 
li  c  m   manya  f     planes  j          detecting disjoint inconsistent subformulas computing lower bounds max sat  proceedings   th aaai  aaai press 
lynce  i     silva  j  p  m          probing based preprocessing techniques propositional
satisfiability  proceedings ictai    pp          ieee computer society 
lynce  i     silva  j  p  m          efficient data structures backtrack search sat solvers  ann 
math  artif  intell                 
manquinho  v  m     silva  j  p  m          satisfiability based algorithms boolean optimization  ann  math  artif  intell                   
moskewicz  m  w   madigan  c  f   zhao  y   zhang  l     malik  s          chaff  engineering
efficient sat solver  proceedings dac    pp          acm 
nieuwenhuis  r     oliveras  a          sat modulo theories optimization problems 
proceedings sat    vol       lncs  pp          springer 
papadimitriou  c          computational complexity  addison wesley  usa 
sandholm  t          algorithm optimal winner determination combinatorial auctions 
proceedings ijcai    pp          morgan kaufmann 
sheini  h  m     sakallah  k  a          pueblo  hybrid pseudo boolean sat solver  journal
satisfiability  boolean modeling computation            
shen  h     zhang  h          study lower bounds max   sat  proceedings aaai   
pp          aaai press   mit press 
silva  j  p  m     sakallah  k  a          grasp   new search algorithm satisfiability 
iccad  pp         
smyth  k   hoos  h  h     stutzle  t          iterated robust tabu search max sat 
proceedings ai    vol       lncs  pp          springer 
tompkins  d  a  d     hoos  h  h          ubcsat  implementation experimentation
environment sls algorithms sat   max sat  proceedings sat    vol 
     lncs  pp          springer 
walsh  t          sat v csp  proceedings cp    vol       lncs  pp          springer 
  

fih eras   l arrosa     liveras

xing  z     zhang  w          maxsolver  efficient exact algorithm  weighted  maximum
satisfiability  artificial intelligence                 
zhang  l   madigan  c  f   moskewicz  m  w     malik  s          efficient conflict driven learning boolean satisfiability solver  proceedings iccad    pp         
zivan  r     meisels  a          conflict directed backjumping maxcsps  proceedings
ijcai    pp         

  


