journal of artificial intelligence research               

submitted       published      

m ini m ax s at  an efficient weighted max sat solver
federico heras
javier larrosa
albert oliveras

fheras   lsi   upc   edu
larrosa   lsi   upc   edu
oliveras   lsi   upc   edu

technical university of catalonia  lsi department
jordi girona             barcelona  spain 

abstract
in this paper we introduce m ini m ax s at  a new max sat solver that is built on top of m in it incorporates the best current sat and max sat techniques  it can handle hard clauses
 clauses of mandatory satisfaction as in sat   soft clauses  clauses whose falsification is penalized by a cost as in max sat  as well as pseudo boolean objective functions and constraints  its
main features are  learning and backjumping on hard clauses  resolution based and substractionbased lower bounding  and lazy propagation with the two watched literal scheme  our empirical
evaluation comparing a wide set of solving alternatives on a broad set of optimization benchmarks
indicates that the performance of m ini m ax s at is usually close to the best specialized alternative
and  in some cases  even better 
i s at   

   introduction
max sat is the optimization version of sat where the goal is to satisfy the maximum number of
clauses  it is considered one of the fundamental combinatorial optimization problems and many important problems can be naturally expressed as max sat  they include academic problems such as
max cut or max clique  as well as real problems in domains like routing  bioinformatics  scheduling
or electronic markets 
there is a long tradition of theoretical work about the structural complexity  papadimitriou 
      and approximability  karloff   zwick        of max sat  most of this work is restricted to
the simplest case in which all clauses are equally important  i e   unweighted max sat  and have a
fixed size  mainly binary or ternary   from a practical point of view  significant progress has been
made in the last   years  shen   zhang        larrosa   heras        larrosa  heras    de givry 
      xing   zhang        li  manya    planes               as a result  there is a handful of
new solvers that can deal  for the first time  with instances involving hundreds of variables 
the main motivation of our work comes from the study of max sat instances modelling realworld problems  we usually encounter three features 
 the satisfaction of all clauses does not have the same importance  so each clause needs to be
associated with a weight that represents the cost of its violation  in the extreme case  which
often happens in practice as observed by cha  iwama  kambayashi  and miyazaki        
there are clauses whose satisfaction is mandatory  they are usually modelled by associating
a very high weight with them 
 literals do not appear randomly along the clauses  on the contrary  it is easy to identify
patterns  symmetries or other kinds of structures 
c
    
ai access foundation  all rights reserved 

fih eras   l arrosa     o liveras

 in some problems there are mandatory clauses that reduce dramatically the number of feasible
assignments  so the optimization part of the problem only plays a secondary role  however 
in some other problems mandatory clauses are trivially satisfiable and the real difficulty lays
on the optimization part 
when we look at current max sat solvers  we find that none of them is robust over these three
features  for instance  li et al s              solvers are restricted to formulas in which all clauses
are equally important  i e  unweighted max sat   shen and zhangs        one is restricted to binary clauses  the one described by larrosa et al         seems to be efficient on very overconstrained
problems  i e   only a small fraction of the clauses can be simultaneously satisfied   while the one by
alsinet  manya  and planes        seems to be efficient on slightly overconstrained problems  i e 
almost all the clauses can be satisfied   the solver described by argelich and manya         developed in parallel to the research described in this paper  can handle mandatory clauses and is the only
one that incorporates some learning  so it seems to perform well on structured problems  however 
all non mandatory clauses must have the same weight  finally  approaches based on translating a
max sat instance into a sat instance and solve them with a sat solver seem to be effective in
highly structured problems in which almost all clauses are mandatory  fu   malik        le berre 
      
in this paper we introduce m ini m ax s at  a new weighted max sat solver that incorporates
the current best sat and max sat techniques  it is build on top of m ini s at    een   sorensson 
       so it borrows its capability to deal with pseudo boolean problems and all the m ini s at  een
  sorensson        features processing mandatory clauses such as learning and backjumping  we
have extended it allowing it to deal with weighted clauses  while preserving the two watched literal
lazy propagation method  the main original contribution of m ini m ax s at is that it implements
a novel and very efficient lower bounding technique  specifically  it applies unit propagation in
order to detect disjoint subsets of mutually inconsistent clauses as done by li et al          then
it simplifies the problem following larrosa and heras         heras and larrosa         larrosa
et al         in order to increment the lower bound  however  while in those works only the clauses
that accomplish specific patterns are transformed  in m ini m ax s at there is no need to define such
patterns 
the structure of the paper is as follows  section   provides preliminary definitions on sat and
section   presents state of the art solving techniques incorporated in a modern sat solver such as
m ini s at  then  section   presents preliminary definitions on max sat and section   overviews
m ini m ax s at  after that  sections   and   focus on its lower bounding and additional features 
respectively  in section   we present the benchmarks used in our empirical evaluation and we
report the experimental results  finally  section   presents related work and section    concludes
and points out possible future work 

   preliminaries on sat
in the sequel x    x    x            xn   is the set of boolean variables  a literal is either a variable xi or its
negation xi   the variable to which literal l refers is noted var l   given a literal l  its negation l is xi
if l is xi and is xi if l is xi   a clause c is a disjunction of literals  the size of a clause  noted  c   is the
number of literals that it has  the set of variables that appear in c is noted var c   sometimes we
associate a subscript greek letter to a clause  e g   xi  x j     in order to facilitate future references
of such clause 
 

fim ini m ax s at 

an

e fficient w eighted m ax  sat s olver

algorithm    dpll basic structure 
function search     boolean
 
initqueue     
 
loop
 
up     
 
if conflict then
 
analyzeconflict     
 
if top conflict then return f alse  
else
 
learnclause     
 
backjump     
 
  
  
  

else if all variables assigned then return true  
else
l    selectliteral     
enqueue q  l   

an assignment is a set of literals not containing a variable and its negation  assignments of
maximal size n are called complete  otherwise they are called partial  given an assignment a   a
variable x is unassigned if neither x nor x belong to a   similarly  a literal l is unassigned if var l 
is unassigned 
an assignment satisfies a literal iff it belongs to the assignment  it satisfies a clause iff it satisfies
one or more of its literals and it falsifies a clause iff it contains the negation of all its literals  in the
latter case we say that the clause is conflicting as it always happens with the empty clause  noted
   a boolean formula f in conjunctive normal form  cnf  is a set of clauses representing their
conjunction  a model of f is a complete assignment that satisfies all the clauses in f  
if f has a model  we call it satisfiable  otherwise we say it is unsatisfiable  moreover  if all
complete assignments satisfy f   we say that f is a tautology 
clauses of size one are called unit clauses or simply units  when a formula contains a unit l  it
can be simplified by removing all clauses containing l and removing l from all the clauses where it
appears  the application of this rule until quiescence is called unit propagation  up  and it is well
recognized as a fundamental propagation technique in all current sat solvers 
another well known rule is resolution  which  given a formula containing two clauses of the
form  x  a    x  b   called clashing clauses   allows one to add a new clause  a  b   called the
resolvent  

   overview of state of the art dpll based sat solvers
in this section we overview the architecture of sat solvers based on the dpll  davis  logemann 
  loveland        procedure  this procedure  currently regarded as the most efficient complete
search procedure for sat  performs a systematic depth first search on the space of assignments  an
internal node is associated to a partial assignment and its two successors are obtained by selecting
an unassigned variable x and extending the current assignment with x and x  respectively  at each
visited node  new units are derived due to the application of unit propagation  up   if that leads
 

fih eras   l arrosa     o liveras

algorithm    unit propagation 
function up q    conflict
while  q contains non propagated literals  do
  
l    getfirstnonpropagatedlit q   markaspropagated l   
  
foreach clause c  l that becomes unit or falsified do
  
if c  l becomes a unit q then enqueue q  q   
  
else if c  l becomes falsified then return conflict  
return none  

to a conflicting clause  the procedure backtracks  performing non chronological backtracking and
clause learning  as originally proposed by silva and sakallah        
an algorithmic description of the dpll procedure appears in algorithm    the algorithm uses a
propagation queue q which contains all units pending propagation and also contains a representation
of the current assignment 
first  propagation queue q is filled with the units contained in the original formula  line     the
main loop starts in line   and at each iteration procedure up is in charge of propagating all pending
units  line     if a conflicting clause is found  line     the conflict is analyzed  line    and as a result
a new clause is learned  i e  inferred and recorded  line    
then  the procedure backtracks  using the propagation queue q to undo the assignment until
exactly one of the literals of the learned clause becomes unassigned  line     if one can further
backtrack while still maintaining this condition  it is advantageous to do so  this is commonly referred to as backjumping or non chronological backtracking  see silva   sakallah         if up
leads to no conflict  a new unassigned literal is selected to extend the current partial assignment 
the new literal is added to q  line     and a new iteration takes place 
the procedure stops when a complete assignment is found  line    or when a top level conflict
is found  line     in the first case  the procedure returns true which indicates that a model has been
found  while in the second case it returns f alse which means that no model exists for the input
formula 
the performance of dpll based sat solvers was greatly improved in       when the sat
solver c haff  moskewicz  madigan  zhao  zhang    malik        incorporated the two watched
literal scheme for efficient unit propagation  the first uip scheme  zhang  madigan  moskewicz 
  malik        for clause learning and the cheap vsids branching heuristic  currently  most stateof the art sat solvers  like m ini s at  een   sorensson         implement small variations of all
these three features  in the following we describe them in more depth 
    unit propagation
the aim of unit propagation is twofold  on the one hand  it finds all clauses that have become units
due to the current assignment  and on the other hand  it detects whether some clause has become
conflicting  a more concrete procedure is given in algorithm    while non propagated literals exist
in q  it picks the oldest one l and marks it as propagated  line      then all clauses containing l
that may have become falsified or units are traversed  we will later describe how these clauses are
detected   if one of such clauses becomes a unit q  it is enqueued in q to be propagated later  line
 

fim ini m ax s at 

an

e fficient w eighted m ax  sat s olver

     the procedure iterates until there are no more units to propagate or until a conflicting clause is
found  line     
there are two types of literals in q  decision literals are those that the algorithm has heuristically
selected and assigned at a branching point  lines    and    in algorithm     consequence literals are
those which are added because they are logical consequences of previous decision literals  line     
m ini s at uses a non standard queue to handle units pending propagation  unlike classical queues 
after fetching an element  it is not removed  but just marked as such  consequently  q is formed
by two sets of elements  the already propagated literals and the literals pending propagation  the
advantage of such strategy is that at any execution point  q also contains the current assignment 
besides  the propagated literals of q are divided into decision levels  each decision level contains a
decision literal and the set of its related consequences  furthermore  a literal l is associated with the
original clause that caused its propagation and it is noted as l    such a clause is usually referred
to as the reason of l  note that a decision literal l does not have a reason and will be represented as
ld  
example   consider the formula   x   x       x   x       x   x       before starting the execution 
the propagation queue is empty q    k   we use the symbol k to separate propagated literals  on
the left  from literals pending propagation  on the right   if literal x  is selected  it is added to
q  before propagation the queue contains q    kxd     up will propagate x  and add two new
consequences x  and x    the propagation queue is now q    xd  kx      x      and the current
assignment is  x    x    x     the propagation of x  and x  does not add new literals to q  so it becomes
q    xd    x      x    k 
if x  is decided  up will add a new consequence x    after the propagation  we have q  
d
 x    x      x      xd    x    k   the current assignment is  x    x    x    x    x     note that no more literals
can be propagated and a complete assignment has been found  note as well that q contains two
decision levels  the first one is formed by literals x    x  and x  while the second one is formed by
literals x  and x   
      l azy data s tructures  
as mentioned  the aim of up is to detect all units and all conflicting clauses  taking into account
that this process typically takes up to     of the total runtime of a sat solver  it is important to
design efficient data structures 
the first attempt was the use of adjacency lists  for each literal  one keeps the list of all clauses
in which the literal appears  then  upon the addition of a literal l to the assignment  only clauses
containing l have to be traversed  the main drawback of further refinements to detect efficiently
when a clause has become unit  such as keeping counters indicating the number of unassigned
literals of a clause  is that they involved a considerable amount of work upon backtracking 
the method used by m ini s at is the two watched literal scheme introduced by moskewicz et al 
        its basic idea is that a clause cannot be unit or conflicting if  i  it has one satisfied literal or
 ii  it has two unassigned literals 
the algorithm keeps two special literals for each clause  called the watched literals  initially
two unassigned literals  and tries to maintain the invariant that always one satisfied literal or two
unassigned literals are watched 
the invariant may be broken only if one of the two watched literals becomes falsified  in this
case  the clause is traversed looking for another non false literal to watch in order to restore the
 

fih eras   l arrosa     o liveras

invariant  if one such literal cannot be found  the clause is declared to be true  unit or conflicting depending on the value of the other watched literal  hence  when a literal l is added to the assignment 
the clauses that may have become falsified or unit  line    in algorithm    are only those clauses
where l is watched 
the main advantage of such an approach is that no work on the clauses has to be done upon
backtracking  however  the main drawback is that the only way to know how many literals are
unassigned for a given clause is by traversing all its literals  note that this information is used by
other techniques such as the two sided jeroslow branching heuristic  see section      
      r esolution r efutation t rees  
if up detects a conflict  an unsatisfiable subset of clauses f   can be determined using the information provided by q  since f   is unsatisfiable  the empty clause   can be derived from f   via
resolution  such resolution process is called a refutation  a refutation for an unsatisfiable clause set
f   is a resolution refutation tree  or simply a refutation tree  if every clause is used exactly once
during the resolution process 
a refutation tree  can be built from the propagation queue q as follows  let c  be the conflicting
clause  traverse q in a lifo  last in first out  fashion until a clashing clause d  is found  then
resolution is applied between c  and d    obtaining resolvent c    next  the traversal of q continues
until a clause d  that clashes with c  is found  giving resolvent c  and we iterate the process until
the resolvent we obtain is the empty clause    the importance of refutation trees will become
relevant in section   
example   consider f     x       x   x       x   x       x   x   x       x   x   x       x   x      
if we apply unit propagation the unit clause  is enqueued producing q    kx       then x  is
propagated and q becomes  x    kx      x      x       after that  literal x  is propagated causing
clause  to become unit and q becomes  x      x    kx      x      x       after that  literal x 
is propagated and clause  is found to be conflicting  figure   a shows the state of q after the
propagation 
now we build the refutation tree  starting from the tail of q the first clause clashing with the
conflicting clause  is   resolution between  and  generates the resolvent x   x   x    the first
clause clashing with x  is   producing resolvent x   x    the next clause clashing with x  is  and
resolution generates x    finally  we resolve with clause  and we obtain   figure   b shows the
resulting refutation tree 
    learning and backjumping
learning and backjumping are best illustrated with an example  see silva   sakallah        zhang
et al         for a precise description  
example   consider the formula   x   x       x   x       x   x       x   x   x      and the partial
assignment  x    x    x    x    x    x    that leads to a conflict over clause   suppose that the current
propagation queue is q    xd    x      xd    x      xd    x    k  
in the example it is easy to see that decision xd  is incompatible with decision xd    such incompatibility can be represented with clause  x   x     similarly  consequence x  is incompatible with
decision xd  and it can be represented with the clause  x   x    
 

fim ini m ax s at 

an

e fficient w eighted m ax  sat s olver

f     x       x   x       x   x       x   x   x       x   x   x       x   x     

 x   x   x     x   x   x   
x    

x   x   x 

 x   x   

x    
x    

x   x 

 x   x   

x 

 x   

x    
x    

 
a 

b 

figure    graphical representation of the propagation queue q and a refutation tree  of example
   on the top  the original formula f   on the left  the propagation q after step    arrows
indicate the order in which resolving clauses are selected  on the right  the resolution tree
computed in step   

clause learning implements different techniques that are used to discover such implicit incompatibilities and adds them to the formula  learned clauses can accelerate the subsequent search 
since they can increase the potential of future up executions  however  it has been observed that
unrestricted clause learning can be impractical in some cases  recorded clauses consume memory
and repeated recording may lead to its exhaustion   for this reason  current sat solvers incorporate
different clause deletion policies in order to remove some of the learned clauses 
learned clauses can also be used to backjump if their presence would have allowed a unit propagation at an earlier decision level  in this case  we say that the clause is asserting and backjumping
can proceed by going back to that level and adding the unit propagated literal  among the several
automated ways of generating asserting clauses  m ini s at uses the so called first unique implication point   uip   zhang et al         
    branching heuristic
branching occurs in the function selectliteral  algorithm     when there are no more literals
to propagate  this function chooses one variable from all the unassigned ones and assigns it a value 
 

fih eras   l arrosa     o liveras

the importance of the branching heuristic is well known  since different branching heuristic may
produce different sized search trees 
early branching heuristics include the bohms heuristic  buro   buning         the maximum ocurrences on minimum sized clauses  mom   freeman        and the two sided jeroslow
wang heuristic  jeroslow   wang         those heuristics try to choose the literal such that its
assignment will generate the largest number of implications or that satisfy most clauses  all these
heuristics are state dependent  that is  they use information about the state of the clauses given the
current assignment  in most of them  such information is the number of unassigned literals for each
clause  hence  they were implemented jointly with data structures based on adjacency lists since
they keep such information  for instance  the two sided jeroslow wang heuristic computes for
each literal l of f the following function 
j l   



  c 

cf
s t  lc

and selects the literal l that maximizes function j l  
as solvers become more efficient  updating metrics of state dependent heuristics dominates the
execution time  hence m ini s at uses a slight modification of a state independent heuristic first
proposed by moskewicz et al          such heuristic  called variable state independent decaying
sum  vsids   selects the literal that appears more frequently over all clauses  but giving priority to
recently learned clauses  the advantage of this heuristic is that metrics only have to be updated when
clauses are learned  since this only occurs occasionally  its computation has very low overhead  the
vsids heuristic suits perfectly with lazy data structures such as the two watched literal scheme 

    weighted  max sat
a weighted clause is a pair  c  w   where c is a clause and w is an integer representing the cost
of its falsification  also called its weight  if a problem contains clauses that must be satisfied  we
call such clauses mandatory or hard and associate with them a special weight    non mandatory
clauses are also called soft  a weighted formula in conjunctive normal form  wcnf  is a set of
weighted clauses  a model is a complete assignment that satisfies all mandatory clauses  the cost
of an assignment is the sum of weights of the clauses that it falsifies  given a wcnf formula f  
weighted max sat is the problem of finding a model of f of minimum cost  this cost will be
called the optimal cost of f   note that if a formula contains only mandatory clauses  weighted
max sat is equivalent to classical sat  if all the clauses have weight    we have the so called
 unweighted  max sat problem  in the following  we will assume weighted max sat 
we say that a weighted formula f   is a relaxation of a weighted formula f  noted f   v f   if
the optimal cost of f   is less than or equal to the optimal cost in f  non models are considered to
have cost infinity   we say that two weighted formulas f   and f are equivalent  noted f    f   if
f   v f and f v f    
max sat simplification rules transforms a formula f into an equivalent  but presumably simpler formula f     all sat simplification rules  e g  unit propagation  tautology removal      can be
directly applied to max sat if restricted to mandatory clauses  however  several specific max sat
simplification rules exist  larrosa et al          for instance  if a formula contains clauses  c  u 
and  c  v   they can be replaced by  c  u   v   if it contains a clause  c      it may be removed  if it
contains a unit  l      it can be simplified by removing all  including soft  clauses containing l and
 

fim ini m ax s at 

an

e fficient w eighted m ax  sat s olver

removing l from all the clauses  including soft clauses  where it appears  the application of this
rule until quiescence is the natural extension of unit propagation to max sat 
the empty clause may appear in a weighted formula  if its weight is    it is clear that the
formula does not have any model  if its weight is w      the cost of any assignment will include
that weight  so w is an obvious lower bound of the formula optimal cost  weighted empty clauses
and their interpretation in terms of lower bounds will become relevant in section   
as shown by larrosa et al          the notion of resolution can be extended to weighted formulas
as follows    


 a  b  m  








  x  a  u  m   
 x  b  w  m  
  x  a  u    x  b  w   



 x  a  b  m   






 x  a  b  m 

where a and b are arbitrary disjunctions of literals and m   min u  w  
 x  a  u  and  x  b  w  are called the prior clashing clauses   a  b  m  is called the resolvent 
 x  a  u  m  and  x  b  w  m  are called the posterior clashing clauses  and  x  a  b  m  and
 x  a b  m  are called the compensation clauses  the effect of max sat resolution  as in classical
resolution  is to infer  namely  make explicit  a connection between a and b  however  there is an
important difference between classical resolution and max sat resolution  while the former yields
the addition of a new clause  max res is a transformation rule  namely  it requires the replacement
of the left hand clauses by the right hand clauses  the reason is that some cost of the prior clashing
clauses must be substracted in order to compensate the new inferred information  consequently 
max res is better understood as a movement of knowledge in the formula 
the resolution rule for max sat preserves equivalence     the last two compensation clauses
may lose the clausal form  so the following rule  larrosa et al         may be needed to recover it 

a  l    b     
cnf a  l  b  u   

  a  l  b  u   cnf a  b  u     b     

example   if we apply weighted resolution to the following clauses   x   x         x   x   x       
we obtain   x   x   x         x   x            x   x   x            x   x    x   x          x   x   x  
x         the first clause can be simplified  the second clause can be omitted because it weight is
zero  the fifth clause can be omitted because it is a tautology  the fourth element is not a clause
because it is not a simple disjunction  hence  we apply cnf rule to it and we obtain two new
clauses cnf x   x    x   x            x   x   x   x         x   x   x         note that the first new
clause is a tautology  therefore  we obtain the equivalent formula   x   x         x   x   x         x  
x   x        

   overview of m ini m ax s at
m ini m ax s at is a weighted max sat solver built on top of m ini s at    een   sorensson        
any other dpll based sat solver could have been used  but m ini s at   was particularly wellsuited because of its short and open source code  besides  it can deal with pseudo boolean constraints 
   if a is the empty clause then a represents a tautology  for the special weight    we have the relations    m    
and           larrosa et al        

 

fih eras   l arrosa     o liveras

algorithm    m ini m ax s at basic structure 
function search     integer
  
ub    localsearch    lb       
  
initqueue q   
  
loop
  
propagate    
  
if hard conflict then
analyzeconflict    
if top level hard conflict then return ub  
else
learnclause    
backjump    
  

  
  
  

  

else if soft conflict then
chronologicalbactrack    
if end of search then return ub  
else if all variables assigned then
ub    lb  
if ub     then return ub  
chronologicalbactrack    
if end of search then return ub  
else
l    selectliteral    
enqueue q  l   

given a wcnf formula  possibly containing hard and soft clauses   m ini m ax s at returns the
cost of the optimal model  or   if there is no model   this is achieved by means of a branch andbound search  as it is usually done to solve optimization problems 
like m ini s at  the tree of assignments is traversed in a depth first manner  at each search point 
the algorithm tries to simplify the current formula and  ideally  detect a conflict  which would mean
that the current partial assignment cannot be successfully extended  m ini m ax s at distinguishes
two types of conflicts  hard and soft  hard conflicts indicate that there is no model extending the
current partial assignment  namely  all the mandatory clauses cannot be simultaneously satisfied  
hard conflicts are detected taking only into account hard clauses and using the methods of m ini s at 
when a hard conflict occurs  m ini m ax s at learns a hard clause and backjumps as m ini s at would
do  soft conflicts indicate that the current partial assignment cannot be extended to an optimal
assignment  in order to identify soft conflicts  the algorithm maintains two values during the search 
 the cost of the best model found so far  which is an upper bound ub of the optimal solution 
 an underestimation of the best cost that can be achieved extending the current partial assignment into a model  which is a lower bound lb of the current subproblem 
a soft conflict is detected when lb  ub  because it means that the current assignment cannot lead to
an optimal model  when a soft conflict is detected  the algorithm backtracks chronologically  note
  

fim ini m ax s at 

an

e fficient w eighted m ax  sat s olver

algorithm    minimaxsat propagation 
function ms up     conflict
while  q contains non propagated literals  do
  
l    getfirstnonpropagatedlit q   markaspropagated l   
  
  
lb    lb  v  l  
  
if lb  ub then return soft conflict  
    that becomes unit or falsified do
  
foreach hard clause  c l 

  
if  c  l     becomes unit  q     then enqueue q  q   
    becomes falsified then return hard conflict  
  
else if  c  l 
 u  that becomes unit do
  
foreach soft clause  c l 

  
if  c l  u  becomes a unit  q  u  then v  q     v  q    u  

  
  
  
  
  

return none  
function propagate     conflict
c    ms up     
if c   hard or soft conflict then return c  
improvelb     
if lb  ub then return soft conflict  
return none  

that one could also backjump by computing a clause expressing the reasons that led to lb  ub 
however  in the presence of lots of soft clauses  this approach ends up creating too many long
clauses which affect negatively to the efficience of the solver and hence we decided to perform
simple chronological backtracking 
we also want to remark that any soft clause  c  w  with w  ub must be satisfied in an optimal
assignment  therefore  in the following we assume that such soft clauses are automatically transformed into hard clauses previous to search  other than those ones  no other soft clause is promoted
into a hard one during the search 
an algorithmic description of m ini m ax s at is presented in algorithm    before starting the
search  a good initial upper bound is obtained with a local search method  line     which may yield
the identification of some new hard clauses  in our current implementation we use u bcsat  tompkins   hoos        with default parameters  the selected local search algorithm is irots  iterated
robust tabu search   smyth  hoos    stutzle         besides  the lower bound is initialized to
zero  next  the queue q is initialized with all unit hard clauses in the resulting formula  line     
the main loop starts in line    and each iteration is in charge of propagating all pending literals
 line     and  if no conflict is detected  attempting the extension of the current partial assignment
 line      pending literals in q are propagated in function propagate  line      which may return a hard or soft conflict  if a hard conflict is encountered  line     the conflict is analyzed  a
new hard clause is learned and backjumping is performed  this is done as introduced in section   
if a soft conflict is encountered  line     chronological backtracking is performed  if no conflict is
found  line      a literal is heuristically selected and added to q for propagation in the next iteration 
however  if the current assignment is complete  line      the upper bound is updated  search stops
if a zero cost solution is found  since it cannot be further improved  line      else  chronological
backtracking is performed  line      note that backjumping leads to termination if a top level hard
  

fih eras   l arrosa     o liveras

conflict is found  while chronological backtracking leads to termination if the two values for the first
assigned variable have been tried 
algorithm   describes the propagation process  function propagate   it uses an array v  l 
which accumulates the weight of all soft clauses that have become unit over l  namely  original
clauses  a  l  w  such that the current assignment falsifies a  if no such clauses exists  we assume
v  l       first of all  it performs a max sat adapted form of unit propagation  ms up  line     
ms up iterates over the non propagated literals l in q  line      firstly  adding l to the assignment
 we
may make a set of soft clauses falsified  since the cost of all such clauses is kept in v  l  
add it to the lower bound  line      if the lower bound increment identifies a soft conflict  it is
returned  line      then  if a hard clause becomes unit  the corresponding literal is added to q
for future propagation  line      finally  if a soft clause becomes a unit clause  q  u   line      its
weight u is added to v  q   line      if during this process a hard conflict is detected  the function
returns it  lines         else  the algorithm attempts to detect a soft conflict with a call to procedure
improvelb  line      and it returns the soft conflict if it is found  line      in the next section a
detailed description of improvelb can be found  finally  if no conflict is detected  the function
returns none  line     

   lower bounding in m ini m ax s at
in the following  we consider an arbitrary search state of m ini m ax s at before the call to the
procedure improvelb  for the purpose of this section  such a search state can be characterized
by the current assignment  the current assignment determines the current subformula which is the
original formula conditioned by the current assignment  if a clause contains a literal that is part of
the current assignment  it is removed  besides  all the literals whose negation appear in the current
assignment are removed from the clauses where they appear 
the value of lb maintained by m ini m ax s at is precisely the aggregation of costs of all the
clauses that have become empty due to the current assignment  similarly  we recall that the value
v  l  is the aggregation of costs of all the clauses that have become unit over l due to the current
assignment  thus  the current subformula contains     lb  and  l v  l   for every l 
m ini m ax s at computes its lower bound by deriving new soft empty clauses     w  through
a resolution process  such clauses are added to the already existing clause     lb  producing an
increment of the lower bound 
 w  by  l  u  m    l 
 w
as a first step  improvelb replaces each occurrence of  l  u  and  l 
m       m   with m   min u  w    which amounts to applying a restricted version of max sat resolution known as unit neighborhood resolution  unr   larrosa et al         
it produces an immediate increment of the lower bound  i e   the weight of the empty clause at
line     as it is illustrated in the following example 
example   consider the current state is           x         x         x         x         x   x         unr
would resolve on clauses  x       and  x       replacing them by  x       and         all other compensation clauses are removed because their weight is zero or they are tautologies   the two empty
clauses can be grouped into                 unr would also resolve on clauses  x       and  x      
replacing them by  x       and         the two empty clauses can be grouped into                 so 
the new equivalent formula is           x         x         x   x        with a higher lower bound of   
  

fim ini m ax s at 

an

e fficient w eighted m ax  sat s olver

algorithm    lower bounding in m ini m ax s at
function sup     conflict
  
initqueue q   
while  q contains non propagated literals  do
l    getfirstnonpropagatedlit q   markaspropagated l   
  
foreach  hard or soft  clause c  l that becomes unit or falsified do
if c  l becomes a unit q then enqueue q  q   
else if c  l becomes falsified then return conflict  

  
  
  
  
  
  
  

return none  
procedure improvelb     lb
 w   f do
foreach  l  v    l 
 w  m       m  with m    min  v  w   
replace them by  l  v  m    l 
while su p     con f lict do
    buildtree    
m    minimum weight among clauses in  
if condition then applyresolution    m    
else lb    lb   m  remove weight m from clauses in  

as a second step improvelb executes a simulation of unit propagation  sup  line     in
which soft clauses are treated as if they were hard  first  sup adds to q all unit soft clauses  line
     then  the new literals in q are propagated  when new  hard or soft  clauses become unit 
they are inserted in q  line      if sup yields a conflict  it means that there is a subset of  soft or
hard  clauses that cannot be simultaneously satisfied  we showed in section   that q can be used
to identify such subset and build a refutation tree   improvelb computes such a tree  line     
if we take into account again the weights of the clauses and apply max sat resolution  section   
as dictated by   one can see that it will produce a new clause     m   where m is the minimum
weight among all the clauses in the tree  line      it means that the extension of the current partial
assignment to the unassigned variables will have a cost of at least m 
it is important to remark that at each step in the max sat resolution process we do not consider
the minimum of the weight of the two clauses  but rather the minimum of all the clauses in the
resolution tree  this is why m is passed as a parameter in line    
the result of the resolution process is the replacement of all the clauses in the leaves of  by
    m  and the corresponding compensation clauses  function applyresolution in line     
thus obtaining an equivalent formula with a lower bound increment of m  we call this procedure
resolution based lower bounding 
example   consider the formula f     x          x   x          x   x          x   x   x          x  
x   x          x   x        
step    apply sup  initially  the unit clause  is enqueued producing q    kx       then
x  is propagated and q becomes  x    kx      x      x       literal x  is propagated and clause 
becomes unit  producing q    x      x    kx      x      x       after that  literal x  is propagated
and clause  is found to be conflicting  figure   a shows the state of q after the propagation 
  

fih eras   l arrosa     o liveras

f     x          x   x          x   x          x   x   x          x   x   x          x   x        

 x   x   x        x   x   x      

x    






x    



x    

 x   x   x      
 x   x   x   x        x   x   x        x   x      
 x   x   x   x      
 x   x      

 x   x      

 x   x      



x    
x    

 x      

 

 x      

      

a 

b 

c 

f       x   x         x   x                 x   x   x         x   x   x   x         x   x   x   x       
f

  

    x   x         x   x   x         x   x               

figure    graphical representation of m ini m ax s at lower bounding  on the top  the original
current formula f   on the left  the propagation q after step    in the middle  the structure
of the refutation tree computed by the simulation of up in step    on the right  the
effect of actually executing the max sat resolution  step     the resulting formula f  
appears bellow  if substraction based lower bounding is performed  step   is replaced by
a substraction of weights  producing formula f     

step    build the simulated refutation tree  starting from the tail of q the first clause clashing
with the conflicting clause  is   resolution between  and  generates the resolvent x   x   x   
the first clause clashing with x  is   producing resolvent x   x    the next clause clashing with
x  is  and resolution generates x    finally  we resolve with clause  and we obtain   figure   b
shows the resulting resolution tree 
step    apply max sat resolution  we apply max sat resolution as indicated by the refutation
tree computed in step    figure   c graphically shows the result of the process  leaf clauses are
the original  weighted  clauses involved in the resolution  each internal node indicates a resolution
step  the resolvents appear in the junction of the edges  beside each resolvent  inside a box  there
are the compensation clauses that must be added to the formula to preserve equivalence  since
clauses that are used in resolution must be removed  the resulting formula f   consists of the root of
  

fim ini m ax s at 

an

e fficient w eighted m ax  sat s olver

the tree          all compensation clauses and all clauses not used in the refutation tree  that is  the
resulting formula is f       x   x         x   x                 x   x   x         x   x   x   x         x  
x   x   x         the soundness of max sat resolution guarantees that f  f    
remark   all the transformations applied by the resolution based lower bounding can be passed
on to descendent nodes because the changes preserve equivalence  nevertheless  transformations
have to be restored when backtracking takes place 
an alternative to problem transformation through resolution is to identify the lower bound increment m and then substract it from all the clauses that would have participated in the resolution
tree  this procedure is similar to the lower bound computed by li et al         and we call it
substraction based  line     lower bounding 
example   consider formula f from the previous example  steps   and   are identical  however 
substraction based lower bounding would replace step   by step   that substracts weight   from
the clauses that appear in the refutation tree and then adds        to the formula  the result is
f        x   x         x   x   x         x   x                 note that f    v f  
remark   all the substractions applied by the substraction based lower bounding have to be restored before moving to a descendent node because they do not preserve equivalence 
after the increment of the lower bound with either technique  procedure sup can be executed
again  which may yield new lower bound increments  the process is repeated until sup does not
detect any conflict 
when comparing the two previous approaches  we observe that resolution based lower bounding
has a larger overhead  because resolution steps need to be actually computed and their consequences
must be added to the current formula and removed upon backtracking  however  the effort invested
in the transformation may be well amortized because the increment obtained in the lower bound
becomes part of the current formula  so it does not have to be discovered again and again by all
the descendent nodes of the search  on the other hand  substraction based lower bounding has a
smaller overhead because resolution needs not to be actually computed  this also facilitates the
context restoration upon backtracking 
m ini m ax s at incorporates the two alternatives and chooses to apply one or the other heuristically  lines        depending on a specific condition  line      we observed that resolution based
lower bounding seems to be more effective if resolution is only applied to low arity clauses  as a
consequence  after the identification of the resolution tree  m ini m ax s at applies resolution based
lower bounding only if the largest resolvent in the resolution tree has arity strictly less than    otherwise  it applies substraction based lower bounding  see section   for more details 

   additional features of m ini m ax s at
in this section we overview other important features of m ini m ax s at  namely the use of the twowatched literal scheme  its branching heuristic  the use of soft probing and how m ini m ax s at
deals with pseudo boolean functions 
  

fih eras   l arrosa     o liveras

    two watched literals
m ini m ax s at uses the two watched literal scheme also on soft clauses  recall that one of the main
advantages of this technique  when applied to pure sat problems  is that when backtracking takes
place  no work has to be done on the clauses  unfortunately  in the case of soft clauses some restoration needs to be done  when a soft clause becomes unit over literal l in function ms up  its weight
is added to v  l  and the clause is eliminated  or marked as eliminated  to avoid reusing it in the
lower bounding procedure  these changes  as well as any addition to lb  have to be restored when
backtracking is performed  however  note that during the executions of sup  simulation of unit
propagation  all clauses are considered as hard  in this case the two watched literal scheme works
exactly as in a sat solver with both hard and soft clauses  when an inconsistency is detected by
sup or it stops because there are no more literals to propagate  the initial state has to be recovered 
in that situation restoring the initial state is completely overhead free 
    branching heuristic
m ini m ax s at incorporates two alternative branching heuristics  the first one is the vsids heuristic  moskewicz et al         disregarding soft clauses  that is  m ini s at  s default   this heuristic is
likely to be good in structured problems in which learning and backjumping play a significant role 
as well as in problems in which it is difficult to find models  namely  the satisfaction component of
the problem is more difficult than the optimization component   since this heuristic disregards soft
clauses  it is likely to be ineffective in problems where it is easy to find models and the difficulty
is to find the optimal one and prove its optimality  in the extreme case  where problems only contain soft clauses  every complete assignment is a model  the vsids heuristic is blind and therefore
completely useless 
to overcome this limitation of vsids  m ini m ax s at also incorporates the weighted jeroslow
heuristic  heras   larrosa         it is the extension of the sat jeroslow heuristic described in
section    given a weighted formula f  for each literal l of f the following function is defined 
j l   



  c   w

 c w f
s t  lc

where mandatory clauses are assumed to have a weight equal to the upper bound ub  the heuristic
selects the literal with the highest value of j l   its main disadvantage is that metrics need to be
updated at each visited node  in combination with the two watched literal this updating becomes
expensive and does not seem to pay off in general  thus  in our current implementation of the
heuristic  the j l  values are computed only at the root node and used throughout all the solving
process  we found in our experiments that this heuristic is a good alternative in problems where
the difficulty lies on the optimization part  e g  problems with many models   m ini m ax s at
automatically changes from vsids to weighted jeroslow if the problem does not contain any literal
l such that there are some hard clauses with l and some other hard clauses with l 
in both heuristics  if there is some literal l such that v  l    lb  ub at some node of the search
tree  then l is the selected literal and l is never assigned 
  

fim ini m ax s at 

an

e fficient w eighted m ax  sat s olver

    soft probing
probing is a well known sat technique that allows the formulation of hypothetical scenarios  lynce
  silva         the idea is to temporarily assume that l is a hard unit clause and then execute unit
propagation  if up yields a conflict  we know that any model extending the current assignment must
contain l  the process is iterated over all the literals until quiescence  exhaustive experiments in
the sat context indicate that it is too expensive to probe during the search  le berre        lynce
  silva         so it is normally done as a pre process in order to reduce the initial number of
branching points 
we can easily extend this idea to max sat  in that context  besides the discovery of unit hard
clauses  it may be used to make explicit weighted unit clauses  we call it soft probing  as in sat  the
idea is to temporarily assume that l is a unit clause and then simulate unit propagation  i e   execute
sup     then  we build the resolution tree  from the propagation queue q  if all the clauses in 
are hard  we know that l must be added to the assignment  else  we can reproduce  applying max m  where m is the minimum
sat resolution with the weighted clauses and derive a unit clause  l 
weight among the clauses in   having unit soft clauses upfront makes the future executions of
improvelb much more effective in the subsequent search  besides  if we derive both  l  u  and
 w   we can generate via unit neighborhood resolution  see example    an initial non trivial lower
 l 
bound of min u  w   we tested soft probing during the search and as a preprocessing in several
benchmarks  we observed empirically that soft probing as a preprocessing was the best option as it
is in sat 

example   consider formula f     x   x          x   x          x   x          if we assume x  by
adding it to q and then execute sup a conflict is reached  we obtain q    xd    x      x      and
we detect that  is a conflicting clause  the clauses involved in the refutation tree are     and  
resolving clauses  and  results in   x   x          x   x         x   x   x         x   x   x         the
resolution of the previous resolvent and  produces the  equivalent  formula f       x         x  
x   x         x   x   x        
    pseudo boolean functions
a pseudo boolean optimization problem  pbo   barth        sheini   sakallah        een  
sorensson        has the form 
minimize nj   c j  x j
subject to nj   ai j l j  bi   i           m
where x j          l j is either x j or    x j   and c j   ai j and bi are non negative integers 
if m ini m ax s at is provided with a pbo instance  it translates it into a max sat formula as follows  each pseudo boolean constraint is translated into a set of hard clauses using m ini s at    een
  sorensson         the algorithm heuristically decides the most appropriate translation choosing
among adders  sorters or bdds   the objective function is translated into a set of soft unit clauses 
each summand c j  x j becomes a new soft unit clause  x j   c j    after the translation m ini m ax s at
is executed as usual 
  

fih eras   l arrosa     o liveras

   empirical results
in this section we present the benchmarks and the solvers used in our empirical evaluation  then 
we report the experiments performed in order to adjust the parameters of m ini m ax s at  finally  a
comparison with other solvers is presented 
    benchmarks and encodings
having a good set of problems is fundamental to show the effectiveness of new solvers  in the
following  we present several problems and we explain how to encode them as weighted max sat 
      m ax   k  sat
a k sat cnf formula is a cnf formula in which all clauses have size k  we generated random
unsatisfiable   sat and   sat formulas with the cnfgen generator  and solved the corresponding
max sat problem  in the benchmarks  we fixed the number of variables and varied the number of
clauses  which can be repeated 
      m ax   cut
given a graph g    v  e   a cut is defined by a subset of vertices u  v   the size of a cut is
the number of edges  vi   v j   such that vi  u and v j  v  u   the max cut problem consists on
finding a cut of maximum size  it can be encoded as max sat associating one variable xi to each
graph vertex  value true  respectively  false  indicates that vertex vi belongs to u  respectively  to
v  u    for each edge  vi   v j    there are two soft clauses  xi  x j        xi  x j       given a complete
assignment  the number of violated clauses is  e   s where s is the size of the cut associated to the
assignment  in our experiments we considered max cut instances extracted from random graphs of
   nodes with varying number of edges 
      m ax   one
given a satisfiable cnf formula  max one is the problem of finding a model with a maximum
number of variables set to true  this problem can be encoded as max sat by considering the
clauses in the original formula as mandatory and adding a weighted unary clause  xi      for each
variable in the formula  note that solving this problem is much harder than solving the usual sat
problem  because the search cannot stop as soon as a model is found  the optimal model must be
found and its optimality must be proved  we considered the max one problem over two types of
cnf formula  random   sat instances of     variables  generated with cnfgen   and structured
satisfiable instances coming from the      sat competition   
      m inimum v ertex c overing

and

m ax  c lique

given a graph g    v  e   a vertex covering is a set u  v such that for every edge  vi   v j   either
vi  u or v j  u   the size of a vertex covering is  u    the minimum vertex covering problem
consists in finding a covering of minimal size  it can be naturally formulated as  weighted  maxsat  we associate one variable xi to each graph vertex vi   value true  respectively  false  indicates
   a  van gelder ftp   dimacs rutgers edu pub challenge satisfiability contributed ucsc instances
   http   www satcompetition org      

  

fim ini m ax s at 

an

e fficient w eighted m ax  sat s olver

that vertex vi belongs to u  respectively  to v u    there is a binary hard  xi  x j      for each edge
 vi   v j    it specifies that one or both of these two vertices have to be in the covering because there
is an edge connecting them  there is a unary clause  xi      for each variable xi   in order to specify
that it is preferred not to add vertices to u   there is a simple way to transform minimum vertex
coverings into max cliques and vice versa  fahle        
in our experiments  we considered maximum clique instances extracted from random graphs
with     nodes and varying number of edges  we also considered the    max clique instances
from the dimacs challenge   
      c ombinatorial auctions
a combinatorial auction is defined by a set of goods g and a set of bidders that bid for indivisible
subsets of goods  each bid i is defined by the subset of requested goods gi  g and the amount of
money offered  the bid taker  who wants to maximize its revenue  must decide which bids are to be
accepted  note that if two bids request the same good  they cannot be jointly accepted  sandholm 
       in its max sat encoding  there is one variable xi associated to each bid  there are unit
clauses  xi   ui   indicating that if bid i is not accepted there is a loss of profit ui   besides  for each
pair i  j of conflicting bids  there is a mandatory clause  xi  x j      
in our experiments  we used the cats generator  k  leyton brown   shoham        that
allows to generate random instances inspired from real world scenarios  in particular  we generated
instances from the regions  paths and scheduling distributions  the number of goods was fixed to
   and we increased the number of bids  by increasing the number of bids  instances become more
constrained  namely  there are more conflicting pairs of bids  and harder to solve 
      m iscellaneous
we also considered the following sets of instances widely used in the literature 
 the unsatisfiable instances of the  nd dimacs implementation challenge   considered by
de givry  larrosa  meseguer  and schiex        and li et al          random   sat instances
 aim and dubois   pigeon hole problem  hole  and coloring problems  pret   observe that all
these instances are modelled as unweighted max sat  i e  all clauses have weight    
 max csp random instances generated using the protocol specified by larrosa and schiex
       and de givry  heras  larrosa  and zytnicki         we distinguish   different sets of
problems  dense loose  dl   dense tight  dt   sparse loose  sl  and sparse tight  st  
tight instances have about    variables while loose instances have about    variables  each
set contains    instances with   values and    instances with   values per variable 
 planning  cooper  cussat blanc  de roquemaurel    regnier        and graph coloring  
structured instances taken from a weighted constraint satisfaction problem  wcsp  repository    
  
  
  
  

ftp   dimacs rutgers edu pub challenge graph benchmarks clique
http   mat gsia cmu edu challenge html
http   mat gsia cmu edu coloring   benchmarks
http   mulcyber toulouse inra fr plugins scmcvs cvsweb php benchs  cvsroot toolbar

  

fih eras   l arrosa     o liveras

 problems taken from the      pseudo boolean evaluation     logic synthesis  misc  garden  
routing  mpi  minimum prime implicant   mps  miplib   these instances are encoded to
max sat as specified in the previous section 
note that max csp  planning and graph coloring instances are encoded into max sat using the
direct encoding  walsh        
    alternative solvers
we compare m ini m ax s at with several optimizers from different communities  we restricted our
comparison to freely available solvers  we considered the following ones 
 m axsatz  li et al         li  manya    planes         unweighted max sat solver  it was
the best unweighted max sat solver in the      max sat evaluation 
 m ax  dpll  heras   larrosa        larrosa et al          weighted max sat solver  it is
part of the t oolbar package  it was the best solver for weighted max sat and the second
best solver for unweighted max sat in the      max sat evaluation 
 t oolbar  larrosa        larrosa   schiex        de givry et al                it is a
state of the art weighted csp solver 
 p ueblo      sheini   sakallah         it is a pseudo boolean solver  it ranked first on
several categories of the      pseudo boolean evaluation 
 m inisat    een   sorensson         it is a pseudo boolean solver that translates the problems into sat and solves them with minisat  it ranked first on several categories of the     
pseudo boolean evaluation 
those instances taken from the pseudo boolean evaluation were given in their original format to
p ueblo and m inisat    all other instances were translated from max sat to pbo by partitioning
the set of clauses into three sets  h contains the mandatory clauses  c      w contains the nonunary weighted clauses  c  u      and u contains the unary weighted clauses  l  u   for each
hard clause  c j       h there is a pseudo boolean constraint c j     where c j is obtained from
c j by replacing  by   and negated variables x by    x  for each non unary weighted clause
 c j   u j    w there is a pseudo boolean constraint c j   r j     where c j is computed as before 
and r j is a new variable that  when set to    trivially satisfies the constraint  finally  the objective
function to minimize is 



u jr j  



u jl j

 l j  u j  u

 c j  u j  w

    experimental results
we divide the experiments in two parts  the purpose of the first part is to evaluate the impact
of the different techniques of m ini m ax s at and set the different parameters  since some of the
techniques can be effective in some benchmarks and useless or even counterproductive in some others  brglez  li    stallman         we aimed at finding a configuration such that m ini m ax s at
   http   www cril univ artois fr pb   

  

fim ini m ax s at 

an

e fficient w eighted m ax  sat s olver

performs reasonably well on all the instances  the purpose of the second part is to compare m in i m ax s at with alternative solvers  since some of these solvers are specifically designed for some
type of problems  we do not expect that m ini m ax s at will outperform them  we rather want to
show the robustness of m ini m ax s at by showing that it is usually close in performance with the
best alternative for each type of problems 
results are presented in plots and tables  regarding tables  the first column contains the name
of the set of problems  the second column shows the number of instances  the remaining columns
report the performance of the different solvers  each cell contains the average cpu time that the
solver required to solve all instances  if some solver could not solve all the instances of a set  a
number inside brackets indicates the number of solved instances and the average cpu time only
takes into account solved instances  if a cell contains a dash  it means that no instance could be
solved within the time limit  regarding plots  note that the legend goes in accordance with the
performance of the solvers  the time limit was set to     seconds for each instance 
our solver  written in c    was implemented on top of m inisat    een   sorensson        
executions were made on a     ghz xeon computer with linux  in all the experiments with random
instances  samples had    instances and plots report mean cpu time in seconds 
    setting the parameters of m ini m ax s at
in the following we evaluate in order the importance of the following techniques inside m ini m ax s at  lower bounding  soft probing  branching heuristics  learning and backjumping 
starting from a basic version that guides search with the jeroslow branching heuristic and has
the rest of techniques deactivated  we analyze them one by one  each analysis studies one technique
and incorporates all the previously analyzed ones with the corresponding tuned parameters  in the
three first experiments we only consider little but challenging instances generated randomly in which
lower bounding plays a fundamental role to solve them  finally  we consider structured instances in
which learning and backjumping is required to solve them 
      l ower

bounding

in this experiment we analyze the impact of resolution based lower bounding versus substractionbased lower bounding  as well as combined strategies  we considered the following combination
of the two techniques  when sup detects an inconsistency and the refutation tree is computed 
we look at the resolvent with maximum size  if its size is less than or equal to a parameter k 
then resolution based lower bounding is applied  otherwise substraction based lower bounding is
applied  we tested k                         note that k     corresponds to pure substraction based
lower bounding  and therefore is similar to the approach of li et al          while k    corresponds
to a pure resolution based lower bounding 
the results are presented in figure    as can be seen  the pure substraction based lower bounding k     is always the worst option  better results are obtained as k increases  however  the
improvement stops  or nearly stops  when k      when k     no significant improvement is noticed  the plot omits the k     and k     case for clarity reasons  since higher values of k may
produce new clauses of higher size and this may cause overhead in some instances  we set k    
for the rest of the experiments 
  

fih eras   l arrosa     o liveras

 a  max   sat      variables

  
  

 b  max   sat     variables

k  
k  
k  
k  
k inf

cpu time

cpu time

  

 
 
                           

  
  
  
  
  
  
 

k  
k  
k  
k inf
k  

   

number of clauses

   

   

   

   

   

number of clauses

cpu time

 c  max cut     nodes
  
  
  
 
 
 
 
 
   

k  
k  
k  
k  
k inf

   

   

   

   

   

number of nodes

figure    performance of m ini m ax s at with different mixed lower boundings  k               inf  

      s oft

probing

in our second experiment  we evaluate the impact of soft probing  in our preliminary experiments 
we observed that soft probing was too time consuming  so we decided to limit soft probing as
follows  initially  we assign a propagation level of   to the variable to probe  then  each new literal
to propagate is assigned a propagation level l     if the literal that produces its propagation has
level l  we limited probing to propagate literals with a maximum propagation level of m  we
finally restricted m    since it gives the best results  note that a propagation level is not the same
as a decision level 
we compare three alternatives  probing at each node of the search  s   probing as a pre process
before search  p  and no probing at all  n   the results  in figure    indicates that probing during
search is the worst option for max   sat and max   sat while it produces some improvement in
max cut  finally  probing as a preprocessing gives slightly improvement for max   sat and the
best results for max cut  note that soft probing as a preprocessing on max   sat has no effect
and is omitted from the plot  its results are similar to n   given these results  we decided to include
soft probing only as a preprocessing 
      j eroslow

branching heuristic

in the following experiment  we evaluate the importance of the weighted jeroslow heuristic  figure
  shows the time difference between m ini m ax s at with the jeroslow heuristic as in the previous
two experiments  jeroslow  and without heuristic  none   the results indicates that guiding search
with the jeroslow heuristic gives important speed ups  hence  we maintain the jeroslow heuristic
for m ini m ax s at 
  

fim ini m ax s at 

an

e fficient w eighted m ax  sat s olver

 a  max   sat      variables

cpu time

  
  

 b  max   sat     variables

s
n
p

cpu time

  

  
 
 
                           

  
  
  
  
  
  
  
 

s
n

   

number of clauses

   

   

   

   

   

number of clauses
 c  max cut     nodes

 

cpu time

 

n
s
p

 
 
 
 
   

   
   
   
number of nodes

   

figure    performance of m ini m ax s at without soft probing  with probing as preprocessing  p 
and with probing during the search  s  

      l earning  

backjumping and

vsids

in the final experiment  we evaluate the importance of learning and backjumping  for these experiments we use structured instances  since it is well known that learning and backjumping are only
useful in this type of problems  besides  we also evaluate the importance of the vsids heuristic
in combination with learning and backjumping  recall that this heuristic was specially designed to
work in cooperation with learning  so it is meaningless to analyze its effect by itself 
table   reports the results of this experiment  the third column reports results without learning
and backjumping but with the lower bounding  probing and the jeroslow heuristic  none   the
fourth column reports results adding learning and backjumping to the previous version  learning  
the fifth column reports results adding learning  backjumping but changing the jeroslow heuristic
by the vsids heuristic  vsids   the results show that m ini m ax s at without learning and backjumping  none  is clearly the worst option  significant improvements are obtained when learning
and backjumping  learning  are added  finally  adding the vsids heuristic  vsids  improve further the results specially on the routing instances  based on those results  we incorporated learning
and backjumping to m ini m ax s at 
regarding the branching heuristic  for problems in which literals appear in hard clauses with
both polarities it applies the vsids heuristic  otherwise the jeroslow heuristic is computed in the
root of the search tree as stated in section    this choice is done once and for all before starting the
search 
  

fih eras   l arrosa     o liveras

 a  max   sat      variables

  

 b  max   sat     variables
   

none
jeroslow

none
jeroslow

  
cpu time

cpu time

  

  
 

  
  
  

 
                           

 
   

number of clauses

   

   

   

   

   

number of clauses
 c  max cut     nodes

 
cpu time

 

none
jeroslow

 
 
 
 
                           
number of nodes

figure    performance of m ini m ax s at without heuristic  none  and with the jeroslow heuristic
computed in the root node of the search tree  jeroslow  

problem
max one  col
max one cnt
max one dp
max one ezfact  
routing s 
routing s 

n  inst 
  
 
 
  
 
  

none

        
        
         
        


learning
     
      
     
    
    
         

vsids
     
    
     
    
    
        

figure    structured instances 
    comparison with other boolean optimizers
when reporting results  we will omit a solver if it cannot deal with the corresponding instances
for technical reasons  e g  it cannot deal with weighted clauses  or it performs extremely bad in
comparison with the others 
figure   contains plots with the results on different benchmarks  plots a and b reports results on
random unweighted max sat instances  p ueblo and m inisat   are orders of magnitude slower 
so they are not included in the graphics  on max   sat  plot a   m ini m ax s at lays between
m ax  dpll and m axsatz  which is the best option  on max   sat  plot b  m ini m ax s at
clearly outperforms m ax  dpll and is very close to m axsatz  which is again the best  in both
max   sat and max   sat m axsatz is no more than   times faster than m ini m ax s at 
  

fim ini m ax s at 

an

e fficient w eighted m ax  sat s olver

plot c reports results on random max cut instances  m ini m ax s at performs slightly better
than m axsatz  which is the second alternative 
on random max one  plot d  m ini m ax s at is the best solver by far  almost all instances are
solved instantly while p ueblo and m ax  dpll require up to    seconds in the most difficult instances  m inisat   performs very poorly  the results on structured max one instances are reported
in figure    m inisat   seems to be the fastest in general  m ini m ax s at is close in performance
to p ueblo  note  however  that in the d p instances  m ini m ax s at is the only system solving all
instances 
plot e reports the results on random max clique instances  m ini m ax s at is the best solver  up
to an order of magnitude faster than m ax  dpll  the second best option  p ueblo and m inisat  
perform poorly again  regarding the structured dimacs instances  m ini m ax s at is again the best
option  it solves    instances within the time limit  while m ax  dpll m inisat   and p ueblo
solve        and    respectively 
plots f   g and h present the results on combinatorial auctions following different distributions 
on the paths distribution  m ini m ax s at is the best solver  twice faster than m ax  dpll  which
ranks second  on the regions distribution  m ini m ax s at is the best solver while m ax  dpll is
the second best solver requiring double time  on the paths and regions distributions  p ueblo and
m inisat   perform very poorly  on the scheduling distribution  m inisat   is the best solver while
m ini m ax s at and m ax  dpll are about one order of magnitude slower 
results regarding the unsatisfiable dimacs instances are presented in figure    note that all
these instances have optimum cost    hence  as soon as m ini m ax s at find a solution of cost   
all the clauses are declared hard and learning and backjumping can be applied when hard conflicts
arise  the results indicate that m axsatz and m ax  dpll do not solve any instance on some sets
 pret    and aim      while m ini m ax s at solves all sets of instances with the best times in all
of them  except for the hole instances in which m axsatz is slightly faster  if we encode these
problems in the most advantageous way for p ueblo and m inisat    that is  as decision problems
rather than optimization problems they solve all the instances with similar times to m ini m ax s at 
on the planning instances  fig      p ueblo is the best solver  m ini m ax s at is the second best
solver  t oolbar is the third and the last one is m inisat    this is not surprising since t oolbar
does not perform learning over the hard constraints  results regarding graph coloring instances are
presented in fig      as can be observed  m ini m ax s at is able to solve one more instance than
t oolbar  while p ueblo and m inisat   solve many less instances  on the max csp problems
 fig      t oolbar solves all the instances instantly while p ueblo is the worst option unable to
solve a lot of instances  m ini m ax s at is clearly the second best solver and m ini s at   is the third
best performing solver  note that both of them solve all the instances 
results regarding the instances taken from the pseudo boolean evaluation can be found in figure
    note that this is the first time that a max sat solver is tested on pseudo boolean instances 
results indicate that no solver consistently outperforms the other and that m ini m ax s at is fairly
competitive with p ueblo and m inisat   
from all these results we can conclude that m ini m ax s at is a very robust weighted maxsat solver  it is very competitive for pure optimization problems and for problems with lots of
hard clauses and  sometimes  it is the best option 
as a final remark  note that m ini m ax s at and almost all the previous benchmarks were submitted to the second max sat evaluation       a co located event of the tenth international conference on theory and applications of satisfiability testing  hence  the interested reader can find a
  

fih eras   l arrosa     o liveras

 a  max   sat      variables
  
  

cpu time

max dpll
minimaxsat
maxsatz

  
cpu time

 b  max   sat     variables

  
  
 
                               

   
   
   
   
   
  
 

max dpll
minimaxsat
maxsatz

                           

number of clauses

number of clauses

 c  max cut     nodes

 

cpu time

max dpll
maxsatz
minimaxsat

  
cpu time

 d  max one  random   sat      variables

 
 
 
 
   

   

   

   

   

  
minisat 
  
pueblo
max dpll
  
minimaxsat
  
  
 
 
                                   

number of edges

number of hard clauses

 e  max clique      nodes
  

minisat 
pueblo
max dpll
minimaxsat

  

pueblo
minisat 
max dpll
minimaxsat

  
cpu time

  
cpu time

 f  c  auctions paths     goods
   

  
  

  
  
  

 

 
 

  

  

  

   

                                

connectivity    

number of bids

 g  c  auctions scheduling     goods

cpu time

  
  

 h  c  auctions regions     goods
  

pueblo
max dpll
minimaxsat
minisat 

cpu time

  

  

  
  

minisat 
pueblo
max dpll
minimaxsat

 

  
 

 
   

                                
number of bids

   

   

   

   

   

number of bids

figure    plots of different benchmarks  note that the order in the legend goes in accordance with
the performance of the solvers 

more exhaustive comparison  including more instances and solvers  in the second max sat evaluation      web page    the results of such evaluation showed that m ini m ax s at was the best
performing solver in two of the four existing categories 
   http   www maxsat   udl es 

  

fim ini m ax s at 

an

n  inst 
  
 
 
 
 
 
 

problem
dubois
pret  
pret   
hole
aim  
aim   
aim   

e fficient w eighted m ax  sat s olver

m ini m ax s at
    
    
    
    
    
    
    

m axsatz
         
     

    
    
    


m ax  dpll
         
     

     
    
      


figure    unsatisfiable dimacs instances 

problem
 col  
 col   
 col   
 col   
cnt
dp
ezfact  

n  inst 
  
  
  
  
 
 
  

m ini m ax s at
    
    
     
     
    
     
    

p ueblo
    
    
     
     
    
       
    

m inisat  
    
    
    
    
    
       
    

figure    structured max one instances 

problem
planning
graph coloring
max csp dl
max csp dt
max csp sl
max csp st

n  inst 
  
  
  
  
  
  

toolbar
    
         
    
    
    
    

m ini m ax s at
    
        
    
    
    
    

p ueblo
    
         
          

      


m inisat  
    
        
    
    
    
    

figure     results for wcsp and max csp instances 

   related work
some previous work has been done about incorporating sat techniques inside a max sat solver 
alsinet et al         presented a lazy data structure to detect when clauses become unit  but it requires a static branching heuristic  argelich and manya      a  test different versions of a branch
and bound procedure  one of these versions uses the two watched literals  but it uses a very basic
lower bounding  we can conclude that none of these previous approaches is as general as our use of
the two watched literals  as far as we know  the rest of max sat solvers are based on adjacency
lists  therefore  they are presumably inefficient for unit propagation  lynce   silva         par  

fih eras   l arrosa     o liveras

problem
misc
logic synthesis
mpi
mps
routing

n  inst 
 
  
   
  
  

m ini m ax s at
       
        
          
        
         

p ueblo
       
        
          
        
    

m inisat  
       
         
         
       
     

figure     results for pseudo boolean instances 
ticularly in the presence of long clauses  argelich and manya      b  enhance a max sat branch
and bound procedure with learning over hard constraints  but it is used in combination with simple lower bounding techniques  an improved version is presented by argelich and manya       
with a more powerful lower bound  but it does not incorporate the two watched literal scheme 
backjumping  etc  to the best of our knowledge  no max sat solver incorporates backjumping 
note that m ini m ax s at restricts backjumping to the occurrence of hard conflicts  related works
on the integration of backjumping techniques into branch and bound include work by zivan and
meisels        for weighted csp  manquinho and silva        for pseudo boolean optimization 
and nieuwenhuis and oliveras        for sat modulo theories 
most max sat solvers use variations of what we call substraction based lower bounding  in
most cases  they search for special patterns of mutually inconsistent subsets of clauses  shen  
zhang        xing   zhang        alsinet et al          for efficiency reasons  these patterns are
always restricted to small sets of small arity clauses    or   clauses or arity less than     m ini m ax s at uses a natural weighted extension of the approach proposed by li et al          it was the
first one able to detect inconsistencies in arbitrarily large sets of arbitrarily large clauses 
the idea of what we call resolution based lower bounding was inspired from the wcsp domain
 larrosa        larrosa   schiex        de givry et al               and it was first proposed in
the max sat context by larrosa and heras        and further developed by li et al          heras
and larrosa         and larrosa et al          in these works  only special patterns of fixed size
resolution trees were executed  the use of simulated unit propagation allows m ini m ax s at to
identify arbitrarily large resolution trees  in the following example  we present two inconsistent
subsets of clauses that are detected by m ini m ax s at and transformed into an equivalent formula
while previous solvers cannot transform them since they are limited to specific patterns 
   x    w      x    w      x    w      x   x   x    w    
   x    w      x   x    w      x   x   x    w      x   x   x   x    w      x   x   x   x    w    
in the first case  m ini m ax s at replaces the clauses by     m  with m   min w    w    w    w   
and a set of compensation clauses  for the second case  m ini m ax s at replaces it by     m  with
m   min w    w    w    w    w    and a set of compensation clauses  in both cases  the equivalence is
preserved  however  other solvers in the literature detect those inconsistent subset of clauses but
cannot transform the problem into an equivalent one  li et al         or simply cannot detect them
 heras   larrosa        
our probing method to derive weighted unit clauses is related to the    res and cycle rule
of heras and larrosa        and larrosa et al          to failed literals of li et al          and
  

fim ini m ax s at 

an

e fficient w eighted m ax  sat s olver

to singleton consistency in csp  debruyne   bessiere         again  the use of simulated unit
propagation allows m ini m ax s at to identify arbitrarily large resolution trees 

    conclusions and future work
m ini m ax s at is an efficient and very robust max sat solver that can deal with hard and soft
clauses as well as pseudo boolean functions  it incorporates the best available techniques for each
type of problems  so its performance is similar to the best specialized solver  besides the development of m ini m ax s at combining  for the first time  known techniques from different fields  the
main original contribution of this paper is a novel lower bounding technique based on resolution 
m ini m ax s at lower bounding combines in a very clean and elegant way most of the approaches that have been proposed in the last years  mainly based on unit propagation based lower
bounding and resolution based problem transformation  in this paper we use the information provided by the propagation queue  i  to determine a subset of inconsistent clauses and  ii  to determine
a simple ordering in which resolution can be applied to increase the lower bound and generate an
equivalent formula  however  this is not necessarily the best ordering to do so  it is easy to see that
different orderings may generate resolvents and compensation clauses of different arities  if one
selects the ordering that generates the smallest resolvents and compensation clauses the resulting
formula may be presumably simpler  future work concerns the study of such orderings  the development of vsids like heuristics for soft clauses and backjumping techniques for soft conflicts 

acknowledgments
we would like to thank to niklas een and niklas sorensson for making m inisat   code publicly
available  we are also grateful to the anonymous referees for their helpful suggestions on improving
the paper 
this work has been partially supported by the spanish ministry of education and science
through the projects tin           c       heras and larrosa  and tin            oliveras  

references
alsinet  t   manya  f     planes  j          improved exact solvers for weighted max sat  in
proceedings of sat    vol       of lncs  pp          springer 
argelich  j     manya  f       a   exact max sat solvers for over constrained problems  j 
heuristics                  
argelich  j     manya  f       b   learning hard constraints in max sat  in proceedings of
csclp    vol       of lncs  pp       springer 
argelich  j     manya  f          partial max sat solvers with clause learning  in proceedings
of sat    vol       of lncs  pp        springer 
barth  p          a davis putnam based enumeration algorithm for linear pseudo boolean optimization  research report mpi i           max planck institut fur informatik  im stadtwald  d       saarbrucken  germany 
brglez  f   li  x     stallman  m          the role of a skeptic agent in testing and benchmarking
of sat algorithms  in in proceedings of sat    pp         
  

fih eras   l arrosa     o liveras

buro  m     buning  h  k          report on a sat competition  bulletin of the european
association for theoretical computer science             
cha  b   iwama  k   kambayashi  y     miyazaki  s          local search algorithms for partial
maxsat  in proceedings of aaai    pp          the mit press 
cooper  m   cussat blanc  s   de roquemaurel  m     regnier  p          soft arc consistency
applied to optimal planning  in proceedings of cp    vol       of lncs  pp         
springer 
davis  m   logemann  g     loveland  g          a machine program for theorem proving  communications of the acm            
de givry  s   heras  f   larrosa  j     zytnicki  m          existential arc consistency  getting
closer to full arc consistency in weighted csps  in proceedings of the   th ijcai  pp       
professional book center 
de givry  s   larrosa  j   meseguer  p     schiex  t          solving max sat as weighted csp  in
proceedings of cp    vol       of lncs  pp          springer 
debruyne  r     bessiere  c          some practicable filtering techniques for the constraint satisfaction problem  in proceedings of icjai    pp          morgan kaufmann 
een  n     sorensson  n          an extensible sat solver  in proceedings of sat    vol      
of lncs  pp          springer 
een  n     sorensson  n          translating pseudo boolean constraints into sat  journal on
satisfiability  boolean modeling and computation         
fahle  t          simple and fast  improving a branch and bound algorithm for maximum clique 
in proceedings of esa    vol       of lncs  pp          springer 
freeman  j  w          improvements to propositional satisfiability search algorithms  ph d 
thesis  university of pennsylvania 
fu  z     malik  s          on solving the partial max sat problem  in proceedings of sat   
vol       of lncs  pp          springer 
heras  f     larrosa  j          new inference rules for efficient max sat solving  in proceedings
of the   th aaai  aaai press 
jeroslow  r  g     wang  j          solving propositional satisfiability problems  annals of mathematics and artificial intelligence            
k  leyton brown  m  p     shoham  y          towards a universal test suite for combinatorial
auction algorithms  in proceedings of acm conference on electronic commerce    pp 
     
karloff  h  j     zwick  u          a     approximation algorithm for max  sat   in focs 
pp         
larrosa  j     heras  f          resolution in max sat and its relation to local consistency for
weighted csps  in proceedings of ijcai    pp          professional book center 
larrosa  j   heras  f     de givry  s          a logical approach to efficient max sat solving  in
artificial intelligence  to appear 
  

fim ini m ax s at 

an

e fficient w eighted m ax  sat s olver

larrosa  j     schiex  t          in the quest of the best form of local consistency for weighted
csp  in proceedings of the   th ijcai  pp         
larrosa  j          node and arc consistency in weighted csp  in proceedings of aaai    pp 
      aaai press 
le berre  d          exploiting the real power of unit propagation lookahead  in proceedings of
lics workshop on theory and applications of satisfiability testing 
le berre  d          the sat j project for max sat   http   www sat j org  
li  c   manya  f     planes  j          exploiting unit propagation to compute lower bounds
in branch and bound max sat solvers  in proceedings of cp    vol       of lncs  pp 
       
li  c   manya  f     planes  j          new inference rules for max sat  in journal of artificial
intelligence research  to appear 
li  c  m   manya  f     planes  j          detecting disjoint inconsistent subformulas for computing lower bounds for max sat  in proceedings of the   th aaai  aaai press 
lynce  i     silva  j  p  m          probing based preprocessing techniques for propositional
satisfiability  in proceedings of ictai    pp          ieee computer society 
lynce  i     silva  j  p  m          efficient data structures for backtrack search sat solvers  ann 
math  artif  intell                 
manquinho  v  m     silva  j  p  m          satisfiability based algorithms for boolean optimization  ann  math  artif  intell                   
moskewicz  m  w   madigan  c  f   zhao  y   zhang  l     malik  s          chaff  engineering an
efficient sat solver  in proceedings of dac    pp          acm 
nieuwenhuis  r     oliveras  a          on sat modulo theories and optimization problems  in
proceedings of sat    vol       of lncs  pp          springer 
papadimitriou  c          computational complexity  addison wesley  usa 
sandholm  t          an algorithm for optimal winner determination in combinatorial auctions 
in proceedings of ijcai    pp          morgan kaufmann 
sheini  h  m     sakallah  k  a          pueblo  a hybrid pseudo boolean sat solver  journal
on satisfiability  boolean modeling and computation            
shen  h     zhang  h          study of lower bounds for max   sat  in proceedings of aaai   
pp          aaai press   the mit press 
silva  j  p  m     sakallah  k  a          grasp   a new search algorithm for satisfiability  in
iccad  pp         
smyth  k   hoos  h  h     stutzle  t          iterated robust tabu search for max sat  in
proceedings of ai    vol       of lncs  pp          springer 
tompkins  d  a  d     hoos  h  h          ubcsat  an implementation and experimentation
environment for sls algorithms for sat   max sat  in proceedings of sat    vol 
     of lncs  pp          springer 
walsh  t          sat v csp  in proceedings of cp    vol       of lncs  pp          springer 
  

fih eras   l arrosa     o liveras

xing  z     zhang  w          maxsolver  an efficient exact algorithm for  weighted  maximum
satisfiability  artificial intelligence                 
zhang  l   madigan  c  f   moskewicz  m  w     malik  s          efficient conflict driven learning in boolean satisfiability solver  in proceedings of iccad    pp         
zivan  r     meisels  a          conflict directed backjumping for maxcsps  in proceedings of
ijcai    pp         

  

fi