journal artificial intelligence research                  

submitted        published      

complexity planning problems
simple causal graphs
omer gimenez

omer gimenez upc edu

dept  de llenguatges sistemes informatics
universitat politecnica de catalunya
jordi girona     
      barcelona  spain

anders jonsson

anders jonsson upf edu

dept  information communication technologies
passeig de circumvallacio   
      barcelona  spain

abstract
present three new complexity results classes planning problems simple
causal graphs  first  describe polynomial time algorithm uses macros generate plans class  s planning problems binary state variables acyclic
causal graphs  implies plan generation may tractable even planning
problem exponentially long minimal solution  prove problem
plan existence planning problems multi valued variables chain causal graphs
np hard  finally  show plan existence planning problems binary state
variables polytree causal graphs np complete 

   introduction
planning area research artificial intelligence aims achieve autonomous
control complex systems  formally  planning problem obtain sequence
transformations moving system initial state goal state  given description
possible transformations  planning algorithms successfully used variety
applications  including robotics  process planning  information gathering  autonomous
agents spacecraft mission control  research planning seen significant progress
last ten years  part due establishment international planning
competition 
important aspect research planning classify complexity solving
planning problems  able classify planning problem according complexity
makes possible select right tool solving it  researchers usually distinguish
two problems  plan generation  problem generating sequence transformations achieving goal  plan existence  problem determining whether
sequence exists  original strips formalism used  plan existence undecidable first order case  chapman        pspace complete propositional
case  bylander         using pddl  representation language used international
planning competition  plan existence expspace complete  erol  nau    subrahmanian         however  planning problems usually exhibit structure makes much
c
    
ai access foundation  rights reserved 

figimenez   jonsson

easier solve  helmert        showed many benchmark problems used
international planning competition fact p np 
common type structure researchers used characterize planning problems called causal graph  knoblock         causal graph planning
problem graph captures degree independence among state variables
problem  easily constructed given description problem transformations  independence state variables exploited devise algorithms
efficiently solving planning problem  causal graph used tool
describing tractable subclasses planning problems  brafman   domshlak        jonsson
  backstrom        williams   nayak         decomposing planning problems
smaller problems  brafman   domshlak        jonsson        knoblock        
basis domain independent heuristics guide search valid plan  helmert 
      
present work explore computational complexity solving planning problems simple causal graphs  present new results three classes planning problems studied literature  class  s  jonsson   backstrom         class cn
 domshlak   dinitz         class planning problems polytree causal graphs
 brafman   domshlak         brief  show plan generation instances
first class solved polynomial time using macros  plan existence
solvable polynomial time remaining two classes  unless p   np  work first
appeared conference paper  gimenez   jonsson         current paper provides
detail additional insights well new sections plan length cp nets 
planning problem belongs class  s causal graph acyclic state
variables either static  symmetrically reversible splitting  see section   precise definition terms   class  s introduced studied jonsson
backstrom        example class plan existence easy  there exists
polynomial time algorithm determines whether particular planning problem
class solvable  plan generation hard  there exists polynomial time algorithm generates valid plan every planning problem class   precisely 
jonsson backstrom showed planning problems class  s
every valid plan exponentially long  clearly prevents existence efficient
plan generation algorithm 
first contribution show plan generation  s fact easy
allowed express valid plan using macros  macro simply sequence operators
macros  present polynomial time algorithm produces valid plans
form planning problems class  s  namely  algorithm outputs polynomial
time system macros that  executed  produce actual valid plan planning
problem instance  algorithm sound complete  is  generates valid plan
one exists  contrast algorithm incremental algorithm proposed
jonsson backstrom         polynomial size output 
investigate complexity class cn planning problems multivalued state variables chain causal graphs  words  causal graph
directed path  domshlak dinitz        showed solvable instances
class require exponentially long plans  however  case class  s 
could exist efficient procedure generating valid plans cn instances using
   

ficomplexity planning problems

macros novel idea  show plan existence cn np hard  hence
ruling efficient procedure exists  unless p   np 
prove plan existence planning problems whose causal graph polytree  i e   underlying undirected graph acyclic  np complete  even restrict
problems binary variables  result closes complexity gap appears brafman domshlak        regarding planning problems binary variables  authors
show plan existence np complete planning problems singly connected causal
graphs  plan generation polynomial planning problems polytree causal
graphs bounded indegree  use reduction prove similar problem
polytree cp nets  boutilier  brafman  domshlak  hoos    poole        np complete 
    related work
several researchers used causal graph devise algorithms solving planning
problems study complexity planning problems  knoblock        used
causal graph decompose planning problem hierarchy increasingly abstract
problems  certain conditions  solving hierarchy abstract problems easier
solving original problem  williams nayak        introduced several restrictions
planning problems ensure tractability  one causal graph
acyclic  jonsson backstrom        defined class  s planning problems 
requires causal graphs acyclic  showed plan existence polynomial
class 
domshlak dinitz        analyzed complexity several classes planning
problems acyclic causal graphs  brafman domshlak        designed polynomialtime algorithm solving planning problems binary state variables acyclic causal
graph bounded indegree  brafman domshlak        identified conditions
possible factorize planning problem several subproblems solve
subproblems independently  claimed planning problem suitable
factorization causal graph bounded tree width 
idea using macros planning almost old planning  fikes   nilsson 
       minton        developed algorithm measures utility plan fragments
stores macros deemed useful  korf        showed macros
exponentially reduce search space size planning problem chosen carefully  vidal
       used relaxed plans generated computing heuristics produce macros
contribute solution planning problems  macro ff  botea  enzenberger  muller 
  schaeffer         algorithm identifies caches macros  competed fourth
international planning competition  authors showed macros help reduce
search effort necessary generate valid plan 
jonsson        described algorithm uses macros generate plans planning
problems tree reducible causal graphs  exist planning problems
algorithm generate exponentially long solutions polynomial time  algorithm  s  unlike ours  algorithm handle multi valued variables  enables
solve problems towers hanoi  however  planning problems  s
tree reducible causal graphs  algorithm cannot used show plan generation
 s polynomial 
   

figimenez   jonsson

    hardness plan length
contribution paper show plan generation may polynomial even
planning problems exponential length minimal solutions  provided solutions may
expressed using concise notation macros  motivate result
discuss consequences  previously  thought plan generation planning
problems exponential length minimal solutions harder np  since
known whether problems np intractable  certain cannot generate
exponential length output polynomial time 
however  planning problem exponential length minimal solution 
clear plan generation inherently hard  difficulty lies fact
plan long  consider two functional problems
f   f     w      f     
f   f     w t f      f     
f   cnf formula   f   number clauses f   w   k  word containing
k copies symbol   t f     f satisfiable  i e   f  sat    
not  cases  problem consists generating correct word  observe
f  f  provably intractable  since output exponential size input 
nevertheless  intuitive regard problem f  easier problem f    one way
formalize intuition allow programs produce output succinct
notation  instance  allow programs write w  k  instead string containing
k copies symbol   problem f  becomes polynomial  problem f 
 unless p   np  
wanted investigate following question  regarding class  s  plan generation intractable solution plans long  f    problem intrinsically hard  f    answer plan generation  s solved polynomial
time  provided one allowed give solution terms macros  macro
simple substitution scheme  sequence operators and or macros  back
claim  present algorithm solves plan generation  s polynomial time 
researchers argued intractability using fact plans may exponential length  domshlak dinitz        proved complexity results several classes
planning problems multi valued state variables simple causal graphs  argued
class cn planning problems chain causal graphs intractable since plans
may exponential length  brafman domshlak        stated plan generation
strips planning problems unary operators acyclic causal graphs intractable
using reasoning  new result puts question argument used prove
hardness problems  reason  analyze complexity problems
prove hard showing plan existence problem np hard 

   notation
let v set state variables  let d v  finite domain state variable v v  
define state function v maps state variable v v value
s v  d v  domain  partial state p function subset vp v state
   

ficomplexity planning problems

variables maps state variable v vp p v  d v   subset c v
state variables  p   c partial state obtained restricting domain p vp c 
sometimes use notation  v    x            vk   xk   denote partial state p defined
vp    v            vk   p vi     xi vi vp   write p v    denote v
  vp  
two partial states p q match  denote pq  p   vq   q   vp  
i e   v vp vq   p v    q v   define replacement operator q
r two partial states  p   q r partial state defined vp   vq vr   p v    r v 
v vr   p v    q v  v vq vr   note that  general  p q    q p 
partial state p subsumes partial state q  denote p q  pq
vp vq   remark p q r s  follows p r q s  difference
two partial states q r  denote q r  partial state p defined
vp    v vq   q v     r v   p v    q v  v vp  
planning problem tuple p   hv  init  goal  ai  v set variables 
init initial state  goal partial goal state  set operators  operator
  hpre a   post a i consists partial state pre a  called pre condition
partial state post a  called post condition  operator applicable state
spre a   applying operator state results new state post a  
valid plan p sequence operators sequentially applicable state init
resulting state satisfies goal 
causal graph planning problem p directed graph  v  e  state variables
nodes  edge  u  v  e u    v exists operator
u vpre a  vpost a  v vpost a   

   class  s
jonsson backstrom        introduced class  s planning problems study
relative complexity plan existence plan generation  section  introduce
additional notation needed describe class  s illustrate properties
 s planning problems  begin defining class  s 
definition     planning problem p belongs class  s causal graph acyclic
state variable v v binary either static  symmetrically reversible 
splitting 
below  provide formal definitions static  symmetrically reversible splitting 
note fact causal graph acyclic implies operators unary  i e  
operator a   vpost a         without loss generality  assume  s planning
problems normal form  mean following 
state variable v  d v           init v      
post a     v   x   x         implies pre a  v      x 
satisfy first condition  relabel values d v  initial goal
states well pre  post conditions operators  satisfy second condition 
operator post a     v   x  pre a  v       x  either remove
   

figimenez   jonsson

v

v 

u
v  
v

v  

w  
w
w  

w

v 



u
v  
v



 a 

v  

w  
w
w  

w



v 



v 

w

 b 

figure    causal graph splitting variable partitions  a  v   b  w 
pre a  v    x  let pre a  v      x previously undefined  resulting planning
problem normal form equivalent original one  process done
time o  a  v    
following definitions describe three categories state variables  s 
definition     state variable v v static one following holds 
   exist post a  v      
   goal v      exist post a  v      
definition     state variable v v reversible
post a     v   x   exists post a      v     x   addition  v
symmetrically reversible pre a      v  v     pre a     v  v   
definitions follows value static state variable cannot
must change  whereas value symmetrically reversible state variable change
freely  long possible satisfy pre conditions operators change
value  third category state variables splitting  informally  splitting state variable
v splits causal graph three disjoint subgraphs  one depends value
v      one depends v      one independent v  however 
precise definition involved  need additional notation 
v v   let qv  subset state variables  different v  whose value
changed operator v     pre condition  formally  qv     u v  v   
s t  pre a  v      u vpost a     define qv  way v      let
gv     v  e v   subgraph  v  e  whose edges exclude v qv  qv   
formally  e v   e   v  w    w qv  w
  qv     finally  let v v v subset state
variables weakly connected state variable qv  graph gv    define
v v way v     
definition     state variable v v splitting v v v v disjoint 
figure   illustrates causal graph planning problem two splitting state
variables  v w  edge label v     indicates operators changing
value u v     pre condition  words  qv     u  w   graph
gv     v  e v   excludes two edges labeled v      v v includes state state variables 
   

ficomplexity planning problems

since v weakly connected u w connects remaining state variables  set
qv  empty since operators changing value state variable
v v     pre condition  consequently  v v empty well  figure   a  shows
resulting partition v 
w
w
case w  qw
     s   g     v  e    excludes edge labeled w     
w
v     s   since state variable connected edge w     removed 
likewise  v w    t   use vw   v v w v w denote set remaining state
variables belong neither v w v w   figure   b  shows resulting partition
w 
lemma     splitting state variable v  two sets v v v v non empty 
v belongs neither v v v v  
proof contradiction  assume v belongs v v   v weakly connected
state variable qv  graph gv     v  e v    since e v exclude edges
v qv    state variable qv  weakly connected state variable
qv  gv    consequently  state variables qv  belong v v v v   contradicts
v splitting  reasoning holds show v belong v v  
lemma     value splitting state variable never needs change twice
valid plan 
proof assume valid plan changes value splitting state variable v
least three times  show reorder operators way
value v need change twice  need address three cases  v
belongs v v  cf  figure   a    v belongs v v   v belongs vv  cf  figure   b   
v belongs v v   follows lemma     v v empty  consequently 
operator plan requires v     pre condition  thus  safely remove
operators change value v  except possibly last  needed case
goal v       v belongs v v   follows lemma     v v empty  thus 
operator plan requires v     pre condition  first operator changes
value v necessary set v    that  safely remove operators
change value v  except last case goal v       cases resulting
plan contains two operators changing value v 
v belongs vv   edges v v   v v   vv v vv
qv  v v qv  v v   let         subsequences operators
affect state variables v v   v v   vv   respectively  write   h   av    i  av 
last operator changes value v      claim reordering
h      av        plan still valid  indeed  operators   require v     
holds initial state  operators   require v      holds
due operator av    note operators changing value v safely
removed since value v     never needed pre condition change value
state variable vv   result valid plan changes value v twice
 its value may reset     

   

figimenez   jonsson

variable
v 
v 
v 
v 
v 
v 
v 
v 

operators
av     h v         v      i
av     h v         v      i
av     h v       v         v      i
av     h v       v       v         v      i
av  
av  
av  
av  
av  

  h v 
  h v 
  h v 
  h v 
  h v 

     v 
     v 
     v 
     v 
     v 

     v         v      i
       v      i
       v      i
       v      i
     v         v      i

v vi
v

v vi
v


 v    v   
v  v   

v

v
 v    v    v   


v




v


table    operators sets v vi v vi example planning problem 

v 
v 

v 
v 

v 
v 

v 

v 

figure    causal graph example planning problem 
previous lemma  holds splitting state variables general  provides
additional insight solve planning problem splitting state variable v 
first  try achieve goal state state variables v v value v   
initial state  then  set value v   try achieve goal state state
variables v v   finally  goal v       reset value v   
    example
illustrate class  s using example planning problem  set state variables
v    v            v     since planning problem normal form  initial state
init vi       vi v   goal state defined goal    v       v       
operators listed table    figure   shows causal graph  v  e 
planning problem  operators easy verify v  static v 
v  symmetrically reversible  planning problem  s  remaining
state variables splitting  table   lists two sets v vi v vi state
variable vi v show indeed  v vi v vi   state variables set
 v    v    v    v    v    
   

ficomplexity planning problems

   plan generation  s
section  present polynomial time algorithm plan generation  s 
algorithm produces solution instance  s form system macros 
idea construct unary macros change value single state variable 
macros may change values state variables execution  always reset
terminating  macros generated  goal achieved
one state variable time  show algorithm generates valid plan
one exists 
begin defining macros use paper  next  describe
algorithm pseudo code  figures          prove correctness  facilitate
reading moved straightforward involving proof appendix  following
description algorithm analyze complexity steps involved 
follows  assume  s planning problems normal form defined previous
section 
    macros
macro operator  macro short  ordered sequence operators viewed unit 
operator sequence respect pre conditions operators follow
it  pre condition operator sequence violated  applying macro
equivalent applying operators sequence given order  semantically 
macro equivalent standard operator pre condition postcondition  unambiguously induced pre  post conditions operators
sequence 
since macros functionally operators  operator sequence associated macro
include macros  long create circular definition  consequently 
possible create hierarchies macros operator sequences macros
one level include macros level below  solution planning problem
viewed macro sits top hierarchy 
define macros first introduce concept induced pre  post conditions
operator sequences    ha            ak operator sequence  write     k 
denote subsequence ha            ai i 
definition     operator sequence   ha            ak induces pre condition pre    
pre ak   pre a    post condition post     post a    post ak    addition 
operator sequence well defined  pre i   post i    pre ai  
    k 
follows  assume p    v  init  goal  a  planning problem
vpost a  vpre a  operator a    ha            ak operator sequence 
lemma     planning problem p type   vpost   vpre    
proof direct consequence definitions vpre     vpre a    vpre ak   vpost    
vpost a    vpost ak    
   

figimenez   jonsson

lemma     operator sequence applicable state well defined
spre    state sk resulting application sk   post   
proof induction k  result clearly holds k      k      note
pre     pre ak   pre k     post     post k    post ak    well defined
k  well defined  pre k    post k    pre ak   
hypothesis induction state sk  resulting application k 
sk    post k     follows sk   sk  post ak     post   
assume applicable state s  means k  applicable ak
applicable sk    post k     hypothesis induction  former implies
spre k    k  well defined  latter  s post k    pre ak   
last condition implies  pre k    post k    pre ak   use pre k    s 
consequence spre k    total state  finally  deduce
s pre ak   pre k     spre k     s post k    pre ak    using
vpost k    vpre k      follows well defined spre   
conversely  assume well defined spre    implies k 
well defined spre k     hypothesis induction  k  applicable state s 
remains show ak applicable state sk    is   s post k    pre ak   
 pre k    post k    pre ak   follows post k   pre ak    fact
s pre ak   pre k     vpost k    vpre k    completes proof 
since macros induced pre  post conditions  lemmas         trivially extend
case operator sequence includes macros  ready
introduce definition macros 
definition     macro sequence   ha            ak operators macros
induces pre condition pre m    pre   post condition post m    post  
pre    macro well defined circular definitions occur
well defined 
make macros consistent standard operators  induced post condition
include state variables whose values indeed changed macro  achieved
computing difference post   pre    particular  holds
 s planning problem normal form  derived macros satisfy second condition normal
form  namely post m     v   x   x         implies pre m  v      x 
definition     let ancv set ancestors state variable v  s planning
problem  define partial state prev vprev   ancv
   prev  u      u ancv splitting v v u  
   prev  u      otherwise 
definition     macro  s macro well defined and  x         post m   
 v   x  pre m  prev  v     x  
   

ficomplexity planning problems

macro
mv  
mv  
mv  
mv  
mv  
mv  
mv  
mv  
mv  

sequence

pre condition

hav  
hav  
hmv     av     mv  
hav  
hav  
hav  
hav  
hmv     av     mv  
hav  

 v 
 v 
 v 
 v 
 v 
 v 
 v 
 v 
 v 

    
    
     v 
     v 
     v 
     v 
     v 
     v 
     v 

    
     v 
     v 
    
    
     v 
     v 

post condition

    
    

    
     v      

 v 
 v 
 v 
 v 
 v 
 v 
 v 
 v 
 v 

    
    
    
    
    
    
    
    
    

table    macros generated algorithm example planning problem 

algorithm present generates  s macros  fact  generates one
macro   mvx post m     v   x  state variable v value x        
illustrate idea  s macros give flavor algorithm  table   lists macros
generated algorithm example  s planning problem previous section 
claim macro  s macro  example  operator sequence hav  
induces pre condition  v       v       post condition  v       v        v        
 v       v        thus  macro mv   induces pre condition pre mv        v       v      
post condition post mv        v       v        v       v          v        since v 
v  splitting since v  v v  v  v v    follows prev   v        
 v       v       v       v        pre mv        v       v       prev   v       
macros combined produce solution planning problem  idea
identify state variable v goal v      append macro mv 
solution plan  example  results operator sequence hmv     mv   i  however 
pre condition mv   specifies v      v       makes necessary insert mv  
mv   mv     addition  pre condition mv   specifies v       makes
necessary insert mv   mv     resulting final plan hmv     mv     mv     mv     mv   i 
note order macros matter  mv   requires v    mv   requires
v     splitting state variable v  goal state achieved state
variables v v value v set    expand solution plan
consists solely operators a  example  results operator sequence
hav     av     av     av     av     av     av     av     av   i  case  algorithm generates optimal
plan  although true general 
    description algorithm
proceed providing detailed description algorithm plan generation  s 
first describe subroutine generating unary macro sets value state
variable v x  algorithm  call generatemacro  described figure   
algorithm takes input planning problem p   state variable v  value x  either  
   

figimenez   jonsson

 
 
 
 
 
 
 
 
 
  
  
  
  
  

function generatemacro p   v  x   
post a  v    x
s  s  hi
satisf true
u  u vpre a   v    pre a  u      
u u increasing topological order
u static mu 
 
satisf false
else u splitting mu  mu 
s  hs    mu 
s  hmu    s 
satisf
return hs    a  s 
return f ail
figure    algorithm generating macro sets value v x 

    set macros vs ancestors causal graph  prior executing
algorithm  perform topological sort state variables  assume that 
v v x         contains one macro mvx post mvx      v   x  
algorithm  use notation mvx test whether contains mvx  
operator sets value v x  algorithm determines whether
possible satisfy pre condition pre a  starting initial state  this 
algorithm finds set u state variables pre a  assigns    the values
state variables already satisfy pre a  initial state   algorithm constructs two
sequences operators  s  s    going state variables u increasing
topological order  operator sequence  use hs  oi shorthand denote
operator sequence length  s      consisting operators followed o 
either operator macro  possible satisfy pre condition pre a 
operator a  algorithm returns macro hs    a  s  i  otherwise  returns f ail 
lemma     v symmetrically reversible generatemacro p   v       successfully generates macro  generatemacro p   v       
proof assume generatemacro p   v       successfully returns macro hs    a  s 
operator post a       definition symmetrically
reversible follows exists operator post a      
pre a     v  v    pre a    v  v   thus  set u identical  
consequence  values s    s    satisf loop 
means generatemacro p   v       returns macro hs      s    note
generatemacro p   v       may return another macro goes operators different order  however  guaranteed successfully return macro 
theorem     macros  s macros generatemacro p   v  x   
generates macro mvx    f ail  mvx  s macro 
   

ficomplexity planning problems

 
 
 
 
 
 
 
 
 
  

function macro  s p  

v v increasing topological order
mv  generatemacro p   v      
mv  generatemacro p   v      
mv     f ail mv     f ail
 mv    mv   
else mv     f ail goal v      
 mv   
return generateplan p   v    
figure    algorithm macro  s 
proof theorem     appears appendix a 

next  describe algorithm plan generation  s  call macro  s 
figure   shows pseudocode macro  s  algorithm goes state variables
increasing topological order attempts generate two macros state variable
v  mv  mv    macros successfully generated  added current
set macros   mv  generated goal state assign   v 
algorithm adds mv    finally  algorithm generates plan using subroutine
generateplan  describe later 
lemma     let p  s planning problem let v v state variable 
exists valid plan solving p sets v    macro  s p   adds macro mv   
if  addition  plan resets v    macro  s p   adds mv   
proof first note mv  mv  generated  macro  s p   adds  
mv  generated mv    macro  s p   adds mv  unless goal v       however 
goal v      contradicts fact valid plan solving p sets v  
without resetting    remains show generatemacro p   v       always
generates mv     f ail generatemacro p   v       always generates mv     f ail
plan resets v   
plan solving p sets v   contain operator
post a  v       plan resets v    contain operator
post a   v       show generatemacro p   v       successfully generates
mv     f ail operator selected line    note algorithm may return another
macro selects another operator a  however  always generates macro a 
guaranteed successfully return macro mv     f ail  true mv   
prove lemma induction state variables v  v ancestors
causal graph  set u empty default  thus  satisf never set false
generatemacro p   v       successfully returns macro mv    hai a  exists 
generatemacro p   v       successfully returns mv    ha  
v ancestors causal graph  let u    u vpre a   v    pre a  u       
since plan contains set u u    hypothesis induction 
macro  s p   adds mu  u u   consequence  satisf never set
   

figimenez   jonsson

 
 
 
 
 
 
 
 
 
  
  
  
  
  
  
  
  

function generateplan p   w    
 w      
return hi
v first variable topological order present w
v splitting
v  generate plan p   w  v v  v     
v  generate plan p   w  v v  v     
v generate plan p   w  v v v v v  v     
v    f ail v    f ail v   f ail  goal v      mv 
   
return f ail
else mv 
  return hv   v    v 
else goal v      return hv   v    mv    v    mv 
else return hv   v    mv    v 
generate plan p   w  v    
  f ail  goal v      mv 
    return f ail
else goal v      return h  mv 
else return
figure    algorithm generating final plan

false thus  generatemacro p   v       successfully returns mv  a  exists 
let w    w vpre a    v    pre a   w        plan contains   set
w w    hypothesis induction  macro  s p   adds mw
  w w
consequently  generatemacro p   v       successfully returns mv   
finally  describe subroutine generateplan p   w     generating final
plan given planning problem p   set state variables w set macros  
set state variables empty  generateplan p   w     returns empty operator
sequence  otherwise  finds state variable v w comes first topological order 
v splitting  algorithm separates w three sets described v v   v v  
vv   v v v v v   algorithm recursively generates plans three sets
necessary  inserts mv  v v v v final plan  case 
algorithm recursively generates plan w  v   goal v      mv    algorithm
appends mv  end resulting plan 
lemma      let w plan generated generateplan p   w      let v
first state variable topological order present w   let v   ha   w   b final
plan generated macro  s p    mv  follows  pre a  post a   pre mv    
proof determine content operator sequence precedes w final
plan inspection  note call generateplan p   w     nested within
sequence recursive calls generateplan starting generateplan p   v     
let z set state variables u z first state variable
topological order call generateplan prior generateplan p   w     
u z correspond call generateplan set state variables
u w u   u splitting  u contribute since
   

ficomplexity planning problems

possible addition macro plan line    places macro mu  end
plan generated recursively 
assume u z splitting state variable  three cases  w v u   w v u  
w vu   v v u v u   w vu   u contribute since never places
macros u   w v u   plan u part since precedes u  lines    
        w v u   plans u u  part since precede u 
cases  mu    macro mu  part since precedes u  lines   
    macros part  
since macros unary  plan generated generateplan p   u    
changes values state variables u   splitting state variable u 
edges vu  u  v u   vu  u  v u   v u v u   follows
plan u change value state variable appears pre condition
macro u    holds u respect u  u  respect u   
thus  macro changes value splitting state variable u ancv
mu  case w v u  
recall prev defined ancv assigns   u u splitting
v v u   ancestors v  value   holds initial state
altered   u splitting v v u   follows definition  s macros
pre mv    u      pre mv    u     pre mv    u       correct append mu 
mv  satisfy pre mv    u   mu 
  follows u
  vpre mv      since pre mv    u     
would caused generatemacro p   v       set satisf false line    thus 
pre condition pre mv    mv  agrees pre a   post a   value state
variable  means two partial states match 
lemma      generateplan p   v     generates well defined plan 
proof note state variable v v   generateplan p   w     called
precisely v first state variable topological order  lemma     
follows  pre a   post a   pre mv     plan precedes w
final plan  since v first state variable topological order w   plans v   
v    v     recursively generated generateplan  change value
state variable pre mv     follows mv  applicable following ha   v   v  ha   i 
since mv  changes value v  mv  applicable following ha   v   v    mv    v  i 
theorem      macro  s p   generates valid plan solving planning problem  s
one exists 
proof generateplan p   v     returns f ail exists state variable
v v goal v      mv 
    lemma     follows
exist valid plan solving p sets v    consequently  exist
plan solving p   otherwise  generateplan p   v     returns well defined plan due
lemma       since plan sets   state variable v goal v     
resets   state variable v goal v       plan valid plan solving
planning problem 
   

figimenez   jonsson

v 

v 

v 

v 

v 

figure    causal graph planning problem p   
    examples
illustrate algorithm example introduced jonsson backstrom       
show instances  s exponentially sized minimal solutions  let pn  
hv  init  goal  ai planning problem defined natural number n  v    v            vn   
goal state defined vgoal   v   goal vi       vi  v            vn    
goal vn        state variable vi v   two operators a 
av i   h v               vi       vi       vi        vi     i 
av i   h v               vi       vi       vi        vi     i 
words  state variable symmetrically reversible  causal graph planning problem p  shown figure    note state variable vi  v            vn    
v
v
pre a i     vi       pre a i     vi        vi   qv i vi   q vi   since
edge causal graph vi   vi     state variable  v            vn   
v
splitting  hand  vn  vn splitting since v  n    v vn   v vn    
backstrom nebel        showed length shortest plan solving pn  n   
i e   exponential number state variables 
state variable vi  v            vn     algorithm generates two macros mv i
vi
m    single operator  av i   changes value vi      pre av i  
assigns   vi    u    vi     since vi  splitting  mv i defined mv i  
v
v
v
v
hm i    av i   m i  i  similarly  mv i defined mv i   hm i    av i   m i  i  state variable
vn   u    vn     splitting  mv n defined mv n   hav n i 
generate final plan  algorithm goes state variables topological order  state variables v  vn    algorithm nothing  since
state variables splitting goal state    state variable vn   
algorithm recursively generates plan vn   hmv n since goal vn       
v
since goal vn         algorithm inserts m n  mv n satisfy pre condition
v
vn      m n  mv n achieve goal state goal vn         thus  final plan
vn 
v
vn
hm    m    m n  i  expand plan  end sequence  n   operators  however  individual macro operator sequence length greater    together 
macros recursively specify complete solution planning problem 
demonstrate planning problems  s polynomial length
solutions algorithm may generate exponential length solutions  this 
modify planning problem pn letting goal vi       vi v   addition 
state variable vi v   add two operators a 
bv i   h v               vi       vi        vi     i 
bv i   h v               vi       vi        vi     i 
   

ficomplexity planning problems

add operator cv n   h vn       vn        vn     i a  consequence  state variables  v            vn    still symmetrically reversible splitting 
vn  symmetrically reversible longer splitting  since pre av n   vn       
v
v
pre cv n   vn        implies vn v  n  v  n    vn still splitting since v vn   v vn    
assume generatemacro p   vi   x    always selects bvxi first  consequence 
state variable vi v x         generatemacro p   vi   x    generates
v
v
macro mvxi   hm i            mv     bvxi   mv             m i  i 
let li length plan represented mvxi   x         definition
v

mx li     l            li         show induction li    i   
length macro v  l                 
li                   i           

 i   
 i   
    
       i           i   
  
 

generate final plan algorithm change value state variable
     total length plan l   l            ln                 n   
  n       however  exists plan length n solves planning problem 
namely hbv             bv n i 
    complexity
section prove complexity algorithm polynomial 
analyze step algorithm separately  summary complexity result
step algorithm given below  note number edges  e  causal
graph o  a  v     since operator may introduce o  v    edges  complexity result
o  v      e     o  a  v    topological sort follows cormen  leiserson  rivest 
stein        
constructing causal graph g    v  e 
calculating v v v v v v
performing topological sort g
generatemacro p   v  x   
generateplan p   v    
macro  s p  

o  a  v   
o  a  v     
o  a  v   
o  a  v   
o  v     
o  a  v     

lemma     
lemma     
lemma     
lemma     
theorem     

lemma      complexity constructing causal graph g    v  e  o  a  v    
proof causal graph consists  v   nodes  operator state
variable u vpre a    add edge u unique state variable v vpost a   
worst case   vpre a      o  v     case complexity o  a  v    
lemma      complexity calculating sets v v v v state variable
v v o  a  v      
proof state variable v v   establish sets qv  qv    requires
going operator worst case  note interested
pre condition v unique state variable vpost a    means
   

figimenez   jonsson

need go state variable vpre a    next  construct graph gv   
copying causal graph g  takes time o  a  v     removing
edges v qv  qv    takes time o  v    
finally  construct set v v find state variable weakly connected state variable u qv  graph gv    state variable u qv   
performing undirected search starting u takes time o  a  v     performed search starting u  need search state variables qv 
reached search  way  total complexity search exceed
o  a  v     case constructing v v identical  since perform
procedure state variable v v   total complexity step o  a  v      
lemma      complexity generatemacro p   v  x    o  a  v    
proof operator a  generatemacro p   v  x    needs check whether
post a  v    x  worst case   u     o  v     case complexity
algorithm o  a  v    
lemma      complexity generateplan p   v     o  v      
proof note state variable v v   generateplan p   v     called recursively exactly v first variable topological order  words 
generateplan p   v     called exactly  v   times  generateplan p   v     contains
constant operations except intersection difference sets lines     
since intersection set difference done time o  v     total complexity
generateplan p   v     o  v      
theorem      complexity macro  s p   o  a  v      
proof prior executing macro  s p    necessary construct causal graph g 
find sets v v v v state variable v v   perform topological sort
g  shown steps take time o  a  v       state variable
v v   macro  s p   calls generatemacro p   v  x    twice  lemma     
follows step takes time o   v   a  v      o  a  v       finally  macro  s p   calls
generateplan p   v      takes time o  v      due lemma       follows
complexity macro  s p   o  a  v      
conjecture possible improve complexity result macro s p   o  a  v     however  proof seems somewhat complex  main objective
devise algorithm efficient possible  rather  interested
establishing algorithm polynomial  follows theorem      
    plan length
section study length plans generated given algorithm  begin
with  derive general bound length plans  then  show compute
actual length particular plan without expanding macros  present
algorithm uses computation efficiently obtain i th action plan
   

ficomplexity planning problems

macro form  start introducing concept depth state variables
causal graph 
definition      depth d v  state variable v longest path v
state variable causal graph 
since causal graph acyclic planning problems  s  depth state variable
unique computed polynomial time  also  follows least one state
variable depth    i e   outgoing edges 
definition      depth planning problem p  s equals largest depth
state variable v p   i e     maxvv d v  
characterize planning problem based depth state variables  let
n    v   number state variables  let ci denote number state variables
depth i  planning problem depth d  follows c            cd   n 
example  consider planning problem whose causal graph appears figure   
planning problem  n           c       c       c       c       c       c      
lemma      consider values li             d  defined ld      li  
  ci   li     ci   li             cd ld         d  values li upper bound
length macros generated algorithm state variable v depth i 
proof prove decreasing induction value i  assume v depth   d 
follows definition      v incoming edges  thus  operator changing
value v pre condition state variable v  ld     upper
bound  stated 
now  assume v depth   d  li k k     upper bounds
length corresponding macros  let operator changes value v 
definition depth follows cannot pre condition state variable
u depth j i  otherwise would edge u v causal graph  causing
depth u greater i  thus  worst case  macro v change
values state variables depths larger i  change value v  reset
values state variables lower levels  follows li     ci   li             cd ld      
upper bound 
theorem      upper bounds li lemma      satisfy li   dj i         cj   
proof note
li     ci   li     ci   li             cd ld        
   ci   li       ci   li             cd ld        
   ci   li     li       ci       li    
result easily follows induction 
   

figimenez   jonsson

obtain upper bound l total length plan  worst
case  goal state assigns different value state variable initial state 
i e   goal v     init v  v v   achieve goal state algorithm applies one
macro per state variable  hence
l   c  l    c  l            cd ld   c  l   


l   
      c   l   
 y
 
 
 
      cj    
 
 
 
 
j  

previous bound depends distribution variables depths according
causal graph  obtain general bound depend depths
variables first find distribution maximizes upper bound l 
q
lemma      upper bound l      dj       cj      planning problems n variables
depth maximized ci equal  is  ci   n  d      
proof note ci     i  c      cd   n  result follows direct
application well known am gm  arithmetic mean geometric mean  inequality 
states arithmetic mean positive values xi greater equal geometric
mean  equality xi same 
implies product positive
p
factors xi         ci   fixed sum   dj   xj    n   maximized
equal  is  ci   n  d      
theorem      length plan generated algorithm planning problem
 s n state variables depth        n  d      d        
proof direct consequence lemma       since c            cd discrete  may
possible set c            cd   n  d       nevertheless         n  d      d       
upper bound l case 
observe bound established theorem      increasing function d 
implies given d  bound applies planning problems  s depth
smaller d  consequence  depth planning problem  s bounded
d  algorithm generates solution plan planning problem
polynomial length o nd      since complexity executing plan proportional
plan length  use depth define tractable complexity classes planning
problems  s respect plan execution 
theorem      length plan generated algorithm planning problem
 s n state variables   n      
proof worst case  depth planning problem n   follows theorem
     length plan        n n n          n      
note bound established theorem      tight  second example section
     showed algorithm generates plan whose length   n      
   

ficomplexity planning problems

 
 
 
 
 
 
 
 
 

function operator s  i 
first operator
length o   
length o 
next operator
primitive o 
return
else
return operator o  i 
figure    algorithm determining i th operator sequence

lemma      complexity computing total length plan generated
algorithm o  v      
proof algorithm generates   v     o  v    macros    state variable 
operator sequence macro consists one operator    v        o  v   
macros  use dynamic programming avoid computing length macro
once  worst case  compute length o  v    macros 
sum o  v    terms  resulting total complexity o  v      
lemma      given solution plan length l integer   l  complexity
determining i th operator plan o  v      
proof prove lemma providing algorithm determining i th operator 
appears figure    since operator sequences consist operators macros 
variable represents either operator macro generated macro  s 
function primitive o  returns true operator f alse macro  function
length o  returns length macro    otherwise  assume length
macros pre computed  know lemma      takes time o  v      
algorithm simply finds operator macro i th position sequence 
taking account length macros sequence  i th position part
macro  algorithm recursively finds operator appropriate position
operator sequence represented macro  worst case  algorithm go
o  v    operators sequence call operator recursively o  v    times 
resulting total complexity o  v      
    discussion
general view plan generation output consist valid sequence
grounded operators solves planning problem  contrast  algorithm generates
solution plan form system macros  one might argue truly solve
plan generation problem  algorithm expand system macros arrive
sequence underlying operators  case  algorithm would longer polynomial 
since solution plan planning problem  s may exponential length  fact 
objective execute solution plan once  algorithm offers marginal
benefit incremental algorithm proposed jonsson backstrom        
   

figimenez   jonsson

hand  several reasons view system macros generated
algorithm complete solution planning problem  s  macros collectively
specify steps necessary reach goal  solution plan generated
verified polynomial time  plan stored reused using polynomial memory 
even possible compute length resulting plan determine i th
operator plan polynomial time shown lemmas            thus 
practical purposes system macros represents complete solution  even
objective execute solution plan once  algorithm faster
jonsson backstrom         necessary execute plan generated
algorithm maintain stack currently executing macros select next operator
execute  whereas algorithm jonsson backstrom perform several steps
operator output 
jonsson backstrom        proved bounded plan existence problem  s
np hard  bounded plan existence problem problem determining whether
exists valid solution plan length k  consequence  optimal
plan generation problem  s np hard well  otherwise  would possible
solve bounded plan existence problem generating optimal plan comparing
length resulting plan k  examples seen algorithm
generate optimal plan general  fact  algorithm bad
incremental algorithm jonsson backstrom  sense algorithms may
generate exponential length plans even though exists solution polynomial length 
since algorithm makes possible compute total length valid solution
polynomial time  used generate heuristics planners  specifically 
katz domshlak        proposed projecting planning problems onto provably tractable
fragments use solution fragments heuristics original problem 
shown  s tractable fragment  unfortunately  optimal planning
 s np hard  hope generating admissible heuristic  however 
heuristic may still informative guiding search towards solution original
problem  addition  planning problems exponential length optimal solutions 
standard planner hope generating heuristic polynomial time  making
macro based approach  and jonsson         current  viable option 

   class cn
domshlak dinitz        defined class cn planning problems multi valued
state variables chain causal graphs  since chain causal graphs acyclic  follows
operators unary  moreover  let vi i th state variable chain      
operator vpost a   vi   holds vpre a     vi    vi    words 
operator changes value state variable vi may pre conditions
vi  vi  
authors showed instances cn exponentially sized minimal
solutions  therefore argued class intractable  light previous section 
argument length solutions discard possibility instances
class solved polynomial time using macros  show
case  unless p   np 
   

ficomplexity planning problems

v 

vk

w

figure    causal graph p  f   
c 

c   c 

   
cn cn
cn

c 

   
 





   



 

c   c 
   

cn cn

cn

figure    domain transition graph vi  
define decision problem plan existence cn follows  valid input planexistence cn planning instance p cn   input p belongs plan existencecn p solvable  show section problem plan existencecn np hard  implies that  unless p   np  solving instances cn truly
intractable problem  namely  polynomial time algorithm distinguish solvable
unsolvable instances cn   particular  polynomial time algorithm solve cn
instances using macros kind output format  
prove plan existence cn np hard reduction cnf sat  is 
problem determining whether cnf formula f satisfiable  let c            cn
clauses cnf formula f   let v            vk variables appear f  
briefly describe intuition behind reduction  planning problem create
formula f state variable variable appearing f   plans forced
commit value  either      state variables actually using them  then 
satisfy goal problem  variables used pass messages  however 
operators defined way plan succeed
state variable values committed satisfying assignment f  
proceed describe reduction  first  we define planning problem p  f    
hv  init  goal  ai follows  set state variables v    v            vk   w   d vi    
 s        c    c            cn   cn   vi d w     s             n   initial state defines
init v    v v goal state defines goal w    n  figure   shows
causal graph p  f   
domain transition graph state variable vi shown figure    node
represents value d vi    edge x means exists operator
pre a  vi     x post a  vi     y  edge labels represent pre condition
operators state variable vi    multiple labels indicate several operators
associated edge  enumerate operators acting vi using notation
  hpre a   post a i  when     mention vi  understood void  
   valid output format one enables efficient distinction output representing valid
plan output representing fact solution found 

   

figimenez   jonsson



c   c 

n 

 

cn cn

n

figure     domain transition graph w 
    two operators hvi    s  vi   s  vi    i hvi    s  vi   s  vi    i allow vi
move either     
         clause cj x  cj   cj    two operators
hvi    x  vi      vi   cj hvi    x  vi      vi   cj i  operators allow vi move cj cj vi  done so 
    clause cj x         operator hvi    x  vi      vi   cj v
occurs clause cj   operator hvi    x  vi      vi   cj vi occurs clause
cj   operators allow vi move cj cj even vi  done so 
    clause cj x           two operators hvi    x  vi   cj   vi    i
hvi    x  vi   cj   vi    i  operators allow vi move back     
domain transition graph state variable w shown figure     every clause
cj two operators acting w hvk   x  w   j    w   ji  x  cj   cj  
 if j      pre condition w   j   replaced w   s  
proposition     cnf formula f satisfiable planning instance p  f  
solvable 
proof proof follows relatively straightforward interpretation variables
values planning instance p  f    every state variable vi   must use
operator     commit either      note that  choice made  variable vi
cannot set value  reason need two values cj cj clause
enforce commitment  cj corresponds vi      cj corresponds vi      
reach goal state variable w advance step step along values            n 
clearly  every clause cj must exist variable vi first set values cj
cj using operator      then  message propagated along variables
vi             vk using operators      note existence operator     acting
vi implies initial choice     state variable vi   applied formula
variable vi   makes clause cj true  hence  plan solving p  f    use
initial choices state variables vi define  partial  assignment satisfies
clauses f  
conversely  assignment satisfies f   show obtain plan
solves p  f    first  set every state variable vi value  vi    every one
clauses cj   choose variable vi among make cj true using assignment  
then  increasing order j  set state variable vi corresponding clause cj
value cj cj  depending  vi     pass message along vi             vk w 
theorem     plan existence cn np hard 
   

ficomplexity planning problems

vx
vc

vc

vc

vc

vc

vc

 

 

 

vx

vy

vy

vz

vz

 

 

v 

v 

v 

v 

v 

 

figure     causal graph pf f   c  c  c  three variables x  y  z 
proof producing planning instance p  f   cnf formula f easily done
polynomial time  polynomial time reduction cnf sat p plan existencecn  

   polytree causal graphs
section  study class planning problems binary state variables
polytree causal graphs  brafman domshlak        presented algorithm finds
plans problems class time o n     n number variables
maximum indegree polytree causal graph  brafman domshlak       
showed solve time roughly o n   planning domains local depth
causal graphs tree width   interesting observe algorithms fail solve
polytree planning domains polynomial time different reasons  first one fails
tree broad  unbounded indegree   second one fails tree deep
 unbounded local depth  since tree width polytree    
section prove problem plan existence polytree causal graphs
binary variables np hard  proof reduction  sat class
planning problems  example reduction  figure    shows causal graph
planning problem pf corresponds formula f three variables three
clauses  the precise definition pf given proposition       finally  end
section remark reduction solves problem expressed terms cp nets
 boutilier et al          namely  dominance testing polytree cp nets binary
variables partially specified cpts np complete 
let us describe briefly idea behind reduction  planning problem pf two
          v   depends
different parts  first part  state variables vx   vx           vc    vc
 
 
formula f property plan may change value v     
many times number clauses f truth assignment satisfy  however 
condition v  cannot stated planning problem goal  overcome difficulty
introducing second part  state variables v    v            vt   translates regular
planning problem goal 
first describe second part  let p planning problem hv  init  goal  ai
v set state variables  v            v k    set  k   operators
              k                 k          operators defined     hv       v     i
   

figimenez   jonsson

    hv       v     i       operators   hvi       vi      vi    i
  hvi       vi      vi    i  initial state init vi       i  goal state
goal vi       even goal vi       odd 
lemma     valid plan planning problem p changes state variable v     
least k times  valid plan achieves minimum 
proof let ai bi be  respectively  sequences operators h            h            i 
easy verify plan hb k    a k    b k            b    a    b  solves planning
problem p   indeed  applying operators ai  respectively  operators bi   
variables v            vi become    respectively      particular  variable vi attains goal
state    even    odd   subsequent operators plan modify vi  
variable remains goal state end  operator   appears k times
plan  one sequence type bi    thus value v  changes k times     
proceed show k minimum  consider plan solves
planning problem p   let number operators appearing  in
words  number times value vi changes  either    
      note number times operator appears equal precisely one
number occurrences   show i      since  k    
implies    k    plan has  least  k occurrences     completing
proof 
show i      let si subsequence operators plan  
clearly  si starts  since initial state vi       operator cannot
appear twice consecutively si   si           etc  note that      
vi      pre condition  vi       hence must least one operator
i  plan betweeen two operators   reason must
least one operator i  two operators   one operator i 
first operator   shows i    hand  variables vi
vi  different values goal state  subsequences si si  must different
lengths  is  i       together  implies i      desired 
proposition      sat reduces plan existence planning problems binary variables polytree causal graphs 
proof let f cnf formula k clauses n variables  produce planning
problem pf  n    k   state variables  n     k   operators  planning
problem two state variables vx vx every variable x f   two state variables vc
every clause c f    k   additional variables v           v
vc
 
 k    variables
  initial state   partial  goal state defined vgoal    v            v k    
goal vi       even  goal vi       odd  problem p lemma
     operators are 
    operators hvx      vx    i hvx      vx    i every variable x f  
     v    i  hv      v      v    i hv      v      v    i
    operators hvc
c
c
c
c
c
c
c
every clause c f  

   

ficomplexity planning problems

    seven operators every clause c  one partial assignment satisfies c 
without loss generality  let x  y  z three variables appear clause c 
operator among seven  vpre a     vx   vx   vy   vy   vz   vz   vc   v    
vpost a     v     pre a  vc        pre a  v         post a  v         precondition state variables vx   vx   vy   vy   vz   vz depends corresponding satisfying partial assignment  example  operator corresponding partial
assignment  x           z      clause c   x z pre condition
 vx      vx      vy      vy      vz      vz      
    operator h c  vc       v       v     i 
    operators   hvi       vi      vi    i   hvi       vi      vi    i
   k    the operators problem p except       
note simple facts problem pf   variable x  state variables vx
vx pf start    applying operators     change  
back    particular  plan cannot reach partial states hvx      vx    i
hvx      vx    i course execution 
similarly  c clause f   state variable vc change     and  first
   v change back    changes possible  since
changing vc
c
  
operator brings back vc
interpret operators          operators affect v   
change v      need apply one operators      thus require
vc     clause c  way bring back v    applying operator
    pre condition vc      deduce every time v  changes
value     back   plan   least one k state variables vc
used up  sense vc brought     back    cannot
used purpose 
show f  sat valid plan problem pf   assume
f  sat  let truth assignment satisfies f   consider following plan
  first  set vx    x  vx      x  variables x using operators     
then  clause c f   set vc      apply operator     corresponds
restricted variables clause c  at point  v  changes       set
    v      apply operator      at point  v change  
vc
 
c
    repeating process every clause c f switching state variable v 
exactly k times      now  following proof lemma      easily extend
plan plan sets variables vi goal values 
show converse  namely  existence valid plan pf implies f
satisfiable  define assignment setting  x      partial state  vx      vx     
appears execution    x      otherwise   recall one
partial states  vx      vx       vx      vx      appear execution
plan   lemma      must state variable v  changes     least k
times  implies k operators      corresponding different clauses 
used move v       apply operator  values state
variables  vx   vx   must satisfy corresponding clause  thus assignment satisfies
k clauses f  
   

figimenez   jonsson

theorem     plan existence planning problems binary variables polytree
causal graph np complete 
proof due proposition     need show problem np 
brafman domshlak        showed holds general setting planning
problems causal graphs component directed path singly connected  that
is  one directed path pair nodes   proof exploits
non trivial auxiliary result  solvable planning problems binary variables directedpath singly connected causal graph plans polynomial length  the true
non binary variables  unrestricted causal graphs  
    cp nets
boutilier et al         introduced notion cp net graphical representation
user preferences  brief  cp net network dependences set variables 
preferences user variable depend values others 
ceteris paribus  all else equal  assumption  is  user preferences variable
completely independent values variables mentioned  preferences
variable given parent variables network stored conditional preference
tables  cpts 
boutilier et al         showed dominance query problem acyclic cp nets 
is  problem deciding one variable outcome preferable another 
expressed terms planning problem  network dependences cp net
becomes causal graph planning problem 
however  certain conditions  perform opposite process  transform
planning problem cp net dominance query problem  answering
query amounts solving planning problem  possible following
conditions planning problems acyclic causal graph binary variables 
   two operators modify variable opposing directions must nonmatching prevail conditions  the prevail condition operator partial state
pre a    v vpost a    
   must allow partially specified cpts cp net description 
first condition guarantees obtain consistent cpts planning instance
operators  second condition ensures reduction polynomial size preserving 
since fully specified cpts exponential maximum node indegree cp net 
particular  planning instance pf reduced f satisfies first condition 
 note true planning problem p lemma      drop
reversing operators     constructing pf proposition       consequence 
claim following 
theorem     dominance testing polytree cp nets binary variables partially
specified cpts np complete 
   

ficomplexity planning problems

   conclusion
presented three new complexity results planning problems simple causal
graphs  first  provided polynomial time algorithm uses macros generate solution plans class  s  although solutions generally suboptimal  algorithm
generate representations exponentially long plans polynomial time  several implications theoretical work planning  since generally accepted
exponentially sized minimal solutions imply plan generation intractable  work
shows always case  provided one allowed express solution
succinct notation macros  showed plan existence class cn
np hard  plan existence class planning problems binary variables
polytree causal graph np complete 
jonsson backstrom        investigated whether plan generation significantly
harder plan existence  using class  s  demonstrated plan existence
solved polynomial time  plan generation intractable sense
solution plans may exponential length  work casts new light result  even
though solution plans exponential length  possible generate representation
solution polynomial time  thus  appears class  s  plan generation
inherently harder plan existence  aware work
determines relative complexity plan existence plan generation  question
whether plan generation harder plan existence remains open 
potential criticism algorithm solution form macros
standard  intractable expand system macros arrive possibly
exponentially long sequence underlying operators  although true  shown
system macros share several characteristics proper solution  possible
generate validate solution polynomial time  solution stored
using polynomial memory  showed possible compute total length
solution polynomial time  well determine i th operator
underlying sequence 
since relatively simple  class cn class planning problems
binary state variables polytree causal graphs could seen promising candidates
proving relative complexity plan existence plan generation  however 
shown plan existence cn np hard  plan existence planning problems
polytree causal graphs np complete  consequently  classes cannot used
show plan generation harder plan existence  since plan existence already
difficult  work closes complexity gaps appear literature regarding
two classes 
however possible exist subsets planning problems classes
plan existence solved polynomial time  fact  polytree causal
graphs binary variables know case  due algorithms brafman
domshlak              mentioned section    hence plan generation problem
polynomial restrict polytree causal graphs either bounded indegree
bounded local depth   consequently  reduction  sat exhibits unbounded
indegree unbounded local depth 
   

figimenez   jonsson

similarly  one may ask class cn planning problems parameter that 
bounded  would yield tractable subclass  state variables reduction
domains whose size depends number clauses corresponding cnf formula 
domain size appears interesting candidate  planning problems cn
binary variables tractable due work brafman domshlak        
ideas use extend domain sizes    hence would interesting
investigate whether problem plan existence class cn easier size
state variable domains bounded constant 

appendix a  proof theorem    
assume generatemacro p   v  x    successfully returns macro mvx   hs    a  s  i 
let u    u vpre a   v    pre a  u       let w    w            wk   u set
wi

state variables u wi splitting   mw
    m      wi comes wj topological order   j  follows u u static 
wk
w 
w 
k
s    hmw
            m  s    hm            m  i  since state variable wi w
splitting  symmetrically reversible 
lemma a   wi w   prewi prev  
proof since wi vpre a  v vpost a    edge wi v causal graph 
thus  ancestor wi ancestor v  ancwi ancv   state variable
u ancwi   prewi  u      u splitting wi v u   graph gu     v  e u  
includes edge wi v  means v v u wi v u   follows
prewi  u      prev  u       consequence  prewi prev  

let   hs    a  s  i  wi w         let w
sequence preceding
wi 
w
w
w
w
i  
w

 

k
i 
macro   is      hm            m      hs    a  mw
            m 


further  let sequence appearing a  is    hs  i 

wi


lemma a     k  post conditions sequences w
       

post w
       wi                wk      

post a      w               wk      

post w
       w               wi       wi              wk      v   x  

proof direct consequence post ha            ak i    post a    post ak   post mw
  
 wi   y   post a     v   x  

wi


lemma a     k  pre conditions sequences w
         
wi
v


satisfy pre w
    pre    pre     pre   pre  v     x  


proof since pre ha            ak i    pre ak   pre a     follows pre w
    pre   
wi
v
pre     pre    prove pre   pre  v     x   state variable u
pre   u      let mu first operator hs    a  s  u vpre mu    
pre   u    pre mu   u  

   

ficomplexity planning problems

u
wi  w      prev  

mu   mw

    follows pre m   pre
wi
used m   s macro  wi symmetrically reversible  prewi prev due
lemma a    particular  pre mu   u    prev  u  
since assume planning problems normal form  u   wi implies
wi
u

u vpre mwi     follows mu    mw
  i  u    wi i    m 
 
pre mu   prewi  wi       due u    wi   deduce pre mu   u   
prewi  u    prev  u  
finally  consider case mu   a  u   v pre mu   u      x  desired 
u    v splitting  either v belongs v u pre mu   u       v belongs v u
pre mu   u       is  pre mu   u    prev  u   u    v symmetrically reversible
follows pre mu   u       since case pre mu   u      would forced algorithm
either fail include u w   u    v static  pre mu   u       else algorithm would
failed 

lemma a   let p  p   q r partial states  p p  p q r   p q r 
proof direct consequence p q p q 
lemma a   macro mvx generated algorithm well defined 
proof since includes macros ancestors v causal graph  since
causal graph acyclic  cyclic definitions occur  remains show that  macro
sequence preceding   holds  pre m   post m   pre m  
note due lemmas a   a   enough show
wi

 a   prev  v     x  post w
    pre m    

 b   prev  v     x  post a   pre a  
wi

 c   prev  v     x  post w
    pre m    
wi

case  a  follows easily since vpost wi   vpre mwi     pre mw
      pre  wi     
 
 
w
prev   case  c  similar  although time must use post     wi      
wi
wi  w       finally  case  b 

post w

    wj       j   i  required pre m      pre
holds variable u vpre a  either u   v  covered  v     x  
splitting static  covered prev   symmetrically reversible  covered
prev  u      pre a  u       post a   u      pre a  u      

remains show mvx  s macro  follows lemmas a   a  
well defined satisfies pre mvx     pre   prev  v     x   finally  post mvx    
post  pre      v   x  direct consequence post      w               wk      v   x 
lemma a    pre   wi        pre   v      x proof lemma a   

acknowledgments
work partially funded mec grants tin           c      tin          c       grammars  
   

figimenez   jonsson

references
backstrom  c     nebel  b          complexity results sas  planning  computational
intelligence                 
botea  a   enzenberger  m   muller  m     schaeffer  j          macro ff  improving ai
planning automatically learned macro operators  journal artificial intelligence research             
boutilier  c   brafman  r   domshlak  c   hoos  h     poole  d          cp nets  tool
representing reasoning conditional ceteris paribus preference statements 
journal artificial intelligence research             
brafman  r     domshlak  c          structure complexity planning unary
operators  journal artificial intelligence research             
brafman  r     domshlak  c          factored planning  how  when  not 
proceedings   st national conference artificial intelligence 
bylander  t          computational complexity propositional strips planning 
artificial intelligence             
chapman  d          planning conjunctive goals  artificial intelligence                
cormen  t   leiserson  c   rivest  r     stein  c          introduction algorithms  mit
press mcgraw hill 
domshlak  c     dinitz  y          multi agent off line coordination  structure complexity  proceedings  th european conference planning  pp         
erol  k   nau  d     subrahmanian  v          complexity  decidability undecidability
results domain independent planning  artificial intelligence                
fikes  r     nilsson  n          strips  new approach application theorem
proving problem solving  artificial intelligence                
gimenez  o     jonsson  a          hardness planning problems simple
causal graphs  proceedings   th international conference automated
planning scheduling  pp         
helmert  m          complexity results standard benchmark domains planning 
artificial intelligence                 
helmert  m          fast downward planning system  journal artificial intelligence
research             
jonsson  a          role macros tractable planning causal graphs 
proceedings   th international joint conference artificial intelligence  pp 
         
jonsson  p     backstrom  c          tractable plan existence imply tractable
plan generation  annals mathematics artificial intelligence                  
katz  m     domshlak  c          structural patterns heuristics  basic idea concrete
instance  workshop heuristics domain independent planning  progress 
ideas  limitations  challenges  icaps     
   

ficomplexity planning problems

knoblock  c          automatically generating abstractions planning  artificial intelligence                
korf  r          planning search  quantitative approach  artificial intelligence        
     
minton  s          selectively generalizing plans problem solving  proceedings
 th international joint conference artificial intelligence  pp         
vidal  v          lookahead strategy heuristic search planning  proceedings
  th international conference automated planning scheduling  pp         
williams  b     nayak  p          reactive planner model based executive 
proceedings   th international joint conference artificial intelligence  pp 
         

   


