journal of artificial intelligence research                  

submitted        published      

exploiting subgraph structure in
multi robot path planning
malcolm r  k  ryan

malcolmr cse unsw edu au

arc centre of excellence for autonomous systems
university of new south wales  australia

abstract
multi robot path planning is difficult due to the combinatorial explosion of the search
space with every new robot added  complete search of the combined state space soon
becomes intractable  in this paper we present a novel form of abstraction that allows
us to plan much more efficiently  the key to this abstraction is the partitioning of the
map into subgraphs of known structure with entry and exit restrictions which we can
represent compactly  planning then becomes a search in the much smaller space of subgraph
configurations  once an abstract plan is found  it can be quickly resolved into a correct
 but possibly sub optimal  concrete plan without the need for further search  we prove
that this technique is sound and complete and demonstrate its practical effectiveness on a
real map 
a contending solution  prioritised planning  is also evaluated and shown to have similar
performance albeit at the cost of completeness  the two approaches are not necessarily
conflicting  we demonstrate how they can be combined into a single algorithm which outperforms either approach alone 

   introduction
there are many scenarios which require large groups of robots to navigate around a shared
environment  examples include  delivery robots in an office  hada   takase         a
warehouse  everett  gage  gilbreth  laird    smurlo         a shipping yard  alami  fleury 
herrb  ingrand    robert         or a mine  alarie   gamache         or even virtual
armies in a computer wargame  buro   furtak         in each case we have many robots
with independent goals which must traverse a shared environment without colliding with
one another  when planning a path for just a single robot we can usually consider the
rest of the world to be static  so that the world can be represented by a graph called a
road map  the path planning problem then amounts to finding a path in the road map  for
which reasonably efficient algorithms exist  however  in a multi robot scenario the world is
not static  we must not only avoid collisions with obstacles  but also with other robots 
centralised methods  barraquand   latombe         which treat the robots as a single composite entity  scale poorly as the number of robots increases  decoupled methods
 lavalle   hutchinson        erdmann   lozano perez         which first plan for each
robot independently then resolve conflicts afterwards  prove to be much faster but are incomplete because many problems require robots to deliberately detour from their optimal
path in order to let another robot pass  even if a priority ordering is used  van den berg
  overmars         requiring low priority robots to plan to avoid high priority robots 
problems can be found which cannot be solved with any priority ordering 

c
    
ai access foundation  all rights reserved 

firyan

in realistic maps there are common structures such as roads  corridors and open spaces
which produce particular topological features in the map which constrain the possible interactions of robots  in a long narrow corridor  for instance  it may be impossible for one robot
to overtake another and so robots must enter and exit in a first in first out order  on the
other hand  a large open space may permit many robots to pass through it simultaneously
without collision 
we can characterise these features as particular kinds of subgraphs occurring in the
road map  if we can decompose a map into a collection of such simple subgraphs  then we
can build plans hierarchically  first planning the movements from one subgraph to another 
then using special purpose planners to build paths within each subgraph 
in this paper we propose such an abstraction  we limit ourselves to considering an
homogeneous group of robots navigating using a shared road map  we identify particular
kinds of subgraphs in this road map which place known constraints on the ordering of robots
that pass through them  we use these constraints to make efficient planning algorithms for
traversing each kind of subgraph  and we combine these local planners into a hierarchical
planner for solving arbitrary problems 
this abstraction can be used to implement both centralised and prioritised planners 
and we demonstrate both in this paper  unlike most heuristic abstractions  this method is
sound and complete  that is  when used with a centralised search it is guaranteed to find a
correct plan if and only if one exists  this guarantee cannot be made when prioritised search
is used  however the two stage planning process means that a prioritised planner with the
abstraction can often find plans that would not be available to it otherwise  experimental
investigation shows that this approach is most effective in maps with only sparsely connected
graph representations 

   problem formulation
we assume for this work that we are provided with a road map in the form of a graph
g    v  e  representing the connectivity of free space for a single robot moving around the
world  e g  a vertical cell decomposition or a visibility graph  lavalle         we also have
a set of robots r    r            rk   which we shall consider to be homogeneous  so a single map
suffices for them all  we shall assume all starting locations and goals lie on this road map 
further  we shall assume that the map is constructed so that collisions only occur when
one robot is entering a vertex v at the same time as another robot is occupying  entering or
leaving this vertex  robots occupying other vertices in the map do not affect this movement 
with appropriate levels of underlying control these assumptions can be satisfied for most
real world problems 
a simple centralised approach to computing a plan proceeds as follows  first  initialise
every robot at its starting position  then select a robot and move it to a neighbouring vertex 
checking first that no other robot is currently occupying that vertex  continue in this fashion  selecting and moving one of the robots at each step until each is at its goal  pseudocode
for this process is shown in algorithm    the code is presented as a non deterministic algorithm  with choice points indicated by the choose operator  and backtracking required
when the fail command is encountered  in practice  a search algorithm such as depth first 
breadth first or a  search is necessary to evaluate all the alternative paths it presents 

   

fiexploiting subgraph structure in multi robot path planning

algorithm   a simple centralised planning algorithm 
   function plan g  a  b 
  
if a   b then
  
return hi
  
end if
  
choose r  r
  
select vf   a vf     r
  
choose vt   v    vf   v   g 
  
if a vt        then
  
fail
   
else
   
a vf     
   
a vt    r
   
return  r  vf   vt   plan g  a  b 
   
end if
    end function

  build a plan from a to b in graph g 
  nothing to do 
  choose a robot 
  find its location 
  choose an edge 
  the destination is occupied  backtrack 
  move the robot from vf to vt  
  recurse 

this algorithm does a complete search of the composite space gk   g  g      g 
for k    r  robots  after eliminating vertices which represent collisions between robots  the
size of the composite graph is given by 
fi
fi
fi
fi
fiv  gk  fi   n pk
 

n 
 n  k  

fi
fi
fi
k fi
fie g  fi   k  e g    n   p k  
  k  e g  

 n     
 n  k     

where n    v  g   and k    r   the running time of this algorithm will depend on the
search algorithm used  but it can be expected to be very long for moderately large values
of n and k 

   subgraph abstraction
consider the problem shown in figure    this road map contains    vertices and    edges 
and there are   robots to plan for  so  according to the above formulae  the composite
graph has                vertices and                        edges  a small map has
expanded into a large search problem  but to a human mind it is obvious that a lot of these
arrangements are equivalent  what is important is not the exact positions of the robots 
but their ordering 
consider the subgraph labeled x  we recognise this subgraph as a stack  that is  robots
can only move in and out of this subgraph in a last in first out  lifo  order  robots inside
the stack cannot change their order without exiting and re entering the stack  so if our
goal is to reverse the order of robots in x  we know immediately that this cannot be done
without moving all the robots out of the stack and then have them re enter in the opposite
order  once the robots are in the right order  rearranging them into the right positions is
   

firyan

y 

x 

x 
a

x 

x 

x 

y 

y 

y 

y 

y 

y

z 

z 

z 

z 

z 

z

x 

c

b

x

z 

figure    a planning problem illustrating the use of subgraphs 
trivial  thus we can make a distinction between the arrangement of the robots  in which
we specify exactly which vertex each robot occupies  and the configuration of the stack  in
which we are only interested in their order  
now x has   vertices  so when there are m robots in the stack  there are   pm  
       m   possible arrangements  so the total number of arrangements is 
 

p         p         p      p                          
     

in terms of deciding whether a robot can leave the stack  however  all we need to know is
their order  so we need only represent                             different configurations
of the stack 
subgraphs y and z are also stacks  applying this analysis to all three  we find that
we can represent the abstract state space with only    different states  and     possible
transitions between states  moving the top most robot off one stack onto another   this is
dramatically smaller than the composite map space above 
a stack is a very simple kind of subgraph and we will need a larger collection of canonical
subgraphs to represent realistic problems  the key features we are looking for are as follows 
   computing transitions to and from the subgraph does not require knowledge of the exact arrangement of robots within the subgraph  only some more abstract configuration
 in this case  their order  
   if two arrangements of robots share the same configuration  then transforming one
into the other can be done easily without search 
   therefore planning need only be done in the configuration space  which is significantly
smaller 
later we will introduce three more subgraph types  cliques  halls and rings  which also
share these properties and which are readily found in realistic planning problems  but first
we need to formalise the ideas of subgraph planning 

   

fiexploiting subgraph structure in multi robot path planning

   definitions
in this section we outline the concepts we will use later in the paper  a complete formal
definition of these terms is provided in the appendix  along with a proof of soundness and
completeness of the subgraph planning process 
given a map represented by a graph g we partition it into a set of disjoint subgraphs
s            sm   these subgraphs are induced  i e  an edge exists between two vertices in a
subgraph if and only if it also exists in g 
an arrangement a of robots in g is a   to   partial function a   v  g   r  which
represents the locations of robots within g  if robot r is in vertex v  we write a v    r 
we can also speak of the arrangement of robots within a subgraph s  we will denote
arrangements by the lowercase roman letters a  b
a configuration of a subgraph s is a set of equivalent arrangements of robots within s 
two arrangements are equivalent if there exists a plan to move robots from one to the other
without any robots leaving the subgraph  we will denote a configuration of subgraph sx
by cx   the configuration of the whole map can then be represented as a tuple of subgraph
configurations     c            cm   
there are two operators  and   which operate on configurations  representing a robot
entering and leaving the subgraph respectively  when a robot r moves between two subgraphs sx and sy their configurations change depending on the identity of the edge  u  v 
on which the robot traveled  we write 
c x  cx    r  u  
c y  cy   r  v 
in complex subgraphs it is possible for such a transition to result in several possible configurations  so the operators  and   return sets  it is also possible that a transition is
impossible from a particular configuration  in which case the operation returns the empty
set 
an abstract plan  can now be defined as a sequence of transitions  with intermediate
configurations   for every abstract plan between two arrangements there exists at least one
corresponding concrete plan  and vice versa  all the subgraph transitions in the concrete
plan must also exist in the abstract plan  the equivalence of arrangements in a configuration
then guarantees the existence of the intermediate steps  see the appendix for a complete
proof 

   subgraph planning
we can now construct a planning algorithm which searches the space of abstract plans  algorithm     the procedure is much the same as before  first we compute the configuration
tuple for the initial arrangement  then we extend the plan one step at a time  each step
consists of selecting a robot r and moving it from the subgraph it currently occupies sx to
a neighbouring subgraph sy in the reduced graph x  along a connecting edge  u  v  
this transition is only possible if the plan step  s   u  v   is applicable  if it is  it may
result in a number of different configurations in the subgraph entered  we need to choose
one to create the configuration tuple for the next step  both the applicability test and the
selection of the subsequent configurations are performed in lines       of abstractplan 
   

firyan

the abstract plan is extended step by step in this fashion until it reaches a configuration
tuple which matches the goal arrangement  the resulting abstract plan is then resolved into
a concrete plan  for each transition in the abstract plan we build two short concrete plans
 one to move the robot to the outgoing vertex of the transition  and one to make sure the
incoming vertex is clear and the subgraph is appropriately arranged to create the subsequent
configuration  since these two plans are on separate subgraphs  they can be combined in
parallel  the final step is to rearrange the robots into the goal arrangement  again  this
can be done in parallel on each of the subgraphs 
abstractplan has been written as a non deterministic program  including choicepoints  a search algorithm such as breadth first or depth first search is needed to examine
each possible set of choices in some ordered fashion  if this search is complete then an
abstract plan is guaranteed to be found  if one exists and so by the theorem above this
planning algorithm is both sound and complete  note that the resolution phase of the
planner is entirely deterministic  so no further search is needed once an abstract plan is
found 
    subgraph methods
the efficiency of this algorithm relies on being able to compute several functions without a
lot of search 
 exit to compute c    r  u   testing if it is possible for a robot to exit the subgraph
and determining the resulting configuration s  
 enter to compute c   r  v   testing if it is possible for a robot to enter the subgraph
and determining the resulting configuration s  
 terminate to compute b s  c  testing if it is possible for the robots in the subgraph
to move to their terminating positions 
 resolveexit to build a plan rearranging robots in a subgraph to allow one to exit 
 resolveenter to build a plan rearranging robots in a subgraph to allow one to
enter 
 resolveterminate to build a plan rearranging robots in a subgraph into their
terminating positions 
the key to efficient subgraph planning is to carefully constrain the allowed structure
of the subgraphs in our partition  so these functions are simple to implement and do not
require expensive search  the advantage of this approach is that each of these functions can
always be computed based only on the arrangement of other robots within that particular
subgraph  not relying on the positions of robots elsewhere 

   subgraph structures
the key to this process is therefore in the selection of subgraph types  these abstractions
need to be chosen such that 
   

fiexploiting subgraph structure in multi robot path planning

v 

v 

v 

v 

vk

v 

 a  a stack

v 

vk

 b  a hall

v 

v 

v 

v 

v 

v 

v 

v 

 c  a clique

 d  a ring

figure    examples of the four different subgraph structures 

   they are commonly occurring in real road maps 
   they are easy to detect and extract from a road map 
   they abstract a large portion of the search space 
   computing the legality of transitions is fast  sound and complete 
   resolving an abstract plan into a concrete sequence of movements is efficient 
in this paper we present four subgraph types  stacks  halls  cliques and rings  which satisfy
these requirements  in the following analysis  let n be the the number of vertices in the
subgraph and k be the number of robots occupying the subgraph before the action takes
place 
    stacks
a stack  figure   a   represents a narrow dead end corridor in the road map  it has only
one exit and it is too narrow for robots to pass one another  so robots must enter and leave
in a last in first out order  it is one of the simplest subgraphs and does not occur often
in real maps  but it serves as an easy illustration of the subgraph methods  formally it
consists of a chain of vertices  each linked only to its predecessor and its successor  only
the vertex at one end of the chain  called the head  is connected to other subgraphs so all
entrances and exits happen there 
a configuration of a stack corresponds to an ordering of the robots that reside in it  from
the head down  robots in the stack cannot pass each other  and so the ordering cannot be
changed without the robots exiting and re entering the stack 

   

firyan

      enter
a robot can always enter the stack as long as the stack is not full  only one new configuration is created  adding the robot to the front of the ordering  this computation can be
done in o    time 
      exit
a robot can exit the stack only if it is the top robot in the ordering  only one new
configuration is created  removing the robot from the ordering  this computation can also
be done in o    time 
      terminate
to determine whether termination is possible  we need to check if the order of robots in the
current configuration is the same as that in the terminating arrangement  this operation
takes o k  time 
      resolveenter
rearranging robots inside the stack is simple since we know that the ordering is constant 
to vacate the top of the stack  the only possible entrance point  we move robots deeper
into the stack  as necessary   there is guaranteed to be room  since entering a full stack is
not permitted  at worst this takes o k  time 
      resolveexit
when a robot exits the stack  the abstract planner has already determined that it is the
first robot in the stack with no others between it and the head vertex  it can simply move
up the stack to the head  and then out  no other robots need to be moved  at worst this
takes o n  time 
      resolveterminate
finally  moving robots to their terminating positions can be done in a top to bottom order 
if a robot is below its terminating position it can move upwards without interference  if
a robot is above its terminating position  other robots below may need to be moved lower
in order to clear its path  this approach is sound  since the terminating positions of these
robots must be further down the stack  or else the ordering would be different   this process
has an o nk  total worst case running time 
    halls
a hall is a generalisation of a stack  figure   b    like a stack  it is a narrow corridor
which does not permit passing  but a hall may have multiple entrances and exits along its
length  formally it consists of a single chain of vertices  each one joined to its predecessor
and its successor  there must be no other edges between vertices in the hall  but there may
be edges connecting to other subgraphs from any node in the hall  halls are much more
commonly occurring structures  but still maintain the same property as stacks  the robots

   

fiexploiting subgraph structure in multi robot path planning

j  
v 

v 

v 

v 

v 
a

v 
b

c

d
j  
v 

v 

v 

v 

v 
b

a

v 
c

d
j  
v 
a

v 

v 

v 

b

v 

v 

c

d

figure    example of entering a hall subgraph  with k      n     and i      robot d can
enter at three possible sequence positions j        or   but not at j     

cannot be reordered without exiting and re entering  thus  as with stacks  the configuration
of a hall corresponds to the order of the robots occupying it  from one end of the hall to
the other 
      enter
a robot can enter a hall as long as it is not full  the configurations generated by that
entrance depend on three factors     the size of the hall n     the number of robots
already in the hall k  and    the index i of the vertex at which it enters  ranging from   to
n  
figure   shows how entering a hall can result in several different configurations  it is
a matter of how the robots already in the hall are arranged  to the left and right of the
entrance  before the entering robot moves in  if there is enough space in the hall on either
side of the entrance vertex  then the new robot can be inserted at any point in the ordering 
but if space is limited  as in the example  then it may not be possible to move all the robots
to one side or another  limiting the possible insertion points 
given the three variables k  n  i above  we can compute the maximum and minimum
insertion points as 
j  min i     k 
j  max    k   n  i  

   

firyan

creating a new configuration is then just a matter of inserting the new robot into the
ordering at the appropriate point  since the list of robots needs to be copied in order to do
this  it takes o k  time for each new configuration 
      exit
whether a robot can exit a hall via a given edge again depends on several factors     the
size of the hall n     the number of robots in the hall k     the index i of the vertex from
which it exits  from   to k      the index j of the robot in the ordering  from   to k   exit
is possible if 
j  i  n   k  j 
if exit is possible there is one resulting configuration  the previous ordering with the robot
removed  this takes o k  time to compute 
      terminate
checking termination is the same for halls as with stacks  we just have to test that the order
of robots in the final arrangement matches the current configuration  this can be done in
o k  time for k robots in the hall 
      resolveenter
to resolve an entrance to a hall we need to know which of the subsequent configurations we
are aiming to generate  so we know the proper insertion point for the entering robot  the
robots before the insertion point are shuffled in one direction so that they are on one side
of the entry vertex  and the rest to the other side  at worst this will take o nk  time 
      resolveexit
resolving an exit involves moving the robot up or down the hall to the exit vertex  shuffling
any other robots that are in the way  in the worst case  in which all the robots shuffle from
one end of the hall to the other  this takes o nk  time 
      resolveterminate
resolveterminate for a hall is identical to that for a stack  described above 
    cliques
a clique  figure   c   represents a large open area in the map with many exit points
 vertices  around its perimeter  robots can cross directly from any vertex to another  and
as long as the clique is not full  other robots inside can be shuffled out of the way to allow
this to happen 
formally a clique is a totally connected subgraph  cliques have quite different properties
to halls and stacks  as long as there is at least one empty vertex in a clique  it is possible
to rearrange it arbitrarily  so a configuration of a clique  in this circumstance  is just the
set of robots it contains 

   

fiexploiting subgraph structure in multi robot path planning

however there are a special set of configurations in which the clique is locked  this
occurs when the number of robots in the clique equals the number of vertices  then it
is impossible for the clique to be rearranged  a configuration of a locked clique has to
explicitly record the position of each robot 
      enter
a clique can always be entered so long as it is not full  if the clique has more than one
vacant vertex  then there is a single new configuration with the entering robot added to the
set of occupants  if the clique has only one space remaining  then the entering robot locks
the clique  in theory  at this point it is necessary to make a new configuration for every
possible arrangement of the occupying robots  with the entering robot always in the vertex
it enters  
in practice  it is more efficient to create just a single locked configuration which
records the locking robot and its vertex  and leaves the other positions unspecified  any
permutation of the other robots is possible  so the exact details of the configuration need
not be pinned down until the next action  either exit or terminate  requires them to be 
this is a form of least commitment  and it can significantly reduce the branching factor of
our search 
performing this test and creating the new configuration takes o k  time for k robots in
the clique 
      exit
if the clique is unlocked then any robot can exit from any vertex and the new configuration
is created by simply removing the robot from the set of occupants 
if the clique is locked then a robot can only exit from the specific vertex that it occupies  the resulting configuration is unlocked and the exact locations of the robots can be
discarded 
in the least commitment version  the locking robot is constrained to exit from its vertex
and every other robot can exit from any vertex except the one occupied by the locking
robot 
performing this test and creating the new configuration takes o k  time for k robots in
the clique 
      terminate
with an unlocked configuration  checking for termination simply consists of making sure
that all  and only  the required occupants are in the clique  for a locked configuration the
robots must all be in their terminating positions  as there is no possibility of rearranging
them   in the least commitment version just the locking robot must be in its terminating vertex  we can then assume that all the other robots are also in their places  thus
committing to a choice of configuration that we delayed earlier  
performing this test takes o k  time for k robots in the clique 

   

firyan

      resolveenter
if the entrance vertex is occupied when a robot wishes to enter then we can simply move
the occupant directly to another vacant vertex in the clique  since every vertex is connected
to every other 
if we are using least commitment and the entering robot locks the clique then we need to
look ahead in the plan to see the next action involving this clique  if it is an exit transition
then we need to move the exiting robot to the exit vertex now  before the clique is locked  
if there is no subsequent exit  meaning the robots will be terminating in this clique  then
we need to rearrange them into their terminating positions at this point 
if we amortise the cost of any rearrangements over the subsequent call to resolveexit
or resolveterminate we can treat this operation as taking o    time 
      resolveexit
if the clique is full at the time of exit then we can assume that the exiting robot is already
at its exit vertex and nothing needs to be done  on the other hand  if the clique is not full it
may be that the robot is not at its exit vertex  it must be moved there  if the exit vertex is
already occupied by another robot  it can be moved into another unoccupied vertex  both
these movements can be done directly  as the clique is totally connected  this operation
takes o    time 
      resolveterminate
if the clique is locked then we can assume that the robots have already been appropriately
arranged into their terminal positions and no further work needs to be done  otherwise the
robots may need to be rearranged  a simple way to do this is to proceed as follows  for each
robot that is out of place  first vacate its terminating position by moving any occupant to
another unoccupied vertex  then move the terminating robot into the vertex  once a robot
has been moved in this way it will not have to move again  so this process is correct but it
may produce longer plans than necessary  the upside is that it takes only o n  time 
    rings
a ring  figure   d   resembles a hall with its ends connected  formally  it is a subgraph s
with vertices v  s     v            vn   and induced edges e s  satisfying 
 vi   vj    e s  iff  i  j      mod n 
as with a hall  ordering is important in a ring  robots in the ring cannot pass one another
and so cannot re order themselves  they can  however  rotate their ordering  provided that
the ring is not full   thus in a ring of size   or more  the sequence hr    r    r  i is equivalent
to hr    r    r  i but not to hr    r    r  i  equivalent sequences represent the same configuration 
like cliques  rings are locked when they are full  a locked ring cannot be rotated  so
in a ring of size three the sequences hr    r    r  i and hr    r    r  i are not equivalent  they
represent two locked configurations with different properties 

   

fiexploiting subgraph structure in multi robot path planning

      enter
a robot may always enter a ring provided that it is not full  if there are k robots already
occupying the ring  then there are k possible configurations that can result  or one if k is
zero   one for each possible insertion point 
if the entering robot locks the ring then we must also record the specific positions of
each robot in the ring  this will still only produce k different configurations because the
robots cannot be arbitrarily rearranged  unlike in cliques 
it is also possible to produce least commitment versions of enter for rings as with
cliques  again  this can significantly reduce the branching factor of the search  but the
details are more involved than we wish to enter into in this paper 
this operation takes o k  time for each new configuration generated 
      exit
when the ring is locked a robot can only exit from its recorded position  otherwise it can
exit from any vertex  the robot is removed from the sequence to produce the resultant
configuration  the new configuration is unlocked and any position information can be
discarded  this can be done in o k  time for k robots in the ring 
      terminate
to check if termination is possible we need to see if the order of robots around the ring in
the terminal arrangement matches that of the current configuration  if the configuration is
not locked then rotations are allowed  otherwise the match must be exact  this test can be
done in o k  time for k robots in the ring 
      resolveenter
when a robot is about to enter the ring  we need to first rearrange it so that the the entry
vertex is empty and the nearest robots on either side of that vertex provide the correct
insertion point for the subsequent configuration  as selected in enter above  this may
require shuffling the robots one way or another  in much the same fashion as in a stack or
hall  in the worst case this will take o nk  operations for k robots in a ring of n vertices 
      resolveexit
if a ring is locked then any robot exiting must already be at its exit position so nothing needs
to be done  otherwise  in an unlocked ring  the robots may need to be shuffled around the
ring in order to move the robot to its exit  in the worst case this will take o nk  operations
for k robots in a ring of n vertices 
      resolveterminate
if a ring is locked then all the robots must already be in their terminating positions  this is
guaranteed by the abstract planner  otherwise they will need to be rotated into the correct
positions  once one robot has been moved to its correct vertex  the rest of the ring can be
treated as a stack and the resolveterminate method described above can be used  with
o nk  worst case running time for k robots in a ring of n vertices 
   

firyan

    summary
of these four subgraphs halls and rings are the most powerful  such subgraphs are not only
common in the structured maps of man made environments  but can also be found often
in purely random graphs  consider  any shortest path in an unweighted graph is a hall  
halls  rings and cliques of significant size can be found in many realistic planning problems 
importantly  these structures are well constrained enough that the six procedures for
planning outlined above can all be implemented efficiently and deterministically  without the
need for any further search  in the cases of the clique and the ring  the resolution methods
we describe sometimes sacrifice path optimality for speed  but this could be improved by
using smarter resolution planners  since the resolution stage is only done once  this probably
would not have a major effect on the overall running time of the planner 

   prioritised planning
a common solution to the rapid growth of search spaces in multi robot planning is prioritised
planning  erdmann   lozano perez        van den berg   overmars         in this
approach we give the robots a fixed priority ordering before we begin  planning is performed
in priority ordering  first a plan is built for just the robot with highest priority  then a plan
for the second highest  such that it does not interfere with the first  then the third  and so
on  each new plan must be constructed so that it does not interfere with the plans before
it  an example implementation is shown in algorithm    usually there is no backtracking
once a plan has been made  this is signified in the algorithm by the cut operator in line  
of plan 
because of this cut  the search is no longer complete  there are problems with solutions
that a prioritised planner cannot find  figure   is an example  robots a and b wish to
change positions  to plan for either robot on its own is easy  the plan contains just one
step  but to plan for both robots together requires each of them to move out of its way 
to the right hand side of the map so that the other can pass  a prioritised planner which
committed to a one step plan for either a or b cannot then construct a plan for the other
robot which does not interfere 
this incompleteness is not just a mistake  however  it is the core of what makes prioritised planning more efficient  the search space has been pruned significantly by eliminating

x 

x 
a

x 

x 

b
y

figure    a simple planning problem that cannot be solved with naive prioritised planning 
the goal is to swap the positions of robots a and b 

   

fiexploiting subgraph structure in multi robot path planning

certain plans from consideration  if there is still a viable solution within this pruned space
 and often there is  then it can be found much more quickly  in the  hopefully few  cases
where it fails  we can always resort to a complete planner as a backup 
    prioritised subgraph planning
prioritised planning is not strictly a competitor to subgraph planning  in fact  prioritised
search and the subgraph representation are orthogonal ideas  and it is quite possible to use
both together  as in algorithm    a plan is constructed for each robot consecutively  but
rather than building an entire concrete plan  only the abstract version is produced  in the
fashion of algorithm   earlier  only when compatible abstract plans have been produced
for every robot  are they resolved into a concrete plan 
as well as adding the advantage of abstraction to prioritised planning  the subgraph
representation also allows the planner to cover more of the space of possible plans  by
delaying resolution until the end  we avoid commitment to concrete choices for a high
priority robot which will hamper the planning of later robots 
to illustrate this  lets return to the example in figure   above  if we partition this
subgraph so that vertices  x    x    x    x    are a hall x  then the prioritised subgraph planner
can solve the problem  the abstract plan for the highest priority robot is empty  there is
nothing for it to do as it is already in its goal subgraph  given this plan  the second highest
priority robot can plan to move from x to y and then back again  this plan can produce
the goal configuration required  resolving this plan will move the highest priority robot to
x  and back again as needed  but this plan will be built by the resolve methods for halls 
and not by search 
of course there is no such thing as a free lunch and this example only works if we choose
the right partition  if instead we treat  x    x    as a stack and  x    x    y  as a separate hall
then the prioritised subgraph planner will not help us  furthermore there exist problems 
such as the one in figure   which can be solved by standard prioritised planners but will
fail if we introduce the wrong subgraph abstraction  it is difficult to generate more realistic

x 

x 

x 

a

x 
b

y

figure    a simple planning problem that can be solved with naive prioritised planning but
not with the subgraph abstraction  the goal is to swap the positions of robots
a and b  with priority ordering a  b the subgraph planner will choose for robot
a to remain inside the hall  robot b is then trapped  because a blocks the only
exit to y  note that the edges  x    y  and  y  x    are directed  

   

firyan

cases of this problem with small numbers of robots  but as we will see in section     below 
they can occur when the number of robots is large 

   search complexity
let us consider more carefully where the advantages  if any  of the subgraph decomposition lie  subgraph transitions act as macro operators between one abstract state  set of
configurations  to another  there is a long history of planners using macros of one kind
or another  and their advantages and disadvantages are well known  see section       it is
widely recognised that macros are advantageous when they reduce the depth of the search 
but become a disadvantage when too many macros are created and the branching factor of
the search becomes too large  these guidelines also apply to the use of subgraphs 
a typical search algorithm proceeds as follows  select a plan from the frontier of incomplete plans and create all expansions  add all the expansions to the frontier and recurse
until a complete plan is found  the time taken to complete this search is determined by
the number of nodes in the search tree  which is in turn determined by three factors 
   d  the depth of the goal state 
   b  the average branching factor of the tree  i e  the number of nodes generated per
node expanded
   the efficiency of the search 
a perfect search algorithm  which heads directly to the goal  will nevertheless contain o bd 
nodes as the alternative nodes must still be generated  even if they are never followed  an
uninformed breadth first search  on the other hand  will generate o bd   nodes  this can be
regarded as a sensible upper bound on the efficiency of the search  although it is possible
to do worse  
macro operators tend to decrease d at the expense of increasing b  so do very well in
uninformed search when d dominates  but show less advantage when a good heuristic exists 
where b and d are equally important  so it becomes important to consider how to keep the
increases in branching factor to a minimum  in the case of subgraph planning  there are
two main reasons why b increases 
   the reduced graph may have a larger average degree than the original  since a
subgraph contains many vertices  it tends to have more out going edges than a single
vertex  if all these edges connect to different subgraphs  then the branching factor will
be significantly larger  sparse subgraphs  such as halls  are worse in this regard than
dense subgraphs  such as cliques   the subgraph decomposition needs to be chosen
carefully to avoid this problem 
   a single subgraph transition may create a large number of possible configurations 
such as when a robot enters a large hall which is already occupied by several robots 
in some cases it may not strictly matter which configuration is generated and where
possible we use least commitment to avoid creating unnecessary alternatives  but if
there is the possibility that different configurations will result in different outcomes

   

fiexploiting subgraph structure in multi robot path planning

further down the track  then they all need to be considered  halls in particular have
this problem 
as we will see in the experiments that follow  careful choice of the subgraph decomposition is important to avoid these pitfalls  but with an appropriate partition the abstraction
can significantly improve both informed and uninformed search 

   experiments
to empirically test the advantages of the subgraph approach  we ran several experiments
on both real and randomly generated problems  our first experiment demonstrates how the
algorithms scale with changes to the size of the problem  in terms of the number of vertices 
edges and robots  under a standard breadth first search  the second experiment shows how
these results are affected by using an heuristic to guide search  both of these experiments
use randomly generated graphs  the final experiment demonstrates the algorithm on a
realistic problem 
in the first two experiments  maps were generated randomly and automatically partitioned into subgraphs  random generation was done as follows  first a spanning tree was
generated by adding vertices one by one  connecting each to a randomly selected vertex in
the graph  if further edges were required they were generated by randomly selecting two
non adjacent vertices and creating an edge between them  all edges were undirected  
automated partitioning worked as follows 
   initially mark all vertices as unused 
   select a pair of adjacent unused vertices 
   use this pair as the basis for growing a hall  a ring and a clique 
hall  randomly add unused vertices adjacent to either end of the hall  provided they
do not violate the hall property  continue until no further growth is possible 
ring  randomly add unused vertices adjacent to either end of the ring until a loop
is created  discard any vertices not involved in the loop 
clique  randomly add unused vertices adjacent to every vertex in the clique  continue until no further growth is possible 
   keep the biggest of the three generated subgraphs  mark all its vertices as used 
   go back to step    until no adjacent unused pairs can be found 
   all remaining unused vertices are singletons 
this is not intended to be an ideal algorithm  its results are far from optimal but it is fast
and effective  experience suggests that a partition generated by this approach can contain
about twice as many subgraphs as one crafted by hand  and it makes no effort to minimise
the degree of the reduced graph  but even with these randomly generated partitions the
advantages of the subgraph abstraction are apparent 
   it should be noted that this algorithm does not generate a uniform distribution over all connected graphs
of a given size  but it is very difficult to generate sparse connected graphs with a uniform distribution 
the bias is not deemed significant 

   

firyan

   
original
reduced

  

   

degree

  subgraphs

   
  

   

   
  
   

 

   
  

  

  

  

  

  

  

  

  

   

  

  vertices

  

  

  

  

  

  

  

  

   

  vertices

figure    the results of the automatic partitioning program in experiment  a  the left
graph shows the average number of subgraphs generated and the right graph
shows the average degree of the reduced graph 

    experiment    scaling problem size
      scaling  v  
in the first experiment we investigate the effect that scaling the number of vertices in the
graph has on search time  random graphs were generated with the number of vertices
ranging from    to      edges we added so that the average degree d    e   v   was always
equal to     this value seems typical for the realistic maps   one hundred graphs were
generated of each size  and each one was partitioned using the method described above 
figure   shows the performance of the auto partitioning  as we can see  the number of
subgraphs increased roughly linearly with the size of the graph  with an average subgraph
size of    for small graphs  with fewer than    vertices  the reduced graph after partitioning
is sparser than the original  but as the size increases the average degree of the reduced graph
gets larger  these results are presented for informative purposes only  we make no claims
about the quality of this partitioning algorithm  other than that it is indeed reducing the
size of the graph  if only by a small factor 
in each graph  three robots were given randomly selected initial and final locations  and
a plan was generated  figure   a  shows the average run times for each of the four approaches   it shows a clear performance hierarchy  the complete planners are significantly
slower than the priority planners  and in both cases the subgraph abstraction shows a significant improvement over the naive alternative  nevertheless  in every case the combinatorial
growth in runtime is apparent  note that the graph is plotted on a log scale   the linear
relationship between number of vertices and number of subgraphs prevents the subgraph
   it has been noted that these times are overall rather slow  we acknowledge this and attribute it to our
implementation  which is in java and which was not heavily optimised to avoid garbage collection  we
are currently working on an implementation with an optimised search engine  but we believe that these
results still provide a valuable comparison between methods 

   

fiexploiting subgraph structure in multi robot path planning

       

      

time  ms 

     

    

   
naive complete
naive priority
subgraph complete
subgraph priority

  

 
  

  

  

  

  

  

  

  

  

   

  vertices
 a  run times
 
naive complete
naive priority
subgraph complete
subgraph priority

 

naive complete
naive priority
subgraph complete
subgraph priority

  

 

path length

branching factor

 

 

  

 
  

 
 
 

 
  

  

  

  

  

  

  

  

  

   

  

  vertices

  

  

  

  

  

  

  

  

   

  vertices

 b  branching factor

 c  goal depth

figure    the results of experiment  a  in graph  a  the boxes show the first and third
quartile and whiskers to show the complete range  when an experiment failed to
complete due to time or memory limits or incompleteness of the search  the run
time was treated as infinite  no value is plotted for cases where more than    
of experiments failed  in graph  c  the goal depth for the naive complete and
subgraph priority approaches are identical for graphs of    to    vertices  so the
lines overlap  the naive complete planner could not solve problems with more
than    vertices 

   

firyan

table    the number of planning failures recorded by the two prioritised planning approaches in experiment  a 
  failures
vertices naive subgraph
  
 
 
       
 
 
  
 
 
        
 
 

approaches from doing better than this  a better partitioning algorithm should ameliorate
this problem 
to analyse the causes of this variation in run times  we need to consider the search
process more carefully  we can measure the search depth d and average branching factor b
for each experiment  the results are plotted in figure   b  and  c   as we expected  when
the subgraph abstraction is used  the goal depth is decreased and grows more slowly  but
the branching factor is increased  since we are doing uninformed search  d dominates and
the overall result is an improvement in planning time 
the incompleteness of prioritised planning shows in table    on three occasions the
naive prioritised search failed to find available solutions  however this was not a problem
for the prioritised subgraph search 
      scaling  e 
next we examine the effect of graph density  fixing the number of vertices at     we
generated random graphs with average degree ranging from     to      for each value 
    graphs were randomly generated and automatically partitioned  again the planning
problem was to move three robots from between selected initial and goal locations 
the results for this experiment are shown in figure    there does not appear to be much
overall change in the run times of any of the approaches  other than a small improvement
from the naive prioritised planner as the graph gets denser  figures   b  and  c  show
the expected result  increasing the density of the graph increases the branching factor but
decreases the depth  it appears to affect all four approaches similarly 
an interesting difference  however  is shown in table    this records the percentage of
experiments for which each of the prioritised planners was unable to find a solution  for
very sparse graphs  the naive planner failed on as many as     of problems  but it improved
quickly as density increased  with the subgraph abstraction added  the planner was able
to solve all but two of the problems  in no case did we find problems which were solved by
the naive planner and not by the subgraph planner 
      scaling  r 
in the last of the scaling experiments  we investigate how each approach performs with
varying numbers of robots  as before      random graphs were generated and partitioned 
each with    vertices and average degree of    and each one was partitioned using the
   

fiexploiting subgraph structure in multi robot path planning

     

time  ms 

    

   

  
naive complete
naive priority
subgraph complete
subgraph priority
 
   

   

   

   

   

   

   

   

   

   

   

degree
 a  run times
 

  

 

naive complete
naive priority
subgraph complete
subgraph priority

  
path length

branching factor

 

naive complete
naive priority
subgraph complete
subgraph priority

 
 

  

 
  
 
 
   

   

   

   

   

   

   

   

   

   

   

 
   

   

   

   

   

degree

   

   

degree

 b  branching factor

 c  goal depth

figure    the results for experiment  b 

   

   

   

   

   

firyan

      

time  ms 

     

    

   

naive complete
naive priority
subgraph complete
subgraph priority

  

 
 

 

 

 

 

 

 

 

 

  

  robots
 a  run times
naive complete
naive priority
subgraph complete
subgraph priority

 

naive complete
naive priority
subgraph complete
subgraph priority

    

 

   
path length

branching factor

 

 

 

  

 

 

 
 

 

 

 

 

 

 

 

 

  

 

 

 

 

  robots

 

 
  robots

 b  branching factor

 c  goal depth

figure    the results for experiment  c 

   

 

 

 

  

fiexploiting subgraph structure in multi robot path planning

table    the number of planning failures recorded by the two prioritised planning approaches in experiment  b 
  failures
degree naive subgraph
   
  
 
   
 
 
   
 
 
   
 
 
   
 
 
   
 
 
   
 
 
         
 
 

table    the number of planning failures recorded by the two prioritised planning approaches in experiment  c 
  failures
  robots naive subgraph
   
 
 
 
 
 
 
 
 
 
  
 
 
 
 
 
 
 
 
  
 
  
  
 

automatic partitioning algorithm  ten planning problems were set in each graph with the
number of robots varying from   to     in each case initial and goal locations were selected
randomly 
the running times for all four approaches are plotted in figure   a   there is a major
performance difference between the prioritised and non prioritised planners  with the prioritised planners able to handle twice as many robots  between the two complete search
approaches  the subgraph abstraction is an unnecessary overhead for very small problems 
but shows significant advantage as the number of robots increases 
there is less obvious advantage to the subgraph abstraction in the case of prioritised
planning  until we look at the failure rates shown in table    as the number of robots
increases the incompleteness of the naive prioritised algorithm begins to become apparent 
until with    robots we see that     of the problems could not be solved by this planner 
the advantage of the subgraph abstraction is now apparent  only a total of   problems
could not be solved out of      tried 

   

firyan

figures   b  and  c  plot the average branching factor and goal depth for these problems 
as in previous experiments  the subgraph abstraction is seen to increase the branching
factor but decrease the depth  in the complete search approaches the branching factor
grows rapidly with the number of robots  as each node on the search path contains a choice
of which robot to move  the prioritised approach reverses this trend  as planning is only
ever done for one robot at a time  and the later robots are much more heavily constrained
in the options available to them  providing fewer alternatives in the search tree 
      discussion
to summarise the above experiments  the advantages of the subgraph abstraction are twofold  firstly  it decreases the necessary search depth of a planning problem by compressing
many robot movements into a single abstract step  like other macro based abstractions  it
does this at the expense of increasing the branching factor but the gains seem to outweigh
the losses in practice  of course  this is dependent to some degree on the use of uninformed
search  which we shall address below 
the other advantage is specific to the prioritised planner  for tightly constrained problems with sparse maps and or many robots the incompleteness of the naive prioritised
search becomes a very significant issue  with the addition of the subgraph abstraction the
number of such failures is dramatically reduced  without additional search 
    experiment    heuristic search
all the experiments so far have involved uninformed breadth first search without the use of
an heuristic  as such  the runtime of the algorithms is more strongly affected by changes
in search depth than by the branching factor  as we explained above  uninformed search
has an o bd   expected running time  however a perfect heuristic can reduce this to o bd  
making the branching factor a much more significant aspect  a perfect heuristic is  of course 
unavailable  but it it possible to efficiently compute a reasonably good search heuristic for
this task by relaxing the problem  disregarding collisions we can simply compute the sum
of the shortest path lengths from each robots location to its goal  this is an underestimate
of the actual path length  but is accurate for loosely constrained problems  with few robots
and dense graphs  
in this experiment we used a best first search algorithm guided by this heuristic   at
every node in the search tree  we selected the plan which minimised this value  in the case
of the subgraph planner  the actual locations of robots at any time point are not specified 
just the subgraph they occupy  so the heuristic was calculated using the maximum distances
from any vertex in each robots subgraph to its goal  we pre computed the shortest path
distances between every pair of nodes before running the planner  so the time to do this
computation is not counted in the runtime for the algorithm 
the utility of this heuristic depends largely on how constrained the problem is  if the
graph is dense and there are relatively few robots  the heuristic should direct the planner
quickly to the goal  however if the graph is sparser  then interactions between robots
will become more important  and the heuristic will be less useful  for this reason  we
   the a  algorithm was not used  as we have no desire to minimise the length of the solution  just to find
a solution as quickly as possible 

   

fiexploiting subgraph structure in multi robot path planning

concentrate our attention in this experiment on how varying the density of the graph affects
the performance of our different approaches 
random maps of     vertices were generated  with average degree ranging from   to
   one hundred graphs were generated of each size and partitioned using the algorithm
described earlier  figure    shows the results  as the original graph gets denser  the
number of subgraphs decreases  mostly because it is possible to create longer halls  this is
good  as fewer subgraphs mean shorter paths  but the consequential increase in degree will
adversely affect the branching factor 
ten robots were placed randomly in each graph and assigned random goal locations 
all four planning approaches were applied to these problems  the resulting run times
are plotted in figure    a   the first thing that is apparent from this graph is that the
distinction between the different approaches is greatly reduced  both the size of the graph
and the number of robots are much larger than in previous experiments  and this has had
a corresponding effect on the goal depth and branching factor  figure    b  and  c    but
the run times are much smaller  so clearly the heuristic is effective at guiding the search 
on average the ratio of search nodes expanded to goal depth was very close to     in all
experiments  with only a slight increase in the more constrained cases  so we can conclude
that this heuristic is close to perfect 
when we compare the four approaches we see three distinct stages  in the most constrained case  at     edges  we see both the subgraph approaches outperforming either naive
approach  with a small benefit in prioritised search over complete search  at     edges the
pattern has changed  the two prioritised methods are significantly better than the two
complete approaches  as the number of edges increases  both the naive methods continue
to improve  while prioritised subgraph search holds steady and complete subgraph search
gets significantly worse  due to its rapid increase in branching factor   at     edges both
the naive approaches are doing significantly better than the subgraph approaches 

all
singletons
halls
cliques
rings

  

   

original
reduced

   

  

degree

  subgraphs

   
  
  

   
   

  

   

  

   

 

   
   

   

   

   

   

   

   

   

   

   

   

   

  edges

   

   

   

   

   

   

   

   

   

  edges

 a  subgraphs

 b  degree

figure     the results of the auto partitioner on graphs in experiment   

   

   

firyan

     

time  ms 

    

   
naive complete
naive priority
subgraph complete
subgraph priority
  
   

   

   

   

   

   

   

   

   

   

   

edges
 a  run times
   

naive complete
naive priority
subgraph complete
subgraph priority

   

naive complete
naive priority
subgraph complete
subgraph priority

   
  

path length

branching factor

   

  

   

  
   
  
 
   

   

   

   

   

   

 
   

   

   

edges

   
edges

 b  branching factor

 c  goal depth

figure     the results for experiment   

   

   

   

fiexploiting subgraph structure in multi robot path planning

table    the number of planning failures recorded by the two prioritised planning approaches in experiment   
  failures
  edges naive subgraph
   
  
 
   
 
 
   
 
 
   
 
 
   
 
 
         
 
 

the cause is clearly seen in figures    b  and  c   the branching factors for the subgraph
approaches increase significantly faster than for the naive approaches  and the corresponding
improvement in goal depth is not sufficient to outweigh the cost 
the benefits of the subgraph abstraction in highly constrained cases is also shown in the
failure cases  table     at     edges the naive prioritised search was unable to solve    
of problems  while prioritised search with subgraphs could solve them all  the number of
failures fell quickly as the density of the graph increased 
      discussion
once a graph becomes moderately dense and interactions between robots become few 
the total single robot paths measure becomes a near perfect heuristic  this makes the
branching factor a much more critical factor than when using uninformed search  the
auto partitioning algorithm we use does a very poor job limiting this factor and so the
subgraph approaches perform poorly 
better results could be achieved with better decomposition  but it is not clear whether
this could be found in a random graph without excessive computation  certainly partitioning such graphs by hand is no easy task  realistic graphs  on the other hand  are generally
shaped by natural constraints  e g  rooms  doors and corridors  which make decomposition
much simpler  as we will see in the following experiment 
    experiment    the indoor map
figure    shows the map for our final two experiments  based on the floor plan of level   of
the k   building at the university of new south wales  a road map of     vertices and    
edges has been drawn  by hand  connecting all the offices and open plan desk locations 
it is imagined that this might be used as a map for a delivery task involving a team of
medium sized robots 
the road map has been partitioned into    subgraphs     cliques    halls and   ring 
plus    remaining singleton nodes  subgraphs containing only one vertex   the average

   

firyan

figure     the map for experiment    vertices are coloured by subgraph 

   

fiexploiting subgraph structure in multi robot path planning

     
naive complete
naive priority
subgraph complete
subgraph priority

time  ms 

    

   

  
 

 

 

 

 

 

 

 

 

  

  

  

  

  

  

  

  

  

  

  

robots

figure     comparing run times for experiment   
degree of the reduced graph is      compared to     in the original   partitioning was done
by hand with the aid of an interactive gui which performed some simple graph analysis
and offered recommendations  by indicating nodes which could be added to a hall or clique
the user is creating   the road map was clearly laid out with partitioning in mind and
deciding on this partitioning was not on the whole difficult  large open spaces generally
became cliques  corridors became halls or rings  only the foyer area  around vertex    
caused any particular trouble when finding an ideal partitioning  due to its slightly unusual
topology  
a series of experiments were run in this world  varying the number of robots from  
to     for each experiment     runs were performed in which each robot was placed in
a random office or desk and was required to make a delivery to another random office or
desk  chosen without replacement  so no two robots had the same goal   plans were built
using both complete and prioritised planners with and without the subgraph abstraction 
all four approaches utilised the total single robot shortest path heuristic from the previous
experiment  the running times of each algorithm are shown in figure    
we can see that for small numbers of robots    or    the naive approaches are significantly better than the subgraph approaches  the overhead of doing subgraph search
outweighs its disadvantages in such simple problems  as the number of robots increases
the subgraph methods take over  and for around   to    robots both subgraph methods are
significant better than either naive approach  at    robots the combination of complete
search with subgraphs begins to perform less well and the two prioritised approaches are
the best performers  with a considerable advantage to the subgraph approach 
   in comparison  the auto partitioner yielded a partition with fewer subgraphs  avg        but higher
degree  avg        
   for the curious  the empty rooms in the centre of the map  near vertex     are bathrooms  we did not
consider that the robots would need to make deliveries there 

   

firyan

naive complete
naive priority
subgraph complete
subgraph priority

   
   

expanded   path

   
   
   
   
   
   
   
 

 

 

 

 

 

 

 

                                  
robots

figure     assessing the quality of the heuristic in experiment    the value plotted is the
ratio of the number of expanded nodes in the search tree and the goal depth  a
perfect heuristic yields a value of     

considering search complexity  let us first examine the performance of the heuristic 
figure    plots the ratio or the average number of expanded nodes in the search tree and
the goal depth  for a perfect heuristic  this value is      as it is in this experiment for up
to    robots  with more than    robots the heuristic begins to become inaccurate  the
inaccuracy seems to affect the complete planners more badly than the prioritised ones  and
in both cases the subgraph approach is more seriously affected than the naive approach 
to explain this difference  note that the heuristic we are using contains significantly less
information for subgraph search than it does for naive search  as we do not know exactly
where a robot is within a subgraph  we assume that it is in the worst possible position  this
means that the value of a configuration tuple is based solely on the allocation of robots to
subgraphs  and not on the particular configurations of those subgraphs  hall subgraphs in
particular may have several different configurations for the same set of robots  which will all
be assigned the same heuristic value despite having significantly different real distances to
the goal this creates a plateau in the heuristic function which broadens the search  for large
numbers of robots these permutations become a significant factor in the search  to improve
the heuristic we need to find a way to distinguish the value of different configurations of a
subgraph  this will probably require an extra method for each specific subgraph structure 
the graphs of branching factor and goal depth  figure     show what we have come to
expect  the branching factor is larger in the complete search than in prioritised search and
the subgraph abstraction makes it worse  significantly  the branching factor for prioritised
   

fiexploiting subgraph structure in multi robot path planning

naive complete
naive priority
subgraph complete
subgraph priority

  

naive complete
naive priority
subgraph complete
subgraph priority

    

path length

branching factor

  

  

  

    

  

 

 
 

 

 

 

 

 

 

 

                                  

 

robots

 

 

 

 

 

 

 

                                  
robots

 a  branching factor

 b  goal depth

figure     the branching factor and goal depth for experiment   
table    the number of planning failures recorded by the two prioritised planning approaches in experiment   
  failures
edges naive subgraph
   
 
 
       
 
 
  
 
 

search does not increase as more robots are added  because at any step in the plan only
one robot can be moved  the goal depth shows the opposite pattern  complete searches are
shorter than prioritised searches and the subgraph abstraction approximately halves the
search depth in all cases 
failure rates are recorded in table    the story here is different from that of previous
experiments  the naive prioritised planner was able to solve all the problems at every depth 
but adding the subgraph abstraction caused a small number of failures in more complex
problems  it is not clear what has caused this reversal  the cases involved are very complex
and elude analysis  this problem warrants further investigation 
      discussion
this experiment has shown that in a realistic problem with an appropriately chosen set
of subgraphs the subgraph abstraction is an effective way to reduce the search even when
a good heuristic is available  why does the subgraph abstraction work so well in this
example  compared to the random graphs in experiment    the answer seems to be found
in the degree of the reduced graph  automatically partitioning a random graph significantly
increases its degree  as we saw in figure    b   this  in turn  increases the branching factor
and thus the search time 

   

firyan

in contrast  when we partition the realistic map we decreased the degree of the graph
from     to      by hand  or       automatically   the branching factor for the subgraph
methods is still larger  as one transition can still create multiple configurations  but the
effect is reduced enough to be overcome by the decrease in goal depth  the indication is
that a realistic map has more structure that can be exploited by this abstraction  more
investigation is warranted to characterise the features that many this possible 

    conclusion
we have demonstrated a new kind of abstract representation for multi robot path planning
which allows for much faster planning without sacrificing completeness  decomposing a
road map into subgraphs is a simple and intuitive way of providing background knowledge
to a planner which can be efficiently exploited  the key is to find subgraph structures which
allow us to treat many arrangements of robots as equivalent configurations and to compute
transitions between these configurations quickly and deterministically  we have described
four such structures in this paper  stacks  halls  cliques and rings  these structures are
simple enough to compute configurations easily but also common enough to be found in
many realistic maps 
we have shown that abstract plans on these subgraphs can be resolved deterministically
into concrete plans without the need for further search  the planner is sound and complete 
although the plans produced are not necessarily optimal  future work could prove that it
is worth spending more time in the resolution phase to trim unnecessarily wasteful plans 
using  for example  simulated annealing  sanchez  ramos    frausto         it may be that
the time saved in abstract planning leaves us space to do more clever resolution 
the conventional solution to the search space explosion in multi robot planning is prioritisation  we have shown that not only is subgraph based planning competitive with
prioritised planning but also that the combination of the two methods is more powerful still
and in some cases  partly alleviates the incompleteness of the prioritised approach 
     related work
abstraction and hierarchical decomposition are standard techniques in planning and other
related search problems  the use of macro operators dates back as far as sacerdotis early
work on the abstrips planning system  sacerdoti        which introduced abstraction
hierarchies  whereby a problem could first be solved at a high level of abstraction while
ignoring lower level details  the idea has been re expressed in many different ways through
the history of planning  far too many to review in detail  this present work was particularly
inspired by the generic types of long and fox        in which they similarly detected
substructures in a task planning problem and solved them using structure specific planners 
hierarchical planning has been applied to path planning before with abstractions such
as approximate cell decomposition  barbehenn   hutchinson        conte   zulli        
generalised voronoi graphs  choset   burdick        choset        and general ad hoc
hierarchical maps  bakker  zivkovic    krose        zivkovic  bakker    krose              
but the structures identified in these examples do not carry over well to the multi robot
scenario 

   

fiexploiting subgraph structure in multi robot path planning

other faster solutions to the multi robot problem are available if we can assume the
existence of garage locations for each robot  lavalle   hutchinson        or other kinds
of temporary free space  sharma   aloimonos        fitch  butler    rus         the
method we present here makes no such assumption and is thus more general in application 
there does not appear to be any previous work which provides a complete abstraction based
planner for the general multi robot problem 
the work that bears most similarity to our own is not explicitly in robot path planning 
but in solving the sokoban puzzle  botea  muller    schaeffer        junghanns   schaeffer         that domain is significantly more constrained than ours  the map is necessarily
an orthogonal grid and the stones can only move when they are pushed by the man  but
the method they employ is similar  dividing a map up into rooms and tunnels they use
the strongly connected component algorithm to identify equivalent arrangements of boulders in each subpart  equivalent arrangements are then treated as a single abstract state 
corresponding to a configuration in our formulation  which is used as the state in a global
search  the particular structures they represent are different  but the general ideas of partitioning into independent local subproblems and identifying abstract states from strongly
connected components  are the same as those employed in this work 
     future plans
in the next stage of this project we plan to examine the symmetries provided by the subgraph
representation  recent work in symbolic task planning  porteous  long    fox       
has shown that recognising and exploiting symmetries and almost symmetries in planning
problems can eliminate large amounts of search  subgraph configurations provide a natural
ground for similar work in our problem domain and we expect similar improvements are
possible 
we also plan to further investigate the problem of automatic subgraph partitioning
of maps  having identified the importance of trading off path depth against branching
factor  we plan to make a partitioning algorithm which chooses subgraphs that optimise this
relationship  automatically finding an optimal partition could be very hard  but creating
a powerful interactive partitioning tool for a human operator would seem to be a viable
compromise  one approach would be to adapt the auto partitioner we describe in this
paper so that the seed vertices are selected by the user  who is then allowed to choose from
a number of possible subgraphs based on this selection 
further subgraph structures can also be identified  and we are currently working on
formalising the properties of tree structured subgraphs  another possibility would be to
generalise cliques and rings into a new ring with chords structure  although characterising
such a structure may prove difficult 
there have been many other advances in search technology which may be applicable
to the multi robot planning problem  we are currently in the process of re expressing the
entire problem as a constraint satisfaction problem  csp  in the gecode constraint engine
 gecode team         we believe that the csp formulation will be a powerful way to take
advantage of the structural knowledge that subgraph decomposition represents 

acknowledgments
   

firyan

id like to thank jonathan paxman  brad tonkes and maurice pagnucco for their help in
developing the ideas in this paper and proofreading the drafts 

appendix a  proof of soundness and completeness
in this appendix we set up the necessary formal definitions and then prove the soundness
and completeness of the abstract planning process  the main result is a theorem showing
that an abstract plan exists for a given problem if and only if a concrete plan also exists 
a   graphs and subgraphs
an induced subgraph s  g is a graph s    v  s   e s   such that
v  s   v  g 

e s      u  v    u  v  v  s    u  v   e g  

intuitively this describes a subgraph consisting of a subset of vertices with all their connecting edges from the parent graph  thus an induced subgraph can be specified solely in
terms of its vertices  we shall henceforth assume that all subgraphs we refer to are induced 
a partition p of g is a set  s            sm   of subgraphs of g satisfying
 
v  g   
v  si  
and
v  si    v  sj       i  j   i    j
i     m

given a graph g and a partition p we can construct the reduced graph x of g by
contracting each subgraph to a single vertex
v  x    p
e x      si   sj     x  si   y  sj    x  y   g 
a   robots and arrangements
let us assume we have a set of robots r  an arrangement a of robots in a graph g is a
  to   partial function a   v  g   r  an arrangement represents the locations of robots
within g  if a v    r  then robot r is at vertex v  we shall use the notation a v     
to indicate that a is undefined at v  i e  vertex v is unoccupied  an arrangement may not
necessarily include every robot in r  two arrangements a and b are said to be disjoint if
range a   range b      let ag represent the set of all arrangements of r in g 
if s is a subgraph of g  and a is an arrangement of r in g then we define a s  the
induced arrangement of r in s  as
a s v    a v   v  v  s 
if s  and s  are disjoint subgraphs of g with disjoint arrangements a  in s  and a  in
s    then we define the combined arrangement a   a   a  as an arrangement in s   s 
satisfying
 
a   v  if v  s 
a v   
a   v  if v  s 

   

fiexploiting subgraph structure in multi robot path planning

lemma   if a is an arrangement in g with partition p    s            sm   and  a            am  
is the set of induced arrangements ai   a si   then the combined arrangement a    am  
a 
given this identity  we can uniquely identify an arrangement a in g as the combination of
its induced arrangements over a partition p 
a   concrete plans
we now need to define what it means to move robots around a graph  first we will define
two operators  and   which respectively add and remove robots from a given arrangement 
formally    ag  r  v  g   ag is a mapping which satisfies
g

a   r  v    b
g

where

 
r
b u   
a u 

if u   v
otherwise

similarly     ag  r  ag is a mapping which satisfies
g

a r  b
g

where

 
 
b u   
a u 

if a u    r
otherwise

we will omit the subscript g when it is clear from the context 
we can now define a plan step s  r  e g  in g as a robot edge pair  r  u  v  
representing the movement of r along the edge from u to v  with u    v  a plan step is
applicable to an arrangement a  ag iff a u    r and a v       in this case we can apply
s to a to produce a new arrangement b   s a  where
s a     a   r    r  v 
a concrete plan  or just plan  in g from a  ag to b  ag is a sequence of plan steps
hs            sl i such that there exist arrangements a            al  ag with si applicable to ai 
and
a    a
al   b
ai   si  ai     i       i  l
lemma   if s is a subgraph of g and p is a plan in s then p is also a plan in g 
lemma   if p is a plan in g from a to b and q is a plan in g from b to c  then the
concatenation of p and q  written p q is a plan in g from a to c 
   

firyan

lemma   let p kq denote the set of all interleavings of sequences p and q  let s  and
s  be disjoint subgraphs of g  p  be a plan on s  from a  to b  and p  be a plan on s  from
a  to b    such that a  and a  are disjoint  any arbitrary interleaving p  p  kp  is a plan
on g from a   a  to b   b   
a   configurations
having defined the machinery for concrete plans  we now introduce abstraction  the key
idea is that of a configuration which is an abstraction of arrangements  if the robots in a
subgraph can be rearranged from one arrangement to another  without any of the robots
having to leave the subgraph during the rearrangement  then those two arrangements can
be treated as equivalent  configurations represent sets of equivalent arrangements in a
subgraph  so  for example  in a stack subgraph a configuration is the set of all arrangements
which have the same ordering of robots  an arrangement over an entire partitioned graph
can be abstracted as the list of configurations it produces in each of its subgraphs 
formally  we define a configuration relation  on graph g as an equivalence relation
g

over ag such that a  b iff there exists plans pab and pba in g from a to b and from b to a
g

respectively 
a configuration c of g is an equivalence class of   we write c     a  to represent
g

g

the equivalence class containing arrangement a  let cg be the set of all configurations of
g 
lemma   if a  b then range a    range b 
g

given this identity  we can unambiguously define the range of a configuration c to be
range c    range a   for any a  c
we can now extend our definitions of  and   to configurations  if c  cg is a
configuration of g  r  r and v  v  g  then


c   r  v      a   r  v     a  c  a v     
g
g
g


c    r  v      a   r    a  c  a v    r
g

g

g

note that  and   map configurations to sets of configurations  
given a partition p    s            sm   of g and a corresponding set of configuration
relations                we define a configuration tuple  of r in g as a tuple  c            cm  
s 

sm

where i   ci  csi   and
 

range ci     r

i     m

range ci    range cj       i  j   i    j
   astute readers will notice that c    r  v  never contains more than one element  although it may be
g

empty 

   

fiexploiting subgraph structure in multi robot path planning

a configuration tuple represents the abstract state of all the robots in the entire graph  in
terms of the configurations of the individual subgraphs in the partition  given an arrangement a of g we can construct a corresponding configuration tuple  a     c            cm   where
ci     a si    conversely  if a si  ci for all ci in   then we write a   
si

lemma   if a and b are arrangements in graph g with partition  s            sm   and  is a
configuration tuple in g with a  b    then there exists a plan from a to b in g 
proof
for each i           m  let ai   a si and bi   b si   now ai  ci and bi  ci so
ai  bi   therefore from the definition of  there exists a plan pi from ai to bi in si  
si

let p  p  k       kpm   since the pi s are plans on disjoint subgraphs  p is a plan from
a       am   a to b       bm   b as required 

a   abstract plans
with configuration tuples as our abstract state representation  we can now define abstract
plans  as sequences of subgraph transitions  plan steps which move a robot from one
subgraph to another  we will then prove the main result of this section  that an abstract
plan for a problem exists if and only if a corresponding concrete plan exists  this will allow
us later to prove the soundness and completeness of our subgraph planning algorithm 
for the rest of this section we shall assume that our graph g has a partition p  
 s            sm   with corresponding configuration relations                
s 

sm

a subgraph transition  or just transition  is a plan step s    r  u  v  such that u  sx  
v  sy and sx    sy   a transition s    r  u  v  is applicable to a configuration tuple
    c            cm   of g if
cx    r  u       where u  sx  
sx

and cy   r  v       where v  sy  
sy

that is  the robots in sx can be rearranged so that robot r can leave via u and the robots
in sy can be rearranged so that v is empty for r to enter 
if transition s    r  u  v  is applicable to     c            cm   with u  sx and v  sy then
we can apply s to  to compute a set s   of configuration tuples
 c           c m    s  
if and only if
c x  cx    r  u  
sx

and

c y

 cy   r  v  

c z

  cz   otherwise 

sy

lemma   if a is an arrangement in g with partition  s            sm   and transition s  
 r  u  v  is applicable to a then s is also applicable to  a   with
 s a    s  a  
   

firyan

proof let sx   sy be disjoint subgraphs from the partition such that u  sx   v  sy   let
ax   a sx and ay   a sy   let  a     c            cm    now
ax  cx
ax  u    r
 cx    r  u      
and similarly
ay  cy
ay  v     
 cy   r  v      
therefore s is applicable in  a  
further  let b   s a  and  b     c             c m    now
c x    b sx  
sx

   ax   r 
sx

 cx    r  u 
and
c y    b sy  
sy

   ay   r  v  
sy

 cy   r  v 
and
c z   cz  
therefore  b   s   as required 



lemma   if s    r  u  v  with u  v  sx  i e  s is not a transition  and a is an arrangement in g such that s is applicable in a  then  a     s a   
proof
let b   s a   let ai   a si and bi   b si for all i           m  let  a   
 c            cm   and  b     c             c m   
now the plan px   hsi is a plan from ax to bx in sx   so ax  bx implying cx   c x   for
all other z    x  we have az   bz so cz   c z   therefore  a     b  as required 


   

fiexploiting subgraph structure in multi robot path planning

now we can define an abstract plan  from arrangement  to  in g as a tuple     
where  is a sequence of configuration tuples h            l i and  is a sequence of plan steps
hs            sl i  such that
       
l      
si is applicable in i   
and i  s i    
theorem   an abstract plan from  to  in g exists if and only if there exists a corresponding concrete plan p from  to  in g 
proof case    p   
let         be an abstract plan on g from  to   with    h            l i and
   hs            sl i  let i    ci            cim   
we shall construct a concrete plan
p   p    hs  i  p        pl    hsl i  pl
where each pi is a concrete plan from ai to bi   satisfying
a     
bl    
ai   bi  i  
si   is applicable in bi  
and ai     si    bi    i           l    
proposition   ai and bi exist satisfying these conditions for all i           l 
proof by induction 
a     therefore a  exists 
assume ai exists 
let si      r  u  v  with u  sx and v  sy   from the definition of an abstract plan 
si   is applicable in i   and i     si    i    therefore
ci  
 cix    r  u     
x
n
o
i
 ci  

 a
 
 r 
u  
 
a u 
 
r 
a

c
x
x    
 a  cix   a u    r
set bix equal to this a  we now have
ci  
   bix    r  u  
x
 bix    r  u   ci  
x

   

firyan

also
ci  
 ciy   r  v     
y
n
o
i
 ci  

 a

 r 
v  
 
a v 
 
  
a

c
y
y    
 a  ciy   a v     
set biy equal to this a  we now have
ci  
   biy   r  v  
y
 biy   r  v   ci  
y
set biz   ai  sz for all other z 
   x  y 
bij is now defined for every subgraph sj in the partition of g  therefore bi   bi    bim
exists and is an arrangement in g 
so if ai exists then bi also exists for all i           l    
now si   is applicable in bi since
bi  u    bix  u    r
bi  v    biy  v     
so ai     si    bi   exists  and
ai    sx   bix   r  ci  
x
ai    sy   biy   r  v   ci  
y
ai    sz   biz   z 
   x  y   ciz
 ci  
z
so
ai    i  
by induction  ai  i exists for all i           l and bi  i exists for all i           l    
furthermore bl          l   so bi exists for all i for all i           l  as required 

proposition   a concrete plan pi from ai to bi exists  for i              l
proof

since ai   bi  i a plan pi must exist from ai to bi   by lemma   above 



proposition   p is a concrete plan from  to  in g 
proof
pi is a plan from ai to bi for all i              l  furthermore ai     si    bi    so
hsi   i is a plan from bi to ai     therefore by the concatenation of plans
p   p    hs  i        hsl i  pl
is a plan in g from a     to bl     as required 
   



fiexploiting subgraph structure in multi robot path planning

case  p    
let p   hs            sl i be a concrete plan from  to  in g  we wish to construct an
abstract plan         from  to  in g 
let t   ht            tl i be an increasing sequence of integers with t      and ti   t iff st is
a subgraph transition   note  we are using capital l to designate the length of the concrete
plan p and lowercase l to designate the number of transitions in that plan  which will be
the length of the corresponding abstract plan   
now construct the sequence of arrangements a   h            l i such that
    
i     si    i    i           l   
and split a into subsequences a            al such that


ff
ai   ti           ti    
define i    ti    i              l     h            l i and    hst            stl i 
proposition   a   a  ai  a  i
proof by induction 
by definition 
ti   ti     i
now assume t  i for t   ti   j  j    ai       we need to prove t    i  
let st      r  u  v   since t     
  t we must have u  v  sx   so using lemma   above
 t        st    t   
   t  
  i  
therefore  by induction
a  i   a  ai
as required 



proposition           is a valid abstract plan from  to  
proof
first we check that the initial and final configuration tuples contain  and 
respectively 
              
and
  al
   l  
 l      

   

firyan

now  for each i           l    let bi   ti      i e  the final element of ai    and let
  bi  sz for z           m 
let s   sti      r  u  v  with u  sx and v  sy   now s is applicable in bi by the
definition of p   therefore  by lemma   above  s is applicable in i and

biz

i      ai    
   s bi   
 s  bi      s i    as required 

therefore  is a valid abstract plan 



this theorem is significant for our planning problem  it tells us that we do not need to
perform a search of all concrete plans  instead  we need only search for an abstract plan
and then convert it into a concrete form  such a search will succeed if and only if a concrete
plan exists 

references
alami  r   fleury  s   herrb  m   ingrand  f     robert  f          multi robot cooperation
in the martha project  robotics   automation magazine  ieee              
alarie  s     gamache  m          overview of solution strategies used in truck dispatching systems for open pit mines  international journal of surface mining  reclamation and environment               
bakker  b   zivkovic  z     krose  b          hierarchical dynamic programming for robot
path planning  proceedings of ieee rsj international conference on intelligent
robots and systems           
barbehenn  m     hutchinson  s          efficient search and hierarchical motion planning
by dynamically maintaining single source shortest paths trees  ieee transactions on
robotics and automation                 
barraquand  j     latombe  j  c          robot motion planning  a distributed representation approach  international journal of robotics research                 
botea  a   muller  m     schaeffer  j          using abstraction for planning in sokoban  in
computers and games  lecture notes in computer science  vol        pp         
springer 
buro  m     furtak  t          rts games and real time ai research  proceedings of the
behavior representation in modeling and simulation conference  brims   arlington
va            
choset  h          sensor based motion planning  the hierarchical generalized voronoi
graph  ph d  thesis  california institute of technology  pasadena  california 
choset  h     burdick  j          sensor based planning  i  the generalized voronoi graph 
proceedings of the international conference on robotics and utomation    

   

fiexploiting subgraph structure in multi robot path planning

conte  g     zulli  r          hierarchical path planning in a multi robot environment with
a simple navigation function  ieee transactions on systems  man and cybernetics 
               
erdmann  m     lozano perez  t          on multiple moving objects  tech  rep      
m i t  ai laboratory 
everett  h   gage  d   gilbreth  g   laird  r     smurlo  r          real world issues
in warehouse navigation  proceedings of the spie conference on mobile robots ix 
     
fitch  r   butler  z     rus  d          reconfiguration planning for heterogeneous selfreconfiguring robots  proceedings of ieee rsj international conference on intelligent robots and systems              
gecode team         gecode  generic constraint development environment   available
from http   www gecode org 
hada  y     takase  k          multiple mobile robot navigation using the indoor global
positioning system  igps   proceedings of ieee rsj international conference on
intelligent robots and systems    
junghanns  a     schaeffer  j          sokoban  enhancing general single agent search
methods using domain knowledge  artificial intelligence                    
lavalle  s  m          planning algorithms  cambridge university press 
lavalle  s  m     hutchinson  s  a          optimal motion planning for multiple robots
having independent goals  in ieee transactions on robotics and automation 
vol     
long  d     fox  m          planning with generic types  chap     pp          morgan
kaufmann 
porteous  j   long  d     fox  m          the identification and exploitation of almost
symmetry in planning problems  in brown  k   ed    proceedings of the   rd uk
planning and scheduling sig 
sacerdoti  e          planning in a hierarchy of abstraction spaces  artificial intelligence 
              
sanchez  g   ramos  f     frausto  j          locally optimal path planning by using
probabilistic road maps and simulatead annealing  proceedings of iasted international conference on robotics and applications 
sharma  r     aloimonos  y          coordinated motion planning  the warehousemans
problem with constraints on free space  ieee transactions on systems  man and
cybernetics                 
van den berg  j     overmars  m          prioritized motion planning for multiple robots 
in proceedings of ieee rsj international conference on intelligent robots and systems  pp         
zivkovic  z   bakker  b     krose  b          hierarchical map building using visual landmarks and geometric constraints  proceedings of ieee rsj international conference
on intelligent robots and systems           
   

firyan

zivkovic  z   bakker  b     krose  b          hierarchical map building and planning based
on graph partitioning  ieee international conference on robotics and automation 

   

fiexploiting subgraph structure in multi robot path planning

algorithm   planning with subgraph abstraction 
   function plan g  p  r  a  b 
  
   a 
  
   b 
  
  abstractplan g  p  r     
  
p  resolve g  p    a  b 
  
return p
   end function

  build a plan from a to b in g using partition p 
  get the initial configuration 
  get the final configuration 
  build the abstract plan 
  resolve to a concrete plan 

   function abstractplan g  p  r        build an abstract plan from  to  in g using p 
  
if     then
  
return  hi   hi 
  done 
  
end if
  
 c            cm     
  
choose r  r
  choose a robot 
  
select x   r  range cx  
  find the subgraph it occupies 
  
choose sy  p    sx   sy    x
  choose a neighbouring subgraph 
  
choose  u  v   e g    u  sx   v  sy
  choose a connecting edge 
  choose the resulting configurations of sx and sy  
   
choose c x  cx    r  u 
   
choose c y  cy   r  v 
   
   c            c x           c y           cm  
  construct the new configuration tuple 
   
      abstractplan g  p  r     
  recurse 
   
    
   
    r  u  v  
   
return         
    end function
   function resolve g  p    a  b 
  resolve the abstract plan into a concrete plan 
  
       
  
   h            l i
  
   hs            sl i
  
p hi
  
a   a
  
for i            l     do
  
 r  u  v    si  
  the next transition 
  
 c             c m     i  
  the target configurations 
   
find sx   u  sx
   
find sy   v  sy
   
aiz  ai  sz   z           m
   
 pxi   bix    sx  resolveexit aix   r  u  c x  
  rearrange sx to let robot r exit 
  rearrange sy to let robot r enter 
   
 pyi   biy    sy  resolveenter aiy   r  v  c y  
   
p  p  pxi   pyi  
   
bi   ai          bix         biy         aim
   
ai    si    bi  
   
p  p   hsi   i
  add the transition 
   
end for
   
for z           m do
   
tz  sz  resolveterminate al  sz   b sz  
  rearrange sz into its final arrangement 
   
end for
   
p  p  t             tm  
   
return p
    end function

   

firyan

algorithm   a simple prioritised planning algorithm 
   function plan g  a  b 
  
a   v      v  g
  a  is the initial arrangement of robots
 
  
b  v      v  g
  b  is the final arrangement of robots
  
for i           k do
  
a   v    ri   for v   a v    ri
  
b   v    ri   for v   b v    ri
  
 p  pi   planone g  ri   hp            pi  i   h            i   a    b   
  build a plan for
  
cut
  do not backtrack once a plan
  
end for
   
return p
    end function

r        ri  
r        ri  

r        ri  
is found

   function planone g  ri   hp            pi  i   ht            ti  i   a  b 
  
if a   b then
  
return  hi  hi 
  done 
  
end if
  
choose rj  r   j  i
  choose a robot to move 
  
if j   i then
  
select vf   a vf     ri
  
choose vt   v    vf   v   g 
  choose a new action for ri
  
else
   
 r  vf   vt    pj  tj  
  select the old action for rj from pj
   
tj  tj    
   
end if
   
if a vt        then
   
fail
  backtrack if the destination is occupied 
   
end if
   
a vf     
  move the robot 
   
a vt    r
   
 p  pi   planone g  ri   hp            pi  i   ht            ti  i   a  b 
  recurse 
   
p   rj   vf   vt   p
  add this step to the global plan 
   
if j   i then
   
pi   ri   vf   vt   pri
  add this step to ri s plan 
   
end if
   
return  p  pi  
    end function

   

fi