journal of artificial intelligence research                  

submitted        published      

the complexity of planning problems
with simple causal graphs
omer gimenez

omer gimenez upc edu

dept  de llenguatges i sistemes informatics
universitat politecnica de catalunya
jordi girona     
      barcelona  spain

anders jonsson

anders jonsson upf edu

dept  of information and communication technologies
passeig de circumvallacio   
      barcelona  spain

abstract
we present three new complexity results for classes of planning problems with simple
causal graphs  first  we describe a polynomial time algorithm that uses macros to generate plans for the class  s of planning problems with binary state variables and acyclic
causal graphs  this implies that plan generation may be tractable even when a planning
problem has an exponentially long minimal solution  we also prove that the problem of
plan existence for planning problems with multi valued variables and chain causal graphs
is np hard  finally  we show that plan existence for planning problems with binary state
variables and polytree causal graphs is np complete 

   introduction
planning is an area of research in artificial intelligence that aims to achieve autonomous
control of complex systems  formally  the planning problem is to obtain a sequence of
transformations for moving a system from an initial state to a goal state  given a description
of possible transformations  planning algorithms have been successfully used in a variety
of applications  including robotics  process planning  information gathering  autonomous
agents and spacecraft mission control  research in planning has seen significant progress
during the last ten years  in part due to the establishment of the international planning
competition 
an important aspect of research in planning is to classify the complexity of solving
planning problems  being able to classify a planning problem according to complexity
makes it possible to select the right tool for solving it  researchers usually distinguish
between two problems  plan generation  the problem of generating a sequence of transformations for achieving the goal  and plan existence  the problem of determining whether
such a sequence exists  if the original strips formalism is used  plan existence is undecidable in the first order case  chapman        and pspace complete in the propositional
case  bylander         using pddl  the representation language used at the international
planning competition  plan existence is expspace complete  erol  nau    subrahmanian         however  planning problems usually exhibit structure that makes them much
c
    
ai access foundation  all rights reserved 

figimenez   jonsson

easier to solve  helmert        showed that many of the benchmark problems used at the
international planning competition are in fact in p or np 
a common type of structure that researchers have used to characterize planning problems is the so called causal graph  knoblock         the causal graph of a planning
problem is a graph that captures the degree of independence among the state variables
of the problem  and is easily constructed given a description of the problem transformations  the independence between state variables can be exploited to devise algorithms for
efficiently solving the planning problem  the causal graph has been used as a tool for
describing tractable subclasses of planning problems  brafman   domshlak        jonsson
  backstrom        williams   nayak         for decomposing planning problems into
smaller problems  brafman   domshlak        jonsson        knoblock         and as the
basis for domain independent heuristics that guide the search for a valid plan  helmert 
      
in the present work we explore the computational complexity of solving planning problems with simple causal graphs  we present new results for three classes of planning problems studied in the literature  the class  s  jonsson   backstrom         the class cn
 domshlak   dinitz         and the class of planning problems with polytree causal graphs
 brafman   domshlak         in brief  we show that plan generation for instances of the
first class can be solved in polynomial time using macros  but that plan existence is not
solvable in polynomial time for the remaining two classes  unless p   np  this work first
appeared in a conference paper  gimenez   jonsson         the current paper provides
more detail and additional insights as well as new sections on plan length and cp nets 
a planning problem belongs to the class  s if its causal graph is acyclic and all state
variables are either static  symmetrically reversible or splitting  see section   for a precise definition of these terms   the class  s was introduced and studied by jonsson and
backstrom        as an example of a class for which plan existence is easy  there exists a
polynomial time algorithm that determines whether or not a particular planning problem
of that class is solvable  but plan generation is hard  there exists no polynomial time algorithm that generates a valid plan for every planning problem of the class   more precisely 
jonsson and backstrom showed that there are planning problems of the class  s for which
every valid plan is exponentially long  this clearly prevents the existence of an efficient
plan generation algorithm 
our first contribution is to show that plan generation for  s is in fact easy if we are
allowed to express a valid plan using macros  a macro is simply a sequence of operators and
other macros  we present a polynomial time algorithm that produces valid plans of this
form for planning problems of the class  s  namely  our algorithm outputs in polynomial
time a system of macros that  when executed  produce the actual valid plan for the planning
problem instance  the algorithm is sound and complete  that is  it generates a valid plan
if and only if one exists  we contrast our algorithm to the incremental algorithm proposed
by jonsson and backstrom         which is polynomial in the size of the output 
we also investigate the complexity of the class cn of planning problems with multivalued state variables and chain causal graphs  in other words  the causal graph is just a
directed path  domshlak and dinitz        showed that there are solvable instances of this
class that require exponentially long plans  however  as it is the case with the class  s 
there could exist an efficient procedure for generating valid plans for cn instances using
   

ficomplexity of planning problems

macros or some other novel idea  we show that plan existence in cn is np hard  hence
ruling out that such an efficient procedure exists  unless p   np 
we also prove that plan existence for planning problems whose causal graph is a polytree  i e   the underlying undirected graph is acyclic  is np complete  even if we restrict to
problems with binary variables  this result closes the complexity gap that appears in brafman and domshlak        regarding planning problems with binary variables  the authors
show that plan existence is np complete for planning problems with singly connected causal
graphs  and that plan generation is polynomial for planning problems with polytree causal
graphs of bounded indegree  we use the same reduction to prove that a similar problem on
polytree cp nets  boutilier  brafman  domshlak  hoos    poole        is np complete 
    related work
several researchers have used the causal graph to devise algorithms for solving planning
problems or to study the complexity of planning problems  knoblock        used the
causal graph to decompose a planning problem into a hierarchy of increasingly abstract
problems  under certain conditions  solving the hierarchy of abstract problems is easier than
solving the original problem  williams and nayak        introduced several restrictions on
planning problems to ensure tractability  one of which is that the causal graph should be
acyclic  jonsson and backstrom        defined the class  s of planning problems  which
also requires the causal graphs to be acyclic  and showed that plan existence is polynomial
for this class 
domshlak and dinitz        analyzed the complexity of several classes of planning
problems with acyclic causal graphs  brafman and domshlak        designed a polynomialtime algorithm for solving planning problems with binary state variables and acyclic causal
graph of bounded indegree  brafman and domshlak        identified conditions under
which it is possible to factorize a planning problem into several subproblems and solve
the subproblems independently  they claimed that a planning problem is suitable for
factorization if its causal graph has bounded tree width 
the idea of using macros in planning is almost as old as planning itself  fikes   nilsson 
       minton        developed an algorithm that measures the utility of plan fragments
and stores them as macros if they are deemed useful  korf        showed that macros can
exponentially reduce the search space size of a planning problem if chosen carefully  vidal
       used relaxed plans generated while computing heuristics to produce macros that
contribute to the solution of planning problems  macro ff  botea  enzenberger  muller 
  schaeffer         an algorithm that identifies and caches macros  competed at the fourth
international planning competition  the authors showed how macros can help reduce the
search effort necessary to generate a valid plan 
jonsson        described an algorithm that uses macros to generate plans for planning
problems with tree reducible causal graphs  there exist planning problems for which the
algorithm can generate exponentially long solutions in polynomial time  just like our algorithm for  s  unlike ours  the algorithm can handle multi valued variables  which enables it
to solve problems such as towers of hanoi  however  not all planning problems in  s have
tree reducible causal graphs  so the algorithm cannot be used to show that plan generation
for  s is polynomial 
   

figimenez   jonsson

    hardness and plan length
a contribution of this paper is to show that plan generation may be polynomial even when
planning problems have exponential length minimal solutions  provided that solutions may
be expressed using a concise notation such as macros  we motivate this result below and
discuss the consequences  previously  it has been thought that plan generation for planning
problems with exponential length minimal solutions is harder than np  since it is not
known whether problems in np are intractable  but it is certain that we cannot generate
exponential length output in polynomial time 
however  for a planning problem with exponential length minimal solution  it is not
clear if plan generation is inherently hard  or if the difficulty just lies in the fact that the
plan is long  consider the two functional problems
f   f     w      f     
f   f     w t f      f     
where f is a   cnf formula   f   is the number of clauses of f   w   k  is a word containing
k copies of the symbol   and t f   is   if f is satisfiable  i e   f is in  sat   and   if it is
not  in both cases  the problem consists in generating the correct word  observe that both
f  and f  are provably intractable  since their output is exponential in the size of the input 
nevertheless  it is intuitive to regard problem f  as easier than problem f    one way
to formalize this intuition is to allow programs to produce the output in some succinct
notation  for instance  if we allow programs to write w  k  instead of a string containing
k copies of the symbol   then problem f  becomes polynomial  but problem f  does not
 unless p   np  
we wanted to investigate the following question  regarding the class  s  is plan generation intractable because solution plans are long  like f    or because the problem is intrinsically hard  like f    the answer is that plan generation for  s can be solved in polynomial
time  provided that one is allowed to give the solution in terms of macros  where a macro
is a simple substitution scheme  a sequence of operators and or other macros  to back up
this claim  we present an algorithm that solves plan generation for  s in polynomial time 
other researchers have argued intractability using the fact that plans may have exponential length  domshlak and dinitz        proved complexity results for several classes of
planning problems with multi valued state variables and simple causal graphs  they argued
that the class cn of planning problems with chain causal graphs is intractable since plans
may have exponential length  brafman and domshlak        stated that plan generation
for strips planning problems with unary operators and acyclic causal graphs is intractable
using the same reasoning  our new result puts in question the argument used to prove the
hardness of these problems  for this reason  we analyze the complexity of these problems
and prove that they are hard by showing that the plan existence problem is np hard 

   notation
let v be a set of state variables  and let d v  be the finite domain of state variable v  v  
we define a state s as a function on v that maps each state variable v  v to a value
s v   d v  in its domain  a partial state p is a function on a subset vp  v of state
   

ficomplexity of planning problems

variables that maps each state variable v  vp to p v   d v   for a subset c  v of
state variables  p   c is the partial state obtained by restricting the domain of p to vp  c 
sometimes we use the notation  v    x            vk   xk   to denote a partial state p defined by
vp    v            vk   and p vi     xi for each vi  vp   we write p v    to denote that v 
  vp  
two partial states p and q match  which we denote pq  if and only if p   vq   q   vp  
i e   for each v  vp vq   p v    q v   we define a replacement operator  such that if q and
r are two partial states  p   q  r is the partial state defined by vp   vq  vr   p v    r v 
for each v  vr   and p v    q v  for each v  vq  vr   note that  in general  p  q    q  p 
a partial state p subsumes a partial state q  which we denote p  q  if and only if pq and
vp  vq   we remark that if p  q and r  s  it follows that p  r  q  s  the difference
between two partial states q and r  which we denote q  r  is the partial state p defined by
vp    v  vq   q v     r v   and p v    q v  for each v  vp  
a planning problem is a tuple p   hv  init  goal  ai  where v is the set of variables 
init is an initial state  goal is a partial goal state  and a is a set of operators  an operator
a   hpre a   post a i  a consists of a partial state pre a  called the pre condition and a
partial state post a  called the post condition  operator a is applicable in any state s such
that spre a   and applying operator a in state s results in the new state s  post a   a
valid plan  for p is a sequence of operators that are sequentially applicable in state init
such that the resulting state s satisfies s goal 
the causal graph of a planning problem p is a directed graph  v  e  with state variables
as nodes  there is an edge  u  v   e if and only if u    v and there exists an operator
a  a such that u  vpre a   vpost a  and v  vpost a   

   the class  s
jonsson and backstrom        introduced the class  s of planning problems to study the
relative complexity of plan existence and plan generation  in this section  we introduce
additional notation needed to describe the class  s and illustrate some of the properties of
 s planning problems  we begin by defining the class  s 
definition     a planning problem p belongs to the class  s if its causal graph is acyclic
and each state variable v  v is binary and either static  symmetrically reversible  or
splitting 
below  we provide formal definitions of static  symmetrically reversible and splitting 
note that the fact that the causal graph is acyclic implies that operators are unary  i e   for
each operator a  a   vpost a         without loss of generality  we assume that  s planning
problems are in normal form  by which we mean the following 
 for each state variable v  d v           and init v      
 post a     v   x   x          implies that pre a  v       x 
to satisfy the first condition  we can relabel the values of d v  in the initial and goal
states as well as in the pre  and post conditions of operators  to satisfy the second condition 
for any operator a with post a     v   x  and pre a  v        x  we either remove it if
   

figimenez   jonsson

v

v 

u
v  
v

v  

w  
w
w  

w

v 

s

u
v  
v

t

 a 

v  

w  
w
w  

w

s

v 

t

v 

w

 b 

figure    causal graph with splitting variable partitions for  a  v   b  w 
pre a  v    x  or we let pre a  v       x if previously undefined  the resulting planning
problem is in normal form and is equivalent to the original one  this process can be done
in time o  a  v    
the following definitions describe the three categories of state variables in  s 
definition     a state variable v  v is static if and only if one of the following holds 
   there does not exist a  a such that post a  v      
   goal v      and there does not exist a  a such that post a  v      
definition     a state variable v  v is reversible if and only if for each a  a such that
post a     v   x   there exists a  a such that post a      v      x   in addition  v is
symmetrically reversible if pre a      v   v     pre a     v   v   
from the above definitions it follows that the value of a static state variable cannot or
must not change  whereas the value of a symmetrically reversible state variable can change
freely  as long as it is possible to satisfy the pre conditions of operators that change its
value  the third category of state variables is splitting  informally  a splitting state variable
v splits the causal graph into three disjoint subgraphs  one which depends on the value
v      one which depends on v      and one which is independent of v  however  the
precise definition is more involved  so we need some additional notation 
for v  v   let qv  be the subset of state variables  different from v  whose value is
changed by some operator that has v     as a pre condition  formally  qv     u  v   v   
a  a s t  pre a  v       u  vpost a     define qv  in the same way for v      let
gv     v  e v   be the subgraph of  v  e  whose edges exclude those between v and qv   qv   
formally  e v   e    v  w    w  qv   w 
  qv     finally  let v v  v be the subset of state
variables that are weakly connected to some state variable of qv  in the graph gv    define
v v in the same way for v     
definition     a state variable v  v is splitting if and only if v v and v v are disjoint 
figure   illustrates the causal graph of a planning problem with two splitting state
variables  v and w  the edge label v     indicates that there are operators for changing
the value of u that have v     as a pre condition  in other words  qv     u  w   the graph
gv     v  e v   excludes the two edges labeled v      and v v includes all state state variables 
   

ficomplexity of planning problems

since v is weakly connected to u and w connects to the remaining state variables  the set
qv  is empty since there are no operators for changing the value of a state variable other
than v with v     as a pre condition  consequently  v v is empty as well  figure   a  shows
the resulting partition for v 
w
w
in the case of w  qw
     s   g     v  e    excludes the edge labeled w      and
w
v     s   since no other state variable is connected to s when the edge w     is removed 
likewise  v w    t   we use vw   v  v w  v w to denote the set of remaining state
variables that belong neither to v w nor to v w   figure   b  shows the resulting partition
for w 
lemma     for any splitting state variable v  if the two sets v v and v v are non empty 
v belongs neither to v v nor to v v  
proof by contradiction  assume that v belongs to v v   then v is weakly connected to
some state variable of qv  in the graph gv     v  e v    but since e v does not exclude edges
between v and qv    any state variable in qv  is weakly connected to the same state variable of
qv  in gv    consequently  state variables in qv  belong to both v v and v v   which contradicts
that v is splitting  the same reasoning holds to show that v does not belong to v v  
lemma     the value of a splitting state variable never needs to change more than twice
on a valid plan 
proof assume  is a valid plan that changes the value of a splitting state variable v at
least three times  we show that we can reorder the operators of  in such a way that the
value of v does not need to change more than twice  we need to address three cases  v
belongs to v v  cf  figure   a    v belongs to v v   or v belongs to vv  cf  figure   b   
if v belongs to v v   it follows from lemma     that v v is empty  consequently  no
operator in the plan requires v     as a pre condition  thus  we can safely remove all
operators in  that change the value of v  except possibly the last  which is needed in case
goal v       if v belongs to v v   it follows from lemma     that v v is empty  thus  no
operator in the plan requires v     as a pre condition  the first operator in  that changes
the value of v is necessary to set v to    after that  we can safely remove all operators in 
that change the value of v  except the last in case goal v       in both cases the resulting
plan contains at most two operators changing the value of v 
if v belongs to vv   then the only edges between v v   v v   and vv are those from v  vv
to qv   v v and qv   v v   let         and  be the subsequences of operators in  that
affect state variables in v v   v v   and vv   respectively  write    h   av     i  where av  is
the last operator in  that changes the value of v from   to    we claim that the reordering
h       av         i of plan  is still valid  indeed  the operators of   only require v     
which holds in the initial state  and the operators of   only require v      which holds
due to the operator av    note that all operators changing the value of v in  can be safely
removed since the value v     is never needed as a pre condition to change the value of a
state variable in vv   the result is a valid plan that changes the value of v at most twice
 its value may be reset to   by    

   

figimenez   jonsson

variable
v 
v 
v 
v 
v 
v 
v 
v 

operators
av     h v         v      i
av     h v         v      i
av     h v       v         v      i
av     h v       v       v         v      i
av  
av  
av  
av  
av  

  h v 
  h v 
  h v 
  h v 
  h v 

     v 
     v 
     v 
     v 
     v 

     v         v      i
       v      i
       v      i
       v      i
     v         v      i

v vi
v

v vi
v


 v    v   
v   v   

v

v
 v    v    v   


v




v


table    operators and the sets v vi and v vi for the example planning problem 

v 
v 

v 
v 

v 
v 

v 

v 

figure    causal graph of the example planning problem 
the previous lemma  which holds for splitting state variables in general  provides some
additional insight into how to solve a planning problem with a splitting state variable v 
first  try to achieve the goal state for state variables in v v while the value of v is    as in
the initial state  then  set the value of v to   and try to achieve the goal state for state
variables in v v   finally  if goal v       reset the value of v to   
    example
we illustrate the class  s using an example planning problem  the set of state variables
is v    v            v     since the planning problem is in normal form  the initial state is
init vi       for each vi  v   the goal state is defined by goal    v       v        and
the operators in a are listed in table    figure   shows the causal graph  v  e  of the
planning problem  from the operators it is easy to verify that v  is static and that v 
and v  are symmetrically reversible  for the planning problem to be in  s  the remaining
state variables have to be splitting  table   lists the two sets v vi and v vi for each state
variable vi  v to show that indeed  v vi  v vi    for each of the state variables in the set
 v    v    v    v    v    
   

ficomplexity of planning problems

   plan generation for  s
in this section  we present a polynomial time algorithm for plan generation in  s  the
algorithm produces a solution to any instance of  s in the form of a system of macros  the
idea is to construct unary macros that each change the value of a single state variable  the
macros may change the values of other state variables during execution  but always reset
them before terminating  once the macros have been generated  the goal can be achieved
one state variable at a time  we show that the algorithm generates a valid plan if and only
if one exists 
we begin by defining macros as we use them in the paper  next  we describe the
algorithm in pseudo code  figures       and    and prove its correctness  to facilitate
reading we have moved a straightforward but involving proof to the appendix  following
the description of the algorithm we analyze the complexity of all steps involved  in what
follows  we assume that  s planning problems are in normal form as defined in the previous
section 
    macros
a macro operator  or macro for short  is an ordered sequence of operators viewed as a unit 
each operator in the sequence has to respect the pre conditions of operators that follow
it  so that no pre condition of any operator in the sequence is violated  applying a macro
is equivalent to applying all operators in the sequence in the given order  semantically 
a macro is equivalent to a standard operator in that it has a pre condition and a postcondition  unambiguously induced by the pre  and post conditions of the operators in its
sequence 
since macros are functionally operators  the operator sequence associated with a macro
can include other macros  as long as this does not create a circular definition  consequently 
it is possible to create hierarchies of macros in which the operator sequences of macros on
one level include macros on the level below  the solution to a planning problem can itself
be viewed as a macro which sits at the top of the hierarchy 
to define macros we first introduce the concept of induced pre  and post conditions of
operator sequences  if    ha            ak i is an operator sequence  we write i      i  k  to
denote the subsequence ha            ai i 
definition     an operator sequence    ha            ak i induces a pre condition pre    
pre ak    pre a    and a post condition post     post a     post ak    in addition 
the operator sequence is well defined if and only if  pre i   post i    pre ai   for each
    i  k 
in what follows  we assume that p    v  init  goal  a  is a planning problem such that
vpost a   vpre a  for each operator a  a  and that    ha            ak i is an operator sequence 
lemma     for each planning problem p of this type and each   vpost    vpre    
proof a direct consequence of the definitions vpre     vpre a      vpre ak   and vpost    
vpost a         vpost ak    
   

figimenez   jonsson

lemma     the operator sequence  is applicable in state s if and only if  is well defined
and spre    the state sk resulting from the application of  to s is sk   s  post   
proof by induction on k  the result clearly holds for k      for k      note that
pre     pre ak    pre k     post     post k     post ak    and  is well defined if
and only if k  is well defined and  pre k     post k    pre ak   
by hypothesis of induction the state sk  resulting from the application of k  to s is
sk    s  post k     it follows that sk   sk   post ak     s  post   
assume  is applicable in state s  this means that k  is applicable in s and that ak
is applicable in sk    s  post k     by hypothesis of induction  the former implies that
spre k    and k  is well defined  and the latter that  s  post k    pre ak    this
last condition implies that  pre k     post k    pre ak   if we use that pre k     s 
which is a consequence of spre k    and s being a total state  finally  we deduce
s pre ak    pre k     from spre k    and  s  post k    pre ak    by using that
vpost k     vpre k      it follows that  is well defined and that spre   
conversely  assume that  is well defined and spre    this implies that k  is
well defined and spre k     so by hypothesis of induction  k  is applicable in state s 
it remains to show that ak is applicable in state sk    that is   s  post k    pre ak   
from  pre k     post k    pre ak   it follows that post k   pre ak    the fact that
s pre ak    pre k     and vpost k     vpre k    completes the proof 
since macros have induced pre  and post conditions  lemmas     and     trivially extend
to the case for which the operator sequence  includes macros  now we are ready to
introduce our definition of macros 
definition     a macro m is a sequence    ha            ak i of operators and other macros
that induces a pre condition pre m    pre   and a post condition post m    post   
pre    the macro is well defined if and only if no circular definitions occur and  is
well defined 
to make macros consistent with standard operators  the induced post condition should
only include state variables whose values are indeed changed by the macro  which is achieved
by computing the difference between post   and pre    in particular  it holds that for a
 s planning problem in normal form  derived macros satisfy the second condition of normal
form  namely that post m     v   x   x          implies pre m  v       x 
definition     let ancv be the set of ancestors of a state variable v in a  s planning
problem  we define the partial state prev on vprev   ancv as
   prev  u      if u  ancv is splitting and v  v u  
   prev  u      otherwise 
definition     a macro m is a  s macro if it is well defined and  for x          post m   
 v   x  and pre m   prev   v      x  
   

ficomplexity of planning problems

macro
mv  
mv  
mv  
mv  
mv  
mv  
mv  
mv  
mv  

sequence

pre condition

hav   i
hav   i
hmv     av     mv   i
hav   i
hav   i
hav   i
hav   i
hmv     av     mv   i
hav   i

 v 
 v 
 v 
 v 
 v 
 v 
 v 
 v 
 v 

    
    
     v 
     v 
     v 
     v 
     v 
     v 
     v 

    
     v 
     v 
    
    
     v 
     v 

post condition

    
    

    
     v      

 v 
 v 
 v 
 v 
 v 
 v 
 v 
 v 
 v 

    
    
    
    
    
    
    
    
    

table    macros generated by the algorithm in the example planning problem 

the algorithm we present only generates  s macros  in fact  it generates at most one
macro m   mvx with post m     v   x  for each state variable v and value x          to
illustrate the idea of  s macros and give a flavor of the algorithm  table   lists the macros
generated by the algorithm in the example  s planning problem from the previous section 
we claim that each macro is a  s macro  for example  the operator sequence hav   i
induces a pre condition  v       v       and a post condition  v       v         v        
 v       v        thus  the macro mv   induces a pre condition pre mv        v       v      
and a post condition post mv        v       v         v       v          v        since v 
and v  are splitting and since v   v v  and v   v v    it follows that prev    v        
 v       v       v       v        so pre mv        v       v        prev    v       
the macros can be combined to produce a solution to the planning problem  the idea
is to identify each state variable v such that goal v      and append the macro mv  to the
solution plan  in the example  this results in the operator sequence hmv     mv   i  however 
the pre condition of mv   specifies v      and v       which makes it necessary to insert mv  
and mv   before mv     in addition  the pre condition of mv   specifies v       which makes
it necessary to insert mv   before mv     resulting in the final plan hmv     mv     mv     mv     mv   i 
note that the order of the macros matter  mv   requires v  to be   while mv   requires
v  to be    for a splitting state variable v  the goal state should be achieved for state
variables in v v before the value of v is set to    we can expand the solution plan so that
it consists solely of operators in a  in our example  this results in the operator sequence
hav     av     av     av     av     av     av     av     av   i  in this case  the algorithm generates an optimal
plan  although this is not true in general 
    description of the algorithm
we proceed by providing a detailed description of the algorithm for plan generation in  s 
we first describe the subroutine for generating a unary macro that sets the value of a state
variable v to x  this algorithm  which we call generatemacro  is described in figure   
the algorithm takes as input a planning problem p   a state variable v  a value x  either  
   

figimenez   jonsson

 
 
 
 
 
 
 
 
 
  
  
  
  
  

function generatemacro p   v  x  m  
for each a  a such that post a  v    x do
s   s   hi
satisf y  true
u   u  vpre a    v    pre a  u      
for each u  u in increasing topological order do
if u is static or mu  
  m then
satisf y  false
else if u is not splitting and mu   m and mu   m then
s   hs    mu  i
s   hmu    s  i
if satisf y then
return hs    a  s  i
return f ail
figure    algorithm for generating a macro that sets the value of v to x 

or     and a set of macros m for vs ancestors in the causal graph  prior to executing the
algorithm  we perform a topological sort of the state variables  we assume that  for each
v  v and x          m contains at most one macro mvx such that post mvx      v   x   in
the algorithm  we use the notation mvx  m to test whether or not m contains mvx  
for each operator a  a that sets the value of v to x  the algorithm determines whether
it is possible to satisfy its pre condition pre a  starting from the initial state  to do this  the
algorithm finds the set u of state variables to which pre a  assigns    the values of all other
state variables already satisfy pre a  in the initial state   the algorithm constructs two
sequences of operators  s  and s    by going through the state variables of u in increasing
topological order  if s is an operator sequence  we use hs  oi as shorthand to denote an
operator sequence of length  s      consisting of all operators of s followed by o  which can
be either an operator or a macro  if it is possible to satisfy the pre condition pre a  of some
operator a  a  the algorithm returns the macro hs    a  s  i  otherwise  it returns f ail 
lemma     if v is symmetrically reversible and generatemacro p   v     m   successfully generates a macro  so does generatemacro p   v     m   
proof assume that generatemacro p   v     m   successfully returns the macro hs    a  s  i
for some operator a  a such that post a       from the definition of symmetrically
reversible it follows that there exists an operator a  a such that post a       and
pre a     v   v    pre a    v   v   thus  the set u is identical for a and a   as
a consequence  the values of s    s    and satisf y are the same after the loop  which
means that generatemacro p   v     m   returns the macro hs    a   s  i for a   note
that generatemacro p   v     m   may return another macro if it goes through the operators of a in a different order  however  it is guaranteed to successfully return a macro 
theorem     if the macros in m are  s macros and generatemacro p   v  x  m  
generates a macro mvx    f ail  then mvx is a  s macro 
   

ficomplexity of planning problems

 
 
 
 
 
 
 
 
 
  

function macro  s p  
m 
for each v  v in increasing topological order do
mv   generatemacro p   v     m  
mv   generatemacro p   v     m  
if mv     f ail and mv     f ail then
m  m   mv    mv   
else if mv     f ail and goal v       then
m  m   mv   
return generateplan p   v   m  
figure    the algorithm macro  s 
the proof of theorem     appears in appendix a 

next  we describe the algorithm for plan generation in  s  which we call macro  s 
figure   shows pseudocode for macro  s  the algorithm goes through the state variables
in increasing topological order and attempts to generate two macros for each state variable
v  mv  and mv    if both macros are successfully generated  they are added to the current
set of macros m   if only mv  is generated and the goal state does not assign   to v  the
algorithm adds mv  to m   finally  the algorithm generates a plan using the subroutine
generateplan  which we describe later 
lemma     let p be a  s planning problem and let v  v be a state variable  if there
exists a valid plan for solving p that sets v to    macro  s p   adds the macro mv  to m  
if  in addition  the plan resets v to    macro  s p   adds mv  to m  
proof first note that if mv  and mv  are generated  macro  s p   adds them both to m  
if mv  is generated but not mv    macro  s p   adds mv  to m unless goal v       however 
goal v      contradicts the fact that there is a valid plan for solving p that sets v to  
without resetting it to    it remains to show that generatemacro p   v     m   always
generates mv     f ail and that generatemacro p   v     m   always generates mv     f ail
if the plan resets v to   
a plan for solving p that sets v to   has to contain an operator a  a such that
post a  v       if the plan also resets v to    it has to contain an operator a  a such
that post a   v       we show that generatemacro p   v     m   successfully generates
mv     f ail if a is the operator selected on line    note that the algorithm may return another
macro if it selects another operator before a  however  if it always generates a macro for a 
it is guaranteed to successfully return a macro mv     f ail  the same is true for mv  and a  
we prove the lemma by induction on state variables v  if v has no ancestors in the
causal graph  the set u is empty by default  thus  satisf y is never set to false and
generatemacro p   v     m   successfully returns the macro mv    hai for a  if a exists 
generatemacro p   v     m   successfully returns mv    ha i for a  
if v has ancestors in the causal graph  let u    u  vpre a    v    pre a  u       
since the plan contains a it has to set each u  u to    by hypothesis of induction 
macro  s p   adds mu  to m for each u  u   as a consequence  satisf y is never set to
   

figimenez   jonsson

 
 
 
 
 
 
 
 
 
  
  
  
  
  
  
  
  

function generateplan p   w   m  
if  w       then
return hi
v  first variable in topological order present in w
if v is splitting then
v   generate plan p   w   v v   v    m  
v   generate plan p   w   v v   v    m  
v  generate plan p   w   v  v v  v v   v    m  
if v    f ail or v    f ail or v   f ail or  goal v      and mv  
  m   then
return f ail
else if mv  
  m then return hv   v    v  i
else if goal v      then return hv   v    mv    v    mv  i
else return hv   v    mv    v  i
  generate plan p   w   v   m  
if    f ail or  goal v      and mv  
  m   then return f ail
else if goal v      then return h  mv  i
else return 
figure    algorithm for generating the final plan

false and thus  generatemacro p   v     m   successfully returns mv  for a  if a exists 
let w    w  vpre a     v    pre a   w        if the plan contains a   it has to set each
w  w to    by hypothesis of induction  macro  s p   adds mw
  to m for each w  w
and consequently  generatemacro p   v     m   successfully returns mv  for a  
finally  we describe the subroutine generateplan p   w   m   for generating the final
plan given a planning problem p   a set of state variables w and a set of macros m   if
the set of state variables is empty  generateplan p   w   m   returns an empty operator
sequence  otherwise  it finds the state variable v  w that comes first in topological order 
if v is splitting  the algorithm separates w into the three sets described by v v   v v   and
vv   v  v v  v v   the algorithm recursively generates plans for the three sets and if
necessary  inserts mv  between v v and v v in the final plan  if this is not the case  the
algorithm recursively generates a plan for w   v   if goal v      and mv    the algorithm
appends mv  to the end of the resulting plan 
lemma      let w be the plan generated by generateplan p   w   m    let v be the
first state variable in topological order present in w   and let v   ha   w   b i be the final
plan generated by macro  s p    if mv   m it follows that  pre a  post a   pre mv    
proof we determine the content of the operator sequence a that precedes w in the final
plan by inspection  note that the call generateplan p   w   m   has to be nested within
a sequence of recursive calls to generateplan starting with generateplan p   v   m   
let z be the set of state variables such that each u  z was the first state variable in
topological order for some call to generateplan prior to generateplan p   w   m   
each u  z has to correspond to a call to generateplan with some set of state variables
u such that w  u   if u is not splitting  u does not contribute to a since the only
   

ficomplexity of planning problems

possible addition of a macro to the plan on line    places the macro mu  at the end of the
plan generated recursively 
assume that u  z is a splitting state variable  we have three cases  w  v u   w  v u  
and w  vu   v  v u  v u   if w  vu   u does not contribute to a since it never places
macros before u   if w  v u   the plan u is part of a since it precedes u  on lines    
    and     if w  v u   the plans u and u  are part of a since they both precede u  in
all cases  if mu   m   the macro mu  is also part of a since it precedes u  on lines    and
    no other macros are part of a  
since the macros in m are unary  the plan generated by generateplan p   u   m  
only changes the values of state variables in u   for a splitting state variable u  there are
no edges from vu   u  to v u   from vu   u  to v u   or from v u to v u   it follows that the
plan u does not change the value of any state variable that appears in the pre condition
of a macro in u    the same holds for u with respect to u  and for u  with respect to u   
thus  the only macro in a that changes the value of a splitting state variable u  ancv is
mu  in case w  v u  
recall that prev is defined on ancv and assigns   to u if and only if u is splitting and
v  v u   for all other ancestors of v  the value   holds in the initial state and is not
altered by a   if u is splitting and v  v u   it follows from the definition of  s macros that
pre mv    u      or pre mv    u     if pre mv    u       it is correct to append mu  before
mv  to satisfy pre mv    u   if mu  
  m it follows that u 
  vpre mv      since pre mv    u     
would have caused generatemacro p   v     m   to set satisf y to false on line    thus 
the pre condition pre mv    of mv  agrees with pre a    post a   on the value of each state
variable  which means that the two partial states match 
lemma      generateplan p   v   m   generates a well defined plan 
proof note that for each state variable v  v   generateplan p   w   m   is called
precisely once such that v is the first state variable in topological order  from lemma     
it follows that  pre a    post a   pre mv     where a is the plan that precedes w in
the final plan  since v is the first state variable in topological order in w   the plans v   
v    v   and   recursively generated by generateplan  do not change the value of any
state variable in pre mv     it follows that mv  is applicable following ha   v   v  i or ha   i 
since mv  only changes the value of v  mv  is applicable following ha   v   v    mv    v  i 
theorem      macro  s p   generates a valid plan for solving a planning problem in  s
if and only if one exists 
proof generateplan p   v   m   returns f ail if and only if there exists a state variable
v  v such that goal v      and mv  
  m   from lemma     it follows that there does
not exist a valid plan for solving p that sets v to    consequently  there does not exist a
plan for solving p   otherwise  generateplan p   v   m   returns a well defined plan due
to lemma       since the plan sets to   each state variable v such that goal v      and
resets to   each state variable v such that goal v       the plan is a valid plan for solving
the planning problem 
   

figimenez   jonsson

v 

v 

v 

v 

v 

figure    causal graph of the planning problem p   
    examples
we illustrate the algorithm on an example introduced by jonsson and backstrom        to
show that there are instances of  s with exponentially sized minimal solutions  let pn  
hv  init  goal  ai be a planning problem defined by a natural number n  v    v            vn   
and a goal state defined by vgoal   v   goal vi       for each vi   v            vn     and
goal vn        for each state variable vi  v   there are two operators in a 
av i   h v               vi       vi       vi        vi     i 
av i   h v               vi       vi       vi        vi     i 
in other words  each state variable is symmetrically reversible  the causal graph of the planning problem p  is shown in figure    note that for each state variable vi   v            vn    
v
v
pre a i     vi       and pre a i     vi        so vi    qv i and vi    q vi   since there is
an edge in the causal graph between vi   and vi     no state variable in  v            vn    is
v
splitting  on the other hand  vn  and vn are splitting since v  n     and v vn   v vn    
backstrom and nebel        showed that the length of the shortest plan solving pn is  n   
i e   exponential in the number of state variables 
for each state variable vi   v            vn     our algorithm generates two macros mv i and
vi
m    there is a single operator  av i   that changes the value of vi from   to    pre av i  
only assigns   to vi    so u    vi     since vi  is not splitting  mv i is defined as mv i  
v
v
v
v
hm i    av i   m i  i  similarly  mv i is defined as mv i   hm i    av i   m i  i  for state variable
vn   u    vn     which is splitting  so mv n is defined as mv n   hav n i 
to generate the final plan  the algorithm goes through the state variables in topological order  for state variables v  through vn    the algorithm does nothing  since these
state variables are not splitting and their goal state is not    for state variable vn   
the algorithm recursively generates the plan for vn   which is hmv n i since goal vn       
v
since goal vn         the algorithm inserts m n  before mv n to satisfy its pre condition
v
vn      and m n  after mv n to achieve the goal state goal vn         thus  the final plan
vn 
v
vn
is hm    m    m n  i  if we expand the plan  we end up with a sequence of  n    operators  however  no individual macro has operator sequence length greater than    together 
the macros recursively specify a complete solution to the planning problem 
we also demonstrate that there are planning problems in  s with polynomial length
solutions for which our algorithm may generate exponential length solutions  to do this 
we modify the planning problem pn by letting goal vi       for each vi  v   in addition 
for each state variable vi  v   we add two operators to a 
bv i   h v               vi       vi        vi     i 
bv i   h v               vi       vi        vi     i 
   

ficomplexity of planning problems

we also add an operator cv n   h vn       vn        vn     i to a  as a consequence  state variables in  v            vn    are still symmetrically reversible but not splitting 
vn  is also symmetrically reversible but no longer splitting  since pre av n   vn        and
v
v
pre cv n   vn        implies that vn  v  n  v  n    vn is still splitting since v vn   v vn    
assume that generatemacro p   vi   x  m   always selects bvxi first  as a consequence  for
each state variable vi  v and each x          generatemacro p   vi   x  m   generates
v
v
the macro mvxi   hm i            mv     bvxi   mv             m i  i 
let li be the length of the plan represented by mvxi   x          from the definition of
v
i
mx above we have that li     l            li         we show by induction that li    i   
the length of any macro for v  is l             for i     
li                   i           

 i    
 i    
    
       i            i   
  
 

to generate the final plan the algorithm has to change the value of each state variable
from   to    so the total length of the plan is l   l            ln                 n   
  n        however  there exists a plan of length n that solves the planning problem 
namely hbv             bv n i 
    complexity
in this section we prove that the complexity of our algorithm is polynomial  to do this
we analyze each step of the algorithm separately  a summary of the complexity result for
each step of the algorithm is given below  note that the number of edges  e  in the causal
graph is o  a  v     since each operator may introduce o  v    edges  the complexity result
o  v      e     o  a  v    for topological sort follows from cormen  leiserson  rivest  and
stein        
constructing the causal graph g    v  e 
calculating v v and v v for each v  v
performing a topological sort of g
generatemacro p   v  x  m  
generateplan p   v   m  
macro  s p  

o  a  v   
o  a  v     
o  a  v   
o  a  v   
o  v     
o  a  v     

lemma     
lemma     
lemma     
lemma     
theorem     

lemma      the complexity of constructing the causal graph g    v  e  is o  a  v    
proof the causal graph consists of  v   nodes  for each operator a  a and each state
variable u  vpre a    we should add an edge from u to the unique state variable v  vpost a   
in the worst case   vpre a      o  v     in which case the complexity is o  a  v    
lemma      the complexity of calculating the sets v v and v v for each state variable
v  v is o  a  v      
proof for each state variable v  v   we have to establish the sets qv  and qv    which requires
going through each operator a  a in the worst case  note that we are only interested in
the pre condition on v and the unique state variable in vpost a    which means that we do not
   

figimenez   jonsson

need to go through each state variable in vpre a    next  we have to construct the graph gv   
we can do this by copying the causal graph g  which takes time o  a  v     and removing
the edges between v and qv   qv    which takes time o  v    
finally  to construct the set v v we should find each state variable that is weakly connected to some state variable u  qv  in the graph gv    for each state variable u  qv   
performing an undirected search starting at u takes time o  a  v     once we have performed search starting at u  we only need to search from state variables in qv  that were
not reached during the search  this way  the total complexity of the search does not exceed
o  a  v     the case for constructing v v is identical  since we have to perform the same
procedure for each state variable v  v   the total complexity of this step is o  a  v      
lemma      the complexity of generatemacro p   v  x  m   is o  a  v    
proof for each operator a  a  generatemacro p   v  x  m   needs to check whether
post a  v    x  in the worst case   u     o  v     in which case the complexity of the
algorithm is o  a  v    
lemma      the complexity of generateplan p   v   m   is o  v      
proof note that for each state variable v  v   generateplan p   v   m   is called recursively exactly once such that v is the first variable in topological order  in other words 
generateplan p   v   m   is called exactly  v   times  generateplan p   v   m   contains
only constant operations except the intersection and difference between sets on lines     
since intersection and set difference can be done in time o  v     the total complexity of
generateplan p   v   m   is o  v      
theorem      the complexity of macro  s p   is o  a  v      
proof prior to executing macro  s p    it is necessary to construct the causal graph g 
find the sets v v and v v for each state variable v  v   and perform a topological sort
of g  we have shown that these steps take time o  a  v       for each state variable
v  v   macro  s p   calls generatemacro p   v  x  m   twice  from lemma      it
follows that this step takes time o   v   a  v      o  a  v       finally  macro  s p   calls
generateplan p   v   m    which takes time o  v      due to lemma       it follows that
the complexity of macro  s p   is o  a  v      
we conjecture that it is possible to improve the above complexity result for macro s p   to o  a  v     however  the proof seems somewhat complex  and our main objective
is not to devise an algorithm that is as efficient as possible  rather  we are interested in
establishing that our algorithm is polynomial  which follows from theorem      
    plan length
in this section we study the length of the plans generated by the given algorithm  to begin
with  we derive a general bound on the length of such plans  then  we show how to compute
the actual length of some particular plan without expanding its macros  we also present
an algorithm that uses this computation to efficiently obtain the i th action of the plan
   

ficomplexity of planning problems

from its macro form  we start by introducing the concept of depth of state variables in the
causal graph 
definition      the depth d v  of a state variable v is the longest path from v to any
other state variable in the causal graph 
since the causal graph is acyclic for planning problems in  s  the depth of each state variable
is unique and can be computed in polynomial time  also  it follows that at least one state
variable has depth    i e   no outgoing edges 
definition      the depth d of a planning problem p in  s equals the largest depth of
any state variable v of p   i e   d   maxvv d v  
we characterize a planning problem based on the depth of each of its state variables  let
n    v   be the number of state variables  and let ci denote the number of state variables
with depth i  if the planning problem has depth d  it follows that c            cd   n  as an
example  consider the planning problem whose causal graph appears in figure    for this
planning problem  n      d      c       c       c       c       c       and c      
lemma      consider the values li for i              d  defined by ld      and li  
  ci   li     ci   li             cd ld       when i   d  the values li are an upper bound on
the length of macros generated by our algorithm for a state variable v with depth i 
proof we prove it by a decreasing induction on the value of i  assume v has depth i   d 
it follows from definition      that v has no incoming edges  thus  an operator changing
the value of v has no pre condition on any state variable other than v  so ld     is an upper
bound  as stated 
now  assume v has depth i   d  and that all li k for k     are upper bounds on the
length of the corresponding macros  let a  a be an operator that changes the value of v 
from the definition of depth it follows that a cannot have a pre condition on a state variable
u with depth j  i  otherwise there would be an edge from u to v in the causal graph  causing
the depth of u to be greater than i  thus  in the worst case  a macro for v has to change
the values of all state variables with depths larger than i  change the value of v  and reset
the values of state variables at lower levels  it follows that li     ci   li             cd ld      
is an upper bound 
theorem      the upper bounds li of lemma      satisfy li   dj i         cj   
proof note that
li     ci   li     ci   li             cd ld        
   ci   li       ci   li             cd ld        
   ci   li     li       ci       li    
the result easily follows by induction 
   

figimenez   jonsson

now we can obtain an upper bound l on the total length of the plan  in the worst
case  the goal state assigns a different value to each state variable than the initial state 
i e   goal v     init v  for each v  v   to achieve the goal state the algorithm applies one
macro per state variable  hence
l   c  l    c  l            cd ld   c  l   

d
l    
      c   l    
 y
 
 
 
      cj     
 
 
 
 
j  

the previous bound depends on the distribution of the variables on depths according
to the causal graph  to obtain a general bound that does not depend on the depths of the
variables we first find which distribution maximizes the upper bound l 
q
lemma      the upper bound l      dj       cj      on planning problems on n variables
and depth d is maximized when all ci are equal  that is  ci   n  d      
proof note that ci     for all i  and that c         cd   n  the result follows from a direct
application of the well known am gm  arithmetic mean geometric mean  inequality  which
states that the arithmetic mean of positive values xi is greater or equal than its geometric
mean  with equality only when all xi are the same 
this implies that the product of positive
p
factors xi         ci   with fixed sum a   dj   xj    n   d is maximized when all are
equal  that is  ci   n  d      
theorem      the length of a plan generated by the algorithm for a planning problem in
 s with n state variables and depth d is at most        n  d      d         
proof this is a direct consequence of lemma       since c            cd are discrete  it may not
be possible to set c            cd   n  d       nevertheless         n  d      d         is an
upper bound on l in this case 
observe that the bound established in theorem      is an increasing function of d  this
implies that for a given d  the bound also applies to planning problems in  s with depth
smaller than d  as a consequence  if the depth of a planning problem in  s is bounded
from above by d  our algorithm generates a solution plan for the planning problem with
polynomial length o nd      since the complexity of executing a plan is proportional to
the plan length  we can use the depth d to define tractable complexity classes of planning
problems in  s with respect to plan execution 
theorem      the length of a plan generated by the algorithm for a planning problem in
 s with n state variables is at most   n       
proof in the worst case  the depth d of a planning problem is n   it follows from theorem
     that the length of a plan is at most        n n n           n       
note that the bound established in theorem      is tight  in the second example in section
     we showed that our algorithm generates a plan whose length is   n       
   

ficomplexity of planning problems

 
 
 
 
 
 
 
 
 

function operator s  i 
o  first operator in s
while length o    i do
i  i  length o 
o  next operator in s
if primitive o  then
return o
else
return operator o  i 
figure    an algorithm for determining the i th operator in a sequence

lemma      the complexity of computing the total length of any plan generated by our
algorithm is o  v      
proof the algorithm generates at most   v     o  v    macros    for each state variable  the
operator sequence of each macro consists of one operator and at most    v         o  v   
other macros  we can use dynamic programming to avoid computing the length of a macro
more than once  in the worst case  we have to compute the length of o  v    macros  each
of which is a sum of o  v    terms  resulting in a total complexity of o  v      
lemma      given a solution plan of length l and an integer    i  l  the complexity of
determining the i th operator of the plan is o  v      
proof we prove the lemma by providing an algorithm for determining the i th operator 
which appears in figure    since operator sequences s consist of operators and macros 
the variable o represents either an operator in a or a macro generated by macro  s  the
function primitive o  returns true if o is an operator and f alse if o is a macro  the function
length o  returns the length of o if o is a macro  and   otherwise  we assume that the length
of macros have been pre computed  which we know from lemma      takes time o  v      
the algorithm simply finds the operator or macro at the i th position of the sequence 
taking into account the length of macros in the sequence  if the i th position is part of
a macro  the algorithm recursively finds the operator at the appropriate position in the
operator sequence represented by the macro  in the worst case  the algorithm has to go
through o  v    operators in the sequence s and call operator recursively o  v    times 
resulting in a total complexity of o  v      
    discussion
the general view of plan generation is that an output should consist in a valid sequence of
grounded operators that solves a planning problem  in contrast  our algorithm generates a
solution plan in the form of a system of macros  one might argue that to truly solve the
plan generation problem  our algorithm should expand the system of macros to arrive at the
sequence of underlying operators  in this case  the algorithm would no longer be polynomial 
since the solution plan of a planning problem in  s may have exponential length  in fact  if
the only objective is to execute the solution plan once  our algorithm offers only marginal
benefit over the incremental algorithm proposed by jonsson and backstrom        
   

figimenez   jonsson

on the other hand  there are several reasons to view the system of macros generated by
our algorithm as a complete solution to a planning problem in  s  the macros collectively
specify all the steps necessary to reach the goal  the solution plan can be generated and
verified in polynomial time  and the plan can be stored and reused using polynomial memory 
it is even possible to compute the length of the resulting plan and determine the i th
operator of the plan in polynomial time as shown in lemmas      and       thus  for all
practical purposes the system of macros represents a complete solution  even if the only
objective is to execute the solution plan once  our algorithm should be faster than that of
jonsson and backstrom         all that is necessary to execute a plan generated by our
algorithm is to maintain a stack of currently executing macros and select the next operator
to execute  whereas the algorithm of jonsson and backstrom has to perform several steps
for each operator output 
jonsson and backstrom        proved that the bounded plan existence problem for  s
is np hard  the bounded plan existence problem is the problem of determining whether or
not there exists a valid solution plan of length at most k  as a consequence  the optimal
plan generation problem for  s is np hard as well  otherwise  it would be possible to
solve the bounded plan existence problem by generating an optimal plan and comparing
the length of the resulting plan to k  in our examples we have seen that our algorithm
does not generate an optimal plan in general  in fact  our algorithm is just as bad as the
incremental algorithm of jonsson and backstrom  in the sense that both algorithms may
generate exponential length plans even though there exists a solution of polynomial length 
since our algorithm makes it possible to compute the total length of a valid solution
in polynomial time  it can be used to generate heuristics for other planners  specifically 
katz and domshlak        proposed projecting planning problems onto provably tractable
fragments and use the solution to these fragments as heuristics for the original problem  we
have shown that  s is such a tractable fragment  unfortunately  because optimal planning
for  s is np hard  there is no hope of generating an admissible heuristic  however  the
heuristic may still be informative in guiding the search towards a solution of the original
problem  in addition  for planning problems with exponential length optimal solutions  a
standard planner has no hope of generating a heuristic in polynomial time  making our
macro based approach  and that of jonsson        the only  current  viable option 

   the class cn
domshlak and dinitz        defined the class cn of planning problems with multi valued
state variables and chain causal graphs  since chain causal graphs are acyclic  it follows that
operators are unary  moreover  let vi be the i th state variable in the chain  if i      for
each operator a such that vpost a    vi   it holds that vpre a     vi    vi    in other words 
each operator that changes the value of a state variable vi may only have pre conditions on
vi  and vi  
the authors showed that there are instances of cn with exponentially sized minimal
solutions  and therefore argued that the class is intractable  in light of the previous section 
this argument on the length of the solutions does not discard the possibility that instances
of the class can be solved in polynomial time using macros  we show that this is not the
case  unless p   np 
   

ficomplexity of planning problems

v 

vk

w

figure    causal graph of p  f   
c 

c   c 

   
cn cn
cn

c 

   
 

s

s

   

s

 

c   c 
   

cn cn

cn

figure    domain transition graph for vi  
we define the decision problem plan existence cn as follows  a valid input of planexistence cn is a planning instance p of cn   the input p belongs to plan existencecn if and only if p is solvable  we show in this section that the problem plan existencecn is np hard  this implies that  unless p   np  solving instances of cn is a truly
intractable problem  namely  no polynomial time algorithm can distinguish between solvable
and unsolvable instances of cn   in particular  no polynomial time algorithm can solve cn
instances by using macros or any other kind of output format  
we prove that plan existence cn is np hard by a reduction from cnf sat  that is 
the problem of determining whether a cnf formula f is satisfiable  let c            cn be the
clauses of the cnf formula f   and let v            vk be the variables that appear in f   we
briefly describe the intuition behind the reduction  the planning problem we create from
the formula f has a state variable for each variable appearing in f   and plans are forced
to commit a value  either   or    to these state variables before actually using them  then 
to satisfy the goal of the problem  these variables are used to pass messages  however  the
operators for doing this are defined in such a way that a plan can only succeed when the
state variable values it has committed to are a satisfying assignment of f  
we proceed to describe the reduction  first  we define a planning problem p  f    
hv  init  goal  ai as follows  the set of state variables is v    v            vk   w   where d vi    
 s        c    c            cn   cn   for each vi and d w     s             n   the initial state defines
init v    s for each v  v and the goal state defines goal w    n  figure   shows the
causal graph of p  f   
the domain transition graph for each state variable vi is shown in figure    each node
represents a value in d vi    and an edge from x to y means that there exists an operator
a such that pre a  vi     x and post a  vi     y  edge labels represent the pre condition of
such operators on state variable vi    and multiple labels indicate that several operators
are associated with an edge  we enumerate the operators acting on vi using the notation
a   hpre a   post a i  when i     any mention of vi  is understood to be void  
   a valid output format is one that enables efficient distinction between an output representing a valid
plan and an output representing the fact that no solution was found 

   

figimenez   jonsson

s

c   c 

n 

 

cn cn

n

figure     domain transition graph for w 
    two operators hvi    s  vi   s  vi    i and hvi    s  vi   s  vi    i that allow vi
to move from s to either   or   
    only when i      for each clause cj and each x   cj   cj    two operators
hvi    x  vi      vi   cj i and hvi    x  vi      vi   cj i  these operators allow vi to move to cj or cj if vi  has done so 
    for each clause cj and each x          an operator hvi    x  vi      vi   cj i if v i
occurs in clause cj   and an operator hvi    x  vi      vi   cj i if vi occurs in clause
cj   these operators allow vi to move to cj or cj even if vi  has not done so 
    for each clause cj and each x           two operators hvi    x  vi   cj   vi    i
and hvi    x  vi   cj   vi    i  these operators allow vi to move back to   or   
the domain transition graph for state variable w is shown in figure     for every clause
cj the only two operators acting on w are hvk   x  w   j     w   ji  where x   cj   cj  
 if j      the pre condition w   j    is replaced by w   s  
proposition     a cnf formula f is satisfiable if and only if the planning instance p  f  
is solvable 
proof the proof follows from a relatively straightforward interpretation of the variables
and values of the planning instance p  f    for every state variable vi   we must use an
operator of     to commit to either   or    note that  once this choice is made  variable vi
cannot be set to the other value  the reason we need two values cj and cj for each clause
is to enforce this commitment  cj corresponds to vi      while cj corresponds to vi      
to reach the goal the state variable w has to advance step by step along the values            n 
clearly  for every clause cj there must exist some variable vi that is first set to values cj
or cj using an operator of      then  this message can be propagated along variables
vi             vk using operators of      note that the existence of an operator of     acting on
vi implies that the initial choice of   or   for state variable vi   when applied to the formula
variable vi   makes the clause cj true  hence  if  is a plan solving p  f    we can use the
initial choices of  on state variables vi to define a  partial  assignment  that satisfies all
clauses of f  
conversely  if  is some assignment that satisfies f   we show how to obtain a plan 
that solves p  f    first  we set every state variable vi to value  vi    for every one of the
clauses cj   we choose a variable vi among those that make cj true using assignment  
then  in increasing order of j  we set the state variable vi corresponding to clause cj to a
value cj or cj  depending on  vi     and we pass this message along vi             vk up to w 
theorem     plan existence cn is np hard 
   

ficomplexity of planning problems

vx
vc

vc

vc

vc

vc

vc

 

 

 

vx

vy

vy

vz

vz

 

 

v 

v 

v 

v 

v 

 

figure     causal graph of pf when f   c   c   c  on three variables x  y  z 
proof producing a planning instance p  f   from a cnf formula f can be easily done in
polynomial time  so we have a polynomial time reduction cnf sat p plan existencecn  

   polytree causal graphs
in this section  we study the class of planning problems with binary state variables and
polytree causal graphs  brafman and domshlak        presented an algorithm that finds
plans for problems of this class in time o n     where n is the number of variables and
 is the maximum indegree of the polytree causal graph  brafman and domshlak       
also showed how to solve in time roughly o n   planning domains with local depth  and
causal graphs of tree width   it is interesting to observe that both algorithms fail to solve
polytree planning domains in polynomial time for different reasons  the first one fails when
the tree is too broad  unbounded indegree   the second one fails when the tree is too deep
 unbounded local depth  since the tree width  of a polytree is    
in this section we prove that the problem of plan existence for polytree causal graphs
with binary variables is np hard  our proof is a reduction from  sat to this class of
planning problems  as an example of the reduction  figure    shows the causal graph of
the planning problem pf that corresponds to a formula f with three variables and three
clauses  the precise definition of pf is given in proposition       finally  at the end of this
section we remark that the same reduction solves a problem expressed in terms of cp nets
 boutilier et al          namely  that dominance testing for polytree cp nets with binary
variables and partially specified cpts is np complete 
let us describe briefly the idea behind the reduction  the planning problem pf has two
           and v   depends on
different parts  the first part  state variables vx   vx           vc    vc
 
 
the formula f and has the property that a plan may change the value of v  from   to   as
many times as the number of clauses of f that a truth assignment can satisfy  however  this
condition on v  cannot be stated as a planning problem goal  we overcome this difficulty
by introducing a second part  state variables v    v            vt   that translates it to a regular
planning problem goal 
we first describe the second part  let p be the planning problem hv  init  goal  ai
where v is the set of state variables  v            v k    and a is the set of  k    operators
              k                 k     for i      the operators are defined as     hv       v     i
   

figimenez   jonsson

and     hv       v     i  for i      the operators are i   hvi       vi      vi    i and
i   hvi       vi      vi    i  the initial state is init vi       for all i  and the goal state
is goal vi       if i is even and goal vi       if odd 
lemma     any valid plan for planning problem p changes state variable v  from   to  
at least k times  there is a valid plan that achieves this minimum 
proof let ai and bi be  respectively  the sequences of operators h            i i and h            i i 
it is easy to verify that the plan hb k    a k    b k            b    a    b  i solves the planning
problem p   indeed  after applying the operators of ai  respectively  the operators of bi   
variables v            vi become    respectively      in particular  variable vi attains its goal
state    if i is even    if i is odd   subsequent operators in the plan do not modify vi   so
the variable remains in its goal state until the end  the operator   appears k times in the
plan  one for each sequence of type bi    thus the value of v  changes k times from   to   
we proceed to show that k is the minimum  consider some plan  that solves the
planning problem p   and let i be the number of operators i and i appearing in   in
other words  i is the number of times that the value of vi changes  either from   to   or
from   to     note that the number of times operator i appears is equal to or precisely one
more than the number of occurrences of i   we will show that i    i   since  k     
this implies that     k     so that plan  has  at least  k occurrences of     completing
the proof 
we show that i    i   let si be the subsequence of operators i and i in plan  
clearly  si starts with i  since the initial state is vi       and the same operator cannot
appear twice consecutively in si   so si   i   i   i   i   etc  also note that  for i      i has
vi      as a pre condition  and i has vi       hence there must be at least one operator
i  in plan  betweeen any two operators i and i   for the same reason we must have
at least one operator i  between any two operators i and i   and one operator i 
before the first operator i   this shows that i   i   on the other hand  variables vi and
vi  have different values in the goal state  so subsequences si and si  must have different
lengths  that is  i     i   together  this implies i    i   as desired 
proposition      sat reduces to plan existence for planning problems with binary variables and polytree causal graphs 
proof let f be a cnf formula with k clauses and n variables  we produce a planning
problem pf with  n    k    state variables and  n     k    operators  the planning
problem has two state variables vx and vx for every variable x in f   two state variables vc
 for every clause c in f   and  k    additional variables v           v
and vc
 
 k    all variables
are   in the initial state  the  partial  goal state is defined by vgoal    v            v k    
goal vi       when i is even  and goal vi       when i is odd  like in problem p of lemma
     the operators are 
    operators hvx      vx    i and hvx      vx    i for every variable x of f  
      v     i  hv       v      v    i and hv       v      v    i
    operators hvc
c
c
c
c
c
c
c
for every clause c of f  

   

ficomplexity of planning problems

    seven operators for every clause c  one for each partial assignment that satisfies c 
without loss of generality  let x  y  and z be the three variables that appear in clause c 
then for each operator a among these seven  vpre a     vx   vx   vy   vy   vz   vz   vc   v    
vpost a     v     pre a  vc        pre a  v         and post a  v         the precondition on state variables vx   vx   vy   vy   vz   vz depends on the corresponding satisfying partial assignment  for example  the operator corresponding to the partial
assignment  x      y      z      of the clause c   x  y  z has the pre condition
 vx      vx      vy      vy      vz      vz      
    an operator h c  vc       v       v     i 
    operators i   hvi       vi      vi    i and i   hvi       vi      vi    i for
   i   k     the same operators as in problem p except for   and     
we note some simple facts about problem pf   for any variable x  state variables vx and
vx in pf start at    and by applying the operators in     they can change into   but not
back to    in particular  a plan  cannot reach both of the partial states hvx      vx    i
and hvx      vx    i during the course of its execution 
similarly  if c is a clause of f   state variable vc can change from   to   and  by first
 into    v can change back to    no further changes are possible  since no
changing vc
c
 to   
operator brings back vc
now we interpret operators in     and      which are the only operators that affect v   
to change v  from   to   we need to apply one of the operators in      thus we require
vc     for a clause c  but the only way to bring back v  to   is applying the operator in
    which has as pre condition that vc      we deduce that every time that v  changes its
value from   to   and then back to   in plan   at least one of the k state variables vc is
used up  in the sense that vc has been brought from   to   and then back to    and cannot
be used again for the same purpose 
we show that f is in  sat if and only if there is a valid plan for problem pf   assume
f is in  sat  and let  be a truth assignment that satisfies f   consider the following plan
   first  we set vx    x  and vx       x  for all variables x using the operators of     
then  for a clause c in f   we set vc      we apply the operator of     that corresponds to
 restricted to the variables of clause c  at this point  v  changes from   to     then we set
     and v      and we apply the operator of      at this point  v change from   to
vc
 
c
    by repeating this process for every clause c of f we are switching the state variable v 
exactly k times from   to    now  following the proof of lemma      we can easily extend
this plan  to a plan  that sets all variables vi to their goal values 
we show the converse  namely  that the existence of a valid plan  in pf implies that f
is satisfiable  define an assignment  by setting  x      if the partial state  vx      vx     
appears during the execution of   and  x      otherwise   recall that at most one of the
partial states  vx      vx      and  vx      vx      can appear during the execution of any
plan   by lemma       must be such that state variable v  changes from   to   at least k
times  this implies that k operators of      all of them corresponding to different clauses 
have been used to move v  from   to    but to apply such an operator  the values of state
variables  vx   vx   must satisfy the corresponding clause  thus the assignment  satisfies all
the k clauses of f  
   

figimenez   jonsson

theorem     plan existence for planning problems with binary variables and polytree
causal graph is np complete 
proof due to proposition     we only need to show that the problem is in np  but
brafman and domshlak        showed that this holds in the more general setting of planning
problems with causal graphs where each component is directed path singly connected  that
is  there is at most one directed path between any pair of nodes   their proof exploits a
non trivial auxiliary result  solvable planning problems on binary variables with a directedpath singly connected causal graph have plans of polynomial length  the same is not true
for non binary variables  or unrestricted causal graphs  
    cp nets
boutilier et al         introduced the notion of a cp net as a graphical representation of
user preferences  in brief  a cp net is a network of dependences on a set of variables  the
preferences the user has for a variable depend on the values of some of the others  under the
ceteris paribus  all else being equal  assumption  that is  the user preferences on the variable
are completely independent of the values of the variables not mentioned  the preferences
for a variable given its parent variables in the network are stored in conditional preference
tables  or cpts 
boutilier et al         showed that the dominance query problem in acyclic cp nets 
that is  the problem of deciding if one variable outcome is preferable to another  can be
expressed in terms of a planning problem  the network of dependences of the cp net
becomes the causal graph of the planning problem 
however  under certain conditions  we can perform the opposite process  transform
a planning problem into a cp net and a dominance query problem  such that answering
the query amounts to solving the planning problem  this is possible under the following
conditions on planning problems with acyclic causal graph and binary variables 
   two operators that modify the same variable in opposing directions must have nonmatching prevail conditions  the prevail condition of an operator a is the partial state
pre a    v  vpost a    
   we must allow partially specified cpts in the cp net description 
the first condition guarantees that we obtain consistent cpts from the planning instance
operators  the second condition ensures that the reduction is polynomial size preserving 
since fully specified cpts are exponential in the maximum node indegree of the cp net 
in particular  the planning instance pf we reduced f to satisfies the first condition 
 note that this is not true for the planning problem p of lemma      but we drop the
reversing operators   and   when constructing pf in proposition       as a consequence 
we can claim the following 
theorem     dominance testing for polytree cp nets with binary variables and partially
specified cpts is np complete 
   

ficomplexity of planning problems

   conclusion
we have presented three new complexity results for planning problems with simple causal
graphs  first  we provided a polynomial time algorithm that uses macros to generate solution plans for the class  s  although the solutions are generally suboptimal  the algorithm
can generate representations of exponentially long plans in polynomial time  this has several implications for theoretical work in planning  since it has been generally accepted that
exponentially sized minimal solutions imply that plan generation is intractable  our work
shows that this is not always the case  provided that one is allowed to express the solution
in a succinct notation such as macros  we also showed that plan existence for the class cn
is np hard  and that plan existence for the class of planning problems with binary variables
and polytree causal graph is np complete 
jonsson and backstrom        investigated whether plan generation is significantly
harder than plan existence  using the class  s  they demonstrated that plan existence
can be solved in polynomial time  while plan generation is intractable in the sense that
solution plans may have exponential length  our work casts new light on this result  even
though solution plans have exponential length  it is possible to generate a representation
of the solution in polynomial time  thus  it appears as if for the class  s  plan generation
is not inherently harder than plan existence  we are not aware of any other work that
determines the relative complexity of plan existence and plan generation  so the question
of whether plan generation is harder that plan existence remains open 
a potential criticism of our algorithm is that a solution in the form of macros is not
standard  and that it is intractable to expand the system of macros to arrive at the possibly
exponentially long sequence of underlying operators  although this is true  we have shown
that the system of macros share several characteristics with a proper solution  it is possible
to generate and validate the solution in polynomial time  and the solution can be stored
using polynomial memory  we also showed that it is possible to compute the total length
of the solution in polynomial time  as well as determine which is the i th operator in the
underlying sequence 
since they are relatively simple  the class cn and the class of planning problems with
binary state variables and polytree causal graphs could be seen as promising candidates for
proving the relative complexity of plan existence and plan generation  however  we have
shown that plan existence for cn is np hard  and that plan existence for planning problems
with polytree causal graphs is np complete  consequently  these classes cannot be used
to show that plan generation is harder than plan existence  since plan existence is already
difficult  our work also closes the complexity gaps that appear in the literature regarding
these two classes 
it is however possible that there exist subsets of planning problems in these classes
for which plan existence can be solved in polynomial time  in fact  for polytree causal
graphs in binary variables we know that this is the case  due to the algorithms of brafman
and domshlak              mentioned in section    hence the plan generation problem
is polynomial if we restrict to polytree causal graphs with either bounded indegree  or
bounded local depth   consequently  our reduction from  sat exhibits both unbounded
indegree and unbounded local depth 
   

figimenez   jonsson

similarly  one may ask if the class cn of planning problems has some parameter that 
when bounded  would yield a tractable subclass  the state variables in our reduction have
domains whose size depends on the number of clauses of the corresponding cnf formula 
so the domain size appears as an interesting candidate  planning problems of cn with
binary variables are tractable due to the work of brafman and domshlak         but the
ideas they use do not extend to domain sizes other than    hence it would be interesting
to investigate whether the problem of plan existence for the class cn is easier if the size of
the state variable domains is bounded by a constant 

appendix a  proof of theorem    
assume that generatemacro p   v  x  m   successfully returns the macro mvx   hs    a  s  i 
let u    u  vpre a    v    pre a  u       and let w    w            wk    u be the set
wi
i
of state variables in u such that wi is not splitting   mw
    m     m   and wi comes before wj in topological order if and only if i   j  it follows that no u  u is static  that
wk
w 
w 
k
s    hmw
            m  i and that s    hm            m  i  since each state variable wi  w is
not splitting  it has to be symmetrically reversible 
lemma a   for each wi  w   prewi  prev  
proof since wi  vpre a  and v  vpost a    there is an edge from wi to v in the causal graph 
thus  any ancestor of wi is also an ancestor of v  so ancwi  ancv   for a state variable
u  ancwi   prewi  u      if and only if u is splitting and wi  v u   the graph gu     v  e u  
includes the edge from wi to v  which means that v  v u if and only if wi  v u   it follows
that prewi  u      if and only if prev  u       and as a consequence  prewi  prev  
i
let    hs    a  s  i  for each wi  w and y          let w
y be the sequence preceding
wi 
w
w
w
w
i  
w
i
 
i
k
i 
the macro my i in   that is      hm            m  i and     hs    a  mw
            m 
a
a
further  let  be the sequence appearing before a  that is     hs  i 

wi
a
i
lemma a   for each    i  k  the post conditions of sequences w
       and   are
i
 post w
       wi                wk      

 post a      w               wk      
i
 post w
       w               wi       wi              wk      v   x  
i
proof a direct consequence of post ha            ak i    post a     post ak   and post mw
y   
 wi   y   post a     v   x  

wi
a
i
lemma a   for each    i  k  the pre conditions of sequences w
           and 
wi
v
a
i
satisfy pre w
     pre     pre      pre    pre   v      x  
a
i
proof since pre ha            ak i    pre ak    pre a     it follows that pre w
     pre    
wi
v
pre      pre    we prove that pre    pre   v      x   for a state variable u
such that pre   u      let mu be the first operator in hs    a  s  i such that u  vpre mu    
so that pre   u    pre mu   u  

   

ficomplexity of planning problems

u
wi   w       prev   where we have
i
if mu   mw
i
    then it follows that pre m    pre
wi
used that m  is a  s macro  wi is symmetrically reversible  and that prewi  prev due to
lemma a    in particular  pre mu   u    prev  u  
since we assume that planning problems are in normal form  u   wi implies that
wi
u
i
u  vpre mwi     it follows that if mu    mw
  for all i  then u    wi for all i  if m   m 
 
we have that pre mu    prewi   wi       but due to u    wi   we deduce pre mu   u   
prewi  u    prev  u  
finally  consider the case mu   a  if u   v then pre mu   u       x  as desired  if
u    v is splitting  then either v belongs to v u and pre mu   u       or v belongs to v u and
pre mu   u       that is  pre mu   u    prev  u   if u    v is symmetrically reversible it
follows that pre mu   u       since the case pre mu   u      would have forced the algorithm
to either fail or include u in w   if u    v is static  pre mu   u       else the algorithm would
have failed 

lemma a   let p  p   q and r be partial states  if p  p and  p  q r  then  p  q r 
proof a direct consequence of p  q  p  q 
lemma a   the macro mvx generated by the algorithm is well defined 
proof since  only includes macros for the ancestors of v in the causal graph  and since
the causal graph is acyclic  no cyclic definitions occur  it remains to show that  for a macro
m in  and a sequence m preceding m in   it holds that  pre m    post m   pre m  
note that due to lemmas a   and a   it is enough to show that
wi
i
 a   prev   v      x   post w
    pre m    

 b   prev   v      x   post a   pre a  
wi
i
 c   prev   v      x   post w
    pre m    
wi
i
case  a  follows easily since vpost wi   vpre mwi      and pre mw
      pre  wi      
 
 
w
prev   case  c  is similar  although this time we must use that post   i   wi       and
wi
wi   w       finally  case  b 
i
post w
i
    wj       for j   i  as required by pre m      pre
holds because a variable u  vpre a  can be either u   v  which is covered by  v      x  
splitting or static  which is covered by prev   or symmetrically reversible  which is covered
by prev  u      if pre a  u       and by post a   u      if pre a  u      

in remains to show that mvx is a  s macro  it follows from lemmas a   and a   that it
is well defined and it satisfies pre mvx     pre    prev   v      x   finally  post mvx    
post  pre      v   x  is a direct consequence of post      w               wk      v   x 
from lemma a    and pre   wi        pre   v       x from the proof of lemma a   

acknowledgments
this work was partially funded by mec grants tin           c      and tin          c       grammars  
   

figimenez   jonsson

references
backstrom  c     nebel  b          complexity results for sas  planning  computational
intelligence                 
botea  a   enzenberger  m   muller  m     schaeffer  j          macro ff  improving ai
planning with automatically learned macro operators  journal of artificial intelligence research             
boutilier  c   brafman  r   domshlak  c   hoos  h     poole  d          cp nets  a tool for
representing and reasoning with conditional ceteris paribus preference statements 
journal of artificial intelligence research             
brafman  r     domshlak  c          structure and complexity in planning with unary
operators  journal of artificial intelligence research             
brafman  r     domshlak  c          factored planning  how  when  and when not  in
proceedings of the   st national conference on artificial intelligence 
bylander  t          the computational complexity of propositional strips planning 
artificial intelligence             
chapman  d          planning for conjunctive goals  artificial intelligence                
cormen  t   leiserson  c   rivest  r     stein  c          introduction to algorithms  mit
press and mcgraw hill 
domshlak  c     dinitz  y          multi agent off line coordination  structure and complexity  in proceedings of the  th european conference on planning  pp         
erol  k   nau  d     subrahmanian  v          complexity  decidability and undecidability
results for domain independent planning  artificial intelligence                
fikes  r     nilsson  n          strips  a new approach to the application of theorem
proving to problem solving  artificial intelligence                
gimenez  o     jonsson  a          on the hardness of planning problems with simple
causal graphs  in proceedings of the   th international conference on automated
planning and scheduling  pp         
helmert  m          complexity results for standard benchmark domains in planning 
artificial intelligence                 
helmert  m          the fast downward planning system  journal of artificial intelligence
research             
jonsson  a          the role of macros in tractable planning over causal graphs  in
proceedings of the   th international joint conference on artificial intelligence  pp 
         
jonsson  p     backstrom  c          tractable plan existence does not imply tractable
plan generation  annals of mathematics and artificial intelligence                  
katz  m     domshlak  c          structural patterns heuristics  basic idea and concrete
instance  in workshop on heuristics for domain independent planning  progress 
ideas  limitations  challenges  icaps     
   

ficomplexity of planning problems

knoblock  c          automatically generating abstractions for planning  artificial intelligence                
korf  r          planning as search  a quantitative approach  artificial intelligence        
     
minton  s          selectively generalizing plans for problem solving  in proceedings of the
 th international joint conference on artificial intelligence  pp         
vidal  v          a lookahead strategy for heuristic search planning  in proceedings of the
  th international conference on automated planning and scheduling  pp         
williams  b     nayak  p          a reactive planner for a model based executive  in
proceedings of the   th international joint conference on artificial intelligence  pp 
         

   

fi