journal artificial intelligence research                  

submitted          published       

first order decision diagrams relational mdps
chenggang wang
saket joshi
roni khardon

cwan cs tufts edu
sjoshi   cs tufts edu
roni cs tufts edu

department computer science  tufts university
    college avenue  medford         usa

abstract
markov decision processes capture sequential decision making uncertainty 
agent must choose actions optimize long term reward  paper studies efficient reasoning mechanisms relational markov decision processes  rmdp 
world states internal relational structure naturally described terms
objects relations among them  two contributions presented  first  paper
develops first order decision diagrams  fodd   new compact representation functions relational structures  together set operators combine fodds 
novel reduction techniques keep representation small  second  paper shows
fodds used develop solutions rmdps  reasoning performed
abstract level resulting optimal policy independent domain size  number
objects  instantiation  particular  variant value iteration algorithm developed using special operations fodds  algorithm shown converge
optimal policy 

   introduction
many real world problems cast sequential decision making uncertainty 
consider simple example logistics domain agent delivers boxes  agent
take three types actions  load box truck  unload box truck 
drive truck city  however effects actions may perfectly predictable 
example gripper may slippery load actions may succeed  navigation
module may reliable may end wrong location  uncertainty
compounds already complex problem planning course action achieve
goals maximize rewards 
markov decision processes  mdp  become standard model sequential decision making uncertainty  boutilier  dean    hanks         models provide
general framework artificial intelligence  ai  planning  agent achieve
maintain well defined goal  mdps model agent interacting world 
agent fully observe state world takes actions change state 
that  agent tries optimize measure long term reward obtain
using actions 
classical representation algorithms mdps  puterman        require enumeration state space  complex situations specify state space
terms set propositional variables called state attributes  state attributes
together determine world state  consider simple logistics problem
c
    
ai access foundation  rights reserved 

fiwang  joshi    khardon

one box one truck  state attributes truck paris  tp   box
paris  bp   box boston  bb   etc  let state space represented n binary
state attributes total number states would  n   problems  however 
domain dynamics resulting solutions simple structure described
compactly using state attributes  previous work known propositionally factored approach developed suite algorithms take advantage structure
avoid state enumeration  example  one use dynamic bayesian networks  decision trees  algebraic decision diagrams concisely represent mdp model 
line work showed substantial speedup propositionally factored domains  boutilier 
dearden    goldszmidt        boutilier  dean    goldszmidt        hoey  st aubin  hu 
  boutilier        
logistics example presented small  realistic problem
large number objects corresponding relations among them  consider problem
four trucks  three boxes  goal box paris 
matter box paris  propositionally factored approach  need
one propositional variable every possible instantiation relations domain 
e g   box   paris  box   paris  box   truck    box   truck    on 
action space expands way  goal becomes ground disjunction
different instances stating box   paris  box   paris  box   paris  box  
paris  thus get large mdp time lose structure implicit
relations potential benefits structure terms computation 
main motivation behind relational first order mdps  rmdp     first
order representation mdps describe domain objects relations among them 
use quantification specifying objectives  logistics example  introduce three predicates capture relations among domain objects  i e   bin box  city  
in t ruck  city   on box  ruck  obvious meaning  three parameterized actions  i e   load box  ruck   unload box  ruck   drive t ruck  city  
domain dynamics  reward  solutions described compactly abstractly using
relational notation  example  define goal using existential quantification 
i e   b  bin b  p aris   using goal one identify abstract policy  optimal
every possible instance domain  intuitively   steps go 
agent rewarded box paris  one step go
box paris yet  agent take one action help achieve goal 
box  say b    truck  say t    truck paris  agent execute
action unload b    t     may make bin b    p aris  true  thus goal achieved 
two steps go  box truck paris  agent
take unload action twice  to increase probability successful unloading
box   box truck paris  agent first take action
drive followed unload  preferred plan depend success probability
different actions  goal paper develop efficient solutions problems
using relational approach  performs general reasoning solving problems
propositionalize domain  result complexity algorithms
   sanner boutilier        make distinction first order mdps utilize full power
first order logic describe problem relational mdps less expressive  follow
calling language rmdp 

   

fifirst order decision diagrams relational mdps

change number domain objects changes  solutions obtained good
domain size  even infinite ones  simultaneously  abstraction
possible within propositional approach 
several approaches solving rmdps developed last years  much
work devoted developing techniques approximate rmdp solutions using
different representation languages algorithms  guestrin  koller  gearhart    kanodia 
    a  fern  yoon    givan        gretton   thiebaux        sanner   boutilier       
       example  dzeroski  de raedt  driessens        driessens  ramon 
gartner        use reinforcement learning techniques relational representations  fern 
yoon  givan        gretton thiebaux        use inductive learning methods
learn value map policy solutions simulations small instances  sanner
boutilier              develop approach approximate value iteration need
propositionalize domain  represent value functions linear combination
first order basis functions obtain weights lifting propositional approximate
linear programming techniques  schuurmans   patrascu        guestrin  koller  par   
venktaraman      b  handle first order case 
work exact solutions symbolic dynamic programming
 sdp   boutilier  reiter    price         relational bellman algorithm  rebel   kersting  otterlo    de raedt         first order value iteration  fovia   gromann 
holldobler    skvortsova        hoolldobler  karabaev    skvortsova        
working implementation sdp hard keep state formulas consistent
manageable size context situation calculus  compared sdp  rebel
fovia provide practical solutions  use restricted languages represent
rmdps  reasoning formulas easier perform  paper develop
representation combines strong points approaches 
work inspired successful application algebraic decision diagrams  add 
 bryant        mcmillan        bahar  frohm  gaona  hachtel  macii  pardo    somenzi 
      solving propositionally factored mdps pomdps  hoey et al         st aubin 
hoey    boutilier        hansen   feng        feng   hansen         intuition
behind idea add representation allows information sharing  e g   sharing
value states belong abstract state  algorithms consider
many states together need resort state enumeration  sufficient
regularity model  adds compact  allowing problems represented
solved efficiently  provide generalization approach lifting adds
handle relational structure adapting mdp algorithms  main difficulty lifting
propositional solution  relational domains transition function specifies
set schemas conditional probabilities  propositional solution uses concrete
conditional probability calculate regression function  possible
schemas  one way around problem first ground domain problem hand
perform reasoning  see example sanghai  domingos    weld        
however allow solutions abstracting domains problems 
sdp  rebel  fovia  constructions perform general reasoning 
first order decision trees even decision diagrams already considered
literature  blockeel   de raedt        groote   tveretina        several semantics
diagrams possible  blockeel de raedt        lift propositional decision
   

fiwang  joshi    khardon

trees handle relational structure context learning relational datasets 
groote tveretina        provide notation first order binary decision diagrams
 bdd  capture formulas skolemized conjunctive normal form provide
theorem proving algorithm based representation  paper investigates
approaches identifies approach groote tveretina        better suited
operations value iteration algorithm  therefore adapt extend
approach handle rmdps  particular  first order decision diagrams  fodd 
defined modifying first order bdds capture existential quantification well realvalued functions use aggregation different valuations diagram 
allows us capture mdp value functions using algebraic diagrams natural way 
provide additional reduction transformations algebraic diagrams help keep
size small  allow use background knowledge reductions  develop
appropriate representations algorithms showing value iteration performed
using fodds  core algorithm introduce novel diagram based algorithm
goal regression where  given diagram representing current value function 
node diagram replaced small diagram capturing truth value
action  offers modular efficient form regression accounts potential
effects action simultaneously  show version abstract value iteration
correct hence converges optimal value function policy 
summarize  contributions paper follows  paper identifies
multiple path semantics  extending groote   tveretina        useful representation
rmdps contrasts single path semantics blockeel de raedt        
paper develops fodds algorithms manipulate general
context rmdps  paper develops novel weak reduction operations first order
decision diagrams shows relevance solving relational mdps  finally paper
presents version relational value iteration algorithm using fodds shows
correct thus converges optimal value function policy  relational
value iteration developed specified previous work  boutilier et al         
knowledge first detailed proof correctness convergence algorithm 
section briefly summarized research background  motivation  approach  rest paper organized follows  section   provides background
mdps rmdps  section   introduces syntax semantics first order decision diagrams  fodd   section   develops reduction operators fodds  sections
    present representation rmdps using fodds  relational value iteration
algorithm  proof correctness convergence  last two sections conclude
paper discussion results future work 

   relational markov decision processes
assume familiarity standard notions mdps value iteration  see example
bellman        puterman         following introduce notions 
introduce relational mdps discuss previous work solving them 
markov decision processes  mdps  provide mathematical model sequential optimization problems stochastic actions  mdp characterized state space
s  action space a  state transition function p r sj  si   a  denoting probability
   

fifirst order decision diagrams relational mdps

transition state sj given state si action a  immediate reward function r s  
specifying immediate utility state s  solution mdp optimal
policy maximizes expected discounted total reward defined bellman equation 
v  s    maxaa  r s   

x

p r s   s  a v  s    

s 

v represents optimal state value function  value iteration algorithm  vi 
uses bellman equation iteratively refine estimate value function 
vn    s    maxaa  r s   

x

p r s   s  a vn  s    

   

s 

vn  s  represents current estimate value function vn    s  next
estimate  initialize process v  reward function  vn captures optimal
value function n steps go  discussed algorithm
known converge optimal value function 
boutilier et al         used situation calculus formalize first order mdps
structured form value iteration algorithm  one useful restrictions introduced
work stochastic actions specified randomized choice among deterministic alternatives  example  action unload logistics example succeed
fail  therefore two alternatives action  unloads  unload success 
unloadf  unload failure   formulation algorithms support number action
alternatives  randomness domain captured random choice specifying
action alternative  unloads unloadf   gets executed agent attempts
action  unload   choice determined state dependent probability distribution
characterizing dynamics world  way one separate regression
effects action alternatives  deterministic  probabilistic choice
action  considerably simplifies reasoning required since need perform
probabilistic goal regression directly  work rmdps used assumption  use assumption well  sanner boutilier        investigate model
going beyond assumption 
thus relational mdps specified set predicates domain  set
probabilistic actions domain  reward function  probabilistic action 
specify deterministic action alternatives effects  probabilistic choice
among alternatives  relational mdp captures family mdps generated
choosing instantiation state space  thus logistics example corresponds
possible instantiations   boxes   boxes on  get concrete
mdp choosing instantiation   yet algorithms attempt solve entire
mdp family simultaneously 
boutilier et al         introduce case notation represent probabilities rewards
compactly  expression   case     t      n   tn    logical formula 
equivalent     t   t      n  t   tn     words  equals ti
   one could define single mdp including possible instances time  e g  include
states   boxes  states   boxes infinite number boxes  obviously
subsets states form separate mdps disjoint  thus prefer view rmdp
family mdps 

   

fiwang  joshi    khardon

true  general  constrained steps vi algorithm require
disjoint partition state space  case  exactly one
true state  denotes abstract state whose member states
value probability reward  example  reward function logistics
domain  discussed illustrated right side figure    captured
case b  bin b  p aris       b  bin b  p aris       following notation
operations function defined case expressions  operators defined
taking cross product partitions adding multiplying case values 
case i   ti   n  case j   vj   j m    case i j   ti   vj   n  j m 
case i   ti   n  case j   vj   j m    case i j   ti vj   n  j m  
iteration vi algorithm  value stochastic action a  x  parameterized
free variables  x determined following manner 
qa  x   s    rcase s    j  pcase nj   x   s  regr nj   x   vcase do nj   x   s         
rcase s  vcase s  denote reward value functions case notation  n j   x 
denotes possible outcomes action a  x   pcase nj   x   s  choice probabilities nj   x   note replace sum possible next states s  standard
value iteration  equation    finite sum action alternatives j  reflected j
equation     since different next states arise different action alternatives 
regr  capturing goal regression  determines states one must action
order reach particular state action  figure   illustrates regression
b  bin b  p aris  reward function r action alternative unloads b     
b  bin b  p aris  true action unloads b     true box
b truck truck paris  notice reward function r partitions
state space two regions abstract states  may include infinite
number complete world states  e g   infinite number domain objects  
notice get another set abstract states regression step 
way first order regression ensures work abstract states never need
propositionalize domain 
regression  get parameterized q function accounts possible
instances action  need maximize action parameters q function
get maximum value could achieved using instance action 
illustrate step  consider logistics example two boxes b   b   
b  truck t    paris  that is  on b    t    in t    p aris    b 
boston  bin b    boston    action schema unload b      instantiate b
b  t  respectively  help us achieve goal  instantiate b
b  t  respectively  effect  therefore need perform
maximization action parameters get best instance action  yet  must
perform maximization generically  without knowledge actual state  sdp 
done several steps  first  add existential quantifiers action parameters  which
leads non disjoint partitions   sort abstract states q a  x  value
decreasing order include negated conditions first n abstract states
formula  n     th   ensuring mutual exclusion  notice step leads complex
   

fifirst order decision diagrams relational mdps

r
b   bin   b   paris  

b   bin   b   paris  

  

b   bin   b   paris  
 

  b      
tin      paris  

figure    example illustrating regression action alternative unloads b     

description resulting state partitions sdp  process performed every
action separately  call step object maximization denote obj max q a  x    
finally  get next value function maximize q functions different
actions  three steps provide one iteration vi algorithm repeats
update convergence 
solutions rebel  kersting et al         fovia  gromann et al        
hoolldobler et al         follow outline use simpler logical language representing rmdps  abstract state rebel captured using existentially quantified
conjunction  fovia  gromann et al         hoolldobler et al         complex
representation allowing conjunction must hold state set conjunctions
must violated  important feature rebel use decision list  rivest 
      style representations value functions policies  decision list gives us
implicit maximization operator since rules higher list evaluated first  result
object maximization step simple rebel  state partition represented
implicitly negation rules it  explicitly conjunction rule 
hand  regression rebel requires one enumerate possible matches
subset conjunctive goal  or state partition  action effects  reason
separately  step potentially improved 
following section introduce new representation first order decision diagrams  fodd   fodds allow sharing parts partitions  leading space time
saving  importantly value iteration algorithm based fodds simple
regression simple object maximization 
   

fiwang  joshi    khardon

   first order decision diagrams
decision diagram graphical representation functions propositional  boolean 
variables  function represented labeled rooted directed acyclic graph
non leaf node labeled propositional variable exactly two children 
outgoing edges marked values true false  leaves labeled numerical
values  given assignment truth values propositional variables  traverse
graph node follow outgoing edge corresponding truth value 
gives mapping assignment leaf diagram turn
value  leaves marked values        interpret graph
representing boolean function propositional variables  equivalently  graph
seen representing logical expression satisfied   leaf
reached  case        leaves known binary decision diagrams  bdds 
case numerical leaves  or general algebraic expressions  known algebraic
decision diagrams  adds   decision diagrams particularly interesting impose
order propositional variables require node labels respect order
every path diagram  case known ordered decision diagrams  odd  
case every function unique canonical representation serves normal form
function  property means propositional theorem proving easy odd
representations  example  formula contradictory fact evident
represent bdd  since normal form contradiction single leaf valued
   property together efficient manipulation algorithms odd representations
led successful applications  e g   vlsi design verification  bryant       
mcmillan        bahar et al         well mdps  hoey et al         st aubin et al  
       following generalize representation relational problems 
    syntax first order decision diagrams
various ways generalize adds capture relational structure  one could
use closed open formulas nodes  latter case must interpret
quantification variables  process developing ideas paper
considered several possibilities including explicit quantifiers lead
useful solutions  therefore focus following syntactic definition
explicit quantifiers 
representation  assume fixed set predicates constant symbols 
enumerable set variables  allow using equality pair terms
 constants variables  
definition   first order decision diagram
   first order decision diagram  fodd  labeled rooted directed acyclic graph 
non leaf node exactly two children  outgoing edges marked
values true false 
   non leaf node labeled with  atom p  t            tn   equality t    t 
ti variable constant 
   leaves labeled numerical values 
   

fifirst order decision diagrams relational mdps

p  x 
q  x 
 

h  y 

   

 

figure    simple fodd 

figure   shows fodd binary leaves  left going edges represent true branches 
simplify diagrams paper draw multiple copies leaves      and
occasionally values small sub diagrams  represent node
fodd 
use following notation  node n  nt denotes true branch n  nf
false branch n  na outgoing edge n  true false 
edge e  source e  node edge e issues from  target e  node edge e
points to  let e  e  two edges  e    sibling e    iff source e      source e    
following slightly abuse notation let na mean either edge
sub fodd edge points to  use na target e    interchangeably
n   source e    true false depending whether e  lies
true false branch n 
    semantics first order decision diagrams
use fodd represent function assigns values states relational mdp 
example  logistics domain  might want assign values different states
way box paris  state assigned value    
box paris box truck paris raining  state
assigned value      on   question define semantics fodds
order intended meaning 
semantics first order formulas given relative interpretations  interpretation domain elements  mapping constants domain elements and 
predicate  relation domain elements specifies predicate
true  mdp context  state captured interpretation  example
logistics domain  state includes objects boxes  trucks  cities  relations
among them  box   truck    on b    t      box   paris  bin b    p aris  
on  one way define meaning fodd b interpretation i 
following discuss two possibilities 
      semantics based single path
semantics relational decision trees given blockeel de raedt       
adapted fodds  semantics define unique path followed traversing
   result regression logistics domain cf  figure    l  

   

fiwang  joshi    khardon

b relative i  variables existential node evaluated relative path
leading it 
particular  reach node variables seen
path new  consider node n label l n  path leading
root  let c conjunction labels nodes exited true
branch path  node n evaluate  x  c l n    x includes
variables c l n   formula satisfied follow true branch 
otherwise follow false branch  process defines unique path root
leaf value 
example  evaluate diagram figure   interpretation  
domain           true atoms  p     q     h     follow
true branch root since x  p x  satisfied  follow false branch q x 
since x  p x  q x  satisfied  since leaf labeled   say b
satisfy i  attractive approach  partitions set interpretations
mutually exclusive sets used create abstract state partitions mdp
context  however  reasons discuss later  semantics leads various complications
value iteration algorithm  therefore used paper 
      semantics based multiple paths
second alternative builds work groote tveretina        defined semantics based multiple paths  following work  define semantics first relative
variable valuation   given fodd b variables  x interpretation i  valuation
maps variable  x domain element i  done  node predicate
evaluates either true false traverse single path leaf  value
leaf denoted mapb  i    
different valuations may give different values  recall use fodds represent
function states  state must assigned single value  therefore  next
define
mapb  i    aggregate  mapb  i    
aggregation function  is  consider possible valuations  
valuation calculate mapb  i     aggregate values  special
case groote tveretina        leaf labels        variables universally
quantified  easily captured formulation using minimum aggregation
function  paper use maximum aggregation function  corresponds
existential quantification binary case  if valuation leading value   
value assigned    gives useful maximization value functions
general case  therefore define 
mapb  i    max mapb  i     


using definition b assigns every unique value v   mapb  i  b defines function
interpretations real values  later refer function map b 
consider evaluating diagram figure   interpretation i  given
true atoms  p     q     h      valuation x mapped  
   

fifirst order decision diagrams relational mdps

mapped   denoted  x    y    leads leaf value   maximum    leaf
labels        interpret diagram logical formula  map b  i      
example  say satisfies b mapb  i      say falsifies
b 
define node formulas  nf  edge formulas  ef  recursively follows  node
n labeled l n  incoming edges e            ek   node formula nf n     i ef ei    
edge formula true outgoing edge n ef nt     nf n  l n   edge formula
false outgoing edge n ef nf     nf n  l n   formulas 
variables existentially quantified  capture conditions node edge
reached 
    basic reduction fodds
groote tveretina        define several operators reduce diagram normal
form  total order node labels assumed  describe operators briefly
give main properties 
 r   neglect operator  children node p fodd lead node q
remove p link parents p q directly 
 r   join operator  two nodes p  q label point two
children join p q  remove q link qs parents p  
 r   merge operator  node child label parent point
directly grandchild 
 r   sort operator  node p parent q label ordering violated  l p   
l q   reorder nodes locally using two copies p q labels
nodes violate ordering 
define fodd reduced none four operators applied 
following 
theorem    groote   tveretina       
    let  neglect  join  merge  sort  operator o b  result applying
fodd b  b  i    mapb  i      mapo b   i    
    b    b  reduced satisfy   mapb   i      mapb   i    identical 
property     gives soundness  property     shows reducing fodd gives normal
form  however  holds maps identical every condition
stronger normal equivalence  normal form suffices groote tveretina
       use provide theorem prover first order logic  strong
enough purposes  figure   shows two pairs reduced fodds  with respect r r   mapb   i    mapb   i    mapb   i       mapb   i     case
although maps fodds reduced form  consider
first pair part  a  figure  interpretation p a  false p b 
true substitution  x a  y b  leads value   b  b  always evaluates
   diagrams equivalent  interpretation  p c  true object
   

fiwang  joshi    khardon

b 

b 

p  x 

 a 

 

 

p  y 
 

 

p  x  y 
 b 

p  y  z 
 

p  x  y 

 

p  z  x 

 

 

 

 

figure    examples illustrating weakness normal form 

c mapb   i      substitution  x c   p c  false object c
mapb   i      substitution  x c  y c   thus map always  
b  well  section     show additional reduction operators
developed  b  first pair reduced    thus diagrams  a  form
reduction  however  reductions resolve second pair given part  b 
figure  notice functions capture path two edges labeled p graph
 we change order two nodes rename variables  diagrams evaluate
  interpretation path  even though b  b  logically
equivalent  cannot reduced form using r  r  new operators 
identify unique minimal syntactic form one may consider possible renamings
variables sorted diagrams produce  expensive operation 
discussion normal form conjunctions uses operation given garriga 
khardon  de raedt        
    combining fodds
given two algebraic diagrams may need add corresponding functions  take
maximum use binary operation  op  values represented functions  adopt solution propositional case  bryant        form
procedure apply b   b   op  b  b  algebraic diagrams  let p q
roots b  b  respectively  procedure chooses new root label  the lower
among labels p  q  recursively combines corresponding sub diagrams  according
relation two labels          order make sure result
reduced propositional sense one use dynamic programming avoid generating
nodes either neglect join operators   r    r   above  would applicable 
figure   illustrates process  example  assume predicate ordering
p  p    parameter ordering x  x    non leaf nodes annotated numbers
numerical leaves underlined identification execution trace  example 
   

fifirst order decision diagrams relational mdps

 
p   x  
 
p   x  
  



 
p   x  
 

 

 

   
p   x  
 

   
p   x  

   

    
p   x  
  

  

p   x  
 

 

figure    simple example adding two fodds 

top level call adds functions corresponding nodes      since p   x   
smaller label picked label root result  must add
left right child node   node    calls performed recursively  easy
see size result may product sizes input diagrams  however 
much pruning occur shared variables pruning made possible weak
reductions presented later 
since interpretation fixed valuation fodd propositional 
following lemma  later refer property correctness apply 
lemma   let c   apply a  b  op     mapa  i    op mapb  i     
mapc  i    
proof  first introduce terminology  let  nodes x  refer set nodes
fodd x  let root nodes b aroot broot respectively  let
fodds rooted aroott   arootf   broott   brootf   croott   crootf al   ar   b l   b r  
c l c r respectively 
proof induction n     nodes a       nodes b    lemma true
n      case aroot broot single leaves operation
operation two real numbers  inductive step need
consider two cases 
case    aroot   broot   since root nodes equal  valuation reaches al  
reach b l reaches ar   reach b r   also 
definition apply  case c l   apply al   b l   op  c r   apply ar   b r   op   therefore statement lemma true mapal  i    op mapb l  i      mapc l  i   
mapar  i    op mapb r  i      mapc r  i    i  now  since   nodes al    
 nodes b l      n   nodes ar      nodes b r      n  guaranteed induction
hypothesis 
case    aroot    broot   without loss generality let us assume aroot broot  
definition apply  c l   apply al   b  op  c r   apply ar   b  op   therefore
statement lemma true mapal  i    op mapb  i      mapc l  i   
mapar  i    op mapb  i      mapc r  i    i  guaranteed
induction hypothesis 
 
   

fiwang  joshi    khardon

    order labels
syntax fodds allows two types objects  constants variables 
argument predicate constant variable  assume complete ordering
predicates  constants  variables  ordering two labels given
following rules 
   p  x         xn   p    x          x m   p p  
   p  x         xn   p  x          x n   exists xj   x j j   i 
type xi   type x i    where type constant variable  type xi     type x i  
xi x i  
predicate order set arbitrarily appears useful assign equality
predicate first predicate ordering equalities top
diagrams  reductions often encounter situations one side equality
completely removed leading substantial space savings  may useful
order argument types constant variables  ordering may helpful
reductions  intuitively  variable appearing lower diagram bound
value constant appears it  heuristic guidelines best
ordering may well problem dependent  later introduce forms arguments 
predicate parameters action parameters  ordering discussed section   

   additional reduction operators
context  especially algebraic fodds  may want reduce diagrams further 
distinguish strong reductions preserve mapb  i    weak reductions
preserve mapb  i   theorem   shows r  r  given strong reductions  details relational vi algorithm directly depend reductions
used  readers interested rmdp details skip section   read
independently  except reductions illustrated examples  
reduction operators incorporate existing knowledge relationships
predicates domain  denote background knowledge b  example
blocks world may know block block clear 
x  y   on x  y  clear y   
following define conditions reduction operators  two types
conditions  reachability condition value condition  name reachability
conditions starting p  for path condition  reduction operator number 
name conditions values starting v reduction operator number 
     r   strong reduction implied branches
consider node n whenever n reached true branch followed 
case remove n connect parents directly true branch  first
present condition  followed lemma regarding operator 
 p     b     x   nf n  l n    x variables ef nt   
   

fifirst order decision diagrams relational mdps

let r  n  denote operator removes node n connects parents directly
true branch  notice generalization r   easy see
following lemma true 
lemma   let b fodd  n node condition p  holds  b   result
r  n   interpretation valuation map b  i     
mapb    i    
similar reduction formulated false branch  i e   b     x   nf n 
l n   whenever node n reached false branch followed  case
remove n connect parents directly false branch 
implied branches may simply result equalities along path  example  x  
y  p x  p y  may prune p y   x   y  p x  known true  implied
branches may result background knowledge  example blocks world
on x  y  guaranteed true reach node labeled clear y 
remove clear y  connect parent clear y f  
     r   weak reduction removing dominated edges
consider two edges e  e  fodd whose formulas satisfy follow
e  using valuation follow e  using possibly different valuation 
e  gives better value e  intuitively e  never determines value diagram
therefore redundant  formalize reduction operator r    
let p   source e     q   source e     e    pa   e    qb   b true
false  first present conditions operator follow
definition operator 
 p       b      x  ef e       y   ef e      x variables ef e     y
variables ef e    
 p       b     u    w 
  ef e       v   ef e       u variables appear
target e    target e      v variables appear ef e     u 
w
  variables appear ef e     u  condition requires
every valuation   reaches e  valuation   reaches e   
  agree variables appear target e    target e    
 p       b     r     s  ef e       t  ef e       r variables appear
target e    target sibling e       t variables appear ef e     r 
 s variables appear ef e     r  condition requires
every valuation   reaches e  valuation   reaches e   
  agree variables appear target e    target sibling e     
 v       min target e     max target e     min target e     minimum leaf
value target e     max target e     maximum leaf value target e     case
regardless valuation know better follow e  e   
 v       min target e     max target sibling e      
 v       leaves   target e    target e    non negative values  denoted
   case fixed valuation better follow e  instead e   
   use r  skip notation r  consistency earlier versions paper  see
discussion section       

   

fiwang  joshi    khardon

 v       leaves g   target e    target sibling e     non negative values 
define operators r  replace b  e    e    replacing target e    constant b
  min target e      we may write r  replace e    e    b      
r  drop e    e    dropping node q   source e    connecting parents
target sibling e     
need one safety condition guarantee reduction correct 
 s     nf source e     sub fodd target e    remain
r  replace r  drop  condition says must harm value promised
target e     words  must guarantee p   source e    reachable
sub fodd target e    modified replacing branch   
condition violated q sub fodd pa   p sub fodd qb  
holds cases  p q unrelated  one descendant
other   q sub fodd pa   p sub fodd qb   a  b
negations a  b 
lemma   let b fodd  e  e  edges conditions p     v     s 
hold  b   result r  replace b  e    e       b min target e     
interpretation mapb  i    mapb    i  
proof  consider valuation   reaches target e     according p    
another valuation reaching target e    v    gives higher value  therefore  mapb  i  never determined target e    replace target e   
constant   min target e     without changing map 
 
lemma   let b fodd  e  e  edges conditions p     v     s 
hold  b   result r  replace b  e    e       b min target e     
interpretation mapb  i    mapb    i  
proof  consider valuation   reaches target e     p    another
valuation   reaching target e        agree variables appear
target e    target e     therefore  v    achieves higher value  otherwise 
must branch   target e    target e    negative value   therefore according
maximum aggregation value mapb  i  never determined target e    
replace constant described above 
 
note conditions previous two lemmas comparable since p   
p    v    v     intuitively relax conditions values  need
strengthen conditions reachability  subtraction operation   target e    
target e    propositional  test v    implicitly assumes common variables operands p    check this  figure   illustrates
reachability condition p    together v     i e   combining weaker portions conditions lemma   lemma    cannot guarantee replace
branch constant  consider interpretation domain              relations  h        q        p      addition assume domain knowledge b    x  y  h x  y 
z  w  q z  w    p    v    hold e     q x  y  t e     h z  y t   
mapb   i      mapb   i       therefore possible replace h z  y t   
   

fifirst order decision diagrams relational mdps

q x y 
p y 

q x y 

h z y 
  p y   

 

 

 
b 

 

p y 
 

 

 
b 

figure    example illustrating subtraction condition r  

  

b 

b 

p x 

p x 

q y 
 

  

p y 

  

h y 

    

h y 
 

 

figure    example illustrating condition removing node r  

sometimes drop node q completely r  drop  intuitively 
remove node  must guarantee gain extra value  conditions
r  replace guarantee lose value  remove node
q  valuation supposed reach e  may reach better value e  sibling 
would change map  illustrated figure    notice conditions p   
v    hold e     p x  t e     p y  t replace  p y  t constant 
consider interpretation domain        relations  q     p     h     
mapb   i       via valuation  x    mapb   i       via valuation  x    y     thus
removing p y  correct 
therefore need additional condition guarantee gain extra value
node dropping  condition stated as  valuation   reaches e 
thus redirected reach value v  sibling e    q removed 
valuation   reaches leaf value v  v    however  condition complex
test practice  following identify two stronger conditions 
lemma   let b fodd  e  e  edges condition v    hold addition
conditions replacing target e    constant  b   result r  drop e    e    
interpretation mapb  i    mapb    i  
proof  consider valuation reaching target e     true value dominated
another valuation reaching target e     remove q   source e    valuation
reach target sibling e     v    value produced smaller value
target e     map preserved 
 
   

fiwang  joshi    khardon

lemma   let b fodd  e  e  edges p    v    hold addition
conditions replacing target e    constant  b   result r  drop e    e    
interpretation mapb  i    mapb    i  
proof  consider valuation   reaching target e     value dominated
another valuation reaching target e     remove q   source e    valuation
reach target sibling e     conditions p    v     valuation  
reach leaf greater value target e    otherwise branch g leading
negative value   maximum aggregation map changed 
 
summarize p    v    s  hold p    v    s  hold
replace target e    constant  replace v    p    v    hold
drop q   source e    completely 
following provide detailed analysis applicability variants r  
      r   special case r 
special case r  p   q  i e   e  e  siblings  context r 
considered focus single node n instead two edges  assuming e     nt
e    nf   rewrite conditions r  follows 
 p       b      x  nf n     x   y   ef nt     condition requires n reachable
nt reachable 
 p       b     r    v   nf n     v   w 
  ef nt     r variables appear
nt nf    v variables appear nf n   r  w
  variables
l n   r  v  
 p       b     u    v   nf n     v   w 
  ef nt     u variables appear
nt  since sibling e      e      v variables appear nf n   u  w
 
variables l n   u  v  
 v       min nt   max nf   
 v       nt constant 
 v       leaves diagram   nt nf non negative values 
conditions s  v    always true  previously analyzed special case
separate reduction operator named r   wang  joshi    khardon        
special case  may still useful check separately applying generalized
case r   provides large reductions seems occur frequently example domains 
important special case r  occurs l n  equality t   
variable occur fodd node n  case  condition p   
holds since choose value y  enforce equality subdiagram nt   therefore v    holds remove node n connecting parents
nt substituting t  diagram nt    note may need make copies
nodes this   section     introduce elaborate reduction handle
equalities taking maximum left right children 
      application order
cases several instances r  applicable  turns order
apply important  following  first example shows order affects
   

fifirst order decision diagrams relational mdps

p x  y  
q x  

p x  y  
q x  
  

p x  y  

q x  
 

   
 a 

p x  y  

  

 

q x  
 

q x    

q x  
  

 

 b 

 

q x  

p x  y  
  q x  
 
 d 

 c 

p x  y  

p x  y  
  

 

 

 

q x  
  

p x  y  
 

 

 

 e 

figure    example illustrating effect application order r  

number steps needed reduce diagram  second example shows
order affects final result 
consider fodd figure   a   r  applicable edges e     p x    y    t
e     p x    y    t   e      q x    t e      q x    t   reduce top
manner  i e   first apply r  pair  p x    y    t  p x    y    t   get fodd
figure   b   apply r   q x    t  q x    t   get
fodd figure   c   however  apply r  first  q x    t  q x    t thus getting
figure   d   r  cannot applied  p x    y    t  p x    y    t  p x    y    t
 p x    y    t negative leaves  case  diagram still reduced 
reduce comparing  q x    t  q x    t right part fodd  first
remove q x    get fodd shown figure   e   use neglect operator
remove p x    y     see example applying one instance r  may render
instances applicable may introduce possibilities reductions general
must apply reductions sequentially  wang        develops conditions
several instances r  applied simultaneously 
one might hope repeated application r  lead unique reduced result
true  fact  final result depends choice operators order
application  consider figure   a   r  applicable edges e     p x  t e     p y  t  
e      q x  t e      q y  t   reduce top manner  i e   first apply
r  pair  p x  t  p y  t   get fodd figure   b   cannot
reduced using existing reduction operators  including operator r  introduced below  
however  apply r  first  q x  t  q y  t get figure   c  
apply r  e     p x  t e     p y  t get final result figure   d  
clearly compact figure   b   interesting first example seems
   

fiwang  joshi    khardon

p x 
  

p x 
  

p y 

   q x 
  

   q y 
 

q y 
 

 

 

 a 

 b 

p x 
  

q x 

p x 
   q x 

p y 

    

   q x 
    

 d 

 c 

figure    example illustrating final result r  reductions order dependent 
suggest applying r  top manner  since takes fewer steps   second
seems suggest opposite  since final result compact   research
needed develop useful heuristics guide choice reductions application
order general develop complete set reductions 
note could consider generalizing r   figure   b   reach  q y  
clearly reach  p x  t  q x  t   since  p x  t  q x  t give better values  safely replace  q y  t    thus obtaining final result figure   d   theory generalize p    b      x  ef e      y     ef e       y n   ef e n   
 x variables ef e    y i variables ef e i     n  generalize
corresponding value condition v        n   min target e i    max target e     
generalize reachability value conditions similarly  however resulting
conditions expensive test practice 
      relaxation reachability conditions
conditions p    p    sufficient  necessary guarantee correct reductions  sometimes valuations need agree smaller set variables
intersection variables  see this  consider example shown figure   
b     intersection  x  y  z   however  guarantee b     need
agree either  x  y   x  z   intuitively agree variable x avoid
situation two paths p x  y  q x  p x  y  q x  h z  co exist  order
prevent co existence two paths p x  y  h z  p x  y  q x  h z   either
z well  change example little bit replace
   

fifirst order decision diagrams relational mdps

h z  h z  v   two minimal sets variables different size  one  x  y  
 x  z  v   result cannot identify minimum set variables
subtraction must either choose intersection heuristically identify minimal set 
example  using greedy procedure 



b

p x  y 

p x  y 

q x 
 

h z 
   

q x 
 

   

h z 
 

h z 
 

 

figure    example illustrating minimal set variables subtraction
unique 
     r   weak reduction unification
consider fodd b  let  v denote variables  let  x  y disjoint subsets  v  
cardinality  define operator r  b   x   y   replacing variables
 x corresponding variables  y   denote resulting fodd b  x  y  
result variables  v   x  following condition correctness r  
 v     leaves b  x  y   b non negative 
lemma   let b fodd  b   result r  b   x   y   v  holds 
interpretation mapb  i    mapb    i  
proof  consider valuation    v b  v   b  x  y   gives better value
valuation  therefore lose value operator  gain
extra value  consider valuation   variables b   reaching leaf node value
v  construct valuation    v b variables  x taking corresponding
value  y   reach leaf node b value  therefore map
changed unification 
 
figure    illustrates cases r  applicable r  not  apply
r   x   x    get fodd shown figure    b   since  b   a      b  becomes
result reduction  note unify way  i e   x   x     get
figure    c   isomorphic figure    b   cannot reduce original fodd
result   c   a       phenomenon happens since subtraction operation
 implemented apply  used reductions propositional therefore sensitive
variable names 
     r   equality reduction
consider fodd b equality node n labeled   x  sometimes drop n
connect parents sub fodd result taking maximum left
   

fiwang  joshi    khardon

p x  
p x  
p x  

 

x    x 

q x  
  

q x    
  
 a 

 

 

 
 b 

x   x 

p x  
q x  
  

 

 
 c 

figure     example illustrating r  

right children n  reduction applicable b satisfy following
condition 
 e       equality node n labeled   x least one x variable
appears neither nf node formula n  simplify description
reduction procedure below  assume x variable 
additionally make following assumption domain 
 d       domain contains one object 
assumption guarantees valuations reaching right child equality
nodes exist  fact needed proving correctness equality reduction operator 
first describe reduction procedure r  n   let bn denote fodd rooted
node n fodd b  extract copy bnt  and name bnt  copy   copy
bnf  bnf  copy  b  bnt  copy  rename variable x produce diagram
bn   copy  let bn    apply bn   copy  bnf  copy  max   finally drop node n b
connect parents root bn  obtain final result b     example shown
figure    
informally  extracting parts fodd rooted node n  one x  
 and renaming x part  one x    t  condition e   
assumption d    guarantee regardless value t  valuations reaching
parts  since definition map  maximize valuations  case
maximize diagram structure itself  calculating function
maximum two functions corresponding two children n  using
apply  replacing old sub diagram rooted node n new combined diagram 
theorem   proves affect map b 
one concern implementation simply replace old sub diagram
new sub diagram  may result diagram strong reductions applicable 
problem semantically  avoid need strong reductions
using apply implicitly performs strong reductions r  neglect  r  join  follows 
   

fifirst order decision diagrams relational mdps

let ba denote fodd resulting replacing node n b    bb
fodd resulting replacing node n   leaves node n   
final result b     ba bb  bb    bb bn    correctness apply two
forms calculating b   give map 

b x
 

p y 
q x 

x y
p y 
 

q x 

  

q x 

q x 
  

p x 
 

  

 b 

 

 a 

 c 
b x

q x 
 

 

 
 d 

 

p x 
q x 

  

q x 
 

 

 e 

figure     example equality reduction   a  fodd reduction 
node x   satisfies condition e    variable y   b  bnt  copy  nt extracted  
 c  bnt  copy renamed produce bn   copy   d  bnf  copy   e  final result
node n replaced apply bn   copy  bnf  copy  max 
following prove node n equality condition e    holds b
perform equality reduction r  without changing map interpretation
satisfying d     start properties fodds defined above  e g   b   bb   bb    let
n denote set valuations reaching node n let denote set valuations
reaching node n b  basic definition map following 
claim
 a 
 b 
 c 
 d 

  interpretation i 
  mapba  i      mapb  i    
n   mapba  i        
  mapbb  i        
n   mapbb  i        

claim   definition map  have 
claim   interpretation i 
 a    mapbb   i        
 b  n   mapbb   i      mapbn   i    
claim    claim    definition map have 

   

fiwang  joshi    khardon

claim   interpretation i 
 a    mapb    i      mapb  i    
 b  n   mapb    i      mapbn   i    
next prove main property reduction stating valuations reaching
node n b  old sub fodd rooted n new  combined  sub fodd produce
map 
lemma   let n set valuations reaching node n fodd b  interpretation satisfying d     maxn mapbn  i      maxn mapbn   i    
proof  condition e     variable x appear n f  n  hence value
n constrained  therefore partition valuations n disjoint
sets  n       valuation variables x   variables
x fixed value x take value domain i  assumption
d    guarantees every contains least one valuation reaching bnt least one
valuation reaching bnf b  note valuation reaches bnt   x satisfied
thus mapbnt  i      mapbn   copy  i     since x appear bnf

mapbn   copy  i    constant   therefore correctness
f
apply max mapbn  i      max mapbn   i    
finally  definition map  maxn mapbn  i      max max mapbn  i   
  max max mapbn   i      maxn mapbn  i    
 
lemma   let b fodd  n node condition e    holds  b   result
r  n   interpretation satisfying d     map b  i    mapb    i  
proof  let x   maxm mapb    i      maxn mapb    i     definition map  mapb    i    max x     however  claim    x   maxm mapb  i   
claim   lemma      maxn mapbn   i      maxn mapbn  i     thus
 
max x      mapb  i    mapb    i  
lemma   guarantees correctness  applying practice may important
avoid violations sorting order  which would require expensive re sorting
diagram   x variables sometimes replace new variable
name resulting diagram sorted  however always possible 
violation unavoidable  tradeoff performing reduction sorting
diagram ignoring potential reduction 
summarize  section introduced several new reductions compress diagrams significantly  first  r   generic strong reduction removes implied
branches diagram  three  r   r   r   weak reductions alter
overall map diagram alter map specific valuations  three
reductions complementary since capture different opportunities space saving 

   decision diagrams mdps
section show fodds used capture rmdp  therefore use
fodds represent domain dynamics deterministic action alternatives  probabilistic choice action alternatives  reward function  value functions 
   

fifirst order decision diagrams relational mdps

    example domain
first give concrete formulation logistics problem discussed introduction  example follows exactly details given boutilier et al          used
illustrate constructions mdps  domain includes boxes  trucks cities 
predicates bin box  city   in t ruck  city   on box  ruck   following
boutilier et al          assume on b  t  bin b  c  mutually exclusive 
box truck city vice versa  is  background knowledge includes
statements b  c  t  on b  t  bin b  c  b  c  t  bin b  c  on b  t   reward
function  capturing planning goal  awards reward    formula b  bin b  p aris 
true  box paris  thus reward allowed include constants
need completely ground 
domain includes   actions load  unload  drive  actions effect
preconditions met  actions fail probability  attempting
load  successful version loads executed probability       unsuccessful version loadf  effectively no operation  probability       drive action executed
deterministically  attempting unload  probabilities depend whether raining not  raining successful version unloads executed probability
     unloadf probability      raining unloads executed probability
     unloadf probability     
    domain dynamics
follow boutilier et al         specify stochastic actions randomized choice
among deterministic alternatives  domain dynamics defined truth value diagrams  tvds   every action schema a  a  predicate schema p  x  tvd
 a  a   p  x   fodd        leaves  tvd gives truth value p  x 
next state a  a  performed current state  call  a action parameters   x predicate parameters  variables allowed tvd 
reasoning behind restriction explained section      restriction sometimes sidestepped introducing action parameters instead variables 
truth value tvd valid fix valuation parameters 
tvd simultaneously captures truth values instances p  x  next state 
notice tvds different predicates separate  safely done even
action coordinated effects  not conditionally independent  since action alternatives
deterministic 
since allow action parameters predicate parameters  effects action
restricted predicates action arguments tvd expressive
simple strips based schemas  example  tvds easily express universal effects
action  see note p  x  true  x action a  a  tvd
 a  a   p  x   captured leaf valued    universal conditional effects
captured similarly  hand  since explicit universal quantifiers 
tvds cannot capture universal preconditions 
domain  tvd predicate p  x  defined generically figure    
idea predicate true true undone action
false brought action  tvds logistics domain
   

fiwang  joshi    khardon

p  x  
bring


undo
 

 

 

figure     template tvd

bin  b  c 
 

 b  t 

 b  t  

b  b 

t  t 
 

tin  t   c 
 

 

b  b 

b  b 

bin  b  c 
 

 

c  c 
 

 
 b 

bin  b  c  
 

tin  t  c  

 c 

c c 
 

 d 

t  t 
c  c 

 
 e 

 

 

 

tin  t  c 
t  t 

b  b 
t  t 

tin  t   c 

 
 a 

 b  t 

 

rain
   

bin  b  paris 

   

  

 f 

 
 g 

figure     fodds logistics domain  tvds  action choice  reward function   a  b  tvds bin b  c  on b    action choice
unloads b       c  d  tvds bin b  c  on b    action
choice loads b     c    note c must action parameter  d 
valid tvd   e  tvd in t  c  action choice drives t   c   
 f  probability fodd action choice unloads b       g  reward
function 

   

fifirst order decision diagrams relational mdps

running example given figure     tvds omitted figure
trivial sense predicate affected action  order simplify
presentation give tvds generic form sort diagrams using
order proposed section      tvds consistent ordering bin  
rain  notice tvds capture implicit assumption usually taken
planning based domains preconditions action satisfied
action effect 
notice utilize multiple path semantics maximum aggregation  predicate true true according one paths specified get disjunction
conditions free  use single path semantics blockeel de raedt
       corresponding notion tvd significantly complicated since single
path must capture possibilities predicate become true  capture that  must
test sequentially different conditions take union substitutions
different tests turn requires additional annotation fodds appropriate
semantics  similarly operation would require union substitutions  thus complicating representation  explain issues detail section    
introduce first order value iteration algorithm 
    probabilistic action choice
one consider modeling arbitrary conditions described formulas state
control natures probabilistic choice action  multiple path semantics makes
hard specify mutually exclusive conditions using existentially quantified variables
way specify distribution  therefore restrict conditions either propositional
depend directly action parameters  condition interpretation follows
exactly one path  since variables thus empty valuation  thus
aggregation function interact probabilities assigned  diagram showing
action choice unloads logistics example given figure     example 
condition propositional  condition depend action parameters 
example  assume result affected whether box big not 
diagram figure    specifying action choice probability 
big b  
rain

   

       

figure     example showing choice probability depend action parameters 
note probability usually depends current state  depend arbitrary properties state  with restriction stated above   e g   rain big b   
shown figure     allow arbitrary conditions depend predicates arguments restricted action parameters dependence complex  however 
allow free variables probability choice diagram  example  cannot
model probabilistic choice unloads b     depends boxes truck  
   

fiwang  joshi    khardon

e g   b  on b    b    b        otherwise       write fodd capture
condition  semantics fodd means path     selected max aggregation distribution cannot modeled way  clearly restriction 
conditions based action arguments still give substantial modeling power 
    reward value functions
reward value functions represented directly using algebraic fodds  reward
function logistics domain example given figure    

   value iteration fodds
following boutilier et al         define first order value iteration algorithm follows 
given reward function r action model input  set v    r  n     repeat
procedure rel greedy termination 
procedure   rel greedy
   action type a  x   compute 
a  
x 

qv n

  r   j  prob aj   x   regr vn   aj   x    

   

a  
x 

   qa
vn   obj max qvn   
   vn     maxa qa
vn  
notation steps procedure discussed section   except
work fodds instead case statements  note since reward function
depend actions  move object maximization step forward adding
reward function  i e   first
a  
x 

tv n

  j  prob aj   x   regr vn   aj   x    

followed
a  
x 

qa
vn   r obj max tvn   
later see object maximization step makes reductions possible  therefore moving step forward get savings computation  compute
updated value function way comprehensive example value iteration given
later section     
 puterman         case
value iteration terminates kvi   vi k    
 
need test values achieved two diagrams within    
   
formulations goal based planning problems use absorbing state zero
additional reward goal reached  handle formulation
one non zero leaf r  case  replace equation  
a  
x 

qv n

  max r  j  prob aj   x   regr vn   aj   x    

see correct  note due discounting max value always r  r
satisfied state care action  max would r  r  
state get value discounted future reward 
   

fifirst order decision diagrams relational mdps

note goal based domains  i e   one non zero
leaf  mean cannot disjunctive goals  means must
value goal condition equally 
    regressing deterministic action alternatives
first describe calculation regr vn   aj   x   using simple idea call block replacement  proceed discuss obtain result efficiently 
consider vn nodes fodd  node take copy corresponding tvd  predicate parameters renamed correspond
nodes arguments action parameters unmodified  br regress v n   a  x   fodd
resulting replacing node vn corresponding tvd  outgoing edges
connected      leaves tvd 
recall rmdp represents family concrete mdps generated choosing
concrete instantiation state space  typically represented number objects
types   formal properties algorithms hold concrete instantiation 
fix concrete instantiation state space  let denote state resulting
executing action a  x  state s  notice vn br regress vn   a  x   exactly
variables  following lemma 
lemma    let valuation variables vn  and thus variables
br regress vn   a  x     mapvn  s      mapbrregress vn  a  x    s    
proof  consider paths p  p followed valuation two diagrams 
definition tvds  sub paths p applied guarantee corresponding nodes
p take truth values s  p  p reach leaf value
obtained 
 
naive implementation block replacement may efficient  use block
replacement regression resulting fodd necessarily reduced moreover 
since different blocks sorted start result even sorted  reducing
sorting results may expensive operation  instead calculate result
follows  fodd vn traverse br regress vn   a  x   using postorder traversal
terms blocks combine blocks  step combine   fodds
parent block yet processed  so tvd binary leaves 
two children processed  so general fodds   call parent
bn   true branch child bt false branch child bf represent
combination  bn bt       bn   bf   
lemma    let b fodd bt bf fodds  bn fodd       
leaves  let b result using apply calculate diagram  bn bt      bn  bf   
interpretation valuation mapb  i      mapb  i    
proof  true since fixing valuation effectively ground fodd
paths mutually exclusive  words fodd becomes propositional clearly
combination using propositional apply correct 
 
high level description algorithm calculate br regress v n   a  x   block
combination follows 
   

fiwang  joshi    khardon

procedure   block combination br regress vn   a  x  
   perform topological sort vn nodes  see example cormen  leiserson  rivest 
  stein        
   reverse order  non leaf node n  its children bt bf already
processed   let bn copy corresponding tvd  calculate  bn bt      
bn   bf   
   return fodd corresponding root 
notice different blocks share variables cannot perform weak reductions
process  however  perform strong reductions intermediate steps since
change map valuation  process completed perform
combination weak strong reductions since change map
regressed value function 
blue  b 

 b  t 
 

big t 
on b t 
 

 

b  b 

big t 
 b  t 

t  t 

 
 a 

blue  b 

 

bin  b  c 
tin  t  c 

 

b  b 
t  t 

 

 
 b 

bin  b  c 
tin  t  c 
 

 
 c 

figure     example illustrating variables allowed tvds 
explain cannot variables tvds example illustrated figure     suppose value function defined figure    a   saying
blue block big truck block truck
value   assigned  figure    b  gives tvd on b    action loads 
c variable instead action parameter  figure    c  gives result
block replacement  consider interpretation domain  b    t    c    c    relations
 blue b     big t     bin b    c     in t    c      action loads b    t    reach
state    blue b     big t     on b    t     in t    c      gives us value    figure    c  b   b      t  evaluated gives value   valuation  b b    c c    t t    
choice c c  makes sure precondition violated  making c action parameter  applying action must explicitly choose valuation leads correct
value function  object maximization turns action parameters variables allows us
choose argument maximize value 
   

fifirst order decision diagrams relational mdps

    regressing probabilistic actions
regress probabilistic action must regress deterministic alternatives combine choice probability equation    discussed section    due
restriction rmdp model explicitly specifies finite number deterministic
action alternatives  replace potentially infinite sum equation   finite
sum equation    done correctly every state result equation  
correct  following specify done fodds 
recall prob aj   x   restricted include action parameters cannot include variables  therefore calculate prob aj   x  regr vn   aj   x   step     directly
using apply  however  different regression results independent functions
sum j  prob aj   x   regr vn   aj   x    must standardize apart different regression results adding functions  note action parameters still considered
constants stage   holds addition reward function  need
standardize apart complicates diagrams often introduces structure
reduced  performing operations first use propositional apply procedure
follow weak strong reductions 

v 

asucc x  
q  x 

p  x 
  

p  a 
 

 

a x 

 

q  a 
 

 a 

 
 b 
q  x  

q  x  
p  x      
x   x 

q  x  
 

p  x      
 

q  x  
 

 



q  x  
p  x  

 

x   x 
q  x  

 
 c 

   

figure     example illustrating need standardize apart 
figure    illustrates need standardize apart different action outcomes  action
succeed  denoted asucc  fail  denoted af ail  effectively no operation  
chosen probability      part  a  gives value function v     part  b  gives
tvd p  a  action choice asucc x    tvds trivial  part
 c  shows part result adding two outcomes standardizing apart
 to simplify presentation diagrams sorted   consider interpretation
domain        relations  q     p      seen  c   choosing x      i e 
   

fiwang  joshi    khardon

action a     valuation x       x      gives value     action  without
considering discount factor   obviously standardize apart  i e x     x    
leaf value     get wrong value  intuitively contribution
asucc value comes bring portion diagram af ails
contribution uses bindings undo portion two portions refer
different objects  standardizing apart allows us capture simultaneously 
lemma       discussion far have 
lemma    consider concrete instantiation rmdp  let vn value function
corresponding mdp  let a  x  probabilistic action domain 
a  
x 
qvn calculated equation   correct  is  state s  mapqa  x   s 
vn

expected value executing a  x  receiving terminal value v n  
    observations single path semantics

section     suggested single path semantics blockeel de raedt       
support value iteration well multiple path semantics  explanation
regression  use example illustrate this  suppose value function
defined figure    a   saying red block big city value  
assigned  figure    b  gives result block replacement action unloads b     
however correct  consider interpretation domain  b     b    t    c   
relations  red b     blue b     big c     bin b    c     in t    c     on b    t      note use
single path semantics  follow true branch root since b  c  bin b  c  true
 b b    c c     follow false branch red b  since b  c  bin b  c  red b 
satisfied  therefore get value    clearly  get value   instead
 b b    c c     impossible achieve value figure    b  single
path semantics  reason block replacement fails top node decides true
branch based one instance predicate really need true instances
predicate filter true leaf tvd 
correct problem  want capture instances true
undone instances made true one path  figure    c  gives one
possible way it  means variable renaming  stands union operator 
takes union substitutions  treated edge operations  note
coordinated operation  i e   instead taking union substitutions
b  b     c  c   separately need take union substitutions  b    c   
 b     c      approach may possible clearly leads complicated diagrams 
similar complications arise context object maximization  finally use
representation procedures need handle edge marking unions
substitutions approach look promising 
    object maximization
notice since handling different probabilistic alternatives action
separately must keep action parameters fixed regression process
added step   algorithm  step   maximize choice action
parameters  mentioned get maximization free  simply rename
   

fifirst order decision diagrams relational mdps

bin b  c  

bin b   c  

bin b  c 

b  b 

red b 

bin b  c  

on b   t  

b  b 

tin t  c  

big c 
 

 
 a 

red b  
big c  
 

red b  

on b  t  
 

 

 

on b  t  
tin t  c  

tin t  c    b c 
 b  c  
 b c 
 b  c  
 b  c  

big c  
 

b  b 

 b c 
 b  c  

 

red b 
big c 

 b 

 

 

 c 

figure     example illustrating union or 

action parameters using new variable names  to avoid repetition iterations 
consider variables  aggregation semantics provides maximization
definition selects best instance action  since constants turned
variables additional reduction typically possible stage  combination weak
strong reductions used  discussion following lemma 
lemma    consider concrete instantiation rmdp  let vn value function
corresponding mdp  let a  x  probabilistic action domain 
qa
vn calculated object maximization step   algorithm correct  is 
state s  mapqa  s  maximum expected values achievable executing
vn
instance a  x  receiving terminal value vn  
potential criticism object maximization essentially adding
variables diagram thus future evaluation diagram state becomes
expensive  since substitutions need considered   however  true
diagram remains unchanged object maximization  fact  illustrated
example given below  variables may pruned diagram process
reduction  thus long final value function compact evaluation efficient
hidden cost 
    maximizing actions
maximization vn     maxa qa
n   step     combines independent functions  therefore must first standardize apart different diagrams  follow
propositional apply procedure finally follow weak strong reductions 
clearly maintains correctness concrete instantiation state space 
   

fiwang  joshi    khardon

    order argument types
resume discussion ordering argument types extend predicate
action parameters  above  structure suggested operations
algorithm  section     already suggested order constants variables 
action parameters special constants object maximization become
variables object maximization  thus position allow behave
variables  therefore order constants action parameters 
note predicate parameters exist inside tvds  replaced domain
constants variables regression  thus need decide relative
order predicate parameters action parameters  put action parameters
predicate parameters latter replaced constant get order
violation  order useful  hand  put predicate parameters
action parameters instantiations predicate parameters possible 
notice substituting predicate parameter variable  action parameters
still need larger variable  as tvd   therefore  order
action parameters variables 
summarize  ordering  constants variables  predicate parameters case
tvds  action parameters  suggested heuristic considerations orders maximize potential reductions  avoid need re sorting diagrams 
finally  note want maintain diagram sorted times  need
maintain variant versions tvd capturing possible ordering replacements
predicate parameters  consider tvd figure    a   rename predicate parameters
x x  x  respectively  x  x    resulting sub fodd
shown figure    b  violates order  solve problem define another
tvd corresponding case substitution x substitution  
shown figure    c   case replacing x x  x    use tvd
figure    c  instead one figure    a  

on x  y 

on x   x  

on x  y 

p x 

p x  

p y 

p x  

p y 
 

 
 a 

 

p x 
 

 b 

 

 
 c 

figure     example illustrating necessity maintain multiple tvds 

    convergence complexity
since step procedure   correct following theorem 

   

fifirst order decision diagrams relational mdps

theorem   consider concrete instantiation rmdp  let vn value function
corresponding mdp n steps go  value vn   calculated
procedure   correctly captures value function n     steps go 
is  state s  mapvn    s  maximum expected value achievable n    
steps 
note rmdps problems require infinite number state partitions 
thus cannot converge v finite number steps  however  since algorithm
implements vi exactly  standard results approximating optimal value functions
policies still hold  particular following standard result  puterman        holds
algorithm  stopping criterion guarantees approximating optimal value functions
policies 
theorem   let v optimal value function let vk value function calculated
relational vi algorithm 
    r s  kvn v k n
    kvn   vn k

   
 

 m
 
log     

log  

 

kvn   v k  

algorithm maintains compact diagrams  reduction diagrams guaranteed domains  therefore provide trivial upper bounds terms
worst case time complexity  notice first every time use apply procedure
size output diagram may large product size inputs 
must consider size fodd giving regressed value function  block
replacement o n   n size current value function  sorted
sorting may require exponential time space worst case  example 
bryant        illustrates ordering may affect size diagram  function
 n arguments  function x  x    x  x      x n  x n requires diagram
 n     nodes  function x  xn     x  xn       xn x n requires  n   nodes 
notice two functions differ permutation arguments 
x  x    x  x      x n  x n result block replacement clearly sorting
requires exponential time space  true block combination procedure
method calculating result  simply output exponential
size  case heuristics change variable ordering  propositional adds
 bryant         would probably useful 
assuming tvds  reward function  probabilities size c  action
action alternatives  current value function vn n nodes  worst case
space expansion regression apply operations  overall size result
 
time complexity one iteration o c  n        however note
worst case analysis take reductions account  method
guaranteed always work efficiently  alternative grounding mdp
unmanageable number states deal with  despite high worst case complexity
method provides potential improvement  next example illustrates  reductions
substantially decrease diagram size therefore save considerable time computation 
   

fiwang  joshi    khardon

    comprehensive example value iteration
figure    traces steps application value iteration logistics domain 
tvds  action choice probabilities  reward function domain given figure     simplify presentation  continue using predicate ordering bin  
rain introduced earlier  
given v    r shown figure    a   figure    b  gives result regression
v  unloads b     block replacement  denoted regr v    unloads b      
figure    c  gives result multiplying regr v    unloads b      choice
probability unloads p r unloads b      
figure    d  gives result p r unloadf  b      regr v    unloadf  b       notice diagram simpler since unloadf change state tvds
trivial 
figure    e  gives unreduced result adding two outcomes unload b      i e  
result adding  p r unloads b     regr v    unloads b        p r unloadf  b     
regr v    unloadf  b        note first standardize apart diagrams unloads b    
unloadf  b     respectively renaming b b  b    action parameters b
stage considered constants change them  note
recursive part apply  addition   performed reductions  i e   removing node
rain children lead value    
figure    e   apply r  node bin b    p aris  left branch 
conditions
p      b    bin b    p aris    b    b    bin b    p aris  bin b    p aris   
v     min bin b    p aris t        max bin b    p aris f       
v     bin b    p aris t constant
hold  according lemma   lemma   drop node bin b    p aris  connect
parent bin b    p aris  true branch  figure    f   gives result reduction 
next  consider true child bin b    p aris  true child root 
conditions
p      b    b    bin b    p aris  bin b    p aris    b    bin b    p aris   
v     min bin b    p aris t        max bin b    p aris t        
v     min bin b    p aris t        max bin b    p aris f      
hold  according lemma   lemma    drop node bin b    p aris 
connect parent bin b    p aris  bin b    p aris f   figure    g  gives result
unload b  t  
reduction get fully reduced diagram  tv 
 
next step perform object maximization maximize action parameters
b get best instance action unload  note b
become variables  perform one reduction  drop equality
right branch r   figure    h  gives result object maximization  i e  
unload b  t  
obj max tv 
   note renamed action parameters avoid
repetition iterations 
unload b  t  
figure    i  gives reduced result multiplying figure    h   obj max tv 
  
       adding reward function  result qunload
 
 
   details change substantially use order suggested section      where equality
first  

   

fifirst order decision diagrams relational mdps

bin  b  paris 

v 

  

bin  b  paris 
  

b  b 

b  b 
 b  t  

tin  t   paris 

tin  t   paris 

  

 

 

 

 

 

 d 

 c 

bin  b   paris 
  

 

rain

 

rain

 b 

bin  b   paris 

bin  b  paris 

 b  t  

 
 a 

bin  b  paris 

bin  b   paris 
  

bin  b   paris 

bin  b   paris 

rain
b   b 
 
 b   t  

 

tin  t   paris 
  

rain

b   b 

b   b 
 b   t  

 b   t  

     

 b   t  

tin  t   paris 

tin  t   paris 
 

rain

b   b 

  

tin  t   paris 

rain

 

     

 

 e 

 f 

bin  b   paris 
  

bin  b   paris 

b   b 
 b   t  

 

q unload

 b   t  

  

 

       
 h 

v 

       
 l 

 

bin  b  paris 

 

  

tin  t  paris 

 b  t  

 

tin  t   paris 

rain

q

 i 

b  b 

 b  t 

tin  t  paris 

 j 

 

 k 

bin  b  paris 

bin  b  paris 
  

 

drive
 

rain

 
 g 

  

tin  t  paris 

 

 

bin  b  paris 

 b  t 

  

rain
 

q load

bin  b  paris 

tin  t   paris 

tin  t   paris 
rain

 

rain

tin  t  paris 

t  t 
 

 

on b  t 

tin  t  paris 
 

rain
       

 

rain
       



b b 

  



 



 

 
 

tin  t  paris 
 

rain
       
 n 

 m 

figure     example value iteration logistics domain 

   

fiwang  joshi    khardon

calculate qload
q drive way results shown figure    j 
 
figure    k  respectively  drive tvds trivial calculation
relatively simple  load  potential loading box already paris dropped
diagram reduction operators process object maximization 
figure    l  gives v    result maximizing qunload
  qload
qdrive
 
 
 
 
standardized apart diagrams  maximized them  reduced
result  case diagram unload dominates actions  therefore q unload
 
becomes v    value function first iteration 
start second iteration  i e   computing v  v    figure    m  gives
result block replacement regression v   action alternative unloads b     
note sorted tvd on b    obeys ordering chosen 
however  diagram resulting block replacement sorted 
address use block combination algorithm combine blocks bottom
up  figure    n  illustrates combine blocks in t  p aris   tvd 
two children  processed general fodds  combine
in t  p aris  two children  on b  t t processed  since on b  t f     
combine on b  t  two children next step block combination 
continuing process get sorted representation regr v    unloads b      
    extracting optimal policies
one way represent policies fodds  simply note
policy represented implicitly set regressed value functions  value
iteration terminates  perform one iteration compute set q functions
using equation   
then  given state s  compute maximizing action follows 
   q function qa  x    compute mapqa  x   s    x considered variables 
   maximum map obtained  record action name action parameters  from
valuation  obtain maximizing action 
clearly implements policy represented value function  alternative
approach represents policy explicitly developed context policy
iteration algorithm  wang   khardon        

   discussion
adds used successfully solve propositional factored mdps  work gives one
proposal lifting ideas rmdps  general steps similar  technical
details significantly involved propositional case  decision diagram
representation combines strong points sdp rebel approaches rmdp 
one hand get simple regression algorithms directly manipulating diagrams 
hand get object maximization free rebel  get space saving
since different state partitions share structure diagrams  possible disadvantage
compared rebel reasoning required reduction operators might complex 
   

fifirst order decision diagrams relational mdps

terms expressiveness  approach easily capture probabilistic strips style
formulations rebel  allowing flexibility since use fodds capture
rewards transitions  example  representation capture universal effects
actions  hand  limited sdp since cannot use arbitrary
formulas rewards  transitions  probabilistic choice  example cannot express
universal quantification using maximum aggregation  cannot used reward
functions action preconditions  approach capture grid world rl domains
state based reward  which propositional  factored form since reward
described function location 
contrasting single path semantics multiple path semantics see
interesting tension choice representation task  multiple path method
directly support state partitions  makes awkward specify distributions
policies  since values actions must specified leaves   however 
semantics simplifies many steps easily supporting disjunction maximization
valuations crucial value iteration likely lead significant saving
space time 
implementation empirical evaluation progress  precise choice
reduction operators application crucial obtain effective system  since
general tradeoff run time needed reductions size resulting
fodds  apply complex reduction operators get maximally reduced fodds 
takes longer perform reasoning required  optimization still open issue
theoretically empirically  additionally  implementation easily incorporate
idea approximation combining leaves similar values control size
fodds  st aubin et al          gives simple way trading efficiency
accuracy value functions 
many open issues concerning current representation  results
fodds give first step toward complete generalization adds  crucially
yet semantically appropriate normal form important simplifying reasoning 
one define normal form  cf   garriga et al         treatment conjunctions 
clear calculated incrementally using local operations adds 
would interesting investigate conditions guarantee normal form useful set
reduction operators fodds 
another possible improvement representation modified allow
compression  example allow edges rename variables traversed
compress isomorphic sub fodds illustrated figure    c   another
interesting possibility copy operator evaluates several copies predicate  with
different variables  node illustrated figure     constructs
usable one must modify fodd mdp algorithmic steps handle diagrams
new syntactic notation 

   conclusion
paper makes two main contributions  first  introduce fodds  generalization
adds  relational domains may useful various applications  developed
calculus fodds reduction operators minimize size many open
   

fiwang  joshi    khardon

p  x  p  y 

p  x 
q  x 

 

q  x 

p  y   

f  y   

f  y   
 

 

 

 

 

figure     example illustrating copy operator 

issues regarding best choice operators reductions  second contribution
developing fodd based value iteration algorithm rmdps potential
significant improvement previous approaches  algorithm performs general
relational probabilistic reasoning without ever grounding domains proved
converge abstract optimal value function solution exists 

references
bahar  r  i   frohm  e  a   gaona  c  m   hachtel  g  d   macii  e   pardo  a     somenzi 
f          algebraic decision diagrams applications  proceedings
international conference computer aided design  pp         
bellman  r  e          dynamic programming  princeton university press 
blockeel  h     de raedt  l          top induction first order logical decision trees 
artificial intelligence              
boutilier  c   dean  t     goldszmidt  m          stochastic dynamic programming
factored representations  artificial intelligence                
boutilier  c   dean  t     hanks  s          decision theoretic planning  structural assumptions computational leverage  journal artificial intelligence research 
        
boutilier  c   dearden  r     goldszmidt  m          exploiting structure policy construction  proceedings international joint conference artificial intelligence 
pp           
boutilier  c   reiter  r     price  b          symbolic dynamic programming first order
mdps  proceedings international joint conference artificial intelligence 
pp         
bryant  r  e          graph based algorithms boolean function manipulation  ieee
transactions computers  c                
bryant  r  e          symbolic boolean manipulation ordered binary decision diagrams  acm computing surveys                 
cormen  t  h   leiserson  c  e   rivest  r  l     stein  c          introduction algorithms  mit press 
   

fifirst order decision diagrams relational mdps

driessens  k   ramon  j     gartner  t          graph kernels gaussian processes
relational reinforcement learning  machine learning                  
dzeroski  s   de raedt  l     driessens  k          relational reinforcement learning 
machine learning          
feng  z     hansen  e  a          symbolic heuristic search factored markov decision
processes  proceedings national conference artificial intelligence  pp 
       
fern  a   yoon  s     givan  r          approximate policy iteration policy language
bias  international conference neural information processing systems 
fern  a   yoon  s     givan  r          approximate policy iteration policy language
bias  solving relational markov decision processes  journal artificial intelligence
research            
garriga  g   khardon  r     de raedt  l          mining closed sets multi relational
data  proceedings international joint conference artificial intelligence 
pp         
gretton  c     thiebaux  s          exploiting first order regression inductive policy
selection  proceedings conference uncertainty artificial intelligence 
pp         
groote  j  f     tveretina  o          binary decision diagrams first order predicate
logic  journal logic algebraic programming          
gromann  a   holldobler  s     skvortsova  o          symbolic dynamic programming
within fluent calculus  proceedings iasted international conference
artificial computational intelligence 
guestrin  c   koller  d   gearhart  c     kanodia  n       a   generalizing plans new
environments relational mdps  proceedings international joint conference
artificial intelligence  pp           
guestrin  c   koller  d   par  r     venktaraman  s       b   efficient solution algorithms
factored mdps  journal artificial intelligence research             
hansen  e  a     feng  z          dynamic programming pomdps using factored
state representation  proceedings international conference artificial
intelligence planning systems  pp         
hoey  j   st aubin  r   hu  a     boutilier  c          spudd  stochastic planning using decision diagrams  proceedings conference uncertainty artificial
intelligence  pp         
hoolldobler  s   karabaev  e     skvortsova  o          flucap  heuristic search planner
first order mdps  journal artificial intelligence research             
kersting  k   otterlo  m  v     de raedt  l          bellman goes relational  proceedings
international conference machine learning 
mcmillan  k  l          symbolic model checking  kluwer academic publishers 
   

fiwang  joshi    khardon

puterman  m  l          markov decision processes  discrete stochastic dynamic programming  wiley 
rivest  r  l          learning decision lists  machine learning                
sanghai  s   domingos  p     weld  d          relational dynamic bayesian networks 
journal artificial intelligence research             
sanner  s     boutilier  c          approximate linear programming first order mdps 
proceedings conference uncertainty artificial intelligence 
sanner  s     boutilier  c          practical linear value approximation techniques firstorder mdps  proceedings conference uncertainty artificial intelligence 
sanner  s     boutilier  c          approximate solution techniques factored first order
mdps  proceedings international conference automated planning
scheduling 
schuurmans  d     patrascu  r          direct value approximation factored mdps 
international conference neural information processing systems  pp           
st aubin  r   hoey  j     boutilier  c          apricodd  approximate policy construction using decision diagrams  international conference neural information
processing systems  pp           
wang  c          first order markov decision processes  tech  rep  tr         computer
science department  tufts university 
wang  c   joshi  s     khardon  r          first order decision diagrams relational
mdps  proceedings international joint conference artificial intelligence 
pp           
wang  c     khardon  r          policy iteration relational mdps  proceedings
conference uncertainty artificial intelligence 

   


