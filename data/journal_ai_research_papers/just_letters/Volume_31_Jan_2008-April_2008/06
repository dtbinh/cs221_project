journal artificial intelligence research                  

submitted        published      

exploiting subgraph structure
multi robot path planning
malcolm r  k  ryan

malcolmr cse unsw edu au

arc centre excellence autonomous systems
university new south wales  australia

abstract
multi robot path planning difficult due combinatorial explosion search
space every new robot added  complete search combined state space soon
becomes intractable  paper present novel form abstraction allows
us plan much efficiently  key abstraction partitioning
map subgraphs known structure entry exit restrictions
represent compactly  planning becomes search much smaller space subgraph
configurations  abstract plan found  quickly resolved correct
 but possibly sub optimal  concrete plan without need search  prove
technique sound complete demonstrate practical effectiveness
real map 
contending solution  prioritised planning  evaluated shown similar
performance albeit cost completeness  two approaches necessarily
conflicting  demonstrate combined single algorithm outperforms either approach alone 

   introduction
many scenarios require large groups robots navigate around shared
environment  examples include  delivery robots office  hada   takase        
warehouse  everett  gage  gilbreth  laird    smurlo         shipping yard  alami  fleury 
herrb  ingrand    robert         mine  alarie   gamache         even virtual
armies computer wargame  buro   furtak         case many robots
independent goals must traverse shared environment without colliding
one another  planning path single robot usually consider
rest world static  world represented graph called
road map  path planning problem amounts finding path road map 
reasonably efficient algorithms exist  however  multi robot scenario world
static  must avoid collisions obstacles  robots 
centralised methods  barraquand   latombe         treat robots single composite entity  scale poorly number robots increases  decoupled methods
 lavalle   hutchinson        erdmann   lozano perez         first plan
robot independently resolve conflicts afterwards  prove much faster incomplete many problems require robots deliberately detour optimal
path order let another robot pass  even priority ordering used  van den berg
  overmars         requiring low priority robots plan avoid high priority robots 
problems found cannot solved priority ordering 

c
    
ai access foundation  rights reserved 

firyan

realistic maps common structures roads  corridors open spaces
produce particular topological features map constrain possible interactions robots  long narrow corridor  instance  may impossible one robot
overtake another robots must enter exit first in first out order 
hand  large open space may permit many robots pass simultaneously
without collision 
characterise features particular kinds subgraphs occurring
road map  decompose map collection simple subgraphs 
build plans hierarchically  first planning movements one subgraph another 
using special purpose planners build paths within subgraph 
paper propose abstraction  limit considering
homogeneous group robots navigating using shared road map  identify particular
kinds subgraphs road map place known constraints ordering robots
pass them  use constraints make efficient planning algorithms
traversing kind subgraph  combine local planners hierarchical
planner solving arbitrary problems 
abstraction used implement centralised prioritised planners 
demonstrate paper  unlike heuristic abstractions  method
sound complete  is  used centralised search guaranteed find
correct plan one exists  guarantee cannot made prioritised search
used  however two stage planning process means prioritised planner
abstraction often find plans would available otherwise  experimental
investigation shows approach effective maps sparsely connected
graph representations 

   problem formulation
assume work provided road map form graph
g    v  e  representing connectivity free space single robot moving around
world  e g  vertical cell decomposition visibility graph  lavalle        
set robots r    r            rk   shall consider homogeneous  single map
suffices all  shall assume starting locations goals lie road map 
further  shall assume map constructed collisions occur
one robot entering vertex v time another robot occupying  entering
leaving vertex  robots occupying vertices map affect movement 
appropriate levels underlying control assumptions satisfied
real world problems 
simple centralised approach computing plan proceeds follows  first  initialise
every robot starting position  select robot move neighbouring vertex 
checking first robot currently occupying vertex  continue fashion  selecting moving one robots step goal  pseudocode
process shown algorithm    code presented non deterministic algorithm  choice points indicated choose operator  backtracking required
fail command encountered  practice  search algorithm depth first 
breadth first a  search necessary evaluate alternative paths presents 

   

fiexploiting subgraph structure multi robot path planning

algorithm   simple centralised planning algorithm 
   function plan g  a  b 
  
  b
  
return hi
  
end
  
choose r r
  
select vf   a vf     r
  
choose vt  v    vf   v  g 
  
a vt       
  
fail
   
else
   
a vf    
   
a vt   r
   
return  r  vf   vt   plan g  a  b 
   
end
    end function

  build plan b graph g 
  nothing do 
  choose robot 
  find location 
  choose edge 
  destination occupied  backtrack 
  move robot vf vt  
  recurse 

algorithm complete search composite space gk   g g g 
k    r  robots  eliminating vertices represent collisions robots 
size composite graph given by 




fiv  gk  fi   n pk
 

n 
 n k  




k
fie g  fi   k  e g    n   p k  
  k  e g  

 n    
 n k    

n    v  g   k    r   running time algorithm depend
search algorithm used  expected long moderately large values
n k 

   subgraph abstraction
consider problem shown figure    road map contains    vertices    edges 
  robots plan for  so  according formulae  composite
graph                vertices                      edges  small map
expanded large search problem  human mind obvious lot
arrangements equivalent  important exact positions robots 
ordering 
consider subgraph labeled x  recognise subgraph stack  is  robots
move subgraph last in first out  lifo  order  robots inside
stack cannot change order without exiting re entering stack 
goal reverse order robots x  know immediately cannot done
without moving robots stack re enter opposite
order  robots right order  rearranging right positions
   

firyan

y 

x 

x 


x 

x 

x 

y 

y 

y 

y 

y 



z 

z 

z 

z 

z 

z

x 

c

b

x

z 

figure    planning problem illustrating use subgraphs 
trivial  thus make distinction arrangement robots  in
specify exactly vertex robot occupies  configuration stack  in
interested order  
x   vertices  robots stack    pm  
      m   possible arrangements  total number arrangements is 
 

p        p        p      p                        
     

terms deciding whether robot leave stack  however  need know
order  need represent                           different configurations
stack 
subgraphs z stacks  applying analysis three  find
represent abstract state space    different states      possible
transitions states  moving top most robot one stack onto another  
dramatically smaller composite map space above 
stack simple kind subgraph need larger collection canonical
subgraphs represent realistic problems  key features looking follows 
   computing transitions subgraph require knowledge exact arrangement robots within subgraph  abstract configuration
 in case  order  
   two arrangements robots share configuration  transforming one
done easily without search 
   therefore planning need done configuration space  significantly
smaller 
later introduce three subgraph types cliques  halls rings
share properties readily found realistic planning problems  first
need formalise ideas subgraph planning 

   

fiexploiting subgraph structure multi robot path planning

   definitions
section outline concepts use later paper  complete formal
definition terms provided appendix  along proof soundness
completeness subgraph planning process 
given map represented graph g partition set disjoint subgraphs
s            sm   subgraphs induced  i e  edge exists two vertices
subgraph exists g 
arrangement robots g   to   partial function   v  g  r 
represents locations robots within g  robot r vertex v  write a v    r 
speak arrangement robots within subgraph s  denote
arrangements lowercase roman letters a  b
configuration subgraph set equivalent arrangements robots within s 
two arrangements equivalent exists plan move robots one
without robots leaving subgraph  denote configuration subgraph sx
cx   configuration whole map represented tuple subgraph
configurations    c            cm   
two operators operate configurations  representing robot
entering leaving subgraph respectively  robot r moves two subgraphs sx sy configurations change depending identity edge  u  v 
robot traveled  write 
c x cx  r  u  
c y cy  r  v 
complex subgraphs possible transition result several possible configurations  operators return sets  possible transition
impossible particular configuration  case operation returns empty
set 
abstract plan defined sequence transitions intermediate
configurations   every abstract plan two arrangements exists least one
corresponding concrete plan  vice versa  subgraph transitions concrete
plan must exist abstract plan  equivalence arrangements configuration
guarantees existence intermediate steps  see appendix complete
proof 

   subgraph planning
construct planning algorithm searches space abstract plans  algorithm     procedure much before  first compute configuration
tuple initial arrangement  extend plan one step time  step
consists selecting robot r moving subgraph currently occupies sx
neighbouring subgraph sy reduced graph x  along connecting edge  u  v  
transition possible plan step  s   u  v   applicable  is  may
result number different configurations subgraph entered  need choose
one create configuration tuple next step  applicability test
selection subsequent configurations performed lines       abstractplan 
   

firyan

abstract plan extended step step fashion reaches configuration
tuple matches goal arrangement  resulting abstract plan resolved
concrete plan  transition abstract plan build two short concrete plans
one move robot outgoing vertex transition  one make sure
incoming vertex clear subgraph appropriately arranged create subsequent
configuration  since two plans separate subgraphs  combined
parallel  final step rearrange robots goal arrangement  again 
done parallel subgraphs 
abstractplan written non deterministic program  including choicepoints  search algorithm breadth first depth first search needed examine
possible set choices ordered fashion  search complete
abstract plan guaranteed found  one exists theorem
planning algorithm sound complete  note resolution phase
planner entirely deterministic  search needed abstract plan
found 
    subgraph methods
efficiency algorithm relies able compute several functions without
lot search 
exit compute c  r  u   testing possible robot exit subgraph
determining resulting configuration s  
enter compute c  r  v   testing possible robot enter subgraph
determining resulting configuration s  
terminate compute b s c  testing possible robots subgraph
move terminating positions 
resolveexit build plan rearranging robots subgraph allow one exit 
resolveenter build plan rearranging robots subgraph allow one
enter 
resolveterminate build plan rearranging robots subgraph
terminating positions 
key efficient subgraph planning carefully constrain allowed structure
subgraphs partition  functions simple implement
require expensive search  advantage approach functions
always computed based arrangement robots within particular
subgraph  relying positions robots elsewhere 

   subgraph structures
key process therefore selection subgraph types  abstractions
need chosen that 
   

fiexploiting subgraph structure multi robot path planning

v 

v 

v 

v 

vk

v 

 a  stack

v 

vk

 b  hall

v 

v 

v 

v 

v 

v 

v 

v 

 c  clique

 d  ring

figure    examples four different subgraph structures 

   commonly occurring real road maps 
   easy detect extract road map 
   abstract large portion search space 
   computing legality transitions fast  sound complete 
   resolving abstract plan concrete sequence movements efficient 
paper present four subgraph types  stacks  halls  cliques rings  satisfy
requirements  following analysis  let n number vertices
subgraph k number robots occupying subgraph action takes
place 
    stacks
stack  figure   a   represents narrow dead end corridor road map 
one exit narrow robots pass one another  robots must enter leave
last in first out order  one simplest subgraphs occur often
real maps  serves easy illustration subgraph methods  formally
consists chain vertices  linked predecessor successor 
vertex one end chain  called head  connected subgraphs
entrances exits happen there 
configuration stack corresponds ordering robots reside it 
head down  robots stack cannot pass other  ordering cannot
changed without robots exiting re entering stack 

   

firyan

      enter
robot always enter stack long stack full  one new configuration created  adding robot front ordering  computation
done o    time 
      exit
robot exit stack top robot ordering  one new
configuration created  removing robot ordering  computation
done o    time 
      terminate
determine whether termination possible  need check order robots
current configuration terminating arrangement  operation
takes o k  time 
      resolveenter
rearranging robots inside stack simple since know ordering constant 
vacate top stack  the possible entrance point  move robots deeper
stack  as necessary   guaranteed room  since entering full stack
permitted  worst takes o k  time 
      resolveexit
robot exits stack  abstract planner already determined
first robot stack others head vertex  simply move
stack head  out  robots need moved  worst
takes o n  time 
      resolveterminate
finally  moving robots terminating positions done top to bottom order 
robot terminating position move upwards without interference 
robot terminating position  robots may need moved lower
order clear path  approach sound  since terminating positions
robots must stack  or else ordering would different   process
o nk  total worst case running time 
    halls
hall generalisation stack  figure   b    stack  narrow corridor
permit passing  hall may multiple entrances exits along
length  formally consists single chain vertices  one joined predecessor
successor  must edges vertices hall  may
edges connecting subgraphs node hall  halls much
commonly occurring structures  still maintain property stacks  robots

   

fiexploiting subgraph structure multi robot path planning

j  
v 

v 

v 

v 

v 


v 
b

c


j  
v 

v 

v 

v 

v 
b



v 
c


j  
v 


v 

v 

v 

b

v 

v 

c



figure    example entering hall subgraph  k      n          robot
enter three possible sequence positions j          j     

cannot reordered without exiting re entering  thus  stacks  configuration
hall corresponds order robots occupying it  one end hall
other 
      enter
robot enter hall long full  configurations generated
entrance depend three factors     size hall n     number robots
already hall k     index vertex enters  ranging  
n  
figure   shows entering hall result several different configurations 
matter robots already hall arranged  left right
entrance  entering robot moves in  enough space hall either
side entrance vertex  new robot inserted point ordering 
space limited  as example  may possible move robots
one side another  limiting possible insertion points 
given three variables k  n  above  compute maximum minimum
insertion points as 
j min i    k 
j max    k  n i  

   

firyan

creating new configuration matter inserting new robot
ordering appropriate point  since list robots needs copied order
this  takes o k  time new configuration 
      exit
whether robot exit hall via given edge depends several factors    
size hall n     number robots hall k     index vertex
exits  from   k      index j robot ordering  from   k   exit
possible if 
j n  k j 
exit possible one resulting configuration  previous ordering robot
removed  takes o k  time compute 
      terminate
checking termination halls stacks  test order
robots final arrangement matches current configuration  done
o k  time k robots hall 
      resolveenter
resolve entrance hall need know subsequent configurations
aiming generate  know proper insertion point entering robot 
robots insertion point shuffled one direction one side
entry vertex  rest side  worst take o nk  time 
      resolveexit
resolving exit involves moving robot hall exit vertex  shuffling
robots way  worst case  robots shuffle
one end hall other  takes o nk  time 
      resolveterminate
resolveterminate hall identical stack  described above 
    cliques
clique  figure   c   represents large open area map many exit points
 vertices  around perimeter  robots cross directly vertex another 
long clique full  robots inside shuffled way allow
happen 
formally clique totally connected subgraph  cliques quite different properties
halls stacks  long least one empty vertex clique  possible
rearrange arbitrarily  configuration clique  circumstance 
set robots contains 

   

fiexploiting subgraph structure multi robot path planning

however special set configurations clique locked 
occurs number robots clique equals number vertices 
impossible clique rearranged  configuration locked clique
explicitly record position robot 
      enter
clique always entered long full  clique one
vacant vertex  single new configuration entering robot added
set occupants  clique one space remaining  entering robot locks
clique  theory  point necessary make new configuration every
possible arrangement occupying robots  with entering robot always vertex
enters  
practice  efficient create single locked configuration
records locking robot vertex  leaves positions unspecified 
permutation robots possible  exact details configuration need
pinned next action  either exit terminate  requires be 
form least commitment  significantly reduce branching factor
search 
performing test creating new configuration takes o k  time k robots
clique 
      exit
clique unlocked robot exit vertex new configuration
created simply removing robot set occupants 
clique locked robot exit specific vertex occupies  resulting configuration unlocked exact locations robots
discarded 
least commitment version  locking robot constrained exit vertex
every robot exit vertex except one occupied locking
robot 
performing test creating new configuration takes o k  time k robots
clique 
      terminate
unlocked configuration  checking termination simply consists making sure
 and only  required occupants clique  locked configuration
robots must terminating positions  as possibility rearranging
them   least commitment version locking robot must terminating vertex  assume robots places  thus
committing choice configuration delayed earlier  
performing test takes o k  time k robots clique 

   

firyan

      resolveenter
entrance vertex occupied robot wishes enter simply move
occupant directly another vacant vertex clique  since every vertex connected
every other 
using least commitment entering robot locks clique need
look ahead plan see next action involving clique  exit transition
need move exiting robot exit vertex  before clique locked  
subsequent exit  meaning robots terminating clique 
need rearrange terminating positions point 
amortise cost rearrangements subsequent call resolveexit
resolveterminate treat operation taking o    time 
      resolveexit
clique full time exit assume exiting robot already
exit vertex nothing needs done  hand  clique full
may robot exit vertex  must moved there  exit vertex
already occupied another robot  moved another unoccupied vertex 
movements done directly  clique totally connected  operation
takes o    time 
      resolveterminate
clique locked assume robots already appropriately
arranged terminal positions work needs done  otherwise
robots may need rearranged  simple way proceed follows 
robot place  first vacate terminating position moving occupant
another unoccupied vertex  move terminating robot vertex  robot
moved way move again  process correct
may produce longer plans necessary  upside takes o n  time 
    rings
ring  figure   d   resembles hall ends connected  formally  subgraph
vertices v  s     v            vn   induced edges e s  satisfying 
 vi   vj   e s  iff  i j     mod n 
hall  ordering important ring  robots ring cannot pass one another
cannot re order themselves  can  however  rotate ordering  provided
ring full   thus ring size   more  sequence hr    r    r  equivalent
hr    r    r  hr    r    r  i  equivalent sequences represent configuration 
cliques  rings locked full  locked ring cannot rotated 
ring size three sequences hr    r    r  hr    r    r  equivalent 
represent two locked configurations different properties 

   

fiexploiting subgraph structure multi robot path planning

      enter
robot may always enter ring provided full  k robots already
occupying ring  k possible configurations result  or one k
zero   one possible insertion point 
entering robot locks ring must record specific positions
robot ring  still produce k different configurations
robots cannot arbitrarily rearranged  unlike cliques 
possible produce least commitment versions enter rings
cliques  again  significantly reduce branching factor search 
details involved wish enter paper 
operation takes o k  time new configuration generated 
      exit
ring locked robot exit recorded position  otherwise
exit vertex  robot removed sequence produce resultant
configuration  new configuration unlocked position information
discarded  done o k  time k robots ring 
      terminate
check termination possible need see order robots around ring
terminal arrangement matches current configuration  configuration
locked rotations allowed  otherwise match must exact  test
done o k  time k robots ring 
      resolveenter
robot enter ring  need first rearrange entry
vertex empty nearest robots either side vertex provide correct
insertion point subsequent configuration  selected enter above  may
require shuffling robots one way another  much fashion stack
hall  worst case take o nk  operations k robots ring n vertices 
      resolveexit
ring locked robot exiting must already exit position nothing needs
done  otherwise  unlocked ring  robots may need shuffled around
ring order move robot exit  worst case take o nk  operations
k robots ring n vertices 
      resolveterminate
ring locked robots must already terminating positions 
guaranteed abstract planner  otherwise need rotated correct
positions  one robot moved correct vertex  rest ring
treated stack resolveterminate method described used 
o nk  worst case running time k robots ring n vertices 
   

firyan

    summary
four subgraphs halls rings powerful  subgraphs
common structured maps man made environments  found often
purely random graphs  consider  shortest path unweighted graph hall  
halls  rings cliques significant size found many realistic planning problems 
importantly  structures well constrained enough six procedures
planning outlined implemented efficiently deterministically  without
need search  cases clique ring  resolution methods
describe sometimes sacrifice path optimality speed  could improved
using smarter resolution planners  since resolution stage done once  probably
would major effect overall running time planner 

   prioritised planning
common solution rapid growth search spaces multi robot planning prioritised
planning  erdmann   lozano perez        van den berg   overmars        
approach give robots fixed priority ordering begin  planning performed
priority ordering  first plan built robot highest priority  plan
second highest  interfere first  third 
on  new plan must constructed interfere plans
it  example implementation shown algorithm    usually backtracking
plan made  signified algorithm cut operator line  
plan 
cut  search longer complete  problems solutions
prioritised planner cannot find  figure   example  robots b wish
change positions  plan either robot easy  plan contains one
step  plan robots together requires move way 
right hand side map pass  prioritised planner
committed one step plan either b cannot construct plan
robot interfere 
incompleteness mistake  however  core makes prioritised planning efficient  search space pruned significantly eliminating

x 

x 


x 

x 

b


figure    simple planning problem cannot solved naive prioritised planning 
goal swap positions robots b 

   

fiexploiting subgraph structure multi robot path planning

certain plans consideration  still viable solution within pruned space
 and often is  found much quickly   hopefully few  cases
fails  always resort complete planner backup 
    prioritised subgraph planning
prioritised planning strictly competitor subgraph planning  fact  prioritised
search subgraph representation orthogonal ideas  quite possible use
together  algorithm    plan constructed robot consecutively 
rather building entire concrete plan  abstract version produced 
fashion algorithm   earlier  compatible abstract plans produced
every robot  resolved concrete plan 
well adding advantage abstraction prioritised planning  subgraph
representation allows planner cover space possible plans 
delaying resolution end  avoid commitment concrete choices high
priority robot hamper planning later robots 
illustrate this  lets return example figure   above  partition
subgraph vertices  x    x    x    x    hall x  prioritised subgraph planner
solve problem  abstract plan highest priority robot empty 
nothing already goal subgraph  given plan  second highest
priority robot plan move x back again  plan produce
goal configuration required  resolving plan move highest priority robot
x  back needed  plan built resolve methods halls 
search 
course thing free lunch example works choose
right partition  instead treat  x    x    stack  x    x    y  separate hall
prioritised subgraph planner help us  furthermore exist problems 
one figure   solved standard prioritised planners
fail introduce wrong subgraph abstraction  difficult generate realistic

x 

x 

x 



x 
b



figure    simple planning problem solved naive prioritised planning
subgraph abstraction  goal swap positions robots
b  priority ordering a  b subgraph planner choose robot
remain inside hall  robot b trapped  blocks
exit  note edges  x    y   y  x    directed  

   

firyan

cases problem small numbers robots  see section     below 
occur number robots large 

   search complexity
let us consider carefully advantages  if any  subgraph decomposition lie  subgraph transitions act macro operators one abstract state  set
configurations  another  long history planners using macros one kind
another  advantages disadvantages well known  see section      
widely recognised macros advantageous reduce depth search 
become disadvantage many macros created branching factor
search becomes large  guidelines apply use subgraphs 
typical search algorithm proceeds follows  select plan frontier incomplete plans create expansions  add expansions frontier recurse
complete plan found  time taken complete search determined
number nodes search tree  turn determined three factors 
   d  depth goal state 
   b  average branching factor tree  i e  number nodes generated per
node expanded
   efficiency search 
perfect search algorithm  heads directly goal  nevertheless contain o bd 
nodes alternative nodes must still generated  even never followed 
uninformed breadth first search  hand  generate o bd   nodes 
regarded sensible upper bound efficiency search  although possible
worse  
macro operators tend decrease expense increasing b  well
uninformed search dominates  show less advantage good heuristic exists 
b equally important  becomes important consider keep
increases branching factor minimum  case subgraph planning 
two main reasons b increases 
   reduced graph may larger average degree original  since
subgraph contains many vertices  tends out going edges single
vertex  edges connect different subgraphs  branching factor
significantly larger  sparse subgraphs  such halls  worse regard
dense subgraphs  such cliques   subgraph decomposition needs chosen
carefully avoid problem 
   single subgraph transition may create large number possible configurations 
robot enters large hall already occupied several robots 
cases may strictly matter configuration generated
possible use least commitment avoid creating unnecessary alternatives 
possibility different configurations result different outcomes

   

fiexploiting subgraph structure multi robot path planning

track  need considered  halls particular
problem 
see experiments follow  careful choice subgraph decomposition important avoid pitfalls  appropriate partition abstraction
significantly improve informed uninformed search 

   experiments
empirically test advantages subgraph approach  ran several experiments
real randomly generated problems  first experiment demonstrates
algorithms scale changes size problem  terms number vertices 
edges robots  standard breadth first search  second experiment shows
results affected using heuristic guide search  experiments
use randomly generated graphs  final experiment demonstrates algorithm
realistic problem 
first two experiments  maps generated randomly automatically partitioned subgraphs  random generation done follows  first spanning tree
generated adding vertices one one  connecting randomly selected vertex
graph  edges required generated randomly selecting two
non adjacent vertices creating edge them  edges undirected  
automated partitioning worked follows 
   initially mark vertices unused 
   select pair adjacent unused vertices 
   use pair basis growing hall  ring clique 
hall  randomly add unused vertices adjacent either end hall  provided
violate hall property  continue growth possible 
ring  randomly add unused vertices adjacent either end ring loop
created  discard vertices involved loop 
clique  randomly add unused vertices adjacent every vertex clique  continue growth possible 
   keep biggest three generated subgraphs  mark vertices used 
   go back step    adjacent unused pairs found 
   remaining unused vertices singletons 
intended ideal algorithm  results far optimal fast
effective  experience suggests partition generated approach contain
twice many subgraphs one crafted hand  makes effort minimise
degree reduced graph  even randomly generated partitions
advantages subgraph abstraction apparent 
   noted algorithm generate uniform distribution connected graphs
given size  difficult generate sparse connected graphs uniform distribution 
bias deemed significant 

   

firyan

   
original
reduced

  

   

degree

  subgraphs

   
  

   

   
  
   

 

   
  

  

  

  

  

  

  

  

  

   

  

  vertices

  

  

  

  

  

  

  

  

   

  vertices

figure    results automatic partitioning program experiment  a  left
graph shows average number subgraphs generated right graph
shows average degree reduced graph 

    experiment    scaling problem size
      scaling  v  
first experiment investigate effect scaling number vertices
graph search time  random graphs generated number vertices
ranging         edges added average degree    e   v   always
equal     this value seems typical realistic maps   one hundred graphs
generated size  one partitioned using method described above 
figure   shows performance auto partitioning  see  number
subgraphs increased roughly linearly size graph  average subgraph
size    small graphs  with fewer    vertices  reduced graph partitioning
sparser original  size increases average degree reduced graph
gets larger  results presented informative purposes only  make claims
quality partitioning algorithm  indeed reducing
size graph  small factor 
graph  three robots given randomly selected initial final locations 
plan generated  figure   a  shows average run times four approaches   shows clear performance hierarchy  complete planners significantly
slower priority planners  cases subgraph abstraction shows significant improvement naive alternative  nevertheless  every case combinatorial
growth runtime apparent  note graph plotted log scale   linear
relationship number vertices number subgraphs prevents subgraph
   noted times overall rather slow  acknowledge attribute
implementation  java heavily optimised avoid garbage collection 
currently working implementation optimised search engine  believe
results still provide valuable comparison methods 

   

fiexploiting subgraph structure multi robot path planning

       

      

time  ms 

     

    

   
naive complete
naive priority
subgraph complete
subgraph priority

  

 
  

  

  

  

  

  

  

  

  

   

  vertices
 a  run times
 
naive complete
naive priority
subgraph complete
subgraph priority

 

naive complete
naive priority
subgraph complete
subgraph priority

  

 

path length

branching factor

 

 

  

 
  

 
 
 

 
  

  

  

  

  

  

  

  

  

   

  

  vertices

  

  

  

  

  

  

  

  

   

  vertices

 b  branching factor

 c  goal depth

figure    results experiment  a  graph  a  boxes show first third
quartile whiskers show complete range  experiment failed
complete due time memory limits incompleteness search  run
time treated infinite  value plotted cases    
experiments failed  graph  c  goal depth naive complete
subgraph priority approaches identical graphs       vertices 
lines overlap  naive complete planner could solve problems
   vertices 

   

firyan

table    number planning failures recorded two prioritised planning approaches experiment  a 
  failures
vertices naive subgraph
  
 
 
       
 
 
  
 
 
        
 
 

approaches better this  better partitioning algorithm ameliorate
problem 
analyse causes variation run times  need consider search
process carefully  measure search depth average branching factor b
experiment  results plotted figure   b   c   expected 
subgraph abstraction used  goal depth decreased grows slowly 
branching factor increased  since uninformed search  dominates
overall result improvement planning time 
incompleteness prioritised planning shows table    three occasions
naive prioritised search failed find available solutions  however problem
prioritised subgraph search 
      scaling  e 
next examine effect graph density  fixing number vertices    
generated random graphs average degree ranging          value 
    graphs randomly generated automatically partitioned  planning
problem move three robots selected initial goal locations 
results experiment shown figure    appear much
overall change run times approaches  small improvement
naive prioritised planner graph gets denser  figures   b   c  show
expected result  increasing density graph increases branching factor
decreases depth  appears affect four approaches similarly 
interesting difference  however  shown table    records percentage
experiments prioritised planners unable find solution 
sparse graphs  naive planner failed many     problems  improved
quickly density increased  subgraph abstraction added  planner able
solve two problems  case find problems solved
naive planner subgraph planner 
      scaling  r 
last scaling experiments  investigate approach performs
varying numbers robots  before      random graphs generated partitioned 
   vertices average degree    one partitioned using
   

fiexploiting subgraph structure multi robot path planning

     

time  ms 

    

   

  
naive complete
naive priority
subgraph complete
subgraph priority
 
   

   

   

   

   

   

   

   

   

   

   

degree
 a  run times
 

  

 

naive complete
naive priority
subgraph complete
subgraph priority

  
path length

branching factor

 

naive complete
naive priority
subgraph complete
subgraph priority

 
 

  

 
  
 
 
   

   

   

   

   

   

   

   

   

   

   

 
   

   

   

   

   

degree

   

   

degree

 b  branching factor

 c  goal depth

figure    results experiment  b 

   

   

   

   

   

firyan

      

time  ms 

     

    

   

naive complete
naive priority
subgraph complete
subgraph priority

  

 
 

 

 

 

 

 

 

 

 

  

  robots
 a  run times
naive complete
naive priority
subgraph complete
subgraph priority

 

naive complete
naive priority
subgraph complete
subgraph priority

    

 

   
path length

branching factor

 

 

 

  

 

 

 
 

 

 

 

 

 

 

 

 

  

 

 

 

 

  robots

 

 
  robots

 b  branching factor

 c  goal depth

figure    results experiment  c 

   

 

 

 

  

fiexploiting subgraph structure multi robot path planning

table    number planning failures recorded two prioritised planning approaches experiment  b 
  failures
degree naive subgraph
   
  
 
   
 
 
   
 
 
   
 
 
   
 
 
   
 
 
   
 
 
         
 
 

table    number planning failures recorded two prioritised planning approaches experiment  c 
  failures
  robots naive subgraph
   
 
 
 
 
 
 
 
 
 
  
 
 
 
 
 
 
 
 
  
 
  
  
 

automatic partitioning algorithm  ten planning problems set graph
number robots varying       case initial goal locations selected
randomly 
running times four approaches plotted figure   a   major
performance difference prioritised non prioritised planners  prioritised planners able handle twice many robots  two complete search
approaches  subgraph abstraction unnecessary overhead small problems 
shows significant advantage number robots increases 
less obvious advantage subgraph abstraction case prioritised
planning  look failure rates shown table    number robots
increases incompleteness naive prioritised algorithm begins become apparent 
   robots see     problems could solved planner 
advantage subgraph abstraction apparent  total   problems
could solved      tried 

   

firyan

figures   b   c  plot average branching factor goal depth problems 
previous experiments  subgraph abstraction seen increase branching
factor decrease depth  complete search approaches branching factor
grows rapidly number robots  node search path contains choice
robot move  prioritised approach reverses trend  planning
ever done one robot time  later robots much heavily constrained
options available them  providing fewer alternatives search tree 
      discussion
summarise experiments  advantages subgraph abstraction twofold  firstly  decreases necessary search depth planning problem compressing
many robot movements single abstract step  macro based abstractions 
expense increasing branching factor gains seem outweigh
losses practice  course  dependent degree use uninformed
search  shall address below 
advantage specific prioritised planner  tightly constrained problems sparse maps and or many robots incompleteness naive prioritised
search becomes significant issue  addition subgraph abstraction
number failures dramatically reduced  without additional search 
    experiment    heuristic search
experiments far involved uninformed breadth first search without use
heuristic  such  runtime algorithms strongly affected changes
search depth branching factor  explained above  uninformed search
o bd   expected running time  however perfect heuristic reduce o bd  
making branching factor much significant aspect  perfect heuristic is  course 
unavailable  possible efficiently compute reasonably good search heuristic
task relaxing problem  disregarding collisions simply compute sum
shortest path lengths robots location goal  underestimate
actual path length  accurate loosely constrained problems  with robots
dense graphs  
experiment used best first search algorithm guided heuristic  
every node search tree  selected plan minimised value  case
subgraph planner  actual locations robots time point specified 
subgraph occupy  heuristic calculated using maximum distances
vertex robots subgraph goal  pre computed shortest path
distances every pair nodes running planner  time
computation counted runtime algorithm 
utility heuristic depends largely constrained problem is 
graph dense relatively robots  heuristic direct planner
quickly goal  however graph sparser  interactions robots
become important  heuristic less useful  reason 
   a  algorithm used  desire minimise length solution  find
solution quickly possible 

   

fiexploiting subgraph structure multi robot path planning

concentrate attention experiment varying density graph affects
performance different approaches 
random maps     vertices generated  average degree ranging  
   one hundred graphs generated size partitioned using algorithm
described earlier  figure    shows results  original graph gets denser 
number subgraphs decreases  mostly possible create longer halls 
good  fewer subgraphs mean shorter paths  consequential increase degree
adversely affect branching factor 
ten robots placed randomly graph assigned random goal locations 
four planning approaches applied problems  resulting run times
plotted figure    a   first thing apparent graph
distinction different approaches greatly reduced  size graph
number robots much larger previous experiments 
corresponding effect goal depth branching factor  figure    b   c   
run times much smaller  clearly heuristic effective guiding search 
average ratio search nodes expanded goal depth close    
experiments  slight increase constrained cases  conclude
heuristic close perfect 
compare four approaches see three distinct stages  constrained case      edges  see subgraph approaches outperforming either naive
approach  small benefit prioritised search complete search      edges
pattern changed  two prioritised methods significantly better two
complete approaches  number edges increases  naive methods continue
improve  prioritised subgraph search holds steady complete subgraph search
gets significantly worse  due rapid increase branching factor       edges
naive approaches significantly better subgraph approaches 


singletons
halls
cliques
rings

  

   

original
reduced

   

  

degree

  subgraphs

   
  
  

   
   

  

   

  

   

 

   
   

   

   

   

   

   

   

   

   

   

   

   

  edges

   

   

   

   

   

   

   

   

   

  edges

 a  subgraphs

 b  degree

figure     results auto partitioner graphs experiment   

   

   

firyan

     

time  ms 

    

   
naive complete
naive priority
subgraph complete
subgraph priority
  
   

   

   

   

   

   

   

   

   

   

   

edges
 a  run times
   

naive complete
naive priority
subgraph complete
subgraph priority

   

naive complete
naive priority
subgraph complete
subgraph priority

   
  

path length

branching factor

   

  

   

  
   
  
 
   

   

   

   

   

   

 
   

   

   

edges

   
edges

 b  branching factor

 c  goal depth

figure     results experiment   

   

   

   

fiexploiting subgraph structure multi robot path planning

table    number planning failures recorded two prioritised planning approaches experiment   
  failures
  edges naive subgraph
   
  
 
   
 
 
   
 
 
   
 
 
   
 
 
         
 
 

cause clearly seen figures    b   c   branching factors subgraph
approaches increase significantly faster naive approaches  corresponding
improvement goal depth sufficient outweigh cost 
benefits subgraph abstraction highly constrained cases shown
failure cases  table         edges naive prioritised search unable solve    
problems  prioritised search subgraphs could solve all  number
failures fell quickly density graph increased 
      discussion
graph becomes moderately dense interactions robots become few 
total single robot paths measure becomes near perfect heuristic  makes
branching factor much critical factor using uninformed search 
auto partitioning algorithm use poor job limiting factor
subgraph approaches perform poorly 
better results could achieved better decomposition  clear whether
could found random graph without excessive computation  certainly partitioning graphs hand easy task  realistic graphs  hand  generally
shaped natural constraints  e g  rooms  doors corridors  make decomposition
much simpler  see following experiment 
    experiment    indoor map
figure    shows map final two experiments  based floor plan level  
k   building university new south wales  road map     vertices    
edges drawn  by hand  connecting offices open plan desk locations 
imagined might used map delivery task involving team
medium sized robots 
road map partitioned    subgraphs    cliques    halls   ring 
plus    remaining singleton nodes  subgraphs containing one vertex   average

   

firyan

figure     map experiment    vertices coloured subgraph 

   

fiexploiting subgraph structure multi robot path planning

     
naive complete
naive priority
subgraph complete
subgraph priority

time  ms 

    

   

  
 

 

 

 

 

 

 

 

 

  

  

  

  

  

  

  

  

  

  

  

robots

figure     comparing run times experiment   
degree reduced graph      compared     original   partitioning done
hand aid interactive gui performed simple graph analysis
offered recommendations  by indicating nodes could added hall clique
user creating   road map clearly laid partitioning mind
deciding partitioning whole difficult  large open spaces generally
became cliques  corridors became halls rings  foyer area  around vertex    
caused particular trouble finding ideal partitioning  due slightly unusual
topology  
series experiments run world  varying number robots  
    experiment     runs performed robot placed
random office desk required make delivery another random office
desk  chosen without replacement  two robots goal   plans built
using complete prioritised planners without subgraph abstraction 
four approaches utilised total single robot shortest path heuristic previous
experiment  running times algorithm shown figure    
see small numbers robots       naive approaches significantly better subgraph approaches  overhead subgraph search
outweighs disadvantages simple problems  number robots increases
subgraph methods take over  around      robots subgraph methods
significant better either naive approach     robots combination complete
search subgraphs begins perform less well two prioritised approaches
best performers  considerable advantage subgraph approach 
   comparison  auto partitioner yielded partition fewer subgraphs  avg        higher
degree  avg        
   curious  empty rooms centre map  near vertex     bathrooms 
consider robots would need make deliveries there 

   

firyan

naive complete
naive priority
subgraph complete
subgraph priority

   
   

expanded   path

   
   
   
   
   
   
   
 

 

 

 

 

 

 

 

                                  
robots

figure     assessing quality heuristic experiment    value plotted
ratio number expanded nodes search tree goal depth 
perfect heuristic yields value     

considering search complexity  let us first examine performance heuristic 
figure    plots ratio average number expanded nodes search tree
goal depth  perfect heuristic  value      experiment
   robots     robots heuristic begins become inaccurate 
inaccuracy seems affect complete planners badly prioritised ones 
cases subgraph approach seriously affected naive approach 
explain difference  note heuristic using contains significantly less
information subgraph search naive search  know exactly
robot within subgraph  assume worst possible position 
means value configuration tuple based solely allocation robots
subgraphs  particular configurations subgraphs  hall subgraphs
particular may several different configurations set robots 
assigned heuristic value despite significantly different real distances
goal this creates plateau heuristic function broadens search  large
numbers robots permutations become significant factor search  improve
heuristic need find way distinguish value different configurations
subgraph  probably require extra method specific subgraph structure 
graphs branching factor goal depth  figure     show come
expect branching factor larger complete search prioritised search
subgraph abstraction makes worse  significantly  branching factor prioritised
   

fiexploiting subgraph structure multi robot path planning

naive complete
naive priority
subgraph complete
subgraph priority

  

naive complete
naive priority
subgraph complete
subgraph priority

    

path length

branching factor

  

  

  

    

  

 

 
 

 

 

 

 

 

 

 

                                  

 

robots

 

 

 

 

 

 

 

                                  
robots

 a  branching factor

 b  goal depth

figure     branching factor goal depth experiment   
table    number planning failures recorded two prioritised planning approaches experiment   
  failures
edges naive subgraph
   
 
 
       
 
 
  
 
 

search increase robots added  step plan
one robot moved  goal depth shows opposite pattern  complete searches
shorter prioritised searches subgraph abstraction approximately halves
search depth cases 
failure rates recorded table    story different previous
experiments  naive prioritised planner able solve problems every depth 
adding subgraph abstraction caused small number failures complex
problems  clear caused reversal  cases involved complex
elude analysis  problem warrants investigation 
      discussion
experiment shown realistic problem appropriately chosen set
subgraphs subgraph abstraction effective way reduce search even
good heuristic available  subgraph abstraction work well
example  compared random graphs experiment    answer seems found
degree reduced graph  automatically partitioning random graph significantly
increases degree  saw figure    b   this  turn  increases branching factor
thus search time 

   

firyan

contrast  partition realistic map decreased degree graph
         by hand        automatically   branching factor subgraph
methods still larger  as one transition still create multiple configurations 
effect reduced enough overcome decrease goal depth  indication
realistic map structure exploited abstraction 
investigation warranted characterise features many possible 

    conclusion
demonstrated new kind abstract representation multi robot path planning
allows much faster planning without sacrificing completeness  decomposing
road map subgraphs simple intuitive way providing background knowledge
planner efficiently exploited  key find subgraph structures
allow us treat many arrangements robots equivalent configurations compute
transitions configurations quickly deterministically  described
four structures paper  stacks  halls  cliques rings  structures
simple enough compute configurations easily common enough found
many realistic maps 
shown abstract plans subgraphs resolved deterministically
concrete plans without need search  planner sound complete 
although plans produced necessarily optimal  future work could prove
worth spending time resolution phase trim unnecessarily wasteful plans 
using  example  simulated annealing  sanchez  ramos    frausto         may
time saved abstract planning leaves us space clever resolution 
conventional solution search space explosion multi robot planning prioritisation  shown subgraph based planning competitive
prioritised planning combination two methods powerful still
cases  partly alleviates incompleteness prioritised approach 
     related work
abstraction hierarchical decomposition standard techniques planning
related search problems  use macro operators dates back far sacerdotis early
work abstrips planning system  sacerdoti        introduced abstraction
hierarchies  whereby problem could first solved high level abstraction
ignoring lower level details  idea re expressed many different ways
history planning far many review detail  present work particularly
inspired generic types long fox        similarly detected
substructures task planning problem solved using structure specific planners 
hierarchical planning applied path planning abstractions
approximate cell decomposition  barbehenn   hutchinson        conte   zulli        
generalised voronoi graphs  choset   burdick        choset        general ad hoc
hierarchical maps  bakker  zivkovic    krose        zivkovic  bakker    krose              
structures identified examples carry well multi robot
scenario 

   

fiexploiting subgraph structure multi robot path planning

faster solutions multi robot problem available assume
existence garage locations robot  lavalle   hutchinson        kinds
temporary free space  sharma   aloimonos        fitch  butler    rus        
method present makes assumption thus general application 
appear previous work provides complete abstraction based
planner general multi robot problem 
work bears similarity explicitly robot path planning 
solving sokoban puzzle  botea  muller    schaeffer        junghanns   schaeffer         domain significantly constrained  the map necessarily
orthogonal grid stones move pushed man 
method employ similar  dividing map rooms tunnels use
strongly connected component algorithm identify equivalent arrangements boulders subpart  equivalent arrangements treated single abstract state
corresponding configuration formulation used state global
search  particular structures represent different  general ideas partitioning independent local subproblems identifying abstract states strongly
connected components  employed work 
     future plans
next stage project plan examine symmetries provided subgraph
representation  recent work symbolic task planning  porteous  long    fox       
shown recognising exploiting symmetries almost symmetries planning
problems eliminate large amounts search  subgraph configurations provide natural
ground similar work problem domain expect similar improvements
possible 
plan investigate problem automatic subgraph partitioning
maps  identified importance trading path depth branching
factor  plan make partitioning algorithm chooses subgraphs optimise
relationship  automatically finding optimal partition could hard  creating
powerful interactive partitioning tool human operator would seem viable
compromise  one approach would adapt auto partitioner describe
paper seed vertices selected user  allowed choose
number possible subgraphs based selection 
subgraph structures identified  currently working
formalising properties tree structured subgraphs  another possibility would
generalise cliques rings new ring with chords structure  although characterising
structure may prove difficult 
many advances search technology may applicable
multi robot planning problem  currently process re expressing
entire problem constraint satisfaction problem  csp  gecode constraint engine
 gecode team         believe csp formulation powerful way take
advantage structural knowledge subgraph decomposition represents 

acknowledgments
   

firyan

id thank jonathan paxman  brad tonkes maurice pagnucco help
developing ideas paper proofreading drafts 

appendix a  proof soundness completeness
appendix set necessary formal definitions prove soundness
completeness abstract planning process  main result theorem showing
abstract plan exists given problem concrete plan exists 
a   graphs subgraphs
induced subgraph g graph    v  s   e s  
v  s  v  g 

e s      u  v    u  v v  s    u  v  e g  

intuitively describes subgraph consisting subset vertices connecting edges parent graph  thus induced subgraph specified solely
terms vertices  shall henceforth assume subgraphs refer induced 
partition p g set  s            sm   subgraphs g satisfying
 
v  g   
v  si  

v  si   v  sj       i  j      j
i     m

given graph g partition p construct reduced graph x g
contracting subgraph single vertex
v  x    p
e x      si   sj     x si   sj    x  y  g 
a   robots arrangements
let us assume set robots r  arrangement robots graph g
  to   partial function   v  g  r  arrangement represents locations robots
within g  a v    r  robot r vertex v  shall use notation a v     
indicate undefined v  i e  vertex v unoccupied  arrangement may
necessarily include every robot r  two arrangements b said disjoint
range a  range b      let ag represent set arrangements r g 
subgraph g  arrangement r g define a s 
induced arrangement r s 
a s v    a v   v v  s 
s  s  disjoint subgraphs g disjoint arrangements a  s  a 
s    define combined arrangement   a  a  arrangement s  s 
satisfying
 
a   v  v s 
a v   
a   v  v s 

   

fiexploiting subgraph structure multi robot path planning

lemma   arrangement g partition p    s            sm    a             
set induced arrangements ai   a si   combined arrangement a   
a 
given identity  uniquely identify arrangement g combination
induced arrangements partition p 
a   concrete plans
need define means move robots around graph  first define
two operators respectively add remove robots given arrangement 
formally   ag r v  g  ag mapping satisfies
g

 r  v    b
g



 
r
b u   
a u 

u   v
otherwise

similarly   ag r ag mapping satisfies
g

r  b
g



 
 
b u   
a u 

a u    r
otherwise

omit subscript g clear context 
define plan step r e g  g robot edge pair  r  u  v  
representing movement r along edge u v  u    v  plan step
applicable arrangement ag iff a u    r a v       case apply
produce new arrangement b   s a 
s a     a r   r  v 
concrete plan  or plan  g ag b ag sequence plan steps
hs            sl exist arrangements a            al ag si applicable ai 

a   
al   b
ai   si  ai           l
lemma   subgraph g p plan p plan g 
lemma   p plan g b q plan g b c 
concatenation p q  written p q plan g c 
   

firyan

lemma   let p kq denote set interleavings sequences p q  let s 
s  disjoint subgraphs g  p  plan s  a  b  p  plan s 
a  b    a  a  disjoint  arbitrary interleaving p p  kp  plan
g a  a  b  b   
a   configurations
defined machinery concrete plans  introduce abstraction  key
idea configuration abstraction arrangements  robots
subgraph rearranged one arrangement another  without robots
leave subgraph rearrangement  two arrangements
treated equivalent  configurations represent sets equivalent arrangements
subgraph  so  example  stack subgraph configuration set arrangements
ordering robots  arrangement entire partitioned graph
abstracted list configurations produces subgraphs 
formally  define configuration relation graph g equivalence relation
g

ag b iff exists plans pab pba g b b
g

respectively 
configuration c g equivalence class   write c    a  represent
g

g

equivalence class containing arrangement a  let cg set configurations
g 
lemma   b range a    range b 
g

given identity  unambiguously define range configuration c
range c    range a   c
extend definitions configurations  c cg
configuration g  r r v v  g 


c  r  v     a  r  v     c  a v     
g
g
g


c  r  v     a r    c  a v    r
g

g

g

note map configurations sets configurations  
given partition p    s            sm   g corresponding set configuration
relations               define configuration tuple r g tuple  c            cm  
s 

sm

  ci csi  
 

range ci     r

i     m

range ci   range cj       i  j      j
   astute readers notice c  r  v  never contains one element  although may
g

empty 

   

fiexploiting subgraph structure multi robot path planning

configuration tuple represents abstract state robots entire graph 
terms configurations individual subgraphs partition  given arrangement g construct corresponding configuration tuple  a     c            cm  
ci    a si    conversely  a si ci ci   write  
si

lemma   b arrangements graph g partition  s            sm  
configuration tuple g a  b   exists plan b g 
proof
          m  let ai   a si bi   b si   ai ci bi ci
ai bi   therefore definition exists plan pi ai bi si  
si

let p p  k       kpm   since pi plans disjoint subgraphs  p plan
a    b  bm   b required 

a   abstract plans
configuration tuples abstract state representation  define abstract
plans  sequences subgraph transitions plan steps move robot one
subgraph another  prove main result section  abstract
plan problem exists corresponding concrete plan exists  allow
us later prove soundness completeness subgraph planning algorithm 
rest section shall assume graph g partition p  
 s            sm   corresponding configuration relations               
s 

sm

subgraph transition  or transition  plan step    r  u  v  u sx  
v sy sx    sy   transition    r  u  v  applicable configuration tuple
   c            cm   g
cx  r  u       u sx  
sx

cy  r  v       v sy  
sy

is  robots sx rearranged robot r leave via u robots
sy rearranged v empty r enter 
transition    r  u  v  applicable    c            cm   u sx v sy
apply compute set s   configuration tuples
 c           c m   s  

c x cx  r  u  
sx



c y

cy  r  v  

c z

  cz   otherwise 

sy

lemma   arrangement g partition  s            sm   transition  
 r  u  v  applicable applicable  a  
 s a   s  a  
   

firyan

proof let sx   sy disjoint subgraphs partition u sx   v sy   let
ax   a sx ay   a sy   let  a     c            cm   
ax cx
ax  u    r
cx  r  u      
similarly
ay cy
ay  v     
cy  r  v      
therefore applicable  a  
further  let b   s a   b     c             c m   
c x    b sx  
sx

   ax r 
sx

cx  r  u 

c y    b sy  
sy

   ay  r  v  
sy

cy  r  v 

c z   cz  
therefore  b  s   required 



lemma      r  u  v  u  v sx  i e  transition  arrangement g applicable a   a     s a   
proof
let b   s a   let ai   a si bi   b si           m  let  a   
 c            cm    b     c             c m   
plan px   hsi plan ax bx sx   ax bx implying cx   c x  
z    x  az   bz cz   c z   therefore  a     b  required 


   

fiexploiting subgraph structure multi robot path planning

define abstract plan arrangement g tuple     
sequence configuration tuples h            l sequence plan steps
hs            sl i 
       
l      
si applicable i   
s i    
theorem   abstract plan g exists exists corresponding concrete plan p g 
proof case   p   
let        abstract plan g     h            l
  hs            sl i  let    ci            cim   
shall construct concrete plan
p   p    hs   p     pl    hsl  pl
pi concrete plan ai bi   satisfying
a     
bl    
ai   bi  
si   applicable bi  
ai     si    bi              l   
proposition   ai bi exist satisfying conditions           l 
proof induction 
a    therefore a  exists 
assume ai exists 
let si      r  u  v  u sx v sy   definition abstract plan 
si   applicable   i     si    i    therefore
ci  
cix  r  u    
x
n


ci  

 a

 r 
u  
 
a u 
 
r 


c
x
x   
cix   a u    r
set bix equal a 
ci  
   bix  r  u  
x
bix  r  u  ci  
x

   

firyan


ci  
ciy  r  v    

n


ci  

 a

 r 
v  
 
a v 
 
  


c

  
ciy   a v     
set biy equal a 
ci  
   biy  r  v  

biy  r  v  ci  

set biz   ai  sz z
   x  y 
bij defined every subgraph sj partition g  therefore bi   bi  bim
exists arrangement g 
ai exists bi exists           l   
si   applicable bi since
bi  u    bix  u    r
bi  v    biy  v     
ai     si    bi   exists 
ai    sx   bix r ci  
x
ai    sy   biy  r  v  ci  

ai    sz   biz   z
   x  y  ciz
ci  
z

ai   i  
induction  ai exists           l bi exists           l   
furthermore bl        l   bi exists           l  required 

proposition   concrete plan pi ai bi exists               l
proof

since ai   bi plan pi must exist ai bi   lemma   above 



proposition   p concrete plan g 
proof
pi plan ai bi              l  furthermore ai     si    bi   
hsi   plan bi ai     therefore concatenation plans
p   p    hs      hsl  pl
plan g a    bl     required 
   



fiexploiting subgraph structure multi robot path planning

case  p   
let p   hs            sl concrete plan g  wish construct
abstract plan        g 
let   ht            tl increasing sequence integers t      ti   iff st
subgraph transition   note  using capital l designate length concrete
plan p lowercase l designate number transitions plan 
length corresponding abstract plan   
construct sequence arrangements   h            l
   
i     si    i              l  
split subsequences a            al



ai   ti           ti    
define    ti                 l    h            l   hst            stl i 
proposition     ai
proof induction 
definition 
ti  ti    
assume   ti   j  j    ai      need prove t    
let st      r  u  v   since    
  must u  v sx   using lemma  
 t        st    t   
   t  
   
therefore  induction
  ai
required 



proposition          valid abstract plan  
proof
first check initial final configuration tuples contain
respectively 
              

al
l  
l      

   

firyan

now            l   let bi   ti      i e  final element ai    let
  bi  sz z           m 
let   sti      r  u  v  u sx v sy   applicable bi
definition p   therefore  lemma   above  applicable

biz

i      ai    
   s bi   
s  bi      s i    required 

therefore valid abstract plan 



theorem significant planning problem  tells us need
perform search concrete plans  instead  need search abstract plan
convert concrete form  search succeed concrete
plan exists 

references
alami  r   fleury  s   herrb  m   ingrand  f     robert  f          multi robot cooperation
martha project  robotics   automation magazine  ieee              
alarie  s     gamache  m          overview solution strategies used truck dispatching systems open pit mines  international journal surface mining  reclamation environment               
bakker  b   zivkovic  z     krose  b          hierarchical dynamic programming robot
path planning  proceedings ieee rsj international conference intelligent
robots systems           
barbehenn  m     hutchinson  s          efficient search hierarchical motion planning
dynamically maintaining single source shortest paths trees  ieee transactions
robotics automation                 
barraquand  j     latombe  j  c          robot motion planning  distributed representation approach  international journal robotics research                 
botea  a   muller  m     schaeffer  j          using abstraction planning sokoban 
computers games  lecture notes computer science  vol        pp         
springer 
buro  m     furtak  t          rts games real time ai research  proceedings
behavior representation modeling simulation conference  brims   arlington
va            
choset  h          sensor based motion planning  hierarchical generalized voronoi
graph  ph d  thesis  california institute technology  pasadena  california 
choset  h     burdick  j          sensor based planning  i  generalized voronoi graph 
proceedings international conference robotics utomation    

   

fiexploiting subgraph structure multi robot path planning

conte  g     zulli  r          hierarchical path planning multi robot environment
simple navigation function  ieee transactions systems  man cybernetics 
               
erdmann  m     lozano perez  t          multiple moving objects  tech  rep      
m i t  ai laboratory 
everett  h   gage  d   gilbreth  g   laird  r     smurlo  r          real world issues
warehouse navigation  proceedings spie conference mobile robots ix 
     
fitch  r   butler  z     rus  d          reconfiguration planning heterogeneous selfreconfiguring robots  proceedings ieee rsj international conference intelligent robots systems              
gecode team         gecode  generic constraint development environment   available
http   www gecode org 
hada  y     takase  k          multiple mobile robot navigation using indoor global
positioning system  igps   proceedings ieee rsj international conference
intelligent robots systems    
junghanns  a     schaeffer  j          sokoban  enhancing general single agent search
methods using domain knowledge  artificial intelligence                    
lavalle  s  m          planning algorithms  cambridge university press 
lavalle  s  m     hutchinson  s  a          optimal motion planning multiple robots
independent goals  ieee transactions robotics automation 
vol     
long  d     fox  m          planning generic types  chap     pp          morgan
kaufmann 
porteous  j   long  d     fox  m          identification exploitation almost
symmetry planning problems  brown  k   ed    proceedings   rd uk
planning scheduling sig 
sacerdoti  e          planning hierarchy abstraction spaces  artificial intelligence 
              
sanchez  g   ramos  f     frausto  j          locally optimal path planning using
probabilistic road maps simulatead annealing  proceedings iasted international conference robotics applications 
sharma  r     aloimonos  y          coordinated motion planning  warehousemans
problem constraints free space  ieee transactions systems  man
cybernetics                 
van den berg  j     overmars  m          prioritized motion planning multiple robots 
proceedings ieee rsj international conference intelligent robots systems  pp         
zivkovic  z   bakker  b     krose  b          hierarchical map building using visual landmarks geometric constraints  proceedings ieee rsj international conference
intelligent robots systems           
   

firyan

zivkovic  z   bakker  b     krose  b          hierarchical map building planning based
graph partitioning  ieee international conference robotics automation 

   

fiexploiting subgraph structure multi robot path planning

algorithm   planning subgraph abstraction 
   function plan g  p  r  a  b 
  
 a 
  
 b 
  
abstractplan g  p  r     
  
p resolve g  p    a  b 
  
return p
   end function

  build plan b g using partition p 
  get initial configuration 
  get final configuration 
  build abstract plan 
  resolve concrete plan 

   function abstractplan g  p  r        build abstract plan g using p 
  
 
  
return  hi   hi 
  done 
  
end
  
 c            cm    
  
choose r r
  choose robot 
  
select x   r range cx  
  find subgraph occupies 
  
choose sy p    sx   sy   x
  choose neighbouring subgraph 
  
choose  u  v  e g    u sx   v sy
  choose connecting edge 
  choose resulting configurations sx sy  
   
choose c x cx  r  u 
   
choose c y cy  r  v 
   
 c            c x           c y           cm  
  construct new configuration tuple 
   
     abstractplan g  p  r     
  recurse 
   
   
   
   r  u  v  
   
return         
    end function
   function resolve g  p    a  b 
  resolve abstract plan concrete plan 
  
      
  
  h            l
  
  hs            sl
  
p hi
  
a 
  
           l   
  
 r  u  v    si  
  next transition 
  
 c             c m     i  
  target configurations 
   
find sx   u sx
   
find sy   v sy
   
aiz ai  sz   z          
   
 pxi   bix   sx  resolveexit aix   r  u  c x  
  rearrange sx let robot r exit 
  rearrange sy let robot r enter 
   
 pyi   biy   sy  resolveenter aiy   r  v  c y  
   
p p  pxi   pyi  
   
bi   ai        bix       biy       aim
   
ai   si    bi  
   
p p   hsi  
  add transition 
   
end
   
z          
   
tz sz  resolveterminate al  sz   b sz  
  rearrange sz final arrangement 
   
end
   
p p  t             tm  
   
return p
    end function

   

firyan

algorithm   simple prioritised planning algorithm 
   function plan g  a  b 
  
a   v     v g
  a  initial arrangement robots
 
  
b  v     v g
  b  final arrangement robots
  
          k
  
a   v    ri   v   a v    ri
  
b   v    ri   v   b v    ri
  
 p  pi   planone g  ri   hp            pi    h            i   a    b   
  build plan
  
cut
  backtrack plan
  
end
   
return p
    end function

r        ri  
r        ri  

r        ri  
found

   function planone g  ri   hp            pi    ht            ti    a  b 
  
  b
  
return  hi  hi 
  done 
  
end
  
choose rj r   j
  choose robot move 
  
j  
  
select vf   a vf     ri
  
choose vt  v    vf   v  g 
  choose new action ri
  
else
   
 r  vf   vt   pj  tj  
  select old action rj pj
   
tj tj    
   
end
   
a vt       
   
fail
  backtrack destination occupied 
   
end
   
a vf    
  move robot 
   
a vt   r
   
 p  pi   planone g  ri   hp            pi    ht            ti    a  b 
  recurse 
   
p  rj   vf   vt   p
  add step global plan 
   
j  
   
pi  ri   vf   vt   pri
  add step ri plan 
   
end
   
return  p  pi  
    end function

   


