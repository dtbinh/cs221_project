journal of artificial intelligence research          

submitted         published        

exact query reformulation over databases
with first order and description logics ontologies
enrico franconi
volha kerhet
nhung ngo

franconi inf unibz it
kerhet inf unibz it
ngo inf unibz it

free university of bozen bolzano  italy

abstract
we study a general framework for query rewriting in the presence of an arbitrary
first order logic ontology over a database signature  the framework supports deciding the
existence of a safe range first order equivalent reformulation of a query in terms of the
database signature  and if so  it provides an effective approach to construct the reformulation based on interpolation using standard theorem proving techniques  e g   tableau  
since the reformulation is a safe range formula  it is effectively executable as an sql query 
at the end  we present a non trivial application of the framework with ontologies in the
very expressive alchoiq description logic  by providing effective means to compute
safe range first order exact reformulations of queries 

   introduction
we address the problem of query reformulation with expressive ontologies over databases 
an ontology provides a conceptual view of the database and it is composed by constraints
on a vocabulary extending the basic vocabulary of the data  querying a database using
the terms in such a richer ontology allows for more flexibility than using only the basic
vocabulary of the relational database directly 
in this paper we study and develop a query rewriting framework applicable to knowledge
representation systems where data is stored in a classical finite relational database  in a way
that in the literature has been called the locally closed world assumption  etzioni  golden 
  weld         exact views  marx        nash  segoufin    vianu        fan  geerts 
  zheng         or dbox  seylan  franconi    de bruijn        franconi  ibanez garcia 
  seylan         a dbox is a set of ground atoms which semantically behaves like a
database  i e   the interpretation of the database predicates in the dbox is exactly equal
to the database relations  the dbox predicates are closed  i e   their extensions are the
same in every interpretation  whereas the other predicates in the ontology are open  i e  
their extensions may vary among different interpretations  we do not consider here the
open interpretation for the database predicates  also called abox or sound views   in an
abox  the interpretation of database predicates contains the database relations and possibly
more  this notion is less faithful in the representation of a database semantics since it would
allow for spurious interpretations of database predicates with additional unwanted tuples
not present in the original database 
in our general framework an ontology is a set of first order formulas  and queries are
 possibly open  first order formulas  within this setting  the framework provides precise
semantic conditions to decide the existence of a safe range first order equivalent reformulac
    
ai access foundation  all rights reserved 

fifranconi  kerhet    ngo

tion of a query in terms of the database signature  it also provides an effective approach to
construct the reformulation with sufficient conditions  we are interested in safe range reformulations of queries because their range restricted syntax is needed to reduce the original
query answering problem to a relational algebra evaluation  e g   via sql  over the original
database  abiteboul  hull    vianu         our framework points out several conditions on
the ontologies and the queries to guarantee the existence of a safe range reformulation  we
show that these conditions are feasible in practice and we also provide an efficient method
to ensure their validation  standard theorem proving techniques can be used to compute
the reformulation 
in order to be complete  our framework is applicable to ontologies and queries expressed
in any fragment of first order logic enjoying finitely controllable determinacy  nash et al  
       a stronger property than the finite model property of the logic  if the employed logic
does not enjoy finitely controllable determinacy our approach would become sound but
incomplete  but still effectively implementable using standard theorem proving techniques 
we have explored non trivial applications where the framework is complete  in this paper 
the application with alchoiq ontologies and concept queries is discussed  we show how
 i  to check whether the answers to a given query with an ontology are solely determined
by the extension of the dbox predicates and  if so   ii  to find an equivalent rewriting of the
query in terms of the dbox predicates to allow the use of standard database technology for
answering the query  this means we benefit from the low computational complexity in the
size of the data for answering queries on relational databases  in addition  it is possible to
reuse standard techniques of description logics reasoning to find rewritings  such as in the
paper by seylan et al         
the query reformulation problem has received strong interest in classical relational
database research as well as modern knowledge representation studies  differently from
the mainstream research on query reformulation  halevy         which is mostly based
on perfect or maximally contained rewritings with sound views under relatively inexpressive constraints  see  e g   the dl lite approach in artale  calvanese  kontchakov    zakharyaschev         we focus here on exact rewritings with exact views  since it characterises
precisely the query answering problem with ontologies and databases  in the case when the
exact semantics of the database must be preserved  as an example  consider a ground negative query over a given standard relational database  by adding an ontology on top of it  its
answer is not supposed to changesince the query uses only the signature of the database
and additional constraints are not supposed to change the meaning of the querywhereas
if the database were treated as an abox  sound views  the answer may change in presence
of an ontology  this may be important from the application perspective  a dbox preserves
the behaviour of the legacy application queries over a relational database  moreover  by
focussing on exact reformulations of definable queries  as opposed to considering the certain
answer semantics to arbitrary queries  such as in dl lite   we guarantee that answers to
queries can be subsequently composed in an arbitrary way  this may be important to legacy
database applications 
this work extends the works on exact rewritings with exact views by marx        and
nash et al         by focussing on safe range reformulations and on the conditions ensuring
their existence  and by considering general first order ontologies extending the database
signature  rather than just local as view constraints over the database predicates  halevy 
   

fiexact query reformulation over dbs with fo and dl ontologies

       this paper extends the papers by franconi  kerhet  and ngo      a      b  by
providing a precise semantic characterisation for the existence of an exact reformulation
 theorem    as opposed to just sufficient conditions  by considering the much more expressive description logic alchoiq  and by providing all the proofs 
the paper is organised as follows  section   provides the necessary formal background
and definitions  section   introduces the notion of a query determined by a database  section   introduces a characterisation of the query reformulation problem  in sections   and  
the conditions allowing for an effective reformulation are analysed  and a sound and complete algorithm to compute the reformulation is introduced  finally  we present the case of
alchoiq ontologies  all the proofs are presented in details in the appendix 

   preliminaries
let fol c  p  be a classical function free first order language with equality over a signature
    c  p   where c is a finite set of constants and p is a set of predicates with associated
arities  in the rest of this paper we will refer to an arbitrary fragment of fol c  p   which
will be called l 
we denote with p        n   the set of all predicates occurring in the formulas             n  
with c        n   the set of all constants occurring in the formulas             n   for the sake of
brevity  instead of p    resp  c     we write p  resp  c    we denote with              n  
the signature of the formulas             n   namely the union of p        n   and c        n    
we denote the arity of a predicate p as ar p    given a formula   we denote the set of
all variables appearing in  as var    and the set of the free variables appearing in  as
free    we may use for  the notation  x    where x   free   is the  possibly empty 
set of free variables of the formula 
a database  instance  db is a finite set of ground atoms of the form p  c            cn    where
p  p  n ary predicate  and ci  c     i  n   the set of all predicates appearing in a
database db is denoted as pdb   and the set of all constants appearing in db is called the
active domain of db  and is denoted as cdb   a  possibly empty  finite set kb of closed
formulas will be called an ontology 
as usual  an interpretation i   hi   i i includes a non empty setthe domain i and
an interpretation function i defined over constants and predicates of the signature  we say
that interpretations i   hi   i i and j   hj   j i are equal  written i   j   if i   j
and i   j   an interpretation i embeds a database db  if it holds that ai   a for every
database constant a  cdb  the standard name assumption  sna   customary in databases 
see abiteboul et al         and that  c            cn    p i if and only if p  c            cn    db  we
denote the set of all interpretations embedding a database db as e db  
in other words  in every interpretation embedding a db the interpretation of any
database predicate is always the same and it is given exactly by its content in the database 
this is  in general  not the case for the interpretation of the non database predicates  we
say that all the database predicates are closed  while all the other predicates are open and
may be interpreted differently in different interpretations  we do not consider here the open
world assumption  the abox   for embedding a database in an interpretation  in an open
world  an interpretation i soundly embeds a database if it holds that  c            cn    p i if
 but not only if  p  c            cn    db 
   

fifranconi  kerhet    ngo

in order to allow for an arbitrary database to be embedded  we generalise the standard
name assumption to all the constants in c  this implies that the domain of any interpretation
necessarily includes the set of all the constants c  the finiteness of c corresponds to the
finite ability of a database system to represent distinct constant symbols  c is meant to be
unknown in advance  since different database systems may have different limits  we will
see that the framework introduced here will not depend on the choice of c 
given an interpretation i   hi   i i  we denote as i s the interpretation restricted to
the smaller signature s  p  c  i e   the interpretation with the same domain i and the
same interpretation function i defined only for the constants and predicates from the set
s  the semantic active domain of a signature     p  c in an interpretation i  denoted
adom      i   is the set of all elements of the domain i occurring in interpretations of
predicates and constants from    in i 
adom      i    

 

 

p     a       an  p i

 a            an   

 

 ci   

c  

if     pdb  c  then for any interpretations i and j embedding db we have 
adom      i    adom      j    so  for such a case we introduce the notation adom      db    
adom      i   where i is any interpretation embedding the database db  intuitively
adom      db  includes the constants from    and from db appearing in the relations corresponding to the predicates from     
let x be a set of variable symbols and s a set  a substitution is a total function    x   s
assigning an element in s to each variable in x  including the empty substitution  when
x     domain and image  range  of a substitution  are written as dom   and rng  
respectively  given a subset of the set of constants c   c  we write that a formula  x 
is true in an interpretation i with its free variables substituted according to a substitution
   x   c  as  i     x      given an interpretation i   hi   i i and a subset of
its domain   i   we write that a formula  x  is true in i with its free variables
interpreted according to a substitution    x    as  i         the extension domain of
asformula  x  with respect to the interpretation i is defined as the set of domain elements
 rng     dom     x  rng      i       x    
as usual  an interpretation in which a closed formula is true is called a model for
the formula  the set of all models of a formula   resp  kb  is denoted as m     resp 
m  kb    a database db is legal for an ontology kb if there exists a model of kb embedding
db  in the following  we will consider only consistent non tautological ontologies and legal
databases 
    queries
a query is a  possibly closed  formula  given a query q x    we define its certain answer
over kb and db as follows 
definition    certain answer   the  certain  answer of a query q x  to a database db
under the ontology kb is the set of substitutions with constants 
    dom     x  rng    c   i  m  kb   e db    i    q x     
   

fiexact query reformulation over dbs with fo and dl ontologies

query answering is defined as an entailment problem  and as such it is going to have the
same  high  complexity as entailment 
note  that if a query q is closed  i e   a boolean query   then the certain answer is    if
q is true in all the models of the ontology embedding the database  and  otherwise  in the
following  we assume that the closed formula q x   is neither valid nor inconsistent under
the ontology kb  given a substitution    x   c assigning to variables distinct constants
not appearing in q  nor in kb  nor in cdb   this would lead to trivial reformulations 
we now show that we can weaken the standard name assumption for the constants by
just assuming unique names  without changing the certain answers  as we said before  an
interpretation i satisfies the standard name assumption if ci   c for any c  c  alternatively  an interpretation i satisfies the unique name assumption  una  if ai    bi for
any different a  b  c  we denote the set of all interpretations satisfying standard name
assumption as i sna   we denote the set of all interpretations satisfying unique name
assumption as i una   the following proposition allows us to freely interchange the standard name and the unique name assumptions with interpretations embedding databases 
this is of practical advantage  since we can encode the unique name assumption in classical
first order logic reasoners  and many description logics reasoners do support natively the
unique name assumption as an extension to owl 
proposition    sna vs una   for any query q x    ontology kb and database db 
    dom     x  rng    c   i  i sna   m  kb   e db    i    q x      
    dom     x  rng    c   i  i una   m  kb   e db    i    q x     
since a query can be an arbitrary first order formula  its answer may depend on the
domain  which we do not know in advance  for example  the query q x    student x 
over the database student a   student b   with domain  a  b  c  has the answer  x   c  
while with domain  a  b  c  d  has the answer  x   c  x   d   therefore  the notion of
domain independent queries has been introduced in relational databases  here we adapt
the classical definitions  avron        abiteboul et al         to our framework  we need
a more general version of domain independence  namely domain independence w r t an
ontology  i e   restricted to the models of an ontology 
definition    domain independence   a formula q x  is domain independent with
respect to an ontology kb iff for every two models i and j of kb  i e   i   hi   i i
and j   hj   j i  which agree on the interpretation of the predicates and constants  i e 
i   j    and for every substitution    x   i  j we have 
rng    i and i      q x  iff
rng    j and j       q x   
the above definition reduces to the classical definition of domain independence whenever
the ontology is empty 
a weaker version of domain independencewhich is relevant for open formulasis the
following 
definition    ground domain independence   a formula q x  is ground domain independent iff q x   is domain independent for every substitution    x   c 
   

fifranconi  kerhet    ngo

for example  the formula p  x  is ground domain independent  but it is not domain independent 
the problem of checking whether a fol formula is domain independent is undecidable
 abiteboul et al          the well known safe range syntactic fragment of fol introduced
by codd is an equally expressive language  indeed any safe range formula is domain independent  and any domain independent formula can be easily transformed into a logically
equivalent safe range formula  intuitively  a formula is safe range if and only if its variables
are bounded by positive predicates or equalities  for full details see appendix a     for
example  the formula a x   b x  is safe range  while queries a x  and x  a x  are
not  to check whether a formula is safe range  the formula is transformed into a logically
equivalent safe range normal form and its range restriction is computed according to a set
of syntax based rules  the range restriction of a formula is a subset of its free variables  and
if this coincides with the free variables then the formula is said to be safe range  abiteboul
et al          similar to domain independence  a formula is ground safe range if any grounding of this formula is safe range  an ontology kb is safe range  domain independent   if
every formula in kb is safe range  domain independent  
the safe range fragment of first order logic with the standard name assumption is
equally expressive to the relational algebra  which is the core of sql  abiteboul et al  
      

   determinacy
the certain answer to a query includes all the substitutions which make the query true in
all the models of the ontology embedding the database  so  if a substitution would make the
query true only in some model  then it would be discarded from the certain answer  in other
words  it may be the case that the answer to the query is not necessarily the same among
all the models of the ontology embedding the database  in this case  the query is not fully
determined by the given source data  indeed  there is some answer which is possible  but
not certain  due to the indeterminacy of the query with respect to the data  the complexity
to compute the certain answer in general increases up to the complexity of entailment in
the logic  in this paper we focus on the case when a query has the same answer over all the
models of the ontology embedding the database  namely  when the information requested
by the query is fully available from the source data without ambiguity  in this way  the
indeterminacy disappears  and the complexity of the process may decrease  see section    
the determinacy of a query w r t  a source database  nash et al         marx        fan
et al         has been called implicit definability of a formula  the query  from a set of
predicates  the database predicates  by beth        
definition    finite determinacy or implicit definability   a query q x  is  finitely 
determined by  or implicitly definable from  the database predicates pdb under kb iff for
any two models i and j of the ontology kbboth with a finite interpretation to the
database predicates pdb whenever i pdb c   j  pdb c then for every substitution
   x   i we have  i      q x  iff j       q x   
intuitively  the answer of an implicitly definable query does not depend on the interpretation of non database predicates  once the database and a domain are fixed  it is never
   

fiexact query reformulation over dbs with fo and dl ontologies

the case that a substitution would make the query true in some model of the ontology
and false in others  since the truth value of an implicitly defined query depends only on
the interpretation of the database predicates and constants and on the domain  which are
fixed   in practice  by focussing on finite determinacy of queries we guarantee that the user
can always interpret the answers as being not only certain  but also exactnamely that
whatever is not in the answer can never be part of the answer in any possible world 
in the following we focus on ontologies and queries in those fragments of fol c  p  for
which determinacy under models with a finite interpretation of database predicates  finite
determinacy  and determinacy under models with an unrestricted interpretation of database
predicates  unrestricted determinacy  coincide  we say that these fragments have finitely
controllable determinacy  we require that whenever a query is finitely determined then it is
also determined in unrestricted models  the reverse is trivially true   indeed  the results in
this paper would fail if finite determinacy and unrestricted determinacy do not coincide  it
can be shown  gurevich        that theorem   below fails if we consider only models with
a finite interpretation of database predicates 
example    example from database theory   let p    p  r  a   pdb    p  r  
kb    x  y  z  r x  y   r x  z   y   z 
x  y  r x  y   z  r z  x  
 x  y  r x  y   z  r y  z     x  a x   p  x    
the formula x  y  r x  y   z  r y  z  is entailed from the first two formulas only over
finite interpretations of r  the query q   a x  is finitely determined by p  it is equivalent
to p  x  under the models with a finite interpretation of r   but it is not determined by any
database predicate under models with an unrestricted interpretation of r  this knowledge
base does not enjoy finitely controllable determinacy 
the exact reformulation of a query  nash et al          also called explicit definition by
beth        is a formula logically equivalent to the query which makes use only of database
predicates and constants 
definition    exact reformulation or explicit definability   a query q x  is explicitly definable from the database predicates pdb under the ontology kb iff there is some
b x  in fol c  p   such that kb    x q x   q
b x  and  q 
b  pdb   we call
formula q
b x  an exact reformulation of q x  under kb over pdb  
this formula q
determinacy of a query is completely characterised by the existence of an exact reformulation of the query  it is well known that a first order query is determined by database
predicates if and only if there exists a first order exact reformulation 
theorem    projective beth definability  beth         a query q is implicitly definable from the database predicates pdb under an ontology kb  iff it is explicitly definable as
b in fol c  p  over pdb under kb 
a formula q
e the formula obtained from it by uniformly replacing
let q be any formula in l and q
every occurrence of each non database predicate p with a new predicate pe  we extend this
renaming operator e to any set of formulas in a natural way  one can check whether a query
is implicitly definable by using the following theorem 
theorem    testing determinacy  beth         a query q x  is implicitly definable
g    x q x   q
e x   
from the database predicates pdb under the ontology kb iff kb  kb

   

fifranconi  kerhet    ngo

   exact safe range query reformulation
in this section we analyse the conditions under which the original query answering problem
corresponding to an entailment problem can be reduced systematically to a model checking
problem of a safe range formula over the database  e g   using a database system with
sql   given a database signature pdb   an ontology kb  and a query q x  expressed in l
and determined by the database predicates  our goal is to find a safe range reformulation
b x  of q x  in fol c  p   that when evaluated as a relational algebra expression over a
q
legal database instance  gives the same answer as the certain answer of q x  to the database
under kb  this can be reformulated as the following problem 
problem    exact safe range query reformulation   find an exact reformulation
b x  of q x  under kb as a safe range query in fol c  p  over pdb  
q
since an exact reformulation is equivalent under the ontology to the original query  the
certain answer of the original query and of the reformulated query are identical  more
precisely  the following proposition holds 
proposition    given a database db  let q x  be implicitly definable from pdb under kb
b x  be an exact reformulation of q x  under kb over pdb   then 
and let q
    dom     x  rng    c   i  m  kb   e db    i    q x      
b x     
    dom     x  rng    c   i  m  kb   e db    i    q
from the above equation it is clear that in order to answer an exactly reformulated query 
one may still need to consider all the models of the ontology embedding the database  i e  
we still have an entailment problem to solve  the following theorem states the condition
to reduce the original query answering problembased on entailmentto the problem of
checking the validity of the exact reformulation over a single model  the condition is that
the reformulation should be domain independent  indeed there is only one interpretation
 with a particular domain  embedding the database with the signature restricted to the
database predicates 
theorem    adequacy of exact safe range query reformulation   let db be
b x  is an exact domain
a database which is legal for kb  and let q x  be a query  if q
independent  or safe range  reformulation of q x  under kb over pdb   then 
    dom     x  rng    c   i  m  kb   e db    i    q x      
b db   i   hc  i i  e db    i p
    dom     x  rng    adom  q  

db c

b x     
   q

a safe range reformulation is necessary to transform a first order query to a relational
algebra query which can then be evaluated by using sql techniques  the theorem above
shows in addition that being safe range is also a sufficient property for an exact reformulation to be correctly evaluated as an sql query  let us now see an example in which we
cannot reduce the problem of answering an exact reformulation to model checking over a
database  if the exact reformulation is not safe range 
example    let p    p  a   pdb    p    c    a  
db    p  a  a    kb    y  p  a  y   a y   
b x    y  p  x  y   i e   x    x   
q x    q
   

fiexact query reformulation over dbs with fo and dl ontologies

 c includes the active domain cdb  it is actually equal  
 db is legal for kb because there is i   h a   i i such that p i     a  a    ai   
and obviously  i  m  kb  
     dom     x  rng    c   i  m  kb   e db    i    q x        because
one can take i   h a  b   i i such that p i     a  a    ai    b   then i  m  kb  
e db   but for the only possible substitution  x  a  we have  i     y p  a  y  
 however 
b db   i   hc  i i  e db    i p c    q
b x      
    dom     x  rng    adom  q  
db

 x  a 
as we have seen  answers to a query for which a reformulation exists will contain only
constants from the active domain of the database and the query  therefore  ground statements in the ontology involving non database predicates and non active domain constants
 for example  as abox statements  will not play any role in the final evaluation of the
reformulated query over the database 

   conditions for an exact safe range reformulation
we have just seen the importance of getting an exact safe range query reformulation  in
this section we are going to study the conditions under which an exact safe range query
reformulation exists 
first of all  we will focus on the semantic notion of safe range namely domain independence  while implicit definability isas we already knowa sufficient condition for the
existence of an exact reformulation  it does not guarantee alone the existence of a domain
independent reformulation 
example    let p    a  b   pdb    a   kb    x b x   a x    q   b x  
then q is implicitly definable from pdb under kb  and every exact reformulation of q over
pdb under kb is logically equivalent to a x  and not domain independent 
by looking at the example  it seems that the reason for the non domain independent
reformulation lies in the fact that the ontology  which is domain independent  cannot guarantee existence of an exact domain independent reformulation of the non domain independent
query  however  let us consider the following example 
example    let pdb    a  c   kb    a a  
y b y   c x   it is easy to see that kb is
is implicitly definable from pdb under kb  and
independent reformulation of q 

x  a x   b x   and let a query q  
domain independent and q is not  q
b   a a   c x  is an exact domain
q

it is obvious that in spite of the fact that the query q is not domain independent  it
is domain independent with respect to the ontology kb  in other words  in this case the
ontology guarantees the existence of an exact domain independent reformulation 
with queries that are domain independent with respect to an ontology  the following
theorem holds  giving the semantic requirements for the existence of an exact domain
independent reformulation 
   

fifranconi  kerhet    ngo

theorem    semantic characterisation   given a set of database predicates pdb   a
domain independent ontology kb  and a query q x    a domain independent exact reformub x  of q x  over pdb under kb exists if and only if q x  is implicitly definable from
lation q
pdb under kb and it is domain independent with respect to kb 
the above theorem shows us the semantic conditions to have an exact domain independent reformulation of a query  but it does not give us a method to compute such reformulation and its equivalent safe range form  the following theorem gives us sufficient
conditions for the existence of an exact safe range reformulation in any decidable fragment of
fol c  p  where finite and unrestricted determinacy coincide  and gives us a constructive
way to compute it  if it exists 
theorem    constructive   if 
g    x  q x   q
e x   that is  q x  is implicitly definable  
   kb  kb
   q x  is safe range  that is  q x  is domain independent  
   kb is safe range  that is  kb is domain independent  
b x  of q x  as a safe range query in fol c  p 
then there exists an exact reformulation q
over pdb under kb  that can be obtained constructively 
in order to constructively compute the exact safe range query reformulation we use the
b x  from a
tableau based method to find the craigs interpolant  fitting        to compute q
gq
e x     see section   for full details 
validity proof of the implication  kb  q x      kb
let us now consider a fully worked out example  adapted from the paper by nash et al 
       
example    given  p    r  v    v    v    a   pdb    v    v    v    adom  where adom is the
active domain of db 
kb     x  y  v   x  y   z  v  r z  x   r z  v   r v  y  
x  y  v   x  y   z  r x  z   r z  y  
x  y  v   x  y   z  v  r x  z   r z  v   r v  y  
q x  y    z  v  u  r z  x   r z  v   r v  u   r u  y   
the conditions of the theorem are satisfied  q x  y  is implicitly definable from pdb under
kb  q x  y  is safe range  kb is safe range 
b y 
therefore  with the tableau method one finds the craigs interpolant to compute q x 
g
e
b
from a validity proof of the implication  kb  q x      kb  q x    and obtain q x  y   
z  v   x  z   v   v   v  z   v   v  y  an exact ground safe range reformulation  since
b y   adom x  
the answer of q is in the active domain  we also have kb    q x 
b
adom y   then kb    q x  y   q x  y   adom x   adom y   therefore  z  v   x  z  
v   v   v  z   v   v  y  adom x adom y  is an exact safe range reformulation of q x  y 
from pdb under kb 
   

fiexact query reformulation over dbs with fo and dl ontologies

   constructing the safe range reformulation
in this section we introduce a method to compute a safe range reformulation of an implicitly
definable query when conditions in theorem   are satisfied  the method is based on the
notion of interpolant introduced by craig        
definition    interpolant   the sentence  is an interpolant for the sentence   
in fol c  p   if all predicate and constant symbols of  are in the set of predicate and
constant symbols of both  and   and both    and    are valid sentences in
fol c  p  
theorem    craigs interpolation   if    is a valid sentence in fol c  p   and
neither  nor  are valid  then there exists an interpolant 
note  that the beth definability  theorem    and craigs interpolation theorem do not
hold for all fragments of fol c  p   an interpolant may not always be expressed in the
fragment itself  but obviously it is in fol c  p   because of theorem    
an interpolant is used to find an exact reformulation of a given implicitly definable
query as follows 
theorem    interpolant as definition   let q x  be a query with n    free variables
implicitly definable from the database predicates pdb under the ontology kb  then  the
closed formula with c         cn distinct constant symbols in c not appearing in kb or q x   
 
 
g q
e x c      c    
   kb   q x c       cn         kb 
   
n
 
b c      c  x  is an exact reformulation of q x  under kb over
is valid  and its interpolant q
n
 
pdb  
therefore  to find an exact reformulation of an implicitly definable query in terms of
database predicates it is enough to find an interpolant of the implication     and then to
substitute all the constants c            cn back with the free variables x of the original query 
an interpolant can be constructed from a validity proof of     by using automated theorem
proving techniques such as tableau or resolution  in order to guarantee the safe range
property of the reformulation  we use a tableau method as in the book by fitting        
    tableau based method to compute an interpolant
in this section we recall in our context the tableau based method to compute an interpolant  fitting        
assume    is valid  therefore    is unsatisfiable  then there is a closed tableau
corresponding to     in order to compute an interpolant from this tableau one needs
to modify it to a biased tableau 
definition    biased tableau   a biased tableau for formulas    is a tree t    v  e 
where 
 v is a set of nodes  each node is labelled by a set of biased formulas  a biased formula
is an expression in the form of l   or r   where  is a formula  for each node n 
s n  denotes the set of biased formulas labelling n 
   

fifranconi  kerhet    ngo

 the root of the tree is labelled by  l    r   
 e is a set of edges  given   nodes n  and n     n    n     e iff there is a biased
completion rule from n  to n    we say there is a biased completion rule from n  to
n  if
 y    is the result of applying a rule to x    where x and y refer to l or r
 for some rules  there are two possibilities of choosing y      and
 s n       s n       x       y     
let c be the set of all constants in the input formulas of the tableau  c par extends c
with an infinite set of new constants  a constant is new if it does not occur anywhere in
the tableau  with these notations  we have the following rules  
 propositional rules
x  
x  

negation rules
x   
x  

rule
x       

x  
x   

x    
x    

rule
x         
x       x    

 first order rules
rule
x x  

rule
x x  

x  t  
for any t  c par

x  c  
for a new constant c

 equality rules
reflexivity rule

replacement rule
x t   u 
y   t  

x  
t

x t   t 
occurs in 

y   u  

c par

a node in the tableau is closed if it contains x   and y     if a node is closed  no
rule is applied  in the other words  it becomes a leaf of the tree  a branch is closed if it
contains a closed node and a tableau is closed if all of its branches are closed  obviously  if
the standard tableau for fol is closed then so is the biased tableau and vice versa 
given a closed biased tableau  the interpolant is computed by applying interpolant rules 
int
an interpolant rule is written as s  i  where i is a formula and
s    l      l           l n    r      r           r m    
 rules for closed branches
int

int

r   s   l    l     

r   s   r    r      

int

int

r   s   l     

r   s   r      
int

int

r   s   l    r     

r   s   r    l     
   

fiexact query reformulation over dbs with fo and dl ontologies

 rules for propositional cases
int
s   x     i
p  

p  

p  

int

p  

int

s   x     i
int
s   x      x       i

s   x      i
int

int

p  

s   x     i
int

s   x     i
s   x      i
int
int
s   l       i  s   l       i 
p  

int

int

s   x          i
s   l            i   i 
int
int
s   r       i  s   r       i 
int

s   r            i   i 
 rules for first order cases  
int
s   x  p     i
f  

f  

f  

f  

f  

where p is a parameter that does not occur in s or 

int

s   x x  x     i
int
s   l  c     i
int

if c occurs in           n  

s   l x  x     i
int
s   r  c     i
int

if c occurs in           m  

s   r x  x     i
int
s   l  c     i
int

s   l x  x     x i c x 
int
s   r  c     i
int

if c does not occur in           n  
if c does not occur in           m  

s   r x  x     x i c x 
 rules for equality cases
int
s   x  p    x t   t    i
e  

e  

int

int

e  

s   x  p     i
int
s   l  u    r t   u    i
int

s   x  u    x t   u    i
int

s   x  t    x t   u    i
if u occurs in  t            m

s   l  t    r t   u    t   u  i
int
s   r  u    l t   u    i

if u occurs in  t            m
int
s   r  t    l t   u    t   u  i
int
s   l  u    r t   u    i
e  
if u does not occur in  t            m
int
s   l  t    r t   u    i u t 
int
s   r  u    l t   u    i
e  
if u does not occur in  t            m
int
s   r  t    l t   u    i u t 
e  

in summary  in order to compute an interpolant of  and   one first need to generate
a biased tableaux proof of unsatisfiability of    using biased completion rules and then
apply interpolant rules from bottom leaves up to the root 
let us consider an example to demonstrate how the method works 
example    let p    s  g  u    pdb    s  u   
   

fifranconi  kerhet    ngo

kb     x s x    g x   u  x   
x g x   s x  
x u  x   s x  
x g x   u  x   
q x    g x 
obviously  q is implicitly definable from s and u   since the ontology states that g and
u partition s  now we will follow the tableau method to find its exact reformulation  for
int
compactness  we use the notation s i instead of s  i 
s     l x s x    g x   u  x     
l x g x   s x    
l x u  x   s x    
l x g x   u  x    
l g c   
r x s x    g   x   u  x     
r x g   x   s x    
r x u  x   s x    
r x g   x   u  x    
r g   c   
by applying the rule for  and removing the implication  we have 
s     l s c   g c   u  c   
l g c   s c    
l u  c   s c   
l g c   u  c   
l g c   
r s c   g   c   u  c   
r g   c   s c   
r u  c   s c   
r g   c   u  c   
r g   c   
and the interpolant of s  can be computed as follows 
s    r s c  s c 

s    r u  c   u  c 

s    s    r s c   u  c    s c u  c  



s    r g   c    

 s c u  c  

b  

s    l g c   

s    s    l u  c   

 s c u  c  

s    s    l s c   

 s c u  c  

b  

s    l g c   

b  

s 

b
therefore  s c u  c  is the interpolant and q x 
  s x u  x  is an exact reformulation
of q x  
   

fiexact query reformulation over dbs with fo and dl ontologies

algorithm   safe range reformulation
input  a safe range kb  a safe range and implicitly definable query q x   
output  an exact safe range reformulation 
b x  as in theorem  
   compute the interpolant q
b x  do
   for each free variable x which is not bounded by any positive predicate in q
b x     q
b x   adom b  x 
q
q
b x 
   return q

    a safe range reformulation
now we want to show that the reformulation computed by the above tableau based method
under the condition of theorem   generates a ground safe range query 
theorem    ground safe range reformulation   let kb be an ontology  and let q be
a query which is implicitly definable from pdb   if kb and q are safe range then a rewritten
b obtained using the tableau method described in section     is ground safe range 
query q
in other words  the conditions of theorem   guarantee that all quantified variables in the
reformulation are range restricted  we need to consider now the still unsafe free variables 
the theorem below will help us deal with non range restricted free variables  let us first
define the active domain predicate of a query q as the safe range formula 
adom q  x    
 w
w
p pq z            zar p      p  x  z            zar p              p  z            zar p      x  
ccq  x   c  

theorem    range of the query   let kb be a domain independent ontology  and let
q x       xn   be a query which is domain independent with respect to kb  then
kb    x            xn   q x       xn    adom q  x            adom q  xn   
given a safe range ontology  a safe range and implicitly definable query is obviously
domain independent with respect to the ontology  in this case  theorem   says that the
answer of the reformulation can only include active domain elements  therefore  the active
domain predicate can be used as a guard for free variables which are not bounded by any
positive predicate 
based on theorem   and theorem    we propose a complete procedure to construct a
safe range reformulation in algorithm   

   the guarded negation fragment of alchoiq
alchoiq is an extension of the description logic alc with role hierarchies  individuals 
inverse roles  and qualified cardinality restrictions  it corresponds to the shoiq description logic without transitive roles  it is the logic at the basis of owl  the syntax and
semantics of alchoiq concept expressions is summarised in the figure    where a is an
atomic concept  c and d are concepts  o is an individual name  p is an atomic role  and
r is either p or p    the forall and the qualified and unqualified atmost operators can be
derived by using negation and the atleast operator in the usual way  a tbox in alchoiq
   

fifranconi  kerhet    ngo

syntax
a
 o 
p
p
c
c ud
c td
 nr
 nr c

semantics
ai  i
 oi    i
p i  i  i
  y  x   x  y   p i  
i  c i
c i  di
c i  di
 x    y  x  y   ri     n 
 x    y  x  y   ri    c i    n 

figure    syntax and semantics of alchoiq concepts and roles
is a set of concept inclusion axioms c v d and role inclusion axioms r v s  where c  d
are concepts and r  s are roles  with the usual description logics semantics 
in this section  we present an application of theorem    by introducing the alchoiqgn
description logic  the guarded negation syntactic fragment of alchoiq  figure    which
happens to express exactly the domain independent concepts and tboxes of alchoiq 
the language restricts alchoiq by just prescribing that negated concepts should be
guarded by some generalised atom  an atomic concept  a nominal  an unqualified atleast
number restriction   i e   absolute negation is forbidden  similarly  the derived forall and
atmost operators would be guarded by using their standard definition as the dual of the
atleast operator  but with the guarded negation  alchoiqgn is actually at the intersection of the gnfo fragment  barany  ten cate    otto        and alchoiq  see
appendix a   for details on gnfo  
alchoiqgn has the very important property of coinciding with the domain independent fragment of alchoiq  therefore providing an excellent candidate language for
ontologies and queries satisfying the conditions of theorem   
theorem     expressive power equivalence   the domain independent fragment of
alchoiq and alchoiqgn are equally expressive 
in other words the theorem says that any domain independent tbox axiom and any
domain independent concept query in alchoiq is logically equivalent  respectively  to a
tbox axiom and a concept query in alchoiqgn   and vice versa  this theorem provides
the description logics version of codds theorem  codds theorem states that the safe range
syntactic fragment of fol and the domain independent fragment of fol are precisely
equivalent in expressive power  that is  a database query can be formulated in one language
if and only if it can be expressed in the other 
r
b
c

   
   
   

p   p
a    o     nr
b    nr c    nr c   b u c   c u d   c t d
figure    syntax of alchoiqgn concepts and roles
   

fiexact query reformulation over dbs with fo and dl ontologies

    applying the constructive theorem
we want to reformulate concept queries over an ontology with a dbox so that the reformulated query can be evaluated as an sql query over the database represented by the dbox 
in this context  the database is a dbox  the ontology is an alchoiqgn tbox  and the
query is an alchoiqgn concept query  a concept query is either an alchoiqgn
concept expression denoting an open formula with one free variable  or an alchoiqgn
abox concept assertion denoting a boolean query  as expected  a dbox includes ground
atomic statements of the form a a  and p  a  b   where a is an atomic concept and p is an
atomic role   from theorem    we can draw the following corollary 
corollary    alchoiqgn tboxes and concept queries are domain independent 
we can also prove the following theorem 
theorem     alchoiqgn tboxes with concept queries have finitely controllable determinacy 
therefore  we satisfy the conditions of theorem    with a language which is like the
very expressive alchoiq description logic  but with guarded negation 
we argue that non guarded negation should not appear in a cleanly designed ontology 
and  if present  should be fixed  indeed  the use of absolute negative informationsuch as 
e g   in a non male is a female   male v female should be discouraged by a clean
design methodology  since the subsumer would include all sorts of objects in the universe
 but the ones of the subsumee type  without any obvious control  only guarded negative
information in the subsumee should be allowedsuch as in the axiom a non male person
is a female  person u  male v female  
this observation suggests a fix for non guarded negations  for every non guarded negation users will be asked to replace it by a guarded one  where the guard may be an arbitrary
atomic concept  or nominal  or non qualified existential  therefore  the user is asked to make
explicit the type of that concept  in a way to make it domain independent  note that the
type could be also a fresh new atomic concept  we believe that the fix we are proposing
for alchoiq is a reasonable one  and would make all alchoiq ontologies eligible to
be used with our framework 
    a complete procedure
alchoiqgn is a decidable logic and it is a feasible application of our general framework 
given an alchoiqgn ontology kb and a concept query q  we can apply the procedure
below to generate a safe range reformulation over the database concepts and roles  based
on the constructive theorem  all the conditions of which are satisfied   if it exists 
input  an alchoiqgn tbox kb  a concept query q in alchoiqgn   and a
database signature  database atomic concepts and roles  
g    q  q
e using
   check the implicit definability of the query q by testing if kb  kb
a standard owl  reasoner  alchoiqgn is a sublanguage of owl    continue if
this holds 
   

fifranconi  kerhet    ngo

b from the tableau proof generated in step    see
   compute a safe range reformulation q
section     this can be implemented as a simple extension of a standard dl reasoner
even in the presence of the most important optimisation techniques such as semantic
branching  absorption  and backjumping as explained by seylan et al         and ten
cate  franconi  and seylan        
b expressed over the database signature 
output  a safe range reformulation q
note that the procedure for checking determinacy and computing the reformulation
could be run in offline mode at compile time  indeed  it could be run for each atomic concept
in the ontology  and store persistently the outcome for each of them if the reformulation has
been successful  this pre computation may be an expensive operation  sinceas we have
seenit is based on entailment  but the complexity involves only the size of the ontology
and not of the data 
in order to get an idea about the size of the reformulations  for the alcf i description
logic there is a tableau based algorithm computing explicit definitions of at most double
exponential size  ten cate et al         ten cate  franconi    seylan         this algorithm is
optimal because it is also shown that the smallest explicit definition of an implicitly defined
concept may be double exponentially long in the size of the input tbox 
clearly  similarly to dl lite reformulations  more research is needed in order to optimise
the reformulation step in order to make it practical  however  note that the framework
presented here has a clear advantage from the point of view of conceptual modelling since
implicit definitions  that is  queries  under general tboxes can be double exponentially
more succinct than acyclic concept definitions  that is  explicit queries over the database  
there is also another interesting open problem about checking that a given database
is legal with respect to a given ontology  remember that a database db is legal for an
ontology kb if there exists a model of kb embedding db  this check involves heavy
computations for which an optimised algorithm is still unknown  as a matter of fact  the
only known method today is to reduce the problem to a satisfiability problem where the
database is embedded in a tbox using nominals  franconi et al          more research is
needed in order to optimise the reasoning with nominals in this special case 
appendix a   contains all the definitions and theorems needed to prove theorems   
and    

   conclusion
we have introduced a framework to compute the exact reformulation of first order queries
to a database under ontologies  we have found the exact conditions which guarantee that
a safe range reformulation exists  and we show that it can be evaluated as a relational
algebra query over the database to give the same answer as the original query under the
ontology  a non trivial case study has been presented in the field of description logics  with
the alchoiq language 
we have also implemented a tool based on the prover  theorem prover  mccune        
given an arbitrary first order ontology  a database signature  and an arbitrary first order
query in tptp syntax  the tool performs all the tests on them to check whether a reformulation can be computed  and it computes an optimal safe range reformulation 
   

fiexact query reformulation over dbs with fo and dl ontologies

this framework is useful in data exchange like scenarios  where the target database
 made by determined relations  should be materialised as a proper database  over which
arbitrary queries should be performed  this is not achieved in a context with non exact
rewritings preserving the certain answers  in our scenario with description logics ontologies 
rewritings of concept queries are pre computed offline once  we have shown that our framework works in theory also in the case of arbitrary safe range first order queries  and our tool
shows that this is possible in practice  in the case of description logics  we are working on
extending the theoretical framework with conjunctive queries  we need finitely controllable
determinacy with conjunctive queries  which seems to follow for some description logic from
the works by barany  gottlob  and otto        and rosati        
in future work  we would like to study optimisations of reformulations  from the practical perspective  since there might be many rewritten queries from one original query  the
problem of selecting an optimised query in terms of query evaluation is very important  in
fact  one has to take into account which criteria should be used to optimise  such as  the
size of the rewritings  the numbers of used predicates  the priority of predicates  the number
of relational operators  and clever usage of duplicates  with the tool  we plan to evaluate
our proposed technique in a real context 
concurrently  we are exploring the problem of fixing real ontologies in order to enforce
definability when it is known it should be the case  franconi  ngo    sherkhonov      c  
this happens when it is intuitively obvious that the answer of a query can be found from
the available data  that is  the query is definable from the database   but the mediating
ontology does not entail the definability  we introduce the novel problem of definability
abduction and we solve it completely in the data exchange scenario 
we thank the anonymous reviewers for the very useful comments we got on earlier versions of this paper  we wish to thank alex borgida  tommaso di noia  umberto straccia 
david toman  and grant weddell for the fruitful discussions we had on the topics of this
paper 

appendix a  proofs
a   proofs of section  
proposition  
proof 

let

asna       dom     x  rng    c   i  i sna m  kb e db    i    q x    
and
auna       dom     x  rng    c   i  i una m  kb e db    i    q x    
since sna is stricter than una  i e  i sna   i una   we have  auna  asna trivially 
let   asna   if  
  auna then there is an interpretation i   hi   i i embedding
db and satisfying una such that i  m  kb  and i     q x     let us construct new


interpretation j   hj   j i embedding db as follows 


 j     i    ai   a  c    c 
   

fifranconi  kerhet    ngo



 for each constant a  c  aj    a 


 for every predicate p  p  pj is constructed from pi by replacing of each element
ai  pi   where a is some constant  with a 
obviously  j satisfies sna and j and i are isomorphic  since first order logic sentences cannot distinguish two isomorphic structures  j     q x   which contradicts with
the assumption   asna   therefore   auna  
a   proofs of section  
proposition   
b x  is an exact reformulation of q x    kb    x q x   q
b x    then  for any
proof  since q
i
b x   
model i  m  kb  and for any substitution    x    we have  i      q x   q
b x    
which is equivalent to  i      q x   i      q
now  let  be any substitution from     dom     x  rng     c   i  m  kb  
e db    i    q x      and i   h  i i be any model of the kb embedding the db  if
there are any   let     i  a composition of the substitution  and the interpretation
function i  i e   x    a   iff  x    c  c and ci   a   then i      q x  
b x   i    q
b
b
i    q x   and i      q
 x     summing up  i    q x    i    q x    
b x      the
hence        dom     x  rng     c   i  m  kb   e db    i    q
inverse inclusion can be proved similarly 
theorem   
proof  first of all recall that we assume sna  in order to prove the theorem  one needs the
following two propositions 
proposition    domain independence   a query q x  is domain independent iff for
every two interpretations i   hi   i i and j   hj   j i which agree on the interpretation
of the predicates from pq  and all constants c   and for every substitution    x   i j
we have 
rng    i and i      q x 
iff
rng    j and j       q x   
proof     obviously  if the second part of the proposition holds  then the query is domain
independent 
   suppose  the query is domain independent  let i   hi   i i and j   hj   j i
be any two interpretations  which agree on the interpretation of all the predicates from pq
 and all constants c   that is i pq c   j  pq c   let us fix any substitution    x   i j
 if the query is closed  we just omit everything  that concerns a substitution below in the
proof  such that 
rng    i and i      q x   
   
   

fiexact query reformulation over dbs with fo and dl ontologies

 

 

let us consider interpretations i     hi   i i and j     hj   j i  such that i pq c  
 
 
 
i    pq c

  j  pq c   j  pq c   and p  p   pq   p i      p j   let us consider now i and
i     they have the same domain and interpret all the predicates and constants  occurring
in q x  equally  therefore  since i      q x   by       i         q x   
let us consider interpretations i   and j     by construction  they agree on interpretation of all predicates and constants  therefore  we can apply the definition of domain
independence to them  then  since
rng    i and i         q x   

   

rng    j and j         q x   

   

we have  that
then again interpretations j and j   have the same domain and interpret all the predicates
and constants  occurring in q x  equally  thus  because of     
rng    j and j       q x   

   

therefore             similarly            and the proposition is proved 

proposition    if q x  is domain independent  then for any interpretation i   h  i i
and any substitution    x     such that i      q x    the following holds 
rng    adom  q x     i  
proof  assume  that x    x   that is q has one free variable x  the proof can be easily
extended then to the general case  
let us prove by contradiction  suppose  there exists a substitution  x  b  such that
i   x  b     q x  and b     adom  q x    i   let us consider interpretation i    
h   a   i i  where a is any brand new element  that does not appear in   then i      x 
b     q x  because of domain independence of q x   consider then another interpretation
  
i      h   a   i i such that occurrence of b in interpretation of any predicate is replaced
with the element a  in other words  for any n ary predicate p  p    q x             a         
  
 
p i iff          b          p i  since by supposition b does not appear in interpretations of
predicates in the query   interpretations of all the other predicates and all the constants
are the same  then i    satisfies sna  even if b  c   then  since i      x  b     q x    by
construction of i    we have  i       x  a     q x   because we changed just interpretations
of predicates  that do not appear in the query  then since i   and i    have the same domain
and agree on interpretations of all the predicates in q x  and all constants  the following
holds  i      x  a     q x  
let us now consider interpretations i   h  i i and i     h   a   i i  they have the
same interpretation function  therefore  since q x  is domain independent and i      x 
a     q x   we have  rng  x  a      that is a    it is a contradiction  because by
supposition a    
   

fifranconi  kerhet    ngo

now we prove the theorem itself 
l        dom     x  rng    c   i  m  kb   e db    i    q x     
b db   i   hc  i i  e db    i p
r        dom     x  rng    adom  q  

db c

b x     
   q

b
let   l  then for any i  m  kb   e db  we have  i    q x   and i    q
 x    
because of proposition   
consider any j   hc  i i embedding db  i and j agree on interpretations of c
b  p which is a subset of pdb  
 since we have sna  and predicates from the set  q 
b x  is domain independent  by proposition   we have  j    q
b
then  since q
 x     since
b
b
b
 q x     pdb  c  j  p c    q
  since q x  is domain independent  by proposition
db

 x  

b x     j    adom  q
b x     j     adom  q
b x     db   because
  we have  rng    adom  q
b x     pdb  c  therefore  rng    adom  q
b x     db   then
we assume sna and  q
  r and  hence  l  r 
b x     db    then for any j   hc  i i embedding db we
let   r  rng    adom  q
b
b
have  j  pdb c    q
 x     then j    q x     consider any i  m  kb   e db   then j
b
and i agree on interpretations of c  since we have sna  and pdb   since  q
   pdb c
 x  

b x  is domain independent  by proposition   we have  i    q
b
b
and q
 x     since q x  is exact
reformulation of q x  under kb over pdb   by proposition   we have  i    q x     then
  l and  hence  r  l 
theorem   is proved completely 
a   definitions and proofs of section  
proposition    let kb be a domain independent ontology  if interpretation i   hi   i i
is a model of kb  then any j   hj   j i  such that i   j   is also a model of kb 
proof  let  be any sentence from kb  then  since i is a model of kb  i       is domain
independent  because kb is domain independent  hence  since i   j   j      thus  j is
a model of any sentence from kb  it means  that j is a model of kb 

proposition    let kb be an ontology  and let q x  be a query which is domain independent
with respect to kb  any exact reformulation of q x  under kb  over any set of predicates 
is also domain independent with respect to kb 
b x  be any exact reformulation of q x  under kb  over some set of predicates  
proof  let q
i
i
i   h    i and j   hj   j i be any two models of kb such that i   j   and
   x   i  j be any substitution such that
b x   
rng    i and i      q
b
then  since q x  is exact reformulation of q x    we have  i      q x    then  since q x 
is domain independent with respect to kb  we have 
rng    j and j       q x   
b x  is exact reformulation of q x    we have  j       q
b x    thus  q
b x 
and again  since q
is domain independent with respect to kb by definition 

   

fiexact query reformulation over dbs with fo and dl ontologies

lemma    let kb be a domain independent ontology  and let q x  be a query which is
domain independent with respect to kb  then for any i   h  i i which is a model of kb
and any substitution    x    such that i      q x  the following holds 
rng    adom  q x     i  
proof  without loss of generality assume  that x    x   that is q has one free variable x
 the proof can be easily extended then to the general case  
let us prove by contradiction  suppose that i   x  b     q x   where b    
adom  q x     i   since kb is domain independent  for any brand new element a  that
does not appear in   interpretation i   h   a   i i is also a model of kb by proposition
   then  since q x  is domain independent with respect to kb and i and i have the same
interpretation function  i   x  b     q x  
 
consider a new interpretation i     h   a   i i constructed from i such that occurrence of b in interpretation of any predicate is replaced by element a  in other words  for
 
any n ary predicate p  p   pq            a          p i iff          b          p i  since by supposition
b does not appear in interpretations of predicates in the query  
then  since i   x  b     q x  and by construction of i   we have  i      x  a     q x 
 since we simply replace b  that does not appear neither as a constant in q x  nor in
interpretations of predicates in q x   with a   then  since i and i   have the same domain
   a  and agree on interpretations of all the predicates from q x  and all the constants
 since we assume sna   we have  i   x  a     q x  
let us now consider interpretations i   h  i i and i   h   a   i i  they are both
models of kb and have the same interpretation function i   so  since q x  is domain
independent with respect to kb and i   x  a     q x   we have  a   and i   x 
a     q x  by definition of domain independence with respect to an ontology  it is a
contradiction  because by supposition a     the lemma is proved 
let  be any set of formulas  then adom  is defined similarly to adom q   where q is
a query 
lemma    let kb be a domain independent ontology  and let q x   x    x         xn    be a
query which is domain independent with respect to kb  then the following holds 
kb    x q x   q x   adom kbq
where q x   adom kbq is q   x   adom kbq  x          adom kbq  xn    and q   x  is q x 
such that 
 every sub formula of q x  in the form of x  x  is replaced by x  x adom kbq  x 
 every sub formula of q x  in the form of x  x  is replaced by x adom kbq  x  
 x 
proof  without loss of generality  we will prove the lemma when n      in this case  we
write q x  instead of q x    we prove by contradiction 
assume there is a model i   hi   i i of kb and an element a  i such that i   x 
a     q x  but i   x  a      q x  adom kbq  
   

fifranconi  kerhet    ngo

we construct a new interpretation j   hadom ikbq  c  j i such that for any predicate
p  pkbq   p j    p i   and for any predicate p  p   pkbq   p j     
since kb is domain independent  j is also a model of kb by proposition    then 
j    x  a     q x  because q is domain independent with respect to kb  as a consequence  however  j    x  a     q x  adom kbq by the definition of q x  adom kbq  
q x  adom kbq is safe range by construction  see definition      hence  it is domain
independent  therefore i   x  a     q x  adom kbq   contradiction 
assume there is a model i   hi   i i of kb and an element a  i such that i   x 
a     q x  adom kbq but i   x  a      q x   one can lead to a contradiction similarly
as above  therefore  the lemma is proved 
theorem   
proof  the theorem can be proved after theorem   
 the if direction  based on lemma    one can see that exact reformulations of q x 
are also exact reformulations of q x   adom kbq   since q x   adom kbq is safe range
and kb can always be transformed to a logically equivalent safe range ontology kb    
b x  found in theorem   which takes
obviously the exact safe range reformulation q
 
kb and q x   adom kbq as its input is the exact domain independent reformulation
of q x   
 the only if direction 
b x  of q x 
suppose  that there exists an exact domain independent reformulation q
over pdb under kb  then it is domain independent with respect to kb  hence  by
proposition    q x  is domain independent with respect to kb  since there exists an
exact reformulation of q x    q x  is implicitly definable from pdb under kb by the
theorem   
the theorem is proved completely 
in order to help readers follow easier  we recall here formal definitions of safe range and
safe range normal form  abiteboul et al         
definition    safe range normal form   denoted by srnf
a first order formula can be transformed to srnf by following steps  
 variable substitution  no distinct pair of quantifiers may employ same variable 
 remove universal quantifiers
 remove implications
 push negation
 flatten and or
   

fiexact query reformulation over dbs with fo and dl ontologies

definition    range restriction of a formula   denoted by rr
input   a formula  in srnf
output   a subset of free   or 
case  of
 r e         en     rr     set of variables in e         en
 x   a or a   x  where a is a constant   rr      x 
 x   y   rr     
        rr     rr      rr    
        rr     rr      rr    
    x   y   rr     rr     if  x  y   rr         rr     rr       x  y  otherwise
     rr       rr    
 x    rr     rr      x  if x  rr      rr      otherwise
note     z     z    z   z    
definition     safe range   a formula  is safe range iff rr srnf      free   
definition     ground safe range   a formula  is ground safe range iff after substitution of free variables of  with constants it becomes safe range 
observation   
   for any query q x  and any interpretation i   h  i i the following holds 
adom iq   adom  q x     i  
   adom q  x  is safe range 
theorem   
proof  the theorem can be proved after theorem   and theorem   
we will use the following lemma in the proof 
lemma    if kb is an ontology  q x   x    x            xn    is ground safe range query and
kb    x  q x      x            n  xn   

   

b x     q x     x        n  xn  
where             n are n safe range formulas  then the query q
b
is safe range and kb    x  q x   q x   
   

fifranconi  kerhet    ngo

proof  let q  x  be a safe range normal form of the query q x    i e  q  x     srnf q x     
y   xy    where  xy  is in conjunctive normal form  the safe range normal form of the
query is in prenex normal form   then q  x  is ground safe range  and kb    q  x   q x   
hence  kb    x  q  x      x            n  xn    let q   x     q  x       x            n   xn   
where each i   xi     srnf i  xi     then by    kb    q  x   q   x    on the other hand
b x   q   by construction  summing up everything  we have  kb    q
b x  
kb    x  q
 x 

b x  is safe range 
q x  and the only thing we need to prove is that q
  
 
one can see  that q x   y    xy     x        n   xn    which is a safe range normal
b x    since q    y   xy  is ground safe range  then rr  xy      x   y   y 
form of q
 x 

where for any y  y y  there exists a conjunct x   y in  xy    for some x  x  then  since
each i   xi   is safe range  by definition of range restriction rr  xy      x        n   xn     
x  y  and then rr y    xy       x            n   xn       x   free q   x     therefore 
b x  is safey    xy       x            n   xn    is safe range by definition  and hence q
range 
let us continue to prove the theorem 
b by using
if x      q is closed  then we build an exact safe range reformulation q
theorem   
suppose now  x    x            xn    since q x  is safe range and implicitly definable from
pdb   we apply theorem   for q x  and construct a ground safe range rewriting q  x  expressed over pdb such that kb    x  q x   q  x    since q x  is domain independent
 since it is safe range   it is also domain independent with respect to kb  hence  by proposition    q  x  is also domain independent with respect to kb  moreover  kb is safe range
and  hence  domain independent  then by theorem   
kb    x  q  x   adom q  x            adom q  xn   
by the second item of observation   adom q  x  is a safe range formula  then by lemma  
b x     q   adom q   x            adom q   xn   is safe range and kb    x  q  
the query q
 x 
 x 
b x    since kb    x  q x   q    we have  kb    x  q x   q
b x    therefore  the
q
 x 

b x  is the one we were looking for 
constructed query q
theorem   is proved completely 
a   proofs of section  
theorem   
proof  first we will prove that if q is implicitly definable then the formula     is valid 
g    x q x   q
g
applying syntactic definition of implicit definability  kb  kb
 x    therefore 
when
we
replace
x
by
a
set
of
constants
c
 
    
c
 
the
following
formula
is valid
 
n
v
vg
e x c      c      as a consequence      is valid 
  kb  kb 
  q x c       cn    q
n
 
b c      c  x    where q
b x c      c   is a craig internext  we have to prove kb     q x   q
n
 
n 
 
b x c      c   is an interpolant 
polant of      since q
 

n

   

fiexact query reformulation over dbs with fo and dl ontologies

v
b x c      c  
      kb   q x c       cn      q
n
 
b x c      c    
then   kb     q x c       cn    q
n
 
g q
e x c      c    
b x c      c      v kb 
   q
n
n
 
 
g     q
b x c      c    q
e x c      c     
then   kb
n
n
 
 
b  pdb   the relation kb     q
b x c      c    q x c      c     holds as well
since  q 
n
n
 
 
from       we have the expected statement 
b x c      c      pdb then  q
b c      c  x     pdb  
last but not least  since  q
n
n
 
 
b c      c  x  is really an explicit definition of q
with above statements  q
n
 
theorem   
proof  we need the following propositions to prove the theorem 
proposition         is safe range and closed iff   and   are safe range and closed 
proof  we have 
 rr          rr      rr    
 free          free      free    
 rr        or rr      free    
 rr        or rr      free    
      is closed iff f ree       free       
   is closed iff free       
   is closed iff free       
      is safe range iff rr          free       
   is safe range iff rr       free    
   is safe range iff rr       free    
therefore 
      is closed iff   and   are closed
      is closed  safe range iff   and   are closed  safe range 

proposition         is safe range and closed iff   and   are safe range and closed 
proof  we have 
 rr          rr      rr    
   

fifranconi  kerhet    ngo

 free          free      free    
 rr        or rr      free    
 rr        or rr      free    
      is closed iff free       free       
   is closed iff free       
   is closed iff free       
      is safe range iff rr          free       
   is safe range iff rr       free    
   is safe range iff rr       free    
therefore 
      is closed iff   and   are closed
      is closed  safe range iff   and   are closed  safe range 

proposition     x  x  is closed and safe range then   t  is closed and safe range where
 t are constants 
proof  obviously  if  x  x  is closed then   t  is closed 
assume that   t  is not safe range  since its closed rr srnf   t      
 srnf   t   must contain a subformula which is in the form  z    t   z 
where  z   rr srnf     t   z   
 srnf   x   must contain a subformula which is in the form  z    x   z 
where  z   rr srnf     x   z   
 srnf   x   must contain a subformula which is in the form  z    x   z 
where  z   rr srnf     x   z    because pushing negation does not effect the formula under

 rr srnf   x      
 rr srnf  x  x      
 rr srnf  x  x      
 x  x  is not safe range
 contradiction 
proposition      x  x  is closed and safe range then   t  is closed and safe range where
 t are constants 
proof  undoubtedly  if  x  x  is closed then   t  is closed 
assume that   t  is not safe range  since it is closed  rr srnf   t      
 srnf   t   must contain a subformula which is in the form  z    t   z 
where  z   rr srnf     t   z   
   

fiexact query reformulation over dbs with fo and dl ontologies

 srnf   x   must contain a subformula which is in the form  z    x   z 
where  z   rr srnf     x   z   
 rr srnf   x      
 rr srnf  x  x      
 x  x  is not safe range
 contradiction 
based on these propositions  we prove theorem   as follows 
first  we will show that if  and  are closed and safe range and    is valid then
so is their interpolant  assume t is a biased tableau of of     therefore the root node
of t is s    l    r     based on all the tableau expansion rules and above propositions  at every expansion step where s    l           l n    r           r m              n
and          m are safe range and closed     
now we need to prove that the interpolant at each step is safe range and closed      by
induction on the shape of proof and the set of rules in section   
 rules for closed branches  its trivial because  and  are safe range and closed
because of    
 rules for propositional case  
for the rule  p   p   p   p   nothing changes  so one does not need to prove 
for the rule  p    apply the proposition         holds 
for the rule  p    apply the proposition        holds 
 rules for first order case  
for the rule  f    f    f   nothing changes  so one does not need to prove 
for the rule  f    since c does not occur in           n   then the only case to have c in
int
i is that s contains r  c    therefore s   l  c     i    c   since x  x  is
safe range  due to      then x i c x  is safe range too
for the rule  f    since c does not occur in           m   then the only case to have c in
int
i is that s contains l  c    therefore s   r  c     i    c   since x  x 
is safe range  due to      then x i c x  is safe range too
 rules for equality   because all the input formulas are closed and do not contain
function symbols  all equations are ground  therefore  they do not influence the
safe range property of interpolant in each step 
as a consequence  because q  c   kb  kb    q    c  are closed and safe range then so is the
b c  of kb  q  c  and kb    q    c  
interpolant q  
theorem   
proof  as a consequence of lemma    theorem   holds 
   

fifranconi  kerhet    ngo

a   definitions and proofs of section  
the safe range fragment of alchoiq  we call any axiom  concept  in alchoiq
 ground  safe range  if the corresponding logically equivalent  open  formula in fol c  p 
is  ground  safe range  for any concept c we denote the corresponding logically equivalent
formula in fol c  p  with one free variable x as c x   unfortunately concept inclusion
axioms in alchoiq ontologies may not be safe range  for example  the axiom  male v
female is not safe range  it is easy to see that an axiom c v d is not safe range if and only
if c x  is not safe range and d x  is safe range  just observe that the axiom is logically
equivalent to the formula x  c x   d x  in fol c  p   which is actually in a saferange normal form   the following proposition provides recursive rules deciding whether
an alchoiq concept is safe range 
proposition     let a be an atomic concept  let c and d be alchoiq concepts  and
let r be either an atomic role or an inverse atomic role  then 
   a   o    nr   nr c are safe range 
   c u d is safe range if and only if c is safe range or d is safe range 
   c t d is safe range if and only if c is safe range and d is safe range 
   c is safe range if and only if c is not safe range 
proof  it is enough to prove the proposition just for atomic roles because the order of
variables in binary atoms of a first order logic translation of an alchoiq concept does
not affect the safe range property of the translation  therefore hereafter we assume that r
is an atomic role 
 since a is an atomic concept  a x  is safe range 
  o  x     x   o    safe range 
   nr  x    x            xn   r x  x            r x  xn     x     x             xn     xn   safe range 
   nr c  x    x            xn   r x  x            r x  xn    c x            c xn     x    
x             xn     xn     safe range 
 let us prove  that  c u d  x    c x   d x  is safe range if and only if c x  is
safe range or d x  is safe range 
  let c x  or d x  be safe range and let both of them be in safe range normal
forms  then
c x   d x  is safe range by definition 
  let c x   d x  be safe range and in safe range normal form  i e  both c x  and
d x  are in safe range normal form   let us prove by contradiction  suppose  both
c x  and d x  are not safe range  then c x   d x  is not safe range by definition 
it is a contradiction  therefore  c x  is safe range or d x  is safe range 
   

fiexact query reformulation over dbs with fo and dl ontologies

 let us prove  that  c t d  x    c x   d x  is safe range if and only if c x  is
safe range and d x  is safe range 
  let c x  and d x  be both safe range and in safe range normal forms  then
c x   d x  is safe range by definition 
  let c x   d x  be safe range and in safe range normal form  i e  both c x  and
d x  are in safe range normal form   let us prove by contradiction  suppose  c x 
or d x  is not safe range  then c x   d x  is not safe range by definition  it is a
contradiction  therefore  c x  is safe range and d x  is safe range 
 let us prove  that c x  is safe range if and only if c x  is not safe range 
  let c x  be safe range  let us prove by contradiction  let c x  be also saferange  then both c x  and c x  are domain independent  but one can easily see
 looking at the definition of domain independence   that it is impossible  therefore 
c x  is not safe range    we need to prove  that if c x  is not safe range  then
c x  is safe range 
let us prove by induction on structure of the formula  suppose  the item is true for
any subformula of the formula c x  
suppose  c x  is not safe range  let us consider  using already proved items  all the
possible cases  when c x  is not safe range 
 c x     r d  x    y  r x  y   d y   y r x  y d y    not safe range 
where d is any  possibly complex  concept  then c x    y r x  y   d y 
is safe range by definition 
 suppose  c x     d u f   x  is not safe range  then d x  is not safe range and
f  x  is not safe range  since both d x  and f  x  are subformulas of c x   by
applying the current item we get  d x  and f  x  are safe range  c x  
 d x   f  x    d x   f  x    safe range  because d x  and f  x  are
safe range 
 suppose  c x     d t f   x  is not safe range  then d x  is not safe range or
f  x  is not safe range  since both d x  and f  x  are subformulas of c x   by
applying the current item we get  either d x  or f  x  is safe range  c x  
 d x   f  x    d x   f  x    safe range  because either d x  or f  x 
is safe range 
 suppose  c x    d x  is not safe range  we need to prove  that c x   d x 
is safe range  let us prove by contradiction  suppose  d x  is not safe range 
then  since d x  is a subformula of c x   by applying the current item we get 
d x   c x  is safe range  it is a contradiction  hence  c x  is safe range 
the item is proved completely 
the proposition is proved completely 
proposition     all alchoiq role inclusion axioms are safe range 
   

fifranconi  kerhet    ngo

proof  let s v r be any role inclusion axiom in alchoiq  the formula x  y  s x  y  
r x  y  is a first order logic translation of the axiom  where  x  y  stands for  x  y  if the
preceding role is atomic and  x  y  stands for  y  x  if the preceding role is inverse atomic 
this formula is safe range 
guarded negation first order logic  we recall the definition of guarded negation firstorder logic  gnfo  given in the paper by barany et al          gnfo is a fragment of
first order logic consisting of all formulas generated by the following recursive definition 
     r t            tn     t    t                  x       

   

where each ti is either a variable or a constant   in    is an atomic formula  possibly
an equality statement  containing all free variables of  
guarded negation fragment of alchoiq  now we consider alchoiqgn   a
guarded negation fragment of alchoiq  i e  an intersection of gnfo and alchoiq  
we say  that
 a concept c is an alchoiqgn concept if c is an alchoiq concept and the
corresponding first order logic translation c x  is expressed in gnfo 
 a concept inclusion axiom c v d is an alchoiqgn concept inclusion axiom if
c and d are alchoiq concepts and the formula x  c x   d x   which is
equivalent to the first order translation of c v d  is expressed in gnfo 
 a role inclusion axiom s v r is an alchoiqgn role inclusion axiom if s and r are
roles  atomic or inverse atomic  and the formula x  y  s x  y   r x  y    where
 x  y  stands for  x  y  if the preceding role is atomic and  x  y  stands for  y  x  if
the preceding role is inverse atomic  is expressed in gnfo 
it is easy to see  that any alchoiq role inclusion axiom is an alchoiqgn role inclusion
axiom  then because of proposition    the following holds 
proposition    

 all alchoiqgn role inclusion axioms are safe range 

 all safe range role inclusion axioms in alchoiq are in alchoiqgn  
from the definition of gnfo and alchoiq it follows  that the complex concept c
of the logic alchoiqgn is recursively defined as follows 
b     a    o     nr
c     b    nr c    nr c   b u c   c u d   c t d

   

where a is an atomic concept  r is an atomic role or an inverse atomic role  and c and d
are alchoiqgn concepts  possibly complex  
note  that in general  according to the definition     of gnfo all formulas with atleast
operator for n    are not in gnfo because of non guarded inequality statements xi   
xj   we fix this by assuming that inequality relation is actually a special binary database
predicate  this assumption is usual for databases 
   

fiexact query reformulation over dbs with fo and dl ontologies

also strictly speaking  nr u c is not in gnfo  indeed  the formula
 x            xn   r x  x            r x  xn     x     x             xn     xn     c x  is not in
gnfo  r x  y  here stands for p  x  y  if r stands for an atomic role p   and r x  y  stands
for p  y  x  if r stands for an inverse atomic role p     but it can be easily transformed to a
logically equivalent gnfo one by simply shifting the parentheses  x            xn    r x  x    
       r x  xn     x     x             xn     xn    c x    so  we can assume  that the formula
 nr u c is in alchoiqgn  
proposition     all alchoiqgn concepts are safe range 
proof  let us prove by induction on the structure of alchoiqgn concepts defined by
    
   a   o    nr   nr c   nr c  c is an alchoiqgn concept  are safe range
because of the item   of proposition    
   for any atomic concept a  any individual o any role r and any natural number n the
concepts a u c   o  u c and  nr u c are safe range because of the item   of
proposition    and since a   o  and  nr are safe range by the first item 
   suppose  that alchoiqgn concepts c and d are safe range  then the concepts
c u d and c t d are safe range by the items   and   of proposition    respectively 
the proposition is proved 
lemma    for any safe range concept c in alchoiq the following holds 
c v b  t       t bn  
where bi appears as a subconcept in c and is one of the following concepts 
 an atomic concept a 
  o   where o is an individual name 
  nr  where r is an atomic role or inverse atomic role  n is a natural number 
proof  let us prove the proposition by induction for all safe range concepts of alchoiq 
 a   o    nr   nr c are safe range by proposition     a v a   o  v  o    nr v
 nr   nr c v  nr 
suppose now that c is a complex safe range concept and the proposition holds for all
safe range subconcepts of c 
   c   c  u c    safe range  then either c  or c  is safe range  let c  be safe range 
hence  c  v b  t       t bm   where bi is a concept of the aforementioned type  then
c  u c  v c  v b   t       t b m  
   c   c  t c    safe range  then c  and c  are safe range  hence  c  v b  t       t bk
and c  v bk   t       t bm   where bi is a concept of the aforementioned type  then
c  t c  v  b  t       t bk   t  bk   t       t bm   v b  t       t bm  
   

fifranconi  kerhet    ngo

   c   d is safe range  by proposition    it is possible if and only if d is not saferange  that is one of the following cases takes place 
 d   d  u d    then d  d  t d    and we reduced this case to the item   
 d   d  t d    then d  d  u d    and we reduced this case to the item   
 d   d    then d  d   d    hence  d  is a safe range subconcept of d 
then the proposition holds for d  and  hence  also for c  because c  d  d   
the lemma is proved completely 
lemma    for any alchoiq concept c there exists an alchoiqgn concept c   such
that either c  c   or c  c    
proof  suppose that the lemma holds for all alchoiq subconcepts of the alchoiq
concept c  let us prove it for c 
   base  a   o    nr are alchoiqgn concepts by the definition of alchoiqgn
concept     
   c    nr d and d  is an alchoiqgn concept such that d  d  or d 
d    then c  nr d  or c  nr d     nr d  and  nr d  are both
alchoiqgn concepts  hence  the item is proved 
   c   d and d  is an alchoiqgn concept such that d  d  or d  d    then
c  d  or c  d   d    the item is proved 
   c   c  u c  and c   is an alchoiqgn concept such that c   c   or c   c     c  
is an alchoiqgn concept such that c   c   or c   c     consider all possible
cases 
 a  c   c   and c   c     then c  c     where c     c   u c   is an alchoiqgn
concept  because c   and c   are alchoiqgn concepts  
 b  c   c   and c   c     then c  c   u c     c   t c       c     where
c     c   tc   is an alchoiqgn concept  because c   and c   are alchoiqgn
concepts  
 c  c   c   and c   c    the case when c   c   and c   c   is the similar
one   then c  c   u c     since c   is an alchoiqgn concept by proposition
   it is safe range and  hence  by lemma   c   v b  t       t bn   where each bi is
either an atomic concept a or  o  or r  then c    c   u  b  t       t bn   and 
hence  c  c   u  b  t       t bn   u c    c   u  b  u c   t       t bn u c      each
disjunct bi u c   is an alchoiqgn concept  because c  is alchoiqgn
concept and by the definition     of alchoiqgn concepts   then c     c   u
 b  u c   t       t bn u c     is an alchoiqgn concept  c  c     the item is
proved 
   c   c  t c    c  u c     this case is reduced to the items   and   
   

fiexact query reformulation over dbs with fo and dl ontologies

the lemma is proved completely 
corollary    for any alchoiq concept c and any concept b  which is either an atom
a or  o  or  nr  the concept b u c is equivalent to some alchoiqgn concept 
proof  by lemma   there exists an alchoiqgn concept c   such that either c  c  
or c  c     then b u c  b u c   or b u c  b u c     both b u c   and b u c  
are alchoiqgn concepts  by the definition     of alchoiqgn concepts   hence  the
corollary is proved 
proposition     any safe range alchoiq concept is equivalent to some alchoiqgn
concept 
proof  let c be any safe range alchoiq concept  by lemma   c v b  t       t bn  
where each bi is either an atom a or  o  or  nr  then c  c u  b  t       t bn   
b  uct     tbn uc  by the corollary   for each disjunct bi uc there exists an alchoiqgn
concept di such that bi u c  di   then c  d  t       t dn   the concept d  t       t dn is an
alchoiqgn concept as a disjunction of alchoiqgn concepts  hence  the proposition
is proved 
proposition     all alchoiqgn concept inclusion axioms are safe range 
proof  let c v d be any concept inclusion axiom in alchoiqgn   it means that the
corresponding first order logic translation x  c x   d x  is in gnfo  hence  c x  
d x  is in gnfo or  that is the same  c u d is in alchoiqgn   it is easy to see  that
x  c x   d x  is safe range if and only if the formula c x   d x  is safe range  that
is if and only if the corresponding alchoiqgn concept c u d is safe range  but by
proposition    any alchoiqgn concept is safe range  the proposition is proved 
lemma    for any safe range alchoiq concept c and any alchoiq concept d the
concept c u d is equivalent to some alchoiqgn concept c   u d    where c   and d  are
alchoiqgn concepts 
proof  since c is safe range by lemma   c v b  t       t bn   where each bi is either an
atomic concept a or  o  or r  then c  c u  b  t       t bn   and  hence  c u d 
c u  b  t       t bn   u d  c u  b  u d t       t bn u d   by the corollary   each disjunct
bn ud is an alchoiqgn concept  hence  d     b  udt     tbn ud is an alchoiqgn
concept  since c is s safe range by proposition    there exists an alchoiqgn concept
c   such that c  c     then c u d  c   u d    and c   u d  is an alchoiqgn concept 
where c   and d  are alchoiqgn concepts 
proposition     any safe range alchoiq concept inclusion axiom c v d can be transformed to a concept inclusion axiom c   v d    where c   and d  are alchoiqgn  
proof  let c v d be any safe range alchoiq concept inclusion axiom  then the corresponding formula x  c x   d x  is safe range  then the first order logic formula
c x   d x  is safe range  or  that is the same  the alchoiq concept c u d is saferange  by proposition    we have that c is safe range or d is safe range 
   

fifranconi  kerhet    ngo

 c is safe range  then by lemma   there exist two alchoiqgn concepts c   and
d  such that c u d is logically equivalent to the alchoiqgn concept c   u d   
then x  c x   d x  is logically equivalent to x  c    x   d   x   hence  c v d
is logically equivalent to c   v d   c   and d  are alchoiqgn concepts  
 d is safe range  the proof is similar to the previous item 
the proposition is proved completely 
proposition     for any two alchoiqgn concepts c and d the axiom c v d is an
alchoiqgn concept inclusion axiom 
proof  the axiom c v d is logically equivalent to the first order logic formula x  c x 
d x   where c x  and d x  are in gnfo  then x  c x   d x  is also in gnfo  hence 
by the definition of alchoiqgn concept inclusion axiom the axiom c v d is an
alchoiqgn concept inclusion axiom 
propositions    and    imply the following 
proposition     any safe range alchoiq concept inclusion axiom is equivalent to some
alchoiqgn concept inclusion axiom 
we consider a connection between safe range fragment of alchoiq and guarded negation fragment of alchoiq  that is alchoiqgn   when we say fragment  we mean a
set of tbox assertions  concept and role inclusion axioms  and concepts  open formulas  of
alchoiq satisfying a particular property  e g safe range or guarded negation   taking
into account propositions                and     we have the following theorem 
proposition     the safe range fragment of alchoiq and alchoiqgn are equally
expressive 
this proves theorem    
theorem     expressive power equivalence   the domain independent fragment of
alchoiq and alchoiqgn are equally expressive 
theorem     alchoiqgn tboxes have finitely controllable determinacy of concept
queries 
proof  we need to prove  that for any alchoiqgn tbox t  ontology   any concept
query q in alchoiqgn and any set of database predicates pdb   whenever the query is
finitely determined by the database predicates under the ontology then it is also determined
in unrestricted models 
suppose  that q is finitely determined by pdb under t   then from theorem   it
e where   fin p means entailment over models with a
follows  that t  te   fin pdb q v q 
db
e
finite interpretation to the database predicates  hence  in particular t  te   fin q v q 
where   fin means entailment over finite models  hereafter let  be one sentence  that is a
first order logic translation of a conjunction of all axioms in the tbox t   then from the
aforementioned entailment we have 
e
  fin    e
     x  q x   q x   
   

   

fiexact query reformulation over dbs with fo and dl ontologies

e
by proposition    q x  is safe range  hence  q x   q x 
is safe range  hence the
e is safe range and  hence  by proposition    there exists an
alchoiq concept q u q
e  c     then x  q x   q x 
e
alchoiqgn concept c   such that q u q
 x c    x 
and the following holds 
  fin    e
     x c    x   
    
x c    x  is in gnfo  because c    x  is in gnfo  since all the axioms in t are alchoiqgn
tbox axioms  the sentences  and e are in gnfo  then the sentence   e
 is in gnfo 
therefore the right hand side of the entailment      is in gnfo  then     e
  
 x c    x    is also in gnfo and by the entailment      does not have a finite model 
then  since gnfo has the finite model property      e
     x c    x    is unsatisfiable  hence  we have 
      e
     x c    x   
e
since x c    x   x  q x   q x  
the following holds 
e
      e
     x  q x   q x   
e by theorem   it means  that the query q is determined in
then t  te    q v q 
unrestricted models by the database predicates pdb under the ontology t  
the proposition is proved 

references
abiteboul  s   hull  r     vianu  v          foundations of databases  addison wesley 
artale  a   calvanese  d   kontchakov  r     zakharyaschev  m          the dl lite family
and relations  j  artif  intell  res   jair           
avron  a          constructibility and decidability versus domain independence and absoluteness  theor  comput  sci               
barany  v   gottlob  g     otto  m          querying the guarded fragment  in proceedings
of the   th annual ieee symposium on logic in computer science  lics        pp 
    
barany  v   ten cate  b     otto  m          queries with guarded negation  full version  
corr  abs           
beth  e          on padoas method in the theory of definition  indagationes mathematicae 
           
craig  w          three uses of the herbrand gentzen theorem in relating model theory
and proof theory  j  symb  log                  
etzioni  o   golden  k     weld  d  s          sound and efficient closed world reasoning
for planning  artif  intell              
fan  w   geerts  f     zheng  l          view determinacy for preserving selected information in data transformations  inf  syst           
fitting  m          first order logic and automated theorem proving   nd edition   springer 
   

fifranconi  kerhet    ngo

franconi  e   ibanez garcia  y  a     seylan  inanc          query answering with dboxes
is hard  electronic notes in theoretical computer science  elsevier            
franconi  e   kerhet  v     ngo  n       a   exact query reformulation over shoq dboxes 
in proc  of the      international workshop on description logics  dl       
franconi  e   kerhet  v     ngo  n       b   exact query reformulation with first order ontologies and databases  in logics in artificial intelligence     th european conference 
jelia       pp         
franconi  e   ngo  n     sherkhonov  e       c   the definability abduction problem for
data exchange  in web reasoning and rule systems    th international conference
rr      
gurevich  y          toward logic tailored for computational complexity  in computation
and proof theory  vol        pp          springer 
halevy  a  y          answering queries using views  a survey  the vldb journal     
       
marx  m          queries determined by views  pack your views  in proceedings of the   th
acm symposium on principles of database systems  pods     pp       
mccune  w             
prover  

prover  and mace  

http   www cs unm edu  mccune 

nash  a   segoufin  l     vianu  v          views and queries  determinacy and rewriting 
acm trans  database syst                 
rosati  r          on the finite controllability of conjunctive query answering in databases
under open world assumption  j  comput  syst  sci                  
seylan  inanc   franconi  e     de bruijn  j          effective query rewriting with ontologies over dboxes  in proc  of the   st international joint conference on artificial
intelligence  ijcai        pp         
ten cate  b   franconi  e     seylan  inanc          beth definability in expressive description logics  in proc  of the   nd international joint conference on artificial
intelligence  ijcai        pp           
ten cate  b   franconi  e     seylan  inanc          beth definability in expressive description logics  journal of artificial intelligence research  jair              

   

fi