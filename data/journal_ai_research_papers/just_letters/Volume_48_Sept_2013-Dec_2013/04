journal artificial intelligence research          

submitted         published        

exact query reformulation databases
first order description logics ontologies
enrico franconi
volha kerhet
nhung ngo

franconi inf unibz it
kerhet inf unibz it
ngo inf unibz it

free university bozen bolzano  italy

abstract
study general framework query rewriting presence arbitrary
first order logic ontology database signature  framework supports deciding
existence safe range first order equivalent reformulation query terms
database signature  so  provides effective approach construct reformulation based interpolation using standard theorem proving techniques  e g   tableau  
since reformulation safe range formula  effectively executable sql query 
end  present non trivial application framework ontologies
expressive alchoiq description logic  providing effective means compute
safe range first order exact reformulations queries 

   introduction
address problem query reformulation expressive ontologies databases 
ontology provides conceptual view database composed constraints
vocabulary extending basic vocabulary data  querying database using
terms richer ontology allows flexibility using basic
vocabulary relational database directly 
paper study develop query rewriting framework applicable knowledge
representation systems data stored classical finite relational database  way
literature called locally closed world assumption  etzioni  golden 
  weld         exact views  marx        nash  segoufin    vianu        fan  geerts 
  zheng         dbox  seylan  franconi    de bruijn        franconi  ibanez garcia 
  seylan         dbox set ground atoms semantically behaves
database  i e   interpretation database predicates dbox exactly equal
database relations  dbox predicates closed  i e   extensions
every interpretation  whereas predicates ontology open  i e  
extensions may vary among different interpretations  consider
open interpretation database predicates  also called abox sound views  
abox  interpretation database predicates contains database relations possibly
more  notion less faithful representation database semantics since would
allow spurious interpretations database predicates additional unwanted tuples
present original database 
general framework ontology set first order formulas  queries
 possibly open  first order formulas  within setting  framework provides precise
semantic conditions decide existence safe range first order equivalent reformulac
    
ai access foundation  rights reserved 

fifranconi  kerhet    ngo

tion query terms database signature  provides effective approach
construct reformulation sufficient conditions  interested safe range reformulations queries range restricted syntax needed reduce original
query answering problem relational algebra evaluation  e g   via sql  original
database  abiteboul  hull    vianu         framework points several conditions
ontologies queries guarantee existence safe range reformulation 
show conditions feasible practice provide efficient method
ensure validation  standard theorem proving techniques used compute
reformulation 
order complete  framework applicable ontologies queries expressed
fragment first order logic enjoying finitely controllable determinacy  nash et al  
       stronger property finite model property logic  employed logic
enjoy finitely controllable determinacy approach would become sound
incomplete  still effectively implementable using standard theorem proving techniques 
explored non trivial applications framework complete  paper 
application alchoiq ontologies concept queries discussed  show
 i  check whether answers given query ontology solely determined
extension dbox predicates and  so   ii  find equivalent rewriting
query terms dbox predicates allow use standard database technology
answering query  means benefit low computational complexity
size data answering queries relational databases  addition  possible
reuse standard techniques description logics reasoning find rewritings 
paper seylan et al         
query reformulation problem received strong interest classical relational
database research well modern knowledge representation studies  differently
mainstream research query reformulation  halevy         mostly based
perfect maximally contained rewritings sound views relatively inexpressive constraints  see  e g   dl lite approach artale  calvanese  kontchakov    zakharyaschev         focus exact rewritings exact views  since characterises
precisely query answering problem ontologies databases  case
exact semantics database must preserved  example  consider ground negative query given standard relational database  adding ontology top it 
answer supposed changesince query uses signature database
additional constraints supposed change meaning querywhereas
database treated abox  sound views  answer may change presence
ontology  may important application perspective  dbox preserves
behaviour legacy application queries relational database  moreover 
focussing exact reformulations definable queries  as opposed considering certain
answer semantics arbitrary queries  dl lite   guarantee answers
queries subsequently composed arbitrary way  may important legacy
database applications 
work extends works exact rewritings exact views marx       
nash et al         focussing safe range reformulations conditions ensuring
existence  considering general first order ontologies extending database
signature  rather local view constraints database predicates  halevy 
   

fiexact query reformulation dbs fo dl ontologies

       paper extends papers franconi  kerhet  ngo      a      b 
providing precise semantic characterisation existence exact reformulation
 theorem    opposed sufficient conditions  considering much expressive description logic alchoiq  providing proofs 
paper organised follows  section   provides necessary formal background
definitions  section   introduces notion query determined database  section   introduces characterisation query reformulation problem  sections    
conditions allowing effective reformulation analysed  sound complete algorithm compute reformulation introduced  finally  present case
alchoiq ontologies  proofs presented details appendix 

   preliminaries
let fol c  p  classical function free first order language equality signature
   c  p   c finite set constants p set predicates associated
arities  rest paper refer arbitrary fragment fol c  p  
called l 
denote p        n   set predicates occurring formulas             n  
c        n   set constants occurring formulas             n   sake
brevity  instead p    resp  c     write p  resp  c    denote              n  
signature formulas             n   namely union p        n   c        n    
denote arity predicate p ar p    given formula   denote set
variables appearing var    set free variables appearing
free    may use notation  x    x   free    possibly empty 
set free variables formula 
database  instance  db finite set ground atoms form p  c            cn   
p p  n ary predicate  ci c    n   set predicates appearing
database db denoted pdb   set constants appearing db called
active domain db  denoted cdb    possibly empty  finite set kb closed
formulas called ontology 
usual  interpretation   hi   includes non empty setthe domain
interpretation function defined constants predicates signature  say
interpretations   hi   j   hj   j equal  written   j     j
  j   interpretation embeds database db  holds ai   every
database constant cdb  the standard name assumption  sna   customary databases 
see abiteboul et al          c            cn   p p  c            cn   db 
denote set interpretations embedding database db e db  
words  every interpretation embedding db interpretation
database predicate always given exactly content database 
is  general  case interpretation non database predicates 
say database predicates closed  predicates open
may interpreted differently different interpretations  consider open
world assumption  the abox   embedding database interpretation  open
world  interpretation soundly embeds database holds  c            cn   p
 but if  p  c            cn   db 
   

fifranconi  kerhet    ngo

order allow arbitrary database embedded  generalise standard
name assumption constants c  implies domain interpretation
necessarily includes set constants c  finiteness c corresponds
finite ability database system represent distinct constant symbols  c meant
unknown advance  since different database systems may different limits 
see framework introduced depend choice c 
given interpretation   hi   i  denote i s interpretation restricted
smaller signature p c  i e   interpretation domain
interpretation function defined constants predicates set
s  semantic active domain signature   p c interpretation i  denoted
adom      i   set elements domain occurring interpretations
predicates constants   i 
adom      i    

 

 

p    a       an  p

 a             

 

 ci   

c  

  pdb c  interpretations j embedding db have 
adom      i    adom      j    so  case introduce notation adom      db    
adom      i   interpretation embedding database db  intuitively
adom      db  includes constants   db appearing relations corresponding predicates    
let x set variable symbols set  substitution total function   x  
assigning element variable x  including empty substitution
x     domain image  range  substitution written dom   rng  
respectively  given subset set constants c  c  write formula  x 
true interpretation free variables substituted according substitution
  x   c   i     x      given interpretation   hi   subset
domain   write formula  x  true free variables
interpreted according substitution   x    i        extension domain
asformula  x  respect interpretation defined set domain elements
 rng     dom     x  rng     i      x    
usual  interpretation closed formula true called model
formula  set models formula  resp  kb  denoted     resp 
 kb    database db legal ontology kb exists model kb embedding
db  following  consider consistent non tautological ontologies legal
databases 
    queries
query  possibly closed  formula  given query q x    define certain answer
kb db follows 
definition    certain answer    certain  answer query q x  database db
ontology kb set substitutions constants 
    dom     x  rng   c   kb  e db       q x     
   

fiexact query reformulation dbs fo dl ontologies

query answering defined entailment problem  going
 high  complexity entailment 
note  query q closed  i e   boolean query   certain answer   
q true models ontology embedding database  otherwise 
following  assume closed formula q x   neither valid inconsistent
ontology kb  given substitution   x   c assigning variables distinct constants
appearing q  kb  cdb   would lead trivial reformulations 
show weaken standard name assumption constants
assuming unique names  without changing certain answers  said before 
interpretation satisfies standard name assumption ci   c c c  alternatively  interpretation satisfies unique name assumption  una  ai    bi
different a  b c  denote set interpretations satisfying standard name
assumption i sna   denote set interpretations satisfying unique name
assumption i una   following proposition allows us freely interchange standard name unique name assumptions interpretations embedding databases 
practical advantage  since encode unique name assumption classical
first order logic reasoners  many description logics reasoners support natively
unique name assumption extension owl 
proposition    sna vs una   query q x    ontology kb database db 
    dom     x  rng   c  i sna   kb  e db       q x      
    dom     x  rng   c  i una   kb  e db       q x     
since query arbitrary first order formula  answer may depend
domain  know advance  example  query q x    student x 
database student a   student b   domain  a  b  c  answer  x   c  
domain  a  b  c  d  answer  x   c  x   d   therefore  notion
domain independent queries introduced relational databases  adapt
classical definitions  avron        abiteboul et al         framework  need
general version domain independence  namely domain independence w r t
ontology  i e   restricted models ontology 
definition    domain independence   formula q x  domain independent
respect ontology kb iff every two models j kb  i e     hi  
j   hj   j i  agree interpretation predicates constants  i e 
  j    every substitution   x   j have 
rng   i     q x  iff
rng   j j      q x   
definition reduces classical definition domain independence whenever
ontology empty 
weaker version domain independencewhich relevant open formulasis
following 
definition    ground domain independence   formula q x  ground domain independent iff q x   domain independent every substitution   x   c 
   

fifranconi  kerhet    ngo

example  formula p  x  ground domain independent  domain independent 
problem checking whether fol formula domain independent undecidable
 abiteboul et al          well known safe range syntactic fragment fol introduced
codd equally expressive language  indeed safe range formula domain independent  domain independent formula easily transformed logically
equivalent safe range formula  intuitively  formula safe range variables
bounded positive predicates equalities  for full details see appendix a    
example  formula a x  b x  safe range  queries a x  x  a x 
not  check whether formula safe range  formula transformed logically
equivalent safe range normal form range restriction computed according set
syntax based rules  range restriction formula subset free variables 
coincides free variables formula said safe range  abiteboul
et al          similar domain independence  formula ground safe range grounding formula safe range  ontology kb safe range  domain independent  
every formula kb safe range  domain independent  
safe range fragment first order logic standard name assumption
equally expressive relational algebra  core sql  abiteboul et al  
      

   determinacy
certain answer query includes substitutions make query true
models ontology embedding database  so  substitution would make
query true model  would discarded certain answer 
words  may case answer query necessarily among
models ontology embedding database  case  query fully
determined given source data  indeed  answer possible 
certain  due indeterminacy query respect data  complexity
compute certain answer general increases complexity entailment
logic  paper focus case query answer
models ontology embedding database  namely  information requested
query fully available source data without ambiguity  way 
indeterminacy disappears  complexity process may decrease  see section    
determinacy query w r t  source database  nash et al         marx        fan
et al         called implicit definability formula  the query  set
predicates  the database predicates  beth        
definition    finite determinacy implicit definability   query q x   finitely 
determined  or implicitly definable from  database predicates pdb kb iff
two models j ontology kbboth finite interpretation
database predicates pdb whenever i pdb c   j  pdb c every substitution
  x   have  i     q x  iff j      q x   
intuitively  answer implicitly definable query depend interpretation non database predicates  database domain fixed  never
   

fiexact query reformulation dbs fo dl ontologies

case substitution would make query true model ontology
false others  since truth value implicitly defined query depends
interpretation database predicates constants domain  which
fixed   practice  focussing finite determinacy queries guarantee user
always interpret answers certain  exactnamely
whatever answer never part answer possible world 
following focus ontologies queries fragments fol c  p 
determinacy models finite interpretation database predicates  finite
determinacy  determinacy models unrestricted interpretation database
predicates  unrestricted determinacy  coincide  say fragments finitely
controllable determinacy  require whenever query finitely determined
determined unrestricted models  the reverse trivially true   indeed  results
paper would fail finite determinacy unrestricted determinacy coincide 
shown  gurevich        theorem   fails consider models
finite interpretation database predicates 
example    example database theory   let p    p  r  a   pdb    p  r  
kb    x  y  z  r x  y  r x  z    z 
x  y  r x  y  z  r z  x  
 x  y  r x  y  z  r y  z    x  a x  p  x    
formula x  y  r x  y  z  r y  z  entailed first two formulas
finite interpretations r  query q   a x  finitely determined p  it equivalent
p  x  models finite interpretation r   determined
database predicate models unrestricted interpretation r  knowledge
base enjoy finitely controllable determinacy 
exact reformulation query  nash et al          also called explicit definition
beth        formula logically equivalent query makes use database
predicates constants 
definition    exact reformulation explicit definability   query q x  explicitly definable database predicates pdb ontology kb iff
b x  fol c  p   kb    x q x  q
b x   q 
b pdb   call
formula q
b x  exact reformulation q x  kb pdb  
formula q
determinacy query completely characterised existence exact reformulation query  well known first order query determined database
predicates exists first order exact reformulation 
theorem    projective beth definability  beth         query q implicitly definable database predicates pdb ontology kb  iff explicitly definable
b fol c  p  pdb kb 
formula q
e formula obtained uniformly replacing
let q formula l q
every occurrence non database predicate p new predicate pe  extend
renaming operator e set formulas natural way  one check whether query
implicitly definable using following theorem 
theorem    testing determinacy  beth         query q x  implicitly definable
g    x q x  q
e x   
database predicates pdb ontology kb iff kb kb

   

fifranconi  kerhet    ngo

   exact safe range query reformulation
section analyse conditions original query answering problem
corresponding entailment problem reduced systematically model checking
problem safe range formula database  e g   using database system
sql   given database signature pdb   ontology kb  query q x  expressed l
determined database predicates  goal find safe range reformulation
b x  q x  fol c  p   evaluated relational algebra expression
q
legal database instance  gives answer certain answer q x  database
kb  reformulated following problem 
problem    exact safe range query reformulation   find exact reformulation
b x  q x  kb safe range query fol c  p  pdb  
q
since exact reformulation equivalent ontology original query 
certain answer original query reformulated query identical 
precisely  following proposition holds 
proposition    given database db  let q x  implicitly definable pdb kb
b x  exact reformulation q x  kb pdb   then 
let q
    dom     x  rng   c   kb  e db       q x      
b x     
    dom     x  rng   c   kb  e db       q
equation clear order answer exactly reformulated query 
one may still need consider models ontology embedding database  i e  
still entailment problem solve  following theorem states condition
reduce original query answering problembased entailmentto problem
checking validity exact reformulation single model  condition
reformulation domain independent  indeed one interpretation
 with particular domain  embedding database signature restricted
database predicates 
theorem    adequacy exact safe range query reformulation   let db
b x  exact domain
database legal kb  let q x  query  q
independent  or safe range  reformulation q x  kb pdb   then 
    dom     x  rng   c   kb  e db       q x      
b db     hc  e db    i p
    dom     x  rng   adom  q  

db c

b x     
   q

safe range reformulation necessary transform first order query relational
algebra query evaluated using sql techniques  theorem
shows addition safe range sufficient property exact reformulation correctly evaluated sql query  let us see example
cannot reduce problem answering exact reformulation model checking
database  exact reformulation safe range 
example    let p    p  a   pdb    p    c    a  
db    p  a  a    kb    y  p  a  y  a y   
b x    y  p  x  y   i e   x    x   
q x    q
   

fiexact query reformulation dbs fo dl ontologies

c includes active domain cdb  it actually equal  
db legal kb   h a   p     a  a    ai  
obviously   kb  
    dom     x  rng   c   kb  e db       q x      
one take   h a  b   p     a  a    ai    b    kb 
e db   possible substitution  x a  have      p  a  y  
however 
b db     hc  e db    i p c    q
b x      
    dom     x  rng   adom  q  
db

 x a 
seen  answers query reformulation exists contain
constants active domain database query  therefore  ground statements ontology involving non database predicates non active domain constants
 for example  abox statements  play role final evaluation
reformulated query database 

   conditions exact safe range reformulation
seen importance getting exact safe range query reformulation 
section going study conditions exact safe range query
reformulation exists 
first all  focus semantic notion safe range namely domain independence  implicit definability isas already knowa sufficient condition
existence exact reformulation  guarantee alone existence domain
independent reformulation 
example    let p    a  b   pdb    a   kb    x b x  a x    q   b x  
q implicitly definable pdb kb  every exact reformulation q
pdb kb logically equivalent a x  domain independent 
looking example  seems reason non domain independent
reformulation lies fact ontology  domain independent  cannot guarantee existence exact domain independent reformulation non domain independent
query  however  let us consider following example 
example    let pdb    a  c   kb    a a  
b y  c x   easy see kb
implicitly definable pdb kb 
independent reformulation q 

x  a x  b x   let query q  
domain independent q not  q
b   a a  c x  exact domain
q

obvious spite fact query q domain independent 
domain independent respect ontology kb  words  case
ontology guarantees existence exact domain independent reformulation 
queries domain independent respect ontology  following
theorem holds  giving semantic requirements existence exact domain
independent reformulation 
   

fifranconi  kerhet    ngo

theorem    semantic characterisation   given set database predicates pdb  
domain independent ontology kb  query q x    domain independent exact reformub x  q x  pdb kb exists q x  implicitly definable
lation q
pdb kb domain independent respect kb 
theorem shows us semantic conditions exact domain independent reformulation query  give us method compute reformulation equivalent safe range form  following theorem gives us sufficient
conditions existence exact safe range reformulation decidable fragment
fol c  p  finite unrestricted determinacy coincide  gives us constructive
way compute it  exists 
theorem    constructive   if 
g    x  q x  q
e x   that is  q x  implicitly definable  
   kb kb
   q x  safe range  that is  q x  domain independent  
   kb safe range  that is  kb domain independent  
b x  q x  safe range query fol c  p 
exists exact reformulation q
pdb kb  obtained constructively 
order constructively compute exact safe range query reformulation use
b x 
tableau based method find craigs interpolant  fitting        compute q
gq
e x     see section   full details 
validity proof implication  kb q x     kb
let us consider fully worked example  adapted paper nash et al 
       
example    given  p    r  v    v    v    a   pdb    v    v    v    adom  adom
active domain db 
kb     x  y  v   x  y  z  v  r z  x  r z  v  r v  y  
x  y  v   x  y  z  r x  z  r z  y  
x  y  v   x  y  z  v  r x  z  r z  v  r v  y  
q x  y    z  v  u  r z  x  r z  v  r v  u  r u  y   
conditions theorem satisfied  q x  y  implicitly definable pdb
kb  q x  y  safe range  kb safe range 
b y 
therefore  tableau method one finds craigs interpolant compute q x 
g
e
b
validity proof implication  kb q x     kb q x    obtain q x  y   
z  v   x  z  v   v   v  z  v   v  y  an exact ground safe range reformulation  since
b y  adom x 
answer q active domain  kb    q x 
b
adom y   kb    q x  y  q x  y  adom x  adom y   therefore  z  v   x  z 
v   v   v  z  v   v  y  adom x adom y  exact safe range reformulation q x  y 
pdb kb 
   

fiexact query reformulation dbs fo dl ontologies

   constructing safe range reformulation
section introduce method compute safe range reformulation implicitly
definable query conditions theorem   satisfied  method based
notion interpolant introduced craig        
definition    interpolant   sentence interpolant sentence
fol c  p   predicate constant symbols set predicate
constant symbols   valid sentences
fol c  p  
theorem    craigs interpolation   valid sentence fol c  p  
neither valid  exists interpolant 
note  beth definability  theorem    craigs interpolation theorem
hold fragments fol c  p   interpolant may always expressed
fragment itself  obviously fol c  p   because theorem    
interpolant used find exact reformulation given implicitly definable
query follows 
theorem    interpolant definition   let q x  query n   free variables
implicitly definable database predicates pdb ontology kb  then 
closed formula c         cn distinct constant symbols c appearing kb q x   
 
 
g q
e x c      c    
   kb  q x c       cn        kb 
   
n
 
b c      c  x  exact reformulation q x  kb
valid  interpolant q
n
 
pdb  
therefore  find exact reformulation implicitly definable query terms
database predicates enough find interpolant implication    
substitute constants c            cn back free variables x original query 
interpolant constructed validity proof     using automated theorem
proving techniques tableau resolution  order guarantee safe range
property reformulation  use tableau method book fitting        
    tableau based method compute interpolant
section recall context tableau based method compute interpolant  fitting        
assume valid  therefore unsatisfiable  closed tableau
corresponding   order compute interpolant tableau one needs
modify biased tableau 
definition    biased tableau   biased tableau formulas tree    v  e 
where 
v set nodes  node labelled set biased formulas  biased formula
expression form l   r   formula  node n 
s n  denotes set biased formulas labelling n 
   

fifranconi  kerhet    ngo

root tree labelled  l    r   
e set edges  given   nodes n  n     n    n    e iff biased
completion rule n  n    say biased completion rule n 
n 
   result applying rule x    x refer l r
 for rules  two possibilities choosing     
s n       s n       x      y     
let c set constants input formulas tableau  c par extends c
infinite set new constants  constant new occur anywhere
tableau  notations  following rules  
propositional rules
x  
x  

negation rules
x   
x  

rule
x      

x  
x   

x    
x    

rule
x        
x       x    

first order rules
rule
x x  

rule
x x  

x  t  
c par

x  c  
new constant c

equality rules
reflexivity rule

replacement rule
x t   u 
  t  

x  


x t   t 
occurs

  u  

c par

node tableau closed contains x       node closed 
rule applied  words  becomes leaf tree  branch closed
contains closed node tableau closed branches closed  obviously 
standard tableau fol closed biased tableau vice versa 
given closed biased tableau  interpolant computed applying interpolant rules 
int
interpolant rule written i  formula
   l      l           l n    r      r           r m    
rules closed branches
int

int

r    l    l   

r    r    r     

int

int

r    l   

r    r     
int

int

r    l    r   

r    r    l   
   

fiexact query reformulation dbs fo dl ontologies

rules propositional cases
int
 x   
p  

p  

p  

int

p  

int

 x   
int
 x      x     

 x    
int

int

p  

 x   
int

 x   
 x    
int
int
 l      i   l      i 
p  

int

int

 x       
 l          i  i 
int
int
 r      i   r      i 
int

 r          i  i 
rules first order cases  
int
 x  p   
f  

f  

f  

f  

f  

p parameter occur

int

 x x  x   
int
 l  c   
int

c occurs           n  

 l x  x   
int
 r  c   
int

c occurs            

 r x  x   
int
 l  c   
int

 l x  x    x i c x 
int
 r  c   
int

c occur           n  
c occur            

 r x  x    x i c x 
rules equality cases
int
 x  p    x t   t  
e  

e  

int

int

e  

 x  p   
int
 l  u    r t   u  
int

 x  u    x t   u  
int

 x  t    x t   u  
u occurs  t           

 l  t    r t   u     u
int
 r  u    l t   u  

u occurs  t           
int
 r  t    l t   u     u
int
 l  u    r t   u  
e  
u occur  t           
int
 l  t    r t   u   i u t 
int
 r  u    l t   u  
e  
u occur  t           
int
 r  t    l t   u   i u t 
e  

summary  order compute interpolant   one first need generate
biased tableaux proof unsatisfiability using biased completion rules
apply interpolant rules bottom leaves root 
let us consider example demonstrate method works 
example    let p    s  g  u    pdb    s  u   
   

fifranconi  kerhet    ngo

kb     x s x   g x  u  x   
x g x  s x  
x u  x  s x  
x g x  u  x   
q x    g x 
obviously  q implicitly definable u   since ontology states g
u partition s  follow tableau method find exact reformulation 
int
compactness  use notation instead i 
s     l x s x   g x  u  x     
l x g x  s x    
l x u  x  s x    
l x g x  u  x    
l g c   
r x s x   g   x  u  x     
r x g   x  s x    
r x u  x  s x    
r x g   x  u  x    
r g   c   
applying rule removing implication  have 
s     l s c  g c  u  c   
l g c  s c    
l u  c  s c   
l g c  u  c   
l g c   
r s c  g   c  u  c   
r g   c  s c   
r u  c  s c   
r g   c  u  c   
r g   c   
interpolant s  computed follows 
s   r s c  s c 

s   r u  c   u  c 

s    s   r s c  u  c    s c u  c  



s   r g   c    

 s c u  c  

b  

s   l g c   

s    s   l u  c   

 s c u  c  

s    s   l s c   

 s c u  c  

b  

s   l g c   

b  

s 

b
therefore  s c u  c  interpolant q x 
  s x u  x  exact reformulation
q x  
   

fiexact query reformulation dbs fo dl ontologies

algorithm   safe range reformulation
input  safe range kb  safe range implicitly definable query q x   
output  exact safe range reformulation 
b x  theorem  
   compute interpolant q
b x 
   free variable x bounded positive predicate q
b x     q
b x  adom b  x 
q
q
b x 
   return q

    safe range reformulation
want show reformulation computed tableau based method
condition theorem   generates ground safe range query 
theorem    ground safe range reformulation   let kb ontology  let q
query implicitly definable pdb   kb q safe range rewritten
b obtained using tableau method described section     ground safe range 
query q
words  conditions theorem   guarantee quantified variables
reformulation range restricted  need consider still unsafe free variables 
theorem help us deal non range restricted free variables  let us first
define active domain predicate query q safe range formula 
adom q  x    
w
w
p pq z            zar p      p  x  z            zar p            p  z            zar p      x 
ccq  x   c  

theorem    range query   let kb domain independent ontology  let
q x       xn   query domain independent respect kb 
kb    x            xn   q x       xn   adom q  x          adom q  xn   
given safe range ontology  safe range implicitly definable query obviously
domain independent respect ontology  case  theorem   says
answer reformulation include active domain elements  therefore  active
domain predicate used guard free variables bounded
positive predicate 
based theorem   theorem    propose complete procedure construct
safe range reformulation algorithm   

   guarded negation fragment alchoiq
alchoiq extension description logic alc role hierarchies  individuals 
inverse roles  qualified cardinality restrictions  corresponds shoiq description logic without transitive roles  logic basis owl  syntax
semantics alchoiq concept expressions summarised figure   
atomic concept  c concepts  individual name  p atomic role 
r either p p   forall qualified unqualified atmost operators
derived using negation atleast operator usual way  tbox alchoiq
   

fifranconi  kerhet    ngo

syntax

 o 
p
p
c
c ud
c td
nr
nr c

semantics
ai
 oi  
p
  y  x   x  y  p  
 c
c di
c di
 x    y  x  y  ri    n 
 x    y  x  y  ri   c   n 

figure    syntax semantics alchoiq concepts roles
set concept inclusion axioms c v role inclusion axioms r v  where c 
concepts r  roles  usual description logics semantics 
section  present application theorem    introducing alchoiqgn
description logic  guarded negation syntactic fragment alchoiq  figure   
happens express exactly domain independent concepts tboxes alchoiq 
language restricts alchoiq prescribing negated concepts
guarded generalised atom  an atomic concept  nominal  unqualified atleast
number restriction   i e   absolute negation forbidden  similarly  derived forall
atmost operators would guarded using standard definition dual
atleast operator  guarded negation  alchoiqgn actually intersection gnfo fragment  barany  ten cate    otto        alchoiq  see
appendix a   details gnfo  
alchoiqgn important property coinciding domain independent fragment alchoiq  therefore providing excellent candidate language
ontologies queries satisfying conditions theorem   
theorem     expressive power equivalence   domain independent fragment
alchoiq alchoiqgn equally expressive 
words theorem says domain independent tbox axiom
domain independent concept query alchoiq logically equivalent  respectively 
tbox axiom concept query alchoiqgn   vice versa  theorem provides
description logics version codds theorem  codds theorem states safe range
syntactic fragment fol domain independent fragment fol precisely
equivalent expressive power  is  database query formulated one language
expressed other 
r
b
c

   
   
   

p   p
   o    nr
b   nr c   nr c   b u c   c u   c
figure    syntax alchoiqgn concepts roles
   

fiexact query reformulation dbs fo dl ontologies

    applying constructive theorem
want reformulate concept queries ontology dbox reformulated query evaluated sql query database represented dbox 
context  database dbox  ontology alchoiqgn tbox 
query alchoiqgn concept query  concept query either alchoiqgn
concept expression denoting open formula one free variable  alchoiqgn
abox concept assertion denoting boolean query  expected  dbox includes ground
atomic statements form a a  p  a  b   where atomic concept p
atomic role   theorem    draw following corollary 
corollary    alchoiqgn tboxes concept queries domain independent 
prove following theorem 
theorem     alchoiqgn tboxes concept queries finitely controllable determinacy 
therefore  satisfy conditions theorem    language
expressive alchoiq description logic  guarded negation 
argue non guarded negation appear cleanly designed ontology 
and  present  fixed  indeed  use absolute negative informationsuch as 
e g   non male female   male v female should discouraged clean
design methodology  since subsumer would include sorts objects universe
 but ones subsumee type  without obvious control  guarded negative
information subsumee allowedsuch axiom non male person
female  person u male v female  
observation suggests fix non guarded negations  every non guarded negation users asked replace guarded one  guard may arbitrary
atomic concept  nominal  non qualified existential  therefore  user asked make
explicit type concept  way make domain independent  note
type could fresh new atomic concept  believe fix proposing
alchoiq reasonable one  would make alchoiq ontologies eligible
used framework 
    complete procedure
alchoiqgn decidable logic feasible application general framework 
given alchoiqgn ontology kb concept query q  apply procedure
generate safe range reformulation database concepts roles  based
constructive theorem  conditions satisfied   exists 
input  alchoiqgn tbox kb  concept query q alchoiqgn  
database signature  database atomic concepts roles  
g    q q
e using
   check implicit definability query q testing kb kb
standard owl  reasoner  alchoiqgn sublanguage owl    continue
holds 
   

fifranconi  kerhet    ngo

b tableau proof generated step    see
   compute safe range reformulation q
section     implemented simple extension standard dl reasoner
even presence important optimisation techniques semantic
branching  absorption  backjumping explained seylan et al         ten
cate  franconi  seylan        
b expressed database signature 
output  safe range reformulation q
note procedure checking determinacy computing reformulation
could run offline mode compile time  indeed  could run atomic concept
ontology  store persistently outcome reformulation
successful  pre computation may expensive operation  sinceas
seenit based entailment  complexity involves size ontology
data 
order get idea size reformulations  alcf description
logic tableau based algorithm computing explicit definitions double
exponential size  ten cate et al         ten cate  franconi    seylan         algorithm
optimal shown smallest explicit definition implicitly defined
concept may double exponentially long size input tbox 
clearly  similarly dl lite reformulations  research needed order optimise
reformulation step order make practical  however  note framework
presented clear advantage point view conceptual modelling since
implicit definitions  that is  queries  general tboxes double exponentially
succinct acyclic concept definitions  that is  explicit queries database  
another interesting open problem checking given database
legal respect given ontology  remember database db legal
ontology kb exists model kb embedding db  check involves heavy
computations optimised algorithm still unknown  matter fact 
known method today reduce problem satisfiability problem
database embedded tbox using nominals  franconi et al          research
needed order optimise reasoning nominals special case 
appendix a   contains definitions theorems needed prove theorems   
   

   conclusion
introduced framework compute exact reformulation first order queries
database ontologies  found exact conditions guarantee
safe range reformulation exists  show evaluated relational
algebra query database give answer original query
ontology  non trivial case study presented field description logics 
alchoiq language 
implemented tool based prover  theorem prover  mccune        
given arbitrary first order ontology  database signature  arbitrary first order
query tptp syntax  tool performs tests check whether reformulation computed  computes optimal safe range reformulation 
   

fiexact query reformulation dbs fo dl ontologies

framework useful data exchange like scenarios  target database
 made determined relations  materialised proper database 
arbitrary queries performed  achieved context non exact
rewritings preserving certain answers  scenario description logics ontologies 
rewritings concept queries pre computed offline once  shown framework works theory case arbitrary safe range first order queries  tool
shows possible practice  case description logics  working
extending theoretical framework conjunctive queries  need finitely controllable
determinacy conjunctive queries  seems follow description logic
works barany  gottlob  otto        rosati        
future work  would study optimisations reformulations  practical perspective  since might many rewritten queries one original query 
problem selecting optimised query terms query evaluation important 
fact  one take account criteria used optimise  as 
size rewritings  numbers used predicates  priority predicates  number
relational operators  clever usage duplicates  tool  plan evaluate
proposed technique real context 
concurrently  exploring problem fixing real ontologies order enforce
definability known case  franconi  ngo    sherkhonov      c  
happens intuitively obvious answer query found
available data  that is  query definable database   mediating
ontology entail definability  introduce novel problem definability
abduction solve completely data exchange scenario 
thank anonymous reviewers useful comments got earlier versions paper  wish thank alex borgida  tommaso di noia  umberto straccia 
david toman  grant weddell fruitful discussions topics
paper 

appendix a  proofs
a   proofs section  
proposition  
proof 

let

asna       dom     x  rng   c  i sna m  kb e db       q x    

auna       dom     x  rng   c  i una m  kb e db       q x    
since sna stricter una  i e  i sna  i una   have  auna asna trivially 
let asna  
  auna interpretation   hi   embedding
db satisfying una  kb      q x     let us construct new


interpretation j   hj   j embedding db follows 


j     i    ai   c   c 
   

fifranconi  kerhet    ngo



constant c  aj    a 


every predicate p p  pj constructed pi replacing element
ai pi   constant  a 
obviously  j satisfies sna j isomorphic  since first order logic sentences cannot distinguish two isomorphic structures  j     q x   contradicts
assumption asna   therefore auna  
a   proofs section  
proposition   
b x  exact reformulation q x    kb    x q x  q
b x    then 
proof  since q

b x   
model  kb  substitution   x   have  i     q x  q
b x    
equivalent  i     q x  i     q
now  let substitution     dom     x  rng     c   kb 
e db       q x        h  model kb embedding db  if
any   let    composition substitution interpretation
function  i e   x    iff  x    c c ci   a   i     q x 
b x     q
b
b
   q x   i     q
 x     summing up     q x      q x    
b x     
hence      dom     x  rng     c   kb  e db       q
inverse inclusion proved similarly 
theorem   
proof  first recall assume sna  order prove theorem  one needs
following two propositions 
proposition    domain independence   query q x  domain independent iff
every two interpretations   hi   j   hj   j agree interpretation
predicates pq  and constants c   every substitution   x   j
have 
rng   i     q x 
iff
rng   j j      q x   
proof     obviously  second part proposition holds  query domain
independent 
   suppose  query domain independent  let   hi   j   hj   j
two interpretations  agree interpretation predicates pq
 and constants c   i pq c   j  pq c   let us fix substitution   x   j
 if query closed  omit everything  concerns substitution
proof  that 
rng   i     q x   
   
   

fiexact query reformulation dbs fo dl ontologies

 

 

let us consider interpretations     hi   j     hj   j i  i pq c  
 
 
 
   pq c

  j  pq c   j  pq c   p p   pq   p     p j   let us consider
    domain interpret predicates constants  occurring
q x  equally  therefore  since i     q x   by              q x   
let us consider interpretations   j     construction  agree interpretation predicates constants  therefore  apply definition domain
independence them  then  since
rng          q x   

   

rng   j j        q x   

   

have 
interpretations j j   domain interpret predicates
constants  occurring q x  equally  thus      
rng   j j      q x   

   

therefore             similarly            proposition proved 

proposition    q x  domain independent  interpretation   h 
substitution   x     i     q x    following holds 
rng   adom  q x     i  
proof  assume  x    x   q one free variable x  the proof easily
extended general case  
let us prove contradiction  suppose  exists substitution  x b 
i   x b     q x  b   adom  q x    i   let us consider interpretation    
h  a   i  brand new element  appear        x
b     q x  domain independence q x   consider another interpretation
  
     h  a   occurrence b interpretation predicate replaced
element a  words  n ary predicate p p    q x             a        
  
 
p iff          b         p  since supposition b appear interpretations
predicates query   interpretations predicates constants
same     satisfies sna  even b c   then  since      x b     q x   
construction    have        x a     q x   changed interpretations
predicates  appear query  since      domain
agree interpretations predicates q x  constants  following
holds       x a     q x  
let us consider interpretations   h      h  a   i 
interpretation function  therefore  since q x  domain independent      x
a     q x   have  rng  x a       contradiction 
supposition    
   

fifranconi  kerhet    ngo

prove theorem itself 
l        dom     x  rng   c   kb  e db       q x     
b db     hc  e db    i p
r        dom     x  rng   adom  q  

db c

b x     
   q

b
let l   kb  e db  have     q x      q
 x    
proposition   
consider j   hc  embedding db  j agree interpretations c
b p subset pdb  
 since sna  predicates set  q 
b x  domain independent  proposition   have  j    q
b
then  since q
 x     since
b
b
b
 q x    pdb c  j  p c    q
  since q x  domain independent  proposition
db

 x  

b x     j    adom  q
b x     j     adom  q
b x     db  
  have  rng   adom  q
b x    pdb c  therefore  rng   adom  q
b x     db  
assume sna  q
r and  hence  l r 
b x     db    j   hc  embedding db
let r  rng   adom  q
b
b
have  j  pdb c    q
 x     j    q x     consider  kb  e db   j
b
agree interpretations c  since sna  pdb   since  q
  pdb c
 x  

b x  domain independent  proposition   have     q
b
b
q
 x     since q x  exact
reformulation q x  kb pdb   proposition   have     q x    
l and  hence  r l 
theorem   proved completely 
a   definitions proofs section  
proposition    let kb domain independent ontology  interpretation   hi  
model kb  j   hj   j i    j   model kb 
proof  let sentence kb  then  since model kb       domain
independent  kb domain independent  hence  since   j   j      thus  j
model sentence kb  means  j model kb 

proposition    let kb ontology  let q x  query domain independent
respect kb  exact reformulation q x  kb  over set predicates 
domain independent respect kb 
b x  exact reformulation q x  kb  over set predicates  
proof  let q


  h   j   hj   j two models kb   j  
  x   j substitution
b x   
rng   i     q
b
then  since q x  exact reformulation q x    have  i     q x    then  since q x 
domain independent respect kb  have 
rng   j j      q x   
b x  exact reformulation q x    have  j      q
b x    thus  q
b x 
again  since q
domain independent respect kb definition 

   

fiexact query reformulation dbs fo dl ontologies

lemma    let kb domain independent ontology  let q x  query
domain independent respect kb    h  model kb
substitution   x   i     q x  following holds 
rng   adom  q x     i  
proof  without loss generality assume  x    x   q one free variable x
 the proof easily extended general case  
let us prove contradiction  suppose i   x b     q x   b  
adom  q x     i   since kb domain independent  brand new element a 
appear   interpretation   h  a   model kb proposition
   then  since q x  domain independent respect kb
interpretation function  i   x b     q x  
 
consider new interpretation     h  a   constructed occurrence b interpretation predicate replaced element a  words 
 
n ary predicate p p   pq            a         p iff          b         p  since supposition
b appear interpretations predicates query  
then  since i   x b     q x  construction   have       x a     q x 
 since simply replace b  appear neither constant q x 
interpretations predicates q x   a   then  since   domain
 a  agree interpretations predicates q x  constants
 since assume sna   have  i   x a     q x  
let us consider interpretations   h    h  a   i 
models kb interpretation function   so  since q x  domain
independent respect kb i   x a     q x   have  i   x
a     q x  definition domain independence respect ontology 
contradiction  supposition     lemma proved 
let set formulas  adom defined similarly adom q   q
query 
lemma    let kb domain independent ontology  let q x   x    x         xn   
query domain independent respect kb  following holds 
kb    x q x  q x   adom kbq
q x   adom kbq q   x  adom kbq  x        adom kbq  xn    q   x  q x 
that 
every sub formula q x  form x  x  replaced x  x adom kbq  x 
every sub formula q x  form x  x  replaced x adom kbq  x 
 x 
proof  without loss generality  prove lemma n      case 
write q x  instead q x    prove contradiction 
assume model   hi   kb element i   x
a     q x  i   x a      q x  adom kbq  
   

fifranconi  kerhet    ngo

construct new interpretation j   hadom ikbq c  j predicate
p pkbq   p j    p   predicate p p   pkbq   p j     
since kb domain independent  j model kb proposition    then 
j    x a     q x  q domain independent respect kb  consequence  however  j    x a     q x  adom kbq definition q x  adom kbq  
q x  adom kbq safe range construction  see definition      hence  domain
independent  therefore i   x a     q x  adom kbq   contradiction 
assume model   hi   kb element i   x
a     q x  adom kbq i   x a      q x   one lead contradiction similarly
above  therefore  lemma proved 
theorem   
proof  theorem proved theorem   
direction  based lemma    one see exact reformulations q x 
exact reformulations q x   adom kbq   since q x   adom kbq safe range
kb always transformed logically equivalent safe range ontology kb    
b x  found theorem   takes
obviously exact safe range reformulation q
 
kb q x   adom kbq input exact domain independent reformulation
q x   
direction 
b x  q x 
suppose  exists exact domain independent reformulation q
pdb kb  domain independent respect kb  hence 
proposition    q x  domain independent respect kb  since exists
exact reformulation q x    q x  implicitly definable pdb kb
theorem   
theorem proved completely 
order help readers follow easier  recall formal definitions safe range
safe range normal form  abiteboul et al         
definition    safe range normal form   denoted srnf
first order formula transformed srnf following steps  
variable substitution  distinct pair quantifiers may employ variable 
remove universal quantifiers
remove implications
push negation
flatten and or
   

fiexact query reformulation dbs fo dl ontologies

definition    range restriction formula   denoted rr
input   formula srnf
output   subset free  
case
r e         en     rr     set variables e         en
x     x  constant   rr      x 
x     rr    
      rr     rr     rr    
      rr     rr     rr    
  x     rr     rr      x  y  rr         rr     rr      x  y  otherwise
    rr     rr    
x    rr     rr      x  x rr      rr     otherwise
note   z   z    z   z   
definition     safe range   formula safe range iff rr srnf      free   
definition     ground safe range   formula ground safe range iff substitution free variables constants becomes safe range 
observation   
   query q x  interpretation   h  following holds 
adom iq   adom  q x     i  
   adom q  x  safe range 
theorem   
proof  theorem proved theorem   theorem   
use following lemma proof 
lemma    kb ontology  q x   x    x            xn    ground safe range query
kb    x  q x     x          n  xn   

   

b x     q x     x        n  xn  
            n n safe range formulas  query q
b
safe range kb    x  q x  q x   
   

fifranconi  kerhet    ngo

proof  let q  x  safe range normal form query q x    i e  q  x     srnf q x     
y   xy     xy  conjunctive normal form  the safe range normal form
query prenex normal form   q  x  ground safe range  kb    q  x  q x   
hence  kb    x  q  x     x          n  xn    let q   x     q  x      x          n   xn   
i   xi     srnf i  xi        kb    q  x  q   x    hand
b x  q   construction  summing everything  have  kb    q
b x 
kb    x  q
 x 

b x  safe range 
q x  thing need prove q
  
 
one see  q x  y    xy     x        n   xn    safe range normal
b x    since q    y   xy  ground safe range  rr  xy      x   y  y 
form q
 x 

y y  exists conjunct x    xy    x x  then  since
i   xi   safe range  definition range restriction rr  xy      x        n   xn     
x y  rr y    xy      x          n   xn       x   free q   x     therefore 
b x  safey    xy      x          n   xn    safe range definition  hence q
range 
let us continue prove theorem 
b using
x      q closed  build exact safe range reformulation q
theorem   
suppose now  x    x            xn    since q x  safe range implicitly definable
pdb   apply theorem   q x  construct ground safe range rewriting q  x  expressed pdb kb    x  q x  q  x    since q x  domain independent
 since safe range   domain independent respect kb  hence  proposition    q  x  domain independent respect kb  moreover  kb safe range
and  hence  domain independent  theorem   
kb    x  q  x  adom q  x          adom q  xn   
second item observation   adom q  x  safe range formula  lemma  
b x     q  adom q   x          adom q   xn   safe range kb    x  q 
query q
 x 
 x 
b x    since kb    x  q x  q    have  kb    x  q x  q
b x    therefore 
q
 x 

b x  one looking for 
constructed query q
theorem   proved completely 
a   proofs section  
theorem   
proof  first prove q implicitly definable formula     valid 
g    x q x  q
g
applying syntactic definition implicit definability  kb kb
 x    therefore 


replace
x


set

constants
c
 
    
c
 

following
formula
valid
 
n
v
vg
e x c      c      consequence      valid 
  kb kb 
 q x c       cn   q
n
 
b c      c  x    q
b x c      c   craig internext  prove kb     q x  q
n
 
n 
 
b x c      c   interpolant 
polant      since q
 

n

   

fiexact query reformulation dbs fo dl ontologies

v
b x c      c  
      kb  q x c       cn     q
n
 
b x c      c    
  kb     q x c       cn   q
n
 
g q
e x c      c    
b x c      c     v kb 
   q
n
n
 
 
g     q
b x c      c   q
e x c      c     
  kb
n
n
 
 
b pdb   relation kb     q
b x c      c   q x c      c     holds well
since  q 
n
n
 
 
from       expected statement 
b x c      c     pdb  q
b c      c  x    pdb  
last least  since  q
n
n
 
 
b c      c  x  really explicit definition q
statements  q
n
 
theorem   
proof  need following propositions prove theorem 
proposition        safe range closed iff     safe range closed 
proof  have 
rr         rr     rr    
free         free     free    
rr       rr     free    
rr       rr     free    
    closed iff f ree       free      
  closed iff free      
  closed iff free      
    safe range iff rr         free      
  safe range iff rr       free    
  safe range iff rr       free    
therefore 
    closed iff     closed
    closed  safe range iff     closed  safe range 

proposition        safe range closed iff     safe range closed 
proof  have 
rr         rr     rr    
   

fifranconi  kerhet    ngo

free         free     free    
rr       rr     free    
rr       rr     free    
    closed iff free       free      
  closed iff free      
  closed iff free      
    safe range iff rr         free      
  safe range iff rr       free    
  safe range iff rr       free    
therefore 
    closed iff     closed
    closed  safe range iff     closed  safe range 

proposition     x  x  closed safe range   t  closed safe range
 t constants 
proof  obviously   x  x  closed   t  closed 
assume   t  safe range  since closed rr srnf   t     
srnf   t   must contain subformula form  z    t   z 
 z   rr srnf     t   z   
srnf   x   must contain subformula form  z    x   z 
 z   rr srnf     x   z   
srnf   x   must contain subformula form  z    x   z 
 z   rr srnf     x   z    pushing negation effect formula

rr srnf   x     
rr srnf  x  x     
rr srnf  x  x     
 x  x  safe range
contradiction 
proposition      x  x  closed safe range   t  closed safe range
 t constants 
proof  undoubtedly   x  x  closed   t  closed 
assume   t  safe range  since closed  rr srnf   t     
srnf   t   must contain subformula form  z    t   z 
 z   rr srnf     t   z   
   

fiexact query reformulation dbs fo dl ontologies

srnf   x   must contain subformula form  z    x   z 
 z   rr srnf     x   z   
rr srnf   x     
rr srnf  x  x     
 x  x  safe range
contradiction 
based propositions  prove theorem   follows 
first  show closed safe range valid
interpolant  assume biased tableau   therefore root node
   l    r     based tableau expansion rules propositions  every expansion step    l           l n    r           r m              n
         safe range closed     
need prove interpolant step safe range closed     
induction shape proof set rules section   
rules closed branches  trivial safe range closed
   
rules propositional case  
rule  p   p   p   p   nothing changes  one need prove 
rule  p    apply proposition         holds 
rule  p    apply proposition        holds 
rules first order case  
rule  f    f    f   nothing changes  one need prove 
rule  f    since c occur           n   case c
int
contains r  c    therefore  l  c       c   since x  x 
safe range  due      x i c x  safe range
rule  f    since c occur             case c
int
contains l  c    therefore  r  c       c   since x  x 
safe range  due      x i c x  safe range
rules equality   input formulas closed contain
function symbols  equations ground  therefore  influence
safe range property interpolant step 
consequence  q  c   kb  kb    q    c  closed safe range
b c  kb q  c  kb   q    c  
interpolant q  
theorem   
proof  consequence lemma    theorem   holds 
   

fifranconi  kerhet    ngo

a   definitions proofs section  
safe range fragment alchoiq  call axiom  concept  alchoiq
 ground  safe range  corresponding logically equivalent  open  formula fol c  p 
 ground  safe range  concept c denote corresponding logically equivalent
formula fol c  p  one free variable x c x   unfortunately concept inclusion
axioms alchoiq ontologies may safe range  example  axiom male v
female safe range  easy see axiom c v safe range
c x  safe range d x  safe range  observe axiom logically
equivalent formula x  c x  d x  fol c  p   which actually saferange normal form   following proposition provides recursive rules deciding whether
alchoiq concept safe range 
proposition     let atomic concept  let c alchoiq concepts 
let r either atomic role inverse atomic role  then 
   a   o   nr  nr c safe range 
   c u safe range c safe range safe range 
   c safe range c safe range safe range 
   c safe range c safe range 
proof  enough prove proposition atomic roles order
variables binary atoms first order logic translation alchoiq concept
affect safe range property translation  therefore hereafter assume r
atomic role 
since atomic concept  a x  safe range 
 o  x     x   o    safe range 
  nr  x    x            xn   r x  x          r x  xn    x     x           xn     xn   safe range 
  nr c  x    x            xn   r x  x          r x  xn   c x          c xn    x    
x           xn     xn     safe range 
let us prove   c u d  x    c x  d x  safe range c x 
safe range d x  safe range 
  let c x  d x  safe range let safe range normal
forms 
c x  d x  safe range definition 
  let c x  d x  safe range safe range normal form  i e  c x 
d x  safe range normal form   let us prove contradiction  suppose 
c x  d x  safe range  c x  d x  safe range definition 
contradiction  therefore  c x  safe range d x  safe range 
   

fiexact query reformulation dbs fo dl ontologies

let us prove   c d  x    c x  d x  safe range c x 
safe range d x  safe range 
  let c x  d x  safe range safe range normal forms 
c x  d x  safe range definition 
  let c x  d x  safe range safe range normal form  i e  c x 
d x  safe range normal form   let us prove contradiction  suppose  c x 
d x  safe range  c x  d x  safe range definition 
contradiction  therefore  c x  safe range d x  safe range 
let us prove  c x  safe range c x  safe range 
  let c x  safe range  let us prove contradiction  let c x  saferange  c x  c x  domain independent  one easily see
 looking definition domain independence   impossible  therefore 
c x  safe range    need prove  c x  safe range 
c x  safe range 
let us prove induction structure formula  suppose  item true
subformula formula c x  
suppose  c x  safe range  let us consider  using already proved items 
possible cases  c x  safe range 
c x     r d  x    y  r x  y  d y  y r x  y d y    safe range 
 possibly complex  concept  c x    y r x  y  d y 
safe range definition 
suppose  c x     d u f   x  safe range  d x  safe range
f  x  safe range  since d x  f  x  subformulas c x  
applying current item get  d x  f  x  safe range  c x 
 d x  f  x   d x  f  x    safe range  d x  f  x 
safe range 
suppose  c x     d f   x  safe range  d x  safe range
f  x  safe range  since d x  f  x  subformulas c x  
applying current item get  either d x  f  x  safe range  c x 
 d x  f  x   d x  f  x    safe range  either d x  f  x 
safe range 
suppose  c x    d x  safe range  need prove  c x  d x 
safe range  let us prove contradiction  suppose  d x  safe range 
then  since d x  subformula c x   applying current item get 
d x  c x  safe range  contradiction  hence  c x  safe range 
item proved completely 
proposition proved completely 
proposition     alchoiq role inclusion axioms safe range 
   

fifranconi  kerhet    ngo

proof  let v r role inclusion axiom alchoiq  formula x  y  s x  y 
r x  y  first order logic translation axiom   x  y  stands  x  y 
preceding role atomic  x  y  stands  y  x  preceding role inverse atomic 
formula safe range 
guarded negation first order logic  recall definition guarded negation firstorder logic  gnfo  given paper barany et al          gnfo fragment
first order logic consisting formulas generated following recursive definition 
    r t            tn     t    t                x   

   

ti either variable constant  atomic formula  possibly
equality statement  containing free variables  
guarded negation fragment alchoiq  consider alchoiqgn  
guarded negation fragment alchoiq  i e  intersection gnfo alchoiq  
say 
concept c alchoiqgn concept c alchoiq concept
corresponding first order logic translation c x  expressed gnfo 
concept inclusion axiom c v alchoiqgn concept inclusion axiom
c alchoiq concepts formula x  c x  d x   which
equivalent first order translation c v d  expressed gnfo 
role inclusion axiom v r alchoiqgn role inclusion axiom r
roles  atomic inverse atomic  formula x  y  s x  y  r x  y   
 x  y  stands  x  y  preceding role atomic  x  y  stands  y  x 
preceding role inverse atomic  expressed gnfo 
easy see  alchoiq role inclusion axiom alchoiqgn role inclusion
axiom  proposition    following holds 
proposition    

alchoiqgn role inclusion axioms safe range 

safe range role inclusion axioms alchoiq alchoiqgn  
definition gnfo alchoiq follows  complex concept c
logic alchoiqgn recursively defined follows 
b        o    nr
c     b   nr c   nr c   b u c   c u   c

   

atomic concept  r atomic role inverse atomic role  c
alchoiqgn concepts  possibly complex  
note  general  according definition     gnfo formulas atleast
operator n   gnfo non guarded inequality statements xi   
xj   fix assuming inequality relation actually special binary database
predicate  assumption usual databases 
   

fiexact query reformulation dbs fo dl ontologies

strictly speaking nr u c gnfo  indeed  formula
 x            xn   r x  x          r x  xn    x     x           xn     xn    c x 
gnfo  r x  y  stands p  x  y  r stands atomic role p   r x  y  stands
p  y  x  r stands inverse atomic role p    easily transformed
logically equivalent gnfo one simply shifting parentheses  x            xn    r x  x   
      r x  xn    x     x           xn     xn   c x    so  assume  formula
nr u c alchoiqgn  
proposition     alchoiqgn concepts safe range 
proof  let us prove induction structure alchoiqgn concepts defined
    
   a   o   nr  nr c  nr c  c alchoiqgn concept  safe range
item   proposition    
   atomic concept a  individual role r natural number n
concepts u c   o  u c nr u c safe range item  
proposition    since a   o  nr safe range first item 
   suppose  alchoiqgn concepts c safe range  concepts
c u c safe range items     proposition    respectively 
proposition proved 
lemma    safe range concept c alchoiq following holds 
c v b        bn  
bi appears subconcept c one following concepts 
atomic concept a 
 o   individual name 
nr  r atomic role inverse atomic role  n natural number 
proof  let us prove proposition induction safe range concepts alchoiq 
a   o   nr  nr c safe range proposition     v a   o  v  o   nr v
nr  nr c v nr 
suppose c complex safe range concept proposition holds
safe range subconcepts c 
   c   c  u c    safe range  either c  c  safe range  let c  safe range 
hence  c  v b        bm   bi concept aforementioned type 
c  u c  v c  v b         b  
   c   c  c    safe range  c  c  safe range  hence  c  v b        bk
c  v bk         bm   bi concept aforementioned type 
c  c  v  b        bk    bk         bm   v b        bm  
   

fifranconi  kerhet    ngo

   c   safe range  proposition    possible saferange  one following cases takes place 
  d  u d    d  d    reduced case item   
  d  d    d  u d    reduced case item   
  d    d  d    hence  d  safe range subconcept d 
proposition holds d  and  hence  c  c d   
lemma proved completely 
lemma    alchoiq concept c exists alchoiqgn concept c  
either c c   c c    
proof  suppose lemma holds alchoiq subconcepts alchoiq
concept c  let us prove c 
   base  a   o   nr alchoiqgn concepts definition alchoiqgn
concept     
   c   nr d d  alchoiqgn concept d 
d    c nr d  c nr d    nr d  nr d 
alchoiqgn concepts  hence  item proved 
   c   d  alchoiqgn concept d  d   
c d  c d  d    item proved 
   c   c  u c  c   alchoiqgn concept c  c   c  c     c  
alchoiqgn concept c  c   c  c     consider possible
cases 
 a  c  c   c  c     c c     c     c   u c   alchoiqgn
concept  because c   c   alchoiqgn concepts  
 b  c  c   c  c     c c   u c    c   c       c    
c     c   tc   alchoiqgn concept  because c   c   alchoiqgn
concepts  
 c  c  c   c  c    the case c  c   c  c   similar
one   c c   u c     since c   alchoiqgn concept proposition
   safe range and  hence  lemma   c   v b        bn   bi
either atomic concept  o  r  c   c   u  b        bn   and 
hence  c c   u  b        bn   u c   c   u  b  u c         bn u c     
disjunct bi u c   alchoiqgn concept  because c  alchoiqgn
concept definition     alchoiqgn concepts   c     c   u
 b  u c         bn u c     alchoiqgn concept  c c     item
proved 
   c   c  c   c  u c     case reduced items     
   

fiexact query reformulation dbs fo dl ontologies

lemma proved completely 
corollary    alchoiq concept c concept b  either atom
 o  nr  concept b u c equivalent alchoiqgn concept 
proof  lemma   exists alchoiqgn concept c   either c c  
c c     b u c b u c   b u c b u c     b u c   b u c  
alchoiqgn concepts  by definition     alchoiqgn concepts   hence 
corollary proved 
proposition     safe range alchoiq concept equivalent alchoiqgn
concept 
proof  let c safe range alchoiq concept  lemma   c v b        bn  
bi either atom  o  nr  c c u  b        bn  
b  uct     tbn uc  corollary   disjunct bi uc exists alchoiqgn
concept di bi u c di   c d        dn   concept d        dn
alchoiqgn concept disjunction alchoiqgn concepts  hence  proposition
proved 
proposition     alchoiqgn concept inclusion axioms safe range 
proof  let c v concept inclusion axiom alchoiqgn   means
corresponding first order logic translation x  c x  d x  gnfo  hence  c x 
d x  gnfo or  same  c u alchoiqgn   easy see 
x  c x  d x  safe range formula c x  d x  safe range 
corresponding alchoiqgn concept c u safe range 
proposition    alchoiqgn concept safe range  proposition proved 
lemma    safe range alchoiq concept c alchoiq concept
concept c u equivalent alchoiqgn concept c   u d    c   d 
alchoiqgn concepts 
proof  since c safe range lemma   c v b        bn   bi either
atomic concept  o  r  c c u  b        bn   and  hence  c u
c u  b        bn   u c u  b  u       bn u d   corollary   disjunct
bn ud alchoiqgn concept  hence  d     b  udt     tbn ud alchoiqgn
concept  since c safe range proposition    exists alchoiqgn concept
c   c c     c u c   u d    c   u d  alchoiqgn concept 
c   d  alchoiqgn concepts 
proposition     safe range alchoiq concept inclusion axiom c v transformed concept inclusion axiom c   v d    c   d  alchoiqgn  
proof  let c v safe range alchoiq concept inclusion axiom  corresponding formula x  c x  d x  safe range  first order logic formula
c x  d x  safe range  or  same  alchoiq concept c u saferange  proposition    c safe range safe range 
   

fifranconi  kerhet    ngo

c safe range  lemma   exist two alchoiqgn concepts c  
d  c u logically equivalent alchoiqgn concept c   u d   
x  c x  d x  logically equivalent x  c    x  d   x   hence  c v
logically equivalent c   v d   c   d  alchoiqgn concepts  
safe range  proof similar previous item 
proposition proved completely 
proposition     two alchoiqgn concepts c axiom c v
alchoiqgn concept inclusion axiom 
proof  axiom c v logically equivalent first order logic formula x  c x 
d x   c x  d x  gnfo  x  c x  d x  gnfo  hence 
definition alchoiqgn concept inclusion axiom axiom c v
alchoiqgn concept inclusion axiom 
propositions       imply following 
proposition     safe range alchoiq concept inclusion axiom equivalent
alchoiqgn concept inclusion axiom 
consider connection safe range fragment alchoiq guarded negation fragment alchoiq  alchoiqgn   say fragment  mean
set tbox assertions  concept role inclusion axioms  concepts  open formulas 
alchoiq satisfying particular property  e g safe range guarded negation   taking
account propositions                    following theorem 
proposition     safe range fragment alchoiq alchoiqgn equally
expressive 
proves theorem    
theorem     expressive power equivalence   domain independent fragment
alchoiq alchoiqgn equally expressive 
theorem     alchoiqgn tboxes finitely controllable determinacy concept
queries 
proof  need prove  alchoiqgn tbox  ontology   concept
query q alchoiqgn set database predicates pdb   whenever query
finitely determined database predicates ontology determined
unrestricted models 
suppose  q finitely determined pdb   theorem  
e   fin p means entailment models
follows  te   fin pdb q v q 
db
e
finite interpretation database predicates  hence  particular te   fin q v q 
  fin means entailment finite models  hereafter let one sentence 
first order logic translation conjunction axioms tbox  
aforementioned entailment have 
e
  fin   e
   x  q x  q x   
   

   

fiexact query reformulation dbs fo dl ontologies

e
proposition    q x  safe range  hence  q x  q x 
safe range  hence
e safe range and  hence  proposition    exists
alchoiq concept q u q
e c     x  q x  q x 
e
alchoiqgn concept c   q u q
x c    x 
following holds 
  fin   e
   x c    x   
    
x c    x  gnfo  c    x  gnfo  since axioms alchoiqgn
tbox axioms  sentences e gnfo  sentence e
gnfo 
therefore right hand side entailment      gnfo     e
 
 x c    x    gnfo entailment      finite model 
then  since gnfo finite model property     e
   x c    x    unsatisfiable  hence  have 
     e
   x c    x   
e
since x c    x  x  q x  q x  
following holds 
e
     e
   x  q x  q x   
e theorem   means  query q determined
te    q v q 
unrestricted models database predicates pdb ontology  
proposition proved 

references
abiteboul  s   hull  r     vianu  v          foundations databases  addison wesley 
artale  a   calvanese  d   kontchakov  r     zakharyaschev  m          dl lite family
relations  j  artif  intell  res   jair           
avron  a          constructibility decidability versus domain independence absoluteness  theor  comput  sci               
barany  v   gottlob  g     otto  m          querying guarded fragment  proceedings
  th annual ieee symposium logic computer science  lics        pp 
    
barany  v   ten cate  b     otto  m          queries guarded negation  full version  
corr  abs           
beth  e          padoas method theory definition  indagationes mathematicae 
           
craig  w          three uses herbrand gentzen theorem relating model theory
proof theory  j  symb  log                  
etzioni  o   golden  k     weld  d  s          sound efficient closed world reasoning
planning  artif  intell              
fan  w   geerts  f     zheng  l          view determinacy preserving selected information data transformations  inf  syst           
fitting  m          first order logic automated theorem proving   nd edition   springer 
   

fifranconi  kerhet    ngo

franconi  e   ibanez garcia  y  a     seylan  inanc          query answering dboxes
hard  electronic notes theoretical computer science  elsevier            
franconi  e   kerhet  v     ngo  n       a   exact query reformulation shoq dboxes 
proc       international workshop description logics  dl       
franconi  e   kerhet  v     ngo  n       b   exact query reformulation first order ontologies databases  logics artificial intelligence     th european conference 
jelia       pp         
franconi  e   ngo  n     sherkhonov  e       c   definability abduction problem
data exchange  web reasoning rule systems    th international conference
rr      
gurevich  y          toward logic tailored computational complexity  computation
proof theory  vol        pp          springer 
halevy  a  y          answering queries using views  survey  vldb journal     
       
marx  m          queries determined views  pack views  proceedings   th
acm symposium principles database systems  pods     pp       
mccune  w             
prover  

prover  mace  

http   www cs unm edu  mccune 

nash  a   segoufin  l     vianu  v          views queries  determinacy rewriting 
acm trans  database syst                 
rosati  r          finite controllability conjunctive query answering databases
open world assumption  j  comput  syst  sci                  
seylan  inanc   franconi  e     de bruijn  j          effective query rewriting ontologies dboxes  proc    st international joint conference artificial
intelligence  ijcai        pp         
ten cate  b   franconi  e     seylan  inanc          beth definability expressive description logics  proc    nd international joint conference artificial
intelligence  ijcai        pp           
ten cate  b   franconi  e     seylan  inanc          beth definability expressive description logics  journal artificial intelligence research  jair              

   


