Journal of Artificial Intelligence Research 18 (2003) 315-349

Submitted 10/02; published 4/03

Structure and Complexity in Planning with Unary Operators
Ronen I. Brafman
Carmel Domshlak

brafman@cs.bgu.ac.il
dcarmel@cs.bgu.ac.il

Department of Computer Science
Ben-Gurion University
P.O. Box 653, 84105 Beer-Sheva, Israel

Abstract
Unary operator domains  i.e., domains in which operators have a single effect  arise
naturally in many control problems. In its most general form, the problem of strips planning in unary operator domains is known to be as hard as the general strips planning
problem  both are pspace-complete. However, unary operator domains induce a natural
structure, called the domains causal graph. This graph relates between the preconditions
and effect of each domain operator. Causal graphs were exploited by Williams and Nayak
in order to analyze plan generation for one of the controllers in NASAs Deep-Space One
spacecraft. There, they utilized the fact that when this graph is acyclic, a serialization
ordering over any subgoal can be obtained quickly. In this paper we conduct a comprehensive study of the relationship between the structure of a domains causal graph and the
complexity of planning in this domain. On the positive side, we show that a non-trivial
polynomial time plan generation algorithm exists for domains whose causal graph induces
a polytree with a constant bound on its node indegree. On the negative side, we show
that even plan existence is hard when the graph is a directed-path singly connected DAG.
More generally, we show that the number of paths in the causal graph is closely related to
the complexity of planning in the associated domain. Finally we relate our results to the
question of complexity of planning with serializable subgoals.

1. Introduction
One of the first well formulated problems addressed by AI researchers was the planning
problem. Simply stated, it involves the generation of a sequence of system transformations,
taken out of a given set of system transformations (called actions or plan operators), whose
combined effect is to move the system from some given initial state into one of a set of
desired goal states. The planning problem is known to be intractable in general (Chapman,
1987), and tractable algorithms exist for very restrictive classes of problems only. This
discouraging fact has not deterred planning researchers. Indeed, many researchers believe
that real-world problems have some properties, or structure, that could be exploited, either
implicitly or explicitly. In this paper we attempt to understand the relationship between
structure and complexity in planning problems in which each action changes the value of a
single variable.
To study the relation between the structure and the complexity in a class of problems
we must identify a set of parameters that characterize it. In the case of planning, a number
of such problem properties have been studied in the past (which we review in more detail
in Section 6). These properties have been mostly syntactical, i.e., they involve restriction
on operators, e.g., the type and number of preconditions or effects that operators have. For
c
2003
AI Access Foundation and Morgan Kaufmann Publishers. All rights reserved.

fiBrafman & Domshlak

example, Bylander (1994) showed that strips planning in domains where each operator is
restricted to have positive preconditions and one postcondition only is tractable. Backstrom
and Klein (1991b) considered other, more global types of syntactical restrictions, but using
a more refined model in which two types of preconditions are considered: prevail conditions,
which are variable values that are required prior to the execution of the operator and are
not affected by the operator, and preconditions, which are affected by the operator. For
example, they have shown that when operators have a single effect, no two operators have
the same effect, and each variable can be affected only in one context (of prevail conditions)
then the planning problem can be solved in polynomial time. However, these restrictions
are very strict, and it is difficult to find reasonable domains satisfying them.
In this paper we concentrate on more global properties of unary operator domains;
properties that capture some of the interactions between different planning operators. The
tool we use to study these properties is the domains causal graph. A causal graph is a
directed graph whose nodes stand for the domain propositions. An edge (p, q) appears in
the causal graph if and only if some operator that changes the value of q has a prevail
condition involving p. Such a problem structure was introduced by Knoblock (1994) in
the context of automatically generating abstractions for planning. Subsequently, Jonsson
and Backstrom (1998b) introduced the 3S class of planning problems with unary operators,
which was characterized by the acyclicity of the causal graph, and some restrictions on the
operator set. It was shown that determining plan existence for this class of problems is
polynomial, while plan generation is provably intractable.
Complexity results for unary operators would be of theoretical interest alone if one
could not supply interesting problems in which unary operators are used. One interesting
application in which this problem arises is the determination of dominance relationship
between different outcomes in a CP-net (Boutilier, Brafman, Hoos, & Poole, 1999). This
problem is reducible to strips planning with unary operators.
Another example, of greater interest to the planning community, is a planning-based
reactive control system that commands the NASA Deep Space One autonomous spacecraft (Pell, Bernard, Chien, Gat, Muscettola, Nayak, Wagner, & Williams, 1997; Williams
& Nayak, 1996, 1997). This system was hailed by Weld (1999) in his recent survey of AI
planning as one of the most exciting recent developments in the area of planning. Naturally, the complete system (Pell et al., 1997) is very complex, however, its configuration
planning and execution subsystem are of particular interest to us. In the context of controlling Deep-Space One, Williams and Nayak (1996, 1997) present a reactive planner, Burton,
that generates a single control action for the main engine subsystem of the spacecraft, and
compensates for anomalies at every step. Given a high-level goal (for example, thrust in
one of the engines), Burton continually tries to transition the system toward a state that
satisfies the desired goal. What is particularly relevant for us is that Burtons task can be
described as a strips planning problem in which each operator affects only a single variable (hardware component)  Williams and Nayak (1997) argue that in physical hardware
it is usually the case that each state variable is commanded separately. However, Burton is
based on two additional important restrictions: First, the planner is explicitly supplied with
a serialization order for any satisfiable set of goal. Second, all operators must be reversible.
One of the reasons cited for designing Burton as a reactive planner that generates a
single action at a time was the potential intractability of generating whole plans. Indeed,
316

fiStructure and Complexity in Planning with Unary Operators

Williams and Nayak were pessimistic about the prospects of generating whole plans quickly
even for Burton, i.e., for problem instances with serializable sub-goals and single-effect
operators. As our results show, this pessimism was not fully justified.
Our work continues the study of planning with unary operators. This apparently easier
problem is in fact as hard as the general strips planning problem (Bylander, 1994). However, we can obtain finer distinctions and some positive results if we pay closer attention to
the causal structure of the domain. For example, it is easy to show that when the causal
graph is a tree, it is easy to determine a serializability ordering over any set of sub-goals,
and consequently, obtain a plan in polynomial time. In this paper we analyze the relationship between the domains causal graph and the complexity of plan generation and plan
existence. In particular we prove the following results:
 When the causal graph forms a polytree (the induced undirected graph is acyclic), and
its node indegree is bounded by a constant, then plan existence and plan generation
are polynomial.
 When the causal graph is directed-path singly connected (there is at most one directed
path between any pair of nodes), then plan existence is np-complete.
 In general, plan generation for the problems with acyclic causal graphs is provably
intractable, i.e., the problem requires exponential time. The corresponding claim
is derived from a previous result by Jonsson and Backstrom (1998b). However, we
show that the complexity of plan generation for these problems can be bounded by a
function of the number of paths within the causal graph.
Note that the complexity of the problems with polytree causal graphs but with unbounded
node indegree remains an open problem  it is still to be shown whether they can be solved
in polynomial time, or they are np-complete.
Finally, we relate our results to an old open question: how difficult is it to generate
plans for problems with serializable subgoals (Korf, 1987)? This question was stated by
Bylander (1992), and different hypotheses were raised by different researchers. Here, we
present a clear, though somewhat disappointing answer: First, our results suggest that even
when the underlying causal graph of the problem is acyclic (and thus the problem is known
to be serializable), finding a serialization ordering on the problem subgoals may be hard.
Second, we show that even if the actual serialization ordering on the subgoals is known,
solving the problem is not necessarily easy.
The rest of this paper is organized as follows: In Section 2 we first introduce some
basic formalism used in the paper, then discuss, motivate and illustrate the notion of causal
graph. In Sections 3 and 4 we present our results on the relation between the form of
the causal graph and the complexity of the planning problem. In Section 5 we discuss the
sub-goal serializability issue and the impact of our results on it. In Section 6 we describe
some related work on complexity of planning, and connect our work with the previous
results. We summarize in Section 7. Finally, Appendix A provides a short review of the
POP algorithm (Penberthy & Weld, 1992), and Appendix B provides some of the proofs.
317

fiBrafman & Domshlak

2. Basic Formalism and Causal Graphs
In this paper we consider only propositional planning problems, using the propositional
strips with negative goals formalism (Bylander, 1994), in which both positive and negative
preconditions are allowed. Following Backstrom and Klein (1991b), we distinguish between
preconditions and prevail conditions. In the former case the variable involved changes its
value after the operator is executed, while in the latter case the value does not change. The
post-condition of an operator expresses which state variables it changes and what values
these variables will have after executing the operator. The pre-condition specifies which
values these changed variables must have before the operator is executed. The prevail
condition specifies which of the unchanged variables must have some specific value before
execution of the operator and what these values are. Hence, prevail conditions, such as
having a visa, are needed in order to apply an operator, such as Enter-USA, but their
values do not change after the operator is applied. Finally, we assume that an operator is
applicable if and only if both its pre- and prevail conditions are satisfied.
Formally, we assume that a problem instance is given by a quadruple  = hV, , Init, Goali,
where:
 V = {v1 , . . . , vn } is a set of propositional state variables, each one with an associated
binary domain D(vi ). The domain D(vi ) of the variable vi induces an extended domain
D+ (vi ) = D(vi )  {u}, where u denotes the unspecified value.
 Init is an initial, fully specified state, i.e. Init  D(v1 )  . . .  D(vn ).
 Goal is a set of possible goal states. We assume that such a set is specified by a partial
assignment on V, thus Goal  D+ (v1 )  . . .  D+ (vn ).
  = {A1 , . . . , AN } is a finite set of operators of the form hpre, post, prvi, where
pre, post, prv  D+ (v1 )  . . .  D+ (vn ) denote the pre-, post-, and prevail condition,
respectively. In what follows, by pre(A), post(A), and prv(A) we denote the corresponding conditions of an operator A, and by pre(A)[i], post(A)[i], and prv(A)[i] the
corresponding values of the variable vi .
For every vi  V, we must have either pre(A)[i] = u or prv(A)[i] = u. Further,
post(A)[i] 6= u if and only if pre(A)[i] 6= u, in which case post(A)[i] 6= pre(A)[i].
In this paper we analyse only planning problems with unary operators. Therefore, in
what follows, we assume that, for each operator A  , we have that:
1. there exists a variable vi  V, such that pre(A)[i] 6= u, and
2. for each other variable vj  V  {vi }, pre(A)[j] = u.
Note that specifying both pre- and postconditions in case of only propositional variables
is redundant, and we use it only to simplify the presentation. Likewise, our assumption that
post(A) 6= u implies pre(A) 6= u is different from the usual strips formalism, and requires
an exponential time translation in general. However, in our case of only unary operators,
this translation takes only linear time.
318

fiStructure and Complexity in Planning with Unary Operators

2.1 Causal Graphs
Causal graphs were used by Williams and Nayak (1997) as a tool for describing the structure
of planning domains with unary operators. They represent a dependence relation between
the state variables in the domain. A causal graph G is a directed graph whose nodes
correspond to the state variables. An edge from p to q appears in the causal graph if
and only if some operator that changes the value of q has a prevail condition involving
some value of p. Hence the immediate predecessors of q in G are all those variables that
affect our ability to change the value of q. Such a problem structure was introduced by
Knoblock (1994) in the context of automatic generation of abstractions for planning. The
causal graph is an intuitive model which is easily constructed given any planning problem.
Causal graphs are not the only graphical structure that can be derived from a given
planning problem, and effectively exploited in solving it. For instance, graphs in which
operators and literals (and not variables/propositions) are represented by the nodes, and the
edges represent both prevail and preconditions were introduced by Etzioni (1993) and Smith
and Peot (1993). In particular, problem space graphs of Etzioni (1993) and operator graphs
of Smith and Peot (1993) were proposed as mechanisms to reduce the number of threats
that arise during the total-order and partial-order planning, respectively. However, in this
paper we focus on the causal graphs, since they were shown to be especially informative
when all operators are unary (Jonsson & Backstrom, 1998b; Williams & Nayak, 1997).
Causal graphs have an important potential role in the design of autonomous industrial
systems, as argued and demonstrated by Williams and Nayak (1997): Unary operators are
natural when the manipulated objects are hardware components, since the basic control
actions in such systems change the state of a single hardware component. The applicability
of these control actions in any state depends on the state of the affected component as
well as on the state of the related hardware components. This naturally gives rise to a
planning domain with unary operators. Moreover, since the state variables correspond
to hardware components, in the induced causal graph we typically see that the prevail
dependencies between variables are usually implicitly entailed by the inter-composition of
the hardware components. Thus, the causal graph of such domains resembles the structure
of and the relationships between the systems hardware components. This resemblance has
important practical ramifications for system design given the relationship between causal
graph structure and the complexity of plan generation: It enables the system designer to
consider the effect of his hardware design on the systems ability to autonomously generate
control sequences.
A case in point is the planning problem studied by Williams and Nayak (1997), which
had a number of important features: all operators were unary and reversible, and the causal
graph was acyclic. Williams and Nayak argued that acyclic connectivity frequently occurs
in designed systems. However, the requirement that all operators should be reversible seems
to us restrictive, and it has important impact on the complexity of the problem. In the
case of the Burton planner (Williams & Nayak, 1997), there were good reasons to make this
assumption. Burtons reactive nature precludes extensive deliberation on the consequences
of its operators. Thus it leaves open the possibility that operators may degrade the systems
capabilities, leading it to dead-ends. In that case, the restriction to reversible operators was
319

fiBrafman & Domshlak

required in order to achieve a more reliable system. As we show later, in certain cases,
complete plans can be generated efficiently even when the operators are not reversible.
Williams and Nayaks work has another interesting aspect, as noted by Weld (1999).
For a long time, researchers have known that planning problems with serializable subgoals
are likely to be easier to solve. Williams and Nayak recognized that their spacecraft configuration task was serializable (many real-world problems are not), and, more importantly,
they developed a fast algorithm for computing the correct order based on the fact that
the underlying causal graph is acyclic. However, their algorithm makes heavy use of the
fact that all operators are reversible. Informally, reversibility implies that we can solve our
subgoals one by one as long as they are consistent with some topological order of the causal
graph without taking into account any global considerations: any side-effect can always
be undone. Without the assumption of operator reversibility, it is relatively easy to show
that Williams and Nayaks algorithm works only if the causal graph forms a directed chain.
Even when the causal graph is a tree, although the problem is easy, one must take care in
the choice of which subgoal to achieve next when operators are not reversible. As we show
later, when the structure of the causal graph is more complicated than a directed tree then
either the problem is hard or, if not, a more sophisticated algorithm is required.
Finally, we note that the existence of reversible operators might make the problem seem
easier than it actually is. In this paper we present an example of a propositional planning
problem with unary operators, acyclic causal graph, and totally reversible operators, the
minimal solution of which is exponentially long in the size of the problems description.
2.2 Example
In order to illustrate the notion of a causal graph, consider the following example, inspired
by the work of Williams and Nayak (1997) on controlling the main engine subsystem of the
Cassini spacecraft, in general, and its valve driver circuitry, in particular.
Each valve V L (on/off) is controlled by a valve driver V LD (open/close), and a safety
control unit SCU (safe/unsafe). Each driver controls exactly one valve, while a safety
control unit can control several valves. Commands to the driver are sent via a driver
control unit, that consist of two switches, S l and S r , which can be either on or off. The
activating states of S l and S r are described below. A valve reacts (by a state change)
to a command from its driver only if (i) the instruction actually involve a state change
(i.e., an open valve should not be reopened), and (ii) the safety control unit indicates that
manipulating the valve is safe. In addition, the valve can be closed if the safety control unit
indicates an unsafe situation. For simplicity of presentation, Table 1 presents the operator
set for controlling the valves and valve drivers only. The dashed boxes stand for driver
control units, two switches in each.
Now suppose that the valves V L1 and V L2 , with the drivers V LD1 and V LD2 , respectively, are controlled by a shared safety control unit SCU . Given the operator set in
Table 1, the causal graph for controlling this subsystem is presented in Figure 1.

3. Polytree Causal Graphs
Starting at this section, we show how, by bounding the structural complexity of the causal
graph, we can bound the complexity of plan generation. Recall that we use a propositional
320

fiStructure and Complexity in Planning with Unary Operators

Affected component
V LD
VL

pre
close
open
on
of f
on

post
open
close
of f
on
of f

prv
Sl = 1  Sr = 0
Sl = 0  Sr = 1
V LD = close  SCU = saf e
V LD = open  SCU = saf e
SCU = unsaf e

Table 1: A subset of the operator set for the valve circuitry controller example.
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 




S1r

S1l




EE
ww
E

_ _ _ _ _EEE_ _ _ _ _ _www_w _ _ _ _
EE
w
w
E"
{ww

V LD1

GG
G#

SCU

HH
HH
HH
HH
H#



S2r 
S2l G
G
y
G
y


_ _ _ _ _GGG_G _ _ _ _ _ yy_y _ _ _ _



w
ww
ww
w
w
w{ w

V LD2

GG
GG
GG
GG
G#

V L1

yy
|yy

vv
vv
v
vv
v{ v

V L2

Figure 1: Causal graph for the example.
language (binary variables) to describe the state of the world, and each operator is described
by its prevail conditions, single precondition, and single effect (or post-condition). The
precondition and the effect are two literals, one the negation of the other.
A causal graph forms a polytree if there is a single path between every pair of nodes in
the induced undirected graph1 , i.e., the induced undirected graph is a tree. For example, the
causal graph presented in Figure 1 forms a polytree. For this class of problems we present
a planning algorithm which is polynomial if the indegree of all nodes in the causal graph is
bounded by a constant. We argue that this assumption is reasonable if the prevail dependencies reflect the inter-composition of some controlled hardware components (Williams &
Nayak, 1997).
Given a propositional planning instance with a polytree causal graph, we:
1. Provide a general upper bound for the number of times that a variable may be required
to change its value on a valid, irreducible plan.
2. Using this general upper bound, provide a polynomial time procedure, called determinemax-sequence, that, given a variable v, determines the actual maximal number of
times that v can change its value on a valid, irreducible plan.
3. Provide a preprocessing algorithm that: (a) determines whether or not a plan for a
given problem instance of our class exists, and (b) performs a substantial amount of
1. These graphs are also known as singly connected DAGs.

321

fiBrafman & Domshlak

preprocessing for the subsequent step of plan generating. This algorithm is based on
a top-down execution of determine-max-sequence on the variables of the given
problem instance.
4. If the answer of the plan existence check is positive we run a particular deterministic instance of the POP algorithm2 (Penberthy & Weld, 1992), called pop-pcg,
that generates the required plan using the information provided by the preprocessing
algorithm, without backtracking, in linear time.
Informally, this process is based on the following properties of the planning problems
with polytree causal graph. First, the bound achieved in step 1 is necessary for the steps 2-3,
which are the main steps of our technique. By itself, this bound will be valid not only for
a polytree, but for a wider class of directed-path singly connected causal graphs. However,
steps 2-3 will be valid for polytree causal graphs only, because of the following properties
of this form of dependence relation between the variables:
(i) Given a variable v  V, changing the value of a parent (immediate predecessor)
w  pred(v) does not require any changes of neither other parents of v, nor their
predecessors in the causal graph.
(ii) The number of times that a variable v will be able to change its value along a valid
plan for a given problem instance depends directly both on these numbers for pred(v),
and on the actual ordering of the value changes of pred(v).
(iii) From (i) it follows that all the possible orderings of the value changes of pred(v) are
legal. In addition, it will be shown that chosing an ordering for the value changes of
pred(v) will not affect our ability to change the value of any variable except of v.
(iv) The crucial part of the process (steps 2-3) is basically about finding the right ordering of
the right number of value changes of pred(v) for each variable v  V. By synchronizing
these changes to vs parents appropriately, we can increase the number of possible
changes to v.
We start with some notation. First, a valid plan P for a given planning instance 
will be called irreducible if any subplan P 0 of P is not a plan for , in the following sense:
Removal of any subset of (not necessarily subsequent) actions from P makes the resulting
plan either illegal, or its initial state is not Init, or its goal state is not one of the states
specified by Goal. The notion of irreducible plans was introduced by Kambhampati (1995),
where it was exploited for admissible pruning of partial plans during search3 .
2. A short review of the POP algorithm, and the corresponding formalism is provided in Appendix A. For
those familiar with the algorithm, we note one slight technical change, stemming from the use of unary
operators. POP uses two fictitious actions A0 and A to capture the initial and goal state, respectively.
Here, we replace each of these actions by a set of actions, each with a single effect. The (fictitious) action
setting the initial value of variable vi is denoted A0i and the fictitious action whose precondition is the
goal value of variable vi is denoted Ai .
3. Irreducible plans were called in (Kambhampati, 1995) minimal plans. However, we decided to change the
name of this concept in order to prevent an ambiguity between minimal as irreducible and minimal
as optimal.

322

fiStructure and Complexity in Planning with Unary Operators

Now, given a planning instance , let P be the set of all irreducible plans for . We
denote by MaxReq(v) the maximal number of times that a variable v  V changes its value
in the course of execution of an irreducible plan for . Formally, let Req(P, v) be the number
of times that v changes its value in the course of execution of a plan P . Then,
MaxReq(v) = max{Req(P, v)}
P P

Observe that, for any planning problem with unary operators, a variable must change
its value at most once for each required change of its immediate successors in the causal
graph (in order to satisfy the necessary prevail conditions), and then at most once in order
to obtain the value requested by the goal. Thus, for all variables in V, MaxReq(v) satisfies:
X
MaxReq(v)  1 +
MaxReq(u)
(1)
succ(v)

where succ(v) denotes the immediate successors of v in the corresponding causal graph.
Adopting the terminology from (Domshlak & Shimony, 2003; Shimony & Domshlak, 2002),
a directed acyclic graph G is directed-path singly connected if, for every pair of nodes s, t  G,
there is at most one directed path from s to t. The following lemma shows that if the causal
graph forms a directed-path singly connected DAG then we can bound MaxReq(v) by n.
Clearly, all polytrees are directed-path singly connected DAGs, but not vice versa.
Lemma 1 For any solvable problem instance  with a directed-path singly connected causal
graph over n variables, for any variable v, we have that MaxReq(v)  n.
Proof: The proof is by induction on n. For n = 1 it is obvious that MaxReq(v)  1. Now
suppose that when |V| = n  1 then for any v  V,
MaxReq(v)  n  1
Let 0 be some problem instance for which |V 0 | = n. Suppose that the variables in V 0 =
{v1 , . . . vn } are topologically ordered based on the domains causal graph. Clearly, vn is
a leaf node (i.e., succ (vn ) = ). We will denote by  the problem instance obtained by
removing vn from the domain, and the corresponding variable set by V. According to Eq. 1,
for each immediate predecessor v of vn in the causal graph,
newMaxReq(v)  MaxReq(v) + newMaxReq(vn )  MaxReq(v) + 1
where newMaxReq(v) denotes MaxReq(v) with respect to 0 . Generally, since the causal
graph is directed-path singly connected, for each variable v  V 0 ,

MaxReq(v) + 1, if there is a path from v to vn
newMaxReq(v) 
(2)
MaxReq(v),
otherwise
and thus, for each v  V 0 , holds
newMaxReq(v)  n

323

fiBrafman & Domshlak

Recall that MaxReq(v) stands for an upper bound on the number of value changes of v
that may be required by a valid, irreducible plan. However, the maximal achievable number
of value changes of v, denoted by MaxPoss(v) can be greater or less than MaxReq(v). For
example, if v has no predecessors in the causal graph, and there are two operators affecting
v differently, then MaxPoss(v) = .
We denote the upper bound on the feasible number of value changes of v that may
be required in a valid, irreducible plan for  by FMaxReq(v). Informally, no more than
MaxPoss(v) value changes of v can be required and no more than MaxReq(v) value changes
of v should be required, thus
FMaxReq(v) = min(MaxPoss(v), MaxReq(v))

(3)

Determining FMaxReq(v) for all variables requires explicit examination of a given problem instance. Recall that here we restrict the causal graph of  to form a polytree. To
simplify the presentation, we assume that the goal values are specified for all state variables,
i.e. Goal  D(v1 )  . . .  D(vn ). Later we show that this assumption does not affect the
generality of the algorithm. Denote by v 0 and v  the initial and the goal values of v in ,
and by v   the set of all operators affecting v. First we examine the root variables of
the causal graph, then we analyze the rest of the variables.
Denote by pred(v) the immediate predecessors of v in the causal graph. If pred(v) = ,
+
+

then there are at most two operators A
v , Av in v : Av has v as its postcondition, while

Av has the reverse effect. Since these operators have no prevail condition, if both A
v and
+
Av are presented in , then they can be applied one after another an infinite number of
+
times. Therefore, from Eq. 3, FMaxReq(v) = n. If v 6= {A
v , Av } then we have two cases:
If the initial and the goal values of v are the same, then we cannot change the value of v
and reconstruct it later, and thus FMaxReq(v) = 0. Alternatively, if the initial and the goal
values of v are different then if v = {A+
v } then we can achieve the goal value of v but only
once and thus FMaxReq(v) = 1. Otherwise, the goal value of v is unachievable, thus the
given problem instance is unsolvable. Table 2 summarize this analysis.

v0
v0

=

v

6=

v

v

{Av , A+
v}
otherwise
+
{A
v , Av }
+
{Av }
otherwise

FMaxReq(v)
n
0
n
1
no solution

Table 2: FMaxReq(v) values for the root variables in the causal graph.
Now consider a variable v which is presented by an internal node in the causal graph:
pred(v) = {w1 , . . . , wk } =
6 . Observe that the number of possible value changes of v depends
on and only on:
1. The initial and the goal values of v, i.e., v 0 and v  .
324

fiStructure and Complexity in Planning with Unary Operators

2. The set of operators affecting v, i.e., v .
3. The maximally possible (but still reasonable) number of times that predecessors of v
can change their values, i.e., FMaxReq(w1 ), . . . , FMaxReq(wk ).
4. The actual scheduling of the value changes of the predecessors of v.
The last point is crucial  it means that in order to determine FMaxReq(v) we should find
a particular scheduling of the value changes of pred(v) that allows such a maximal number
of value changes for v. The corresponding interleaving sequence of vs values, starting and
finishing by v 0 and v  respectively, with FMaxReq(v) value changes will be called maximal
and will be denoted by (v) (|(v)| = FMaxReq(v) + 1).
From Lemma 1, for 1  i  k, we have FMaxReq(wi )  n, thus the number of different
orderings of value changes of pred(v) can be exponential in n. For instance, when, for
1  i  k, we have FMaxReq(wi ) = n, this number of different orderings can be expressed
as:


k1
n 
YX
n  1 ni + 1
 2nk
j
j1
i=1 j=1

where the correctness of the expression on the left side of the inequality is shown by Lemma 4
(see Appendix B, p. 347). Clearly, we cannot check all these orderings in a naive manner.
Following, we provide an algorithm that determines (v) in time which is polynomial in n.
For clarity of presentation we want to distinguish between the different elements of a
maximal sequence (v). Since all variables are binary, we denote the initial value of v, v 0 ,
by bv and the opposite value by wv (black/white). Similarly, bi and wi will stand for the
corresponding values of the variable vi . If so, we can think about all the operators in 
as described in this language. Likewise, we sequentially number the appearances of each
value of v on (v). For example, biv stands for the ith appearance of the value bv along
(v). To illustrate this notation, suppose that D(v) = {true, f alse}, the initial value of v
is v 0 = true, and FMaxReq(v) = 4. Then, we have:
bv  true
wv  f alse
(v) = b1v  wv1  b2v  wv2  b3v
First, for every variable v, every operator A  v is extended to a set of operators that
explicitly specify prevail values for all parents of v in the causal graph: If |pred(v)| = k,
and the prevail condition of A is specified only in terms of some 0  k 0  k parents4 of
0
v, then A is extended to a set of 2kk operators, where each operator extends A by an
instantiation of the previously unspecified parents of v. For example, consider a variable v
with pred(v) = {u, w}, and an operator
A = {pre : {bv }, post : {wv }, prv : {bu }},
4. For every other parent wj of v, we have prv(A)[j] = u.

325

fiBrafman & Domshlak

the prevail condition of which does not involve w. This operator is extended to a pair of
operators:
A0 = {pre : {bv }, post : {wv }, prv : {bu , bw }}
A00 = {pre : {bv }, post : {wv }, prv : {bu , ww }}

corresponding to the possible values of w. In what follows, we refer to the operator set
resulting from such a compilation of  as ./ . Note that, under the assumption of constantly
bounded maximal indegree  of the causal graph, compiling  into ./ takes only polynomial
+1 , and thus |./ | = O(n2+1 ).
time, since, for every variable v, |./
v |2
Given the maximal sequences (w1 ), . . . , (wk ) and the operator set ./
v we construct
0
a directed graph (denoted as Ge (v)) that captures all (and only) feasible sequences of, up
to n, value changes of v, where each value change is annotated with the corresponding
assignment on pred(v). Although the number of the captured sequences can be exponential
in n, the size of G0e (v) is polynomial in n. With respect to this graph, the problem of finding
the maximal sequence (v) is reduced to the problem of finding a longest path from a given
node to an arbitrary other node in a directed acyclic graph.
The graph G0e (v) is created in three incremental steps. At the first step, given the
maximal sequences (w1 ), . . . , (wk ) and the operator set ./
v we construct a directed labeled
graph G(v) capturing information about all sequences of assignments on pred(v) that can
enable n or less value flips of v. The graph G(v) is defined as follows:
1. G(v) consist of  nodes, where

 n, ((n = 2j) and (v 0 = v  )) or
((n = 2j + 1) and (v 0 6= v  )), j  N
=

n  1, otherwise
2. G(v) forms a 2-colored multichain, i.e., (i) the nodes of the graph are colored by black
and white, starting by black; (ii) there are no two subsequent nodes with the same
color; (iii) for 1  i    1, edges from the node i are only to the node i + 1.
Observe that such a construction of G(v) promises that the color of the last node will
be consistent with v  .
3. The nodes of G(v) are denoted precisely by the elements of the maximal sequence
(v), i.e., biv stands for the ith black node in G(v).
4. Suppose that there are m operators in ./
v that change the value of v from bv to wv . In
i
this case, for each i, there are m edges from biv to wvi , and |./
v |  m edges from wv to
bi+1
v . All edges are labeled by the prevail conditions of the corresponding operators,
i.e., a k-tuple of the values of w1 , . . . , wk . This tuple is denoted by l(e) (label of the
edge e) and its component, corresponding to a predecessor wi , is denoted by l(e)wi .
This formal definition of G(v) is relatively complicated, thus we provide a demonstrating
example: Suppose that we are given a problem instance over 5 variables, and we consider
326

fiStructure and Complexity in Planning with Unary Operators

a variable v with pred(v) = {u, w}, v 0 = bv , and v  = wv . Recall that every operator in
./ is presented as a three-tuple hpre, post, prvi of pre-, post-, and prevail conditions of the
operator respectively. Suppose that:
1
2
(u) = b1u  wu1
(w) = b1w  ww
 b2w  ww
 1
 Av = {pre : {bv }, post : {wv }, prv : {bu , ww }}
./
A2 = {pre : {wv }, post : {bv }, prv : {bu , bw }}
v =
 v3
Av = {pre : {wv }, post : {bv }, prv : {wu , ww }}

For this case, the graph G(v) is presented by Figure 2.
bu bw
bu ww /
b1v

wv1

bu bw

$
:

bu ww /
b2v

wv2

$

3 bu ww /

: bv

wv3

wu ww

wu ww

Figure 2: Example of the graph G(v).
The constructed graph G(v) captures information about all potentially possible executions of the operators in ./
v that can provide us MaxReq(v) or less value changes of v.
Each path, started at the source node of G(v), uniquely corresponds to such an execution.
Although the number of these alternative executions may be exponential in n, this graphical representation is compact: the number of edges in G(v) is O(n  |./
v |). Note that the
information about the number of times that each operator in ./
can
be executed is not
v
captured by G(v). The following two steps add this information indirectly and exploit it to
find a maximal sequence (v).
At the second step of construction, we expand G(v) with respect to the maximal sequences (w1 ), . . . , (wk ) as follows: Each edge e  G(v) (which by definition corresponds
to some operator A  ./
v ), is replaced by a set of edges such that their labels correspond to
all possible assignments of the elements of (w1 ), . . . , (wk ) to l(e) (i.e., prv(A)). Likewise,
we add a dummy source node sv , with an edge from sv to the original source node of G(v)
labeled by a tuple of the first elements of (w1 ), . . . , (wk ) (= initial values of w1 , . . . , wk ).
Similarly, we add a dummy target node tv , with an edge from the original target node of
G(v) to tv labeled by a tuple of the last elements of (w1 ), . . . , (wk ) (= goal values of
w1 , . . . , wk ). We denote this extended graph by G0 (v), and Figure 3 illustrates G0 (v) for the
example above.
The extended graph G0 (v) can be viewed as a projection of the maximal sequences (wi ),
1  i  k, on the graph G(v). Each edge in G(v) may be replaced by O(nk ) edges in G0 (v),
and thus the number of edges in G0 (v) is O(nk+1  |./
v |).
It is easy to see that not all paths in G0 (v) starting at sv are relevant. For example, in
G0 (v) above, an operator instance prevailed by b1u b2w can not be performed after an operator
2 . Thus, now we are faced with the problem of finding a longest
instance prevailed by b1u ww
feasible path from sv to a node in G0 (v), the label of which is consistent with v  . The
following (last) step provides a reduction of the problem of finding a longest feasible path
from sv to a v  -colored node in G0 (v) to a known problem of finding a longest path in a
327

fiBrafman & Domshlak

b1u b1w

b1u b1w
1
b1u ww

sv

b1u b1w

/ b1
v
2
b1u ww

&

b1u b2w
1
8 wv
1 w1
wu
w

% 
2
9 bH v

1
b1u ww

2
b1u ww

1 w2
wu
w

&

b1u b2w
2
8 wv

% 
3
9 bH v

1 w1
wu
w

1
b1u ww

&

3
8 wv

1 w2
wu
w

/ tv

2
b1u ww

1 w2
wu
w

Figure 3: Example of the graph G0 (v).
directed acyclic graph. Let the graph G0e (v) have the edges of G0 (v) as nodes, and let its
edges be defined by all allowed pairs of immediately subsequent edges in G0 (v): (e, e0 ) is
allowed if, for 1  i  k, either l(e)wi = l(e0 )wi or l(e0 )wi appears after l(e)wi on (wi ). Such
a construction is a variant of a so called edge graph known in graph theory; the addition
in our case is the exclusion of non-allowed edges from it. Clearly, G0e (v) can be constructed
2
in time polynomial in size of G0 (v), and the number of edges in G0e (v) is O(n2k+2  |./
v | ).
b1u b1w

b1 b1

2
wu1 ww

2
wu1 ww

u /w J
// JJ
// JJJ
// JJJJ
// JJJ
J
//
JJ
JJ
//
$
$
//
/
1
1
1
2
1
1
1
1
2
/
_
_
_
_
/
bu bw //
b1u ww
bu ww
bu ww
bu bw //
//77
77 /
JJ
7
//77
//
u:
JJ
77 //
7 /
u
//77
//77
JJ
u
/
/
77 /
7 /
JJ
// 77
// 77
u
J$
/
/
7
7
7
7
u
// 7
// 7
//
77 //
7
7
7
1
1
2
/
/
7
7
7
bu bw
wu1 ww
77 //
7 //
// 77
// 77
II
u:
77//
7 //
II
u
// 77
// 77
II
uu
77//
7 //
// 77
// 77
II
uu
u
/
/
7
7
7
7
I$
u
// 
// 

u

// w1 w1
// w1 w1
2
1 w2
1 w2
b1u ww
b
b
u wJ
u w
// u w
// u w
JJ
JJ
JJ
//
JJ
JJ ///
JJ /
JJ /
JJ /
J$ 
$ 

Figure 4: Example of the graph G0e (v).
Figure 4 presents G0e (v) for our example. The dashed edges present the longest path
from the dummy source node to a node that corresponds to a value change from v  to v 
(from bv to wv ). Such a longest path in G0e (v) describes a maximal sequence of value changes
(v), and its length is actually FMaxReq(v) + 1. In our example, (v) = b1v  wv1  b2v  wv2 , and
FMaxReq(v) = 3. Note that if v 0 = v  then the empty path will be also acceptable since,
in general, v does not have to change its value. In this case FMaxReq(v) = 0 and (v) will
consist of only one element which corresponds to the initial (= goal) value of v.
Observe that a longest path in G0e (v) describes not only (v) but also the actual sequence
j
of invocations of the operators from ./
v that provides (v). We denote by {A(bv )} and
j
{A(wv )} the sequences of operator instances that have as effects the corresponding elements
from the sequences {bjv } and {wvj } ({bjv }  {wvj } = (v)) of vs values, respectively. In
what follows, we address these sequences of operator instances as one sequence of operator
328

fiStructure and Complexity in Planning with Unary Operators

Procedure forward-check ()
1. Topologically sort all variables V based on the the causal graph.
2. For each variable v  V, call determine-max-sequence(, v), respecting the above
ordering.
3. If one of the calls to determine-max-sequence return failure, then return failure.
Otherwise return success.
Procedure determine-max-sequence (, v)
1. If pred(v) =  then
(a) If v 0 6= v  and A+
v 6 v , return failure.
(b) Otherwise, determine (v) according to the rules in Table 2, and return success.
2. Otherwise, if pred(v) = {w1 , . . . , wk } then
(a) Construct G(v) (based on v 0 , v  , and ./
v ).
(b) Construct G0 (v) (from G(v), based on (w1 ), . . . (wk )).
(c) Construct G0e (v) (from G0 (v), based on (w1 ), . . . (wk )).
(d) Determine the longest path in G0e (v) to a node corresponding to a v  -ended value
change, and derive (v) and the corresponding sequence of operators from it.
(e) If v 0 6= v  and FMaxReq(v) = 0, return failure. Otherwise, return success.
Figure 5: forward-check algorithm
FMaxReq(v)

instances v = {A(vi )}i=2

vi

=




, where A(vi ) has vi as its effect, and
i+1

bv 2 ,
i
2

 w ,
v

i = 2k + 1

kN

i = 2k

Procedure forward-check in Figure 5 summarizes the presented approach. Note that
finding a set of longest paths from a node to all other nodes in a directed acyclic graph
can be done in time linear in the size of the graph (Wiest & Levy, 1969). Therefore, the
time complexity of a call to the determine-max-sequence procedure with a variable v is
2
bounded by the size of the constructed graph G0e (v) and thus is O(n2k+2 |./
v | ). forwardcheck calls determine-max-sequence n times. Therefore, if the maximal node indegree
is bounded by a constant , then the overall complexity of the algorithm is O(|V|2+3 22+2 ),
i.e., polynomial in the size of the problem description.
Theorem 1 A given problem instance with a polytree causal graph is solvable if and only
if, for each v  V, forward-check succeeds in constructing the maximal sequence (v).
forward-check fails if and only if at least one of the calls to the determine-maxsequence procedure fails. In turn, a call to determine-max-sequence on a variable v
329

fiBrafman & Domshlak

Algorithm: pop-pcg (hA, O, Li, agenda, )
1. Termination: If agenda is empty, return hA, O, Li
2. Goal selection: Let hi , Aneed i be a rightmost pair on the agenda (by definition,
Aneed  A and i is one of the pre/prevail conditions of Aneed ).
3. Operator selection:
(a) If Aneed 6= Ai (i = ij ) then Aadd = A(ij )  i  {A0i }.
(b) Otherwise:
i. Let m = max { j | A(ij )  A}.
ii. If vi is consistent with im (both associated with the same color from {b, w})
then Aadd = A(im ), else Aadd = A(im+1 ).


4. Plan updating: Let L = L  {Aadd i Aneed }, and let O = O  {Aadd < Aneed }. If
Aadd is newly instantiated, then A = A  {Aadd } and O = O  {A0i < Aadd < Ai }
(otherwise A and O remain unchanged).
5. Update goal set: Let agenda = agenda - {hi , Aneed i}. If Aadd is newly instantiated,
then for each of its pre/prevail conditions Q, add hQ, Aadd i to agenda.
6. Threat prevention: If Aadd = A(ij ), j > 1, then, for each A  A, s.t. ij1 belongs
to the prevail conditions of A, add {A < A(ij )} to O.
7. Recursive invocation: pop-pcg(hA, O, Li, agenda, ), where agenda is topologically ordered (based on the causal graph with respect to the precondition part of each
pair).
Figure 6: pop-pcg algorithm
fails if and only if the initial and the goal values of v are different but there is no way to
change the value of v even once. Thus, if forward-check fails, then no plan exists.
To prove the opposite direction we proceed as follows: We define the pop-pcg algorithm
(POP for polytree causal graphs) and show that it will succeed without backtracking if
forward-check succeeds.5 pop-pcg is described in detail in Figure 6, and it works as
follows: First, let us expand each sequence of operator instances i by A(i1 ) (A(b1i )) which
will stand for the dummy operator A0i . (Recall that up until now, only operators of the
form A(ij ) for j > 1 were defined.) The algorithm maintains a goal agenda sorted based
on the causal graph structure: parent variables appear after their descendents. At each
point, the next agenda item is selected; if it requires achieving some value for vi we add the
corresponding operator to the plan with the desired effect (step 3a). Actually, if we would
be ready to accept plans with possible redundant steps, we can omit the next step 3b from
the algorithm by assuming that the goal value of each variable v is the last element of the
5. For a short review of the POP algorithm, the corresponding formalism, and the description of the initial
call to the algorithm, we refer the reader to Appendix A.

330

fiStructure and Complexity in Planning with Unary Operators

maximal sequence (v). However, if we would like our plan to be irreducible, then a careful
decision about the really required number of value changes of each variable is required.
This decision is captured in step 3b by analysis of the value changes of a variable vi that
were found necessary in the previous iterations of the algorithm in order to satisfy the
predecessors of vi in the causal graph. Note that the agenda is sorted with respect to some
reverse topological ordering of the causal graph, thus if an operator affecting vi was selected
from the agenda then no operator affecting some predecessor of vi in the causal graph will
appear on the agenda until the end of the algorithm. No threats arise in pop-pcg, and the
ordering constraints are consistent.
Lemma 2 If forward-check was successful then pop-pcg will return a valid plan.
Proof:

The lemma will follow from the following claims:

1. For every agenda item, there exists an operator that has it as an effect.
2. There are no threats in the output of pop-pcg.
3. The ordering constraints in O are consistent.
4. The agenda will be empty after a polynomial number of steps.
For the proof see Appendix B, p. 343. 
Recall that, for simplicity of presentation, we assumed that the goal values are specified
for all state variables (single goal state), i.e. Goal  D(v1 )  . . .  D(vn ). Now we show that
the presented approach, with minor modifications, works for a set of possible goal states as
well, if such a set is specified by a partial assignment on V, i.e. Goal  D+ (v1 ). . .D+ (vn ).
Note that the latter assumption is widely accepted in the planning literature.
First, no modifications should be done in processing variables that are specified by Goal.
Now, for each variable v, such that v  is not specified by Goal, the modifications are as
follows:
1. The graph G(v) will consist of exactly n nodes. This is correct since (i) according to
Lemma 1, n changes of v have to be sufficient, and (ii) any value change of v can be
its last value change.
2. No changes in construction of G0 (v) and G0e (v).
3. In the procedure determine-max-sequence:
(a) In step 2d, determine the longest path from the dummy source node to any other
node in the graph.
(b) In step 2e, always return success.
Again, this is correct since any value change of v can be its last value change, and, in
particular, v may remain unchanged in a plan for a given problem.
Finally, the pop-pcg algorithm starts with a null plan that contains the end operator
Ai only if vi is specified by Goal.
331

fiBrafman & Domshlak

4. Directed-Path Singly Connected and General DAGs
In this section we analyze planning complexity in face of more complicated causal graphs.
First, we show that when the causal graph is directed-path singly connected even plan
existence is np-complete. Second, we show that for general causal graphs the situation is
even worse. Finally, we characterize an important parameter of the causal graph affecting
planning complexity, which allows us to extend the class of problems which are in np.
Theorem 2 Plan existence for strips planning problems with unary operators and directedpath singly connected causal graph is np-complete.
Proof:

For the proof see Appendix B, p. 346. 

Note that node indegree in the causal graph of the problem created in the proof of
Theorem 2 is bounded by 6. The hardness for directed-path singly connected causal graphs
with maximal indegree lower than 6 is thus open.
The directed-path singly connected structure of the causal graph turns out to be crucial
for guaranteeing reasonable solution times. As we now show, there are solvable propositional planning problems with an arbitrary acyclic (DAG) causal graph that have minimal
solutions of exponential size. Analysis of this class of problems points to the reason for such
provable intractability. This allows us to characterize an important parameter of the causal
graph affecting planning complexity and to extend the class of problems which are in np.
However, all these restricted problems are still np-complete.
Theorem 3 Plan generation for general strips planning problems with unary operators
and acyclic causal graph is provably intractable, i.e. it is harder than np.
This theorem follows from Theorem 5.4 in (Jonsson & Backstrom, 1998b), that shows
that plan generation for the 3S problem class is provably intractable. The point is that the
upper bound for MinPlanSize, presented in Eq. 5, can be exponential in the size of the input
in this case. First, we show by example that this upper bound can be achieved, then we
present some analysis of the reasons for this intractability.
The following example shows that an exponential upper bound can be achieved. It was
used in the proof of Theorem 5.4 in (Jonsson & Backstrom, 1998b), and was originally
presented in a different context by Backstrom and Nebel (1995). Consider a propositional
planning problem with |V| = n, where, for 1  i  n, D(vi ) = {0, 1} and pred(vi ) =
{v1 , . . . vi1 }. The operator set  consist of 2n operators {A1 , A01 , . . . An , A0n } where
pre(Ai )[j] =

post(A0i )[j]


=

0 if j = i
u otherwise


1
pre(A0i )[j] = post(Ai )[j] =
u

 0
0
1
prv(Ai )[j] = prv(Ai )[j] =

u
332

if j = i
otherwise
if j < i  1
if j = i  1
otherwise

fiStructure and Complexity in Planning with Unary Operators

It is easy to see that the causal graph of this problem forms a DAG (see Figure 7), and
an instance of this planning problem with the initial state h0, . . . , 0i and the goal state
h0, . . . , 0, 1i has a unique minimal solution of length 2n  1 corresponding to a Hamilton
path in the state space.
PQRS
WVUT
V1

PQRS
/ WVUT
V2

'

...

4

PQRS
WVUT
Vn1

&
PQRS
/ WVUT
Vn
7

Figure 7: Causal graph for the proof of Theorem 3
Now we show that this escalation in complexity can be parametrized by the form of
the causal graph.
Lemma 3 For any solvable problem instance  with an acyclic causal graph over n variables, for any variable v, we have that:
MaxReq(vi )  1 +

n
X

(vi , vj )

j=i+1

where (vi , vj ) denotes the total number of different, not necessary disjoint, paths from vi
to vj , where variables are ordered via a topological sort of the causal graph.
Proof: The proof is by induction on i. For i = n it is obvious that MaxReq(vn )  1.
Now we assume that the lemma holds for any i > k, and prove it for i = k. Without loss
of generality, assume that succ(vk ) 6= . Otherwise, we simply have that MaxReq(vk )  1.
The proof is straightforward:
Eq. 1

MaxReq(vk )



X

1 +

MaxReq(vik ) 

vik succ(vk )
I.H.



X

1 + |succ(vk )| +

vik succ(vk )

=

1+

n
X

n
X

(vik , vj ) =

j=ik +1

(vk , vj )

j=k+1


Lemma 3 entails that the upper bound for MinPlanSize() for a general planning problem
with unary operators and acyclic causal graph depends on the number of different paths
between the nodes in the causal graph. An immediate conclusion is that there is a significant
class of problems with an acyclic causal graph for which planning is in np. Let a DAG be
called max--connected if the number of different directed paths between every two nodes
in this graph is bounded by .
333

fiBrafman & Domshlak

Theorem 4 Plan generation for strips planning problems with unary operators and max-connected causal graph is np-complete if  is polynomially bounded.
Proof: Membership in np is straightforward: If the variables of a given problem  are
considered in a topological ordering induced by the causal graph, then from Lemma 3 follows
that, for any variable vi , MaxReq(vi )  n. In turn, from this follows that MinPlanSize() 
n2 , and thus, if  is polynomially bounded, then we can guess a minimal plan for  that
could be verified in polynomial time.
The hardness follows from Theorem 2 that shows that even if the causal graph is max-1connected (directed-path singly connected), then plan existence (and thus plan generation)
is hard. 

5. Serializable Subgoals
A set of subgoals is defined to be serializable (Korf, 1987) if there exists an ordering among
the subgoals such that the subgoals can always be solved sequentially without ever violating
a previously solved subgoal in the order. Naturally, not all collections of subgoals are
serializable  sometimes it may be necessary to interleave plans for achieving different goals.
However, when a problem instance is serially decomposable, it is possible to design a set of
macro-operators with respect to which the subgoals are serializable (Korf, 1985).
A problem instance is serially decomposable if there exists some ordering of the state
variables for which the effect of each operator on each state variable depends only on that
state variable and previous state variables in the ordering. Unfortunately, Bylander (1992)
shows that determining serial decomposability of a problem is pspace-complete.
One major open problem put forth by Bylander in this context is: If a problem is
known to be serially decomposable, how difficult is it to determine whether a given instance
is solvable? As far as we know, the only work in this direction was done by Chalasani
et al. (1991), where the serial decomposability of the general permutation problem was
considered. In particular, they showed that this problem is in np, but it is unknown
whether it is np-hard. Recently, some complementary results for Bylanders question were
presented Koehler and Hoffmann (2000). Our results shed more light on this question:
Any problem instance based on a unary operator domain whose causal graph is acyclic is
serially decomposable. Therefore, it can be concluded that finding a solution for serially
decomposable problems may require exponential time (i.e., the problem is in exptime).
However, Bylanders question is about plan existence. In that case, Theorem 3 does not
apply, and we can only apply our np-hardness result (for directed-path singly-connected
graphs), since it addresses plan existence as well.
Weld (1999) hypothesized that: (1) If the underlying causal graph of the planning
problem is acyclic, then a serialization ordering on the subgoals of the problem is obvious;
(2) Serialized subgoals could be solved extremely quickly because no backtracking is required
between them. Although the first observation sounds intuitive, our results suggest that it
is rarely true. The acyclicity of the causal graph implies serializability, but in most of the
cases its structure does not provide us sufficient information about the actual serialization
ordering. Even when the causal graph is a directed tree one must think first before choosing
334

fiStructure and Complexity in Planning with Unary Operators

an ordering. Likewise, our results imply that when the causal graph does not form an
undirected tree determining a subgoal ordering is np-complete, and if the causal graph is
not directed-path singly connected, the problem is even more complex.
The second observation is not always true either. The problem is that it is important to
determine not only the serialization ordering over the subgoals, but also the exact strategies
for achieving them. As we showed, in certain cases, a problem with n serializable subgoals
requires an exponentially long solution. When the domain variables are not binary, the
situation is even worse  some of the corresponding complexity results can be derived from
the computational analysis of Domshlak and Dinitz (2001).

6. Connection with Related Work on Planning Complexity
The idea of analyzing and exploiting structural properties is not new to classical planning,
and in the last few years a number of important results have emerged. Generating plans
in the context of the strips representation language was shown by Bylander (1994) to
be pspace-complete. Despite this fact, the existence of many successful planning systems,
especially in recent years, demonstrates that planning is possible and practical for a wide list
of domains. Bylander argues that the large gap between the theoretical hardness of planning
and its practical success stems from the use of domain-dependent problem analysis and
algorithms. Consequently, various authors have explored the existence of some constrained
problem classes for which planning is easier.
In this section we shortly overview some of the major, previous results on complexity
of planning, and discuss their relationship to the results presented in this paper. For a
more detailed presentation of the previous results discussed below we refer the reader to
the original papers.
6.1 Local Syntactical Restrictions
In his seminal paper, Bylander (1994) presents a number of complexity results for propositional planning, analyzing different planning problems based on the type of formulas used,
the number and type (positive/negative) of operator pre- and postconditions, etc. The work
of Bylander is extended by some interesting, complementary results by Erol at al. (1995).
For example, Bylander shows that propositional planning in domains where each operator
is restricted to have positive preconditions and one postcondition only is tractable. Generally, extremely severe restrictions on operators are required to guarantee tractability, or
even membership in np. Note that Bylander (1994) and Erol et al. (1995) focuses on local
syntactical properties of operators, i.e., properties of single operators.
The only syntactic restriction that we pose on the planning problems in this paper is
the unarity of the operators. Determining plan existence for this, apparently easier class
of problems was shown by Bylander to be as hard as general propositional planning, i.e.
pspace-complete. Note that this result by itself does not entail our Theorem 3, since
planning problems with unary operators may induce causal graphs with cycles. Therefore,
none of our results is entailed by the results presented by Bylander (1994) and Erol et
al. (1995).
335

fiBrafman & Domshlak

6.2 Global Syntactical Restrictions
Backstrom and Klein (1991a, 1991b), and, subsequently, Backstrom and Nebel (1995),
consider other types of restrictions, but using a more refined model (the SAS formalism) in
which:
1. The state variables are multi-valued, and
2. Two types of preconditions are considered: prevail conditions, which are variable
values that are required prior to the execution of the operator and are not affected by
the operator, and preconditions, which are affected by the operator.
In general, four different restrictions were considered in these works:
(P) Post-uniqueness: For each effect there is at most one operator that achieves this effect.
In other words, desired effects determine operators to be used in a plan. Formally, a
problem instance is post-unique if and only if, for each vi  V and x  D(vi ), there is
at most one operator A   such that post(A)[i] = x.
(S) Single-valuedness: At most one value of each state variable appears in the prevail
conditions of the operators. For instance, if a certain operator requires the light
to be on (as a prevail condition), no other operator can use the prevail condition
that the light is off. Formally, a problem instance is single-valued iff there exist no
two operators A, A0   and vi  V such that prv(A)[i] 6= u, prv(A0 )[i] 6= u, and
prv(A)[i] 6= prv(A0 )[i].
(U) Unariness: Each operator affects only one state variable.
(B) Binariness: All state variables have exactly two possible values, i.e. all state variables
are propositional.
All these four properties are syntactical. However, the properties P and S differ from the
properties U and B by the fact that they have a global nature: Post-uniqueness and singlevaluedness restrict not the form of the operators, but a global property of the whole set of
operators. Backstrom and Nebel (1995) showed that US (unariness and single-valuedness)
is the extreme problem class for which plan generation is polynomial. 6
The problems that we analyzed in this paper belong to the problem class UB, by definition. As we already mentioned, even determining plan existence for this class of problems
is pspace-complete. Now consider the problem class PUB. Backstrom and Nebel (1995)
showed that: (i) PUB has instances with exponentially long minimal solutions, thus plan
generation for PUB is requires exponential time; (ii) existence of bounded length plans for
PUB is strongly np-hard; and (iii) the complexity of general plan existence for PUB is still
an open question. Informally it means that strengthening restrictions from UB to PUB
does not reduce the complexity significantly, at least from the practical point of view.
Proposition 1 Every UB problem instance with a tree causal graph is either post-unique,
or can be transformed into an equivalent post-unique problem instance in (low) polynomial
time. Thus, TreeUB  PUB.
6. For a thorough analysis of the complexity of SAS planning, we refer to Backstrom and Nebel (1995).

336

fiStructure and Complexity in Planning with Unary Operators

Proof: Consider a UB problem with a tree causal graph, and suppose that it is not postunique. It means that there exist a variable v  V, with D(v) = {v 0 , v 00 }, such that there
exist two operators A1 , A2  v that change the value of v from v 0 to v 00 , and prv(A1 ) 6=
prv(A2 ).
From the assumption that the causal graph forms a tree it follows that |pred(v)|  1.
If pred(v) = , then it is easy to see that the existence of such a pair of operators is
simply impossible. Therefore, let pred(v) = {w}, where D(w) = {w0 , w00 }. Without loss of
generality assume that prv(A1 )[w] = {w0 }, prv(A2 )[w] = {w00 }. Otherwise, if, for instance,
prv(A1 )[w] = u, then it is easy to see that A2 is a redundant operator.
Observe that in this case, prevail dependence of v on w is redundant: We can replace
the pair of operators A1 , A2 in  by a single operator A that changes the value of v from
v 0 to v 00 without any prevail condition. The replacement of A1 , A2 by A brings us to an
equivalent problem instance in which the operator set v is post-unique. This way we
continue to process iteratively all such problematic variables v until we arrive at a postunique problem instance. 

Proposition 2 There are UB problem instances with a tree causal graph that are not singlevalued, thus TreeUB 6 UBS.
Proof: The proof of Proposition 2 is straightforward: Consider a variable v  V, D(v) =
{v 0 , v 00 }, such that succ(v) = {u, w}. It can be the case that any value change of u will be
prevailed by v 0 , while any value change of w will be prevailed by v 00 . Therefore, restricting
causal graphs even to trees does not entail single-valuedness.7 
Propositions 1 and 2 show that TreeUB is a polynomial subclass of PUB that is not
entailed by any tractability results of Backstrom and Nebel (1995).
Proposition 3 There are UB problem instances with a polytree causal graph that are neither single-valued, nor post-unique.
Proof: The proof is straightforward: Consider a planning problem with a polytree causal
graph, such that there exist a variable v  V with pred(v) = {u, w}, and the following
operator set v :
pre
v0
v0
v 00
v 00

post
v 00
v 00
v0
v0

prv
{u0 , w00 }
{u00 , w0 }
{u0 , w0 }
{u00 , w00 }

Clearly, any problem instance with such v   is neither single-valued, nor postunique, since (i) there is more than one operator achieving any value of v, and (ii) both
values of u (and both values of w) appear in prevail conditions of the operators in v . Note
7. Using the simple construction technique from the proof of Proposition 1 it can be shown that restricting
causal graphs to directed chains only does entails single-valuedness. However, this case is too restrictive.

337

fiBrafman & Domshlak

that the maximal indegree of such a polytree can be minimal, i.e. equal to 2. Thus, the
proposition is valid for any polytree that is not a tree. 
From Proposition 3 it follows that Theorems 1 and 4 introduce new polynomial and
np-easy subclasses of the UB problem class, respectively.
6.3 Structural Restrictions in Propositional Planning
Jonsson and Backstrom (1998b) present the 3S class of planning problems. This class is most
closely related to the problems examined in this paper, since it defines a special subclass of
problems with binary variables, unary operators and acyclic causal graphs. The 3S problem
class is defined by posing some additional, relatively severe, restrictions on the problems
operator set: Each variable v in a 3S problem instance is required to be either (i) static,
i.e., unchangeable; (ii) symmetrically reversible, i.e., for each operator A affecting v, there
exist an operator A0 affecting v with the same prevail conditions and the opposite effect;
or (iii) splitting. For the formal definition of the splitting property we refer to Jonsson
and Backstrom (1998b). Informally, if a binary variable v is splitting then the problem
instance can be split into three, well-defined subproblems that can be solved independently.
For this class of planning problems it was shown that plan existence can be determined in
polynomial time, while plan generation is provably intractable, since there are instances of
3S with exponentially long minimal solutions. In particular, the problem instance that we
used in the proof of Theorem 3 is in 3S.
The complexity analysis by Jnonsson and Backstrom (1998b) is somewhat unique in
the research on complexity of propositional planning, since, to the best of our knowledge,
this was the only attempt to exploit not only syntactical restrictions on the operator set,
but also some structural restrictions on interaction between the variables. Our analysis
can be seen as continuing this direction by looking on the structural restrictions only. We
believe that eliminating the marginal effect of the problem structure on the problems (potential) hardness will allow us to understand better the connection between the component
interactions topology, and the potential complexity of the problem.
6.4 Structural Restrictions in Multi-valued Formalisms
When the variables are no longer propositional, some additional properties of the problems
can be identified, and, possibly, exploited. In particular, additional internal structures of
the problem can be analysed.
Jonsson and Backstrom (1998a) analyze different properties of a multi-valued problem
structure, which is called the domain transition graph. Such a structure is defined for each
state variable of the problem, and it describes possible transitions between different values
of this variable. The domain transition graph of a state variable v is a directed labeled
graph Gv = (V, E), where V is associated with the vs set of possible values, D(v), and
(x, A, y)  E if and only if the operator A can be applied at some state in which v = x, and
its application results in a state in which v = y holds.
Jonsson and Backstrom identify sets of structural restrictions on domain transition
graphs which make planning instances tractable. Roughly, the properties are the following:
(1) The problem domain is interference-safe, i.e., each operator is either unary or irreplace338

fiStructure and Complexity in Planning with Unary Operators

able with respect to every variable it affects. An operator A is irreplaceable with respect
to a variable v if the removal of all edges from Gv that stem from A disconnects some
weakly connected component of Gv . (2) For every variable v, the graph Gv , restricted to
the set of values that appear in the prevail conditions of some operators, is acyclic. (3) Any
sequence of operators annotating a path from x to y in the domain transition graph of v, is
stronger than all shortest such sequences connecting x and y. Here, a sequence A1 , . . . , Ak
is stronger than A01 , . . . , A0l if there is a subsequence Ai1 , . . . , Ail of A1 , . . . , Ak such that for
every 1  j  l, the prevail conditions of A0j are a subset of the prevail conditions of Aij .
Jonsson and Backstrom present a map of the computational complexity of problems with
different restrictions, displaying the frontier between the tractable and intractable cases.
Each domain transition graph combines and structures the influence of many operators
on a particular variable. Therefore, they provide us a more global picture than the operator
set alone. Hence, in spite of the fact that domain transition graphs do not capture the relationship between different variables, they do allow us to express some structural properties
that address interactions between the variables (e.g., see property (2) above).
Observe that domain transition graphs are not very informative in the case of propositional planning, since they are only distinguish between the variables that can be changed
only in one direction and the variables that can be changed in both directions. Although
this property of domain transition graphs allows to distinguish between the polynomial
planning with only positive postconditions, and the pspace-complete planning with both
positive and negative postconditions (Bylander, 1994), it seems to be not very helpful in
further hierarchical refinement of the propositional planning complexity. On the other hand,
there is no a priori reason why the causal graphs will not be informative in the multi-valued
case. Exploiting the properties of causal graphs, together with the properties of domain
transition graphs, seems to be a natural direction to extend the work presented in this paper.
The recent work of Domshlak and Dinitz (2001) on multi-entity off-line coordination can be
seen as investigating connections between the structure of the causal graph, together with
the properties of the domain transition graphs, and the complexity of the corresponding
problems in case of multi-valued domains. To the best of our knowledge, this is the only
work that was done with respect to such a mixed structural analysis, and a lot of work
remains to be done. For instance, combining various properties of the domain transition
graphs studied by Jonsson and Backstrom (1998a), with the properties of the problems
causal graph is a direction for the further research.

7. Summary and Future Work
We have shown that the form of the causal graph for strips planning problems with unary
operators is an important factor in determining the computational complexity of plan generation. In particular, we have shown that a polynomial time algorithm exists for any
problem with a polytree causal graph and the node indegree bounded by a constant. More
generally, this result shows that planning with polytree causal graphs is at most (what is
often referred to in the Bayes nets literature as) locally exponential, i.e., it is exponential in the maximal number of parents of a node. Note that in hardware-control planning
problems the maximal node indegree is expected to be small, since prevail dependencies
between the variables reflect the direct interconnections between the corresponding hard339

fiBrafman & Domshlak

ware components. Likewise we have shown that for a problem with directed-path singly
connected causal graph the maximal plan length is a low order polynomial, but the problem
is np-complete. More generally, we have shown a relation between the number of paths between variables in the causal graph and the computational complexity of the corresponding
planning problem. Finally we have presented the impact of our results on the question of
complexity of planning problems with serializable subgoals, and connected our work with
previous results on planning complexity.
Our work leaves a number of open questions with respect to purely syntactical, and a
mixture of both structural and syntactical restrictions on the planning problems with unary
operators. In the former case, one of the most important directions is a further analysis of
causal graphs with constantly bounded node indegree. It turns out that complexity analysis for this class of problems will be very helpful in understanding various computational
properties of CP-nets (Boutilier et al., 1999). Although here we provided a partial answer
for this question, the general picture of the worst-case complexity for this class of problems
is not clear. For example, if the indegree of the causal graph is known to be bounded by
2, and this is the only structural property of the causal graph, it is even not clear whether
this problem subclass is in np.
In the latter case, various syntactical restrictions can be analysed together with the form
of the causal graph. For example, one may be interested in the computational properties
of the problems with acyclic causal graphs, and the restriction that every operator has at
most  prevail conditions, where  is bounded by a constant. This, as well as many other
related questions with respect to various special cases of planning with unary operators are
of interest for the future work.

Acknowledgments
A preliminary version of this paper appeared in the Sixth International Conference on Artificial Intelligence Planning and Scheduling, April, 2002. We would like to thank the three
anonymous reviewers for their extremely helpful comments. Ronen Brafman is supported
in part by the Paul Ivanier Center for Robotics Research and Production Management.

340

fiStructure and Complexity in Planning with Unary Operators

Appendix A. A Short Review of POP, Causal Links and Threats
We represent a plan as a tuple: hA, O, Li, where A is a set of unary operators, O is a set of
ordering constraints over A, and L is a set of causal links. For example, if A = {A1 , A2 , A3 }
then O might be the set {A1 < A3 , A2 < A3 }. These constraints specify a plan in which
A3 is necessarily the last operator, but do not commit to a particular order on A1 and A2 .
Naturally, the set of ordering constraints must be consistent, i.e., there must exist some

total order satisfying them. A causal link has the form Ap i Ac , where Ap and Ac are
operators and i is a possible value for some propositional variable vi . It denotes the fact
that Ap produces (i.e., has the postcondition) vi = i which is consumed by Ac (i.e., used to
satisfy a pre- or prevail-condition of Ac ). Causal links help us detect whether one operator
At interferes with the work done to enable the execution of some other operator Ac . In that
case, At is said to constitute a threat to one of A0c s causal links. Formally, suppose that


hA, O, Li is a plan, and Ap i Ac is a causal link in L. Let At be a different operator in A.


We say that At threatens Ap i Ac when the following two criteria are satisfied:
 O  {Ap < At < Ac } is consistent, and
 At has i as an effect.
When a partial order plan P contains threats, it is possible that the goal will not be
achieved by some (or all) of the total order plans consistent with P s ordering constraints.
To prevent this, the plan generator must check for threats and remove them by adding one
of two possible ordering constraints: At < Ap (demotion) or Ac < At (promotion).
A tutorial introduction to POP algorithms can be found in (Weld, 1994). POP is a
regressive framework for partial order planning that starts with the null plan and continuously updates it by inserting new actions and removing threats. This process continues until
the precondition and the prevail conditions of every operator in the plan are supported by
some causal link and no threats exist. The first argument to POP is a plan and the second
argument is an agenda of goals that need to be supported by causal links. Each item on the
agenda is represented by a pair hi , Ai where i is either pre- or prevail condition of a plan
action A. The last argument to POP is the whole collection of the operators defined by
the planning instance. The initial call to POP contains the null plan, a specially initialized
agenda, and the operator set  of the given problem.
In this paper we introduce a specialized, deterministic POP algorithm that starts the
planning process using a variant of the null plan which encodes the planning problem. In
particular, if the planning instance has v1 , . . . , vn as the goal then the corresponding null
plan has exactly 2n dummy unary operators, A = {A01 , . . . , A0n , A1 , . . . , An }, n ordering
constraints, O = {{A01 < A1 }, . . . , {A0n < An }}, and no causal links, L = {}. For every
vi  V, A0i is the corresponding start operator - it has neither pre- nor prevail conditions,
and its effect specifies the value of the variable vi in the initial state, which is denoted by
vi0 . Similarly, Ai is the end operator - it has no effect, no prevail conditions, but its
precondition is set to the value of vi in the goal state, which in turn is denoted by vi .8
8. Actually, the goal state may not specify the values of all the variables, thus the number of the end
operators can be less than n. However, for clarity of presentation, we leave this definition of the null
plan.

341

fiBrafman & Domshlak

Our description of the null plan is modified from that of Weld (1994) to better suit the
restriction to unary operators. Likewise, the initial call to our POP algorithm contains the
agenda {hv1 , A1 i, . . . , hvn , An i}.

342

fiStructure and Complexity in Planning with Unary Operators

Appendix B. Proofs and Auxiliary Results
Lemma 2 If forward-check was successful then pop-pcg will return a valid plan.
Proof:

The lemma will follow from the following claims:

1. For every agenda item, there exists an operator that has it as an effect.
2. There are no threats in the output of pop-pcg.
3. The ordering constraints in O are consistent.
4. The agenda will be empty after a polynomial number of steps.
(1+4) The first claim follows from the success of the forward-check procedure.
forward-check implies that for any ij  (vi ) there is an operator instance A(ij ) 
i  {A0i }. Therefore, if ij  (vi ) then the existence of an appropriate Aadd is promised.
Assume to the contrary that ij 6 (vi ) and, without loss of generality, assume that this
is the first iteration that it happens. If so, then for each variable u  succ(vi ), there is no
edge labeled by ij in the graph G0 (u), which is created by the forward-check. From this
follows that Aneed cannot have ij as a prevail condition, and thus Aneed has to affect the
variable vi itself. In this case either Aneed = A(ij+1 ) or Aneed = Ai .
Consider the former case: If Aneed = A(ij+1 ) then ij+1 was previously selected from the
agenda. By our assumption it means that ij+1  (vi ), and it contradicts our assumption
that ij 6 (vi ) since ij is a predecessor of ij+1 on (vi ).
Now consider the last option that Aneed = Ai . If Aadd = A(ij ) then the goal value of
the variable vi is consistent with ij , and A(ij1 )  A (see Step 3(b)ii). If A(ij1 )  A
then ij1 was previously selected from the agenda. By our assumption it means that
ij1  (vi ). However, it contradicts our assumption that ij 6 (vi ) since (vi ), by
definition, terminates with a node consistent with the goal value of vi .
In addition, since we have shown that the only operators added into A are those from
i  {A0i , Ai }, for 1  i  n, the agenda will be empty after O(n2 ) steps.


(2) Suppose that some operator At threatens Ap i Ac , i.e.,
 O  {Ap < At < Ac } is consistent, and
 At has i as an effect.
For a given variable vi , pop-pcg forces the operators affecting vi as follows (Step 4):
A0i  A(i1 ) < A(i2 ) < . . . < A(ix ),

x  FMaxReq(vi )

(4)

Thus Ac can only be an operator with i as a prevail condition. Note that Ap and At
affect the same variable vi . In (1) we already showed that i = ij  (vi ). In that
case At = A(il ), l > j. However, if ij is a prevail condition of Ac then the ordering
constraint {Ac < A(ij+1 )} was added to O at Step 6. If so then from Eq. 4, it follows that
343

fiBrafman & Domshlak

{A(il ) < A(ij+1 ), A(ij+1 ) < A(il )}, l > j, will be implied by O  {Ap < At < Ac }, and it
contradicts with the assumption that O  {Ap < At < Ac } is consistent.
(3) The ordering constraints are consistent if no two operators Ai and Aj are such that
O implies {{Ai < Aj }, {Aj < Ai }}. In what follows, Ai will be used to denote an arbitrary
operator affecting variable vi .
First note that each ordering constraint added in Step 4 or Step 6 is either between
operators affecting the same variable or between operators affecting a variable and its child
(with respect to the causal graph). In particular, if Ai < Aj was added in Step 4 then either
vi = vj or vi  pred(vj ), whereas if Ai < Aj was added in Step 6 then vj  pred(vi ).
Assume, to the contrary that O implies Ai < Aj and Aj < Ai . From the argument
above, we know that there is a, possibly empty, path between vi and vj in the undirected
graph induced by the causal graph. By our structural assumption, we know that such an
undirected path between vi and vj is unique, and thus the situation is as follows: We have
two chains of operators
 : Ai = A1i0 < . . . < Axi00 < A1i1 < . . . < Axi11 < . . . . . . < A1im < . . . < Aximm = Aj
 : Ai = A1i0 > . . . > Ayi00 > A1i1 > . . . > Ayi11 > . . . . . . > A1im > . . . > Ayimm = Aj

such that, for 0  k  m, both xk  1 and yk  1. The corresponding unique undirected
path between vi and vj is:
vi = vi0  vi1  . . .  vim1  vim = vj
Without loss of generality, the internal elements of  and  are disjoint. Otherwise, if there
is an operator B that belongs to the internal parts of both  and  then we can reduce
these chains and deduce Ai < B and Ai > B.
The proof of consistency is as follows:
(a) We prove that if such  and  exist then at least one of them should have at least
one internal element.
(b) We show some useful property of  and , that is exploited in (c).
(c) We show that for 0  k  m, Axikk and Ayikk are different except when x0 = y0 = 1.
Note that (a) together with (c) contradicts our assumption that Aximm = Ayimm .
(a) Assume, to the contrary, that both  and  do not contain any internal elements.
If so, then the algorithm actually adds to O ordering constraints Ai < Aj and Aj < Ai .
If vi and vj are the same variable then Ai < Aj can only stem from Step 4 and only
because Ai has the precondition of Aj as its effect. However, by definition of forwardcheck, Aj can not have the same role w.r.t. Ai and thus it is impossible that Aj < Ai was
added to O. Alternatively, if vi is a parent of vj then Ai < Aj can stem only from Step 4
because Ai has the prevail condition of Aj as its effect. Suppose that Ai = A(bji ) and thus
bji  prv(Aj ). In turn, Aj < Ai can be added only in Step 6 because Aj has the precondition
of Ai as the prevail condition. But if bji  prv(Aj ) then Ai = A(wij ), and this contradicts
344

fiStructure and Complexity in Planning with Unary Operators

our assumption that Ai = A(bji ). Alternatively, we can assume that Ai = A(wij ) but this
situation is completely symmetric, and thus the result will be the same. Hence we proved
that either  or  have to contain at least one internal element. In particular it means
that the next to last elements of  and  are different and this fact is exploited later in the
proof.
(b) Consider subchains of  that consist of operators affecting only one particular variable. For each such a subchain, i.e. for 0  k  m, for 1  j  xk  1, the ordering
j
j+1
constraint Ajik < Aj+1
ik can only stem from Step 4 because Aik has the precondition of Aik
as its effect. Thus, post(Ajik ) = pre(Aj+1
ik ). Similarly, for the subchains of , for 0  k  m
j
and for 2  j  yk , post(Aik ) = pre(Aj1
ik ). In what follows we denote this property of 
and  by local monotonicity.
(c) First suppose that either x0 > 1 or y0 > 1, or both. Consider the following sequence:
 : Ayi00 < Ayi00 1 < . . . < A1i0 = A1i0 < ... < Axi00
From the local monotonicity, the construction of forward-check, and the fact that ||  2
0
it follows that post(Ayi0 ) appears before post(Axi00 ) on the maximal sequence vi0 . Continuing
1

with the next variable vi1 we claim that post(Ayi1 ) has to appear before post(Axi11 ) on vi1 .
(i) If vi0 is a parent of vi1 then Axi00 < A1i1 can only stem from Step 4 because Axi00 has
the prevail condition of A1i1 as its effect. In turn, Ayi00 > A1i1 can only stem from Step 6
because the prevail condition of A1i1 is the precondition of Ayi00 . From the relation between
Axi00 and Ayi00 , and the construction of G0e (vi1 ) in forward-check, it follows that post(A1i1 )
appears before post(A1i1 ) on (vi1 ). Subsequently, from the local monotonicity it follows
that post(Ayi11 ) appears before post(Axi11 ) on (vi1 ).
(ii) Similarly, if vi1 is a parent of vi0 then Ayi00 > A1i1 can only stem from Step 4 because
A1i1 has the prevail condition of Ayi00 as its effect, and Axi00 < A1i1 can only stem from Step 6
because the prevail condition of Axi00 is the precondition of A1i1 . From the relation between
Axi00 and Ayi00 , and the construction of G0e (vi1 ) in forward-check, it follows that post(A1i1 )
appears before post(A1i1 ) on (vi1 ), and again, from the local monotonicity it follows that
post(Ayi11 ) appears before post(Axi11 ) on (vi1 ).
Alternatively, if x0 = y0 = 1 then Axi00 = Ayi00 = Ai . From (a) immediately follows
that A1i1 6= A1i1 , and an analysis similar to the above shows that post(Ayi11 ) appears before
post(Axi11 ) on (vi1 ).
Having established that post(Ayi11 ) appears before post(Axi11 ) on (vi1 ), it is apparent
that an inductive argument will allow us to show that for all k > 0 we have that post(Ayikk )
appears before post(Axikk ) on (vik ). Note that in particular it means that the operators
Axikk and Ayikk are different, and this contradicts our assumption that Aximm = Ayimm . 

345

fiBrafman & Domshlak

Theorem 2
Plan existence for strips planning problems with unary operators and
directed-path singly connected causal graph is np-complete.
Proof: First we show the membership in np. Let MinPlanSize() denote the size of the
minimal plan for a problem instance . Using the MaxReq property of the state variables,
the following upper bound for MinPlanSize() is straightforward from the Lemma 1:
X
MinPlanSize() 
MaxReq(v)  n2
(5)
vV

Thus, if we guess a minimal solution for a given solvable problem, we can verify it in low
polynomial time.
The proof of the hardness is by polynomial reduction from 3-sat to the corresponding
propositional plan generation problem with a directed-path singly connected causal graph.
3-sat is the problem of finding a satisfying assignment for a propositional formula in conjunctive normal form in which each conjunct (clause) has at most three literals.
Let F = C1 . . .Cn be a propositional formula belonging to 3-SAT, and let X1 , . . . , Xm
be the variables used in F. An equivalent propositional planning problem with a directedpath singly connected causal graph can be constructed as follows: The variable set is V =
{X1 , X1 , . . . , Xm , Xm }  {C1 , . . . , Cn }. The variables Xi and Xi have no predecessors in
the causal graph, thus pred(Xi ) = pred(Xi ) = {}. In turn, for 1  i  n, pred(Ci ) =
{Xi1 , Xi1 , Xi2 , Xi2 , Xi3 , Xi3 }, where Xi1 , Xi2 , and Xi3 are the variables that participate in
the ith clause of F. Finally, Init and Goal consist of false and true assignments to all
variables in V, respectively.
Let every operator A   be presented as a three-tuple h{pre}, {post}, {prv}i of pre, post,
and prevail conditions respectively. Then, the corresponding operator set  is specified as
follows:
Xi

={

h{f }, {t}, {}i }

Xi

={

h{f }, {t}, {}i }

 Ci

={

h{f }, {t}, {1i }i, h{f }, {t}, {2i }i, h{f }, {t}, {3i }i

	

where ji (1  j  3) corresponds to the truth assignment on the variable Xij that satisfies
the ith clause of F. Let Ci = (X1  X2  X8 ). Then 1i = {X1 = t, X1 = f }, 2i = {X2 =
f, X2 = t}, and 3i = {X8 = t, X8 = f }.
To illustrate the proposed reduction consider the following example. Formula F consist
of 3 clauses: (x1  x2  x3 )  (x1  x2  x4 )  (x2  x3  x4 ). The causal graph of the
corresponding planning problem is as follows:
@ABC
GFED
@ABC
@ABC
GFED
GFED
@ABC
@ABC
@ABC
GFED
@ABC
GFED
x2 F GFED
x3
x1 F GFED
x4
x
x1
x3
::
- F  2 :
-- FF
;
{
H

::
-- FFF
- F  :
{; {; H x8 x8 x8
:

;
{
:
F
F
H

:
-FF
{;
-
A
x8 x8
:
F
FF :::  A
-{; {; x8 x8 H H
F
FF  : 
:
A

;
{
8
x

F
-H
F :
A
F : {; {; {; x8 x8 x8
H A A
 FFFF ::: 
-:
F
8
x
H

;
{
x8
  FFF ::
-H A A

{; x8 {; x8 F x8 F: :
FF:: - 
H

;
{
--  
8
x
F : H A A
FF::- 
{;
F#    { x {; x8 x8
F#     
   { x
@ABC
GFED
@ABC
GFED
@ABC
GFED
C1
C2
C3
346

@ABC
GFED
x4
x8 8x A
A
A

fiStructure and Complexity in Planning with Unary Operators

This is a propositional planning problem with single-effect operators and an underlying
directed-path singly connected causal graph. Clearly, Goal is reachable ( is solvable) if and
only if a satisfying assignment for F can be found. Thus, plan existence for the propositional
planning problems with directed-path singly connected causal graphs is np-complete. 

Lemma 4 Given k ordered sequences 1 ,    , k of n elements each, the number T [k] of
different merges of 1 ,    , k , preserving the orderings induced by 1 ,    , k on their elements, is given by:


k1
n 
YX
n  1 ni + 1
T [k] =
(6)
j1
j
i=1 j=1

Proof: Considering the merge operation of such k sequences as iterative merge of i ,
2  i  k, with the already merged sequences 1 , . . . , i1 , it is easy to see that T (k) can
be expressed as:
(
T [k  1]  S [n(k  1), n] , k > 1
T [k] =
(7)
1,
k=1
where S[x, y] stands for the number of different, order preserving merges of two ordered
sequences of sizes x and y (without loss of generality, we assume that x  y).
We consider the process of merging two ordered sequences  and  0 , ||  | 0 |, as:
(i) partition of  0 into j sub-sequences,
(ii) partition of  into l sub-sequences, where j  1  l  j + 1, and
(iii) interleaving and order preserving concatenation of the sub-sequences of  and  0 .
First, observe that  0 can be partitioned into 1  j  | 0 | sub-sequences. Second, for
0 |1
any j, the numbers of different partitions corresponding to steps (i) and (ii) are |j1
and

||+1
, respectively. Finally, given a pair of such partitions of  and  0 , there exist exactly
j
one possible interleaving and order preserving concatenation as in step (iii). Therefore, we
have:


y 
X
y1 x+1
S(x, y) =
(8)
j1
j
j=1

and combining Eq. 7 with Eq. 8, we arrive to Eq. 6. 

347

fiBrafman & Domshlak

References
Backstrom, C., & Klein, I. (1991a). Parallel non-binary planning in polynomial time. In
Proceedings of Twelfth International Joint Conference on Artificial Intelligence, pp.
268273, Sydney, Australia. Morgan Kaufmann Publishers.
Backstrom, C., & Klein, I. (1991b). Planning in polynomial time: The SAS-PUBS class.
Computational Intelligence, 7 (3), 181197.
Backstrom, C., & Nebel, B. (1995). Complexity results for SAS+ planning. Computational
Intelligence, 11 (4), 625655.
Boutilier, C., Brafman, R., Hoos, H., & Poole, D. (1999). Reasoning with conditional ceteris
paribus preference statements. In Proceedings of the Fifteenth Annual Conference on
Uncertainty in Artificial Intelligence, pp. 7180. Morgan Kaufmann Publishers.
Bylander, T. (1992). Complexity results for serial decomposability. In Proceedings of the
Tenth National Conference on Artificial Intelligence, pp. 729734, San Jose, CL. AAAI
Press.
Bylander, T. (1994). The computational complexity of propositional STRIPS planning.
Artificial Intelligence, 69 (1-2), 165204.
Chalasani, P., Etzioni, O., & Mount, J. (1991). Integrating efficient model-learning and
problem-solving algorithms in permutation environments. In Proceedings of the Second
International Conference on Principles of Knowledge Representation and Reasoning,
pp. 8998, Cambridge, MA. Morgan Kaufmann Publishers.
Chapman, D. (1987). Planning for conjunctive goals. Artificial Intelligence, 32 (3), 333377.
Domshlak, C., & Dinitz, Y. (2001). Multi-agent off-line coordination: Structure and complexity. In Proceedings of Sixth European Conference on Planning, Toledo, Spain.
Domshlak, C., & Shimony, S. E. (2003). Efficient probabilistic reasoning in Bayes nets
with mutual exclusion and context specific independence. In Proceedings of the Sixteenth International FLAIRS Conference, Special Track on Uncertain Reasoning, St.
Augustine, FL. AAAI Press. to appear.
Erol, K., Nau, D. S., & Subrahmanian, V. S. (1995). Complexity, decidability and undecidability results for domain-independent planning. Artificial Intelligence, Special Issue
on Planning, 76 (12), 7588.
Etzioni, O. (1993). Acquiring search-control knowledge via static analysis. Artificial Intelligence, 62 (2), 255301.
Jonsson, P., & Backstrom, C. (1998a). State-variable planning under structural restrictions:
Algorithms and complexity. Artificial Intelligence, 100 (12), 125176.
Jonsson, P., & Backstrom, C. (1998b). Tractable plan existence does not imply tractable
plan generation. Annals of Mathematics and Artificial Intelligence, 22 (3-4), 281296.
Kambhampati, S. (1995). Admissible pruning strategies based on plan minimality for planspace planning. In Proceedings of the Fourteenth International Joint Conference on
Artificial Intelligence, pp. 16271635, Montreal, Canada.
348

fiStructure and Complexity in Planning with Unary Operators

Knoblock, C. (1994). Automatically generating abstractions for planning. Artificial Intelligence, 68 (2), 243302.
Koehler, J., & Hoffmann, J. (2000). On reasonable and forced goal orderings and their use
in an agenda-driven planning algorithm. Journal of Artificial Intelligence Research,
12, 338386.
Korf, R. (1985). Macro-operators: A weak method for learning. Artificial Intelligence, 26 (1),
3577.
Korf, R. (1987). Planning as search: A quantitative approach. Artificial Intelligence, 33 (1),
6588.
Pell, B., Bernard, D., Chien, S., Gat, E., Muscettola, N., Nayak, P., Wagner, M., & Williams,
B. (1997). An autonomous spacecraft agent prototype. In Proceedings of the First
International Conference on Autonomous Agents, pp. 253261, Marina del Rey, CL.
ACM Press.
Penberthy, J. S., & Weld, D. S. (1992). UCPOP: A sound, complete, partial order planner
for ADL. In Proceedings of Third International Conference on Principles of Knowledge Representation and Reasoning, pp. 103114, Cambridge, MA. Morgan Kaufmann
Publishers.
Shimony, S. E., & Domshlak, C. (2002). Complexity of probabilistic reasoning in (directedpath) singly connected (not polytree!) Bayes networks. submitted for publication.
Smith, D., & Peot, M. (1993). Postponing threats in partial-order planning. In Proceedings of
the Eleventh National Conference on Artificial Intelligence, pp. 500506, Washington,
D.C. AAAI Press.
Weld, D. S. (1994). An introduction to least commitment planning. AI Magazine, 15 (4),
2761.
Weld, D. S. (1999). Recent advances in AI planning. AI Magazine, 20 (2), 93123.
Wiest, J. D., & Levy, F. K. (1969). A Management Guide to PERT/CPM. Prentice Hall.
Williams, B., & Nayak, P. (1996). A model-based approach to reactive self-configuring systems. In Proceedings of the Thirteenth National Conference on Artificial Intelligence,
pp. 971977, Portland, OR. AAAI Press.
Williams, B., & Nayak, P. (1997). A reactive planner for a model-based executive. In
Proceedings of the Fifteenth International Joint Conference on Artificial Intelligence,
pp. 11781185, Nagoya, Japan.

349

fi