Journal of Artificial Intelligence Research 29 (2007) 1947

Submitted 03/06; published 05/07

Computationally Feasible VCG Mechanisms
Noam Nisan

noam@cs.huji.ac.il

School of Computer Science and Engineering,
The Hebrew University of Jerusalem, Israel

Amir Ronen

amirr@ie.technion.ac.il

Faculty of Industrial Engineering & Management,
Technion - Israel Institute of Technology,
Haifa 32000, Israel

Abstract
A major achievement of mechanism design theory is a general method for the construction of truthful mechanisms called VCG (Vickrey, Clarke, Groves). When applying
this method to complex problems such as combinatorial auctions, a diculty arises: VCG
mechanisms are required to compute optimal outcomes and are, therefore, computationally infeasible. However, if the optimal outcome is replaced by the results of a sub-optimal
algorithm, the resulting mechanism (termed VCG-based) is no longer necessarily truthful.
The rst part of this paper studies this phenomenon in depth and shows that it is near
universal. Specically, we prove that essentially all reasonable approximations or heuristics for combinatorial auctions as well as a wide class of cost minimization problems yield
non-truthful VCG-based mechanisms. We generalize these results for ane maximizers.
The second part of this paper proposes a general method for circumventing the above
problem. We introduce a modication of VCG-based mechanisms in which the agents are
given a chance to improve the output of the underlying algorithm. When the agents behave
truthfully, the welfare obtained by the mechanism is at least as good as the one obtained
by the algorithms output. We provide a strong rationale for truth-telling behavior. Our
method satises individual rationality as well.

1. Introduction
Mechanism design is a sub-eld of game theory and microeconomics that studies the design of protocols for non-cooperative environments. In such environments the participating
agents follow their own goals and do not necessarily act as instructed by the mechanism.
This theory has traditionally been applied to economic applications such as auctions of various kinds. An introduction to mechanism design can be found in several books (Osborne
& Rubinstein, 1994; Mas-Collel, Whinston, & Green, 1995). In recent years, problems
on the border of mechanism design and computer science have attracted the attention of
many researchers, both within and outside the AI community. In particular, mechanism
design models were applied to multi-agent systems (Rosenschein & Zlotkin, 1994; Wellman,
Wurman, Walsh, & MacKie-Mason, 2001; Shoham & Tanaka, 1997; Shoham & Tennenholtz, 2001), decentralized resource and task allocations (Nisan & Ronen, 2001; Wellman
et al., 2001; Elkind, Sahai, & Steiglitz, 2004; Porter, Ronen, Shoham, & Tennenholtz, 2002),
economic and electronic commerce applications (Parkes, 1999; Cramton, 1997), and communication networks (Feigenbaum, Papadimitriou, & Shenker, 2000; Anderson, Kelly, &
Steinberg, 2002).
c
2007
AI Access Foundation. All rights reserved.

fiNisan & Ronen

The canonical mechanism design problem can be described as follows: A set of rational
agents needs to collaboratively choose an outcome o from a nite set O of possibilities.
Each agent i has a privately known valuation function v i : O  R quantifying the agents
benet from each possible outcome. The agents are supposed to report their valuation
functions v i () to some centralized mechanism. The goal of the mechanism is to choose an

outcome o that maximizes the total welfare i v i (o). The main diculty is that agents may
choose to misreport their valuations in an attempt to aect the outcome to their liking.
Such manipulations are likely to severely damage the resulting welfare (simulations that
demonstrate this welfare loss can be found in Carroll & Grosu, 2005). The tool that the
mechanism uses to motivate the agents to reveal the truth is monetary payments. These
payments need to be designed in a way that ensures that rational agents always reveal their
true valuations. Mechanisms with this property are called incentive compatible or truthful
(in dominant strategies). To date, only one general method, called VCG (Vickrey, 1961;
Clarke, 1971; Groves, 1973) (or slightly more generally, ane maximization), is known for
designing such a payment structure1 . In some settings, it is known that this method is the
sole available one (Roberts, 1979; Lavi, Nisan, & Mualem, 2003).
Many novel applications of mechanism design are complex and require implementation
on computer systems. Cases in point include combinatorial auctions where multiple items
are concurrently sold in an auction (Cramton, Shoham, & Steinberg, 2006), decentralized
task and resource allocation problems (Nisan & Ronen, 2001; Wellman et al., 2001), and
networking applications (Feigenbaum et al., 2000; Anderson et al., 2002). For many of
these applications, the range of possible outcomes is huge and even nding an outcome that
maximizes the total welfare is known to be NP-complete. Since for such cases computing
the optimal outcome is intractable, the VCG method cannot be applied.
A natural general approach for the development of mechanisms for such cases would be
to use a sub-optimal polynomial time algorithm for computing the outcome, and calculate
the payments by applying the VCG payment rule to the underlying algorithm. We term
such mechanisms VCG-based.
The starting point of this paper is the observation, noted already by some researchers
(Lehmann, OCallaghan, & Shoham, 2002; Nisan & Ronen, 2001), that VCG-based mechanisms are not necessarily truthful. Thus, rational agents may lie, taking advantage of quirks
in the outcome determination algorithm.
1.1 VCG-based Mechanisms are Generally not Truthful
The rst part of this paper examines this last phenomenon in depth and shows that it is
near universal: essentially all reasonable VCG-based mechanisms are not truthful.
We rst turn our attention to combinatorial auctions and characterize the class of truthful VCG-based mechanisms for this problem2 . We say that an allocation algorithm for
1. Recently, a few truthful mechanisms, which are not ane maximizers, were obtained for combinatorial
auctions (Bartal, Gonen, & Nisan, 2003).
2. The importance of combinatorial auctions is twofold. First, they have direct applications such as FCC
auctions. Second, they abstract many problems of resource allocation among self-interested agents. A
comprehensive survey of research on combinatorial auctions can be found in a recent book (Cramton
et al., 2006).

20

fiComputationally Feasible VCG Mechanisms

combinatorial auctions is reasonable if, whenever an item is desired by a single agent only,
this agent receives the item. The above characterization leads to the following corollary:
Theorem: Any truthful VCG-based mechanism for combinatorial auctions is not reasonable (unless it uses the exponential optimal allocation algorithm).
In particular, unless P = N P , every polynomial time, truthful VCG-based mechanism is
not reasonable.
Loosely speaking, we show that essentially the only degree of freedom available to truthful VCG-based mechanisms is the choice of range over which to optimize. Within this range
perfect optimization is needed. This theorem seems intuitive as VCG payments identify
each agents utility with that of society, and thus if the social welfare is not optimized by
the mechanism, then agents are motivated to to lie in order to do so. Yet, such an argument
only shows that the outcome must be locally optimal  with locality dened as a deviation
by a single agent. The heart of our argument is a delicate hybrid argument showing that
in a general context this local optimization essentially implies global optimization.
Next we study a family of problems termed cost minimization allocation problems. This
family contains many natural decentralized task allocation problems such as mechanism
design versions of the shortest path problem (Elkind et al., 2004; Nisan & Ronen, 2001;
Rosenschein & Zlotkin, 1994). We call a mechanism for such a problem degenerate if there
exist inputs that cause it to produce results that are arbitrarily far from the optimal.
Theorem: For any cost minimization allocation problem, any sub-optimal truthful VCGbased mechanism is degenerate.
A word is in order here about the signicance of these results. VCG-based mechanisms are
not just some special case of truthful mechanisms  they are essentially the only general
method known for truthful mechanisms in non-single dimensional settings. Moreover, in
certain settings they are known to indeed be the only truthful mechanisms (Roberts, 1979;
Lavi et al., 2003). More precisely, weighted versions of VCG-based mechanisms  called
ane maximizers  are truthful, but our results extend (as we show) to these cases as well.
Consequently, our results imply that designing truthful mechanisms for computationally
intractable problems requires either restricting the range of the outcomes (getting unreasonable or degenerate mechanisms) or developing entirely new techniques for truthful
mechanisms  which may not even exist. A similar implication results if the intractability
stems not from computational considerations, but rather from communication considerations (Cramton et al., 2006, Chapter 11).
1.2 The Second Chance Mechanism
The second part of this paper proposes a general method for circumventing the diculty
of constructing truthful mechanisms. While VCG-based mechanisms lose their incentive
compatibility, they still pose a very special property. Loosely speaking, in such a mechanism,
the only reason for an agent to misreport its valuation is to help the algorithm compute
a better outcome. We would like to exploit this property to obtain mechanisms that are
almost truthful.
21

fiNisan & Ronen

Given any algorithm for the corresponding optimization problem we dene the second chance mechanism based on it. This mechanism is a modication of the VCG-based
mechanism where, in addition to their valuations, the agents are allowed to submit appeal
functions. An appeal function allows the agent to give the algorithm an input (a vector of
declared valuations), which is dierent from the original input, but without misreporting
its type. When the agents behave truthfully, the welfare obtained by the mechanism is at
least as good as the one obtained by the algorithms output.
We then formulate the rationale for truthful behavior in our mechanism. Informally, our
argument is as follows: Under reasonable assumptions, in any situation in which the agent
believes it is benecial for it to lie to the mechanism, it is better for the agent to report its
actual type to the mechanism and ask its appeal to check whether this lie really helps it.
Thus, the agent can construct a truthful strategy premised on the fact that it is not aware
of any situation in which another strategy would be better. We believe that this is a strong
argument for truth-telling.
We construct a version of our mechanism that satises individual rationality as well.
A generalization of our results to ane maximization and to compensation and bonus
mechanisms (Nisan & Ronen, 2001) is straightforward.
Several alternative approaches aimed at handling the diculty of developing truthful
mechanisms were suggested in the past. One approach is the construction of mechanisms
that are computationally hard to manipulate (e.g., Bartholdi et al., 1992). To the best of
our knowledge such manipulations are only hard in the worst case (e.g., it may be NPhard to always compute such a manipulation). Nevertheless, such hardness does not rule
out the possibility that manipulations may be easy to compute in typical cases. Another
possible approach is to consider other equilibria of VCG (Holzman, Kr-Dahav, Monderer, &
Tennenholtz, 2004; Holzman & Monderer, 2004). However, there is no apparent way for the
agents to coordinate such equilibria. Several recent works construct ascending mechanisms
for combinatorial auctions (e.g. Parkes, 1999). Such mechanisms rely on assumptions about
the agents which are very dierent from ours (e.g., myopic behavior). It may be interesting
to compare the virtues of such mechanisms to those of ours.
A few multi-round mechanisms for combinatorial auctions that let the agents improve
the provisional allocation were proposed and tested in the past (Banks, Ledyard, & Porter,
1989). Our argument for truthfulness in second chance mechanisms may provide a partial
explanation for the relative success reported in these experiments.

2. Preliminaries
In this section we formally present our model. We attempt as much as possible to use the
standard notions of both mechanism design and computational complexity theories.
2.1 Mechanism Design Problems
This section formulates the class of mechanism design problems that we study.
Denition 1 (utilitarian mechanism design problem) A (utilitarian) mechanism design problem is described by:
1. A nite set O of allowed outputs.
22

fiComputationally Feasible VCG Mechanisms

2. Each agent i = (1, . . . , n) has a real function v i (o  O) called its valuation or type.
This is a quantication of its benet from each possible output o in terms of some
common currency. v i (.) is privately known to agent i.
3. If the mechanisms output is o and in addition the mechanism hands the agent pi units
of currency, then its utility ui equals3 v i (o) + pi . This utility is what the agent aims
to optimize.
4. The goal of the mechanism is to select an output o  O that maximizes the total

welfare g(v, o) = i v i (o).
An example of such a problem can be found in Section 2.4.
Note that the goal in these problems is to maximize the total welfare but not necessarily
the revenue. This goal, also known as economic eciency, is justied in many settings and
is extensively studied in economics.
In a direct revelation mechanism, the participants are simply asked to reveal their types
to the mechanism. Based on these declarations the mechanism computes the output o and
the payment pi for each of the agents.
Denition 2 (mechanism) A (direct revelation) mechanism is a pair m = (k, p) such
that:
 The output function k accepts as input a vector w = (w1 , . . . , wn ) of declared valuation
functions4 and returns an output k(w)  O.
 The payment function p(w) = (p1 (w), . . . , pn (w)) returns a real vector quantifying the
payment handed by the mechanism to each of the agents (e.g. if pi = 2, the mechanism
pays two units of currency to agent i).
The agents try to maximize their own utility and thus may lie to the mechanism.
As these lies might severely reduce the total welfare, the mechanism should be carefully
designed such that it will be for the benet of the agents to report their types truthfully.
Notation: We denote the tuple (a1 , ...ai1 , ai+1 , ..., an ) by ai . We let (ai , ai ) denote the
tuple (a1 , . . . , an ).
Denition 3 (truthful mechanism) A mechanism is called truthful if truth-telling is a
dominant strategy, i.e., for every agent i of type v i and for every type declaration wi for
the other agents, the agents utility is maximized when it declares its real valuation function
vi.
As an example consider the famous Vickrey auction (Vickrey, 1961): A seller wishes to
sell one item in an auction. There are n buyers, each privately knowing its valuation v i for
this item. (The value for not winning is assumed to be zero.) In a Vickrey auction each
of the buyers is simply asked for its valuation; the item is allocated to the buyer with the
3. This assumption is called quasi-linearity and is very common in mechanism design.
4. We do not consider the issue of how to represent the valuations.

23

fiNisan & Ronen

highest bid for the price of the second highest. The reader may verify that this mechanism
is truthful. Another example of a truthful mechanism can be found in Section 2.4.
In general, the communication protocol of a mechanism can be complicated. A simple
observation known as the revelation principle for dominant strategies (e.g., Mas-Collel et al.,
1995, pp. 871) states that for every mechanism where the agents have dominant strategies,
there exists an equivalent truthful mechanism. Thus, w.l.o.g. it is possible to focus on
truthful mechanisms.
2.2 VCG-based Mechanisms
This subsection presents the celebrated VCG mechanisms. Intuitively, these mechanisms
solve utilitarian problems by identifying the utility of truthful agents with the declared
total welfare. We then generalize these mechanisms.
Denition 4 (VCG mechanism, (via Groves, 1973)) A mechanism m = (k, p) belongs
to the VCG family if:
 k(w) maximizes the total welfare according to w. That is, for all w, k(w)  arg maxo g(w, o).
 The payment is calculated according to the VCG formula: pi (w) =
hi (wi ) (hi (.) is an arbitrary function of wi ).



j=i w

j (k(w))

+

The reader may verify that the Vickrey auction is a VCG mechanism. It is well known
that VCG mechanisms are truthful (Groves, 1973).
Unfortunately, for many applications, the task of nding an output k(w) that maximizes the total welfare is computationally infeasible (e.g., NP-hard). In this paper we
consider VCG mechanisms where the optimal algorithm is replaced by a sub-optimal but
computationally feasible one.
Denition 5 (VCG-based mechanism) Let k(w) be an algorithm that maps type declarations into allowable outputs. We call m = (k(w), p(w)) a VCG mechanism based on

k(.) if p(.) is calculated according to the VCG formula: pi (w) = j=i wj (k(w)) + hi (wi )
(where hi (.) is an arbitrary function of wi ).
Obviously, a VCG-based mechanism that is based on an optimal algorithm is a VCG mechanism. Note that the payment function of a VCG-based mechanism is not identical to the
VCG payment because the algorithm k(.) is plugged into the payment formula. We will now
characterize the utility of an agent in VCG-based mechanisms. This utility is equivalent to
the total welfare according to the declared types of the other agents and the actual type of
the agent under consideration.
Lemma 2.1 (VCG-based utility) Consider a VCG-based mechanism dened by the allocation algorithm k(.), and the functions (h1 (.), . . . , hn (.)). Suppose that the actual valuation
of agent i is v i , and the declarations are w = (w1 (.), . . . , wn (.)). Then the utility of agent i
equals g((v i , wi ), k(w)) + hi (wi ).
24

fiComputationally Feasible VCG Mechanisms

Proof: The proof is immediate from the denitions. The agents utility equals v i (k(w)) +

pi (w) = v i (k(w)) + j=i v j (k(w)) + hi (wi ) = g((v i , wi ), k(w)) + hi (wi ).
In other words, a VCG-based mechanism identies the utility of truthful agents with the
total welfare. In particular, when k(.) is optimal, g((v i , wi ), k(w)) is maximized when the
agent is truthful. This implies that VCG mechanisms are truthful but this truthfulness is
not necessarily preserved by VCG-based mechanisms.
2.2.1 Example: Non Optimal Vickrey Auction
This section demonstrates the problems that might occur when the optimal algorithm in a
VCG mechanism is replaced by a sub-optimal one. Consider the sale of a single item. As
we already commented, a Vickrey auction is a VCG mechanism. Its algorithm allocates the

item to the agent with the highest declared value. The function hi (wi ) =  j=i wj (o)
equals the negation of the second highest value in case i is winning.
Consider the same mechanism where the optimal algorithm is replaced by an algorithm
that only chooses the second highest agent. The mechanism will now give the object to the
agent with the second highest declaration for the price of the third highest agent.
Suppose that there are three agents. Alice who has a value of $2 million, Bob with a
value of $1.7 million, and Carol who has a value of $1 million. When the agents are truthful,
Bob wins and pays $1 million. In this case it is for Alices benet to reduce her declaration
below Bobs. Similarly, if Alice wins, Bob would like to lower his declaration further, and
so on. Note that there are natural situations where Carol will win as well.
It is not dicult to see that there are no dominant strategies in this game. The outcome
of the mechanism is highly unpredictable, depending heavily on the agents beliefs about
the others, their risk attitude, and their level of sophistication. Such a mechanism can
yield inecient outcomes. The eciency loss may get much worse when the underlying
optimization problem has a complex combinatorial structure (simulations that demonstrate
this in the context of scheduling were done by Carroll & Grosu, 2005).
2.2.2 Affine-based mechanisms
It is possible to slightly generalize the class of VCG mechanisms and obtain mechanisms
called ane maximizers. Such mechanisms maximize ane transformations of the valuations. When the domain of valuations is unrestricted, ane maximizers are the sole
truthful mechanisms (Roberts, 1979; Lavi et al., 2003). Similarly to VCG, we generalize
these mechanisms to incorporate sub-optimal algorithms.
Notation: Let a = (a0 , . . . , an ) be an n + 1-tuple such that a0 (.) is a valuation function,
and a1 , . . . , an are strictly positive. We dene the weighted welfare ga (w, o) of an output o

as a0 (o) + i>0 ai  wi (o) where w is a vector of types and o an output.
Denition 6 (ane-based mechanism) Let k(w) be an algorithm that maps type declarations into allowable outputs, a = (a0 , . . . , an ) be an n + 1-tuple such that a0 (.) is a
valuation function, and a1 , . . . , an are strictly positive. We call m = (k(w), p(w)) an ane

mechanism based on k if p is calculated according to the formula: pi (w) = a1i ( j=i,0 aj 
wj (k(w)) + hi (wi )) (where hi () is an arbitrary function of wi ).
25

fiNisan & Ronen

The function a0 (.) can be interpreted as the preferences of the mechanism over the set of
the alternatives and a1 , . . . , an as weights over the agents. As in VCG mechanisms, the
agents utility have a convenient characterization.
Lemma 2.2 (ane-based utility) Consider an ane-based mechanism dened by the
allocation algorithm k(.), a tuple a and the functions h1 (.), . . . , hn (.). Suppose that the
actual valuation of agent i is v i , and the declarations are w = (w1 (.), . . . , wn (.)). Then the
utility of agent i equals a1i (ga ((v i , wi ), k(w)) + hi (wi )).
Proof: The proof is immediate from the denitions. The agents utility equals v i (k(w) +
pi (w)) = a1i (ai v i (k(w)) + pi (w) = a1i (ga ((v i , wi ), k(w)) + hi (wi )).
In other words, an ane-based mechanism identies the agents utility with the ane
transformation of the valuations it aims to optimize. In particular, when k(.) maximizes
ga (w, .), the mechanism is truthful.
2.3 Computational Considerations in Mechanism Design
This section adopts standard notions of computational complexity to revelation mechanisms.
Denition 7 (polynomial mechanism) A mechanism (k, p) is called polynomial time
computable if both k(w) and p(w) run in polynomial time (in the size of w).
Note that a VCG-based mechanism is polynomial i its output algorithm and the functions hi (.) are polynomial. We sometimes call polynomial algorithms and mechanisms
computationally feasible.
Denition 8 (NP-complete problem) A mechanism design problem is called NP-Complete
if the problem of nding an output that maximizes the total welfare is NP-Complete.
We use the term feasible to denote acceptable computational time and infeasible for
unacceptable computational time. In particular, NP-hard problems and exponential algorithms are considers infeasible, while polynomial algorithms are considered feasible. We use
these non-standard terms because most of our results are not limited to specic complexity
classes.
2.4 Example: Combinatorial Auctions
The problem of combinatorial auctions has been extensively studied in recent years (a recent
book can be found at Cramton et al., 2006). The importance of this problem is twofold.
Firstly, several important applications rely on it (e.g., the FCC auction Cramton, 1997).
Secondly, it is a generalization of many other problems of interest, in particular in the eld
of electronic commerce.
The problem: A seller wishes to sell a set S of items (radio spectra licenses, electronic
devices, etc.) to a group of agents who desire them. Each agent i has, for every subset
s  S of the items, a non-negative number v i (s) that represents how much s is worth for
it. v i (.) is privately known to each agent i. We make two standard additional assumptions
on the agents type space:
26

fiComputationally Feasible VCG Mechanisms

No externalities The valuation of each agent i depends only on the items allocated to
it. In other words, for every two allocations x = (x1 , . . . , xn ) and y = (y1 , . . . , yn ),
if xi = yi , then v i (x) = v i (y). Thus, we denote the valuation of each agent i by
v i : 2S  R.
Free disposal Items have non-negative values, i.e., if s  t, then v i (s)  v i (t). Also,
v i () = 0.


Items can either be complementary, i.e., v i (S T )  v i (S) + v i (T ), or substitutes, i.e.,

v i (S T )  v i (S) + v i (T ) (for disjoint S and T ). For example, a buyer may be willing to
pay $200 for a T.V. set, $150 for a VCR, $450 for both and only $200 for two VCRs.
If agent i gets the set si of items, and its payment is pi , its utility is v i (si ) + pi . (The
payments in combinatorial auctions are non-positive.) This utility is what each agent tries
to optimize. For example, an agent prefers to buy a $1000 valued VCR for $600, gaining
$400, rather buy a $1500 valued VCR for $1250.
In a VCG mechanism for a combinatorial auction, the participants are rst required
to reveal their valuation functions to the mechanism. The mechanism then computes,
according to the agents declarations, an allocation s that maximizes the total welfare. The
payment for each of the agents is calculated according to the VCG formula. By Lemma
2.1, the utility ui = v i (si ) + pi of each of the agents is maximized when it reveals its true
valuation to the mechanism. When all agents are truthful, the mechanism maximizes the
total welfare.
Consider, however, the computational task faced by such a mechanism. After the types
are declared, the mechanism needs to select, among all possible allocations, one that maximizes the total welfare. This problem is known to be NP-Complete. Therefore, unless
the number of agents and items is small, such a mechanism is computationally infeasible.
Even the problem of nding
an allocation that approximates the optimal allocation within

a reasonable factor of |S|   is N P -Complete (Zuckerman, 2006). Nevertheless, various
heuristics and tractable sub-cases have been analyzed in the literature (Cramton et al.,
2006, Chapter 13). We would like to nd a way to turn these sub-optimal algorithms into
mechanisms.
We note that, in general, revealing a valuation function requires exponential communication. While we ignore communication issues in this paper, a subsequent work (Ronen,
2001) extends the second chance method to address communication limitations as well.

3. Limitations of Truthful VCG-based Mechanisms
This section studies the limitations of truthful VCG-based mechanisms. Section 3.1 characterizes these mechanisms for the important problem of combinatorial auctions (see Section
2.4). This characterization precludes the possibility of obtaining truthfulness by applying
VCG rules to many of the proposed heuristics for combinatorial auctions (e.g., the greedy
algorithms of Lehmann et al., 2002 and Nisan, 2000). Moreover, we show that any truthful
non-optimal VCG-based mechanism for combinatorial auctions suers from abnormal behavior. Section 3.2 shows that for many natural cost minimization problems, any truthful
VCG-based mechanism is either optimal or produces results that are arbitrarily far from
27

fiNisan & Ronen

optimal. As a result, when such a problem is computationally intractable, any truthful computationally feasible VCG-based mechanism has inputs that cause it to produce degenerate
results. Furthermore, since standard algorithmic techniques do not yield such anomalies, it
might be dicult to develop algorithms that can be plugged into truthful mechanisms. We
generalize these results to ane-based mechanisms as well.
3.1 Truthful VCG-based Mechanisms for Combinatorial Auctions
This section characterizes the class of truthful VCG-based mechanisms for combinatorial
auctions.
Denition 9 (maximal in its range) Let k(w) be an algorithm that maps type decladf



rations into allowable outputs. Let V = ni=1 V i be the space of all possible types and let
V   V be a subspace of V . Let O denote the range of k at V  , i.e. O = {k(w)|w  V  }.
We say that k is maximal in its range at V  if for every type w  V  , k(w) maximizes g
over O. We say that k is maximal in its range if it is maximal in its range at V .
Consider, for example, an algorithm for combinatorial auctions that allocates all the
items (the set S) to the agent with the highest valuation v i (S). Clearly, this polynomial
time algorithm is maximal in its range . The welfare obtained by the allocation of this
algorithm achieves at least a factor of max(1/n, 1/|S|) of the optimal welfare (where n
denotes the number of agents).
Proposition 3.1 A VCG-based mechanism with an output algorithm that is maximal in
its range is truthful.
Proof: Such a mechanism is a VCG mechanism where the set of allowable outputs is the
range of its output algorithm. By Lemma 2.1 such a mechanism is truthful.
We will now show that the above proposition almost characterizes the class of truthful
VCG-based mechanisms for the combinatorial auction problem.
Notation: We let V denote the space of all types v = (v 1 , . . . , v n ) such that for any two
dierent allocations x and y, g(v, x) = g(v, y). (Recall that g(.) denotes the total welfare.)
It is not dicult to see that V contains almost all the types, i.e. V  V has a measure zero
in V .
Theorem 3.2 If a VCG-based mechanism for the combinatorial auction problem is truthful,
then its output algorithm is maximal in its range at V .
Proof: Assume by contradiction that m = (k, p) is truthful but k(.) is not maximal in its
range at V . Since the functions hi (.) do not aect the truthfulness of the mechanism, we

can assume that they are all zero, i.e., we assume that for all i, pi (w) = j=i wj (k(w)).

According to Lemma 2.1, the utility of each agent i equals v i (k(w)) + j=i wj (k(w)) =
g((v i , wi ), k(w)).
Let O denote the range of k(.) at V and let v  V be a type such that k(v) is not
optimal over O. Let y = arg maxoO g(v, o) be the optimal allocation among O. Note that
28

fiComputationally Feasible VCG Mechanisms

from the denition of V , y is unique. Finally, let w  V be a type such that y = k(w). Such
a type exists since y is in the range of the algorithm.
Dene a type vector z by

i

z (s) =

v i (s) if s  y i

if s  y i .

where  stands for a suciently large number. In other words, each agent i strongly desires
the set y i . Apart from this, v i and z i are identical. We assume that z  V . Otherwise we
could add suciently small noise i (s) to z such that all the claims below remain true.
We will show that z forces the algorithm to output y. We will then show that if
the algorithm outputs y when the type is z, it must also output y when the type is v  a
contradiction.
Lemma 3.3 y = k(z).
Proof: Dene a sequence of type vectors by:
w0 = (w1 , . . . , wn )
w1 = (z 1 , w2 , . . . , wn )
w2 = (z 1 , z 2 , w3 , . . . , wn )
..
.
wn = (z 1 , . . . , z n ).
In other words, every agent in turn moves from wi to z i . We assume that wj  V for all
j. It is not dicult to see that z can be modied by adding small noise to it, in a way that
guarantees the above.
Claim 3.4 k(w1 ) = y.
Proof: Assume by contradiction that this is false. From the denition of V we obtain that
g(w1 , k(w1 )) = g(w1 , y).
Consider the case where agent 1s type is z 1 and the types of the others are w2 , . . . , wn .
By declaring w1 , agent 1 can force the algorithm to decide on y. Since the mechanism is
truthful, it must be that g(w1 , k(w1 )) > g(w1 , y).
Since  is large, it must be that k 1 (w1 )  y 1 (i.e., agent 1 gets all the items it gets

when its type is w1 ). Thus, from the denition of z 1 , we obtain  + nj=2 wj (k(w1 )) >

 + nj=2 wj (y). Because, due to the free disposal assumption, w1 (k(w1 ))  w1 (y), we


obtain that w1 (k(w1 )) + nj=2 wj (k(w1 )) > w1 (y) + nj=2 wj (y) (even when z is perturbed).
Thus, g(w0 , k(w1 )) > g(w0 , y).
Therefore, when the type of agent 1 is w1 , it is better o declaring z 1 , forcing the
mechanism to output k(w1 ). This contradicts the truthfulness of the mechanism.
Similarly, by induction on j, we obtain that k(wj ) = y for all j, and in particular for wn = z.
This completes the proof of Lemma 3.3.
We will now show that k(z) = y implies that k(v) = y  a contradiction. Consider the
following sequence of type vectors:
29

fiNisan & Ronen

v0 = (v 1 , . . . , v n )
v1 = (z 1 , v 2 , . . . , v n )
..
.
vn = (z 1 , . . . , z n ).
In other words, every agent in turn, moves from v i to z i . Again we can choose z such that
all vj s are in V .
Claim 3.5 For all vj , y maximizes g on O.
Proof: We will show this for v1 . The proof for j > 1 follows from a similar argument.
Assume by contradiction that x = y maximizes the welfare for v1 . Since  is arbitrarily
large it must be that x1  y i . Consequently, in both cases agent 1s valuation equals .
Recall that y uniquely maximizes g on O for v0 . Thus, for every allocation x = y, we have




v 1 (y) + nj=2 v j (y) > v 1 (x) + nj=2 v j (x). Therefore,  + nj=2 v j (y) >  + nj=2 v j (x). But
the left hand side equals g(v1 , y) and the right hand side equals g(v1 , x). Thus, g(v1 , y) >
g(v1 , x)  contradiction.
Claim 3.6 k(vn1 ) = y.
Proof: We showed that k(vn ) = y. (Recall that vn = z.) We also showed that y uniquely
maximizes g(vn1 , .). Let xn1 = k(vn1 ). Assume by contradiction that xn1 = y. According to Lemma 2.1, the utility of agent n when it is truthful is g(vn1 , xn1 ). Thus,
when agent ns type is v n , it is better o declaring z n obtaining a utility of g(vn1 , y). This
contradicts the truthfulness of the mechanism.
Similarly, by downward induction on j, we obtain that k(v0 ) = y. But v0 = v and we
assumed that k(v) = y  a contradiction. This completes the proof of Theorem 3.2.
Remarks The above theorem characterizes the output algorithms that could be incorporated into truthful VCG-based mechanisms on all but a zero-measured subset of the types.
This characterization holds even when the set of possible types is discrete (under the mild
condition that the type vector z can be dened such that the agents are not indierent
between allocations). The theorem gives rise to several interesting algorithmic and combinatorial questions. For example, given an approximation factor c  1, what is the minimal
size of a sub-family O  O such that for every v, maxyO g(v, y)  c  gopt (v)? A limited
version of this question was analyzed by Holzman et al., 2004 and Holzman & Monderer,
2004.
Corollary 3.7 Consider a VCG-based mechanism for a combinatorial auction with an output algorithm k. If the mechanism is truthful, there exists an output algorithm k, maximal
in its range, such that for every v, g(v, k(v)) = g(v, k(v)).
Proof: Let O denote the range of k on V , and dene another algorithm that is optimal
in its range by v, k(v)  arg maxoO . According to Proposition 3.1, a VCG mechanism
30

fiComputationally Feasible VCG Mechanisms

based on k is truthful. Consider the case where the agents are truthful. Recall that the
utility of all agents is determined by the resulting total welfare. Thus, it is not dicult to
see that the welfares g(v, k(v)) and g(v, k(v)) must be continuous in v. Two continuous real
functions, which are identical on a dense subspace, are identical on the whole space and
thus the corollary follows.
We now show that non-optimal truthful VCG-based mechanisms suer from the following
disturbing abnormal behavior:
Denition 10 (reasonable mechanism) A mechanism for combinatorial auctions is
called reasonable if whenever there exists an item j and an agent i such that:
1. For all S, if j 
/ S, then v i (S  {j}) > v i (S), and,
2. For every agent l = i, S, v i (S  {j}) = v i (S),
then j is allocated to agent i.
Simply put, in situations where only one agent desires an item, that agent gets it.
Theorem 3.8 Any non-optimal truthful VCG-based mechanism for combinatorial auctions
is not reasonable.
Proof: Consider such a mechanism m. According to Corollary 3.7 there exists an equivalent
mechanism m = (k, p), which is optimal in its range. Since m must also be sub-optimal,
there exists at least one partition s = (s1 , . . . , sn ) that is not in the range of the mechanism.
Dene a vector of types by:

1 if x  si
i
v (x) =
0 otherwise.
In other words, each agent i wants a single set si , and no two agents want the same item
(as the sets are disjoined). Since s is not in the range of m it must be that k(v) = s. Since
s is strictly optimal, k(v) must also be suboptimal. Hence, there exists at least one agent
i that does not get si . In particular, there exists at least one item j  si that agent i does
not get. Since i is the only agent that desires j, the theorem follows.
Corollary 3.9 Unless P = N P , any polynomial time truthful VCG-based mechanism for
combinatorial auctions is not reasonable.
We believe that most of the natural allocation algorithms (e.g., linear programming relaxations, algorithms that greedily allocate items to agents, local search algorithms) will
not yield the above anomaly. In particular, we presume that when each agent wants a single
subset of items and these subsets are disjoined, any such algorithm will nd the optimal
allocation. Thus, the above corollary suggests that it might be dicult to develop allocation
algorithms that yield truthful VCG-based mechanisms.
We now show how to generalize our results to any ane-based mechanism. Given a tuple
a = (a0 , . . . , an ), we dene V to be the space of all types v such that for any two dierent
allocations x and y, ga (v, x) = ga (v, y). Similarly to the unweighted case, we say that an
algorithm is optimal in its range with respect to ga (.) if it always produces allocations that
maximize ga (.).
31

fiNisan & Ronen

Theorem 3.10 Consider an ane-based mechanism for the combinatorial auction problem
dened by an allocation algorithm k(.), and a tuple a = (a0 , . . . , an ). If the mechanism is
truthful, then k(.) is maximal in its range with respect to ga (.) at V .
Proof: (sketch) The proof is similar to the proof of Theorem 3.2 and we thus only sketch it.
Dene V and O similarly but w.r.t. the ane transformation ga (.). Assume by contradiction
that there exists a type vector v such that k(v) is not optimal in O. Let y be the optimal
allocation in the range O, and w  V such that k(w) = y. According to Lemma 2.2, the
utility of each agent is maximized with the weighted welfare ga ((v i , wi ), .). Thus, it is
possible to proceed along the lines of the proof of Theorem 3.2: Dene a type vector z
similarly; then, start from w and gradually transform all agents to z and conclude that
k(z) = y; then gradually transform all agents from z to v and show that k(v) = y, i.e.,  a
contradiction.
Open Questions We currently do not know whether theorems similar to Theorem 3.2
hold when the valuations are bounded. Moreover, we do not know how to get rid of the
usage of V . Thus, we do not preclude the possibility that Corollary 3.7 will not hold when
the space of possible types is discrete. We also do not know whether they hold when the
allocation algorithm is randomized or whether Bayesian versions of our theorems apply to
the expected externality mechanism (dAspremont & Gerard-Varet, 1979) (an analog of
VCG in the Bayesian model). We leave this to future research. We conjecture that similar
theorems apply to many other mechanism design problems.
3.2 Truthful VCG-based Mechanisms for Cost Minimization Problems
We now show that for many natural cost minimization problems, any truthful VCG-based
mechanism is either optimal or produces results that are arbitrarily far from the optimal.
We start with a sample problem.
Multicast transmissions: A communication network is modeled by a directed graph
G = (V, E). Each edge e is a privately owned link. The cost te of sending a message along
that edge is privately known to its owner. Given a source s  V and a set T  V of
terminals, the mechanism must select a subtree rooted in s that covers all the terminals.
The message is then broadcasted along this tree. We assume that no agent owns a cut in
the network.
Naturally, the goal of the mechanism is to select, among all possible trees, a tree R that

minimizes the total cost:
eR te . The goal of each agent is to maximize its own prot:

pi  (eR owned by i) te . It is not dicult to see that this is a utilitarian mechanism design
problem.
This example was introduced by Feigenbaum et al., 2000 (using a dierent model). It is
motivated by the need to broadcast long messages (e.g., movies) over the Internet. We now
generalize this example.
Denition 11 (cost minimization allocation problem)
A cost minimization allocation problem (CMAP) is a mechanism design problem described by:
32

fiComputationally Feasible VCG Mechanisms

i ). We let m =
Type space The type of each agent i is described by a vector (v1i , . . . , vm
i

i
i mi . (In our multicast example ve corresponds to the negation of the cost te .)

Allowable outputs Each output is denoted by a bit vector x = (x11 , . . . , x1m1 , . . . , xn1 , . . . , xnmn ) 
{0, 1}m . We denote (xi1 , . . . , ximi ) by xi . There may be additional constraints on the
set O of allowable outputs. (In our example x corresponds to a tree in the networks
graph where xij equals 1 i the corresponding edge is in the chosen tree.)
such that the following conditions are satised:
i ) describes a type for agent i and w i  v i (as
Unbounded costs If v i = (v1i , . . . , vm
i
i
vectors), then w also describes a type.

Independence and monotonicity Each valuation v i depends only on is bits xi . (In our
example, the agent valuation of a given tree depends only on its own edges in it.) If
for all j, wji  vji , then for every output x, wi (xi )  v i (xi ).
Forcing condition For every type v, an allowable output x and a real number ,
dene a type v[] by


v[]ij

=

vji


if xij = 1
otherwise.

The forcing condition is satised if for every allowable output y = x, lim g(t(), y) =
.
Many natural decentralized task allocation problems in which the goal is to minimize
the total cost under given constraints belong to this class. In particular the reader may
verify that our multicast example falls into this category. Another example is the shortest
path problem studied extensively in recent years (e.g., Rosenschein & Zlotkin, 1994; Archer
& Tardos, 2002; Elkind et al., 2004).
Notation: For a type v we let gopt (v) denote the optimal value of g. We denote g(v, k(v))
by gk (v).
Denition 12 (degenerate algorithm) An output algorithm k is called degenerate if the
g (v)gopt (v)
is unbounded, i.e., there exist vs such that rk (v) is arbitrarily
ratio rk (v) = k|gopt (v)|+1
large.
A degenerate algorithm is arbitrarily far from optimal, both additively and multiplicatively. Note that this should not be confused with the standard notion of an approximation
ratio, as our denition corresponds to a single problem. In particular, the number of agents
is xed. We note that we do not rule out the possibility that such an algorithm will be
good by some non worst case metric.
Theorem 3.11 If a VCG-based mechanism for a CMAP is truthful, then its output algorithm is either optimal or degenerate.
33

fiNisan & Ronen

Before stating the proof let us illustrate it using the multicast transmission example.
Suppose that we start with a type vector that leads to a sub-optimal solution. If we raise
the cost of an edge, the utility of the owner cannot increase (due to the truthfulness and
Lemma 2.1). We then gradually raise the cost of all edges except the ones in the optimal
tree. Still, the algorithm will have to choose a sub-optimal tree. However, the cost of any
suboptimal tree is now arbitrarily high while the optimal cost remains the same.
Proof: Let m = (k, p) be a non-optimal truthful VCG-based mechanism for a CMAP. As

in Theorem 3.2, assume that pi (w) = j=i wj (k(w)). Let v be a type vector such that k(v)
is not optimal and let y = opt(v) be an optimal output.
We dene a type z by:


zji =

vji
if yji = 1
 otherwise.

where  is arbitrarily large.
Consider the type sequence:
v0 = (v 1 , . . . , v n )
v1 = (z 1 , v 2 , . . . , v n )
..
.
vn = (z 1 , . . . , z n ).
Claim 3.12 For all j, y = opt(vj ).
Proof: By denition y is optimal for v0 . Let x = y be an allocation. From the independence
condition, for all j, g(vj , y) = g(v0 , y). From the monotonicity, g(vj , x)  g(v0 , x). Together,
g(vj , x)  g(v0 , x)  g(v0 , y) = g(vj , y).
Claim 3.13 g(v1 , k(v1 )) < g(v1 , y)
Proof: Assume by contradiction that the claim is false. Since y is optimal for v1 , this
means that g(v1 , k(v1 )) = g(v1 , y). From independence, g(v1 , y) = g(v0 , y). Recall that
k(v0 ) is suboptimal so g(v0 , y) > g(v0 , k(v0 )). From monotonicity (we only worsen the
type of agent 1), g(v0 , k(v1 ))  g(v1 , k(v1 )). Thus, together g(v0 , k(v1 ))  g(v1 , k(v1 )) =
g(v1 , y) = g(v0 , y) > g(v0 , k(v0 )). In particular, g(v0 , k(v1 )) > g(v0 , k(v0 )).
Consider the case where agent 1s type is v 1 and the declarations of the other agents are
(v 2 , . . . , v n ). According to Lemma 2.1, its utility when it is truthful, equals g(v0 , k(v0 )). On
the other hand, when it falsely declares z 1 , its utility equals g(v0 , k(v1 )). Since we showed
that g(v1 , k(v1 )) > g(v0 , k(v0 )), this contradicts the truthfulness of the mechanism.
Similarly, we obtain that g(vn , k(vn )) < g(vn , y) = g(v0 , y). By the forcing condition,
g(vn , k(vn ))   when   . Thus, the algorithm is degenerate.
Corollary 3.14 Unless P = N P , any polynomial time truthful VCG-based mechanism for
an NP-hard CAMP is degenerate.
34

fiComputationally Feasible VCG Mechanisms

Note that due to the revelation principle, the theorems in this section hold for any mechanism where the agents have dominant strategies. Similarly to Theorem 3.11, any mechanism
that uses VCG payments and has a non-optimal ex-post Nash equilibrium also has equilibria
which are arbitrarily far from optimal.
We now show how to generalize the theorems in this section to ane-based mechanisms.
Theorem 3.15 If an ane-based mechanism (k, p) for a CMAP is truthful, then its output
algorithm is either optimal or degenerate.
Proof:(sketch) The proof is almost identical to the proof of Theorem 3.11. Let v be a
type such that k(w) is not optimal w.r.t. to the corresponding ane transformation ga . We
dene a type vector z similarly to Theorem 3.11 and consider a sequence of type vectors
where each agent in turn changes its type from wi to z i . Due to the incentive compatibility
and Lemma 2.2 , the utility of each agent cannot increase, meaning that the weighted welfare
ga remains sub-optimal. Due to the forcing condition, all outputs except the optimal, have
arbitrarily high cost. This means that the algorithm is degenerate.
The compensation and bonus mechanism (Nisan & Ronen, 2001) identies the utility of
agents with the total welfare similarly to VCG, i.e., the utility of an agent can be described similarly to Lemma 2.1. Thus, all the theorems in this section can be applied to
compensation and bonus mechanisms as well.

4. Second Chance Mechanisms
To date, ane maximization is the only known general method for the development of
truthful mechanisms. Therefore, the results in the previous section do not leave much hope
for the development of truthful mechanisms for many complex problems.
This section proposes a method for circumventing this problem. Consider a VCG-based
mechanism. An immediate consequence of Lemma 2.1 is that the only reason for an agent
to misreport its type is to help the algorithm to improve the overall result. This leads to
the intuition that if the agents cannot improve upon the underlying algorithm, they can
do no better than be truthful. We would like to exploit this special property of VCG-based
mechanisms and construct mechanisms that are almost truthful.
Given any algorithm for the corresponding optimization problem we dene the second chance mechanism based on it. This mechanism is a modication of the VCG-based
mechanism where in addition to their valuations, the agents are allowed to submit appeal
functions. An appeal function allows the agent to give the algorithm an input (vector of
declared valuations) that is dierent from the original input but without misreporting its
type. When the agents behave truthfully, the welfare obtained by the mechanism is at least
as good as the one obtained by the algorithms output.
We then formulate the rationale for truthfulness in second chance mechanisms. Informally, our argument is as follows: Under reasonable assumptions, in any situation in which
the agent believes it is benecial for it to lie to the mechanism, it is better for it to report its
actual type to the mechanism and ask its appeal to check whether this lie is indeed helpful.
Thus, the agent can construct a truthful strategy premised on the fact that it is not aware
35

fiNisan & Ronen

of any situation in which another strategy is better for it. We believe that this is a strong
argument for truth-telling.
A generalization of our results to ane maximization and to compensation and bonus
mechanisms is straightforward.
4.1 The Mechanism
In this section we formulate the second chance mechanism and its basic properties.
Denition 13 (appeal function) Let V =
appeal is a partial function5 l : V  V .



i Vi

denote the type space of the agents. An

The semantics of an appeal l(.) is: when the agents type vector is v = (v1 , . . . , vn ), I
believe that the output algorithm k(.) produces a better result (w.r.t. v) if it is given the
input l(v) instead of the actual input v. An appeal function gives the agent an opportunity
to improve the algorithms output. If v is not in the domain of l(.), the semantics is that
the agent does not know how to cause the algorithm to compute a better result than k(v).
The second chance mechanism is dened in Figure 4.1. It is a modication of VCG that
allows the agents to submit appeal functions as well.

Before the execution The manager of the mechanism publishes the outcome determination algorithm and a time limit T on the computation time of each appeal.
Declaration Each agent submits a type declaration wi and an appeal function li (.) to the
mechanism. The appeals must adhere to the specied time limit.
Allocation Let w = (w1 , . . . , wn ). The mechanism computes k(w), k(l1 (w)), . . . , k(ln (w))
and chooses among these outputs the one that maximizes the total welfare (according
to w).
Payment Let o denote the chosen output. The mechanism calculates the payments ac
cording to the VCG formula: pi = j=i wj (o) + hi (wi , li ) (where hi (.) is any real
function).
Figure 1: The Second Chance Mechanism
Remarks The agents send programs that represent their appeal functions to the mechanism. These programs are then executed by the mechanism. The mechanism can terminate
the computation of each appeal after T units of computation time (and refer to the vector
of declarations w as if it is not in the appeals domain). Thus, we can assume w.l.o.g. that
all appeals adhere to the given time limit. A discussion on the choice of the time limit and
alternative representations of the appeal functions appears in Section 4.3. We believe that
it is possible to construct software tools and APIs that will make the formulation of the
appeals an easy task.
5. A function f : D  R is called partial if its domain is a subset of D, i.e. if Dom(f )  D.

36

fiComputationally Feasible VCG Mechanisms

The functions hi (.) do not play any role in the agents considerations as every hi (.) is
independent of is actions. Until Section 4.4 it is possible to simply assume that hi (.)  0
for all i. In Section 4.4 we will use these functions in order to satisfy individual rationality.
Denition 14 (truthful action) An action in the second chance mechanism is a pair
(wi , li ) where wi is a type declaration and li (.) is an appeal function. An action is called
truthful if wi = v i .
The following observation is a key property of the mechanism.
Proposition 4.1 Consider a second chance mechanism with an output algorithm k. For
every type vector v = (v 1 , . . . , v n ), if all agents are truth-telling, g(v, o)  g(w, k(v)).

In other words, when the agents are truth-telling, the result of the mechanism is at least
as good as k(v). The proof is immediate from the denition of the mechanism. We now
formulate an analog of Lemma 2.1. The proof is similar to the lemmas proof and is
henceforth omitted.
Lemma 4.2 (second chance utility) Consider a second chance mechanism. Let o be the
chosen output. The utility of agent i equals g((v i , wi ), o) + hi (wi , li ).

Therefore, informally, it is benecial for an agent to declare wi = v i only if it either helps
the output algorithm k(.) to compute a better result (w.r.t. (v i , wi )) or it helps one of the
appeals of the other agents.
Note that lying to a second chance mechanism may harm an agent in two ways. First,
it can damage the output algorithm k(.). Second, it can cause the mechanism to measure
the welfare according to a wrong type vector and thus cause it to choose an inferior output.
Notation: We say that a second chance mechanism is T-limited if the time limit it species
is T . Similarly, an algorithm is called T-limited if its computational time never exceeds T
units of computation.
The following proposition is obvious.
Proposition 4.3 Consider a T -limited second chance mechanism. If the output algorithm
of the mechanism is also T -limited, the overall computational time of the mechanism is
O(nT ).

4.1.1 A toy example
Consider a combinatorial auction of two items. A type of an agent is a 3-tuple representing
its value for every non empty subset of items. Suppose that agent i values the pair of
items at $3 million but values every single item at $1 million. Its type is, therefore, v i =
37

fiNisan & Ronen

{3, 1, 1}. Suppose that the agent notices that the allocation algorithm often produces better
allocations if it declares wi = {3, 0, 0} (i.e., it hides its willingness to accept only one item).
In a VCG-based mechanism the agent may prefer to declare wi instead of its actual type.
This might cause two problems:
1. Even when the others are truthful, there may be many type vectors v i belonging to the other agents, for which declaring wi damages the chosen allocation, i.e.,
g((v i , wi ), k((wi , wi ))) < g((v i , wi ), k((v i , wi ))).
2. Even when this is not the case and every agent i chooses a declaration wi such that
g((v i , wi ), k((wi , v i )))  g((v i , wi ), k(w)), it may be that according to the actual
type vector v the output k(w) may be inferior to k(v) (i.e., g(v, k(w)) < g(v, k(v))).
The second chance mechanism enables the agent to check whether declaring a falsied type
would yield a better result. Instead of declaring wi = {3, 0, 0}, the agent can declare its
actual type and dene its appeal as li (w ) = (wi , wi ). In this way the agent enjoys both
worlds. In cases where the falsied type is better, the mechanism will prefer k((wi , wi ))
over k((v i , wi )). In cases where the truthful declaration is better, the mechanism will prefer
k((v i , wi )). Note that the mechanism allows an appeal to modify not only the declaration
of the agent that submitted it but also the whole vector of declarations. This will allow us
to provide a strong argument for truth-telling.
Possible Variants of the Second Chance Mechanism One alternative denition
of the mechanism is to let the agents submit outcome determination algorithms instead
of appeals. It is possible to apply reasoning similar to ours to this variant. However,
formulating such output algorithms might be a demanding task for many applications.
There are also other more delicate dierences.
Another possibility is to dene a multi-round variant of the mechanism. In the rst
round the agents submit type declarations w. Then, at each round, each agent gets the
chance to improve the allocation found by the algorithm k(w). The mechanism terminates
when no agent improves the current allocation. The strategy space of multi-round mechanisms is very complex. Yet, under myopic behavior (Parkes, 1999), arguments similar to
ours can be used to justify truthful behavior. Such arguments may explain the relative
success of ad hoc mechanisms such as iterative VCG (IVG) and AUSM6 reported by Banks
et al., 1989.
Standard Equilibria in Second Chance Mechanisms The second chance mechanism
uses VCG payments and, therefore, the theorems of the rst part of the paper apply to it.
From Lemma 4.2, a vector of truthful actions is an ex post equilibrium if and only if the
resulting allocation o is optimal in the range of the algorithm. Moreover, consider agent
i and let (wi , li ) be a set of actions of the other agents. (wi , li ) is a best response for
the agent if and only if the resulting allocation o is optimal in the range of the underlying
algorithm with respect to (v i , wi ). At least intuitively, nding such a response is at least as
6. Both mechanisms are in the spirit of our second chance mechanism, as they let the agents improve the
allocation. The actual rules of these mechanisms are complicated and are described by Banks et al.,
1989.

38

fiComputationally Feasible VCG Mechanisms

hard as nding an allocation that is optimal in the range of the algorithm. Thus, one should
not expect the agents to follow equilibrium strategies in the traditional sense. We argue
that similar arguments can be made for every game in which computing the best response
is computationally dicult. Hence, an argument that takes into account the agents own
limitations is required. We note that we did not succeed in nding natural complexity
limitations under which truth-telling is an equilibria for the agents. We leave this as an
intriguing open problem.
4.2 The Rationale for Truth-telling
As we noted, standard equilibria should not be expected in second chance mechanisms. This
section formulates the rationale for truth-telling under these mechanisms. We rst introduce
the notion of feasibly dominant actions7 which takes into account the fact that the agents
capabilities are limited. We then demonstrate that under reasonable assumptions about
the agents, truthful, polynomial time, feasibly dominant actions exist.
4.2.1 Feasible Truthfulness
The basic models of equilibria in game theory are justied by the implicit assumption
that the agents are capable of computing their best response functions. In many games,
however, the action space is huge and this function is too complex to be computed, even
approximately within a reasonable amount of time. In such situations the above assumption
seems no longer valid.
In this section we re-formulate the concept of dominant actions under the assumption
that agents have a limited capability of computing their best response. Our concept is meant
to be used in the context of one stage games, i.e. games in which the agents choose their
actions without knowing anything about the others choices. The second chance mechanism
is a one stage-game. In a nutshell, an action is feasibly dominant if the agent is not aware
of any situation (a vector of the other agents actions) where another action is better for it.
Notation: We denote the action space of each agent i by Ai . Given a tuple a = (a1 , . . . , an )
of actions chosen by the agents, we denote the utility of agent i by ui (a).
Denition 15 (revision function) A revision function of agent i is any partial function
of the form bi : Ai  Ai .
The semantics of bi (ai ) is If I knew that the actions of the others are ai , I would choose
bi (ai ) (instead of ai ). A revision function captures all the cases where the agent knows
how it would like to act if it knew the others actions. Note that optimal revision functions
are standard best-response functions. When a vector of actions ai does not belong to the
domain of bi (.), the semantics is that the agent prefers to stick to its action.
Denition 16 (feasible non-regret) Let i be an agent, bi (.) its revision function, and
ai a vector of actions for the other agents. An action ai satises the feasible non-regret
7. We make a standard distinction between an action and a strategy  a mapping from the agents type to
its action.

39

fiNisan & Ronen

condition (w.r.t. ai and bi ), if either ai is not in the domain of bi or ui ((bi (ai ), ai )) 
ui (a).
In other words, other actions may be better against ai , but the agent is unaware of them
or cannot compute them when choosing its action.
When the revision function of the agent is optimal, a feasible non-regret is equivalent
to the standard non-regret (best response) condition.
Denition 17 (feasibly dominant action) Let i be an agent, bi (.) its revision function.
An action ai is called feasibly dominant (w.r.t. bi (.)) if for every vector ai of the actions
of the other agents, ai satises the feasible non-regret condition (w.r.t. ai and bi ).
Put dierently, an action ai is feasibly dominant if (when choosing its action) the agent is
not aware of any action ai and any vector ai of the actions of the other agents, such that
it is better o choosing ai when the others choose ai . A dominant action is always feasibly
dominant. When the revision function is optimal, a feasibly dominant action is dominant.
Example In order to demonstrate the concept of feasibly dominant actions consider a
chess match in which Alice and Bob submit computer programs that play on their behalf.
Currently, of course it is not known how to compute an equilibrium in chess and therefore
standard equilibria are not relevant for the analysis of such a game. A program aA is feasibly
dominant for Alice if she is not aware of any possible program of Bob against which she is
better o submitting another program.
Denition 18 (feasibly truthful action) An action ai in the second chance mechanism
is called feasibly truthful if it is both, truthful and feasibly dominant.
4.2.2 Natural revision functions that give rise to feasibly truthful actions
Beforehand we showed that when the agents are truthful, the total welfare is at least
g(v, k(v)). We also argued that if a feasibly truthful action is available, the agent has a strong
incentive to choose it. This subsection demonstrates that under reasonable assumptions
about the agents, polynomial time feasibly truthful actions do exist.
Notation: We let  denote the empty appeal. By (w, ) we denote an action vector where
the declaration of each agent i is wi and all the appeals are empty.
Denition 19 (appeal-independent revision function) A revision function bi (.) is
called appeal independent if every vector in its domain includes only empty appeals, i.e. for
all ai  dom(bi ), there exists a vector wi such that ai = (wi , ).
We say that an appeal independent function is T -limited if its own computational time
is bounded by T and so is every appeal function in its range.
The class of appeal-independent revision functions represents agents that only explore
the output algorithm (or alternatively, base their choice of action solely on the output
algorithm). This approach seems reasonable as the space of appeals of the other agents is
40

fiComputationally Feasible VCG Mechanisms

huge, with no apparent structure. At least intuitively, it seems unreasonable that an agent
will be able to lie in a way that will improve the result of the appeals of the other agents
with signicant probability. Moreover, as we commented, an agent has an obvious potential
loss from misreporting its type.
Theorem 4.4 Consider a second chance mechanism with a T -limited output algorithm.
Suppose that an agent has a T -limited appeal-independent revision function. For every
T  = (T ), if the mechanism is T  -limited, the agent has a feasibly truthful action.
Proof: Let bi (.) be the agents revision function. Dene an appeal li (.) as follows. For
every vector wi , let (wi ,  i ) = bi ((wi , )). Let w = (wi , wi ). Consider the outputs
o1 = k(w) and o2 = k( i (w)). We dene li (w) to be the better of the two outputs, i.e.,
li (w) = arg maxj=1,2 g((v i , wi ), oj ). Intuitively, li (.) checks whether declaring wi is helpful
for the agent.
Claim 4.5 ai = (v i , li ) is feasibly truthful.
Proof: If it is not, there exists a vector ai = (wi , ) in the domain of bi (.) such that
u(ai , ai ) < u(bi (ai ), ai ). Let bi (ai ) = (wi ,  i ). Recall that according to Lemma 4.2,
the agents utility is equivalent to the total welfare g((v i , wi ), o) of the chosen output o
(up to adding hi (.), which is independent of the agents actions).
Consider the case when the agents action is bi (ai ). Let o denote the chosen output
in this case. According to the denition of the mechanism, o is taken from the set {o1 , o2 }
and the welfare is measured according to the declaration w.
When the agent chooses the truthful action ai , the output (denoted o) is chosen from
the outputs o0 = k((v i , wi )) (from the denition of the mechanism), and both, o1 , o2 (from
the denition of li ). This is a superset of the set outputs of the rst case. Moreover,
the output is chosen according to the right type vector (v i , wi ). Thus, g((v i , wi ), o) 
g((v i , wi ), o), implying that the agent has a higher utility in the second case  a contradiction.
It remains to show that li (.) is (T )-limited. This is obvious as both, k(.) and  i (.) are
T -limited. This completes the proof of the theorem.
Given the agents revision function, it is easy to construct the appeal li (.) dened above (i.e.,
construct the program that computes it). Thus, if the agent has such an appeal independent
function, it can guarantee itself a feasibly dominant action.
A more general class of revision functions can be found in the Appendix. Interestingly,
there is a tradeo between the generality of the class and the time limit, which suces for
feasible truthfulness.
4.3 Remarks on the Choice of the Time Limit
Sections 4.2.2 and A.1 demonstrate two natural classes of revision functions under which
the agents have polynomial time feasibly truthful actions. We do not claim that every
revision function in practice will fall into these categories. Yet, it is plausible that this will
be the case in many applications. In general, there exists a tradeo between the generality
41

fiNisan & Ronen

of the class of the revision functions and the time limit required for feasible truthfulness.
In particular, without any time limit, submitting an optimal appeal is dominant. On the
other hand, it is plausible that small time limits will suce in practice. We leave a more
comprehensive study of this tradeo to future research.
An interesting future direction is to develop representations of the appeal functions that
relate the time limit imposed on each agent to its actual revision function. One possibility
is to represent the appeals by decision trees where the agents are required to supply for each
leaf , a type vector v , such that the algorithms result is strictly improved when it is given
l(t ) instead of the actual input v . v proves to the mechanism that the computational time
required to compute the leaf  is indeed needed in order to represent the agents revision
function. A related possibility is to allow the agent to purchase additional computational
time.
Currently, we do not know whether every polynomial class of revision functions guarantees the existence of polynomial feasibly truthful actions. If an agent has substantial
knowledge of the appeal space of the other agents, it may be able to nd a falsied declaration that causes typical appeals to produce better results. In such a case, it may be
benecial for an agent to lie. We do not know whether such knowledge will exist in practice.
If yes, it may be possible to overcome this by allowing the agents to submit meta-appeals,
i.e., functions that let the agents modify the input of the appeals of the other agents. We
leave this to future research.
4.4 Obtaining Individual Rationality
A basic desirable property of mechanisms is that the utility of a truthful agent is guaranteed
to be non-negative (individual rationality). In this section we construct a variant of second
chance mechanisms that satises this property.
Let gopt (v) denote the optimal welfare obtained when the type vector is v . We shall
assume that for each agent i, there exists a type v i such that for every v = (v 1 , . . . , v n ),
gopt ((v i , v i ))  gopt (v). We call such a type the lowest. In a combinatorial auction for
example, the lowest type is dened by the zero valuation v i (s) = 0 for every combination s
of items.
The Clarke mechanism (Clarke, 1971) is a VCG mechanism in which hi (wi ) = gopt (v i , wi ),

i.e., pi (w) = j=i wj (opt(w))  gopt (v i , (wi )). In other words, each agent pays the welfare
loss it causes to the society. Thus, it is natural to dene the payment of a VCG-based

mechanism as j=i wj (opt(w))  g((v i , wi ), k((v i , wi ))).
Like truthfulness, individual rationality may not be preserved when the optimal algorithm in the Clarke mechanism is replaced by a sub-optimal one. In order to x this we
need to ensure that the result of the algorithm will not improve when the declaration wi is
replaced by the lowest type v i .

Denition 20 (lowest type closure) Given an allocation algorithm k(w) we dene its
lowest type closure k as the best allocation (according to w) among the outputs (k(w), k((v 1 , w1 )), . . . , k((v n , w
Since k(.) calls k(.) n times, if k is T -limited, then k is O(nT )-limited.
Claim 4.6 For every w, g(w, k(w))  g((v i , wi ), k((v i , wi ))).
42

fiComputationally Feasible VCG Mechanisms

Proof: Since k((v i , wi )) is a candidate output that k tests, g(w, k(w))  g(w, k((v i , wi ))).
Given the denition of v i , g(w, k((v i , wi )))  g((v i , wi ), k(v i , wi )), the claim follows.
Denition 21 (second chance-IR) Given an allocation algorithm k(w) and a time limit
T we dene the corresponding second chance-IR mechanism as the second chance mechanism
with output algorithm k(.), time limit T , and for every agent i, hi (wi ) = g((v i , wi ), k((v i , wi ))).
The utility of a truthful agent in the above mechanism equals ui = g(w, o)g((v i , wi ), k((v i , wi ))) 
g(w, k(w))  g((v i , wi ), k((v i , wi )))  0. Therefore, the mechanism satises individual rationality.

5. Conclusion and Future Research
This paper studies VCG mechanisms in which the optimal outcome determination algorithm
is replaced by some sub-optimal but computationally tractable algorithm. The rst part of
the paper shows that for a wide range of problems, such mechanisms lose the game theoretic
virtues of their optimal counterparts. Similar results hold for ane maximization. These
results do not leave much hope for the development of polynomial time truthful mechanisms
for many problems of high complexity.
The second part of the paper proposes a general method for overcoming the diculty
of constructing truthful mechanisms. Given any algorithm for the underlying optimization
problem we dene the second chance mechanism based on it. We demonstrate that under
reasonable assumptions about the agents, truth-telling is still the rational strategy for the
agents. When the agents are truthful, the welfare obtained by the mechanism is at least as
good as the one obtained by the underlying algorithm.
Successful implementation of second chance mechanisms relies on several tools to be
developed  in particular, tools for the description of valuations and appeal functions.
These engineering issues require further exploration.
It is important to stress that the second chance method has not yet been tested. In
particular, the truthfulness of the agents should be validated experimentally. On the other
hand, we believe that in practice, small time limits on the agents appeals are likely to
guarantee the truthfulness of the agents. Several questions regarding the payment properties
of second chance mechanisms are open. We leave them for future research.
Several open questions, which directly stem from this work, are raised within the body
of the paper.

Acknowledgments
We thank Abraham Newman and Motty Perry for helpful discussions at various stages of this
work. We thank Ron Lavi, Ahuva Mualem, Elan Pavlov, Inbal Ronen, and the anonymous
reviewers for comments on earlier drafts of this paper. Noam Nisan was supported by
grants from the Israel Science Foundation and from the USA-Israel Binational Science
Foundation. Amir Ronen was supported in part by grant number 969/06 from the Israel
Science Foundation. A preliminary version of this paper appeared in the proceedings of the
3rd ACM Conference on Electronic Commerce (EC 01).
43

fiNisan & Ronen

Appendix A. d-bounded Revision Functions
The class of d-bounded revision functions represents agents that, in addition to the output
algorithm, explore a polynomial family of potential appeals of the other agents. This class
is a generalization of d-limited appeal-independent functions.
Denition 22 (d-bounded revision function) We say that a revision function bi (.) is
d-bounded if the following hold:
1. The revision function bi (.) is O(nd )-limited.
2. Let
L = {lj | li,j , wi s.t. (wi , (li , li,j ))  Dom(bi )}



{li | (wi , li ), wi s.t. (wi , li ) = bi ((wi , li ))}

be the family of all appeals that appear in either the domain or range of bi (.). Then
|L| = O(nd ).
3. There exists a constant c such that every appeal l  L is cnd -limited.
Theorem A.1 Consider a second chance mechanism with an O(nd )-limited output algorithm. Suppose that an agent has a d-bounded revision function. For every T  = (n2d ), if
the mechanism is T  -limited, the agent has a feasibly truthful action.
Proof: Let i be the agent and let bi be its revision function. We again use a simulation
argument in order to dene the appeal li (.). For every vector wi we compute the following
outputs:
1. o0 = k(w).
2. Similarly to the the proof of Theorem 4.4, let L = {1 . . . |L| } be the family of all
appeal functions that are in the domain or the range of bi . For all j = 1, . . . |L| dene
oj = k(j (w))).
3. Dene l(w) = arg max0j|L| g((v i , wi ), oj ) as the output with the maximum welfare
according to (v i , wi ) among all the outputs dened above.
Claim A.2 li (.) is n2d -limited.
Proof: W.l.o.g. the running time of k(.) is bounded by cnd . Otherwise, we will raise the
constant. According to the denitions, the appeal li performs nd + 1 computations, each
requiring at most cnd time units. Thus, the overall computation takes at most O(n2d ).
Claim A.3 ai = (v i , li ) is feasibly truthful.
Proof: Assume by contradiction that there exists an action vector ai in dom(bi ) such that
u((ai , ai ) < u((bi (ai ), ai ).
Consider the case when the agent chooses bi (ai ) = (wi ,  i ). The mechanism takes the
output o that maximizes the welfare (according to w) from the following set S of outputs:
44

fiComputationally Feasible VCG Mechanisms

1. o0 = k(w).
2. oj = k(lj (w)) for every j = i, i.e. the result of the appeals of the other agents.
3. oi = k( i (w)).
When the agent chooses ai , the outputs are measured according to the right type
vector (vi , wi ). Moreover, it is taken from the following superset of the outputs in S:
1. o0 = k((vi , wi )) (from the denition of the mechanism).
2. oj = k(lj ((vi , wi ))) for every j = i, i.e., the result of the appeals of the other agents
(also, from the denition of the mechanism).
3. oj = k( (w)) for every   L. Since ai is in the domain of bi , this set includes all the
outputs of the form k(lj (w)) from the case where i chooses bi (ai ). It also contains
the result of its own appeal  i (w).
4. k(w) (from the denition of li (.)).
Let o be the chosen output in this case. Since the set of outputs in the second case is a
superset of the rst, g((vi , wi ), o)  g((vi , wi ), o). According to Lemma 4.2 the utility of
the agent when choosing ai is thus higher than when choosing bi (ai )  a contradiction.
This completes the proof of Theorem A.1.
As in the case of appeal-independent functions, the theorem gives a prescription for constructing an appeal that guarantees the agent a feasibly dominant action.

References
Anderson, E., Kelly, F., & Steinberg, R. (2002). A contract and balancing mechanism for
sharing capacity in a communication network.. To appear.
Archer, A., & Tardos, E. (2002). Frugal path mechanisms. In Proceedings of the 13th
Annual ACM-SIAM Symposium on Discrete Algorithms, 991999.
Banks, J., Ledyard, J., & Porter, D. (1989). Allocating uncertain and unresponsive resources: An experimental approach. RAND Journal of Economics, 20, 125.
Bartal, Y., Gonen, R., & Nisan, N. (2003). Incentive compatible multi unit combinatorial
auctions. In Proceedings of Ninth Conference of Theoretical Aspects of Rationality
and Knowledge, pp. 7287.
Bartholdi, J. J., Tovey, C. A., & Trick., M. A. (1992). How hard is it to control an election?.
Mathematical and Computer Modelling (Special Issue on Formal Theories of Politics),
16, 2740.
Carroll, T. E., & Grosu, D. (2005). Distributed algorithmic mechanism design for scheduling
on unrelated machines. In Proceedings of the 8th International Symposium on Parallel
Architectures, Algorithms, and Networks, pp. 194199.
45

fiNisan & Ronen

Clarke, E. H. (1971). Multipart pricing of public goods. Public Choice, 1733.
Cramton, P. (1997). The fcc spectrum auction: an early assessment. Journal of Economics
and Management Strategy, 431495.
Cramton, P., Shoham, Y., & Steinberg, R. (2006). Combinatorial Auctions. MIT Press.
dAspremont, C., & Gerard-Varet, L. (1979). Incentives and incomplete information. Journal of Public Economics, 11 (1), 2545.
Elkind, E., Sahai, A., & Steiglitz, K. (2004). Frugality in path auctions. In Proceedings of
the 15th Annual ACM-SIAM Symposium on Discrete Algorithms, pp. 701709.
Feigenbaum, J., Papadimitriou, C., & Shenker, S. (2000). Sharing the cost of multicast
transmissions. In Proceeding of the Thirty-Second Annual ACM Symposium on Theory
of Computing.
Groves, T. (1973). Incentives in teams. Econometrica, 41, 617631.
Holzman, R., Kr-Dahav, N., Monderer, D., & Tennenholtz, M. (2004). Bundling equilibrium in combinatorial auctions. Games and Economic Behavior, 47, 104123.
Holzman, R., & Monderer, D. (2004). Characterization of ex post equilibrium in the vcg
combinatorial auctions. Games and Economic Behavior, 47, 87103.
Lavi, R., Nisan, N., & Mualem, A. (2003). Towards a characterization of truthful combinatorial auctions. In Proceedings of the 44th Annual IEEE Symposium on Foundations
of Computer Science.
Lehmann, D., OCallaghan, L., & Shoham, Y. (2002). Truth revelation in rapid, approximately ecient combinatorial auctions. Journal of the ACM, 49 (5), 577602. A
preliminay version appeared at Proc. of the rst ACM Conference on Electronic Commerce.
Mas-Collel, A., Whinston, W., & Green, J. (1995). Microeconomic Theory. Oxford university
press.
Nisan, N. (2000). Bidding and allocation in combinatorial auctions. In Proceedings of the
Second ACM Conference on Electronic Commerce, pp. 112.
Nisan, N., & Ronen, A. (2001). Algorithmic mechanism design. Games and Economic
Behaviour, 35, 166196. Extended abstract appeared in Proceedings of the Thirty
First Annual ACM symposium on Theory of Computing.
Osborne, M. J., & Rubinstein, A. (1994). A Course in Game Theory. MIT press.
Parkes, D. (1999). ibundle: An ecient ascending price bundle auction.. In Proceedings of
the ACM Conference on Electronic Commerce (EC-99), pp. 148157.
Porter, R., Ronen, A., Shoham, Y., & Tennenholtz, M. (2002). Mechanism design with
execution uncertainty. In In Proceedings of the 18th Conference on Uncertainty in
Articial Intelligence, pp. 414421.
Roberts, K. (1979). The characterization of implementable choise rules. In Laont, J.-J.
(Ed.), Aggregation and Revelation of Preferences, pp. 321349. North-Holland. Papers
presented at the rst European Summer Workshop of the Econometric Society.
46

fiComputationally Feasible VCG Mechanisms

Ronen, A. (2001). Mechanism design with incomplete languages. In Proceedings of the
Third ACM Conference on Electronic Commerce, 105114.
Rosenschein, J. S., & Zlotkin, G. (1994). Rules of Encounter: Designing Conventions for
Automated Negotiation Among Computers. MIT Press.
Shoham, Y., & Tanaka, K. (1997). A dynamic theory of incentives in multi-agent systems
(preliminary report). In Proceedings of the Fifteenth International Joint Conferences
on Articial Intelligence, pp. 626631.
Shoham, Y., & Tennenholtz, M. (2001). The fair imposition of tasks in multi-agent systems.
In Proceedings of the International Conference on Articial Intelligence, pp. 1083
1088.
Vickrey, W. (1961). Counterspeculation, auctions and competitive sealed tenders. Journal
of Finance, 837.
Wellman, M., Wurman, P., Walsh, W., & MacKie-Mason, J. (2001). Auction protocols for
decentralized scheduling. Games and Economic Behavior, 35, 271303.
Zuckerman, D. (2006). Linear degree extractors and the inapproximability of max clique
and chromatic number. In Proceedings of the 38th ACM Symposium on Theory of
Computing, Seattle, Washington, USA.

47

fi