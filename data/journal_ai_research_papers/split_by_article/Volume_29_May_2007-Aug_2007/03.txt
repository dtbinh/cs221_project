Journal of Artificial Intelligence Research 29 (2007) 421-489

Submitted 8/06; published 8/07

An Algebraic Graphical Model for Decision with
Uncertainties, Feasibilities, and Utilities
Cedric Pralet

cedric.pralet@onera.fr

ONERA Toulouse, France
2 av. Edouard Belin, 31400 Toulouse

Gerard Verfaillie

gerard.verfaillie@onera.fr

ONERA Toulouse, France
2 av. Edouard Belin, 31400 Toulouse

Thomas Schiex

thomas.schiex@toulouse.inra.fr

INRA Toulouse, France
Chemin de Borde Rouge, 31320 Castanet-Tolosan

Abstract
Numerous formalisms and dedicated algorithms have been designed in the last decades
to model and solve decision making problems. Some formalisms, such as constraint networks, can express simple decision problems, while others are designed to take into account uncertainties, unfeasible decisions, and utilities. Even in a single formalism, several
variants are often proposed to model different types of uncertainty (probability, possibility...) or utility (additive or not). In this article, we introduce an algebraic graphical model
that encompasses a large number of such formalisms: (1) we first adapt previous structures
from Friedman, Chu and Halpern for representing uncertainty, utility, and expected utility
in order to deal with generic forms of sequential decision making; (2) on these structures,
we then introduce composite graphical models that express information via variables linked
by local functions, thanks to conditional independence; (3) on these graphical models,
we finally define a simple class of queries which can represent various scenarios in terms
of observabilities and controllabilities. A natural decision-tree semantics for such queries
is completed by an equivalent operational semantics, which induces generic algorithms.
The proposed framework, called the Plausibility-Feasibility-Utility (PFU) framework, not
only provides a better understanding of the links between existing formalisms, but it also
covers yet unpublished frameworks (such as possibilistic influence diagrams) and unifies
formalisms such as quantified boolean formulas and influence diagrams. Our backtrack
and variable elimination generic algorithms are a first step towards unified algorithms.

1. Introduction
In the last decades, numerous formalisms have been developed to express and solve decision
making problems. In such problems, an agent must make decisions consisting of either
choosing actions and ways to fulfill them (as in action planning, task scheduling, or resource
allocation), or choosing explanations of observed phenomena (as in diagnosis or situation
assessment). These choices may depend on various parameters:
1. uncertainty measures, which we call plausibilities, may describe beliefs about the state
of the environment;
2. preconditions may have to be satisfied for a decision to be feasible;
c
2007
AI Access Foundation. All rights reserved.

fiPralet, Verfaillie, & Schiex

3. the possible states of the environment and decisions do not generally have the same
value from the decision makers point of view. Utilities can be expressed to model costs,
gains, risks, satisfaction degrees, hard requirements, and more generally, preferences;
4. when time is involved, decision processes may be sequential and the environment may
be partially observable. This means that there may be several decision steps, and that
the values of some variables may be observed between two steps, as in chess where
each player plays in turn and can observe the move of the opponent before playing
again;
5. there may be adversarial or collaborative decision makers, each of them controlling a
set of decisions. Hence, a multi-agent aspect can yield partial controllabilities.
Given the plausibilities defined over the states of the environment, the feasibility constraints on the decisions, the utilities defined over the decisions and the states of the environment, and given the possible multiple decision steps, the objective is to provide the decision
maker with optimal decision rules for the decision variables he controls, depending on the
environment and on other agents. To be concise, the class of such problems is denoted as
the class of sequential decision problems with plausibilities, feasibilities, and utilities.
Various formalisms have been designed to cope with problems of this class, sometimes
in a degenerated form (covering only a subset of the features of the general problem):
 formalisms developed in the boolean satisfiability framework: the satisfiability problem (SAT), quantified boolean formulas, stochastic SAT (Littman, Majercik, & Pitassi,
2001), and extended stochastic SAT (Littman et al., 2001);
 formalisms developed in the very close constraint satisfaction framework: constraint
satisfaction problems (CSPs, Mackworth, 1977), valued/semiring CSPs (Bistarelli,
Montanari, Rossi, Schiex, Verfaillie, & Fargier, 1999) (covering classical, fuzzy, additive, lexicographic, probabilistic CSPs), mixed CSPs and probabilistic mixed CSPs
(Fargier, Lang, & Schiex, 1996), quantified CSPs (Bordeaux & Monfroy, 2002), and
stochastic CSPs (Walsh, 2002);
 formalisms developed to represent uncertainty and extended to represent decision
problems under uncertainty: Bayesian networks (Pearl, 1988), Markov random fields
(Chellappa & Jain, 1993) (also known as Gibbs networks), chain graphs (Frydenberg, 1990), hybrid or mixed networks (Dechter & Larkin, 2001; Dechter & Mateescu,
2004), influence diagrams (Howard & Matheson, 1984), unconstrained (Jensen & Vomlelova, 2002), asymmetric (Smith, Holtzman, & Matheson, 1993; Nielsen & Jensen,
2003), or sequential (Jensen, Nielsen, & Shenoy, 2004) influence diagrams, valuation
networks (Shenoy, 1992), and asymmetric (Shenoy, 2000) or sequential (Demirer &
Shenoy, 2001) valuation networks;
 formalisms developed in the classical planning framework, such as STRIPS planning (Fikes & Nilsson, 1971; Ghallab, Nau, & Traverso, 2004), conformant planning (Goldman & Boddy, 1996), and probabilistic planning (Kushmerick, Hanks, &
Weld, 1995);

422

fiThe PFU Framework

 formalisms such as Markov decision processes (MDPs), probabilistic, possibilistic,
or using Spohns epistemic beliefs (Spohn, 1990; Wilson, 1995; Giang & Shenoy,
2000), factored or not, possibly partially observable (Puterman, 1994; Monahan, 1982;
Sabbadin, 1999; Boutilier, Dean, & Hanks, 1999; Boutilier, Dearden, & Goldszmidt,
2000).
Many of these formalisms present interesting similarities:
 they include variables modeling the state of the environment (environment variables)
or the decisions (decision variables);
 they use sets of functions which, depending on the formalism considered, can model
plausibilities, feasibilities, or utilities;
 they use operators either to combine local information (such as  to aggregate probabilities under independence hypothesis, + to aggregate gains and costs), or to project
a global information (such as + to compute a marginal probability, min or max to
compute an optimal decision).
Even if the meaning of variables, functions, and combination or projection operators
may be specific to each formalism, they can all be seen as graphical models in the sense that
they exploit, implicitly or explicitly, a hypergraph of local functions between variables. This
article shows that it is possible to build a generic algebraic framework subsuming many of
these formalisms by reducing decision making problems to a sequence of so-called variable
eliminations on an aggregation of local functions.
Such a generic framework will be able to provide:
 a better understanding of existing formalisms: a generic framework has an obvious
theoretical and pedagogical interest, since it can bring to light similarities and differences between the formalisms covered and help people of different communities to
communicate on a common basis;
 increased expressive power : a generic framework may be able to capture problems
that cannot be directly modeled in any existing formalism. This increased expressiveness should be reachable by capturing the essential algebraic properties of existing
frameworks;
 generic algorithms: ultimately, besides a generic framework, it should be possible
to define generic algorithms capable of solving problems defined in this framework.
This objective fits into a growing effort to identify common algorithmic approaches
that were developed for solving different AI problems. It may also facilitate crossfertilization by allowing each subsumed framework to reuse algorithmic ideas defined
in another one.
1.0.1 Article Outline
After the introduction of some notations and notions, the article starts by showing, with a
catalog of existing formalisms for decision making, that a generic algebraic framework can
423

fiPralet, Verfaillie, & Schiex

be informally identified. This generic framework, called the Plausibility-Feasibility-Utility
(PFU) framework, is then formally introduced in three steps: (1) algebraic structures capturing plausibilities, feasibilities, and utilities are introduced (Section 4), (2) these algebraic structures are exploited to build a generic form of graphical model (Section 5), and
(3) problems over such graphical models are captured by the notion of queries (Section 6).
The framework is analyzed in Section 7 and generic algorithms are defined in Section 8.
A table recapitulating the main notations used is available in Appendix A and the proofs
of all propositions and theorems appear in Appendix B. A short version of the framework
described in this article has already been published (Pralet, Verfaillie, & Schiex, 2006c).

2. Background Notations and Definitions
The essential objects used in the article are variables, domains, and local functions (called
scoped functions).
Definition 1. The domain of values of a variable x is denoted dom(x) and for every
a  dom(x), (x, a) denotes the assignment of value a to x. By extension, for a set of
variables S, we denote
Q by dom(S) the Cartesian product of the domains of the variables in
S, i.e. dom(S) = xS dom(x). An element A of dom(S) is called an assignment of S.1
If A1 , A2 are assignments of disjoint subsets S1 , S2 , then A1 .A2 , called the concatenation
of A1 and A2 , is the assignment of S1  S2 where variables in S1 are assigned as in A1 and
variables in S2 are assigned as in A2 . If A is an assignment of a set of variables S, the
projection of A onto S 0  S is the assignment of S 0 where variables are assigned to their
value in A.
Definition 2. (Scoped function) A scoped function is a pair (S, ) where S is a set of
variables and  is a function mapping elements in dom(S) to a given set E. In the following,
we will often consider that S is implicit and denote a scoped function (S, ) as  alone. The
set of variables S is called the scope of  and is denoted sc(). If A is an assignment of a
superset of sc() and A0 is the projection of A onto sc(), we define (A) by (A) = (A0 ).
For example, a scoped function  mapping assignments of sc() to elements of the
boolean lattice B = {t, f } is analogous to a constraint describing the subset of dom(sc())
of authorized tuples in constraint networks.
From this, the general notion of graphical model can be defined:
Definition 3. (Graphical model) A graphical model is a pair (V, ) where V = {x1 , . . . , xn }
is a finite set of variables and  = {1 , . . . , m } is a finite set of scoped functions whose
scopes are included in V .
The terminology of graphical models is used here simply because a set of scoped functions
can be represented as a hypergraph that contains one hyperedge per function scope. As
we will see, this hypergraph captures a form of independence (see Section 5) and induces
parameters for the time and space complexity of our algorithms (see Section 8). This
definition of graphical models generalizes the usual one used in statistics, defining a graphical
1. An assignment of S = {x1 , . . . , xk } is actually a set of variable-value pairs {(x1 , a1 ), . . . , (xk , ak )}; we
assume that variables are implicit when using a tuple of values (a1 , . . . , ak )  dom(S).

424

fiThe PFU Framework

model as a (directed or not) graph where the nodes represent random variables and where
the structure captures probabilistic independence relations.
Local scoped functions in a graphical model give a space-tractable definition of a
global function defined by their aggregation. For example, in a Bayesian network (Pearl,
1988) a global probability distribution Px,y,z over x, y, z may be defined as the product
(using operator ) of a set of scoped functions {Px , Py|x , Pz|y }. Local scoped functions
can also facilitate the projection of the information expressed by a graphical model onto a
smaller scope. For example, in order to compute
P a marginal
P probability distribution Py,z
from the previous network, we can computeP x Px,y,z = ( x Px  Py|x )  Pz|y and avoid
taking Pz|y into account. Here the operator
is used to project information onto a smaller
scope by eliminating variable x. Operators used to combine scoped functions will be called
combination operators, while operators used to project information onto smaller scopes will
be called elimination operators.
Definition 4. (Combination) Let 1 , 2 be scoped functions to E1 and E2 respectively. Let
 : E1 E2  E be a binary operator. The combination of 1 and 2 , denoted by 1 2 , is
the scoped function to E with scope sc(1 )sc(2 ) defined by (1 2 )(A) = 1 (A)2 (A)
for all assignments A of sc(1 )  sc(2 ).  is called the combination operator of 1 and
2 .
In the rest of the article, all combination operators will be denoted .
Definition 5. (Elimination) Let  be a scoped function to E. Let op be an on E which
is associative, commutative, and has an identity element . The elimination of variable
x from  with op is a scoped function whose scope is sc()  {x} and whose value for an
assignment A of its scope is (opx )(A) = opadom(x) (A.(x, a)). In this context, op is called
the elimination operator for x. The elimination of a set of variables S = {x1 , . . . , xk } from
 is a function with scope sc()  S defined by opS (A) = opA0 dom(S) (A.A0 ).
P
Hence, when computing x (Px  Py|x  Pz|x ), scoped functions are aggregated using
the combination operator  =  and the information is projected by eliminating x using
the elimination operator +. In this article,  denotes elimination operators.
In some cases, the elimination of a set of variables S with an operator op from a scoped
function  should only be performed on a subset of dom(S) containing assignments that
satisfy some property denoted by a boolean scoped function F . Then, we must compute
for every A  dom(sc()  S) the value opA0 dom(S),F (A0 )=t (A.A0 ). For simplicity and
homogeneity, and in order to always use elimination over dom(S), we can equivalently
truncate  so that elements of dom(S) which do not satisfy F are mapped to a special
value (denoted ) which is itself defined as a new identity for op.
Definition 6. (Truncation operator) The unfeasible value  is a new special element that
is supposed to be outside of the domain E of every elimination operator op : E  E  E.
We explicitly extend every elimination operator op : E  E  E on E  {} by taking the
convention op(, e) = op(e, ) = e for all e  E  {}.
Let {t, f } be the boolean lattice. For any boolean b and any e  E, we define b ? e to be
equal to e if b = t and  otherwise. ? is called the truncation operator.

425

fiPralet, Verfaillie, & Schiex

Given a boolean scoped function F ,  and ? make it possible to write quantities like
opA0 dom(S),F (A0 )=t  as the elimination opS (F ? ).
In order to solve decision problems, one usually wants to compute functions mapping the
available information to a decision. The notion of decision rules will be used to formalize
this:
Definition 7. (Decision rule, policy) A decision rule for a variable x given a set of variables
S 0 is a function  : dom(S 0 )  dom(x) mapping each assignment of S 0 to a value in dom(x).
By extension, a decision rule for a set of variables S given a set of variables S 0 is a function
 : dom(S 0 )  dom(S). A set of decision rules is called a policy.
Definition 8. (Optimal decision rule) Consider a totally -ordered set E, a scoped function
 from dom(sc()) to E, and a set of variables S  sc(). A decision rule  : dom(sc() 
S)  dom(S). is said to be optimal iff, for all (A, A0 )  dom(sc()  S)  dom(S),
(A.(A))  (A.A0 ) (resp. (A.(A))  (A.A0 )). Such a decision rule always exists
when dom(sc()) is finite.
In other words, optimal decision rules are examples of decision rules given by argmin
and argmax (in this article, we consider that optimality on decision rules is always given by
min or max on some totally ordered set).
Definition 9. (Directed Acyclic Graph (DAG)) A directed graph G is a DAG if it contains
no directed cycle. When variables are used as vertices, paG (x) denotes the set of parents of
variable x in G.
Last, [1, n] will denote the set of integers i such that 1  i  n.

3. From Examples of Graphical Models to a Generic Framework
We now present different AI formalisms for expressing and solving decision problems. In
the most simple case, a single decision which maximizes utility is sought. The introduction
of plausibilities (uncertainties), unfeasible actions (feasibilities), and sequential decision
(several decision steps with some observations between decision steps) only appears in the
most sophisticated frameworks. The goal of this section is to show that these formalisms
can all be viewed as graphical models where specific elimination and combination operators
are used.
3.1 Examples of Graphical Models
The examples used cover various AI formalisms, which are briefly described. A wider and
more accurate review of existing graphical models could be provided (Pralet, 2006).
3.1.1 Constraint Networks
Constraint networks (CNs, Mackworth, 1977), often called constraint satisfaction problems
(CSPs), are graphical models (V, ) where the scoped functions in  are constraints mapping
assignments onto {t, f }. The usual query on a CN is to determine the existence of an

426

fiThe PFU Framework

assignment of V that satisfies all constraints. By setting f  t, this decision problem can
be answered by computing:


max   .
(1)
V



If this quantity equals true, then an optimal decision rule for V defines a solution. This
query can be answered by performing eliminations (using max) on a combination of scoped
functions (using ). Replacing the hard constraints in  by soft constraints (boolean scoped
functions being replaced by cost functions) and replacing  by an abstract operator  equal
to +, min, , . . . leads to queries on a valued and totally ordered semiring CN (Bistarelli
et al., 1999).
3.1.2 Bayesian Networks
Bayesian networks (BNs, Pearl, 1988) can model problems with plausibilities expressed as
probabilities. A BN is a graphical model (V, ) in which  is a set of local conditional
probability distributions:  = {Px | paG (x) , x  V }, where G is a DAG with vertices in V .
A BN represents a joint probability distribution P
QV over all variables as a combination of
local conditional probability distributions (PV = xV Px | paG (x) ), just as the combination
of local constraints in a CN defines a global constraint over all variables. One possible query
on a BN is to compute the marginal probability distribution of a variable y  V :
!
X
X
Y
Py =
PV =
Px | paG (x) .
(2)
V {y}

V {y}

xV

Equation 2 corresponds to variable eliminations (with +) on a product of scoped functions.
In other queries on BNs such as MAP (Maximum A Posteriori hypothesis), eliminations
with max are also performed.
3.1.3 Quantified Boolean Formulas and Quantified CNs
Quantified boolean formulas (QBFs) and quantified CNs (Bordeaux & Monfroy, 2002) can
model sequential decision problems. Let x1 , x2 , x3 be boolean variables. A QBF using the
so-called prenex conjunctive normal form looks like (with f  t):
x1 x2 x3 ((x1  x3 )  (x2  x3 )) = max min max((x1  x3 )  (x2  x3 )).
x1

x2

x3

(3)

Thus, the query Is there a value for x1 such that for all values of x2 , there exists a value
for x3 such that the clauses x1  x3 and x2  x3 are satisfied? can be answered as in
Equation 3 using a sequence of eliminations (max over x1 , min over x2 , and max over x3 )
on a conjunction of clauses. In a quantified CN, clauses are replaced by constraints.
3.1.4 Stochastic CNs
A stochastic CN (Walsh, 2002) can model sequential decision problems with probabilities as
plausibilities and hard requirements as utilities, provided that the decisions do not influence
the environment (the so-called contingency assumption). In a stochastic CN, two types of
427

fiPralet, Verfaillie, & Schiex

variables are defined: decision variables di and environment (stochastic) variables sj . A
global probability distribution over the environment variables is expressed as a combination
of local probability distributions. If the environment variables are mutually independent,
these local probability distributions are simply unary probability distributions Psj . Finally,
a stochastic CN defines a set of constraints {C1 , . . . , Cm } mapping tuples of values onto
{0, 1} (instead of {t, f }). This allows constraints to be multiplied with probabilities.
Consider a situation where first two decisions d1 and d2 are made, then an environment
variable s1 is observed, then decisions d3 and d4 are made, while an environment variable s2
remains unobserved. A possible query on a stochastic CN is to compute decision rules for
d1 , d2 , d3 , and d4 which maximize the expected constraint satisfaction, through Equation 4:
Q

X
X
C
(4)
(Ps1  Ps2 ) 
max
max
i[1,m] i .
d1 ,d2

s1

d3 ,d4

s2

The answer to the query defined by Equation 4 is determined by a sequence of eliminations
(max over the decision variables, + over the environment ones) on a combination of scoped
functions (probabilities are combined using , constraints are combined using , since they
are expressed onto {0, 1} instead of {t, f }, and probabilities are combined with constraints
using ).
3.1.5 Influence Diagrams
Influence diagrams (Howard & Matheson, 1984) can model sequential decision problems
with probabilities as plausibilities together with gains and costs as utilities. They can be
seen as an extension of BNs including the notions of decision and utility. More precisely,
an influence diagram is a composite graphical model defined by three sets of variables
organized in a DAG G: (1) a set S of chance variables; for each s  S, a conditional
probability distribution Ps | paG (s) of s given its parents in G is specified; (2) a set D of
decision variables; for each d  D, paG (d) is the set of variables observed before decision
d is made; (3) a set  = {u1 , . . . , um } of utility variables, each of which is associated with
a utility function Ui = UpaG (ui ) of scope paG (ui ). Utility variables P
must be leaves in the
DAG, and the utility functions define a global additive utility UG = i[1,m] Ui .
The usual problem associated with an influence diagram is to compute decision rules
maximizing the global expected utility. If we modify the example used for stochastic CNs
by replacing Ps1 by Ps1 | d2 , Ps2 by Ps2 | d1 ,d3 , and the constraints C1 , . . . , Cm by the additive
utility functions U1 , . . . , Um , then an optimal policy can be obtained by computing optimal
decision rules for d1 , d2 , d3 , and d4 in Equation 5:

X
X
 P
max
max
Ps1 | d2  Ps2 | d1 ,d3 
U
.
(5)
i
i[1,m]
d1 ,d2

s1

d3 ,d4

s2

Again, the answer to the query defined by Equation 5 can be computed by a sequence
of eliminations (alternating max- and sum-eliminations) on a combination of scoped functions (plausibilities combined using , utilities combined using +, plausibilities and utilities
combined using ).

428

fiThe PFU Framework

3.1.6 Valuation Networks
Valuation networks (Shenoy, 1992) can model sequential decision problems with plausibilities, feasibilities, and utilities, where plausibilities are combined using  and where utilities
are additive. A valuation network is composed of several sets of nodes and valuations: (1)
a set D of decision nodes, (2) a set S of chance nodes, (3) a set F of indicator valuations,
which specify unfeasible assignments of decision and chance variables, (4) a set P of probability valuations, which are multiplicative factors of a joint probability distribution over
the chance variables, and (5) a set
P U of utility valuations, representing additive factors
of a joint utility function UG =
Ui U Ui . Arcs between nodes are also used to define
the order in which decisions are made and chance variables are observed. If this order is
d1  d2  s1  d3  d4  s2 , it can be shown that optimal decision rules for d1 , d2 , d3 , d4
are defined through Equation 6:


 


X
X 
Y
X
  Fi ? 
max
max
Pi   
Ui  .
(6)
d1 ,d2

s1

d3 ,d4

Fi F

s2

Pi P

Ui U

Local feasibility constraints are combined using , and combined with other scoped functions using the truncation operator ? (cf. Definition 6).
3.1.7 Finite Horizon Markov Decision Processes
Finite horizon Markov Decision Processes (MDPs, Puterman, 1994; Monahan, 1982; Sabbadin, 1999; Boutilier et al., 1999, 2000) model sequential decision problems with plausibilities and utilities over a horizon of T time-steps. For every time-step t, a variable st
represents the state of the environment and a variable dt represents the decision made after
observing st . In factored MDPs, several state variables may be used at each time-step.
In a probabilistic finite horizon MDP, plausibilities over the environment are described by
local probability distributions Pst+1 | st ,dt of being in state st+1 given st and dt . The utilities
over states and decisions are local additive rewards Rst ,dt , and boolean functions Fdt | st can
express whether a decision dt is feasible in state st . An optimal policy for each initial state
s1 can be computed by the following equation (which is a bit unusual for defining optimal
policies for a MDP, but is equivalent to the usual form):
!
!


max u max . . . u max
d1

s2

d2

sT

dT


t[1,T ]

Fdt |st

?

p Pst+1 |st ,dt
t[1,T [

pu

u Rst ,dt
t[1,T ]

.

(7)

Plausibilities are combined using p = , utilities are combined using u = +, plausibilities
and utilities are combined using pu = , decision variables are eliminated using max, and
environment variables are eliminated using u = +. The truncation operator ? enables the
elimination operators to ignore unfeasible decisions.
In a pessimistic possibilistic finite horizon MDP (Sabbadin, 1999), probability distributions Pst+1 | st ,dt are replaced by possibility distributions st+1 | st ,dt , rewards Rst ,dt are
replaced by preferences st ,dt , and the operators used are u = p = u = min and
pu : (p, u)  max(1  p, u).

429

fiPralet, Verfaillie, & Schiex

3.2 Towards a Generic Framework
The previous section shows that usual queries in various existing formalisms can be reduced
to a sequence of variable eliminations on a combination of scoped functions.
This observation has led to the definition of algebraic MDPs (Perny, Spanjaard, & Weng,
2005) or to the definition of valuation algebras (Shenoy, 1991; Kolhas, 2003), a generic
algebraic framework in which eliminations can be performed on a combination of scoped
functions. However, valuation algebras use only one combination operator, whereas several
combination operators may be needed to manipulate different types of scoped functions (as
previously shown). Moreover, valuation algebras can deal with only one type of elimination,
whereas several elimination operators may be required for handling the different types of
variables. In valuation networks (Shenoy, 2000), plausibilities are necessarily represented as
probabilities, and eliminations with min cannot be performed. Essentially, a more powerful
framework is needed.
In order to be simple and yet general enough to cover the queries defined by Equations 1
to 7, the generic form we should consider is:
!



!
Sov

 Fi

Fi F

?

p
Pi P

Pi

pu

u
Ui U

Ui

.

(8)

where (1)  is used to combine local feasibilities, p is used to combine plausibilities, u
is used to combine utilities, pu is used to combine plausibilities and utilities, and the
truncation operator ? is used to ignore unfeasible decisions without having to deal with
elimination operations over restricted domains;2 (2) F , P , U are (possibly empty) sets
of local feasibility, plausibility, and utility functions respectively; (3) Sov is an operatorvariable(s) sequence, indicating how to eliminate variables. Sov involves min or max to
eliminate decision variables and an operator u to eliminate environment variables.
Equation 8 is still very informal. To define it formally, and to provide it with clear
semantics, we need to define three key elements:
1. We must capture the essential properties of the combination operators p , u , pu
used respectively to combine plausibilities, utilities, and plausibilities with utilities.
We must also characterize the elimination operators u and p used to project information coming from utilities and plausibilities. These operators will define the
algebraic structure of the PFU (Plausibility-Feasibility-Utility) framework.
2. On this algebraic structure, we must define a generic form of graphical model, involving a set of variables and sets of scoped functions expressing plausibilities, feasibilities,
and utilities (sets P , F , U ). Together, they will define a PFU network. The factored
form offered by such graphical models must also be analyzed in order to understand
when and how it can be applied to concisely represent global functions (using the
notion of conditional independence).
2. In Equation 8, all plausibilities are combined using the same operator p and all utilities are combined
using the same operator u ; we denote such models as composite graphical models because they include
different types of scoped functions (plausibilities, feasibilities, and utilities). Beyond this, Equation 8
also allows for heterogeneous information among each type of scoped functions. For example, in order to
manipulate both probabilities and possibilities, we can use p defined over probability-possibility pairs
by (p1 , 1 ) p (p2 , 2 ) = (p1  p2 , min(1 , 2 )).

430

fiThe PFU Framework

3. Finally, we must define queries on PFU networks capturing interesting decision problems. As Equation 8 shows, such queries will be defined by a sequence Sov of operatorvariable(s) pairs, applied on the combination of the scoped functions in the network.
The fact that the answer to such queries represents meaningful values from the decision theory point of view will be proved by relating approach.
3.3 Summary
We have informally shown that several queries in various formalisms dealing with plausibilities and/or feasibilities and/or utilities reduce to sequences of variable eliminations
applied to combinations of scoped functions, using various operators. They can intuitively
be covered by Equation 8.
The three key elements (an algebraic structure, a PFU network, and a sequence of variable eliminations) needed to formally define and give sense to this equation are introduced
in Sections 4, 5, and 6.

4. The PFU Algebraic Structures
The first element of the PFU framework is an algebraic structure specifying how the information provided by plausibilities, feasibilities, and utilities is combined and synthesized.
This algebraic structure is obtained by adapting previous structures defined by Friedman,
Chu, and Halpern (Friedman & Halpern, 1995; Halpern, 2001; Chu & Halpern, 2003a) for
representing uncertainties and expected utilities.
4.1 Definitions
Definition 10. (E, ~) is a commutative monoid iff E is a set and ~ is a binary operator
on E which is associative (x ~ (y ~ z) = (x ~ y) ~ z), commutative (x ~ y = y ~ x), and
has an identity 1E  E (x ~ 1E = 1E ~ x = x).
Definition 11. (E, , ) is a commutative semiring iff
 (E, ) is a commutative monoid, with an identity denoted 0E ,
 (E, ) is a commutative monoid, with an identity denoted 1E ,
 0E is annihilator for  (x  0E = 0E ),
  distributes over  (x  (y  z) = (x  y)  (x  z)).
Definition 12. Let (Ea , a , a ) be a commutative semiring. Then, (Eb , b , ab ) is a semimodule on (Ea , a , a ) iff
 (Eb , b ) is a commutative monoid, with an identity denoted 0Eb ,
 ab : Ea  Eb  Eb satisfies
 ab distributes over b (a ab (b1 b b2 ) = (a ab b1 ) b (a ab b2 )),
 ab distributes over a ((a1 a a2 ) ab b = (a1 ab b) b (a2 ab b)),
431

fiPralet, Verfaillie, & Schiex

 linearity property: a1 ab (a2 ab b) = (a1 a a2 ) ab b,
 for all b  Eb , 0Ea ab b = 0Eb and 1Ea ab b = b.
Definition 13. Let E be a set with a partial order . An operator ~ on E is monotonic
iff (x  y)  (x ~ z  y ~ z) for all x, y, z  E.
4.2 Plausibility Structure
Various forms of plausibilities exist (Halpern, 2003). The most usual one is probabilities. As
shown previously, for example with Equation 2, probabilities are aggregated using p = 
as a combination operator, and projected using p = + as an elimination operator.
But plausibilities can also be expressed as possibility degrees in [0, 1]. Possibilities are
eliminated using p = max and usually combined using p = min. An interesting case
appears when possibility degrees are booleans describing which states of the environment
are completely possible or impossible. Plausibilities are then combined using p =  and
eliminated using p = .
Another example is Spohns epistemic beliefs, also known as -rankings (kappa rankings, Spohn, 1990; Wilson, 1995; Giang & Shenoy, 2000). In this case, plausibilities are
elements of N  {+} called surprise degrees, 0 is associated with non-surprising situations,
+ is associated with completely surprising (impossible) situations, and more generally a
surprise degree k can be viewed as a probability of k for an infinitesimal . Surprise degrees
are combined using p = + and eliminated using p = min.
To capture these various plausibility modeling frameworks, we start from FriedmanHalperns work on plausibility measures (Friedman & Halpern, 1995; Halpern, 2001). Weydert (1994) and Darwiche-Ginsberg (1992) developed similar approaches.
Friedman-Halperns structure Assume we want to express plausibilities over the assignments of a set of variables S. Each subset of dom(S) is called an event. Friedman and
Halpern (1995) define plausibilities as elements of a set Ep called the plausibility domain.
Ep is equipped with a partial order p and with two special elements 0p and 1p satisfying
0p p p p 1p for all p  Ep . A function P l : 2dom(S)  Ep is a plausibility measure over S
iff it satisfies P l() = 0p , P l(dom(S)) = 1p , and (W1  W2 )  (P l(W1 ) p P l(W2 )). This
means that 0p is associated with impossibility, 1p is associated with the highest plausibility
degree, and the plausibility degree of a set is as least as high as the plausibility degree of
each of its subsets.
Among all plausibility measures, we focus on so-called algebraic conditional plausibility
measures, which use abstract functions p and p which are analogous to + and  for
probabilities. These measures satisfy properties such as decomposability: for all disjoint
events W1 , W2 , P l(W1  W2 ) = P l(W1 ) p P l(W2 ). As  is associative and commutative,
it follows that p is associative and commutative on representations of disjoint events, i.e.
(a p b) p c = a p (b p c) and a p b = b p a if there exist pairwise disjoint sets
W1 , W2 , W3 such that P l(W1 ) = a, P l(W2 ) = b, P l(W3 ) = c. More details are available in
Friedman-Halperns references (Friedman & Halpern, 1995; Halpern, 2001).
Restriction of Friedman-Halperns structure An important aspect in FriedmanHalperns work is that the algebraic properties of p and p hold only on the domains

432

fiThe PFU Framework

of definition of p and p . Although this is sufficient to express and manipulate plausibilities, it can be algorithmically restrictive. Indeed, consider a Bayesian network involving two
that Px1 is a constant
boolean variables {x1 , x2 } and define Px1 ,x2 as Px1  Px2 | x1 . Assume
P
 Px2 | x1 ((x2 , t)) must
factor 0 = 0.5. In order to evaluate Px2 ((x2 , t)), the quantity x1 0 P
be computed. To do so, it is simpler to factor it and compute 0  x1 Px2 | x1 ((x2 , t)). If
Px2 | x1 ((x2 , t).(x1 , t)) = 0.6 and Px2 | x1 ((x2 , t).(x1 , f )) = 0.8, the answer is 0.5(0.6+0.8) =
0.7. Performing 0.6 + 0.8 requires applying addition outside of the range of usual probabilities, for which a p b is defined only if a + b  1, since two probabilities whose sum exceeds
1 cannot be associated with disjoint events.
To take such issues into account, we adapt Friedman-Halperns Ep , p , p so that p
and p become closed in Ep and so that Friedman-Halperns axioms hold in the closed
structure. Once this closure is performed, we obtain a plausibility structure.
Definition 14. A plausibility structure is a tuple (Ep , p , p ) such that
 (Ep , p , p ) is a commutative semiring (identities for p and p are denoted 0p and
1p respectively),
 Ep is equipped with a partial order p such that 0p = min(Ep ) and such that p and
p are monotonic with respect to p .
Elements of Ep are called plausibility degrees
Note that 1p is not necessarily the maximal element of Ep . For probabilities, FriedmanHalperns structure would be ([0, 1], +0 , ), where a +0 b = a + b if a + b  1 and is
undefined otherwise. In order to get closed operators, we take (Ep , p , p ) = (R+ , +, )
and therefore 1p = 1 is not the maximal element in Ep . In some cases, Friedman-Halperns
structure is already closed. This is the case with -rankings (where (Ep , p , p ) = (N 
{+}, min, +)) and with possibilities (where (Ep , p , p ) is typically ([0, 1], max, min),
although other choices like ([0, 1], max, ) are possible).
Given two plausibility structures (Ep , p , p ) and (Ep0 , 0p , 0p ), if we define E = Ep Ep0 ,
(p1 , p01 )  (p2 , p02 ) = (p1 p p2 , p01 0p p02 ) and (p1 , p01 )  (p2 , p02 ) = (p1 p p2 , p01 0p p02 ), then
(E, , ) is a plausibility structure too. This allows us to deal with different kinds of plausibilities (such as probabilities and possibilities) or with families of probability distributions.
4.2.1 From Plausibility Measures to Plausibility Distributions
Let us consider a plausibility measure (Friedman & Halpern, 1995; Halpern, 2001) P l :
2dom(S)  Ep over a set of variables S. Assume that P l(W1  W2 ) = P l(W1 ) p P l(W2 )
for all disjoint sets W1 , W2  2dom(S) , as is the case with Friedman-Halperns algebraic
plausibility measures. This assumption entails that P l(W ) = p AW P l({A}) for all W 
2dom(S) . This holds even for W =  since 0p is the identity for p . Hence, defining
P l({A}) for all complete assignments A of S suffices to describe P l. Moreover, in this
case, the three conditions defining plausibility measures (P l(dom(S)) = 1p , P l() = 0p ,
and (W1  W2 )  (P l(W1 ) p P l(W2 ))) are equivalent to just p Adom(S) P l({A}) = 1p ,
using the monotonicity of p for the third condition. This means that we can deal with
plausibility distributions instead of plausibility measures:

433

fiPralet, Verfaillie, & Schiex

Definition 15. A plausibility distribution over S is a function PS : dom(S)  Ep such
that p Adom(S) PS (A) = 1p .
The normalization condition imposed on plausibility distributions is simply a generalization of the convention that probabilities sum up to 1. It captures the fact that the
disjunction of all the assignments of S has 1p as a plausibility degree.
Proposition 1. A plausibility distribution PS can be extended to give a plausibility distribution PS 0 over every S 0  S, defined by PS 0 = p SS 0 PS .
4.3 Feasibility Structure
Feasibilities define whether a decision is possible or not, and are therefore expressed as
booleans in {t, f }. This set is equipped with the total order bool satisfying f bool t.
Boolean scoped functions expressing feasibilities are combined using the operator ,
since an assignment of decision variables is feasible iff all feasibility functions agree that
this assignment is feasible.
Given a scoped function Fi expressing feasibilities, we can compute whether an assignment A of a set S of variables is feasible according to Fi by computing sc(Fi )S Fi (A), since
A is feasible according to Fi iff one of its extensions over sc(Fi ) is feasible. This means that
the projection of feasibility functions onto a smaller scope uses the elimination operator .
As a result, feasibilities are expressed using the feasibility structure Sf = ({t, f }, , ).
Sf is not only a commutative semiring, but also a plausibility structure. Therefore, all
plausibility notions and properties apply to feasibility. We may therefore speak of feasibility distributions, and the normalization condition S FS = t imposed on a feasibility
distribution FS over S means that at least one decision must be feasible.
4.4 Utility Structure
Utilities express preferences and can take various forms. Typically, utilities can be combined
with +. But utilities can also model priorities combined using min. Also, when utilities
represent hard requirements such as goals to be achieved or properties to be satisfied, they
can be modeled as booleans combined using . More generally, utility degrees are defined as
elements of a set Eu equipped with a partial order u . Smaller utility degrees are associated
with less preferred events. Utility degrees are combined using an operator u which is
assumed to be associative and commutative. This guarantees that combined utilities do
not depend on the way combination is performed. We also assume that u admits an
identity 1u  Eu , representing indifference. This ensures the existence of a default utility
degree when there are no utility scoped functions. These properties are captured in the
following notion of utility structure.
Definition 16. (Eu , u ) is a utility structure iff it is a commutative monoid and Eu is
equipped with a partial order u . Elements of Eu are called utility degrees.
Eu may have a minimum element u representing unacceptable events and which will
be an annihilator for u (the combination of any event with an unacceptable one must be
unacceptable too). u is also usually monotonic. But these properties are not necessary to
establish the forthcoming results.
434

fiThe PFU Framework

The distinction between plausibilities, feasibilities, and utilities is important and can
be justified using algebraic arguments. Since p and u may be different operators (for
example, p =  and u = + in usual probabilities with additive utilities), we must
distinguish plausibilities and utilities. It is also necessary to distinguish feasibilities from
utilities or plausibilities. Indeed, imagine a simple card game involving two players P1 and
P2 , each having three cards: a jack J, a queen Q, and a king K. P1 must first play one
card x  {J, Q, K}, then P2 must play a card y  {J, Q, K}, and last P1 must play a card
z  {J, Q, K}. A rule forbids to play the same card consecutively (feasibility functions Fxy :
x 6= y and Fyz : y 6= z). The goal for P1 is that his two cards x and z have a value strictly
better than P2 s card y. By setting J < Q < K, this requirement corresponds to two utility
functions Uxy : x > y and Uyz : z > y. In order to compute optimal decisions in presence of
unfeasibilities, we must restrict optimizations (eliminations of decision variables with max
or min) to feasible values: instead of maxx miny maxz (Uxy  Uyz ), we must compute:



max
min
max
(Uxy (a, b)  Uyz (b, c))
,
adom(x)

bdom(y),Fxy (a,b)=t

cdom(z),Fyz (b,c)=t

which, by setting f  t, is logically equivalent to


max min Fxy  max (Fyz  (Uxy  Uyz )) .
x

y

z

In the latter quantity, feasibility functions concerning P2 s play (y) are taken into account
using logical connective , so that P2 s unfeasible decisions are ignored in the set of all
scenarios considered. Feasibility functions concerning P1 s last move (z) are taken into account using , so that P1 does not consider scenarios in which he achieves a forbidden move.
Therefore, feasibility functions cannot be handled simply by using the same combination
operator as for utility functions: we need to dissociate what is unfeasible for all decision
makers (unfeasibility is absolute) from what is unacceptable or required for one decision
maker only (utility is relative), i.e. what a decision maker wants from what a decision maker
can do.
At a more general level, for example when Uxy and Uyz are soft requirements or when we
do not know exactly in advance who controls which variable, the logical connectives  and
 cannot be used anymore. In order to ignore unfeasible values in decision variables elimination, we use the truncation operator ? introduced in Definition 6. In order to eliminate a
variable x from a scoped function  while ignoring unfeasibilities indicated by a feasibility
function Fi , we simply perform the elimination of x on (Fi ? ) instead of . This maps
unfeasibilities to value , which is ignored by elimination operators (see Definition 6). On
the example above, if Uxy and Uyz were additive gains and costs, we would compute


max min Fxy ? max (Fyz ? (Uxy + Uyz )) .
x

y

z

4.5 Combining Plausibilities and Utilities via Expected Utility
To define expected utilities, plausibilities and utilities must be combined. Consider a
situation where a utility ui is obtained with a plausibility pi for all i  [1, N ], with

435

fiPralet, Verfaillie, & Schiex

p1 p . . . p pN = 1p . L = ((p1 , u1 ), . . . , (pN , uN )) is classically called a lottery (von Neumann & Morgenstern, 1944). When we speak of expected utility, we implicitly speak of the
expected utility EU (L) of a lottery L.
The standard way to combine plausibilities and utilities is to use the
P probabilistic expected utility (von Neumann & Morgenstern, 1944) defining EU (L) as i[1,N ] (pi  ui ): it
aggregates plausibilities and utilities using the combination operator pu =  and projects
the aggregated information using the elimination operator u = +. However, alternative
definitions exist:
 If plausibilities are possibilities, then EU (L) = mini[1,N ] max(1  pi , ui ) with the
possibilistic pessimistic expected utility (Dubois & Prade, 1995) (i.e. u = min and
pu : (p, u)  max(1p, u)) and EU (L) = maxi[1,N ] min(pi , ui ) with the possibilistic
optimistic expected utility (Dubois & Prade, 1995) (i.e. u = max and pu = min).
 If plausibilities are -rankings and utilities are positive integers (Giang & Shenoy,
2000), then EU (L) = mini[1,N ] (pi + ui ) (i.e. u = min and pu = +).
To generalize these definitions of EU (L), we start from Chu-Halperns work on generalized expected utility (Chu & Halpern, 2003a, 2003b).
Chu-Halperns structure Generalized expected utility is defined in an expectation domain, which is a tuple (Ep , Eu , Eu0 , u , pu ) such that: (1) Ep is a set of plausibility degrees
and Eu is a set of utility degrees; (2) pu : Ep  Eu  Eu0 combines plausibilities with
utilities and satisfies 1p pu u = u; (3) u : Eu0  Eu0  Eu0 is a commutative and associative
operator which can aggregate the information combined using pu .
When a decision problem is additive, i.e. when, for all plausibility degrees p1 , p2 associated with disjoint events, (p1 p p2 ) pu u = (p1 pu u) u (p2 pu u), the generic definition
of the expected utility of a lottery is:
EU (L) = u (pi pu ui ).
i[1,N ]

Classical expectation domains also satisfy additional properties such as u is monotonic and 0p pu u = 0u , where 0u is the identity of u .
Restriction of Chu-Halperns structure for sequential decision making If we
use pu : Ep  Eu  Eu0 and u : Eu0  Eu0  Eu0 to compute expected utilities at
the first decision step, then we need to introduce operators 0pu : Ep  Eu0  Eu00 and
0u : Eu00  Eu00  Eu00 to compute expected utilities at the second decision step. In the end, if
there are T decision steps, we must define T operators pu and T operators u . In order to
avoid the definition of an algebraic structure that would depend on the number of decision
steps, we take Eu = Eu0 and work with only one operator pu : Ep  Eu  Eu and one
operator u : Eu  Eu  Eu .
As for plausibilities, and for the sake of the future algorithms, we restrict Chu-Halperns
expectation domains (Ep , Eu , Eu , u , pu ) so that u and pu become closed and generalize
properties of the initial u and pu . However, this closure is not sufficient to deal with
sequential decision making, because Chu-Halperns expected utility is designed for one-step
decision processes only. This is why we introduce three additional axioms for u and pu :
436

fiThe PFU Framework

 The first axiom is similar to a standard axiom for lotteries (von Neumann & Morgenstern, 1944) defining compound lotteries. It states that if a lottery L2 involves a
utility u with plausibility p2 , and if one of the utilities of a lottery L1 is the expected
utility of L2 with plausibility p1 , then it is as if utility u had been obtained with
plausibility p1 p p2 . This gives the axiom p1 pu (p2 pu u) = (p1 p p2 ) pu u.
 We further require that pu distributes over u . To justify this point, assume that a
lottery L = ((p1 , u1 ), (p2 , u2 )) is obtained with plausibility p. Two different versions
of the contribution of L to the global utility degree can be derived: the first is p pu
((p1 pu u1 ) u (p2 pu u2 )), and the second, which uses compound lotteries, is ((p p
p1 ) pu u1 ) u ((p p p2 ) pu u2 ). We want these two quantities to be equal for all
p, p1 , p2 , u1 , u2 . This can be shown to be equivalent to a simpler property p pu (u1 u
u2 ) = (p pu u1 ) u (p pu u2 ), i.e. that pu distributes over u .
 Finally, we assume that pu is right monotonic (i.e. (u1 u u2 )  (p pu u1 u
p pu u2 )). This means that if an agent prefers (strictly or not) an event ev2 to
another event ev1 , and if both events have the same plausibility degree p, then the
contribution of ev2 to the global expected utility degree must not be lesser than the
contribution of ev1 .
These axioms define the notion of expected utility structure.
Definition 17. Let (Ep , p , p ) be a plausibility structure and let (Eu , u ) be a utility
structure. (Ep , Eu , u , pu ) is an expected utility structure iff
 (Eu , u , pu ) is a semimodule on (Ep , p , p ) (cf. Definition 12),
 u is monotonic for u and pu is right monotonic for u ((u1 u u2 )  (ppu u1 u
p pu u2 )).
Many structures considered in the literature are instances of expected utility structures,
as shown in Proposition 2. The results presented in the remaining of the article hold not only
for these usual expected utility structures, but more generally for all structures satisfying
the axioms specified in Definitions 14, 16, and 17.
Proposition 2. The structures in Table 1 are expected utility structures.
It is possible to define more complex expected utility structures from existing ones. For
example, from two expected utility structures (Ep , Eu , u , pu ) and (Ep0 , Eu0 , 0u , 0pu ), it is
possible to build a compound expected utility structure (Ep  Ep0 , Eu  Eu0 , 00u , 00pu ). This
can be used to deal simultaneously with probabilistic and possibilistic expected utility or
more generally to deal with tuples of expected utilities.
The business dinner example To flesh out these definitions, we consider the following
toy example, which will be referred to in the sequel. It does not correspond to a concrete
real-life problem, but is used for its simplicity. Peter invites John and Mary (a divorced
couple) to a business dinner in order to convince them to invest in his company. Peter
knows that if John is present at the end of the dinner, he will invest $10K. The same holds
for Mary with $50K. Peter knows that John and Mary will not come together (one of them
437

fiPralet, Verfaillie, & Schiex

1
2
3
4
5
6
7
8
9

Ep
R+
R+
[0, 1]
[0, 1]
N  {}
{t, f }
{t, f }
{t, f }
{t, f }

p





bool
bool
bool
bool

p
+
+
max
max
min





p


min
min
+





0p , 1p
0, 1
0, 1
0, 1
0, 1
, 0
f, t
f, t
f, t
f, t

Eu
R  {}
R+
[0, 1]
[0, 1]
N  {}
{t, f }
{t, f }
{t, f }
{t, f }

u





bool
bool
bool
bool

u
+

min
min
+





u
+
+
max
min
min





pu
0u , 1u

0, 0

0, 1
min
0, 1
max(1p, u) 1, 1
+
, 0

f, t

t, t

f, f

t, f

Table 1: Expected utility structures for: 1. probabilistic expected utility with additive
utilities (allows the probabilistic expected utility of a cost or a gain to be computed); 2. probabilistic expected utility with multiplicative utilities, also called
probabilistic expected satisfaction (allows the probability of satisfaction of some
constraints to be computed); 3. possibilistic optimistic expected utility; 4. possibilistic pessimistic expected utility; 5. qualitative utility with -rankings and
with only positive utilities; 6. boolean optimistic expected utility with conjunctive utilities (allows one to know whether there exists a possible world in which all
goals of a set of goals G are satisfied); bool denotes the order on booleans such
that f bool t; 7. boolean pessimistic expected utility with conjunctive utilities
(allows one to know whether in all possible worlds, all goals of a set of goals G are
satisfied); 8. boolean optimistic expected utility with disjunctive utilities (allows
one to know whether there exists a possible world in which at least one goal of a
set of goals G is satisfied); 9. boolean pessimistic expected utility with disjunctive
utilities (allows one to know whether in all possible worlds, at least one goal of a
set of goals G is satisfied).

has to baby-sit their child), that at least one of them will come, and that the case John
comes and Mary does not occurs with a probability of 0.6. As for the menu, Peter can order
fish or meat for the main course, and white or red for the wine. However, the restaurant
does not serve fish and red wine together. John does not like white wine and Mary does not
like meat. If the menu does not suit them, they will leave the dinner. If John comes, Peter
does not want him to leave the dinner because he is his best friend.
Example. The dinner problem uses the expected utility structure representing probabilistic
expected additive utility (row 1 in Table 1): the plausibility structure is (R+ , +, ), u = +,
pu = , and utilities are additive gains ((Eu , u ) = (R  {}, +), with the convention
that u + () = ).
4.6 Relation with Existing Structures
If we compare the algebraic structures defined with existing ones (Friedman & Halpern,
1995; Halpern, 2001; Chu & Halpern, 2003a), we can observe that:

438

fiThe PFU Framework

 The structures defined here are less general than Friedman-Chu-Halperns, since additional axioms are introduced. For example, plausibility structures are not able to
model belief functions (Shafer, 1976), which are not decomposable, whereas this is
possible using Friedman-Halperns plausibility measures (however, the authors are
not aware of existing schemes for decision theory using belief functions). Moreover, for one-step decision processes, Chu-Halperns generalized expected utility is
more general, since it assumes that pu : Ep  Eu  Eu0 whereas we consider
pu : Ep  Eu  Eu .
 Conversely, the structures defined here can deal with multi-step decision processes
whereas Chu-Halperns generalized expected utility is designed for one-shot decision
processes. Beyond this, other axioms, such as the use of closed operators, are essentially motivated by operational reasons. We use a less expressive structure for the
sake of future algorithms (cf. Section 8).
As a set Ep of plausibility degrees and a set Eu of utility degrees are defined, plausibilities and utilities must be cardinal. Purely ordinal approaches such as CP-nets (Boutilier,
Brafman, Domshlak, Hoos, & Poole, 2004), which, like Bayesian networks, exploit the notion of conditional independence to express a network of purely ordinal preference relations,
are not covered.
As pu takes values in Eu , it is implicitly assumed that plausibilities and utilities are
commensurable: works from Fargier and Perny (1999), describing a purely ordinal approach,
where qualitative preferences and plausibilities are not necessarily commensurable, are not
captured either. Also, works from Giang and Shenoy (2005), which satisfy all required
associativity, commutativity, identity, annihilator, and distributivity properties, are not
covered because they implicitly use pu : Ep  Eu  Eu0 with Eu 6= Eu0 (even if the
expected utility EU (L) = (p1 pu u1 ) u (p2 pu u2 ) of a lottery L = ((p1 , u1 ), (p2 , u2 )) stays
in Eu ).
Furthermore, some axioms entail that only distributional plausibilities are covered (the
plausibility of a set of variable assignments is determined by the plausibilities of each covered
complete assignment): Dempster-Shafer belief functions (Shafer, 1976) or Choquet expected
utility (Schmeidler, 1989) are not encompassed. Finally, as only one partial order u on Eu
is defined, it is assumed that the decision makers share the same preferences over utilities.
4.7 Summary
In this section, we have introduced expected utility structures, which are the first element
of the PFU framework. They specify how plausibilities are combined and projected (using
p and p respectively), how utilities are combined (using u ), and how plausibilities and
utilities are aggregated to define generalized expected utility (using u and pu ). The
structure chosen is inspired by Friedman-Chu-Halperns plausibility measures and generalized expected utility. The main differences lie in the addition of axioms to deal with
multi-step decision processes and in the use of extended domains to have closed operators,
motivated by operational reasons.

439

fiPralet, Verfaillie, & Schiex

5. Plausibility-Feasibility-Utility Networks
The second element of the PFU framework is a network of scoped functions Pi , Fi , and
Ui (cf. Equation 8) over a set of variables V . This network defines a compact and structured representation of the state of the environment, of the decisions, and of the global
plausibilities, feasibilities, and utilities which hold over them.
In the rest of the article, a plausibility function denotes a scoped function to Ep (the
set of plausibility degrees), a feasibility function is a scoped function to {t, f } (the set
of feasibility degrees), and a utility function, a scoped function to Eu (the set of utility
degrees).
5.1 Variables
In structured representations, decisions are represented using decision variables, which are
directly controlled by an agent, and the state of the environment is represented by environment variables, which are not directly controlled by an agent. The notion of agent used
here is restricted to cooperative and adversarial decision makers (if there is an uncertainty
on the way a decision maker behaves, then the decisions he controls will be modeled as
environment variables). We use VD to denote the set of decision variables and VE to denote
the set of environment variables. VD and VE form a partition of V .
Example. The dinner problem can be modeled using six variables: bpJ and bpM (value t
or f ), representing Johns and Marys presence at the beginning, epJ and epM (value t or
f ), representing their presence at the end, mc (value f ish or meat), representing the main
course choice, and w (value white or red), representing the wine choice. Thus, we have
VD = {mc, w} and VE = {bpJ , bpM , epJ , epM }.
5.2 Decomposing Plausibilities and Feasibilities into Local Functions
Using combined local functions to represent a global one raises some considerations: how
and when such local functions can be obtained from a global one, and conversely, when
such local functions are directly used, which implicit assumptions on the global function
are made. We now show that all these questions boil down to the notion of conditional
independence. In the following definitions and propositions, (Ep , p , p ) corresponds to a
plausibility structure.
5.2.1 Preliminaries: Generalization of Bayesian Networks Results
Assume that we want to express a global plausibility distribution PS (cf. Definition 15)
as a combination of local plausibility functions Pi . As work on Bayesian networks (Pearl,
1988) has shown, the factorization of a joint distribution is essentially related to the notion of conditional independence. To introduce conditional independence, we first define
conditional plausibility distributions.
Definition 18. A plausibility distribution PS over S is said to be conditionable iff there
exists a set of functions denoted PS1 | S2 (one function for each pair S1 , S2 of disjoint subsets
of S) such that if S1 , S2 , S3 are disjoint subsets of S, then

440

fiThe PFU Framework

(a) for all assignments A of S2 such that PS2 (A) 6= 0p , PS1 | S2 (A) is a plausibility distribution over S1 ,3
(b) PS1 |  = PS1 ,
(c) p S1 PS1 ,S2 | S3 = PS2 | S3 ,
(d) PS1 ,S2 | S3 = PS1 | S2 ,S3 p PS2 | S3 ,
(e) (PS1 ,S2 ,S3 = PS1 | S3 p PS2 | S3 p PS3 )  (PS1 ,S2 | S3 = PS1 | S3 p PS2 | S3 ).
PS1 | S2 is called the conditional plausibility distribution of S1 given S2 .
Condition (a) means that conditional plausibility distributions must be normalized.
Condition (b) means that the information given by an empty set of variables does not
change the plausibilities over the states of the environment. Condition (c) means that
conditional plausibility distributions are consistent from the marginalization point of view.
Condition (d) is the analog of the so-called chain rule with probabilities. Condition (e) is a
kind of weak division axiom.4
Proposition 3 gives simple conditions on a plausibility structure, satisfied in all usual
frameworks, that suffice for plausibility distributions to be conditionable.
Definition 19. A plausibility structure (Ep , p , p ) is called a conditionable plausibility
structure iff it satisfies the axioms:
 if p1 p p2 and p2 6= 0p , then max{p  Ep | p1 = p p p2 } exists and is p 1p ,
 if p1 p p2 , then there exists a unique p  Ep such that p1 = p p p2 ,
 if p1 p p2 , then there exists a unique p  Ep such that p2 = p p p1 .
Proposition 3. If (Ep , p , p ) is a conditionable plausibility structure, then all plausibility distributions are conditionable: it suffices to define PS1 | S2 by PS1 | S2 (A) = max{p 
Ep | PS1 ,S2 (A) = p p PS2 (A)} for all A  dom(S1  S2 ) satisfying PS2 (A) 6= 0p .
The systematic definition of conditional plausibility distributions given in Proposition 3
fits with the usual definitions of conditional distributions, which are, with probabilities,
PS1 | S2 (A) = PS1 ,S2 (A)/PS2 (A), with -rankings, PS1 | S2 (A) = PS1 ,S2 (A)  PS2 (A),
and with possibility degrees combined using min, PS1 | S2 (A) = PS1 ,S2 (A) if PS1 ,S2 (A) <
PS2 (A), 1 otherwise. In the following, every conditioning statement PS1 | S2 for conditionable plausibility structures will refer to the canonical notion of conditioning given in
Proposition 3. Conditional independence can now be defined.
3. To avoid specifying that properties of PS1 | S2 hold only for assignments A of S1  S2 satisfying PS2 (A) 6=
0p , we use expressions such as PS1 | S2 =  to denote A  dom(S1  S2 ), (PS2 (A) 6= 0p ) 
(PS1 | S2 (A) = (A)).
4. Compared to Friedman and Halperns conditional plausibility measures (Friedman & Halpern, 1995;
Halpern, 2001), (c) is the analog of axiom (Alg1), (d) is the analog of axiom (Alg2), (e) is the analog of
axiom (Alg4), and axiom (Alg3) corresponds to the distributivity of p over p .

441

fiPralet, Verfaillie, & Schiex

Definition 20. Let (Ep , p , p ) be a conditionable plausibility structure. Let PS be a
plausibility distribution over S and S1 , S2 , S3 be disjoint subsets of S. S1 is said to be
conditionally independent of S2 given S3 , denoted I(S1 , S2 | S3 ), iff PS1 ,S2 | S3 = PS1 | S3 p
PS2 | S3 .
This means that S1 is conditionally independent of S2 given S3 , iff the problem can be
split into one part depending on S1 and S3 , and another part depending on S2 and S3 .5
This definition satisfies the usual properties of conditional independence, as Proposition 4
shows.
Proposition 4. I(., . | .) satisfies the semigraphoid axioms:
1. symmetry: I(S1 , S2 | S3 )  I(S2 , S1 | S3 ),
2. decomposition: I(S1 , S2  S3 | S4 )  I(S1 , S2 | S4 ),
3. weak union: I(S1 , S2  S3 | S4 )  I(S1 , S2 | S3  S4 ),
4. contraction: (I(S1 , S2 | S4 )  I(S1 , S3 | S2  S4 ))  I(S1 , S2  S3 | S4 ).
Proposition 4 makes it possible to use Bayesian network techniques to express information in a compact way. With Bayesian networks, a DAG of variables is used to represent
conditional independences between the variables (Pearl, 1988). In some cases, such as image
processing and statistical physics, it is more natural to express conditional independences
between sets of variables. If probabilities are used, such situations can be modeled using chain graphs (Frydenberg, 1990). In a chain graph, the DAG defined is not a DAG of
variables, but a DAG of sets of variables, called components. Conditional probability distributions Px | paG (x) of variables are replaced by conditional probability distributions Pc | paG (c)
of components, each Pc | paG (c) being expressed in a factored form c1 c2 . . .ckc . Markov
random fields (Chellappa & Jain, 1993) correspond to the case in which there is Q
a unique
component equal to V , and in which the factored form of PV looks like 1/Z  jJ eHj
(Gibbs distribution).
We now formally introduce DAGs over sets of variables, called DAGs of components,
and then use them to factor plausibility distributions.
Definition 21. A DAG G is said to be a DAG of components over a set of variables S iff
the vertices of G form a partition of S. C(G) denotes the set of components of G. For each
c  C(G), paG (c) denotes the set of variables included in the parents of c in G, and ndG (c)
denotes the set of variables included in the non-descendant components of c in G.
Definition 22. Let (Ep , p , p ) be a conditionable plausibility structure. Let PS be a
plausibility distribution over S and let G be a DAG of components over S. G is said to
be compatible with PS iff I(c, ndG (c)  paG (c) | paG (c)) for all c  C(G) (c is conditionally
independent of its non-descendants given its parents).
5. Definition 20 differs from Halperns, which is S1 is conditionally independent (CI) of S2 given S3 iff
PS1 | S2 ,S3 = PS1 | S3 and PS2 | S1 ,S3 = PS2 | S3 . Halpern (2001) called the definition we adopt noninteractivity (NI) and showed that NI is weaker than CI. This implies that NI is satisfied more often
and may lead to more factorizations. Halpern gave a simple axiom (axiom (Alg4)) under which CI and
NI are equivalent. Though this axiom holds in many usual frameworks, it does not hold with possibility
degrees combined using min, a case covered by the PFU algebraic structure.

442

fiThe PFU Framework

Theorem 1. (Conditional independence and factorization) Let (Ep , p , p ) be a conditionable plausibility structure and let G be a DAG of components over S.
(a) If G is compatible with a plausibility distribution PS over S, then PS = p cC(G) Pc | paG (c) .
(b) If, for all c  C(G), there is a function c,paG (c) such that c,paG (c) (A) is a plausibility
distribution over c for all assignments A of paG (c), then S = p cC(G) c,paG (c) is a
plausibility distribution over S with which G is compatible.
Theorem 1 links conditional independence and factorization. Theorem 1(a) is a generalization of the usual result of Bayesian networks (Pearl, 1988) which says that if a DAG
of variables
is compatible with a probability distribution PS , then PS can be factored as
Q
PS = xS Px | paG (x) . Theorem 1(b) is a generalization of the standard result of Bayesian
networks (Pearl, 1988) which says that, given a DAG G of variables
Q in S, if conditional
probabilities Px | paG (x) are defined for each variable x  S, then xS Px | paG (x) defines a
probability distribution over S with which G is compatible. Both results are generalizations
since they hold for arbitrary plausibility distributions (and not for probability distributions
only). Results similar in spirit are provided by Halpern (2001), who gives some conditions
under which a plausibility measure can be represented by a Bayesian network.
Theorem 1(a) entails that, in order to factor a global plausibility distribution PS , it
suffices to define a DAG of components compatible with it, i.e. to express conditional
independences. To define such a DAG, the following systematic procedure can be used.
The initial DAG of components is an empty DAG G. While C(G) = {c1 , . . . , ck1 } is not a
partition of S, do:
1. Let Sk = c1  . . .  ck1 ; choose a subset ck of the set S  Sk of variables not already
considered.
2. Add ck as a component to G and find a minimal subset pak of Sk such that I(ck , Sk 
pak | pak ). Add edges directed from components containing at least one variable in
pak to ck , so that paG (ck ) = (c{c1 ,...,ck1 })/(cpak 6=) c.
The resulting DAG of components is guaranteed to be compatible with PS , which implies, using Theorem 1(a), that the local functions Pi representing PS can simply be defined
as the functions in the set {Pc | paG (c) , c  C(G)}. In practice, if there is a reasonable notion
of causes and effects, then networks that are smaller or somehow easier to build can be
obtained by using the following two heuristics in order to choose ck at each step of the
procedure above:
(R1) Consider causes before effects: in the dinner problem, this suggests not putting epJ
in ck if its causes bpJ and w are not in Sk .
(R2) Gather in a component variables that are correlated even when all variables in Sk are
assigned : bpJ and bpM are correlated and (R1) does not apply. Indeed, we cannot
say that bpJ has a causal influence on bpM , or that bpM has a causal influence on bpJ ,
since which of Mary or John chooses first if (s)he baby-sits is not specified. We can
even assume that bpJ and bpM are correlated via an unmodeled common cause, such

443

fiPralet, Verfaillie, & Schiex

as a coin toss that determines the baby-sitter. Hence, bpJ and bpM can be put in the
same component c = {bpJ , bpM }.6
We say that (R1) and (R2) build a DAG respecting causality. They must be seen just as
possible mechanisms that help in identifying conditional independences by using the notions
of causes and effects.
All the previous results extending Bayesian networks results to plausibility distributions
also apply to feasibilities. Indeed, the feasibility structure Sf = ({t, f }, , ) is a particular
case of a conditionable plausibility structure, since it satisfies the axioms of Definition 19.
We may therefore speak of conditional feasibility distribution. If S is a set of decision
variables, the construction of a DAG compatible with a feasibility distribution FS leads to
the factorization FS = cC(G) Fc | paG (c) .
5.2.2 Taking the Differenty Types of Variables into Account
The material defined in the previous subsection enables us to factor one plausibility distribution PVE defined over the set VE of environment variables and one feasibility distribution
FVD defined over the set VD of decision variables. However, dealing with just one plausibility
distribution over VE and one feasibility distribution over VD is not sufficient.
Indeed, for plausibilities, decision variables can influence the environment (for example,
the health state of a patient depends on the treatment chosen for him by a doctor). Rather
than expressing one plausibility distribution over VE , we want to express a family of plausibility distributions over VE , one for each assignment of VD . To make this clear, we define
controlled plausibility distributions.
Definition 23. A plausibility distribution over VE controlled by VD (or just a controlled
plausibility distribution), denoted PVE || VD , is a function dom(VE  VD )  Ep , such that
for all assignments AD of VD , PVE || VD (AD ) is a plausibility distribution over VE .
For feasibilities, it goes the other way around: the values of environment variables can
constrain the possible decisions (for example, an unmanned aerial vehicle which is flying
cannot take off). Thus, we want to express a family of feasibility distributions over VD ,
one for each assignment of VE . In other words, we want to express a controlled feasibility
distribution FVD || VE .
In order to directly reuse Theorem 1 for controlled distributions, we introduce the notion
of the completion of a controlled distribution. This allows us to extend a distribution to
the full set of variables V by assigning the same plausibility (resp. feasibility) degree to
every assignment of VD (resp. VE ), and to work with only one plausibility (resp. feasibility)
distribution.
6. Components such as {bpJ , bpM } could be broken by assuming for example that bpM causally influences
bpJ , i.e. that Mary chooses if she baby-sits first. We can (and prefer to) keep the component as
{bpJ , bpM } because, in general, breaking components can increase the scopes of the functions involved.
For example, assume that we want to model plausibilities over variables representing colors of pixels of
an N  N image, such that the color of a pixel probabilistically depends on the colors of its 4 neighbors
only. With a component approach, results of Markov random fields (Chellappa & Jain, 1993) show that
the local functions obtained have scopes of size 5 only, whereas with a component-breaking mechanism,
the size of the largest scope is linear in N .

444

fiThe PFU Framework

Proposition 5. Let (Ep , p , p ) be a conditionable plausibility structure. Then, for all
n  N , there exists a unique p0 such that p i{1,...,n} p0 = 1p .
Definition 24. Let (Ep , p , p ) be a conditionable plausibility structure and let PVE || VD be
a controlled plausibility distribution. Then, the completion of PVE || VD is a function denoted
PVE ,VD , defined by PVE ,VD = PVE || VD p p0 , where p0 is the unique element of Ep such that
p i[1,|dom(VD )|] p0 = 1p (the cardinality of a set  is denoted ||).
In other words, PVE ,VD is defined from PVE || VD by assigning the same plausibility degree
p0 to all assignments of VD . In the case of probability theory, it corresponds to saying that
the assignments of VD are equiprobable. The definition of the completion of a controlled
plausibility distribution could be made more flexible: instead of defining a uniform plausibility distribution over VD , we could define a plausibility distribution such that no assignment
of VD has 0p as a plausibility degree. We arbitrarily choose the uniform distribution, the
goal being just to introduce some prior plausibilities over decision variables, for the sake of
factorization.
Proposition 6. Let PVE ,VD be the completion of a controlled plausibility distribution PVE || VD .
Then, PVE ,VD is a plausibility distribution over VE  VD and PVE | VD = PVE || VD .
As a result, we use PVE | VD to denote PVE || VD (and this is equivalent). Similarly, it is
possible to complete a controlled feasibility distribution FVD || VE .
5.2.3 A First Factorization
Proposition 7 below, entailed by Theorem 1(a), shows how to obtain a first factorization of
PVE | VD and FVD | VE .
Definition 25. A DAG G is a typed DAG of components over VE  VD iff the vertices of
G form a partition of VE  VD such that each element of this partition is a subset of either
VD or VE . Each vertex of G is called a component. The set of components contained in
VE (environment components) is denoted CE (G) and the set of components contained in VD
(decision components) is denoted CD (G).
Proposition 7. Let G be a typed DAG of components over VE  VD . Let Gp be the partial
graph of G induced by the arcs of G incident to environment components. Let Gf be the
partial graph of G induced by the arcs of G incident to decision components. If Gp is
compatible with the completion of PVE || VD (cf. Definition 22) and Gf is compatible with
the completion of FVD || VE , then
PVE | VD =

p Pc | paG (c)
cCE (G)

and FVD | VE =


cCD (G)

Fc | paG (c) .

This allows us to specify local Pi and Fi functions: it suffices to express each Pc | paG (c)
and each Fc | paG (c) to express PVE | VD and FVD | VE in a compact way. In fact, we could have
defined two DAGs, one for the factorization of PVE | VD and the other for the factorization
of FVD | VE , but these two DAGs can actually always be merged as soon as we make the
(undemanding) assumption that it is impossible, given x  VD and y  VE , that both x
influences y and y constrains the possible decision values for x. This assumption ensures
that the union of the two DAGs does not create cycles. We use just one DAG for simplicity.
445

fiPralet, Verfaillie, & Schiex

Example. Consider the dinner problem to illustrate the first factorization step. One way
to obtain G is to use the causality-based reasoning described after Theorem 1. We start
with an empty DAG. As epJ and epM are both effects of bpJ , bpM , w, or mc, they are not
considered in the first component c1 . bpJ can be chosen as a variable to add to c1 , because
we cannot say that bpJ is necessarily an effect of another variable. As previously explained,
bpJ can be a cause of bpM , or an effect of bpM , or bpJ may be correlated with bpM via an
unmodeled cause. As a result, we get c1 = {bpJ , bpM } as a first component. Obviously, c1
has no parents in the DAG because it is the first added component.
Then, as epJ and epM are effects of w or mc, we do not consider epJ or epM in the
second component c2 . Since w is not necessarily an effect of mc, we can add w to c2 . The
dinner problem specifies that ordering fish and red wine simultaneously is not feasible, but
we do not know whether the wine is chosen before or after the main course, i.e. w can
be a cause or an effect of mc. As a result, we take c2 = {mc, w}. As the menu choice is
independent from who is present at the beginning, c2 has no parent in the temporary DAG.
As epJ is a direct effect of bpJ and w only (John leaves the dinner if white wine is
chosen), we can add epJ to c3 . Moreover, epJ is not correlated with epM when c1  c2 =
{bpJ , bpM , mc, w} is assigned. Therefore, we take c3 = {epJ }. Given that epJ depends both
on bpJ and w, c3 gets {bpJ , bpM } and {mc, w} as parents. Finally, c4 = {epM }, and as epM
depends on bpM and mc (Mary leaves if meat is chosen) and is independent of epJ given bpM
and mc, we have that I({epM }, {epJ , bpJ , w} | {bpM , mc}). This entails that {epM } is added
to the DAG with {bpJ , bpM } and {mc, w} as parents. Therefore, we get CD (G) = {{mc, w}}
as the set of decision components and CE (G) = {{bpJ , bpM }, {epJ }, {epM }} as the set of
environment components. The DAG of components is shown in Figure 1a.
Using Proposition 7, we know that the joint probability distribution factors as PVE | VD =
PbpJ ,bpM  PepJ | bpJ ,bpM ,mc,w  PepM | bpJ ,bpM ,mc,w and that the joint feasibility distribution
can be factored as FVD | VE = Fmc,w .
5.2.4 Further Factorization Steps
Proposition 7 provides us with a decomposition of PVE | VD and FVD | VE based on the conditional independence relation I(., . | .) of Definition 20. It may be possible to perform further
factorization steps by factoring each Pc | paG (c) as a set of local plausibility functions Pi and
factoring each Fc | paG (c) as a set of local feasibility functions Fi .
 In some cases, expressing factors of Pc | paG (c) or Fc | paG (c) is quite natural. For example, if p = , if variables in an environment component c = {xi,j | i, j  [1, n]}
without parents represent pixel colors, and if we want to model in Pc that two
adjacent pixels have different colors, it is natural to define a set of binary differ
ence constraints xi,j ,xk,l and
to
factor
P
as
P
=




c
c
x
,x
i[1,n1]
j[1,n]
i,j
i+1,j

i[1,n] j[1,n1] xi,j ,xi,j+1 . Such a decomposition cannot be obtained based only
on the conditional independence relation I(., . | .) of Definition 20.
 In some settings, as in Markov random fields (Chellappa & Jain, 1993), systematic
techniques exist to obtain such factorizations. The Bayesian network community
also offers systematic techniques: with hybrid networks (Dechter & Larkin, 2001),
we can extract the deterministic information contained in conditional probability
distributions. More precisely, a conditional probability distribution Px | paG (x) can
446

fiThe PFU Framework

be expressed as Px | paG (x) = Px | paG (x)  , where  is the 0-1 function defined by

0 if Px | paG (x) (A) = 0
(A) =
. The factorization of Px | paG (x) as Px | paG (x)   can
1 otherwise
be computationally relevant when constraint propagation techniques on 0-1 functions
are used to solve hybrid networks.
 We may use another weaker definition of conditional independence: in valuation-based
systems (Shenoy, 1994), S1 and S2 are said to be conditionally independent given S3
with regard to a function S1 ,S2 ,S3 if this function factors into two scoped functions
with scopes S1  S3 and S2  S3 . This definition is not used for the first factorization
step because it destroys the normalization conditions which may be useful from a
computational point of view.
These additional factorization steps are of interest because decreasing the size of the
scopes of the functions involved or adding redundant information in the problem can be
computationally useful.
For every environment component c, if Pi  F act(c) stands for Pi is a factor of
Pc | paG (c) , the second factorization gives us
Pc | paG (c) =

p
Pi .
Pi F act(c)

As p c Pc | paG (c) = 1p , the Pi functions in F act(c) satisfy the normalization condition
p c (p Pi F act(c) Pi ) = 1p . Their scopes sc(Pi ) are contained in sc(Pc | paG (c) ) = c  paG (c).
For every decision component c, if Fi  F act(c) stands for Fi is a factor of Fc | paG (c) ,
the second factorization gives us
Fc | paG (c) =



Fi F act(c)

Fi .

Given that c Fc | paG (c) = t, the Fi functions in F act(c) satisfy the normalization condition
c Fi F act(c) Fi = t. Moreover, sc(Fi )  c  paG (c).
Other factorizations, which do not decrease the scopes of the functions involved, could
also be exploited. Indeed, each scoped function Pi or Fi can itself have an internal local
structure, as for instance when Pi is a noisy-OR gate (Pearl, 1988) in a Bayesian network,
or in presence of context-specific independence (Boutilier, Friedman, Goldszmidt, & Koller,
1996). Such internal local structures can be made explicit by representing functions with
tools such as Algebraic Decision Diagrams (Bahar, Frohm, Gaona, Hachtel, Macii, Pardo,
& Somenzi, 1993). In the rest of the article, we do not make any assumption on the way
each scoped function is represented.
Example. PbpJ ,bpM can be expressed in terms of a first plausibility function P1 specifying the probability of John and Mary being present at the beginning. P1 is defined
by P1 ((bpJ , t).(bpM , f )) = 0.6, P1 ((bpJ , f ).(bpM , t)) = 0.4, and P1 ((bpJ , t).(bpM , t)) =
P1 ((bpJ , f ).(bpM , f )) = 0. We can also add redundant deterministic information with a second plausibility function P2 defined as the constraint bpJ 6= bpM (P2 (A) = 1 if the constraint
is satisfied, 0 otherwise). We get PbpJ ,bpM = P1 p P2 and F act({bpJ , bpM }) = {P1 , P2 }.

447

fiPralet, Verfaillie, & Schiex

PepJ | bpJ ,bpM ,mc,w can be specified as a combination of two plausibility functions P3 and
P4 . P3 expresses that if John is absent at the beginning, he is absent at the end: P3 is the
hard constraint (bpJ = f )  (epJ = f ) (P3 (A) = 1 if the constraint is satisfied, 0 otherwise).
Then, P4 : (bpJ = t)  ((epJ = t)  (w 6= white)) is a hard constraint specifying that
John leaves iff white wine is chosen. Hence, we have PepJ | bpJ ,bpM ,mc,w = P3 p P4 and
F act({epJ }) = {P3 , P4 }. Similarly, PepM | bpJ ,bpM ,mc,w = P5 p P6 , with P5 , P6 defined as
constraints, and F act({epM }) = {P5 , P6 }.
As for feasibilities, Fmc,w can be specified by a feasibility function F1 expressing that ordering fish with red wine is not allowed: F1 : ((mc = f ish)(w = red)) and F act({mc, w})
= {F1 }. The association of local functions with components appears in Figure 1a.
5.3 Local Utilities
Local utilities can be defined over the states of the environment only (as in the utility of
the health state of a patient), over decisions only (as in the utility of the decision of buying
a car or not), or over the states of the environment and decisions (as in the utility of the
result of a horse race and a bet on the race).7
In order to specify local utilities, one standard approach, used in CSPs and influence
diagrams, is to directly define a set U of local utility functions, modeling preferences or
hard requirements, over decision and environment variables. This set implicitly defines a
global utility UV = uUi U Ui over all variables. If this factored form is obtained from
a global joint utility, one may rely, when u = +, on the work of Fishburn (1982) and
Bacchus-Grove (1995), who introduced a notion of conditional independence for utilities.
No normalization condition is imposed on local utilities.
Example. In the dinner problem, three local utility functions can be defined. A binary
utility function U1 expresses that Peter does not want John to leave the dinner: U1 is
the hard constraint (bpJ = t)  (epJ = t) (U1 (A) = 0 if the constraint is satisfied, 
otherwise). Two unary utility functions U2 and U3 over epJ and epM respectively express the
gains expected from the presences at the end: U2 ((epJ , t)) = 10 and U2 ((epJ , f )) = 0 (John
invests $10K if he is present at the end), while U3 ((epM , t)) = 50 and U3 ((epM , f )) = 0
(Mary invests $50K if she is present at the end). U2 and U3 can be viewed as soft constraints.
All the local functions are represented in a graphical model in Figure 1b.
5.4 Formal Definition of PFU Networks
We can now formally define Plausibility-Feasibility-Utility networks. The definition is justified by the previous construction process, but it holds even if the plausibility structure is
not conditionable.
7. In influence diagrams, special nodes called value nodes are introduced to represent the outcome of
decisions, and one utility function is associated with each of these value nodes (the utility of the outcome).
In the PFU framework, we directly represent such utility functions as scoped functions which hold on
the parents of value nodes. This explicitly express that utility functions are scoped functions, just as
plausibility and feasibility functions. In other words, utility functions are directly utilities of the outcome
of decision and environment variables assignments.

448

fiThe PFU Framework

P4
mc, w

bpJ , bpM
P1 , P 2

F1

w
F1

epJ

epM

P3 , P 4

P5 , P 6

(a)

mc

bpJ

P3

environment

P2 U1

P1

bpM

P5

decision

epJ
U2

plausibility
function

epM

P6

feasibility
function

U3

utility
function

(b)

Figure 1: (a) DAG of components (b) Network of scoped functions.
Definition 26. A Plausibility-Feasibility-Utility network on an expected utility structure
is a tuple N = (V, G, P, F, U ) such that the following conditions hold:
 V = {x1 , x2 , . . .} is a finite set of finite domain variables. V is partitioned into VD
(decision variables) and VE (environment variables);
 G is a typed DAG of components over VE  VD (cf. Definition 25);
 P = {P1 , P2 , . . .} is a finite set of plausibility functions. Each Pi  P is associated with a unique component c  CE (G) such that sc(Pi )  c  paG (c). The set of
Pi  P associated with a component c  CE (G) is denoted F act(c) and must satisfy
p (p Pi F act(c) Pi ) = 1p ;
c

 F = {F1 , F2 , . . .} is a finite set of feasibility functions. Each function Fi is associated
with a unique component c  CD (G) such that sc(Fi )  c  paG (c). The set of
Fi  F associated
 with a component c  CD (G) is denoted F act(c) and must satisfy
 Fi F act(c) Fi = t;
c

 U = {U1 , U2 , . . .} is a finite set of utility functions.
5.5 From PFU Networks to Global Functions
We have seen how to obtain a PFU network expressing a global controlled plausibility
distribution PVE || VD , a global controlled feasibility distribution FVD || VE , and a global utility
UV . Conversely, let N = (V, G, P, F, U ) be a PFU network, i.e. a set of variables, a typed
DAG of components, and sets of scoped functions. Then
 the global function  = p Pi P Pi is a controlled plausibility distribution of VE given
VD . Moreover, by Theorem 1(b), if the plausibility structure is conditionable and if
Gp is the partial DAG of G induced by the arcs incident to environment components,
then Gp is compatible with the completion of ;
 the global function  = Fi F Fi is a controlled feasibility distribution of VD given
VE . Moreover, by Theorem 1(b), if Gf is the partial DAG of G induced by the arcs of
G incident to decision components, then Gf is compatible with the completion of ;
449

fiPralet, Verfaillie, & Schiex

  = uUi U Ui is necessarily a global utility.
We can therefore denote  by PVE || VD ,  by FVD || VE , and  by UV .
5.6 Back to Existing Frameworks
Let us consider the formalisms described in Section 3 again.
 A CSP (hard or soft) can easily be represented as a PFU network N = (V, G, , , U ):
all variables in V are decision variables, G is reduced to a single decision component
containing all variables, and constraints are represented by utility functions. Using
feasibility functions to represent constraints, it would be impossible to represent inconsistent networks because of the normalization conditions on feasibilities. SAT is
modeled similarly; the only difference is that constraints are replaced by clauses.
 The same PFU network as above is used to represent the local functions of a quantified
boolean formula or of a quantified CSP. The differences with CSPs or SAT appear
when we consider queries on the network (see Section 6).
 A Bayesian network can be modeled as N = (V, G, P, , ): all variables in V are
environment variables, G is the DAG of the BN, and P = {Px | paG (x) , x  V }. There
is no feasibility or utility function. A chain graph is also modeled as N = (V, G, P, , ),
with G the DAG of components of the chain graph and P the set of factors of each
Pc | paG (c) .
 A stochastic CSP is represented by a PFU network N = (V, G, P, , U ), where V
is partitioned into VD , the set of decision variables, and VE , the set of stochastic
variables, G is a DAG which depends on the relations between the stochastic variables,
P is the set of probability distributions over the stochastic variables, and U is the set
of constraints.
 An influence diagram can be modeled by N = (V, G, P, , U ) such that VD contains
the decision variables, VE contains the chance variables, G is the DAG of the influence
diagram without the utility nodes and with arcs into random variables only (i.e. we
keep only the so-called influence arcs), and P = {Px | paG (x) , x  VE }. There are no
feasibilities, and one utility function Ui is defined per utility variable u, the scope
of Ui being paG (u). To represent valuation networks, a set F of feasibility functions
is added. Note that the business dinner example could not have been modeled using a standard influence diagram, since influence diagrams cannot model feasibilities
(suitable extensions exist however, Shenoy, 2000).
 A finite horizon probabilistic MDP can be modeled as N = (V, G, P, F, U ). If there are
T time-steps, then VD = {dt , t  [1, T ]}{s1 } and VE = {st , t  [2, T ]};8 G is a DAG of
components such that (a) each component contains one variable, (b) the unique parent
of a decision component {dt } is {st }, (c) the parents of an environment component
{st+1 } are {st } and {dt }; P = {Pst+1 |st ,dt , t  [1, T  1]}, F = {Fdt | st , t  [1, T ]}, and
U = {Rst ,dt , t  [1, T ]}. Modeling a finite horizon possibilistic MDP is similar.
8. As there is no plausibility distribution over the initial state s1 , s1 is not viewed as an environment
variable. This corresponds to the special case where decision variables model problem parameters.

450

fiThe PFU Framework

5.7 Summary
In this section, we have introduced the second element of the PFU framework: a network of
variables linked by local plausibility, feasibility, and utility functions, with a DAG capturing
normalization conditions. The factorization of global plausibilities, feasibilities, and utilities
into scoped functions was linked to conditional independence.

6. Queries on a PFU Network
A query will correspond to a reasoning task on the information expressed by a PFU network.
If decision variables are involved in the PFU network considered, answering a query may
provide decision rules. Examples of informal queries about the dinner problem are
1. What is the best menu choice if Peter does not know who is present at the beginning?
2. What is the best menu choice if Peter knows who is present at the beginning?
3. How should we maximize the expected investment if the restaurant chooses the main
course first and Peter is pessimistic about this choice, then who is present at the
beginning is observed, and last Peter chooses the wine?
Dissociating PFU networks from queries is consistent with the trend in the influence diagram community to relax the so-called information links, as in Unconstrained Influence
Diagrams (Jensen & Vomlelova, 2002) or Limited Memory Influence Diagrams (Lauritzen
& Nilsson, 2001): it explains the intuition that queries do not change the local relations
between variables.
In this section, we define a simple class of queries on PFU networks. We assume that
a sequence of decisions must be performed, and that the order in which decisions and
observations are made is known. We also make a no-forgetting assumption, that is, when
making a decision, an agent is aware of all previous decisions and observations. From
now on, the set of utility degrees Eu is assumed to be totally ordered. This total order
assumption, which holds in most of the standard frameworks, implies that there always
exists an optimal decision rule. See Subsection 6.7 for a discussion of how to extend the
results to a partial order.
Two definitions of the answer to a query are given, the first based on decision trees,
and the second more operational. An equivalence between these two definitions is then
established.
6.1 Query Definition
In order to formulate reasoning tasks on a PFU network, we use a sequence Sov of operatorvariable(s) pairs. This sequence captures different aspects of the query:
 Partial observabilities: Sov specifies the order in which decisions are made and environment variables are observed. If x  VE appears to the left of y  VD (for example
Sov = . . . (u , {x}) . . . (max, {y}) . . .), this means that the value of x is known (observed) when a value for y is chosen. Conversely, Sov = . . . (max, {y}) . . . (u , {x}) . . .
if x is not observed when choosing y.
451

fiPralet, Verfaillie, & Schiex

 Optimistic/pessimistic attitude concerning the decision makers: (max, {y}) is inserted
in the elimination sequence if the decision maker is optimistic about the behavior of
the agent controlling a decision variable y (i.e. if this agent is cooperative), and
(min, {y}) if one is pessimistic (i.e. if the agent controlling y is an adversary). The
operator used for environment variables will always be u , to model that expected
utilities are sought.9
 Parameters of the decision making problem: the set S of variables that are not involved
in Sov are kind of parameters. Their absence indicates that we want to obtain optimal
expected utilities and/or optimal policies for each assignment of S. This is useful in
order to evaluate several scenarios simultaneously.
Example. The sequence corresponding to the informal query: How should we maximize the
expected investment if the restaurant chooses the main course first and Peter is pessimistic
about this choice, then those present at the beginning of the dinner are observed, and last
Peter chooses the wine before knowing who is present at the end? is
Sov = (min, {mc}).(u , {bpJ , bpM }).(max, {w}).(u , {epJ , epM }).
It models the fact that: (1) Peter is pessimistic about the main course (min over mc), which
is chosen without observing any variable (no variable to the left of mc in Sov); (2) Peter
makes the best choice of wine (max over w) after the main course has been chosen and
after knowing who is present at the beginning (w appears to the right of mc, bpJ , and bpM
in Sov), but before knowing who is present at the end (w appears to the left of epJ , epM ).
Specifically, bpJ and bpM are partially observable, whereas epJ and epM are unobservable.
If the query becomes What should Peter do if he observes those present at the beginning
of the dinner and then chooses the wine before knowing who is present at the end?, then
the sequence to use is Sov = (u , {bpJ , bpM }).(max, {w}).(u , {epJ , epM }). In this case,
variable mc does not appear in the sequence anymore, which means that mc is a parameter
and that an answer for each value of this parameter is sought.
Definition 27. A query on a PFU network is a pair Q = (N , Sov) where N is a PFU
network and Sov = (op1 , S1 )(op2 , S2 )    (opk , Sk ) is a sequence of operator-set of variables
pairs such that
(1) all the Si are disjoint;
(2) either Si  VD and opi = min or max, or Si  VE and opi = u ;
(3) variables not involved in any of the Si , called free variables, are decision variables;
(4) for all variables x, y of different types (one is a decision variable, the other is an
environment variable), if there is a directed path from the component which contains
x to the component which contains y in the DAG of the PFU network N , then x does
not appear to the right of y in Sov, i.e. either x appears to the left of y, or x is a free
variable.
9. If a decision is made by nature and if we have a plausibility distribution on that decision, then this
decision will be viewed as an environment variable.

452

fiThe PFU Framework

Condition (1) ensures that each variable is eliminated at most once. Condition (2) means
that optimal decisions are sought for decision variables (either maximized if the decision
maker who controls a decision variable is cooperative, or minimized if he is adversarial),
whereas expected utilities are sought for environment variables. Condition (3) means that
variables which are not eliminated in Sov act as problem parameters and are viewed as
decision variables. Condition (4) means that if x and y are of different types and x is an
ancestor of y, then x is assigned before y. This ensures that causality is respected for variables of different types: for example, (N , (u , {bpJ , bpM , epJ , epM }).(max, {mc, w})), which
violates condition (4), violates causality since the menu cannot be chosen after knowing who
is present at the end.
Variables appearing in Sov are called quantified variables, by analogy with quantified
boolean formulas. The set of free variables is denoted by Vf r . Notice that the definition of
queries does not prevent an environment variable from being quantified by min or max,
because we may have u = min or u = max. Note also that it is straightforward that for
every PFU network N , there exists at least one query on N without free variables.
For all i  [1, k], we define
 the set l(Si ) of variables appearing in Vf r or to the left of Si in Sov by l(Si ) =
Vf r  (j[1,i1] Sj );
 the set r(Si ) of variables appearing to the right of Si in Sov by r(Si ) = j[i+1,k] Sj .
6.2 Semantic Answer to a Query
In this subsection, we assume that the plausibility structure is conditionable (cf. Definition 19). The controlled plausibility distribution PVE || VD = p Pi P Pi can then be completed (cf. Definition 24) to give a plausibility distribution PVE ,VD over VE  VD . Similarly,
the controlled feasibility distribution FVD || VE = Fi F Fi can be completed to give a feasibility distribution FVE ,VD over VE  VD . We also use the global utility UV = uUi U Ui
defined by the PFU network.
Imagine that we want to answer the query Q = (N , Sov), where N is the network of
the dinner problem and Sov = (min, {mc}).(u , {bpJ , bpM }).(max, {w}).(u , {epJ , epM }).
To answer such a query, we can use a decision tree. First, the restaurant chooses the
worst possible main course, taking into account the feasibility distribution of mc. Here,
Fmc ((mc, meat)) = Fmc,w ((mc, meat).(w, white))  Fmc,w ((mc, meat).(w, red)) = t  t =
t. Similarly, Fmc ((mc, f ish)) = t. Both choices are feasible. Then, if A1 denotes the
assignment of mc, the uncertainty over those present at the beginning given the main
course choice is described by the probability distribution PbpJ ,bpM | mc (A1 ). For each possible
assignment A2 of {bpJ , bpM }, i.e. for each A2 such that PbpJ ,bpM | mc (A1 .A2 ) 6= 0p , Peter
chooses the best wine while taking into account the feasibility Fw | mc,bpJ ,bpM (A1 .A2 ): if
the restaurant chooses meat, Peter chooses an optimal value between red and white, and
if the restaurant chooses fish, Peter can choose white wine only. Then, for each feasible
assignment A3 of w, the uncertainty regarding the presence of John and Mary at the end
of the dinner is given by PepJ ,epM | bpJ ,bpM ,mc,w (A1 .A2 .A3 ).
Note that the conditional probabilities used in the decision tree above are not directly
defined by the network. They must be computed from the global distributions. This
computation can be a challenge in large problems.
453

fiPralet, Verfaillie, & Schiex

The utility UV (A1 .A2 .A3 .A4 ) can be associated with each possible complete assignment
A1 .A2 .A3 .A4 of the variables. For each possible assignment A1 .A2 .A3 of {bpJ , bpM , mc, w},
the last stage, i.e. the one in which epJ and epM are assigned,
P can be seen as a lottery (von
Neumann & Morgenstern, 1944) whose expected utility is A4 dom({epJ ,epM }) p(A4 )u(A4 ),
where p(A4 ) = PepJ ,epM | bpJ ,bpM ,mc,w (A1 .A2 .A3 .A4 ) and u(A4 ) = UV (A1 .A2 .A3 .A4 ). This
expected utility becomes the reward of the scenario over {bpM , bpJ , mc, w} described by
A1 .A2 .A3 . It provides us with a criterion for choosing an optimal value for w. The step
in which bpJ and bpM are assigned can then be seen as a lottery, which provides us with a
criterion for choosing a worst value for mc. The computation associated with the previously
described process is:
min
A1 dom(mc),Fmc (A1 )=t
X
PbpJ ,bpM | mc (A1 .A2 )
(
A2 dom({bpJ ,bpM }),PbpJ ,bpM

(

max
X

| mc (A1 .A2 )6=0

A3 dom(w),Fw | mc,bpJ ,bpM (A1 .A2 .A3 )=t

(

PepJ ,epM | bpJ ,bpM ,mc,w (A1 .A2 .A3 .A4 )

A4  dom({epJ , epM })
PepJ ,epM | bpJ ,bpM ,mc,w (A1 .A2 .A3 .A4 ) 6= 0

UV (A1 .A2 .A3 .A4 )))).

Decision rules for the decision variables (argmin and argmax) can be recorded during
the computation. This formulation represents the decision process as a decision tree in
which each internal level corresponds to variable assignments. Arcs associated with the
assignment of a set of decision variables are weighted by the feasibility of the decision given
the previous assignments. Arcs associated with the assignment of environment variables are
weighted by the plausibility degree of the assignment given the previous assignments. Leaf
nodes correspond to the utilities of complete assignments, and a node collects the values of
its children to compute its own value.
6.2.1 Formalization of the Decision Tree Procedure
In order to formalize the decision tree procedure, some technical results are first introduced
in Proposition 8. These results and the definitions preceding them can be skipped for a first
reading.
Definition 28. Let PS1 | S2 be the conditional plausibility distribution of S1 given S2 and let
A  dom(S2 ). The function PS1 | S2 (A) is said to be well-defined iff PS2 (A) 6= 0p . Similarly,
if FS1 | S2 is the conditional feasibility distribution of S1 given S2 , then, for all A  dom(S2 ),
FS1 | S2 (A) is said to be well-defined iff FS2 (A) = t.
Next, the conditioning can be defined directly for controlled plausibility distributions
because for all A  dom(VD ), PVE || VD (A) is a plausibility distribution over VE :
Definition 29. Assume that the plausibility structure used is conditionable. Let PVE || VD
be a controlled plausibility distribution and S, S 0 be two disjoint subsets of VE . We define
conditional controlled plausibility distributions by: for all A  dom(S  S 0  VD ) such that
PS 0 || VD (A) 6= 0p , PS | S 0 || VD (A) = max{p  Ep | PS,S 0 || VD (A) = p p PS 0 || VD (A)}, as in
the canonical definition of conditioning given in Proposition 3. Given a controlled feasi454

fiThe PFU Framework

bility distribution FVD || VE , the definition of conditional controlled feasibility distributions
FS | S 0 || VE for S, S 0 disjoint subsets of VD is similar.
Proposition 8. Assume that the plausibility structure used is conditionable. Let Q =
(N , Sov) be a query where Sov = (op1 , S1 )  (op2 , S2 )    (opk , Sk ). Let Vf r denote the set of
free variables of Q.
(1) If Si  VE and PSi | l(Si ) (A) is well-defined, then there exists at least one A0  dom(Si )
satisfying PSi | l(Si ) (A.A0 ) 6= 0p .
(2) If Si  VD and FSi | l(Si ) (A) is well-defined, then there exists at least one A0  dom(Si )
satisfying FSi | l(Si ) (A.A0 ) = t.
(3) If VE 6=  and Si is the leftmost set of environment variables appearing in Sov, then,
for all A  dom(l(Si )), PSi | l(Si ) (A) is well-defined.
(4) If i, j  [1, k], i < j, Si  VE , Sj  VE , r(Si )  l(Sj )  VD (Sj is the first set of environment variables appearing to the right of Si in Sov), (A, A0 )  dom(l(Si ))dom(Si ),
PSi | l(Si ) (A) is well-defined, and PSi | l(Si ) (A.A0 ) 6= 0p , then, for all A00 extending A.A0
over l(Sj ), PSj | l(Sj ) (A00 ) is well-defined.
(5) If i, j  [1, k], i < j, Si  VD , Sj  VD , r(Si )  l(Sj )  VE (Sj is the first set of
decision variables appearing to the right of Si in Sov), (A, A0 )  dom(l(Si ))dom(Si ),
FSi | l(Si ) (A) is well-defined, and FSi | l(Si ) (A.A0 ) = t, then, for all A00 extending A.A0
over l(Sj ), FSj | l(Sj ) (A00 ) is well-defined.
(6) For all i  [1, k] such that Si  VE , PSi | l(Si ) = PSi | l(Si )VE ||VD .
(7) For all i  [1, k] such that Si  VD , FSi | l(Si ) = FSi | l(Si )VD ||VE .
The technical results of Proposition 8 ensure that, in the following semantic answer to
a query (see Definition 30),
 all quantities PS | l(S) (A.A0 ) and FS | l(S) (A.A0 ) used are defined (thanks to items 3 to
5 in Proposition 8);
 all eliminations over restricted domains are defined because the restricted domains
used are never empty (items 1 and 2 in Proposition 8);
 the conditional distributions used coincide with a conditioning defined directly from
the controlled plausibility and feasibility distributions PVE || VD and FVD || VE (items 6
and 7 in Proposition 8). This is useful because this guarantees that PS | l(S) (A.A0 )
and FS | l(S) (A.A0 ), which a priori require the notion of completion to be written, are
actually independent of the notion of completion, which is arbitrarily added to the
basic information expressed in a PFU network. We use PS | l(S) and FS | l(S) instead
of conditional controlled distributions PS | l(S)VE || VD and FS | l(S)VD || VE for notation
convenience and to explicitly represent that PS | l(S)VE || VD and FS | l(S)VD || VE do not
depend on the assignment of VD  l(S) and VE  l(S) respectively.

455

fiPralet, Verfaillie, & Schiex

Definition 30. The semantic answer Sem-Ans(Q) to a query Q = (N , Sov) is a function
of the set Vf r of free variables of Q defined by10

 if FVf r (A) = f
Sem-Ans(Q)(A) =
Qs(N , Sov, A) otherwise,
with Qs inductively defined by:
(1)

Qs(N , , A) = UV (A)

(2)

Qs(N , (op, S) . Sov, A) =


min
Qs (N , Sov, A.A0 )

0

A  dom(S)



FS|l(S) (A.A0 ) = t




Qs (N , Sov, A.A0 )
max











A0  dom(S)
FS|l(S) (A.A0 ) = t

u

A0  dom(S)
PS|l(S) (A.A0 ) 6= 0p

if (S  VD )  (op = min),
if (S  VD )  (op = max),


PS|l(S) (A.A0 ) pu Qs (N , Sov, A.A0 )

if (S  VE ).

In other words, each step involving decision variables (first two cases) corresponds to an
optimization step among the feasible choices, and each step involving environment variables
(third case) corresponds to a lottery (von Neumann & Morgenstern, 1944) such that the
rewards are the Qs (N , Sov, A.A0 ), and such that the plausibility attributed to a reward is
PS | l(S) (A.A0 ) (the formula looking like ui (pi pu ui ) is the expected utility of this lottery).
When a set of decision variables S is eliminated, a decision rule for S can be recorded, using
an argmax (resp. an argmin) if max (resp. min) is performed.
Example. What is the maximum investment Peter can expect, and which associated decision(s) should he make if he chooses the menu without knowing who will attend? To answer
this question, we can use a query in which bpJ , bpM , epJ , and epM are eliminated before
mc and w to represent the fact that their values are not known when the menu is chosen.
This query is:
(N , (max, {mc, w}).(u , {bpJ , bpM , epJ , epM })).
The answer is $6K, with (mc, meat).(w, red) as a decision. If Peter knows who comes, the
query becomes
(N , (u , {bpJ , bpM }).(max, {mc, w}).(u , {epJ , epM })).
and optimal values for mc and w can depend on bpJ and bpM . The answer is $26K with
a $20K gain from the observability of who is present. The decision rule for {mc, w} is
(mc, meat).(w, red) if John is present and Mary is not, (mc, f ish).(w, white) otherwise.
Consider the query introduced at the beginning of Section 6.1:
(N , (min, {mc}).(u , {bpJ , bpM }).(max, {w}).(u , {epJ , epM })).
The answer is : in the worst main course case, even if Peter chooses the wine, the situation can be unacceptable. In order to compute the expected utility for each menu choice,
we can use a query in which mc and w are free variables:
10.  is the unfeasible value, cf. Definition 6.

456

fiThe PFU Framework

(N , (u , {bpJ , bpM , epJ , epM })).
The answer is a function of {mc, w}. These examples show how queries can capture various
situations in terms of partial observabilities, optimistic/pessimistic attitude, and parameters
in the decision process.
6.3 Operational Answer to a Query
The quantities PS | l(S) (A.A0 ) and FS | l(S) (A.A0 ) involved in the definition of the semantic answer to a query are not directly available from the local functions and can be very expensive
to compute. For instance, with
probabilities, PS | l(S) (A.A0 ) equals PS,l(S) (A.A0 )/Pl(S) (A).
P
0 00
Computing PS,l(S) (A.A0 ) =
A00 dom(V (Sl(S))) PVE ,VD (A.A .A ) typically requires time
exponential in |V  (S  l(S))|. Moreover, such quantities must be computed at each node
of the decision tree. Fortunately, there exists an alternative definition of the answer to
a query, which can be directly expressed using a PFU instance, i.e. the expressed local
plausibility, feasibility, and utility functions.
Definition 31. The operational answer Op-Ans(Q) to a query Q = (N , Sov) is a function
of the free variables of Q: if A is an assignment of the free variables, then (Op-Ans(Q))(A)
is defined inductively as follows:
(Op-Ans(Q))(A) = Qo (N , Sov, A)
Qo(N , (op, S) . Sov, A) = opA0 dom(S) Qo (N , Sov, A.A0 )
!



!
Qo(N , , A) =
 Fi ? p Pi pu u Ui
(A).
Fi F

Pi P

(9)
(10)

Ui U

By Equation 10, if all the problem variables are assigned, the answer to the query is the
combination of the plausibility degree, the feasibility degree, and the utility degree of the
corresponding complete assignment. By Equation 9, if the variables are not all assigned and
(op, S) is the leftmost operator-variable(s) pair in Sov, the answer to the query is obtained
by eliminating S using op as an elimination operator. Again, optimal decision rules for the
decision variables can be recorded if needed, using argmin and argmax. Equivalently, by
considering a sequence of operator-variable(s) pairs as a sequence of variable eliminations,
Op-Ans(Q) can be written:
!
!



Op-Ans(Q) = Sov
 Fi ? p Pi pu u Ui
.
Fi F

Pi P

Ui U

It shows that Op-Ans(Q) actually corresponds to the generic form of Equation 8.
6.4 Equivalence Theorem
Theorem 2 proves that the semantic definition Sem-Ans(Q) gives semantic foundations to
what is computed with the operational definition Op-Ans(Q).
Theorem 2. If the plausibility structure is conditionable, then, for all queries Q on a PFU
network, Sem-Ans(Q) = Op-Ans(Q) and the optimal policies for the decisions are the same
with Sem-Ans(Q) and Op-Ans(Q).
457

fiPralet, Verfaillie, & Schiex

In other words, Theorem 2 shows that it is possible to perform computations in a
completely generic algebraic framework, while providing the result of the computations with
decision-theoretic foundations. Due to this equivalence theorem, Op-Ans(Q) is denoted
simply by Ans(Q) in the following. Note that the operational definition applies even in
a non-conditionable plausibility structure. Giving a decision-theoretic-based semantics to
Op-Ans when the plausibility structure is not conditionable is an open issue.
6.5 Bounded Queries
It may be interesting to relax the problem of computing the exact answer to a query.
Assume that the leftmost operator-variable(s) pair in the sequence Sov is (max, {x}), with
x a decision variable. From the decision maker point of view, computing decision rules
providing an expected utility greater than a given threshold  may be sufficient. This is
the case with the E-MAJSAT problem, defined as Given a boolean formula over a set
of variables V = VD  VE , does there exist an assignment of VD such that the formula is
satisfied for at least half of the assignments of VE ?  Extending the generic PFU framework
to answer such queries is done in Definitions 32 and 33, which introduce bounded queries.
Definition 32. A bounded query B-Q is a triple (N , Sov, ), such that (N , Sov) is a query
and   Eu ( is the threshold).
Definition 33. The answer Ans(B-Q) to a bounded query B-Q = (N , Sov, ) is a boolean
function of the free variables of the unbounded query Q = (N , Sov). For every assignment
A of these free variables,

t if Ans(Q)(A) u 
(Ans(B-Q))(A) =
f otherwise.
As the threshold  may be used to prune the search space during the resolution, computing the answer to a bounded query is easier than computing the answer to an unbounded
one.
6.6 Back to Existing Frameworks
Let us consider again the frameworks of Section 3. Solving a CSP (Equation 1) or a totally
ordered soft CSP corresponds to the query Q = (N , (max, V )), with N the PFU network
corresponding to the CSP and V the set of variables of the CSP. Computing the probability
distribution of a variable y for a Bayesian network (Equation 2) modeled as N corresponds
to Q = (N , (+, V  {y}). These examples are mono-operator queries, involving only one
type of elimination operator.
Consider multi-operator queries. The search for an optimal policy for the stochastic
CSP associated with Equation 4 is captured by a query such as Q = (N , (max, {d1 , d2 })
.(+, {s1 }).(max, {d3 , d4 }).(+, {s2 })). The query on influence diagrams of Equation 5 and
the query on valuation networks of Equation 6 are captured the same way.
For a finite horizon MDP with T time-steps (Equation 7), the query looks like Q =
(N , (max, {d1 }).(u , {s2 }).(max, {d2 }) . . . (u , {sT }).(max, {dT })), where u = + with probabilistic MDPs and u = min with pessimistic possibilistic MDPs. The initial state s1 is a

458

fiThe PFU Framework

free variable. With a quantified CSP or a quantified boolean formula, elimination operators
min and max are used to represent  and .
More formally, we can show:
Theorem 3. Queries and bounded queries can be used to express and solve the following
list of problems:
1. SAT framework: SAT, MAJSAT, E-MAJSAT, quantified boolean formula, stochastic
SAT (SSAT) and extended-SSAT (Littman et al., 2001).
2. CSP (or CN) framework:
 Check consistency for a CSP (Mackworth, 1977); find a solution to a CSP; count
the number of solutions of a CSP.
 Find a solution of a valued CSP (Bistarelli et al., 1999).
 Solve a quantified CSP (Bordeaux & Monfroy, 2002).
 Find a conditional decision or an unconditional decision for a mixed CSP or a
probabilistic mixed CSP (Fargier et al., 1996).
 Find an optimal policy for a stochastic CSP or a policy with a value greater than
a threshold; solve a stochastic COP (Constraint Optimization Problem) (Walsh,
2002).
3. Integer Linear Programming (Schrijver, 1998) with finite domain variables.
4. Search for a solution plan with a length  k in a classical planning problem (STRIPS
planning, Fikes & Nilsson, 1971; Ghallab et al., 2004).
5. Answer classical queries on Bayesian networks (Pearl, 1988), Markov random fields
(Chellappa & Jain, 1993), and chain graphs (Frydenberg, 1990), with plausibilities
expressed as probabilities, possibilities, or -rankings:
 Compute plausibility distributions.
 MAP (Maximum A Posteriori hypothesis) and MPE (Most Probable Explanation).
 Compute the plausibility of an evidence.
 CPE task for hybrid networks (Dechter & Larkin, 2001) (CPE means CNF Probability Evaluation, a CNF being a formula in Conjunctive Normal Form).
6. Solve an influence diagram (Howard & Matheson, 1984).
7. With a finite horizon, solve a probabilistic MDP, a possibilistic MDP, a MDP based on
-rankings, completely or partially observable (POMDP), factored or not (Puterman,
1994; Monahan, 1982; Sabbadin, 1999; Boutilier et al., 1999, 2000).

459

fiPralet, Verfaillie, & Schiex

6.7 Towards More Complex Queries
Queries can be made more complex by relaxing some assumptions:
 In the definition of queries, the order u on Eu is assumed to be total. Extending
the results to a partial order is possible if (Eu , u ) defines a lattice (partially ordered
set closed under least upper and greatest lower bounds) and if pu distributes over
the least upper bound lub and greatest lower bound glb (i.e. p pu lub(u1 , u2 ) =
lub(p pu u1 , p pu u2 ) and p pu glb(u1 , u2 ) = glb(p pu u1 , p pu u2 )). This allows
semiring CSPs (Bistarelli et al., 1999) to be captured in the framework. We believe
that other extensions to partial orders on utilities should allow algebraic MDPs (Perny
et al., 2005) to be captured.
 We can try to relax the no-forgetting assumption, as in limited memory influence
diagrams (LIMIDs, Lauritzen & Nilsson, 2001), which show that this can be relevant
for decision processes involving multiple decision makers or memory constraints on
the policy recording. In such cases, optimal decisions can become nondeterministic
(decisions such as choose x = 0 with probability p and x = 1 with probability 1p).
 The order in which decisions are made and environment variables are observed is
total and completely determined by the query. One may wish to compute not only
an optimal policy for the decisions, but also an optimal order in which to perform
decisions, without exactly knowing the steps at which other agents make decisions or
the steps at which observations are made. Work on influence diagrams with unordered
decisions (Jensen & Vomlelova, 2002) is good starting point to try and extend our
work in this direction.
While it should be possible to relax the assumption that variables have a finite domain,
doing this is nontrivial, since transforming u = + into integrals is not straightforward,
and performing min- or max-eliminations over continuous domains requires the guarantee
of existence of a supremum.
6.8 Summary
In Section 6, the last element of the PFU framework, a class of queries on PFU networks, has
been introduced. A decision-tree based definition of the answer to a query has been provided.
The first main result of the section is Theorem 2, which gives theoretical foundations to
another equivalent operational definition, reducing the answer to a query to a sequence of
eliminations on a combination of scoped functions. The latter is best adapted to future
algorithms, because it directly handles the local functions defined by a PFU network. The
second important result is Theorem 3, which shows that many standard queries are PFU
queries. Overall, the PFU framework is captured by Definitions 14, 16, and 17 for algebraic
structures, Definition 26 for PFU networks, and Definitions 27 and 31 for queries.

7. Gains and Costs
A better understanding Theorem 3 shows that many existing frameworks are instances
of the PFU framework. Through this unification, similarities and differences between ex460

fiThe PFU Framework

isting formalisms can be analyzed. For instance, by comparing VCSPs and the optimistic
version of finite horizon possibilistic MDPs through the operational definition of the answer
to a query, it appears that a finite horizon optimistic possibilistic MDP (partially observable
or not) is a fuzzy CSP: both can indeed be represented as a query Q whose operational
answer looks like maxV (min ), where V is a set of variables and  is a set of scoped
functions. Techniques available for solving fuzzy CSPs can then be used to solve finite
horizon optimistic possibilistic MDPs.
From the complexity theory point of view, studying the time and space complexity for
answering queries of the form of Equation 8 can lead to upper bounds on the complexity
for several frameworks simultaneously. One may also try to characterize which properties
lead to a given theoretical complexity.
Increased expressive power The expressive power of PFU networks is the result of
a number of features: (1) flexibility of the plausibility/utility model; (2) flexibility of the
possible networks; (3) flexibility of the queries in terms of situation modeling. This enables
queries on PFU networks to cover generic finite horizon sequential decision problems with
plausibilities, feasibilities, and utilities, cooperative or adversarial decision makers, partial observabilities, and possible parameters in the decision process modeled through free
variables.
As none of the frameworks indicated in Theorem 3 presents such flexibility, for every
subsumed formalism X indicated in Theorem 3, it is possible to find a problem which can
be represented with PFUs but not directly with X. More specifically, compared to influence
diagrams (Howard & Matheson, 1984; Jensen & Vomlelova, 2002; Smith et al., 1993; Nielsen
& Jensen, 2003; Jensen et al., 2004) or valuation networks (VNs, Shenoy, 1992, 2000;
Demirer & Shenoy, 2001), PFUs can deal with more than the probabilistic expected additive
utility and allow us to perform eliminations with min to model the presence of adversarial
agents. Thus, quantified boolean formulas cannot be represented with influence diagrams
or VNs, but are covered by PFU networks (see Theorem 3). Moreover, PFU networks use a
DAG which captures the normalization conditions of plausibilities or feasibilities, whereas
with VNs, this information is lost. Compared to sequential influence diagrams (Jensen
et al., 2004) or sequential VNs (Demirer & Shenoy, 2001), PFUs can express some so-called
asymmetric decision problems (problems in which some variables may not even need to be
considered in a decision process) by adding dummy values to variables.
Actually, some simple problems which can be expressed with PFUs cannot be apparently
directly expressed in other frameworks. The simple instance feasibilities with normalization
conditions + hard requirements is not captured by any of the subsumed frameworks. For
example, using a CSP to model it would result in a loss of the information provided by
the normalization conditions on feasibilities. The same occurs for influence diagrams like sequential decision processes based on possibilistic expected utility, which could be
called possibilistic influence diagrams. Similarly for stochastic CSPs without contingency
assumption.
The cost of greater flexibility and increased expressive power is that the PFU framework
cannot be described as simply and straightforwardly as, for example, constraint networks.
Generic algorithms Section 8 shows that generic algorithms can be built to answer
queries on PFU networks. As previously said, building generic algorithms should facilitate
461

fiPralet, Verfaillie, & Schiex

cross-fertilization in the sense that any of the subsumed formalisms will directly benefit
from the techniques developed on another subsumed formalism. This fits into a growing
effort to generalize resolution methods used for different AI problems. For example, soft
constraint propagation drastically improves the resolution of valued CSPs; integrating such
a tool in a generic algorithm on PFUs could improve the resolution of influence diagrams.
Using abstract operators may enable us to identify algorithmically interesting properties,
or to infer necessary or sufficient conditions for a particular algorithm to be usable.
However, one could argue that some techniques are highly specific to one formalism or
to one type of problem, and that, in this case, dedicated approaches certainly outperform
a generic algorithm. A solution for this can be to characterize the actual properties used
by a dedicated approach, in order to generalize it as much as possible. Moreover, even if
specialized schemes usually improve over generic ones, there exist cases in which general
tools can be more efficient than specialized algorithms, as shown by the use of SAT solvers
for solving STRIPS planning problems (Sang, Beame, & Kautz, 2005).

8. Algorithms
The ability to design generic algorithms is one of the motivations for building the PFU
framework, and some choices are justified by algorithmic considerations. We present generic
algorithms that answer arbitrary PFU queries.
8.1 A Generic Tree Search Algorithm
The operational definition of the answer to a query Q actually defines a naive exponential
time algorithm to compute Ans(Q) using a tree-exploration procedure, with a variable
ordering given by Sov, that collects elementary plausibilities, feasibilities, and utilities.
More precisely, for each assignment A of the free variables of Q, a tree is explored. Each
node in this tree corresponds to a partial assignment of the variables. The value of a leaf
is provided by the combination of the scoped functions of the PFU network, applied to
the complete assignment defined by the path from the root to the leaf. Depending on
the operator used, the value of an internal node is computed by performing a min, max,
or u operation on the values of its children. The root node returns (Ans(Q))(A). The
corresponding pseudo-code is given in Figure 2. For a query (N , Sov), the first call is
TreeSearchAnswerQ(N , Sov). It returns a function of the free variables.
If we assume that every operator returns a result in a constant time, then the time
complexity of the algorithm is O(m  n  ln(d)  dn ), where d stands for the maximum domain
size, n stands for the number of variables of the PFU network, and m stands for the number
of scoped functions.11
The space complexity is polynomial (it can be shown to be linear in the entry data
size). Hence, computing the answer to a bounded query is PSPACE. Moreover, given that
the satisfiability of a QBF is a PSPACE-complete problem which can be expressed as a
bounded query (cf. Theorem 3), it follows that computing the answer to a bounded query
is PSPACE-hard. Being PSPACE and PSPACE-hard, the decision problem that consists of
11. The factor n  ln(d) corresponds to an upper bound on the time needed to get (A) for a scoped function
 represented as a table (of size  dn ).

462

fiThe PFU Framework

TreeSearchAnswerQ((V, G, P, F, U ), Sov)
begin
foreach A  dom(Vf r ) do (A)  AnswerQ((V, G, P, F, U ), Sov, A)
return 
end
AnswerQ((V, G, P, F, U ), Sov, A)
begin
if Sov =  then return ((Fi F Fi ) ? (p Pi P Pi ) pu (uUi U Ui ))(A)
else
(op, S).Sov 0  Sov
choose x  S
if S = {x} then Sov  Sov 0 else Sov  (op, S  {x}).Sov 0
dom  dom(x)
res  
while dom 6=  do
choose a  dom
dom  dom  {a}
res  op (res, AnswerQ((V, G, P, F, U ), Sov, A.(x, a)))
return res
end

Figure 2:
A generic tree search algorithm for answering a query Q
((V, G, P, F, U ), Sov)

=

answering a bounded query is PSPACE-complete. This result is not surprising, but it gives
an idea of the level of expressiveness which can be reached by the PFU framework. More
work is needed to identify subclasses of queries with a lower complexity, although many are
already known.
8.2 A Generic Variable Elimination Algorithm
Quite naturally, a generic variable elimination algorithm (Bertele & Brioschi, 1972; Shenoy,
1991; Dechter, 1999; Kolhas, 2003) can be defined to answer queries on a PFU network.
8.2.1 A First Naive Scheme
This first naive variable elimination algorithm is given in Figure 3. It eliminates variables
from the right to the left of the sequence Sov of the query, whereas with the tree search
procedure, variables are assigned from the left to the right. This right-to-left processing
entails that the algorithm naturally returns a function of the free variables of the query.
The first call is VarElimAnswerQ((V, G, P, F, U ), Sov).
The version presented in Figure 3 is actually a very naive variable elimination scheme
with time and space complexities O(m  n  ln(d)  dn ) and O(m  dn ) respectively: it begins
by combining all the scoped functions before eliminating variables, whereas the interest of
a variable elimination algorithm is primarily to use the factorization into local functions.

463

fiPralet, Verfaillie, & Schiex

VarElimAnswerQ((V, G, P, F, U ), Sov)
begin
0  ((Fi F Fi ) ? (p Pi P Pi ) pu (uUi U Ui ))
while Sov 6=  do
Sov 0 .(op, S)  Sov
choose x  S
if S = {x} then Sov  Sov 0 else Sov  Sov 0 .(op, S  {x})
0  opx 0
return 0
end

Figure 3: A first generic variable elimination algorithm for answering a query Q =
((V, G, P, F, U ), Sov)
8.2.2 Improving the Basic Scheme
The algorithm of Figure 3 works on a unique global function defined by the combination
of all the plausibility, feasibility, and utility functions (first line), whereas a factorization is
available. To improve this scheme, the properties of the algebraic structure can be used.
In the sequel, we denote by +x (resp. x ) a scoped function which has (resp. does not
have) x in its scope. Moreover, we extend every combination operator  on E  {} by
setting   e = e   =  (combining anything with something unfeasible is unfeasible
too).12
First, in order to use the factorization of plausibilities and feasibilities, we can use the
properties below, which come from the right monotonicity of pu , the distributivity of pu
over u , and the definition
truncation operator ?:
 of the x
min
(P
pu U ) = P x pu (minx U )
x




maxx (P x pu U ) = P x pu (maxx U )



ux (P x pu U ) = P x pu (ux U )
minx (F x ? U ) = F x ? (minx U )





maxx (F x ? U ) = F x ? (maxx U )


ux (F x ? U ) = F x ? (ux U ) .
They express that when a variable x is eliminated, it is not necessary to consider plausibility
functions or feasibility functions that do not have x in their scope.
However, it is necessary to add some axioms on the expected utility structure, since
in the general case, an expression such as ux (P +x pu (U x u U +x )) cannot be decomposed. We give two axioms, Ax1 and Ax2, each of which is a sufficient additional condition
to exploit the factorization of utility functions.
(Ax1) (Ep , p ) = (Eu , u ), p = u , p = u = pu
(Ax2) u = u on Eu (but not on Eu  {}).
12. An operator op can be used both as a combination operator between scoped functions and as an elimination operator over some variables. In this case, the extension of op used as a combination operator creates
an operator op0 such that op0 (e, ) = , whereas the extension of op used as an elimination operator
creates an operator op00 such that op00 (e, ) = e. op0 and op00 coincide on E but differ on E  {}.

464

fiThe PFU Framework

Among the cases in Table 1, rows 2, 3, 5, 6 satisfy Ax1, whereas rows 1, 4, 7, 8 satisfy
Ax2. Ax1 andAx2 enable us to write:
minx (F +x ? (U x u U +x )) = U x u (minx F +x ? U +x )
maxx (F +x ? (U x u U +x )) = U x u (maxx F +x ? U +x ) .
and
 x

U u (ux P +x pu U +x ) with Ax1
+x
x
+x
u P pu (U u U ) =
((p x P +x ) pu U x ) u (ux P +x pu U +x ) with Ax2.
x
Hence, when eliminating a variable x, it is not necessary to consider utility functions which
do not have x in their scope.
We present an algorithm when Ax1 is satisfied. When Ax2 holds, working on plausibility/utility pairs (p, u) allows Ax1 to be recovered: this is used, for example, to solve
influence diagrams (Ndilikilikesha, 1994). When Ax1 is satisfied, there is actually only one
set E = Ep = Eu , one order =p =u , one combination operator  = p = u = pu ,
and one elimination operator  = p = u . Rather than express feasibilities on {t, f }, we
can express them on {1E , } by mapping t onto 1E and f onto : this preserves the value
of the answer to a query, since f ? u =   u and t ? u = 1E  u.
The improved variable elimination algorithm is shown in Figure 4. To answer a query
Q = ((V, G, P, F, U ), Sov), the first call is Ax1-VarElimAnswerQ(P  F  U, Sov). It
returns a set of scoped functions whose -combination equals Ans(Q). This time, the
factorization available in a PFU network is exploited, since when eliminating a variable x,
only scoped functions involving x are considered.
Ax1-VarElimAnswerQ(, Sov)
begin
if Sov =  then return 
else
Sov 0 .(op, S)  Sov
choose x  S
if S = {x} then Sov  Sov 0 else Sov  Sov 0 .(op, S  {x})
+x  {   | x  sc()}
0  opx +x 
  (  +x )  {0 }
return Ax1-VarElimAnswerQ(, Sov)
end

Figure 4: Variable elimination algorithm when Ax1 holds (: set of scoped functions)
When Ax1 holds, the algorithm is actually a standard variable elimination algorithm on a
commutative semiring. As for classical variable elimination algorithms, the time complexity
of this algorithm is in O(m  n  ln(d)  dw+1 ), where w is the tree-width (Bodlaender, 1997;
Dechter & Fattah, 2001) of the network of scoped functions, constrained by the elimination
order imposed by Sov. Yet, its space complexity is also exponential in this tree-width.
8.3 Other Approaches
Starting from the generic tree-search algorithm of Section 8.1, bound computations and local
consistencies (Mackworth, 1977; Cooper & Schiex, 2004; Larrosa & Schiex., 2003) can be

465

fiPralet, Verfaillie, & Schiex

integrated in order to prune the search space. Local consistencies can improve the quality of
the bounds thanks to the use of smaller local functions. Techniques coming from quantified
boolean formulas or from game algorithms (such as the -algorithm) can be considered to
more efficiently manage bounds when min and max operators alternate. Caching strategies
exploiting the problem structure (Darwiche, 2001; Jegou & Terrioux, 2003) are also obvious
candidates to improve the basic tree search scheme. Additional axioms Ax1 and Ax2 can
be useful in this direction. Heuristics for the choice of the variable to assign when a pair
(op, S) is encountered, as well as heuristics for the value choices, may also speed up the
search.
In another direction, approximate algorithms using sampling and local search could also
be considered: sampling when eliminations with + (+, and not u ) are performed, local
search when eliminations with min or max are performed.

9. Conclusion
In the last decades, AI has witnessed the design and study of numerous formalisms for
reasoning about decision problems. In this article, we have built a generic framework
to model sequential decision making with plausibilities, feasibilities, and utilities. This
framework covers many existing approaches, including hard, valued, quantified, mixed, and
stochastic CSPs, Bayesian networks, finite horizon probabilistic or possibilistic MDPs, or
influence diagrams. The result is an algebraic framework built upon decision-theoretic
foundations: the PFU framework. The two facets of the PFU framework are explicit in
Theorem 2, which states that the operational definition of the answer to a query is equivalent
to the decision tree-based semantics. This is the result of a design that accounts both for
expressiveness and for computational aspects.
Compared to related works (Shenoy, 1991; Dechter, 1999; Kolhas, 2003), the PFU framework is the only framework which directly deals with different types of variables (decision
and environment variables), different types of local functions (plausibilities, feasibilities,
utilities), and different types of combination and elimination operators.
From an algorithmic point of view, generic algorithms based on tree search and variable
elimination have been described. They prove that the PFU framework is not just an abstraction. The next step is to explore ways of improving these algorithms, so as to generalize
techniques that are used in formalisms subsumed by the PFU framework. Along this line,
a generic approach to query optimization has lead to the definition of original architectures
for answering queries, called multi-operator cluster trees and multi-operator cluster DAGs.
These can be applied to QBFs and other structures compatible with Ax1 (Pralet, Schiex, &
Verfaillie, 2006a), as well as influence diagrams and other structures satisfying Ax2 (Pralet,
Schiex, & Verfaillie, 2006b).

Acknowledgments
We would like to thank Jean-Loup Farges, Jerome Lang, Regis Sabbadin, and the three
anonymous reviewers for useful comments on previous versions of this article. The work

466

fiThe PFU Framework

described in this article was initiated when the first author was at LAAS-CNRS and INRA
Toulouse. It was partially conducted within the EU Integrated Project COGNIRON (The
Cognitive Companion) and funded by the European Commission Division FP6-IST Future
and Emerging Technologies under Contract FP6-002020.

Appendix A. Notations
See Table 2.
Symbol

p
u

p
u
pu
p
u
?


VE
VD
dom(x)
dom(S)
G
paG (x)
ndG (x)
CE (G)
CD (G)
Pi
Fi
Ui
F act(c)
sc()
PS
PS1 | S2
FS
FS1 | S2

M eaning
Elimination operator
Elimination operator on plausibilities
Elimination operator on utilities
Combination operator
Combination operator for plausibilities
Combination operator for utilities
Combination operator between plausibilities and utilities
Partial order on plausibilities
Partial order on utilities
Truncation operator
Unfeasible value

Environment variables
Decision variables
Domain
of values of a variable x
Q
dom(x)
xS
Directed Acyclic Graph (DAG)
Parents of x in the DAG G
Non-descendant of x in the DAG G
Set of environment components of G
Set of decision components of G
Plausibility function
Feasibility function
Utility function
Pi or Fi factors associated with a component c
Scope of a local function 
Plausibility distribution over S
Conditional plausibility distribution of S1 given S2
Feasibility distribution over S
Conditional feasibility distribution of S1 given S2

Sov
Sequence of operator-variable(s) pairs
Sem-Ans(Q) Semantic answer to a query Q (decision trees)
Op-Ans(Q) Operational answer to a query Q
Ans(Q)
Answer to a query Q

Table 2: Notation.
467

fiPralet, Verfaillie, & Schiex

Appendix B. Proofs
Proposition 1 A plausibility distribution PS can be extended to give a plausibility distribution PS 0 over every S 0  S, defined by PS 0 = p SS 0 PS .
Proof. Given that p is associative and commutative, p S 0 PS 0 = p S 0 (p SS 0 PS ) = p S PS = 1p .
Thus, PS 0 : dom(S 0 )  Ep is a plausibility distribution over S 0 .

Proposition 2 The structures presented in Table 1 are expected utility structures.
Proof. It is sufficient to verify each of the required axioms successively.

Proposition 3 If (Ep , p , p ) is a conditionable plausibility structure, then all plausibility distributions are conditionable: it suffices to define PS1 | S2 by PS1 | S2 (A) = max{p 
Ep | PS1 ,S2 (A) = p p PS2 (A)} for all A  dom(S1  S2 ) satisfying PS2 (A) 6= 0p .
Proof. Let PS be a plausibility distribution over S. For all S1 , S2 disjoint subsets of S and for all
A  dom(S1  S2 ) satisfying PS2 (A) 6= 0p , let us define PS1 | S2 (A) = max{p  Ep | PS1 ,S2 (A) =
p p PS2 (A)}. We must show that the PS1 | S2 functions satisfy axioms a, b, c, d, e of Definition 18.
(a) By definition of PS1 | S2 and by distributivity of p over p , we can write
PS2 = p S1 PS1 ,S2 = p S1 (PS1 | S2 p PS2 ) = (p S1 PS1 | S2 ) p PS2 .
As PS2 p PS2 , we can infer that p S1 PS1 | S2 p 1p . Let A2 be an assignment of S2 satisfying
PS2 (A2 ) 6= 0p . Assume that the hypothesis (H): p S1 PS1 | S2 (A2 ) p 1p  holds.
Then, for all A1  dom(S1 ), PS1 ,S2 (A1 .A2 ) p PS2 (A2 ), since if PS1 ,S2 (A1 .A2 ) = PS2 (A2 ),
then PS1 | S2 (A1 .A2 ) = 1p , which implies that p S1 PS1 | S2 (A2 ) p 1p by the monotonicity of
p . Moreover, (H) implies that there exists a unique p  Ep satisfying (p S1 PS1 | S2 (A2 )) p
p = 1p . Combining this equation by PS2 (A2 ) gives PS2 (A2 ) p PS2 (A2 ) p p = PS2 (A2 ), i.e.
PS2 (A2 ) p (1p p p) = PS2 (A2 ). This implies that 1p p p p 1p . Given that 1p p p p 1p
(by monotonicity of p ), we obtain 1p p p = 1p . We analyze two cases.
 If p p 1p , there exists a unique p0 satisfying p0 p p = 1p . As both (p S1 PS1 | S2 (A2 )) p p
= 1p and 1p p p = 1p , this entails that p S1 PS1 | S2 (A2 ) = 1p , which contradicts (H).
 If p = 1p , then 1p p 1p = 1p . This entails that p is idempotent. Let dom0 be a subset
of dom(S1 ) such that p A1 dom0 PS1 ,S2 (A1 .A2 ) = PS2 (A2 ). Let A01  dom0 . We can
write:
(
PS1 ,S2 (A01 .A2 ) p (p A1 dom0 {A0 } PS1 ,S2 (A1 .A2 )) = PS2 (A2 )
1
.
PS1 ,S2 (A01 .A2 ) p (p A1 dom0 PS1 ,S2 (A1 .A2 )) = PS2 (A2 ) (as p is idempotent)
As PS1 ,S2 (A01 .A2 ) p PS2 (A2 ), there exists a unique p00  Ep such that PS1 ,S2 (A01 .A2 )p
p00 = PS2 (A2 ). Therefore, p A1 dom0 PS1 ,S2 (A1 .A2 ) = p A1 dom0 {A0 } PS1 ,S2 (A1 .A2 ),
1
which gives p A1 dom0 {A0 } PS1 ,S2 (A1 .A2 ) = PS2 (A2 ).
1

The assumption p A1 dom0 PS1 ,S2 (A1 .A2 ) = PS2 (A2 ) holds for dom0 = dom(S1 ). Recursively applying the previous mechanism by removing one assignment in dom0 at each
iteration leads to p A1 dom0 PS1 ,S2 (A1 .A2 ) = PS2 (A2 ) with |dom0 | = 1, i.e. it leads to
PS1 ,S2 (A001 .A2 ) = PS2 (A2 ) with dom0 = {A001 }. As a result, we obtain a contradiction.
In both cases, a contradiction with (H) is obtained, so p S1 PS1 | S2 (A2 ) = 1p .
(b) PS1 = PS1 |  p P = PS1 |  p (p S PS ) = PS1 |  p 1p = PS1 |  .
468

fiThe PFU Framework

(d) Let A  dom(S1  S2  S3 ) satisfying PS2 ,S3 (A) 6= 0p . Then, PS1 ,S2 | S3 (A) = PS1 | S2 ,S3 (A) p
PS2 | S3 (A) holds, because:
 If PS1 ,S2 ,S3 (A) p PS3 (A), then, there exists a unique p  Ep such that PS1 ,S2 ,S3 (A) =
pp PS3 (A). As both PS1 ,S2 ,S3 (A) = PS1 ,S2 | S3 (A)p PS3 (A) (by definition of PS1 ,S2 | S3 )
and PS1 ,S2 ,S3 (A) = PS1 | S2 ,S3 (A)p PS2 | S3 (A)p PS3 (A) (by definition of PS1 | S2 ,S3 and
PS2 | S3 ), this implies that PS1 ,S2 | S3 (A) = PS1 | S2 ,S3 (A) p PS2 | S3 (A).
 Otherwise, PS1 ,S2 ,S3 (A) = PS3 (A). This implies that 1p p PS1 ,S2 | S3 (A) and, as
PS1 ,S2 | S3 (A) p 1p , that PS1 ,S2 | S3 (A) = 1p . Similarly, this entails that PS2 | S3 (A) = 1p
and PS1 | S2 ,S3 (A) = 1p (the monotonicity of p implies that PS1 ,S2 ,S3 (A) = PS2 ,S3 (A) =
PS3 (A)). As 1p = 1p p 1p , we get PS1 ,S2 | S3 (A) = PS1 | S2 ,S3 (A) p PS2 | S3 (A).
(c)

p S1 PS1 ,S2 | S3

= p S1 (PS1 | S2 ,S3 p PS2 | S3 ) (using (d))
= (p S1 PS1 | S2 ,S3 ) p PS2 | S3 (because p distributes over p )
= PS2 | S3 (using (a))

(e) Assume that PS1 ,S2 ,S3 = PS1 | S3 p PS2 | S3 p PS3 . Let A  dom(S1  S2  S3 ) such that
PS3 (A) 6= 0p . Then, PS1 ,S2 | S3 (A) = PS1 | S3 (A) p PS2 | S3 (A) holds, because:
 If PS1 ,S2 ,S3 (A) p PS3 (A), there exists a unique p  Ep such that PS1 ,S2 ,S3 (A) =
p p PS3 (A), and therefore PS1 ,S2 | S3 (A) = PS1 | S3 (A) p PS2 | S3 (A).
 Otherwise, we can write PS1 | S3 (A) = PS2 | S3 (A) = PS1 ,S2 | S3 (A) = 1p by using reasoning similar to that of (d), and therefore PS1 ,S2 | S3 (A) = PS1 | S3 (A) p PS2 | S3 (A).

Proposition 4 I(., . | .) satisfies the semigraphoid axioms:
1. symmetry: I(S1 , S2 | S3 )  I(S2 , S1 | S3 ),
2. decomposition: I(S1 , S2  S3 | S4 )  I(S1 , S2 | S4 ),
3. weak union: I(S1 , S2  S3 | S4 )  I(S1 , S2 | S3  S4 ),
4. contraction: (I(S1 , S2 | S4 )  I(S1 , S3 | S2  S4 ))  I(S1 , S2  S3 | S4 ).
Proof.
1. Symmetry axiom: directly satisfied by commutativity of p .
2. Decomposition axiom: assume that I(S1 , S2  S3 | S4 ) holds. Then
PS1 ,S2 | S4 = p S3 PS1 ,S2 ,S3 | S4
= p S3 (PS1 | S4 p PS2 ,S3 | S4 ) (since I(S1 , S2  S3 | S4 ))
= PS1 | S4 p (p S3 PS2 ,S3 | S4 ) (by distributivity of p over p )
= PS1 | S4 p PS2 | S4 .
Thus, I(S1 , S2 | S4 ) holds.
3. Weak union axiom: assume that I(S1 , S2  S3 | S4 ) holds. The decomposition axiom entails
that I(S1 , S3 | S4 ) is also satisfied. Then
PS1 ,S2 ,S3 ,S4 = PS1 ,S2 ,S3 | S4 p PS4 (chain rule)
= PS1 | S4 p PS2 ,S3 | S4 p PS4 (since I(S1 , S2  S3 | S4 ))
= PS1 | S4 p PS3 | S4 p PS4 p PS2 | S3 ,S4 (chain rule)
= PS1 ,S3 | S4 p PS4 p PS2 | S3 ,S4 (since I(S1 , S3 | S4 ))
= PS1 | S3 ,S4 p PS2 | S3 ,S4 p PS3 ,S4 (chain rule).
From axiom (e) in Definition 18, we can infer that PS1 ,S2 | S3 ,S4 = PS1 | S3 ,S4 p PS2 | S3 ,S4 , i.e.
I(S1 , S2 | S3  S4 ) holds.
469

fiPralet, Verfaillie, & Schiex

4. Contraction axiom: assume that I(S1 , S2 | S4 ) and I(S1 , S3 | S2  S4 ) hold. Then
PS1 ,S2 ,S3 | S4 = PS1 ,S3 | S2 ,S4 p PS2 | S4 (chain rule)
= PS1 | S2 ,S4 p PS3 | S2 ,S4 p PS2 | S4 (since I(S1 , S3 | S2  S4 ))
= PS1 ,S2 | S4 p PS3 | S2 ,S4 (chain rule)
= PS1 | S4 p PS2 | S4 p PS3 | S2 ,S4 (since I(S1 , S2 | S4 ))
= PS1 | S4 p PS2 ,S3 | S4 (chain rule).
Thus, I(S1 , S2  S3 | S4 ) holds.

Theorem 1 (Conditional independence and factorization) Let (Ep , p , p ) be a conditionable plausibility structure and let G be a DAG of components over S.
(a) If G is compatible with a plausibility distribution PS over S, then PS = p cC(G) Pc | paG (c) .
(b) If, for all c  C(G), there is a function c,paG (c) such that c,paG (c) (A) is a plausibility
distribution over c for all assignments A of paG (c), then S = p cC(G) c,paG (c) is a
plausibility distribution over S with which G is compatible.
Proof.
(a) First, if |C(G)| = 1, G contains a unique component c1 . Then, p cC(G) Pc | paG (c) = Pc1 |  =
Pc1 : the proposition holds for |C(G)| = 1.
Assume that the proposition holds for all DAGs with n components. Let G be a DAG of
components compatible with a plausibility distribution PS and such that |C(G)| = n + 1.
Let c0 be a component labeling a leaf of G. As G is compatible with PS , we can write
I(c0 , ndG (c0 )  paG (c0 ) | paG (c0 )). As c0 is a leaf, ndG (c0 ) = S  c0 , and consequently
I(c0 , (S  c0 )  paG (c0 ) | paG (c0 )). This means that PSpaG (c0 ) | paG (c0 ) = Pc0 | paG (c0 ) p
P(Sc0 )paG (c0 ) | paG (c0 ) . Combining each side of the equation by PpaG (c0 ) gives
PS = Pc0 | paG (c0 ) p PSc0 .
0
Let G be the DAG obtained from G by deleting the node labeled with c0 . Then for every
component c  C(G0 ), paG0 (c) = paG (c) (since the deleted component c0 is a leaf). Moreover
ndG0 (c) equals either ndG (c) or ndG (c)c0 (again, since the deleted component c0 is a leaf). In
the first case (ndG0 (c) = ndG (c)), the property I(c, ndG (c)  paG (c) | paG (c)) directly implies
I(c, ndG0 (c)paG0 (c) | paG0 (c)). In the second case (ndG0 (c) = ndG (c)c0 ), the decomposition
axiom allows us to write I(c, ndG0 (c)  paG0 (c) | paG0 (c)) from I(c, ndG (c)  paG (c) | paG (c)).
Consequently, G0 is a DAG compatible with PSc0 . As |C(G0 )| = n, the induction hypothesis
gives PSc0 = p cC(G0 ) Pc | paG (c) , which implies that PS = p cC(G) Pc | paG (c) , as desired.
(b) Assume that for every component c, c,paG (c) (A) is a plausibility distribution over c for all
assignments A of paG (c). For |C(G)| = 1, C(G) = {c1 }. Then, S = c1 is a plausibility
distribution over c1 . Moreover, as  |  = 1p , we can write c1  |  = c1 |  p  |  , i.e.
I(c1 ,  | ). Therefore, G is compatible with c1 : the proposition holds for |C(G)| = 1.
Assume that the proposition holds for all DAGs with n components. Consider a DAG G
with n + 1 components. We first show that S is a plausibility distribution over S, i.e.
p S (p cC(G) c,paG (c) ) = 1p . Let c0 be a leaf component in G. As c0 is a leaf, the unique
scoped function whose scope contains a variable in c0 is c0 ,paG (c0 ) . By the distributivity of
p over p , this implies that
p c0 (p cC(G) c,paG (c) ) = (p c0 c0 ,paG (c0 ) ) p (p cC(G){c0 } c,paG (c) ).
Given that c0 ,paG (c0 ) (A) is a plausibility distribution over c0 for all assignments A of paG (c0 ),
470

fiThe PFU Framework

p c0 c0 ,paG (c0 ) = 1p . Consequently,
p c0 (p cC(G) c,paG (c) ) = p cC(G){c0 } c,paG (c) .
Applying the induction hypothesis to the DAG with n components obtained from G by deleting c0 , we can infer that p Sc0 (p cC(G){c0 } c,paG (c) ) = 1p . This allows us to write
p Sc0 (p c0 (p cC(G) c,paG (c) )) = 1p , i.e. p S S = 1p : S is a plausibility distribution
over S. It remains to prove that G is a DAG of components compatible with S . Let c  C(G).
We must show that I(c, ndG (c)  paG (c) | paG (c)) holds. There are two cases:
1. If c = c0 , we must prove that
c0 ,ndG (c0 )paG (c0 ) | paG (c0 ) = c0 | paG (c0 ) p ndG (c0 )paG (c0 ) | paG (c0 ) .
First, note that
c0 ,paG (c0 ) = p S(c0 paG (c0 )) (p cC(G) c,paG (c) )
= (p S(c0 paG (c0 )) (p cC(G){c0 } c,paG (c) )) p c0 ,paG (c0 )
(because p distributes over p and sc(c0 ,paG (c0 ) )  c0  paG (c0 )
= (p SpaG (c0 ) (p cC(G) c,paG (c) )) p c0 ,paG (c0 )
(because p distributes over p and c0 c0 ,paG (c0 ) = 1p )
= paG (c0 ) p c0 ,paG (c0 ) .
From this, it is possible to write:
ndG (c0 )paG (c0 ) | paG (c0 ) p c0 | paG (c0 ) p paG (c0 )
= ndG (c0 )paG (c0 ) | paG (c0 ) p c0 ,paG (c0 )
= ndG (c0 )paG (c0 ) | paG (c0 ) p paG (c0 ) p c0 ,paG (c0 )
= ndG (c0 ) p c0 ,paG (c0 )
= S{c0 } p c0 ,paG (c0 ) (because c0 is a leaf in G)
=

(p cC(G){c0 } c,paG (c) ) p c0 ,paG (c0 )

= p cC(G) c,paG (c)
= S .
Using axiom (e) of Definition 18, this entails that ndG (c0 )paG (c0 ) | paG (c0 ) p c0 | paG (c0 ) =
SpaG (c0 ) | paG (c0 ) , i.e., as S = c0  ndG (c0 ), that I(c0 , ndG (c0 )  paG (c0 ) | paG (c0 )).
2. Otherwise, c 6= c0 . Let G0 be the DAG obtained from G by deleting c0 . G0 contains
n components: by the induction hypothesis, I(c, ndG0 (c)  paG0 (c) | paG0 (c)). As c0
is a leaf in G, we have c0 
/ paG (c), which implies that paG0 (c) = paG (c). Thus,
I(c, ndG0 (c)  paG (c) | paG (c)).
(i) If ndG0 (c) = ndG (c), then it is immediate that I(c, ndG (c)  paG (c) | paG (c)).
(ii) Otherwise, ndG0 (c) 6= ndG (c). As c0 is a leaf in G, this is equivalent to say that
ndG (c) = ndG0 (c)  c0 . This means that c is not an ancestor of c0 , and a fortiori c 
/ paG (c0 ). In the following, the four semigraphoid axioms are used to
prove the required result. From the decomposition axiom, from I(c0 , ndG (c0 ) 
paG (c0 ) | paG (c0 )), and from (c  ndG0 (c))  ndG (c0 ) (because ndG (c0 ) = S 
c0 ), it follows that I(c0 , (c  ndG0 (c))  paG (c0 ) | paG (c0 )), or, in other words, as
c  paG (c0 ) = , that I(c0 , c  (ndG0 (c)  paG (c0 )) | paG (c0 )). Using the weak
union axiom leads to I(c0 , c | (ndG0 (c)  paG (c0 ))  paG (c0 )) and, using the symmetry axiom, to I(c, c0 | (ndG0 (c)  paG (c0 ))  paG (c0 )). As shown previously,
I(c, ndG0 (c)paG (c) | paG (c)). Together with I(c, c0 | (ndG0 (c)paG (c0 ))paG (c0 )),
the contraction axiom implies that I(c, (ndG0 (c)  paG (c))  c0 | paG (c)). As c0 
/
paG (c) and ndG (c) = ndG0 (c)  c0 , this means that I(c, ndG (c)  paG (c)) | paG (c)).
471

fiPralet, Verfaillie, & Schiex

We have proved that G is compatible with S . Consequently, the proposition holds if there
are n + 1 components in G, which ends the proof by induction.

Proposition 5 Let (Ep , p , p ) be a conditionable plausibility structure. Then, for all
n  N , there exists a unique p0 such that p i[1,n] p0 = 1p .
Proof. Let n  N . If p i[1,n] 1p = 1p , then p0 = 1p satisfies the required property. Moreover, in
this case, the distributivity of p over p implies that for all p  Ep , p i[1,n] p = p. Therefore, if
p i[1,n] p = 1p , then p = 1p , which shows that p0 is unique.
Otherwise, p i[1,n] 1p 6= 1p . In this case, as 1p p p i[1,n] 1p by monotonicity of p , we can
write 1p p p i[1,n] 1p . The second item of Definition 19 then implies that there exists a unique
p0  Ep such that 1p = p0 p (p i[1,n] 1p ), i.e. such that 1p = p i[1,n] p0 .

Proposition 6
Let PVE ,VD be the completion of a controlled plausibility distribution
PVE || VD . Then, PVE ,VD is a plausibility distribution over VE  VD and PVE | VD = PVE || VD .
Proof. PVE ,VD = PVE || VD p p0 , where p0 is the element of Ep such that p i[1,|dom(VD )|] p0 = 1p .
Then p VE VD PVE ,VD = p VE VD (PVE || VD p p0 ) = p VD ((p VE PVE || VD ) p p0 ) = p VD p0 =
p i[1,|dom(VD )|] p0 = 1p . This proves that PVE ,VD is a plausibility distribution over VE  VD .
As PVE ,VD = PVE || VD p p0 and PVE ,VD = PVE | VD p PVD , we can write PVE || VD p p0 =
PVE | VD p PVD . Moreover, PVD = p VE PVE ,VD = p VE (PVE || VD p p0 ) = p0 . Thus, PVE || VD p
p0 = PVE | VD p p0 . Summing this equation |dom(VD )| times with p gives PVE || VD = PVE | VD .

Proposition 7 Let G be a typed DAG of components over VE  VD . Let Gp be the partial
graph of G induced by the arcs of G incident to environment components. Let Gf be the
partial graph of G induced by the arcs of G incident to decision components. If Gp is
compatible with the completion of PVE || VD (cf. Definition 22) and Gf is compatible with
the completion of FVD || VE , then
PVE | VD =

p Pc | paG (c)
cCE (G)

and FVD | VE =


cCD (G)

Fc | paG (c) .

Proof. The result is proved only for PVE | VD (the proof for FVD | VE is similar). The completion of
PVE || VD looks like PVE ,VD = PVE || VD p p0 . Gp being compatible with this completion, Theorem 1a
entails that PVE ,VD = p cC(Gp ) Pc | paGp (c) . As the decision components are roots in Gp , we can infer,
by successively eliminating the environment components, that PVD = p VE PVE ,VD = p cCD (Gp ) Pc .

On the other hand, PVD = p VE PVE || VD p p0 = p0 . This proves that p cCD (Gp ) Pc =
p0 . Therefore, PVE ,VD = PVE | VD p p0 = (p cCE (Gp ) Pc | paGp (c) ) p p0 . Summing this equation
|dom(VD )| times with p gives PVE | VD = p cCE (Gp ) Pc | paGp (c) . As CE (Gp ) = CE (G) and paGp (c) =
paG (c) for every c  CE (G), this entails that PVE | VD = p cCE (G) Pc | paG (c) .

Proposition 8 Assume that the plausibility structure used is conditionable. Let Q =
(N , Sov) be a query where Sov = (op1 , S1 )  (op2 , S2 )    (opk , Sk ). Let Vf r denote the set
of free variables of Q.
472

fiThe PFU Framework

(1) If Si  VE and PSi | l(Si ) (A) is well-defined, then there exists at least one A0  dom(Si )
satisfying PSi | l(Si ) (A.A0 ) 6= 0p .
(2) If Si  VD and FSi | l(Si ) (A) is well-defined, then there exists at least one A0  dom(Si )
satisfying FSi | l(Si ) (A.A0 ) = t.
(3) If VE 6=  and Si is the leftmost set of environment variables appearing in Sov, then,
for all A  dom(l(Si )), PSi | l(Si ) (A) is well-defined.
(4) If i, j  [1, k], i < j, Si  VE , Sj  VE , r(Si )l(Sj )  VD (Sj is the first set of environment variables appearing to the right of Si in Sov), (A, A0 )  dom(l(Si ))  dom(Si ),
PSi | l(Si ) (A) is well-defined, and PSi | l(Si ) (A.A0 ) 6= 0p , then, for all A00 extending A.A0
over l(Sj ), PSj | l(Sj ) (A00 ) is well-defined.
(5) If i, j  [1, k], i < j, Si  VD , Sj  VD , r(Si )  l(Sj )  VE (Sj is the first set of
decision variables appearing to the right of Si in Sov), (A, A0 )  dom(l(Si ))dom(Si ),
FSi | l(Si ) (A) is well-defined, and FSi | l(Si ) (A.A0 ) = t, then, for all A00 extending A.A0
over l(Sj ), FSj | l(Sj ) (A00 ) is well-defined.
(6) For all i  [1, k] such that Si  VE , PSi | l(Si ) = PSi | l(Si )VE ||VD .
(7) For all i  [1, k] such that Si  VD , FSi | l(Si ) = FSi | l(Si )VD ||VE .
Proof. We denote by p0 the element in Ep such that the completion of PVE || VD equals PVE || VD  p0 .
Note that p0 6= 0p , since it must satisfy p i[1,|dom(VD )|] p0 = 1p .
Lemma 1. Let (Ep , p , p ) be a conditionable plausibility structure. Then, (p1 p p2 = 0p ) 
((p1 = 0p )  (p2 = 0p )).
Proof. First, if p1 = 0p or p2 = 0p , then p1 p p2 = 0p . Conversely, assume that p1 p p2 = 0p . Then,
if p1 p 0p , the conditionability of the plausibility structure together with p1 p 0p = 0p entails that
p2 = 0p . Similarly, if p2 p 0p , then p1 = 0p . Therefore (p1 p p2 = 0p )  ((p1 = 0p )(p2 = 0p )).
Lemma 2. Assume that the plausibility structure is conditionable. Let S1 , S2 be disjoint subsets of
VE . Then, PS1 | S2 || VD = PS1 | S2 ,VD .
Proof. Note that PS1 ,S2 | VD = PS1 | S2 ,VD p PS2 | VD . Moreover, we can also write PS1 ,S2 | VD =
PS1 ,S2 || VD = PS1 | S2 || VD p PS2 || VD = PS1 | S2 || VD p PS2 | VD . Let A be an assignment of V .
If PS1 ,S2 | VD (A) p PS2 | VD (A), then the conditionability of the plausibility structure entails that
PS1 | S2 ,VD (A) = PS1 | S2 || VD (A). Otherwise, PS1 ,S2 | VD (A) = PS2 | VD (A), which also entails that
PS1 ,S2 || VD (A) = PS2 || VD (A). In this case, PS1 | S2 ,VD (A) = PS1 | S2 || VD (A) = 1p . Therefore,
PS1 | S2 ,VD = PS1 | S2 || VD .
(1) Assume that Si  VE and PSi | l(Si ) (A) is well-defined. Then, PSi | l(Si ) (A) is a plausibility
distribution over Si . Hence, p A0 dom(Si ) PSi | l(Si ) (A.A0 ) = 1p , which implies that there exists
at least one A0  dom(Si ) such that PSi | l(Si ) (A.A0 ) 6= 0p .
(2) Proof similar to point (2).
(3) Assume that VE 6= . Let Si be the leftmost set of environment variables appearing in Sov and
let A  dom(l(Si )). Since l(Si )  VE = , we can write Pl(Si ) (A) = p V l(Si ) PVE ,VD (A) =
p VD l(Si ) (p VE PVE ,VD (A)) = p VD l(Si ) p0 6= 0p . Therefore, PSi | l(Si ) (A) is well-defined.

473

fiPralet, Verfaillie, & Schiex

(6) Let lE (Si ) = l(Si )  VE and lD (Si ) = l(Si )  VD . For a set of variables S, we denote by dG (S)
the set of variables in V that are descendant in the DAG G of at least one variable in S.
First, PSi ,lE (Si ) || VD = p VE (Si lE (Si )) PVE || VD = p VE (Si lE (Si )) (p Pj P Pj ). By definition of a query, variables in VE dG (VD lD (Si )) do not belong to Si lE (Si ) (the environment
variables that are descendants of as-yet-unassigned decision variables are not assigned yet).
Thus, PSi ,lE (Si ) || VD = p VE (Si lE (Si )dG (VD lD (Si ))) (p Pj F act(c),c*VE dG (VD lD (Si )) Pj ).
The last equality is obtained by successively eliminating the environment components included
in dG (VD lD (Si )) (using the normalization conditions). As the scope of a plausibility function
Pj  F act(c) is included in cpaG (c), this equality entails that PSi ,lE (Si ) || VD does not depend
on the assignment of VD  lD (Si ). Morever, PlE (Si ) || VD = Si PSi ,lE (Si ) || VD does not depend
on the assignment of VD  lD (Si ) too. As PSi | lE (Si ) || VD = max{p  Ep | PSi ,lE (Si ) || VD =
p p PlE (Si ) || VD }, this also entails that PSi | lE (Si ) || VD does not depend on the assignment of
VD  lD (Si ). It can be denoted PSi | lE (Si ) || lD (Si ) .
We now show that PSi | l(Si ) = PSi | lE (Si ) || lD (Si ) . First, note that
PSi ,l(Si ) = p VD lD (Si ) PSi ,lE (Si ),VD = p VD lD (Si ) (PSi | lE (Si ),VD p PlE (Si ),VD )
= p VD lD (Si ) (PSi | lE (Si ) || VD p PlE (Si ),VD ) (using Lemma 2)
= PSi | lE (Si ) || VD p (p VD lD (Si ) PlE (Si ),VD )
(since PSi | lE (Si ) || VD does not depend on the assignment of VD  lD (Si ))
= PSi | lE (Si ) || VD p Pl(Si ) .
Let A be an assignment of V .
 If PSi ,l(Si ) (A) p Pl(Si ) (A), then the conditionability of the plausibility structure directly
entails that PSi | l(Si ) (A) = PSi | lE (Si ) || VD (A).
 Otherwise, PSi ,l(Si ) (A) = Pl(Si ) (A). In this case, PSi | l(Si ) (A) = 1p . Next, as V 
l(Si ) = (VD  lD (Si ))  (VE  lE (Si )), observe that Pl(Si ) = p V l(Si ) (PVE || VD p p0 ) =
p VD lD (Si ) (PlE (Si ) || VD p p0 ). Similarly, we have PSi ,l(Si ) = p V (Si l(Si )) (PVE || VD p
p0 ) = p VD lD (Si ) (PSi ,lE (Si ) || VD p p0 ). As PSi ,l(Si ) (A) = Pl(Si ) (A), we can infer that
p VD lD (Si ) (PlE (Si ) || VD (A) p p0 ) = p VD lD (Si ) (PSi ,lE (Si ) || VD (A) p p0 ). As neither
PlE (Si ) || VD nor PSi ,lE (Si ) || VD depends on the assignment of VD lD (Si ), this entails that
PlE (Si ) || VD (A) p (p VD lD (Si ) p0 ) = PSi ,lE (Si ) || VD (A) p (p VD lD (Si ) p0 ). Summing
this equation |dom(lD (Si ))| times gives PSi ,lE (Si ) || VD (A) = PlE (Si ) || VD (A), and thus
PSi | lE (Si ) || VD (A) = 1p = PSi | l(Si ) (A).
(7) Proof similar to point (6).
(4) Let i, j  [1, k] such that i < j, Si  VE , Sj  VE , and r(Si )  l(Sj )  VD (Sj is the first set of
environment variables appearing to the right of Si in Sov). Let (A, A0 )  dom(l(Si ))dom(Si )
such that PSi | l(Si ) (A) is well-defined (i.e. Pl(Si ) (A) 6= 0p ) and PSi | l(Si ) (A.A0 ) 6= 0p . Let A00
be an extension of A.A0 over l(Sj ). We must show that PSj | l(Sj ) (A00 ) is well-defined, i.e.
that Pl(Sj ) (A00 ) 6= 0p . As PSi | l(Si ) (A.A0 ) 6= 0p and Pl(Si ) (A) 6= 0p , Lemma 1 implies that
PSi ,l(Si ) (A.A0 ) 6= 0p . Similarly to the proof of point (6), it is possible to show that Pl(Sj ) does
not depend on the assignment of l(Sj )  (Si  l(Si )). Therefore, for every A00 extending A.A0
over l(Sj ), p l(Sj )(Si l(Si )) Pl(Sj ) (A00 ) 6= 0p , which implies that Pl(Sj ) (A00 ) 6= 0p .
(5) Proof similar to point (4), except that plausibilities are replaced by feasibilities and decision
variables are replaced by environment variables.

474

fiThe PFU Framework

Theorem 2 If the plausibility structure is conditionable, then, for all queries Q on a PFU
network, Sem-Ans(Q) = Op-Ans(Q) and the optimal policies for the decisions are the same
with Sem-Ans(Q) and Op-Ans(Q).
Proof. Let Af r be an assignment of the set of free variables Vf r such that FVf r (Af r ) = f . The
semantic definition gives (Sem-Ans(Q))(Af r ) = . Given that FVf r (Af r ) = V Vf r FVE ,VD (Af r ) =
V Vf r FVD || VE (Af r ) = V Vf r (Fi F Fi (Af r )) (since the completion of FVD || VE gives FVD || VE =
FVD ,VE ), we can infer that for every complete assignment A00 extending Af r , Fi F Fi (A00 ) = f and
(Fi F Fi (A00 )) ? (p Pi P Pi (A00 )) pu (uUi U Ui (A00 )) = . As min(, ) = max(, ) =  u  =
, this entails that (Op-Ans(Q))(Af r ) =  too.
We now analyze the case FVf r (Af r ) = t. We use A00 to denote a complete assignment which
must be considered with the semantic definition. Using the properties:
 p pu min(u1 , u2 ) = min(p pu u1 , p pu u2 ) (right monotonicity of pu ),
 p pu max(u1 , u2 ) = max(p pu u1 , p pu u2 ) (right monotonicity of pu ),
 p pu (u1 u u2 ) = (p pu u1 ) u (p pu u2 ) (distributivity of pu over u ),
 p1 pu (p2 pu u) = (p1 p p2 ) pu u,
we can move all the PSi | l(Si ) (A.A0 ) to get, starting from the semantic definition,
(p i[1,k],Si VE PSi | l(Si ) )(A00 ) pu UV (A00 )
on the right of the elimination operators.
We now prove that this quantity equals PVE | VD (A00 ) pu UV (A00 ). Let S be the rightmost set
of quantified environment variables. The chain rule enables us to write PVE | VD = PS | lE (S),VD p
PlE (S) | VD , where lE (S) = l(S)  VE . Moreover, using Lemma 2 and Proposition 8(6), we can
write PS | lE (S),VD = PS | lE (S) || VD = PS | l(S) . Therefore, PVE | VD = PS | l(S) p PlE (S) | VD . Recursively applying this mechanism leads to: PVE | VD = p i[1,k],Si VE PSi | l(Si ) . Therefore, we obtain
PVE | VD (A00 ) pu UV (A00 ) on the right of the elimination operators.
The semantic definition of the query meaning can be simplified a bit, thanks to Lemma 1. This
lemma implies that conditions like PS | l(S) (A.A0 ) 6= 0p , which are used only when Pl(S) (A) 6= 0p , are
equivalent to PS,l(S) (A.A0 ) 6= 0p , since PS,l(S) (A.A0 ) = PS | l(S) (A.A0 ) p Pl(S) (A). As a result, the
operators uA0 dom(S),PS | l(S) (A.A0 )6=0p can be replaced by uA0 dom(S),PS,l(S) (A.A0 )6=0p . Similarly, in
the eliminations minA0 dom(S),FS | l(S) (A.A0 )=t , the conditions FS | l(S) (A.A0 ) = t can be replaced by
FS,l(S) (A.A0 ) = t. The same holds for the eliminations with maxadom(xi ),FS | l(S) (A.A0 )=t .
We now start from the operational definition and show that it can be reformulated as above. The
operational definition applies a sequence of variable eliminations on the global function (Fi F Fi ) ?
(p Pi P Pi ) pu (Ui U Ui ), which also equals FVD | VE ? PVE | VD pu UV . Let S be the leftmost
set of quantified decision variables. Let A be an assignment of l(S). Assume that S is quantified by min. Let A0  dom(S) such that FS,l(S) (A.A0 ) = f . It can be inferred that for
all complete assignment A00 extending A.A0 , FVE ,VD (A00 ) = f , and consequently FVD | VE (A00 ) =
f . This implies that FVD | VE (A00 ) ? PVE | VD (A00 ) pu UV (A00 ) = . Given that min(, ) =
max(, ) =  u  = , we obtain Qo(N , Sov, A.A0 ) = . As min(d, ) = d, this entails
that minA0 dom(S) Qo(N , Sov, A.A0 ) = minA0 dom(S){A0 } Qo(N , Sov, A.A0 ). Thus, minA0 dom(S)
can be replaced by minA0 dom(S),FS,l(S) (A.A0 )=t (as FVf r (A) = t, there exists at least one assignment
A0  dom(S) such that FS,l(S) (A.A0 ) = t). The same result holds if S is quantified by max. Applying this mechanism to each set of quantified decision variables from the left to the right of Sov,
we obtain that minA0 dom(S) and maxA0 dom(S) can be replaced by minA0 dom(S),FS,l(S) (A.A0 )=t and
maxA0 dom(S),FS,l(S) (A.A0 )=t respectively. Moreover, it can be shown that for every complete assignment A00 considered in the corresponding transformed operational definition, FVD | VE (A00 ) = t. It is
thus possible to replace FVD | VE (A00 ) ? PVE | VD (A00 ) pu UV (A00 ) by PVE | VD (A00 ) pu UV (A00 ).

475

fiPralet, Verfaillie, & Schiex

We now transform each uA0 dom(S) Qo(N , Sov, A.A0 ) so that it looks like the expression in the
semantic definition. Let S be the leftmost set of quantified environment variables. Let A be an assignment of l(S). Let A0  dom(S) be such that PS,l(S) (A.A0 ) = 0p . Then, for all complete assignments
A00 extending A.A0 , PVE | VD (A00 ) = 0p , and thus PVE | VD (A00 ) pu UV (A00 ) = 0u . As min(0u , 0u ) =
max(0u , 0u ) = 0u u 0u = 0u , we obtain Qo(N , Sov, A.A0 ) = 0u . As d u 0u = d, computing uA0 dom(S) Qo(N , Sov, A.A0 ) is equivalent to computing uA0 dom(S){A0 } Qo(N , Sov, A.A0 ).
Thus, uA0 dom(S) can be replaced by uA0 dom(S),PS,l(S) (A.A0 )6=0p (as Pl(S) (A) 6= 0p , there exists
at least one assignment A0  dom(S) satisfying PS,l(S) (A.A0 ) 6= 0p ). Applying this mechanism,
considering each set of quantified environment variables from the left to the right of Sov, we get
uA0 dom(S),PS,l(S) (A,A0 )6=0p instead of uA0 dom(S) .
Consequently, we have found a function  such that Sem-Ans(Q) =  and Op-Ans(Q) = .
Moreover, the optimal policies for the decisions for Sem-Ans(Q) are optimal policies for decisions
for . Indeed, the transformation rules used preserve the set of optimal policies. The same holds
for Op-Ans(Q) and . It entails that Sem-Ans(Q) = Op-Ans(Q), and that the optimal policies for
Sem-Ans(Q) are the same as those for Op-Ans(Q).

Theorem 3 Queries and bounded queries can be used to express and solve the following
nonexhaustive list of problems:
1. SAT framework: SAT, MAJSAT, E-MAJSAT, quantified boolean formula, stochastic
SAT (SSAT) and extended-SSAT (Littman et al., 2001).
2. CSP (or CN) framework:
 Check consistency for a CSP (Mackworth, 1977); find a solution to a CSP; count
the number of solutions of a CSP.
 Find a solution of a valued CSP (Bistarelli et al., 1999).
 Solve a quantified CSP (Bordeaux & Monfroy, 2002).
 Find a conditional decision or an unconditional decision for a mixed CSP or a
probabilistic mixed CSP (Fargier et al., 1996).
 Find an optimal policy for a stochastic CSP or a policy with a value greater than
a threshold; solve a stochastic COP (Constraint Optimization Problem) (Walsh,
2002).
3. Integer Linear Programming (Schrijver, 1998) with finite domain variables.
4. Search for a solution plan with a length  k in a classical planning problem (STRIPS
planning, Fikes & Nilsson, 1971; Ghallab et al., 2004).
5. Answer classical queries on Bayesian networks (Pearl, 1988), Markov random fields
(Chellappa & Jain, 1993), and chain graphs (Frydenberg, 1990), with plausibilities
expressed as probabilities, possibilities, or -rankings:
 Compute plausibility distributions.
 MAP (Maximum A Posteriori hypothesis) and MPE (Most Probable Explanation).
476

fiThe PFU Framework

 Compute the plausibility of an evidence.
 CPE task for hybrid networks (Dechter & Larkin, 2001) (CPE means CNF Probability Evaluation, a CNF being a formula in Conjunctive Normal Form).
6. Solve an influence diagram (Howard & Matheson, 1984).
7. With a finite horizon, solve a probabilistic MDP, a possibilistic MDP, a MDP based on
-rankings, completely or partially observable (POMDP), factored or not (Puterman,
1994; Monahan, 1982; Sabbadin, 1999; Boutilier et al., 1999, 2000).
Proof.
Lemma 3. Let (Ep , Eu , u , pu ) be an expected utility structure such that Eu is totally ordered by
u . Let S1 ,S2 be a local function on Eu whose scope is S1  S2 . Then
max
u
S1 ,S2 ((A).A)
:dom(S2 )dom(S1 ) Adom(S2 )

= u max S1 ,S2 .
S2

S1

Moreover,  : dom(S2 )  dom(S1 ) satisfies (maxS1 S1 ,S2 )(A) = S1 ,S2 ((A).A) for all A 
dom(S2 ) iff max:dom(S2 )dom(S1 ) uAdom(S2 ) S1 ,S2 ((A).A) = uAdom(S2 ) S1 ,S2 ((A).A). In
other words, the two sides of the equality have the same set of optimal policies for S1 .
Proof. Let 0 : dom(S2 )  dom(S1 ) be a function such that
max:dom(S2 )dom(S1 ) uAdom(S2 ) S1 ,S2 ((A).A) = uAdom(S2 ) S1 ,S2 (0 (A).A).
Given that, for all A  dom(S2 ), S1 ,S2 (0 (A).A) u maxA0 dom(S1 ) S1 ,S2 (A0 .A), the monotonicity
of u entails that uAdom(S2 ) S1 ,S2 (0 (A).A) u uAdom(S2 ) maxA0 dom(S1 ) S1 ,S2 (A0 .A). Thus,
max:dom(S2 )dom(S1 ) uAdom(S2 ) S1 ,S2 ((A).A) u uS2 maxS1 S1 ,S2 .
On the other hand, let 0 : dom(S2 )  dom(S1 ) be a function such that A  dom(S2 ),
(maxS1 S1 ,S2 )(A) = S1 ,S2 (0 (A).A). Then,
uS2 maxS1 S1 ,S2 =
u
S1 ,S2 (0 (A).A) u
max
u
S1 ,S2 ((A).A).
:dom(S2 )dom(S1 ) Adom(S2 )

Adom(S2 )

The antisymmetry of u implies the required equality. The equality of the set of optimal policies
over S1 is directly implied by the equality.
We now give the proof of the theorem, which uses for some cases the previous lemma.
1. (CSP based problems, Mackworth, 1977 )
Let us consider a CSP over a set of variables V and with a set of constraints {C1 , . . . , Cm }.
(a) (Consistency and solution finding) Consistency can be checked by using the query Q =
(N , (max, V )), where N = (V, G, , , U ) (all variables in V are decision variables, G is
reduced to a unique decision component containing all variables, and U = {C1 , . . . , Cm }),
and where the expected utility structure is boolean optimistic expected conjunctive
utility (row 6 in Table 1). Computing Ans(Q) = maxV (C1  . . .  Cm ) is equivalent to
checking consistency, because Ans(Q) = t iff there exists an assignment of V satisfying
C1 . . .Cm , i.e. iff the CSP is consistent. In order to get a solution when Ans(Q) = t, it
suffices to record an optimal decision rule for V . Integer Linear Programming (Schrijver,
1998) with finite domain variables can be formulated as a CSP.
(b) (Counting the number of solutions) The expected utility structure considered for this
task is probabilistic expected satisfaction (row 2 in Table 1). The PFU network is
N = (V, G, P, , U ), where all variables in V are environment variables, G is a DAG with
a unique component c0 = V , P = {1/0 }, 0 being a constant factor equal to |dom(V )|

477

fiPralet, Verfaillie, & Schiex

such that F act(c0 ) = {0 }, and U = {C1 , . . . , Cm }. Implicitly, 1/0 specifies that the
complete assignments are equiprobable. It enables the normalization
condition for all
P
c  CE (G), p c p Pi F act(c) Pi = 1p  to be satisfied, since V (1/|dom(V )|) = 1. The
query to consider is then Q = (N , (+, V )). It is P
not hard to check that this satisfies the
conditions imposed on queries and Ans(Q) = V (1/0  (C1  . . .  Cm )) gives the
percentage of solutions of the CSP. 0  Ans(Q) gives the number of solutions.
2. (Solving a Valued CSP (VCSP), Bistarelli et al., 1999 )
In order to model this problem, the only difficulty lies in the definition of an expected utility
structure. In a VCSP, a triple (E, ~, ) called a valuation structure is introduced. It satisfies
properties such as (E, ~) is a commutative semigroup,  is a total order on E, and E has
a minimum element denoted >. The expected utility structure to consider is the following
one: (Ep , p , p ) = ({t, f }, , ), (Eu , u ) = (E, ~), and the expected utility structure is
(Ep , Eu , u , pu ), with u = min and pu defined by f alse pu u = > and true pu u =
u (it is not hard to check that this structure is an expected utility structure). Next, the
PFU network is N = (V, G, , , U ), where V is the set of variables of the VCSP, G is a
DAG with only one decision component containing all the variables, and U contains the soft
constraints. The query Q = (min, V ) enables us to find the minimum violation degree of the
soft constraints. A solution for the VCSP is an optimal (argmin) decision rule for V .
3. (Problems from the SAT framework, Littman et al., 2001 )
In the SAT framework, queries on a conjunctive normal form boolean formula  over a set
of variables V = {x1 , . . . , xn } are asked. Let us first prove that an extended SSAT formula can be evaluated with a PFU query. An extended SSAT formula is defined by a
triple (, , q) where  is a boolean formula in conjunctive normal form,  is a threshold
in [0, 1], and q = (q1 x1 ) . . . (qn xn ) is a sequence of quantifier/variable pairs (the quantifiers
are , , or R; the meaning of R appears below). If we take f  t, the value of  under the quantification sequence q, val(, q), is defined recursively by: (i) val(, ) = 1 if 
is t, 0 otherwise; (ii) val(,
(x) q 0 ) = maxx val(, q 0 ); (iii) val(, (x) q 0 ) = minx val(, q 0 );
P
(iv) val(, (Rx) q 0 ) =
0.5
 val(, q 0 ). Intuitively, the last case means that R quantifies
x
boolean variables taking equiprobable values. An extended SSAT formula (, , q) is t iff
val(, q)  . If S denotes the set of variables quantified by R, an equivalent definition of
val(, q) is: (i) val(, ) = 0.5|S| if  is t, 0 otherwise; (ii) val(,
(x) q 0 ) = maxx val(, q 0 );
P
0
0
0
(iii) val(, (x) q ) = minx val(, q ); (iv) val(, (Rx) q ) = x val(, q 0 ). This second definition proves that val(, q) can be computed with the PFU query defined by: (a) expected
utility structure: probabilistic expected satisfaction (row 2 in Table 1); (b) PFU network:
N = (V, G, P, , U ), with V the set of variables of the formula  (the decision variables are
the variables quantified by  or ), G a DAG without arcs, with one decision component per
decision variable and a unique environment component containing all variables quantified by
R, P = {0 }, 0 being a constant factor equal to 0.5|VE | , and U the set of clauses of ; (c)
query: Q = (N , Sov), Sov being obtained from q by replacing , , and R by max, min, and
+ respectively. Then, Ans(Q) = val(, q), which implies that the value of an extended SSAT
formula (, , q) is the value of the bounded query (N , Sov, ).
SSAT is a particular case of extended-SSAT and is therefore covered. SAT, MAJSAT, EMAJSAT, QBF are also particular cases of extended SSAT. As a result, they are instances
of PFU bounded queries. More precisely, SAT corresponds to a bounded query of the form
Q = (N , (max, V ), 1); MAJSAT (given a boolean formula over a set of variables V , is it
satisfied for at least half of the assignments of V ) corresponds to a bounded query of the
form (N , (+, V ), 0.5); E-MAJSAT (given a boolean formula over V = VE  VD , does there
exist an assignment of VD such that the formula is satisfied for at least half of the assignments
of VE ?) corresponds to a bounded query of the form (N , (max, VD ).(+, VE ), 0.5); QBF

478

fiThe PFU Framework

corresponds to a bounded query in which max over existentially quantified variables and min
over universally quantified variables alternate.
4. (Solving a Quantified CSP (QCSP), Bordeaux & Monfroy, 2002 )
A QCSP represents a formula of the form Q1 x1 . . . Qn xn (C1  . . .  Cm ), where each Qi is a
quantifier ( or ) and each Ci is a constraint. The value of a QCSP is defined recursively as
follows: the value of a QCSP without variables (i.e. containing only t, f , and connectives) is
given by the definition of the connectives. A QCSP x qcsp is t iff either qcsp((x, t)) = t or
qcsp((x, f )) = t. Assuming f  t, it gives that x qcsp is t iff maxx qcsp = t. A QCSP x qcsp
is t iff qcsp((x, t)) = t and qcsp((x, f )) = t. Equivalently, x qcsp is t iff minx qcsp = t. It
implies that the value of a QCSP is actually given by the formula op(Q1 )x1 . . . op(Qn )xn (C1 
. . .  Cm ), with op() = max and op() = min. It corresponds to the answer to the query
(N , (op(Q1 ), x1 ). . . . .(op(Qn ), xn )), where N = (V, G, , , U ) (V is the set of variables of the
QCSP, G is a DAG with only one decision component containing all variables, and U is the
set of constraints), and where the expected utility structure is boolean optimistic expected
conjunctive utility (row 6 in Table 1).
5. (Solving a mixed CSP or a probabilistic mixed CSP, Fargier et al., 1996 )
A probabilistic mixed CSP is defined by (i) a set of variables partitioned into a set W of
contingent variables and a set X of decision variables; an assignment AW of W is called
a world and an assignment AX of X is called a decision; (ii) a set C = {C1 , . . . , Cm } of
constraints involving at least one decision variable; (iii) a probability distribution PW over
the worlds; a possible world AW (i.e. such that PW (AW ) > 0) is covered by a decision AX iff
the assignment AW .AX satisfies all the constraints in C.
On one hand, if a decision must be made without knowing the world, the task is to find
an optimal non-conditional decision, i.e. to find an assignment AX of the decision variables
that
is covered by AX . This probability is equal to
P maximizes the probability that the world
P
P
(A
)
=
(P
W
W  C1  . . .  Cm ). As a result, an optimal
AW | (C1 ...Cm )(AX ,AW )=1 W
W
non-conditionalPdecision can be found by recording an optimal decision rule for X for the
formula maxX W (PW  C1  . . .  Cm ). The previous formula actually specifies how to
solve such a problem with PFUs. The algebraic structure is probabilistic expected additive
utility (row 2 in Table 1), the PFU network is N = (V, G, P, , U ), with VD = X, VE = W ,
G a DAG without arc, with one decision component X and a set of environment components
that depends on how PW is specified, P is the set of multiplicative factors that define PW ,
and finally U = {C1 , . . . , Cm }. The query is then Q = (N , (max, X).(+, W )).
On the other hand, if the world is known when the decision is made, the task is to look for an
optimal conditional decision, i.e. to look for a decision rule 0 : dom(W )  dom(X) which
maximizes the probability
P that the world is covered. In other words, the goal is to compute
max:dom(W )dom(X) AW dom(W ) | (C1 ...Cm )(AW .(AW ))=1 PW (AW ) =
P
max:dom(W )dom(X) AW dom(W ) (PW  C1  . . .  Cm ) (AW .(AW )). Due to Lemma 3, it
P
also equals W maxX (PW  C1  . . .  Cm ), and 0 can be found by recording an optimal
decision rule for X. It proves that the query Q = (N , (+, W ).(max, X)) enables us to compute
an optimal conditional decision.
With Mixed CSPs, PW is replaced by a set K of constraints defining the possible worlds. The
goal is then to look for a decision, either conditional or non-conditional, that maximizes the
number of covered worlds. This task is equivalent, ignoring a normalizing constant, to find a
decision that maximizes the percentage of covered worlds. This can be solved using the set
of plausibility functions P = K  {N0 }, with N0 a normalizing constant ensuring that the
normalization condition on plausibilities holds. N0 is the number of possible worlds, but it
does actually not need to be computed, since it is a constant factor and we are only interested
in optimal decisions.
479

fiPralet, Verfaillie, & Schiex

6. (Stochastic CSP (SCSP) and stochastic COP (SCOP), Walsh, 2002 )
Formally, a SCSP is a tuple (V, S, P, C, ), where V is a list of variables (each variable x
having a finite domain dom(x)), S is the set of stochastic variables in V , P = {Ps | s  S}
is a set of probability distributions (in a more advanced version of SCSPs, probabilities over
S may be defined by a Bayesian network; the subsumption result is still valid for this case),
C = {C1 , . . . , Cm } is a set of constraints, and  is a threshold in [0, 1].
A SCSP-policy is a tree with internal nodes labeled with variables. The root is labeled with
the first variable in V , and the parents of the leaves are labeled with the last variable in
V . Nodes labeled with a decision variable have only one child, whereas nodes labeled with
a stochastic variable s have |dom(s)| children. Leaf nodes are labeled with 1 if the complete
assignment they define satisfies all theQconstraints in C, and with 0 otherwise. With each leaf
node can be associated a probability sS Ps (AS ), where AS stands for the assignment of S
implicitly defined by the path from the root to the leaf. The satisfaction of a SCSP-policy
is the sum of the values of the leaves weighted by their probabilities. A SCSP is satisfiable
iff there exists a SCSP-policy with a satisfaction of at least . The optimal satisfaction of a
SCSP is the maximum satisfaction over all SCSP-policies.
For the subsumption proof, we first consider the problem of looking for the optimal satisfaction of a SCSP. In a SCSP-policy, each decision variable x can take one value per
assignment of the set preds (x) of stochastic variables which precede x in the list of variables V . Instead of being described as a tree, a SCSP-policy can be viewed as a set of
x
functions
 =
s (x))  dom(x)), x  V  S}, and its value is val() =
P
Q { : dom(pred
Q
(
P

C
 x (AS ))). The goal is to maximize the previAS dom(S)
sS s
Ci C i )(AS .(
xV S

ous quantity among the sets . Let y be the last decision variable in V , and let y be the set
of local functions y : dom(preds (y))
defining
Y rule for y. Then
X  dom(y)X
Ya decision
(
val() = max
Ps 
Ci )(AS .(  x (AS ))).
max
y
y
y
y
 

 

AS dom(preds (y)) Spreds (y) sS

Ci C

xV S

By
also equals:

P Lemma 3, the
Pprevious quantity
Q
Q
max
P
y
preds (y))
Spreds (y)
sS s 
Ci C Ci . A recursive application of this mechanism shows that the answer Ans(Q) to the query Q described below is equal to the optimal
satisfaction of a SCSP:
 expected utility structure: row 2 in Table 1 (probabilistic expected satisfaction);
 PFU network: N = (V 0 , G, P, , U ), with V 0 the set of variables of the SCSP; VE = S
and VD = V 0  S; G is a DAG without arcs, with one component per variable; P =
{Ps | s  S}; F act({s}) = {Ps }; U is the set of constraints of the SCSP;
 query: Q =(N , Sov), with Sov=t(V ) (V is thelist of variables of the SCSP), t(V ) being
(+, {x}).t(V 00 ) if x  S
.
recursively defined by t() =  and t(x.V 00 ) =
(max, {x}).t(V 00 ) otherwise
An optimal SCSP-policy can be recorded during the evaluation of Ans(Q). The satisfiability
of a SCSP can be answered with the bounded query (N , Sov, ). Again, a corresponding
SCSP-policy can be obtained by recording optimal decision rules.
With Stochastic Constraint Optimization Problem (SCOP), the constraints in C are additive
soft constraints. The subsumption proof is similar.
7. (Classical planning problems (STRIPS planning), Fikes & Nilsson, 1971; Ghallab et al., 2004 )
In order to search for a plan of length lesser than k, we can simply model a classical planning problem as a CSP. Such a transformation is already available in the literature (Ghallab
et al., 2004). However, we can also model a classical planning problem more directly in the
PFU framework. More precisely, the state at one step can be described by a set of boolean

480

fiThe PFU Framework

environment variables. For each step, there is a unique decision variable whose set of values corresponds to the actions available. Plausibility functions are deterministic and link
variables in step t to variables in step t + 1 (these functions simply specify the positive and
negative effects of actions). The initial state is also represented by a plausibility function
which links variables in the first step. Feasibility functions define preconditions for an action
to be feasible. They link variables in a step t to the decision variable of that step. Utility
functions are boolean functions which describe the goal states. They hold over variables in
step k. In order to search for a plan of length lesser than k, the sequence of elimination is a
max-elimination on all variables. The expected utility structure used is the boolean optimistic
expected disjunctive utility.
8. (Influence diagrams, Howard & Matheson, 1984 )
We start from the definition of influence diagrams of Section 3. With each decision variable
d, we can associate a decision rule  d : dom(paG (d))  dom(d). An influence diagram policy
(ID-policy) is a set  = { d | d  D} of decision rules (one for each decision variable). The
value val() of an ID-policy X
 is given
Yby the probabilistic
X expectation of the utility:
((
Ps | paG (s) )  (
Ui ))(AS .(   d (AS ))).
val() =
AS dom(S)

Ui U

sS

dD

To solve an influence diagram, we must compute the maximum value of the previous quantity and find an associated optimal ID-policy. Using Lemma 3 and the DAG structure, it is
possible to show, using the same ideas as in the SCSP subsumption proof, that the optimal
expected utility is given by the answer to the query Q below (associated optimal decision rules
can be recorded during the evaluation of Ans(Q)):
 expected utility structure: row 1 in Table 1 (probabilistic expected additive utility);
 PFU network: N = (V, G0 , P, , U ); V is the set of variables of the influence diagram,
G0 is the DAG obtained from the DAG of the influence diagram by removing utility
nodes and arcs into decision nodes; in G0 , there is one component per variable; P =
{Ps | paG (s) , s  VE } and F act({s}) = {Ps | paG (s) }; U is the set of utility functions
associated with utility nodes.
 PFU query: Q = (N , Sov), with Sov obtained from the DAG of the influence diagram as
follows. Initially, Sov = . In the DAG of an influence diagram, the decisions are totally
ordered. Let d be the first decision variable in the DAG G of the influence diagram (i.e.
the decision variable with no parent decision variable). Then, repeatedly update Sov
by Sov  Sov.(+, paG (d)).(max, {d}) and delete d and the variables in paG (d) from G
until no decision variable remains. Then, perform Sov  Sov.(+, S), where S is the set
of chance variables that have not been deleted from G.
9. (Finite horizon MDPs, Puterman, 1994; Monahan, 1982; Sabbadin, 1999; Boutilier et al.,
1999, 2000 ) In order to prove that the encoding in the PFU framework given in Sections 5.6
and 6.6 actually enables us to solve a T time-steps probabilistic MDP, we start by reminding
the algorithm used to compute an optimal MDP-policy. Usually, a decision rule for dT is
chosen by computing VsT = maxdT RsT ,dT . VsT is the optimal reward which can be obtained
in state sT . AtP
a time-step i  [1, T [, a decision rule for di is chosen by computing Vsi =
maxdi (Rsi ,di + si+1 Psi+1 | si ,di  Vsi+1 ). Last, the optimal expected value of the reward,
which depends on the initial state s1 , is Vs1 .
Let us prove by induction
that forP
all i  [1,
P
Q T  1],
P
Vs1 = maxd1 s2 . . .maxdi si+1 (( k[1,i] Psk+1 | sk ,dk )  (( k[1,i] Rsk ,dk ) + Vsi+1 )).
This proposition holds for i = 1, since P

Vs1 = maxd1 (R
P s1 ,d1 + s2 Ps2 | s1 ,d1  Vs2)
P
= maxd1 s2 (Ps2 | s1 ,d1  (Rs1 ,d1 + Vs2 )) (since s2 Ps2 | s1 ,d1 = 1).
481

fiPralet, Verfaillie, & Schiex

Moreover, if the proposition
holds P
at stepQi  1 (with i > 1), then P
P
Vs1 = maxd1 s2 . . . maxdi1 si (( k[1,i1] Psk+1 | sk ,dk )  (( k[1,i1] Rsk ,dk ) + Vsi )).
Given
P that
P
P
( k[1,i1] Rsk ,dk ) + Vsi = ( k[1,i1] Rsk ,dk ) + maxdi (Rsi ,di + si+1 Psi+1 | si ,di  Vsi+1 )
P
P
= maxdi (( k[1,i] Rsk ,dk ) + si+1 Psi+1 | si ,di  Vsi+1 )
P
P
= maxdi si+1 Psi+1 | si ,di  (( k[1,i] Rsk ,dk ) + Vsi+1 )
P
(the last equality holds since si+1 Psi+1 | si ,di = 1), it can be inferred that
Q
P
( k[1,i1] Psk+1 | sk ,dk )  (( k[1,i1] Rsk ,dk ) + Vsi )
P
Q
P
= maxdi si+1 (( k[1,i] Psk+1 | sk ,dk )  (( k[1,i] Rsk ,dk ) + Vsi+1 )),
which proves that the proposition holds at step i. This proves that it also holds at step T , and
therefore Vs1 = Ans(Q). Furthermore, as each step in the proof preserves the set of optimal
decision rules, an optimal MDP-policy can be recorded during the evaluation of Ans(Q).
We now study the case of partially observable finite horizon MDPs (finite horizon POMDPs).
In a POMDP, we add for each time step t > 1 a conditional probability distribution Pot | st
of making observation ot at time step t given the state st . The value of st remains unobserved. We also assume that a probability distribution Ps1 over the initial state is available.
The subsumption proof for this case is more difficult. We consider the approach of POMDPs
which consists in finding an optimal policy tree. This approach is equivalent to compute,
for each decision variable dt , a decision rule for dt depending on the observations made so
far, i.e. a function dt : dom({o2 , . . . , ot })  dom(dt ). The set of such functions is denoted
dt . A set  = {d1 , . . . , dT } is called a POMDP-policy. The value of a POMDP-policy
is recursively defined as follows. First, the value of the reward at the last decision step,
which depends on the assignment AsT of sT and on the observations O2T made from the
beginning, is V ()sT ,o2 ,...,ot (AsT .O2T ) = RsT ,dT (AsT , dT (O2T )). At a time step i, the
obtained reward depends on the actual state Asi and on the observations O2i made so far.
Its expression is:
V ()si ,o2 ,...,o
P
Pi (Asi .O2i )
= (Rsi ,di + si+1 Psi+1 | si ,di  oi+1 Poi+1 | si+1  V ()si+1 ,o1 ,...,oi+1 )(A)
where A = Asi .di (O2i ).O2i This equation and the recursive formula used to define the
value of a policy tree for a POMDP (Kaelbling, Littman, & Cassandra,P
1998) are equivalent. Finally, the expected reward of the POMDP-policy  is V () = s1 Ps1  V ()s1 .
Solving a finite horizon POMDP consists in computing the optimal expected reward among
all POMDP-policies (i.e. in computing V  = maxd1 ,...,dT V ({d1 , . . . , dT })), as well as
associated optimal decision rules.
Using a proof by induction as in the observable MDP case, it is first possible to prove that
for a problem with T steps, P
P
V  = maxd1 ,...,dT o2 ,...,oT s1 ,...,sT V
Q
Q
P
with V = (Ps1  i[1,T [ Psi+1 | si ,di  i[1,T [ Poi+1 | si+1 )  ( i[1,T ] Rsi ,di ).
From this, a recursive use of Lemma
3 enables
P
P us to infer
Pthat
P
V  = maxd1 o2 maxd2 o3 maxd3 . . . oT maxdT s1 ,...,sT V .
It proves that the query defined below enables us to compute V  as well as an optimal policy:
 algebraic structure: probabilistic expected additive utility (row 1 in Table 1);
 PFU network: N = (V, G, P, , U ); V equals {si | i  [1, T ]}  {oi | i  [2, T ]}  {di | i 
[1, T ]}, with VD = {di | i  [1, T ]}; G is a DAG with one variable per component; a
decision component does not have any parents, an environment component {oi } has
{si } as parent, and a component {si+1 } has {si } and {di } as parents; P = {Ps1 } 
{Psi+1 | si ,di , i  [1, T  1]}  {Poi | si | i  [2, T ]}; F act({s1 }) = {Ps1 }, F act({si+1 }) =
{Psi+1 | si ,di }, and F act({oi }) = {Poi | si }; last, U = {Rsi ,di | i  [1, T ]};
482

fiThe PFU Framework

 PFU query: based on the DAG, a necessary condition for a query to be defined is that
each decision di must appear to the left of the variables in {sk | k  [i + 1, T ]}  {ok | k 
[i + 1, T ]}; the query considered is Q = (N , Sov), with
Sov = (max, d1 ).(+, o2 ).(max, d2 ). . . . .(+, oT ).(max, dT ).(+, {s1 , . . . , sT }).
The proofs for finite horizon (PO)MDPs based on possibilities or on -rankings are similar.
As for the subsumption of factored MDPs, we can first argue that every factored MDP can
be represented as a usual MDP, and therefore as a PFU query on a PFU network. Even if
this is a sufficient argument, we can define a better representation of factored MDPs in the
PFU framework: it corresponds to a representation where the variables describing states are
directly used together with the local plausibility functions and rewards, which can be modeled
by scoped functions (defined as decision trees, binary decision diagrams. . . ).
10. (Queries on Bayesian networks, Pearl, 1988, Markov random fields, Chellappa & Jain, 1993,
and chain graphs, Frydenberg, 1990 )
It suffices to consider chain graphs, since Bayesian networks and Markov random fields are
particular cases of chain graphs. The subsumption proofs are provided for the general case of
plausibility distributions defined on a totally ordered conditionable plausibility structure.
(a) (MAP, MPE, and probability of an evidence) As MPE (Most Probable Explanation) and
the computation of the probability of an evidence are particular cases of MAP (Maximum
A Posteriori hypothesis), it suffices to prove that MAP is subsumed. The probabilistic
MAP problem consists in finding, given a probability distribution PV , a Maximum A
Posteriori explanation to an assignment of a subset O of V which has been observed (also
called evidence). More formally, let D denote the set of variables on which an explanation
is sought and let e denote the observed assignment of O. The MAP problem consists in
finding an assignment A of D such that maxAdom(D) PD | O (A.e) = PD | O (A .e). As
PD | O = PD,O /PO , we can write:
maxAdom(D) PD | O (A.e) = (maxAdom(D) P
PD,O (A.e))/PO (e)
= (maxAdom(D) A0 dom(V (DO)) PV (A.e.A0 ))/PO (e)
P
Thus, computing maxD V (DO) PV (e) is sufficient (the difference lies only in a normalizing constant). This result can be generalized to all totally ordered conditionable
plausibility structures.
Indeed, as p is monotonic, maxAdom(D) PD,O (A.e) = (maxAdom(D) PD | O (A.e)) p
PO (e). If maxAdom(D) PD,O (A.e) p PO (e), then there exists a unique p  Ep such
that maxAdom(D) PD,O (A.e) = p p PO (e). This gives us p = maxAdom(D) PD | O (A.e).
Otherwise, if maxAdom(D) PD,O (A.e) = PO (e), then we can infer that there exists
A  dom(D) such that PD,O (A .e) = PO (e), and therefore PD | O (A .e) = 1p . Thus,
maxAdom(D) PD | O (A.e) = 1p too. This shows that determining maxAdom(D) PD,O (A.e)
gives maxAdom(D) PD | O (A.e).
Moreover, if A  argmax{PD,O (A0 .e), A0  dom(D)}, then max{p  Ep | PD,O (A .e) =
p p PO (e)} p max{p  Ep | PD,O (A.e) = p p PO (e)} for all A  dom(D). Therefore, an optimal assignment of D for maxD PD,O (e) is also an optimal assignment of D
for maxD PD | O (e). As a result, the MAP problem can be reduced to the computation of
maxD PD,O (e) = maxD p V (DO) PV (e) = maxD p V D (PV p O )
where O is the scoped function with scope O such that O (e0 ) = 1p if e0 = e, 0p otherwise. We define a PFU query whose answer is Ans(Q) = maxD p V D (PV p O ):
 the plausibility structure is (Ep , p , p ), the utility structure is (Eu , u ) = (Ep , p ),
and the expected utility structure is (Ep , Eu , u , pu ) = (Ep , Ep , p , p );
 PFU network: the difficulty in the definition of the PFU network lies in the fact that
normalization conditions on components must be satisfied. The idea is that only the
483

fiPralet, Verfaillie, & Schiex

components in which a variable in D  O is involved have to be modified. The PFU
network is N = (V, G, P, , U ); V the set of variables of the chain graph; VD = D
and VE = V D; G is a DAG of components obtained from the DAG G0 of the chain
graph by splitting every component c in which a variable in D  O is involved: such
a component c is transformed into |c| components containing only one variable; all
these |c| components become parents of the child components of c; for a component
{x0 } included in one of these |c| components, if x0  D, then {x0 } is a decision
component; otherwise, {x0 } is an environment component, and we create a plausibility function Pi , equal to a constant p0 (x0 ) such that p i[1,|dom(x0 )|] p0 (x0 ) = 1p ,
and such that F act({x0 }) = {p0 (x0 )}; P contains first the constants defined above,
and second the factors expressing Pc | paG0 (c) in the chain graph for the components
c satisfying c  (D  O) = ; last, U contains the factors expressing Pc | paG0 (c) in the
chain graph for the components c such that c  (D  O) 6= , and a constant factor
p1 (x0 ) satisfying p1 (x0 ) p p0 (x0 ) = 1p for each component {x0 } created in the
splitting process described above, and hard constraints representing O ; with this
PFU network, the local normalization conditions are satisfied, and the combination
of the local functions equals PV p O ;
 PFU query: the query is simply Q = (N , (max, D).(u , V  D)).
An optimal decision rule for D can be recorded during the computation of Ans(Q).
(b) (Plausibility distribution computation task ) Given a plausibility distribution PV expressed as a combination of plausibility functions as in chain graphs, the goal is to
compute the plausibility distribution PS over a set S  V . The basic formula PS =
p V S PV proves that the query defined below actually computes PS . This query shows
the usefulness of free variables.
 the plausibility structure is (Ep , p , p ), the utility structure is (Eu , u ) = (Ep , p ),
and the expected utility structure is (Ep , Eu , u , pu ) = (Ep , Ep , p , p );
 PFU network: N = (V, G, P, , U ), with VE = V  S, VD = S, and with the DAG
G and the sets P , U obtained similarly as for the MAP case;
 PFU query: Q = (N , (u , V  S))
11. (Hybrid networks, Dechter & Larkin, 2001 )
A hybrid network is a triple (G, P, F ), where G is a DAG on a set of variables V partitioned
into R and D, P is a set of probability distributions expressing Pr | paG (r) for all r  R,
and F is a set of functions fpaG (d) for all d  D (variables in D are deterministic, in the
sense that their value is completely determined by the assignment of their parents). The
most general task on hybrid networks is the task of belief assessment conditioned on a formula  in conjunctive normal form. It consists of computing the probability distribution
of a variable x given a complex evidence  (complex because it may involve several variables).
P Ignoring a normalizing constant, it requires to compute, for all assignments (x, a) of
x, Adom(V {x}) | (A.(x,a))=t PV (A.(x, a)). If C = {C1 , . . . , Cm } denotes the set of clauses
P
Q
Q
Q
of , it also equals ( V {x} ( rR Pr | paG (r) )  ( dD fpaG (d) )  ( Ci C Ci ))((x, a)).
The query corresponding to this computation uses the probabilistic expected satisfaction structure (row 2 in Table 1), and the PFU network N = (V, G, P, , U ), with VE = V , VD = {x},
P = {Pr | paG (r) | r  R  {x}}  {fpaG (d) | d  D  {x}}, and either U = C  {Px | paG (x) } if
x  R or U = C  {fpaG (x) } if x  D. The query is Q = (N , (+, V  {x})).

484

fiThe PFU Framework

References
Bacchus, F., & Grove, A. (1995). Graphical Models for Preference and Utility. In Proc. of
the 11th International Conference on Uncertainty in Artificial Intelligence (UAI-95),
pp. 310, Montreal, Canada.
Bahar, R., Frohm, E., Gaona, C., Hachtel, G., Macii, E., Pardo, A., & Somenzi, F. (1993).
Algebraic Decision Diagrams and Their Applications. In IEEE /ACM International
Conference on CAD, pp. 188191, Santa Clara, California, USA. IEEE Computer
Society Press.
Bertele, U., & Brioschi, F. (1972). Nonserial Dynamic Programming. Academic Press.
Bistarelli, S., Montanari, U., Rossi, F., Schiex, T., Verfaillie, G., & Fargier, H. (1999).
Semiring-Based CSPs and Valued CSPs: Frameworks, Properties and Comparison.
Constraints, 4 (3), 199240.
Bodlaender, H. (1997). Treewidth: Algorithmic techniques and results. In Proc. of the
22nd International Symposium on Mathematical Foundations of Computer Science
(MFCS-97).
Bordeaux, L., & Monfroy, E. (2002). Beyond NP: Arc-consistency for Quantified Constraints. In Proc. of the 8th International Conference on Principles and Practice of
Constraint Programming (CP-02), Ithaca, New York, USA.
Boutilier, C., Brafman, R., Domshlak, C., Hoos, H., & Poole, D. (2004). CP-nets: A Tool for
Representing and Reasoning with Conditional Ceteris Paribus Preference Statements.
Journal of Artificial Intelligence Research, 21, 135191.
Boutilier, C., Dean, T., & Hanks, S. (1999). Decision-Theoretic Planning: Structural Assumptions and Computational Leverage. Journal of Artificial Intelligence Research,
11, 194.
Boutilier, C., Dearden, R., & Goldszmidt, M. (2000). Stochastic Dynamic Programming
with Factored Representations. Artificial Intelligence, 121 (1-2), 49107.
Boutilier, C., Friedman, N., Goldszmidt, M., & Koller, D. (1996). Context-Specific Independence in Bayesian Networks. In Proc. of the 12th International Conference on
Uncertainty in Artificial Intelligence (UAI-96), pp. 115123, Portland, Oregon, USA.
Chellappa, R., & Jain, A. (1993). Markov Random Fields: Theory and Applications. Academic Press.
Chu, F., & Halpern, J. (2003a). Great Expectations. Part I: On the Customizability of
Generalized Expected Utility. In Proc. of the 18th International Joint Conference on
Artificial Intelligence (IJCAI-03), Acapulco, Mexico.
Chu, F., & Halpern, J. (2003b). Great Expectations. Part II: Generalized Expected Utility
as a Universal Decision Rule. In Proc. of the 18th International Joint Conference on
Artificial Intelligence (IJCAI-03), pp. 291296, Acapulco, Mexico.
Cooper, M., & Schiex, T. (2004). Arc Consistency for Soft Constraints. Artificial Intelligence, 154 (1-2), 199227.
Darwiche, A. (2001). Recursive Conditioning. Artificial Intelligence, 126 (1-2), 541.
485

fiPralet, Verfaillie, & Schiex

Darwiche, A., & Ginsberg, M. (1992). A Symbolic Generalization of Probability Theory.
In Proc. of the 10th National Conference on Artificial Intelligence (AAAI-92), pp.
622627, San Jose, CA, USA.
Dechter, R. (1999). Bucket Elimination: a Unifying Framework for Reasoning. Artificial
Intelligence, 113 (1-2), 4185.
Dechter, R., & Fattah, Y. E. (2001). Topological Parameters for Time-Space Tradeoff.
Artificial Intelligence, 125 (1-2), 93118.
Dechter, R., & Larkin, D. (2001). Hybrid Processing of Beliefs and Constraints. In Proc. of
the 17th International Conference on Uncertainty in Artificial Intelligence (UAI-01),
pp. 112119, Seattle, WA, USA.
Dechter, R., & Mateescu, R. (2004). Mixtures of Deterministic-Probabilistic Networks
and their AND/OR Search Space. In Proc. of the 20th International Conference on
Uncertainty in Artificial Intelligence (UAI-04), Banff, Canada.
Demirer, R., & Shenoy, P. (2001). Sequential Valuation Networks: A New Graphical Technique for Asymmetric Decision Problems. In Proc. of the 6th European Conference on
Symbolic and Quantitavive Approaches to Reasoning with Uncertainty (ECSQARU01), pp. 252265, London, UK.
Dubois, D., & Prade, H. (1995). Possibility Theory as a Basis for Qualitative Decision
Theory. In Proc. of the 14th International Joint Conference on Artificial Intelligence
(IJCAI-95), pp. 19251930, Montreal, Canada.
Fargier, H., Lang, J., & Schiex, T. (1996). Mixed Constraint Satisfaction: a Framework
for Decision Problems under Incomplete Knowledge. In Proc. of the 13th National
Conference on Artificial Intelligence (AAAI-96), pp. 175180, Portland, OR, USA.
Fargier, H., & Perny, P. (1999). Qualitative Models for Decision Under Uncertainty without
the Commensurability Assumption. In Proc. of the 15th International Conference on
Uncertainty in Artificial Intelligence (UAI-99), pp. 188195, Stockholm, Sweden.
Fikes, R., & Nilsson, N. (1971). STRIPS: a New Approach to the Application of Theorem
Proving. Artificial Intelligence, 2 (3-4), 189208.
Fishburn, P. (1982). The Foundations of Expected Utility. D. Reidel Publishing Company,
Dordrecht.
Friedman, N., & Halpern, J. (1995). Plausibility Measures: A Users Guide. In Proc. of the
11th International Conference on Uncertainty in Artificial Intelligence (UAI-95), pp.
175184, Montreal, Canada.
Frydenberg, M. (1990). The Chain Graph Markov Property. Scandinavian Journal of
Statistics, 17, 333353.
Ghallab, M., Nau, D., & Traverso, P. (2004). Automated Planning: Theory and Practice.
Morgan Kaufmann.
Giang, P., & Shenoy, P. (2000). A Qualitative Linear Utility Theory for Spohns Theory
of Epistemic Beliefs. In Proc. of the 16th International Conference on Uncertainty in
Artificial Intelligence (UAI-00), pp. 220229, Stanford, California, USA.

486

fiThe PFU Framework

Giang, P., & Shenoy, P. (2005). Two Axiomatic Approaches to Decision Making Using
Possibility Theory. European Journal of Operational Research, 162 (2), 450467.
Goldman, R., & Boddy, M. (1996). Expressive Planning and Explicit Knowledge. In Proc. of
the 3rd International Conference on Artificial Intelligence Planning Systems (AIPS96), pp. 110117, Edinburgh, Scotland.
Halpern, J. (2001). Conditional Plausibility Measures and Bayesian Networks. Journal of
Artificial Intelligence Research, 14, 359389.
Halpern, J. (2003). Reasoning about Uncertainty. The MIT Press.
Howard, R., & Matheson, J. (1984). Influence Diagrams. In Readings on the Principles and
Applications of Decision Analysis, pp. 721762. Strategic Decisions Group, Menlo
Park, CA, USA.
Jegou, P., & Terrioux, C. (2003). Hybrid Backtracking bounded by Tree-decomposition of
Constraint Networks. Artificial Intelligence, 146 (1), 4375.
Jensen, F., Nielsen, T., & Shenoy, P. (2004). Sequential Influence Diagrams: A Unified
Asymmetry Framework. In Proceedings of the Second European Workshop on Probabilistic Graphical Models (PGM-04), pp. 121128, Leiden, Netherlands.
Jensen, F., & Vomlelova, M. (2002). Unconstrained Influence Diagrams. In Proc. of the
18th International Conference on Uncertainty in Artificial Intelligence (UAI-02), pp.
234241, Seattle, WA, USA.
Kaelbling, L., Littman, M., & Cassandra, A. (1998). Planning and Acting in Partially
Observable Stochastic Domains. Artificial Intelligence, 101 (1-2), 99134.
Kolhas, J. (2003). Information Algebras: Generic Structures for Inference. Springer.
Kushmerick, N., Hanks, S., & Weld, D. (1995). An Algorithm for Probabilistic Planning.
Artificial Intelligence, 76 (1-2), 239286.
Larrosa, J., & Schiex., T. (2003). In the quest of the best form of local consistency for
weighted csp. In Proc. of the 18th International Joint Conference on Artificial Intelligence (IJCAI-03), Acapulco, Mexico.
Lauritzen, S., & Nilsson, D. (2001). Representing and Solving Decision Problems with
Limited Information. Management Science, 47 (9), 12351251.
Littman, M., Majercik, S., & Pitassi, T. (2001). Stochastic Boolean Satisfiability. Journal
of Automated Reasoning, 27 (3), 251296.
Mackworth, A. (1977). Consistency in Networks of Relations. Artificial Intelligence, 8 (1),
99118.
Monahan, G. (1982). A Survey of Partially Observable Markov Decision Processes: Theory,
Models, and Algorithms. Management Science, 28 (1), 116.
Ndilikilikesha, P. (1994). Potential Influence Diagrams. International Journal of Approximated Reasoning, 10, 251285.
Nielsen, T., & Jensen, F. (2003). Representing and solving asymmetric decision problems.
International Journal of Information Technology and Decision Making, 2, 217263.

487

fiPralet, Verfaillie, & Schiex

Pearl, J. (1988). Probabilistic Reasoning in Intelligent Systems: Networks of Plausible Inference. Morgan Kaufmann.
Perny, P., Spanjaard, O., & Weng, P. (2005). Algebraic Markov Decision Processes. In
Proc. of the 19th International Joint Conference on Artificial Intelligence (IJCAI05), Edinburgh, Scotland.
Pralet, C. (2006). A Generic Algebraic Framework for Representing and Solving Sequential Decision Making Problems with Uncertainties, Feasibilities, and Utilities. Ph.D.
thesis, Ecole Nationale Superieure de lAeronautique et de lEspace, Toulouse, France.
Pralet, C., Schiex, T., & Verfaillie, G. (2006a). Decomposition of Multi-Operator Queries
on Semiring-based Graphical Models. In Proc. of the 12th International Conference
on Principles and Practice of Constraint Programming (CP-06), pp. 437452, Nantes,
France.
Pralet, C., Schiex, T., & Verfaillie, G. (2006b). From Influence Diagrams to Multioperator
Cluster DAGs. In Proc. of the 22nd International Conference on Uncertainty in
Artificial Intelligence (UAI-06), Cambridge, MA, USA.
Pralet, C., Verfaillie, G., & Schiex, T. (2006c). Decision with Uncertainties, Feasibilities,
and Utilities: Towards a Unified Algebraic Framework. In Proc. of the 17th European
Conference on Artificial Intelligence (ECAI-06), pp. 427431, Riva del Garda, Italy.
Puterman, M. (1994). Markov Decision Processes, Discrete Stochastic Dynamic Programming. John Wiley & Sons.
Sabbadin, R. (1999). A Possibilistic Model for Qualitative Sequential Decision Problems
under Uncertainty in Partially Observable Environments. In Proc. of the 15th International Conference on Uncertainty in Artificial Intelligence (UAI-99), pp. 567574,
Stockholm, Sweden.
Sang, T., Beame, P., & Kautz, H. (2005). Solving Bayesian Networks by Weighted Model
Counting. In Proc. of the 20th National Conference on Artificial Intelligence (AAAI05), pp. 475482, Pittsburgh, PA, USA.
Schmeidler, D. (1989). Subjective Probability and Expected Utility without Additivity.
Econometrica, 57 (3), 571587.
Schrijver, A. (1998). Theory of Linear and Integer Programming. John Wiley and Sons.
Shafer, G. (1976). A Mathematical Theory of Evidence. Princeton University Press.
Shenoy, P. (1991). Valuation-based Systems for Discrete Optimization. Uncertainty in
Artificial Intelligence, 6, 385400.
Shenoy, P. (1992). Valuation-based Systems for Bayesian Decision Analysis. Operations
Research, 40 (3), 463484.
Shenoy, P. (1994). Conditional Independence in Valuation-Based Systems. International
Journal of Approximated Reasoning, 10 (3), 203234.
Shenoy, P. (2000). Valuation Network Representation and Solution of Asymmetric Decision
Problems. European Journal of Operational Research, 121, 579608.

488

fiThe PFU Framework

Smith, J., Holtzman, S., & Matheson, J. (1993). Structuring Conditional Relationships in
Influence Diagrams. Operations Research, 41, 280297.
Spohn, W. (1990). A General Non-Probabilistic Theory of Inductive Reasoning. In Proc. of
the 6th International Conference on Uncertainty in Artificial Intelligence (UAI-90),
pp. 149158, Cambridge, MA, USA.
von Neumann, J., & Morgenstern, O. (1944). Theory of Games and Economic Behaviour.
Princeton University Press.
Walsh, T. (2002). Stochastic Constraint Programming. In Proc. of the 15th European
Conference on Artificial Intelligence (ECAI-02), pp. 111115, Lyon, France.
Weydert, E. (1994). General Belief Measures. In Proc. of the 10th International Conference
on Uncertainty in Artificial Intelligence (UAI-94), pp. 575582.
Wilson, N. (1995). An Order of Magnitude Calculus. In Proc. of the 11th International
Conference on Uncertainty in Artificial Intelligence (UAI-95), pp. 548555, Montreal,
Canada.

489

fi