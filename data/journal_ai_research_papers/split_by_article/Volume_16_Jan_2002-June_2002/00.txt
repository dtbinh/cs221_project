Journal of Artificial Intelligence Research 16 (2002) 1-58

Submitted 7/01; published 1/02

Fusions of Description Logics and
Abstract Description Systems
Franz Baader
Carsten Lutz

baader@cs.rwth-aachen.de
lutz@cs.rwth-aachen.de

Teaching and Research Area for Theoretical Computer Science,
RWTH Aachen, Ahornstrae 55, 52074 Aachen, Germany

Holger Sturm

holger.sturm@uni-konstanz.de

Fachbereich Philosophie, Universitat Konstanz,
78457 Konstanz, Germany

Frank Wolter

wolter@informatik.uni-leipzig.de

Institut fur Informatik, Universitat Leipzig,
Augustus-Platz 10-11, 04109 Leipzig, Germany

Abstract
Fusions are a simple way of combining logics. For normal modal logics, fusions have
been investigated in detail. In particular, it is known that, under certain conditions, decidability transfers from the component logics to their fusion. Though description logics
are closely related to modal logics, they are not necessarily normal. In addition, ABox
reasoning in description logics is not covered by the results from modal logics.
In this paper, we extend the decidability transfer results from normal modal logics to
a large class of description logics. To cover different description logics in a uniform way,
we introduce abstract description systems, which can be seen as a common generalization
of description and modal logics, and show the transfer results in this general setting.

1. Introduction
Knowledge representation systems based on description logics (DL) can be used to represent the knowledge of an application domain in a structured and formally well-understood
way (Brachman & Schmolze, 1985; Baader & Hollunder, 1991; Brachman, McGuinness,
Patel-Schneider, Alperin Resnick, & Borgida, 1991; Woods & Schmolze, 1992; Borgida,
1995; Horrocks, 1998). In such systems, the important notions of the domain can be described by concept descriptions, i.e., expressions that are built from atomic concepts (unary
predicates) and atomic roles (binary predicates) using the concept constructors provided
by the description logic employed by the system. The atomic concepts and the concept
descriptions represent sets of individuals, whereas roles represent binary relations between
individuals. For example, using the atomic concepts Woman and Human, and the atomic
role child, the concept of all women having only daughters (i.e., women such that all their
children are again women) can be represented by the description Woman u child.Woman,
and the concept of all mothers by the description Woman u child.Human. In this example,
we have used the constructors concept conjunction (u), value restriction (R.C), and existential restriction (R.C). In the DL literature, also various other constructors have been
considered. A prominent example are so-called number restrictions, which are available in
almost all DL systems. For example, using number restrictions the concept of all women
c
2002
AI Access Foundation and Morgan Kaufmann Publishers. All rights reserved.

fiBaader, Lutz, Sturm, & Wolter

having exactly two children can be represented by the concept description
Woman u ( 2child) u ( 2child).
The knowledge base of a DL system consists of a terminological component (TBox) and
an assertional component (ABox). In its simplest form, the TBox consists of concept
definitions, which assign names (abbreviations) to complex descriptions. More general TBox
formalisms allow for so-called general concept inclusion axioms (GCIs) between complex
descriptions. For example, the concept inclusion
Human u ( 3child) v entitled.Taxbreak
states that people having at least three children are entitled to a tax break. The ABox
formalism consists of concept assertions (stating that an individual belongs to a concept)
and role assertions (stating that two individuals are related by a role). For example, the
assertions Woman(MARY), child(MARY, TOM), Human(TOM) state that Mary is a woman,
who has a child, Tom, who is a human.
DL systems provide their users with various inference capabilities that allow them to
deduce implicit knowledge from the explicitly represented knowledge. For instance, the subsumption problem is concerned with subconcept-superconcept relationships: C is subsumed
by D (C v D) if, and only if, all instances of C are also instances of D, i.e., the first description is always interpreted as a subset of the second description. For example, the concept
description Woman obviously subsumes the concept description Woman u child.Woman.
The concept description C is satisfiable iff it is non-contradictory, i.e., it can be interpreted
by a nonempty set. In DLs allowing for conjunction and negation of concepts, subsumption can be reduced to (un)satisfiability: C v D iff C u D is unsatisfiable. The instance
checking problem consists of deciding whether a given individual is an instance of a given
concept. For example, w.r.t. the assertions from above, MARY is an instance of the concept
description Woman u child.Human. The ABox A is consistent iff it is non-contradictory,
i.e., it has a model. In DLs allowing for negation of concepts, the instance problem can be
reduced to (in)consistency of ABoxes: i is an instance of C w.r.t. the ABox A iff A{C(i)}
is inconsistent.
In order to ensure a reasonable and predictable behavior of a DL system, reasoning
in the DL employed by the system should at least be decidable, and preferably of low
complexity. Consequently, the expressive power of the DL in question must be restricted in
an appropriate way. If the imposed restrictions are too severe, however, then the important
notions of the application domain can no longer be expressed. Investigating this trade-off
between the expressivity of DLs and the complexity of their inference problems has thus
been one of the most important issues in DL research (see, e.g., Levesque & Brachman,
1987; Nebel, 1988; Schmidt-Schau, 1989; Schmidt-Schau & Smolka, 1991; Nebel, 1990;
Donini, Lenzerini, Nardi, & Nutt, 1991, 1997; Donini, Hollunder, Lenzerini, Spaccamela,
Nardi, & Nutt, 1992; Schaerf, 1993; Donini, Lenzerini, Nardi, & Schaerf, 1994; De Giacomo
& Lenzerini, 1994a, 1994b, 1995; Calvanese, De Giacomo, & Lenzerini, 1999; Lutz, 1999;
Horrocks, Sattler, & Tobies, 2000).
This paper investigates an approach for extending the expressivity of DLs that (in many
cases) guarantees that reasoning remains decidable: the fusion of DLs. In order to explain
2

fiFusions of Description Logics and Abstract Description Systems

the difference between the usual union and the fusion of DLs, let us consider a simple
example. Assume that the DL D1 is ALC, i.e., it provides for the Boolean operators u, t,
 and the additional concept constructors value restriction R.C and existential restriction
R.C, and that the DL D2 provides for the Boolean operators and number restrictions
( nR) and ( nR). If an application requires concept constructors from both DLs for
expressing its relevant concepts, then one would usually consider the union D1  D2 of D1
and D2 , which allows for the unrestricted use of all constructors. For example, the concept
description C1 := (R.A) u (R.A) u ( 1R) is a legal D1  D2 description. Note that this
description is unsatisfiable, due to the interaction between constructors of D1 and D2 . The
fusion D1 D2 of D1 and D2 prevents such interactions by imposing the following restriction:
one assumes that the set of all role names is partitioned into two sets, one that can be used
in constructors of D1 , and another one that can be used in constructors of D2 . Thus, the
description C1 from above is not a legal D1  D2 description since it uses the same role R
both in the existential restrictions (which are D1 -constructors) and in the number restriction
(which is a D2 -constructor). In contrast, the descriptions (R1 .A) u (R1 .A) u ( 1R2 )
and (R1 .( 1R2 )) are admissible in D1  D2 since they employ different roles in the D1 and D2 -constructors. If the concepts that must be expressed are such that they require
both constructors from D1 and D2 , but the ones from D1 for other roles than the ones from
D2 , then one does not really need the union of D1 and D2 ; the fusion would be sufficient.
What is the advantage of taking the fusion instead of the union? Basically, for the union
of two DLs one must design new reasoning methods, whereas reasoning in the fusion can be
reduced to reasoning in the component DLs. Indeed, reasoning in the union may even be
undecidable whereas reasoning in the fusion is still decidable. As an example, we consider
the DLs (i) ALCF, which extends the basic DL ALC by functional roles (features) and
the same-as constructor (agreement) on chains of functional roles (Hollunder & Nutt, 1990;
Baader, Burckert, Nebel, Nutt, & Smolka, 1993); and (ii) ALC +,,t , which extends ALC by
transitive closure, composition, and union of roles (Baader, 1991; Schild, 1991). For both
DLs, subsumption of concept descriptions is known to be decidable (Hollunder & Nutt,
1990; Schild, 1991; Baader, 1991). However, their union ALCF +,,t has an undecidable
subsumption problem (Baader et al., 1993). This undecidability result depends on the fact
that, in ALCF +,,t , the role constructors transitive closure, composition, and union can
be applied to functional roles that also appear within the same-as constructor. This is not
allowed in the fusion ALCF  ALC +,,t . Of course, failure of a certain undecidability proof
does not make the fusion decidable.
Why do we know that the fusion of decidable DLs is again decidable? Actually, in
general we dont, and this was our main reason for writing this paper. The notion fusion was introduced and investigated in modal logic, basically to transfer results like finite
axiomatizability, decidability, finite model property, etc. from uni-modal logics (with one
pair of box and diamond operators) to multi-modal logics (with several such pairs, possibly satisfying different axioms). This has led to rather general transfer results (see, e.g.,
Wolter, 1998; Kracht & Wolter, 1991; Fine & Schurz, 1996; Spaan, 1993; Gabbay, 1999
for results that concern decidability), which are sometimes restricted to so-called normal
modal logics (Chellas, 1980). Since there is a close relationship between modal logics and
DLs (Schild, 1991), it is clear that these transfer results also apply to some DLs. The question is, however, to which DLs exactly and to which inference problems. First, some DLs
3

fiBaader, Lutz, Sturm, & Wolter

allow for constructors that are not considered in modal logics (e.g., the same-as constructor
mentioned above). Second, some DL constructors that have been considered in modal logics, such as qualified number restrictions ( nR.C), ( nR.C) (Hollunder & Baader, 1991),
which correspond to graded modalities (Van der Hoek & de Rijke, 1995), can easily be
shown to be non-normal. Third, the transfer results for decidability are concerned with the
satisfiability problem (with or without general inclusion axioms). ABoxes and the related
inference problems are not considered. ABoxes can be simulated in modal logics allowing
for so-called nominals, i.e., names for individuals, within formulae (Prior, 1967; Gargov
& Goranko, 1993; Areces, Blackburn, & Marx, 2000). However, as we will see below, the
general transfer results do not apply to modal logics with nominals.
The purpose of this paper is to clarify for which DLs decidability of the component DLs
transfers to their fusion. To this purpose, we introduce so-called abstract description systems
(ADSs), which can be seen as a common generalization of description and modal logics.
We define the fusion of ADSs, and state four theorems that say under which conditions
decidability transfers from the component ADSs to their fusion. Two of these theorems
are concerned with inference w.r.t. general concept inclusion axioms and two with inference
without TBox axioms. In both cases, we first formulate and prove the results for the
consistency problem of ABoxes (more precisely, the corresponding problem for ADSs) and
then establish analogous results for the satisfiability problem of concepts.
From the DL point of view, the four theorems shown in this paper are concerned with
the following four decision problems:
(i) decidability of consistency of ABoxes w.r.t. TBox axioms (Theorem 17);
(ii) decidability of satisfiability of concepts w.r.t. TBox axioms; (Corollary 22);
(iii) decidability of consistency of ABoxes without TBox axioms (Theorem 29); and
(iv) decidability of satisfiability of concepts without TBox axioms (Corollary 34).
These theorems imply that decidability of the consistency problem and the satisfiability
problem transfers to the fusion for most DLs considered in the literature. The main exceptions (which do not satisfy the prerequisites of the theorems) are
(a) DLs that are not propositionally closed, i.e., do not contain all Boolean connectives;
(b) DLs allowing for individuals (called nominals in modal logic) in concept descriptions;
and
(c) DLs explicitly allowing for the universal role or for negation of roles.
Results from modal logic for problem (iv) usually require the component modal logics to
be normal. Our Theorem 29 is less restrictive, and thus also applies to DLs allowing for
constructors like qualified number restrictions.

2. Description logics
Before defining abstract description systems in the next section, we introduce the main
features of DLs that must be covered by this definition. To this purpose, we first introduce
4

fiFusions of Description Logics and Abstract Description Systems

ALC, the basic DL containing all Boolean connectives, and the relevant inference problems.
Then, we consider different possibilities for extending ALC to more expressive DLs.
Definition 1 (ALC Syntax). Let NC , NR , and NI be countable and pairwise disjoint sets
of concept, role, and individual names, respectively. The set of ALC concept descriptions
is the smallest set such that
1. every concept name is a concept description,
2. if C and D are concept descriptions and R is a role name, then the following expressions are also concept descriptions:
 C (negation), C u D (conjunction), C t D (disjunction),
 R.C (existential restriction), and R.C (value restriction).
We use > as an abbreviation of A t A and  as an abbreviation for A u A (where A is
an arbitrary concept name).
Let C and D be concept descriptions. Then C v D is a general concept inclusion axiom
(GCI). A finite set of such axioms is called a TBox.
Let C be a concept description, R a role name, and i, j individual names. Then C(i) is
a concept assertion and R(i, j) a role assertion. A finite set of such assertions is called an
ABox.
The meaning of ALC-concept descriptions, TBoxes, and ABoxes can be defined with
the help of a set-theoretic semantics.
Definition 2 (ALC Semantics). An ALC-interpretation I is a pair (I , I ), where I
is a nonempty set, the domain of the interpretation, and I is the interpretation function.
The interpretation function maps
 each concept name A to a subset AI of I ,
 each role name R to a subset RI of I  I ,
 each individual name i to an element iI of I such that different names are mapped
to different elements (unique name assumption).
For a role name R and an element a  I we define RI (a) := {b | (a, b)  RI }. The
interpretation function can inductively be extended to complex concepts as follows:
(C)I := I \ C I
(C u D)I := C I  DI
(C t D)I := C I  DI
(R.C)I := {a  I | RI (a)  C I 6= }
(R.C)I := {a  I | RI (a)  C I }
An interpretation I is a model of the TBox T iff it satisfies C I  DI for all GCIs C v D
in T . It is a model of the ABox A iff it satisfies iI  C I for all concept assertions C(i)  A
and (iI , j I )  RI for all role assertions R(i, j)  A. Finally, I is a model of an ABox
relative to a TBox iff it is a model of both the ABox and the TBox.
5

fiBaader, Lutz, Sturm, & Wolter

Given this semantics, we can now formally define the relevant inference problems.
Definition 3 (Inferences). Let C and D be concept descriptions, i an individual name,
T a TBox, and A an ABox. We say that C subsumes D relative to the TBox T (D vT C)
iff DI  C I for all models I of T . The concept description C is satisfiable relative to the
TBox T iff there exists a model I of T such that C I 6= . The individual i is an instance of
C in the ABox A relative to the TBox T iff iI  C I for all models of A relative to T . The
ABox A is consistent relative to the TBox T iff there exists a model of A relative to T .
These three inferences can also be considered without reference to a TBox: C subsumes
D (C is satisfiable) iff C subsumes D (C is satisfiable) relative to the empty TBox, and i
is an instance of C in A (A is consistent) iff i is an instance of C in A (A is consistent)
relative to the empty TBox.
We restrict our attention to DLs that are propositionally closed (i.e., allow for the
Boolean operators conjunction, disjunction, and negation). Consequently, subsumption
can be reduced to (un)satisfiability since C vT D iff C u D is unsatisfiable relative to T .
Conversely, (un)satisfiability can be reduced to subsumption since C is unsatisfiable relative
to T iff C vT . For this reason, it is irrelevant whether we consider the subsumption or the
satisfiability problem in our results concerning the transfer of decidability of these problems
from component DLs to their fusion (informally called transfer results in the following).
Similarly, the instance problem can be reduced to the (in)consistency problem and vice
versa: i is an instance of C in A relative to T iff A  {C(i)} is inconsistent relative to T ;
and A is inconsistent relative to T iff i is an instance of  in A relative to T , where i is an
arbitrary individual name. Consequently, it is irrelevant whether we consider the instance
problem or the consistency problem in our transfer results.
Finally, the satisfiability problem can be reduced to the consistency problem: C is satisfiable relative to T iff the ABox {C(i)} is consistent relative to T , where i is an arbitrary
individual name. However, the converse need not be true. It should be obvious that this
implies that a transfer result for the satisfiability problem does not yield the corresponding
transfer result for the consistency problem: from decidability of the consistency problem
for the component DLs we can only deduce decidability of the satisfiability problem in their
fusion. What might be less obvious is that a transfer result for the consistency problem need
not imply the corresponding transfer result for the satisfiability problem: if the satisfiability
problems in the component DLs are decidable, then the transfer result for the consistency
problem can just not be applied (since the prerequisite of this transfer result, namely, decidability of the consistency problem in the component DLs, need not be satisfied). However,
we will show that the method used to show the transfer result for the consistency problem
also applies to the satisfiability problem.
2.1 More expressive DLs
There are several possibilities for extending ALC in order to obtain a more expressive DL.
The three most prominent are adding additional concept constructors, adding role constructors, and formulating restrictions on role interpretations. In addition to giving examples
for such extensions, we also introduce a naming scheme for the obtained DLs. Additional
concept constructors are indicated by appending caligraphic letters to the language name,
role constructors by symbols in superscript, and restrictions on roles by letters in subscript.
6

fiFusions of Description Logics and Abstract Description Systems

We start with introducing restrictions on role interpretations, since we need to refer to
such restrictions when defining certain concept constructors.
2.1.1 Restrictions on role interpretations
These restrictions enforce the interpretations of roles to satisfy certain properties, such as
functionality, transitivity, etc. We consider three prominent examples:
1. Functional roles. Here one considers a subset NF of the set of role names NR ,
whose elements are called features. An interpretation must map features f  NF to
functional binary relations f I  I  I , i.e., relations satisfying a, b, c.f I (a, b) 
f I (a, c)  b = c. We will sometimes treat functional relations as partial functions,
and write f I (a) = b rather than f I (a, b). ALC extended with features is denoted by
ALC f .
2. Transitive roles. Here one considers a subset NR+ of NR . Role names R  NR+
are called transitive roles. An interpretation must map transitive roles R  NR+ to
transitive binary relations RI  I  I . ALC extended with transitive roles is
denoted by ALC R+ .
3. Role hierarchies. A role inclusion axiom is an expression of the form R v S with
R, S  NR . A finite set H of role inclusion axioms is called a role hierarchy. An
interpretation must satisfy RI  S I for all R v S  H. ALC extended with a role
hierarchy H is denoted by ALC H(H) . If H is clear from the context or irrelevant, we
write ALCH instead of ALC H(H) .
The above restrictions can also be combined with each other. For example, ALC HR+ is ALC
with a role hierarchy and transitive roles.
Transitive roles in DLs were first investigated by Sattler (1996). Features were introduced in DLs by Hollunder and Nutt (1990) and (under the name attributes) in the
CLASSIC system (Brachman et al., 1991), in both cases in conjunction with feature agreements and disagreements (see concept constructors below). Features without agreements
and disagreements are, e.g., used in the DL SHIF (Horrocks & Sattler, 1999), albeit in a
more expressive local way, where functionality can be asserted to hold at certain individuals, but not necessarily on the whole model. According to our naming scheme, we indicate
the presence of features in a DL by the letter f in subscript.1
A remark on role hierarchies is also in order: in our definition, if H1 and H2 are different
role hierarchies, then ALC H(H1 ) and ALC H(H2 ) are different DLs. In the DL literature,
usually only one logic ALCH is defined and role hierarchies are treated like TBoxes, i.e.,
satisfiability and subsumption are defined relative to TBoxes and role hierarchies (see, e.g.,
Horrocks, 1998). For our purposes, however, it is more convenient to define one DL per role
hierarchy since distinct role hierarchies impose distinct restrictions on the interpretation of
roles. The advantages of this approach will become clear later on when frames and abstract
description systems are introduced.
1. Note that some authors (e.g., Horrocks & Sattler, 1999) use an appended F to denote local features.
Following Hollunder and Nutt (1990), we will use F to denote a DL that allows for feature agreements
(see below).

7

fiBaader, Lutz, Sturm, & Wolter

Name
Unqualified
number restrictions
Qualified
number restrictions
Nominals
Feature agreement
and disagreement

Syntax
nR
nR
nR.C
nR.C
I
u1 u2
u1 u2

Semantics
{a  I | |RI (a)|  n}
{a  I | |RI (a)|  n}
{a  I | |RI (a)  C I |  n}
{a  I | |RI (a)  C I |  n}
I I  I with |I I | = 1
{a  I | b  I . uI1 (a) = b = uI2 (a)}
{a  I | b1 , b2  I .
uI1 (a) = b1 6= b2 = uI2 (b1 )}

Symbol
N
Q
O
F

Figure 1: Some description logic concept constructors.
2.1.2 Concept constructors
Concept constructors take concept and/or role descriptions and transform them into more
complex concept descriptions. In addition to the constructors available in ALC, various
other concept constructors are considered in the DL literature. A small collection of such
constructors can be found in Figure 1, where |S| denotes the cardinality of a set S. The
symbols in the rightmost column indicate the naming scheme for the resulting DL. As
mentioned above the name modifiers for concept constructors are not written in subscript,
they are appended to the language name. For example, ALC HR+ extended with qualified
number restrictions is called ALCQHR+ . The syntax of the extended DLs is as expected, i.e.,
the constructors may be arbitrarily combined. The semantics is obtained by augmenting
the semantics of ALC with the appropriate conditions, which can be found in the third
column in Figure 1. Nominals and feature (dis)agreements need some more explanation:
 Nominals. We consider a set NO of (names for) nominals, which is pairwise disjoint
to the sets NC , NR , and NI . Elements from NO are often denoted by I (possibly
with index). An interpretation must map nominals to singleton subsets of I . The
intention underlying nominals is that they stand for elements of , just like individual
names. However, since we want to use the nominal I  NO as a (nullary) concept
constructor, I must interpret them by a set, namely the singleton set consisting of
the individual that I denotes.
 Feature (dis)agreements. ALCF is the extension of ALC f with feature agreements
and disagreements. Beside the additional concept constructors, ALCF uses feature
chains as part of the (dis)agreement constructor. A feature chain is an expression of
the form u = f1      fn . The interpretation uI of such a feature chain is just the
composition of the partial functions f1I , . . . , fnI , where composition is to be read from
left to right.
DLs including nominals or feature (dis)agreements and additional concept constructors or
restrictions on role interpretations are defined (and named) in the obvious way.
Number restriction are available in almost all DL systems. The DL ALCN (i.e., ALC
extended with number restrictions) was first treated by Hollunder and Nutt (1990), as was
ALCF. The DL ALCQ was first investigated by Hollunder and Baader (1991), and ALCO
by Schaerf (1994).
8

fiFusions of Description Logics and Abstract Description Systems

Name
Role composition

Syntax
R1  R2

Semantics
{(a, b)  I  I |
c  I . (a, c)  R1I  (c, b)  R2I }
Role complement R
{(a, b)  I  I | (a, b) 
/ RI }
Role conjunction
R1 u R2 {(a, b)  I  I | (a, b)  R1I  (a, b)  R2I }
Role disjunction
R1 t R2 {(a, b)  I  I | (a, b)  R1I  (a, b)  R2I }
Inverse roles
R1
{(a, b)  I  I | (b, a)  RI }
Transitive closure R+
{(a, b)  I  I | (a, b)  (RI )+ }
Universal role
U
I  I
For a binary relation R, R+ denotes the transitive closure of R.

Symbol


u
t
1
+
U

Figure 2: Some description logic role constructors.
2.1.3 Role constructors
Role constructors allow us to build complex role descriptions. A collection of role constructors can be found in Figure 2. Again, the rightmost column indicates the naming scheme,
where name modifiers for role constructors are written in superscript and separated by
commas. For example, ALCQ with inverse roles and transitive closure is called ALCQ+,1 .
In DLs admitting role constructors, the set of role descriptions is defined inductively, analogously to the set of concept descriptions. The semantics of role constructors is given in
the third column of Figure 2. As with concept descriptions, it can be used to extend the
interpretation function from role names to role descriptions.
In a DL with role constructors, role descriptions can be used wherever role names may
be used in the corresponding DLs without role constructors. For example,
(R1 u R3 ).C u (R2 t R2 ).C
,u,t

is an ALC
-concept description. This concept description is unsatisfiable since R2 t R2
is equivalent to the universal role. Note that role descriptions can also be used within role
assertions in an ABox.
The DL ALC ,t,+ was first treated by Baader (1991) (under the name ALC trans ); Schild
(1991) has shown that this DL is a notational variant of propositional dynamic logic (PDL).
DLs with Boolean operators on roles were investigated by Lutz and Sattler (2000). The
inverse operator was available in the system CRACK (Bresciani, Franconi, & Tessaris,
1995), and reasoning in DLs with inverse roles was, for example, investigated by Calvanese
et al. (1998) and Horrocks et al. (2000). The universal role can be expressed using DLs with
Boolean operators on roles (see the above example), and it can in turn be used to simulate
general concept inclusion axioms within concept descriptions.
2.2 Restricting the syntax
Until now, constructors could be combined arbitrarily. Sometimes it makes sense to restrict
the interaction between constructors since reasoning in the restricted DL may be easier than
reasoning in the unrestricted DL. We will consider DLs imposing certain restrictions on

9

fiBaader, Lutz, Sturm, & Wolter

1. which roles may be used inside certain concept constructors,
2. which roles may be used inside certain role constructors,
3. the combination of role constructors, and
4. the role constructors that may be used inside certain concept constructors.
As an example for the first case, consider the fragment of ALCQR+ in which transitive roles
may be used in existential and universal restrictions, but not in number restrictions (see,
e.g., Horrocks et al., 2000).
As the result of taking the fusion of two DLs, we will obtain DLs whose set of roles NR
is partitioned. For example, the fusion of ALCQ with ALC 1 yields a fragment of ALCQ1
where NR is partitioned in two sets, say NR1 and NR2 . In this fragment, the inverse role
constructor and roles from NR2 may not be used within qualified number restrictions, while
roles from NR1 may not be used inside the inverse role constructor.2 Thus, this DL is an
example for the first, the second, and the fourth case.
Now consider the DL ALCF introduced above, which does not only extend ALC f with
feature (dis)agreement as a concept constructor, but also provides the role composition constructor. However, the role chains built using composition have to be comprised exclusively
of features and non-functional roles may not appear inside feature (dis)agreement. Hence,
ALCF is also an example for the first, second, and fourth case.
As an example for the third case, the fragment of ALC ,u in which role conjunction
may not be used inside the role complement constructor is considered by Lutz and Sattler
(2000).
For these restricted DLs, we do not introduce an explicit naming scheme. Note that,
in this paper, we do not deal with DLs in which the combinability of concept constructors
with each other is restricted since these DLs would not fit into the framework of abstract
description systems introduced in the next section. An example of such a DL would be
one with atomic negation of concepts, i.e., where negation may only be applied to concept
names (e.g., the DL AL discussed by Donini et al., 1997).

3. Abstract description systems
In order to define the fusion of DLs and prove general results for fusions of DLs, one needs
a formal definition of what are description logics. Since there exists a wide variety of DLs
with very different characteristics, we introduce a very general formalization, which should
cover all of the DLs considered in the literature, but also includes logics that would usually
not be subsumed under the name DL.
3.1 Syntax and semantics
The syntax of an abstract description system is given by its abstract description language,
which determines a set of terms, term assertions, and object assertions. In this setting,
concept descriptions are represented by terms that are built using the abstract description
2. This will become clearer once we have given a formal definition of the fusion.

10

fiFusions of Description Logics and Abstract Description Systems

language. General inclusion axioms in DLs are represented by term assertions and ABox
assertions in DLs are represented by object assertions.
Definition 4 (Abstract description language). An abstract description language (ADL)
is determined by a countably infinite set V of set variables, a countably infinite set X of
object variables, a (possibly infinite) countable set R of relation symbols of arity two,3 and
a (possibly infinite) countable set F of functions symbols f , which are equipped with arities
nf . All these sets have to be pairwise disjoint.
The terms tj of this ADL are built using the follow syntax rules:
tj

 x, t1 , t1  t2 , t1  t2 , f (t1 , . . . , tnf ),

where x  V , f  F, and the Boolean operators , ,  are different from all function
symbols in F. For a term t, we denote by var(t) the set of set variables used in t. The
symbol > is used as an abbreviation of x  x and  as an abbreviation for x  x (where
x is a set variable).
The term assertions of this ADL are
 t1 v t2 , for all terms t1 , t2 ,
and the object assertions are
 R(a, b), for a, b  X and R  R;
 (a : t), for a  X and t a term.
The sets of term and object assertions together form the set of assertions of the ADL.
From the DL point of view, the set variables correspond to concept names, object
variables to individual names, relation symbols to roles, and the Boolean operators as well
as the function symbols correspond to concept constructors. Thus, terms correspond to
concept descriptions. As an example, let us view concept descriptions of the DL ALCN u ,
i.e., ALC extended with number restrictions and conjunction of roles, as terms of an ADL.
Value restrictions and existential restrictions can be seen as unary function symbols: for
each role description R, we have the function symbols fR and fR , which take a term tC
(corresponding to the concept description C) and transform it into the more complex terms
fR (tC ) and fR (tC ) (corresponding to the concept descriptions R.C and R.C). Similarly,
number restrictions can be seen as nullary function symbols: for each role description R
and each n  N, we have the function symbols fnR and fnR . Hence, the ALCN u -concept
description A u (R1 u R2 ).(B u ( 2R1 )) corresponds to the term xA  f(R1 uR2 ) ((xB 
f(2R1 ) )). We will analyze the connection between ADLs and DLs more formally later on.
The semantics of abstract description systems is defined based on abstract description
models. These models are the general semantic structures in which the terms of the ADL
are interpreted. It should already be noted here, however, that an abstract description
system usually does not take into account all abstract description models available for the
language: it allows only for a selected subclass of these models. This subclass determines
the semantics of the system.
3. To keep things simpler, we restrict our attention to the case of binary predicates, i.e., roles in DL.
However, the results can easily be extended to n-ary predicates.

11

fiBaader, Lutz, Sturm, & Wolter

Definition 5. Let L be an ADL as in Definition 4. An abstract description model (ADM)
for L is of the form
D
E
W = W, F W = {f W | f  F}, RW = {RW | R  R} ,


ff
where W is a nonempty set, the f W are functions mapping every sequence X1 , . . . , Xnf
of subsets of W to a subset of W , and the RW are binary relations on W .
Since ADMs do not interpret variables, we need an assignment that assigns a subset
of W to each set variable, before we can evaluate terms in an ADM. To evaluate object
assertions, we need an additional assignment that assigns an element of W to each object
variable.
ff


Definition 6. Let L be an ADL and W = W, F W , RW be an ADM for L. An assignment
for W is a pair A = (A1 , A2 ) such that A1 is a mapping from the set of set variables V into
2W , and A2 is an injective4 mapping from the set of object variables X into W . Let W be
an ADM and A = (A1 , A2 ) be an assignment for W. With each L-term t, we inductively
associate a value tW,A in 2W as follows:
 xW,A := A1 (x) for all variables x  V ,
 t2W,A ,
, (t1  t2 )W,A := tW,A
 tW,A
 (t)W,A := W \ (t)W,A , (t1  t2 )W,A := tW,A
1
2
1
 f (t1 , . . . , tnf )W,A := f W (tW,A
, . . . , tW,A
nf ).
1
If x1 , . . . , xn are the set variables occurring in t, then we often write tW (X1 , . . . , Xn ) as
shorthand for tW,A , where A is an assignment with xA
i = Xi for 1  i  n.
The truth-relation |= between hW, Ai and assertions is defined as follows:
 hW, Ai |= R(a, b) iff A2 (a)RW A2 (b),
 hW, Ai |= a : t iff A2 (a)  tW,A ,
.
 tW,A
 hW, Ai |= t1 v t2 iff tW,A
2
1
In this case we say that the assertion is satisfied in hW, Ai. If, for an ADM W and a set of
assertions , there exists an assignment A for W such that each assertion in  is satisfied
in hW, Ai, then W is a model for .
There are two differences between ADMs and DL interpretations. First, in a DL interpretation, the interpretation of the role names fixes the interpretation of the function
symbols corresponding to concept constructors that involve roles (like value restrictions,
number restrictions, etc.). The interpretation of the concept names corresponds to an assignment. Thus, a DL model is an ADM together with an assignment, whereas an ADM
alone corresponds to what is called frame in modal logics. Second, in DL the roles used in
concept constructors may, of course, also occur in role assertions. In contrast, the definition
of ADMs per se does not enforce any connection between the interpretation of the function
symbols and the interpretation of the relation symbols. Such connections can, however, be
enforced by restricting the attention to a subclass of all possible ADMs for the ADL.
4. This corresponds to the unique name assumption.

12

fiFusions of Description Logics and Abstract Description Systems

Definition 7. An abstract description system (ADS) is a pair (L, M), where L is an ADL
and M is a class of ADMs for L that is closed under isomorphic copies.5
From the DL point of view, the choice of the class M defines the semantics of the
concept and role constructors, and it allows us, e.g., to incorporate restrictions on role
interpretations. In this sense, the ADS can be viewed as determining a (description) logic.
To be more concrete, in a DL interpretation the interpretation of the function symbols
is determined by the interpretation of the role names. Thus one can, for example, restrict
the class of models to ADMs that interpret a certain role as a transitive relation or as the
composition of two other roles. Another restriction that can be realized by the choice of
M is that nominals (corresponding to nullary function symbols) must be interpreted as
singleton sets.
Let us now define reasoning problems for abstract description systems. We will introduce
satisfiability of sets of assertions (with or without term assertions), which corresponds to
consistency of ABoxes (with or without GCIs), and satisfiability of terms (with or without
term assertions), which corresponds to satisfiability of concept descriptions (with or without
GCIs).
Definition 8. Given an ADS (L, M), a finite set of assertions  is called satisfiable in
(L, M) iff there exists an ADM W  M and an assignment A for W such that hW, Ai
satisfies all assertions in . The term t is called satisfiable in (L, M) iff {a : t} is satisfiable
in (L, M), where a is an arbitrary object variable.
 The satisfiability problem for (L, M) is concerned with the following question: given
a finite set of object assertions  of L, is  is satisfiable in (L, M).
 The relativized satisfiability problem for (L, M) is concerned with the following question: given a finite set of assertions  of L, is  is satisfiable in (L, M).
 The term satisfiability problem for (L, M) is concerned with the following question:
given a term t of L, is t satisfiable in (L, M).
 The relativized term satisfiability problem for (L, M) is concerned with the following
question: given a term t and a set of term assertions  of L, is {a : t}   satisfiable
in (L, M).
In the next section, we will define the fusion of two ADSs, and show that (relativized)
satisfiability is decidable in the fusion if (relativized) satisfiability in the component ADSs
is decidable. For these transfer results to hold, we must restrict ourselves to so-called local
ADSs.


ff
Wp , RWp over pairwise
Definition 9. Given a family (Wp )pP
 of ADMs W
p = Wp , F
ff
disjoint domains Wp , we say that W = W, F W , RW is the disjoint union of (Wp )pP iff
S
 W = pP Wp ,
5. Intuitively, this means that, if an ADM W belongs to M, then all ADMs that differ from it only w.r.t.
the names of the elements in its domain W also belong to M.

13

fiBaader, Lutz, Sturm, & Wolter

S
 f W (X1 , . . . , Xnf ) = pP f Wp (X1  Wp , . . . , Xnf  Wp ) for all f  F and
X1 , . . . , Xnf  W ,
S
 RW = pP RWp for all R  R.
An ADS S = (L, M) is called local iff M is closed under disjoint unions.
In the remainder of this section, we first analyze the connection between ADSs and DLs
in more detail, and then comment on the relationship to modal logics.
3.2 Correspondence to description logics
We will show that the DLs introduced in Section 2 correspond to ADSs. In order to do this,
we first need to introduce frames, a notion well-known from modal logic. Let L be one of
the DLs introduced in Section 2.
Definition 10 (Frames). An L-frame F is a pair (F , F ), where F is a nonempty set,
called the domain of F, and F is the interpretation function, which maps
 each nominal I to a singleton subset I F of F , and
 each role name R to a subset RF of F  F such that the restrictions for role
interpretations in L are satisfied. For example, in ALC R+ , each R  NR+ is mapped
to a transitive binary relation.
The interpretation function F can inductively be extended to complex roles in the obvious
way, i.e., by interpreting the role constructors in L according to their semantics as given in
Figure 2.
An interpretation I is based on a frame F iff I = F , RI = RF for all roles R  NR ,
and I I = I F for all nominals I  NO .
A frame can be viewed as an interpretation that is partial in the sense that the interpretation of individual and concept names is not fixed. Note that (in contrast to the case of
concept and individual names) the interpretation of nominals is already fixed in the frame.
The reason for this is that, if we do not interpret nominals in the frame, then we have to
treat them as set variables on the ADS side. These would, however, have to be variables
to which only singleton sets may be assigned. Since such a restriction is not possible in the
framework of ADSs as defined above, we interpret nominals in the frame. The consequence
is that they correspond to functions of arity 0 on the ADS side.
Now, we define the abstract description system S = (L, M) corresponding to a DL L.
It is straightforward to translate the syntax of L into an abstract description language L.
Definition 11 (Corresponding ADL). Let L be a DL with concept and role constructors
as well as restrictions on role interpretations as introduced in Section 2. The corresponding
abstract description language L is defined as follows. For every concept name A in L, there
exists a set variable xA in L, and for every individual name i in L there exists an object
variable ai in L. Let R be the set of (possibly complex) role descriptions of L. The set of
relation symbols of L is R, and the set of function symbols of L is the smallest set containing
1. for every role description R  R, unary function symbols fR and fR ,
14

fiFusions of Description Logics and Abstract Description Systems

2. if L provides unqualified number restrictions, then, for every n  N and every role
description R  R, function symbols fnR and fnR of arity 0,
3. if L provides qualified number restrictions, then, for every n  N and every role R  R,
unary function symbols fnR
and fnR
,


4. if L provides nominals, then, for every I  NO , a function symbol fI of arity 0,
5. if L provides feature agreement and disagreement, then, for every pair of feature chains
(u1 , u2 ), two function symbols fu1 u2 and fu1 u2 of arity 0.
For an L-concept description C, let tC denote the representation of C as an L-term,
which is defined in the obvious way: concept names A are translated into set variables xA ,
the concept constructors , u, and t are mapped to , , and , respectively, and all other
concept constructors are translated to the corresponding function symbols. Obviously, both
the sets of function and relation symbols of L may be infinite.
An example of the translation of concept descriptions into terms of an ADL was already
given above: the ALCN u -concept description A u (R1 u R2 ).(B u ( 2R1 )) corresponds
to the term xA  f(R1 uR2 ) ((xB  f(2R1 ) )).
We now define the set of abstract description models M corresponding to the DL L.
For every L-frame, M contains a corresponding ADM.
Definition 12 (Corresponding
Let
F = (F , F ) be a frame. The corresponding

 ADM).
ff
abstract description model W = W, F W , RW has domain W := F . The relation symbols
of L are just the role descriptions of L, and thus they are interpreted in the frame F. For
each relation symbol R  R we can hence define RW := RF .
To define F W , we need to define f W for every nullary function symbol f in L, and
W
f (X) for every unary function symbol f in L and every X  I . Let A be an arbitrary
concept name. For each X  F , let IX be the interpretation based on F mapping the
concept name A to X and every other concept name to .6 To define f W , we make a case
distinction according to the type of f :
W (X) := (R.A)IX ,
1. fR

W (X) := (R.A)IX ,
fR

W := (nR)I , f W := (nR)I ,
2. fnR
nR
W (X) := (nR.A)IX , f W (X) := (nR.A)IX ,
3. fnR


nR

4. fIW := I I ,
5. fuW1 u2 = (u1 u2 )I , fuW1 u2 = (u1 u2 )I .
The class of ADMs M thus obtained from a DL L is obviously closed under isomorphic copies since this also holds for the set of L-frames (independently of which DL L we
consider). Hence, the tuple S = (L, M) corresponding to a DL L is indeed an ADS.
As an example, let us view the DL ALCN u as an ADS. The ADL L corresponding to
ALCN u has already been discussed. Thus, we concentrate on the class of ADMs M induced
6. Taking the empty set here is arbitrary.

15

fiBaader, Lutz, Sturm, & Wolter

by the frames of ALCN u . Assume that F is such a frame, i.e., F consists
of a nonempty


ff
domain and interpretations RF of the role names R. The ADM W = W, F W , RW induced
by F is defined as follows. The set W is identical to the domain of F. Each role description
yields a relation symbol, which is interpreted in W just as in the frame. For example,
(R1 u R2 )W = R1F  R2F . It remains to define the interpretation of the function symbols.
We illustrate this on two examples. First, consider the (unary) function symbol f(R1 uR2 ) .
W
Given a subset X of W , the function f(R
maps X to
1 uR2 )
W
f(R
(X) := {w  W | v  X for all v with (w, v)  R1F  R2F },
1 uR2 )

i.e., the interpretation of the concept description (R1 u R2 ).A in the interpretations based
on F interpreting A by X. Accordingly, the value of the constant symbol f(2R) in W is
given by the interpretation of ( 2R) in the interpretations based on F.
It is easy to show that the interpretation of concept descriptions in L coincides with the
interpretation of the corresponding terms in S = (L, M).


ff
Lemma 13. Let F be a frame, W = W, F W , RW be the ADM corresponding to F, A =
(A1 , A2 ) be an assignment for W, C be a concept description, and let the concept names
used in C be among A1 , . . . , Ak . For all interpretations I based on F with AIi = A1 (xAi )
for all 1  i  k, we have that
C I = tW,A
.
C
As an easy consequence of this lemma, there is a close connection between reasoning
in a DL L and reasoning in the corresponding ADS. Given a TBox T and an ABox A of
the DL L, we define the corresponding set S(T , A) of assertions of the corresponding ADL
(L, M) in the obvious way, i.e., each GCI C v D in T yields a term assertion tC v tD , each
role assertion R(i, j) in A yields an object assertion R(ai , aj ), and each concept assertion
C(i) yields an object assertion ai : tC .
Proposition 14. The ABox A is consistent relative to the TBox T in L iff S(T , A) is
satisfiable in the corresponding ADS.
We do not treat non-relativized consistency explicitly since it is the special case of
relativized consistency where the TBox is empty.
As already mentioned above, our transfer results require the component ADSs to be
local. We call a DL L local iff the ADS (L, M) corresponding to L is local. It turns out
that not all DLs introduced in Section 2 are local.
Proposition 15. Let L be one of the DLs introduced in Section 2. Then, L is local iff L
does not include any of the following constructors: nominals, role complement, universal
role.
Proof. We start with the only if direction, which is more interesting since it shows why
ADSs corresponding to DLs with nominals, role complement, or the universal role are not
local. We make a case distinction according to which of these constructors L contains.
 Nominals. Consider the disjoint union W of the ADMs W1 and W2 , and assume
that W1 and W2 correspond to frames of a DL with nominals. By definition of the
16

fiFusions of Description Logics and Abstract Description Systems

disjoint union, we know that W1  W2 = . If I  NO is a nominal, then the
definition of the disjoint union implies that fIW = fIW1  fIW2 . Since nominals are
interpreted by singleton sets in W1 and W2 , and since the domains of W1 and W2
are disjoint, this implies that fIW is a set of cardinality 2. Consequently, W cannot
correspond to an ADM induced by a frame for a DL with nominals, since such frames
interpret nominals by singleton sets.
 Universal role. Again, consider the disjoint union W of the ADMs W1 and W2 , and
assume that W1 and W2 correspond to frames of a DL with the universal role. Let U
denote the universal role, i.e., a role name for which the interpretation is restricted to
the binary relation relating each pair of individuals of the domain. By the definition of
the disjoint union, we have U W = U W1 U W2 = W1 W1 W2 W2 6= W W .
Consequently, W cannot correspond to an ADM induced by a frame for a DL with
universal role, since such a frame would interpret U by W  W .
 Role complement. Again, consider the disjoint union W of the ADMs W1 and W2 ,
and assume that W1 and W2 correspond to frames of a DL with role negation. For an
W
W
W
arbitrary role name R, we have R = R 1  R 2 = (W1  W1 \ RW1 )  (W2 
W2 \ RW2 ) 6= (W1  W2 ) \ (RW1  RW2 ) = W \ RW .
It remains to prove the if direction. Assume that L is one of the DLs introduced in
Section 2 that does not allow for nominals, role complements, and
 the universal role.
Let
ff
(Fp )pP be a family of L-frames Fp = (Fp , Fp ) and let Wp = Wp , F Wp , RWp be the
ADMs corresponding to them. By definition, Fp = Wp for all p  P . Assume that the
domains (Wp )pP are pairwise disjoint. We must show that the disjoint union of (Wp )pP
also corresponds to an L-frame. To this purpose, we define the frame F = (F , F ) as
follows:
 F :=

S

 RF :=

S

pP

Fp and

pP

RFp for all R  NR .

ff


Let W = W, F W , RW  M be the
S ADM corresponding
S to F.WpBy Definition 12 (corW
responding ADM), we have W = pP Wp and R = pP R
for all R  NR . By
induction on the structure of complex roles, it is easy to show that this also holds for
all R  R, i.e., all complex role descriptions. For example, consider the role description
S
S
W
W
R1  R2 . By induction, we know that R1W = pP R1 p and R2W = pP R2 p . Since the
sets (Wp )pP are pairwise disjoint,
(R1  R2 )W = R1W  R2W =

[

pP

Wp

R1



[

Wp

R2

pP

=

[

pP

Wp

R1

Wp

 R2

=

[

(R1  R2 )Wp .

pP

Since RWp = RFp for all R  R and p  P , we obtain the following fact:
() For all p  P , a  Fp , and role descriptions R  R, the following holds: RF (a) =
RFp (a); in particular, RF (a)  Fp .
17

fiBaader, Lutz, Sturm, & Wolter

It remains to show that, for all n  0, all X1 , . . . , Xn  W , and all function symbols f of
arity n, we have
[
f W (X1 , . . . , Xn ) =
f Wp (X1  Wp , . . . , Xn  Wp ).
pP

This can be proved by making a case distinction according to the type of f . We treat two
cases exemplarily.
S
 f = fu1 u2 . Since W = pP Wp and the sets Wp are pairwise disjoint, fuW1 u2 is the
disjoint union of the sets fuW1 u2  Wp for p  P . It remains to show that fuW1 u2  Wp =
W

W

W

p
p
p
fu1 u
(p  P ). By definition of fu1 u
, we know that a  fu1 u
iff a  Fp , both
2
2
2

F

F

F

F

u1 p (a) and u2 p (a) are defined, and u1 p (a) = u2 p (a). By (), this is the case iff
a  Fp , both uF1 (a) and uF2 (a) are defined and uF1 (a) = uF2 (a), which is equivalent to
a  fuW1 u2  Wp .
S
W (X) is
 f = fnR
. Since W = pP Wp and the sets Wp are pairwise disjoint, fnR



W (X)  W for p  P . It remains to show that
the disjoint union of the sets fnR
p

W

W

W (X)  W = f p (X  W ) (p  P ). By definition of f p , we know that
fnR
p
p



nR
nR
W

p
a  fnR
(X  Wp ) iff a  Fp and |RFp (a)  (X  Wp )|  n. By (), this is the case iff


W (X)  W .
|RF (a)  (X  Wp )|  n iff |RF (a)  X|  n, and hence iff a  fnR
p




It should be noted that arguments similar to the ones used in the proof of the only
if direction show that, in the presence of the universal role or of role negation, function
symbols (e.g., fU ) may also violate the locality condition.
The transfer results for decidability that are developed in this paper only apply to fusions
of local ADSs. Hence, the only if direction of the proposition implies that our results
are not applicable to fusions of ADSs corresponding to DLs that incorporate nominals, role
complement, or the universal role.
3.3 Correspondence to modal logics
In this paper our concern are fusions of description logics and not modal logics. Nevertheless,
it is useful to have a brief look at the relationship between ADSs and modal logic. Standard
modal languages can be regarded as ADLs without relation symbols and object variables
(just identify propositional formulas with terms). Given such an ADL L, a set L of L-terms
is called a classical modal logic iff is contains all tautologies of classical propositional logic
and is closed under modus ponens, substitutions, and the regularity rule
x1  y1 , . . . , xnf  ynf
f (x1 , . . . , xnf )  f (y1 , . . . , ynf )
for all function symbols f of L. The minimal classical modal logic in the language with one
unary function symbol is known as the logic E (see Chellas, 1980).
Any ADS (L, M) based on L determines a classical modal logic L by taking the valid
terms, i.e., by defining
t  L iff tW,A = W for all W  M and assignments A in W.
18

fiFusions of Description Logics and Abstract Description Systems

The logic E is determined by the ADS with precisely one unary operator whose class
of ADMs consists of all models. Chellas formulates this completeness result (Theorem
9.8 in Chellas, 1980) for so-called minimal models (alias neighborhood-frames), which are,
however, just a notational variant of abstract description models with one unary operator
(Dosen, 1988). If the classical modal logic L is determined by an ADS with decidable term
satisfiability problem, then L is decidable since t  L iff t is unsatisfiable.
A classical modal logic L is called normal iff it additionally contains
f (x1 , . . . , xj1 , xj  yj , xj+1 , . . . , xnf )  f (x1 , . . . , xj1 , xj , xj+1 , . . . , xnf ) 
f (x1 , . . . , xj1 , yj , xj+1 , . . . , xnf )
and
f (>, , . . . , ), f (, >, , . . . , ), . . . , f (, . . . , , >),
for all function symbols f and all j with 1  j  nf (Jonsson & Tarski, 1951; Jonsson &
Tarski, 1952; Goldblatt, 1989). This definition of normal modal logics assumes that the
formulas (terms) are built using only necessity (box) operators.7 We will work here only
with necessity operators; the corresponding possibility-operators are definable by putting
f 3 (x1 , . . . , xnf ) = f (x1 , . . . , xnf ).
The minimal normal modal logic in the language with one unary operator is known as K
(Chellas, 1980).
We call a function F : W n  W normal iff for all 1  j  n and X1 , . . . , Xn , Yj  W
F (X1 , . . . , Xj1 , Xj  Yj , Xj+1 , . . . , Xn ) = F (X1 , . . . , Xj1 , Xj , Xj+1 , . . . , Xn ) 
F (X1 , . . . , Xj1 , Yj , Xj+1 , . . . , Xn ))
and
F (W, , . . . , ) = F (, W, , . . . , ) =    = F (, . . . , , W ) = W.
Note that a unary function F is normal iff F (W ) = W and F (X  Y ) = F (X)  F (Y ), for
any X, Y  W . A function symbol f is called normal in an ADS (L, M) iff the functions
f W are normal for all W  M.
For any role R of some DL, the function symbol fR is normal in the corresponding
ADS. To the contrary, it is readily checked that neither fnR
and fnR
nor their duals


3
3
fnR
and
f
are
normal.


nR
Obviously, an ADS (L, M) determines a normal modal logic iff all function symbols of
L are normal in (L, M). Completeness of K with respect to Kripke semantics (Chellas,
1980) implies that the logic K is determined by the ADS with one unary operator whose
class of ADMs consists of all models interpreting this operator by a normal function.
7. Note that some authors define normal modal logics using possibility (diamond) operators, in which case
the definitions are the duals of what we have introduced and thus at first sight look quite different.

19

fiBaader, Lutz, Sturm, & Wolter

4. Fusions of abstract description systems
In this section, we define the fusion of abstract description systems and prove two transfer theorems for decidability, one concerning satisfiability and the other one concerning
relativized satisfiability.
Definition 16. The fusion S1  S2 = (L1  L2 , M1  M2 ) of two abstract description
systems S1 = (L1 , M1 ) and S2 = (L2 , M2 ) over
 disjoint sets of function symbols F of L1 and G of L2 ,
 disjoint sets of relation symbols R of L1 and Q of L2 , and
 the same sets of set and object variables
is defined as follows: L1  L2 is the ADL based on
 the union F  G of the function symbols of L1 and L2 , and
 the union R  Q of the relation symbols of L1 and L2 ,
and M1  M2 is defined as
E
E
D
E D
D
{ W, F W  G W , RW  QW | W, F W , RW  M1 and W, G W , QW  M2 }.
As an example, consider the ADSs S1 and S2 corresponding to the DLs ALCF and
ALC +,,t introduced in Section 2. We concentrate on the function symbols provided by
their fusion. In the following, we assume that the set of role names employed by ALCF
and ALC +,,t are disjoint.
 The ADS S1 is based on the following function symbols: (i) unary functions symbol
fR and fR for every role name R of ALCF, (ii) nullary functions symbols corresponding to the same-as constructor for every pair of chains of functional roles of
ALCF.
 The ADS S2 is based on the following function symbols: (iii) unary functions symbol
fQ and fQ for every role description Q built from role names of ALC +,,t using
union, composition, and transitive closure.
Since we assumed that the set of role names employed by ALCF and ALC +,,t are disjoint,
these sets of function symbols are also disjoint. The union of these sets provides us both
with the symbols for the same-as constructor and with the symbols for value and existential restrictions on role descriptions involving union, composition, and transitive closure.
However, the role descriptions contain only role names from ALC +,,t , and thus none of
the functional roles of ALCF occurs in such descriptions. Thus, the fusion of ALCF and
ALC +,,t yields a strict fragment of their union ALCF +,,t .
4.1 Relativized satisfiability
We prove a transfer result for decidability of the relativized satisfiability problem, show that
this also yields a corresponding transfer result for the relativized term satisfiability problem,
and investigate how these transfer results can be extended to ADSs that correspond to DLs
providing for the universal role.
20

fiFusions of Description Logics and Abstract Description Systems

4.1.1 The transfer result
This section is concerned with establishing the following transfer theorem:
Theorem 17. Let S1 and S2 be local ADSs, and suppose that the relativized satisfiability
problems for S1 and S2 are decidable. Then the relativized satisfiability problem for S1  S2
is also decidable.
The idea underlying the proof of this theorem is to translate a given set of assertions 
of S1  S2 into a set of assertions 1 of S1 and a set of assertions 2 of S2 such that  is
satisfiable in S1  S2 iff 1 is satisfiable in S1 and 2 is satisfiable in S2 . The first (naive)
idea for how to obtain the set i (i = 1, 2) is to replace in  alien terms (i.e., subterms
starting with function symbols not belonging to Si ) by new set variables (the surrogate
variables introduced below). With this approach, satisfiability of  would in fact imply
satisfiability of the sets i , but the converse would not be true. The difficulty arises when
trying to combine the models of 1 and 2 into one for . To ensure that the two models
can indeed be combined, the sets i must contain additional assertions that make sure that
the surrogate variables in one model and the corresponding alien subterms in the other
model are interpreted in a compatible way. To be more precise, there are (finitely many)
different ways of adding such assertions, and one must try which of them (if any) leads to
a satisfiable pair 1 and 2 .
For the proof of Theorem 17, we fix two local ADSs Si = (Li , Mi ), i  {1, 2}, in which
L1 is based on the set of function symbols F and relation symbols R, and L2 is based on G
and Q. Let L = L1  L2 and M = M1  M2 .
In what follows, we use the following notation: for a set of assertions , denote by
term() and obj() the set of terms and object names in , respectively.
We start with explaining how alien subterms in the set  can be replaced by new set
variables. For each L-term t of the form h(t1 , . . . , tn ), h  F  G, we reserve a new variable
xt , which will be called the surrogate of t. We assume that the set of surrogate variables
is disjoint to the original sets of variables. As sketched above, the idea underlying the
introduction of surrogate variables is that the decision procedure for S1 (S2 ) cannot deal
with terms containing function symbols from G (F). Thus, these alien function symbols
must be replaced before applying the procedure. To be more precise, we replace the whole
alien subterm starting with the alien function symbol by its surrogate. For example, if the
unary symbol f belongs to F, and the unary symbol g belongs to G, then f (g(f (x))) is a
mixed L-term. To obtain a term of L1 , we replace the subterm g(f (x)) by its surrogate,
which yields f (xg(f (x)) ). Analogously, to obtain a term of L2 , we replace the whole term
by its surrogate, which yields xf (g(f (x))) . We now define this replacement process more
formally.
Definition 18. For an L-term t without surrogate variables, denote by sur1 (t) the L1 -term
resulting from t when all occurrences of terms g(t1 , . . . , tn ), g  G, that are not within the
scope of some g 0  G are replaced by their surrogate variable xg(t1 ,...,tn ) . For a set  of
terms, put sur1 () := {sur1 (t) | t  } and define sur2 (t) as well as sur2 () accordingly.
Denote by sub() the set of subterms of terms in , and by sub1 () the variables
occurring in  as well as the subterms of alien terms (i.e., terms starting with a symbol
21

fiBaader, Lutz, Sturm, & Wolter

from G) in . More formally, we can define
sub1 () := sub{t | xt  var(sur1 ())}  var().
Define sub2 () accordingly.
For example, let f  F be unary and g  G be binary. If t = f (g(x, f (g(x, y)))), then
sur1 (t) = f (xg(x,f (g(x,y))) ). Note that the restriction not within the scope of some g 0  G
is there to clarify that only the top-most alien subterms are to be replaced. For the term t
of this example, we have sub1 ({t}) = {g(x, f (g(x, y))), f (g(x, y)), g(x, y), x, y}.
Note that the Boolean operators occurring in terms are shared function symbols in
the sense that they are alien to neither L1 nor L2 . Thus, sur1 (f (x)g(x, y)) = f (x)xg(x,y)
and sur2 (f (x)  g(x, y)) = xf (x)  g(x, y).
Of course, when replacing whole terms by variables, some information is lost. For
example, consider the (inconsistent) assertion (R1 .((1 R2 )u(2 R2 )))(i) and assume that
R1 is a role of one component of a fusion, and R2 a role of the other component. Translated
into abstract description language syntax, the concept description R1 .((1 R2 ) u (2 R2 ))
yields the term t := fR1 (f(1 R2 )  f(2 R2 ) ), where fR1 is a function symbol of L1 and
the other two function symbols belong to L2 . Now, sur1 (t) = fR1 (x  y), where x is the
surrogate for f(1 R2 ) and y is the surrogate for f(2 R2 ) . If the decision procedure for the
first ADS only sees fR1 (x  y), it has no way to know that the conjunction of the alien
subterms corresponding to x and y is unsatisfiable. In fact, for this procedure x and y are
arbitrary set variables, and thus x  y is satisfiable. To avoid this problem, we introduce
so-called consistency set consisting of types, where a type says for each relevant formula
whether the formula itself or its negation is supposed to hold. The sets 1 and 2 will then
contain additional information that basically ensures that their models satisfy the same
types. This will allow us to merge these models into one for .
Definition 19. Given a finite set  of L-terms, we define the consistency set C() of  as
C() := {tc | c  }, where the type tc determined by c   is defined as
tc :=

^

{ |   c} 

^

{ |    \ c}.

Given a finite set  of assertions in L, we define subi () := subi (term()). We abbreviate
C i () := C(subi ()), for i  {1, 2}.
In the example above, we have
sub1 (fR1 (f(1 R2 )  f(2 R2 ) ) = {f(1 R2 ) , f(2 R2 ) },
and thus C 1 ({ai : fR1 (f(1 R2 )  f(2 R2 ) )}) consists of the 4 terms
f(1 R2 )
f(1 R2 )
f(1 R2 )
f(1 R2 )






f(2 R2 ) ,
f(2 R2 ) ,
f(2 R2 ) , and
f(2 R2 ) .
22

fiFusions of Description Logics and Abstract Description Systems

Given a set of terms , an element tc of its consistency set C() can indeed be considered
as the type of an element e of the domain of an ADM w.r.t. . Any such element e
belongs to the interpretations of some of the terms in , and to the complements of the
interpretations of the other terms. Thus, if c is the set of terms of  to which e belongs,
then e also belongs to the interpretation of tc and it does not belong to the interpretation
of any of the other terms in C(). In this case we say that e realizes the type tc .
We are now ready to formulate the theorem that reduces the relativized satisfiability
problem in a fusion of two local ADSs to relativized satisfiability in the component ADSs.
A proof of this theorem can be found in the appendix.
Theorem 20. Let Si = (Li , Mi ), i  {1, 2}, be two local ADSs in which L1 is based on
the set of function symbols F and relation symbols R, and L2 is based on G and Q, and
let L = L1  L2 and M = M1  M2 . If  is a finite set of assertions from L, then the
following are equivalent:
1.  is satisfiable in (L, M).
2. There exist
(a) a set D  C 1 (),
(b) for every term t  D an object variable at 6 obj(),
(c) for every a  obj() a term ta  D,
such that the union 1 of the following sets of assertions in L1 is satisfiable in
(L1 , M1 ):
W
(d) {at : sur1 (t) | t  D}  {> v sur1 ( D)},
(e) {a : sur1 (ta ) | a  obj()},

(f ) {R(a, b) | R(a, b)  , R  R},
(g) {sur1 (t1 ) v sur1 (t2 ) | t1 v t2  }  {a : sur1 (s) | (a : s)  };
and the union 2 of the following sets of assertions in L2 is satisfiable in (L2 , M2 ):
W
(h) {at : sur2 (t) | t  D}  {> v sur2 ( D)},
(i) {a : sur2 (ta ) | a  obj()},

(j) {Q(a, b) | Q(a, b)  , Q  Q}.
Intuitively, (2a) guesses a set D of types (i.e., elements of the consistency set). The
idea is that these are exactly the types that are realized in the model of  (to be constructed
when showing (2  1) and given when showing (1  2)). Condition (2b) introduces for
every type in D a name for an object realizing this type, and (2c) guesses for every object
variable occurring in  a type from D.
W Regarding (2d) and (2h), one should note that the set of assertions {at : t | t  D}{> v
D} states that every type in D is realized (i.e., there is an object in the model having
this type) and that every object has one of the types in D. The sets of assertions (2d) and
(2h) are obtained from this set through surrogation to make it digestible by the decision
procedures of the component logics.
23

fiBaader, Lutz, Sturm, & Wolter

The assertions in (2e) and (2i) state (again in surrogated versions) that the object
interpreting the variable a has type ta . This ensures that, in the models of 1 and 2
(given when showing (2  1)), the objects interpreting a have the same type ta from D.
Otherwise, these models could not be combined into a common one for .
The sets (2f) and (2j) are obtained from  by distributing its relationship assertions
between 1 and 2 , depending on the relation symbol used in the assertion.
The set (2g) contains (in surrogated version) the term assertions of the form t1 v t2 and
the membership assertions of the form a : s of .
Condition 2 is asymmetric in two respects. First, it guesses a subset of C 1 () rather than
a subset of C 2 (). Of course this is arbitrary, we could also have chosen index 2 instead
of 1 here. Second, the set 2 neither contains the assertions {sur2 (t1 ) v sur2 (t2 ) | t1 v
t2  } nor {a : sur2 (s) | (a : s)  }. If we added these assertions, the theorem would
still be true, but this would unnecessarily increase the amount of work to be done by the
combined decision procedure. In fact, since the other assertions in 1 and 2 enforce a tight
coordination between the models of 1 and 2 , the fact that the membership assertions and
term assertions of  are satisfied in the models of 1 implies that they are also satisfied in
the models of 2 (see the appendix for details).
To prove Theorem 17, we must show how Theorem 20 can be used to construct a
decision procedure for relativized satisfiability in S1  S2 from such decision procedures for
the component systems S1 and S2 . For a given finite set of assertions  of S1  S2 , the set
C 1 () is also finite, and thus there are finitely many sets D in (2a) and choices of types for
object variables in (2c). Consequently, we can enumerate all of them and check whether
one of these choices leads to satisfiable sets 1 and 2 . By definition of the sets i and of
the functions suri , the assertions in i are indeed assertions of Li , and thus the satisfiability
algorithm for (Li , Mi ) can be applied to i . This proves Theorem 17.
Regarding the complexity of the obtained decision procedure, the costly step is guessing
the right set D. Since the cardinality of the set sub1 () is linear in the size of , the
cardinality of C 1 () is exponential in the size of  (and each element of it has size quadratic
in ). Thus, there are doubly exponentially many different subsets to be chosen from. Since
the cardinality of the chosen set D may be exponential in the size of , also the size of 1
and 2 may be exponential in  (because of the big disjunction over D). From this, the
following corollary follows.
Corollary 21. Let S1 and S2 be local ADSs, and suppose that the relativized satisfiability
problems for S1 and S2 are decidable in ExpTime (PSpace). Then the relativized satisfiability problem for S1  S2 is decidable in 2ExpTime (ExpSpace).
p (n)

Proof. Assume that  has size n. Then we must consider 22 1 (for some polynomial p1 )
p (n)
different sets D in (2a). Each such set has size 2p1 (n) and thus we have of 22 2 choices
in (2c) (for some polynomial p2 ). Overall, this still leaves us with doubly exponentially
many choices. Now assume that the relativized satisfiability problems for S1 and S2 are
decidable in ExpTime. Since each call of these procedures is applied to a set of assertions of
p (n)
p (n)
exponential size, it may take double exponential time, say 22 3 and 22 4 (for polynomials
p3 and p4 ). Overall, we thus have a time complexity of
22

p1 (n)

 22

p2 (n)

 (22
24

p3 (n)

+ 22

p4 (n)

),

fiFusions of Description Logics and Abstract Description Systems

p(n)

which can clearly be majorized by 22
for an appropriate polynomial p. This shows
membership in 2ExpTime.
The argument regarding the space complexity is similar. Here one must additionally
take into account that doubly exponentially many choices can be enumerated using an
exponentially large counter.

4.1.2 The relativized term satisfiability problem
The statement of Theorem 17 itself does not imply a transfer result for the relativized term
satisfiability problem. The problem is that decidability of the relativized term satisfiability
problem in S1 and S2 does not necessarily imply decidability of the relativized satisfiability
problem in these ADSs, and thus the prerequisite for the theorem to apply is not satisfied.
However, if we consider the statement of Theorem 20, then it is easy to see that this theorem
also yields a transfer result for the relativized term satisfiability problem.
Corollary 22. Let S1 and S2 be local ADSs, and suppose that the relativized term satisfiability problems for S1 and S2 are decidable. Then the relativized term satisfiability problem
for S1  S2 is also decidable.
Proof. Consider the satisfiability criterion in Theorem 20. If we are interested in relativized term satisfiability, then  is of the form {a : t}  0 , where 0 is a set of term
assertions. In this case, the sets of assertions 1 and 2 do not contain object assertions
involving relations. Now, assume that i is of the form {a1 : t1 , . . . , an : tn }  0i , where 0i
is a set of term assertions. Since two assertions of the form b : s1 , b : s2 are equivalent to
one assertion b : s1  s2 , we may assume that the ai are distinct from each other. Since Si
is local, it is easy to see that the following are equivalent:
1. {a1 : t1 , . . . , an : tn }  0i is satisfiable in Si .
2. {aj : tj }  0i is satisfiable in Si for all j = 1, . . . , n.
Since (1  2) is trivial, it is enough to show (2  1). Given models Wj  Mi of {aj :
tj }  0i (j = 1, . . . , n), their disjoint union also belongs to Mi , and it is clearly a model of
{a1 : t1 , . . . , an : tn }  0i .
The second condition can now be checked by applying the term satisfiability test in Si
n times.

4.1.3 Dealing with the universal role
As stated above (Proposition 15), ADSs corresponding to DLs with the universal role are
not local, and thus Theorem 17 cannot be applied directly. Nevertheless, in some cases
this theorem can also be used to obtain a decidability result for fusions of DLs with the
universal role, provided that both of them provide for a universal role. (We will comment
on the usefulness of this approach in more detail in Section 5.4).
Definition 23. Given an ADS S = (L, M), we denote by S U the ADS obtained from S by
1. extending L with two function symbols fUS and fUS , and
25

fiBaader, Lutz, Sturm, & Wolter



ff
W and
2. extending every ADM W = W, F W , RW  M with the unary functions fU
S
W , where
fU
S
W (X) =  if X = , and f W (X) = W otherwise;
 fU
US
S
W (X) = W if X = W , and f W (X) =  otherwise.
 fU
US
S

For ADSs S corresponding to a DL L, the ADS S U corresponds to the extension of L
with the universal role, where the universal role can only be used within value and existential
restrictions.8 There is a close connection between the relativized satisfiability problem in S
and the satisfiability problem in S U .
Proposition 24. If S is a local ADS, then the following conditions are equivalent:
1. the relativized (term) satisfiability problem for S is decidable,
2. the (term) satisfiability problem for S U is decidable,
3. the relativized (term) satisfiability problem for S U is decidable.

Proof. We restrict our attention to the term satisfiability problem since the equivalences
for the satisfiability problem can be proved similarly.
The implication (3  2) is trivial, and (2  1) is easy to show. In fact, t is satisfiable in
S relative to the term assertions {s1 v t1 , . . . , sn v tn } iff tfUS .((t1 s1 ). . .(tn sn ))
is satisfiable in S U .
To show (1  3), we assume that the relativized term satisfiability problem for S is
decidable. Let S = (L, M) and S U = (LU , MU ). In the following, we use fU as an
abbreviation for fUS . Since we can replace equivalently in any term the function symbol
fUS by fU , we may assume without loss of generality that fUS does not occur in terms
of LU .
Suppose a set  = {a : s}   from LU is given, where  is a set of term assertions. We
want to decide whether  is satisfiable in some model W  MU . To this purpose, we transform  into a set of assertions not containing fU . The idea underlying this transformation
is that, given a model W  MU , we have fU (t)W  {W, }, depending on whether tW = W
or not. Consequently, if we replace fU (t) accordingly by > or , the evaluation of this term
in W does not change. However, in the satisfiability test we do not have the model W (we
are trying to decide whether one exists), and thus we must guess the right replacement.
A term t from LU is called a U -term iff it starts with fU . The set of U -terms that
occur (possibly as subterms) in  is denoted by U . Set, inductively, for any function
8. Note that it is not necessary to add the universal role U to the set of relation symbols since an assertion
of the form U (a, b) is trivially true. However, the use of the universal role within (qualified) number
restrictions is not covered by this extension.

26

fiFusions of Description Logics and Abstract Description Systems

 : U  {, >} and all subterms of terms in :
x := x,
(t1  t2 ) := t1  t2 ,
(t1  t2 ) := t1  t2 ,
(t) := t ,
(f (t1 , . . . , tn )) := f (t1 , . . . , tn ) for f 6= fU of arity n,
(fU (t)) := (fU (t)).
Thus, t is obtained from t by replacing all occurrences of U -terms in t by their image under
, i.e., by  or >. Define, for any such function ,
 := {t1 v t2 | t1 v t2  }  {a : s } 
{> v t | fU (t)  U and (fU (t)) = >} 
{at : t | fU (t)  U and (fU (t)) = },
where the at are mutually distinct new object variables. Note that  does not contain the
function symbol fU , and thus it can be viewed as a set of assertions of S. In addition, though
it contains more than one membership assertion, it does not contain assertions involving
relation symbols. Consequently, the satisfiability of  in S can be checked using the term
satisfiability test for S (see the proof of Corollary 22 above). Decidability of the relativized
term satisfiability problem for S U then follows from the following claim:
Claim.  is satisfiable in a member of MU iff there exists a mapping  : U  {, >}
such that  is satisfiable in a member of M.
To 
prove this claim, firstff suppose that  is satisfied under an assignment A in a member
W = W, F W  {fUW }, RW of MU . Define  by setting (fU (t)) = > if (fU (t))W,A =
W , and (fU (t))
 =  otherwise.
Obviously, this implies that  is satisfied under the
ff
W
W
assignment A in W, F , R , which is a member of M.
suppose  is satisfiable for some mapping . Take a member W =

 Conversely,
ff
W
W

0
ffand an assignment A such such that hW, Ai |=  . Set W :=

W, F W , R W of M
W
W, F  {fU }, R , and prove, by induction, for all terms t that occur in :
()

0

tW ,A = (t )W,A .

The only critical case is the one where t = fU (s). First, assume that (fU (s)) = (fU (s)) =
0
>. Then  contains > v s , and thus W = (s )W,A = sW ,A , where the second identity
0
0
holds by induction. However, sW ,A = W implies (fU (s))W ,A = W = >W,A . The case where
(fU (s)) = (fU (s)) =  can be treated similarly. Here the term assertion as : s ensures
that s (and thus by induction s) is not interpreted as the whole domain. Consequently,
applying fU to it yields the empty set.
Since hW, Ai |=  , the identity () implies that hW0 , Ai |= . This completes the proof
of the claim, and thus also of the proposition.

For normal modal logics, the result stated in this proposition was already shown by
Goranko and Passy (1992). The proof technique used there can, however, not be transfered
27

fiBaader, Lutz, Sturm, & Wolter

to our more general situation since it strongly depends on the normality of the modal
operators.
Using Proposition 24, we obtain the following corollary to our first transfer theorem.
Corollary 25. Let S1 , S2 be local ADSs and assume that, for i  {1, 2}, the relativized
(term) satisfiability problem for Si is decidable. Then the relativized (term) satisfiability
problem for S1U  S2U is decidable.
Proof. We know by Theorem 17 (Corollary 22) that the relativized (term) satisfiability
problem for S1  S2 is decidable. Hence, Proposition 24 yields that the relativized (term)
satisfiability problem for (S1  S2 )U is decidable. But S1U  S2U is just a notational variant
of (S1  S2 )U : the function symbols fUS1 and fUS2 can be replaced by fUS1 S2 (and
analogously for fUS1 S2 ) since all three have identical semantics.

4.2 Satisfiability
Note that Theorem 17 does not yield a transfer result for the unrelativized satisfiability
problem. Of course, if the relativized satisfiability problems for S1 and S2 are decidable,
then the theorem implies that the satisfiability problem for S1  S2 is also decidable (since
it is a special case of the relativized satisfiability problem). However, to be able to apply
the theorem to obtain decidability of the satisfiability problem in the fusion, the component
ADSs must satisfy the stronger requirement that the relativized satisfiability problemWis decidable. Indeed, the set i in Theorem 20 contains a term assertion (namely > v suri ( D))
even if  does not contain any term assertions.
There are cases where the relativized satisfiability problem is undecidable whereas the
satisfiability problem is still decidable. For example, Theorem 17 cannot be applied for
the fusion of ALCF and ALC +,,t since the relativized satisfiability problem for ALCF is
already undecidable (Baader et al., 1993). However, the satisfiability problem is decidable
for both DLs.
4.2.1 Covering normal terms
Before we can formulate a transfer result for the satisfiability problem, we need to introduce
an additional notion, which generalizes the notion of a normal modal logic.
Definition 26 (Covering normal terms). Let (L, M) be an ADS and f be a function
symbol of L of arity n. The term tf (x) (with one variable x) is a covering normal term for
f iff the following holds for all W  M:
 tW
f (W ) = W
W
W
 for all X, Y  W , tW
f (X  Y ) = tf (X)  tf (Y ), and

 for all X, X1 , . . . , Yn  W : X  Xi = X  Yi for 1  i  n implies
W
W
W
tW
f (X)  f (X1 , . . . , Xn ) = tf (X)  f (Y1 , . . . , Yn ).

An ADS (L, M) is said to have covering normal terms iff one can effectively determine a
covering normal term tf for every function symbol f of L.
28

fiFusions of Description Logics and Abstract Description Systems

Intuitively, the first two conditions state that the covering normal term behaves like a
value restriction (or box operator). Consider the term fR (x), where fR is the function
symbol corresponding to the value restriction constructor for the role R. Then fR (x)
obviously satisfies the first two requirements for covering normal terms. Note that the
second condition implies that the function induced by tf is monotonic, i.e., X  Y implies
W
tW
f (X)  tf (Y ). The third condition specifies the connection between the covering normal
term and the function symbol it covers. With respect to elements of tW
f (X), the values
W
W
of the functions f (X1 , . . . , Xn ) and f (Y1 , . . . , Yn ) agree provided that their arguments
agree on X. It is easy to see that fR (x) is a covering normal term for the function symbols
corresponding to the value, existential, and (qualified) number restrictions on the role R
(see Proposition 35 below).
Given covering normal terms tf for the function symbols f of a finite set of function
symbols E, one can construct a term tE that is a covering normal term for all the elements
of E.
Lemma 27. Suppose the ADS (L, M) has covering normal terms and L is based on a set
of function symbols F . Denote by tf the covering normal term for the function symbol f ,
for all f  F . Then, for every finite set E  F of function symbols, the term
tE (x) :=

^

tf (x)

f E

is a covering normal term for all f  E.
4.2.2 Correspondence to normal modal logics
The following result shows that any ADS in which every function symbol is normal has
covering normal terms. Hence, the notion of covering normal terms generalizes the notion
of normality in modal logics.
Proposition 28. Let (L, M) be an ADS, and assume that f is a normal function symbol
in (L, M). Then
tf (x) := f (x, , . . . , )  f (, x, . . . , )      f (, . . . , , x)
is a covering normal term for f . In particular, if f is nullary (unary), then tf (x) = >
(tf (x) = f (x)) is a covering normal term for f .
Proof. The first two conditions in the definition of covering normal terms immediately
follow from the definition of normal function symbols. Thus, we concentrate on the third
condition. Assume, for simplicity, that f is binary. Suppose W  M and X, X1 , X2 , Y1 , Y2 
W with X  Xi = X  Yi for i = 1, 2, and set F := f W . Then F (X  X1 , X  X2 ) =
F (X  Y1 , X  Y2 ). Since F is normal, we know that
F (X  X1 , X  X2 ) = F (X, X)  F (X, X2 )  F (X1 , X)  F (X1 , X2 ),
F (X  Y1 , X  Y2 ) = F (X, X)  F (X, Y2 )  F (Y1 , X)  F (Y1 , Y2 ),
29

fiBaader, Lutz, Sturm, & Wolter

and thus
F (X, X)  F (X, X2 )  F (X1 , X)  F (X1 , X2 ) =
F (X, X)  F (X, Y2 )  F (Y1 , X)  F (Y1 , Y2 ).
Since, by normality of F ,
F (X, X)  F (X, X2 )  F (X1 , X)  tW
f (X),
F (X, X)  F (X, Y2 )  F (Y1 , X)  tW
f (X),
W
this implies tW
f (X)  F (X1 , X2 ) = tf (X)  F (Y1 , Y2 ).



4.2.3 The transfer result
Using covering normal terms, we can now formulate the second transfer theorem, which is
concerned with the transfer of decidability of (non-relativized) satisfiability.
Theorem 29. Let S1 and S2 be local ADSs having covering normal terms, and suppose
that the satisfiability problems for S1 and S2 are decidable. Then the satisfiability problem
for S1  S2 is also decidable.
As in the proof of Theorem 17, we fix two local ADSs Si = (Li , Mi ), i  {1, 2}, in which
L1 is based on the set of function symbols F and relation symbols R, and L2 is based on G
and Q. Let L = L1  L2 and M = M1  M2 .
The proof of Theorem 29 follows the same general ideas as the proof of Theorem 17.
There are, however, notable differences in the way satisfiability in S1  S2 is reduced to
satisfiability in S1 and S2 . In Theorem 20 we had to guess a set D of types, and then
based on this set and some additional guesses, a pair of satisfiability problems 1 and 2 in
S1 and S2 , respectively, was generated. In the proof of Theorem 29, we do not need to guess
D. Instead, we can compute the right set. However, this computation requires us to solve
additional satisfiability problems in the fusion S1  S2 . Nevertheless, this yields a reduction
since the alternation depth (i.e., number of alternations between function symbols of S1
and S2 ) decreases when going from the input set  to these additional mixed satisfiability
problems.
Before we can describe this reduction in more detail, we must introduce someWnew
notation. In the case of relativized satisfiability, term assertions of the W
form > v suri ( D)
were used to assert that all elements of theW domain belong to suri ( D). Now, we use
covering normal terms to propagate suri ( D) into terms up to a certain depth. For a
set of function symbols E, define the E-depth dE (t) of a term t inductively:
dE (xi ) = 0
dE (t) = dE (t)
dE (t1  t2 ) = dE (t1  t2 ) = max{dE (t1 ), dE (t2 )}
dE (f (t1 , . . . , tn )) = max{dE (t1 ), . . . , dE (tn )} + 1 if f  E
dE (f (t1 , . . . , tn )) = max{dE (t1 ), . . . , dE (tn )} if f 6 E
30

fiFusions of Description Logics and Abstract Description Systems

If  is a finite set of assertions, then
dE () := max{dE (t) | t  term()}.
Put, for a term t(x) with one variable x, t0 (x) := x, tm+1 (x) := t(tm (x)), t0 (x) := x, and
tm+1 (x) := tm+1 (x)  tm (x).
We are now in the position to formulate the result that reduces satisfiability in the fusion
of two local ADSs with covering normal terms to satisfiability in the component ADSs.
Theorem 30. Let Si = (Li , Mi ), i  {1, 2}, be two local ADSs having covering normal
terms in which L1 is based on the set of function symbols F and relation symbols R, and
L2 is based on G and Q, and let L = L1  L2 and M = M1  M2 . Let  be a finite set
of object assertions from L. Put m := dF (), r := dG (), and let c(x) (d(x)) be a covering
normal term for all function symbols in  that are in F (G).
For i  {1, 2}, denote by i the set of all s  C i () such that the term s is satisfiable in
(L, M). Then the following three conditions are equivalent:
1.  is satisfiable in (L, M).
2. There exist
 for every t  1 an object variable at 6 obj()
 for every a  obj() a term ta  1
such that the union 1 of the following sets of object assertions is satisfiable in
(L1 , M1 ):
W
 {at : sur1 (t  cm (sur1 ( 1 )) | t  1 },
W
 {a : sur1 (ta  cm (sur1 ( 1 )) | a  obj()},
 {R(a, b) | R(a, b)  , R  R},
 {a : sur1 (s) | (a : s)  };
and the union 2 of the following sets of object assertions is satisfiable in (L2 , M2 ):
W
 {at : sur2 (t  dr (sur2 ( 1 )) | t  1 },
W
 {a : sur2 (ta  dr (sur2 ( 1 )) | a  obj()},
 {Q(a, b) | Q(a, b)  , Q  Q}.

3. The same condition as in (2) above, with 1 replaced by 2 .
The sets i in the above theorem are very similarWto the ones in Theorem 20. The
main difference is that
W the term assertion > v suri ( D) is no longer there. Instead,
the disjunction suri ( 1 ) is directly inserted into the terms using the covering normals
terms. As already mentioned above, another difference is that the set D, which had to be
guessed in Theorem 20, is replaced by the set 1 in (2) and 2 in (3). Actually, guessing the
set D is no
W longer possible in this case. In the proof of Theorem 30 we need to know that
> v suri ( D) is satisfiable in Si (i.e., holds in at least one model in Mi ). But we have no
way to check this effectively since we do not have an algorithm for relativized satisfiability
31

fiBaader, Lutz, Sturm, & Wolter

in Si . Taking the set i ensures that this property is satisfied (see the proof in the appendix
for details).
By definition, i is the set of all s  C i () such that the term s is satisfiable in (L, M).
Recall that the term s is satisfiable iff {a : s} is satisfiable in (L, M) for an arbitrary
object variable a. Since the elements of C i () are still mixed terms (i.e., terms of the
fusion), computing the set i actually needs a recursive call to the decision procedure for
satisfiability in (L, M). This recursion is well-founded since the alternation depth decreases.
Definition 31. For a term s of L, denote by a1 (s) and a2 (s) the 1-alternation and the
2-alternation depth of s, respectively. That is to say, a1 (s) is the length of the longest
sequence of the form (g1 , f2 , g3 , . . .) such that
g1 (. . . (f2 . . . (g3 . . .)))
with gj  G and fj  F appears in s. The 2-alternation depth a2 (s) is defined by exchanging
the roles of F and G. Put a(s) := a1 (s) + a2 (s), and call this the alternation depth. For a
finite set  of terms, a() is the maximum of all a(s) with s  .
Thus, a1 (s) counts the maximal number of changes between symbols from the first and
the second ADS, starting with the first symbol from S2 (i.e., the first symbol from S2
counts as a change, even if it does not occur inside the scope of a symbol from S2 ). The
2-alternation depth is defined accordingly. The alternation depth sums up the 1- and the
2-alternation depth.
Lemma 32. If a(term()) > 0, then a(C 1 ()) < a(term()) or a(C 2 ()) < a(term()).
Proof. We show that, if a(term()) > 0, then we have a(sub1 ()) < a(term()) or
a(sub2 ()) < a(term()), which, by definition of C i , clearly implies the lemma. First
note that, by definition of subi , we have
ai (subj ())  ai (term()) for all i, j.

()

We now make a case distinction as follows:
1. a1 (term())  a2 (term()). We want to show that a1 (sub2 ()) < a1 (term()),
since, by (), this implies a(sub2 ()) < a(term()). Assume to the contrary that
a1 (sub2 ())  a1 (term()). Then () implies a1 (sub2 ()) = a1 (term()). Hence,
there exists a term s  sub2 () and a sequence (g1 , f2 , g3 , . . . ) of function symbols
gi  G, fi  F of length a1 (term()) such that g1 (. . . (f2 . . . (g3 . . .))) occurs in s. By
definition of sub2 , this implies the existence of a term t  term() and a function
symbol f  F such that f (. . . g1 (. . . (f2 . . . (g3 . . .)))) occurs in t. Since the length of
(g1 , f2 , g3 , . . . ) is a1 (term()), this obviously yields a2 (term()) > a1 (term()) which
is a contradiction.
2. a1 (term())  a2 (term()). Similar to the previous case: just exchange the roles of
a1 and a2 , F and G, and sub1 and sub2 .

32

fiFusions of Description Logics and Abstract Description Systems

To prove Theorem 29, we must show how Theorem 30 can be used to construct a decision
procedure for satisfiability in S1  S2 from such decision procedures for the component
systems S1 and S2 . Let us first consider the problem of computing the sets 1 and 2 .
If a((term()) = 0, then  consists of Boolean combinations of set variables. In this
case, C i () consists of set variables, and i , i = 1, 2, can be computed using Boolean
reasoning. If a(term()) > 0, then Lemma 32 states that there is an i  {1, 2} such
that a(C i ()) < a(term()). By induction we can thus assume that i can effectively be
computed. Consequently, it remains to check Condition (i + 1) of Theorem 30 for i  {1, 2}.
Since i is finite, we can guess for every object variable a occurring in  a type ta in i . The
sets 1 and 2 obtained this way are indeed sets of assertions of L1 and L2 , respectively.
Thus, their satisfiability can effectively be checked using the decision procedures for S1 and
S2 . This proves Theorem 29.
The argument used above also shows why in Theorem 30 it was not sufficient to state
equivalence of (1) and (2) (as in Theorem 20). In fact, the induction argument used above
does not necessarily always apply to the computation of 1 . In some cases, the alternation
depth may not decreases for 1 , but only for 2 . It should be noted that Theorem 20 could
also have been formulated in this symmetric way. We have not done this since it was not
necessary for proving Theorem 17.
Regarding the complexity of the combined decision procedure, we must in principle also
consider the complexity of computing covering normal terms and the size of these terms.
In the examples from DL, these terms are just value restrictions, and thus their size and
the complexity of computing them is linear. Here, we assume a polynomial bound on both.
Under this assumption, we obtain the same complexity results as for the case of relativized
satisfiability. In fact, the complexity of testing Condition (2) and (3) of Theorem 30 agrees
with the complexity of testing Condition (2) of Theorem 20: it adds one exponential to the
complexity of the decision procedure for the single ADSs. In order to compute i , we need
exponentially many recursive calls to the procedure. Since the recursion depth is linear in
the size of , we end up with at most exponentially many tests of Condition (2) and (3).
Corollary 33. Let S1 and S2 be local ADSs having covering normal terms, and assume
that these covering normal terms can be computed in polynomial time. If the satisfiability
problems for S1 and S2 are decidable in ExpTime (PSpace), then the satisfiability problem
for S1  S2 is decidable in 2ExpTime (ExpSpace).
With the same argument as in the case of relativized satisfiability, we can extend the
transfer result also to term satisfiability.
Corollary 34. Let S1 and S2 be local ADSs having covering normal terms, and suppose
that the term satisfiability problems for S1 and S2 are decidable. Then the term satisfiability
problem for S1  S2 is also decidable.

5. Fusions of description logics
Given two DLs L1 and L2 , their fusion is defined as follows. We translate them into the
corresponding ADSs S1 and S2 , and then build the fusion S1  S2 . The fusion L1  L2
of L1 and L2 is the DL that corresponds to S1  S2 . Since the definition of the fusion of
ADSs requires their sets of function symbols to be disjoint, we must ensure that the ADSs
33

fiBaader, Lutz, Sturm, & Wolter

corresponding to L1 and L2 are built over disjoint sets of function symbols. For the DLs
introduced in Section 2, this can be achieved by assuming that the sets of role names of L1
and L2 are disjoint and the sets of nominals of L1 and L2 are disjoint. The DL L1  L2 then
allows the use of the concept and role constructors of both DLs, but in a restricted way.
Role descriptions are either role descriptions of L1 or of L2 . There are no role descriptions
involving constructors or names of both DLs. Concept descriptions may contain concept
constructors of both DLs; however, a constructor of Li may only use a role description of
Li (i = 1, 2).
Let us illustrate these restrictions by two simple examples. The fusion ALC +  ALC 1
of the two DLs ALC + and ALC 1 is the fragment of ALC +,1 whose set of role names is
partitioned into two sets NR1 and NR2 such that
 the transitive closure operator may only be applied to names from NR1 ;
 the inverse operator may only be applied to names from NR2 .
For example, if A is a concept name, R  NR1 and Q  NR2 , then R+ .A u Q1 .A is
a concept description of ALC +  ALC 1 , but R+ .A u R1 .A and (Q1 )+ .A are not.
Note that, although the two source DLs have disjoint sets of role names, in ALC +  ALC 1
role names from both sets may be used inside existential and value restrictions since these
concept constructors are available in both DLs.
The fusion ALCQ  ALC R+ of the two DLs ALCQ and ALC R+ is the fragment of
ALCQR+ whose set of role names NR (with transitive roles NR+  NR ) is partitioned into
two sets NR1 and NR2 with NR+  NR2 such that, inside qualifying number restrictions,
only role names from NR1 may be used. In particular, this means that transitive roles
cannot occur within qualified number restrictions.
In the following, we give examples that illustrate the usefulness of the transfer results
proved in the previous section. First, we will give an example for the case of satisfiability and
then for relativized satisfiability. Subsequently, we will consider a more complex example
involving so-called concrete domains. Here, our general transfer result can be used to prove
a decidability result that has only recently been proved by designing a specialized algorithm
for the fusion. Finally, we will give an example that demonstrates that the restriction to
local ADSs is really necessary.
5.1 Decidability transfer for satisfiability
In this subsection, we will give an example for an application of Theorem 29 where the
decidability result could not be obtained using Theorem 17.
Theorem 29 requires the ADSs to have covering normal terms. This is, however, satisfied
by all the DLs that yield local ADSs.
Proposition 35. Let L be one of the DLs introduced in Section 2, and let the corresponding
ADS S = (L, M) be local. Then S has covering normal terms, and these terms can be
computed in linear time.
Proof. For all function symbols f in L, the term tf has the form fR (x) for some role
description R. The semantics of value restrictions implies that terms of this form satisfy
34

fiFusions of Description Logics and Abstract Description Systems

the first two properties of Definition 26. This completes the proof for all function symbols
f of arity 0 since for these the third condition of Definition 26 is trivially satisfied. Thus,
for nullary function symbols, fR (x) for an arbitrary role name R does the job.
It remains to show that, for every unary function symbol f  {fR , fR , fnR
, fnR
},


the term fR (x) also satisfies the third property. This is an immediate consequence of the
W (X)  f W (Y ) = f W (X)  f W (X  Y )
fact that, for these function symbols f , we have fR
R
for all models W  M and X, Y  W .

In the following, we consider the two description logics ALCF and ALC +,,t . Hollunder
and Nutt (1990) show that satisfiability of ALCF-concept descriptions is decidable. The
same is true for consistency of ALCF-ABoxes (Lutz, 1999). Note, however, that relativized
satisfiability of ALCF-concept descriptions and thus also relativized ABox consistency in
ALCF is undecidable (Baader et al., 1993). For ALC +,,t , decidability of satisfiability is
shown by Baader (1991) and Schild (1991).9 Decidability of ABox consistency in ALC +,,t
is shown in Chapter 7 of (De Giacomo, 1995).
The unrestricted combination ALCF +,,t of the two DLs is undecidable. To be more precise, satisfiability of ALCF +,,t -concept descriptions (and thus also consistency of ALCF +,,t ABoxes) is undecidable. This follows from the undecidability of relativized satisfiability of
ALCF-concept descriptions and the fact that the role operators in ALCF +,,t can be used
to internalize TBoxes (Schild, 1991; Baader et al., 1993). In contrast to the undecidability
of ALCF +,,t , Theorem 29 immediately implies that satisfiability of concept descriptions
in the fusion of ALCF and ALC +,,t is decidable.
Theorem 36. Satisfiability of concept descriptions and consistency of ABoxes is decidable
in ALCF  ALC +,,t , whereas satisfiability of ALCF +,,t -concept descriptions is already
undecidable.
Taking the fusion thus yields a decidable combination of two DLs whose unrestricted
combination is undecidable. The price one has to pay is that the fusion offers less expressivity than the unrestricted combination. The concept f1 f2 u f1+ .C is an example of a
concept description of ALCF +,,t that is not allowed in the fusion ALCF  ALC +,,t .
5.2 Decidability transfer for relativized satisfiability
As an example for the application of Corollary 22 (and thus of Theorem 17), we consider the
DL ALC +,,u,t
. For this DL, satisfiability of concept descriptions is undecidable. However,
f
an expressive fragment with a decidable relativized satisfiability problem can be obtained
by building the fusion of the two sublanguages ALC +,,t
and ALC +,,t,u .
f
Theorem 37. Satisfiability of ALC +,,u,t
-concept descriptions is undecidable.
f
Undecidability can be shown by a reduction of the domino problem (Berger, 1966;
Knuth, 1973) (see, e.g., Baader & Sattler, 1999, for undecidability proofs of DLs using such
a reduction). The main tasks to solve in such a reduction is that one can express the 
grid and that one can access all points on the grid. One square of the grid can be expressed

N N

9. Note that ALC +,,t is a notational variant of test-free propositional dynamic logic (PDL) (Fischer &
Ladner, 1979).

35

fiBaader, Lutz, Sturm, & Wolter

by a description of the form (xyuyx).>, where x, y are features. In fact, this description
expresses that the points belonging to it have both an x  y and a y  x successor, and
that these two successors coincide. Accessing all point on the grid can then be achieved by
using the role description (x t y)+ .
Note that this undecidability result is also closely related to the known undecidability
of IDPDL, i.e., deterministic propositional dynamic logic with intersection (Harel, 1984).
However, the undecidability proof for IDPDL by Harel (1984) uses the test construct, which
is not available in ALC +,,u,t
.
f
Next, we show that relativized satisfiability in two rather expressive sublanguages of
ALC +,,u,t
is decidable.
f
Theorem 38. Relativized satisfiability of concept descriptions is decidable in ALC f+,,t and
ALC +,,t,u .
Proof sketch. In both cases, TBoxes can be internalized as described by Schild (1991)
and Baader et al. (1993). Thus, it is sufficient to show decidability of (unrelativized)
satisfiability.
, this follows from decidability of DPDL (Ben-Ari, Halpern, & Pnueli,
For ALC +,,t
f
1982), the known correspondence between PDL and ALC +,,t (Schild, 1991), and the fact
that non-functional roles can be simulated by functional ones in the presence of composition
and transitive closure (Parikh, 1980).
For ALC +,,t,u , decidability of satisfiability follows from decidability of IPDL, i.e., PDL
with intersection (Danecki, 1984).

Given this theorem, Corollary 22 now yields the following decidability result.
Corollary 39. Relativized satisfiability of concept descriptions is decidable in the fusion
ALC f+,,t  ALC +,,t,u .
5.3 A concrete example
Description logics with concrete domains were introduced by Baader and Hanschke (1991)
in order to allow for the reference to concrete objects like numbers, time intervals, spatial
regions, etc. when defining concepts. To be more precise, Baader and Hanschke (1991)
define the extension ALC(D) of ALC, where D is a concrete domain (see below). Under
suitable assumptions on D, they show that satisfiability in ALC(D) is decidable. One of the
main problems with this extension of DLs is that relativized satisfiability (and satisfiability in DLs where TBoxes can be internalized) is usually undecidable (Baader & Hanschke,
1992) (though there are exceptions, see Lutz, 2001). For this reason, Haarslev et al. (2001)
introduce a restricted way of extending DLs by concrete domains, and show that the corresponding extension of ALCN HR+ has a decidable relativized satisfiability problem.10 In
the following, we show that this result can also be obtained as an easy consequence of
10. To be more precise, they even show that relativized ABox consistency is decidable in their restricted
extension of ALCN HR+ by concrete domains. Here, we restrict ourself to satisfiability of concepts
since the ABoxes introduced by Haarslev et al. (2001) also allow for the use of concrete individuals and
for predicate assertions on these individuals, which is not covered by the object assertions for ADSs
introduced in the present paper.

36

fiFusions of Description Logics and Abstract Description Systems

our Theorem 17. Moreover, ALCN HR+ can be replaced by an arbitrary local DL with a
decidable relativized satisfiability problem.
Definition 40 (Concrete Domain). A concrete domain D is a pair (D , D ), where D
is a nonempty set called the domain, and D is a set of predicate names. Each predicate
name P  D is associated with an arity n and an n-ary predicate P D  nD . A concrete
domain D is called admissible iff (1) the set of its predicate names is closed under negation
and contains a name >D for D , and (2) the satisfiability problem for finite conjunctions
of predicates is decidable.
Given a concrete domain D and one of the predicates P  D (of arity n), one can
define a new concept constructor f1 , . . . , fn .P (predicate restriction), where f1 , . . . , fn are
concrete features.11 In contrast to the abstract features considered until now, concrete
features are interpreted by partial functions from the abstract domain I into the concrete
domain D . We consider the basic DL that allows for Boolean operators and these new
concept constructors only.
Definition 41 (B(D)). Let NC be a set of concept names and NFc be a set of names for
concrete features disjoint from NC , and let D be an admissible concrete domain. Concepts
descriptions of B(D) are Boolean combinations of concept names and predicate restrictions, i.e., expressions of the form f1 , . . . , fn .P where P is an n-ary predicate in D and
f1 , . . . , fn  NFc .
The semantics of B(D) is defined as follows. We consider an interpretation I, which
has a nonempty domain I , and interprets concept names as subsets of I and concrete
features as partial functions from I into D . The Boolean operators are interpreted as
usual, and
(f1 , . . . , fn .P )I = {a  I | x1 , . . . , xn  D .
fiI (a) = xi for all 1  i  n and (x1 , . . . , xn )  P D }.
Note that concept descriptions are interpreted as subsets of I and not of I  D .
Thus, if we go to the ADS corresponding to B(D), the concrete domain is not an explicit
part of the corresponding ADMs. It is only used to define the interpretation of the function
symbols corresponding to predicate restrictions. The predicate restriction constructor is
translated into a function symbol ff1 ,...,fn .P of arity 0, and, for an ADM W corresponding
W
to a frame F, ff
is defined as (f1 , . . . , fn .P )I , where I is the interpretation based
1 ,...,fn .P
on F that maps all concept names to the empty set.
Theorem 42. Let D be an admissible concrete domain. Then, B(D) is local and the
relativized satisfiability problem for B(D)-concept descriptions is decidable.
Proof. Given the family (Wi )iI of ADMs Wi corresponding to the frames Fi over pairwise
disjoint
domains Fi (i  I), we first build the union F of the frames: the domain of F is
S
F
i and it interprets the concrete features in the obvious way, i.e., f F (x) := f Fi (x) if
iI 
11. Note that the general framework introduced by Baader and Hanschke (1991) allows for feature chains in
predicate restrictions. Considering only feature chains of length one is the main restriction introduced
by Haarslev et al. (2001).

37

fiBaader, Lutz, Sturm, & Wolter

x  Fi . Let W be the ADM induced by F. ToSprove that W is in fact the disjoint union of
Wi
W
(Wi )iI , it remains to show that ff
= iI ff
. This is an easy consequence
1 ,...,fn .P
1 ,...,fn .P
of the semantics of the predicate restriction constructor, the interpretation of the concrete
features in F, and the fact that the domains Fi are pairwise disjoint.
Decidability of the unrelativized satisfiability problem is an immediate consequence of
the decidability results for ALC(D) given by Baader and Hanschke (1991). Since B(D) is a
very simple DL that does not contain any concept constructors requiring the generation of
abstract individuals, it is easy to see that a B(D)-concept description C0 is satisfiable relative
to the TBox C1 v D1 , . . . , Cn v Dn iff it is satisfiable in a one-element interpretation. But
then the TBox can be internalized in a very simple way: C0 is satisfiable relative to the
TBox C1 v D1 , . . . , Cn v Dn iff C0 u (C1 t D1 ) u . . . u (Cn t Dn ) is satisfiable.

Given this theorem, Corollary 22 now yields the following transfer result, which shows
that concrete domains with the restricted form of predicate restrictions introduced above can
be integrated into any local DL with a decidable relativized satisfiability problem without
losing decidability.
Corollary 43. Let D be an admissible concrete domain and L be a local DL for which
relativized satisfiability of concept descriptions is decidable. Then, relativized satisfiability
of concept descriptions in B(D)  L is also decidable.
5.4 Non-local DLs
By Proposition 15, DLs allowing for nominals, the universal role, or role negation are not
local. It follows that the decidability transfer theorems are not applicable to fusions of such
DLs. In the following, we try to clarify the reasons for this restricted applicability of the
theorems.
First, we show that there are DLs with decidable satisfiability problem such that their
fusion has an undecidable satisfiability problem. The culprit in this case is the universal
role (or role negation).
Theorem 44. Satisfiability of concept descriptions is decidable in ALC U and ALCF, but
undecidable in their fusion ALC U  ALCF.
Proof. Decidability of ALCF was shown by Hollunder and Nutt (1990) and of ALC U by
Baader et al. (1990) and Goranko and Passy (1992). Undecidability of ALC U  ALCF
(which is identical to ALCF U ) follows from the results by Baader et al. (1993) and the fact
that the universal role can be used to simulate TBoxes (see Proposition 24).

Note that role negation can be used to simulate the universal role: just replace U.C
by R.C u R.C and U.C by R.C t R.C. In addition, decidability of ALC  is known
to be decidable (Lutz & Sattler, 2000). Consequently, the theorem also holds if we replace
ALC U by ALC  .
It should be noted that the example given in the above theorem depends on the fact
that one of the two DLs allows for the universal role and the other becomes undecidable
if the universal role is added. In fact, Corollary 25 shows that decidability does transfer if
both DLs already provide for the universal role.
38

fiFusions of Description Logics and Abstract Description Systems

Concerning nominals, we do not have a counterexample to the transfer of decidability
in their presence. However, we think that it is very unlikely that there can be a general
transfer result in this case. In fact, note that for each DL L without nominals introduced in
Section 2, its fusion with ALCO is identical to L extended with nominals. Since (relativized)
satisfiability in ALCO is decidable, a general transfer result in this case would imply that
this extension is decidable provided that L is decidable. Consequently, this would yield a
general transfer result for adding nominals.

6. Conclusion
Regarding related work, the work that is most closely related to the one presented here is
(Wolter, 1998). There, analogs of our Theorems 20 and 30 are proved for normal modal
logics within an algebraic framework. The present results extend the ones from Wolter
(1998) in two directions. First, we have added object assertions, and thus can also prove
transfer results for ABox reasoning. Second, we can show transfer results for satisfiability in
non-normal modal logics as long as we have covering normal terms. This allows us to handle
non-normal concept constructors like qualified number restrictions (graded modalities) in
our framework.
We also think that the introduction of abstract description systems (ADSs) is a contribution in its own right. ADSs abstract from the internal structure of concept constructors
and thus allow us to treat a vast range of such constructors in a uniform way. Nevertheless, the model theoretic semantics provided by ADSs is less abstract than the algebraic
semantics employed by Wolter (1998). It is closer to the usual semantics of DLs, and thus
easier to comprehend for people used to this semantics. The results in this paper show
that ADSs in fact yield a good level of abstraction for proving general results on description logics. Recently, the same notion has been used for proving general results about
so-called E-connections of representation formalisms like description logics, modal spatial
logics, and temporal logics (Kutz, Wolter, & Zakharyaschev, 2001). In contrast to fusions,
in an E-connection the two domains are not merged but connected by means of relations.
Regarding complexity, our transfer results yield only upper bounds. Basically, they
show that the complexity of the algorithm for the fusion is at most one exponent higher
than of the ones for the components. We believe that the complexity of satisfiability in the
fusion of ADSs can indeed be exponentially higher than the complexity of satisfiability in
the component ADSs. However, we do not yet have matching lower bounds, i.e., we know
of no example where this exponential increase in the complexity really happens.
Note that Spaans results (1993) on the transfer of NP and PSpace decidability from
the component modal logics to their fusion are restricted to normal modal logics, and that
they make additional assumptions on the algorithms used to solve the satisfiability problem
in the component logics. Nevertheless, for many PSpace-complete description logics it is
easy to see that their fusion is also PSpace-complete. In this sense, the general techniques
for reasoning in the fusion of descriptions logics developed in this paper give only a rough
complexity estimate.

39

fiBaader, Lutz, Sturm, & Wolter

Appendix A. Proofs
In this appendix, we give detailed proofs of criteria for (relativized) satisfiability in the
fusion of local ADSs. Recall that, from these criteria, the transfer theorems for decidability
easily follow. We have deferred the proofs of these theorems to the appendix since they are
rather technical.
A.1 Proof of Theorem 20
Before we can prove this theorem, we need a technical lemma. In the proof of Theorem 20,
we are going to merge models W1  M1 and W2  M2 by means of a bijective function b
from the domain W1 of W1 onto the domain W2 of W2 in such a way that the surrogates
suri (t), t  C 1 (), are respected by b in the sense that
1

w  sur1 (t)W1 ,A  b(w)  sur2 (t)W2 ,A

2

for all w  W1 and t  C 1 (). The existence of such a bijection is equivalent to the condi1
1
2
2
tion that the cardinalities |sur1 (t)W1 ,A | of sur1 (t)W1 ,A and |sur2 (t)W2 ,A | of sur2 (t)W2 ,A
coincide for all t  C 1 (): if t 6= t0 for t, t0  C 1 (), then t contains a conjunct which is
i
(equivalent to) the negation of a conjunct of t0 ; hence, for all such t, t0 , we have suri (t)Wi ,A 
i
suri (t0 )Wi ,A =  for i  {1, 2}, which clearly yields the above equivalence. The following
lemma will be used to choose models in such a way that this cardinality condition is satisfied.
(We refer the reader to, e.g., Gratzer, 1979 for information about cardinals.)
Lemma 45. Let (L, M) be a local ADS and  a set of assertions satisfiable in (L, M).
Then there
exists aff cardinal  such that, for all cardinals 0  , there exists a model


W = W, F W , RW  M with |W | = 0 and an assignment A with hW, Ai |=  and
|sW,A |  {0, 0 } for all terms s.


ff
Proof. By assumption, there exists an ADM W0 = W0 , F W0 , RW0  M and an assignment B = hB1 , B2 i in it such that hW0 , Bi |= . Let  = max{0 , |W0 |}. We
show that
Let 0  . Take 0 disjoint isomorphic copies hW , B1 i,

  isWas required.
ff
W
W = W , F  , R 
 ,  < 0 , ffof hW0 , B1 i. (The first member of the list coincides
with W0 .) Let W = W, F W , RW be the disjoint union of the W ,  < 0 , and define
hW, A = hA1 , A2 ii by putting A2 (a) = B2 (a), for all a  X , and
[ 
A1 (x) =
B1 (x),
<0

for all x  V . Note that all object variables are interpreted in W0 . It follows from the
definitions of term semantics and disjoint unions that
[
sW,A =
sW ,B ,
()
<0

for all terms s. Hence |W | = 0 and hW, Ai |= . It remains to show that |sW,A |  {0, 0 }
for every term s. Suppose |sW,A | =
6 0. Then, by (), 0  |sW,A |    0 = 0 , which means
0
W,A
 = |s
|.

40

fiFusions of Description Logics and Abstract Description Systems

i

i

As noted above, the disjointness of the sets suri (t)Wi ,A and suri (t0 )Wi ,A (for t 6= t0 )
is required in order to ensure the existence of the bijection b. More precisely, in order to
i
merge models W1 , W2 , the sets suri (t)Wi ,A for t member of some relevant subset of C 1 ()
must form a partition of Wi s domain that satisfies a certain cardinality condition. This is
formalized by the following definition:
Definition 46. Let  be a cardinal. A set {X1 , . . . , Xn } is called a -partition of a set W
iff
1. |Xi | = , for all 1  i  n,
2. Xi  Xj =  whenever i 6= j, and
S
3. W = 1in Xi .
{X1 , . . . , Xn } is a -partition of an ADM W with domain W iff it is a -partition of W .
In the proof, we will enforce that Properties 1 and 3 hold by appropriate constructions,
while Property 2 holds by definition of C 1 ().
Before proving Theorem 20, we repeat its formulation.
Theorem 20. Let Si = (Li , Mi ), i  {1, 2}, be two local ADSs in which L1 is based on
the set of function symbols F and relation symbols R, and L2 is based on G and Q, and
let L = L1  L2 and M = M1  M2 . If  is a finite set of assertions from L, then the
following are equivalent:
1.  is satisfiable in (L, M).
2. There exist
(a) a set D  C 1 (),
(b) for every term t  D an object variable at 6 obj(),
(c) for every a  obj() a term ta  D,
such that the union 1 of the following sets of assertions in L1 is satisfiable in
(L1 , M1 ):
W
(d) {at : sur1 (t) | t  D}  {> v sur1 ( D)},
(e) {a : sur1 (ta ) | a  obj()},

(f ) {R(a, b) | R(a, b)  , R  R},
(g) {sur1 (t1 ) v sur1 (t2 ) | t1 v t2  }  {a : sur1 (s) | (a : s)  };
and the union 2 of the following sets of assertions in L2 is satisfiable in (L2 , M2 ):
W
(h) {at : sur2 (t) | t  D}  {> v sur2 ( D)},
(i) {a : sur2 (ta ) | a  obj()},

(j) {Q(a, b) | Q(a, b)  , Q  Q}.
41

fiBaader, Lutz, Sturm, & Wolter

sur1 (s1 )W1 ,A

b

1

b

W1 ,A1

sur1 (s2 )

sur2 (s1 )W2 ,A

2

sur2 (s2 )W2 ,A

2

.
.
.

.
.
.

sur1 (sk )W1 ,A

.
.
.

b

1

sur2 (sk )W2 ,A

W1

2

W2
Figure 3: The mapping b.

Proof. We start with the direction from (2) to (1). Take a set D  C 1 () satisfying
the properties listed in the theorem. Take

 cardinals

i1, i 1ffff{1, 2} 
as in Lemma

 245 2for
ffff
1
2
(Li , Mi ), put  = max{
1 , 2 }, and
take W1 , A = A1 , A2 and W2 , A = A1 , A2
ff
with Wi  Mi such that Wi , Ai |= i for i  {1, 2}. By Lemma 45, for i  {1, 2} we can
i
assume |Wi | =  and, |suri (s)Wi ,A |  {0, } for all s  D.
i
The sets {suri (s)Wi ,A : s  D}
are -partitions
of WiWfor i  {0, 1} since (i) for each s 
ff
i
D, we have (as : suri (s))  i , (ii) Wi , A |= > v suri ( D), and (iii) s, s0  D and s 6= s0
i
i
implies suri (s)Wi ,A  suri (s0 )Wi ,A by definition of D and C 1 . Moreover, obj(1 ) = obj(2 )
1
2
and, for all a  obj(1 ) and s  D, we have A12 (a)  sur1 (s)W1 ,A iff A22 (a)  sur2 (s)W2 ,A .
Together with the fact that A12 and A22 are injective, this implies the existence of a
bijection b from W1 onto W2 such that
1

2

{b(w) : w  sur1 (t)W1 ,A } = sur2 (t)W2 ,A ,
for all t  D, and

b(A12 (a)) = A22 (a),

for all a  obj(1 ). Figure 3, in which it is assumed that D = {s1 , . . . , sk }, illustrates the
mapping b.


ff
Define a model W = W, (F  G)W , (R  Q)W  M by putting
 W = W1 ,
 f W = f W1 , for f  F,
 for all g  G of arity n and all Z1 , . . . , Zn  W ,
g W (Z1 , . . . , Zn ) = b1 (g W2 (b(Z1 ), . . . , b(Zn ))),
where b(Z) = {b(z) : z  Z},
 RW = RW1 , for all R  R,
 QW (x, y) iff QW2 (b(x), b(y)), for all Q  Q.
42

fiFusions of Description Logics and Abstract Description Systems

Since M2 is closed under isomorphic copies, it is not hard to see that W  M1  M2 . Let
A = A1 . To prove the implication from (2) to (1) of the theorem it remains to show that
hW, Ai |= . To this end it suffices to prove the following claim:
Claim. For all terms t  sub1 (), we have
2

1

tW,A = sur1 (t)W1 ,A = b1 (sur2 (t)W2 ,A ).
Before we prove this claim, let us show that it implies hW, Ai |= . First note that, from
the claim, we obtain
1
tW,A = sur1 (t)W1 ,A for all t  term().
(1)
This may be proved by induction on the construction of t  term() from terms in sub1 ()
using the booleans and function symbols from L1 , only. The basis of induction (i.e., the
equality for members of sub1 ()) is stated in the claim and the induction step is straightforward.
We now show that hW, Ai |=  is a consequence of (1). Suppose R(a, b)  . Then
R(a, b)  1 and thus hW, Ai |= R(a, b). Similarly, Q(a, b)   implies Q(a, b)  2 and
1
hW, Ai |= Q(a, b). Suppose (a : t)  . Then (a : sur1 (t))  1 and so A12 (a)  sur1 (t)W1 ,A
which implies, by (1), A12 (a)  tW,A . Hence hW, Ai |= (a : t). If t1 v t2  , then
sur1 (t1 ) v sur1 (t2 )  1 and so, by (1), tW,A
 tW,A
. Hence hW, Ai |= t1 v t2 .
1
2
We come to the proof of the claim. It is proved by induction on the structure of t.
Due to the following equalities holding for all t  sub1 (), it suffices to show that tW,A =
1
sur1 (t)W1 ,A .
sur1 (t)W1 ,A

1

1

=

[

{sur1 (s)W1 ,A : s  D, t is a conjunct of s}

=

[

{b1 (sur2 (s)W2 ,A ) : s  D, t is a conjunct of s}

2

2

= b1 (sur2 (t)W2 ,A )
W
1
The first equality holds since sur1 ( D)W1 ,A = W1 and, for all s  D, either t or t
is a conjunct of s. The second equality is true by definition of b and the validity of the
thirdWequality can be seen analogously to the validity of the first one by considering that
2
sur2 ( D)W2 ,A = W2 .
1

Hence let us show tW,A = sur1 (t)W1 ,A . For the induction start, let t be a variable. The
1
equation tW,A = sur1 (t)W1 ,A is an immediate consequence of the fact that A = A1 . For
the induction step, we distinguish several cases:

 t = t1 . By induction hypothesis, tW,A
= sur1 (t1 )W1 ,A1 . Hence, tW,A = W \ tW,A
=
1
1
1
1
W
,A
W
,A
1
1
W \ sur1 (t1 )
= sur1 (t)
(since W = W1 ).
 t = t1  t2 . By induction hypothesis, tW,A
= sur1 (ti )W1 ,A1 for i  {1, 2}. Hence,
i
1
1
1
tW,A = tW,A
 tW,A
= sur1 (t1 )W1 ,A  sur1 (t2 )W1 ,A = sur1 (t)W1 ,A .
1
2
 t = t1  t2 . Similar to the above case.
43

fiBaader, Lutz, Sturm, & Wolter

1

 t = f (t1 , . . . , tn ). By induction hypothesis, tW,A
= sur1 (ti )W1 ,A for 1  i  n. Hence,
i
1
1
1
W,A
W,A
tW,A = f W (t1 , . . . , tn ) = f W (sur1 (t1 )W1 ,A , . . . , sur1 (tn )W1 ,A ) = sur1 (t)W1 ,A
(since f W = f W1 ).
 t = g(t1 , . . . , tn ). In this case, tW,A = b1 (g W2 (b(tW,A
), . . . , b(tW,A
))). Since, by the
n
1
2
2
1
W
,A
1
W
,A
1
2
above equalities, sur1 (t)
= b (sur2 (t)
), it remains to show that sur2 (t)W2 ,A =
2
2
2
g W2 (b(tW,A
), . . . , b(tW,A
)). Since we have sur2 (t)W2 ,A = g W2 (sur2 (t1 )W2 ,A , . . . , sur2 (tn )W2 ,A ),
n
1
2
this amounts to showing that b(tW,A
) = sur2 (ti )W2 ,A for 1  i  n. This, however,
i
follows by induction hypothesis together with the above equations.
This concludes the proof of the direction from (2) to (1).
It remains to prove the direction from (1) to (2). Suppose hW, Ai |= , for some W  M
and A = hA1 , A2 i. Put
D = {s  C 1 () : sW,A 6= }.
Note that the fusion of local ADLs is a local ADL again. Hence (L, M) is local and we may
assume, by Lemma 45, that the sets sW,A are infinite.
Take a new object name as 6 obj() for every s  D and let, for a  obj(),
^
^
ta = {t  sub1 () : A2 (a)  tW,A }  {t : t  sub1 (), A2 (a) 6 tW,A }.
We prove that set of assertions 1 based on D, ta , a  obj(), and as , s  D, is satisfiable
in (L1 , M1 ).
W
Let F W denote the restriction of (F  G)W to the
 symbols in F.
R
ff Similarly,

 1 is the
ff
W
W
W
1
restriction of (RQ) to the symbols in R. Set W1 = W, F , R
 M1 , A = A1 , A12 ,
where
A11 = A1  {xt 7 tW,A : t = g(t1 , . . . , tk )  sub1 ()},
A12 (a) = A2 (a), for a  obj(), and A12 (as )  sW,A , for all s  D. Note that we can choose
an injective function A12 because the sW,A are infinite. We show by induction that
sur1 (t)W1 ,A1 = tW,A for all t  term().

(2)

Let t = x be a variable. Then x is not a surrogate, and so A11 (x) = A1 (x). For the induction
step, we distinguish several cases:
 The inductive steps for t = t1 , t = t1  t2 , t = t1  t2 , and t = f (t1 , . . . , tn ), f  F,
are identical to the corresponding cases in the proof of Equation 1, which occurs in
the direction that (2) implies (1) above.
 t = g(t1 , . . . , tn ), where g  G. Then sur1 (t) = xt . Hence A11 (xt ) = tW,A and the
equation is proved.


ff


ff
From Equation 2,
 we obtain
W1 , A1 |= 1 : we prove W1 , A1 |= R(a, b) whenever
ff
R(a, b)  1 and W1 , A1 |= sur1 (t1 ) v sur1 (t2 ) whenever sur1 (t1 ) v sur1 (t2 )  1 . The
remaining formulas from 1 are left

 to theffreader. Suppose R(a, b)  1 . Then R(a, b)  
and so hW, Ai |= R(a, b). Hence W1 , A1 |= R(a, b). Suppose sur1 (t1 ) v sur1 (t2 )  1 .
44

fiFusions of Description Logics and Abstract Description Systems

 t2W,A . By Equation 2,
Then t1 v t2  . Hence hW, Ai |= t1 v t2 which means tW,A
1


ff
1
1
sur1 (t1 )W1 ,A  sur1 (t2 )W1 ,A which means W1 , A1 |= sur1 (t1 ) v sur1 (t2 ).
The construction of a model in M2 satisfying 2 is similar and left to the reader.

A.2 Proof of Theorem 30
As in the proof of Theorem 17, we fix two local ADSs Si = (Li , Mi ), i  {1, 2}, in which
L1 is based on the set of function symbols F and relation symbols R, and L2 is based on
G and Q. Let L = L1  L2 and M = M1  M2 . We assume that S1 and S2 have covering
normal terms.
Similarly to what was done in the previous section, we will merge models by means
1
of bijections which map points in sets sur1 (t)W1 ,A to points in the corresponding sets
2
sur2 (t)W2 ,A . For a finite set of object assertions  of L, let i () denote the set of all
s  C i () such that the term s is satisfiable in (L, M) (for i  {1, 2}). To ensure that
the merging of models succeeds, we must enforce that the elements of 1 () and 2 ()
form -partitions (for some appropriate ) of the models to be merged. For 1 (), this
is captured by the following lemma. Explicitly stating a dual of this lemma for 2 () is
omitted for brevity.
Lemma 47. Let  be a finite set of object assertions of L,  a cardinal satisfying the
conditions of Lemma 45 for (L, M) and , and 1 = 1 (). If 0  , then
1. there exists a model W  M1 and an assignment A such that
{sur1 (s)W,A | s  1 }
is a 0 -partition of W; and
2. there exists a model W  M2 and an assignment A such that
{sur2 (s)W,A | s  1 }
is a 0 -partition of W.
Proof. 1. By definition of 1 , for each s  1 , we find a model Ws  M and an
assignment As such that sWs ,As 6= . Since the fusion of two local ADSs is again local,
the set of models M is closed under disjoint unions. Hence, there exists a model W1
and an assignment A1 such that sW1 ,A1 6=  for all s  1 . It follows that the set
1 := D{as : s | s  1 } is satisfiable
E in (L, M). By Lemma 45, there thus exists a model
0
0
0
0
W
W
W = W , (F  G) , (R  Q)
 M and an assignment A0 such that W0 , A0 |= 1 and
0

0

{sW ,A | s  1 } is a 0 -partition of W 0 . Now let W denote the restriction of W0 to L1 and
define
0
0
A1 = A01  {xt 7 tW ,A | t = g(t1 , . . . , tk )  sub1 ()}.
0

0

Then hW, Ai is as required. To prove this note that sur1 (t)W,A = tW ,A for all t  term().
2. is similar and left to the reader.

45

fiBaader, Lutz, Sturm, & Wolter

We repeat the formulation of the theorem to be proved.
Theorem 30. Let Si = (Li , Mi ), i  {1, 2}, be two local ADSs having covering normal
terms in which L1 is based on the set of function symbols F and relation symbols R, and
L2 is based on G and Q, and let L = L1  L2 and M = M1  M2 . Let  be a finite set
of object assertions from L. Put m := dF (), r := dG (), and let c(x) (d(x)) be a covering
normal term for all function symbols in  that are in F (G).
For i  {1, 2}, denote by i the set of all s  C i () such that the term s is satisfiable in
(L, M). Then the following three conditions are equivalent:
1.  is satisfiable in (L, M).
2. There exist
 for every t  1 an object variable at 6 obj()
 for every a  obj() a term ta  1
such that the union 1 of the following sets of object assertions is satisfiable in
(L1 , M1 ):
W
 {at : sur1 (t  cm (sur1 ( 1 )) | t  1 },
W
 {a : sur1 (ta  cm (sur1 ( 1 )) | a  obj()},
 {R(a, b) | R(a, b)  , R  R},
 {a : sur1 (s) | (a : s)  };
and the union 2 of the following sets of object assertions is satisfiable in (L2 , M2 ):
W
 {at : sur2 (t  dr (sur2 ( 1 )) | t  1 },
W
 {a : sur2 (ta  dr (sur2 ( 1 )) | a  obj()},
 {Q(a, b) | Q(a, b)  , Q  Q}.

3. The same condition as in (2) above, with 1 replaced by 2 .
We start the proof with the direction from (1) to (2) and (1) to (3). The proofs are
dual to
so we onlyff give a proof for (1)  (2). Suppose hW, Ai |= , where

 each other,
W
W = W, (F  G) , (R  Q)W . By Lemma 45, we can assume that that, for every t  1 ,
|tW,A | is infinite. Take a new object name as 6 obj() for every s  1 and let, for
a  obj(),
^
^
ta = {t  sub1 () : A2 (a)  tW,A }  {t : t  sub1 (), A2 (a) 6 tW,A }.
We prove that the set 1 of assertions based on ta , a  obj(), and as , s  1 , is satisfiable
in (L1 , M1 ) (the proof is rather similar to the proof of the direction from (1) to (2) in the
proof of Theorem 20). Let F W (resp. G W ) denote the restriction of (F  G)W to the symbols
in F (resp. G). Similarly, RW and
 QW are theffrestrictions of 
(R  Q)ffW to the symbols in
R and Q, respectively. Set W1 = W, F W , RW  M1 , A1 = A11 , A12 , where
A11 = A1  {xt 7 tW,A | t = g(t1 , . . . , tk )  sub1 ()},
46

fiFusions of Description Logics and Abstract Description Systems

A12 (a) = A2 (a), for a  obj(), and A12 (at )  tW,A , for all t  1 (we can choose an injective
function for A12 since the sets tW,A are infinite).
As in the corresponding part of the proof of Theorem 20, it can show by induction that
sur1 (t)W1 ,A1 = tW,A for all t  term().


ff
Let us see now why W1 , A1 |= 1 follows from
For R(a, b)  1 we have

 this equation.
ff
1 |= R(a, b). We have hW, Ai |=
R(a,
b)


and
so
hW,
Ai
|=
R(a,
b).
Hence
W
,
A

 1 1ff
W
W
( 1 ) = > (by the definition
of

).
Hence
W1 , A |= sur1 ( 1 ) = > and so, by
1
ff


W
the definition of cm , W1 , A1 |= (cm (sur1 ( 1 ))) = >. It remains to observe that
A12 (a)  sur1 (ta )W1 ,A1 for all a  obj(), A12 (a)  sur1 (s)W1 ,A1 whenever (a : s)  , and
A12 (at )  sur1 (t)W1 ,A1 for all t  1 .
The construction of a model in M2 satisfying 2 is similar and left to the reader.
It remains to show the implications (2)  (1) and (3)  (1). They are similar, so
we concentrate on the first. In the proof of Theorem 20 it was possible to construct the
required model for  by merging models for 1 and 2 . The situation is different here. It
is not possible to W
merge models for 1 and
W 2 in one step, since we do not know whether
they satisfy sur1 ( 1 ) = > and sur2 ( 1 ) = >,
W respectively. We only know that
W they
satisfy the approximations a : sur1 (s)  cm (sur1 ( 1 )) and a : sur2 (s)  dr (sur2 ( 1 )),
respectively, for a : s  . To merge models of this type we have to distinguish various
pieces of the models and have to add new pieces as well. To define those pieces we need a
technical claim. As in the proof of Theorem 17, take cardinals i , i  {1, 2} as in Lemma 45
for (Li , Mi ) and put  = max{1 , 2 }.
Claim 1. Suppose (2) holds.


ff
(a) There exist W1 = W1 , F W , RW  M1 , an assignment A = hA1 , A2 i into W1 , and
a sequence X0 , . . . , Xm of subsets of W1 such that
[a1] A2 (a)  Xm , for all a  obj(1 ),
[a2] hW1 , Ai |= 1 ,
[a3] Xn+1  Xn  cW1 (Xn ), for all 0  n < m,
[a4] The set {sur1 (s)W1 ,A  Xm : s  1 } is a -partition of Xm ,
[a5] The sets
{sur1 (s)W1 ,A  (Xn  Xn+1 ) : s  1 }
are -partitions of Xn  Xn+1 , for 0  n < m.
[a6] |W1  X0 | = .


ff
(b) There exist W2 = W2 , G W , QW  M2 , an assignment B = hB1 , B2 i, and a sequence
Y0 , . . . , Yr of subsets of W2 such that
[b1] B2 (a)  Yr , for all a  obj(1 ),
[b2] hW2 , Bi |= 2 ,
47

fiBaader, Lutz, Sturm, & Wolter

A1 = W1  X0
A0 = X 0  X 1

..
.

..
.

Am2 = Xm2  Xm1
Am1 = Xm1  Xm
Xm

W1
Figure 4: The sets Xi .

[b3] Yn+1  Yn  dW2 (Yn ), for all 0  n < r,
[b4] The set {sur2 (s)M,A  Yr : s  1 } is a -partition of Yr ,
[b5] The sets
{sur2 (s)M,A  (Yn  Yn+1 ) : s  1 }
are -partitions of Yn  Yn+1 , for 0  n < r.
[b6] |W2  Y0 | = .
Figure 4 illustrates the relation between the sets Xi . (We set Ai = Xi  Xi+1 for 0  i < m
and A1 = W
W1  X0 .) Intuitively, Xm is the set of points for which we know that points in
W1  sur1 ( 1 )W1 ,A are very far away. For Xm1 they are possibly less far away, for
Xm2 possibly even less far, and so on for W
Xi , i < m  1. Finally, for members of A1 it
is not even known whether they are in sur1 ( 1 )W1 ,A or not. Note that all object names
are interpreted in Xm . We now come to the formal construction of the sets Xi .
Proof of Claim 1. We prove (a). Part (b) is proved
andffleft to the reader. By

 similarly
W
a
assumption and Lemma 45, we find an ADM Wa = Wa , F , RWa  M1 with |Wa | = 
and an assignment Aa = hAa1 , Aa2 i such that hWa , Aa i |= 1 .
Let
_
Zn = (cn (sur1 ( 1 )))Wa ,Aa ,
for 0 
 n  m. By Lemma
47 (1) we can take for every n with 1  n  m an ADM
ff
Wn = Wn , F Wn , RWn  M1 and assignments An such that
n

{sur1 (s)Wn ,A : s  1 }
48

fiFusions of Description Logics and Abstract Description Systems

are -partitions of Wn .
ff


Take the disjoint union W (with W = W, F W , RW ) of the Wn , 1  n  m, and Wa .
Define A = hA1 , A2 i in W by putting
[
A1 (x) = Aa1 (x) 
Ai1 (x),
1im

for all set variables x and A2 (b) = Aa2 (b), for all object variables b. Let, for 0  n  m,
[
Xn = Zn 
Wi .
nim

We show that hW, Ai and the sets Xn , 0  n  m, are as required.
[a1] We have hWa , Aa i |= 1 and so A2 (b) = Aa2 (b)  Zm for all b  obj(1 ). Hence
A2 (b)  Xm = Zm  Wm for all b  obj(1 ).
[a2] By the definition of disjoint unions and because hWa , Aa i |= 1 .
[a3] Firstly, we have, by the definition of cn t and since cW is monotone (it distributes
over intersections),
Zn+1  Zn  cW (Zn )  Xn  cW (Xn ).
(3)
Secondly, by the definition of disjoint unions, the first property of covering normal
terms, and since cW is monotone
[
[
[
[
Wi 
Wi 
Wi  cW (
Wi )  Xn  cW Xn .
(4)
n+1im

nim

nim

nim

From (3) and (4) we obtain
Xn+1 = Zn+1 

[

Wi  Xn  cW Xn .

(5)

n+1im

[a4] We show that the three properties from Definition 46 are satisfied. Since
{sur1 (s)Wm ,Am : s  1 }
is a -partition of Wm , we have |sur1 (s)Wm ,Am | =  for all s  1 . This implies
Property 1 since sur1 (s)W,A  Wm = sur1 (s)Wm ,Am , Wm  Xm , and |Xm |  .
Property 2 is an immediate consequence of the definition of 1 . As for Property 3,
we show that, for all w  Xm , we have w  sW,A for an s  1 . Fix a w  Xm . We
distinguish two cases: firstly, assume w  Wm . Then, by the fact that {sur1 (s)Wm ,Am :
s  1 } is a -partition of Wm , it is clear
W that there exists an s  1 as required.
m (sur (  )))Wa ,Aa . By definition of cm t, we have
Secondly, assume
w

Z
=
(c
m
1
1
W
w  (sur1 ( 1 ))Wa ,Aa and so again w  sur1 (s)W,A for some s  1 .
[a5] The proof is similar to that of Property [a4].
49

fiBaader, Lutz, Sturm, & Wolter

[a6] By definition.
This finishes the proof of Claim 1.
Suppose now that we have
E
D
E
D
W1 = W1 , F W1 , RW1 , A, Xm , . . . , X0 and W2 = W2 , G W2 , QW2 , B, Yr , . . . , Y0
satisfying the properties listed in Claim 1. We may assume that
(W1  Xm )  (W2  Yr ) = .
Using an appropriate bijection b from Xm onto Yr we may also assume that Xm = Yr ,
A2 (a) = B2 (a) for all object variables a  obj(1 ), and
sur1 (s)W1 ,A  Xm = sur2 (s)W2 ,B  Xm for all s  1 .

(6)

This follows from the fact that all object variables are mapped by A2 and B2 into Xm and
Yr ([a1], [b1]), respectively, the injectivity of the mappings A2 and B2 , and the conditions
[a4] and [b4] which state that {sur1 (s)W1 ,A  Xm : s  1 } and {sur2 (s)W2 ,B  Yr : s  1 }
both form -partitions of Xm = Yr . Some abbreviations are useful: set
 Ai = Xi  Xi+1 , for 0  i < m,
 Bi = Yi  Yi+1 , for 0  i < r,
 A1 = W1  X0 , B1 = W2  Y0 .
So far we have merged the Xm -part of W1 with the Yr -part of W2 . It remains to take care
of the sets Ai , 1  i < m, and Bi , 1  i < r: the sets Ai will be merged with new
models Wi  M2 and the sets Bi will be merged with new models Vi from M1 . Thus,
the final model will be obtained by merging the disjoint union of W1 and Wi , 1  i < m
with the disjoint union of W2 and Vi , 1  i < r. Figure 5 illustrates this merging. In the
figure, we assume that 1 = {s1 , . . . , sk }.
Of course, when merging Ai , i  0, with a new model Wi we have to respect the partition
{sur1 (t)W1 ,A  Ai | t  1 }
of Ai . And when merging Bi , i  0, with a new model Vi we have to respect the partition
{sur1 (t)W1 ,B  Bi | t  1 }
of Bi . Note that for A1 and B1 there is no partition
care
D to take
E of. We now proceed with
i
i
i
W
W
the formal construction. We find models W = Ai , G , Q
 M2 with assignments

 i iff
i
B = B1 , B2 , 1  i  m  1, such that, for 0  i  m  1,
i

i

sur2 (s)W ,B = sur1 (s)W1 ,A  Ai for all s  1 .
This follows from [a5], [a6], and Lemma 47 (2).
50

(7)

fiFusions of Description Logics and Abstract Description Systems

Xm Am1

...

A0 A1 Vr1

...

V0 V1

sur1 (s1 )

.
.
.

...

...

...
Wm1 . . .

...
...

sur1 (sk )

Yr

W0 W1 Br1

B0 B1

sur2 (s1 )

.
.
.

...

.. .

sur2 (sk )
Figure 5: The bijection.

D
E
i
i
We find, now using [b5], [b6], and Lemma 47 (1), models Vi = Bi , F V , RV  M1


ff
with assignments Ai = Ai1 , Ai2 , 1  i  r  1, such that, for 0  i  r  1,
i

i

sur1 (s)V ,A = sur2 (s)W2 ,B  Bi for all s  1 .
Let

(8)

D
E
0
0
W01 = W1  (W2  Yr ), F W1 , RW1  M1

be the disjoint union of the Vi , 1  i < r, and W1 , and let
D
E
0
0
W02 = W2  (W1  Xm ), G W2 , QW2  M2
be the disjoint union of the Wi , 1  i < m, and W2 . We assume Xm = Yr and so the
domain of both ADMs is
 W1  W2 .
ff
Define a model W = W, (F  G)W , (R  Q)W  M based on W = W1 W2 by putting
0

 RW = RW1 ,
0

 F W = F W1 ,
0

 QW = QW2 ,
0

 G W = G W2 .
51

fiBaader, Lutz, Sturm, & Wolter

Define an assignment C = hC1 , C2 i in W by putting
 C2 (a) = A2 (a)(= B2 (a)), for all a  obj(1 ).
S
 C1 (x) = A1 (x)  1i<r Ai1 (x), for all set variables x in term().
S
Notice that C1 (x) = B1 (x)  1i<m B1i (x), for all set variables x  term().
 C1 (xt ) = A1 (xt ) 

S

 C1 (xt ) = B1 (xt ) 

S

1i<r

Ai1 (xt ), for all t = g(t1 , . . . , tk )  sub1 ().

i
1i<m B1 (xt ),

for all t = f (t1 , . . . , tk )  sub1 ().

We will show that hW, Ci |= . Firstly, however, we make a list of the relevant properties
of hW, Ci:
Claim 2.
[c1] C2 (a)  Xm = Yr , for all a  obj();
[c2] hW, Ci |= 1  2 ;
[c3] sur1 (t)W,C  (X0  Y0 ) = sur2 (t)W,C  (X0  Y0 ), for all t  1 ;
[c4] sur1 (s)W,C  (X0  Y0 ) = sur2 (s)W,C  (X0  Y0 ), for all s  sub1 ();
[c5] Xn+1  Xn  cW (Xn ), for all 0  n < m;
[c6] Yn+1  Yn  dW (Yn ), for all 0  n < r;
[c7] for all g  G of arity l, 0  n < m, and all C1 , . . . , Cl  W :
g W (C1 , . . . , Cl )  Xn = g W (C1  Xn , . . . , Cl  Xn )  Xn ;
[c8] for all f  F of arity l, 0  n < r, and all C1 , . . . , Cl  W :
f W (C1 , . . . , Cl )  Yn = f W (C1  Yn , . . . , Cl  Yn )  Yn .
Proof of Claim 2. [c1] follows from [a1] and [b1] and the construction of hW, Ci. [c2] follows
from [a2] and [b2]. [c3] follows from the construction of hW, Ci and equations (6), (7), and
(8). [c4] follows from [c3]. [c5] and [c6] follow from [a3] and

 [b3], ffrespectively. It remains
to prove [c7] and [c8]. But [c7] follows from the fact that W, GW is the disjoint union of
structures based on Xn and W  Xn , for 0  n < m, and [c8] is dual to [c7]. Claim 2 is
proved.
We now show hW, Ci |= . To this end we first show the following:
Claim 3. For all k1 , k2 with 0  k1  m and 0  k2  r and all s  sub1 () with dF (s)  k1
and dG (s)  k2 we have, for Z  {Xk1 , Yk2 },
Z  sM,C = Z  sur1 (s)M,C = Z  sur2 (s)M,C .
52

fiFusions of Description Logics and Abstract Description Systems

Proof of Claim 3. By [c4] it suffices to prove the first equation. The proof is by induction
on the cardinal k1 + k2 . The induction base k1 = k2 = 0 follows from sur1 (s) = sur2 (s) for
dF (s) = dG (s) = 0.
Suppose the claim is proved for all Xk , Yk0 with k  m, k 0  r and k + k 0 < k1 + k2 . We
prove the claim for Xk1 , Yk2 . The proof is by induction on the construction of terms s with
dF (s)  k1 and dG (s)  k2 . The boolean cases are trivial.
Suppose s = f (s1 , . . . , sl ) with dF (s)  k1 and dG (s)  k2 . We have to show the
following two statements:
(i) Xk1  sW,C = Xk1  sur1 (s)M,C .
(ii) Yk2  sW,C = Yk2  sur1 (s)M,C .
Consider (i) first. The induction hypothesis yields
Xk1 1  sW,C
= Xk1 1  sur1 (si )W,C
i
for 1  i  l. We have
Xk1 1  cW (Xk1 1 )  sW,C = Xk1 1  cW (Xk1 1 )  f W (s1W,C , . . . , slW,C )
= Xk1 1  cW (Xk1 1 )  f W (sur1 (s1 )W,C , . . . , sur1 (sl )W,C )
= Xk1 1  cW (Xk1 1 )  sur1 (s)W,C .
The second equation is an immediate consequence of the third property of covering normal
terms as given in Definition 26. Now the equation follows from [c5], i.e. Xk1  Xk1 1 
cW (Xk1 1 ). (i) is proved.
(ii) Suppose first that k2 = r. Then Yk2 = Xm and the claim can be proved as above
since Xm  Xk1 and, by induction hypothesis, Xk1 1  sW,C
= Xk1 1  sur1 (si )W,C , for
i
1  i  l.
Assume now that k2 < r. By induction hypothesis,
Yk2  sW,C
= Yk2  sur2 (si )W,C ,
i
for 1  i  l. Hence
, . . . , Yk2  sW,C
) = f W (Yk2  sur2 (s1 )W,C , . . . , Yk2  sur2 (sl )W,C ).
f W (Yk2  sW,C
1
l
We intersect both sides of the equation with Yk2 and derive with the help of [c8]:
Yk2  f W (sW,C
, . . . , sW,C
) = Yk2  f W (sur2 (s1 )W,C , . . . , sur2 (sl )W,C ).
1
l
This means Yk2  sW,C = Yk2  sur2 (s)W,C , and the equation follows. The statements are
proved.
The case s = g(s1 , . . . , sl ) is dual and left to the reader. We have proved claim 3.
By induction (c.f. in the proof of Theorem 20 the proof of (1) from the corresponding
claim), we obtain from Claim 3:
Xm  sW,C = Xm  sur1 (s)M,C for all s  term().
53

(9)

fiBaader, Lutz, Sturm, & Wolter

Let us see how hW, Ai |=  follows from (9). We distinguish three cases: Suppose R(a, b) 
. Then R(a, b)  1 and therefore hW, Ci |= R(a, b). Similarly, Q(a, b)   implies
Q(a, b)  2 and hW, Ci |= Q(a, b). Suppose (a : t)  . Then (a : sur1 (t))  1 and so, by
[c2], C2 (a)  sur1 (t)W,C which implies, by (9), C2 (a)  tW,C . Hence hW, Ci |= (a : t). This
finishes the proof of Theorem 30.

References
Areces, C., Blackburn, P., & Marx, M. (2000). The computational complexity of hybrid
temporal logics. Logic Journal of the IGPL, 8 (5), 653679.
Baader, F. (1991). Augmenting concept languages by transitive closure of roles: An alternative to terminological cycles. In Proc. of the 12th Int. Joint Conf. on Artificial
Intelligence (IJCAI91).
Baader, F., Burckert, H.-J., Hollunder, B., Nutt, W., & Siekmann, J. H. (1990). Concept
logics. In Lloyd, J. W. (Ed.), Computational Logics, Symposium Proceedings, pp.
177201. Springer-Verlag.
Baader, F., Burckert, H.-J., Nebel, B., Nutt, W., & Smolka, G. (1993). On the expressivity
of feature logics with negation, functional uncertainty, and sort equations. J. of Logic,
Language and Information, 2, 118.
Baader, F., & Hanschke, P. (1991). A schema for integrating concrete domains into concept
languages. In Proc. of the 12th Int. Joint Conf. on Artificial Intelligence (IJCAI91),
pp. 452457.
Baader, F., & Hanschke, P. (1992). Extensions of concept languages for a mechanical engineering application. In Proc. of the 16th German Workshop on Artificial Intelligence
(GWAI92), Vol. 671 of Lecture Notes in Computer Science, pp. 132143, Bonn (Germany). Springer-Verlag.
Baader, F., & Hollunder, B. (1991). A terminological knowledge representation system with
complete inference algorithm. In Proc. of the Workshop on Processing Declarative
Knowledge (PDK91), Vol. 567 of Lecture Notes in Artificial Intelligence, pp. 6786.
Springer-Verlag.
Baader, F., & Sattler, U. (1999). Expressive number restrictions in description logics. J. of
Logic and Computation, 9 (3), 319350.
Ben-Ari, M., Halpern, J. Y., & Pnueli, A. (1982). Deterministic propositional dynamic logic:
Finite models, complexity, and completeness. J. of Computer and System Sciences,
25, 402417.
Berger, R. (1966). The undecidability of the dominoe problem. Mem. Amer. Math. Soc.,
66, 172.
Borgida, A. (1995). Description logics in data management. IEEE Trans. on Knowledge
and Data Engineering, 7 (5), 671682.
Brachman, R. J., McGuinness, D. L., Patel-Schneider, P. F., Alperin Resnick, L., & Borgida,
A. (1991). Living with CLASSIC: When and how to use a KL-ONE-like language. In
54

fiFusions of Description Logics and Abstract Description Systems

Sowa, J. F. (Ed.), Principles of Semantic Networks, pp. 401456. Morgan Kaufmann,
Los Altos.
Brachman, R. J., & Schmolze, J. G. (1985). An overview of the KL-ONE knowledge representation system. Cognitive Science, 9 (2), 171216.
Bresciani, P., Franconi, E., & Tessaris, S. (1995). Implementing and testing expressive description logics: Preliminary report. In Proc. of the 1995 Description Logic Workshop
(DL95), pp. 131139.
Calvanese, D., De Giacomo, G., & Lenzerini, M. (1999). Reasoning in expressive description
logics with fixpoints based on automata on infinite trees. In Proc. of the 16th Int.
Joint Conf. on Artificial Intelligence (IJCAI99), pp. 8489.
Calvanese, D., De Giacomo, G., & Rosati, R. (1998). A note on encoding inverse roles and
functional restrictions in ALC knowledge bases. In Proc. of the 1998 Description Logic
Workshop (DL98), pp. 6971. CEUR Electronic Workshop Proceedings, http://ceurws.org/Vol-11/.
Chellas, B. F. (1980). Modal logic. Cambridge University Press, Cambridge, UK.
Danecki, R. (1984). Nondeterministic Propositional Dynamic Logic with intersection is
decidable. In Proc. of the 5th Symp. on Computation Theory, Vol. 208 of Lecture
Notes in Computer Science, pp. 3453. Springer-Verlag.
De Giacomo, G. (1995). Decidability of Class-Based Knowledge Representation Formalisms.
Ph.D. thesis, Dipartimento di Informatica e Sistemistica, Universita di Roma La
Sapienza.
De Giacomo, G., & Lenzerini, M. (1994a). Boosting the correspondence between description
logics and propositional dynamic logics. In Proc. of the 12th Nat. Conf. on Artificial
Intelligence (AAAI94), pp. 205212. AAAI Press/The MIT Press.
De Giacomo, G., & Lenzerini, M. (1994b). Concept language with number restrictions and
fixpoints, and its relationship with -calculus. In Proc. of the 11th Eur. Conf. on
Artificial Intelligence (ECAI94), pp. 411415.
De Giacomo, G., & Lenzerini, M. (1995). Whats in an aggregate: Foundations for description logics with tuples and sets. In Proc. of the 14th Int. Joint Conf. on Artificial
Intelligence (IJCAI95), pp. 801807.
Donini, F. M., Hollunder, B., Lenzerini, M., Spaccamela, A. M., Nardi, D., & Nutt, W.
(1992). The complexity of existential quantification in concept languages. Artificial
Intelligence, 23, 309327.
Donini, F. M., Lenzerini, M., Nardi, D., & Nutt, W. (1991). Tractable concept languages. In
Proc. of the 12th Int. Joint Conf. on Artificial Intelligence (IJCAI91), pp. 458463,
Sydney (Australia).
Donini, F. M., Lenzerini, M., Nardi, D., & Nutt, W. (1997). The complexity of concept
languages. Information and Computation, 134, 158.
Donini, F. M., Lenzerini, M., Nardi, D., & Schaerf, A. (1994). Deduction in concept languages: From subsumption to instance checking. J. of Logic and Computation, 4 (4),
423452.
55

fiBaader, Lutz, Sturm, & Wolter

Dosen, K. (1988). Duality between modal algebras and neighbourhood frames. Studia
Logica, 48, 219234.
Fine, K., & Schurz, G. (1996). Transfer theorems for stratified modal logics. In Copeland,
J. (Ed.), Logic and Reality: Essays in Pure and Applied Logic. In Memory of Arthur
Prior, pp. 169213. Oxford University Press.
Fischer, M. J., & Ladner, R. E. (1979). Propositional dynamic logic of regular programs.
J. of Computer and System Sciences, 18, 194211.
Gabbay, D. M. (1999). Fibring Logics, Vol. 38 of Oxford Logic Guides. Clarendon Press,
Oxford.
Gargov, G., & Goranko, V. (1993). Modal logic with names. J. of Philosophical Logic, 22,
607636.
Goldblatt, R. I. (1989). Varieties of complex algebras. Annals of Pure and Applied Logic,
38, 173241.
Goranko, V., & Passy, S. (1992). Using the universal modality: Gains and questions. Journal
of Logic and Computation, 2 (1), 530.
Gratzer, G. (1979). Universal Algebra. Springer-Verlag, New York.
Haarslev, V., Moller, R., & Wessel, M. (2001). The description logic ALCN HR+ extended
with concrete domains: A practically motivated approach. In Proceedings of the International Joint Conference on Automated Reasoning IJCAR01, Lecture Notes in
Artificial Intelligence. Springer-Verlag.
Harel, D. (1984). Dynamic logic. In Handbook of Philosophical Logic, Vol. 2, pp. 497640.
D. Reidel, Dordrecht (Holland).
Hollunder, B., & Baader, F. (1991). Qualifying number restrictions in concept languages.
Tech. rep. RR-91-03, Deutsches Forschungszentrum fur Kunstliche Intelligenz (DFKI),
Kaiserslautern (Germany). An abridged version appeared in Proc. of the 2nd Int.
Conf. on the Principles of Knowledge Representation and Reasoning (KR91).
Hollunder, B., & Nutt, W. (1990). Subsumption algorithms for concept languages. Tech. rep.
RR-90-04, Deutsches Forschungszentrum fur Kunstliche Intelligenz (DFKI), Kaiserslautern (Germany).
Horrocks, I. (1998). Using an expressive description logic: FaCT or fiction?. In Proc. of the
6th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR98),
pp. 636647.
Horrocks, I., & Sattler, U. (1999). A description logic with transitive and inverse roles and
role hierarchies. J. of Logic and Computation, 9 (3), 385410.
Horrocks, I., Sattler, U., & Tobies, S. (2000). Practical reasoning for very expressive description logics. J. of the Interest Group in Pure and Applied Logic, 8 (3), 239264.
Jonsson, B., & Tarski, A. (1951). Boolean algebras with operators. I. American Journal of
Mathematics, 73, 891939.
Jonsson, B., & Tarski, A. (1952). Boolean algebras with operators. II. American Journal
of Mathematics, 74, 127162.
56

fiFusions of Description Logics and Abstract Description Systems

Knuth, D. E. (1973). The Art of Computer Programming, Vol. 3. Addison-Wesley, Mass.
Kracht, M., & Wolter, F. (1991). Properties of independently axiomatizable bimodal logics.
The Journal of Symbolic Logic, 56 (4), 14691485.
Kutz, O., Wolter, F., & Zakharyaschev, M. (2001). Connecting abstract description systems.
Submitted. Available from http://www.informatik.uni-leipzig.de/wolter/.
Levesque, H. J., & Brachman, R. J. (1987). Expressiveness and tractability in knowledge
representation and reasoning. Computational Intelligence, 3, 7893.
Lutz, C. (1999). Reasoning with concrete domains. In Dean, T. (Ed.), Proc. of the 16th
Int. Joint Conf. on Artificial Intelligence (IJCAI99), pp. 9095, Stockholm, Sweden.
Morgan Kaufmann, Los Altos.
Lutz, C. (2001). Interval-based temporal reasoning with general TBoxes. In Proc. of the
17th Int. Joint Conf. on Artificial Intelligence (IJCAI 2001), pp. 8994.
Lutz, C., & Sattler, U. (2000). Mary likes all cats. In Proc. of the 2000 Description
Logic Workshop (DL 2000), pp. 213226. CEUR Electronic Workshop Proceedings,
http://ceur-ws.org/Vol-33/.
Nebel, B. (1988). Computational complexity of terminological reasoning in BACK. Artificial
Intelligence, 34 (3), 371383.
Nebel, B. (1990). Terminological reasoning is inherently intractable. Artificial Intelligence,
43, 235249.
Parikh, R. (1980). Propositional logics of programs: Systems, models and complexity. In
Proc. of the 7th ACM SIGACT-SIGPLAN Symp. on Principles of Programming Languages (POPL80), pp. 186192, Las Vegas (USA).
Prior, A. N. (1967). Past, Present and Future. Oxford University Press.
Sattler, U. (1996). A concept language extended with different kinds of transitive roles. In
Gorz, G., & Holldobler, S. (Eds.), Proc. of the 20th German Annual Conf. on Artificial
Intelligence (KI96), No. 1137 in Lecture Notes in Artificial Intelligence, pp. 333345.
Springer-Verlag.
Schaerf, A. (1993). On the complexity of the instance checking problem in concept languages
with existential quantification. J. of Intelligent Information Systems, 2, 265278.
Schaerf, A. (1994). Reasoning with individuals in concept languages. Data and Knowledge
Engineering, 13 (2), 141176.
Schild, K. (1991). A correspondence theory for terminological logics: Preliminary report. In
Proc. of the 12th Int. Joint Conf. on Artificial Intelligence (IJCAI91), pp. 466471.
Schmidt-Schau, M. (1989). Subsumption in KL-ONE is undecidable. In Brachman, R. J.,
Levesque, H. J., & Reiter, R. (Eds.), Proc. of the 1st Int. Conf. on the Principles of
Knowledge Representation and Reasoning (KR89), pp. 421431. Morgan Kaufmann,
Los Altos.
Schmidt-Schau, M., & Smolka, G. (1991). Attributive concept descriptions with complements. Artificial Intelligence, 48 (1), 126.
57

fiBaader, Lutz, Sturm, & Wolter

Spaan, E. (1993). Complexity of Modal Logics. Ph.D. thesis, Department of Mathematics
and Computer Science, University of Amsterdam, The Netherlands.
Van der Hoek, W., & de Rijke, M. (1995). Counting objects. J. of Logic and Computation,
5 (3), 325345.
Wolter, F. (1998). Fusions of modal logics revisited. In Kracht, M., de Rijke, M., Wansing, H., & Zakharyaschev, M. (Eds.), Advances in Modal Logic, pp. 361379. CSLI
Publications.
Woods, W. A., & Schmolze, J. G. (1992). The KL-ONE family. In Lehmann, F. W. (Ed.),
Semantic Networks in Artificial Intelligence, pp. 133178. Pergamon Press. Published
as a special issue of Computers & Mathematics with Applications, Volume 23, Number
29.

58

fi