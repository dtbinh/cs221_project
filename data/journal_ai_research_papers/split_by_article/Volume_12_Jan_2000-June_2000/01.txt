Journal of Artificial Intelligence Research 12 (2000) 35-86

Submitted 5/99; published 2/00

Reasoning on Interval and Point-based
Disjunctive Metric Constraints in Temporal Contexts
Federico Barber

FBARBER@DSIC.UPV.ES

Dpto. de Sistemas Informticos y Computacin
Universidad Politcnica de Valencia
Camino de Vera s/n, 46022 Valencia, Spain

Abstract
We introduce a temporal model for reasoning on disjunctive metric constraints on intervals and
time points in temporal contexts. This temporal model is composed of a labeled temporal algebra
and its reasoning algorithms. The labeled temporal algebra defines labeled disjunctive metric pointbased constraints, where each disjunct in each input disjunctive constraint is univocally associated
to a label. Reasoning algorithms manage labeled constraints, associated label lists, and sets of
mutually inconsistent disjuncts. These algorithms guarantee consistency and obtain a minimal
network. Additionally, constraints can be organized in a hierarchy of alternative temporal contexts.
Therefore, we can reason on context-dependent disjunctive metric constraints on intervals and
points. Moreover, the model is able to represent non-binary constraints, such that logical
dependencies on disjuncts in constraints can be handled. The computational cost of reasoning
algorithms is exponential in accordance with the underlying problem complexity, although some
improvements are proposed.

1. Introduction
Two main lines of research are commonly recognized in the temporal reasoning area. The first
approach deals with reasoning about temporal constraints on time-dependent entities. The goal is to
determine what consequences (T) follow from a set of temporal constraints, "{TemporalConstraints}|=T?", or to determine whether a set of temporal constraints is consistent, with no
assumptions about properties of temporal facts. The second approach deals with reasoning about
change, events, actions and causality. Here, the goal is to obtain the consequent state from a set of
actions or events which are performed on an initial state: "[Si, {A1, A2, ..., An }]|= Sj?". Both these
approaches constitute active fields of research with applications in several artificial intelligence areas
such as reasoning about change, scheduling, temporal planning, knowledge-based systems, natural
language understanding, etc. In these areas, time plays a crucial role, problems have a dynamic
behavior, and it is necessary to represent and reason about the temporal dimension of information.
In this paper, we deal with the first of these approaches. Our goal is reasoning on qualitative and
quantitative constraints between intervals or time-points in temporal contexts. Moreover, special
cases of non-binary constraints are also managed. These tasks are pending issues in the temporal
reasoning area, as well as important features to facilitate modeling of relevant problems in this area
(including planning, scheduling, causal or hypothetical reasoning, etc.).
Several temporal reasoning models have been defined in the literature, with a clear trade-off
between representation expressiveness and complexity of reasoning algorithms. Qualitative Point
Algebra (PA) (Vilain, Kautz & Van Beek, 1986) is a limited subset of interval-based models. Interval

 2000 AI Access Foundation and Morgan Kaufmann Publishers. All rights reserved.

fiREASONING ON INTERVAL AND POINT -BASED DISJUNCTIVE M ETRIC CONSTRAINTS IN TEMPORAL CONTEXTS

Algebra (IA) introduced by Allen (1983) represents symbolic (qualitative) constraints between
intervals but metric information, such as 'interval1 starts 2 seconds before interval2 ', cannot be
included. Metric (quantitative) point-based models (Dechter, Meiri & Pearl, 1991) include the 'time
line' (metric) in their constraints, but they can only represent a limited subset of disjunctive
constraints between intervals. Thus, constraints like 'interval1 {bef, aft} interval2 ' cannot be
represented (Gerevini & Schubert, 1995).
Some efforts have been made to integrate qualitative and quantitative temporal information on
points and intervals (Kautz & Ladkin, 1991; Drakengren & Jonsson, 1997; etc.). Particularly, Meiri
(1996) introduces Qualitative Algebra (QA), where each interval is represented by three nodes (one
representing the interval and the other two representing its extreme points) such that QA can
represent qualitative and metric constraints on points and intervals. Badaloni and Berati (1996) define
the Interval Distance Sub Algebra (IDSA), where nodes are intervals. These intervals are related by
disjunctive 4-tuple-metric constraints between their ending time points {(I-i, I-j ), (I+i , I-j ), (I-i , I+j ), (I+i ,
I+j )}. Staab and Hahn (1998) propose a model for reasoning on qualitative and metric boundaries of
intervals. However, these models cannot handle constraints on interval durations, which were
identified earlier by Allen (1983). Constraints such as 'interval1 lasts 2 seconds more than interval2'
require a high-order expression (Dechter et al., 1991), or a duration primitive which should be
integrated with interval and point constraints (Allen, 1983; Barber, 1993). Particularly, Barber (1993)
proposes two orthogonal networks to relate constraints on durations and time points. Navarrete
(1997) and Wetprasit and Sattar (1998) relate disjunctive constraints on durations and time points,
but only a limited subset of interval constraints is managed. More recently, Pujari and Sattar (1999)
propose a framework for reasoning on points, intervals and durations (PIDN). Here, variables
represent points or intervals, and constraints are an ordered set of three intervals representing (Start,
End, Duration) subdomains. However, no specialized algorithms for management of PIDN
constraints are proposed.
In relation to the complexity of reasoning algorithms, the consistency problem is polynomial in
PA (Vilain, Kautz & Van Beek, 1986) and in non-disjunctive metric networks (Dechter et al., 1991).
However, Vilain, Kautz and Van Beek (1986) also showed that determining the consistency of a
general-case temporal network (i.e.: disjunctive qualitative and metric constraints between points,
intervals or durations) is NP-hard. Thus, in previous qualitative or quantitative models, the
consistency problem is tractable only under some properties on constraints, relationships between
variable domains and constraints, or by using restricted subsets of constraints (Dechter et al., 1991;
Dechter, 1992; van Beek & Detcher, 1995; Wetprasit & Sattar, 1998; Jeavons et al., 1998; etc.). For
instance, tractable subclasses of IA have been identified by Vilain, Kautz and Van Beek (1986),
Nebel and Burckert (1995), Drakengren and Jonsson (1997), etc. Moreover, some interesting results
have been obtained in identification of tractable subclasses of QA. Specifically, Jonsson et al. (1999)
identified the five maximal tractable subclasses of the qualitative point-interval algebra. However,
to my knowledge the maximal tractable subclass of PIDN model (maximal tractable subclass of
qualitative and quantitative point, interval and duration constraints) is still not identified. In any case,
these restricted tractable subclasses are not able to obtain expressiveness of full models, and the
problem of reasoning on disjunctive constraints on points and intervals remains NP-complete.
On the other hand, these qualitative and metric temporal models do not manage certain types of
non-binary constraints, which are important for modeling some problems (scheduling, causal
reasoning, etc.). For instance, disjunctive assertions like (interval1 {bef, meets} interval2 )  (time36

fiBARBER

point3 is [10 20] from time-point4 ), or temporal-causal relations like If (interval1 {bef, meets}
interval2 ) then (time-point3 is [10 20] from time-point4 ) should be incorporated in these models
(Meiri, 1996). Moreover, the global consistency property introduced by Dechter (1992) is an
important property in temporal networks, since it allows us to obtain solutions by backtrack-free
search (Dechter, 1992; Freuder, 1982). In particular, a global consistent network would allow us to
handle conjunctive queries like does (interval1 {bef, meets} interval2 )  (time-point3 is [10 20] from
time-point4 ) hold? without propagation of the query, as it is required in (van Beek, 1991).
Stergiou and Koubarakis (1996), Jonsson and Bckstrm (1996) dealt with the representation of
temporal constraints by means of disjunctions of linear constraints (linear inequalities and
inequations) also named Disjunctive Linear Relations (DLRs). These expressions are a unifying
approach to manage disjunctive constraints on points, intervals and durations, such that these
expressions subsume most of the formalism for temporal constraint reasoning (Jonsson & Bckstrm,
1998). Moreover, DLRs are able to represent disjunctions of non-disjunctive metric constraints (x1 y1 c1  x2 -y2 c2  .... xn -yn cn ), where xi and yi are time points, ci real numbers and n1 (Stergiou
& Koubarakis, 1998). Obviously, the satisfiability problem for an arbitrary set of disjunctions of
linear constraints is NP-complete. Interesting tractable subclasses of DLRs and conditions on
tractability are identified in (Cohen et al., 1996; Jonsson & Bckstrm, 1996; and Stergiou &
Koubarakis, 1996). The two main tractable subclasses are Horn linear and Ord-Horn linear
constraints (Stergiou & Koubarakis, 1996; Jonsson & Bckstrm, 1998). However, these subclasses
subsume temporal algebras whose management is also polynomial.
The management of a set of disjunctions of linear constraints is mainly based on general methods
from linear programming, although some specific methods have been defined for tractable subclasses
(Stergiou & Koubarakis, 1998; Cohen et al., 1996; etc.). As Pujari and Sattar outline (1999), the
linear programming approach, though expressive, does not take advantage of the underlying
structures (e.g., domain constraints) of temporal constraints. In addition, usual concepts in temporal
reasoning, as composition and intersection operations on constraints, minimal constraints, kconsistency (Freuder, 1982), decomposability (Montanari , 1974), globally consistency (Dechter,
1992), etc., and their consequences should be adapted to reasoning on disjunctive linear constraints,
which is not a trivial issue.
In spite of the expressive power of the previous models, some problems (including planning,
scheduling, hypothetical reasoning, etc.) also need to reason on alternative contexts (situations,
intentions or causal projections) and to know what holds in each one of them (Dousson et al., 1993;
Gerevini & Schubert, 1995; Garcia & Laborie, 1996; Srivastava & Kambhampati, 1999). This gives
rise to the need to reason on context-dependent constraints. This feature is not supported in the usual
temporal models in a general way, nor described in the usual expressive power of constraints
(Jeavons et al., 1999). Therefore, ad-hoc methods should be used when reasoning on temporal
contexts is required.
These issues will be addressed in this paper. We describe a temporal model, which integrates
qualitative and metric disjunctive constraints on time-points and intervals. The temporal model is
based on time-points as primitive, such that intervals are represented by means of their end timepoints. However, the representation of interval constraints seems to imply some kind of relation
among endpoint constraints (Gerevini & Schubert, 1995). The proposed temporal model introduces
labeled constraints, where each elemental constraint (disjunct) in a disjunctive point-based metric
constraint is associated to one unique label. In this way, point-based constraints can be related among
37

fiREASONING ON INTERVAL AND POINT -BASED DISJUNCTIVE M ETRIC CONSTRAINTS IN TEMPORAL CONTEXTS

them without using hyper-arcs. Therefore, metric and symbolic constraints among intervals and timepoints can be fully integrated, represented and managed by means of a labeled metric point-based
Temporal Constraint Network (TCN). Particularly, the model proposed here handles constraints
proposed in QA (Meiri, 1996), IDSA (Badaloni & Berati, 1996), and Distance Constraint Arrays
model (Staab & Hahn, 1998). Moreover, several added functionalities are also provided:
 Management of alternative temporal contexts. Each input constraint can be associated to a
given context. A hierarchy of alternative temporal contexts can be defined, such that
constraints between points and intervals are dependent on each context. To my knowledge,
these features improve existing temporal models, where contexts are not managed.
 Reasoning algorithms on labeled constraints are based on a closure process. These processes
guarantee consistency and obtain a minimal disjunctive context-dependent TCN. Additionally,
a special type of globally labeled-consistent TCN is obtained. This property allows us to obtain
solutions by backtrack-free search (Freuder, 1982).
 Management of a special type of non-binary constraints. Reasoning algorithms are able to
manage disjunctions of disjunctive constraints. This supposes an extension of disjunctions of
non-disjunctive metric constraints proposed by Stergiou and Koubarakis (1998). Moreover,
given a set of disjunctive constraints, the model can handle logical relations among
disjunctions of different constraints. Thus, we can express that a set of atomic disjuncts in
disjunctive constraints are mutually disjunctive among them. Therefore, a special type of
and/or TCN can be managed as a conjunctive (and) TCN. Likewise, the model can also handle
special non-binary constraints representing implications among temporal constraints as were
identified by Meiri (1996).
With these features, the proposed temporal model is suitable for modeling problems where these
requirements appear. The computational cost of reasoning methods is non-polynomial, given the
complexity of the underlying problem. However, several improvements are also proposed.
A brief revision of the main temporal reasoning concepts is presented in Section 2. In Section 3,
a temporal algebra for labeled point-based disjunctive metric constraints is described. This temporal
algebra introduces the concept of labeled constraints and their temporal operations. Reasoning
algorithms for guaranteeing a minimal (and consistent) TCN are specified in Section 4. By using this
model, the integration of interval and point-based constraints and management of non-binary
constraints are respectively described in Sections 5 and 6. Association of constraints to temporal
contexts and management of context-dependent constraints are detailed in Section 7. Finally, Section
8 concludes.

2. Basic Temporal Concepts
Temporal reasoning deals with reasoning on temporal constraints. The syntax and semantics of
constraints are defined by an underlying temporal algebra, which is the basis for performing the
reasoning processes. A temporal algebra can be defined according to the following elements:
 Temporal primitive (or variable) 'x i ', usually time-points (ti ) or intervals (Ii ).
 Interpretation domain D for primitives xi . The interpretation domain represents the time line.
38

fiBARBER

Time points are instantiated on D (ti D), and temporal intervals can be modelled as pairs of
ending time points that can be instantiated on D: Ii = (Ii -, Ii +), Ii DxD, Ii -Ii +.
 Temporal constraints between primitives, where each constraint relates n primitives: c1,2..n (x1 ,
x2 , ..., xn ). As particular cases, the 'empty constraint' {} is named the Inconsistent-Constraint
and 'U' is the Universal-Constraint. Unary-constraints restrict the interpretation domain D for
variables. They are not usually used in symbolic algebras, where an infinite domain is
assumed. Binary-constraints are temporal constraints between two variables (xi cij xj ), and nary-constraints represent temporal constraints among n variables. By default, binary constraints
are assumed in this paper. We can also have qualitative (relative relation) or quantitative
(metric relation) constraints, as well as disjunctive (cij is a set of disjunctive basic constraints,
|cij |1) or non-disjunctive constraints.
 Operations between constraints. Mainly, Temporal Composition (), Temporal Intersection
(), Temporal Union (), and Temporal Inclusion ().
A temporal problem is specified by a set of n variables X= {xi }, an interpretation domain D and
a finite set of temporal constraints between variables {(xi cij xj )}. A temporal problem gives rise to
a Temporal Constraint Network (TCN) which can be represented as a directed graph where nodes
represent temporal primitives (xi ) and labeled-directed edges represent the binary constraints between
them (cij). The Universal Constraint U is not usually represented in the graph, and each direct edge
(representing cij ) between xi and xj implies an inverse one (representing cji ) between xj and xi .
According to the underlying Temporal Algebra, we mainly have IA-TCNs based on the Interval
Algebra (Allen, 1983), PA-TCNs based on the Point Algebra (Vilain et al., 1986), or Metric-TCNs
based on the Metric Point Algebra (Dechter et al., 1991; Dean & McDermott, 1987). In this later
case, disjunctive metric point-based constraints give rise to a Temporal Constraint Satisfaction
Problem (TCSP) (Dechter et al., 1991).
Reasoning on temporal constraints can be seen as a Constraint Satisfaction Problem (CSP). An
instantiation of the variables X is a n-tuple (v1 , v2 , v3 , ...,vn ) / vi D which represents the assignments
of values {vi } to variables {x i }: (x1 =v1 , x2 =v2 , ...,xn =vn). A (global) solution of a TCN is a consistent
instantiation of the variables X in their domains such that all TCN constraints are satisfied. A value
v is a consistent (or feasible) value for xi if there exists a TCN solution in which xi =v. The set of all
feasible values of a variable xi is the minimal domain for the variable. A constraint (xi cij xj ) is
consistent if there exists a solution in which (xi cij xj ) holds. A constraint cij is minimal iff it consists
only of consistent elements (or feasible values) that is, those which are satisfied by some
interpretation of TCN constraints. A TCN is minimal iff all its constraints are minimal.
A TCN is consistent (or satisfiable ) iff it has at least one solution. Freuder (1982) generalizes the
notion of consistency as: 'a network is k-consistent iff (given any instantiation of any k-1 variables
satisfying all the direct constraints among those variables) there exists at least one instantiation of any
kth variable such that the k values taken together satisfy all the constraints among the k variables'. As
consequences: (i) all (k-1)-length paths in the network are consistent, (ii) for each pair or nodes, there
exists an interpretation that satisfies each (k-1)-length path between them, and (iii) each sub-TCN of
k-nodes is consistent. As particular cases, 1-consistency, 2-consistency and 3-consistency are called
node-consistency, arc-consistency and path-consistency, respectively (Mackworth, 1977; Montanari,
1974).
39

fiREASONING ON INTERVAL AND POINT -BASED DISJUNCTIVE M ETRIC CONSTRAINTS IN TEMPORAL CONTEXTS

Path-consistency is a common concept in constraint networks. From Montanari (1974) and
Mackworth (1977), a path of k-length through nodes (x1 , x2 , ..., xk , xj ) is path-consistent iff for any
value v1 d1 and vj dj such that (x1=v1 c1j xj=vj ) holds, there exists a sequence of values v2 d2 , v3d3 ,
..., vk dk such that (v1 cl2 v2 ), (v2 c23 v3 ),...., and (vk ck,j vj ) hold. A TCN is path-consistent iff all its
paths are consistent. Moreover, Montanari (1974) proves that to ensure path-consistency it suffices
to check every 2-length path. Thus, path-consistency and 3-consistency are equivalent concepts.
Alternatively, Meiri (1996) outlines a path of k-length (xi , x1 , x2 , ...,xk , xj ) is path-consistent iff cij 
(ci1  c12  ...  ckj ). However, this definition disregards domain constraints, such that it is equivalent
to the former definition if variable domains are infinite or the TCN is also node and arc-consistent,
as the usual case in symbolic algebras. In metric algebras, path-consistency usually assumes node and
arc-consistency. Therefore, taking into account that it is only necessary to test 2-length paths to
assure path-consistency, a TCN is path-consistent iff cij ,cik ,ckjTCN, cij  (cik  ckj ). This
condition gives rise to the more usual path-consistent algorithm: the Transitive Closure Algorithm
(TCA) which imposes local 3-consistency in each sub-TCN of 3 nodes, such that all 2-length paths
become consistent paths (Mackworth, 1977; Montanari , 1974). The TCA algorithm will obtain an
equivalent path-consistent TCN if it exists. Otherwise, it fails.
cij ,cik ,ckj TCN: cij cij  (cik  ckj )
A network is strong k-consistent iff the network is j-consistent for all jk (Freuder, 1982). An nconsistent TCN is a consistent TCN, and a strong n-consistent TCN is a minimal TCN. Alternatively,
Dechter (1992) introduces the concepts of local and global consistency: A partial instantiation of
variables (x1 =v1 , x2 =v2 , ...,xk =vk ) / 1k<n is locally consistent if it satisfies all the constraints among
these variables. A subTCN is globally consistent if any locally consistent instantiation of the
variables in the subTCN can be extended to a consistent instantiation of all TCN. A globally
consistent TCN is one in which all its subTCNs are globally consistent. Thus, a TCN is strong nconsistent iff it is globally consistent (Dechter, 1992).
The first reasoning task on a TCN is to determine whether the TCN is consistent. If the TCN is
consistent, we can then obtain the minimal-TCN, all TCN solutions (by assuming a discrete and finite
model of time), only one solution, a partial solution (consistent instantiation of a subset of TCN
variables, which is a part of a global solution), etc.
Deductive closure, or propagation, is one of the basic reasoning algorithms. The closure process
is a deductive process on a TCN, where new derived constraints are deduced from the explicitly
asserted ones by means of the composition () and intersection () operations. Thus, the process of
determining the consistency and the minimality of a TCN is related to a sound and complete closure
process (Vilain et al., 1986). Alternatively, CSP-based methods (with several heuristic search criteria)
are also used for guaranteeing consistency and obtaining TCN solutions. In this paper, we are mainly
interested in TCN closure processes.
Determining the consistency of a general-case TCN is NP-hard, and Minimal TCNs can be
obtained by a polynomial number of consistency processes (Vilain et al., 1986). Particularly, Dechter,
Meiri and Pearl (1991) showed that determining consistency and obtaining a minimal disjunctive
metric TCN can be achieved in O(n3 le), where n is the number of TCN nodes, e is the number of
explicitly asserted (input) constraints, and l is the maximum number of intervals in an input
constraint. However, specific levels of k-consistency can guarantee consistency and obtain a minimal
TCN, depending on the TCN topology or the underlying temporal algebra. For example, path40

fiBARBER

consistency guarantees consistency and obtains a minimal non-disjunctive metric TCN (Dechter et
al., 1991). The path-consistency TCA Algorithm has an O(n3) cost (Allen, 1983; Vilain, Kautz & Van
Beek, 1986). However, assuring path-consistency can become a complex task in disjunctive metricTCNs if the variable domain D is large or continuous. As was stated by Dechter, Meiri and Pearl
(1991), the number of intervals in |cij  cjk | is upper bounded by |cij |x|cjk |. Thus, the total number of
disjuncts (subintervals) in a path-consistent TCN might be exponential in the number of disjuncts per
constraints in the initial (input) TCN. Schwalb and Dechter (1997) call this the fragmentation
problem, which does not appear in non-disjunctive metric TCNs. Thus, the TCA algorithm is O(n3
R3 ) in disjunctive metric-TCNs if time is not dense (Dechter et al., 1991), where the range R is the
maximum difference between the lowest and highest number specified in any input constraints.

3. A Labeled Temporal Algebra
The main elements of the point-based disjunctive metric temporal algebra are (Dechter et al., 1991):
 Time-point (ti ) as primitive variable. A continuous variable domain (like Q or ) is usually
assumed.
 Each temporal constraint cij U is a finite set of l mutually exclusive subdomains (or
subintervals) of D.
cij {[d-1 d+1 ], [d-2 d+2 ], ...., [d-k d+k ], ....., [d-l d+l ]} ,

where d-k d+k and d-k ,d+k D,

and disjunctively restricts the temporal distance between two time-points, ti and tj :
tj - ti  {[d-1 d+1 ], [d-2 d+2 ], ....., [d-l d+l ]},
meaning that (d-1 tj -ti  d+1 )  ....  (d-l  tj -ti d+l ). Similar conditions can be applied to open
(d-k d+k ) and semi-open intervals (d-k d+k ], [d-k d+k ). The Universal-Constraint U is {(- +)}.
Unary constraints restrict the associated subdomain of a time-point ti {[d-1 d+1 ], [d-2 d+2], .....,
[d-l d+l ]}. A special time-point T0 is usually included, which represents 'the beginning of the
world' (usually, T0 =0). Thus, each unary constraint on ti can be represented as a binary one
between ti and T0 :
ti - T0  {[d-1 d+1 ], [d-2 d+2 ], ..... ,[d-l d+l ]}  ti[d-1 , d+1 ]  ti [d-2 , d+2 ] , ...,  ti[d-l , d+l ]
and, by default: ti , (T0 {[0 )} ti ).
 The algebra operations, mainly , ,  and . From (Meiri, 1996), given two temporal
constraints S={[dS-i , dS+i ]} and T={[dT-j , dT +j ]},
S  T = {dk / diS  djT / dk = di +dj }.
That is, [dS-i , dS+i ]S, [dT-j , dT +j ]T, T{[dS-i +d T-j , dS+i +d T+j ]}. Here, resulting subdomains
in S  T may not be pairwise disjoint. Therefore, some additional processing may be required
to compute a disjoint subdomain set.
S  T = {dk / dkS  dkT}. That is, the set-intersection of their subdomains.
S  T = {dk / dkS  dk T}, as the set-union of their subdomains.
ST = iff dk S, dk T.
41

fiREASONING ON INTERVAL AND POINT -BASED DISJUNCTIVE M ETRIC CONSTRAINTS IN TEMPORAL CONTEXTS

On the basis of the point-based disjunctive metric temporal algebra and its operations, we
introduce a labeled point-based disjunctive metric temporal algebra, which gives rise to a labeledTCN.
3.1 Labeled Constraints and Inconsistent Label Sets
An elemental constraint (ec) is one disjunct in a disjunctive constraint. Similar terms are atomic,
basic or canonical constraints. However, lets use this term due to the special structure of labeled
elemental constraints which are introduced further on. Thus, a disjunctive constraint cij can be
considered as a disjunctive set of l mutually exclusive elemental constraints {ecij.k }.
ecij.k = [d-ij.k d+ij.k ] / i,j,k d-ij.k d+ij.k
cij {ec ij.1 , ec ij.2 , ..., ec ij.l }  U / k,p(1,..,l), kp, (ecij.k  ec ij.p )=
Definition 1 (Labeled constraints). A labeled elemental constraint lecij.k is an elemental constraint
ecij.k associated to a set of labels {labelij.k}, where each labelij.k is a symbol. A labeled constrain t lc ij
is a disjunctive set of labeled elemental constraints {lecij.k }. That is,
lc ij  {lecij.1 , lecij.2 , ..., lecij.l }, where
lecij.k  (ec ij.k {labelij.k }), and {labelij.k }{label1 , label2 , ..., labels } is a set of symbols.

Each label in a labeled-TCN can be considered as a unique symbol. The following cases can
occur:
i)

If an input (or explicitly asserted) constraint lc ij has only one elemental constraint, that is,
only one disjunct, this elemental constraint has the label 'R0 '. The labeled UniversalConstraint is {U{R0}}. In a given TCN, the set of all elemental constraints labeled with 'R0 '
is the common context. Thus, the label R0 represents the set of elemental constraints which
have no other alternatives (disjuncts). All elemental constraints labeled only with R0 should
hold since they have no other alternative disjuncts.

ii)

If an input constraint lc ij has more than one elemental constraint, each elemental constraint
lecij.k lc ij has a single and exclusive label associated to it (|{labelij.k }|=1). Thus, each label
in the TCN represents bi-univocally an elemental constraint in an explicitly asserted
constraint.

iii) Each derived elemental constraint (obtained by combining (lc) or intersecting ( lc) two
labeled elemental constraints) has a set of labels associated to it. This set of labels is obtained
from the label sets associated to the combined (or intersected) labeled elemental constraints.
It will be detailed in the later specification of operations (lc,  lc) in Section 3.2. In
consequence, the label set associated to a derived elemental constraint represents the
conjunctive support-set of explicitly asserted elemental constraints that imply this derived
elemental constraint.
Let's see a simple example on labeled constraints, which was introduced by Dechter, Meiri and
Pearl (1991).

42

fiBARBER

{([60 70]{R0})}

t4
{([40 50]{R3}) ([20 30]{R4})}

{([10 20]{R0})}

t3

T0
t2

{([60 ){R1}) ([30 40]{R2})}

T0

{([10 20]{R0} )}

t1

Figure 1: The labeled point-based disjunctive metric TCN of the Example 1

Example 1: "John goes to work either by car [30'-40'], or by bus (at least 60'). Fred goes to work
either by car [20'-30'], or in a carpool [40'-50']. Today John left home (t1) between
7:10 and 7:20, and Fred arrived (t4) at work between 8:00 and 8:10. We also know
that John arrived (t2) at work about 10'-20' after Fred left home (t3)."
In this example, we have the disjunctive labeled constraints in Figure 1, where T0 represents the
initial time (7:00) and where the granularity is in minutes. A label 'R0 ' is associated to elemental
constraints belonging to constraints with only one disjunct. In constraints with more than one,
mutually exclusive disjuncts, each disjunct is labeled with an exclusive label Rn (n>0). Thus,
 The label R0 is associated to "John left home between 7:10 and 7:20", "Fred arrived at work
between 8:00 and 8:10", and "John arrived at work about 10'-20' after Fred left home". This
is the common context.
 The label R1 is associated to "John goes by bus", and R2 to "John goes by car".
 The label R3 is associated to "Fred goes in a carpool", and R4 to "Fred goes by car".
Definition 2 (Inconsistent-Label-Sets). An Inconsistent-Label-Set (I-L-Set) is a set of labels {labeli }
and represents a set of overall inconsistent elemental constraints. That is, they cannot all
simultaneously hold. 
Theorem 1. Any label set that is a superset of an I-L-Set is also an I-L-Set. The proof is obvious. If
a set of elemental constraints is inconsistent, any superset of it is also inconsistent. 
Definition 3. Elemental constraints {lecij.k} of an input disjunctive constraint lc ij are pairwise disjoint.
Thus, each 2-length set of labels from each pair of {lecij.k } is added to the set of I-L-Sets. That is, for
each input constraint lc ij  {lecij.1 , lecij.2 , ..., lecij.l }, where lecij.k (ecij.k {labelij.k }) and |{labelij.k }|=1:
k,p(1,..,l) / kp, I-L-Sets  I-L-Sets  ({labelij.k }{labelij.p }) 
In the example of Figure 1, {R1 R2 } and {R3 R4 } are I-L-Sets. Other I-L-Sets existing in a labeled
TCN will be detected in the reasoning processes later detailed in Section 4.

43

fiREASONING ON INTERVAL AND POINT -BASED DISJUNCTIVE M ETRIC CONSTRAINTS IN TEMPORAL CONTEXTS

3.2 Operations on Labeled Constraints
The following points define the main operations on labeled constraints.
3.2.1 TEMPORAL INCLUSION LC
The temporal inclusion operation lc should take into account the inclusion of temporal intervals and
the inclusion of associated label sets:
lecij.k lc lecij.p = (ecij.k {labelij.k }) lc (ecij.p {labelij.p }) =def ecij.k T ecij.p  {labelij.k } {labelij.p }.
3.2.2 TEMPORAL UNION LC
Operation lc performs the disjunctive temporal union of labeled constraints as the set-union of their
elemental constraints. However, all labeled elemental constraints whose associated labels are I-L-Sets
should be rejected.
lc ij lc lcij =def lecij.k lc ij , lc [{lecij.k } lcij] , where
lc [{lecij.k } lcij ] = (ec ij.k {labelij.k }) lc lcij =def
Inconsistent({labelij.k }) : lcij
lecij.p lcij / lecij.p lc lecij.k : lcij
Other : ({lcij }  {lecij.k }) - ({lecij.p }, lecij.plcij  lecij.k lclecij.p )

(s1 )
(s2 ).

The function Inconsistent({labelij.k}) returns true if the set {labelij.k } is an I-L-Set or a superset of
any existing I-L-Set (Theorem 1). Otherwise, it returns false:
Inconsistent({labelij.k }) =def
If {labels }Inconsistent-Label-Sets / {labels }{labelij.k } Then True Else False.
The operation lc simplifies the resulting constraint. Equal or less-restricted elemental constraints
with equal or bigger associated label sets are removed. For instance:
{([10 30] {R1 R3 R5 R9}), ([40 40] {R6 R7})} lc {([10 20] {R1 R3}), ([40 40] {R6 R7 R8})} =
{([10 20] {R1 R3}), ([40 40] {R6 R7})}.
In the resulting constraint, ([10 30] {R1 R3 R5 R9}) and ([40 40] {R6 R7 R8}) are eliminated, as examples
of the cases s1 and s2 , respectively. That is, ([10 20] {R1 R3}) lc ([10 30]{R1 R3 R5 R9}) and ([40 40] {R6 R7})
lc ([40 40] {R6 R7 R8}). These simplifications can seem counter-intuitive. However, note that the label
set associated to each derived-labeled elemental constraint represents the support set (composed of
input elemental constraints) from which the derived-labeled elemental constraint is obtained. Thus,
only the minimal associated label set should be represented, for reason of efficiency. Moreover, the
more labels are in the associated label set {labelij.k }, the elemental constraint (ecij.k ) should be equal
or more restricted.
3.2.3 TEMPORAL COMPOSITION LC
Operation lc performs the temporal composition of labeled constraints. It is based in the operation
 of the underlying disjunctive metric point-based algebra.
44

fiBARBER

lc ij lc lc jk =def lecij.plc ij , lecjk.q lc jk lc [ (ecij.p  ecjk.q {labelij.p }{labeljk.q })].
For instance: {([0 10] {R1}), ([20 30] {R2})} lc {([100 200] {R3}), ([300 400] {R4})} =
{([320 430] {R4 R2}), ([300 410] {R4 R1}), ([100 210] {R3 R1}), ([120 230] {R3 R2})}.
Note that elemental constraints in a labeled derived constraint may not be pairwise disjoint.
However, these labeled derived elemental constraints cannot be simplified. This is related to the
fragmentation problem of the disjunctive metric algebra (Schwalb & Dechter, 1997). We have that
each derived-labeled elemental constraint should have its own associated label set. In the example,
(([320 430] {R4 R2}), ([300 410] {R4 R1})) cannot be simplified to ([300 430] {R4 R2 R1}) since each
subinterval depends on a different set of labels (that is, on a different support-set of elemental
constraints). If the label set {R4 R2 } becomes an I-L-Set, only ([320 430] {R4 R2}) should be removed.
On the other hand, if [300 410] becomes an inconsistent interval between the implied time points,
only {R4 R1 } should be asserted as an I-L-Set.
3.2.4 TEMPORAL INTERSECTION  LC
Operation  lc performs the temporal intersection of labeled constraints and is based on the operation
.
lc ij lc lcij =def lecij.k lc ij , lecij.p lcij , lc [lecij.k  lc lecij.p ]
where, lecij.k  lc lecij.p =def
If ec ij.k  ecij.p =  Then {}
;The Inconsistent-Constraint is returned.
Else [(ecij.k  ecij.p ) ({labelij.k }{labelij.p })]
As example:
{([0 10] {R1}), ([20 25] {R2})}  lc {([0 30] {R3}), ([40 50] {R4})} = {([20 25] {R3 R2}), ([0 10] {R3 R1})}
In the operations lc and  lc, the label set {labelij.r} associated to each derived labeled-elemental
constraint (ecij.r) is obtained from the set-union of labels associated to combined (lc) or intersected
( lc) labeled-elemental constraints. Therefore, {labelij.r} represents the support set (composed of input
elemental constraints) that implies the derived elemental constraint (ecij.r).
Definition 4. A set of I-L-Sets is complete if it represents all inconsistent sets of TCN elemental
constraints. A set of I-L-Sets is sound if each I-L-Set represents an inconsistent set of elemental
constraints. 
Theorem 2. Assuming a complete and sound set of I-L-Sets, a labeled elemental constraint is
consistent iff it has an associated label set which is not an I-L-Set. The proof is trivial, since the label
set associated to each labeled elemental constraint represents its support-set. 
Theorem 3. Assuming a complete and sound set of I-L-Sets, no inconsistent labeled elemental
constraint is obtained in operations lc and lc.
Proof: The operations lc and lc use the operation lc to obtain their results. This operation lc
rejects all labeled elemental constraints whose associated labels are I-L-Sets. Thus, all elemental
constraints derived in operations lc and  lc are consistent (Theorem 2). 
45

fiREASONING ON INTERVAL AND POINT -BASED DISJUNCTIVE M ETRIC CONSTRAINTS IN TEMPORAL CONTEXTS

3.3 Distributive Property  lc Over  lc in Disjunctive Labeled Constraints
Operations  and  are distributive (i.e.:  distributes over ) in non-disjunctive metric TCN, but
this property does not hold in disjunctive metric constraints. Dechter, Meiri and Pearl (1991) show
the following example. Given the disjunctive metric constraints:
a= {[0 1], [10 20]},
we have:

b= {[25 50]},

c= {[0 30], [40 50]},

(a  (b  c) = {[25 31], [35 70]}

(a  b)  (a  c) = {[25 70]}.

Thus, clearly (a  (b  c)  (a  b)  (a  c). However, the distributive property holds for
operations lc and  lc in labeled TCN.
Theorem 4. By using labeled constraints and I-L-Sets, lc distributes over lc.
Proof: Lets consider the labeled constraints lc i , lc j and lc k . Thus,
(lc i lc lc j )  lc (lc i lc lc k )
can be expressed, according to the definition of operation lc, as:
(lecp lc i , lecq lc j , lc[(lecp lc lecq )])  lc (lecrlc i , lecs lc k , lc[(lecr lc lecs)]) =
lecp lc i , lecq lc j , lecrlc i , lecs lc k (lc[(lecp lc lecq)]  lc lc[(lecr lc lecs )])
which, according to the definition of  lc, can be expressed as:
lecp lc i , lecq lc j , lecrlc i , lecs lc k (lc[(lecp lc lecq )  lc (lecr lc lecs )])

(e1)

In this expression, lecp and lecr are elemental constraints of the same-labeled constraint lc i .
However, the set-union of label sets associated to each pair of elemental constraints in any (input or
derived) labeled constraint is an I-L-Set (Definition 3). That is, if lecp lecr, then {labelp }{labelr}
is an I-L-Set. Thus, if lecp lecr, the label set associated to (lecp lc lecq ) lc (lecr lc lecs ) is an I-LSet. In consequence, (lecp lc lecq ) lc (lecr lc lecs ) is rejected in operation lc. That is,
lecp lc i , lecq lc j , lecrlc i , lecs lc k / lecplecr (lc[(lecp lc lecq ) lc (lecr lc lecs )]) = .
Thus, the above expression (e1) results:
lecp lc i , lecq lc j , lecslc k (lc [(lecp lc lecq ) lc (lecp lc lecs )]).
In this expression, lc clearly distributes over  lc for elemental constraints (i.e.: non-disjunctive
constraints). Therefore:
lecp lc i , lecq lc j , lecslc k (lc [(lecp lc (lecq lc lecs ))]) =
lecp lc i , lc [lecp lc (lecqlc j , lecs lc k , lc [lecq lc lecs ])] = lc i lc (lc j lc lc k ).
That is, lc distributes over  lc for labeled constraints.

For instance, following the previous example:
a= {[0 1] {R1}, [10 20] {R2}},

b= {[25 50] {R0}},

c= {[0 30] {R3}, [40 50] {R4}}

and {R1 R2 }, {R3 R4 } are I-L-Sets. Thus, we have:
(a lc (b  lc c) = {[0 1] {R1}, [10 20] {R2}} lc ({[25 50] {R0}}  lc {[0 30] {R3}, [40 50] {R4}}) =
{[0 1] {R1}, [10 20] {R2}}lc {[25 30] {R3 R0}, [40 50] {R4 R0}} =
46

fiBARBER

{[25 31] {R1 R3 R0}, [40 51] {R1 R4 R0}, [35 50] {R3 R2 R0}, [50 70] {R4 R2 R0}}.
Also,
(a lc b)  lc (a lc c) =
({[0 1] {R1}, [10 20] {R2}} lc {[25 50] {R0}})  lc
({[0 1] {R1}, [10 20] {R2}} lc {[0 30] {R3}, [40 50] {R4}}) =
{[25 51] {R1 R0}, [35 70] {R2 R0}}  lc {[0 31] {R1 R3}, [40 51] {R1 R4} [10 50] {R2 R3}, [50 70] {R2 R4}} =
lc ([25 31] {R1 R3 R0}, [40 51] {R1 R4 R0}, [25 50] {R1 R2 R3 R0},
[50 51] {R1 R2 R4 R0}, [40 51] {R1 R2 R4 R0}, [35 50] {R3 R2 R0}, [50 70] {R4 R2 R0}).
However, {R1 R2 }, {R3 R4 } are I-L-Sets. Thus, ([25 50] {R1 R2 R3 R0}, [50 51] {R1 R2 R4 R0}, [40 51] {R1
R2 R4 R0}) are removed in operation lc. Therefore,
(a lc b)  lc (a lc c) = {[25 31] {R1 R3 R0}, [40 51] {R1 R4 R0}, [35 50] {R3 R2 R0}, [50 70] {R4 R2 R0}}.
That is, (a lc (b lc c) = (a lc b)  lc (a lc c).

4. Reasoning Algorithms on Labeled Constraints
Several algorithms for reasoning on disjunctive constraints can be applied for the management of
labeled temporal constraints, by using the lc, lc, lc and lc operations. For instance, the wellknown Transitive Closure Algorithm, general closure algorithms as in (Dechter, 1992; Dechter et al.,
1991; van Beek & Dechter, 1997), CSP-based approaches, etc. However, Montanari (1974) shows
that when composition operation distributes over intersection, any path-consistent TCN is also a
minimal TCN. From Theorem 4, we have that lc distributes over lc. Thus, application of a pathconsistent algorithm on the proposed-labeled TCN will obtain a minimal TCN. Thus, the TCA
algorithm could be used as the closure process on labeled constraints, in a similar way as Allen
(1983) uses it. However, an incremental reasoning process is proposed on the basis of the incremental
path-consistent algorithm for non-disjunctive metric constraints described by Barber (1993). An
incremental reasoning process is useful when temporal constraints are not initially known but are
successively deduced from an independent process; for instance, in an integrated planning and
scheduling system (Garrido et al., 1999). The proposed reasoning algorithm is similar to the TCA
algorithm. However, updating and closure processes are performed at each new input constraint.
Thus, each new input constraint is updated and closured on a previously minimal TCN (Figure 9).
Therefore, no further propagation of modified constraints in the closure process is needed. Moreover,
the proposed reasoning algorithms will obtain a complete and sound set of I-L-Sets.
The specification of reasoning processes is described in Section 4.1. The properties of these
processes will be described later in Section 4.2.
4.1 The Updating Process
Given a previous labeled-TCN, composed by a set of nodes {ni }, a set of labeled constraints {lc ij }
among them, and a set of I-L-Sets, the updating process of each new c ij between nodes ni and nj
constraint is detailed in Figure 2.
47

fiREASONING ON INTERVAL AND POINT -BASED DISJUNCTIVE M ETRIC CONSTRAINTS IN TEMPORAL CONTEXTS

Updating (ni cij nj)
;cij {ecij., ecij.2 , ..., ecij.l }, a disjunctive metric constraint.
lc'ij  Put-Labels (cij ), ;An exclusive label is associated to each elemental constraint
ecij.k in cij
If Consistency-Test (lc ij , lc'ij ) ;Consistency test of lc'ij. The previously existing
constraint between n i and nj is lcij . Moreover, new I-L-Sets
are detected.
Then (*Inconsistent Constraint*)
Return (false)
Else (*Consistent Constraint*)
lc ij  lc ij  lc lc'ij ,
lc ji  Inverselc (lc ij ),
Closure (ni lc ij nj ), ;Closure algorithm for the updated constraint.
Return (true)
End-If
End-Updating
Figure 2: Updating process on labeled constraints
The function Put-Labels(cij ) returns a labeled-constraint lcij {lecij.1 , lecij.2 , ..., lecij.l },
associating an exclusive label to each elemental constraint in cij. If there is only one disjunct in cij ,
the label in the unique elemental constraint is {R0 }. Otherwise, each pair of labels in lcij is added to
the set of I-L-Sets, since elemental constraints in cij are pairwise disjoint (Definition 3). By using the
Inverse function on non-labeled constraints, the Inverse lc function is:
Inverselc ({(ec ij.k {labelij.k })}) =def {(Inverse (ec ij.k ) {labelij.k })}
The described updating process is performed each time that one new input constraint cij is
asserted on a previous TCN. Thus, an initial TCN with no nodes, no constraints, and no I-L-Sets is
assumed (Figure 9). At each new input constraint (cij ), the TCN is incrementally updated and
closured. That is, if cij is consistent (Consistency-Test function), the constraint cij is added to the
TCN, the closure process (Closure function) propagates its effects to all TCN, and the new TCN is
obtained. A new updating process can be performed on this new TCN, and so on successively.
4.1.1. THE CONSISTENCY-TEST FUNCTION
The Consistency-Test function (Figure 3) is based on the operation  lc. A new input constraint lc'ij
between nodes ni and nj is consistent if it temporally intersects with the previously existing constraint
lc ij between these nodes. Moreover, the Consistency-Test function can detect new I-L-Sets:
i)

If the new constraint lc'ij is consistent with the existing constraint lc ij , and two elemental
constraints ecij.p lc'ij , ecij.klc ij do not intersect (ecij.k  ecij.p =), then the label set
{labelij.k }{labelij.p } is an I-L-Set and should be added to the current set of I-L-Sets.

ii)

If an existing elemental constraint between nodes ni and nj (lecij.klc ij) does not intersect with
the new constraint lc'ij , then {labelij.k } is an I-L-Set and should be added to the current set of
I-L-Sets.

48

fiBARBER

Consistency-Test (lc ij , lcij ) =
If (lc ij  lc lcij ) = {}
Then Return (False)
Else
If lecij.k lc ij , lecij.p lc'ij / lecij.k  lc lecij.p ={}
Then I-L-Sets  I-L-Sets  ({labelij.k }{labelij.p }),
If lecij.k lc ij / lecij.k  lc lcij = {}
Then I-L-Sets  I-L-Sets  {labelij.k },
End-If
Return (True)
End- Consistency-Test
Figure 3: Consistency-Test function
For example,
Consistency-Test ({([0 10] {R1}), ([20 25] {R2}), ([100 110] {Ra})},
{([0 30] {R3}), ([40 50] {R4}), ([-50 -40] {Rb})}) = True
since
{{([0 10] {R1}), ([20 25] {R2}), ([100 110] {Ra})}  lc {([0 30] {R3}), ([40 50] {R4}), ([-50 -40] {Rb})} =
{([20 25] {R3 R2}), ([0 10] {R3 R1})}  {}.
In this function, the label sets {R4 R2 }, {R4 R1 } and {Ra} are detected as I-L-Sets and should be
added to the current set of I-L-Sets, since:
{[20 25] {R2}}  lc {[40 50] {R4}}={},
{[0 10] {R1})} lc {[40 50] {R4})}={},
{([100 110] {Ra})}  lc {([0 30] {R3}), ([40 50] {R4}), ([-50 -40] {Rb})}={}.
Note that {Rb } does not need to be detected as an I-L-Set, since the label Rb is not included in the
final constraint {([20 25] {R3 R2}), ([0 10] {R3 R1 })} to be added to the TCN.
Any superset of an I-L-Set is also an I-L-Set (Theorem 1). Moreover, note that {R4 R2}, {R4 R1 }
do not need to be added to the set of I-L-Sets, since the label R4 is not included in the final constraint.
Therefore, the following simplifications can also be performed each time a new I-L-Set is added to
the current set of I-L-Sets. These simplifications do not modify the results of reasoning processes,
but minimize the size of the set of I-L-Sets and improve its management efficiency.
i)

No new I-L-Set that is superset of an existing I-L-Set is added to the set of I-L-Sets.

ii)

If an existing I-L-Set is superset of the new I-L-Set, then the existing I-L-Set is removed.

iii) No new I-L-Set that contains a label of lc'ij , which does not appear in the labeled constraint
(lc ij  lc lc'ij ) to be added to the TCN, should be added to the set of I-L-Sets.
Lets see an example of the updating and consistency-test processes. Lets take the labeled-TCN
that results from Example 1 once the following constraints have been updated and closured:

49

fiREASONING ON INTERVAL AND POINT -BASED DISJUNCTIVE M ETRIC CONSTRAINTS IN TEMPORAL CONTEXTS

Set of Inconsistent-Label-Sets: {{R1 R 2}, {R3 R 4}}
{([60 70] {R0})}

t4
{([40 50] {R3})]
([20 30] {R4})}
{([-10 20] {R3 R0})
([10 40] {R4 R0})}

t3
t1

{([-10 20] {R3 R0})
([10 40] {R4 R0})}

T0
{([40 60] {R2 R0})
([70 ) {R1 R0})}

{([40 ) {R1 R3 R0})
([20 ) {R1 R4 R0})
([-10 30] {R2 R4 R0})
([10 50] {R2 R3 R0})}

{([10 30] {R3 R0})
([30 50] {R4 R0})]}

t2

{((- 0] {R1 R0})
([0 30] {R2 R0})}

{([60 ) {R1})
([30 40] {R2})}

T0
{([10 20] {R0})]}

t4
t1

Figure 4: The resulting labeled-TCN of Figure 1 before updating (t3 {[10 20]} t2 )
(t1 {[60 )R1, [30 40] R2 } t2 ), (t3 {[40 50] R3 , [20 30] R4 } t4), (T0 {[10 20]R0 } t1 ), (T0 {[60 70]R0 } t4 ).
The resulting labeled-TCN is shown in Figure 4 and the set of I-L-Set is {{R1 R2 }, {R3 R4 }}.
Now, we update (t3 {[10 20]R0 } t2 ). The previously existing constraint between t3 and t2 is (Figure 4):
{([40 ){R1 R3 R0 }) ([20 ){R1 R4 R0}), ([-10 30] {R2 R4 R0}) ([10 50] {R2 R3 R0})}
The Consistency-Test function performs:
{[10 20] {R0}}  lc {([40 ){R1 R3 R0 }) ([20 ){R1 R4 R0}), ([-10 30] {R2 R4 R0}) ([10 50] {R2 R3 R0})} =
{[20 20] {R1 R4 R0}, [10 20] {R2 R0} []{R1 R3 R0}}  {}

(e1)

Thus, (t2-t3{[10 20] {R0}}) is consistent. Moreover, {R1 R3 R0 } is detected as an I-L-Set. The
elemental constraints associated to {R1 R3 R0 } are an inconsistent set of disjuncts that cannot hold
simultaneously. That is:
"If today John left home between 7:10 and 7:20 (R0 ), Fred arrived at work between 8:00
and 8:10 (R0 ) and John arrived at work about 10'-20' after Fred left home (R0 ), then it is
impossible for John to have gone by bus (R 1 ) and Fred to have gone in a carpool (R 3 )."
The set of I-L-Sets obtained in the reasoning process can be considered as special derived
constraints, which express the inconsistency of a set of input elemental constraints. For instance, the
I-L-Set {R0 R1 R3 } represents (Figure 1):
 ( (T0 [10 20] T1 )  (T3 [10 20] T2 )  (T0 [60 70] T4 )  (T3 [40 50] T4 )  (T1 [60 ) T2 )).
This expression is a non-binary constraint. This type of constraints could be represented as a
disjunctive linear constraint, as Jonsson and Bckstrm (1996), Stergiou and Koubarakis (1996)
show. However, input elemental constraints should be represented in derived constraints to be able
to derive these inconsistent sets of input elemental constraints. In this model, this is done by means
of the label sets associated to labeled elemental constraints.

50

fiBARBER

4.2 The Closure Process
The closure process (Figure 5) is applied each time a new input constraint (lc'i j ) is updated, such that
the effects of lc'ij are propagated to all TCN.
Closure (ni lc ij nj)
(* First loop: Closure n i  n j  n k *)
nk TCN / lc jk  {U{R0}}:
lc ik  lc ik  lc (lc ij lc lc jk ), lc ki  Inverse(lc ik)
(* Second loop: Closure n j  ni  nl *)
nl TCN / lc il  {U{R0}}:
lc jl  lc jl  lc (Inverse(lc ij ) lc lc il ), lc lj  Inverse(lc jl )
(* Third loop: Closure nl  ni  nj  nk *)1
nl , nk TCN / lc li  {U{R0}}, lc jk  {U{R0}}:
lc lk  lc lk  lc (lc li lc lc ij lc lc jk ), lc kl  Inverse(lc lk )
End-Closure
Figure 5: The closure process on labeled constraints

(3)
nl.1

nl.i

lc il.i

(2)

ni

nk.1
(1)

lcij

nj

nk.i
lcjk.i

nk.t

nl.s

Figure 6: Loops in the Closure Process
The closure process has three loops (Figure 6). In these loops the process obtains:

1

i)

Derived constraints lc ik between ni and any node nk , if nk is previously connected with nj
(edge 1 of Figure 6).

ii)

Derived constraints lc lj between nj and any node nl , if nl is previously connected with ni
(edge 2 of Figure 6).

This loop could be simplified as:
(*n l  n i  n k*): n l, n k TCN / lc li  {U{R0}}, lc j k  {U{R0}}:

lc lk  lc lk lc (lc li lc lc ik), or as

(*n l  nj  n k*): n l, n k TCN / lc li  {U{R0}}, lc j k  {U{R0}}: lc lk  lc lk lc (lc lj lc lcj k)
since lc ik (or lc lj ) has already been closured in the first (or in the second loop). Moreover, the efficiency of the third loop
can be improved if only modified constraints in the first (or in the second loop) are considered.

51

fiREASONING ON INTERVAL AND POINT -BASED DISJUNCTIVE M ETRIC CONSTRAINTS IN TEMPORAL CONTEXTS

Set of Inconsistent-Label-Sets: {{R1 R2 }, {R3 R4}, {R1 R3 R0}}
{([60 70]{R2 R0}) ([70 70]{R4 R1 R0})}

t4
{([60 60]{R4 R1 R0})
([40 60]{R4 R2 R0})
([50 60]{R3 R2 R0})}

t1 {([10 30]{R4 R2 R0})
([10 20]{R3 R2 R0})
([40 40]{R4 R1 R0})}

{([40 50]{R3 R2 R0})
([20 30]{R4 R2 R0})
([20 20]{R4 R1 R0})}

t3

T0

{([40 50]{R2 R3 R0})
([40 60]{R2 R4 R0})
([70 70]{R1 R4 R0})}

{([10 20]{R2 R0}) ([20 20] {R4 R1 R0})}

{([50 50]{R4 R1 R0})
([20 30]{R3 R2 R0})
([30 50]{R4 R2 R0})}

t2

{([0 0] {R1 R4 R0})
([20 30]{R2 R3 R0})
([0 20]{R2 R4 R0})}

{([30 40]{R2 R0})
([60 60]{R1 R4 R0})}

T0
{([10 20]{ R2 R0}) ([10 10] {R4 R1 R0})}

t4
t1

Figure 7: The Labeled-Minimal TCN of the Example 1
iii) Derived constraints lc lk between any pair of nodes nl and nk , if nl and nk are previously
connected with ni and nj respectively (edge 3 of Figure 6).
Lets see the previous Example 1 represented in Figure 1 and Figure 4, when the consistent
constraint (expression e1):
(t3 {[20 20] {R1 R4 R0}, [10 20] {R2 R0}} t2 )
is closured. In the first loop of the closure process, we have:
lc 30  lc 30 lc ({[20 20] {R1 R4 R0}, [10 20] {R2 R0}} lc lc 20 =
{[-30 -10] {R3 R0 } [-50 -30] {R4 R 0 }}  lc
({[20 20] {R1 R4 R0}, [10 20] {R2 R0}} lc {[-60 40] {R2 R0} (- -70] {R1 R0}}) =
{[-30 -10] {R3 R0}} [-50 -30] {R4 R0}}  lc
{[-40 -20] {R1 R2 R4 R0}, (- -50] {R1 R4 R0} [-50 20] {R2 R0} (- -50] {R1 R2 R0}}.
However, {{R1 R2 }, {R3 R4 } {R0 R1 R3 }} are I-L-Sets. No labeled elemental constraints whose
associated label set is a superset of these I-L-Sets will be derived (Theorem 3). Thus:
lc 30 {[-30 -10] {R3 R0}} [-50 -30] {R4 R0}}  lc {(- -50] {R1 R4 R0} [-50 20] {R2 R0} }=
{(-30 -20] {R2 R3 R0} [-50 50] {R4 R1 R0} [-50 -30] {R4 R2 R0}}.
Similarly,
lc 31  lc 31 lc ({[20 20] {R1 R4 R0} [10 20] {R2 R0}} lc lc 21 =
{[-20 -10] {R3 R2 R0 } [-40 -40] {R4 R1 R0} [-30 -10] {R4 R2 R0}}
lc 34  lc 34 lc ({[20 20] {R1 R4 R0}, [10 20] {R2 R0}} lc lc 24 =
{[40 50] {R3 R2 R0 } [20 30] {R4 R2 R0} [20 20] {R4 R1 R0}}.
After the second and third loops, the final labeled-TCN is obtained (Figure 7). The final set of I-LSets is {{R1 R2 }, {R3 R4 } {R0 R1 R3 }}. These sets represent all sets of mutually inconsistent inputelemental constraints that exist in the TCN of Figure 1.
52

fiBARBER

4.3 Properties of Reasoning Algorithms
In this section, the main properties of the proposed reasoning algorithms are described.
Theorem 5. The proposed updating and closure processes (Sections 4.1 and 4.2) guarantee a
consistent TCN if they are applied on a previous minimal (and consistent) TCN.
Proof: The updating constraint lcij is asserted in the TCN if it is consistent with the previous minimal
constraint lc ij (Consistency-Test function).

Theorem 6. The proposed closure algorithm obtains a path-consistent TCN, if it is applied over a
previous minimal TCN.
Proof: This was detailed by Barber (1993) for non-disjunctive TCNs and it is applied here to labeled
TCNs. We have:
i)

No derived constraint can exist between a pair of nodes if no path between them combines
the asserted constraint lc ij .

ii)

The closure process computes a derived constraint between any pair of nodes (nl , nk ) that
become connected by a path across the closured constraint lc ij . Lets assume an existing path
between the nodes nx1 , ny1 that includes lc ij :
nx1 , nx2 , nx3 , ........, nx, (nj lc ij nj ), ny ......, ny2 , ny1
such that a derived constraint between nx1 ny1 should be computed. However, a minimal
constraint between (nx1 , ni ) and between (nj , ny1 ) should already exist in the previous minimal
TCN. In consequence, a derived constraint between (nx1 , ny1 ) is computed in the third loop
of the process.

iii) If the previous TCN is minimal, all possible derived constraints that can exist between any
pair of nodes (nl, nk ) are already computed in the constraint lclk derived between these nodes
in the proposed closure process. In the third loop, this process obtains:
lclk = lc lk  lc (lc li lc lc ij lc lc jk ).
Lets suppose there exists another path between (nl , nk ) across the updated lc ij constraint: (nl ,
np , ni , nj , nq , nk ). This path computes another derived constraint between (nl , nk ):
lc''lk = lc lk lc (lc lp lc lc pi lc lc ij lc lc jq lc lc qk ).
However, since the previous TCN is minimal, the previously existing minimal constraints
lc li and lc jk imply (lc lp lc lc pi ) and (lc jq lc lc qk), respectively. That is, lc li lc(lc lp lc lc pi ) and
lc jk lc(lc jq lc lc qk ) Thus, lc''lk is also implicitly implied by lclk (lclk lclc''lk ). Here, we have
assumed the associative property for lc, which is obvious from its definition.
iv) Derived constraints obtained in the closure process do not need to be closured again if the
previous TCN is minimal. That is, no constraint in the TCN would become more restricted
if derived constraints were also closured. Let suppose lc lk is modified in the third loop of
closure process:
lclk = lc lk  lc (lc li lc lc ij lc lc jk )
such that it should be propagated to the (nl , nk , np ) subTCN (Figure 8). Thus, the following
derived constraints should be obtained:
53

fiREASONING ON INTERVAL AND POINT -BASED DISJUNCTIVE M ETRIC CONSTRAINTS IN TEMPORAL CONTEXTS

lclp = lc lp  lc (lclk lc lc kp )

lcpq = lc pq lc (lc pl lc lclk ).

For constraint lclp , we have,
lclp = lc lp lc (lclk lc lc kp ) = lc lp lc ((lc lk lc (lc li lc lc ij lc lc jk )) lc lc kp ).
However, since lc distributes over  lc,
lclp = lc lp  lc ((lc lk lc lc kp )  lc (lc li lc lc ij lc lc jk lc lc kp )).
Since the previous TCN is minimal, the minimal constraints lc pi and lc pj should previously
exist, such that lclp lc(lc lk lc lc kp ) and lc jp lc(lc jk lc lc kp ). Thus,
lclp lc lc lp  lc (lc li lc lc ij lc lc jp ).
However, in the third loop of the closure process, the following derived constraint is
computed:
lc''lp = lc lp lc (lc li lc lc ij lc lc jp ).
Thus, lclp is already represented in the obtained constraint lc''lp (that is, lc''lp lc lc'lp ). In a
similar way,
lc''pq = lc pq lc (lc pi lc lc ij lc lc jq )
is also obtained in the proposed closure process, such that lc''pq lc lc'pq .
Therefore, each derived constraint (any combinable path across lc ij ) between any pair of nodes
in the TCN is computed, so that the closure process obtains a path-consistent TCN. 

np

lclp

lcpk

lclk

nl
lclj

lc ij

ni

nk
nj

lcjk

Figure 8: lc lk is also propagated to lc lp and lc pq
Theorem 7. The proposed reasoning processes obtain a minimal TCN, if the previous TCN is a
minimal TCN.
Proof: Montanari (1974) shows that when composition distributes over intersection (i.e.: 
distributes over ), any path-consistent TCN is also a minimal TCN). This is the case in nondisjunctive metric TCNs (Dechter et al., 1991). In our case, lc distributes over lc (Theorem 4) and
the closure process obtains a path consistent TCN (Theorem 6). Therefore, the proposed reasoning
processes also obtain a minimal TCN. 

54

fiBARBER

New input
constraint

INITIAL
TCN
No nodes, No
constraints, No I-L-Sets

Input Constraint
( ni lcij nj )
If (ni lcij nj ) is consistent
Reasoning Process: Updating + Closure processes
Consistency-Test: Consistent TCN
Closure Process: Path-Consistent TCN.
Distributive Property ( lc over lc): Minimal
New consistent and minimal TCN
New complete and sound set of I-L-Sets

Figure 9: An incremental reasoning process
Theorem 8. At each updating process, reasoning algorithms obtain a complete and a sound new set
of I-L-Sets (Definition 4), if they are applied on a previous minimal TCN and a previous sound and
complete set of I-L-Sets.
Proof:
i) The new set of I-L-Sets is complete. The consistency test of the updated constraint lc'ij obtains
all possible new I-L-Sets that can appear when lc'ij is added to the TCN, except those I-L-Sets
which are related to the mutual exclusion of the disjuncts in lc'ij (which are determined in the
Put-Label function):
a) No new I-L-Sets can appear in which some label of lc'ij does not participate. Otherwise,
they would have been detected in a previous updating process, since the previous set of
I-L-Sets is assumed complete. Thus, some label of lcij should always participate in any
new I-L-Set that appears when lcij is updated.
b) All new I-L-Sets (in which some label of lcij participates) are detected in the consistency
test of lcij. Let's assume that a new and undetected I-L-Set exists {Rk , R1 , R2 , ....., Rp } in
which some new elemental constraint eck{Rk}lc'ij takes part. Thus, the elemental
constraints associated to {R1 , R2 , ....., Rp } compute a derived elemental constraint ecx
between the nodes ni and nj :
(ecx {R1, R2, ....., Rp})

/

(ecx {R1, R2, ....., Rp})  lc (eck{Rk}) =

This elemental constraint ecx is already represented in the previously existing constraint lc ij

55

fiREASONING ON INTERVAL AND POINT -BASED DISJUNCTIVE M ETRIC CONSTRAINTS IN TEMPORAL CONTEXTS

between ni and nj since the previous TCN is minimal2 . Thus, eck ecx=, such that the I-LSet {Rk , R1 , R2 , ....., Rp } is detected in the consistency test of lcij . In conclusion, all new
inconsistent sets of elemental constraints in which lc'ij participates are detected and no other
new I-L-Sets can exist. Therefore, the new set of I-L-Sets is complete if the previous set
of I-L-Sets is complete.
ii) The new set of I-L-Sets is sound. All new I-L-Sets obtained represent inconsistent sets of
elemental constraints. This is trivial, given the consistency test function. 
In conclusion, the proposed reasoning algorithms obtain a minimal (and consistent) TCN if they
are applied to a previous minimal-TCN (Figure 9). Therefore, the reasoning algorithms guarantee
TCN consistency and obtain a minimal TCN and a complete and sound set of I-L-Sets at each new
input assertion.
4.4 Global Labeled-Consistency
In a minimal (binary) disjunctive network, every subnetwork of size two is globally consistent
(Dechter, 1992). Therefore, any local consistent instantiation of a subset of two variables can be
extended to a full consistent instantiation. However, to assure that a local consistent instantiation of
a subset of more that two variables is overall consistent, the partial instantiation should be propagated
on the whole TCN (van Beek, 1991). Thus, assembling a TCN solution can become a costly
propagation process in disjunctive TCNs, even though a minimal TCN was used. The proposed
reasoning processes maintain a complete and sound set of I-L-Sets (Theorem 8). Thus, we can deduce
if a locally consistent set of elemental constraints is overall consistent by means of label sets
associated to labeled elemental constraints and the set of I-L-Sets. Specifically, we can deduce
whether any locally consistent instantiation of k variables (1<k<n) is overall consistent. Lets see the
following example, which is based on a previous one proposed by Dechter, Meiri and Pearl (1991):
Example 2: "Dave goes walking to work in [25 50]. John goes to work either by car
[10 30'], or by bus [45 60]. Fred goes to work either by car [15' 20'],
or in a carpool [35' 40'], or walking [55 60]. Today, they all left their
home between 6:50 and 7:50 (at t1, t2 and t3 time-points), and arrived at
work at just the same time (t4 ) before 8:00."
Here, we have the following labeled disjunctive constraints where, T0 represents the initial time
(6:50) and granularity is in minutes:
t1 - T0  {[0 60]R0 },
t4 - t 1  {[25 50]R0 },

t 2 - T0  {[0 60]R0 },

t 3 - T0  {[0 60]R0 },

t 4  t 2  {[10 30]R1 , [45 60]R2 },

t 4 - T0  {[0 70]R0 },

t 4  t 3  {[15 20]R3 , [35 40]R4 , [55 60]R5 }.

The minimal TCN of Example 2 is represented in Figure 10. Here, the binary constraints between
each time-point and T0 represent unary constraints and restrict interpretation domains for variables
(t1 , t2 , t3 , t4 ). Obviously, this minimal TCN is not a globally consistent TCN. For instance,

2

The elemental constraint ec x is already represented in an explicit way, or by means of another elemental constraint ecy
(ecy Tec x, {labely }{R1, R2, ....., Rp}) due to the simplification process performed in the operation lc . In both cases,
ec kec x=, ec kecy =.

56

fiBARBER

instantiations {(t1 =0), (t2=0), (t3=0)} are consistent with the existing constraints involved among (T0 ,
t1 , t2 , t3 ), but this partial solution cannot be extended to the overall TCN.

{[0 45]}

t1
{[25 50]}

{[-35 35]}
{[0 55]}

T0
{[-35 40}]

t3

{[15 20] [35 40] [55 60]}

t4

{[-50 45]}
{[10 30] [45 60]}

{[0 60]}

t2

{[25 70]}

Figure 10: Minimal TCN of Example 2
Lets consider the TCN with labeled constraints. For reasons of simplicity, we only denote the
labeled constraints among (T0 , t1 , t2 , t3 ):
(T0 {[5 45]{R0 R5}, [0 45]{R0 R4}, [0 45]{R0 R3}} t 1 ),
(T0 {[0 25]{R2 R0}, [5 60]{R1 R0 R4}, [25 60]{R1 R0 R5}, [0 60]{R1 R0 R3}} t 2 ),
(T0 {[25 55]{R0 R2 R3}, [0 15] {R0 R5}, [0 35]{R0 R1 R4}, [5 55]{R0 R1 R3}, [5 35]{R0 R2 R4}} t 3 ),
(t 1 {([-5 35]{R0 R2}, [-40 5] {R0 R1}} t 2 ),
(t 1 {[-15 15]{R0 R4}, [-35 -5]{R0 R3}, [5 35]{R0 R5}} t 3 ),
(t 2 {[5 30] {R1 R0 R4}, [-45 -25]{R2 R0 R3}, [25 50]{R1 R0 R5}, [-15 10]{R1 R0 R3}, [-25 -5]{R2 R0 R4}, [-5 15]{R2 R0 R5}} t3 ).

The set of I-L-Sets is {{R1 R2 } {R3 R4 } {R3 R5 } {R4 R5}}. From this labeled TCN and the set of
I-L-Sets, we can deduce that instantiations {(t1 =0), (t2 =0), (t3 =0)} are not overall consistent. These
instantiations are not locally consistent with the labeled constraints in the subTCN (T0 , t1 , t2 , t3 ): All
label sets associated to possible simultaneous fulfillment of
(T0 {[0 0]} t 1 ), (T0 {[0 0]} t 2 ) and (T0 {[0 0]} t 3 )

are I-L-Sets. That is, all label sets in the Cartesian product
{{R0 R4 } {R0 R3 }}  {{R2 R0 } {R1 R0 R3 }}  {{R0 R5 } {R0 R1 R4 }}

are I-L-Sets. Thus, the set of I-L-Sets can be used to deduce consistency of a set of labeled elemental
constraints and to obtain a globally consistent labeled-TCN.
Theorem 9. Lets assume a labeled-TCN of n nodes (and the corresponding complete and sound set
of I-L-Sets) and a local set of k (1k( n2 )) labeled elemental constraints in the TCN, each one of
which is between any pair of nodes:
{lec1 , lec2 ,....., leck }  {(ec 1 {label1 }), (ec2 {label2 }), ..., (ec k {labelk })}.

57

fiREASONING ON INTERVAL AND POINT -BASED DISJUNCTIVE M ETRIC CONSTRAINTS IN TEMPORAL CONTEXTS

The local set of labeled elemental constraints {lec1 , lec2 , ... , leck }is overall consistent iff the setunion of their associated label sets (i=1,k {labeli }) is not an I-L-Set.
Proof: The label set (i=1,k {labeli }) is the support-set of the simultaneous fulfillment of {lec1 , lec2 ,
--- , leck }. Moreover, the set of I-L-Sets is complete and sound with respect to overall TCN (Theorem
8), such that any label set not in the set of I-L-Set is overall consistent. Therefore (Theorem 2),
(i=1,k {labeli }) and {lec1 , lec2 , ... , leck } are overall consistent iff i=1,k {labeli } is not an I-L-Set. 
Definition 5 (Labeled-consistency3 ): Lets assume a labeled-TCN of n nodes (and the corresponding
complete set of I-L-Sets) and a set of k (1k(n2 )) constraints, each one of which is between any pair
of nodes in the TCN:
{c ij } / 1in, 1jn, ij.
The set of constraints {c ij } is labeled-consistent with respect to the nodes involved in these
constraints, iff:
i)

For each constraint cij , there exists an elemental labeled constraint elc ij.x between (ni , nj ) in
the TCN such that elc ij.x satisfies cij . That is: cij , elc ij.xlc ij / c ij  ecij.x  .

ii)

The resulting set of the union of label sets associated to these elemental labeled constraints
(which satisfy {c ij }) is not an I-L-Set: U cij{label ij.x} is not an I-L-Set. Note that this is the
condition of Theorem 9. 

Theorem 10. Lets assume a labeled-TCN of n nodes (and the corresponding complete set of I-LSets) and a set of k (1k( n2 )) constraints, each one of which is between any pair of nodes in the
TCN:
{c ij } / 1in, 1jn, ij.
The set of constraints {c ij } is overall consistent iff {c ij } is labeled-consistent with respect to the
nodes involved in constraints {c ij }.
Proof: The proof is trivial according to Definition 5 and Theorem 9. We have that the set of
constraints {c ij } is consistent iff there exists a local set of elemental constraints in the TCN {elc ij.x}
that makes {c ij} labeled-consistent (Definition 5). Thus, the local set {elc ij.x} is consistent (Theorem
9), such that {c ij } is also consistent. 
For instance, we can determine whether any pair of constraints c' ij and c'kl can hold simultaneously
(that is, they are overall consistent) if:
elc ij.xlc ij / c' ij  ecij.x  elc kl.yckl / c'kl  eckl.y  {labelij.x}{labelkl.y }
is not an I-L-Set.
Moreover, any local instantiation of any k-1 (1<kn) variables {t1 =v1 , t2 =v2 , ..., t(k-1)=v(k-1)} can
be extended to a global solution if:
elc 10.xlc 10 / v1ec10.x,...... , elc (k-1)0.ylc (k-1)0 / v(k-1)ec10.x,
where lc i0 is the constraint between ni and T0 , and {label10.x}{label20.y } .... {label(k-1)0.y }is not
and I-L-Set.
3

We need to introduce the concept of labeled-consistency since it is a different concept from the consistency concept.

58

fiBARBER

For instance, in Example 2 of Figure 10, the partial instantiation {(t1 =0), (t2 =5), (t3 =5)} is
consistent. We have:
([0 45]{R0 R3})lc10 / 0[0 45],

([0 60]{R1 R0 R3})lc20 / 5[0 60],

([5 55]{R0 R1 R3})lc30 / 5[5 55],

and {R0 R3 }{R0 R1 R3}{R0 R1 R3 }={R0 R1 R3 } is not an IL-Set. Thus, this partial solution can be
extended to a global solution. For instance, {(t1 =0), (t2 =5), (t3 =5), (t4 =25)}.
Therefore, a labeled-TCN can be considered as a globally labeled-consistent TCN. That is, on the
basis of the concepts introduced by Dechter (1992):
Definition 6. (Local Labeled-consistency): A partial instantiation of variables (1k<n) {t1 =v1 , t2 =v2 ,
..., tk =vk } is local labeled-consistent if it is labeled-consistent with respect to (T0 , t1 , t2 , ..., tk ) nodes.
This also holds for k=n. 
Definition 7. (Global Labeled-consistency): A labeled sub-TCN (with the global set of I-L-Sets) is
global labeled-consistent if any partial instantiation of variables in the sub-TCN, which is local
labeled-consistent, can be extended to the overall TCN. A globally labeled-consistent TCN is one in
which all its sub-TCNs are globally labeled-consistent. 
Theorem 11. At each new assertion, the proposed reasoning processes obtain a globally labeledconsistent TCN, if they are applied on a previous minimal TCN and a previous sound and complete
set of I-L-Sets.
Proof: The proof is trivial according to the previous definitions (Definition 6 and Definition 7) and
to the properties of the reasoning processes (Theorem 7 and Theorem 8). Any partial instantiation
in any subTCN, which is labeled-consistent with respect to the nodes involved in the partial
instantiation, is overall consistent (Theorem 10). 
Similar expressions can be made for k-labeled-consistency and strong k-labeled-consistency on
the basis of the concepts provided by Freuder (1982). Therefore, the set of I-L-Sets in a labeled-TCN
provides a useful way to assure whether a local instantiation of variables can be part of a global
solution. Moreover, Freuder (1982) shows that in a strong k-consistent TCN, consistent instantiations
of variables of any subnetwork of size k can be found in a backtrack-free manner and in any variable
ordering. This is also a consequence of the decomposability (Montanari, 1974; Dechter et al., 1991)
or globally consistency (Dechter, 1992) properties. Obviously, this feature also holds for labeled
TCNs.
4.5 Analysis of Temporal Complexity
Lets analyze the computational cost of the proposed reasoning processes. These processes are,
basically, an incremental path-consistent algorithm (Barber, 1993). At each updating process of a
new input constraint on a TCN with n nodes, the computational cost of updating and closure
processes is bounded by 'n2 (O(lc) + O(lc))'. In the proposed reasoning process, the path-consistent
algorithm obtains a minimal disjunctive metric TCN. This is possible due to the management of
labeled constraints, associated label sets, and I-L-Sets. Thus, the complexity of reasoning processes
is mainly due (instead of a complex closure process) to the management of complex data structures
(labeled constraints, associated label sets, and I-L-Sets). That is, the complexity of the proposed

59

fiREASONING ON INTERVAL AND POINT -BASED DISJUNCTIVE M ETRIC CONSTRAINTS IN TEMPORAL CONTEXTS

reasoning processes is mainly due to the complexity of operations lc and  lc.
The computational cost of lc and  lc depends on the number of elemental constraints in labeled
constraints, the size of associated label sets, and the size of I-L-Sets in the previous minimal labeled
TCN. Let 'n' be the number of nodes, 'l' the maximum number of disjuncts (or labels) in input
constraints, and 'e' the number of updated input constraints in the previous TCN. The maximum
number of labels in the TCN is l*e, since each disjunct in each updated input labeled constraint has
its own, unequivocal label. Moreover, any I-L-Set can have as maximum one label from each input
labeled constraint lc ij , since: (i) elemental constraints in lc ij are pairwise disjoint, such that each pair
of labels in lc ij is added to the set of I-L-Sets, and (ii) any superset of an existing I-L-Set is also an
I-L-Set. Thus, the maximum number of labels in any I-L-Set is e. Furthermore, each label in an I-LSet should be from a different input labeled constraint. There are e input labeled constraints, and each
input labeled constraint has as maximum l labels. Thus, the maximum number of I-L-Sets of q-length
(1qe) is (( qe ) lq ).
Therefore, the number of i-length (1ie) I-L-Sets is i=1,e (( ei ) li ) = O(2e le). However, any
superset of an I-L-Set is already known as inconsistent, such that supersets are not stored in the set
of I-L-Sets. Thus, the number of I-L-Set is bounded by O(le). Additionally, we also have e*( l2 ) I-LSets of 2-length, since the l disjuncts in each updated constraint are mutually exclusive among them.
Similarly, the maximum number of associated label sets is also bounded by O(le), each one with a
maximum of e labels. Thus, the number of elemental constraints (or labeled subintervals) in any
labeled constraint is bound by O(le), since each elemental constraint in a labeled constraint has its
own associated label set.
According to these parameters, the computational cost of each updating process is bounded by
O(n2 l3e). The recovery process of constraints has a constant cost, since a minimal-TCN is always
maintained. The computational cost of the proposed algorithms agreed with the computational cost
inherent to the problem of the management of disjunctive metric constraints (Dechter, 1991). In fact,
the closure process could be considered as an integrated management of the le alternative nondisjunctive TCNs in which a disjunctive TCN can be split, as it is shown by Dechter, Meiri and Pearl
(1991). It should be noted that l can be bounded in some typical problems like scheduling, where
usually l 2 (Garrido et al., 1999), or by restricting domain size (range or granularity) in metric
algebras. On the other hand, several improvements can be made on the described processes. For
example, an efficient management of label sets has a direct influence on the efficiency of the
reasoning processes. Thus, each label set (for instance, {R3 R5 R8 }) can be considered as a
unidimensional array of bits, which is the binary representation of an integer number (for instance
(23 +25 +28 )). Therefore, each associated label set is represented by a number and the set of I-L-Sets
becomes a set of numbers. Matching and set-union processes on label sets in operations lc and lc
can be efficiently performed by means of operations on integer numbers with a constant cost.
Therefore, the computational cost can be bounded by O(n2 l2e).
Other alternative implementations are under study. Two different approaches exist for temporal
constraint management (Brusoni et al., 1997; Yampratoom, Allen, 1993; Barber, 1993). The first
approach is to maintain a closured TCN by recomputing the TCN at each new input constraint and
making the derived constraints explicit. Here, queries are answered in constant time, although this
implies a high spatial cost. The second approach is to explicitly represent only input constraints, such
that the spatial requirements are minimum. However, further computation is needed at query time
and when consistency of each new input constraint is tested. The proposed reasoning methods hold
60

fiBARBER

in the first approach, which seems more appropriate for problems where queries on the TCN are more
usual tasks than updating processes.
In addition, the proposed reasoning algorithms obtain a sound and complete set of I-L-Sets and
a globally labeled-consistent TCN. Regrettably, assembling a solution in a labeled TCN, although
backtrack free, is also costly due to the exponential number of I-L-Sets. However, these features offer
the capability of representing and managing special types of non-binary disjunctive constraints (later
detailed in Section 6).
Other reasoning algorithms for query processes on a non-closured TCN, as well as CSP
approaches can be defined on the basis of the labeled temporal algebra described. Less expensive
algorithms can be applied on labeled constraints by using the specified operations lc, lc, lc and
lc. For instance, the TCA algorithm as is applied by Allen (1983), and the k-consistency algorithms
like those described in (Cooper, 1990; Freuder, 1978). Moreover, a minimal TCN of labeled
constraints can be obtained without enforcing global consistency; for example, by applying the naive
backtracking algorithm described by Dechter, Meiri and Pearl (1991), which is O(n3 le).

5. Interval-Based Constraints Through Labeled Point-Based Constraints
The integration of quantitative and qualitative information has been the goal of several temporal
models, as was described in Section 1. When intervals are represented by means of their ending
points Ii + Ii -, integration of constraints on intervals and points seems to require some kind of nonbinary constraints between time-points (Gerevini & Schubert, 1995; Schwalb & Dechter, 1997;
Drakengren & Jonsson, 1997). In this section, the proposed temporal model is applied in order to
integrate interval and point-based constraints. Constraints on intervals are managed by means of
constraints on ending points of intervals and I-L-Sets. Likewise, metric information can also be added
to interval constraints such that an expressive way of integrating qualitative and quantitative
constraints is obtained.
5.1 Symbolic Interval-Based Constraints
Symbolic constraints on intervals express the qualitative temporal relation between two intervals.
Each symbolic constraint is a disjunctive subset of 13 elemental constraints, which are mutually
exclusive among them (Allen, 1983). For example, the following constraint
I1 {ec 1 , ec2 } I2 ,

ec1 , ec2 {b, m, o, d, s, f, e, bi, mi, oi, di, si, fi},

really means 'I1 [ (ec1  ec2 )  (ec1  ec2 ) ] I2', since ec 1 and ec 2 are mutually exclusive, and one and
only one elemental constraint should hold. For reasons of simplicity, we only consider two disjuncts
in the symbolic constraint. However, these expressions can be easily extended for managing from
2 to 13 disjuncts. The above expression can be expressed as:
I1 [ (ec1  ec2 )  (ec1  ec2 ) ] I2 
I1 [ (ec1  ec1 )  (ec 2  ec2 )  (ec1  ec2 )   (ec1  ec2 ) ] I2
In this way, we have:

61

(e2).

fiREASONING ON INTERVAL AND POINT -BASED DISJUNCTIVE M ETRIC CONSTRAINTS IN TEMPORAL CONTEXTS

i)

The constraints [I1 (ec1  ec1 ) I2 ] and [I1 (ec2  ec2 ) I 2 ] can be expressed as disjunctive
metric constraints on the same pairs of time-points,

ii)

The constraints [I1 (ec 1  ec2 ) I2 ] and [I1 (ec1  ec2 ) I2 ] can be expressed as a mutual
exclusion among the associated labels of the above point-based constraints. That is, as a set
of I-L-Sets.

We present a simple example to illustrate these conclusions. For instance, (I1 {before after} I2 )
can be expressed by means of constraints among the time points I1 -, I1 +, I2 - and I2 +, as:
[I1 {b a} I2 ]  (I1 + {(0 ){Rb1}} I2 -)  (I1 - {(- 0){Ra1}} I2 +).
Thus, when intervals are represented by means of their ending points Ii + Ii -, an interval-based
constraint gives rise to disjunctive constraints between different pairs of time points (i.e.: non-binary
constraints). These non-binary constraints can be represented as I-L-Sets. Thus, according to the
above expression (e2),
[I1 {b a} I2]  [I1 (b  b) I2 ]  [I1 (a  a) I2 ]  [I1 (b  a) I2 ]  [I1 (b  a) I2 ],
we have:
I1 before I2  I1 + {(0 ){Rb1}} I2 -,
I1 before I2
 I1 + {(- 0]{Rb2}} I2 -,

I1 after I2  I1 - {(- 0){Ra1}} I2 +,
I1 after I2  I1 - {[0 ){Ra2}} I2 +.

Therefore, [I1 {b a} I 2 ] can be expressed as:
[I1 + {(0 ){Rb1} (- 0]{Rb2}} I2 -]  [I1 - {(- 0){Ra1} [0 ){Ra2}} I2 +] 
 [ (I1 + {(0 ){Rb1}} I2 -)  (I1 - {(- 0){Ra1}} I2 +) ] 
 [ (I1 + {(- 0]{Rb2}} I2 -)  (I1 - {[0 ){Ra2}} I2 +) ],
which is equivalent to (by using the labels associated to each elemental constraint):
[I1 + {(0 ){Rb1} (- 0]{Rb2}} I2 -]  [I1 - {(- 0){Ra1} [0 ){Ra2}} I2 +]
and {Rb1 Ra1},{Rb2 Ra2} are I-L-Sets, such that one and only one disjunctive symbolic constraint
holds.
Thus, symbolic constraints between intervals can be represented by means of: (i) a set of
disjunctive metric constraints between time-points, and (ii) a set of I-L-Sets. In Table 1, the
equivalent metric constraints between interval ending time points for each elemental interval-based
constraint are detailed. According to this table, the following steps allow us to represent disjunctive
symbolic constraints between intervals by means of disjunctive metric constraints between interval
ending points and I-L-Sets:
i)

Each interval I i is represented by means of its ending points Ii +, Ii-. By default, (I i - {(0, ){R0}}
Ii +) holds.

ii)

A symbolic constraint between two intervals (Ii cij Ij) is composed of a disjunctive set of
(from 1 to 13) elemental symbolic constraints cij ={ecij.k }{b, m, o, d, s, f, e, bi, mi, oi, di,
si, fi}.

iii) Each elemental symbolic constraint ec{b, m, o, d, s, f, e, bi, mi, oi, di, si, fi} is represented
62

fiBARBER

by a conjunctive set of disjunctive point-based metric constraints (fourth column of Table
1). This conjunctive set of point-based constraints expresses the fulfillment or nonfulfillment (ec  ec) of the elemental symbolic constraint ec.
iv) A disjunctive set cij ={ecij.k } of elemental symbolic constraints between Ii and Ij is represented
by:


A conjunctive set of disjunctive point-based metric constraints between the time-points
Ii +, Ii -, Ij+ and I-j . This conjunctive set is composed by the constraints in the fourth column
of Table 1 for each elemental constraint in {ecij.k }.



A set of I-L-Sets that expresses the logical relation among elemental symbolic
constraints in {ec ij.k }. That is, 'one and only one elemental symbolic constraint in {ecij.k}
should hold':
iv.a) Only one elemental constraint in {ecij.k } should hold. This condition does not
need to be represented since the different sets of point-based constraints that
correspond to fulfillment of different elemental symbolic constraints (second
column of Table 1) are already mutually exclusive.
iv.b)

One of the elemental symbolic constraints in {ecij.k } should hold. Let S be the
label sets, where each label set corresponds to the point-based constraints which
are related to the non-fulfillment of each elemental symbolic constraint in {ec ij.k }
(third column of Table 1). Thus, the Cartesian product among the label sets in S
is a set of I-L-Sets.

For instance, I1 {b m s di} I2 can be represented as:
(I1 - { (0 ){R0}} I1 +), (I2 - { (0 ) {R0}} I2 +),

I1 {b b} I2  (I1 + {(0 ){Rb1} (- 0]{Rb2}} I2 -),
I1 {m m} I2  (I1 + {[0 0] {Rm1} (0 ){Rm2} (- 0){Rm3}} I2 -),
I1 {s s} I2  (I1 - {[0 0] {Rs1} (0 ){Rs3} (- 0){Rs4}} I2 -)  (I1 + {(0 ){Rs2} (- 0]{Rs5}} I2 +),
I1 {di di} I2  I2 {d d} I1  (I2 - {(- 0){Rd1} [0 ){Rd3}} I1 -)  (I2 + {(0 ){Rd2} (- 0]{Rd4}} I1 +).

Moreover, one of the symbolic constraints in {b, m, s, di} should hold. Thus (according to Point
iv.b of the method), the Cartesian product of the associated labels related to the non-fulfillment of
each elemental symbolic constraints in {b, m, s, di}. That is:
{{Rb2 }{Rm2 , Rm3 }{Rs3 , Rs4 , Rs5 }{Rd3 , Rd4 }

should be explicitly included in the set of I-L-Sets.
By applying this method, qualitative interval-based constraints can be fully integrated in the
proposed labeled point-based constraints. In this case, the interpretation domain for time-points {Ii Ii +} can be restricted to only three values ({D}={(-, 0), [0 0], (0 )}), such that, l=3. Therefore, the
computational cost of reasoning algorithms is bounded by O(n2 3 2e).
To illustrate the proposed method, lets show a typical example on symbolic interval-based
constraints (Figure 11.a), which was given by Allen (1983). This example shows how interval-based
constraints can be represented and managed by means of disjunctive metric point-based constraints
and a minimal IA-TCN can be obtained.
63

fiREASONING ON INTERVAL AND POINT -BASED DISJUNCTIVE M ETRIC CONSTRAINTS IN TEMPORAL CONTEXTS

Ii ecij.k Ij

Ii ecij.k Ij

Ii  ecij.k Ij

Ii (ecij.k  ec
 ij.k) Ij

Ii before Ij

Ii + {(0 ){Rb1}} Ij -

Ii + {(- 0]{Rb2}} Ij -

Ii + {(0 ){Rb1} (- 0]{Rb2}} Ij -

Ii meets Ij

Ii + {[0 0]{Rm1}} Ij -

Ii + {(0 ){Rm2} (- 0){Rm3}} Ij -

Ii + {[0 0]{Rm1} (0 ){Rm2} (- 0){Rm3}} Ij -

Ii during Ij

Ii - {(- 0){Rd1}} Ij -

(Ii - {[0 ){Rd3}} Ij -)

Ii - {(- 0){Rd1} [0 ){Rd3}} Ij -

Ii + {(0 ){Rd2}} Ij +
Ii starts Ij

Ii + {[0 0]{Rf1}} Ij +
-

Ii {(- 0){Rf2}} Ij

-




Ii + {(0 ){Rd2} (- 0]{Rd4}} Ij +
Ii - {[0 0]{Rs1} (0 ){Rs3} (- 0){Rs4}} Ij Ii + {(0 ){Rs2} (- 0]{Rs5}} Ij +

(Ii + {(- 0]{Rs5}} Ij +)

(Ii + {(0 ){Rf3} (- 0){Rf4}} Ij +)

Ii + {[0 0]{Rf1} (0 ){Rf3} (- 0){Rf4}} Ij +

(Ii {[0 ){Rf5}} Ij )
-

Ii - {(- 0){Rf2} [0 ) {Rf5}} Ij -

-

(Ii + {[0 ){Ro4}} Ij -)

+
Ii overlaps Ij Ii {(- 0){Ro1}} Ij

Ii equal Ij

(Ii + {(- 0]{Rd4}} Ij +)

(Ii - {(0 ){Rs3} (- 0){Rs4}} Ij -)

Ii - {[0 0]{Rs1}} Ij Ii + {(0 ){Rs2}} Ij +

Ii finishes Ij



Ii + {(- 0){Ro1} [0 ){Ro4}} Ij -

Ii + {(0 ){Ro2}} Ij +



(Ii + {(- 0]{Ro5}} Ij +)

Ii + {(0 ){Ro2} (- 0]{Ro5}} Ij +

Ii - {(0 ){Ro3}} Ij -



(Ii - {(- 0]{Ro6}} Ij -)

Ii - {(0 ){Ro3} (- 0]{Ro6}} Ij -

Ii + {[0 0]{Re1}} Ij +

(Ii + {(0 ){Re3} (- 0){Re4}} Ij +)

Ii + {(0 ){Re3} [0 0]{Re1} (- 0){Re4}} Ij +

Ii - {[0 0]{Re2}} Ij -

 (Ii - {(0 ){Re5} (- 0){Re6}} Ij -)

Ii - {(0 ){Re5} [0 0]{Re2} (- 0){Re6}} Ij -

Table 1: Interval-based constraints and their equivalent disjunctive metric constraints between
interval ending points (Cells in the second and fourth columns are a conjunctive set of constraints)

Symbolic
Constraint
(IA {d di} IB)



(IB {d di} IC)



(ID {m s} IA)



(ID {o} IB)



(ID {m s} IC)



Disjunctive Metric Constraint between I+ I-

Inconsistent-Label-Sets

IA - {(- 0){R1} [0 ){R3}} IBIA + {(0 ){R2} (- 0]{R4}} IB+
IB- {(- 0){R5} [0 ){R7}} IA IB+ {(0 ) {R6} (- 0]{R8}} IA +

{R4 R8 } {R3 R8 }
{R4 R7 } {R3 R7 }

IB- {(- 0){R9} [0 ){R11}} ICIB+ {(0 ) {R10} (- 0]{R12}} IC+
IC- {(- 0){R13} [0 ){R15}} IBIC+ {(0 ) {R14} (- 0]{R16}} IB+
+
ID {[0 0]{R17} (0 ){R18} (- 0){R19}} IA ID- {[0 0]{R20} (0 ){R22} (- 0){R23}} IA ID+ {(0 ){R21} (- 0]{R24}} IA +
ID+ {(- 0){R0}} IBID+ {(0 ){R0}} IB+
ID- {(0 ){R0}} IBID+ {[0 0]{R25} (0 ){R26 (- 0){R27}} ICID- {[0 0]{R28} (0 ){R30} (- 0){R31}} ICID+ {(0 ){R29} (- 0]{R32}} IC+

{R12 R16 } {R11 R16 }
{R12 R15 } {R11 R15 }
{R19 R24 } {R18 R24 } {R19 R23 }
{R18 R23 } {R19 R22 } {R18 R22 }

{R27 R32 } {R26 R32 } {R27 R31 }
{R26 R31 } {R27 R30 } {R26 R30 }

Table 2: Symbolic constraints in Figure 11.a by means of disjunctive metric
constraints between I+, I-

64

fiBARBER

Figure 11.a represents a path-consistent IA-TCN, which has inconsistent values in constraints
(Allen, 1983). In Table 2, we have the interval-based symbolic constraints for this example, the
corresponding disjunctive metric constraints between their ending time -points (Ii +, Ii -) and the
corresponding set of I-L-Sets (according to Table 1). Moreover, we also have:
(IA -{(0 ){R0}}IA +), (IB-{(0 ){R0}}IB+), (IC-{(0 ){R0}}IC+ ) and (ID- {(0 ){R0}}ID+).

When all these metric constraints among the ending time-points of intervals are updated according
the proposed methods in Section 4, the labeled minimal TCN in Table 3 is obtained. The associated
labels to each elemental constraint (disjunct) in constraints are not included for reasons of brevity.

D

D
{s,m}
A

{s,m}

{o}

{d, di}

A

B

{d,di}

{d, oi, f, e, fi,
si, s, o , di}

{o}

{d, di}

B

{d,di}

{s,m}

{s,m}
{d, di, s, si, e}

C

a) Path-Consistent IA-TCN

C

b) Minimal IA-TCN

Figure 11: Path-Consistent and equivalent Minimal IA-TCN

IA+
IA+

IA-

IB+

{(- 0)}

{(0 ),
(- 0)}
{(0 )}

IA-

{(0 )}

IB+

{(- 0), {(- 0)}
(0 )}

IB-

{(0 )}

{(0 ),
(- 0)}

IB-

{(0 )}

{[0 0],
(0 )}

{(- 0),
(0 )}
{(- 0)}

{(0 )}

{(0 )}

IC-

ID+

ID-

{(- 0)} {(- )} {(- 0)} {(- 0)} {(- 0)}
{(0 )}

{(- 0), {[0 0], {(- 0),
[0 0],
(0 )}
[0 0]}
(0 )}
{(- 0), {(- 0)} {(- 0)} {(- 0)}
(0 )}
{(0 )}

IC+ {(- )} {(- 0)} {(- 0), {(- 0)}
(0 )}
IC
{(0 )} {(- 0), {(0 )} {(- 0),
[0 0],
(0 )}
(0 )}
ID+ {(0 )} {(- 0), {(0 )} {(- 0)}
[0 0]}
ID-

IC+

{(0 )}

{(- 0),
(0 )}

{(0 )}

{(- 0)}

{(- 0)} {(- 0)} {(- 0)}
{(0 )}

{(0 ),
[0 0]}

{(0 )}

{(- 0),
[0 0]}

{(0 )}

{[0 0],
(0 )}

{(- 0),
[0 0]}
{(- 0)}

{(0 )}

Table 3: The minimal metric point-based TCN of the IA-TCN in Figure 11.a
65

fiREASONING ON INTERVAL AND POINT -BASED DISJUNCTIVE M ETRIC CONSTRAINTS IN TEMPORAL CONTEXTS

Allen (1983) remarks that the symbolic constraint (IA {f fi} IC) cannot hold given the existing
constraints between IA, IB, IC and ID. In the labeled point-based TCN, (IA {f fi} IC) is represented
by a set of constraints among ending points of IA and IC. Moreover, the labels associated to each
labeled elemental constraint allow us to determine whether a set of elemental constraints between
different pairs of time-points can be part of a global solution (Theorem 10). Thus, we can deduce
whether (IA {f fi} IC) can hold in the point-based TCN.
The existing constraints between the ending time-points of IC and IA, with their associated labelsets are:
IC+ {(- ){R25 R30 R29 R17 R22 R21 R0){R27 R28 R29 R19 R20 R21 R0},
(- 0){R27 R28 R29 R17 R22 R21 R9 R10 R15 R16 R1 R2 R7 R0 R8},
(0 ){R25 R30 R29 R19 R20 R21 R11 R12 R13 R14 R3 R4 R5 R0 R6}} IA+
IC-

{(0 ){R27 R28 R29 R17 R22 R21 R9 R10 R15 R16 R1 R2 R7 R8 R0},
[0 0] {R25 R30 R29 R17 R22 R21 R0}{R27 R28 R29 R19 R20 R21 R0},
(- 0){R25 R30 R29 R19 R20 R21 R11 R12 R13 R14 R3 R4 R5 R6 R0}} IA-

Let's ask for each disjunct in (IA {f fi} IC):
i) The constraint (IA {f} IC) implies (IC+ {[0 0]} IA+)  (IC- {(- 0)} IA-). According to
Theorem 10, these constraints hold iff the set-union of the label sets associated to (IC+ [0 0]
IA+) and to (IC- (- 0) IA-) is not an I-L-Set. We have two possibilities:
i.1) {R25 R30 R29 R17 R22 R21 R0 }  {R25 R30 R29 R19 R20 R21 R11 R12 R13 R14 R3 R4 R5 R6 R0 } =
{R6 R5 R4 R3 R20 R19 R25 R30 R29 R17 R22 R21 R11 R12 R13 R14 R0 }, or
i.2)

{R27 R28 R29 R19 R20 R21 R0 }  {R25 R30 R29 R19 R20 R21 R11 R12 R13 R14 R3 R4 R5 R6 R0 } =
{R14 R13 R12 R11 R30 R25 R27 R28 R29 R19 R20 R21 R3 R4 R5 R0 R6 }.

However, both label sets (i.1, i.2) are I-L-Sets: For instance, {R19 R22 } and {R27 R30 } are I-LSets (Table 2) and they are subsets of i.1 and i.2, respectively. Thus, (IA {f} IC) does not hold.
ii) The constraint (IA {fi} IC) implies (IC+ {[0 0]} IA+)  (IC- { (0 )} IA-). Similarly:
ii.1) {R25 R30 R29 R17 R22 R21 R0 }  {R27 R28 R29 R17 R22 R21 R9 R10 R15 R16 R1 R2 R7 R8 R0 } =
{R16 R15 R10 R9 R28 R27 R25 R30 R29 R17 R22 R21 R1 R2 R7 R0 R8 }.

This label set is an I-L-Set. For instance, {R30 R27 } is an I-L-Set. Also,
ii.2) {R27 R28 R29 R19 R20 R21 R0 }  {R27 R28 R29 R17 R22 R21 R9 R10 R15 R16 R1 R2 R7 R8 R0 } =
{R8 R7 R2 R1 R22 R17 R27 R28 R29 R19 R20 R21 R9 R10 R15 R16 R0 }.

Both these label sets (ii.1, ii.2) are also I-L-Sets. For instance, {R 30 R27} and {R19 R22 } are I-LSets. Thus, (IA {fi} IC) does not hold either.
In conclusion, the symbolic constraint (IA {f fi} IC) cannot hold on the globally labeled-consistent
point-based TCN. This conclusion could be also obtained from a minimal IA-TCN (Figure 11.b).
Additionally, we have that (IA {f fi} IC) implies (IA+ [0 0] IC+). That is, if the constraint (IA+ [0 0]
IC+) holds, we have that the associated constraints to the label sets {R25 R30 R29 R17 R22 R21 R0 } or
{R27 R28 R29 R19 R20 R21 R0 } should also hold. Each one of these label sets implies (IC - {[0 0]} IA-).
That is: (IA+ [0 0] IC+)  (IC- {[0 0]} IA-). Thus, the only way that (IA+ [0 0] IC+) can hold is if (IA
{e} IC) holds. These relations will be detailed in Section 6.
66

fiBARBER

5.2 Metric Constraints on Intervals
Metric constraints between intervals can also be managed in the described temporal model. From a
general point of view, metric information can be added to each elemental interval-based constraint
in a standard way (Table 4). These metric constraints on interval boundaries (Table 4) are similar to
the ones proposed by Staab and Hahn (1998).
IA Symbolic
Elemental
Constraints

IA Metric Elemental Constraints
cij  {[dm1 dM1 ], [dm2 dM2 ], ..... [dmn dMn ]}
c'ij  {[dm 1 dM1 ], [dm 2 dM2 ], ..... [dm n dMn ]}
Ii

Ii before Ij

Ii (before cij ) Ij

Ii meets Ij

Ii (meets c ij ) Ij

Ii during Ij

Ii (cij during c'ij ) Ij

Ii starts Ij

Ii (starts c ij ) Ij

Ii finishes Ij

Ii (finishes cij ) I j

C

ij

Ij

Ii
Cij

Ij

Ii

C' ij

C
ij

Ij
Ii
C
ij

Ij
Ii

C
ij

Ij
Ii

Ii overlaps Ij

Ii (overlaps cij ) Ij

Cij

Ij

Ii

Ii equal Ij

Ii (cij equal c'ij ) Ij

C
ij

C'

ij

Ij

Table 4: Metric interval constraints on interval boundaries
Obviously, the metric constraints of Table 4 can be managed in the proposed model, by means
of metric constraints on interval ending points. Thus, symbolic constraints of Interval Algebra can
be extended in this way to metric domain. However, since each interval is represented by means of
its ending time-points, more flexible metric constraints on intervals can be represented by means of
metric constraints on their ending time-points. In this way, the described model also subsumes the
Interval Distance Sub Algebra model proposed by Badaloni and Berati (1996). Moreover, ending
points of intervals can also be related to the initial time-point T0 , and unary metric constraints on
interval durations can be expressed by means of metric constraints between the two ending points of
each interval:
dur (Ii ) = {[dm1 dM1 ], [dm2 dM2 ], ..... [dmn dMn ]} 
(Ii - {[dm1 dM1 ], [dm2 dM2 ], ..... [dmn dMn ]} Ii +).

67

fiREASONING ON INTERVAL AND POINT -BASED DISJUNCTIVE M ETRIC CONSTRAINTS IN TEMPORAL CONTEXTS

-

[ I1 ]

-

[ I1 ]

30
60

T0

I1

I1+

[

]

20
I2
[

50

]

{[140 150], [200 210]}

Figure 12: Metric constraints between intervals
Thus, following constraints (Figure 12):
(I1 {b, o} I2)  (I1- is [[20 30], [50 60]} before I2-)  (I2- is {[140 150], [200 210]} after T0 )
can be represented as (Table 1):
By default: (I1 - { (0 ){R0}} I1+), (I2- { (0 ){R0}} I2+), and
(I1 {b, o} I2)



(I1+ {(0 ){Rb1} (- 0]{Rb2}} I2-),

(I1+ {(- 0){Ro1} [0 ){Ro4}} I2-),

(I1+ {(0 ){Ro2} (- 0]{Ro5}} I2+),

(I1- {(0 ){Ro3} (- 0]{Ro6}} I2-),



(I1- is [[20 30], [50 60]} at the left of I2-)
(I2- is {[140 150], [200 210]} after T0 )



(I1- {[50 60]{R1} [20 30]{R2}} I2-),
(T0 {[140 150]{R3} [200 210]{R4}} I2- ),

and {Rb2 Ro4 }, {Rb2 Ro5 }, {Rb2 Ro6 }, {R1 R2 } and {R3 R4 } are I-L-Sets.

6. Reasoning on Logical Expressions of Constraints
In the described model, each disjunct in an input constraint is univocally associated to a label.
Moreover, the label set associated to each derived elemental constraint represents the support-set of
input elemental constraints from which the elemental constraint is derived. I-L-Sets represent
inconsistent sets of input elemental constraints. By reasoning on labeled disjunctive constraints,
associated label lists and I-L-Sets, the temporal model offers the capability of reasoning on logical
expressions of elemental constraints belonging to disjunctive constraints between different pairs of
time points. Let's assume the following labeled input constraints:
(ni lc ij nj )  (ni {(lecij.1 ){Rij.1} (lecij.2 ) {Rij.2} .....(lecij.p ) {Rij.p}} nj ),
(nk lc kl nl )  (nk {(leckl.1 ) {Rkl.1} (leckl.2 ) {Rkl.2} .....(leckll.q ) {Rkl.q}} nl )
i) To represent that two elemental constraints 4 (elc ij.x lc ij , elckl.ylc kl ) cannot hold simultaneously
(that is (elc ij.x  elc kl.y )) the label set {Rij.x Rkl.y } should be added to the set of I-L-Sets.
ii) To represent a logical dependency between two elemental constraints, such as 'If lec ij.x then
leckl.y' (where lecij.xcij , leckl.yckl ), the Cartesian product {Rij.x}  {{Rkl.1 , Rkl.2 , ....., Rkl.q }{Rkl.y }} should be added to the set of I-L-Sets.
iii) To represent that two elemental constraints (elc ij.xlcij , elckl.y lc kl ) should hold simultaneously
(bi-directional logical dependency), the Cartesian products {Rij.x}  {{Rkl.1 , Rkl.2 , ....., Rkl.q }4

For reasons of simplicity, only two elemental constraints are shown. However, more than two disjunctions can be managed
in a similar way. Likewise, these features can be also applied to labeled derived constraints.

68

fiBARBER

{Rkl.y }} and {Rkl.y }  {{Rij.1 , Rij.2 , ....., Rij.p }-{Rij.x}} should be added to the set of I-L-Sets.
For instance, lets see the Example 2 of Section 4.4 (Figure 10):
 To represent that John goes to work by car and Fred goes to work walking is not possible,
{R1 R5 } should be asserted as an I-L-Set.
 To represent that if John goes to work by car then Fred goes to work walking, {R1 R3 } and
{R1 R4 } should be asserted as I-L-Sets.
 To represent that if John goes to work by car then Fred goes to work walking, and vice versa,
{R1 R3 }, {R1 R4 } and {R5 R2 } should be asserted as I-L-Sets.
In a similar way, logical relations among point-based and interval-based elemental constraints can
also be represented. For instance, the logical dependence "the duration of I1 is [5 8] if I2 is before I3
and the duration of I 1 is [12 15] if I2 is after I3" can be represented as:
(I2 {b, bi} I3 ) 

(I2 + {(0 ){Rb9} (- 0]{Rb10}} I3 -),
{Rb10 Rb12 } is an I-L-Set,

(I3 + {(0 ){Rb11} (- 0]{Rb12}} I2 -),

(I1 - {[5 8] {R1} [12 15] {R2}} I1 +),
and {R1 Rb11 }, {R2 Rb9 } are I-L-Sets, since Rb11 is associated to I2 is after I3  and Rb9 is associated
to I2 is before I3 . Likewise, "I1 starts at the same time as I 2 if t1 occurs after t2" can be represented
as (see Table 1):
I1 {s, s} I2  (I1 - {[0 0] {Rs1} (0 ){Rs3} (- 0){Rs4}} I2 -) , (I1 + {(0 ){Rs2} (- 0]{Rs5}} I2 +) ,
(t1 {(- -1] {R1}, [0 0] {R2}, [1 ){R3}} t2 ),
and {R3 Rs3 }, {R3 Rs4 }, and {R3 Rs5 } are I-L-Sets, since R3 is associated to 't1 occurs after t2 ' and Rs3 ,
Rs4 and Rs5 are associated to 'I1 does not start at the same time as I2 '.
6.1 Disjunctions of Point and Interval-Based Constraints
Disjunctions of constraints between different pairs of points and intervals can be represented in the
proposed model by means of labeled constraints between points and a set of I-L-Sets. This subsumes
the related expressiveness in the subset of disjunctive linear constraints proposed by Stergiou and
Koubarakis (1998), where only disjunctions of constraints between different pairs of points are
managed.
To represent a disjunctive set of disjunctive constraints between points, we have5 :
(ni lc ij nj )  (nk lc kl nl ) can be represented as: (ni {lc ij lc ij } nj )  (nk {lc kl lc kl } nl ),
and some logical relation among lc ij , lc ij , lc kl and lc kl. Thus, the disjunctive set of constraints:
{(ni lc ij nj )  (nk lc kl nl )} 
{(ni {(lecij.1 ){Rij.1}, (lecij.2){Rij.2}, ...., (lecij.p ){Rij.p}} nj ) 
(nk {(leckl.1 ){Rkl.1}, (leckl.2 ){Rkl.2}, ...., (leckj.q ){Rkl.q}} nl )}
5

For reasons of simplicity, only two constraints are shown. However, more than two disjunctive constraints can be managed
in a similar way.

69

fiREASONING ON INTERVAL AND POINT -BASED DISJUNCTIVE M ETRIC CONSTRAINTS IN TEMPORAL CONTEXTS

can be represented as:
i) A conjunctive set of constraints between (ni , nj ) and between (nk , nl ), where, (lecx) can be
represented by means of the complementary domain of (lecx):
(ni {(lecij.1 ){Rij.1}, (lecij.2 ){Rij.2}, ...., (lecij.p ){Rij.p}, {(lecij.1 ){Rij.1}, (lecij.2 ){Rij.2}, ...., (lecij.p ){Rij.p}}} nj ) 
(nk {(leckl.1 ){Rkl.1}, (leckl.2 ){Rkl.2}, ..., (leckj.q ){Rkl.q}, {(leckl.1 ){Rkl.1}, (leckl.2 ){Rkl.2}, ..., (leckj.q ){Rkl.q}}} nl )
{(ni {(lecij.1 ){Rij.1}, (lecij.2 ){Rij.2}, ..., (lecij.p ){Rij.p}, (lecij.1 ){R'ij.1}, (lecij.2 ){R'ij.2}, ..., (lecij.p){R'ij.p}} nj ) 
(nk {(leckl.1){Rkl.1}, (leckl.2 ){Rkl.2}, .., (leckj.q ){Rkl.q}, (leckl.1 ){R'kl.1}, (leckl.2){R'kl.2}, ..., ( leckl.q ){R'kl.q} } nl )}
ii) A set of I-L-Sets to represent the mutually exclusive disjunction of lc ij and lc kl (they cannot
simultaneously hold):
ii.a) One of the constraints lc ij or lc kl should hold: The Cartesian product of label sets from
complementary domains of lc ij and lc kl , {R'ij.1 , R'ij.2 , ...., R'ij.p }{R'kl.1 , R'kl.2 , ...., R'kl.q },
are I-L-Sets.
ii.b) Only one of the constraints lc ij or lc kl should hold: The Cartesian product of label sets
from lc ij and lc kl , {Rij.1 , Rij.2 , ...., Rij.p }{Rkl.1 , Rkl.2 , ...., Rkl.q } are I-L-Sets.
Thus, disjunctive and conjunctive sets of disjunctive constraints between points can be represented
and managed by means of a conjunctive set of disjunctive constraints and a set of I-L-Sets. For
example:
(ti {[5 5] {R1} [10 10] {R2}} tj )  (tk {[0 0] {R3} [20 20] {R4}} tl ) 
(ti {[5 5] {R1} [10 10] {R2} (- 5){R5} (5 10) {R6} (10 ){R7}} tj ) 
(tk {[0 0] {R3} [20 20] {R4} (- 0){R8} (0 20) {R9} (20 ){R10}} tl ),
and
(ii.a) since (ti {[5 5] {R1}, [10 10] {R2}} tj ] or [tk {[0 0] {R3}, [20 20] {R4}} tl ] should hold:
{R5 R6 R7 }{R8 R9 R10 } are I-L-Sets,
(ii.b) since only one constraint (t i {[5 5]{R1} [10 10] {R2}} tj ) or (tk {[0 0] {R3} [20 20]{R4}} tl ) should
hold:
{R1 R2 }{R3 R4 } = {R1 R3 }, {R1 R4 }, {R2 R3 }, {R2 R4 } are I-L-Sets.
Ii  ecij Ij

Ii ecij Ij

Ii ecij Ij

I1 before I2

I1 {(0 ){Rb1}} I2

I3 before I4

I3 + {(0 ){Rb3}} I4 -

+

-

Ii (ecij   ecij) Ij
-

I1 {(0 ){Rb1} (- 0]{Rb2}} I2 -

I3 + {(- 0]{Rb4}} I4 -

I3 + {(0 ){Rb3} (- 0]{Rb4}} I4 -

+

I1 {(- 0]{Rb2}} I2

+

Table 5: Point-based constraints for (I1 before I2 ) and (I3 before I 4 )
Similarly, disjunctions of interval-based constraints between different pairs of intervals can also
be represented. For instance, from Table 1 and Table 5, {(I1 before I2 )  (I3 before I4)} can be
represented as:
(I1 + {(0 ){Rb1} (- 0]{Rb2}} I2 -), (I3 + {(0 ){Rb3} (- 0]{Rb4}} I4 -),

70

fiBARBER

and
a)

one of the constraints (I1 before I2) or (I3 before I4 ) should hold. Thus, the Cartesian product
of label sets associated to the disjunctive constraints in (Ii ecij Ij ) is a set of I-L-Sets: {Rb2 ,
Rb4 } is an I-L-Set,

b)

only one of the constraints (I1 before I2 ) or (I3 before I4 ) should hold. Thus, the label set
associated to the mutual fulfillment of constraints in (Ii ecij Ij ) is an I-L-Set: {Rb1 , Rb3 } is an
I-L-Set.

Thus:
{(I1 before I2 )  (I3 before I4 )} 
(I1 + {(0 ){Rb1} (- 0]{Rb2}} I2 -), (I3 + {(0 ){Rb3} (- 0]{Rb4}} I4 -),
and {Rb2 , Rb4 }, {Rb1 , Rb3 } are I-L-Sets.
Ii ecij Ij

Ii ecij Ij

Ii  ecij Ij

Ii (ecij   ecij) Ij

(I1 during I2 )

I1 - {(- 0){Rd1}} I2 -

(I1 - {[0 ){Rd3}} I2 -)

I1 - {(- 0){Rd1} [0 ){Rd3}} I2 -

I1 + {(0 ){Rd2}} I2 +
(I3 starts I4 )

I3 - {[0 0]{Rs1}} I4 I3 + {(0 ){Rs2}} I4 +



(I1 + {(- 0]{Rd4}} I2 +)

I1 + {(0 ){Rd2} (- 0]{Rd4}} I2 +

(I3 - {(0 ){Rs3} (- 0){Rs4}} I4 -) I3 - {[0 0]{Rs1} (0 ){Rs3} (- 0){Rs4}} I4 

(I3 + {(- 0]{Rs5}} I4 +)

I3 + {(0 ){Rs2} (- 0]{Rs5}} I4 +

Table 6: Point-based constraints for (I1 during I2 ) and (I3 starts I4 )
In a similar way (Table 6), (I1 during I2 )  (I3 starts I 4 ) 
(I1 - {(- 0){Rd1} [0 ){Rd3}} I2 -),

(I1 + {(0 ){Rd2} (- 0]{Rd4}} I2 +),

(I3 - {[0 0] {Rs1} (0 ){Rs3} (- 0){Rs4}} I4 -), (I3 + {(0 ){Rs2} (- 0]{Rs5}} I4 +),
and {Rd1 Rd2 Rs1 Rs2 } and the Cartesian product {Rd3 Rd4 } X {Rs3 Rs4 Rs5 } are I-L-Sets.
Therefore, logical relations on elemental constraints can be represented by a set of I-L-Sets. Thus,
a labeled TCN (and the set of I-L-Sets) can represent a special type of and/or TCN. These types of
non-binary constraints enrich the expressiveness of language and allow for the modeling of more
complex problems (Meiri, 1996). Stergiou and Koubarakis (1996) and Jonsson and Bckstrm (1998)
show that Disjunctions of Linear Constraints (DLR) are also able to represent these non-binary
constraints. However, Pujari and Sattar (1999) remark that general methods from linear programming
should then be applied for DLR management, such that specific temporal concepts (like the ones
detailed in Section 2) are not considered in these general methods. In the proposed model,
management of these non-binary constraints are performed by the proposed reasoning methods
without increasing their computational complexity. The added functionality is of interest in several
temporal reasoning problems, including planning, scheduling and temporal constraint databases
(Barber et al., 1994; Gerevini & Schubert, 1995; Brusoni et al., 1997; Stergiou & Koubarakis, 1998;
etc.) where no general solutions are provided in the specific temporal reasoning area.
In addition, the proposed reasoning algorithms obtain a globally labeled-consistent TCN
(Theorem 11). This feature allows us to manage hypothetical queries, which is an important
requirement in query processes on temporal constraint databases (Brusoni et al., 1997). Thus, queries
71

fiREASONING ON INTERVAL AND POINT -BASED DISJUNCTIVE M ETRIC CONSTRAINTS IN TEMPORAL CONTEXTS

such as Does c'ij hold, if c'kl? can be answered without any TCN propagation. The label set associated
to each derived elemental constraint represents the set of input elemental constraints that should hold
for the fulfillment of this elemental constraint. Therefore,
(xk c'kl xl)(xi c'ij xj )
holds, if elc kl.y lc kl / eckl.yc'kl then elc ij.xlc ij / ec ij.xc'ij and labels(elc ij.x)labels(elc kl.y ) hold.
For example, from the labeled minimal TCN in Figure 7, we have:
(T1 {[40 40]} T3 )  (T2 { [0 0] } T4 ),

(T3 { [20 20] } T2 )  (T3 { [20 20] } T4 ).

However, (T3 {[10 20]} T2 ) does not imply (T1 {[70 70]} T4 ). Similarly, questions such as Can
c'ij hold, if c'kl? can also be easily answered by applying Theorem 9 and Theorem 10.

7. Alternative Temporal Contexts
When we reason on temporal facts, we can simultaneously work on different alternative temporal
contexts, situations, trends, plans, intentions or possible worlds (Dousson et al., 1993; Garcia &
Laborie, 1996). This is usual in a branching (backward or forward) model of time. Here, we can have
alternative past contexts (i.e.: different lines about how facts may have occurred) or alternative future
contexts (i.e.: different lines about how facts may occur). Thus, temporal context management is also
required in hypothetical or causal reasoning. Also, having different contexts permits a partition of
the whole TCN in a set of independent chains in order to decrease the complexity problem size
(Gerevini & Schubert, 1995). In this section, we do not deal with hypothetical reasoning issues. Our
goal is temporal management of context-dependent constraints. Thus, in general, a hierarchy of
alternative temporal contexts can be established, such that constraints can be associated to different
temporal contexts. For instance, Figure 13 represents a hierarchy of alternative contexts, where W0
represents the root context and there are different disjunctive constraints between (n1 , n2 ) in each
context. Temporal reasoning algorithms detailed in this paper are able to manage these contextdependent constraints:
 Input disjunctive constraints are asserted in different temporal contexts. To do this, the labels
associated to input elemental constraints can also be used to represent the context in which the
disjunctive is asserted. For instance (Figure 13), if the constraint:
(n1 {[0 50] {R1}, [200 210] {R2}} n2 )
is asserted in context W1 , we have the following input context-dependent labeled constraint:
(n1 {[0 25] {R1, W1}, [260 280] {R2, W1}} n2 ).
Here, each context-dependent label set associated to each elemental constraint represents both
the alternative temporal disjunct (i.e.: R1 or R2 ) and the context in which the elemental
constraint is asserted (W1 ).
 Label sets associated to context-dependent derived elemental constraints will represent the
temporal contexts in which derived elemental constraints hold.
Definition 8. A context-dependent disjunctive constraint is a disjunctive constraint where each
elemental constraint (i.e.: disjunct) is associated to an alternative temporal context. The universal
labeled constraint is {(- ){W0 R0}}, where W0 is the root context. 
72

fiBARBER

The proposed reasoning processes can manage context-dependent disjunctive constraints in a way
similar to previously defined labeled disjunctive constraints (Section 3). For instance, according to
the constraints and contexts in Figure 13, the following input labeled constraints between nodes n1
n2 should be updated:
(n1 {[0 100] {R1 W0}, [200 300] {R2 W0}} n2 ),

(n1 {[0 50] {R3 W1}, [200 210] {R4 W1}} n2 ),

(n1 {[60 100] {R5 W 2} , [290 300] {R6 W2}} n2 ),

(n1 {[0 25] {R7 W3}, [260 280] {R8 W3}} n2 ),

(n1 { [0 25] {R0 W11}} n2 ),

(n1 { [30 50] {R9 W12}, [200 205] {R10 W12}} n2 ),

(n1 {[0 20] {R0 W31}, [210 215] {R0 W32}} n2 ),

(n1 {[260 280] {R0 W33}} n2 ).

More restricted constraints
Context W11

n1 {[0 25]} n 2

Context W1

n 1 {[0 50], [200 210]} n 2
Context W12

n 1 {[0 100], [200 300]} n 2

Context W2

n 1{[30 50], [200 205]} n 2

n1 {[60 100], [290 300]} n 2

Root-Context W0

Context W31

n 1{[0 20]} n 2
Context W3

n 1{[0 25], [260 280]} n 2

Context W32

n1{[210 215]} n

2

Context W33

n1{[260 280]} n

2

Assertion in Context k

Downward Propagation:
Propagation to contextk
and its successor contexts

Upward Consistency:
Consistency in contextk
and its predecessor contexts

Figure 13: A hierarchy of alternative contexts
The updating process of each new constraint cij in a given context Wp should assure the
consistency of c ij in the context Wp , as well as in its predecessor contexts (Figure 13). The consistency
of cij with the successor contexts of Wp will be detailed in Section 7.2, since several options can be
identified. However, it is not necessary to assure consistency among constraints belonging to contexts
of different hierarchies. Successor contexts of a given context represent different alternatives, which
are mutually exclusive. Thus, constraints belonging to contexts of different hierarchies can be
mutually inconsistent. However, this does not imply that constraints in these contexts should
necessarily be mutually disjoint. For instance (Figure 13), the constraints (n1 {[0 50] {R3 W1}, [200
210]{R4 W1}} n2 ) in context W1 and (n1 {[0 25] {R7 W3}, [260 280] {R8 W3}} n2 ) in context W3 are not
mutually disjoint. However, W1 , W2 and W3 are assumed as three mutually exclusive alternatives of
W0 .
73

fiREASONING ON INTERVAL AND POINT -BASED DISJUNCTIVE M ETRIC CONSTRAINTS IN TEMPORAL CONTEXTS

The closure process of each new constraint cij in context Wp should downward propagate the new
constraint cij to all its successor contexts (Figure 13). Moreover, no propagation should be performed
to the predecessor contexts of contextk , nor among contexts of different hierarchies. Elemental
constraints belonging to contexts of different hierarchies cannot be simultaneously considered, that
is, combined or intersected.
7.1 Context-Dependent Updating and Closure Processes
The update and closure processes defined in Section 4 should be adapted in order to manage contextdependent disjunctive constraints. The Context-Update process (Figure 14) asserts the constraint
cij {ec1 , ec2, ..., ecn } in the context contextk. In a way similar to the updated process described in
Section 4, Context-Update should be performed each time a new context-dependent constraint is
asserted.
Context-Update (ni cij nj contextk)
lc'ij  Put-label-context (cij , contextk )
;Labelling and mutual inconsistency.
If Consistency-Test (get-upward (ni , nj , contextk ), lc'ij )
;Upwards Consistency test
Then (*Inconsistent Constraint*)
Return (false)
Else (*Consistent Constraint*)
;lc'ij is asserted in the contextk and in all its
lc ij  (lc ij - get (ni , nj , contextk )) lc (lc ij  lc lc'ij ),
;successor contexts.
lc ji  Inverselc (lc ij ),
Context-Closure (ni lc ij nj contextk )
;Downwards Closure algorithm in contextk.
.
Return (true)
End-If
End-Context-Update
Figure 14: Context-Update process for context-dependent labeled constraints
Where:
 Put-label-context (cij , contextk ) associates an exclusive label set to each elemental constraint
ecij.p cij . This label set has two labels {Rij.p contextk }. In this label set, the first label is the
label associated to each temporal disjunct. In a way similar to Put-labels function, these labels
are mutually exclusive (Definition 3). The second label represents the context in which cij is
updated. Moreover, each pair of labels associated to successor contexts of the parent context
of contextk is added to the I-L-Sets, since all the successor contexts of a given context are
mutually exclusive:
contextp / contextp Succesor-Contexts(Parent-Context(Contextk )),
I-L-Sets  I-L-Sets  ({contextk }{contextp }).
Where Parent-Context(contextk ) and Successor-Contexts(contextk ) return the parent-context
and the set of successor-contexts of contextk , respectively. Thus, in Figure 13, {{W1 , W2 },
{W1 , W3 }, {W2 , W3 }, {W11 , W12 }, {W31 , W32 }, {W31 , W33 }, {W32 , W33 }} are I-L-Sets.
74

fiBARBER

 get (ni , nj , contextk ) returns the set of labeled elemental constraints between ni and nj in the
contextk (and in all its successor contexts). That is:
get (ni , nj , contextk )::= {(ecij.p {labelij.p })lc ij / contextk {labelij.p }}.
Note that get(ni , nj, contextk ) is a subset of lc ij . Thus, (lc ij - get (ni , nj , context k )) means the setdifference between lc ij and get (ni , nj , contextk ). That is, the set of elemental constraints in the
context-dependent constraint lc ij , which are not in contextk , nor in any of its successor contexts.


get-upward (ni, nj , contextk ), similarly to the previous get function, it returns the existing
constraints between ni and nj in the contextk (and in all its successor contexts). However, if
there is no constraint between ni and nj in the contextk , then the function returns the
constraints between ni and nj that exist in the predecesor context of contextk:
get-upward (ni, nj , contextk ) ::=
If get (ni , nj , contextk )   Then return (get (ni , nj , contextk ))
Else
Contextk  Parent-Context (Contextk )
Until get (ni , nj , contextk )    Contextk =W0 do
If get (ni , nj , contextk )   Then return (get (ni , nj , contextk ))
Else return({(- +)}{W0 R0}})
End-get-upward

The context-dependent closure (Figure 15) process is similar to the closure process described in
Section 4 and it is also performed at each updating process. The closure process of each updated
constraint in contextk is downwards performed in contextk and in all its successor contexts.

Context-Closure (ni lc ij nj contextk)
(* First loop: Closure n i  n j  n k *)
nk TCN / lc jk  {U{R0 W0}}:
lc'ik  lc ik lc (lc ij lc lc jk ),
lc ik  (lc ik - get (ni , nk , contextk )) lc lcij ,
lc ki  Inverse(lc ik)
(* Second loop: Closure n j  ni  nl *)
nl TCN / lc il  {U{R0 W0}}:
lc'jl  lc jl lc (Inverse(lc ij ) lc lc il ),
lc jl  (lc jl - get (nj , nl , contextk )) lc lc'jl ,
lc lj  Inverse(lc jl )
(* Third loop: Closure nl  ni  nj  nk *)
nl , nk TCN / lc lj  {U{R0 W0}}, lc jk  {U{R0 W0}}:
lc'lk  lc lk lc (lc li lc lc ij lc lc jk )
lc lk  (lc lk - get (nl , nk , contextk )) lc lc'lk ,
lc kl  Inverse(lc lk)
End-Context-Closure
Figure 15: Context-Closure process for context-dependent labeled constraints
75

fiREASONING ON INTERVAL AND POINT -BASED DISJUNCTIVE M ETRIC CONSTRAINTS IN TEMPORAL CONTEXTS

The resulting label set associated to each context-dependent derived elemental constraint represents
the contexts where the elemental constraint holds, as well as the hierarchy of predecessor contexts
of the elemental constraint. For instance, Figure 16 shows the contextual labeling for the example in
Figure 13. Moreover, after successively performing the updating and closure processes for all
constraints in this example, we have the following constraint between nodes n1 and n2 :
(n1 lc 12 n2 ): (n1 {[0 100] {R1 W0}, [200 300] {R2 W0}, [0 50] {R3 R1 W1 W0}, [200 210] {R4 R2 W1 W0},
(e3)
[60 100] {R5 R1 W2 W0}, [290 300] {R6 R2 W2 W0}, [0 25] {R7 R1 W3 W0}, [260 280] {R8 R2 W3 W0},
[0 25] {R0 R3 R1 W11 W1 W0}, [30 50] {R9 R3 R1 W12 W1 W0}, [200 205] {R10 R2 R4 W12 W1 W0},
[0 20] {R0 R7 R1 W31 W3 W0}, [210 215]{R0 R2 R8 W32 W3 W0}, [260 280]{R0 R2 R8 W33 W3 W0}} n2 )

{W0}

{W0 W1}

{W0 W1 W11}

{W0 W3}

{W0 W2}

{W0 W1 W12}

{W0 W 3 W 31}

{W0 W3 W32}

{W0 W 3 W33}

Figure 16: Labels in contexts
No closure process is performed among constraints belonging to contexts of different hierarchies.
According to Put-label-context function, each pair of labels related to the successor contexts of each
context is an I-L-Set. Thus, these I-L-Sets prevent deriving elemental constraints from contexts of
different hierarchies. That is, each derived elemental constraint obtained (combining or intersecting)
from two elemental constraints in contexts of different hierarchy will have an inconsistent associated
label set. Therefore, these derived elemental constraints will be rejected in the operation lc. For
instance, in the example of Figure 13, {{W1 , W2 }, {W1 , W3 }, {W2 , W3 }, {W11 , W12 }, {W31 , W32 },
{W31 , W33 }, {W32 , W33 }} are I-L-Sets. Thus, if a constraint is asserted in context W1 :
i) No propagation is performed using constraints in contexts W11 and W12 simultaneously,
since {W11 , W12 } is an I-L-Set.
ii) No propagation is performed in context W2 , nor in W3 , nor in their successors, since {W1 ,
W2 } and {W1 W3 } are I-L-Sets.
Let's see an example of the Context-Update and Context-Closure processes. Lets assume that the
context-dependent constraints in Figure 13 are already updated and closured, such that the previous
constraint lc 12 (expression e3) exists between n1 and n2 . Now, we update (n1 {[20 40]} n2 ) in context
W1 . The call to Consistency-Test function in the Context-Update function is:
Consistency-Test (get-upward (n1 , n2 , W1 ), {[20 40] {R0 W1}}).
Given the previous constraint lc 12 between n1 and n2 (expression e3), the function performs:
{[0 50] {R3 R1 W1 W0}, [200 210] {R4 R2 W1 W0}, [0 25] {R0 R3 R1 W11 W1 W0},
76

fiBARBER

[30 50] {R9 R3 R1 W12 W1 W0}, [200 205] {R10 R2 R4 W12 W1 W0}}  lc {[20 40]{R0 W1}}=
{[20 40] {R3 R1 R0 W1 W0}, [20 25] {R0 R3 R1 W11 W1 W0}, [30 40] {R9 R3 R1 R0 W12 W1 W0}}  
Thus, the new constraint (n1 {[20 40]} n2 ) is consistent in context W1 . Therefore, the constraint
between n1 n2 results:
lc12  (lc 12 - get (n 1 , n 2 , W 1 )) lc (lc 12 lc {[20 40]{R0 W1}}) =
{[0 100]{R1 W0}, [200 300] {R2 W0}, [60 100]{R5 R1 W2 W0}, [290 300]{R6 R2 W2 W0},
[0 25]{R7 R1 W3 W0}, [260 280]{R8 R2 W3 W0}, [0 20]{R0 R7 R1 W31 W3 W0},
[210 215]{R0 R2 R8 W32 W3 W0}, [260 280]{R0 R2 R8 W33 W3 W0}} lc
{[20 40]{R1 R0 W1 W0}, [20 40]{R3 R1 R0 W1 W0}, [20 25]{R0 R3 R1 W11 W1 W0}, [30 40]{R9 R3 R1 R0 W12 W1 W0}}=
{[0 100]{R1 W0}, [200 300] {R2 W0}, [60 100]{R5 R1 W2 W0}, [290 300]{R6 R2 W2 W0}, [0 25]{R7 R1 W3 W0},

(e4)

[260 280]{R8 R2 W3 W0}, [0 20]{R0 R7 R1 W31 W3 W0}, [210 215]{R0 R2 R8 W32 W3 W0}, [260 280]{R0 R2 R8 W33 W3 W0},
[20 40]{R1 R0 W1 W0}, [20 25]{R0 R3 R1 W11 W1 W0}, [30 40]{R9 R3 R1 R0 W12 W1 W0}}.

Note that the new updated constraint is asserted in context W1 and propagated to all its successor
contexts (W11 and W12 ). However, the new constraint in context W1 does not affect the existing
constraints in predecessor contexts of W1 (W0) nor the constraints belonging to contexts of different
hierarchies (W2 , W3 and their successors).
In this update process, no closure process is performed, since no node is related with n1 or n2 .
Now, lets update (n3 {[10 20]} n1 ) in context W1 . We have:
Consistency-Test (get-upward (n3 , n1 , W1 ), {[10 20] {R0 W1}}),
that performs:
{(- +)}{W0 R0}  lc {[20 40] {R0 W1}} = {[20 40] {R0 W0 W1}}  ,
since no previous constraint exists between (n3 n1 ) in context W1 . The constraint (n3 {[10 20]} n1 ) is
consistent, and asserted in the TCN:
lc 31  {(- +)}{W0 R0}, [20 40] {R0 W0 W1}}.
(e5)
Afterwards, this constraint is closured. The call to Context-Closure process is:
Context-Closure (n3 , {(- +)}{W0 R0}, [20 40] {R0 W0 W1}}, n1 , W1 ).
In this closure process, only the first loop is performed since no node is related to n3 . Moreover,
only the previous constraint lc 12 (expression e4) exists in the current TCN between n1 and n2 . Thus,
the first loop performs:
lc'32  lc 32 lc ({(- +)}{W0 R0}, [20 40] {R0 W0 W1}} lc lc 12 ) =
{(- ){W0 R0}}  lc ({(- +)}{W0 R0}, [20 40] {R0 W0 W1}} lc lc 12 ) =
{(- +)}{W0 R0}, [220 340] {R2 R0 W0 W1}, [40 80] {R1 R0 W1 W0},
[40 65] {R0 R3 R1 W11 W1 W0}, [50 80] {R9 R3 R1 R0 W12 W1 W0}},
such that,
lc 32  (lc 32 - get (n3 , n2 , W1 )) lc lc'32 = ({(- ){W0 R0}} - {}) lc lc'32 =
{(- ){W0 R0}, [220 340] {R2 R0 W0 W1}, [40 80] {R1 R0 W1 W0},
[40 65] {R0 R3 R1 W11 W1 W0}, [50 80] {R9 R3 R1 R0 W12 W1 W0}}.
77

(e6)

fiREASONING ON INTERVAL AND POINT -BASED DISJUNCTIVE M ETRIC CONSTRAINTS IN TEMPORAL CONTEXTS

Thus, the asserted constraint between (n3 , n2 ) in context W1 is closured in the context W1 and in
all its successor contexts (W11 and W12 ). Likewise, the closure process does not perform any
propagation simultaneously using constraints of the contexts W11 and W 22 , nor any of the context W2 ,
W3 , nor any of their successors.
7.2 Complete Versus Incomplete Partition of Contexts
In each updating process, the consistency of each new constraint lcij in a given context is assured in
this context and in all its parent contexts. Lets deal with consistency issues between a context and
its successor contexts. Here, we have that constraints in a given context Wi can be either completely
covered or only partially covered by the existing constraints in the successor contexts of Wi . That is,
the successor contexts of Wi can be either a complete partition or only a partial partition of Wi .
For instance, let's assert the constraint (n1 {[210 210] {R0 W1}} n2 ) in the context W1 of the example
in Figure 13. In the Consistency-test function, we have (where the constraint lc 12 is the previous
expression e2):
get-upward (n 1 , n 2 , W 1 ) lc {[210 210]{R0 W1}} =
{[0 50]{R3 R1 W1 W0}, [200 210]{R4 R2 W1 W0}, [0 25]{R0 R3 R1 W11 W1 W0}, [30 50]{R9 R3 R1 W12 W1 W0},
[200 205]{R10 R2 R4 W12 W1 W0}} lc {[210 210]{R0 W1}} = {[210 210]{R0 W1 R4 R2 W0}}.

That is, the asserted constraint is consistent with the existing constraints in context W1 . However,
no resulting elemental constraint is associated to context W11 nor W12 . This means that the asserted
constraint (n1 {[210 210] {R0 W1}} n2 ) is consistent in W1 , but is inconsistent in W11 and in W12 . Here,
two alternatives appear:
i) To assume that existing successor contexts are a complete partition of their parent context.
Therefore, a new constraint cij in a context Wi should be rejected, if cij is inconsistent in all
successor contexts of Wi. For instance, we can assume that W11 and W12 in Figure 13 are a
complete partition of W1 . Thus, (n1 {[210 210] {R0 W1}} n2 ) should be rejected.
ii) To assume that successor contexts are not a complete partition of their parent context. Therefore,
successor contexts become inconsistent and they should be removed. In the example, we can
assume that contexts W11 and W12 are not a complete partition of the context W1 , such that
another possible new successor context of W 1 would be able to match in the future the asserted
constraint (n1 {[210 210] {R0 W1}} n2 ). In this case, the constraint (n1 {[210 210] {R0 W1}} n2 ) is
assumed to be correct, such that it can be asserted in the TCN. Therefore, the contexts W11 and
W12 become inconsistent. {W11 } and {W12 } should be added to the set of I-L-Sets, such that
these contexts (and all their successor contexts and all their constraints) become inconsistent and
removed from the TCN. That is, all elemental constraints with an associated label set containing
{W11 } or {W12 } should be removed.
In both cases, each context will always be consistent with all its successor contexts. The option
to be adopted can depend on the problem type to solve (Garrido et al., 1999). Any of the these options
can be easily introduced in the described reasoning processes, since the function Consistency Test
can determine which successor contexts (Ws ) become inconsistent at each new constraint (lcij ) in
a context (Wk ):
78

fiBARBER

Ws Successor-Contexts(Wk ) / elc ij.p get-upward (ni , nj , Wk ), Ws{labelij.p } 
elc ij.r(get-upward (ni , nj , Wk ) lc lcij ), Ws{labelij.r}.
On the other hand, when: (i) the successor contexts (Wk1 , Wk2 , ..., Wkp ) of a context Wk are a
complete partition of it, and (ii) all constraints in (Wk1 , Wk2 , ..., Wkp ) have been asserted, then
constraints in Wk can be restricted according to the final existing constraints in (W k1 , Wk2 , ..., Wkp ).
To do this, the context Wk should be constrained by the temporal union of the constraints in all its
successor contexts.
7.3 A Minimal and Consistent Context-Dependent TCN
Definition 9. A context-dependent TCN is minimal (and consistent) if the constraints in each context
are consistent (with respect to constraints in this context, in all its predecessor contexts, and all its
successor contexts) and minimal (with respect to constraints in this context and in all its predecessor
contexts). 
Theorem 12. At each updating process, the context-dependent reasoning processes obtain a minimal
(and consistent) context-dependent TCN if the previous context-dependent TCN is minimal.
Proof: If the previous context-dependent TCN is minimal, the Consistency-Test function guarantees
the consistency of each new context-dependent input constraint:
i)

in its context and in all its parent contexts (get-upward function and Theorem 5),

ii)

in all its successor contexts (depending of the two identified cases in Section 7.2).

The closure process of a new constraint in a given context (Wk ) propagates its effects to this
context and to all its successor contexts. Therefore (Theorem 7), the process obtains the new minimal
constraints in this context (Wk ) and in all its successor contexts. 
Moreover, the obtained context-dependent TCN is globally labeled-consistent. Thus, we can
deduce whether a set of elemental constraints (between different pairs of time points) is consistent
(Theorem 10). That is, this set of elemental constraints holds in some context. For instance, given the
previous constraints lc 12 , lc 31 and lc 32 (previous expressions e4, e5 and e6), we can deduce that:
(n1 {[40 40]} n2 )  (n3 {[40 40]} n1 )  (n3 {[40 40]} n2 )
is full consistent since:
elc 12.xlc 12 , elc 31.y lc 31 , elc 32.zlc 32 / ({label12.x}  {label12.x}  {label12.x}) is not an I-L-Set.
Specifically, these instantiations hold in {R1 R0 W1 W0 } and {R1 R0 W0 }. Thus, this set of
elemental constraints holds in context W1 (and, obviously, in all its predecessor contexts).
Likewise, from a minimal context-dependent TCN, the user can retrieve the constraints that hold
in each context or the constraints that simultaneously hold in a set of given contexts. To do this, the
Context-Constraints function retrieves the constraints that hold between a pair of nodes (ni , nj ) in a
given context (contextk ). That is, the result of Get-upwards(ni , nj , contextk ) except those elemental
constraints belonging to successor contexts of contextk :

79

fiREASONING ON INTERVAL AND POINT -BASED DISJUNCTIVE M ETRIC CONSTRAINTS IN TEMPORAL CONTEXTS

Context-Constraints (ni, nj, contextk )::= Get-upwards (ni , nj , contextk ) 
{lecij.p lc ij / contextqSuccesor-Contexts(contextk ), {contextq }{labelij.p }}.
For instance, given the context-dependent constraint lc 12 in Figure 13 (expression e3), the
following constraint would hold between (n1 , n2 ) in both contexts W1 and W3 :
Context-Constraints(n 1 , n 2 , W1 ) lc Context-Constraint(n 1 , n 2 , W 3 ) =
{[0 50]{R3 R1 W1 W0}, [200 210]{R4 R2 W1 W0}} lc {[0 25]{R7 R1 W3 W0}, [260 280]{R8 R2 W3 W0}}=
{[0 25]{R7 R3 R1 W3 W1 W0}}6 .

In addition, we can obtain the constraints, which simultaneously hold in a context and in any of
its successor ones. For instance, in context W1 and in any of its successor contexts (W11 , W12), the
following constraint holds:
Context-Constrains(n1 , n2 , W1) lc [Context-Constraints(n1, n 2 , W11 ) lc Context-Constraints(n 1 , n2 , W12 )]=
{[0 50]{R3 R1 W1 W0}, [200 210]{R4 R2 W1 W0}} lc
{[0 25]{R0 R3 R1 W11 W1 W0}}lc {[30 50] {R9 R3 R1 W12 W1 W0}, [200 205]{R10 R2 R4 W12 W1 W0}}=
{[200 205]{W12 R10 R4 R2 W1 W0}, [0 25]{W11 R0 R3 R1 W1 W0}, [30 50]{W12 R9 R3 R1 W1 W0}}.

On the other hand, each alternative context (Wi ) can be associated to an alternative hypothesis
(Hi ). Each hypothesis Hi gives rise to a set of constraints, which will be asserted in the associated
context Wi . Thus, the proposed reasoning processes assure minimal constraints in the hierarchy of
hypotheses. Moreover, if a hypothesis (Hi ) becomes unavailable, then the label set {Wi } should be
added to the set of I-L-Sets. Thus, all constraints in context Wi (and in all its successor contexts) will
be removed. That is, all constraints that depend on the unavailable hypothesis Hi will be removed.
7.4 Computational Complexity of Temporal Context Management
The management of temporal context does not increase the complexity of the reasoning processes
detailed in Section 4. In fact, we can consider that each label associated to a disjunct (Ri ) in labeled
disjunctive constraints is also associated to a context (Wi ). Thus, the computational cost of each
updating process is also bounded by O(n2 l2e), where 'l' is the maximum number of input disjuncts
between any pair of nodes in all contexts.
The temporal labeled algebra proposed in this paper (Section 3) has been applied on the pointbased disjunctive metric constraints (Dechter, Meiri & Pearl, 1991). However, this labeled algebra
can also be applied on other temporal constraints. In this case, the operations  lc,  lc, lc and  lc
should be specified (Section 3) on the basis of the operations , , T and T of the underlying
algebra. In this way, the management of temporal contexts can also be applied to other types of
constraints.
Theorem 13. The computational complexity of the proposed reasoning process applied to contextdependent non-disjunctive metric constraints is polynomial (O(n2 W2)) in the number W of managed
contexts.
6

However, note that this is an impossible situation, since W 1 and W 3 are mutually exclusive contexts. That is, {W 3, W 1}
is an I-L-Set.

80

fiBARBER

Proof: Disjunctions in constraints are only related to the contexts in which input constraints are
asserted, if non-disjunctive constraints are managed. That is, constraints between each pair of nodes
are in the form:
(ni {(ec ij.0 {W0 R0 }), (ec ij.1 {W1 R0 }), ...... , (ecij.k {Wk R0 })} nj ) ,

0kW / W=|{Wi }|

Thus, the maximum number of disjuncts in constraints is bounded by the maximum number of
managed contexts W. Moreover, the maximum length of associated label sets is the maximum depth
in the hierarchy of contexts, and the set of I-L-Sets has only 2-length sets (i.e.: pairs of labels
associated to each pair of successor contexts of each context). Therefore, the computational cost of
operations lc and  lc is bounded by O(W2 ). 
The methods proposed in Section 7.1 for management of temporal contexts can also be applied
to other temporal reasoning algorithms, instead of the reasoning methods detailed in Section 4. This
requires that these other reasoning algorithms be based on the operations of composition and
intersection of temporal constraints. Thus,
i) Each elemental constraint should only be associated to the context (W i ) in which it is asserted7 .
Thus, label sets associated to elemental constraints have only one contextual label {Wi }.
ii) The methods for management of temporal contexts described in Section 7.1 should be
integrated into the new reasoning algorithms. These algorithms should use the operations 
lc, lc, get and get-upwards. The computational cost of operations  lc and lc related to
management of temporal contexts is polynomial (O(W2 )) in the number (W) of managed
contexts. Therefore, the computational cost of the reasoning algorithms is increased by a factor
W2 when temporal contexts are managed.
For instance, when interval-based constraints are managed, the TCA algorithm can be used to
obtain a path-consistent context-dependent IA-TCN, with a O(n3 W2 ) cost. Similarly, when a contextdependent reasoning is applied to PIDN networks (Pujari & Sattar, 1999), the computational cost of
specific reasoning algorithms on PIDN constraints is increased by a factor W2 . When the proposed
temporal algebra in Section 3 is applied to tractable classes of constraints, the specific reasoning
algorithms for management of these classes of constraints can also be applied. The computational
cost of these reasoning algorithms (which should be based on combination and intersection
operations on constraints) is increased by a polynomial factor W2 . For instance, when nondisjunctive metric constraints are managed, the TCA algorithm can be used as the closure algorithm
in Section 7.1. This algorithm will obtain a minimal context-dependent TCN with a computational
cost O(n 3 W2 ).

8. Conclusions
Several problems remain pending in representation and reasoning problems on temporal constraints.
In relation to this, we have dealt with reasoning on complex qualitative and quantitative constraints
between time-points and intervals, which can be organized in a hierarchy of alternative temporal
7

That is, there are not labels (Ri) associated to disjunctions in disjunctive constraints. Thus, Definition 3 is not applied in
the Put-Label-Context function. Therefore, the distributive property for lc over lc does not hold for disjunctive
constraints. However, this is not relevant since other reasoning processes will be applied.

81

fiREASONING ON INTERVAL AND POINT -BASED DISJUNCTIVE M ETRIC CONSTRAINTS IN TEMPORAL CONTEXTS

contexts. We have described a new-labeled temporal algebra, whose main elements are labeled
disjunctive metric constraints, label sets associated to elemental constraints, and sets of inconsistent
elemental constraints (I-L-Sets). The temporal model presented is able to integrate qualitative and
metric constraints on time-points and intervals. In fact, symbolic and metric constraint between
intervals can be represented by means of disjunctive metric constraints between time points and a set
of I-L-Sets. The model is also able to manage (non-binary) logical relations among elemental
constraints. The reasoning algorithms on the described model are based on the distributive property
for composition over intersection in labeled constraints, and guarantee consistency and obtain a
minimal TCN of disjunctive metric point-based constraints. In addition, a special type of global
labeled-consistent TCN is also obtained.
Labeled constraints can be organized in a hierarchy of alternative temporal contexts, such that
temporal reasoning processes can be performed on these contexts. Reasoning algorithms guarantee
consistency in each hierarchy of contexts, maintain a minimal context-dependent TCN, and allow us
to determine what constraints hold in each context or in a set of alternative contexts. Thus, we can
reason on a hierarchy of context-dependent constraints on intervals, points and unary durations
(Figure 17).
These described features are useful functionalities for modeling important problems in the
temporal reasoning area. However, they have not been identified in previous models. Therefore, the
temporal model presented here represents a flexible framework for reasoning on complex, contextdependent, metric and qualitative constraints on time-points, intervals and unary durations.
Dur(I 1)  { [ 2 0 20], [50 60]}

I1 {b} I 2
t 1 {[10 20], [100 130]} I -2

Context W 1 1
-

I 1 {b d m} I 2
Dur(I 1 ) {[20 30], [50 100]}

I 1 {[100 100], [200 300]} I+ 2
Dur(I 1)  {[20 30], [60 100]}

Context W 1

Context W 1 2
t 1 {[10 20], [100 200]} I - 2
I- 1 {[0 100], [200 300]} I + 2
Root-Context W 0

t 1 {[10 15], [120 200]} I
I 1{ d m } I 2
Context W 2

2

I 1{d} I 2
t 1 {[10 10]} I -2
Context W 2 1
Dur(I 1 ) = 50
I 1 { m } I2
Context W 2 2

Figure 17: Context-dependent constraints on intervals, time points and unary durations
A path-consistent algorithm can be used as the closure process on labeled TCNs, like the typical
TCA algorithm as applied by Allen (1983). This path-consistent algorithm would obtain a minimal
context-dependent TCN of disjunctive metric constraints. We have proposed an incremental
reasoning process. Thus, a minimal (and consistent) context-dependent TCN is assured at each new
assertion. This incremental reasoning allows us to detect whether each new input constraint is
inconsistent with the previously existing ones. This can be useful when problem constraints are not

82

fiBARBER

initially known but are successively deduced from an incremental independent process (Garrido et
al., 1999).
A prototype of proposed reasoning algorithms has been implemented in Common-Lisp and is
available from the author. These reasoning algorithms are being applied to an integrated architecture
of planning and scheduling processes (Garrido et al., 1999). Here, the scheduling process should
guarantee the consistency of each alternative partial plan (i.e.: temporal constraints and availability
of resources for operations) simultaneously as the planner is generating each partial plan (Srivastava
& Kambhampati, 1999). Thus, the following main features are needed:
 Management of disjunctive metric constraints. Particularly, in planning and scheduling
problems the number disjuncts in input constraints is generally bounded by l2 (i.e.: nonsimultaneous use of resources). However, temporal dependencies between constraints (i.e.:
non-binary constraints) can appear. For instance, operation durations can be dependent on the
order in which they are scheduled.
 Incremental reasoning. The process should interactively guarantee the consistency of each new
input temporal constraint (about resources, plans, ordering, and objects) as each new step is
deduced in a partial plan.
 Management of temporal contexts, where each context is associated to an alternative plan
(action or state). Reasoning algorithms simultaneously work over different and alternative
partial plans.
A globally labeled-consistent (and minimal) TCN allows us to determine consistent alternative
choices and to obtain optimal solutions in each plan. Additionally, the proposed model can be a
useful framework to apply on problems where these features also appear (Dousson et al., 1993;
Garcia & Laborie, 1996; Srivastava & Kambhampati, 1999; etc.).
The computational cost of reasoning algorithms is exponential, due to the inherent complexity of
the management of disjunctive constraints. However, the management of temporal contexts does not
increase the complexity of the reasoning processes on disjunctive constraints.
Some improvements to decrease the empirical cost of reasoning algorithms have been proposed
in this paper. The application of algorithms to handle only an explicit TCN (without making the
derived constraints explicit) and empirical evaluations on several test cases are under study.
Moreover, other reasoning algorithms can be applied to the temporal algebra presented, as proposed
in Section 4. On the other hand, it is interesting to identify subclasses of the labeled temporal algebra
where the size of label sets can be bounded, and to identify tractable subclasses of IA on the proposed
model. It could also be interesting to identify the expressive power of I-L-Sets (and labeled
constraints) on the basis of method described by Jeavons, Cohen and Cooper (1999). Here, each I-LSet represents a special derived constraint, which expresses the inconsistency of a set of input
elemental constraints; that is, a special type of disjunctive linear constraint (Jonsson & Bckstrm,
1996; Stergiou & Koubarakis, 1996).
The proposed-labeled algebra (labeled constraints and the operations on them) can be applied to
other temporal models (i.e.: to other classes of temporal constraints, operations, and reasoning
algorithms). To do this, the operations of the labeled algebra (lc, lc, lc and lc) should be defined
on the basis of the respective operations (, ,  and ) of these models, and the reasoning
algorithms should use the operations defined on labeled constraints ( lc, lc, lc and lc). This
83

fiREASONING ON INTERVAL AND POINT -BASED DISJUNCTIVE M ETRIC CONSTRAINTS IN TEMPORAL CONTEXTS

requires that these reasoning algorithms be based on the composition and intersection operations.
Specifically, the application of the proposed model to tractable temporal constraints -as those
identified in Section 1 (Jonsson et al., 1999; Drakengren & Jonsson, 1997; Vilain, Kautz and Van
Beek, 1986; etc.)- allows for a tractable reasoning process on a hierarchy of temporal constraint
contexts.

Acknowledgements
This work was partially supported by the Generalitat Valenciana (Research Project #GV-1112/93)
and by the Spanish Government (Research Project #CYCIT-TAP-98-0345). The author would
sincerely like to thank the JAIR reviewers for their helpful comments and suggestions on previous
versions of this paper.

References
Allen, J. (1983). Maintaining knowledge about temporal intervals. Comm of the ACM, 26, 11, 832843.
Badaloni, S., & Berati, M. (1996). Hybrid Temporal Reasoning for Planning and Scheduling. In
Proceedings of the 3 Int. Workshop on Temporal Representation and Reasoning (TIME96).
Barber, F. (1993). A metric time-point and duration-based temporal model. ACM Sigart Bulletin,
4 (3), 30-40.
Barber, F., Botti, V., Onaindia, E., & Crespo, A. (1994). Temporal reasoning in Reakt: An
environment for real-time knowledge-based systems. AICommunications, 7 (3), 175-202.
Brusoni, V., Console, L., & Terenziani, P. (1997). Later: Managing temporal information efficiently,
IEEE Expert, 12 (4), 56-64.
Cohen, D., Jeavons, P., & Koubarakis, M. (1996). Tractable disjunctive constraints. In Proceedings.
of the 3rd Int. Conf. on Principles and Practice of Constraint Programming (CP96). Freuder,
E.C. (Ed.). Lecture Notes in Computer Science, 1118, 297-307.
Cooper, M.C. (1990). An optimal k-consistency algorithm. Artificial Intelligence, 41, 89-95.
Dean, T.L., & McDermott, D.V. (1987). Temporal data base management. Artificial Intelligence, 38,
1-55.
Dechter. R., Meiri, I., & Pearl, J. (1991). Temporal constraint networks. Artificial Intelligence, 49,
61-95.
Dechter, R. (1992). From local to global consistency. Artificial Intelligence, 55, 87-107.
Dousson, C., Gaborit, P., & Ghallab M. (1993). Situation Recognition: Representation and
Algorithms. In Proceedings of 13th International Joint Conference on Artificial Intelligence
(IJCAI93).
Drakengren, T., & Jonsson, P. (1997). Eight maximal tractable subclasses of Allen's algebra with
metric time. Journal of A.I. Research, 7, 25-45.
84

fiBARBER

Freuder, E. C. (1978). Synthesizing constraint expressions. Comm. of the ACM, 21 (11), 958-965.
Freuder, E. C. (1982). A sufficient condition for backtrack-free search. Journal of the ACM, 29 (1),
24-32.
Garcia, F., & Laborie, P. (1996). Hierarchisation of the Seach Space in Temporal Planning. New
Directions in AI Planning, 217-232, IOS Press.
Garrido, A., Marzal, E., Sebasti, L., & Barber F. (1999). A model for planning and scheduling
integration. In Proceedings of the 8 th. Conference of Spanish Association of A.I.
(CAEPIA99).
Gerevini, A., & Schubert, L. (1995). Efficient algorithms for qualitative reasoning about time.
Artificial Intelligence, 74, 207-248.
Jeavons, P., Cohen, D., & Cooper M. (1998). Constraints, consistency and closure. Artificial
Intelligence, 101, 251-268.
Jeavons, P., Cohen, D., Gyssens, M. (1999). How to determine the expressive power of constraints.
Constraints: An Int. Journal, 4, 113-131.
Jonsson, P., & Bckstrm, C. (1996). A linear-programming approach to temporal reasoning. In
Proceedings of the 13 th. National Conference on Artificial Intelligence (AAAI96).AAAI
Press.
Jonsson, P., & Bckstrm, C. (1998). A unifying approach to temporal constraint reasoning. Artificial
Intelligence, 102, 143-155.
Jonsson, P., Drakengren, T., & Bckstrm, C. (1999). Computational complexity of relating time
points and intervals. Artificial Intelligence, 109, 273-295.
Kautz, H., & Ladkin, P. (1991). Integrating metric and qualitative temporal reasoning. In Proceedings
of the 9th. National Conference on Artificial Intelligence (AAAI91).AAAI Press.
Mackworth, A. K. (1977). Consistency in networks of relations, Artificial Intelligence, 8, 121-118,.
Meiri, I. (1996). Combining qualitative and quantitative constraints in temporal reasoning. Artificial
Intelligence, 87, 343-385.
Montanari, U. (1974). Networks of constraints: fundamental properties and applications to picture
processing. Information Science, 7, 95-132.
Navarrete, I., & Marin, R. (1997). Qualitative temporal reasoning with points and durations. In
Proceedings of the 15 th. International Joint Conference on Artificial Intelligence (IJCAI-97).
Nebel, B., & Burckert, H.J. (1995). Reasoning about temporal relations: a maximal tractable subclass
of Allen's interval algebra. Journal of the ACM, 42 (1), 43-66.
Pujari, A., & Sattar, A. (1999). A new framework for reasoning about Points,. Intervals and
Durations. In Proceedings on the Int. Joint Conference on Artificial Intelligence (IJCAI'99).
Schwalb, E., & Dechter, R. (1997). Processing disjunctions in temporal constraints networks.
Artificial Intelligence, 93, 29-61.
85

fiREASONING ON INTERVAL AND POINT -BASED DISJUNCTIVE M ETRIC CONSTRAINTS IN TEMPORAL CONTEXTS

Staab, S., & Hahn, U. (1998). Distance constraint arrays: A model for reasoning on intervals with
qualitative and quantitative distances. In Proceedings of the 12th Biennial Conference of the
Canadian Society for Computational Studies of Intelligence on Advances in Artificial
Intelligence (AI-98), Lecture Notes in Artificial Intelligence, 1418, 334-348.
Srivastava, B., & Kambhampati, S. (1999). Efficient planning through separate resource scheduling.
In Proceedings of the AAAI Spring Symp. on search strategy under uncertainty and incomplete
information. AAAI Press.
Stergiou, K., & Koubarakis, M. (1996). Tractable disjunctions of Linear Constraints. In Proceedings
of the 2nd Int. Conf. on Principles and Practice of Constraints Programming (CP96).
Freuder, E.C. (Ed.). Lecture Notes in Computer Science, 1118, 297-307.
Stergiou, K., & Koubarakis, M. (1998). Bactracking algorithms for disjunctions of temporal
constraints. In Proceedings of the 15 th. National Conference on Artificial Intelligence (AAAI98). AAAI Press.
Van Beek, P. (1991).Temporal query processing with indefinite information. Artificial Intelligence
in Medicine, 3 (6), 325-339.
Van Beek, P., & Detcher R. (1995). On the minimality and global consistency of row convex
networks. Journal of the ACM, 42 (3), 543-561.
Van Beek, P., & Dechter, R. (1997). Constraint tightness and looseness versus local and global
consistency. Journal of the ACM, 44 (4), 549-566.
Vilain, M., Kautz, H., & Van Beek P. (1986). Constraint propagation algorithm for temporal
reasoning. In Proceedings of the 5Th. National Conference on Artificial Intelligence (AAAI86).AAAI Press.
Wetprasit, R., Sattar A. (1998). Temporal representation with qualitative and quantitative information
about points and durations. In Proceedings of the 15 th. National Conference on Artificial
Intelligence (AAAI98). AAAI Press.
Yampratoom, E., & Allen, J. (1993). Performance of temporal reasoning systems, ACM Sigart
Bulletin, 4, (3), 26-29.

86

fi