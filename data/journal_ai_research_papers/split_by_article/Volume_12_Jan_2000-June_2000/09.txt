Journal of Artificial Intelligence Research 12 (2000) 271-315

Submitted 2/00; published 5/00

On the Compilability and Expressive Power
of Propositional Planning Formalisms
Bernhard Nebel

NEBEL @ INFORMATIK . UNI - FREIBURG . DE

Institut fur Informatik, Albert-Ludwigs-Universitat, Georges-Kohler-Allee, D-79110 Freiburg, Germany

Abstract
The recent approaches of extending the GRAPHPLAN algorithm to handle more expressive
planning formalisms raise the question of what the formal meaning of expressive power is. We
formalize the intuition that expressive power is a measure of how concisely planning domains
and plans can be expressed in a particular formalism by introducing the notion of compilation
schemes between planning formalisms. Using this notion, we analyze the expressiveness of a
large family of propositional planning formalisms, ranging from basic STRIPS to a formalism with
conditional effects, partial state specifications, and propositional formulae in the preconditions.
One of the results is that conditional effects cannot be compiled away if plan size should grow
only linearly but can be compiled away if we allow for polynomial growth of the resulting plans.
This result confirms that the recently proposed extensions to the GRAPHPLAN algorithm concerning
conditional effects are optimal with respect to the compilability framework. Another result is that
general propositional formulae cannot be compiled into conditional effects if the plan size should
be preserved linearly. This implies that allowing general propositional formulae in preconditions
and effect conditions adds another level of difficulty in generating a plan.

1. Introduction
G RAPHPLAN (Blum & Furst, 1997) and SATPLAN (Kautz & Selman, 1996) are among the most
efficient planning systems nowadays. However, it is generally felt that the planning formalism
supported by these systems, namely, propositional basic STRIPS (Fikes & Nilsson, 1971), is not
expressive enough. For this reason, much research effort (Anderson, Smith, & Weld, 1998; Gazen
& Knoblock, 1997; Kambhampati, Parker, & Lambrecht, 1997; Koehler, Nebel, Hoffmann, & Dimopoulos, 1997) has been devoted in extending GRAPHPLAN in order to handle more powerful
planning formalisms such as ADL (Pednault, 1989).
There appears to be a consensus on how much expressive power is added by a particular language feature. For example, everybody seems to agree that adding negative preconditions does not
add very much to the expressive power of basic STRIPS, whereas conditional effects are considered
as a significant increase in expressive power (Anderson et al., 1998; Gazen & Knoblock, 1997;
Kambhampati et al., 1997; Koehler et al., 1997). However, it is unclear how to measure the expressive power in a more formal way. Related to this problem is the question of whether compilation
approaches to extend the expressiveness of a planning formalism are optimal. For example, Gazen
and Knoblock (1997) propose a particular method of compiling operators with conditional effects
into basic STRIPS operators. This method, however, results in exponentially larger operator sets.
While most people (Anderson et al., 1998; Kambhampati et al., 1997; Koehler et al., 1997) agree
that we cannot do better than that, nobody has proven yet that a more space-efficient method is
impossible.
c 2000 AI Access Foundation and Morgan Kaufmann Publishers. All rights reserved.

fiN EBEL

In order to address the problem of measuring the relative expressive power of planning formalisms, we start with the intuition that a formalism  is at least as expressive as another formalism  if planning domains and the corresponding plans in formalism  can be concisely expressed
in the formalism  . This, at least, seems to be the underlying intuition when expressive power is
discussed in the planning literature.
Backstrom (1995) proposed to measure the expressiveness of planning formalisms using his
ESP-reductions. These reductions are, roughly speaking, polynomial many-one reductions on
planning instances that do not change the plan length. Using this notion, he showed that all of
the propositional variants of basic STRIPS not containing conditional effects or arbitrary logical
formulae can be considered as expressively equivalent. However, taking our point of view, ESPreductions are too restrictive for two reasons. Firstly, plans must have identical size, while we might
want to allow a moderate growth. Secondly, requiring that the transformation can be computed
in polynomial time is overly restrictive. If we ask for how concisely something can be expressed,
this does not necessarily imply that there exists a polynomial-time transformation. In fact, one
formalism might be as expressive as another one, but the mapping between the formalisms might
not be computable at all. This, at least, seems to be the usual assumption made when the term
expressive power is discussed (Baader, 1990; Cadoli, Donini, Liberatore, & Schaerf, 1996; Erol,
Hendler, & Nau, 1996; Gogic, Kautz, Papadimitriou, & Selman, 1995).
Inspired by recent approaches to measure the expressiveness of knowledge representation formalisms (Cadoli et al., 1996; Gogic et al., 1995), we propose to address the questions of how
expressive a planning formalism is by using the notion of compiling one planning formalism into
another one. A compilation scheme from one planning formalism to another differs from a polynomial many-one reduction in that it is not required that the compilation is carried out in polynomial
time. However, the result should be expressible in polynomial space. Furthermore, it is required
that the operators of the planning instance can be translated without considering the initial state
and the goal. While this restriction might sound unnecessarily restrictive, it turns out that existing
practical approaches to compilation (Gazen & Knoblock, 1997) as well as theoretical approaches
(Backstrom, 1995) consider only structured transformations where the operators can be transformed
independently from the initial state and the goal description. From a technical point of view this
restriction guarantees that compilations are non-trivial. If the entire instance could be transformed,
a compilation scheme could decide the existence of a plan for the source instance and then generate
a small solution-preserving instance in the target formalism, which would lead to the unintuitive
conclusion that all planning formalisms have the same expressive power.
As mentioned in the beginning, not only the space taken up by the domain structure is important,
but also the space used by the plans. For this reason, we distinguish between compilation schemes
in whether they preserve plan size exactly, linearly, or polynomially.
Using the notion of compilability, we analyze a wide range of propositional planning formalisms, ranging from basic STRIPS to a planning formalism containing conditional effects, arbitrary boolean formulae, and partial state specifications. As one of the results, we identify two
equivalence classes of planning formalisms with respect to polynomial-time compilability preserving plan size exactly. This means that adding a language feature to a formalism without leaving
the class does not increase the expressive power and should not affect the principal efficiency of
1. We assume that the reader has a basic knowledge of complexity theory (Garey & Johnson, 1979; Papadimitriou,
1994), and is familiar with the notion of polynomial many-one reductions and the complexity classes P, NP, coNP,
and PSPACE. All other notions will be introduced in the paper when needed.

272

fiC OMPILABILITY

AND

E XPRESSIVE P OWER OF P LANNING F ORMALISMS

the planning method. However, we also provide results that separate planning formalisms using
results from computational complexity theory on circuit complexity and non-uniform complexity
classes. Such separation results indicate that adding a particular language feature adds to the expressive power and to the difficulty of integrating the feature into an existing planning algorithm.
For example, we prove that conditional effects cannot be compiled away and that boolean formulae
cannot be compiled into conditional effectsprovided the plans in the target formalism are allowed
to grow only linearly.
This answers the question posed in the beginning. The compilation approach proposed by Gazen
and Knoblock (1997) cannot be more space efficient, even if we allow for linear growth of the plans
in the target formalism. Allowing for polynomial growth of the plans, however, the compilation
scheme can be more space efficient. Interestingly, it seems to be the case that a compilation scheme
that allows for polynomially larger plans is similar to the implementation of conditional effects in
the IPP system (Koehler et al., 1997), Kambhampati and colleagues' (1997) planning system, and
Anderson and colleagues' (1998) planning system.
The rest of the paper is structured as follows. In Section 2, we introduce the range of propositional planning formalisms analyzed in this paper together with general terminology and definitions.
Based on that, we introduce the notion of compilability between planning formalisms in Section 3.
In Section 4 we present polynomial-time compilation schemes between different formalisms that
preserve the plan size exactly, demonstrating that these formalisms are of identical expressiveness.
For all of the remaining cases, we prove in Section 5 that there cannot be any compilation scheme
preserving plan size linearly, even if there are no bounds on the computational resources of the
compilation process. In Section 6 we reconsider the question of identical expressiveness by using compilation schemes that allow for polynomial growth of the plans. Finally, in Section 7 we
summarize and discuss the results.

2. Propositional Planning Formalisms
First, we will define a very general propositional planning formalism, which appears almost as
expressive as the propositional variant of ADL (Pednault, 1989). This formalism allows for arbitrary
boolean formulae as preconditions, conditional effects and partial state specifications. Subsequently,
we will specialize this formalism by imposing different syntactic restrictions.
2.1 A General Propositional Planning Formalism
Let  be the countably infinite set of propositional atoms or propositional variables. Finite
subsets of  are denoted by  . Further,   is defined to be the set consisting of the constants 
(denoting truth) and 	 (denoting falsity) as well as atoms and negated atoms, i.e., the literals,
over  . The language of propositional logic over the logical connectives 
fiff , and  and the
propositional atoms  is denoted by fi . A clause is a disjunction of literals. Further, we say that
a formula   is in conjunctive normal form (CNF) if it is a conjunction of clauses. It is in
disjunctive normal form (DNF) if it is a disjunction of conjunctions of literals.
Given a set of literals  , by fi we refer to the positive literals in  , by "!$#%& we refer to
the negative literals in  , and by '(& to the atoms used in  , i.e., '($fi*),+.-//102-33 or 4-5
2. Note that Gazen and Knoblock's (1997) translation scheme also generates planning operators that depend on the
initial state and the goal description. However, these operators simply code the initial state and the goal description
and do nothing else. For this reason, we can ignore them here.

273

fiN EBEL

76

. Further, we define 8 to be the element-wise negation of  , i.e.,

8),+.-90:4-35;6&<=+>4-?0@-=376BA
A state C is a truth-assignment for the atoms in  . In the following, we also identify a state with
the set of atoms that are true in this state. A state specification D is a subset of   , i.e., it is a logical
theory consisting of literals only. It is called consistent iff it does not contain complementary literals
or 	 . In general, a state specification describes many states, namely all those that satisfy D , which
are denoted by EF:GH$D( . Only in case that D is complete, i.e., for each -3/ we have either -=/D
or 4-IJD , D has precisely one model, namely K>$D( . By abusing notation, we will refer to the
inconsistent state specification by 	 , which is the illegal state specification.
Operators are pairs LM)ON pre ff post P . We use the notation pre LB and post LQ to refer to the first
and second part of an operator L , respectively. The precondition pre is an element of RKSKT , i.e.,
it is a set of propositional formulae. The set post, which is the set of postconditions, consists of
conditional effects, each having the form

UWV Xff
UZY

Y

  are called effectV conditions and the elements of 
  are called
where the elements of
U
effects. If or  are singleton sets, e.g., +.-H6
+\[]6 , we often omit the curly brackets and write
- V [.
Example 1 In order to illustrate the various notions, we will use as a running example planning
problems connected with the production of camera-ready manuscripts from LATEX source files
somewhat simplified, of course. As the set of atoms  , we choose the following set:

^),+`_bacffed]fgcffihQj]klffgm no4ffgp\qgffgrsklrsffgr]rsmlffgrsm o4fftklu>hvfftk hQcfftkwm o
hQj]k klu>h nxQffihBjsk y>k _za nx6BA
These propositional atoms have the following intended meaning. The atoms in the first line represent
the presence of the corresponding files, and the atoms in the second line signify that the index and
citations are correct in the dvi-file. Based on that, we define the following operators: rBkwr\_bac , m d{_zac ,
| d]xea>kwu{h]ac . The first of these operators is very simple. The precondition for its execution is that
a rBklr - and an d]fgc -file exist. After the successful execution, a r]rsm - and a r]m o -file will have been
produced:

rBklr{_zacM)~}`d]fgcffgrBkwr4ff{v V +Brsrsmlffgrsm ov6"vA

The

| d]xea>kwu{hsac

operator is similar:

| d]xea>kwu{h]acM)}4`k hc`4ff{v V +Qkwu{h`fftklm ov6"vA
Finally, the m d{_zac operator is a bit more complicated. As a precondition it needs the presence of the
_bac -file and it produces as its effect d]fgc -, k hc -, hBjsk , and m no -files unconditionally. In addition, we
know that the citations will be correct if a rsr]m -file is present and that the index will be correct if an
274

fiC OMPILABILITY

klu>h

-file is present:

AND

E XPRESSIVE P OWER OF P LANNING F ORMALISMS

m d{_bac)~}_zac`4ff
V
  V
rsr]m
fir]rsV m
klu>h

+{d]f:cfftk hQcffihBjsklffgm no`6Bff
V hBjs8k hQy>j]k _bk a y>k n_zaxff nxQff
hBjsk klu>h nxQff
V
kwu{h 8hQj]k kwu{h nx 4 A

The semantics of operators is given by state-transition functions, i.e., mappings from states to
states. Given a state C and a set of postconditions post, CBff post  denotes the active effects in C :

MCsff post()+\0 UWV &

post ffeC0 )

U 6BA

The state-transition function { induced by the operator L is defined as follows:

>\
{C>)

R  3 R 
 C7fi"!$#%$Csff post LB..<$MCsff post LB.. if C0 ) pre LB and

 CBff post LQ.0)	

undefined

otherwise

In words, if the precondition of the operator is satisfied in state C and the active effects are consistent,
then state C is mapped to the state C: which differs from C in that the truth values of active effects
are forced to become true for positive effects and forced to become false for negative effects. If the
precondition is not satisfied or the set of active effects is inconsistent, the result of the function is
undefined.
In the planning formalism itself, we do not work on states but on state specifications. In general,
this can lead to semantic problems. By restricting ourselves to state specifications that are sets of
literals, however, the syntactic manipulations of the state specifications can be defined in a way such
that they are sound in Lifschitz' (1986) sense.
Similarly to the active effects with respect to states, we define a corresponding function with
respect to state specifications:

$Dff post *)+\I0 UWV fifi

post ffD^0 )

U 6BA

Further, we define the potentially active effects as follows:

 $Dff post () CBff postA
e %


$Dff post ,
If for a state specification D and an operator L5)N pre ff post P , we have $Dff post ) 
it means that the state specification resulting from the application of the state-transition functions
might not be representable as a theory consisting of literals only. For this reason, we consider such
an operator application as illegal, resulting in the illegal state specification 	 . We could be more
liberal at this point and consider an operator application to a state specification only as illegal if the
set of states resulting from applying the state-transition functions could definitely not be represented
3. Note that this can only happen if the state specification is incomplete.

275

fiN EBEL

as a theory consisting of literals only. Alternatively, we could consider all atoms mentioned in
 $Dff post ,M$D8ff post  as unsafe after the application of the operator and delete the literals
7  $D8ff post  $Dff post . from the state specification, but consider the resulting state specification
still as legal if $Dff post  is consistent. Since there does not seem to exist a standard model for
the execution of conditional effects in the presence of partial state specifications, we adopt the first
alternative as one arbitrary choice. It should be noted, however, that this decision influences some
of the results we present below.
 $Dff post  leads to an illegal state specification, we
Similarly to the rule that $Dff post ) 
require that if the precondition is not satisfied by all states in EF:GH$D( or if the state specification
is already inconsistent, the result of applying L to D results in 	 . This leads to the definition of the
function  , which defines the outcome of applying an operator L from the set of operators  to a
state specification:

R  1   R 
 D/($Dff post LQ.<5M$D8ff post LB. if D0)	 and

D 0 ) pre LB and
J

 $D8ff post LB.0)
M
 	 $Dand
$D8ffiLQ) 

M
$

8
D
ff


B
L
.



)
ff post LB.
post



	

otherwise

Example 2 Using the propositional atoms and operators from Example 1, we assume the following
two state specifications 
 )+:_zacKfftklu>hK6 , and   )+:_bacKfftklu{h`ffgrsr]mffgrsm ov6 . If we try to apply the
operator m d{_bac to  , we notice that this results in 	 because



 ff post zm d\_bacB.) +{d]fgcfftk hcffihQj]klffgm no4ffihQj]k klu{h nx6Bff
    ff post zm d\_bacB.)  ff post zm d{_bacB.H<=+\hBjsk y>k _za nxQff8hQj]k y>k _ba nx6Bff



  ff post zm d\_bacB.A On the other hand, we can apply rBkwr\_bac
i.e., we have M ff post zm d{_bacB.) 

successfully to  :  ffgrBkwr\_bacB() A



It is easily verified that the syntactic operation on a state specification using the function 
corresponds to state transitions on the states described by the specification.
Proposition 1 Let D be a state specification, L be an operator, and { be the induced state-transition
function. If $D8ffiLQ0)	 , then

EF:GH$$DffiLB.),+{C  0gC  ){C>ffeC0 )Dfi6BA
If $DffiLB;0 )	 , then either
1.

EF:GH$D()

, or

2. there are two states C
3.

 MC  ff post LB. , or
 ffeC  /E:G$D( such that MC  ff post LB.)
there exists a state CWE:GH$D such that {>C> is undefined.
276

fiC OMPILABILITY

E XPRESSIVE P OWER OF P LANNING F ORMALISMS

AND

In other words, whenever $DffiLB results in a legal specification, this specification describes the
states that result from the application of the state-transition function > to the states that satisfy the
original state specification D . Further, if $D8ffiLQ is illegal, there are good reasons for it.

A planning instance is a tuple

)~N&ffifft5Pff

where




)~N$fftP is the domain structure consisting of a finite set of propositional atoms  and a
finite set of operators  ,

Y
    is the initial state specification, and
 Y   is the goal specification.



When we talk about the size of an instance, symbolically 00 00 , in the following, we mean the size
of a (reasonable) encoding of the instance.
In the following, we use the notation  to refer to the set of finite sequences of operators.
Elements  of  are called plans. Then 00 300 denotes the size of the plan, i.e., the number of
operators in  . We say that  is a  -step plan if 00 3008 . The result of applying  to a state
specification D is recursively defined as follows:

 !B
;
R      R 
;!t$Dff\N$P.) D
;!t]$Dff\NL  iff L  ffgAgAgA:ffiL>KP.) ;!]$$DffiL  ff\NL  ffgAgAgA{ffiL{KP.


A sequence of operators  is said to be a plan for or a solution of iff
1. X!]ffe0)	 and
2. X!]ffe;0 ) .
Example 3 Let  and  be the propositional
 atoms and operators introduced in Example 1 and
consider the following planning instance:
)N.N$fftPfft+:_bacKffgrBklr]ffklu>hK6Bfft+\hBjskffihQjsk y>k _za nx6>PA In
words, given a latex source file (_bac ) and a bibliography database ( rBklr ), we want to generate a dvi
file (hBjsk ) such that the citations in this file are correct (hBjsk y>k _ba nx ). Furthermore, we do not know
 but we know that there is no index file yet
anything about the existence of a bbl-file or aux-file etc.,
( kwu{h ). The plan )~Nzrsklr\_bacffgm d{_zacsP is a solution of because the plan does not result in an illegal
state specification and the resulting state specification entails hQj]k and hBjsk y>k _ba nx .
Plans satisfying (1) and (2) above are sound. In order to state this more precisely, we extend
the notion of state transition functions for operators to state transition functions for plans. Let { be
the state transition function corresponding to the composition of primitive state-transition functions
induced by the operators in )~NL ffgAgAgA\ffiL>P , i.e.,



B e.  b> ) >eAgAgAQfi{bvff
4. We could have been more liberal requiring that  T . We have not done that in order to allow for a fair
comparison with restricted planning formalisms.

277

fiN EBEL


such that   e.     C> is defined iff   e.  b C is defined for every  , 9 . Using this
notion, one can easily proveusing induction over the plan lengththat any plan for an instance
is sound in Lifschitz' (1986) sense, i.e., corresponds to the application of state transition functions
to the initial states.


Proposition 2 Let )N&ffifft5P be a planning instance and
 . If X!]ffe is consistent, then

)NL  gff AgAgA\ffiL>P

be an element of

E:GH$X!ffe.),+{C  0tC  ){C>ffeC0 )>6BA
If ;!]ffe is inconsistent, then either
1.

EF:GH\()

, or

2. there exists a (possibly empty) prefix
X!]ff\NL ffgAgAgA:ffiL  P. and either



(a) there are two states C
or

NL  gff AgAgA\ffiL>$P (
 3~ ) of 

 eff C  WEF:GH$D(

such that MC

(b) there exists a state CWE:GH$D such that {bw

 C>

such that

D)

 C  ff post L>  . ,
 ff post L>2  .)
is undefined.

2.2 A Family of Propositional Planning Formalisms
The propositional variant of standard STRIPS (Fikes & Nilsson, 1971), which we will also call 
in what follows, is a planning formalism that requires complete state specifications, unconditional
effects, and propositional atoms as formulae in the precondition lists. Less restrictive planning
formalisms can have the following additional features:
Incomplete state specifications ( ): The state specifications may not be complete.
Conditional Effects ( ): Effects can be conditional.
Literals as formulae ( ): The formulae in preconditions and effect conditions can be literals.
Boolean formulae ( ): The formulae in preconditions and effect conditions can be arbitrary
boolean formulae.
These extensions can also be combined. We will use combinations of letters to refer to such multiple
extensions. For instance,  refers to the formalism  extended by literals in the precondition lists,
S
`s refers to the formalism allowing for incomplete state specifications and conditional effects, and
%QB , finally, refers to the general planning formalism introduced in Section 2.1.



Example 4 When we consider the planning instance from Example 3, it becomes quickly obvious
that this instance has been expressed using  s . The initial state specification is incomplete, the
S
operator m d{_zac contains conditional effects and negative literals in some effect conditions. However,
we do not need general Boolean formulae to express the instance.
278

fiC OMPILABILITY

AND

E XPRESSIVE P OWER OF P LANNING F ORMALISMS

`{

>

 >>

 

 {

`Q

`

`

 



 


Figure 1: Planning formalisms partially ordered by syntactic restrictions

Figure 1 displays the partial order on propositional planning formalisms defined in this way. In
the sequel we say that  is a specialization of  , written  , iff  is identical to  or below
 in the diagram depicting the partial order.
Comparing this set of planning formalisms with the one Backstrom (1995) analyzed, one notices that despite small differences in the presentation of the planning formalisms:

 

is the same as common propositional strips (CPS),

  S is the same as propositional strips with negative goals (PSN), and
 S  is the same as ground Tweak (GT).
2.3 The Computational Complexity of Planning in the  -Family

While one would expect that planning in  is much easier than planning in %s , it turns out that
this is not the case, provided one takes a computational complexity perspective.
In analyzing the computational complexity of planning in different formalisms, we consider, as
usual, the problem of deciding whether there exists a plan for a given instancethe plan existence
problem (PLANEX). We will use a prefix referring to the planning formalism if we consider the
existence problem in a particular planning formalism.
Theorem 3



-PLANEX is PSPACE-complete for all 



with %QB .

5. We do not consider planning formalisms identical to the SAS formalism (Backstrom & Nebel, 1995), since we do
not allow for multi-valued state variables.

279

fiN EBEL

Proof. PSPACE-hardness of  -PLANEX follows from a result by Bylander (1994, Corollary 3.2).
Membership of %Qs -PLANEX in PSPACE follows because we could, step by step, guess a
sequence of operators, verifying at each step that the operator application leads to a legal follow up
state specification and that the last operator application leads to a state specification that entails the
goal specification. For each step, this verification can be carried out in polynomial space. The reason
for this is that all the conditions in the definition of  are verified by polynomially many calls to an
NP-oracle. Therefore, %Qs can be decided on a non-deterministic machine in polynomial space,
hence it is a member of PSPACE.
From that it follows that the plan existence problem for all formalisms that are in expressiveness
between  and %s including both formalismsis PSPACE-complete.

3. Expressiveness and Compilability between Planning Formalisms
Although there is no difference in the computational complexity between the formalisms in the
 QB -family, there might nevertheless be a difference in how concisely planning domains and plans
can be expressed. In order to investigate this question, we introduce the notion of compiling planning formalisms.
3.1 Compiling Planning Formalisms
As mentioned in the Introduction, we will consider a planning formalism  as expressive as another
formalism  if planning domains and plans formulated in formalism  are concisely expressible
in  . We formalize this intuition by making use of what we call compilation schemes, which
are solution preserving mappings with polynomially sized results from  domain structures to 
domain structures. While we restrict the size of the result of a compilation scheme, we do not
require any bounds on the computational resources for the compilation. In fact, for measuring the
expressibility, it is irrelevant whether the mapping is polynomial-time computable, exponential-time
computable, or even non-recursive. At least, this seems to be the idea when the notion of expressive
power is discussed in similar contexts (Baader, 1990; Erol et al., 1996; Gogic et al., 1995; Cadoli
et al., 1996). If we want to use such compilation schemes in practice, they should be reasonably
efficient, of course. However, if we want to prove that one formalism is strictly more expressive
than another one, we have to prove that there is no compilation scheme regardless of how many
computational resources such a compilation scheme might use.
So far, compilation schemes restrict only the size of domain structures. However, when measuring expressive power, the size of the generated plans should also play a role. In Backstrom's
ESP-reductions (1995), the plan size must be identical. Similarly, the translation from   to 
S
S
proposed by Gazen and Knoblock (1997) seems to have as an implicit prerequisite that the plan
length in the target formalism should be almost the same. When comparing the expressiveness of
different planning formalisms, we might, however, be prepared to accept some growth of the plans
in the target formalism. For instance, we may accept an additional constant number of operators, or
we may even be satisfied if the plan in the target formalism is linearly or polynomially larger. This
leads to the schematic picture of compilation schemes as displayed in Figure 2.
Although Figure 2 gives a good picture of the compilation framework, it is not completely
accurate. First of all, a compilation scheme may introduce some auxiliary propositional atoms that
are used to control the execution of newly introduced operators. These atoms should most likely
have an initial value and may appear in the goal specification of planning instances in the target
280

fiC OMPILABILITY

AND

E XPRESSIVE P OWER OF P LANNING F ORMALISMS




Planning

compilation

I



G



B

Planning

 

Figure 2: The compilation framework

formalism. We will assume that the compilation scheme takes care of this and adds some literals to
the initial state and goal specifications.
Additionally, some translations of the initial state and goal specifications may be necessary. If
we want to compile a formalism that permits for literals in preconditions and goals to one that requires atoms, some trivial translations are necessary. Similarly, if we want to compile a formalism
that permits us to use partial state specification to a formalism that requires complete state specifications, a translation of the initial state specification is necessary. However, such state translation
functions should be very limited. They should depend only on the set of symbols in the source
formalism, should be context-independent, i.e., the translation of a literal in a state specification
should not depend on the whole specification, and they should be efficiently computable.
While the compilation framework is a theoretical tool to measure expressiveness, it has, of
course, practical relevance. Let us assume that we have a reasonably fast planning system for a
planning formalism  and we want to add a new feature to  resulting in formalism  . If we
can come up with an efficient compilation scheme from  to  , this means we can easily integrate
the new featureeither by using the compilation scheme or by modifying the planning algorithm
minimally. If no compilation scheme exists, we probably would have problems integrating this feature. Finally, if only computationally expensive compilation schemes exist, we have an interesting
situation. In this case, the off-line compilation costs may be high. However, since the compiled
domain structure can be used for different initial and goal state specifications, the high off-line costs
may be compensated by the efficiency gain resulting from using the  planning algorithm. As
it turns, however, this situation does not arise in analyzing compilability between the %Qs formalisms. Either we can identify a polynomial-time compilation scheme or we are able to prove that
no compilation scheme exists.

6. This means that compilation schemes between planning formalisms are similar to knowledge compilations (Cadoli &
Donini, 1997), where the fixed part of a computational problem is the domain structure and the variable part consists
of the initial state and goal specifications. The main difference to the knowledge compilation framework is that we
also take the (size of the) result into account. In other words we compile function problems instead of decision
problems.

281

fiN EBEL



3.2 Compilation Schemes
Assume a tuple of functions M)N>>ffe  ffe>Qff
N&ffifft5P to  -instances   as follows:

 ffz>P

that induce a function 

from



-instances

)



 ()N@>>ffe  H<  $ffi\ffe>s%<zs$fft9.PgA


If the following three conditions are satisfied, we call  a compilation scheme from



iff there exists a plan for 

1. there exists a plan for



;

2. the state-translation functions z and  are modular, i.e., for
D0)	 , the functions  (for ?)eff	 ) satisfy






to  :

~)  </  , D Y  

, and



$ffD(()
  $   ffDfiff   H<  $   ffDff   ff

and they are polynomial-time computable;
3. and the size of the results of >\ffe  , and > is polynomial in the size of the arguments.
Condition (1) states that the function  induced by the compilation scheme  is solutionpreserving. Condition (2) states requirements on the on-line state-translation functions. The result
of these functions should be computable element-wise, provided the state specification is consistent. Considering the fact that these functions depend only on the original set of symbols and the
state specification, this requirement does not seem to be very restrictive. Since the state-translation
functions are on-line functions, we also require that the result should be efficiently computable.
Finally, condition (3) formalizes the idea that  is a compilation. For a compilation it is much more
important that the result can be concisely represented, i.e., in polynomial space, than that the compilation process is fast. Nevertheless, we are also interested in efficient compilation schemes. We say
that  is a polynomial-time compilation scheme if >\ffe  , and > are polynomial-time computable
functions.
In addition to the resource requirements on the compilation process, we will distinguish between different compilation schemes according to the effects on the size of the plans solving the
  has the property that for every plan 
instance in the target formalism. If a compilation scheme
solving an instance there exists a plan  solving   such that 00 @0000 300
 for some
positive integer constant  ,  is a compilation scheme preserving plan size exactly (up to additive
 00 300 for positive integer constants
  and  , then  is a compilation
constants). If 00 @00K
scheme preserving plan size linearly, and if 00   00-i00 300lff{00 00 for some polynomial - , then 
is a compilation scheme preserving plan size polynomially. More generally, we say that a planning formalism  is compilable to formalism  (in polynomial time, preserving plan size exactly,
linearly, or polynomially), if there exists a compilation scheme with the appropriate properties. We

write 
 in case  is compilable to  or     if the compilation can be done in polynomial time. The super-script  can be  ,  , or - depending on whether the scheme preserves plan size
exactly, linearly plan, or polynomially, respectively.
As is easy to see, all the notions of compilability introduced above are reflexive and transitive.
7. Although it is hard to imagine a modular state-translation function that is not polynomial time computable, some
pathological function could, e.g., output translations that have exponential size in the encoding of the symbols.

282

fiC OMPILABILITY

Proposition 4 The relations



AND



E XPRESSIVE P OWER OF P LANNING F ORMALISMS

and

 



are transitive and reflexive.

Furthermore, it is obvious that when moving upwards in the diagram displayed in Figure 1,
there is always a polynomial-time compilation scheme preserving plan size exactly. If v denotes
the projection to the  -th argument and  the function that returns always the empty set, the generic
compilation scheme for moving upwards in the partial order is )ON ffeffeff ff P .
Proposition 5 If J , then  









.

4. Compilability Preserving Plan Size Exactly
Proposition 5 leads to the question of whether there exist other compilation schemes than those
implied by the specialization relation. Because of Proposition 5 and Proposition 4, we do not have
to find compilation schemes for every pair of formalisms. It suffices to prove that  is compilable
to  , in order to arrive at the conclusion that all formalisms that are below  are compilable to 
and formalisms above  .
A preview of the results of this section is given in Figure 3. We will establish two equivalence
classes such that all members of each class are compilable to each other preserving plan size exactly.
These two equivalence classes will be called   - and  s -class, in symbols    and   s  ,
S
S
S
S
naming them after their respective largest elements.

 {

 >

 >

 

 {

 Q

 >

 

 



`


Figure 3: Equivalence classes of planning formalisms created by polynomial-time compilation
schemes preserving plan size exactly

283

fiN EBEL

4.1 Planning Formalisms without Conditional Effects and Boolean Formulae
First, we will show that the formalisms analyzed by Backstrom (1995), namely,   ,  , and  are
S
S
polynomial-time compilable into each other preserving plan size exactly. In fact, a fourth class can
be added to this set, namely, ` , which lies between   and  .
S
In other words, using the notion of compilability, we get the same equivalence class as with
Backstrom's ESP-reductions. Having a closer look at the proofs in Backstrom's (1995) paper reveals that this is not surprising at all because the ESP-reductions he used could be reformulated as
compilation schemes. Since he used a quite different notation, we will nevertheless prove this claim
from first principles.
The key idea in compiling planning formalisms with literals to formalisms that allow for atoms
only
is to consider - and 4- as different atoms in the new formalism. For this purpose, we introduce
!
!
Y   , then "? is a set where each negative
copy of  . Further, if 
J),+ -0 -=/6 , i.e., a disjoint
!
literal 4- in  is replaced by - , i.e.,
#

?)
"

	

!

!
+.-//I0 -3=76fi<=+ -3
 J0:4-53;6

if 0)	ff
otherwise.

!

Using <  as the new set of atoms, one can translate state specifications and preconditions easily. In the postconditions we have to make sure that the intended semantics is taken care of, i.e.,
!
whenever - is added, - must be deleted and vice versa.
Finally, we have to deal with the problem of partial state specifications. However, this not
a problem when all effects are unconditional and the preconditions contain only atoms. In this
case, we can safely assume that all atoms with unknown truth-value are false without changing the
outcome of the application of an operator. Let $&%*fi denote the completion of  with respect
to  , i.e.,

  fi*),+>4-90 -3/ff-3
 76fi<?XA

$&%

Using this function, we can transform a partial state specification into a complete specification
without changing the outcome, i.e., we get the same plans.
Theorem 6
exactly.

 S  , `  ,  S

, and  are polynomial-time compilable to each other preserving plan size

Proof. Since ^`H  and Z
S
S  S  , it follows from Propositions 4 and 5 that we only
have to show

that     in order to prove the claim.
S
Let )N&ffifft5P be a   -instance with )N$fftP . We translate each operator L into
S
the operator
!
L)~N'" pre LBff(" post LQ<5)"5 post LQ.PA
The set of all such operators is denoted by
N>>ffe  ffe>Qff  ffz{P as follows:

>)
  )
>s)
 $ffi\)
zs$fft9)



!

. Now we can define the compilation scheme
!

!

$N < ff 
 Pff
ff
ff
$&% +* ! ' "?\ff
"==A
284

W)

fiC OMPILABILITY

AND

E XPRESSIVE P OWER OF P LANNING F ORMALISMS

 satisfies conditions (2) and (3), all the functions can be computed in polyThe scheme  obviously
nomial time, and   is a  -instance.
Y   . Then it is obvious that
Let D
!

 $ff$DffiLB.(),  $ffD(ff LBA
!

 ) .N -L  ffgAgAgA:ff/L-  P denote a sequence of operators corresponding to a sequence of operators

)~NL  ffgAgAgA:iff L>vP . Using induction on plan  length, it is easy to show that
!
 is a plan for iff  is a plan for   ,
i.e., condition (1) on compilation schemes is also satisfied. This means,  is in fact a compilation
Let

scheme. Further, since the plan size does not change, the compilation scheme preserves plan size
exactly. Finally, because all functions in  can be computed in time polynomial in their arguments,
 is a polynomial-time compilation scheme.
One view on this result is that it does not matter whether, from an expressivity point of view, we
allow for atoms only or for literals and it does not matter whether we have complete or partial state
specificationprovided propositional formulae and conditional effects are not allowed.
4.2 Planning Formalisms with Conditional Effects but without Boolean Formulae
Interestingly, the view spelled out above generalizes to the case where conditional effects are allowed. Also in this case it does not matter whether only atoms or also literals are allowed and
whether we have partial or complete state specifications. In proving that, however, there are two
additional complications. Firstly, one must compile conditional effects over partial state specifications to conditional effects over complete state specifications. This is a problem because the
 $D8ff post LB. in the definition of the function  must be tested. Seccondition $Dff post LQ.)
ondly, when compiling a formalism with literals into a formalism that allows for atoms only, the
condition M$Dff post LB.0) 	 in the definition of  must be taken care of. For this reason, we will
prove this result in two steps.
As a first step, we show that  s can be compiled to   . The problem in specifying such a
S
S
compilation scheme is that the execution of an operator L on a partial state specification leads to the

$Dff post LB. .
illegal state if $Dff post LB.) 
When considering our running example (Ex. 1), things are quite obvious. When a state specification does not contain the literal or the negation of the literal that is mentioned in the effect
condition, then the illegal state specification results. For example, if a state specification does neither contain r]rsm nor &rsrsm , then the result of executing m d{_bac is 	 . In the general case, however,
things are less straightforward because effect literals can be produced by more than one conditional
rule and an effect condition can consist of more than one literal.
Assuming without loss of generality (using a polynomial transformation) that the effects are
all singleton sets, we have to check the following condition. Either one of the conditional effects
with the same effect literal is activatedi.e., the effect condition is entailed by the partial state
or all of the conditional effects with the same effect literal are blocked, i.e., each effect condition
contains a literal that is inconsistent with the state specification. If this is true, the original operator
 $Dff post LQ. , otherwise the resulting state specification is inconsistent.
satisfies $Dff post LB.)
For example, consider the following  s operator:

L )

S
N$fft+Q+.-ff8[]6 V +>4-H6Bfft+10ff2v6 V +>4-H6Q6>PA
285

fiN EBEL

The application of this operator satisfies $Dff post LB.)
1.
2.

-

0

and 8[ are true in the state specification, or

 $Dff post LB.

iff either

and 2 are true in the state specification, or

3. one of - and *[ is false and one of 0 and 2 is false.



In all other cases, we get M$D8ff post LB.) 
$Dff post LB. and the result is the illegal state. In order
to test for this condition in a formalism with complete states we introduce four new sets of atoms:

  )
  )

+.-  0 -3=6Bff
.+ -  0@-3/6Bff
43 ) .+ -53=0@-3/6Bff
6
) +1   7X0 for the 8 th conditional effect of L  6BA
The atom -  is true if either - or 4- is part of the original partial state specification. The atom
-  is set true by an operator if one of the conditional effects adds - or if - does not appear as an
effect in the operator. The atom 5
- 3 is set true by an operator if one of the conditional effects deletes
- or if 4- does not appear as an effect in the operator. Finally, atoms of the form    7 are added by
an action if the 8 th conditional effect in the  th operator is blocked by some effect condition. Using
these new atoms, we could translate the above operator to

N$ff8+H+.-`ffi[>ff-ff8[]6 V V +.-4 ff-53*ff4-6Bff
+ 0  ff 2  ff 0ff V 2`6 +.-  ff- 3 ff4-H6Bff
1
+.-`ff4-6 V +1    6Bff
+\[  ffi[]6 V 1+     6Bff
+ 04ff9 0H6 V 1+     6Bff
1
+ 2]V ff9 2v6 1+ `   6Bff
1
 V   <5 3 6 I+.- 3 6Bff

+ ;:X 7 (0 < )Z
1
 .6Q6>PA
Let = eff>8] be a function that returns -  or 5
- 3 , if - or 4- , respectively, is the effect of the 8 th
conditional effect in the  th operator. Assuming now that the atoms from fi are set according to
6
their intended semantics and that the previous operator deleted all atoms from 7=<W4
 35< , the
>L ! )

following test operator checks whether the original operator would have led to an inconsistent result:
test

)

ffA@+>9   7ff9=8 iff>8]e6 V 	0(   7
?

6BDC

A

Whenever we have 9   7 , it means the 8 th conditional effect in the  th operator (which must be the
previously executed operator) was not blocked. If in addition to that the effect of this conditional
 $Dff post LB. in the
effect was not activated, i.e., 9=8 iff>8] is true, we would have $Dff post LB.) 
original formalism. For this reason, we force the illegal state. Conversely, if either    7 is true for all
 and 8 or if it is false for one 8 , but = eff>8] is true, we would have $Dff post LQ.)  $D8ff post LB.
in the original formalism and do not need to force the illegal state.
!
We now could force, by using some extra literals, that after each operator L{ the test operator is
applied. This would result in a compilation scheme that preserves plan size only linearly. However,
it is possible to do better than that. The key idea is to merge the test operator for the  th step into the
operator of step E .
286

fiC OMPILABILITY

AND

E XPRESSIVE P OWER OF P LANNING F ORMALISMS

 S s  is polynomial-time compilable to  S  preserving plan size exactly.

)N&ffifft9P be a  S s -instance with ~)N$fftP . Without loss of generality, we
Proof. Let
assume that the postconditions of operators L  1 have the following form:
V F  ffgAgAgA:ffi  : H
G
V F  :z6Bff
post L  ),+\  




Y
F
with    7
  and   7I  .
Lemma 7



First, we introduce a number of new sets of symbols that are pairwise disjoint and disjoint from
:

  )
JI )
  )


)

I3

 3
6

6

+.- 
.+ -KI
+.- 
+.- I3
+.- 3

I

)
 )

)
Y

0@-=/6Bff
0z-3/6Bff
0z-3/6Bff
0z-3/6Bff
0z-3/6Bff
+1KI  7 0 for the 8
+1    7 0 for the 8

th conditional effect of L

 6Bff
th conditional effect of L  6BA

  ,   denotes the set of primed literals, i.e.,   )+.-  0i-^Z76<
For a given set of literals 
2, i.e., C]Mv=)
+>4-`*0"$4- W76 and the function CLl denotes the successor function modulo
6
MN\DOQPSRUT . Further, the functions =WV for )ff: shall be functions from V to JV <9JV3 such
that
#
V [Bfi post L  ff
V / V
[
if    7

= V  eff>8])
[ V3 / V3 if (  7 V 8[B post L>A
Now let postV

L  

postV
let block V

L  

for )ff: be defined as follows

L  *)+\/<?'(2 VV .+ -ff-`ff- V 
6 0@-3/ff\ V V %-  post L  e6&<
+\/<?'(2 >+ 4-ff-`ff- V3 
6 0 -3Wff\
" -   post L>$e6Bff

for )ff: be defined as
block V

L  ()+Q+\[ffi[{ 6 V V  V  7 0Q   7 VXVXF   F 7{ post L  ff\$*[Q75   7>6&<
+Q+>8[ffi[  6 WV  7 0   7
  7\& post L  ffi[3   7>6Bff

and let testV be defined as

Z
Z
Z
6 Z
V\[ 6BA
),+Q+>D   7 V\[ ff9= V\[  iff>8]e6 V 	0]   7 V\[ 
6
V . Now we can
Further, let   ,   , and  be fresh symbols not appearing in <3  <=JV <3JV 3 <
define the pair of compiled operators L V ( )ff: ) corresponding to the original operator L  W :
L V )ON pre L  H<=+\ V 6Bff postV V L  %< blockV ZL  %< testV <
+> V +>*/ V]ff^ `ffi V\[b6Q67<
+> V  V <9 V3 6 J+1= V  iff>8]e6Q6X<
+>
+ K:;
1
V 7 
 .6Q6&<
Z V\[ V]0 < Z V\[ )
6
V
+>
  <5( 3 <5  Z V\[ 6BA
{C

	Y 1 V

287

fiN EBEL

This pair of compiled operators achieves the intended effects and keeps track of fully known
atoms using postV , checks which conditional effects are blocked using block V , tests whether the
 $Dff post LB. using
execution of the previous operator satisfied the condition $Dff post LB.)
testV , and setup the bookkeeping atoms for the next step. Using the atoms /V , it is enforced that
executing and testing is merged by parallelizing the test on step  and execution of step 9 . In
order to check the execution of the last step, we need an extra checking step:

L V )ON +\ V B6 ff test V <=+> V +\`ff8 V Q6 6>PA
Now we can specify a compilation scheme  from 

> )

S s to  S  as follows:
6
6
N\
9
<
fi

s

9
<

<=+\`ffi I ffi{g6Bff
I <5  <5 I 3 <93 <
I <
_
+\L I ffiL   0tL  1?6fi<=+\L I ffiL   6>Pff
6
6
+>^4ffi/IBff8  6&<9(JI 5
< (  <5JI3 <3( 3 <5 I(<9  ff
+\v6Bff
$&%  \%
< $&%    +.-  0 -3=fft+.-ff"-H6Jff?)
 ]6>ff
/A

   )
>B )
 $ffi\ )
 $fft5)

The scheme  obviously satisfies conditions (2), i.e., that the state-translation functions are modular,
 polynomially sized results. Further, all the functions
and (3), i.e., that the compilation functions have
can be computed in polynomial time, and   is a   -instance.
S
Y   . Then it is obvious that
Assume D




 <   *)X!],z.$ffD(H<9>bff\NL I P.5ff1 
 <   ff
.$ff;!t]$Dff\NL> P..5ff1 
provided ;!t]$Dff\NL  P.0) 	 . In case ;!t]$Dff\NL  P.F0 ) 	 , either ;!t],  $ffD(&<  ff\NL I P.0 )
	 or M$Dff post L  .)   $Dff post L  . . In the latter case, the application of any operator to
;!t],  $ffD(ff\NL I P. leads to an inconsistent state because of the conditional effects in test  , which
is part of all postconditions of operators applicable in this state. Additionally, the same is true for
the relation between zb$ffX!]$Dff\NL>.ffiL 7 . and ;!],zi$ffD(H<?>.ff\NL I ffiL]7  P. .
Let   )~NL  ffgAgAgA\ffiL  P denote a sequence of operators corresponding to a sequence of operators
)~NL ffgAgAgA:ffiL>v P . Using induction on the plan length, it can be easily shown that







iff 

is a plan for

Further, since any plan solving the instance 



there exists a plan for



a` LAV


is a plan for 



.

must have LAV as the last operator, it follows that

iff there exists a plan for 



.

From that it follows immediately that  is a polynomial-time compilation scheme from 
preserving plan size exactly, which proves the claim.

S s

to 

S

Having proved that  s can be compiled to   preserving plan size exactly, it seems worth
S
S
noting that this result depends on the semantics chosen for executing conditional operators on partial state specifications. For example, if we use an alternative semantics that deletes all the literals


in 7 $Dff post LB.ZM$Dff post LB. provided $Dff post LB. is consistent, then there exists probably only a compilation scheme that preserves plan size linearly. If we use a semantics where the
288

fiC OMPILABILITY

AND

E XPRESSIVE P OWER OF P LANNING F ORMALISMS

resulting state specification is legal when the application of all state-transformation functions leads
to a theory that can be represented as a set of literals, it seems unlikely that there exists a scheme
that preserves plan size polynomially. The reason for this pessimistic conjecture is that under this
semantics it appears to be coNP-hard to determine whether the state specification resulting from
applying a  B -operator is legal.
S
As a second step in showing that partial state specifications and literals can be compiled away,
we show that we can compile   to   . The key idea in the proof is the same as in the proof of
S
!
Theorem 6. We replace each negative literal 4- by a new atom - . In order to detect inconsistencies
introduced by conditional effects, we add to each postcondition conditional effects of the form
!
+.-ff -%6 V 	 . Further, to check that the last operator in a plan does not introduce any inconsistencies,
we force the application of a checking operator that contains the same conditional effects.
Lemma 8

 S


is polynomial-time compilable to 



preserving plan size exactly.

Proof. Let
) N&ffifft9P be a  S  -instance with ) N$fftP . Since
postconditions of all operators L1 have the following form:

b

post LB()+\

Y

VXb gff AgAgA\ffi




:

VXb

:



is a

 S

-instance, the

6Bff

with ^7Bff 7
 .
!
As in the proof of Theorem 6,  shall be a disjoint copy of  , and "9 is the set of atoms where
!
c LQ be the following set
each negative literal 4- is replaced by the atom - . Now let post
post
c LB()+

?^7 V '"

b

"

fi<5)"5
7

b

\(097 VXb {7 fi
7

post LBe6BA

Further, let cons be the set of conditional effects
cons

),+Q+.-ff -H! 6 V 	0@-3/6Bff
!

let  be an atom not appearing in  , let L be

L! )~N'"

let

!

O)+ M
L! 0tL1?6

pre LBff
post
c LBH< cons <=+>

V 9v6>Pff

, and let the operator L> be

L>)~N$ff cons <=+> V ` 6>PA

Then we can specify a compilation scheme  from 

>Q )
   )
>s )
 $ffi\ )
zs$fft5)

S  to   as follows:
!
!
N$< <3+\v6Bff =
< +\L>Q6>Pff
+>^ `6Bff
+\v6Bff
"?(<5d
 "58ff
"=/A

 satisfies conditions (2) and (3), all the functions can be computed in polyThe scheme  obviously
nomial time, and   is a   -instance.
289

fiN EBEL

Assume D

Y 

. Then it is obvious that
!

 $ff$DffiLB.),  $ffD(ff LBff

provided $DffiLB0)	A

!

!

Y

!

In case $DffiLB;0 )	 , either ,  $ffD(ff LB;0 )	 or +.-ff -%6
,  $ffD(ff LB for some -=/ . In the
!
latter case, the application of any operator to ,  $ffDff LB leads to an inconsistent state because
of the conditional
effects in cons, which is part of all postconditions.
!
Let )N.-L ffgAgAgA:ff/L-  P denote a sequence of operators corresponding to a sequence of operators

)~NL ffgAgAgA:ffiL>vP . Using induction on the plan length, it can be easily shown that







iff 

is a plan for

Further, since any plan solving the instance 



there exists a plan for



!

`



L>

is a plan for 



.

must have L> as the last operator, it follows that

iff there exists a plan for 

It follows that  is polynomial-time compilation scheme from 
which proves the claim.

S

to 





.

preserving plan size exactly,

This result is, of course, not dependent on the semantics because both formalisms deal only with
 $Dff post LB. .
complete state specifications, and hence we always have M$Dff post LB.()
Theorem 9
size exactly.

 S s  ,  S  , ` s

, and 



are polynomial-time compilable to each other preserving plan

Proof.  B     follows from Lemma 8, Lemma 7 and Proposition 4. Using Propositions 4
S
and 5 and the fact that    s and  `B` s , the claim follows.

S

S

S

5. The Limits of Compilation when Preserving Plan Size Linearly
The interesting question is, of course, whether there are other compilation schemes preserving plan
size exactly than those we have identified so far. As it turns out, this is not the case. We will prove
that for all pairs of formalisms for which we have not identified a compilation scheme preserving
plan size exactly, such a compilation scheme is impossible even if we allow for a linear increase of
the plan size. For some pairs of formalisms we are even able to prove that a polynomial increase
of the plan size would not help in establishing a compilation scheme. These results are, however,
 fhe assumption. A preview
conditional based on an assumption that is slightly stronger than the eF)g
of the results of this section is given in Table 1. The symbol  means that there exists a compilation
scheme because the first formalism is a specialization of the second one. In all the other cases, we
specify the separation and give the theorem number for this result.
5.1 Conditional Effects Cannot be Compiled Away
First of all, we will prove that conditional effects cannot be compiled away. The deeper reason
for this is that with conditional effects, one can independently do a number of things in parallel,
which is impossible in formalisms without conditional effects. If we consider, for example, the
operator m d{_zac from Example 1, it is clear that it `propagates' the truth value of rsr]m and klu{h to
hQj]k y>k _ba nx and hBjsk klu>h nx , respectivelyprovided the state specification satisfies the precondition.
290

fiC OMPILABILITY



%s


 Qs


%s





%] 


%Q
j
 i

% 


Cor. 15

Cor. 12

Cor. 15

Cor. 15

ji

ji

4i

Theo. 11

Cor. 12

Cor. 12

ji

ji

4i

Cor. 12

Cor. 12

Cor. 19

)





ji



%









Cor. 15









Theo. 14

 i



)

















Cor. 15



Theo. 18






)

Cor. 19

%Q



 S s  


Cor. 15



 S



)

 S s k



E XPRESSIVE P OWER OF P LANNING F ORMALISMS

AND

 S 












Cor. 15



 i

)

Cor. 19



)

Table 1: Separation Results

It is obviously possible to come up with a set of exponentially many operators that can do the same
thing in one step. However, it is unclear how to do that with less than exponentially many operators.
In fact, we will show that this is impossible.
In order to illustrate this point, let us generalize the above example. We start with a set of 
propositional atoms &) +.- ffgAgAgA:ff-``6 and a disjoint copy of this set: ml ) +.- l 0-  ,fiv6 .
Further, if


D Y fi 



, then Dnl shall denote the corresponding set of literals over

D
Consider now the following 

 
 
 

)

 

o l

, i.e.,

)+.- l 0@-  =Dfi6&<=+>4- l 0g4-  /D6BA
l

S s

domain structure:

fi<5 l ff
B
) @*N$fft+.-  V - l ff"-  V 4- l 0@-  Wfiv6>P ff
) N$   ff8   PA
From the construction it follows that for all pairs fft5 such that  is a consistent and complete set
Y 1l , the instance )N `ffifft5P has a one-step plan. Conversely, for all pairs
over fi and 

fft9 with gff o l Y  1 l , there does not exist a solution.
Trying to define a   domain structure polynomially sized in 00   00 with the same property

seems to be impossible, even if we allow for  -step plans. However, in trying to prove this, it turns
out that an additional condition on the state-translation function is needed.
We say that the state-translation functions are local iff for all state specifications
 ff5 ) we have







 $  ff Dpff   qff s$  ffDff   ()A
291

D

and for

fiN EBEL

With locality as an additional condition on state-translation functions we could easily prove that
conditional effects cannot be compiled away. Instead of doing so we will show, however, that it
is possible to derive a weaker condition from the definition of compilation schemes that will be
enough to prove the impossibility result. This weaker condition is quasi-locality of state-translation
functions relative to a given set of symbols  , which in turn is based on the notion of universal
F
literals. A literal is called a universal literal for given state-translation functions on  iff one of
the following conditions is satisfied:
1. for all -3= :

F

2. for all -3= :

F

3. for all -3= :

F

4. for all -3= :

F

5. for all -3= :

F

6. for all -3= :

F

p   +.-6Bfft+.-H6> , or
p   +.-6Bfft+>4-H6> , or
p   +.-6BffeB , or
pzs +.-H6Bfft+.-H6> , or
pzs +.-H6Bfft+>4-H6> , or
pzs +.-H6BffeB .

Let r denote the set of universal literals. Now we define quasi-locality of state-translation functions relative to a set of propositional atoms  and the induced set of universal literals r as follows.
Y   such that D0)	 and for all pairs  ff Y  with  ff3 ) , we have
For each D







  Y W
r A

 $  ff Dff   sffzs$  ffDfiff







In words, the only non-local literals in quasi-local state-translation functions are the universal literals.
Lemma 10 For a given compilation scheme F)N>{ffe 
Y  such that 00ut^ and  and
exists a set of atoms 



ffe>Qff  ffz>P and natural number 
 are quasi-local on  .

, there

R;v be a function that has as the result the union of all results for all possible
Proof. Let t
translations of a literal returned by the state-translation functions, i.e.,
gl- *)   +.-H6Bfft+.-H6><   +.-H6Bfft+>"-H6><   +.-H6BffeB.<
s +.-H6Bfft+.-6>
< zB +.-H6Bfft+>4-H6>
< zs +.-H6BffeBA
Set

5)
w

and r) . Now we choose an infinite subset
w



of

w

such that either

1. for all -3xw  , there are only finitely many other atoms [xw" such that ,glor if such an infinite subset of w does not exist,
2.

w



has a universal literal

F

fi
 r

and we set r?`)
r<=+

F

6

Aff4g[Q.sUr )
 

,

.
F

 r must
Note that such an infinite subset w  must exist. The reason is that some literal y
occur for infinitely many atoms in over w because we could not find an infinite subset
satisfying condition (1). Because for a single atom there are only six possible ways to generate
F
, there must exist an infinite subset such that this literal occurs in all of either v +.-H6Bfft+.-H6> ,
F
v +.-H6Bfft+>4-H6> , or zv +.-H6BffeB (for ?)iff	 ) and in this subset is a universal literal.
292

fiC OMPILABILITY

AND

E XPRESSIVE P OWER OF P LANNING F ORMALISMS

If we can pick a subset satisfying the first condition, we can choose from it a finite subset  with
any desired cardinality such that the state-translation functions are quasi-local with respect to  and
r .
Otherwise we repeat the selection process with w  and r  until condition (1) is satisfied. This
selection process can only be repeated finitely often because otherwise there are some atoms such that tl-  has an infinite result, which is impossible because the state-translation functions are
polynomial-time computable and can therefore have only finite results.
This demonstrates that there always exists a set of propositional atoms such that the statetranslation functions are quasi-local. However, we might not be able to effectively determine this
set.
Using this result, we are finally able to prove the non-existence of compilation schemes for
compiling conditional effects away when preserving plan size linearly.
Theorem 11

 S s 

cannot be compiled to % preserving plan size linearly.

Proof. Assume for contradiction that there exists a compilation scheme  from  s to %Q preS
serving plan size linearly, which compiles the domain structure   defined above into the %

domain structure

>   )   )ON$   tff    PA
Because of Lemma 10 we can assume that the set of atoms   is chosen such that the translation

functions are quasi-local on this set.
Let us now consider all initial state specifications  that are consistent and complete over
and do not contain only positive or only negative literals:

Obviously, there are
following form

T

 {T

 



K
/R  I
 +>fi4ff(fiK6BA

such state specifications. By assumption, each

%Q

instance of the

N   ff5 .$   ffi\H<?>b   ff5  $  ffi l H<9     .P
has a  -step plan. Since there are only |i0  0 i  different  -step plans, which is a number polyno
mial in the size of   , the same plan  is used for different initial statesprovided  is sufficiently

large.
Suppose that the plan  is used for the pairs t fft ff\t fft  , which result from  and  :


   
   )  $fi4ffi  H<9    K
   )  $  ffi l %<9     
  )  $fi4ffi  H<9    K
  ) zs$fi`ffi l %<9>s  K

Since  )
    ,   and   must differ on at least one atom, say - . Without loss of generality we
assume -33 and 4-35 . Since  is a successful plan from   to   and because  is modular,




it follows that

X!]   ffeh}  

zs +.- l B6 fft+.- l >6 A

}~

293

fiN EBEL

Some of the literals in zs +.-Kl;6Bfft+.-KlX6> may be added by operators in  but none of the literals
in s +.- l 6Bfft+.- l 6> can be deleted by an operator in  without reestablishing this literal by another
operator after its deletion. Because  contains only operators with unconditional effects, it adds
and deletes the same literals regardless of the initial state.
F
Let us now assume that there exists a literal zs +.-Kl;6Bfft+.-KlX6> that is not added by  . This
F
implies that 3t and we have to distinguish three cases:


=    K , from which we conclude that F 3t .
F
2. p   +.K
- lX6BffeB Y t  , which also implies that F 3t .
F
3. 
that the state z. +\[s6Bffi& with [^)  K- l and ,+Q+\[s6BfftF +>*[s6Bffe]6 . Because we assumed
F
translation functions are quasi-local on   , must be a universal literal. If is universal for

F
contain positive and negative
 , then we will have It because the possible initial states
F
literals as well as no literal for some elements from   . If is universal for  , it is present
 F
in  and in  for the same reason. Further, because is not added by  and  is a valid


plan from t to  , it must also be part of of t .



F
In other words, all literals 
 s +.K- lX6Bfft+.K- lX6> that are not added by  are already in t  and t .
From that we conclude that
;!]  ffe }y s +.- l 6Bfft+.- l 6>A
1.

F

Now let

   )
    )

 $    +.- l 6Bffi l J+>4- l 6>H<9     ff
   
< s +.- l 6Bfft+.- l 6>
) zs$  4ffi l +>"- l 67<=+.- l 6>H<9>B  vA
Because z is modular, it is clear that  }   and therefore ;!t]t ffefi}   . Because 




achieves   as well as   +.-KlX6Bfft+.-KlX6> , it follows that (again because  is modular),  achieves

also     .

Since N  ffi ffi l Z+>4K
- l;67</+.E- l76>P does not have any plan, there should not be any plan for
 
N   ffi  fft    P . The  fact that  is a plan for this instance implies that  cannot be a compilation
scheme, which is the desired contradiction.
Using Propositions 4 and 5 as well as Theorem 9, this result can be generalized as follows (see
also Table 1).
Corollary 12 %Qs , %] , and  
preserving plan size linearly.

S s


cannot be compiled to %Q or any formalism specializing %

This answers the question of whether more space efficient compilation schemes from   to
S
 than the one proposed by Gazen and Knoblock (1997) are possible. Even assuming unbounded
computational resources for the compilation process, a more space efficient compilation scheme is
impossibleprovided that the compilation should preserve plan size linearly. If we allow polynomially larger plans, then efficient compilation schemes are possible (see Section 6).
8. This result demonstrates that the choice of the semantics can be very important. If we interpret conditional effects
sequentially as Brewka and Hertzberg (1993) do, then there exists an straightforward compilation scheme preserving
plan size exactly.

294

fiC OMPILABILITY

AND

E XPRESSIVE P OWER OF P LANNING F ORMALISMS

5.2 Non-Uniform Complexity Classes
In the next section we make use of so-called non-uniform complexity classes, which are defined
using advice-taking machines, in order to prove the impossibility of a compilation scheme. An
advice-taking Turing machine is a Turing machine with an advice oracle, which is a (not necessarily recursive) function  from positive integers to bit strings. On input  , the machine loads the
bit string  i00 "00 and then continues as usual. Note that the oracle derives its bit string only from the
length of the input and not from the contents of the input. An advice is said to be polynomial if the
oracle string is polynomially bounded by the instance size. Further, if  is a complexity class defined in terms of resource-bounded machines, e.g., P or NP, then J]pBnm  (also called non-uniform
X) is the class of problems that can be decided on machines with the same resource bounds and
polynomial advice.
Because of the advice oracle, the class P/poly appears to be much more powerful than P. HowY es]pBnm 
ever, it seems unlikely that P/poly contains all of NP. In fact, one can prove that fJe
implies certain relationships between uniform complexity classes that are believed to be very unlikely. For stating this result, we first have to introduce the polynomial hierarchy.
Let X be a class of decision problems. Then e+ denotes the class of decision problems 
that can be decided in polynomial time by a deterministic Turing machine that is allowed to use a
procedurea so-called oraclefor deciding a problem  , whereby executing the procedure
does only cost constant time. Similarly, fJe  denotes the class of decision problems  such that
 of
 in polynomial time using
there is a nondeterministic Turing-machine that solves all
instances



are defined as follows:
an oracle for ~p . Based on these notions, the sets  ,  , and










I

)

 V  )

 V   )

 )
V 









V

V

V



)
)eff
e I  ff I

 ff
fJe
ygn fJe   A

Thus,  )gfhe and

 )ygnfJe . The set of all classes defined in this way is called the polynomial
hierarchy, denoted by PH. Note that

F)  
  V I

e^


Y 




V


)  
 V Y I


V

) 
V I



Y


V



"A

e sekD

Further we have, 
ff
and  ff
 V   . As with other classes, it is unknown whether
V
V
V
V
V
the inclusions between the classes are proper. However, it is strongly believed that this is the case,
i.e., that the hierarchy is truly infinite.
Based on the firm belief that the polynomial hierarchy is proper, the above mentioned question
Y eE]pBnm  can be answered. It has been shown that fJe Y es]pBnm  would imply
  that
of whether fJe

the polynomial hierarchy collapses on the second level (Karp & Lipton, 1982), i.e.,  )
Y yg nfhes] pB.nThis,
m  or
however, is considered to be quite unlikely. Further, it has been shown that fJe
Y
ygnfJe  fJ es ]pBnm  implies that the polynomial hierarchy collapses at the third level (Yap, 1983),
i.e., 
)  , which again is considered to be very unlikely. We will use these result for proving

that for some pairs of formalisms it is very unlikely that one formalism can be compiled into the
other one.
9. The super-script  is only used to distinguish these sets from the analogous sets in the Kleene hierarchy.

295

fiN EBEL

5.3 On the Expressive Power of Partial State Specifications and Boolean Formulae
In all the cases considered so far, operators over partial state specifications could be compiled to
operators over complete state specifications, i.e., partial state specifications did not add any expressiveness. This is no longer true, however, if we also allow for arbitrary boolean formulae in
preconditions and effect conditions. In this case, we can decide the coNP-complete problem of
whether a formula is a tautology by deciding whether a one-step plan exists. Asking, for example,
if the  Q -instance N$fft+]Nff	KPe6Bffefft+\v6>P has a plan is equivalent to asking whether  is a tautology.
Let the one-step plan existence problem (1-PLANEX) be the PLANEX problem restricted to
plans of size one. From the above it is evident that %QB -1-PLANEX and %Q -1-PLANEX are
coNP-hard. Let - be some fixed polynomial, then the polynomial step plan-existence problem
(- -PLANEX) is the PLANEX problem restricted to plans that have length bounded by -  , if  is
the size of the planning instance. As is easy to see, this problem is in NP for all formalisms except
%QB and %Q . The reason is that after guessing a sequence of operators and state specifications of
polynomial size, one can verify for each step in polynomial time that the precondition is satisfied
by the current state specification and produces the next state specification. Since there are only
polynomially many steps, the overall verification takes only polynomial time.
Proposition 13  -- -PLANEX can be solved in polynomial time on a nondeterministic Turing machine for all formalisms different from %s and %Q .
From the fact that % -1-PLANEX is coNP-hard and, e.g., %s -p-PLANEX is in NP, it follows
almost immediately that there is no polynomial-time compilation scheme from  Q to  ] that
 ygnfJe ). However, even if we allow for unbounded
preserves plan length polynomially (if fhe)
computational resources of the compilation process, a proof technique first used by Kautz and Sel
).
man (1992) can be used to show that such a compilation scheme cannot exist (provided  ) 



Theorem 14

%Q

cannot be compiled to %] preserving plan size polynomially, unless 



 )

 

.

Proof. Let  be a propositional formula of size  in conjunctive normal form with three literals per
clause. As a first step, we construct for each  a % domain structure * with size polynomial in 
and the following properties. Unsatisfiability of an arbitrary 3CNF formula  of size  is equivalent
to  -step plan existence for the % -  -PLANEX instance N8`ffi1 fft+\`6>P , where 1 can be computed
in polynomial time from  .
Given a set of  atoms, denoted by  , we define the set of clauses  to be the set containing
all clauses with three literals that can be built using these atoms. The size of   is |    , i.e.,
polynomial in  . Let ? be a set of new atoms -E .    corresponding one-to-one to the clauses
in  . Further, let 
B

)@9 F   F   F  M-  .     (0\+ F  ff F  ff F  6M A
We now construct a % domain structure 8)~N$fivfftKP for all formulae of size  as follows:

 
&




)

)

<?<=+\v6Bff
+]N +> v6Bfft+\v6>Pe6BA


296

fiC OMPILABILITY

AND

E XPRESSIVE P OWER OF P LANNING F ORMALISMS

Let  be a function that determines for all 3CNF formulae  , which atoms in ? correspond to the
clauses in the formula , i.e.,

*()+.-  .     0\+ F  ff F  ff F  63(6BA
Now, the initial state for any particular formula  of size  is computed as follows:
 )h *H<1 ?M~*.H<=+>^v6BA
1
From the construction, it follows that there exists a one-step plan for N$&`fft`ffi1"fft+\v6>P


iff



is

unsatisfiable.
Let us now assume that there exists a compilation scheme  from %Q to %] preserving plan
size polynomially. Further, let us assume that the % domain structure 8 is compiled to the %]
domain structure * )N$fi fft P . Using this compiled domain structure, we can construct the
following advice-taking Turing machine.
On input of a formula  of size  , we load the advice N8 ffe  $&`fftffe>]$&`fft.P . This
advice is polynomial because 8 is polynomial in the size of  and a compilation scheme generates
only polynomially larger domain structures. Because  is a polynomial-time function and 1 can
be computed from  in polynomial time, we can compute

  )
 .$  ffi  % <9>b$  fft  
in polynomial time. Also the goal specification

  )  $  fft+\v6><9  $  fft  
can be computed in polynomial time. Finally, we decide the - -PLANEX problem on the resulting
%] -instance N  ffi  fft  P . From Proposition 13 we know that this can be done in polynomial time

on a nondeterministic Turing machine.
Because deciding - -PLANEX for N  ffi  fft  P is equivalent to deciding  -PLANEX for
N84ffi1"fft+\v6>P , which is in turn equivalent to deciding unsatisfiability of  , it follows that we can
decide a coNP-complete problem on a nondeterministic, polynomial advice-taking Turing machine
Y fhe5]pBnm  . Using Yap's (1983) result, the
in polynomial time. From that it follows that ygnfJe
claim follows.
Using Proposition 4 and Proposition 5, the above result generalizes as follows (see also Table 1).

Corollary 15 %Qs and % cannot
be
  compiled to any of the other planning formalisms preserving

.
plan size polynomially, unless  )





If we restrict the form of the formulae, however, we may be able to devise compilation schemes
from %Q to, e.g., % . Reconsidering the proof of the last theorem, it turns out that it is essential
to use the negation of a CNF formula as a precondition. If we restrict ourselves to CNF formulae
in preconditions, it seems possible to move from partial to complete state descriptions using ideas
similar to the ones used in the proof of Lemma 7.
However, no such compilation scheme will work for %s . The reason is the condition
$Dff post LB.)  $Dff post LB. in the definition of the function  . If this condition is not satisfied, the result of the operator is inconsistent. This condition could be easily employed to reduce
unsatisfiability of CNF formulae to 1-step plan existence, which enables us to use the same technique as in the proof of the above theorem.
297

fiN EBEL

5.4 Circuit Complexity
For the next impossibility result we need the notions of boolean circuits and families of circuits.
A boolean circuit is a directed, acyclic graph )'*ff , where the nodes  are called gates.
Each gate 2
 has a type K!,2K+>fifffiff
&ff:ffi6<F+1 ff ffgAgAgA26 . The gates with K!,2K
 
+sffiff  ff  ffgAgAgA26 have in-degree zero, the gates with K!,2K+>6 have in-degree one, and the
gates with K!,2K+>
fiff6 have in-degree two. All gates except one have at least one outgoing
edge. The gate with no outgoing edge is called the output gate. The gates with no incoming edges
are called the input gates. The depth of a circuit is the length of the longest path from an input gate
to the output gate. The size of a circuit is the number of gates in the circuit.
Given a value assignment to the variables +1
output gate in the obvious way. For example, for 
gate of the circuit shown in Figure 4.

 ff   ffgAgAgA6 , the circuit computes the value of the
 )~ and   ) we get the value 1 at the output







 



Figure 4: Example of a boolean circuit

Instead of using circuits for computing boolean functions, we can also use them for accepting

words of length  in +\ff:>6  . A word  )H AgAgA4+\ff:>6 is now interpreted as a value

assignment to the  input variables  ffgAgAgA:ff4 of a circuit. The word is accepted iff the output gate

has value 1 for this word. In order to deal with words of different length, we need one circuit for
each possible length. A family of circuits is an infinite sequence  )O' ff( ffgAgAgAw , where  has

 input variables. The language accepted by such a family of circuits is theI set of words  such that
  8 accepts  .
Usually, one considers so-called uniform families of circuits, i.e., circuits that can be generated
on a Turing machine with a Pk( -space bound. Sometimes, however, also non-uniform families are
interesting. For example, the class of languages accepted by non-uniform families of polynomiallysized circuits is just the class P/poly introduced in Section 5.2.
Using restrictions on the size and depth of the circuits, we can now define new complexity
classes, which in their uniform variants are all subsets of P. One class that is important in the
following is the class of languages accepted by uniform families of circuits with polynomial size
and logarithmic depth, named NC  . Another class which proves to be important for us is defined
in terms of non-standard circuits, namely circuits with gates that have unbounded fan-in. Instead of
restricting the in-degree of each gate to be two at maximum, we now allow an unbounded in-degree.
The class of languages accepted by families of polynomially sized circuits with unbounded fan-in
and constant depth is called ACI .
298

fiC OMPILABILITY

AND

E XPRESSIVE P OWER OF P LANNING F ORMALISMS

Y

From the definition, it follows almost immediately that AC I
NC  . Moreover, it has been
shown that there are some languages in NC  that are not in the non-uniform variant of ACI , which
implies that AC I )  NC  (Furst, Saxe, & Sipser, 1984).
5.5 Boolean Formulae Cannot be Compiled to Conditional Effects
As we have seen in Section 5.3, Boolean formulae are quite expressive if they are used in combination with partial state specifications. However, what if all state specifications are complete? In
this case, it seems to be possible to simulate the evaluation of CNF formulae by using conditional
effects. In fact, it is possible to compile in polynomial-time, for example, % to   preserving plan
S
size linearly, provided all formulae are in conjunctive normal form. Each operator would have to
be split into two operators, one that evaluates the clauses of all the formulae in the original operator
and one that combines these evaluations and takes the appropriate actions, e.g., asserting 	 if the
precondition is not satisfied. Sequencing of these pairs of operators can be achieved by introducing
some extra literals.
What can we say about the general case, however? When trying to simulate the evaluation of
an arbitrary logical formula using conditional effects, it seems to be the case that we need as many
operators as the nesting depth of the formula, which means that we would need plans that cannot be
bounded to be only linearly longer than the original plans.
We will use the results sketched in Section 5.4 to separate % and   . In order to do so, let us
S
view domain structures with fixed size plans as machines that accept languages. For all words 
consisting of  bits, let

8)ON$fi<=+\`6BfftvPA
Assume that the atoms in fi are numbered from 1 to  . Then a word 

consisting of  bits could

be encoded by the set of literals

 ,
) +.-  0

if the  th bit of  is

 6fi<=+>4-  0 if the  th bit of  is K6BA

Conversely, for a consistent state specification D fi , let   be a word such that the  th bit is 1 iff
-  /D .
We now say that the  -bit word  is accepted with a one-step or  -step plan by 8 iff there
exists a one-step or  -step plan, respectively, for the instance

)~N.N$fi<=\+ v6BfftKPffi  <=+>^ v6Bfft\+ `6>PA
Similarly to families of circuits, we also define families of domain structures, ) ffe ffgAgAgA .

I
The language accepted by such a family with a one-step (or  -step) plan is the set of words accepted
using the domain structure 8 for words of length  . Borrowing the notion of uniformity as well,
we say that a family of domain structures is uniform if it can be generated by a Pk -space Turing
machine.
Papadimitriou has pointed out that the languages accepted by uniform polynomially-sized
boolean expressions is identical to NC  (Papadimitriou, 1994, p. 386). As is easy to see, a family of % domain structures is nothing more than a family of boolean expressions, provided we use
one-step plans for acceptance.
Proposition 16 The class of languages accepted by uniform families of % domain structures using
one-step plan acceptance is identical to NC  .
299

fiN EBEL

If we now have a closer look at what the power of  -step plan acceptance for families of  
S
domain structures is, it turns out that it is less powerful than NC  . In order to show that, we will first
prove the following lemma that relates  -step   plans to circuits with gates of unbounded fan-in.

S

Y

Lemma 17 Let F)~N$fftP be a   domain structure, let 
  , and let  be a  -step plan over
S
 . Then there exists a polynomially sized boolean circuit  with unbounded fan-in and depth >;fiT
such that  is a plan for N&ffifft5P iff the circuit  has value 1 for the input  .
Proof. The general structure of a circuit for a  -step



.
.
.



plan is displayed in Figure 5. For each







1

1

.....



.
.
.

.
.
.



.
.
.

1

 S







1

.
.
.

.....



. . . s





Figure 5: Circuit structure and goal testing for a  -step 

S

plan

7

plan step (or level) 8 and each atom -  , there is a connection -  . The connections on level  are
the input gates, i.e., - I )  . The goal test is performed by an 
 -gate that checks that all the goals
are true on level  , in our case )+.- ff4- ff-  6 . Further, using the  -gate, it is checked that no
 
inconsistency was generated when executing the plan.
For each plan step 8 , it must be computed whether the precondition is satisfied and what the
result of the conditional effects are. Figure 6 (a) displays the precondition test for the precondition
+.-  ff-  ff4-  6 . If the conjunction of the precondition literals is not true, 	 V becomes true, which is
connected to the  -gate in Figure 5.
Without loss of generality (using a polynomial transformation), we assume that all conditional
VGF . Whether the effect F is activated on level 8 is computed by a circuit as
effects have the form 
V 4-  .
displayed in Figure 6 (b), which shows the circuit for +.- ff4- 6
 
Finally, all activated effects are combined by the circuit shown in Figure 6 (c). For all atoms -  ,
we check whether both -  and 4-  have been activated, which would set 	 true. This is again one
of the inputs of the  -gate in Figure 5. If neither -  nor 4-  have been activated, the value of -  on
level 8N is determined by the value of -  on level 8 . Otherwise the value of -  on level 8 is
7
determined by the value of -W , i.e., the activation value of the positive effect -  on level 8 .
The depths of the circuits in Figure 6 (b) and (c) dominate the depth of the circuit necessary to
represent one plan step leading to the conclusion that a plan step can be represented using a circuit
of depth 7. Adding the depth of the goal testing circuit, the claim follows.
The lemma implies that   -step plan acceptance is indeed less powerful than % 1-step plan
S
acceptance, which means that a compilation scheme from % to   preserving plan size linearly is
S
impossible.
300

fiC OMPILABILITY

AND

E XPRESSIVE P OWER OF P LANNING F ORMALISMS


 



 


1z 



 

 




...







s








( 

( 



(a)



 



 

 z 

(b)



 z 

(



(c)

Figure 6: Circuit structure for precondition testing (a), conditional effects (b), and the computation
of effects (c) for   operators

S

Theorem 18

   i 

, for all members



S s

of the 

-class.

Proof. We show that %1  i   , from which by Theorem 9 and Proposition 4 the claim follows.
S
Assume for contradiction that    i   . Let )  ffe ffgAgAgA be a uniform family of  
S

I
domain structures and `)8 ffe8 ffgAgAgAw be the   domain structures generated by a compilation
S

I
scheme  that preserves plan size linearly. By Lemma 17 we know that for each   domain
S
structure   )~N$  fft  P and given goal   we can generate a polynomially sized, unbounded fanin circuit with depth >T that tests whether a particular  -step plan achieves the goal. In order to
decide  -step plan existence, we must test |i0  0 ie different plans, which is polynomial in the size
of 8 because  is a compilation scheme. For each plan, we can generate one test circuit, and by
adding another  -gate we can decide  -step plan existence using a circuit with depth >W and size
polynomial in the size of 8 . Further, since the state-translation functions are modular, the results
of  for fixed  can be computed using an additional level of gates. Since by Proposition 16 all
languages in NC  are accepted by uniform families of % domain structures using one-step plan
acceptance, our assumption % i   implies that we can accept all language in NC  by (possibly
S
non-uniform) ACI circuits, which is impossible by the result of Furst and colleagues (1984).
Using the Propositions 4 and 5 again, we can generalize the above theorem as follows.
Corollary 19

 ]

and 



cannot be compiled to



 S B A

or



 S  

preserving plan size linearly.

6. Compilability Preserving Plan Size Polynomially
As has been shown in the previous section, only the compilation schemes induced by Propositions 4
and 5 and the ones identified in Section 4 allow for compilation schemes preserving plan size exactly. For all other pairs of formalisms we were able to rule out such compilation schemeseven
301

fiN EBEL

if we allow linear growth of the resulting plans. Nevertheless, there might still be a chance for
compilation schemes preserving plan size polynomially. Having shown that %Qs and %Q cannot
be compiled to the other formalisms even if the plan can grow polynomially, we may still be able
to find compilation schemes preserving plan size polynomially for the %Qs /% pair and for the
remaining formalisms.
A preview of the results of this section is given in Figure 7. As it can be seen, we are able

`{>

 >

 >

 

 {

 B

 >

 

 



 


Figure 7: Equivalence classes of planning formalisms created by polynomial-time compilation
schemes preserving plan size polynomially. Compilation schemes constructed in this
section are indicated by dashed lines

to establish compilation schemes preserving plan size polynomially for all pairs of formalisms for
which we have not proved the impossibility of such compilation schemes.
6.1 Compiling Conditional Effects Away for Partial State Specifications
The first compilation scheme we will develop is one from  Qs to  Q . As before, we assume that
the conditional effects have only singleton effect sets. Further, since we can use arbitrary boolean
formulae in the effect conditions in  Qs , we assume that there is only one rule for each effect literal.
Using a simple polynomial transformation, arbitrary sets of operators can be brought into this form.
 $Dff post LB. considerably, because now
This simplifies checking the condition $Dff post LB.)
only one rule can activate a particular literal.
302

fiC OMPILABILITY

AND

E XPRESSIVE P OWER OF P LANNING F ORMALISMS

In order to simulate the parallel behavior of conditional effects, we have to break them up into
individual operators that are executed sequentially. This means that for each conditional effect of
an operator we introduce two new operators. One simulates the successful application of the rule,
the other one simulates the blocking situation of the rule. At least one of these operators must
be executed for each conditional effect in the original operator. This is something we can force
by additional literals that are added to control the execution of operators. All in all this leads to a
sequence of operators that has length bounded by the number of conditional effects in the original
operator.
If we want to simulate the parallel behavior by a sequence of unconditional operators, the effects
of the unconditional operators should not directly influence the state description, but the effect
should be deferred until all operators corresponding to the set of conditional effects have been
executed. For this reason, we will use a sequence of copying operators which copy the activated
effects to the state description after all conditional operators have been executed. These copying
operators can also be used to check that the set of activated effects is consistent.
Theorem 20

 Qs

can be compiled to 

Q

in polynomial time preserving plan size polynomially.

Proof. Assume that ) N$fftP is the %QB source domain structure and assume further, without
loss of generality (using a polynomial transformation), that all operators have the form

L  )~N pre L  fft+{    VXF    ffgAgAgA\ffe   : VGF   :fiz6>Pff
F
F
F
with    73  ,   7  , and   7)    for X
)  .
V
Let   and  3 be disjoint copies of  , which are used to record the active effects of conditional
be another disjoint copy, which is used to record that an active effect has not
effects, and let 
l
been copied yet. Further, let m
 J),+.-4*0zLW?6 be a new set of atoms corresponding one-to-one to
6
the operators in  and let be a set of symbols corresponding one-to-one to all conditional effects
in  , i.e.,
6
V F   7 & post L>@ffiL{81?6BA
),+14  7 0  7 X
Finally, let  be a fresh atom not appearing in <=  </ 3 </
<= that signals that copying
l
the active effects to the state specification is in progress. The set of symbols   for the compiled
domain structure is then

  )F<9  <5
3

<5
l

<9m<

6

</+\\6BA

For each operator L   , the compilation scheme introduces a number of new operators. The
first operator we introduce is one which checks whether the conditional effects of the previous
operators have all been executed, no copying is in progress and the precondition is satisfied. If this
is the case, the execution of the conditional effects for this operator is started:

L pre
 )~N pre L{$H<5


6

<=+>8{6Bff(+.- b 6&<3(7?<5(43<5

<3(
l

PA

This operator enables all the conditional effect operators. For the activated effects, we introduce
the following operators:

Lk    7 ~
) N +.-4b4
5   7Q6Bff*+1   7>6&</+.-  ffl

303

0z-?) F   7>67<=+.- 3 ff l

0:4-) F   76>PA

fiN EBEL

In words, if the effect condition is entailed, then the activated positive or negative effect as well as
the fact that the rule has been tried is recorded.
Since there is at most one effect literal for each conditional effect, a conditional effect is
blocked if the negation of the  effect condition is entailed by the state specification. For all
blocked conditional effects we introduce the following operators:

L   7 ~
) N +.- b 
5(  7 6Bff(+1`  7 6>PA

In order to check that all conditional effects have been tried (activating the corresponding effect
or not activating it because the conditional effect is blocked), the following operator is used:

L  O
) N +.-4bb6fi<=+1   7

6

0   7 VGF   7\

post L

 e6Bff(+\{6&<=+>"-4bb6>PA

This operator enables copying of the activated effects to the state specification, which is achieved
with the following set of operators for each atom -3/ :


L

L
L



)
3


)

)

N +\>ff-  ff4- 3 ff- l B6 fft+.-ff"- l >6 Pff
N +\>ff4-"ff-53(ff- l B6 fft+>4-ff4- l >6 Pff
N +\>ff-  ff- 3 ff- l 6Bff
	 PA

Finally, we need an operator that checks that all possible effects have been copied. This operator
also starts the execution cycle again by enabling the execution of another precondition operator:

Li ~
) N +\{67<3(
l

ff8+>*\6>PA

Using these definitions, we can now specify the set of compiled operators:

pre

  )+\L  ffiL  0L  1?6&< VHF
+\L     7 0L  ?ff\   7 VXF   7\fi post L  e67<
+\L     7  0L   19ff\   7
  7\& post L  e6&<
+\L  ffiL 3 ffiL  0 -3W6fi<
+\LAit6BA
Based on that, we specify a compilation scheme )ON>{ffe>zffe  ff zff  P as follows:
>> ) N$  fft  P
6
>b ) (7?<5(
 3<9 l <3(  <5 </+>8{6Bff
>s ) (m
 <3+>*\6Bff
 $ffi\ ) ff
zs$fft9) =A
The scheme  obviously satisfies conditions (2) and (3)
 for compilation schemes
 and all the functions can be computed in polynomial time. Further,   is a  Q -instance if is a   s -instance.
Let now D   be a legal %s state specification and let D  ) $DffiL   for some operator
it is clear that if D0)	 , then there exists a sequence  of
L>X . From the above discussion,
   7 and L    7 followed
pre
operators from   consisting of L  , followed by operators of the form L 


by the operator L  , followed in turn by operators L  , followed finally by the operator L i , such that
D  );!t]$D5<9  ffe  s ffF A
304

fiC OMPILABILITY

AND

E XPRESSIVE P OWER OF P LANNING F ORMALISMS

Conversely, if D8%0 )	 , then there does not exist any plan that transforms

$D5<9>bffiL pre
 
into a legal state specification that contains 8 and 4-4b .
Using
 induction on the plan length, it follows from the arguments above that there exists a plan
 for iff there exists a plan  for   and for every such plan we have 00 @00v00 300  M 
T <= , with <
being the maximum number of conditional effects in operators of  . Hence  is a
polynomial-time compilation scheme preserving plan size polynomially.
An immediate consequence of this theorem is that %s and %Q form an equivalence class with
respect to compilability preserving plan size polynomially.
Corollary 21
polynomially.

%Qs

and

%

are polynomial-time compilable to each other preserving plan size

Further, we know from Corollary 15 that this class cannot become larger.
As in the case of compiling  s to   , however, the result depends on the semantics chosen
S
S
for executing conditional effects over partial state specifications. If we use the alternative semantics where the resulting state specification is legal when the application of all state-transformation
functions leads to a theory that can be represented as a set of literals, it seems likely that there exists
another scheme that preserves plan size polynomially. However, if we use the alternative semantics


that deletes all the literals in ; $Dff post LB.(I$Dff post LB. if $Dff post LB is consistent, then it
appears to be very unlikely that we are able to identify a compilation scheme that preserves plan
size polynomially.
6.2 Compiling Conditional Effects Away for Complete State Specifications
The next compilation scheme compiles %] to % and   to  . Since we deal with complete state
S
S
 $D8ff post LB. , which
specification, we do not have to take care of the condition M$D8ff post LB.M)
is always true for complete states. This makes the compilation scheme somewhat simpler. Since
 S does not allow for general boolean formulae, the scheme becomes a little bit more difficult. In
general, however, the compilation scheme we will specify is very similar to the one given in the
proof of Theorem 20.
Theorem 22 %] can be compiled to
serving plan size polynomially.

%

and 

S

can be compiled to 

S

in polynomial time pre-

Proof. As in the proof of Theorem 20, we assume that ) N$fftP is the (%] or
domain structure. Further, we assume that all operators have the form

V F   :b6>Pff
L  )~N pre L  fft+ U    VXF    ffgAgAgA\ff U   : X
F
U Y   if  is a %] structure or U   7 Y   if  is a  
with   7M   and   7
S

 S

) source

structure. This means
that we do not assume the effects to be unique for each conditional effect.
In addition, we assume the same set symbols for the compiled domain structure as in the proof
of Theorem 20:

  )F<9  <5

3

<5

305

l

<9m<

6

</+\\6BA

fiN EBEL



pre
For each operator L   , we introduce the operators L  , L  , L
Theorem 20.
In addition, the following operators are needed:


Lk    7 )
L     7e : )

 ,L


3

,L




N +.-4bb6&< U   7>ff*+1   7Q6fi<=+.-  ff - l 0@-?) F   76&<=+.- 3 ff N +.-4bb6&</+>*   7e :0t   7e : U   76Bff*+1   7>6>PA

, and L

l

i

as in the proof of

0:4-) F   76>Pff

The
compiled set of operators  contains all of the above operators and the compilation scheme is

identical to the scheme presented in the proof of Theorem 20. This means that the only significant
difference to the compilation scheme presented in the proof of Theorem 20 is the operator scheme
L     7e : which tests for each rule whether it contains an effect condition that blocks the rule. Since
we have complete state specifications, every conditional effect is either activated or blocked, and
the    7 's are used to record that the execution of each conditional effect has been tried.
Using now similar arguments as in the proof of Theorem 20, it follows that this compilation
scheme is indeed a scheme that leads to the claim made in the theorem.


It follows that  s and   are equivalent with respect to   and all formalisms in   s  and
S

    are equivalent with respect to   . These two sets could be merged into one equivalence class,
S
provided we are able to prove that, e.g., % can be compiled to  .

S

6.3 Compiling Boolean Formulae Away
In Section 5.5 we showed that it is impossible to compile boolean formulae to conditional effects if
plans are only allowed to grow linearly. However, we also sketched already the idea of a compilation
scheme that preserves plan size polynomially. Here we will now show that we can compile boolean
formulae to  , which is expressively equivalent to basic STRIPS, i.e., we can compile boolean
S
formulae away completely.
Theorem 23

%

is polynomial-time compilable to 

S

preserving plan size polynomially.

Proof. Assume that F)ON$fftP is a   domain structure. Further assume without loss of generality
Y   and   =  (i.e., we have just
that all operators L  1 are of the form L  )ON  ffi  P , with  
one formula as the precondition instead of a set of formulae).
Let m and   be two new sets of atoms corresponding one-to-one to all sub-formulae occurring in preconditions of operators in  . These new atoms are denoted by [\ and [>  for the
sub-formula  . Atoms of the form [{ are used to record that the truth-value of the sub-formula 
has been computed and the atoms of the form [\ are used to store the computed truth-value.
For each operator L  )~N  ffi  P , we will have in the target operator set the following operator:

L  )ON +\[Q.ffi[ B  6Bffi  <5(  PA
The set of all operators generated in this way is denoted by   .
Further, for each atom -3/ , we introduce the following two operators:

L 
L



3

)

)

N +.-6Bff*+\[   ffi[  6>Pff
N +>"-H6Bff*+\[   ff8[  6>PA

The set of operators generated in this way is denoted by
306

 

.

fiC OMPILABILITY

AND

E XPRESSIVE P OWER OF P LANNING F ORMALISMS

For each sub-formula occurring in preconditions of
operators are introduced:

L 

L  )
L 3  )
For sub-formulae J)

 
 
L  
L  
L 3

of the form )

 
p 

the following

N +\[   ffi[   ffi[\  ffi[\  B6 fft+\[  ffi[\6>Pff
N +\[   ff*[\  6Bfft+\[  ff8\[ H6>Pff
N +\[   ff *[\  6Bfft+\[  ff8\[ H6>PA
)

3



 , the following operators are introduced:
) N +\[   ffi\[   6Bfft+\[  ffi\[ 6>Pff
) N +\[   ffi\[   6Bfft+\[  ffi\[ 6>Pff
) N +\[   ffi[   ff8\[   ff81[   6Bfft+\[  ff*\[ H6>PA

Finally, for J)^ , we have the following operators:

L 
L



3

)

)

N +\[   ff 8[  6Bfft+\[  iff [\6>Pff
N +\[   iff [  6Bfft+\[  ff8\[ 6>PA

The set of operators generated by sub-formulae is denoted by
Now we can specify the compilation scheme  :

>)
  )
>B)
 $ffi\)
s$fft9)



.

$N <9m9<5  ff8  </  </U*Pff
  ff
  ff
ff
/A

From the construction it is obvious that all the functions are polynomial-time computable, that

 the induced function  is a reduction,
and that for
the state-translation functions are modular, that
every plan  for a source planning instance there exists a plan  for   such that 00 @00
00 300  ,<^\ , with < being the maximum number of sub-formulae of preconditions in  . From
that, the claim follows.
There might be the question whether compiling boolean formulae away could be done more
efficiently. Using the result that boolean expressions can be evaluated by circuits with logarithmic
depth, this should be indeed possible. However, we are satisfied here with the result that there is
a compilation scheme preserving plan size polynomially at all. This result together with Theorem 22 settles the question for compilation schemes preserving plan size polynomially for all pairs
of formalisms.
Corollary 24 All formalisms  with  
S
each other preserving plan size polynomially.

s

or

307

 %]

are polynomial-time compilable to

fiN EBEL

6.4 Parallel Execution Models and the Feasibility of Compilation Schemes Preserving Plan
Size Polynomially
While compilation schemes that preserve plan size exactly or linearly seem to be of immediate use,
a polynomial growth of the plan appears to be of little practical interest. Considering the practical
experience that planning algorithms can roughly be characterized by their property of how many
steps they can plan without getting caught by the combinatorial explosion and the fact that this
number is significantly smaller than 100, polynomial growth does not seem to make much sense.
If we take GRAPHPLAN (Blum & Furst, 1997) into consideration againthe planning system
that motivated our investigation in the first placeit turns out that this system allows for the parallel
execution of actions. Although parallel execution might seem to add to the power of the planning
system considerably, it does not affect our results at all. If a sequential plan can solve a planning
instance with  steps, a parallel plan will also need at least  actions. Nevertheless, although the size
of a plan (measured in the number of operations) might be the same, the number of time steps may
be considerably smallerwhich might allow for a more efficient generation of the plan. Having a
look at the compilation scheme that compiles conditional effects away, it seems to be the case that
a large number of generated actions could be executed in parallelin particular those actions that
simulate the conditional effects.
However, the semantics of parallel execution in GRAPHPLAN is quite restrictive. If one action
adds or deletes an atom that a second action adds or deletes or if one action deletes an atom that
a second action has in its precondition, then these two actions cannot be executed in parallel in
GRAPHPLAN . With this restriction, it seems to be impossible to compile conditional effects away
preserving the number of time steps in a plan. However, a compilation scheme that preserves the
number of time steps linearly seems to be possible. Instead of such a compilation scheme, the
approaches so far either used an exponential translation (Gazen & Knoblock, 1997) or modified the
GRAPHPLAN -algorithm in order to handle conditional effects (Anderson et al., 1998; Koehler et al.,
1997; Kambhampati et al., 1997). These modifications involve changes in the semantics of parallel
execution as well as changes in the search procedure. While all these implementations are compared
with the straightforward translation Gazen and Knoblock (1997) used, it would also be interesting
to compare them with a compilation scheme based on the ideas spelled out in Theorem 22 as the
base line.

7. Summary and Discussion
Motivated by the recent approaches to extend the GRAPHPLAN algorithm (Blum & Furst, 1997) to
deal with more expressive planning formalisms (Anderson et al., 1998; Gazen & Knoblock, 1997;
Kambhampati et al., 1997; Koehler et al., 1997), we asked what the term expressive power could
mean in this context. One reasonable intuition seems to be that the term expressive power refers
to how concisely domain structures and the corresponding plans can be expressed. Based on this
intuition and inspired by recent approaches in the area of knowledge compilation (Gogic et al., 1995;
Cadoli et al., 1996; Cadoli & Donini, 1997), we introduced the notion of compilability in order to
measure the relative expressiveness of planning formalisms. The basic idea is that a compilation
scheme can only transform the domain structure, i.e., the symbol set and the operators, while the
initial state and the goal specification are not transformedmodulo some small changes necessary
for technical reasons. Further, we distinguish compilation schemes according to whether the plan
in the target formalism has the same size (up to an additive constant), a size bounded linearly by the
308

fiC OMPILABILITY

AND

E XPRESSIVE P OWER OF P LANNING F ORMALISMS

size of the plan in the source formalism, or a size bounded polynomially by the original planning
instance and the original plan.
Although the compilability framework appears to be a straightforward and intuitive tool for
measuring the expressiveness of planning formalisms, it is possible to come up with alternative
measures. Backstrom (1995), for instance, proposed to use ESP-reductions, which are polynomial
many-one reductions on planning problems that preserve the plan size exactly. However, requiring
that the transformation should be polynomial-time computable seems to be overly restrictive. In
particular, if we want to prove that one formalism is not as expressive as another one, we had better
proven that there exists no compilation scheme regardless of how much computational resources
the compilation process may need. Furthermore, there appear to be severe technical problems to
using Backstrom's (1995) framework for proving negative results. On the other hand, all of the
positive results reported by Backstrom are achievable in the compilation framework because the
transformations he used are in fact compilation schemes. Taking all this together, it appears to be
the case that the compilation framework is superior from an intuitive and technical point of view.
Another approach to judging the expressiveness of planning formalisms has been proposed by
Erol and colleagues (1994, 1996). They measure the expressiveness of planning formalisms according to the set of plans a planning instance can have. While this approach contrasts hierarchical task
network planning nicely with STRIPS-planning, it does not help us in making distinctions between
the formalisms in the  -family.
The compilability framework is mainly a theoretical tool to measure how concisely domain
structures and plans can be expressed. However, it also appears to be a good measure of how
difficult planning becomes when a new language feature is added. Polynomial-time compilation
schemes that preserve the plan size linearly indicate that it is easy to integrate the feature that is
compiled away. One can either use the compilation scheme as is or mimic the compilation scheme
by extending the planning algorithm. If only a polynomial-time compilation scheme leading to a
polynomial growth of the plan is possible, then this is an indication that adding the new feature
requires most probably a significant extension of the planning algorithm. If even a compilation
scheme preserving plan size polynomially can be ruled out, then there is most probably a serious
problem integrating the new feature.
Using this framework, we analyzed a large family of planning formalisms ranging from basic
STRIPS to formalisms with conditional effects, boolean formulae, and incomplete state specifications. The most surprising result of this analysis is that we are able to come up with a complete
classification. For each pair of formalisms, we were either able to construct a polynomial-time
compilation scheme with the required size bound on the resulting plans or we could prove that compilation schemes are impossibleeven if the computational resources for the compilation process
are unbounded.
In particular, we showed for the formalisms considered in this paper:






incomplete state specifications and literals in preconditions can be compiled to basic STRIPS
preserving plan size exactly,
incomplete state specifications and literals in preconditions and effect conditions can be compiled away preserving plan size exactly, if we have already conditional effects,
and there are no other compilation schemes preserving plan size linearly except those implied
by the specialization relationship and those described above.
309

fiN EBEL

If we allow for polynomial growth of the plans in the target formalism, then all formalisms not
containing incomplete state specifications and boolean formulae are compilable to each other. Incomplete state specifications together with boolean formulae, however, seem to add significantly
to the expressiveness of a planning formalism, since these cannot be compiled away even when
allowing for polynomial growth of the plan and unbounded resources in the compilation process.
It should be noted, however, that some of these results hold only if we use the semantics for
conditional effects over partial state specifications as spelled out in Section 2.1. For other semantics,
we may get slightly different results concerning the compilability of conditional effects over partial
states.
One question one may ask is what happens if we consider formalisms with boolean formulae
that are syntactically restricted. As indicated at various places in the paper, restricted formulae,
such as CNF or DNF formulae, can sometimes be easily compiled away. However, there are also
cases when this is impossible. For example, it can be shown that CNF formulae cannot be compiled
to basic STRIPS preserving plan size linearly (Nebel, 1999), which confirms Backstrom's (1995)
conjecture that CNF-formulae in preconditions add to the expressive power of basic STRIPS.
Another question is how reasonable our restrictions on a compilation scheme are. In particular,
one may want to know whether non-modular state-translation functions could lead to more powerful
compilation schemes. First of all, requiring that the state-translation functions are modular seems
to be quite weak considering the fact that a compilation scheme should only be concerned with
the domain structure and that the initial state and goal specification should not be transformed at
all. Secondly, considering the fact that the state-translation functions do not depend on the operator
set, more complicated functions seem to be useless. From a more technical point of view, we need
modularity in order to prove that conditional effects and boolean formulae cannot be compiled away
preserving plan size linearly. For the conditional effects, modularity or a similar condition seems
to be crucial. For the case of boolean formulae, we could weaken the condition to the point that
we require only that state-translation functions are computable by circuits of constant depthor
something similar. In any case, the additional freedom one gets from non-modular state-translation
functions does not seem to be of any help because these functions do not take the operators into
account. Nevertheless, it seems to be an interesting theoretical problem to prove that more powerful
state-translation functions do not add to the power of compilation schemes.
Although the paper is mainly theoretical, it was inspired by the recent approaches to extend
the GRAPHPLAN algorithm to handle more powerful planning formalisms containing conditional
effects. So, what are the answers we can give to open problems in the field of planning algorithm
design? First of all, Gazen and Knoblock's (1997) approach to compiling conditional effects away
is optimal if we do not want to allow plan growth more than by a constant factor. Secondly, all of
the other approaches (Anderson et al., 1998; Kambhampati et al., 1997; Koehler et al., 1997) that
modify the GRAPHPLAN algorithm are using a strategy similar to a polynomial-time compilation
scheme preserving plan size polynomially. For this reason, these approaches should be compared
to a pure compilation approach using the ideas from the compilation scheme developed in the
proof of Theorem 22 as the base line. Thirdly, allowing for unrestricted boolean formulae adds
again a level of expressivity because they cannot be compiled away with linear growth of the plan
size. In fact, approaches such as the one by Anderson and colleagues (1998) simply expand the
formulae to DNF accepting an exponential blow-up. Again, we cannot do better than that if plan
size should be preserved linearly. Fourthly, if we want to add partial state specifications on top of
general boolean formulae, this would amount to an increase of expressivity that is much larger than
310

fiC OMPILABILITY

AND

E XPRESSIVE P OWER OF P LANNING F ORMALISMS

adding conditional effects or general formulae to basic STRIPS, because in this case there is no way
to compile this away even if we allow for polynomial plan growth.
Finally, one may wonder how our results apply to planning approaches that are based on translating (bounded) planning problems to propositional logic such as SATPLAN (Kautz & Selman, 1996)
or BLACKBOX (Kautz & Selman, 1998). Since the entire analysis of the relative expressiveness of
planning formalisms uses the assumption that we compile from one planning formalism to another
planning formalism, the results do not tell us anything about the size of representations if we switch
to another formalism. In particular, it seems possible to find an encoding of (bounded) planning
problems with conditional operators in propositional logic which is as concise as an encoding of
unconditional operators. The only advice our results give is that such a concise encoding will not
be found by first translating conditional actions to unconditional actions and then using the standard encoding for unconditional actions (Kautz, McAllester, & Selman, 1996) to generate boolean
formulae. However, addressing the problem of determining the conciseness of representation in this
context appears to be an interesting and relevant topic for future research.

Acknowledgments
The research reported in this paper was started and partly carried out while the author enjoyed being
a visitor at the AI department of the University of New South Wales. Many thanks go to Norman
Foo, Maurice Pagnucco, and Abhaya Nayak and the rest of the AI department for the discussions
and cappuccinos. I would also like to thank Birgitt Jenner and Jacobo Toran for some clarifications
concerning circuit complexity.

Appendix A: Symbol Index
Symbol

Explanation
cardinality of a set
size of an instance
symbol used in conditional effects

syntactic specialization relation

compilability relation with restriction  and 

boolean constant denoting falsity, also denoting
	
the illegal state specification

273 boolean constant denoting truth
 Ll
295 advice function
Lff\Ll
275, 275
active effects of an operator in a state or state specification
AC I
298 complexity class

298 boolean circuit
298 family of boolean circuits

coNP
272 complexity class
coNP/poly 295 non-uniform coNP
closing a set of literals w.r.t. 
$&%;(Ll 284
 
277 plan, i.e., sequence of operators
295 complexity class in the polynomial hierarchy
 

295 instance of a problem

0L0
V 00 L]00

Page
292
277
274
279
282
273

311

fiN EBEL




Ll
>\ffe  ffe>
U


F ffeff


;ff b
 
E\GHLl
NC 
"!@#% Ll
NP
NP/poly

L




- ffi[ff0ff24ff
 L\
ff Ll
P
P/poly
PH

277
282
282
282
277
274
273
287
273
273
274
298
273
272
295
274
276
277
274
275

272
295
295
273
>Ll
PLANEX
279
post
274
pre
274

PSPACE
272
 
277
295

276
Lff\Ll
;!t]Lff\Ll 277
C
274
D
274

278
278
 S
%
278
278
`
 
278
;
278
283
  s 
S
  
283
S
'(	Ll
273

273

initial state description
compilation scheme ( )~N>{ffe  ffe>Qff  ffz>P )
transformation induced by compilation scheme
components of a compilation scheme
goal of a planning task
set of boolean formulae
boolean formulae
literal
sets of literals
all boolean formulae that use atoms from 
set of all models of a theory
complexity class
negative literals in a set of literals
complexity class
non-uniform NP
operator ( )~N pre ff post P )
set of operators
set of finite sequences of operators
propositional atoms
potentially active effects of an operator
for a given state specification
complexity class
non-uniform P
the polynomial hierarchy
positive literals in a set of literals
plan existence problem
postconditions of an operator
preconditions of an operator
complexity class
planning instance ( )ON&ffifft9P )
complexity class in the polynomial hierarchy
maps a state specification and an operator to a new state
extension of Lff\Ll to plans
state (or truth assignment)
state specification
the STRIPS planning formalism
STRIPS with literals in preconditions
STRIPS with boolean formulae in preconditions
STRIPS with incomplete state descriptions
STRIPS with conditional effects
STRIPS with combinations of the above extensions
equivalence classes induced by  
equivalence classes induced by   
all propositional atoms used in a set of literals
countably infinite set of propositional atoms
312

fiC OMPILABILITY







r

 
 ffz



X

 ,




273
273
295
282
292
298
295
272
277
299

AND

E XPRESSIVE P OWER OF P LANNING F ORMALISMS

finite subset of 
set of literals overs 
complexity class in the polynomial hierarchy
state-translation functions in a compilation scheme
universal literals
a word over +\ff:>6t
some complexity class
some planning formalisms
domain structure ( )ON$fftP )
family of domain structures

References
Anderson, C. R., Smith, D. E., & Weld, D. S. (1998). Conditional effects in Graphplan. In Proceedings of the 4th International Conference on Artificial Intelligence Planning Systems (AIPS98), pp. 4453. AAAI Press, Menlo Park.
Baader, F. (1990). A formal definition for expressive power of knowledge representation languages.
In Proceedings of the 9th European Conference on Artificial Intelligence (ECAI-90) Stockholm, Sweden. Pitman.
Backstrom, C. (1995). Expressive equivalence of planning formalisms. Artificial Intelligence, 76(1
2), 1734.
Backstrom, C., & Nebel, B. (1995). Complexity results for SAS  planning. Computational Intelligence, 11(4), 625655.
Blum, A. L., & Furst, M. L. (1997). Fast planning through planning graph analysis. Artificial
Intelligence, 90(1-2), 279298.
Brewka, G., & Hertzberg, J. (1993). How to do things with worlds: On formalizing actions and
plans.. Journal Logic and Computation, 3(5), 517532.
Bylander, T. (1994). The computational complexity of propositional STRIPS planning. Artificial
Intelligence, 69(12), 165204.
Cadoli, M., & Donini, F. M. (1997). A survey on knowledge compilation. AI Communications,
10(3,4), 137150.
Cadoli, M., Donini, F. M., Liberatore, P., & Schaerf, M. (1996). Comparing space efficiency of
propositional knowledge representation formalism. In Aiello, L. C., Doyle, J., & Shapiro,
S. (Eds.), Principles of Knowledge Representation and Reasoning: Proceedings of the 5th
International Conference (KR-96), pp. 364373 Cambridge, MA. Morgan Kaufmann.
Erol, K., Hendler, J. A., & Nau, D. S. (1994). HTN planning: Complexity and expressivity. In
Proceedings of the 12th National Conference of the American Association for Artificial Intelligence (AAAI-94), pp. 11231129 Seattle, WA. MIT Press.
313

fiN EBEL

Erol, K., Hendler, J. A., & Nau, D. S. (1996). Complexity results for hierarchical task-network
planning. Annals of Mathematics and Artificial Intelligence, 18, 6993.
Fikes, R. E., & Nilsson, N. (1971). STRIPS: A new approach to the application of theorem proving
to problem solving. Artificial Intelligence, 2, 189208.
Furst, M., Saxe, J. B., & Sipser, M. (1984). Parity, circuits, and the polynomial-time hierarchy.
Mathematical Systems Theory, 17(1), 1327.
Garey, M. R., & Johnson, D. S. (1979). Computers and IntractabilityA Guide to the Theory of
NP-Completeness. Freeman, San Francisco, CA.
Gazen, B. C., & Knoblock, C. (1997). Combining the expressiveness of UCPOP with the efficiency
of Graphplan. In Steel, S., & Alami, R. (Eds.), Recent Advances in AI Planning. 4th European
Conference on Planning (ECP'97), Vol. 1348 of Lecture Notes in Artificial Intelligence, pp.
221233 Toulouse, France. Springer-Verlag.
Gogic, G., Kautz, H. A., Papadimitriou, C. H., & Selman, B. (1995). The comparative linguistics
of knowledge representation. In Proceedings of the 14th International Joint Conference on
Artificial Intelligence (IJCAI-95), pp. 862869 Montreal, Canada. Morgan Kaufmann.
Kambhampati, S., Parker, E., & Lambrecht, E. (1997). Understanding and extending Graphplan.
In Steel, S., & Alami, R. (Eds.), Recent Advances in AI Planning. 4th European Conference
on Planning (ECP'97), Vol. 1348 of Lecture Notes in Artificial Intelligence, pp. 260272
Toulouse, France. Springer-Verlag.
Karp, R. M., & Lipton, R. J. (1982).
Mathematique, 28, 191210.

Turing machines that take advice.

L' Ensignement

Kautz, H. A., McAllester, D. A., & Selman, B. (1996). Encoding plans in propositional logic. In
Aiello, L. C., Doyle, J., & Shapiro, S. (Eds.), Principles of Knowledge Representation and
Reasoning: Proceedings of the 5th International Conference (KR-96), pp. 374385 Cambridge, MA. Morgan Kaufmann.
Kautz, H. A., & Selman, B. (1992). Forming concepts for fast inference.. In Proceedings of the
10th National Conference of the American Association for Artificial Intelligence (AAAI-92),
pp. 786793 San Jose, CA. MIT Press.
Kautz, H. A., & Selman, B. (1996). Pushing the envelope: Planning, propositional logic, and
stochastic search. In Proceedings of the 13th National Conference of the American Association for Artificial Intelligence (AAAI-96), pp. 11941201. MIT Press.
Kautz, H. A., & Selman, B. (1998). BLACKBOX: A new approach to the application of theorem
proving to problem solving. In Working notes of the AIPS'98 Workshop on Planning as
Combinatorial Search Pittsburgh, PA.
Koehler, J., Nebel, B., Hoffmann, J., & Dimopoulos, Y. (1997). Extending planning graphs to an
ADL subset. In Steel, S., & Alami, R. (Eds.), Recent Advances in AI Planning. 4th European
Conference on Planning (ECP'97), Vol. 1348 of Lecture Notes in Artificial Intelligence, pp.
273285 Toulouse, France. Springer-Verlag.
314

fiC OMPILABILITY

AND

E XPRESSIVE P OWER OF P LANNING F ORMALISMS

Lifschitz, V. (1986). On the semantics of STRIPS. In Georgeff, M. P., & Lansky, A. (Eds.), Reasoning about Actions and Plans: Proceedings of the 1986 Workshop, pp. 19 Timberline, OR.
Morgan Kaufmann.
Nebel, B. (1999). What is the expressive power of disjunctive preconditions?. In Biundo, S., & Fox,
M. (Eds.), Recent Advances in AI Planning. 5th European Conference on Planning (ECP'99)
Durham, UK. Springer-Verlag. To appear.
Papadimitriou, C. H. (1994). Computational Complexity. Addison-Wesley, Reading, MA.
Pednault, E. P. (1989). ADL: Exploring the middle ground between STRIPS and the situation
calculus. In Brachman, R., Levesque, H. J., & Reiter, R. (Eds.), Principles of Knowledge
Representation and Reasoning: Proceedings of the 1st International Conference (KR-89),
pp. 324331 Toronto, ON. Morgan Kaufmann.
Yap, C. K. (1983). Some consequences of non-uniform conditions on uniform classes. Theoretical
Computer Science, 26, 287300.

315

fi