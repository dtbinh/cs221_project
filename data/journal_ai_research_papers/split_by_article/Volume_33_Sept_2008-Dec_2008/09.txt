Journal of Artificial Intelligence Research 33 (2008) 349-402

Submitted 05/08; published 11/08

Learning Partially Observable Deterministic Action Models
EYAL @ ILLINOIS . EDU

Eyal Amir
Computer Science Department
University of Illinois, Urbana-Champaign
Urbana, IL 61801, USA

ALLENC 256@ YAHOO . COM

Allen Chang
2020 Latham st., apartment 25
Mountainview, CA 94040, USA

Abstract
We present exact algorithms for identifying deterministic-actions effects and preconditions in
dynamic partially observable domains. They apply when one does not know the action model (the
way actions affect the world) of a domain and must learn it from partial observations over time.
Such scenarios are common in real world applications. They are challenging for AI tasks because
traditional domain structures that underly tractability (e.g., conditional independence) fail there
(e.g., world features become correlated). Our work departs from traditional assumptions about
partial observations and action models. In particular, it focuses on problems in which actions are
deterministic of simple logical structure and observation models have all features observed with
some frequency. We yield tractable algorithms for the modified problem for such domains.
Our algorithms take sequences of partial observations over time as input, and output deterministic action models that could have lead to those observations. The algorithms output all or one of
those models (depending on our choice), and are exact in that no model is misclassified given the
observations. Our algorithms take polynomial time in the number of time steps and state features
for some traditional action classes examined in the AI-planning literature, e.g., STRIPS actions. In
contrast, traditional approaches for HMMs and Reinforcement Learning are inexact and exponentially intractable for such domains. Our experiments verify the theoretical tractability guarantees,
and show that we identify action models exactly. Several applications in planning, autonomous
exploration, and adventure-game playing already use these results. They are also promising for
probabilistic settings, partially observable reinforcement learning, and diagnosis.

1. Introduction
Partially observable domains are common in the real world. They involve situations in which one
cannot observe the entire state of the world. Many examples of such situations are available from
all walks of life, e.g., the physical worlds (we do not observe the position of items in other rooms),
the Internet (we do not observe more than a few web pages at a time), and inter-personal communications (we do not observe the state of mind of our partners).
Autonomous agents actions involve a special kind of partial observability in such domains.
When agents explore a new domain (e.g., one goes into a building or meets a new person), they
have limited knowledge about their action models (actions preconditions and effects). These action models do not change with time, but they may depend on state features. Such agents can act
intelligently, if they learn how their actions affect the world and use this knowledge to respond to
their goals.
c
2008
AI Access Foundation. All rights reserved.

fiA MIR & C HANG

Learning action models is important when goals change. When an agent acted for a while, it can
use its accumulated knowledge about actions in the domain to make better decisions. Thus, learning
action models differs from Reinforcement Learning. It enables reasoning about actions instead of
expensive trials in the world.
Learning actions effects and preconditions is difficult in partially observable domains. The
difficulty stems from the absence of useful conditional independence structures in such domains.
Most fully observable domains include such structures, e.g., the Markov property (independence of
the state at time t + 1 from the state at time t  1, given the (observed) state at time t). These are
fundamental to tractable solutions of learning and decision making.
In partially observable domains those structures fail (e.g., the state of the world at time t + 1
depends on the state at time t  1 because we do not observe the state at time t), and complex
approximate approaches are the only feasible path. For these reasons, much work so far has been
limited to fully observable domains (e.g., Wang, 1995; Pasula, Zettlemoyer, & Kaelbling, 2004),
hill-climbing (EM) approaches that have unbounded error in deterministic domains (e.g., Ghahramani, 2001; Boyen, Friedman, & Koller, 1999), and approximate action models (Dawsey, Minsker,
& Amir, 2007; Hill, Minsker, & Amir, 2007; Kuffner. & LaValle, 2000; Thrun, 2003).
This paper examines the application of an old-new structure to learning in partially observable
domains, namely, determinism and logical formulation. It focuses on some such deterministic domains in which tractable learning is feasible, and shows that a traditional assumption about the form
of determinism (the STRIPS assumption, generalized to ADL, Pednault, 1989) leads to tractable
learning and state estimation. Learning in such domains has immediate applications (e.g., exploration by planning, Shahaf, Chang, & Amir, 2006; Chang & Amir, 2006) and it can also serve as
the basis for learning in stochastic domains. Thus, a fundamental advance in the application of
such a structure is important for opening the field to new approaches of broader applicability. The
following details the technical aspects of our advance.
The main contribution of this paper is an approach called SLAF (Simultaneous Learning and
Filtering) for exact learning of actions models in partially observable deterministic domains. This
approach determines the set of possible transition relations, given an execution sequence of actions
and partial observations. For example, the input could come from watching another agent act or
from watching the results of our own actions execution. The approach is online, and updates a
propositional logical formula called Transition Belief Formula. This formula represents the possible
transition relations and world states at every time step. In this way, it is similar in spirit to Bayesian
learning of HMMs (e.g., Ghahramani, 2001) and Logical Filtering (Amir & Russell, 2003).
The algorithms that we present differ in their range of applicability and their computational
complexity. First, we present a deduction-based algorithm that is applicable to any nondeterministic
learning problem, but that takes time that is worst-case exponential in the number of domain fluents.
Then, we present algorithms that update a logical encoding of all consistent transition relations in
polynomial time per step, but that are limited in applicability to special classes of deterministic
actions.
One set of polynomial-time algorithms that we present applies to action-learning scenarios in
which actions are ADL (Pednault, 1989) (with no conditional effects) and one of the following
holds: (a) the action model already has preconditions known, and we observe action failures (e.g.,
when we perform actions in the domain), or (b) actions execution always succeeds (e.g., when an
expert or tutor performs actions).
350

fiL EARNING PARTIALLY O BSERVABLE D ETERMINISTIC ACTION M ODELS

Our algorithms output a transition belief formula that represents the possible transition relations
and states after partial observations of the state and actions. They do so by updating each component
of the formula separately in linear time. Thus, updating the transition belief formula with every
action execution and observation takes linear time in the size of the input formula.
Processing a sequence of T action executions and observations takes time O(T 2  n) for case
(b). The main reason for this is a linear growth in the representation size of the transition belief
formula: at time t, the iterative process that updates this formula would process a formula that has
size linear in t.
For case (a) processing a sequence of length T takes polynomial time O(T  n k )), only if we
observe every feature in the domain every  k steps in expectation, for some fixed k. The reason for
this is that the transition belief formula can be kept in k-CNF (k Conjunctive Normal
V Form),
W thus
of size O(nk ). (Recall that a propositional formula is in k-CNF, if it is of the form im jk li,j ,
with every li,j a propositional variable or its negation.) Case (b) takes time O(T  n) under the same
assumption.
Another set of polynomial-time algorithms that we present takes linear time in the representation
size. In this case actions are known to be injective, i.e., map states 1:1. There, we can bound
the computation time for T steps with O(T  nk ), if we approximate the transition-belief formula
representation with a k-CNF formula.
In contrast, work on learning in Dynamic Bayesian Networks (e.g., Boyen et al., 1999), reinforcement learning in POMDPs (e.g., Littman, 1996), and Inductive Logic Programming (ILP)
(e.g., Wang, 1995) either approximate the solution with unbounded error for deterministic domains,
n
or take time (22 ), and are inapplicable in domains larger than 10 features. Our algorithms are
better in this respect, and scale polynomially and practically to domains of 100s of features and
more. Section 8 provides a comparison with these and other works.
We conduct a set of experiments that verify these theoretical results. These experiments show
that our algorithms are faster and better qualitatively than related approaches. For example, we can
learn some ADL actions effects in domains of > 100 features exactly and efficiently.
An important distinction must be made between learning action models and traditional creation
of AI-Planning operators. From the perspective of AI Planning, action models are the result of
explicit modeling, taking into account modeling decisions. In contrast, learning action models
is deducing all possible transition relations that are compatible with a set of partially observed
execution trajectories.
In particular, action preconditions are typically used by the knowledge engineer to control the
granularity of the action model so as to leave aside from specification unwanted cases. For example,
if driving a truck with insufficient fuel from one site to another might generate unexpected situations
that the modeller does not want to consider, then a simple precondition can be used to avoid considering that case. The intention in this paper is not to mimic this modeling perspective, but instead
find action models that generate sound states when starting from a sound state. Sound state is any
state in which the system can be in practice, namely, ones that our observations of real executions
can reflect.
Our technical advance for deterministic domains is important for many applications such as
automatic software interfaces, internet agents, virtual worlds, and games. Other applications, such
as robotics, human-computer interfaces, and program and machine diagnosis can use deterministic
action models as approximations. Finally, understanding the deterministic case better can help us
351

fiA MIR & C HANG

develop better results for stochastic domains, e.g., using approaches such as those by Boutilier,
Reiter, and Price (2001), Hajishirzi and Amir (2007).
In the following, Section 2 defines SLAF precisely, Section 3 provides a deduction-based exact
SLAF algorithm, Section 4 presents tractable action-model-update algorithms, Section 5 gives sufficient conditions and algorithms for keeping the action-model representation compact (thus, overall
polynomial time), and Section 7 presents experimental results.

2. Simultaneous Learning and Filtering (SLAF)
Simultaneous Learning and Filtering (SLAF) is the problem of tracking a dynamic system from
a sequence of time steps and partial observations, when we do not have the systems complete
dynamics initially. A solution for SLAF is a representation of all combinations of action models
that could possibly have given rise to the observations in the input, and a representation of all the
corresponding states in which the system may now be (after the sequence of time steps that were
given in the input occurs).
Computing (the solution for) SLAF can be done in a recursive fashion by dynamic programming
in which we determine SLAF for time step t+1 from our solution of SLAF for time t. In this section
we define SLAF formally in such a recursive fashion.
Ignoring stochastic information or assumptions, SLAF involves determining the set of possible
ways in which actions can change the world (the possible transition models, defined formally below)
and the set of states the system might be in. Any transition model determines a set of possible states,
so a solution to SLAF is a transition model and its associated possible states.
We define SLAF with the following formal tools, borrowing intuitions from work on Bayesian
learning of Hidden Markov Models (HMMs) (Ghahramani, 2001) and Logical Filtering (Amir &
Russell, 2003).
Definition 2.1 A transition system is a tuple hP, S, A, Ri, where
 P is a finite set of propositional fluents;
 S  P ow(P) is the set of world states.
 A is a finite set of actions;
 R  S  A  S is the transition relation (transition model).
Thus, a world state, s  S, is a subset of P that contains propositions true in this state (omitted
propositions are false in that state), and R(s, a, s0 ) means that state s0 is a possible result of action a
in state s. Our goal in this paper is to find R, given known P, S, A, and a sequence of actions and
partial observations (logical sentences on any subset of P).
Another, equivalent, representation for S that we will also use in this paper is the following.
A literal is a proposition, p  P, or its negation, p. A complete term over P is a conjunction of
literals from P such that every fluent appears exactly once. Every state corresponds to a complete
term of P and vice versa. For that reason, we sometime identify a state s  S with this term. E.g.,
for states s1 , s2 , s1 s2 is the disjunction of the complete terms corresponding to s 1 , s2 , respectively.
A transition belief state is a set of tuples hs, Ri where s is a state and R a transition relation.
Let R = P ow(S  A  S) be the set of all possible transition relations on S, A. Let S = S  R.
When we hold a transition belief state   S we consider every tuple hs, Ri   possible.

352

fiL EARNING PARTIALLY O BSERVABLE D ETERMINISTIC ACTION M ODELS

Figure 1: Locked door with unknown key domain.
Example 2.2 Consider a domain where an agent is in a room with a locked door (see Figure 1).
In its possession are three different keys, and suppose the agent cannot tell from observation only
which key opens the door. The goal of the agent is to unlock the door.
This domain can be represented as follows: let the set of variables defining the state space
be P = {locked} where locked is true if and only if the door is locked. Let the set of states be
S = {s1 , s2 } where s1 = {locked} (the state in which the door is locked) and s2 = {} (here the
door is unlocked). Let A = {unlock1 , unlock2 , unlock3 } be the three actions wherein the agent
tries unlocking the door using each of the three keys.
Let R1 = {hs1 , unlock1 , s2 i, hs1 , unlock2 , s1 i, hs1 , unlock3 , s1 i} represent a transition relation in which key 1 unlocks the door and the other keys do not. Define R 2 and R3 in a similar
fashion (e.g., with R2 key 2 unlocks the door and keys 1 and 3 do not). A transition belief state
represents the set of possibilities that we consider consistent with our observations so far. Consider
a transition belief state given by  = {hs1 , R1 i, hs1 , R2 i, hs1 , R3 i}, i.e., the state of the world is
fully known but the action model is only partially known.
We would like the agent to be able to open the door despite not knowing which key opens it. To
do this, the agent will learn the actual action model (i.e., which key opens the door). In general, not
only will learning an action model be useful in achieving an immediate goal, but such knowledge
will be useful as the agent attempts to perform other tasks in the same domain.2
Definition 2.3 (SLAF Semantics) Let   S be a transition belief state. The SLAF of  with
actions and observations haj , oj i1jt is defined by
1. SLAF [a]() =
{hs0 , Ri | hs, a, s0 i  R, hs, Ri  };
2. SLAF [o]() = {hs, Ri   | o is true in s};
3. SLAF [haj , oj iijt ]() =
SLAF [haj , oj ii+1jt ](SLAF [oi ](SLAF [ai ]())).
Step 1 is progression with a, and Step 2 filtering with o.
Example 2.4 Consider the domain from Example 2.2. The progression of  on the action unlock 1
is given by SLAF [unlock1 ]() = {hs2 , R1 i, hs1 , R2 i, hs1 , R3 i}. Likewise, the filtering of  on the
observation locked (the door became unlocked) is given by SLAF [locked]() = {hs 2 , R1 i}.2
353

fiA MIR & C HANG

Example 2.5 A slightly more involved example is the following situation presented in Figure 2.
There, we have two rooms, a light bulb, a switch, an action of flipping the switch, and an observation, E (we are in the east room). The real states of the world before and after the action, s2, s2 0 ,
respectively (shown in the top part), are not known to us.
West

East
off

PSfrag replacements

West
off

s2 = sw  lit  E

on

=
sw-on

<s1,R1>

1

East

s20 = sw  lit  E
<s1,R1>

<s3,R3>

<s1,R1>
<s3,R3>

<s2,R2>

on

<s2,R2>

2

Figure 2: Top: Two rooms and flipping the light switch. Bottom: SLAF semantics; progressing
an action (the arrows map state-transition pairs) and then filtering with an observation
(crossing out some pairs).
The bottom of Figure 2 demonstrates how knowledge evolves after performing the action sw-on.
There, 1 = {hs1 , R1 i, hs2 , R2 i, hs3 , R3 i} for some s1 , R1 , s3 , R3 , s2 = {E}, and R2 that includes hs2 , sw-on, s02 i (the identity and full details of R1 , R2 , R3 are irrelevant here, so we omit
them). 2 is the resulting transition belief state after action sw-on and observation E:  2 =
SLAF [sw-on, E](1 ). 2
We assume that observations (and an observation model relating observations to state fluents)
are given to us as logical sentences over fluents after performing an action. They are denoted with
o.
This approach to transition belief states generalizes Version Spaces of action models (e.g.,
Wang, 1995) as follows: If the current state, s, is known, then the version spaces lattice contains
the set of transition relations s = {R | hs, Ri  }. Thus, from the perspective of version spaces,
SLAF semantics is equivalent to a set of version spaces, one for each state in which we might be.
This semantics also generalizes belief states: If the transition relation, R, is known, then the
belief state (set of possible states) is R = {s | hs, Ri  } (read  restricted to R), and Logical
Filtering (Amir & Russell, 2003) of belief state  and action a is equal to (thus, we can define it as)
F ilter[a]() = (SLAF [a]({hs, Ri | s  }))R .
Thus, SLAF semantics is equivalent to holding a set of belief states, each conditioned on a transition
relation, similar to saying if the transition relation is R, then the belief state (set of states) is  R .

3. Learning by Logical Inference
Learning transition models using Definition 2.3 directly is intractable  it requires space (2 2 )
in many cases. The reason for that is the explicit representation of the very large set of possible
transition-state pairs. Instead, in this section and the rest of this paper we represent transition belief states more compactly using propositional logic. In many scenarios there is some amount of
structure that can be exploited to make a propositional representation compact.
|P|

354

fiL EARNING PARTIALLY O BSERVABLE D ETERMINISTIC ACTION M ODELS

A combinatorial argument implies that no encoding is compact for all sets. Nonetheless, we are
motivated by the success of propositional (logical) approaches for logical filtering (Amir & Russell,
2003; Shahaf & Amir, 2007) and logical-database regression (Reiter, 1991, 2001), and observe that
propositional logic represents compactly some natural sets of exponential size.
In this section we re-define SLAF as an operation on propositional logical formulas with a
propositional formula as output. SLAFs input is a propositional formula that represents a transition
belief state, and SLAF computes a new transition belief formula from that input and a sequence of
actions and observations.
We want to find algorithms for SLAF that manipulate an input formula and produce a correct
output. We use general-purpose logical inference for this task in this section. In later sections we
sidestep expensive general-purpose inference, and make assumptions that lead to tractable algorithms. For the rest of this paper we focus on deterministic transition relations, namely, transition
relations that are partial functions (every action has at most one outcome state for every state).
3.1 Representing Transition Relations in Logic
Our initial algorithm for solving SLAF (to be presented momentarily) does so with a compact
representation of transition belief states. We present this logical encoding of transition belief states
first, and define a deduction-based algorithm in the next section.
We use the following general terminology for propositional logical languages (all the terminological conventions apply with or without subscripts and superscripts). L denotes a vocabulary, i.e.,
a set of propositional variables that we use in the present context. L denotes a language, i.e., a set
of propositional sentences. , , and other script Greek letters stand for propositional formulas in
the language of the present context. F, G also stand for such formulas, but in a restricted context
(see below). L() denotes the vocabulary of . L(L) denotes the language built from propositions
in L using the standard propositional connectives (, , ,...). L() is a shorthand for L(L()).
We represent deterministic transition relations with a propositional vocabulary, L A , whose
propositions are of the form aFG , for a  A, F a literal over P, and G a logical formula. F is
the effect of aFG , and G is the precondition of aFG . When proposition aFG takes the truth value TRUE,
this has the intended meaning that If G holds in the present state, then F holds in the state that
results from executing a.
We let F  P  {p | p  P} be the set of all effects, F , that we consider. We let G be the
set of all preconditions, G, that we consider. In the rest of this section and Section 4 we assume
that G represents a single state in S. Recall that we identify a state with a complete term which is
the conjunction of literals that hold in that state. We use this representation of states and write a Fs
instead of aFG . Later we build on this definition and consider Gs that are more general formulas.
From our assumption (G  S for now, as stated above) we conclude that L A has O(2|P|  2|P| 
|A|) propositional variables. We prove fundamental results for this language and a set of axioms,
disregarding the size of the language for a moment. Section 5 focuses on decreasing the language
size for computational efficiency.
Our semantics for vocabulary LA lets every interpretation (truth assignment), M , for LA correspond with a transition relation, RM . Every transition relation has at least one (possibly more)
interpretation that corresponds to it, so this correspondence is surjective (onto) but not injective
(1-to-1). Every propositional sentence   L(LA ) specifies a set of transition models as follows:
355

fiA MIR & C HANG

The set of models1 (satisfying interpretations) of , I[] = {M interpretation to LA | M |= },
specifies the corresponding set of transition relations, {RM | M  I[]}.
Informally, assume that propositions aFs 1 , ...aFs k  LA take the value TRUE in M , and that all
other propositions with precondition
V s take the value FALSE. Then, R M (with action0 a) takes the
0
state s to a state s that satisfies ik Fi , and is identical to s otherwise. If no such s exists (e.g.,
Fi = Fj , for some i, j  k), then RM takes s to no s0 (thus, a is not executable in s according to
RM ).
The following paragraphs show how interpretations over L A correspond to transition relations.
They culminate with a precise definition of the correspondence between formulas in L(L A  P) and
transition belief states   S.
E VERY I NTERPRETATION OF LA C ORRESPONDS TO A U NIQUE T RANSITION R ELATION
Every interpretations of LA defines a unique transition relation RM as follows. Let M be an interpretation of LA . For every state s  S and an action a  A we either define a unique state s 0 such
that hs, a, s0 i  RM or decide that there is no s0 for which hs, a, s0 i  RM .
M gives an interpretation for every proposition aFs , for F a fluent or its negation. If for any
fluent p  P, M [aps ] = M [ap
s ] = TRUE (M [] is the truth value of  according to interpretation
M ), we decide that there is no s0 such that hs, a, s0 i  RM . Otherwise, define
s0 = {p  P | M |= aps }  {p  s | M |= ap
s }
In the left-hand side of  we consider the cases of p  P for which M [a ps ] 6= M [ap
s ], and on the
right-hand side of  we treat the cases of p  P for which M [aps ] = M [ap
s ] = F ALSE (this is
called inertia because p keeps its previous value for lack of other specifications). Put another way,
0
s0 [p] = M [aps ]  (s[p]  M [ap
s ]), if we view s as an interpretation of P. RM is well defined, i.e.,
there is only one RM for every M .
E VERY T RANSITION R ELATION
LA

HAS AT

L EAST O NE C ORRESPONDING I NTERPRETATION

OF

It is possible that RM = RM 0 for M 6= M 0 . This occurs in two circumstances: (a) cases in which
there is no hs, a, s0 i  RM for some s, a and (b) when M [aps ] = M [ap
s ] = F ALSE (inertia) and
p
p
0
0
M [as ] = s[p], M [as ] = s[p] (not inertia).
For an example of the first circumstance, let p be a fluent, let M be an interpretation such that
0
M [aps ] = M [ap
s ] for some G. Define M an interpretation that is identical to M on all propositions
p p
p
0
besides as , as as follows. Define M [as ] to have the opposite truth assignment to M [aps ] (FALSE
p
instead of TRUE, and TRUE instead of FALSE). Define M 0 [ap
s ] = M [as ].
Then, RM = RM 0 because they map all pairs s, a in the same way. In particular, for state s that
corresponds to G, there is no hs, a, s0 i  RM and similarly there is no hs, a, s0 i  RM 0 .
Finally, every transition relation R has at least one interpretation M such that R = R M . To see
this, define MR for every hs, a, s0 i  R the interpretation to aps (p any fluent) MR [aps ] = T RU E iff
/ s0 . Finally, for all s, a for
p  s0 . Also, for the same hs, a, s0 i define MR [ap
s ] = F ALSE iff p 
p
p
which there is no such s0 , define MR [as ] = MR [as ] = T RU E. Then, R = RMR .
1. We overload the word model for multiple related meanings. model refers to a satisfying interpretation of a logical
formula. Transition model is defined in Definition 2.1 to be a transition relation in a transition system. Action model
is define in the Introduction section to be any well-defined specification of actions preconditions and effects.

356

fiL EARNING PARTIALLY O BSERVABLE D ETERMINISTIC ACTION M ODELS

E VERY T RANSITION R ELATION D EFINES A F ORMULA OVER LA
Every deterministic transition relation R defines a logical formula whose set of models all map
to R. There are many such possible formulas, and we define the most general one (up to logical
equivalence) that does not make use of inertia.
Define T h(R) as follows.
F
0
0
T h0 (R) = {aFs , aF
s | as  LA , hs, a, s i  R, s |= F }
p
p
T h1 (R) = {as  as | p  P, s  S}

W
0
0
T h2 (R) = { pP (aps  ap
s ) | s , hs, a, s i  R}
T h(R) = T h0 (R)  T h1 (R)  T h2

T h0 addresses fluent changes, T h1 addresses fluent innertia (effectively disallowing innertia in
our definition), and T h2 addresses conditions in which actions are not executable. Thus, T h(R)
includes as a model M every interpretation that satisfies RM = R and that requires no inertia for
its definition of RM . It represents R in that each of its models M satisfies RM = R.
It is illuminating to see how our modeling decisions (above and throughout this section) lead
to the last definition. On the one hand, we choose to have every interpretation of L A correspond
to a transition relation (we do this to simplify later arguments about logical entailment). Consequently, we associate interpretations M with M [aFs ] = M [aF
s ] = F ALSE with transition relations R(s, a, s0 ) that keep the value of F fixed between s, s0 (this is inertia for F in a, s). On the
other hand, when we define T h(R) above, we choose axioms that exclude such models (thus, we
avoid models that include inertia) because it simplifies our later discussion of learning algorithms.
In summary, we consider every interpretation of LA as representing exactly one transition relation, and we consider the set of axioms defining R as those that define it directly, i.e., without inertia
(without M [aFs ] = M [aF
s ] = F ALSE).
T RANSITION B ELIEF S TATES C ORRESPOND TO F ORMULAS OVER LA  P
Thus, for every
W transition belief state  we can define a formula in L(L A  P) that corresponds to
it: T h() = hs,Ri (s  T h(R)). Other formulas exist that would characterize  in a similar way,
and they are not all equivalent. This is so because there are stronger formulas   L(L A ) such that
 |= T h(R) and T h(R) 6|=  and every model, M , of  satisfies RM = R.
Similarly, for every formula   L(LA  P) we define a transition belief state () = {hM P
, RM i | M |= , }, i.e., all the state-transition pairs that satisfy  (M P is M restricted to
P, viewed as a complete term over P). We say that formula  is a transition belief formula, if
T h(())   (note: (T h()) =  always holds).
3.2 Transition-Formula Filtering
In this section, we show that computing the transition belief formula for SLAF [a]() for successful
action a and transition belief formula  is equivalent to a logical consequence finding operation.
This characterization of SLAF as consequence-finding permits using consequence finding as an
algorithm for SLAF, and is important later in this paper for proving the correctness of our more
tractable, specialized algorithms.
Let CnL () denote the set of logical consequences of  restricted to vocabulary L. That is,
L
Cn () contains the set of prime implicates of  that contain only propositions from the set L.
357

fiA MIR & C HANG

Recall that an implicate  of a formula  is a clause entailed by  ( |= ). Recall that a prime implicate  of a formula  is an implicate of  that is not subsumed (entailed) by any other implicates
of .
Consequence finding is any process that computes CnL () for an input, . For example, propositional resolution (Davis & Putnam, 1960; Chang & Lee, 1973) is an efficient consequence finder
when used properly (Lee, 1967; del Val, 1999) (Marquis, 2000, surveys results about prime implicates and consequence finding algorithms). Thus, Cn L ()  {  L(L)|  |= }.
For a set of propositions P, let P 0 represent the same set of propositions but with every proposition primed (i.e., each proposition f is annotated to become f 0 ). Typically, we will use a primed
fluent to denote the value of the unprimed fluent one step into the future after taking an action. Let
[P 0 /P] denote the same formula as , but with all primed fluents replaced by their unprimed counterparts. For example, the formula (a  b0 )[P 0 /P] is equal to a  b when b  P. (See Section 8 for a
discussion and comparison with relevant formal verification techniques.)
The following lemma shows the logical equivalence of existential quantification of quantified
boolean formulas and consequence finding restricted to a vocabulary. Recall that quantified boolean
formulas (QBF) are propositional formulas with the addition of existential and universal quantifiers
over propositions. Informally, the QBF x. is true for a given interpretation if and only if there
exists some true/false valuation of x that makes  true under the assignment. The lemma will prove
useful for showing the equivalence between SLAF and consequence-finding.
Lemma 3.1 x.  CnL()\{x} (), for any propositional logic formula  and propositional variable x.
P ROOF
See Section B.1. 2
The lemma extends easily to the case of multiple variables:
Corollary 3.2 For any formula  and set of propositional variables X, X.  Cn L()\X ().
We present an algorithm for updating transition belief formulas whose output is equivalent to
that of SLAF (when SLAF is applied to the equivalent transition belief state). Our algorithm applies
consequence finding to the input transition belief formula together with a set of axioms that define
transitions between time steps. We present this set of axioms first.
For a deterministic (possibly conditional) action, a, the action model of a (for time t) is axiomatized as
V
Teff (a) = lF ,GG ((alG  G)  l0 ) 
W
V
(1)
l
0
lF (l  ( GG (aG  G)))

The first part of (1) says that assuming a executes at time t, and it causes l when G holds, and G
holds at time t, then l holds at time t + 1. The second part says that if l holds after as execution,
then it must be that alG holds and also G holds in the current state. These two parts are very similar
to (in fact, somewhat generalize) effect axioms and explanation closure axioms used in the Situation
Calculus (see McCarthy & Hayes, 1969; Reiter, 2001).
Now, we are ready to describe our zeroth-level algorithm (SLAF 0 ) for SLAF of a transition
belief formula. Let L0 = P 0 LA be the vocabulary that includes only fluents of time t+1 and effect
propositions from LA . Recall (Definition 2.3) that SLAF has two operations: progression (with an
action) and filtering (with an observation). At time t we apply progression for the given action a t
and current transition belief formula, t , and then apply filtering with the current observations:
358

fiL EARNING PARTIALLY O BSERVABLE D ETERMINISTIC ACTION M ODELS

0

t+1 = SLAF0 [at , ot ](t ) = (CnL (t  Teff (at )))[P 0 /P]  ot

(2)

This is identical to Definition 2.3 (SLAF semantics), with the above replacing 1 and 2.
0
As stated above, for SLAF0 we can implement CnL () using consequence finding algorithms
such as resolution and some of its variants (e.g., Simon & del Val, 2001; McIlraith & Amir, 2001;
Lee, 1967; Iwanuma & Inoue, 2002). The following theorem shows that this formula-SLAF algorithm is correct and exact.
Theorem 3.3 (Representation) For  transition belief formula, a action,
SLAF [a]({hs, Ri  S | hs, Ri satisfies }) =
{hs, Ri  S | hs, Ri satisfies SLAF0 [a]()}
P ROOF
See Section B.2. 2
This theorem allows us to identify SLAF0 with SLAF , and we do so throughout the rest of the
paper. In particular, we show that polynomial-time algorithms for SLAF in special cases are correct
by showing that their output is logically equivalent to that of SLAF 0 .
U SING

THE

O UTPUT

OF

SLAF0

The output of any algorithm for SLAF of a transition belief formula is a logical formula. The way
to use this formula for answering questions about SLAF depends on the query and the form of the
output formula. When we wish to find if a transition model and state are possible, we wish to see if
M |= , for M an interpretation of L = P  LA and  the output of SLAF0 .
The answer can be found by a simple model-checking algorithm 2 . For example, to check that
an interpretation satisfies a logical formula we assign the truth values of the variables in the interpretation into the formula; computing the truth value of the formula can be done in linear time.
Thus, this type of query from SLAF takes linear time in the size of the output formula from
SLAF because the final query is about a propositional interpretation and a propositional formula.
When we wish to find if a transition model is possible or if a state is possible, we can do so with
propositional satisfiability (SAT) solver algorithms (e.g., Moskewicz, Madigan, Zhao, Zhang, &
Malik, 2001). Similarly, when we wish to answer whether all the possible models satisfy a property
we can use a SAT solver.
Example 3.4 Recall Example 2.4 in which we discuss a locked door and three combinations. Let
0 = locked, and let 1 = SLAF0 [unlock2 , locked](0 ). We wish to find if 1 implies that trying
to unlock the door with key 2 fails to open it. This is equivalent to asking if all models consistent
with 1 give the value TRUE to unlock2locked
locked .
We can answer such a query by taking the SLAF0 output formula, 1 , and checking if 1 
unlock2locked
locked is SAT (has a model). (Follows from the Deduction Theorem for propositional logic:
 |=  iff    is not SAT.)
One example application of this approach is the goal achievement algorithm of Chang and Amir
(2006). It relies on SAT algorithms to find potential plans given partial knowledge encoded as a
transition belief formula.
2. This is not model checking in the sense used in the Formal Verification literature. There, the model is a transition
model, and checking is done by updating a formula in OBDD with some transformations

359

fiA MIR & C HANG

Our zeroth-level algorithm may enable more compact representation, but it does not guarantee
it, nor does it guarantee tractable computation. In fact, no algorithm can maintain compact representation or tractable computation in general. Deciding if a clause is true as a result of SLAF is
coNP-hard because the similar decision problem for Logical Filtering is coNP-hard (Eiter & Gottlob, 1992; Amir & Russell, 2003) even for deterministic actions. (The input representation for
both problems includes an initial belief state formula in CNF. The input representation for Filtering
includes further a propositional encoding in CNF of the (known) transition relation.)
Also, any representation of transition belief states that uses poly(|P|) propositions grows exponentially (in the number of time steps and |P|) for some starting transition belief states and action
sequences, when actions are allowed to be nondeterministic 3 . The question of whether such exponential growth must happen with deterministic actions and flat formula representations (e.g., CNF,
DNF, etc.; see Darwiche & Marquis, 2002) is open (logical circuits are known to give a solution
for deterministic actions, when a representation is given in terms of fluents at time 0, Shahaf et al.,
2006).

4. Factored Formula Update
Update of any representation is hard when it must consider the set of interactions between all parts
of the representation. Operations like those used in SLAF 0 consider such interactions, manipulate
them, and add many more interactions as a result. When processing can be broken into independent
pieces, computation scales up linearly with the number of pieces (i.e., computation time is the
total of times it takes for each piece separately). So, it is important to find decompositions that
enable such independent pieces and computation. Hereforth we examine one type of decomposition,
namely, one that follows logical connectives.
Learning world models is easier when SLAF distributes over logical connectives. A function,
f , distributes over a logical connective,   {, , ...}, if f (  )  f ()  f (). Computation of
SLAF becomes tractable, when it distributes over , . The bottleneck of computation in that case
becomes computing SLAF for each part separately.
In this section we examine conditions that guarantee such distribution, and present a linear-time
algorithm that gives an exact solution in those cases. We will also show that the same algorithm
gives a weaker transition belief formula when such distribution is not possible.
Distribution properties that always hold for SLAF follow from set theoretical considerations and
Theorem 3.3:
Theorem 4.1 For ,  transition belief formulas, a action,
SLAF [a](  )  SLAF [a]()  SLAF [a]()
|= SLAF [a](  )  SLAF [a]()  SLAF [a]()
P ROOF
See Appendix B.3. 2
Stronger distribution properties hold for SLAF whenever they hold for Logical Filtering.
Theorem 4.2 Let 1 , 2 be transition belief states.
SLAF [a](1  2 ) = SLAF [a](1 )  SLAF [a](2 )
3. This follows from a theorem about filtering by Amir and Russell (2003), even if we provide a proper axiomatization
(note that our axiomatization above is for deterministic actions only).

360

fiL EARNING PARTIALLY O BSERVABLE D ETERMINISTIC ACTION M ODELS

iff for every R
R
R
R
F ilter[a](R
1  2 ) = F ilter[a](1 )  F ilter[a](2 ).

We conclude the following corollary from Theorems 3.3, 4.2 and theorems by Amir and Russell
(2003).
Corollary 4.3 For ,  transition belief formulas, a action, SLAF [a](  )  SLAF [a]() 
SLAF [a]() if for every relation R in  , one of the following holds:
1. a in R maps states 1:1
2. a in R has no conditional effects,    includes all its prime implicates, and we observe if a
fails
3. The state is known for R: for at most one s, hs, Ri     .
Condition 2 combines semantics and syntax. It is particularly useful in the correct computation
of SLAF in later sections. It states when    has a particular syntactic form (namely, together
they include their joint prime implicates), and a is simple enough (but not necessarily 1:1), then
computation of SLAF can be broken into separate SLAF of  and .
Figure 3 presents Procedure Factored-SLAF, which computes SLAF exactly when the conditions of Corollary 4.3 hold. Consequently, Factored-SLAF returns an exact solution whenever our
actions are known to be 1:1. If our actions have no conditional effects and their success/failure is
observed, then a modified Factored-SLAF can solve this problem exactly too (see Section 5).
PROCEDURE Factored-SLAF(hai , oi i0<it ,)
i, ai action, oi observation,  transition belief formula.
1. For i from 1 to t do,
(a) Set   Step-SLAF(oi ,ai ,).
(b) Eliminate subsumed clauses in .
2. Return .
PROCEDURE Step-SLAF(o,a,)
o an observation formula in L(P), a an action,  a transition belief formula.
1. If  is a literal, then return oLiteral-SLAF(a,).
2. If  = 1  2 , return Step-SLAF(o,a,1 )Step-SLAF(o,a,2 ).
3. If  = 1  2 , return Step-SLAF(o,a,1 )Step-SLAF(o,a,2 ).
PROCEDURE Literal-SLAF(a,)
a an action,  a proposition in Lt or its negation.
0
1. Return CnL (  Teff (a))[P 0 /P ] .

Figure 3: SLAF using distribution over , 
If we pre-compute (and cache) the 2n possible responses of Literal-SLAF, then every time step
t in this procedure requires linear time in the representation size of , our transition belief formula
at that time step. This is a significant improvement over the (super exponential) time taken by
a straightforward algorithm, and over the (potentially exponential) time taken by general-purpose
consequence finding used in our zeroth-level SLAF procedure above.
Theorem 4.4 Step-SLAF(a, o, ) returns a formula 0 such that SLAF [a, o]() |= 0 . If every run
of Literal-SLAF takes time c, then Step-SLAF takes time O(||c). (recall that || is the syntactic,
representation size of .) Finally, if we assume one of the assumptions of Corollary 4.3, then
0  SLAF [a, o]().
361

fiA MIR & C HANG

A belief-state formula is a transition belief formula that has no effect propositions, i.e., it includes only fluent variables and no propositions of the form a FG . This is identical to the traditional
use of the term belief-state formula, e.g., (Amir & Russell, 2003). We can give a closed-form solution for the SLAF of a belief-state formula (procedure Literal-SLAF in Figure 3). This makes
procedure Literal-SLAF tractable, avoiding general-purpose inference in filtering a single literal,
and also allows us to examine the structure of belief state formulas in more detail.
V
Theorem 4.5 For belief-state formula   L(P), action a, Ca = GG,lF (alG  al
G ), and
G1 , ..., Gm  G all the terms in G such that Gi |= ,
SLAF [a]() 

^

m
_

li
(li  aG
)  Ca
i

l1 ,...,lm F i=1

V

Here, l1 ,...,lm F means a conjunction over all possible (combinations of) selections of m literals
from F.
P ROOF
See Appendix B.4. 2
This theorem is significant in that it says that we can can write down the result of SLAF in a
prescribed form. While this form is still potentially of exponential size, it boils down to simple
computations. Its proof follows by a straightforward (though a little long) derivation of the possible
prime implicates of SLAF [a](t ).
A consequence of Theorem 4.5 is that we can implement Procedure Literal-SLAF using the
equivalence


Theorem 4.5
L(l)  P
SLAF [a](l) 
l  SLAF [a](TRUE) otherwise

Notice that the computation in Theorem 4.5 for  = l a literal is simple because G 1 , ..., Gm are
all the complete terms in L(P) that include l. This computation does not require a general-purpose
consequence finder, and instead we need to answer 2n+1 queries at the initialization phase, namely,
storing in a table the values of SLAF [a](l) for all l = p and l = p for p  P and also for
l = TRUE.
In general, m could be as high as 2|P| , the number of complete terms in G, and finding G1 , ..., Gm
may take time exponential in |P|. Still, the simplicity of this computation and formula provide the
basic ingredients needed for efficient computations in the following sections for restricted cases. It
should also give guidelines on future developments of SLAF algorithms.

5. Compact Model Representation
Previous sections presented algorithms that are potentially intractable for long sequences of actions
and observations. For example, in Theorem 4.5, m could be as high as 2 |P| , the number of complete
terms in G. Consequently, clauses may have exponential length (in n = |P|) and there may be a
super-exponential number of clauses in this result.
In this section we focus on learning action models efficiently in the presence of action preconditions and failures. This is important for agents that have only partial domain knowledge and are
therefore likely to attempt some inexecutable actions.
We restrict our attention to deterministic actions with no conditional effects, and provide an
overall polynomial bound on the growth of our representation, its size after many steps, and the
362

fiL EARNING PARTIALLY O BSERVABLE D ETERMINISTIC ACTION M ODELS

time taken to compute the resulting model. This class of actions generalizes STRIPS (Fikes, Hart,
& Nilsson, 1972), so our results apply to a large part of the AI-planning literature.
We give an efficient algorithm for learning both non-conditional deterministic action effects and
preconditions, as well as an efficient algorithm for learning such actions effects in the presence of
action failures.
5.1 Actions of Limited Effect
In many domains we can assume that every action a affects at most k fluents, for some small k > 0.
It is also common to assume that our actions are STRIPS, and that they may fail without us knowing,
leaving the world unchanged. Those assumptions together allow us to progress SLAF with a limited
(polynomial factor) growth in the formula size.
We use a language that is similar to the one in Section 3, but which uses only action propositions
alG with G being
a fluent term of size k (instead of a fluent term of size n in G). Semantically,
V
l
al1 ...lk  lk+1 ,...,ln all1 ...ln .
Theorem 5.1 Let   L(P) be a belief-state formula, and a a STRIPS action with  k fluents
affected or in the precondition term. Let G k be the set of all terms of k fluents in L(P) that are
consistent with . Then,
SLAF [a]() 

^

k
_

li
(li  aG
)  Ca
i

i=1
G1 , ..., Gk  G k
G1  ...  Gk |= 
l1 , ..., lk  F

V
Here, ... refers to a conjunction over all possible (combinations of) selections of m literals from
F and G1 , ..., Gk from G k such that G1  ...  Gk |= .
P ROOF
See Section B.5. 2
The main practical difference between this theorem and Theorem 4.5 is the smaller number of
terms that need to be checked for practical computation. The limited language enables and entails
a limited number of terms that are at play here. Specifically, when a has at most k literals in its
preconditions, we need to check all combinations of k terms G 1 , ..., Gk  G k , computation that is
bounded by O(exp(k)) iterations.
The proof uses two insights. First, if a has only one case in which change occurs, then every
clause in Theorem 4.5 is subsumed by a clause that is entailed by SLAF [a]( t ), has at most one
alGi i per literal li (i.e., li 6= lj for i 6= j) and Gi is a fluent term (has no disjunctions). Second, every
alG with G term is equivalent to a formula on alGi with Gi terms of length k, if a affects only k
fluents.
Thus, we can encode all of the clauses in the conjunction using a subset of the (extended) action
effect propositions, alG , with G being a term of size k. There are O(nk ) such terms, and O(nk+1 )
such propositions. Every clause is of length 2k, with the identity of the clause determined by the
2
first half (the set of action effect propositions). Consequently, SLAF [a]( t ) takes O(nk +k  k 2 )
2
space to represent using O(nk +k ) clauses of length  2k.
363

fiA MIR & C HANG

5.2 Actions of No Conditional Effects: Revised Language
In thisSsection we reformulate the representation that we presented above in Section 3.1. Let
L0f = aA {af , af  , af , a[f ] , a[f ] } for every f  P. Let the vocabulary for the formulas representing transition belief states be defined as L = P  L0f . The intuition behind propositions in this
vocabulary is as follows:
V
 al  a causes l for literal l. Formally, al  sS als .
V
 af   a keeps f . Formally, af   sS ((s  f )  afs )  ((s  f )  af
s ).
V
).
(Thus, l is a
 a[l]  a causes FALSE if l. Formally, a[l]  sS (s  l)  (als  al
s
precondition for executing a, and it must hold when a executes.)
For each model of a transition belief formula over L, the valuation of the fluents from P defines a
state. The valuation of the propositions from all L0f defines an unconditional deterministic transition
relation as follows: action proposition af (af ) is true if and only if action a in the transition
relation causes f (f ) to hold after a is executed. Action proposition a f  is true if and only if
action a does not affect fluent f . Action proposition a[f ] (a[f ] ) is true if and only if f (f ) is in
the precondition of a. We assume the existence of logical axioms that disallow inconsistent or
impossible models. These axioms are:
1. af  af  af 
2. (af  af )  (af  af  )  (af  af  )


3.  a[f ]  a[f ]

for all possible a  A and f  P. The first two axioms state that in every action model, exactly one
of af , af , or af  must hold (thus, a causes f , its negation, or keeps f unchanged). The last axiom
disallows interpretations where both a[f ] and a[f ] hold. We state these axioms so that we do not
need to represent these constraints explicitly in the transition belief formula itself.
We will use the set theoretic and propositional logic notations for transition belief states interchangeably. Note that the vocabulary we have defined is sufficient for describing any unconditional
STRIPS action model, but not any deterministic action model in general.
Example 5.2 Consider the domain from Example 2.2. The transition belief state  can be represented by the transition belief formula:
locked 
((unlock1locked  unlock2locked  unlock3locked ) 
(unlock1locked  unlock2locked  unlock3locked ) 
(unlock1locked  unlock2locked  unlock3locked )).
2
We provide an axiomatization that is equivalent to SLAF and is a special case of T eff (1) with
our notation above. We do this over P and P 0 . Recall that we intend primed fluents to represent the
value of the fluent immediately after action a is taken.
364

fiL EARNING PARTIALLY O BSERVABLE D ETERMINISTIC ACTION M ODELS

eff (a) 

^

Prea,f  Effa,f

f P

Prea,f



^

(a[l]  l)

l{f,f }

Effa,f



^

((al  (af   l))  l0 )  (l0  (al  (af   l))).

l{f,f }

Here Prea,f describes the precondition of action a. It states that if literal l occurs in the precondition
of a then literal l must have held in the state before taking a. The formula Eff a,f describes the effects
of action a. It states that the fluents before and after taking the action must be consistent according
to the action model defined by the propositions af , af , and af  .
Now we can show that the revised axiomatization of action models,  eff , leads to an equivalent
definition to SLAF within our restricted action models.
0

Theorem 5.3 For any successful action a, SLAF [a]()  Cn LP (  eff (a))[P 0 /P] .
P ROOF

See Appendix B.6. 2

5.3 Always-Successful Non-Conditional Actions
We are now ready to present an algorithm that learns effects for actions that have no conditional
effects. The algorithm allows actions that have preconditions that are not fully known. Still, it
assumes that the filtered actions all executed successfully (without failures), so it cannot effectively
learn those preconditions (e.g., it would know only some more than it knew originally about those
preconditions after seeing a sequence of events). Such a sequence of actions might, for example, be
generated by an expert agent whose execution traces can be observed.
The algorithm maintains transition belief formulas in a special fluent-factored form, defined below. By maintaining formulas in this special form, we will show that certain logical consequence
finding operations can be performed very efficiently. A formula is fluent-factored, if it is the conjunction of formulas f such that each f concerns only one fluent, f , and action propositions.
Also, for every fluent, f , f is conjunction of a positive element, a negative element, and a
neutral one f  (f  explf )  (f  explf )  Af , with explf , explf , Af formulae over action
propositions af , af , a[f ] , a[f ] , and af  (possibly multiple different actions). The intuition here
is that explf and explf are all the possible explanations for f being true and false, respectively.
Also, Af holds knowledge about actions effects and preconditions on f , knowledge that does
not depend on f s current value. Note that any formula in L(L f ) can be represented as a fluentfactored formula. Nonetheless, a translation sometimes leads to a space blowup, so we maintain our
representation in this form by construction.
The new learning algorithm, AS-STRIPS-SLAF4 , is shown in Figure 4. To simplify exposition,
it is described for the case of a single action-observation pair, though it should be obvious how to
apply the algorithm to sequences of actions and observations. Whenever an action is taken, first
the subformulas Af , explf , and explf for each f are updated according to steps 1.(a)-(c). Then,
4. AS-STRIPS-SLAF extends AE-STRIPS-SLAF (Amir, 2005) by allowing preconditions for actions

365

fiA MIR & C HANG

Algorithm AS-STRIPS-SLAF[ha, oi]()
Inputs:
V Successful action a, observation term o, and fluent-factored transition belief formula  =
f P f .

Returns: Fluent-factored transition belief formula for SLAF [ha, oi]()
1. For every f  P
(a) Set Af  (a[f ]  explf )  (a[f ]  explf )  Af
(b) Set explf  (af  (af   a[f ]  explf ))
(c) Set explf  (af  (af   a[f ]  explf ))

(d) If o |= f (f is observed) then seta , f  (f  >)  (f  )  Af  explf
(e) If o |= f then set f  (f  )  (f  >)  Af  explf [Note: If o 6|= f and
o 6|= f , we do nothing beyond the earlier steps.]
2. Simplify  (e.g., eliminate subsumed clauses in ).
3. Return 
a. The term (f  >) is the new explf , and (f  ) is the new explf . They appear here without simplification
to conform to Step 1a of the algorithm. This also emphasizes the syntactic nature of the procedure, and that no
implicit logical simplification is assumed.

Figure 4: SLAF algorithm for always successful STRIPS actions.
when an observation is received, each f is updated according to the observation according to steps
1.(d)-(e). Step 2 merely indicates that in most implementations, it is likely that some simplification
procedure will be used on the formula such as subsumption elimination. However, the use of any
such simplification procedure is not strictly necessary in order for the theoretical guarantees of our
algorithm to hold.
For example, if we know nothing about actions that affect f (e.g., when we start our exploration),
then f = (f  T RU E)  (f  T RU E)  T RU E. With this representation, SLAF [a](f ) is the
conjunction (f explf )(f explf )Af as computed by step 1 of Procedure AS-STRIPS-SLAF.
A similar formula holds for observations.
The following theorem shows the correctness of the algorithm. It shows that the steps taken
by the algorithm produce a result equivalent to the logical consequence-finding characterization of
SLAF of Theorem 5.3.
Theorem 5.4 SLAF[ha, oi]()  AS-STRIPS-SLAF[ha, oi]() for any fluent-factored formula ,
successfully executed action a, and observation term o.
P ROOF
See Appendix B.7 2
The time and space complexity of procedure AS-STRIPS-SLAF are given in the following
theorem. As a time guarantee, it is shown that the procedure takes linear time in the size of the input
formula. Under the condition that the algorithm receives observations often enoughspecifically
366

fiL EARNING PARTIALLY O BSERVABLE D ETERMINISTIC ACTION M ODELS

that every fluent is observed at least once every k calls to the procedureit is possible to show
that the transition belief formula remains in k-CNF indefinitely (recall that  is in k-CNF for some
fixed k, if  is a conjunction of clauses each of size  k). Thus, regardless of the length of actionobservation input sequence, the output of AS-STRIPS-SLAF and the value of  throughout its
computation is in k-CNF. This amounts to a space guarantee on the size of the formula.
Theorem 5.5 The following are true of AS-STRIPS-SLAF:
1. The procedure takes linear time in the size of the input formula for a single action, observation
pair input.
2. If for every fluent and every k steps there is an observation of that fluent in one of those steps,
and the input formula is in k-CNF, them the resulting formula (after an arbitrary number of
steps) is in k-CNF.
3. If the input of AS-STRIPS-SLAF is fluent-factored, then so is its output.
P ROOF
See Appendix B.8 2
The following corollary follows immediately from the above.
Corollary 5.6 In order to process T steps of actions and observations, AS-STRIPS-SLAF requires
O (T  |P|) time. Additionally, if 
every fluentis observed every at most k steps, then the resulting
formula always has size that is O |P|  |A|k .
This Corollary holds because Theorem 5.5(2) guarantees a bound on the size of our belief-state
formula at any point in the algorithm.

5.4 Learning Actions Which May Fail
In many partially observable domains, a decision-making agent cannot know beforehand whether
each action it decides to take will fail or succeed. In this section we consider possible action failure,
and assume that the agent knows whether each action it attempts fails or succeeds after trying the
action.
More precisely, we assume that there is an additional fluent OK observed by the agent such
that OK is true if and only if the action succeeded. A failed action, in this case, may be viewed as
an extra observation by the agent that the preconditions for the action were not met. That is, an
action failure is equivalent to the observation
^

(a[f ]  f )  (a[f ]  f ).
(3)
f P

Action failures make performing the SLAF operation considerably more difficult. In particular,
observations of the form (3) cause interactions between fluents where the value of a particular fluent
might no longer depend on only the action propositions for that fluent, but on the action propositions
for other fluents as well. Transition belief states can no longer be represented by convenient fluentfactored formulas in such cases, and it becomes more difficult to devise algorithms which give
useful time and space performance guarantees.
367

fiA MIR & C HANG

Algorithm PRE-STRIPS-SLAF[a, o]()
Inputs: Action a and observation
term o. The transition belief formula  has the following facV W
tored form:  = i j i,j , where each i,j is a fluent-factored formula.
Returns: Filtered transition belief formula 
1. If o |= OK:
W
(a) Set     i F (li ) where li are the literals appearing in as precondition, and
F (l) is the V
fluent-factored formula equivalent to l (i.e., F (l) = ((l  >)  (l 
)  >)  f P ((f  >)  (f  >)  >))

(b) Set i,j  AS-STRIPS-SLAF[o](i,j ) for all i,j
2. Else (o |= OK):
(a) For all i,j

i. Set i,j  AS-STRIPS-SLAF[P ](i,j ), where P is the precondition of a
ii. Set i,j  AS-STRIPS-SLAF[ha, oi](i,j )
3. Each i,j is factored into Ai,j  Bi,j where Bi,j contains all (and only) clauses containing
a fluent from P. For
W any i such that there exists B such that for all j, B i,j  B, replace
W

with
B

j Ai,j
j i,j
4. Simplify each i,j (e.g. remove subsumed clauses)
5. Return 
Figure 5: Algorithm for handling action failures when preconditions are known.
As we shall demonstrate, action failures can be dealt with tractably if we assume that the action
preconditions are known by the agent. That is, the agent must learn the effects of the actions it can
take, but does not need to learn the preconditions of these actions. In particular, this means that for
each action a, the algorithm is given access to a formula (more precisely, logical term) P a describing
the precondition of action a. Clearly, because the algorithm does not need to learn the preconditions
of its actions, we can restrict the action proposition vocabulary used to describe belief states to the
ones of the forms af , af , and af  , as we no longer need action propositions of the forms a[f ] or
a[f ] .
We present procedure PRE-STRIPS-SLAF5 (Figure 5) that performs SLAF on transition belief
formulas in the presence of action failures for actions of non-conditional effects. It maintains transition belief
as conjunctions of disjunctions of fluent-factored formulas (formulas of the
V formulas
W
form  = i j i,j where each i,j is fluent factored). Naturally, such formulas are a superset of
all fluent-factored formulas.
5. PRE-STRIPS-SLAF is essentially identical to CNF-SLAF (Shahaf et al., 2006)

368

fiL EARNING PARTIALLY O BSERVABLE D ETERMINISTIC ACTION M ODELS

The algorithm operates as follows: When an action executes successfully (and an ensuing observation is received), each of the component fluent-factored formulas  i,j is filtered separately
according to the AS-STRIPS-SLAF procedure on the action-observation pair (Step 2). On the other
hand, when an action fails, a disjunction of fluent-factored formulas is appended to the transition
belief formula (Step 1). Each component of the disjunction corresponds to one of the possible reasons the action failed (i.e., to one of the literals occurring in the actions precondition). Finally, as
observations are accumulated by the learning algorithm, it collapses disjunctions of fluent-factored
formulas occurring in the belief formula together (Step 3) or simplifies them generally (Step 4),
decreasing the total size of the formula. As with the case of AS-STRIPS-SLAF, these simplification
steps are not necessary in order for our time and space guarantees to hold.
The proof of correctness of Algorithm PRE-STRIPS-SLAF relies on our distribution results
from Section 4, Theorem 4.1 and Corollary 4.3.
We proceed to show the correctness of PRE-STRIPS-SLAF. The following theorem shows that
the procedure always returns a filtered transition belief formula that is logically weaker than the
exact result, so it always produces a safe approximation. Additionally, the theorem shows that
under the conditions of Corollary 4.3, the filtered transition belief formula is an exact result.
Theorem 5.7 The following are true:
1. SLAF[a, o]() |= PRE-STRIPS-SLAF[a, o]()
2. PRE-STRIPS-SLAF[a, o]()  SLAF[a, o]() if Corollary 4.3 holds.
P ROOF
See Appendix B.9. 2
Now we consider the time and space complexity of the algorithm. The following theorem shows
that (1) the procedure is time efficient, and (2) given frequent enough observations (as in Theorem
5.5), the algorithm is space efficient because the transition belief formula stays indefinitely compact.
Theorem 5.8 The following are true of PRE-STRIPS-SLAF:
1. The procedure takes time linear in the size of the formula for a single action, observation pair
input.
2. If every fluent is observed every at most k steps and the input formula is in m  k-CNF, then
the filtered formula is in m  k-CNF, where m is the maximum number of literals in any action
precondition.
P ROOF
See Appendix B.10 2
Therefore, we get the following corollary:
Corollary 5.9 In order to process T steps of actions and observations, PRE-STRIPS-SLAF requires
O (T  |P|) time. If every fluent is 
observed at least
 as frequently as every k steps, then the resulting
mk
formula always has size that is O |P|  |A|
.

6. Building on Our Results
In this section we describe briefly how one might extend our approach to include an elaborate
observation model, bias, and parametrized actions.
369

fiA MIR & C HANG

6.1 Expressive Observation Model
The observation model that we use throughout this paper is very simple: at every state, if a fluent is
observed to have value v, then this is its value in the current state. We can consider an observation
model that is more general.
An observation model, O, is a set of logical sentences that relates propositions in a set Obs with
fluents in P. Obs includes propositions that do not appear in P, and which are independent of the
previous and following state (times t  1 and t + 1) given the fluents at time t.
SLAF with o is the result of conjoining t with CnLt (oO), i.e., finding the prime implicates of
o  O and conjoining those with t . We can embed this extension into our SLAF algorithms above,
if we can maintain the same structures that those algorithms use. If O is in k-CNF and at every step
we observe all but (at most) 1 variable, then finding the prime implicates is easy. Embedding this
into the transition-belief formula is done by conjunction of these prime implicates with the formula,
and removal of subsumed clauses. The resulting formula is still fluent factored, if the input was
fluent factored. Then, the algorithms above remain applicable with the same time complexity, by
replacing ot with the prime implicates of ot  Ot .
Using the Model The algorithms we described above provide an exact solution to SLAF, and
all the tuples hs, Ri that are in this solution are consistent with our observations. They compute a
solution to SLAF that is represented as a logical formula. We can use a SAT solver (e.g., Moskewicz
et al., 2001) to answer queries over this formula, such as checking if it entails a f , for action a and
fluent f . This would show if in all consistent models action a makes f have the value TRUE.
The number of variables in the result formula is always independent of T , and is linear in |P|
for some of our algorithms. Therefore, we can use current SAT solvers to treat domains of 1000
features and more.
Preference and Probabilistic Bias Many times we have information that leads us to prefer some
possible action models over others. For example, sometimes we can assume that actions change
only few fluents, or we suspect that an action (e.g., open-door) does not affect some features (e.g.,
position) normally. We can represent such bias using a preference model (e.g., McCarthy, 1986;
Ginsberg, 1987) or a probabilistic prior over transition relations (e.g., Robert, Celeux, & Diebolt,
1993).
We can add this bias at the end of our SLAF computation, and get an exact solution if we can
compute the effect of this bias together with a logical formula efficiently. Preferential biases were
studied before and fit easily with the result of our algorithms (e.g., we can use implementations of
Doherty, Lukaszewicz, & Szalas, 1997, for inference with such bias).
Also, algorithms for inference with probabilistic bias and logical sentences are now emerging
and can be used here too (Hajishirzi & Amir, 2007). There, the challenge is to not enumerate
tentative models explicitly, a challenge that is overcome with some success in the work of Hajishirzi
and Amir (2007) for the similar task of filtering. We can use such algorithms to apply probabilistic
bias to the resulting logical formula.
For example, given a probabilistic graphical model (e.g., Bayesian Networks) and a set of propositional logical sentences, we can consider the logical sentences as observations. With this approach,


a logical sentence  gives rise to a characteristic function  (
x ) which is 1 when 
x satisfies  and
0 otherwise. For a conjunction of clauses we get a set of such functions (one per clause). Thus,
inference in the combined probabilistic-logical system is a probabilistic inference. For example,
370

fiL EARNING PARTIALLY O BSERVABLE D ETERMINISTIC ACTION M ODELS

one can consider variable elimination (e.g., Dechter, 1999) in which there are additional potential
functions.
Parametrized Actions In many systems and situations it is natural to use parametrized actions.
These are action schemas whose effect depend on their parameters, but their definition applies
identically to all instantiations.
For example, move(b, x, y) can be an action which moves b from position x to position y, with
b, x, y as parameters of the action. These are very common in planning systems (e.g., STRIPS,
PDDL, Situation Calculus). A complete treatment of parameterized actions is outside the scope of
this paper, but we give guidelines for a generalization of our current approach for such actions.
Consider a domain with a set of fluent predicates and a universe of named objects. The propositional fluents that are defined in this domain are all ground instantiations of predicate fluents. SLAF
can work on this set of propositional fluents and instantiated actions in the same manner as for the


rest of this paper. We have action propositions a( X )lG instantiated for every vector of object names


X.




y )lG .
The different treatment comes in additional axioms that say that  
x,
y .a(
x )lG  a(
Inference over a transition belief state with these axioms will be able to join information collected
about different instantiations of those actions. We expect that a more thorough treatment will be
able to provide more efficient algorithms whose time complexity depend on the number of action
schemas instead of the number of instantiated actions.
Several approaches already start to address this problem, including the work of Nance, Vogel,
and Amir (2006) for filtering and the work of Shahaf and Amir (2006) for SLAF.

7. Experimental Evaluation
Previous sections discussed the problem settings that we consider and algorithms for their solutions. They showed that modifying traditional settings for learning in dynamic partially observable
domains is important. Determinism alone does not lead to tractability, but our additional assumptions of simple, logical action structure and bounded from 0 frequency of observations for all fluents
do. Specifically, so far we showed that the time and space for computing SLAF of a length-T time
sequence over n fluents are polynomial in T and n.
This section considers the practical considerations involved in using our SLAF procedures. In
particular, it examines the following questions:
 How much time and space do SLAF computations take in practice?
 How much time is required to extract a model from the logical formula in the result of our
SLAF procedures?
 What is the quality of the learned model (taking an arbitrary consistent model)? How far is it
from the true (generating) model?
 Do the conditions for the algorithms correctness hold in practice?
 Can the learned model be used for successful planning and execution? How do the learning
procedures fit with planning and execution?
We implemented our algorithms and ran experiments with AS-STRIPS-SLAF over the following domains taken from the 3rd International Planning Competition (IPC): Drivelog, Zenotravel,
Blocksworld, and Depots (details of the domains and the learning results appear in Appendix C).
371

fiA MIR & C HANG

Each such experiment involves running a chosen algorithm over a sequence of randomly generated
action-observation sequences of 5000 steps. Information was recorded every 200 steps.
The random-sequence generator receives the correct description of the domain, specified in
PDDL (Ghallab, Howe, Knoblock, McDermott, Ram, Veloso, Weld, & Wilkins, 1998; Fox & Long,
2002) (a plannig-domain description language), the size of the domain, and a starting state. (The
size of the domain is the number of propositional fluents in it. It is set by a specification of the
number of objects in the domain and the number and arity of predicates in the domain.) It generates
a valid sequence of actions and observations for this domain and starting state, i.e., a sequence that
is consistent with the input PDDL to that generator but in which actions may fail (action failure is
consistent with the PDDL if the action is attempted in a state in which it canot execute).
For our experiments, we chose to have observations as follows: In every time step we select 10
fluents uniformly at random to observe. We applied no additional restrictions (such as making sure
each fluent was observed every fixed k steps).
Our SLAF algorithm receives only such a sequences of actions and observations, and no domain
information otherwise (e.g., it does not receive the size of the domain, the fluents, the starting state,
or the PDDL). The starting knowledge for the algorithm is the empty knowledge, TRUE.
For each domain we ran the algorithm over different numbers of propositional fluents (19 to 250
fluents). We collected the time and space taken for each SLAF computation and plotted them as a
function of the input-sequence length (dividing by t the total computation time for t steps). The
time and space results are shown in Figures 6, 7, 8, and 9. The graphs are broken into the different
domains and compare the time and space taken for different domain sizes. The time is SLAF-time
without CNF simplification (e.g. we do not remove subsumed clauses)
How much time and space do SLAF computations take in practice? We can answer the first
question now. We can observe in these figures that the time per step remains relatively constant
throughout execution. Consequently, the time taken to perform SLAF of different domains grows
linearly with the number of time steps. Also, we see that the time for SLAF grows with the domain
size, but scales easily for moderate domain sizes (1ms per step of SLAF for domains of 200 fluents).
How much time is required to extract a model from the logical formula in the result of our
SLAF procedures? Our SLAF procedures return a logical formula for each sequence of actions
and observations. We need to apply further work to extract a candidate (consistent) model from that
formula. This computation is done with a SAT solver for CNF formulas.
What is the quality of the learned model (taking an arbitrary consistent model)? How far is it
from the true (generating) model? There are sometimes many possible models, and with little
further bias we must consider each of them possible and as likely. We decided to introduce one
such bias, namely, that actions are instances of actions schemas. Thus, the actions are assumed to
have the same effect on their parameters (or objects), given properties of those parameters. Thus,
actions effects are assumed independent of the identity of those parameter.
So, with the vanilla implementation, there are propositions which look like
((STACK
((STACK
((STACK
((STACK
etc.

E
E
A
A

G)
G)
B)
A)

CAUSES
CAUSES
CAUSES
CAUSES

(ON
(ON
(ON
(ON

E
G
A
A

G))
E))
B))
A))

372

fiL EARNING PARTIALLY O BSERVABLE D ETERMINISTIC ACTION M ODELS

SLAF Time/Step: Blocksworld Domain
1.6

1.4

1.2

Time (ms)

1

19 fluents
41 fluents
71 fluents
131 fluents
209 fluents

0.8

0.6

0.4

0.2

0
200

1000

1800

2600

3400

4200

5000

Input Sequence Length

SLAF Time/Step: Depots Domain
1.6

1.4

1.2

Time (ms)

1

58 fluents
94 fluents
138 fluents
190 fluents
250 fluents

0.8

0.6

0.4

0.2

0
200

1000

1800

2600

3400

4200

5000

Input Sequence Length

Figure 6: SLAF-time without CNF simplification for domains Blocksworld and Depots

Instead, we replace ground propositions like those above with schematized propositions:
((STACK ?X ?Y) CAUSES (ON ?X ?Y))
((STACK ?X ?Y) CAUSES (ON ?Y ?X))
((STACK ?X ?Y) CAUSES (ON ?X ?Y))
etc.
Thus, the belief-state formula looks something like:
373

fiA MIR & C HANG

SLAF Time/Step: Driverlog Domain
1.8
1.6
1.4

Time (ms)

1.2
31 fluents
76 fluents
122 fluents
186 fluents
231 fluents

1
0.8
0.6
0.4
0.2
0
200

1000

1800

2600

3400

4200

5000

Input Sequence Length

SLAF Time/Step: Zeno-Travel Domain
0.8

0.7

0.6

Time (ms)

0.5
58 fluents
91 fluents
134 fluents

0.4

0.3

0.2

0.1

0
200

1000

1800

2600

3400

4200

5000

Input Sequence Length

Figure 7: SLAF-time without CNF simplification for domains Driverlog and Zeno-Travel

(AND
(AND
(OR (ON E G)
(OR ((STACK ?X ?Y) CAUSES (NOT (ON ?X ?Y)))
(AND ((STACK ?X ?Y) KEEPS (ON ?X ?Y))
(NOT ((STACK ?X ?Y) NEEDS (ON ?X ?Y))))))
...
374

fiL EARNING PARTIALLY O BSERVABLE D ETERMINISTIC ACTION M ODELS

SLAF Space: Blocksworld Domain
300K

Space (#lisp symbols)

250K

200K
19 fluents
41 fluents
71 fluents
131 fluents
209 fluents

150K

100K

50K

K
200

1000

1800

2600

3400

4200

5000

Input Sequence Length

SLAF Space: Depots Domain
160K

140K

Space (#lisp symbols)

120K

100K

58 fluents
94 fluents
138 fluents
190 fluents
250 fluents

80K

60K

40K

20K

K
200

1000

1800

2600

3400

4200

5000

Input Sequence Length

Figure 8: SLAF space for domains Blocksworld and Depots

An example fragment of a model (the complete output is given in Appendix C) that is consistent
with our training data is
Blocksworld domain:
* 209 fluents
* 1000 randomly selected actions
* 10 fluents observed per step
* "schematized" learning
375

converting to CNF
clause count: 235492
variable count: 187
adding clauses
calling zchaff

fiA MIR & C HANG

SLAF Space: Driverlog Domain
250K

Space (#lisp symbols)

200K

150K

31 fluents
76 fluents
122 fluents
186 fluents
231 fluents

100K

50K

K
200

1000

1800

2600

3400

4200

5000

Input Sequence Length

SLAF Space: Zeno-Travel Domain
60K

Space (#lisp symbols)

50K

40K
58 fluents
91 fluents
134 fluents

30K

20K

10K

K
200

1000

1800

2600

3400

4200

5000

Input Sequence Length

Figure 9: SLAF space for domains Driverlog and Zeno-Travel

* 1:1 precondition heuristics

parsing result
SLAF time: 2.203
Inference time: 42.312
Learned model:

(UNSTACK NEEDS (NOT (CLEAR ?UNDEROB)))
(UNSTACK NEEDS (CLEAR ?OB))
(UNSTACK NEEDS (ARM-EMPTY))
376

fiL EARNING PARTIALLY O BSERVABLE D ETERMINISTIC ACTION M ODELS

(UNSTACK
(UNSTACK
(UNSTACK
(UNSTACK
(UNSTACK
(UNSTACK
(UNSTACK
(UNSTACK
(UNSTACK
(UNSTACK
(UNSTACK
(UNSTACK
(UNSTACK
...

NEEDS (NOT (HOLDING ?OB)))
NEEDS (ON ?OB ?UNDEROB))
CAUSES (CLEAR ?UNDEROB))
CAUSES (NOT (CLEAR ?OB)))
CAUSES (NOT (ARM-EMPTY)))
CAUSES (HOLDING ?OB))
CAUSES (NOT (ON ?OB ?UNDEROB)))
KEEPS (ON-TABLE ?UNDEROB))
KEEPS (ON-TABLE ?OB))
KEEPS (HOLDING ?UNDEROB))
KEEPS (ON ?UNDEROB ?UNDEROB))
KEEPS (ON ?OB ?OB))
KEEPS (ON ?UNDEROB ?OB))

Sometimes, there are multiple possible schematized propositions that correspond to a ground
action proposition, in which case we disjoin the propositions together when doing the replacement
(i.e., a single ground propositional symbol gets replaced by a disjunction of schema propositions).
This replacement is a simple procedure, but one that is effective in both deriving more information for fewer steps and also in speeding up model finding from the SLAF formula. We implemented
it to run while SLAF runs. One could do this during the SAT-solving portion of the algorithm, with
an equivalent result.
Regarding the latter, we ran into scaling issues with the SAT solver (ZChaff , Moskewicz et al.,
2001; Tang, Yinlei Yu, & Malik, 2004) and the common lisp compiler in large experiments. We got
around these issues by applying the replacement scheme above, thus reducing greatly the number
of variables that the SAT solver handles.
Another issue that we ran into is that the SAT solver tended to choose models with blank preconditions (the sequences that we used in these experiments include no action failure, so no preconditions is never eliminated by our algorithm). To add some bias to the extracted action model,
we added axioms of the following form:
(or (not (,a causes ,f)) (,a needs (not ,f)))
(or (not (,a causes (not ,f))) (,a needs ,f))
These axioms state that if an action a causes a fluent f to hold, then a requires f to not hold in
the precondition (similarly, there is an analagous axiom for f ). Intuitively, these axioms cause
the sat solver to favor 1:1 action models. We got the idea for this heuristic from the work of Wu,
Yang, and Jiang (2007), which uses a somewhat similar set of axioms to bias their results in terms
of learning preconditions. Clearly, these axioms dont always hold, and in the results, one can see
that the learned preconditions are often inaccurate.
Some other inaccuracies in the learned action models are reasonable. For example, if a fluent
never changes over the course of an action sequence, the algorithm may infer that an arbitrary action
causes that fluent to hold.
Do the conditions for the algorithms correctness hold in practice? In all of those scenarios
that we report here, the conditions that guarantee correctness for our algorithms hold. In our experiments we assumed that the main conditions of the algorithms hold, namely, that actions are
377

fiA MIR & C HANG

deterministic and of few preconditions. We did not enforce having observations for every fluent
every (fixed) k steps. The latter condition is not necessery for correctness of the algorithm, but is
necessary to guarantee polynomial-time computation. Our experiments verify that this is not necessary in practice, and it indeed be the case that the algorithms can have a polynomial-time guarantee
for our modified observation
An earlier work of Hlubocky and Amir (2004) has included a modified version of AS-STRIPSSLAF in their architecture and tested it on a suite of adventure-game-like virtual environments that
are generated at random. These include arbitrary numbers of places, objects of various kinds, and
configurations and settings of those. There, an agents task is to exit a house, starting with no
knowledge about the state space, available actions and their effects, or characteristics of objects.
Their experiments show that the agent learns the effects of its actions very efficiently. This agent
makes decisions using the learned knowledge, and inference with the resulting representation is fast
(a fraction of a second per SAT problem in domains including more than 30 object, modes, and
locations).
Can the learned model be used for successful planning and execution? How do the learning
procedures fit with planning and execution? The learned model can be used for planning by
translating it to PDDL. However, that model is not always the correct one for the domain, so the
plan may not be feasible or may not lead to the required goal. In those cases, we can interleave
planning, execution, and learning, as was described in the work of Chang and Amir (2006). There,
one finds a short plan with a consistent action model, executes that plan, collects observations, and
applies SLAF to those. When plan failure can be detected (e.g., that the goal was not achieved), the
results of Chang and Amir (2006) guarantee that the joint planning-execution-learning procedure
would reach the goal in a bounded amount of time. That bounded time is in fact linear in the length
of the longest plan needed for reaching the goal, and is exponential in the complexity of the action
model that we need to learn.

8. Comparison with Related Work
HMMs (Boyen & Koller, 1999; Boyen et al., 1999; Murphy, 2002; Ghahramani, 2001) can be used
to estimate a stochastic transition model from observations. Initially, we expected to compare our
work with the HMM implementation of Murphy (2002), which uses EM (a hill-climbing approach).
Unfortunately, HMMs require an explicit representation of the state space, and our smallest domain (31 features) requires a transition matrix of (231 )2 entries. This prevents initializing HMMs
procedures on any current computer.
Structure learning approaches in Dynamic Bayes Nets (DBNs) (e.g., Ghahramani & Jordan,
1997; Friedman, Murphy, & Russell, 1998; Boyen et al., 1999) use EM and additional approximations (e.g., using factoring, variation, or sampling), and are more tractable. However, they are still
limited to small domains (e.g., 10 features , Ghahramani & Jordan, 1997; Boyen et al., 1999), and
also have unbounded errors in discrete deterministic domains, so are not usable in our settings.
A simple approach for learning transition models was devised in the work of Holmes and
Charles Lee Isbell (2006) for deterministic POMDPs. There, the transition and observation models
are deterministic. This approach is close to ours in that it represents the hidden state and possible models using a finite structure, a Looping Prediction Suffix Tree. This structure can be seen
as related to our representation in that both grow models that relate action histories to possible
transition models. In our work here such interactions are realized in the recursive structure of the
378

fiL EARNING PARTIALLY O BSERVABLE D ETERMINISTIC ACTION M ODELS

transition-belief formula built by AS-STRIPS-SLAF, e.g.,
(af  (af   a[f ]  explf ))
where explf refers to a similar formula to this that was created in the previous time step.
The main difference that we should draw between our work and that of Holmes and Charles
Lee Isbell (2006) is that the latter refers to states explicitly, whereas our work refers to features.
Consequently, our representation is (provably) more compact and our procedures scale to larger
domains both theoretically and in practice. Furthermore, our procedure provably maintains a reference to all the possible models when data is insufficient to determine a single model, whereas the
work of Holmes and Charles Lee Isbell (2006) focuses only on the limit case of enough information for determining a single consistent model. On the down-side, our procedure does not consider
stochasticity in the belief state, and this remains an area for further development.
A similar relationship holds between our work and that of Littman, Sutton, and Singh (2002).
In that work, a model representation is given with a size linear in the number of states. This model,
predictive state representation (PSR), is based on action/observation histories and predicts behavior based on those histories. That work prefers a low-dimensional vector basis instead a featurebased representation of states (one of the traditional hallmarks of the Knowledge Representation
approach). There is no necessary correspondence between the basis vectors and some intuitive features in the real world necessarily. This enables a representation of the world that is more closely
based on behavior.
Learning PSRs (James & Singh, 2004) is nontrivial because one needs to find a good lowdimensional vector basis (the stage called discovery of tests). That stage of learning PSRs requires
matrices of size (n2 ), for states spaces of size n.
Our work advances over that line of work in providing correct results in time that is polylogarithmic in the number of states. Specifically, our work learns (deterministic) transition models
in polynomial time in the state features, thus taking time O(poly(log n)).
Reinforcement Learning (RL) approaches (Sutton & Barto, 1998; Bertsekas & Tsitsiklis, 1996)
compute a mapping between world states and preferred actions. They are highly intractable in
partially observable domains (Kaelbling, Littman, & Cassandra, 1998), and approximation (e.g.,
Kearns, Mansour, & Ng, 2000; Meuleau, Peshkin, Kim, & Kaelbling, 1999; Even-Dar, Kakade, &
Mansour, 2005; McCallum, 1995) is practical only for small domains (e.g., 10-20 features) with
small horizon time T .
In contrast to HMMs, DBNs, and RL, our algorithms are exact and tractable in large domains (>
300 features). We take advantages of properties common to discrete domains, such as determinism,
limited effects of actions, and observed failure.
Previous work on learning deterministic action models in the AI-Planning literature assumes
fully observable deterministic domains. These learn parametrized STRIPS actions using, e.g., version spaces (Gil, 1994; Wang, 1995), general classifiers (Oates & Cohen, 1996), or hill-climbing
ILP (Benson, 1995). Recently, the work of Pasula et al. (2004) gave an algorithm that learns stochastic actions with no conditional effects. The work of Schmill, Oates, and Cohen (2000) approximates
partial observability by assuming that the world is fully observable. We can apply these to partially
observable learning problems (sometimes) by using the space of belief states instead of world states,
but this increases the problem size to exponentially, so this is not practical for our problem.
Finally, recent research on learning action models in partially observable domains includes the
works of Yang, Wu, and Jiang (2005) and of Shahaf and Amir (2006). In the works of Yang et al.
379

fiA MIR & C HANG

(2005), example plan traces are encoded as a weighted maximum SAT problem, from which a
candidate STRIPS action model is extracted. In general, there may be many possible action models
for any given set of example traces, and therefore the approach is by nature approximate (in contrast
to ours, which always identifies the exact set of possible action models). The work also introduces
additional approximations in the form of heuristic rules meant to rule out unlikely action models.
The work of Shahaf and Amir (2006) presents an approach for solving SLAF using logicalcircuit encodings of transition belief states. This approach performs tractable SLAF for more general deterministic models than those that we present in Section 5, but it also requires SAT solvers
for logical circuits. Such SAT solvers are not optimized nowadays in comparison with CNF SAT
solvers, so their overall performance for answering questions from SLAF is lower than ours. Most
importantly, the representation given by Shahaf and Amir (2006) grows (linearly) with the number
of time steps, and this can still hinder long sequences of actions and observations. In comparison,
our transition belief formula has bounded size that is independent of the number of time steps that
we track.
Our encoding language, LA is typical in methods for software and hardware verification and
testing. Relevant books and methods (e.g., Clarke, Grumberg, & Peled, 1999) are closely related
to this representation, and results that we achieve here are applicable there and vice versa. The
main distinction we should draw between our work and that done in Formal Methods (e.g., Model
Checking and Bounded Model Checking) is that we are able to conclude size bounds for logical formulas involved in the computation. While OBDDs are used with some success in Model Checking,
and CNF representations are used with some success in Bounded Model Checking, they have little
bounds for the sizes of formulas in theory or in practice. The conditions available in AI applications
are used in the current manuscript to deliver such bounds and yield tractability and scalability results
that are both theoretical and of practical significance.
Interestingly, methods that use Linear Temporal Logics (LTL) cannot distinguish between what
can happen and what actually happens (Calvanese, Giacomo, & Vardi, 2002). Thus, they cannot
consider what causes an occurence. Our method is similar in that it does not consider alternate
futures for a state explicitly. However, we use an extended language, namely L A , that makes those
alternatives explicit. This allows us to forego the limitations of LTL and produce the needed result.

9. Conclusions
We presented a framework for learning the effects and preconditions of deterministic actions in
partially observable domains. This approach differs from earlier methods in that it focuses on determining the exact set of consistent action models (earlier methods do not). We showed that in several
common situations this can be done exactly in time that is polynomial (sometime linear) in the number of time steps and features. We can add bias and compute an exact solution for large domains
(hundreds of features), in many cases. Furthermore, we show that the number of action-observation
traces that must be seen before convergence is polynomial in the number of features of the domain.
These positive results contrast with the difficulty encountered by many approaches to learning of
dynamic models and reinforcement learning in partially observable domains.
The results that we presented are promising for many applications, including reinforcement
learning, agents in virtual domains, and HMMs. Already, this work is being applied to autonomous
agents in adventure games, and exploration is guided by the transition belief state that we compute
380

fiL EARNING PARTIALLY O BSERVABLE D ETERMINISTIC ACTION M ODELS

and information gain criteria. In the future we plan to extend these results to stochastic domains,
and domains with continuous features.

Acknowledgments
We wish to thank Megan Nance for providing the code and samples for the sequence generator,
and also wish to thank Dafna Shahaf for an encouraging collaboration that enhanced our development and understanding of these results. The first author also wishes to acknowledge stimulating
discussion with Brian Hlubocky on related topics. We wish to acknowledge support from DAF
Air Force Research Laboratory Award FA8750-04-2-0222 (DARPA REAL program). The second
author wishes to acknowledge support from a University of Illinois at Urbana-Champaign, College
of Engineering fellowship. Finally, the first author acknowledges support from a joint Fellowship
(2007-2008) with the Center for Advanced Studies and the Beckman Institute at the University of
Illinois Urbana-Champaign.
Earlier versions of the results in this manuscript appeared in conference proceedings (Amir,
2005; Shahaf et al., 2006).

Appendix A. Our Representation and Domain Descriptions
The transition relation RM for interpretation M in LA is defined in Section 3.1 in a way that is
similar to the interpretation of Domain Descriptions. Domain Descriptions are a common method
for specifying structured deterministic domains (Fagin, Ullman, & Vardi, 1983; Lifschitz, 1990;
Pednault, 1989; Gelfond & Lifschitz, 1998). Other methods that are equivalent in our contexts
include Successor-State Axioms (Reiter, 2001) and the Fluent Calculus (Thielscher, 1998). Their
relevance and influence on our work merit a separate exposition and relationship to our work.
A domain description D is a finite set of effect rules of the form a causes F if G that describe the effects of actions, for F and G being state formulas (propositional combinations of fluent
names). We say that F is the head or effect and G is the precondition for each such rule. We write
a causes F , for a causes F if TRUE. We denote by ED (a) the set of effect rules in D for action
a  A. For an effect rule e, let Ge be its precondition and Fe its effect. Rule e is active in state s, if
s |= Ge (s taken here as a interpretation in P).
Every domain description D defines a unique transition relation R D (s, a, s0 ) as follows.
V
 Let F (a, s) be the conjunction of effects of rules that are active in s for a, i.e., {Fe | e 
ED (a), s |= Ge }. We set F (a, s) = T RU E when no rule of a is active in s.
 Let I(a, s) be the set of fluents that are not affected by a in s, i.e., I(a, s) = {f  P D | e 
ED (a) (s |= Ge )  (f 
/ L(Fe ))}.
 Define (recalling that world states are sets of fluents)
 0



0  (s  I(a, s)) = (s  I(a, s))
RD = hs, a, s i 
(4)
and s0 |= F (a, s)

Thus, if action a has an effect of FALSE in s, then it cannot execute in s.
This definition applies inertia (a fluent keeps its value) to all fluents that appear in no active rule.
In some contexts it is useful to specify this inertia explicitly by extra effect rules of the form a
keeps f if G, for a fluent f  P. It is a shorthand for writing the two rules a causes f if f  G
and a causes f if f  G. When D includes all its inertia (keeps) statements, we say that D is
a complete domain description.
381

fiA MIR & C HANG

Example A.1 Consider the scenario of Figure 2 and assume that actions and observations occur as
in Figure 10. Actions are assumed deterministic, with no conditional effects, and their preconditions
must holds before they execute successfully. Then, every action affects every fluent either negatively,
positively, or not at all. Thus, every transition relation has a complete domain description that
includes only rules of the form a causes l or a keeps l, where l is a fluent literal (a fluent or
its negation).
Time step
Action
Location
Bulb
Switch

1

go-W

E
?
sw

2
E
lit
?

go-E

3
E
?
sw

sw-on

4
E
?
sw

go-W

5
E
lit
?

go-E

6
E
?
sw

Figure 10: An action-observation sequence (table entries are observations). Legend: E: east; E:
west; lit: light is on; lit: light is off; sw: switch is on; sw: switch is off.

Consequently, every transition relation R is completely defined by some domain description D
such that (viewing a tuple as a set of its elements)

 
 

 a causes E,   a causes sw,   a causes lit, 
Y
a causes E  a causes sw  a causes lit
R

 
 
9  a keeps E
8
a keeps lit
a keeps sw
> go-W >
a

>
<

>
=

go-E >
>
>
;
: sw-on >

Say that initially we know the effects of go-E, go-W, but do not know what sw-on does. Then,
transition filtering starts with the product set of R (of 27 possible relations) and all possible 2 3
states. Also, at time step 4 we know that the world state is exactly {E, lit, sw}. We try sw-on
and get that F ilter[sw-on](4 ) includes the same set of transition relations but with each of those
transition relations projecting the state {E, lit, sw} to an appropriate choice from S. When we
receive the observations o5 = E  sw of time step 5, 5 = F ilter[o5 ](F ilter[sw-on](4 ))
removes from the transition belief state all the relations that gave rise to E or to sw. We are left
with transition relations satisfying one of the tuples in




 sw-on causes lit 


sw-on causes E,
sw-on causes lit
 sw-on causes sw 
sw-on keeps E


sw-on keeps lit

Finally, when we perform action go-W, again we update the set of states associated with every
transition relation in the set of pairs 5 . When we receive the observations of time step 6, we
conclude 6 = F ilter[o6 ](F ilter[go-W](5 )) =
 




sw-on keeps E, 
sw-on causes E, 

+
+ *E  
*E  






 
  

   
sw-on causes sw,
sw-on causes sw,
lit
lit
(5)
,
,
,
sw-on causes lit, 
sw-on causes lit, 

  
  







sw
sw
 




go-E...
go-E...
2
382

fiL EARNING PARTIALLY O BSERVABLE D ETERMINISTIC ACTION M ODELS

Appendix B. Proofs
B.1 Proof of Lemma 3.1: Consequence Finding and Existential Quantification
P ROOF
Consider some CNF form of . Suppose the clauses containing the literal x are x 
1 , . . . , x  a where 1 , . . . , a are clauses. Suppose the clauses containing the literal x are
x  1 , . . . , x  b . V
Suppose the clauses
not containing x or x are 1 , . . . , c . Then note
V
L()\{x}
that Cn
()  ( 1ic i )  ( 1ia,1jb i  j ) (the formula produced by adding
all resolvents over variable x and then removing clauses not belonging to L(L()\{x})), since
resolution is complete for consequence finding.
Necessity. (x. |= CnL()\{x} ()) Consider any model m of x.. By definition, m can be
extended to L() (i.e., by assigning some value to m(x)) such that m() = 1. Extend m such that
this is the case. Now suppose for contradiction m is not a model of Cn L()\{x} (). It cannot be the
case that m(k ) = 0 for any k, because then m() = 0, contradiction. Then, it must be the case
that m(i  j ) = 0 for some 1  i  a and 1  j  b. Therefore, m(i ) = 0 and m(j ) = 0.
But m is a model of , so both m(x  i ) = 1 or m(x  j ) = 1. Thus either m(i ) = 1 or
m(j ) = 1, contradiction.
Sufficiency. (CnL()\{x} () |= x.) Consider any model m of CnL()\{x} (). Suppose for
contradiction m(x.) = 0. That is, if m is extended to L(), then m() = 0. Now, extend m
to L() such that m(x) = 0. It cannot be the case that m(k ) = 0 for some k since m models
CnL()\{x} (). Because m(x) = 1, it cannot be the case that m(x   j ) = 0 for any j.
Therefore m(x  i ) = 0 for some 1  i  a. Therefore, m(i ) = 0. Because m(i  j ) = 1 for
all 1  j  n, we must have that m(j ) = 1 for all j. But now if we alter m such that m(x) = 1,
then m satisfies , contradiction. 2
B.2 Proof of Theorem 3.3
P ROOF
Both sides of the equality relation are sets of state-transition-relation pairs. We show
that the two sets have the same elements. We show first that the left-hand side of the equality is
contained in the right-hand side.
Take hs0 , Ri  SLAF [a]({hs, Ri  S | hs, Ri satisfies }). From Definition 2.3 there is s  S
such that s  {s  S | hs, Ri satisfies } such that hs, a, s0 i  R. In other words, there is s  S
such that hs, Ri satisfies  and hs, a, s0 i  R.
To prove that hs0 , Ri satisfies SLAF0 [a]() we need to show that   Teff (at ) has a model M
such that RM = R and s0 interprets P 0 . Let M be such that s interprets P, s0 interprets P 0 , and MR
interpreting LA as in the previous
section. This interpretation
does not
Wsatisfy this formula only if
V
V
one of the conjuncts of   lF ,GG ((alG  G)  l0 )  lF (l0  ( GG (alG  G))) is falsified.
This cannot be the case for  by our choice of s.
Assume by contradiction that (alG  G)  l0 ) fails for some l. Then, (alG  G) hold in M and l0
is FALSE. The portion of M that interprets LA is built according to MR , for our R. Since hs, R, s0 i
we know that s0 satisfies l, by the construction of MR . This is a contradicts l 0 being FALSE in M
(M interprets P 0 according to s0 ), and therefore we conclude that (alG  G)  l0 ) for every l0 .
W
Similarly, assume by contradiction that (l 0  ( GG (alG  G))) fails for some l. Then, l 0 holds
in s0 , and als fails. Again, from the way we constructed MR it must be that als in M takes the value
that corresponds to the l 0 s truth value in s0 . Thus, it must be that als takes the value TRUE in M ,
and we are done with the first direction.
383

fiA MIR & C HANG

For the opposite direction (showing the right-hand side is contained in the left-hand side), take
hs0 , Ri  S that satisfies SLAF [a](). We show that
hs0 , Ri  SLAF [a]({hs, Ri  S | hs, Ri satisfies }).
hs0 , Ri |= SLAF [a]() implies (Corollary 3.2) that there is s  S such that hs 0 , R, si |=
  Teff (a) (s0 , R, s interpreting P 0 , LA , P, respectively). A similar argument to the one we give for
the first part shows that hs, a, s0 i  R, and hs0 , Ri  SLAF [a]({hs, Ri  S | hs, Ri satisfies }).
2
B.3 Proof of Theorem 4.1: Distribution of SLAF Over Connectives
For the first part, we will show that the sets of models of SLAF [a](  ) and SLAF [a]() 
SLAF [a]() are identical.
Take a model M of SLAF [a](  ). Let M 0 be a model of    for which SLAF [a](M 0 ) =
M . Then, M 0 is a model of  or M is a model of . Without loss of generalization, assume M
is a model of . Thus, M |= SLAF [a](), and it follows that M is a model of SLAF [a]() 
SLAF [a]().
For the other direction, take M a model of SLAF [a]()  SLAF [a](). Then, M a model of
SLAF [a]() or M is a model of SLAF [a](). Without loss of generalization assume that M is a
model of SLAF [a](). Take M 0 a model of  such that M = SLAF [a](M 0 ). So, M 0 |=   . It
follows that M |= SLAF [a](  ).
A similar argument follows for the  case. Take a model M of SLAF [a](  ). Let M 0 be
a model of    for which SLAF [a](M 0 ) = M . Then, M 0 is a model of  and . Thus, M |=
SLAF [a]() and M |= SLAF [a](). It follows that M is a model of SLAF [a]()SLAF [a]().
2
B.4 Proof of Theorem 4.5: Closed form for SLAF of a belief state formula
P ROOF SKETCH
We follow the characterization offered by Theorem 3.3 and Formula (1). We
take t at Teff (a, t) and resolve out the literals of time t. This resolution is guaranteed to generate
a set of consequences that is equivalent to CnLt+1 (t  at  Teff (a, t)).
V
Assuming t at , Teff (a, t) is logically equivalent to Teff (a, t)| = lF ,GG,G|= ((alG Gt ) 
V
lt+1 )  lF ,GG,G|= (lt+1  (Gt  alG )). This follows from two observations. First, notice that
t implies that for any G  G such that G 6|=  we get Gt  alG and (alG  Gt )  lt+1 (the
antecedent does notWhold, so the formula is true). Second, notice that, in
V the second part of the
original Teff (a, t), ( GG,G|= (alG  Gt )) is equivalent (assuming ) to ( GG,G|= (Gt  alG )).
Now, resolving out the literals of time t from t  at  Teff (a, t)| should consider all the
resolutions of clauses (Gt is a term) of the form alG  Gt  lt+1 and all the clauses of the form
lt+1  (Gt  alG ) with each other. This yields the equivalent to
^

m
_

[ lit+1
i=1
G1 , ...,
WGm  G
 |= im Gi
l1 , ..., lm  F

m
_
li
 alGi i )]
 (aG
i
i=1

because to eliminate all W
the literals of time t we have to resolve together sets of clauses with matching Gi s such that  |= in Gi . The formula above encodes all the resulting clauses for a chosen
384

fiL EARNING PARTIALLY O BSERVABLE D ETERMINISTIC ACTION M ODELS

li
i
set of G1 , ..., Gm and a chosen set of literals l1 , ..., lm . The reason for including (al
Gi  aGi ) is
that we can always choose a clause with Gi , li of a specific type (either one that includes alG or
one that produces al
G.
Finally, we get the formula in our theorem because aFG  aF
G (G characterizes exactly one
state in S), and the fact that there is one set of G1 , ..., Gm that is stronger than all the rest (it entails
all the rest) because G1 , ..., Gm are complete terms. This set is the complete fluent assignments G i
that satisfy . 2

B.5 Proof of Theorem 5.1: Closed form when k affected fluents
P ROOF SKETCH
For literal l and clause C in the conjunction in Theorem 4.5, we aggregate all
the action propositions to a single action proposition alGl , with G the disjunction of all the complete
preconditions for l in C (notice that there cannot be ls negation because then the C is a tautology).
Lemma B.2 shows that Gl is equivalent to a fluent term. First we prove the more restricted Lemma
B.1.
W
li
t+1
) be a clause of the formula in Theorem 4.5, and let Gl =
Lemma B.1 Let C = m
 aG
i=1 (li
i
W
{Gi | li = l, Gi |= li }, for any literal l6 . Assume that as effect is deterministic with only
one case with a term precondition (if that case does not hold, then nothing changes). Then, G l is
equivalent to a term.
P ROOF
Gl is a disjunction of complete state terms Gi , so it represents the set of states that
corresponds to those Gi s. The intuition that we apply is that
W
lit+1  alGi i 
C m
W
Vm i=1
t+1
( i=1 alGi i )  ( m
i=1 li ) 
0
l
a Gl  l  C
for C 0 the part of C that does not affect l. The reason is that for complete terms G i we know
li
l
i
that al
Gi  aGi . Thus, our choice of G is such that it includes all the conditions under which l
changes, if we assume the precondition alGl .
We now compute the action model of a for l by updating a copy of G l . Let li be a fluent literal,
and set Glt = Gl .
1. If there is no Gl2  Glt such that Gl2 |= li , then all of the terms in Glt include li . Thus,
Glt  Glt  li , and alGl  alGl li . Thus, add li as a conjunct to Glt .
2. Otherwise, if there is no Gl2  Glt such that Gl2 |= li , then all of the terms in Glt include li .
Thus, Glt  Glt  li , and alGl  alGl li . Thus, add li as a conjunct to Glt .
3. Otherwise, we know that under both li and li the value of the fluent of l changes into l =
TRUE. Since we assume that the value of l changes under a single case of its preconditions
(i.e., a has no conditional effects - it either succeeds with the change, or fails with the change),
then li cannot be part of those preconditions, i.e., for every term G i in Glt we can replace li
with li and vice versa, and the precondition would still entail l after the action. Thus,
alGl  alGl \{l } , for Glt \ {li } the result of replacing both li and li by TRUE.
t

t

i

6. Not related to the literal l in the proof above.

385

fiA MIR & C HANG

The result of these replacements is a term Glt that is consistent with t (it is consistent with the
original Gl ) and satisfies a has 1 case |= alGl  alGl . 2
t

W
li
t+1
cl =
Lemma B.2 Let C = m
 aG
be a clause of the formula in Theorem 4.5, and let G
i=1 li
i
W
{Gi | li = l}, for any literal l. Assume that as effect is deterministic with only one case with a
cl is equivalent
term precondition (if that case does not hold, then nothing changes). Then, either G
cl
to a term, or C is subsumed by another clause that is entailed from that formula such that there G
is equivalent to a term.
Gl .

cl and not in
P ROOF
Consider Gl from Lemma B.1, and let Gl1 a complete fluent term in G
l
l
l
Thus, G1 |= l. Let Gt the term that is equivalent to G according to Lemma B.1.
Clause C is equivalent to alGl  al
 .... However, alGl already asserts change from l to l
Gl
t

t

1

in the result of action a, and al
asserts a change under a different condition from l to l. Thus,
Gl
1

. We get a subsuming clause C 0 = C \ al
. In this way we can
a has 1 case |= alGl  al
Gl
Gl
t

1

1

remove from C all the literals alGi with Gi not in Gl .

cl . However, clause C is now
After such a process we are left with a clause C that has Gl  G
not of the form of Theorem 5.1 because some of the Gi s are missing. How do we represent that in
the theorem? We must allow some of the Gi s to be missing.
2
Proof of theorem continues Thus, the representation of C 0 (the new clause) takes space O(n2 )
(each propositional symbol is encoded with O(n) space, assuming constant encoding for every
fluent p  P).
However, the number of propositional symbols is still large (there are O(2 n ) fluent terms, so this
encoding still requires O(2n n) (all preconditions to all effects) new propositional symbols. Now
we notice that we can limit our attention to clauses C that have at most k literals l whose action
proposition alGl satisfies |= Gl  l. This is because if we have more than k such propositions in C,
V
W
l
say {alGi l }ik0 , then C  ( ki=1 alGi l )  aGk+1
 ... im lit+1 , which is always subsumed by
l
i
i
k+1
V
l
.
The
latter
is
a
sentence
that is always true, if we assume that a can change
( ki=1 alGi l )  aGk+1
l
i

k+1

at most k fluents (aGk+1
asserts that lk+1 remains the same, and alGi l asserts that li changes in
lk+1
i
one of the conditions satisfied by Gli ).
V
l
(which state that we have at most k effects)
Using clauses of the form ( ki=1 alGi l )  aGk+1
l
l

i

k+1

l

we can resolve away aGj l for j > k in every clause C of the original conjunction. Thus, we are
j
W
V
left with clauses of the form C  ( ki=1 alGi l )  im lit+1 . Now, since our choice of literals
i
other than l1 , ..., lk is independent of the rest of the clause, and we can do so for every polarity of
those fluents, we get that all of these clauses resolve (on these combinations of literals) into (and are
subsumed by)
k
_
^
lit+1
(6)
C  ( alGi l ) 
i=1

i

386

ik

fiL EARNING PARTIALLY O BSERVABLE D ETERMINISTIC ACTION M ODELS

Thus, we get a conjunction of clauses of the form (6), with G li (i  k) being a fluent term. So,
the conjunction of clauses in Theorem 4.5 is equivalent to a conjunction of clauses such that each
clause has at most 2k literals. Thus, the space required to represent each clause is 2kn.
Finally, we use the fact that every action is dependent on at most k other fluents. Every proposition that asserts no-change in li is equivalent to a conjunction of literals stating that none of the
possible k preconditions that are consistent with it affect li . For example alli1 ...lk lu implies

that alli1 ...lk  alli1 ...lk1 lu  .... Similarly, each one the elements in the conjunction implies

alli1 ...lk lu . 2

B.6 Proof of Theorem 5.3: Equivalent Restricted Definition of Action Axioms
P ROOF
Let 0 = P.(eff (a)). Now we claim that for any successful actionS
a, SLAF [a]() 
0
[P 0 /P] . To see this, consider any model of 0 . The valuation to the fluents in f P L0f define a
transition relation R and the valuation to the fluents in P 0 define a state s0  S such that hs0 , Ri  0 .
By the definition of 0 , hs0 , Ri  0 if and only if there exists hs, Ri   such that eff (a) is satisfied. Finally note that eff (a) is satisfied if and only if the preconditions of action a are met and
s0 is consistent with the effects of action a applied to s. That is, eff (a) is satisfied if and only if
hs, a, s0 i  R. Together, these observations and Corollary 3.2 yield the theorem. 2
B.7 Proof of Theorem 5.4: AS-STRIPS-SLAF is Correct
P ROOF
Let the shorthand notation C() denote C()  CnL ()[P 0 /P] .
By definition, SLAF [ha, oi]()  SLAF [o](SLAF [a]()). From Theorem 5.3, we have
SLAF [a]()  C(  eff (a)). A formula equivalent to C(  eff (a)) may be generated by
resolving
V out all fluents from P (by following the procedure from the proof of Lemma 3.1). Suppose
 = f P f is in fluent-factored form. Then we may rewrite C(  eff (a)) as:
0



SLAF [a]()  










^

f P

^

f P

^

f P

^

f P



C(Prea,f )  C(Effa,f )  C(f ) 

(7)



C(Prea,f  Effa,f ) 


C(f  Prea,f ) 


C(f  Effa,f )

This equivalence holds because all resolvents generated by resolving out literals from P in C( 
eff (a)) will still be generated in the above formula. That is, each pair of clauses that can be possibly resolved together (where a fluent from P is resolved out) in    eff (a) to generate a new
consequence in C (  eff (a)) will appear together in one of the C () components of (7). Because
387

fiA MIR & C HANG

every clause in   eff (a) contains at most one literal from P, we see that all possible consequences
will be generated.
Now we note that Effa,f may be rewritten as follows:
Effa,f



^

((al  (af   l))  l0 )  (l0  (al  (af   l)))

(8)

l{f,f }



^

(l  (l0  al ))  (l0  (al  af  ))

l{f,f }

It is straightforward to verify the equivalence of the rewritten formula to the original formula. Note
that in performing this rewriting, we may discard clauses of the form a f  af  af  , as they must
be true in every consistent model (given the axioms described in Section 5.2).
Now consider the consequences that are generated by each component of (7). We may compute
these consequences by performing resolution. We have that C(Pre a,f )  a[f ]  a[f ] , but we
may discard these clauses because only inconsistent action models will violate this clause. By
the definition of fluent-factored formulas, C(f )  Af . Next, the remaining components can be
computed straightforwardly:
^
C(Effa,f ) 
(l0  al  af  )
l{f,f }

C(f  Prea,f )  C(f )  C(Prea,f ) 

^

(a[l]  expll )

l{f,f }

C(Prea,f  Effa,f )  C(Prea,f )  C(Effa,f ) 

^

(l0  al  a[l] )

l{f,f }

C(f  Effa,f )  C(f )  C(Effa,f ) 

^

(l0  al  expll )

l{f,f }

Finally, it is not difficult to see that in steps (a)-(c) the procedure sets  to the following formula (in
fluent-factored form):
^
^
SLAF [a]() 
Af 
(a[l]  expll )  (l0  al  (af   a[l]  expll )
f P

l{f,f }

Now, note that SLAF [o](SLAF [a]())  SLAF [a]()  o. Note that because o is a term,
then SLAF [a]()  o can be made fluent-factored by performing unit resolution. This is exactly
what steps 1.(d)-(e) do. 2
B.8 Proof of Theorem 5.5: AS-STRIPS-SLAF Complexity
P ROOF
Consider the size of the formula returned by AS-STRIPS-SLAF. Overview: We note
that if a formula is in i-CNF, for any integer i > 0, then the filtered formula after one step is in
(i + 1)-CNF. Then, we note that every observation of fluent f resets the f -part of the belief state
formula to 1-CNF (thus, to i = 1).
Further Details: For the first part, this is because each call to the procedure appends at most
one literal to any existing clauses of the formula, and no new clauses of length more than k + 1 are
388

fiL EARNING PARTIALLY O BSERVABLE D ETERMINISTIC ACTION M ODELS

generated. Additionally, if every fluent is observed every at most k steps, then the transition belief
formula stays in k-CNF (i.e., indefinitely compact). This is because existing clauses may only grow
in length (1 literal per timestep) when augmented in steps 1.(a)-(c), but when the appropriate fluent
is observed in steps 1.(d)-(e), the clauses stop growing. Finally, it is easy to see that each of the
steps 1.(a)-(e) can be performed in polynomial time. 2
B.9 Proof of Theorem 5.7: PRE-STRIPS-SLAF is Correct
P ROOF
Consider the semantics of SLAF when filtering on a STRIPS action with a known precondition. In the case of an action failure, a world is in the filtered transition belief state if and only
if the world did not meet the action precondition (and satisfies the observation). Clearly, step 1 of
the algorithm performs this filtering by conjoining the belief formula with the negation of the action
precondition (converted into a logically equivalent disjunction of fluent-factored formulas).
In the case of an action success, filtering can be performed by first removing worlds which
do not satisfy the action precondition (so in all remaining worlds, the action is executable) and
then filtering the remaining worlds using algorithm AS-STRIPS-SLAF. Moreover, by Theorem 4.1
and Corollary 4.3 it follows that filtering the formula  can be performed by filtering each of the
subformulas i,j separately. Furthermore, SLAF[ha, oi]() |= PRE-STRIPS-SLAF[ha, oi](), and
PRE-STRIPS-SLAF[ha, oi]()  SLAF[ha, oi]() if any of the conditions of Corollary 4.3. The
filtering of each subformula is performed by steps 2 and 3 of the algorithm.
Finally, note that steps 3 and 4 serve only to simplify the belief formula and produce a logically
equivalent formula. 2
B.10 Proof of Theorem 5.8: PRE-STRIPS-SLAF Complexity
P ROOF
Note that each call to AS-STRIPS-SLAF on a subformula takes time linear in the size
of the subformula, and the steps not involving AS-STRIPS-SLAF can be performed in linear time.
Thus the the total time complexity is linear. Additionally, note that if every fluent is observed every
at most k steps, then every fluent-factored subformula i,j of the belief formula is in k-CNF, by a
theorem of Amir
W (2005). If action preconditions contain at most m literals, then each disjunction
of the form j i,j contains at most m disjuncts. Therefore, the entire belief formula stays in
m  k-CNF, indefinitely. 2

Appendix C. Experiments And Their Outputs
Our experiments (Section 7) examine properties of our algorithms for learning action models. They
show that learning is tractable and exact. In this Appendix section we bring the generating models
and the learned models for more detailed comparison by the reader. Recall that our algorithms
output a representation for the set of models that are possible given the input. Below we bring only
one satisfying model from the learned formula.
Our experiments include the following domains from the International Planning Competition
(IPC): Drivelog, Zenotravel, Blocksworld, and Depots.
C.1 Driverlog Domain
The Driverlog domain has the following generating PDDL:
(define (domain driverlog)

389

fiA MIR & C HANG

(:requirements :typing)
(:types
location locatable - object
driver truck obj - locatable )
(:predicates
(at ?obj - locatable ?loc - location)
(in ?obj1 - obj ?obj - truck)
(driving ?d - driver ?v - truck)
(path ?x ?y - location)
(empty ?v - truck) )
(:action LOAD-TRUCK
:parameters
(?obj - obj
?truck - truck
?loc - location)
:precondition
(and (at ?truck ?loc) (at ?obj ?loc))
:effect
(and (not (at ?obj ?loc)) (in ?obj ?truck)))
(:action UNLOAD-TRUCK
:parameters
(?obj - obj
?truck - truck
?loc - location)
:precondition
(and (at ?truck ?loc) (in ?obj ?truck))
:effect
(and (not (in ?obj ?truck)) (at ?obj ?loc)))
(:action BOARD-TRUCK
:parameters
(?driver - driver
?truck - truck
?loc - location)
:precondition
(and (at ?truck ?loc) (at ?driver ?loc) (empty ?truck))
:effect
(and (not (at ?driver ?loc)) (driving ?driver ?truck)
(not (empty ?truck))))
(:action DISEMBARK-TRUCK
:parameters
(?driver - driver
?truck - truck
?loc - location)
:precondition
(and (at ?truck ?loc) (driving ?driver ?truck))
:effect
(and (not (driving ?driver ?truck)) (at ?driver ?loc)
(empty ?truck)))
(:action DRIVE-TRUCK
:parameters
(?truck - truck
?loc-from - location
?loc-to location
?driver - driver)
:precondition
(and (at ?truck ?loc-from)
(driving ?driver ?truck)
(path ?loc-from ?loc-to))
:effect
(and (not (at ?truck ?loc-from)) (at ?truck ?loc-to)))
(:action WALK
:parameters
(?driver - driver
?loc-from - location
?loc-to - location)
:precondition
(and (at ?driver ?loc-from) (path ?loc-from ?loc-to))
:effect
(and (not (at ?driver ?loc-from)) (at ?driver ?loc-to))) )

One learned model (one possible satisfying model of our formula) from our random-sequence
input in this Driverlog domain is the following (brought together with the experimental parameters).
Driverlog domain:
* IPC3 problem 99
* 231 fluents
* 1000 randomly selected actions
* 10 fluents observed per step

390

fiL EARNING PARTIALLY O BSERVABLE D ETERMINISTIC ACTION M ODELS

* "schematized" learning
* 1:1 precondition heuristics
* Action distribution:
((BOARD-TRUCK . 52) (DRIVE-TRUCK . 86) (DISEMBARK-TRUCK . 52)
(WALK . 529) (UNLOAD-TRUCK . 139) (LOAD-TRUCK . 142))
converting to CNF
clause count: 82338
variable count: 210
adding clauses
calling zchaff
parsing result
SLAF time: 2.469
Inference time: 8.406
Learned model:
(WALK NEEDS (AT ?DRIVER ?LOC-FROM))
(WALK NEEDS (NOT (AT ?DRIVER ?LOC-TO)))
(WALK CAUSES (AT ?DRIVER ?LOC-TO))
(WALK CAUSES (NOT (AT ?DRIVER ?LOC-FROM)))
(WALK KEEPS (PATH ?LOC-FROM ?LOC-FROM))
(WALK KEEPS (PATH ?LOC-TO ?LOC-TO))
(WALK KEEPS (PATH ?LOC-TO ?LOC-FROM))
(WALK KEEPS (PATH ?LOC-FROM ?LOC-TO))
(DRIVE-TRUCK NEEDS (NOT (AT ?TRUCK ?LOC-TO)))
(DRIVE-TRUCK NEEDS (AT ?TRUCK ?LOC-FROM))
(DRIVE-TRUCK CAUSES (AT ?TRUCK ?LOC-TO))
(DRIVE-TRUCK CAUSES (NOT (AT ?TRUCK ?LOC-FROM)))
(DRIVE-TRUCK KEEPS (AT ?DRIVER ?LOC-TO))
(DRIVE-TRUCK KEEPS (AT ?DRIVER ?LOC-FROM))
(DRIVE-TRUCK KEEPS (DRIVING ?DRIVER ?TRUCK))
(DRIVE-TRUCK KEEPS (PATH ?LOC-TO ?LOC-TO))
(DRIVE-TRUCK KEEPS (PATH ?LOC-FROM ?LOC-FROM))
(DRIVE-TRUCK KEEPS (PATH ?LOC-FROM ?LOC-TO))
(DRIVE-TRUCK KEEPS (PATH ?LOC-TO ?LOC-FROM))
(DRIVE-TRUCK KEEPS (EMPTY ?TRUCK))
(DISEMBARK-TRUCK NEEDS (NOT (AT ?DRIVER ?LOC)))
(DISEMBARK-TRUCK NEEDS (DRIVING ?DRIVER ?TRUCK))
(DISEMBARK-TRUCK NEEDS (NOT (EMPTY ?TRUCK)))
(DISEMBARK-TRUCK CAUSES (AT ?DRIVER ?LOC))
(DISEMBARK-TRUCK CAUSES (NOT (DRIVING ?DRIVER ?TRUCK)))
(DISEMBARK-TRUCK CAUSES (EMPTY ?TRUCK))
(DISEMBARK-TRUCK KEEPS (AT ?TRUCK ?LOC))
(DISEMBARK-TRUCK KEEPS (PATH ?LOC ?LOC))
(BOARD-TRUCK NEEDS (AT ?DRIVER ?LOC))
(BOARD-TRUCK NEEDS (NOT (DRIVING ?DRIVER ?TRUCK)))
(BOARD-TRUCK NEEDS (EMPTY ?TRUCK))
(BOARD-TRUCK CAUSES (NOT (AT ?DRIVER ?LOC)))
(BOARD-TRUCK CAUSES (DRIVING ?DRIVER ?TRUCK))
(BOARD-TRUCK CAUSES (NOT (EMPTY ?TRUCK)))
(BOARD-TRUCK KEEPS (AT ?TRUCK ?LOC))
(BOARD-TRUCK KEEPS (PATH ?LOC ?LOC))
(UNLOAD-TRUCK NEEDS (NOT (AT ?OBJ ?LOC)))
(UNLOAD-TRUCK NEEDS (IN ?OBJ ?TRUCK))
(UNLOAD-TRUCK CAUSES (AT ?OBJ ?LOC))

391

fiA MIR & C HANG

(UNLOAD-TRUCK CAUSES (NOT (IN ?OBJ ?TRUCK)))
(UNLOAD-TRUCK KEEPS (AT ?TRUCK ?LOC))
(UNLOAD-TRUCK KEEPS (PATH ?LOC ?LOC))
(UNLOAD-TRUCK KEEPS (EMPTY ?TRUCK))
(LOAD-TRUCK NEEDS (AT ?OBJ ?LOC))
(LOAD-TRUCK NEEDS (NOT (IN ?OBJ ?TRUCK)))
(LOAD-TRUCK CAUSES (NOT (AT ?OBJ ?LOC)))
(LOAD-TRUCK CAUSES (IN ?OBJ ?TRUCK))
(LOAD-TRUCK KEEPS (AT ?TRUCK ?LOC))
(LOAD-TRUCK KEEPS (PATH ?LOC ?LOC))
(LOAD-TRUCK KEEPS (EMPTY ?TRUCK))

C.2 Zeno-Travel Domain
The Zeno-Travel domain has the following generating PDDL:
(define (domain zeno-travel)
(:requirements :typing)
(:types aircraft person city flevel - object)
(:predicates (at ?x - (either person aircraft) ?c - city)
(in ?p - person ?a - aircraft)
(fuel-level ?a - aircraft ?l - flevel)
(next ?l1 ?l2 - flevel))
(:action board
:parameters (?p - person ?a - aircraft ?c - city)
:precondition (and (at ?p ?c) (at ?a ?c))
:effect (and (not (at ?p ?c)) (in ?p ?a)))
(:action debark
:parameters (?p - person ?a - aircraft ?c - city)
:precondition (and (in ?p ?a) (at ?a ?c))
:effect (and (not (in ?p ?a)) (at ?p ?c)))
(:action fly
:parameters (?a - aircraft ?c1 ?c2 - city ?l1 ?l2 - flevel)
:precondition (and (at ?a ?c1) (fuel-level ?a ?l1) (next ?l2 ?l1))
:effect (and (not (at ?a ?c1)) (at ?a ?c2) (not (fuel-level ?a ?l1))
(fuel-level ?a ?l2)))
(:action zoom
:parameters (?a - aircraft ?c1 ?c2 - city ?l1 ?l2 ?l3 - flevel)
:precondition (and (at ?a ?c1) (fuel-level ?a ?l1) (next ?l2 ?l1)
(next ?l3 ?l2) )
:effect (and (not (at ?a ?c1)) (at ?a ?c2) (not (fuel-level ?a ?l1))
(fuel-level ?a ?l3) ))
(:action refuel
:parameters (?a - aircraft ?c - city ?l - flevel ?l1 - flevel)
:precondition (and (fuel-level ?a ?l) (next ?l ?l1) (at ?a ?c))
:effect (and (fuel-level ?a ?l1) (not (fuel-level ?a ?l)))))

One learned model (one possible satisfying model of our formula) from our random-sequence
input in this Zeno-Travel domain is the following (brought together with the experimental parameters).
Zenotravel domain:

392

fiL EARNING PARTIALLY O BSERVABLE D ETERMINISTIC ACTION M ODELS

*
*
*
*
*
*
*

IPC3 problem 9
91 fluents, 21000 possible unique actions
1000 actions in learned action sequence
5 observed fluents per step
"schematized" learning
1:1 precondition heuristics
Action distribution: ((ZOOM . 27) (FLY . 216) (REFUEL . 264)
(BOARD . 249) (DEBARK . 244))

converting to CNF
clause count: 71119
variable count: 138
adding clauses
calling zchaff
parsing result
SLAF time: 1.109
Inference time: 11.015
Learned model:
(REFUEL NEEDS (FUEL-LEVEL ?A ?L))
(REFUEL NEEDS (NOT (FUEL-LEVEL ?A ?L1)))
(REFUEL CAUSES (NOT (FUEL-LEVEL ?A ?L)))
(REFUEL CAUSES (FUEL-LEVEL ?A ?L1))
(REFUEL KEEPS (NEXT ?L ?L))
(REFUEL KEEPS (NEXT ?L ?L1))
(REFUEL KEEPS (NEXT ?L1 ?L))
(REFUEL KEEPS (NEXT ?L1 ?L1))
(ZOOM NEEDS (NOT (FUEL-LEVEL ?A ?L3)))
(ZOOM NEEDS (FUEL-LEVEL ?A ?L1))
(ZOOM CAUSES (FUEL-LEVEL ?A ?L3))
(ZOOM CAUSES (NOT (FUEL-LEVEL ?A ?L1)))
(ZOOM KEEPS (FUEL-LEVEL ?A ?L2))
(ZOOM KEEPS (NEXT ?L3 ?L3))
(ZOOM KEEPS (NEXT ?L3 ?L2))
(ZOOM KEEPS (NEXT ?L3 ?L1))
(ZOOM KEEPS (NEXT ?L2 ?L3))
(ZOOM KEEPS (NEXT ?L2 ?L2))
(ZOOM KEEPS (NEXT ?L2 ?L1))
(ZOOM KEEPS (NEXT ?L1 ?L3))
(ZOOM KEEPS (NEXT ?L1 ?L2))
(ZOOM KEEPS (NEXT ?L1 ?L1))
(FLY NEEDS (NOT (FUEL-LEVEL ?A ?L2)))
(FLY NEEDS (FUEL-LEVEL ?A ?L1))
(FLY CAUSES (FUEL-LEVEL ?A ?L2))
(FLY CAUSES (NOT (FUEL-LEVEL ?A ?L1)))
(FLY KEEPS (NEXT ?L2 ?L2))
(FLY KEEPS (NEXT ?L2 ?L1))
(FLY KEEPS (NEXT ?L1 ?L2))
(FLY KEEPS (NEXT ?L1 ?L1))
(DEBARK NEEDS (IN ?P ?A))
(DEBARK CAUSES (NOT (IN ?P ?A)))
(BOARD NEEDS (NOT (IN ?P ?A)))
(BOARD CAUSES (IN ?P ?A))

393

fiA MIR & C HANG

C.3 Blocks-World Domain
The Blocksworld domain has the following generating PDDL:
(define (domain blocksworld)
(:requirements :strips)
(:predicates (clear ?x - object)
(on-table ?x - object)
(arm-empty)
(holding ?x - object)
(on ?x ?y - object))
(:action pickup
:parameters (?ob - object)
:precondition (and (clear ?ob) (on-table ?ob) (arm-empty))
:effect (and (holding ?ob) (not (clear ?ob)) (not (on-table ?ob))
(not (arm-empty))))
(:action putdown
:parameters (?ob - object)
:precondition (holding ?ob)
:effect (and (clear ?ob) (arm-empty) (on-table ?ob)
(not (holding ?ob))))
(:action stack
:parameters (?ob - object
?underob - object)
:precondition (and (clear ?underob) (holding ?ob))
:effect (and (arm-empty) (clear ?ob) (on ?ob ?underob)
(not (clear ?underob)) (not (holding ?ob))))
(:action unstack
:parameters (?ob - object
?underob - object)
:precondition (and (on ?ob ?underob) (clear ?ob) (arm-empty))
:effect (and (holding ?ob) (clear ?underob) (not (on ?ob ?underob))
(not (clear ?ob)) (not (arm-empty)))))

One learned model (one possible satisfying model of our formula) from our random-sequence
input in this Blocksworld domain is the following (brought together with the experimental parameters).
Blocksworld domain:
* 209 fluents
* 1000 randomly selected actions
* 10 fluents observed per step
* "schematized" learning
* 1:1 precondition heuristics
converting to CNF
clause count: 235492
variable count: 187
adding clauses
calling zchaff
parsing result
SLAF time: 2.203
Inference time: 42.312

394

fiL EARNING PARTIALLY O BSERVABLE D ETERMINISTIC ACTION M ODELS

Learned model:
(UNSTACK NEEDS (NOT (CLEAR ?UNDEROB)))
(UNSTACK NEEDS (CLEAR ?OB))
(UNSTACK NEEDS (ARM-EMPTY))
(UNSTACK NEEDS (NOT (HOLDING ?OB)))
(UNSTACK NEEDS (ON ?OB ?UNDEROB))
(UNSTACK CAUSES (CLEAR ?UNDEROB))
(UNSTACK CAUSES (NOT (CLEAR ?OB)))
(UNSTACK CAUSES (NOT (ARM-EMPTY)))
(UNSTACK CAUSES (HOLDING ?OB))
(UNSTACK CAUSES (NOT (ON ?OB ?UNDEROB)))
(UNSTACK KEEPS (ON-TABLE ?UNDEROB))
(UNSTACK KEEPS (ON-TABLE ?OB))
(UNSTACK KEEPS (HOLDING ?UNDEROB))
(UNSTACK KEEPS (ON ?UNDEROB ?UNDEROB))
(UNSTACK KEEPS (ON ?OB ?OB))
(UNSTACK KEEPS (ON ?UNDEROB ?OB))
(STACK NEEDS (CLEAR ?UNDEROB))
(STACK NEEDS (NOT (CLEAR ?OB)))
(STACK NEEDS (NOT (ARM-EMPTY)))
(STACK NEEDS (HOLDING ?OB))
(STACK NEEDS (NOT (ON ?OB ?UNDEROB)))
(STACK CAUSES (NOT (CLEAR ?UNDEROB)))
(STACK CAUSES (CLEAR ?OB))
(STACK CAUSES (ARM-EMPTY))
(STACK CAUSES (NOT (HOLDING ?OB)))
(STACK CAUSES (ON ?OB ?UNDEROB))
(STACK KEEPS (ON-TABLE ?UNDEROB))
(STACK KEEPS (ON-TABLE ?OB))
(STACK KEEPS (HOLDING ?UNDEROB))
(STACK KEEPS (ON ?UNDEROB ?UNDEROB))
(STACK KEEPS (ON ?OB ?OB))
(STACK KEEPS (ON ?UNDEROB ?OB))
(PUTDOWN NEEDS (NOT (CLEAR ?OB)))
(PUTDOWN NEEDS (NOT (ON-TABLE ?OB)))
(PUTDOWN NEEDS (NOT (ARM-EMPTY)))
(PUTDOWN NEEDS (HOLDING ?OB))
(PUTDOWN CAUSES (CLEAR ?OB))
(PUTDOWN CAUSES (ON-TABLE ?OB))
(PUTDOWN CAUSES (ARM-EMPTY))
(PUTDOWN CAUSES (NOT (HOLDING ?OB)))
(PUTDOWN KEEPS (ON ?OB ?OB))
(PICKUP NEEDS (CLEAR ?OB))
(PICKUP NEEDS (ON-TABLE ?OB))
(PICKUP NEEDS (ARM-EMPTY))
(PICKUP NEEDS (NOT (HOLDING ?OB)))
(PICKUP CAUSES (NOT (CLEAR ?OB)))
(PICKUP CAUSES (NOT (ON-TABLE ?OB)))
(PICKUP CAUSES (NOT (ARM-EMPTY)))
(PICKUP CAUSES (HOLDING ?OB))
(PICKUP KEEPS (ON ?OB ?OB))

395

fiA MIR & C HANG

C.4 Depot Domain
The Depot domain has the following generating PDDL:
(define (domain Depot)
(:requirements :typing)
(:types place locatable - object
depot distributor - place
truck hoist surface - locatable
pallet crate - surface)
(:predicates (at ?x - locatable ?y - place)
(on ?x - crate ?y - surface)
(in ?x - crate ?y - truck)
(lifting ?x - hoist ?y - crate)
(available ?x - hoist)
(clear ?x - surface))
(:action Drive
:parameters (?x - truck ?y - place ?z - place)
:precondition (and (at ?x ?y))
:effect (and (not (at ?x ?y)) (at ?x ?z)))
(:action Lift
:parameters (?x - hoist ?y - crate ?z - surface ?p - place)
:precondition (and (at ?x ?p) (available ?x) (at ?y ?p) (on ?y ?z)
(clear ?y))
:effect (and (not (at ?y ?p)) (lifting ?x ?y) (not (clear ?y))
(not (available ?x)) (clear ?z) (not (on ?y ?z))))
(:action Drop
:parameters (?x - hoist ?y - crate ?z - surface ?p - place)
:precondition (and (at ?x ?p) (at ?z ?p) (clear ?z) (lifting ?x ?y))
:effect (and (available ?x) (not (lifting ?x ?y)) (at ?y ?p)
(not (clear ?z)) (clear ?y) (on ?y ?z)))
(:action Load
:parameters (?x - hoist ?y - crate ?z - truck ?p - place)
:precondition (and (at ?x ?p) (at ?z ?p) (lifting ?x ?y))
:effect (and (not (lifting ?x ?y)) (in ?y ?z) (available ?x)))
(:action Unload
:parameters (?x - hoist ?y - crate ?z - truck ?p - place)
:precondition (and (at ?x ?p) (at ?z ?p) (available ?x) (in ?y ?z))
:effect (and (not (in ?y ?z)) (not (available ?x)) (lifting ?x ?y))) )

One learned model (one possible satisfying model of our formula) from our random-sequence
input in this Depot domain is the following (brought together with the experimental parameters).
Depots domain:
* IPC3 problem 5
* 250 fluents
* 1000 randomly selected actions
* 10 fluents observed per step
* "schematized" learning
* 1:1 precondition heuristics
converting to CNF

396

fiL EARNING PARTIALLY O BSERVABLE D ETERMINISTIC ACTION M ODELS

clause count: 85359
variable count: 236
adding clauses
calling zchaff
parsing result
SLAF time: 2.797
Inference time: 8.062
Learned model:
(UNLOAD NEEDS (IN ?Y ?Z))
(UNLOAD NEEDS (NOT (LIFTING ?X ?Y)))
(UNLOAD NEEDS (AVAILABLE ?X))
(UNLOAD CAUSES (NOT (IN ?Y ?Z)))
(UNLOAD CAUSES (LIFTING ?X ?Y))
(UNLOAD CAUSES (NOT (AVAILABLE ?X)))
(UNLOAD KEEPS (AT ?Z ?P))
(UNLOAD KEEPS (AT ?Y ?P))
(UNLOAD KEEPS (AT ?X ?P))
(UNLOAD KEEPS (ON ?Y ?Y))
(UNLOAD KEEPS (CLEAR ?Y))
(LOAD NEEDS (NOT (IN ?Y ?Z)))
(LOAD NEEDS (LIFTING ?X ?Y))
(LOAD NEEDS (NOT (AVAILABLE ?X)))
(LOAD CAUSES (IN ?Y ?Z))
(LOAD CAUSES (NOT (LIFTING ?X ?Y)))
(LOAD CAUSES (AVAILABLE ?X))
(LOAD KEEPS (AT ?Z ?P))
(LOAD KEEPS (AT ?Y ?P))
(LOAD KEEPS (AT ?X ?P))
(LOAD KEEPS (ON ?Y ?Y))
(LOAD KEEPS (CLEAR ?Y))
(DROP NEEDS (NOT (AT ?Y ?P)))
(DROP NEEDS (NOT (ON ?Y ?Z)))
(DROP NEEDS (LIFTING ?X ?Y))
(DROP NEEDS (NOT (AVAILABLE ?X)))
(DROP NEEDS (CLEAR ?Z))
(DROP NEEDS (NOT (CLEAR ?Y)))
(DROP CAUSES (AT ?Y ?P))
(DROP CAUSES (ON ?Z ?Z))
(DROP CAUSES (NOT (ON ?Z ?Z)))
(DROP CAUSES (ON ?Z ?Y))
(DROP CAUSES (NOT (ON ?Z ?Y)))
(DROP CAUSES (ON ?Y ?Z))
(DROP CAUSES (NOT (LIFTING ?X ?Y)))
(DROP CAUSES (LIFTING ?X ?Z))
(DROP CAUSES (NOT (LIFTING ?X ?Z)))
(DROP CAUSES (AVAILABLE ?X))
(DROP CAUSES (NOT (CLEAR ?Z)))
(DROP CAUSES (CLEAR ?Y))
(DROP KEEPS (AT ?Z ?P))
(DROP KEEPS (AT ?X ?P))
(DROP KEEPS (ON ?Z ?Z))
(DROP KEEPS (ON ?Z ?Y))
(DROP KEEPS (ON ?Y ?Y))
(DROP KEEPS (LIFTING ?X ?Z))

397

fiA MIR & C HANG

(LIFT NEEDS (AT ?Y ?P))
(LIFT NEEDS (ON ?Y ?Z))
(LIFT NEEDS (NOT (LIFTING ?X ?Y)))
(LIFT NEEDS (AVAILABLE ?X))
(LIFT NEEDS (NOT (CLEAR ?Z)))
(LIFT NEEDS (CLEAR ?Y))
(LIFT CAUSES (NOT (AT ?Y ?P)))
(LIFT CAUSES (NOT (ON ?Y ?Z)))
(LIFT CAUSES (ON ?Z ?Z))
(LIFT CAUSES (NOT (ON ?Z ?Z)))
(LIFT CAUSES (ON ?Z ?Y))
(LIFT CAUSES (NOT (ON ?Z ?Y)))
(LIFT CAUSES (LIFTING ?X ?Y))
(LIFT CAUSES (LIFTING ?X ?Z))
(LIFT CAUSES (NOT (LIFTING ?X ?Z)))
(LIFT CAUSES (NOT (AVAILABLE ?X)))
(LIFT CAUSES (CLEAR ?Z))
(LIFT CAUSES (NOT (CLEAR ?Y)))
(LIFT KEEPS (AT ?Z ?P))
(LIFT KEEPS (AT ?X ?P))
(LIFT KEEPS (ON ?Y ?Y))
(LIFT KEEPS (ON ?Z ?Z))
(LIFT KEEPS (ON ?Z ?Y))
(LIFT KEEPS (LIFTING ?X ?Z))
(DRIVE NEEDS (AT ?X ?Y))
(DRIVE NEEDS (NOT (AT ?X ?Z)))
(DRIVE CAUSES (NOT (AT ?X ?Y)))
(DRIVE CAUSES (AT ?X ?Z))

References
Amir, E. (2005). Learning partially observable deterministic action models. In Proc. Nineteenth
International Joint Conference on Artificial Intelligence (IJCAI 05), pp. 14331439. International Joint Conferences on Artificial Intelligence.
Amir, E., & Russell, S. (2003). Logical filtering. In Proc. Eighteenth International Joint Conference
on Artificial Intelligence (IJCAI 03), pp. 7582. Morgan Kaufmann.
Benson, S. (1995). Inductive learning of reactive action models. In Proceedings of the 12th International Conference on Machine Learning (ICML-95).
Bertsekas, D. P., & Tsitsiklis, J. N. (1996). Neuro-Dynamic Programming. Athena Scientific.
Boutilier, C., Reiter, R., & Price, B. (2001). Symbolic dynamic programming for first-order MDPs.
In Proc. Seventeenth International Joint Conference on Artificial Intelligence (IJCAI 01), pp.
690697. Morgan Kaufmann.
Boyen, X., Friedman, N., & Koller, D. (1999). Discovering the hidden structure of complex dynamic
systems. In Proceedings of the 15th Conference on Uncertainty in Artificial IntelligenceUAI
1999, pp. 91100. Morgan Kaufmann. Available at http://www.cs.stanford.edu/ xb/uai99/.
Boyen, X., & Koller, D. (1999). Approximate learning of dynamic models. In Kearns, M. S., Solla,
S. A., & Kohn, D. A. (Eds.), Advances in Neural Information Processing Systems 11: Proceedings of the 1998 ConferenceNIPS 1998, pp. 396402. Cambridge: MIT Press. Available at http://www.cs.stanford.edu/ xb/nips98/.
398

fiL EARNING PARTIALLY O BSERVABLE D ETERMINISTIC ACTION M ODELS

Calvanese, D., Giacomo, G. D., & Vardi, M. Y. (2002). Reasoning about actions and planning in
LTL action theories. In Principles of Knowledge Representation and Reasoning: Proc. Eighth
Intl Conference (KR 2002), pp. 593602. Morgan Kaufmann.
Chang, A., & Amir, E. (2006). Goal achievement in partially known, partially observable domains.
In Proceedings of the 16th Intl Conf. on Automated Planning and Scheduling (ICAPS06).
AAAI Press.
Chang, C.-L., & Lee, R. C.-T. (1973). Symbolic Logic and Mechanical Theorem Proving. Academic
Press.
Clarke, E. M., Grumberg, O., & Peled, D. A. (1999). Model Checking. MIT Press.
Darwiche, A., & Marquis, P. (2002). A knowledge compilation map. Journal of Artificial Intelligence Research, 17, 229264.
Davis, M., & Putnam, H. (1960). A computing procedure for quantification theory. Journal of the
ACM, 7, 201215.
Dawsey, W., Minsker, B., & Amir, E. (2007). Real-time assessment of drinking water systems using
Bayesian networks. In World Environmental and Water Resources Congress.
Dechter, R. (1999). Bucket elimination: A unifying framework for reasoning. Artificial Intelligence,
113(12), 4185.
del Val, A. (1999). A new method for consequence finding and compilation in restricted language. In Proc. National Conference on Artificial Intelligence (AAAI 99), pp. 259264.
AAAI Press/MIT Press.
Doherty, P., Lukaszewicz, W., & Szalas, A. (1997). Computing circumscription revisited: A reduction algorithm. Journal of Automated Reasoning, 18(3), 297336.
Eiter, T., & Gottlob, G. (1992). On the complexity of propositional knowledge base revision, updates, and counterfactuals. Artificial Intelligence, 57(2-3), 227270.
Even-Dar, E., Kakade, S. M., & Mansour, Y. (2005). Reinforcement learning in POMDPs. In
Proc. Nineteenth International Joint Conference on Artificial Intelligence (IJCAI 05), pp.
660665. International Joint Conferences on Artificial Intelligence.
Fagin, R., Ullman, J. D., & Vardi, M. Y. (1983). On the semantics of updates in databases. In
Proceedings of the Second ACM SIGACT-SIGMOD Symposium on Principles of Database
Systems, pp. 352365, Atlanta, Georgia.
Fikes, R., Hart, P., & Nilsson, N. (1972). Learning and executing generalized robot plans. Artificial
Intelligence, 3, 251288.
Fox, M., & Long, D. (2002). PDDL2.1: An extension to PDDL for expressing temporal planning
domains. http://www.dur.ac.uk/d.p.long/IPC/pddl.html. Used in AIPS02 competition.
Friedman, N., Murphy, K., & Russell, S. (1998). Learning the structure of dynamic probabilistic
networks. In Proc. Fourteenth Conference on Uncertainty in Artificial Intelligence (UAI 98).
Morgan Kaufmann.
Gelfond, M., & Lifschitz, V. (1998). Action languages. Electronic Transactions on Artificial Intelligence (http://www.etaij.org), 3, nr 16.
399

fiA MIR & C HANG

Ghahramani, Z. (2001). An introduction to Hidden Markov Models and Bayesian networks. International Journal of Pattern Recognition and Artificial Intelligence, 15(1), 942.
Ghahramani, Z., & Jordan, M. I. (1997). Factorial hidden markov models. Machine Learning, 29,
245275.
Ghallab, M., Howe, A., Knoblock, C., McDermott, D., Ram, A., Veloso, M., Weld, D., & Wilkins,
D. (1998). PDDL  The Planning Domain Definition Language, version 1.2. Tech. rep. CVC
TR-98-003/DCS TR-1165, Yale center for computational vision and control.
Gil, Y. (1994). Learning by experimentation: Incremental refinement of incomplete planning domains. In Proceedings of the 11th International Conference on Machine Learning (ICML-94),
pp. 1013.
Ginsberg, M. L. (1987). Readings in Nonmonotonic Reasoning, chap. 1, pp. 123. Morgan Kaufmann, Los Altos, CA.
Hajishirzi, H., & Amir, E. (2007). Stochastic filtering in probabilistic action models. In Proc. National Conference on Artificial Intelligence (AAAI 07).
Hill, D. J., Minsker, B., & Amir, E. (2007). Real-time Bayesian anomaly detection for environmental
sensor data. In 32nd Congress of the International Association of Hydraulic Engineering and
Research (IAHR 2007).
Hlubocky, B., & Amir, E. (2004). Knowledge-gathering agents in adventure games. In AAAI-04
Workshop on Challenges in Game AI. AAAI Press.
Holmes, M. P., & Charles Lee Isbell, J. (2006). Looping suffix tree-based inference of partially
observable hidden state. In Proceedings of the 23rd International Conference on Machine
Learning (ICML-06), pp. 409416. ACM Press.
Iwanuma, K., & Inoue, K. (2002). Minimal answer computation and sol. In Logics in Artificial
Intelligence: Proceedings of the Eighth European Conference, Vol. 2424 of LNAI, pp. 245
257. Springer-Verlag.
James, M., & Singh, S. (2004). Learning and discovery of predictive state representations in dynamical systems with reset. In Proceedings of the 21st International Conference on Machine
Learning (ICML-04), pp. 417424. ACM Press.
Kaelbling, L. P., Littman, M. L., & Cassandra, A. R. (1998). Planning and acting in partially
observable stochastic domains. Artificial Intelligence, 101, 99134.
Kearns, M., Mansour, Y., & Ng, A. Y. (2000). Approximate planning in large POMDPs via reusable
trajectories. In Proceedings of the 12th Conference on Neural Information Processing Systems
(NIPS98), published 1999, pp. 10011007. MIT Press.
Kuffner., J. J., & LaValle, S. M. (2000). Rrt-connect: An efficient approach to single-query path
planning.. In IEEE International Conference on Robotics and Automation (ICRA), pp. 995
1001.
Lee, R. C.-T. (1967). A Completeness Theorem and a Computer Program for Finding Theorems
Derivable from Given Axioms. Ph.D. thesis, University of California, Berkeley.
Lifschitz, V. (1990). On the semantics of STRIPS. In Allen, J. F., Hendler, J., & Tate, A. (Eds.),
Readings in Planning, pp. 523530. Morgan Kaufmann, San Mateo, California.
400

fiL EARNING PARTIALLY O BSERVABLE D ETERMINISTIC ACTION M ODELS

Littman, M. L. (1996). Algorithms for sequential decision making. Ph.D. thesis, Department of
Computer Science, Brown University. Technical report CS-96-09.
Littman, M. L., Sutton, R., & Singh, S. (2002). Predictive representations of state. In Proceedings of
the 15th Conference on Neural Information Processing Systems (NIPS01), published 2002.
MIT Press.
Marquis, P. (2000). Consequence finding algorithms. In Gabbay, D., & Smets, P. (Eds.), Handbook of Defeasible Reasoning and Uncertainty Management Systems, Vol. 5: Algorithms for
defeasible and uncertain reasoning. Kluwer.
McCallum, R. A. (1995). Instance-based utile distinctions for reinforcement learning with hidden
state. In Proceedings of the 12th International Conference on Machine Learning (ICML-95).
Morgan Kaufmann.
McCarthy, J. (1986). Applications of Circumscription to Formalizing Common Sense Knowledge.
Artificial Intelligence, 28, 89116.
McCarthy, J., & Hayes, P. J. (1969). Some philosophical problems from the standpoint of artificial intelligence. In Meltzer, B., & Michie, D. (Eds.), Machine Intelligence 4, pp. 463502.
Edinburgh University Press.
McIlraith, S., & Amir, E. (2001). Theorem proving with structured theories. In Proc. Seventeenth
International Joint Conference on Artificial Intelligence (IJCAI 01), pp. 624631. Morgan
Kaufmann.
Meuleau, N., Peshkin, L., Kim, K.-E., & Kaelbling, L. P. (1999). Learning finite-state controllers for
partially observable environments. In Proc. Fifteenth Conference on Uncertainty in Artificial
Intelligence (UAI 99). Morgan Kaufmann.
Moskewicz, M. W., Madigan, C. F., Zhao, Y., Zhang, L., & Malik, S. (2001). Chaff: Engineering an
Efficient SAT Solver. In Proceedings of the 38th Design Automation Conference (DAC01).
Murphy, K. (2002). Dynamic Bayesian Networks: Representation, Inference and Learning. Ph.D.
thesis, University of California at Berkeley.
Nance, M., Vogel, A., & Amir, E. (2006). Reasoning about partially observed actions. In Proc. National Conference on Artificial Intelligence (AAAI 06). AAAI Press.
Oates, T., & Cohen, P. R. (1996). Searching for planning operators with context-dependent and
probabilistic effects. In Proc. National Conference on Artificial Intelligence (AAAI 96), pp.
863868. AAAI Press.
Pasula, H. M., Zettlemoyer, L. S., & Kaelbling, L. P. (2004). Learning probabilistic relational
planning rules. In Proceedings of the 14th Intl Conf. on Automated Planning and Scheduling
(ICAPS04). AAAI Press.
Pednault, E. P. D. (1989). ADL: exploring the middle ground between STRIPS and the situation
calculus. In Proc. First International Conference on Principles of Knowledge Representation
and Reasoning (KR 89), pp. 324332.
Reiter, R. (2001). Knowledge In Action: Logical Foundations for Describing and Implementing
Dynamical Systems. MIT Press.
401

fiA MIR & C HANG

Reiter, R. (1991). The frame problem in the situation calculus: A simple solution (sometimes) and
a completeness result for goal regression. In Lifschitz, V. (Ed.), Artificial Intelligence and
Mathematical Theory of Computation (Papers in Honor of John McCarthy), pp. 359380.
Academic Press.
Robert, C. P., Celeux, G., & Diebolt, J. (1993). Bayesian estimation of hidden Markov chains: a
stochastic implementation. Statist. Prob. Letters, 16, 7783.
Schmill, M. D., Oates, T., & Cohen, P. R. (2000). Learning planning operators in real-world, partially observable environments. In Proceedings of the 5th Intl Conf. on AI Planning and
Scheduling (AIPS00), pp. 246253. AAAI Press.
Shahaf, D., & Amir, E. (2006). Learning partially observable action schemas. In Proc. National
Conference on Artificial Intelligence (AAAI 06). AAAI Press.
Shahaf, D., & Amir, E. (2007). Logical circuit filtering. In Proc. Twentieth International Joint Conference on Artificial Intelligence (IJCAI 07), pp. 26112618. International Joint Conferences
on Artificial Intelligence.
Shahaf, D., Chang, A., & Amir, E. (2006). Learning partially observable action models: Efficient
algorithms. In Proc. National Conference on Artificial Intelligence (AAAI 06). AAAI Press.
Simon, L., & del Val, A. (2001). Efficient consequence-finding. In Proc. Seventeenth International
Joint Conference on Artificial Intelligence (IJCAI 01), pp. 359365. Morgan Kaufmann.
Sutton, R. S., & Barto, A. G. (1998). Reinforcement Learning: an introduction. MIT Press.
Tang, D., Yinlei Yu, D. R., & Malik, S. (2004). Analysis of search based algorithms for satisfiability of quantified boolean formulas arising from circuit state space diameter problems. In
Proceedings of the Seventh International Conference on Theory and Applications of Satisfiability Testing (SAT2004).
Thielscher, M. (1998). Introduction to the fluent calculus. Electronic Transactions on Artificial
Intelligence (http://www.etaij.org), 3, nr 14.
Thrun, S. (2003). Robotic mapping: a survey. In Exploring artificial intelligence in the new millennium, pp. 135. Morgan Kaufmann.
Wang, X. (1995). Learning by observation and practice: an incremental approach for planning operator acquisition. In Proceedings of the 12th International Conference on Machine Learning
(ICML-95), pp. 549557. Morgan Kaufmann.
Wu, K., Yang, Q., & Jiang, Y. (2007). Arms: an automatic knowledge engineering tool for learning
action models for ai planning. The Knowledge Engineering Review, 22(2), 135152.
Yang, Q., Wu, K., & Jiang, Y. (2005). Learning actions models from plan examples with incomplete
knowledge.. In Biundo, S., Myers, K. L., & Rajan, K. (Eds.), ICAPS, pp. 241250. AAAI.

402

fi