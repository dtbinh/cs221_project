Journal of Artificial Intelligence Research 38 (2010) 371-413

Submitted 2/10; published 7/10

Approximate Model-Based Diagnosis
Using Greedy Stochastic Search
Alexander Feldman

a.b.feldman@tudelft.nl

Delft University of Technology
Mekelweg 4, 2628 CD, Delft, The Netherlands

Gregory Provan

g.provan@cs.ucc.ie

University College Cork
College Road, Cork, Ireland

Arjan van Gemund

a.j.c.vangemund@tudelft.nl

Delft University of Technology
Mekelweg 4, 2628 CD, Delft, The Netherlands

Abstract
We propose a StochAstic Fault diagnosis AlgoRIthm, called Safari, which trades off
guarantees of computing minimal diagnoses for computational efficiency. We empirically
demonstrate, using the 74XXX and ISCAS85 suites of benchmark combinatorial circuits,
that Safari achieves several orders-of-magnitude speedup over two well-known deterministic algorithms, CDA and HA , for multiple-fault diagnoses; further, Safari can compute a
range of multiple-fault diagnoses that CDA and HA cannot. We also prove that Safari
is optimal for a range of propositional fault models, such as the widely-used weak-fault
models (models with ignorance of abnormal behavior). We discuss the optimality of Safari in a class of strong-fault circuit models with stuck-at failure modes. By modeling the
algorithm itself as a Markov chain, we provide exact bounds on the minimality of the diagnosis computed. Safari also displays strong anytime behavior, and will return a diagnosis
after any non-trivial inference time.

1. Introduction
Model-Based Diagnosis (MBD) is an area of artificial intelligence that uses a system model,
together with observations about system behavior, to isolate sets of faulty components (diagnoses) that explain the observed behavior according to some minimality criterion. The
standard MBD formalization (Reiter, 1987) frames a diagnostic problem in terms of a set
of logical clauses that include mode-variables describing the nominal and fault status of
system components; from this the diagnostic status of the system can be computed given
an observation of the systems sensors. MBD provides a sound and complete approach to
enumerating multiple-fault diagnoses, and exact algorithms can guarantee finding a diagnosis optimal with respect to the number of faulty components, probabilistic likelihood,
etc.
The biggest challenge (and impediment to industrial deployment) is the computational
complexity of the MBD problem. The MBD problem of determining if there exists a diagnosis with at most k faults is NP-hard for the arbitrary propositional models we consider in
this article (Bylander, Allemang, Tanner, & Josephson, 1991; Friedrich, Gottlob, & Nejdl,
1990). Computing the set of all diagnoses is harder still, since there are possibly exponenc
2010
AI Access Foundation. All rights reserved.

fiFeldman, Provan, & van Gemund

tially many such diagnoses. Since almost all proposed MBD algorithms have been complete
and exact, with some authors proposing possible trade-offs between completeness and faster
consistency checking by employing methods such as BCP (Williams & Ragno, 2007), the
complexity problem still remains a major challenge to MBD.
To overcome this complexity problem, we propose a novel approximation approach for
multiple-fault diagnosis, based on a stochastic algorithm. Safari (StochAstic Fault diagnosis AlgoRIthm) sacrifices guarantees of optimality, but for diagnostic systems in which
faults are described in terms of an arbitrary deviation from nominal behavior, Safari can
compute diagnoses several orders of magnitude faster than competing algorithms.
Our contributions are as follows. (1) This paper introduces an approximation algorithm
for computing diagnoses within an MBD framework, based on a greedy stochastic algorithm.
(2) We show that we can compute minimal-cardinality diagnoses for weak fault models in
polynomial time (calling an incomplete SAT-solver that implements Boolean Constraint
Propagation1 (BCP) only), and that more general frameworks (such as a sub-class of strong
fault models) are also amenable to this class of algorithm. (3) We model Safari search as a
Markov chain to show the performance and optimality trade-offs that the algorithm makes.
(4) We apply this algorithm to a suite of benchmark combinatorial circuits, demonstrating order-of-magnitude speedup over two state-of-the-art deterministic algorithms, CDA
and HA , for multiple-fault diagnoses. (5) We compare the performance of Safari against
a range of Max-SAT algorithms for our benchmark problems. Our results indicate that,
whereas the search complexity for the deterministic algorithms tested increases exponentially with fault cardinality, the search complexity for this stochastic algorithm appears
to be independent of fault cardinality. Safari is of great practical significance, as it can
compute a large fraction of minimal-cardinality diagnoses for discrete systems too large or
complex to be diagnosed by existing deterministic algorithms.

2. Technical Background
Our discussion continues by formalizing some MBD notions. This paper uses the traditional
diagnostic definitions (de Kleer & Williams, 1987), except that we use propositional logic
terms (conjunctions of literals) instead of sets of failing components.
Central to MBD, a model of an artifact is represented as a propositional formula over
some set of variables. Discerning two subsets of these variables as assumable and observable 2
variables gives us a diagnostic system.
Definition 1 (Diagnostic System). A diagnostic system DS is defined as the triple DS =
hSD, COMPS, OBSi, where SD is a propositional theory over a set of variables V , COMPS 
V , OBS  V , COMPS is the set of assumables, and OBS is the set of observables.
Throughout this paper we will assume that OBS  COMPS =  and SD 6|=. Not all
propositional theories used as system descriptions are of interest to MBD. Diagnostic systems can be characterized by a restricted set of models, the restriction making the problem
1. With formulae in Conjunctive Normal Form (CNF), BCP is implemented through the unit resolution
rule.
2. In the MBD literature the assumable variables are also referred to as component, failure-mode, or
health variables. Observable variables are also called measurable, or control variables.

372

fiApproximate Model-Based Diagnosis Using Greedy Stochastic Search

of computing diagnosis amenable to algorithms like the one presented in this paper. We
consider two main classes of models.
Definition 2 (Weak-Fault Model). A diagnostic system DS = hSD, COMPS, OBSi belongs
to the class WFM iff for COMPS = {h1 , h2 , . . . , hn }, SD is equivalent to (h1  F1 ) (h2 
F2 )  . . .  (hn  Fn ) and COMPS  V  = , where V  is the set of all variables appearing
in the propositional formulae F1 , F2 , . . . , Fn .
Note the conventional selection of the sign of the health variables h1 , h2 , . . . hn . Alternatively, negative literals, e.g., f1 , f2 , . . . , fn can be used to express faults, in which case a
weak-fault model is in the form (f1  F1 )  . . .  (fn  Fn ). Other authors use ab for
abnormal or ok for healthy.
Weak-fault models are sometimes referred to as models with ignorance of abnormal
behavior (de Kleer, Mackworth, & Reiter, 1992), or implicit fault systems. Alternatively,
a model may specify faulty behavior for its components. In the following definition, with
the aim of simplifying the formalism throughout this paper, we adopt a slightly restrictive
representation of faults, allowing only a single fault-mode per assumable variable. This can
be easily generalized by introducing multi-valued logic or suitable encodings (Hoos, 1999).
Definition 3 (Strong-Fault Model). A diagnostic system DS = hSD, COMPS, OBSi belongs
to the class SFM iff SD is equivalent to (h1  F1,1 )  (h1  F1,2 )  . . .  (hn  Fn,1 ) 
(hn  Fn,2 ) such that 1  i, j  n, k  {1, 2}, {hi }  COMPS, F{j,k} is a propositional
formula, and none of hi appears in Fj,k .
Membership testing for the WFM and SFM classes can be performed efficiently in many
cases, for example, when a model is represented explicitly as in Def. 2 or Def. 3.
2.1 A Running Example
We will use the Boolean circuit shown in Fig. 1 as a running example for illustrating all
the notions and algorithms in this paper. The subtractor, shown there, consists of seven
components: an inverter, two or-gates, two xor-gates, and two and-gates. The expression
h  (o  i) models the normative (healthy) behavior of an inverter, where the variables i,
o, and h represent input, output and health respectively. Similarly, an and-gate is modeled
as h  [o  (i1  i2 )] and an or-gate by h  [o  (i1  i2 )]. Finally, an xor-gate is specified
as h  [o   (i1  i2 )].
The above propositional formulae are copied for each gate in Fig. 1 and their variables
renamed in such a way as to properly connect the circuit and disambiguate the assumables,
thus obtaining a propositional formula for the Boolean subtractor, given by:
SDw = {h1  [i   (y  p)]}  {h2  [d   (x  i)]}  [h3  (j  y  p)] 
 [h4  (m  l  j)]  [h5  (b  m  k)]  [h6  (x  l)] 
 [h7  (k  y  p)]

(1)

A strong-fault model for the Boolean circuit shown in Fig. 1 is constructed by assigning
fault-modes to the different gate types. We will assume that, when malfunctioning, the
output of an xor-gate has the value of one of its inputs, an or-gate can be stuck-at-one,
373

fiFeldman, Provan, & van Gemund

x
y
p

h1

h3

i

j

h2

d

h5

b

h6

l

h4

h7

m

k

Figure 1: A subtractor circuit
an and-gate can be stuck-at-zero, and an inverter behaves like a buffer. This gives us the
following strong-fault model formula for the Boolean subtractor circuit:
SDs = SDw  [h1  (i  y)]  [h2  (d  x)]  (h3  j) 
 (h4  m)  (h5  b)  [h6  (x  l)]  (h7  k)

(2)

For both models (SDs and SDw ), the set of assumable variables is COMPS = {h1 , h2 , . . . , h7 }
and the set of observable variables is OBS = {x, y, p, d, b}.
2.2 Diagnosis and Minimal Diagnosis
The traditional query in MBD computes terms of assumable variables which are explanations for the system description and an observation.
Definition 4 (Health Assignment). Given a diagnostic system DS = hSD, COMPS, OBSi,
an assignment  to all variables in COMPS is defined as a health assignment.
A health assignment  is a conjunction of propositional literals. In some cases it is convenient to use the set of negative or positive literals in . These two sets are denoted as
Lit  () and Lit + (), respectively.
In our example, the all nominal assignment is 1 = h1  h2  . . .  h7 . The health
assignment 2 = h1  h2  h3  h4  h5  h6  h7 means that the two and-gates from Fig. 1
are malfunctioning. What follows is a formal definition of consistency-based diagnosis.
Definition 5 (Diagnosis). Given a diagnostic system DS = hSD, COMPS, OBSi, an observation , which is an instantiation of some variables in OBS, and a health assignment , 
is a diagnosis iff SD     6|=.
Traditionally, other authors (de Kleer & Williams, 1987) arrive at minimal diagnosis by computing a minimal hitting set of the minimal conflicts (broadly, minimal health assignments
incompatible with the system description and the observation), while this paper makes no
use of conflicts, hence the equivalent, direct definition above.
There is a total of 96 possible diagnoses given SDw and an observation 1 = x  y  p 
b  d. Example diagnoses are 3 = h1  h2  . . .  h7 and 4 = h1  h2  h3  . . .  h7 .
Trivially, given a weak-fault model, the all faulty health assignment (in our example
374

fiApproximate Model-Based Diagnosis Using Greedy Stochastic Search

a = h1  . . .  h7 ) is a diagnosis for any instantiation of the observable variables in OBS
(cf. Def. 2).
In the analysis of our algorithm we need the opposite notion of diagnosis, i.e., health
assignments inconsistent with a model and an observation. In the MBD literature these
assignments are usually called conflicts. Conflicts, however, do not necessarily instantiate
all variables in COMPS. As in this paper we always use full health instantiations, the use
of the term conflict is avoided to prevent confusion.
In the MBD literature, a range of types of preferred diagnosis has been proposed.
This turns the MBD problem into an optimization problem. In the following definition we
consider the common subset-ordering.
Definition 6 (Minimal Diagnosis). A diagnosis   is defined as minimal, if no diagnosis
  exists such that Lit  (  )  Lit  (  ).
Consider the weak-fault model SDw of the circuit shown in Fig. 1 and an observation
2 = x  y  p  b  d. In this example, two of the minimal diagnoses are 5 =
h1  h2  h3  h4  h5  h6  h7 and 6 = h1  h2  . . .  h5  h6  h7 . The diagnosis
7 = h1  h2  h3  h4  h5  h6  h7 is non-minimal as the negative literals in 5 form
a subset of the negative literals in 7 .
Note that the set of all minimal diagnoses characterizes all diagnoses for a weak-fault
model, but that does not hold in general for strong-fault models (de Kleer et al., 1992).
In the latter case, faulty components may exonerate each other, resulting in a health
assignment containing a proper superset of the negative literals of another diagnosis not to
be a diagnosis. In our example, given SDs and 3 = x  y  p  b  d, it follows that
8 = h1  h2  h3  h4  . . .  h7 is a diagnosis, but 9 = h1  h2  h3  h4  . . .  h7
is not a diagnosis, despite the fact that the negative literals in 9 form a superset of the
negative literals in 8 .
Definition 7 (Number of Minimal Diagnoses). Let the set  (SD  ) contain all minimal diagnoses of a system description SD and an observation . The number of minimal
diagnoses, denoted as | (SD  )|, is defined as the cardinality of  (SD  ).
Continuing our running example, | (SDw  2 )| = 8 and | (SDs  3 )| = 2. The number
of non-minimal diagnoses of SDw  2 is 61.
Definition 8 (Cardinality of a Diagnosis). The cardinality of a diagnosis, denoted as ||,
is defined as the number of negative literals in .
Diagnosis cardinality gives us another partial ordering: a diagnosis is defined as minimal
cardinality iff it minimizes the number of negative literals.
Definition 9 (Minimal-Cardinality Diagnosis). A diagnosis   is defined as minimalcardinality if no diagnosis   exists such that |  | < |  |.
The cardinality of a minimal-cardinality diagnosis computed from a system description SD
and an observation  is denoted as MinCard (SD  ). For our example model SDw and an
observation 4 = x  y  p  b  d, it follows that MinCard (SDw  4 ) = 2. Note that
in this case all minimal diagnoses are also minimal-cardinality diagnoses.
375

fiFeldman, Provan, & van Gemund

A minimal cardinality diagnosis is a minimal diagnosis, but the opposite need not hold.
In the general case, there are minimal diagnoses which are not minimal-cardinality diagnoses. Consider the example SDw and 2 given earlier in this section, and the two resulting
minimal diagnoses 5 and 6 . From these two, only 5 is a minimal-cardinality diagnosis.
Definition 10 (Number of Minimal-Cardinality Diagnoses). Let the set  (SD  ) contain all minimal-cardinality diagnoses of a system description SD and an observation .
The number of minimal-cardinality diagnoses, denoted as | (SD  )|, is defined as the
cardinality of  (SD  ).
Computing the number of minimal-cardinality diagnoses for the running example results in
| (SDw  2 )| = 2, | (SDs  3 )| = 2, and | (SDw  4 )| = 4.
2.3 Converting Propositional Formulae to Clausal Form
Our approach is related to satisfiability, and Safari uses a SAT solver. SAT solvers commonly accept their input in Conjunctive Normal Form (CNF), although there exist SAT
solvers that work directly on propositional formulae (Thiffault, Bacchus, & Walsh, 2004).
Converting a propositional formula to CNF can be done with (Tseitin, 1983) or without
(Forbus & de Kleer, 1993) the introduction of intermediate variables. In both cases important structural information is lost, which may lead to performance degradation when
checking if a formula is consistent or when computing a solution.
Lemma 1. A fault-model SD = F1  F2  . . .  Fn (SD  WFM or SD  SFM) with
n = |COMPS| component variables can be converted to CNF in time O(|COMPS|) where
 is the time for converting the largest subformula Fi (1  i  n) to CNF.
Proof (Sketch). The conversion of SD to CNF can be done by (1) converting each subformula
Fi to CNF and (2) concatenating the resulting CNFs in the final CNF equivalent of SD.
The complexity of (1) is O(n) while the complexity of (2) is, in the worst-case, O(2m ) < ,
where m is the largest number of variables in a subformula Fi . As a result, the total time
for converting SD is dominated by  and it is linear in |COMPS|.
Lemma 1 is useful in the cases in which each subformula Fi is small. This is the case in many
practical situations where SD is composed of small component models. This is also the case
with our experimental benchmark (cf. Sec. 6) where the model of a combinational circuit
is the conjunction of fault models of simple logic gates (x-bit and-gates, typically x < 10,
xor-gates, etc.). Ideally, Safari would use a non-CNF SAT solver, but for practical reasons
we have constrained our reasoning to diagnostic models with concise CNF encodings.
Consider, for example, the formula (x1  y1 )  (x2  y2 )      (xn  yn ), which is
in Disjunctive Normal Form3 (DNF) and, converted to CNF, has 2n clauses. Although
similar examples of propositional formulae having exponentially many clauses in their CNF
representations are easy to find, they are artificial and are rarely encountered in MBD.
Furthermore, the Boolean circuits with which we have tested the performance of Safari
do not show exponential blow-up when converted to CNF.
3. Note that all DNF formulae are also propositional formulae.

376

fiApproximate Model-Based Diagnosis Using Greedy Stochastic Search

2.4 Complexity of Diagnostic Inference
This section discusses the complexity of the problems in which we are interested, namely
the problem of computing a single or the set of all minimal diagnoses, using two minimality
criteria, subset-minimality () and cardinality-minimality (). We assume as input a CNF
formula defined over a variable set V , of which  = |COMPS| are assumable (or fault)
variables. Table 1 introduces the notation that we use to define these 4 types of diagnosis.
Table 1: Summary of definitions of types of diagnosis of interest
Symbol

Diagnoses






1
1
all
all

Preference Criterion





(subset-minimality)
(cardinality-minimality)
(subset-minimality)
(cardinality-minimality)

The complexity of computing the set of all diagnoses is harder than computing a single
diagnosis, since the number of diagnoses is, in the worst case, exponential in the input size
(number of components). This problem is bounded from below by the problem of counting
the number of diagnoses. This problem has been shown to be #co-NP -Complete (Hermann
& Pichler, 2007).
If we restrict our clauses to be Horn or definite Horn, then we can reduce the complexity
of the problems that we are solving, at the expense of decreased model expressiveness. Under
a Horn-clause restriction, for SD  WFM, determining if a first minimal diagnosis exists
is in P . Under the same restriction, for SD  SFM, deciding if a first minimal diagnosis
exists is NP-hard (Friedrich et al., 1990). In both cases (SD  WFM, SFM) deciding if a
next diagnosis exists is NP-hard.
The diagnosis problems of interest in this article are intractable in the worst-case. The
complexity of a closely-related problem, Propositional Abduction Problems (PAPs), has
been studied by Eiter and Gottlob (1995). They show that for a propositional PAP, the
problem of determining if a solution exists is P2 -complete. Computing a minimal diagnosis
is a search problem, and hence it is more difficult to pose a decision question for proving
complexity results. Consequently, one can just note that computing a diagnosis minimal
with respect to  /  requires O(log |COMPS|) calls to an NP oracle (Eiter & Gottlob,
1995), asking the oracle at each step if a diagnosis containing at most k faulty components
exists.
Results on abduction problems indicate that the task of approximate diagnosis is intractable. Roth (1996) has addressed the problems of abductive inference, and of approximating such inference. Roth focuses on counting the number of satisfying assignments for
a range of AI problems, including some instances of PAPs. In addition, Roth shows that
approximating the number of satisfying assignments for these problems is intractable.
Abdelbar (2004) has studied the complexity of approximating Horn abduction problems,
showing that even for a particular Horn restriction of the propositional problem of interest,
the approximation problem is intractable. In particular, for an abduction problem with
costs assigned to the assumables (which can be used to model the preference-ordering ),
377

fiFeldman, Provan, & van Gemund

he has examined the complexity of finding the Least Cost Proof (LCP) for the evidence
(OBS), where the cost of a proof is taken to be the sum of the costs of all hypotheses that
must be assumed in order to complete the proof. For this problem he has shown that it is
NP -hard to approximate an LCP within a fixed ratio r of the cost of an optimal solution,
for any r < 0.
Safari approximates the intractable problems denoted in Table 1. We show that for
WFM, Safari can efficiently compute a single diagnosis that is minimal under  by using
a satisfiability oracle. For SD  SFM, Safari generates a sound but possibly sub-optimal
diagnosis (or set of diagnoses). We have referred to papers indicating that it is intractable
to approximate, within a fixed ratio, a minimal diagnosis. In the following, we adopt a
stochastic approach that cannot provide fixed-ratio guarantees. However, Safari trades off
optimality for efficiency and can compute most diagnoses with high likelihood.

3. Stochastic MBD Algorithm
In this section we discuss an algorithm for computing multiple-fault diagnoses using stochastic search.
3.1 A Simple Example (Continued)
Consider the Boolean subtractor shown in Fig. 1, its weak-fault model SDw given by (1),
and the observation 4 from the preceding section. The four minimal diagnoses associated
to SDw 4 are: 1 = h1 h2 h3 h4 h5 h6 h7 , 2 = h1 h2 h3 h4 h5 h6 h7 ,
3 = h1  h2  . . .  h6  h7 , and 4 = h1  h2  h3  . . .  h6  h7 .
A nave deterministic algorithm would check the consistency of all the 2|COMPS| possible health assignments for a diagnostic problem, 128 in the case of our running example.
Furthermore, most deterministic algorithms first enumerate health assignments of small
cardinality but with high a priori probability, which renders these algorithms impractical in
situations when the minimal diagnosis is of a higher cardinality. Such performance is not
surprising even when using state-of-the art MBD algorithms which utilize, for example conflict learning, or partial compilation, considering the bad worst-case complexity of finding
all minimal diagnoses (cf. Sec. 2.4).
In what follows, we will show a two-step diagnostic process that requires fewer consistency checks. The first step involves finding a random non-minimal diagnosis as a starting
point (cf. Sec. 3.2 for details on computing random SAT solutions with equal likelihood).
The second step attempts to minimize the fault cardinality of this diagnosis by repeated
modification of the diagnosis.
The first step is to find one random, possibly non-minimal diagnosis of SDw  4 . Such
a diagnosis we can obtain from a classical DPLL solver after modifying it in two ways: (1)
not only determine if the instance is satisfiable but also extract the satisfying solution and
(2) find a random satisfiable solution every time the solver is invoked. Both modifications
are trivial, as DPLL solvers typically store their current variable assignments and it is easy
to choose a variable and value randomly (according to a uniform distribution) instead of
deterministically when branching. The latter modification may possibly harm a DPLL
variable or value selection heuristics, but later in this paper we will see that this is of no
378

fiApproximate Model-Based Diagnosis Using Greedy Stochastic Search

concern for the type of problems we are considering as diagnostic systems are typically
underconstrained.
In the subtractor example we call the DPLL solver with SDw  4 as an input and we
consider the random solution (and obviously a diagnosis) 5 = h1  h2  h3  h4  h5 
h6  h7 (|5 | = 4). In the second step of our stochastic algorithm, we will try to minimize
5 by repetitively choosing a random negative literal, flipping its value to positive (thus
obtaining a candidate with a smaller number of faults), and calling the DPLL solver. If the
new candidate is a diagnosis, we will try to improve further this newly discovered diagnosis,
otherwise we will mark the attempt a failure and choose another negative literal. After
some constant number of failures (two in this example), we will terminate the search and
will store the best diagnosis discovered so far in the process.
After changing the sign of h7 in 5 we discover that the new health assignment is
not consistent with SDw  4 , hence it is not a diagnosis and we discard it. Instead,
the algorithm attempts changing h6 to h6 in 5 , this time successfully obtaining a new
diagnosis 6 = h1  h2  h3  h4  h5  h6  h7 of cardinality 3. Next the algorithm
tries to find a diagnosis of even smaller cardinality by randomly choosing h1 and h7 in
6 , respectively, and trying to change their sign, but both attempts return an inconsistency.
Hence the climb is aborted and 6 is stored as the current best diagnosis.
Repeating the process from another random initial DPLL solution, gives us a new diagnosis 7 = h1  h2  h3  h4  h5  h6  h7 . Changing the sign of h7 , again, leads
to inconsistency, but the next two flips (of h4 and h2 ) lead to a double-fault diagnosis
8 = h1  h2  . . .  h6  h7 . The diagnosis 8 can not be improved any further as it is
minimal. Hence the next two attempts to improve 8 fail and 8 is stored in the result.
This process is illustrated in Fig. 2, the search for 6 is on the left and for 8 on the right.
Gates which are shown in solid black are suspected as faulty when the health assignment
they participate in is tested for consistency, and inconsistent candidates are crossed-out.
Let us consider the result. We have found two diagnoses: 6 and 8 , where 6 is not
a minimal diagnosis. This we have done at the price of 11 calls to a DPLL subroutine.
The suboptimal diagnosis 6 is of value as its cardinality is near the one of a minimal
diagnosis. Hence we have demonstrated a way to find an approximation of all minimal
diagnoses, while drastically reducing the number of consistency checks in comparison to a
deterministic algorithm, sacrificing optimality. Next we will formalize our experience into
an algorithm, the behavior of which we will analyze extensively in the section that follows.
Diagnosing a strong-fault model is known to be strictly more difficult than a weak-fault
model (Friedrich et al., 1990). In many diagnostic instances this problem is alleviated by
the fact that there exist, although without a guarantee, continuities in the diagnostic search
space similar to the one in the weak-fault models. Let us discuss the process of finding a
minimal diagnosis of the subtractors strong-fault model SDs and the observation 2 (both
from Sec. 2.1).
The six distinct diagnoses 9 , . . . , 14 of SDs and 2 are shown in Fig. 3. Of these only
9 and 10 are minimal such that |9 | = |10 | = 3. It is visible in Fig. 3 that in all diagnoses
component variables h2 and h5 are false, while h1 and h7 are true (healthy). Hence, any
satisfying assignment of SDs  2 would contain h1  h2  h5  h7 . Starting from the
maximal-cardinality diagnosis 14 , we must flip the variables h3 , h4 , and h6 in order to
reach the two minimal diagnoses. The key insight is that, as shown in Fig. 3, this is always
379

fiFeldman, Provan, & van Gemund

Figure 2: An example of a stochastic diagnostic process
h2
9 
13 
14 
h2
9 
11 
14 

h5

h4

h6

h3

h1

h7

























h5

h4

h6

h3

h1

h7

























h2
10 
12 
14 
h2
10 
13 
14 

h5

h4

h6

h3

h1

h7

























h5

h4

h6

h3

h1

h7

























Figure 3: Diagnoses of a strong-fault model
possible by flipping a single literal at a time from health to faulty and receiving another
consistent assignment (diagnosis).
In what follows we will formalize our experience so far in a stochastic algorithm for
finding minimal diagnoses.
3.2 A Greedy Stochastic Algorithm
Algorithm 1 shows the pseudocode of Safari.
380

fiApproximate Model-Based Diagnosis Using Greedy Stochastic Search

Algorithm 1 Safari: A greedy stochastic hill climbing algorithm for approximating the
set of minimal diagnoses
1: function Safari(DS, , M, N ) returns a trie
inputs: DS = hSD, COMPS, OBSi, diagnostic system
, term, observation
M , integer, climb restart limit
N , integer, number of tries
local variables: SDcnf , CNF
m, n, integers
,   , terms
R, set of terms, result
2:
SDcnf  WffToCNF(SD)
3:
for n = 1, 2, . . . , N do
4:
  RandomDiagnosis(SDcnf , )
 Get a random SAT solution.
5:
m0
6:
while m < M do
7:
   ImproveDiagnosis()
 Flip an unflipped health variable.

8:
if SDcnf     6|= then
 Consistency check.
9:
  
10:
m0
11:
else
12:
mm+1
13:
end if
14:
end while
15:
unless IsSubsumed(R, ) then
16:
AddToTrie(R, )
17:
RemoveSubsumed(R, )
18:
end unless
19:
end for
20:
return R
21: end function

Safari accepts two input parameters: M and N . There are N independent searches
that start from randomly generated starting points. The algorithm tries to improve the
cardinality of the initial diagnoses (while preserving their consistency) by randomly flipping fault literals. The change of a sign of literal is done in one direction only: from faulty
to healthy. Each attempt to find a minimal diagnosis terminates after M unsuccessful attempts to improve the current diagnosis stored in . Thus, increasing M will lead to a
better exploration of the search space and, possibly, to diagnoses of lower cardinality, while
decreasing it will improve the overall speed of the algorithm.
Safari uses a number of utility functions. WffToCNF converts the propositional
formula in SD to CNF (cf. Sec 2.3). The ImproveDiagnosis subroutine takes a term  as
an argument and changes the sign of a random negative literal in . If there are no negative
literals, the function returns its original argument.
381

fiFeldman, Provan, & van Gemund

The implementation of RandomDiagnosis uses a modified DPLL solver returning a
random SAT solution of SD  . Consider the original DPLL algorithm (Davis, Logemann,
& Loveland, 1962) without the unit resolution rule. One can show that if, in the event
of branching, the algorithm chooses unassigned variables and their polarity with equal
probability, the DPLL algorithm is equally likely to compute any satisfiable solution (if such
exists). Note that the order in which variables are assigned does not matter. Of course,
the DPLL algorithm may end-up with a partial assignment, i.e., some of the variables are
dont care. This is not a problem because the partial assignment can be extended to
a full satisfiable assignment by randomly choosing the signs of the unassigned variables
from a uniform distribution. Taking into consideration the unit resolution rule, does not
change the likelihood of the modified DPLL solver finding a particular solution because it
only changes the order in which variables are assigned. A formal proof that this modified
DPLL solver computes a SAT assignment with equal probability is beyond the scope of this
paper, but the idea is to build a probabilistic model of the progress of the DPLL solver. This
probabilistic model is a balanced tree where nodes iterate between branching and performing
unit resolution (assigning values to zero or more unit clauses). As the branching probability
is set to be equal and all leaf nodes (SAT solutions) are at equal depth, one can show the
equal likelihood of arriving to any SAT solution. As most up-to-date SAT solvers are based
on DPLL, creating a randomized DPLL solver that computes any satisfiable solution with
equal probability is not difficult. Of course, random polarity decisions may effect negatively
branching heuristics (Marques-Silva, 1999) but such analysis is also beyond the scope of
this paper.
Similar to deterministic methods for MBD, Safari uses a SAT-based procedure for
checking the consistency of SD. To increase the implementation efficiency of Safari,
we combine a BCP-based LTMS engine (McAllester, 1990) and a full-fledged DPLL solver in
two-stage consistency checking. Experimentation shows that combining LTMS and DPLL
in such a way allows an order-of-magnitude Safari speed-up compared to pure DPLL, while
the soundness and completeness properties of consistency checking are preserved.
We have implemented the two-stage consistency checking as follows. First, Safari calls
a BCP-based LTMS (Forbus & de Kleer, 1993) to check if SD     |=. If the result
is UNSAT then the candidate  is not a diagnosis.4 If the LTMS result is not UNSAT, it
means that the consistency of the candidate is unknown and a call to a complete DPLL
engine is needed. For the full DPLL checking we use POSIT (Freeman, 1995) or MiniSat
(Een & Sorensson, 2003).
Safari benefits from the two-stage SAT procedure because a typical MBD instance
involves many consistency checks (O(|COMPS|2 ) for N = 1, M = |COMPS|). As SD  
does not change during the search and each time only a small number of assumption clauses
have to be updated, the incremental nature of LTMS greatly improves the search efficiency.
Even though the DPLL running time per instance is the same as LTMS (DPLL performs
BCP when doing unit propagation), DPLL construction is expensive and should be avoided
when possible. DPLL initialization is typically slow as it involves building data structures
for clauses and variables, counting literals, initializing conflict databases, etc. On the other
hand, our implementation of LTMS is both incremental (does not have to be reinitialized
4. It can be shown that if a BCP consistency check of SD     returns UNSAT, then the formula is
UNSAT (the opposite is not necessarily true).

382

fiApproximate Model-Based Diagnosis Using Greedy Stochastic Search

before each consistency check) and efficient as it maintains only counters for each clause.
Each counter keeps the number of unassigned literals. Assigning a value to a variable
requires decrementing some or all of the clause counters. If a counter becomes zero, a
contradiction handler is signaled.
There is no guarantee that two diagnostic searches, starting from random diagnoses,
would not lead to the same minimal diagnosis. To prevent this, we store the generated
diagnoses in a trie R (Forbus & de Kleer, 1993), from which it is straightforward to extract
the resulting diagnoses by recursively visiting its nodes. A diagnosis  is added to the trie R
by the function AddToTrie, iff no subsuming diagnosis is contained in R (the IsSubsumed
subroutine checks on that condition). After adding a diagnosis  to the resulting trie R, all
diagnoses contained in R and subsumed by  are removed by a call to RemoveSubsumed.
3.3 Basic Properties of the Greedy Stochastic Search
Before we continue with the topics of completeness and optimality, we show that Safari is
sound, i.e., it returns diagnoses only.
Lemma 2 (Soundness). Safari is sound.
Proof (Sketch). The consistency check in line 8 of Alg. 1 guarantees that only terms  for
which it holds that SD     6|= will be added to the result set R. According to Def. 5
these terms  are diagnoses.
One of the key factors in the success of the proposed algorithm is the exploitation of the
continuity of the search-space of diagnosis models, where by continuity we mean that we
can monotonically reduce the cardinality of a non-minimal diagnosis. Through the exploitation of this continuity property, Safari can be configured to guarantee finding a minimal
diagnosis in weak fault models in a polynomial number of calls to a satisfiability oracle.
The hypothesis which comes next is well studied in prior work (de Kleer et al., 1992),
as it determines the conditions under which minimal diagnoses represent all diagnoses of a
model and an observation. This paper is interested in the hypothesis from the computational
viewpoint: it defines a class of models for which it is possible to establish a theoretical bound
on the optimality and performance of Safari.
Hypothesis 1 (Minimal Diagnosis Hypothesis). Let DS = hSD, COMPS, OBSi be a diagnostic system and   a diagnosis for an arbitrary observation . The Minimal Diagnosis Hypothesis (MDH) holds in DS iff for any health assignment  such that Lit  ()  Lit  (  ),
 is also a diagnosis.
It is easy to show that MDH holds for all weak-fault models. There are other theories
SD 6 WFM for which MDH holds (e.g., one can directly construct a theory as a conjunction
of terms for which MDH holds). Unfortunately, no necessary condition is known for MDH
to hold in an arbitrary SD. The lemma which comes next is a direct consequence of MDH
and weak-fault models.
Lemma 3. Given a diagnostic system DS = hSD, COMPS, OBSi, SD  WFM, and a
diagnosis  for some observation , it follows that  is non-minimal iff another diagnosis
  can be obtained by changing the sign of exactly one negative literal in .
383

fiFeldman, Provan, & van Gemund

Proof (Sketch). From Def. 2 and SD  WFM, it follows that if  is a minimal diagnosis,
any diagnosis   obtained by flipping one positive literal in  is also a diagnosis. Applying
the argument in the other direction gives us the above statement.
Safari operates by performing subset flips on non-minimal diagnoses, attempting to compute minimal diagnoses. We next formalize this notion of flips, in order to characterize
when Safari will be able to compute a minimal diagnosis.
Definition 11 (Subset Flip  ). Given a diagnostic system DS = hSD, COMPS, OBSi and
a health assignment  with a non-empty set of negative literals (Lit  () 6= ), a subset
flip  turns one of the negative literals in  to a positive literal, i.e., it creates a health
assignment   with one more positive literal.
We next characterize flips based on whether they produce consistent models after the flip.
Definition 12 (Valid Subset Flip). Given a diagnostic system DS = hSD, COMPS, OBSi,
an observation , and a non-minimal diagnosis , a valid flip exists if we can perform a
subset flip in  to create   such that SD      6|=.
Given these notions, we can define continuity of the diagnosis search space in terms of literal
flipping.
Definition 13 (Continuity). A system model SD and an observation  satisfy the continuity
property with respect to the set of diagnoses  (SD), iff for any diagnosis k  (SD)
there exists a sequence  = h1 , 2 ,    , k1 , k , k+1 ,    , n i, such that for i =
1, 2,    , n  1, it is possible to go from i to i+1 via a valid subset flip, i  (SD  ),
and n   (SD  ).
The above definition allows for trivial continuity in the cases when a model and an observation lead to minimal diagnoses only (no non-minimal diagnoses). As we will see in Sec. 6,
models and observations such that all diagnoses are minimal are rare in practice (of course,
such problems can be created artificially). Note that the Safari algorithm still works and
its theoretical properties are preserved even in the case of trivial continuity.
Given Def. 13, we can easily show the following two lemmata:
Lemma 4. If SD satisfies MDH, then it satisfies the continuity property.
Proof. Follows directly from Hypothesis 1 and Def 13.
Lemma 5. SD  WFM satisfies the continuity property.
Proof (Sketch). It is straightforward to show that if SD  WFM then SD satisfies MDH.
Then from Lemma 4 it follows that SD satisfies the continuous property.
Our greedy algorithm starts with an initial diagnosis and then randomly flips faulty assumable variables. We now use the MDH property to show that, starting with a non-minimal
diagnosis , the greedy stochastic diagnosis algorithm can monotonically reduce the size of
the seed diagnosis to obtain a minimal diagnosis through appropriately flipping a fault
variable from faulty to healthy; if we view this flipping as search, then this search is continuous in the diagnosis space.
384

fiApproximate Model-Based Diagnosis Using Greedy Stochastic Search

Proposition 1. Given a diagnostic system DS = hSD, COMPS, OBSi, an observation ,
and SD  WFM, Safari configured with M = |COMPS| and N = 1 returns one minimal
diagnosis.
Proof. The diagnosis improvement loop starts, in the worst case, from a health assignment
 which is a conjunction of negative literals only. Necessarily, in this case,  is a diagnosis
as SD  WFM. A diagnosis   that is subsumed by  would be found with at most M
consistency checks (provided that   exists) as M is set to be equal to the number of literals
in  and there are no repetitions in randomly choosing of which literal to flip next. If, after
trying all the negative literals in , there is no diagnosis, then from Lemma 3 it follows that
 is a minimal diagnosis.
Through a simple inductive argument, we can continue this process until we obtain a
minimal diagnosis.
From Proposition 1 it follows that there is an upper bound of O(|COMPS|) consistency
checks for finding a single minimal diagnosis. In most of the practical cases, however, we
are interested in finding an approximation to all minimal-cardinality diagnoses. As a result
the complexity of the optimally configured Safari algorithm becomes O(|COMPS|2 S),
where S is the number of minimal-cardinality diagnoses for the given observation. Section 5
discusses in more detail the computation of multiple minimal-cardinality diagnoses.
The number of assumable variables in a system of practical significance may exceed
thousands, rendering an optimally configured Safari computationally too expensive. In
Sec 4 we will see that while it is more computationally efficient to configure M < |COMPS|,
it is still possible to find a minimal diagnosis with high probability.
It is simple to show that flip-based search algorithms are complete for continuous diagnosis search spaces given weak fault models, i.e., SD  WFM, and models that follow
MDH, i.e., Lemma 3. We can formally characterize the guarantee of finding a minimal diagnosis with Safari in terms of a continuous diagnosis space. Note that this is a sufficient,
but not necessary, condition; for example, we may configure Safari to flip multiple literals
at a time to circumvent problems of getting trapped in discontinuous diagnosis spaces.
Theorem 1. Given a diagnostic system DS = hSD, COMPS, OBSi, and a starting diagnosis
, Safari configured with M = |COMPS| and N = 1 is guaranteed to compute a minimal
diagnosis if the diagnosis space is continuous.
Proof. Given an initial diagnosis , Safari attempts to compute a minimal diagnosis by
performing subset flips. If the diagnosis space is continuous, then we know that there exists
a sequence of valid flips leading to a minimal diagnosis. Hence Safari is guaranteed to find
a minimal diagnosis from .
Finally, we show that Safari provides a strong probabilistic guarantee of computing all
minimal diagnoses.
Theorem 2. The probability of Safari, configured with M = |COMPS|, of computing all
minimal diagnoses of a diagnostic system DS = hSD, COMPS, OBSi and an observation 
is denoted as Pr . Given a continuous diagnosis space (SD, ), it holds that Pr  1 for
N  .
385

fiFeldman, Provan, & van Gemund

Proof (Sketch). Since (1) the search space is continuous, (2) at each step there is a non-zero
probability of flipping any unflipped literal, and (3) there is a polynomial upper bound of
steps (|COMPS|) for computing a diagnosis, Safari can compute any non-minimal diagnosis
with non-zero probability. Hence as N  , Safari will compute all minimal diagnoses.

3.4 Complexity of Inference Using Greedy Stochastic Search
We next look at the complexity of Safari, and its stochastic approach to computing sound
but incomplete diagnoses. We show that the primary determinant of the inference complexity is the consistency checking. Safari randomly computes a partial assignment , and
then checks if  can be extended to create a satisfying assignment during each consistency
check, i.e., it checks the consistency of  with SD. This is solving the satisfiability problem (SAT), which is NP-complete (Cook, 1971). We will show how we can use incomplete
satisfiability checking to reduce this complexity, at the cost of completeness guarantees.
In the following, we call  the complexity of a consistency check, and assume that there
are  components that can fail, i.e.,  = |COMPS|.
Lemma 6. Given a diagnostic system DS = hSD, COMPS, OBSi with SD  WFM, the
worst-case complexity of finding any minimal diagnosis is O( 2 ), where  is the cost of a
consistency check.
Proof. There is an upper bound of  succeeding consistency checks for finding a single
minimal diagnosis since there is a maximum of  steps for computing the all healthy
diagnosis. As Safari performs a consistency check after each flip and at each step the
algorithm must flip at most  literals, the total complexity is O( 2 ).
In most practical cases, however, we are interested in finding an approximation to all minimal-cardinality diagnoses.
As 
a result the complexity of the optimally configured Safari


||
algorithm becomes O    , where || is the cardinality of the minimal-cardinality
diagnoses for the given observation (cf. Sec. 6.6).
The complexity of BCP is well-known, allowing us to get more precise bounds on the
worst-case complexity of computing one minimal-diagnosis with Safari. In what follows
we will assume that SD is represented in CNF (cf. Sec. 2.3).
Lemma 7. Given a diagnostic system DS = hSD, COMPS, OBSi, SD  WFM, and SD
having c clauses and n variables, the worst-case complexity under WFM of finding any
minimal diagnosis is O( 2 cn) when using BCP for consistency checks.5
Proof (Sketch). An implementation of BCP (Forbus & de Kleer, 1993) maintains a total of
c counters for the number of unsatisfied literals in each clause. A consistency check requires
decrementing some or all counters for each of the n variables in SD. This gives us an upper
bound of O(cn) on the execution time of BCP. Combining the complexity of BCP with
Lemma 6 gives us the desired result.
5. More efficient implementations of BCP exist (Zhang & Stickel, 1996).

386

fiApproximate Model-Based Diagnosis Using Greedy Stochastic Search

4. Optimality Analysis (Single Diagnosis)
In contrast to deterministic algorithms, in the Safari algorithm there is no absolute guarantee that the optimum solution (minimal diagnosis) is found. Below we will provide an
intuition behind the performance of the Safari algorithm by means of an approximate,
analytical model that estimates the probability of reaching a diagnostic solution of specific
minimality.
4.1 Optimality of Safari in Weak-Fault Models
We will start by considering a single run of the algorithm without retries where we will
assume the existence of only one minimal diagnosis. Next, we will extend the model by
considering retries.
4.1.1 Basic Model
Consider a diagnostic system DS = hSD, COMPS, OBSi such that SD  WFM, and an
observation  such that  manifests only one minimal diagnosis . For the argument that
follows we will configure Safari with M = 1, N = 1, and we will assume that the starting
solution is the trivial all faulty diagnosis.
When Safari randomly chooses a faulty variable and flips it, we will be saying that it
is a success if the new candidate is a diagnosis, and a failure otherwise. Let k denote the
number of steps that the algorithm successfully traverses in the direction of the minimal
diagnosis of cardinality ||. Thus k also measures the number of variables whose values are
flipped from faulty to healthy in the process of climbing.
Let f (k) denote the probability distribution function (pdf) of k. In the following we
derive the probability p(k) of successfully making a transition from k to k + 1. A diagnosis
at step k has k positive literals and |COMPS|  k negative literals. The probability of the
next variable flip being successful equals the probability that the next negative to positive
flip out of the H  k negative literals does not conflict with a negative literal belonging to
a diagnosis solution . Consequently, of the ||  k literals only COMPS|  ||  k literals
are allowed to flip, and therefore the success probability equals:
p (k) =

||
|COMPS|  ||  k
=1
|COMPS|  k
|COMPS|  k

(3)

The search process can be modeled in terms of the Markov chain depicted in Fig. 4, where
k equals the state of the algorithm. Running into an inconsistency is modeled by the
transitions to the state denoted fail.
The probability of exactly attaining step k (and subsequently failing) is given by:
f (k) = (1  p(k + 1))

k
Y

p(i)

(4)

i=0

Substituting (3) in (4) gives us the pdf of k:

k 
Y
||
||
1
f (k) =
|COMPS|  k + 1
|COMPS|  i
i=0

387

(5)

fiFeldman, Provan, & van Gemund

k=0

1  p(0)

p(0)

k=1

1  p(1)

p(1)

k=2

1  p(2)

p(i)

k=i

p(n  1)

1  p(i + 1)

k=n

1

fail

Figure 4: Model of a Safari run for M = 1 and a single diagnosis  (n = |COMPS|  ||)

At the optimum goal state k = |COMPS|  || the failure probability term in (5) is correct
as it equals unity.
If p were independent of k, f would be geometrically distributed, which implies that the
chance of reaching a goal state k = |COMPS||| is slim. However, the fact that p decreases
with k moves the probability mass to the tail of the distribution, which works in favor of
reaching higher-k solutions. For instance, for single-fault solutions (|| = 1) the distribution
becomes uniform. Figure 5 shows the pdf for problem instances with |COMPS| = 100 for
an increasing fault cardinality ||. In order to decrease sampling noise, the empirical f (k)
values in Fig. 5 are computed by taking the average over 10 samples of k.
0.1

0.1
|| = 1
|| = 5
|| = 10

0.08

|| = 1
|| = 5
|| = 10

0.08

f(k)

0.06

f(k)

0.06
0.04

0.04

0.02

0.02

0

0

20

40

60

80

100

k

0

0

20

40

60

80

100

k

Figure 5: Empirical (left) and analytic (right) f (k) for no retries and a single diagnosis
In the next section we show that retries will further move probability mass towards the
optimum, increasing the tail of the distribution, which is needed for (almost always) reaching
optimality.
4.1.2 Modeling Retries
In this section we extend the model to account for retries, which has a profound effect on
the resulting pdf of f . Again, consider the transition between step k and k + 1, where the
algorithm can spend up to m = 1, . . . , M retries before exiting with failure. As can be
388

fiApproximate Model-Based Diagnosis Using Greedy Stochastic Search

seen by the algorithm (cf. Alg. 1), when a variable flip produces an inconsistency a retry is
executed while m is incremented.
From elementary combinatorics we can compute the probability of having a diagnosis
after flipping any of M different negative literals at step k. Similar to (3), at stage k there
are |COMPS|  k faulty literals from which M are chosen (as variable flips leading to
inconsistency are recorded and not attempted again, there is no difference between choosing
the M variables in advance or one after another). The probability of advancing from stage
k to stage k + 1 becomes:
||
p (k) = 1 

M
|COMPS|k
M

(6)

The progress of Safari can be modeled for values of M > 1 as a Markov chain, similar to
the one shown in Fig. 4 with the transition probability of p replaced by p . The resulting
pdf of the number of successful steps becomes:
#
"
k
||
||
Y

M
M
(7)
1  |COMPS|i
f (k) = |COMPS|k+1
M

i=0

M

It can be seen that (5) is a restricted case of (7) for M = 1.
The retry effect on the shape of the pdf is profound. Whereas for single-fault solutions
the shape for M = 0 is uniform, for M = 1 most of the probability mass is already located
at the optimum k = |COMPS|  ||. Fig. 6 plots f for a number of problem instances with
increasing M . As expected, the effect of M is extremely significant. Note that in case of
the real system, for M = |COMPS| the pdf would consist of a single, unit probability spike
at |COMPS|  ||.
Although we were unable to find an analytic treatment of the transition model above, the
graphs immediately show that for large M the probability of moving to k = |COMPS|  ||
is very large. Hence, we expect the pdf to have a considerable probability mass located at
k = |COMPS|  ||, depending on M relative to |COMPS|.
4.2 Optimality of Safari in Strong-Fault Models
From the above analysis we have seen that in WFM it is easy, starting from a non-minimal
diagnosis, to reach a subset minimal diagnosis. As will be discussed in more detail below,
this is not necessarily the case for strong-fault models. In many practical cases, however,
strong-fault models exhibit, at least partially, behavior similar to MDH, thus allowing greedy
algorithms like Safari to achieve results that are close to the optimal values.
4.2.1 Partial Continuity in Strong-Fault Stuck-At Models
In what follows we will restrict our attention to a large subclass of SFM, called SFSM
(Struss & Dressler, 1992).
Definition 14 (Strong-Fault Stuck-At Model). A system DS = hSD, COMPS, OBSi belongs to the class SFSM iff SD is equivalent to (h1  F1 )  (h1  l1 )      (hn 
Fn )  (hn  ln ) such that 1  i, j  n, {hi }  COMPS, Fj is a propositional formula,
none of hi appears in Fj , and lj is a positive or negative literal in Fj .
389

fiFeldman, Provan, & van Gemund

M=2

M=2

0.04

0.04
|| = 5
|| = 10

0.03
f(k)

f(k)

0.03

0.02

0.01

0

|| = 5
|| = 10

0.02

0.01

0

20

40

60

80

0

100

0

20

40

k
M=4

100

60

80

100

0.12
|| = 5
|| = 10

0.1

|| = 5
|| = 10

0.1
0.08
f(k)

0.08
f(k)

80

M=4

0.12

0.06

0.06

0.04

0.04

0.02

0.02

0

60
k

0

20

40

60

80

100

k

0

0

20

40
k

Figure 6: Empirical (left) and analytic (right) f  (k) for multiple retries and a single diagnosis

MDH (cf. Hypothesis 1) does not hold for SFSM models. Consider an adder whose inputs
and outputs are all zeroes, and whose gate models are all stuck-at-1 when faulty. In this
case, the all nominal assignment is a diagnosis, but, for example, a stuck-at-1 output gate
is not a diagnosis (there is a contradiction with the zero output).
Many practical observations involving SFSM models, however, lead to partial continuity. This means that there are groups of diagnoses that differ in at most one literal, i.e., a
flip based search can improve the cardinality of a diagnosis. We next formalize this notion.
Definition 15 (Partial Continuity). A system model SD and an observation  satisfy the
partial continuity property with respect to a set S  (SD  ), iff for every diagnosis 
such that i  S satisfying Lit  () \ Lit  (i ) there exists a finite sequence of valid subset
flips from i to .
At one extreme of the spectrum, SD and  satisfy the partial continuity property with
respect to the set of all of its diagnoses while at the other extreme, the partial continuity
390

fiApproximate Model-Based Diagnosis Using Greedy Stochastic Search

property is satisfied with respect to a singleton S (consider, for example, SD  WFM
where S consists of the single all faulty diagnosis).
Note that the continuous property is trivally satisfied with respect to any diagnosis
k  (SD  ), i.e., there always exists a sequence containing k only ( = hk i). We are
only interested in the non-trivial cases, for which || > 1.
Consider a system SD and an observation  that satisfy the partial continuity property
with respect to some diagnosis k . We say that the diagnoses in the flip sequence  that
contains k form a continuous subspace. Alternatively, given a diagnostic system SD and an
observation , a continuous diagnostic subspace of SD is a set of diagnoses   (SD)
with the property that, for any diagnosis   , there is another diagnosis    such that
|Lit  ()|  |Lit  ()| = 1.
Unfortunately, in the general SFSM case, we cannot derive bounds for the sizes of the
continuous subspaces, and hence, for the optimality of Safari. In what follows, and with
the help of a few examples, we illustrate the fact that partial continuity depends on the
model and the observation and then we express the optimality of Safari as a function of this
topologically-dependent property. Later, in Sec. 6, we collect empirical data that continuous
subspaces leading to near-optimal diagnoses exist for a class of benchmark SFSM circuits.
Our first example illustrates the notion of discontinuity (lack of partial continuity with
respect to any diagnoses). We show a rare example of a model and and an observation
leading to a set of diagnoses that contains diagnoses of cardinality m and m + q (q > 1),
but has no diagnoses of cardinality m + 1, m + 2,    , m + q  1.
A Discontinuity Example Consider, for example, the Boolean circuit shown in Fig. 7
and modeled by the propositional formula:

[h1  (y  x)]  [h1  (y  x)]
(8)
SDd =
[h2  (y  x)]  [h2  (y  x)]
and an observation d = x  y. Note, that SDd 6 SFSM. There are exactly two diagnoses
of SDd  d : 15 = h1  h2 and 16 = h1  h2 . Note that this model cannot have single
faults. As only 15 is minimal, |15 | = 0, and |16 | = 2, if the algorithm starts from 16 it
is not possible to reach the minimal diagnosis 15 by performing single flips. Similarly we
can construct models which impose an arbitrarily bad bound on the optimality of Safari.
Such models, however, are not common and we will see that the greedy algorithm performs
well on a wide class of strong-fault models.
h1
x

y
h2

Figure 7: A two inverters circuit
Obviously, continuity in the distribution of the cardinalities in a set of diagnoses is a necessary (but not sufficient) condition for Safari to progress. Such models impose arbitrary
difficulty to Safari, leading to suboptimal diagnoses of any cardinality.
391

fiFeldman, Provan, & van Gemund

An Example of Partial Continuity We continue the running example started in Sec. 2.
First, we create a system description SDsa for a SFSM model. Let SDsa = SDw  SDf ,
where SDw is given by (1). The second part of SDsa , the strong fault description SDf ,
specifies that the output of a faulty gate must be stuck-at-1:
SDf = (h1  i)  (h2  d)  (h3  j)  (h4  m) 
 (h5  b)  (h6  l)  (h7  k)

(9)

It is clear that SDsa  SFSM. We next compute the diagnoses of SDsa  1 (1 = x  y 
p  b d). There is one minimal diagnosis of SDsa  1 and it is 5 = h1  h2  h3     h7
(cf. Fig. 8). If we choose the two literals h3 and h4 from 5 and change the signs of h3
and h4 , we create two new health assignments: 15 = h1  h2  h3  h4  h5  h6  h7
and 16 = h1  h2  h3  h4  h5  h6  h7 . It can be checked that both 15 and 16 are
diagnoses, i.e., SDsa  1  15 6|= and SDsa  1  16 6|=. Note that 15 and 16 are
diagnoses of the weak-part of the model, i.e., {15 , 16 }  (SDw  1 ). This follows from
MDH and the fact that 5 is a minimal diagnosis of SDw  1 . Furthermore, 15 is also a
diagnosis in the strong-fault stuck-at model (15  (SDsa  1 )) because SDw  1  h3
does not lead to a contradictory value for j in the strong-fault part SDf . A similar argument
applies to 16 : SDw  1  h4 does not contradict m in SDf . Equivalently, if negating h3
in 5 , which makes j stuck-at-1, results in a diagnosis, and negating h4 in 5 , which makes
m stuck-at-1, also results in a diagnosis, negating both h3 and h4 in 5 will also result in
a diagnosis (consider the fact that the fault mode of h4 sets m only, but does not impose
constraints on j). The above argument can be extended similarly to h5 , h6 , and h7 . Hence,
any assignment of COMPS containing h1  h2 is a diagnosis of SDsa  1 , no matter what
combination of signs we take for h3 , h4 , h5 , h6 , and h7 . Note that a health assignment
containing h4 is a diagnosis conditioned on k = 1.
x=1
y=1
p=1

h2

d=0

h6

h1
i=1

l=0
h4

h3

m=0

j=1

h5

b=1

h7
k=1

Figure 8: Continuous subspace in a strong-fault, stuck-at-1 model of a subtractor
Consider an alternative way of computing a set of ambiguous diagnoses of SDsa  1 . Given
SDsa 1 5 , we can compute a consistent assignment to all internal variables (for example
by propagation). There is exactly one such assignment  and it is  = i  j  k  l  m,
SDsa  1  5   6|= (cf. Fig. 8). Note that for components h1 , h3 , h5 , and h7 , a
change in the state of a component (healthy or faulty) does not lead to a different output
value. For example the output j of the h3 or-gate is 1 because the gate is healthy and its
392

fiApproximate Model-Based Diagnosis Using Greedy Stochastic Search

inputs are 1 but j would also be 1 for a stuck-at-1 or-gate (h3 ). As a result, no diagnostic
reasoner can determine if the components in the dashed region of Fig. 8 are healthy or faulty
(stuck-at-1). Equivalently, one can change the signs of h3 , h5 , and h7 in the diagnosis 5
and the resulting assignments are still diagnoses. We call the set of components modeled
by h1 , h3 , h5 , and h7 an ambiguity group. Clearly, Safari can start from a diagnosis
17 = h1  h2  h3  h4  h5  h6  h7 (|17 | = 4) and reach 5 (|5 | = 1) by
performing valid subset flips.
To make our reasoning precise, we restrict the class of SFSM models to exclude malformed circuits such as ones having disconnected inputs or outputs, etc. Furthermore, we
assume that each component has exactly one output (the set of all component output variables is denoted as COUT). The latter is not a big restriction as multi-output component
models can be replaced by multiple components, each having a single output.6
Definition 16 (Well-Formed Diagnostic System (Wfds)). The diagnostic system DS =
hSD, COMPS, OBSi is well-formed (DS  Wfds) iff for any observation  and for any
diagnosis   (SD  ), there is exactly one assignment  to all component outputs
COUT such that SD       6|=.
Consider an SFSM model SD = (h1  F1 )  (h1  l1 )      (hn  Fn )  (hn  ln ).
We denote as COMPS the set of those hi (1  i  n) for which the respective li literals are
negative (cf. Def. 14), i.e., COMPS is the set of components whose failure modes are stuckat-0. Similarly, we use COMPS+ for the set of component variables whose stuck-at li literals
are positive (COMPS  COMPS+ = COMPS, COMPS  COMPS+ = ). In a Wfds,
an observation  and a diagnosis  force the output of each component either to a negative
or to a positive value. We denote the set of health variables whose respective component
outputs are forced to negative values as G (DS, , ). Similarly, we have G+ (DS, , ) for
the components whose outputs have positive values. With all this we can define the notion
of a component ambiguity group.
Definition 17 (Component Ambiguity Group). Given a system DS = hSD, COMPS, OBSi,
SD  SFSM, SD  Wfds, an observation , and a diagnosis   (SD), the component
ambiguity group U(DS, , ), U  COMPS, is defined as U(DS, , ) = {G (DS, , ) 
COMPS }  {G+ (DS, , )  COMPS+ }.
Finally, we show that a component ambiguity group leads to a continuous subspace. In
the general case we cannot say much about the size of the component ambiguity groups.
From experimentation, we have noticed that it is difficult to assign the inputs of an SFSM
to values that generate small continuous subspaces (either SD   |=, or SD   leads
to large component ambiguity groups). Of course, it is possible to consider an adder, or a
multiplier, for example, whose inputs are all zeroes and whose gate models are all stuck-at-1
when faulty, but the number of such inputs/circuit combinations is small.
Proposition 2. A diagnostic system SD, SD  SFSM, SD  Wfds, and an observation
 entail continuous diagnostic subspaces.
6. Any multi-output Boolean function can be replaced by a composition of single-output Boolean functions.

393

fiFeldman, Provan, & van Gemund

Proof. From Def. 16 and the fact that SD  Wfds it follows that the output values of a
subset of the components have the same sign as the models stuck-at value. We denote this
set as COMPS , COMPS  COMPS. Any health assignment  that differs only in signs
of components belonging to COMPS is also a diagnosis. If the set of diagnoses of SD  
contains all possible assignments to the assumables in COMPS then those diagnoses form
a continuous space (cf. Def. 17).
To best illustrate Proposition 2, consider the or-gate modeled by h3 in Fig. 8. Its output is
1 either because the gate is healthy and one of the gates inputs is 1, or because the gate is
stuck-at-1. In this situation, it is not possible to determine if the component is healthy or
faulty.
Clearly, |U(DS, , )| is a lower bound for the progress of Safari in stuck-at models.
It can be shown that if Safari starts from a diagnosis  of maximum cardinality for the
given subspace, Safari is guaranteed (for M = |COMPS|) to improve the cardinality of
 by at least |U(DS, , )|. In practice, Safari can proceed even further as the stuckat ambiguity groups are only one factor of diagnostic uncertainty. A stuck-at component
effectively disconnects inputs from outputs, hence gates from the fan-in region are not
constrained. For instance, continuing our example, for h5 , all predecessors in the cone of
h5 (components h3 , h4 , h5 , h6 , and h7 ) constitute a continuous health subspace.
Contrary to a component ambiguity group, this set is conditional on the health state of
another component. A thorough study of stuck-at continuity is outside the scope of this
paper but as we shall see in Sec. 6, continuous subspaces justify Safari experiments on
stuck-at models.
4.2.2 Performance Modeling with Stuck-At Models
To further study the optimality of Safari in strong-fault models, we first define a case
in which the algorithm cannot improve a non-minimal diagnosis by changing the sign of a
faulty literal. Note that the existence of such cases is not a sufficient condition for Safari
to be suboptimal, as it is possible to reach a minimal diagnosis by first changing the sign
of some other faulty literal, thus circumventing the missing diagnosis.
From the preceding section we know that the number of invalid flips does not depend
on k, i.e., it is determined by the observation vector and the fault modes. The probability
of Safari to progress from any non-minimal diagnosis becomes
p(k) = 1 

||+|X|
M
|COMPS|k
M

(10)

where |X| is the number of invalid flips. The ratio of the number of invalid flips |X| to
|COMPS| we will call SFM density d. The density d gives the average probability of trying
an invalid flip throughout the diagnostic search. An approximation of the probability of
success of Safari is:
p(k) = 1 

||
M
|COMPS|k
M

394

d

(11)

fiApproximate Model-Based Diagnosis Using Greedy Stochastic Search

Plugging p into (4) allows us to predict f (k) for the SFM models for which our assumptions
hold. This pdf, both measured from an implementation of Safari and generated from (4)
and (11) is shown in Fig. 9 for different values of the density d.
M = 4, |COMPS| = 100, || = 10

M = 4, |COMPS| = 100, || = 10

0.12

0.12
d=0
d = 0.1
d = 0.25
d = 0.5

0.1

0.08
f(k)

f(k)

0.08
0.06

0.06

0.04

0.04

0.02

0.02

0

0

20

40

60

d=0
d = 0.1
d = 0.25
d = 0.5

0.1

80

100

k

0

0

20

40

60

80

100

k

Figure 9: Empirical (left) and analytic (right) f  (k) for various diagnostic densities, multiple
retries and a single diagnosis

From Fig. 9 it is visible that increasing the density d leads to a shift of the probability
density of the length of the walk k to the left. The effect, however, is not that profound
even for large values of d, and is easily compensated by increasing M , as discussed in the
preceding sections.
It is interesting to note that bounds on d can be computed from SD (independent of ),
and these bounds can be used to further improve the performance of Safari.
4.3 Validation
In the preceding sections we have illustrated the progress of Safari with synthetic circuits
exposing specific behavior (diagnoses). In the remainder of this section we will plot the pdf
of the greedy search on one of the small benchmark circuits (for more information on the
74181 model cf. Sec. 6).
The progress of Safari with a weak-fault model of the 74181 circuit is shown in Fig. 10.
We have chosen a difficult observation leading to a minimal diagnosis of cardinality 7 (left)
and an easy observation leading to a single fault diagnosis (right). Both plots show that
the probability mass shifts to the right when increasing M and the effect is more profound
for the smaller cardinality.
The effect of the stuck-at-0 and stuck-at-1 fault modes (SFM) on the probability of
success of Safari is shown in Fig. 11.
Obviously, in this case the effect of increasing M is smaller, although still depending
on the difficulty of the observation vector. Last, even for small values of M , the absolute
probability of Safari finding a minimal diagnosis is sizeable, allowing the use of Safari
395

fiFeldman, Provan, & van Gemund

74181, || = 7

74181, || = 1

0.5

0.5
M=1

M=1

M=2

0.4

M=2

0.4

M=3
0.3

M=3
0.3

0.2

0.2

0.1

0.1

0

0

10

20

M=4

f(k)

f(k)

M=4

30
k

40

50

0
30

60

40

50
k

60

70

Figure 10: Empirical f  (k) for a weak-fault model of the 74181 circuit with observations
leading to two different minimal-cardinality diagnoses and various M

74181, || = 6, S-A-0

74181, || = 6, S-A-1

0.2

0.2
M=1

0.15

M=4
0.1

0.05

0
20

M=2

0.15

M=3
f(k)

f(k)

M=1

M=2

M=3
M=4

0.1

0.05

30

40
k

50

60

0
10

20

30

40

50

60

k

Figure 11: Empirical f  (k) for stuck-at-0 and stuck-at-1 strong-fault models of the 74181
circuit with various M

as a practical anytime algorithm which always returns a diagnosis, the optimality of which
depends on the time allocated to its computation.

5. Optimality Analysis (Multiple Diagnoses)
The preceding section described the process of computing one diagnosis with Safari (N =
1). In this section we discuss the use of Safari in computing (or counting) all minimalcardinality diagnoses (N > 1). For the rest of the section we will assume that Safari is
configured with M = |COMPS|.
396

fiApproximate Model-Based Diagnosis Using Greedy Stochastic Search

Consider a system description SD (SD  WFM) and an observation . The number
of minimal diagnoses | (SD  )| can be exponential in |COMPS|. Furthermore, in practice, diagnosticians are interested in sampling from the set of minimal-cardinality diagnoses
 (SD  ) (recall that  (SD  )   (SD  )) as the minimal-cardinality diagnoses
cover a significant part of the a posteriori diagnosis probability space (de Kleer, 1990). In
what follows, we will see that Safari is very well suited for that task.
Theorem 3. The probability of Safari configured with M = |COMPS| computing a minimal diagnosis of cardinality || in a system with |COMPS| component variables approaches
|COMPS||| for |COMPS|/||  .
Proof (Sketch). Assume a minimal diagnosis of cardinality || exists. From Proposition 1
it follows that Safari configured with M = |COMPS| is guaranteed to compute minimal
diagnoses. Starting from the all faulty assignment, consider a step k in improving the
diagnosis cardinality. If state k contains more than one diagnosis, then at state k+1, Safari
will either (1) flip a literal belonging to this diagnosis (note that a literal may belong to
more than one diagnosis) and subsequently prevent Safari from reaching this diagnosis or
(2) flip a literal belonging to a diagnosis which has already been invalidated (i.e., one or
more of its literals have been flipped at an earlier step).
The probability that a solution of cardinality || survives a flip at iteration k (i.e., is
not invalidated) is:
p (k) = 1 

|COMPS|  ||  k
||
=
|COMPS|  k
|COMPS|  k

(12)

Similarly to our basic model (Sec. 4.1.1), the probability that a diagnosis  survives until
it is returned by the algorithm:
|COMPS|||1

Y

f (|COMPS|  ||  1) =

|COMPS|||1

p(i) =

i=0

Y
i=0

|COMPS|  ||  i
|COMPS|  i

(13)

Rewriting the right hand side of Eq. (13) gives us:
f (|COMPS|  ||  1) =

(|COMPS|  ||)!
||!(|COMPS|  ||)!
=
(|| + 1)(|| + 2)    |COMPS|
|COMPS|!

(14)

Since
1
(|COMPS|  ||)!
=
|COMPS|!
(|COMPS|  || + 1)(|COMPS|  || + 2)    |COMPS|

(15)

it holds that
(|COMPS|  ||)!
= |COMPS|||
|COMPS|!
|COMPS|/||
lim

(16)

As a result, for small || relative to |COMPS|,
f (|COMPS|  ||  1) = ||!|COMPS|||
which gives us the above theorem.
397

(17)

fiFeldman, Provan, & van Gemund

The distribution hi (||) of the cardinalities of the minimal diagnoses in  (SD ) depends
on the topology of SD and on ; i.e., we can create SD and  having any hi (||). We denote
the cardinality distribution of the minimal diagnoses computed by Safari as h(||).
Theorem 3 gives us a termination criterion for Safari which can be used for enumerating
and counting minimal-cardinality diagnoses. Instead of running Safari with
P a fixed N , it
is sufficient to compute the area under the output distribution function
h. This value
P
will converge to a single value, hence we can terminate Safari after the change of
h
drops below a fixed threshold. Note that Safari is efficient in enumerating the minimalcardinality diagnoses, as they are computed with a probability that is exponentially higher
than that of the probability of computing minimal diagnoses of higher-cardinality, as shown
in Theorem 3.
Corollary 1. Safari computes diagnoses of equal cardinality with equal probability.
Proof (Sketch). From Theorem 3 it follows that the probability of success f of Safari in
computing a diagnosis  depends only on || and not on the actual composition of .
The above corollary gives us a simple termination criterion for Safari in the cases when
all minimal diagnoses are also minimal-cardinality diagnoses; it can be proven that in this
case all minimal-cardinality diagnoses are computed with the same probability.
We will see that, given an input cardinality distribution hi (||), Safari produces an
output distribution h(||) that is highly skewed to the right, due to Theorem 3. To facilitate
the study of how Safari transforms hi (||) into h(||) we will use a Monte Carlo simulation
of Safari. The advantage is that the Monte Carlo simulation is much simpler for analysing
the run-time behavior of Safari than studying the algorithm itself.
Algorithm 2 Monte Carlo simulation of Safari
1: function SafariSimulate(, N ) returns a cardinality distribution
inputs:  , a set of minimal diagnoses
N , integer, number of tries
local variables: hi , h, vectors, cardinality distributions
b, vector, fault distribution, n, i, c, integers
2:
hi  CardinalityDistribution( )
3:
for n  1, 2, . . . , N do
4:
for c  1, 2, . . . , |hi | do
5:
b[c]  c  hi [c]
6:
end for
7:
for i  1, 2, . . . , | | do
 
8:
c  DiscreteInverseRandomValue Pb b
9:
b[c]  b[c]  c
10:
end for
11:
h[c]  h[c] + 1
12:
end for
13:
return h
14: end function
398

fiApproximate Model-Based Diagnosis Using Greedy Stochastic Search

Algorithm 2 simulates which diagnoses from the input set of minimal diagnoses  are
reached by Safari in N tries. The auxiliary subroutine CardinalityDistribution
computes the input distribution hi by iterating over all diagnoses in  . We store the input
cardinality distribution hi and the resulting cardinality distribution h in vectors (note the
vector sums in lines 7 and 8 and the division of a vector by scalar in line 8).
The outermost loop of Alg. 2 (lines 3  12) simulates the N runs of Safari. This is done
by computing and updating an auxiliary vector b, which contains the distribution of the
component variables in  according to the cardinalities of the diagnoses these variables
belong to. Initially, b is initialized with the number of literals in single faults in position 1,
the number of literals in double faults in position 2 (for example if there are three double
faults in hi , b[2] = 6), etc. This is done in lines 4  6 of Alg. 2. We assume that diagnoses
do not share literals. This restriction can be easily dropped by counting all the assumables
in the input  (the latter assumption does not change the results of this section).
Lines 7  10 simulate the process of the actual bit flipping of Safari. At each step
the simulation draws a random literal from the probability distribution function (pdf ) Pb b ;
this is done by the DiscreteInverseRandomValue function in line 8. Each bit flip
invalidates a diagnosis from the set  , i.e., a diagnosis of cardinality c cannot be reached
by Safari. After a diagnosis has been invalidated, the vector b is updated, for example, if
the simulation invalidates a quadruple fault, b[4] = b[4]  4 (line 9). Note that the number
of iterations in the loop in lines 7  10 equals the number of diagnoses in  . As a result
after terminating this loop, the value of the integer variable c is equal to the cardinality of
the last invalidated diagnosis. The latter is the diagnosis which Safari computes in this
run. What remains is to update the resulting pdf with the right cardinality (line 11).
The simulation in Alg. 2 links the distribution of the actual diagnoses in  to the
distribution of the cardinalities of the diagnoses returned by Safari. As  can be arbitrarily set, we will apply Alg. 2 to a range of typical input distributions. The results of the
simulation as well as the results of running Safari on synthetic problems with the same
input distributions are shown in Fig. 12.
Fig. 12 shows (1) that Alg. 2 predicts the actual behavior of Safari (compare the second
and third column of plots), and (2) that Safari computes diagnoses of small cardinality
in agreement with Theorem 3. The only case when the output distribution is not a steep
exponential is when the cardinalities in the set of the input minimal diagnoses grow exponentially. Table 2 summarizes the parameters of exponential fits for the input cardinality
distributions shown in Fig. 12 (a is the initial (zero) cardinality,  is the decay constant, and
R2 is the coefficient of determination). We have seen that Safari is suited for computing
multiple diagnoses of small probability of occurrence. In the next section we will provide
an alternative argument leading to similar conclusions.

6. Experimental Results
This section discusses empirical results measured from an implementation of Safari. In order to compare the optimality and performance of Safari to various diagnostic algorithms,
we have performed more than a million diagnosis computations on 64 dual-CPU nodes belonging to a cluster. Each node contains two 2.4 GHz AMD Opteron DP 250 processors
and 4 Gb of RAM.
399

fiFeldman, Provan, & van Gemund

degenerate input

prediction (model)

0.5
0

1

h(||)

1

h(||)

h(||)

1

0.5
0

0

50
||

100

0

0.5
0

50
||

100

0
0

50
||

100

h(||)

h(||)

0.2
0.1

20

exponential input

10
||

0

h(||)

h(||)
20
||

40

0

prediction (model)
0.3

5

10

||

0.2
0.1
0

40

0.3

h(||)

h(||)

h(||)
0

20
||

SAFARI

0.4

0

0.5
0

0

reverse exponential input

0.2

20

1

0.5

40

10
||

SAFARI

0
20
||

0.1

prediction (model)

0
0

0.2

20

1

0.2

100

0
0

0.4

50
||

0.3

0
10
||

0

SAFARI

0.3

0.05

100

0.5

prediction (model)

0.1

50
||

SAFARI

h(||)

h(||)

h(||)

0.5

0

0

1

normal input

h(||)

100

1

0

h(||)

50
||

prediction (model)

1

0

0.5
0

uniform input

0

SAFARI

0.2
0.1

0

5
||

10

0

0

5
||

Figure 12: Predicted and actual cardinality distributions
400

10

fiApproximate Model-Based Diagnosis Using Greedy Stochastic Search

Table 2: Fit coefficients to exponential and goodness of fit for the cardinality distribution
in Fig. 12
a



R2

576
423
69 470
385

0.44
0.34
4.26
0.33

1
0.99
1
0.95

Input Distribution
Uniform
Normal
Exponential
Reverse Exponential

The default configuration of Safari (when not stated otherwise) was M = 8 and N = 4;
that is, Safari is configured for a maximum number of 8 retries before giving up the
climb, and a total of 4 attempts. To provide more precise average run-time optimality and
performance data, all stochastic algorithms (i.e., ones based on SLS Max-SAT and Safari)
have been repeatedly run 10 times on each model and observation vector.
6.1 Implementation Notes and Test Set Description
We have implemented Safari in approximately 1 000 lines of C code (excluding the LTMS,
interface, and DPLL code) and it is a part of the Lydia package.7
Traditionally, MBD algorithms have been tested on diagnostic models of digital circuits
like the ones included in the ISCAS85 benchmark suite (Brglez & Fujiwara, 1985). As
models derived from ISCAS85 are large (from a traditional diagnostic perspective), we
have also considered four medium-sized circuits from the 74XXX family (Hansen, Yalcin,
& Hayes, 1999). In order to provide both weak- and strong-fault cases, we have translated
each circuit to a weak, stuck-at-0 (S-A-0), and stuck-at-1 (S-A-1) model. In the stuck-at
models, the output of each faulty gate is assumed to be the same constant (cf. Def. 14).
The performance of diagnostic algorithms depends to various degrees on the observation
vectors (algorithm designers strive to produce algorithms, the performance of which is not
dependent on the observation vectors). Hence, we have performed our experimentation
with a number of different observations for each model. We have implemented an algorithm
(Alg. 3) that generates observations leading to diagnoses of different minimal-cardinality,
varying from 1 to nearly the maximum for the respective circuits (for the 74XXX models
it is the maximum). The experiments omit nominal scenarios as they are trivial from the
viewpoint of MBD.
Algorithm 3 uses a number of auxiliary functions. RandomInputs (line 3) assigns
uniformly distributed random values to each input in IN (note that for the generation of
observation vectors we partition the observable variables OBS into inputs IN and outputs
OUT and use the input/output information which comes with the original 74XXX/ISCAS85
circuits for simulation). Given the all healthy health assignment and the diagnostic system, ComputeNominalOutputs (line 4) performs simulation by propagating the input
assignment . The result is an assignment  which contains values for each output variable
in OUT.
7. Lydia, Safari, and the diagnostic benchmark can be downloaded from http://fdir.org/lydia/.

401

fiFeldman, Provan, & van Gemund

Algorithm 3 Algorithm for generation of observation vectors
1: function MakeAlphas(DS, N, K) returns a set of observations
inputs: DS = hSD, COMPS, OBSi, diagnostic system
OBS = IN  OUT, IN  OUT = 
N , integer, number of tries for Safari
K, integer, maximal number of diagnoses per cardinality
local variables: , , n , , terms
c, integer, best cardinality so far
A, set of terms (observation vectors), result
2:
for k  1, 2, . . . , K do
3:
  RandomInputs(IN)
4:
  ComputeNominalOutputs(DS, )
5:
c0
6:
for all v  OUT do
7:
n    Flip(, v)
8:
  SmallestCardinalityDiagnosis(Safari(SD, n , |COMPS|, N ))
9:
if || > c then
10:
c  ||
11:
A  A  n
12:
end if
13:
end for
14:
end for
15:
return A
16: end function
The loop in lines 6  13 increases the cardinality by greedily flipping the values of the
output variables. For each new candidate observation n , Alg. 3 uses the diagnostic oracle
Safari to compute a minimal diagnosis of cardinality c. As Safari returns more than
one diagnosis (up to N ), we use SmallestCardinalityDiagnosis to choose the one of
smallest cardinality. If the cardinality c of this diagnosis increases in comparison to the
previous iteration, the observation is added to the list.
By running Alg. 3 we get up to K observations leading to faults of cardinality 1, 2, . . . , m,
where m is the cardinality of the MFMC diagnosis (Feldman, Provan, & van Gemund,
2008b) for the respective circuit. Alg. 3 clearly shows a bootstrapping problem. In order
to create potentially difficult observations for Safari, we require Safari to solve those
difficult observations. Although we have seen in Sec. 5 that Safari is heavily biased
towards generating diagnoses of small cardinality, there is no guarantee. To alleviate this
problem, for the generation of observation vectors, we have configured Safari to compute
subset-minimal diagnoses with M = |COMPS| and N increased to 20.
Table 3 provides an overview of the fault diagnosis benchmark used for our experiments.
The third and fourth columns show the number of observable and assumable variables, which
characterize the size of the circuits. The next three columns show the number of observation
vectors with which we have tested the weak, S-A-0, and S-A-1 models. For the stuck-at
models, we have chosen those weak-fault model observations which are consistent with their
402

fiApproximate Model-Based Diagnosis Using Greedy Stochastic Search

Table 3: An overview of the 74XXX/ISCAS85 benchmark circuits
Name

Description

74182
74L85
74283
74181

4-bit
4-bit
4-bit
4-bit

c432
c499
c880
c1355
c1908
c2670
c3540
c5315
c6288
c7552

27-channel interrupt controller
32-bit SEC circuit
8-bit ALU
32-bit SEC circuit
16-bit SEC/DEC
12-bit ALU
8-bit ALU
9-bit ALU
32-bit multiplier
32-bit adder

Variables
|OBS| |COMPS|

carry-lookahead generator
magnitude comparator
adder
ALU

Observations
Weak S-A-0 S-A-1

14
14
14
22

19
33
36
65

250
150
202
350

150
58
202
143

82
89
202
213

43
73
86
73
58
373
72
301
64
315

160
202
383
546
880
1 193
1 669
2 307
2 416
3 512

301
835
1 182
836
846
1 162
756
2 038
404
1 557

301
235
217
836
846
134
625
158
274
255

301
835
335
836
846
123
743
228
366
233

respective system descriptions (as in strong-fault models it is often the case that SD |=,
we have not considered such scenarios).
6.2 Comparison to Complete Algorithms
Table 4 shows the results from comparing Safari to implementations of two state-of-the-art
complete and deterministic diagnostic algorithms: a modification for completeness of CDA
(Williams & Ragno, 2007) and HA (Feldman & van Gemund, 2006). Table 4 shows, for
each model and for each algorithm, the percentage of all tests for which a diagnosis could
be computed within a cut-off time of 1 minute.
As it is visible from the three rightmost columns of Table 4, Safari could find diagnoses for all observation vectors, while the performance of the two deterministic algorithms
(columns two to seven) degraded with the increase of the model size and the cardinality of
the observation vector. Furthermore, we have observed a degradation of the performance of
CDA and HA with increased cardinality of the minimal-cardinality diagnoses, while the
performance of Safari remained unaffected.
6.3 Comparison to Algorithms Based on ALLSAT and Model Counting
We have compared the performance of Safari to that of a pure SAT-based approach,
which uses blocking clauses for avoiding duplicate diagnoses (Jin, Han, & Somenzi, 2005).
Although SAT encodings have worked efficiently on a variety of other domains, such as
planning, the weak health modeling makes the diagnostic problem so underconstrained that
an uninformed ALLSAT strategy (i.e., a search not exploiting the continuity imposed by
the weak-fault modeling) is quite inefficient, even for small models.
403

fiFeldman, Provan, & van Gemund

Table 4: Comparison of CDA , HA , and Safari [% of tests solved]
Name

Weak

CDA
S-A-0

74182
74L85
74283
74181

100
100
100
79.1

100
100
100
98.6

100
100
100
97.7

c432
c499
c880
c1355
c1908
c2670
c3540
c5315
c6288
c7552

74.1
29
11.6
3.8
0
0
0
0
0
0

75.4
45.5
44.7
4.7
0
0
0
0
0
0

73.1
27.7
32.2
5.4
0
0
0
0
0
0

S-A-1

Weak

HA
S-A-0

S-A-1

Weak

100
100
100
100

100
100
100
100

100
100
100
100

100
100
100
100

100
100
100
100

100
100
100
100

100
100
100
100
100
100
100
100
100
100

100
100
100
100
100
100
100
100
100
100

100
100
100
100
100
100
100
100
100
100

71.1
24.1
12.4
10.8
6.1
5
1.1
1.1
3.5
3.9

94.7
77.9
62.2
10.6
6
64.2
3.8
8.2
5.1
7.8

69.1
25.9
41.5
12.2
6.5
44.7
2.2
5.7
3.3
12

Safari
S-A-0 S-A-1

To substantiate our claim, we have experimented with the state-of-the-art satisfiability
solver RelSat, version 2.02 (Bayardo & Pehoushek, 2000). Instead of enumerating all
solutions and filtering the minimal diagnoses only, we have performed model-counting, whose
relation to MBD has been extensively studied (Kumar, 2002). While it was possible to solve
the two smallest circuits, the solver did not terminate for any of the larger models within
the predetermined time of 1 hour. The results are shown in Table 5.
The second column of Table 5 shows the model count returned by RelSat, with sample single-fault observations from our benchmark. The third column reports the time for
model counting. This slow performance on relatively small diagnostic instances leads us
to the conclusion that specialized solvers like Safari are better suited for finding minimal
diagnoses than off-the-shelf ALLSAT (model counting) implementations that do not encode
inference properties similar to those encoded in Safari.
We have used the state-of-the-art, non-exact model counting method SampleCount
(Gomes, Hoffmann, Sabharwal, & Selman, 2007) to compute lower bounds of the model
counts. The results are shown in the third and fourth columns of Table 5. Configured with
the default settings ( = 3.5, t = 2, z = 20, cutoff 10 000 flips), SampleCount could not
find lower bounds for circuits larger than c1355. Although the performance of SampleCount is significantly better than RelSAT, the fact that SampleCount computes lower
bounds and does not scale to large circuits prevent us from building a diagnosis algorithm
based on approximate model counting.
A satisfiability-based method for diagnosing an optimized version of ISCAS85 has been
used by Smith, Veneris, and Viglas (2004). In a more recent paper (Smith, Veneris, Ali, &
Viglas, 2005), the SAT-based approach has been replaced by a Quantified Boolean Formula
(QBF) solver for computing multiple-fault diagnoses. These methods report good absolute
404

fiApproximate Model-Based Diagnosis Using Greedy Stochastic Search

Table 5: Model count and time for counting
RelSat
Models
Time [s]

Name

SampleCount
Models
Time [s]

74182
74L85
74283
74181

3.9896  107
8.3861  1014
 1.0326  1015
 5.6283  1015

1
340
> 3 600
> 3 600

 3.526359  106
 7.412344  1013
 3.050026  1014
 1.538589  1027

0.2
0.3
0.3
1.1

c432
c499
c880
c1355
c1908
c2670
c3540
c5315
c6288
c7552












7.2045  1018
3.6731  1020
9.4737  1039
1.4668  1028
2.1704  1031
9.0845  1015
4.8611  1019
9.3551  1016
1.0300  1018
1.0049  1016

> 3 600
> 3 600
> 3 600
> 3 600
> 3 600
> 3 600
> 3 600
> 3 600
> 3 600
> 3 600

 1.496602  1067
 7.549183  1083
 8.332702  10166
 7.488300  10233







9.9
13.1
42.7
99.8







execution time for single and double-faults (and we believe that they scale well for higher
cardinalities), but require modifications of the initial circuits (i.e., introduce cardinality and
test constraints) and suggest specialized heuristics for the SAT solvers in order to improve
the search performance. Comparison of the performance of Safari to the timings reported
by these papers would be difficult due to a number of reasons like the use of different and
optimized benchmark sets, trading-off memory for speed, rewriting the original circuits, etc.
6.4 Performance of the Greedy Stochastic Search
Table 6 shows the absolute performance of Safari (M = |COMPS|, N = 4). This varies
from under a millisecond for the small models, to approx. 30 s for the largest strong-fault
model. These fast absolute times show that Safari is suitable for on-line reasoning tasks,
where autonomy depends on speedy computation of diagnoses.
For each model, the minimum and maximum time for computing a diagnosis has been
computed. These values are shown under columns tmin and tmax , respectively. The small
range of tmax  tmin confirms our theoretical results that Safari is insensitive to the fault
cardinalities of the diagnoses it computes. The performance of CDA and HA , on the
other hand, is dependent on the fault cardinality and quickly degrades with increasing fault
cardinality.
6.5 Optimality of the Greedy Stochastic Search
From the results produced by the complete diagnostic methods (CDA and HA ) we know
the exact cardinalities of the minimal-cardinality diagnoses for some of the observations. By
considering these observations, which lead to single and double faults, we have evaluated
405

fiFeldman, Provan, & van Gemund

Table 6: Performance of Safari [ms]
Weak
Name

tmin

S-A-0
tmax

74182
74L85
74283
74181

0.41
0.78
0.92
2.04

1.25
7.47
4.84
6.94

c432
c499
c880
c1355
c1908
c2670
c3540
c5315
c6288
c7552

8.65
14.19
48.08
95.03
237.77
500.54
984.31
1 950.12
2 105.28
4 557.4

38.94
31.78
88.87
141.59
349.96
801.12
1 300.98
2 635.71
2 688.34
6 545.21

tmin
0.39
0.72
0.88
2.13

S-A-1
tmax
4.41
1.89
3.65
22.4

tmin
0.40
0.69
0.92
2.07

tmax
0.98
4.77
5.2
7.19

7.58
30.59
7.96
38.27
11.03
30.32
10.79
31.11
37.08
80.74
38.47
81.34
76.57
150.29
83.14
135.29
196.13
300.11
217.32
442.91
646.95 1 776.72
463.24
931.8
1 248.5
2 516.46
976.56 2 565.18
3 346.49 7 845.41 2 034.5
4 671.17
2 246.84 3 554.4 1 799.18 2 469.48
9 975.04 32 210.71 5 338.97 12 101.61

the average optimality of Safari. Table 7 shows these optimality results for the greedy
search. The second column of Table 7 shows the number of observation vectors leading to
single faults for each weak-fault model. The third column shows the average cardinality of
Safari. The second and third column are repeated for the S-A-0 and S-A-1 models.
Table 7 shows that, for SD  WFM, the average cardinality returned by Safari is
near-optimal for both single and double faults. The c1355 model shows the worst-case
results for the single-fault observations, while c499 is the most difficult weak-fault model for
computing a double-fault diagnosis. These results can be improved by increasing M and N
as discussed in Sec. 4.
With strong-fault models, results are close to optimal for the small models and the
quality of diagnosis deteriorates for c3540 and bigger. This is not surprising, considering
the modest number of retries and number of flips with which Safari was configured.
6.6 Computing Multiple Minimal-Cardinality Diagnoses
We next show the results of experiments supporting the claims made in Sec. 5. For that,
we have first chosen these observations  for which we could compute | (SD  )| with a
deterministic algorithm like CDA or HA (mostly observations leading to single or double
faults). We have then configured Safari with M = |COMPS| and N = 10| (SD  )|.
Finally, from the diagnoses computed by Safari we have filtered the minimal-cardinality
ones. The results are summarized in Table 8.
Table 8 repeats the same columns for weak, S-A-0, and S-A-1 models and the data
in these columns are to be interpreted as follows. The columns marked with | | show
the minimal and maximal number of minimal-cardinality diagnoses per model as computed
by a deterministic algorithm. The columns Mc show the percentage of minimal-cardinality
406

fiApproximate Model-Based Diagnosis Using Greedy Stochastic Search

Table 7: Optimality of Safari [average cardinality]
Single Faults
S-A-0
S-A-1
# Card. # Card.

Name

Weak
# Card.

74182
74L85
74283
74181

50
50
50
50

1
1.04
1.08
1.19

37
18
34
36

1
1.02
1.59
2.81

40
40
46
46

c432
c499
c880
c1355
c1908
c2670
c3540
c5315
c6288
c7552

58
84
50
84
52
29
8
14
13
27

1.19
1.49
1
1.66
1.05
1.03
1.01
1
1
1.01

52
53
39
82
49
39
23
9
13
11

1.06
1.49
1.1
1
2.91
1.77
2.5
3.54
28.83
17.37

37
84
40
84
52
28
16
12
12
18

1
1.03
1.88
2.6

Weak
# Card.

Double Faults
S-A-0
S-A-1
# Card. # Card.

50
50
50
50

2
2.12
2.2
2.25

38
17
45
36

1.04 82
1.01 115
1.05 50
1.02
6
4.79 
2.06 13
3.74 
5.4
7
28.68
1
23.38 16

2.46
3.27
2.01
2.15

2.12

2
2
2

80
34
34
7
2
24
1
3
1
4

2
2.06
2.41
3.61

18
35
42
43

2
2.07
2.6
3.16

2.25 48
3.01 115
2.14 35
2
18
3
3
2.78 15
4.9

3.7
1
27

18.5
6

2.15
2.03
2.07
2.07
3.17
3.27

3.8

27.53

Table 8: % of all minimal-cardinality diagnoses computed by Safari
Weak
Mc

Name

| |

74182
74L85
74283
74181

1  25
1  78
1  48
1  133

100
99.2
97.9
97.4

c432
c499
c880
c1355
c1908
c2670
c3540
c5315
c6288
c7552

1  99
1  22
2  646
5  2 770
2  1 447
1  76
1  384
1  235
1  154
1  490

94.2
78.5
99.9
79.4
96.6
100
81.5
97.7
100
93.1

S-A-0
Mc Mf

| |

0
2
3
1

12
14
1  16
1  16

100
100
93.8
88.6

0
0
0
4.07

1  20
1  49
1  29
1  57

100
99.7
84.9
96.7

0
0
4
6.36

1  40
1  15
1  160
2  648
2  579
1  20
1  153
1  24
1  73
4  236

89.7
96.3
96.9
95.7
85.2
97.1
88.8
81.7
78.1
90.8

0
6
0
0
1.85
0
7.98
7.04
5.1
13.55

1  18
1  16
1  210
2  347
2  374
1  181
1  171
1  30
1  101
1  168

97
94.8
97.5
95.2
82.3
89.7
78.2
93.4
82.1
78

0
0
0
0.52
1.24
0
7.27
8.24
1.22
12.1

7.14
1.51
0
1.02
2.61
2.34
8.52
1.74
13.1
2.17

| |

S-A-1
Mc Mf

Mf

diagnoses returned by Safari (from all minimal-cardinality diagnoses) for those  for which
| (SD  )| > 1. The columns Mf show the percentage of observations for which Safari
could not compute any minimal-cardinality diagnosis.
407

fiFeldman, Provan, & van Gemund

The results shown in Table 8 show that even for moderate values of N (N  27 770),
Safari was capable of computing a significant portion of all minimal-cardinality diagnoses.
This portion varies from 78.5% to 100% for weak-fault models and from 78% to 100% for
strong-fault models. The percentage of cases in which Safari could not reach a minimalcardinality diagnosis is limited (at most 13.55%) and is mainly in the cases in which there
exists only one single-fault diagnosis. Note that even in the cases in which Safari cannot
compute any minimal-cardinality diagnoses, the result of Safari can still be useful. For
example, a subset-minimal diagnosis of small cardinality differing in one or two literals
only nevertheless brings useful diagnostic information (a discussion on diagnostic metrics is
beyond the scope of this paper).
6.7 Experimentation Summary
We have applied Safari to a suite of benchmark combinatorial circuits encoded using
weak-fault models and stuck-at strong fault models, and shown significant performance
improvements for multiple-fault diagnoses, compared to two state-of-the-art deterministic
algorithms, CDA and HA . Our results indicate that Safari shows at least an order-ofmagnitude speedup over CDA and HA for multiple-fault diagnoses. Moreover, whereas the
search complexity for the deterministic algorithms tested increases exponentially with fault
cardinality, the search complexity for this stochastic algorithm appears to be independent
of fault cardinality.
We have compared the performance of Safari to that of an algorithm based on MaxSAT, and Safari shows at least an order-of-magnitude speedup in computing diagnoses.
We have compared the optimality of Safari to that of an algorithm based on SLS MaxSAT, and Safari consistently computes diagnoses of smaller cardinality whereas the SLS
Max-SAT diagnostic algorithm often fails to compute any diagnosis.

7. Related Work
This paper (1) generalizes Feldman, Provan, and van Gemund (2008a), (2) introduces important theoretical results for strong-fault models, (3) extends the experimental results
there, and (4) provides a comprehensive optimality analysis of Safari.
On a gross level, one can classify the types of algorithms that have been applied to solve
MBD as being based on search or compilation. The search algorithms take as input the diagnostic model and an observation, and then search for a diagnosis, which may be minimal
with respect to some minimality criterion. Examples of search algorithms include A -based
algorithms, such as CDA (Williams & Ragno, 2007) and hitting set algorithms (Reiter,
1987). Compilation algorithms pre-process the diagnostic model into a form that is more
efficient for on-line diagnostic inference. Examples of such algorithms include the ATMS
(de Kleer, 1986) and other prime-implicant methods (Kean & Tsiknis, 1993), DNNF (Darwiche, 1998), and OBDD (Bryant, 1992). To our knowledge, all of these approaches adopt
exact methods to compute diagnoses; in contrast, Safari adopts a stochastic approach to
computing diagnoses.
At first glance, it seems like MBD could be efficiently solved using an encoding as
a SAT (Jin et al., 2005), constraint satisfaction (Freuder, Dechter, Ginsberg, Selman, &
Tsang, 1995) or Bayesian network (Kask & Dechter, 1999) problem. However, one needs to
408

fiApproximate Model-Based Diagnosis Using Greedy Stochastic Search

take into account the increase in formula size (over a direct MBD encoding), in addition to
the underconstrained nature of MBD problems.
Safari has close resemblance to Max-SAT (Hoos & Stutzle, 2004) and we have conducted extensive experimentation with both complete (partial and weighted) and SLS-based
Max-SAT. As the results of these experiments are long, we have published them in a separate technical report (Feldman, Provan, & van Gemund, 2009a). The results show that
although Max-SAT can compute diagnoses in many of the cases, the performance of MaxSAT degrades when increasing the circuit size or the cardinality of the injected faults. In
particular, Safari outperforms Max-SAT by at least an order-of-magnitude for the class of
diagnostic problems we have considered. In the case of SLS-based Max-SAT, the optimality
of Max-SAT-based inference is significantly worse than that of Safari.
We show that Safari exploits a particular property of MBD problems, called diagnostic
continuity, which improves the optimality of Safari compared to, for example, straightforward ALLSAT encodings (Jin et al., 2005). We experimentally confirm this favorable
performance and optimality of Safari. Although Safari has close resemblance to MaxSAT, Safari exploits specific landscape properties of the diagnostic problems, which allow
(1) simple termination criteria and (2) optimality bounds. Due to the hybrid nature of
Safari (the use of LTMS and SAT), Safari avoids getting stuck in local optima and performs better than Max-SAT based methods. Incorporating approaches from Max-SAT, and
in particular SAPS (Hutter, Tompkins, & Hoos, 2002), in future versions of Safari may
help in solving more general abduction problems, which may not expose the continuous
properties of the models we have considered.
Stochastic algorithms have been discussed in the framework of constraint satisfaction
(Freuder et al., 1995) and Bayesian network inference (Kask & Dechter, 1999). The latter
two approaches can be used for solving suitably translated MBD problems. It is often the
case, though, that these encodings are more difficult for search than specialized ones.
MBD is an instance of constraint optimization, with particular constraints over failure
variables. MBD has developed algorithms to exploit these domain properties, and our
proposed approach differs significantly from almost all MBD algorithms that appear in the
literature. While most advanced MBD algorithms are deterministic, Safari borrows from
SLS algorithms that, rather than backtracking, may randomly flip variable assignments
to determine a satisfying assignment. Complete MBD algorithms typically make use of
preferences, e.g., fault-mode probabilities, to improve search efficiency; Safari uses this
technique on top of its stochastic search over the space of diagnoses.
A closely-related diagnostic approach is that of Fijany, Vatan, Barrett, James, Williams,
and Mackey (2003), who map the minimal-hitting set problem into the problem of finding
an assignment with bounded weight satisfying a monotone SAT problem, and then propose
to use efficient SAT algorithms for computing diagnoses. The approach of Fijany et al. has
shown speedups in comparison with other diagnosis algorithms; the main drawback is the
number of extra variables and clauses that must be added in the SAT encoding, which is
even more significant for strong fault models and multi-valued variables. In contrast, our
approach works directly on the given diagnosis model and requires no conversion to another
representation.
Our work bears the closest resemblance to preference-based or Cost-Based Abduction
(CBA) (Charniak & Shimony, 1994; Santos Jr., 1994). Of the algorithmic work in this
409

fiFeldman, Provan, & van Gemund

area, the primary paper that adopts stochastic local search is by Abdelbar, Gheita, and
Amer (2006). In this paper, they present a hybrid two-stage method that is based on
Iterated Local Search (ILS) and Repetitive Simulated Annealing (RSA). The ILS stage of
the algorithm uses a simple hill-climbing method (randomly flipping assumables) for the
local search phase, and tabu search for the perturbation phase. RSA repeatedly applies
Simulated Annealing (SA), starting each time from a random initial state. The hybrid
method initially starts from an arbitrary state, or a greedily-chosen state. It then applies
the ILS algorithm; if this algorithm fails to find the optimal solution after a fixed number
 of hill-climbing steps8 or after a fixed number R of repetitions of the perturbation-local
search cycle,9 ILS-based search is terminated and the RSA algorithm is run until the optimal
solution is found.
Our work differs from that of Abdelbar et al. (2006) in several ways. First, our initial
state is generated using a random SAT solution. The hill-climbing phase that we use next
is similar to that of Abdelbar et al.; however, we randomly restart should hill-climbing not
identify a better diagnosis, rather than applying tabu search or simulated annealing. Our
approach is simpler than that of Abdelbar et al., and for the case of weak fault models
is guaranteed to be optimal; in future work we plan to compare our approach to that of
Abdelbar et al. for strong fault models.
In 2009 Safari competed against the diagnostic algorithms NGDE (de Kleer, 2009)
and RODON (Bunus, Isaksson, Frey, & Munker, 2009) in the synthetic track of the first
diagnostic competition DXC09 (Kurtoglu, Narasimhan, Poll, Garcia, Kuhn, de Kleer, van
Gemund, & Feldman, 2009). The conditions under which the DXC09 experiments were
conducted were similar to the ones described in this paper. The CPU and memory performance of Safari were an order of magnitude better than the competing algorithms despite
the fact that NGDE and RODON performed better than the complete algorithms discussed
in this section. In this paper, in addition to computational metrics, we have informally
used the minimality of a diagnosis as an optimality criterion. The DXC09 organizers, however, have defined a utility metric which approximates the expected repair effort of a circuit
(Feldman, Provan, & van Gemund, 2009b). With this utility metric, Safari scored slightly
worse than the two competing algorithms, which is to be expected as Safari trades off
diagnostic precision for computational efficiency. We refer the reader to the DXC papers
mentioned above for a more thorough analysis of the competition results.

8. Conclusion and Future Work
We have described a greedy stochastic algorithm for computing diagnoses within a modelbased diagnosis framework. We have shown that subset-minimal diagnoses can be computed
optimally in weak fault models and in an important subset of strong fault models, and that
almost all minimal-cardinality diagnoses can be computed for more general fault models.
8. Hill-climbing proceeds as follows: given a current state s with a cost of f (s), a neighbouring state s
is generated by flipping a randomly chosen assumable hypothesis. If f (s ) is better than f (s), then s
becomes the current state; otherwise, it is discarded. If  iterations elapse without a change in the
current state, the local search exits.
9. Perturbation-local search, starting from a current state s with a cost of f (s), randomly chooses an
assumable variable h, and applies tabu search to identify a better state by flipping h based on its tabu
status.

410

fiApproximate Model-Based Diagnosis Using Greedy Stochastic Search

We argue that Safari can be of broad practical significance, as it can compute a significant fraction of minimal-cardinality diagnoses for systems too large or complex to be
diagnosed by existing deterministic algorithms.
In future work, we plan to experiment on models with a combination of weak and strong
failure-mode descriptions. We also plan on experimenting with a wider variety of stochastic
methods, such as simulated annealing and genetic search, using a larger set of benchmark
models. Last, we plan to apply our algorithms to a wider class of abduction and constraint
optimization problems.

References
Abdelbar, A. M. (2004). Approximating cost-based abduction is NP-hard. Artificial Intelligence, 159 (1-2), 231239.
Abdelbar, A. M., Gheita, S. H., & Amer, H. A. (2006). Exploring the fitness landscape and
the run-time behaviour of an iterated local search algorithm for cost-based abduction.
Experimental & Theoretical Artificial Intelligence, 18 (3), 365386.
Bayardo, R. J., & Pehoushek, J. D. (2000). Counting models using connected components.
In Proc. AAAI00, pp. 157162.
Brglez, F., & Fujiwara, H. (1985). A neutral netlist of 10 combinational benchmark circuits
and a target translator in fortran. In Proc. ISCAS85, pp. 695698.
Bryant, R. E. (1992). Symbolic Boolean manipulation with ordered binary-decision diagrams. ACM Computing Surveys, 24 (3), 293318.
Bunus, P., Isaksson, O., Frey, B., & Munker, B. (2009). RODON - a model-based diagnosis
approach for the DX diagnostic competition. In Proc. DX09, pp. 423430.
Bylander, T., Allemang, D., Tanner, M., & Josephson, J. (1991). The computational complexity of abduction. Artificial Intelligence, 49, 2560.
Charniak, E., & Shimony, S. E. (1994). Cost-based abduction and MAP explanation. Artificial Intelligence, 66 (2), 345374.
Cook, S. A. (1971). The complexity of theorem-proving procedures. In Proc. STOC71, pp.
151158.
Darwiche, A. (1998). Model-based diagnosis using structured system descriptions. Journal
of Artificial Intelligence Research, 8, 165222.
Davis, M., Logemann, G., & Loveland, D. (1962). A machine program for theorem-proving.
Communications of the ACM, 5 (7), 394397.
de Kleer, J. (1986). An assumption-based TMS. Artificial Intelligence, 28 (2), 127162.
de Kleer, J. (1990). Using crude probability estimates to guide diagnosis. Artificial Intelligence, 45 (3), 381291.
de Kleer, J. (2009). Minimum cardinality candidate generation. In Proc. DX09, pp. 397
402.
de Kleer, J., Mackworth, A., & Reiter, R. (1992). Characterizing diagnoses and systems.
Artificial Intelligence, 56 (2-3), 197222.
411

fiFeldman, Provan, & van Gemund

de Kleer, J., & Williams, B. (1987). Diagnosing multiple faults. Artificial Intelligence,
32 (1), 97130.
Een, N., & Sorensson, N. (2003). An extensible SAT-solver. In Proc. SAT03, Vol. 2919 of
Lecture Notes in Computer Science, pp. 502518. Springer.
Eiter, T., & Gottlob, G. (1995). The complexity of logic-based abduction. Journal of the
ACM, 42 (1), 342.
Feldman, A., Provan, G., & van Gemund, A. (2008a). Computing minimal diagnoses by
greedy stochastic search. In Proc. AAAI08, pp. 911918.
Feldman, A., Provan, G., & van Gemund, A. (2008b). Computing observation vectors for
max-fault min-cardinality diagnoses. In Proc. AAAI08, pp. 911918.
Feldman, A., Provan, G., & van Gemund, A. (2009a). A family of model-based diagnosis
algorithms based on Max-SAT. Tech. rep. ES-2009-02, Delft University of Technology.
Feldman, A., Provan, G., & van Gemund, A. (2009b). The Lydia approach to combinational
model-based diagnosis. In Proc. DX09, pp. 403408.
Feldman, A., & van Gemund, A. (2006). A two-step hierarchical algorithm for model-based
diagnosis. In Proc. AAAI06, pp. 827833.
Fijany, A., Vatan, F., Barrett, A., James, M., Williams, C., & Mackey, R. (2003). A novel
model-based diagnosis engine: Theory and applications. In Proc. IEEE Aerospace03,
Vol. 2, pp. 901910.
Forbus, K., & de Kleer, J. (1993). Building Problem Solvers. MIT Press.
Freeman, J. W. (1995). Improvements to Propositional Satisfiability Search Algorithms.
Ph.D. thesis, University of Pennsylvania.
Freuder, E. C., Dechter, R., Ginsberg, M. L., Selman, B., & Tsang, E. P. K. (1995). Systematic versus stochastic constraint satisfaction. In Proc. IJCAI95, Vol. 2, pp. 20272032.
Friedrich, G., Gottlob, G., & Nejdl, W. (1990). Physical impossibility instead of fault
models. In Proc. AAAI90, pp. 331336.
Gomes, C. P., Hoffmann, J., Sabharwal, A., & Selman, B. (2007). From sampling to model
counting. In Proc. IJCAI07, pp. 22932299.
Hansen, M., Yalcin, H., & Hayes, J. (1999). Unveiling the ISCAS-85 benchmarks: A case
study in reverse engineering. IEEE Design & Test, 16 (3), 7280.
Hermann, M., & Pichler, R. (2007). Counting complexity of propositional abduction. In
Proc. IJCAI07, pp. 417422.
Hoos, H. (1999). SAT-encodings, search space structure, and local search performance. In
Proc. IJCAI99, pp. 296303.
Hoos, H., & Stutzle, T. (2004). Stochastic Local Search: Foundations and Applications.
Morgan Kaufmann Publishers Inc.
Hutter, F., Tompkins, D. A. D., & Hoos, H. H. (2002). Scaling and probabilistic smoothing:
Efficient dynamic local search for SAT. In Proc. CP02, pp. 233248.
412

fiApproximate Model-Based Diagnosis Using Greedy Stochastic Search

Jin, H., Han, H., & Somenzi, F. (2005). Efficient conflict analysis for finding all satisfying
assignments of a Boolean circuit. In Proc. TACAS05, pp. 287300.
Kask, K., & Dechter, R. (1999). Stochastic local search for Bayesian networks. In Proc.
AISTAT99, pp. 113122.
Kean, A., & Tsiknis, G. K. (1993). Clause management systems. Computational Intelligence,
9, 1140.
Kumar, T. K. S. (2002). A model counting characterization of diagnoses. In Proc. DX02,
pp. 7076.
Kurtoglu, T., Narasimhan, S., Poll, S., Garcia, D., Kuhn, L., de Kleer, J., van Gemund, A.,
& Feldman, A. (2009). First international diagnosis competition - DXC09. In Proc.
DX09, pp. 383396.
Marques-Silva, J. P. (1999). The impact of branching heuristics in propositional satisfiability
algorithms. In Proc. EPIA99, pp. 6274.
McAllester, D. A. (1990). Truth maintenance. In Proc. AAAI90, Vol. 2, pp. 11091116.
Reiter, R. (1987). A theory of diagnosis from first principles. Artificial Intelligence, 32 (1),
5795.
Roth, D. (1996). On the hardness of approximate reasoning. Artificial Intelligence, 82 (1-2),
273302.
Santos Jr., E. (1994). A linear constraint satisfaction approach to cost-based abduction.
Artificial Intelligence, 65 (1), 128.
Smith, A., Veneris, A., Ali, M. F., & Viglas, A. (2005). Fault diagnosis and logic debugging
using Boolean satisfiability. IEEE Transactions on CAD of Integrated Circuits and
Systems, 24 (10), 16061621.
Smith, A., Veneris, A., & Viglas, A. (2004). Design diagnosis using Boolean satisfiability.
In Proc. ASP-DAC04, pp. 218223.
Struss, P., & Dressler, O. (1992). Physical negation - integrating fault models into the General Diagnostic Engine. In Readings in Model-Based Diagnosis, pp. 153158. Morgan
Kaufmann Publishers Inc.
Thiffault, C., Bacchus, F., & Walsh, T. (2004). Solving non-clausal formulas with DPLL
search. In Proc. CP04, pp. 663678.
Tseitin, G. (1983). On the complexity of proofs in propositional logics. In Siekmann, J., &
Wrightson, G. (Eds.), Automation of Reasoning: Classical Papers in Computational
Logic (19671970), Vol. 2. Springer-Verlag.
Williams, B., & Ragno, R. (2007). Conflict-directed A* and its role in model-based embedded systems. Journal of Discrete Applied Mathematics, 155 (12), 15621595.
Zhang, H., & Stickel, M. E. (1996). An efficient algorithm for unit propagation. In Proc.
AI-MATH96, pp. 166169.

413

fi