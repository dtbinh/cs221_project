Journal of Artificial Intelligence Research 38 (2010) 633-685

Submitted 03/10; published 08/10

Non-Transferable Utility Coalitional Games
via Mixed-Integer Linear Constraints
Gianluigi Greco

ggreco@mat.unical.it

Dipartimento di Matematica
Universita della Calabria
I-87036 Rende, Italy

Enrico Malizia
Luigi Palopoli
Francesco Scarcello

emalizia@deis.unical.it
palopoli@deis.unical.it
scarcello@deis.unical.it

DEIS
Universita della Calabria
I-87036 Rende, Italy

Abstract
Coalitional games serve the purpose of modeling payoff distribution problems in scenarios where agents can collaborate by forming coalitions in order to obtain higher worths than
by acting in isolation. In the classical Transferable Utility (TU) setting, coalition worths
can be freely distributed amongst agents. However, in several application scenarios, this
is not the case and the Non-Transferable Utility setting (NTU) must be considered, where
additional application-oriented constraints are imposed on the possible worth distributions.
In this paper, an approach to define NTU games is proposed which is based on describing allowed distributions via a set of mixed-integer linear constraints applied to an
underlying TU game. It is shown that such games allow non-transferable conditions on
worth distributions to be specified in a natural and succinct way. The properties and the
relationships among the most prominent solution concepts for NTU games that hold when
they are applied on (mixed-integer) constrained games are investigated. Finally, a thorough analysis is carried out to assess the impact of issuing constraints on the computational
complexity of some of these solution concepts.

1. Introduction
Cooperative game theory providesunder the concept of coalitional gamesan elegant
framework for modeling multi-agent systems where agents might collaborate with other
agents, by forming coalitions in order to guarantee themselves some advantage. Within
this framework, each coalition S  N (where N is the set of all the players, also called the
grand-coalition), is assigned a certain worth v(S)  R, and the outcome of the game is a
vector of real payoffs (xi )iN that is meant to specify the distribution of the worth granted
to the players as the result of the game.
Coalitional games are very often classified according to the mechanisms underlying payoff
distributions. The best known and most widely studied class therein is that of coalitional
games with transferable utility (or TU games) (Osborne & Rubinstein, 1994), where no
constraints whatsoever are imposed over the way coalitional worths can be distributed
amongst coalition members. In this context, several outcomes might be associated with a

c
2010
AI Access Foundation. All rights reserved.

fiGreco, Malizia, Palopoli, & Scarcello

given game, and hence a relevant question is to understand which outcomes most properly
capture the rational behavior of the players. This matter has been extensively studied in
economics and social sciences (Aumann & Hart, 2002). In fact, various solution concepts
have been proposed in the literature to identify worth distributions that embody some
rational concept of stability, i.e., that are somehow immune to deviations caused by
groups of players who may decide to leave the grand-coalition and to form sub-coalitions in
order to claim for higher worths.
There are cases, however, where players cannot freely distribute the coalition worth so
that a pure TU framework is not appropriate for such modeling purposes (Aumann & Peleg,
1960). To deal with those scenarios, coalitional games without transferable utility (or NTU
games) have been introduced in the literature, where the worth function is defined as to
return all those allowed worth distributions (called consequences, in this setting) associated
with any given coalition, rather than associating just one real value with it. In fact, it is
easily understood that NTU games are more general than TU ones, since any game of the
latter kind can be expressed as an NTU game where any possible worth distribution among
the members of a coalition S is a consequence for S.
1.1 Modeling NTU Specifications via Mixed-Integer Linear Constraints on
TU Games
Enhancing TU games with application-oriented constraints over the set of all possible outcomes is an approach that has been exploited in the literature in order to model nontransferable scenarios. The first occurrence of the name constrained games goes back to
the seventies, and is due to Aumann and Dreze (1974), who considered games with coalition structures, where players are partitioned in groups S1 , . . . , Sk , and where any outcome
(xi )iN must allocate the total payoff v(S
P j ) exactly amongst the members of each group Sj ,
that is, so as to satisfy the equalities iSj xi = v(Sj ), for 1  j  k. However, Aumann
and Dreze noticed in their turn that considering constraints over TU games was not a novel
idea, since the core and the nucleolus (which are two prominent solution concepts for TU
games) were indeed defined by Gillies (1959) and Schmeidler (1969), respectively, on games
with outcomes restricted to subsets of R|N | .
Recently, constrained games have been reconsidered under the pragmatic perspective
of modeling some relevant application scenarios, such as price formation (Byford, 2007)
and autonomic wireless networks (Jiang & Baras, 2007). As a matter of fact, however,
they received considerably little attention over the years. In particular, no general framework was proposed in the literature and no systematic study of the (analytical, as well as
computational) properties of this kind of approaches was conducted so far.
In this paper, we embark on a systematic formalization of constrained games, and we
investigate a framework allowing to succinctly specify non-transferable conditions on the
outcomes of an underlying TU game, via a set of constraints expressed as mixed-integer
linear (in)equalities.1 Note that such constrained games are defined on top of an underlying
TU specification, and hence they are expected to retain some of the nice properties of the
transferable setting. However, their ability of restricting the set of possible outcomes makes
1. A good source for basic notions and results on mixed-integer linear programming is the book by
Nemhauser and Wolsey (1988).

634

fiMixed-Integer Constrained Coalitional Games

them fit the more general framework of NTU games, from which they smoothly inherit the
solution concepts that we shall use.
By allowing integer variables, the constrained games studied in this paper will improve
the expressiveness of classical NTU formalizations, in that admissible outcomes might be
possibly restricted over non-convex and non-comprehensive regions (definitions for these
properties are recalled in Section 3.2). Indeed, those NTU games that attracted much attention in earlier literature do not allow to specify arbitrary consequences (Aumann & Hart,
2002). Rather, according to the classical definition due to Aumann and Peleg (1960), an
NTU game is actually a game that must satisfy additional conditions such as, in particular, convexity and comprehensiveness. This view features several nice properties under a
mathematical perspective (Weber, 1994; McLean, 2002), and it influenced several other proposals for defining NTU games which appeared in the literature, where further additional
conditions are often considered. However, this view is not appropriate to model application
scenarios where those required properties do not naturally hold.
In fact, the framework of constrained games proposed in this paper can be viewed as a
framework to (succinctly) define NTU games where convexity and comprehensiveness do not
necessarily hold. This is an important peculiarity of our approach from a knowledge representation perspective. An intuitive exemplification of those scenarios where this peculiarity
might be very useful is illustrated below.
Example 1.1. Three brothers, Tim, John and Jim, aged 10, 8 and 5, resp., have collected
into a piggy money-box all the small Euro coins (values 1, 2, 5, and 10 cents) that Mom
every week has given to each of them since the age of four. Now, the time has come to
break the money-box and divide its content. In order to avoid quarrels among the kids,
Mom decides that the distribution has to go with their ages, so that Tim will deserve at
least 10/8 the money John will get and John, in its turn, will receive at least 8/5 of Jims
money share. (Jim is not very happy with that, but agrees to comply with Moms rule).
The money-box gets broken and the little treasure of seven Euros and ninety Euro cents,
as resulting from the available coin set including one-hundred 1-cent coins, seventy 2-cent
coins, fifty 5-cents coins, and thirty 10-cent coins, can then be divided amongst the kids.
Note that this scenario is based on the non-transferable condition that the treasure
cannot freely be distributed amongst the brothers. The specific distribution rule, however,
does not fit the classical NTU formalization by Aumann and Peleg (1960).
On the other hand, it is easily seen that the scenario can be modeled by means of a
set of linear (in)equalities, with a few variables taking values from the set Z of integer
numbers. In this example, admissible outcomes can indeed be identified as the solutions to
the following set of mixed-integer linear (in)equalities (the three brothers Tim, John and
Jim are denoted by using the indexes 1, 2 and 3, respectively):

635

fiGreco, Malizia, Palopoli, & Scarcello





























xi = 1  i1 + 2  i2 + 5  i5 + 10  i10 , 1  i  3
11 + 21 + 31 = 100
12 + 22 + 32 = 70
15 + 25 + 35 = 50
110 + 210 + 310 = 30
x1  10/8  x2
x2  8/5  x3
i1 , i2 , i5 , i10  0, 1  i  3
xi  R, i1 , i2 , i5 , i10  Z, 1  i  3

Note that the auxiliary variables ij denote the number of coins of value j taken by
player i, the first five equalities encode restrictions on the domains of the variables as defined
by the available coin set, and the subsequent two inequalities encode Moms rule (which
can be seen, for instance, as playing the role of a central market regulation authority). 
1.2 Contribution and Organization
Despite the intuitiveness of the modeling approach adopted in Example 1.1, there is no
reference framework in the literature accounting for it, both because of the specificity of
Moms rule and because money distribution is constrained by the available coin set, so that
those allowed outcomes do not form a convex set.
Proposing and investigating a framework that may serve to model such kinds of scenarios
is the main contribution of this paper. In more detail:
 We define a formal framework for NTU games based on mixed-integer linear constraints applied to an underlying TU game, we discuss its modeling capabilities, and
we show how main solution concepts for NTU gamesin particular, core, bargaining
set, kernel, nucleolus, and Shapley valuespecialize within this novel framework.
 We analyze the impact of constraints on the basic properties of such solution concepts.
Moreover, we highlight similarities and differences featured by constrained games as
opposed to TU games, by investigating in particular whether an outcome that is stable
(under these concepts) in a TU game remains stable if constraints are issued.
 We assess the impact of adding constraints on the computational complexity underlying some of these concepts. In particular, we consider games in characteristic function
form (von Neumann & Morgenstern, 1944) within a setting where worths are given
as oracles. In this context, we discuss both the intrinsic difficulty of checking whether
a given worth distribution is in the core or in the bargaining set, and of deciding the
non-emptiness of these solutions. Complexity results for constrained games are also
compared with those characterizing TU games.
The rest of the paper is organized as follows. In Section 2, we overview some basic
notions of cooperative game theory. The formal framework of constrained games is defined
in Section 3. The properties of this novel framework are illustrated in Section 4, and its
analysis from the computational viewpoint is carried out in Section 5. A discussion and a
few concluding remarks are reported in Section 6.

636

fiMixed-Integer Constrained Coalitional Games

2. Coalitional Games
An important issue in cooperative game theory is to determine payoff distributions for the
agents in scenarios where they can collaborate by forming coalitions, in order to obtain
higher worths than by acting in isolation. In this context, one usually does not take care of
other relevant problems emerging in the coalition formation process, such as the coalition
value calculation and the coalition structure generation problemsan excellent overview of
these problems and a state-of-the-art algorithm facing the latter one can be found in the
work by Rahwan, Ramchurn, Jennings, and Giovannucci (2009).
Coalitional games have been introduced by von Neumann and Morgenstern (1944) in
order to model payoff distributions problems in scenarios where utility can be freely transferred among players. In these cases, coalitional games can be described by associating a
payoff with each possible coalition. Thus, a coalitional game with transferable utility (TU)
is a pair hN, vi, where N is a finite set of players, and v is a function (v : 2N 7 R) that
associates with every coalition S  N a real number v(S), called the worth of S.
Scenarios where utility cannot be freely transferred among players were first formalized
by Aumann and Peleg (1960). In these scenarios, games have to be described by specifying
all the possible payoff distributions for the players in each coalition, rather than by just one
(global) payoff. For any coalition S  N , let |S| denote the cardinality of S, and let RS be
the |S|-dimensional real coordinate space, whose coordinates are labeled with the members
of S; in particular, given a payoff vector x  RS , xi denotes the component associated
with the player i  S. Then, a coalitional game without transferable utility (NTU) is a
pair hN, V i, where N is a finite set of players, and V is a function associating with every
coalition S  N a set of payoff vectors V (S)  RS , also called consequences.
Note that NTU games are generalizations of TU games. In particular, according to the
standard encoding2 discussed, e.g., in the handbook edited by Aumann and Hart (2002) and
in the book by Peleg and Sudholter (2007), the TU game hN, vi will be viewed throughout
this paper as the NTU game hN, Vv i, where:


fiX
Sfi
Vv (S) = x  R fi
xi  v(S) ,  S  N.
(1)
iS

Let G = hN, V i be an NTU game. A consequence x  V (N ) is an imputation of G if
the following two properties hold (see, e.g., Peleg, 1963; Peleg & Sudholter, 2007):

(1) Efficiency: for each y  V (N ), there is a player i  N such that xi  yi this property
is also known as weak Pareto optimality; and
(2) Individual Rationality: for each player i  N , xi  max{ yi | yi  V ({i}) }.
The set of all imputations of an NTU game G is denoted by X(G). If G is actually a TU
game, i.e., G = hN, vi (or, equivalently, G = hN, Vv i), it is immediate to check that:


fiX
Nfi
X(G) = x  R fi
xi = v(N ) and xj  v({j}), j  N .
iN

2. Indeed, this encoding allows most of the solution concepts originally defined for TU games to be smoothly
generalized to the NTU frameworkas we shall discuss later in the section.

637

fiGreco, Malizia, Palopoli, & Scarcello

In particular, note that xj  v({j}) encodes the individual rationality of player j at x.
An outcome for G is an imputation taken from X(G) specifying a payoff distribution for
all the players of the game. This outcome should represent a kind of agreement amongst
players, which has to be stable with respect to the possibility that subsets of players get
an incentive to deviate from it, by forming coalitions on their own. Depending on the criterium adopted to define this concept of stability, various (solution) concepts for coalitional
games can be defined. The most relevant solution concepts for coalitional gamessuch as
the core, the bargaining set, the nucleolus, the kernel, and the Shapley valuehave been
originally defined within the TU framework (see, e.g., Osborne & Rubinstein, 1994). Several
efforts have been subsequently paid to apply these concepts within the more general NTU
framework (see, e.g., Aumann & Hart, 2002). Natural extensions have been defined in some
cases, while natural counterparts are still missing and looked for in others.
In the following, we shall provide an overview of the definitions of the basic solution
concepts for TU games and their canonical extensions to NTU games.
2.1 Core
The concept of the core goes back to the work by Edgeworth (1881). In the TU framework,
it has been formalized by Gillies (1959), and it was first extended to the NTU framework
by Aumann (1961). In fact, this is the solution concept that enjoys the most canonical
extension to the NTU case, which is the one presented next.
Let G = hN, V i be an NTU game. For any coalition S  N , a vector y  RS of
real numbers is called S-feasible if y  V (S). Let x be a consequence in RN . Then, the
pair (y, S) is an objection to x if y is an S-feasible payoff vector such that yk > xk for all
k  Sin this case, the coalition S is also said to block x via y.
Definition 2.1. The core C (G) of an NTU game G = hN, V i is the set of all imputations
x to which there is no objection; that is,
C (G) = {x  X(G) |S  N, y  V (S) such that yk > xk , k  S } .



Thus, an imputation x in the core is stable because there is no coalition whose members will receive a higher payoff than in x by leaving the grand-coalition.
The application of Definition 2.1 over TU games exactly coincides with the original
formulation by Gillies (1959). Moreover, it is easily seen that, when applied over TU
games, Definition 2.1 can be equivalently restated as illustrated next (see, e.g., Osborne &
Rubinstein, 1994). For a coalition
S  N and a payoff vector x  RN , we define x(S) as
P
the value of the expression iS xi .
Definition 2.2. The core C (G) of a TU game G = hN, vi is the set of all imputations
x  X(hN, Vv i) such that, for each coalition S  N , x(S)  v(S).


Thus, the core of a coalitional game with transferable utility and |N | players is defined
by a set of inequalities over |N | variables and, in fact, it is a polytope in RN .

638

fiMixed-Integer Constrained Coalitional Games

2.2 Bargaining Set
The concept of bargaining set was defined by Aumann and Maschler (1964), and has many
variants even within the TU context (see, e.g., Maschler, 1992). A natural extension to the
NTU framework was given by Peleg (1963), which is discussed next.
Let G = hN, V i be an NTU game, and x be a consequence in V (N ). Let S  N be
a coalition, and y be an S-feasible payoff vector (i.e., y  V (S)). The pair (y, S) is an
objection of player i against player j to x if i  S, j 
/ S, and yk > xk for all k  S.
A counterobjection to the objection (y, S) of i against j to x is a pair (z, T ) where j  T ,
i
/ T , and z is a T -feasible payoff vector such that zk  xk for all k  T \ S and zk  yk
for all k  T  S. If there does not exist any counterobjection to (y, S), we say that (y, S)
is a justified objection.
Definition 2.3. The bargaining set B(G) of an NTU game G is the set of all imputations
x to which there is no justified objection.

Note that the above definitions straightforwardly apply to TU games, and coincide for
them with the one originally proposed by Aumann and Maschler (1964). For the sake of
completeness, we just recall here that y (resp., z) is an S-feasible (resp., T -feasible) payoff
vector in the TU game hN, vi if y  Vv (S)
P(resp., z  Vv (T )) holds;
P that is, if y(S)  v(S)
(resp., z(T )  v(T ))recall that y(S) = iS yi (resp., z(T ) = iT zi ).
2.3 Nucleolus

The nucleolus is a solution concept introduced by Schmeidler (1969). Its definition is based
on the notion of excess e(S, x, V ) of a coalition S at an imputation x, which is a measure
of the dissatisfaction of S at x.
In the case of TU games (where v denotes the worth function), it is widely accepted that
the canonical definition of the excess is e(S, x, Vv ) = v(S)  x(S). Then, for each vector
x  RN , let us define (x) as the vector where the excesses associated with all coalitions
(but the empty one) are arranged in non-increasing order:
(x) = (e(S1 , x, V ), e(S2 , x, V ), . . . , e(S2|N| 1 , x, V )).
Let (x)[i] denote the i-th element of (x). For a pair of imputations x and y, we say
that (x) is lexicographically smaller than (y), denoted by (x)  (y), if there exists a
positive integer q such that (x)[i] = (y)[i] for all i < q and (x)[q] < (y)[q].
Since the excess is a measure of dissatisfaction, the imputations lexicographically minimizing the vector of the excesses are very natural candidates to be the stable outcomes
for the game. This is indeed the idea underlying the definition of the nucleolus, as it was
defined by Schmeidler (1969) for TU games.
Definition 2.4. The nucleolus N (G) of a TU game G = hN, vi is the set
N (G) = {x  X(hN, Vv i) | y  X(G) such that (y)  (x)}.



For games that do not fit the TU framework, the above definition can still be used
provided that a suitable generalization of the concept of excess is conceived. The most
639

fiGreco, Malizia, Palopoli, & Scarcello

influential approach to define excess functions for NTU games was proposed by Kalai (1975),
who axiomatized the properties that such functions should satisfy as to retain some of the
nice features of the underlying TU specifications. These properties are as follows:
1. Let x, y  RN . If xi = yi for all players i  S, then e(S, x, V ) = e(S, y, V ) holds, for
each function V ;
2. Let x, y  RN . If xi < yi for all players i  S, then e(S, x, V ) > e(S, y, V ) holds, for
each function V ;
3. Let x  RS . If there is no vector y  V (S) such that, i  S, yi > xi , then
e(S, x, V ) = 0 holds, for each function V ;
4. e(S, x, V ) is continuous jointly in x and V .
As an example, a prototypical excess function discussed by Kalai is the following:


t
, i  S .
eK (S, x, V ) = sup t  R | y  V (S) such that yi = xi +
|S|

(2)

This function coincides with the canonical excess function v(S)x(S) whenever it is applied
on TU games (Kalai, 1975).
2.4 Kernel
The kernel is a solution concept originally introduced in the TU framework by Davis and
Maschler (1965) to help to understand the properties of the bargaining set.
For a TU game hN, vi, define the surplus si,j (x) of player i against player j at an
imputation x as the value si,j (x) = maxS|iS,j / S e(S, x, Vv ) = maxS|iS,j / S (v(S)  x(S)).
Definition 2.5. The kernel K (G) of a TU game G = hN, vi is the set:
K (G) = {x  X(hN, Vv i) | si,j (x) > sj,i(x)  xj = v({j}), i, j  N, i 6= j}.



Note that the above definition for TU games is again based on the notion of excess.
Intuitively, the surplus of player i against j at x is the highest payoff that player i can
gain (or the minimal amount i can lose, if it is a negative value) without the cooperation
of j, by forming coalitions with other players that are satisfied at x; thus, si,j (x) is the
weight of a possible threat of i against j. In particular, player i has more bargaining
power than j at x if si,j (x) > sj,i (x); however, player j is immune to such threat whenever
xj = v({j}), since in this case j can obtain v({j}) even by operating alone. We say that
player i outweighs player j at x if si,j (x) > sj,i(x) and xj > v({j}). The kernel is then the
set of all imputations where no player outweighs another one.
Generalizing the kernel to NTU games is based on considering generalizations of the
excess function, as for the nucleolus. Again, an influential approach, which is recalled next,
is due to Kalai. However, it is worthwhile noticing here that other approaches have also been
proposed in the literature (see, e.g., Orshan & Zarzuelo, 2000; Peleg & Sudholter, 2007).
Indeed, differently from the solution concepts discussed so far, variations of the kernel (and
640

fiMixed-Integer Constrained Coalitional Games

related concepts, such as the prekernel, which is the focus of the extensions cited above) to
NTU games are still subject of research and debate (cf. Serrano, 1997).
Let G = hN, V i be an NTU game. We say that a payoff vector t  RN is a transfer from
player j to player i if tj  0, ti  0, and tk = 0, for each player k  N \ {i, j}. The transfer
t is justified at an imputation x, if for every real number , 0 <  < 1, the vector y = x + t
(such that yk = xk + tk , for each k  N ) is an individually rational vector in V (N ) and
(x + t)  (x)of course, an excess function for G satisfying Kalais axiomatization must
be used in order to define the excess vectors. The kernel K (G) of G is the set: K (G) =
{x  X(G) | there is no justified transfer from player j to player i at x, i, j  N, i 6= j}.
2.5 Shapley Value
The Shapley value is a solution concept introduced in the TU framework by Shapley (1953).
This concept associates with every TU game G = hN, vi a unique payoff vector (G)  RN ,
where each component (G)i , which is called the Shapley value of player i, indicates the
worth to be assigned to player i, based upon her ability in cooperation as measured by the
expected marginal contribution of player i to forming coalitions (as formalized below).
Let  be a permutation on the set N of players. For any player i, we denote by pi the
set of players preceding i in . The marginal contribution of player i to the coalition pi is
v(pi  {i})  v(pi ). If permutations are chosen uniformly at random from the set  of all
possible permutations,
P the expected marginal contribution of player i in the game G is the
value (G)i = |N1 |!  v(pi  {i})  v(pi ) or, equivalently:
(G)i =

X

SN \{i}

|S|!(|N |  |S|  1)!
(v(S  {i})  v(S)) .
|N |!

The Shapley value is the unique payoff vector satisfying the following properties, which
constitute its axiomatic characterization3 :
P
(1) Efficiency:
iN (G)i = v(N ).

(2) Symmetry: Two players i and j are symmetric if, for each S  N with i, j 
/ S,
v(S  {i}) = v(S  {j}). If players i and players j are symmetric, then (G)i = (G)j .
(3) Dummy: A player i is dummy if, for each S  N \ {i}, v(S  {i})  v(S) = v({i}). If
player i is a dummy player, then (G)i = v({i}).
(4) Additivity: Let G  = hN, wi be a TU game, and G  = hN, v + wi be the TU game such
that (v+w)(S) = v(S)+w(S) for each coalition S  N . Then, (G  )i = (G)i +(G  )i .

Note that the Shapley value might not satisfy the individual rationality, and thus it is
not necessarily an imputation. Payoff distributions that are efficient, but not necessarily
individually rational, are called pre-imputations in the literature.
Generalizing the Shapley value to the NTU framework is not straightforward. Different
extensions of the Shapley value for NTU games have been proposed. Each of them, when
3. The characterization reported here is the one that can be found most often in the literature. However,
the original axiomatic formulation of Shapley requires the carrier axiom instead of the efficiency and
dummy axioms; the two axiomatizations are equivalent (Shapley, 1953; Winter, 2002).

641

fiGreco, Malizia, Palopoli, & Scarcello

evaluated on the NTU version of a TU game, coincides with the standard Shapley value for
TU games. Here we discuss the generalization proposed by Shapley (1969) himself in the
formulation reported by McLean (2002), and we refer the interested reader to this latter
work for an extended treatment of the subject of values for NTU games, and to the paper
by Hart (2004) for a comparison between the most notable three of them.
Let G = hN, V i be an NTU game. For a vector   RN of strictly positive real numbers,
let G be the game hN, v i where
(
)
X
v (S) = sup
i zi | z  V (S) .
iS

The TU game G is said to be defined for G if v (S) is finite for each S.
Definition 2.6. Let G = hN, V i be an NTU game. A vector x  RN is a Shapley NTU
value payoff for G if there exists a vector   RN of strictly positive real numbers such
that: x  V (N ); G is defined for G; and i xi = (G )i for each player i  N . The set of
all Shapley NTU values for G is denoted by (G).

Shapley NTU values fulfill, with some adaptations, the same axioms characterizing
standard TU Shapley values. Actually, these axioms do not suffice to uniquely characterize
the NTU counterpart, and other axioms have to be issued in order to define unambiguously
the NTU Shapley value. An axiomatization for the NTU case was given by Aumann (1985).
The interested reader is referred again to the work by McLean (2002), for more on this issue.
2.6 Properties of Solution Concepts for TU Games
We conclude by recalling some well-known properties of the solution concepts discussed
above, when they are applied over TU games.
Proposition 2.7 (see, e.g., Osborne & Rubinstein, 1994). Let G = hN, vi be a TU game
such that X(G) 6= . Then:
(1) |N (G)| = 1;
(2) N (G)  K (G) (hence, K (G) 6= );
(3) K (G)  B(G) (hence, B(G) 6= );
(4) C (G)  B(G); and,
(5) C (G) 6=  implies N (G)  C (G).
Note that there is no relationship between the Shapley value and the other solution
concepts (just recall that the Shapley value is not necessarily an imputation).

3. Constrained Games via Mixed-Integer Linear (In)Equalities
Assume that a TU game G = hN, vi is given and consider the problem of modeling and
dealing with constraints to be imposed on feasible worth distributions amongst players in G.
642

fiMixed-Integer Constrained Coalitional Games

These constraints might be implied by the very nature of the domain at hand (e.g., when the
worth is not arbitrarily divisible), or because they reflect some hard preferences expressed
by the players or by some regulation authorityrecall again Example 1.1. Our approach
to encode application-oriented constraints within a classical coalitional TU game setting
is by defining a set of mixed-integer linear (in)equalities, which have to be satisfied by the
imputations of the game G. This approach is first formalized below; subsequently, we shall
illustrate its modeling capabilities and discuss its relationships with the TU framework.
We start by recalling that a mixed-integer linear (in)equality is a linear (in)equality
where some variables might be constrained to take values from the set Z of integers. For a
set LC of mixed-integer linear (in)equalities, we denote by real (LC) and int(LC) the sets of
all the variables in LC defined over R and Z, respectively. Moreover, we assume that worth
distributions can be constrained by defining inequalities via player and auxiliary variables.
A player variable has the form xi , where i  N is a player in the underlying TU game,
and it is meant to encode the worth that has to be assigned to player i in the outcomes
of the game. The (possibly empty) set of the auxiliary variables in LC is then the set
real (LC)  int(LC) \ {xi | i  N }. Auxiliary variables are sometimes useful for the modeling
purposes, as we illustrated in Example 1.1.
Let us now proceed with our formalization. Let G = hN, vi be a TU game, and recall
from Section 2 that G can be viewed as the NTU game hN, Vv i. Let LC be a set of mixedinteger linear (in)equalities. Define (LC) as the set of all the solutions to LC. Moreover, for
a coalition S  N , let (LC)[S] denote the projection of (LC) onto the subspace associated
with payoff domains for players in S; that is, a vector y with index set S belongs to (LC)[S]
if and only if there is a vector x  (LC) such that xi = yi holds, for each i  S.
Intuitively, a constrained game on LC is defined by restricting the consequences of an
underlying TU game G to those belonging to the solution space of the set LC of mixed-integer
linear (in)equalities projected onto the subspace associated with player variablesrecall
that further auxiliary variables may occur in LC. This is formalized below.
Definition 3.1 (Mixed-Integer Constrained Games). Let G = hN, vi be a TU game and
let LC be a set of mixed-integer linear (in)equalities. Then, the (mixed-integer) constrained
game G|LC is the NTU game hN, VLC i where VLC (S) = Vv (S)  (LC)[S]. That is,


fiX
Sfi
VLC (S) = x  R fi
xi  v(S) and x  (LC)[S] ,  S  N.

iS
3.1 Modeling Capabilities of Constrained Games

Constraining a TU game G via a set LC of (in)equalities that do not involve integer variables
(i.e., int(LC) = ) is an abstraction of those approaches in the literature that consider
specific sets of (in)equalities over real variables (such as Aumann & Dreze, 1974; Byford,
2007; Jiang & Baras, 2007). In particular, this capability might be exploited to:
(1) State hard preferences on the worth distributions.
As an example, consider a game G = hN, vi over the set of players N = {1, 2, 3, 4},
and where v(N ) = 10. Assume that players 3 and 4 together require to get at least a

643

fiGreco, Malizia, Palopoli, & Scarcello

half of the worth. Then, this requirement can be modeled as:

x3 + x4  5
x1 , x2 , x3 , x4  R
Moreover, by allowing integer variables, completely novel modeling capabilities emerge
in our setting w.r.t. earlier approaches. Indeed, integer variables can be used to isolate
non-convex regions, which might be needed to model specific application requirements that
are NTU in their very nature, as exemplified below.
(2) Consider alternative scenarios.
By allowing integer variables, we may model alternative preferences of the players, i.e.,
we may enforce disjunctions of preferences. For instance, consider a scenario where
either players 1 and 2 must get together no more than 3, or players 2 and 3 must get
together no more than 5. In this case, we have two constraints (i.e., x1 + x2  3 and
x2 + x3  5) and the goal is to define a set of (in)equalities prescribing that at least
one of them is satisfied. To this end, an auxiliary integer variable can be used:

x1 + x2  3 + U  y




 x2 + x3  5 + U  (1  y)
0y1



x ,x ,x  R

 1 2 3
yZ

where the constant value U is an upper bound on the worth of any coalition. Indeed,
in the case where y = 1, the constraint x1 + x2  3 + U is trivially satisfied (because U
is sufficiently large), and thus, we just enforce x2 +x3  5. Symmetrically, if y = 0, the
constraint x2 + x3  5 + U is trivially satisfied, and thus, we just enforce x1 + x2  3.
Of course, with simple manipulations, one may easily specify other kinds of alternatives, e.g., the fact that at least (or at most) k given constraints are to be satisfied.

(3) Restrict worth functions over specific domains.
When domains are required to be integer intervals, this is rather obvious. For instance,
assume that x3 should take values from the domain {4, 5, 6, 7, 8, 9, 10}. Then, we may
simply consider the following constraints:

 4  x3  10
x ,x ,x  R
 1 2 4
x3  Z

In order to model more general scenarios, we can have (as in point (2) above) mixedinteger linear (in)equalities to be defined over auxiliary variables. For instance, assume
that player 2 wants either to take the whole worth for herself (even when forming
coalitions with other players) or, whenever this is not possible, to get nothing. This
can be modeled by a few constraints, over an additional variable win fact, notice

644

fiMixed-Integer Constrained Coalitional Games

that v(N ) is a constant value for a game given at hand:

x2 = v(N )  w



0w1
x ,x ,x ,x  R


 1 2 3 4
wZ

Note that Example 1.1 basically presents a more realistic case, where several auxiliary
variables are used to restrict money distributions to the available coin set.
Now that the basic modeling capabilities of constrained games have been discussed,
in order to illustrate possible applications of the resulting framework, it is convenient to
preliminarily observe two of its properties (which are related to the use of integer variables).
First, it is easy to check that, over constrained games, we may deal with imputation
sets of arbitrary sizes.4
Proposition 3.2. Let G = hN, vi be a TU game and let X  X(G) be an arbitrary finite
set of imputations. Then, there is a finite set of constraints LC such that X(G|LC ) = X .
In addition, integer variables might be used to succinctly specify exponentially many
imputations via polynomially many (in)equalities.
Proposition 3.3. There exists a class C = {G|nLC }n>0 of constrained games such that each
game G|nLC is over n + 1 players, LC consists of 2  n + 1 inequalities, and |X(G|LC )| = 2n .
We believe that the setting emerging from the above properties is rather appealing
from a knowledge representation perspective. Indeed, one may exploit constrained games
to naturally model scenarios where non-transferable conditions emerge, by devising very
compact specifications of the desired restrictions on how utilities may be transferred among
coalition members. In fact, various circumstances can be envisaged where the usage of
constrained games is a natural choice; for instance, whenever the worth to be distributed
among the agents comes as a set of indivisible goods, as exemplified below.
Example 3.4 (Distributing indivisible goods). A certain region of the country is
famous for hosting several producers of two kinds of goods, named  and . For each
producer i  {1, . . . , n}, let i and i denote the quantity of  and  pieces produced by i,
respectively. By assembling together one piece  and one piece , a novel kind of indivisible
good can be obtained and, in fact, commercializing the assembled product is a much more
advantageous business than selling  and  separately. Therefore, an agreement is found
amongst producers in the area in order to assemble the pieces of  and  that are overall
available, provided that the resulting units of the assembled product are (fairly) distributed
amongst the involved producers, which would like to independently commercialize them.
This scenario can be easily modeled within our framework as follows. First, we associate
with every coalition S  {1, . . . , n}, the number of pieces of the assembled product that S
can produce. Thus, we just define:
X
X
v(S) = min(
i ,
i ).
iS

iS

4. For the sake of exposition, proofs of the propositions stated in this section are reported in the Appendix.

645

fiGreco, Malizia, Palopoli, & Scarcello

Then, since the assembled product is indivisible, any possible worth distribution is a
vector of non-negative integers, which can immediately be modeled via the following set of
constraints LC = {xi  0, xi  Z, 1  i  n}. In particular, (LC) is not a convex region,
so that earlier modeling perspectives on NTU games, such as those present in the handbook
edited by Aumann and Hart (2002), do not apply here.

There are cases, however, where the worth might practically be assumed to be divisible,
but specific constraints regulate its actual distribution. Notably, even in these cases, integer
variables may play a crucial role as illustrated next.
Example 3.5 (Service composition). Assume that a service T can be acquired for 100
Eurosfor the sake of simplicity, we assume that money is divisible, for otherwise worth
distributions might simply be restricted over a discrete domain as in Example 3.4 or in
Example 1.1. Supplying the service T implies executing m tasks, named t1 , . . . , tm .
Assume also that there is a set {1, . . . , n} of agents, each one capable of carrying out
some of those m tasks, and let sij denote the ability of agent i to perform the task tj (sij = 1
means that agent i is able to perform tj , whereas sij = 0 means that she is not capable to
do so).PThus, a coalition S  {1, . . . , n} is capable of supporting the service T in the case
where iS sij  1, for each j  {1, . . . , m}.
Assume, moreover, that in order to complete T , not only all of its tasks must be completed, but agents contributing to T must be able to exchange some partial results returned
by performing required tasks. Establishing a communication infrastructure guaranteeing
the needed result-transfers to take place has a specific cost for each coalition S, which we
denote by com(S) < 100. Hence, the amount of money that might finally be distributed
amongst players in S is described by the following worth function:

P
i
100  com(S) if
iS sj  1, j  {1, . . . , m}
v(S) =
0
otherwise.
Note that the above scenario defines a classical TU game G = h{1, . . . , n}, vi. However,
things may be significantly different if we assume that each agent i has to sustain an internal
cost, say cij , whenever actually performing the task tj , and that, hence, she may decide not
to perform the task at all, if it is not convenient. Indeed, in this case, letting ji  {0, 1}
be a variable denoting whether i is actually performing tj , it is P
natural to state that the
i
i
total internal cost for agent i (which is given by the expression m
j=1 j  cj ) should not
exceed what the agent gets from the worth distribution. Hence, utilities cannot be freely
distributed and, for a proper modeling of this more realistic scenario, the game has to be
enriched with the following set of constraints:
X

ji = 1, j  {1, . . . , m}




iN



m

X



ji  cij , i  {1, . . . , n}
 xi 
j=1
LC =



0  ji  sij , i  {1, . . . , n}, j  {1, . . . , m}






x1 , . . . , xn  R



 i
j  Z, i  {1, . . . , n}, j  {1, . . . , m}
646

fiMixed-Integer Constrained Coalitional Games

With respect to this formalization, it is worthwhile noting that if (LC) is empty then the
service cannot be provided at all, and indeed X(G|LC ) would be empty in its turn. Otherwise,
i.e., if (LC) 6= , the imputations of G|LC correspond to those worth distributions associated
with some legal staffing for the tasks, rather than to all arbitrary possible worth distributions
(as it would be in the plain TU case).
It is worthwhile contrasting the above formulation with an alternative TU one, where
the constraints in LC are directly encoded in the definition of worth function, instead of
using a separate component thereof, as done in the NTU framework we are proposing here.
For instance, one may add to the condition for v(S) = 100  com(S) the requirement
that there exists an element x  (LC) such that for each task tj , there is a player i  S
with ji 6= 0 (in x). This way, we can ensure that the payoff 100  com(S) is assigned
to each coalition S which is formed by players that can perform some task conforming
with cost constraints, and that can jointly complete T this refined modeling perspective
is exactly the one underlying the class of linear programming games (see, e.g., Owen, 1975).
However, this approach would not prescribe how the payoff 100  com(S) has to be actually
distributed amongst the players in S. In fact, while focusing on accurately modeling the
worth function, it cannot guarantee that the outcome of the game (according to any chosen
solution concept) fulfils the desired constraints on the distribution of payoffs for the single
players. In other words, using constraints in the definition of the worth function may be
useful in certain cases for more careful modeling purposes, but cannot in general replace
the use of external constraints to actually constrain the allowed worth distributions. 
As an important remark, we note here that the structure of the above example may
well be used as a guideline in the formalization of other application scenarios. Indeed,
the basic idea is to use mixed-integer linear constraints to define solutions for combinatorial problems associated with feasible worth distributions (reflecting, e.g., the costs of
such solutions). Thus, while we have contextualized the approach to the case of a staffing
problem, very similar encodings can be used to define constrained games suited to deal with
scheduling and planning problems, just to cite a few.
3.2 A Closer Look at Constrained Games
We can now resort to the presentation of the framework of constrained games by analyzing the structure of their consequences, and the role played by the individual rationality
requirement in this context. This analysis will provide important bases for our subsequent
treatment of the analytical and the computational properties of NTU solution concepts as
applied on constrained games.
3.2.1 Consequences in Constrained Games
In order to understand the nature of constrained games, it is convenient to take a closer
look at the structure of the function VLC . In fact, while in principle an NTU game hN, V i
does not impose any requirement on the function associating a set of consequence V (S) with
each coalition S  N , those NTU games that attracted much attention in the literature do
not actually allow arbitrary consequences to be specified (Aumann & Hart, 2002). Indeed,
the sets of consequences are usually required to satisfy some additional conditions, which
are (de facto) conceived as to guarantee that nice properties hold over the solution concepts
647

fiGreco, Malizia, Palopoli, & Scarcello

of interest. Some of the assumptions that have been most often considered in the literature
(not necessarily required to simultaneously hold) are recalled next. For each S  N , V (S)
might be required to be:
(1) (Upper) Bounded: there is a real number a  R such that for each x  V (S), and for
each i  S, xi  a holds;
(2) Closed: V (S) contains its own boundaries;
(3) Compact: V (S) is both closed and bounded;
(4) Comprehensive: if x  V (S), y  RN and (i  S)(yi  xi ), then y  V (S);
(5) Convex: for each pair x, y  V (S), and for each real number t, 0 < t < 1, the vector
(1  t)x + ty belongs to V (S).
(6) Non-empty: |V (S)| > 0.
In the case of constrained games, we do not explicitly ask for the above requirements
to be satisfied, thereby giving rise to a setting with very powerful modeling capabilities (as
we discussed in Section 3.1). The differences between constrained games and classical NTU
games are illustrated next.
Consider the function VLC associated with a constrained game G|LC . The first difference
concerns property (1), because VLC (S) is not required to be bounded (as for the TU case,
where individual payoffs for players in S are not bounded in general, since the only requirement is that their sum does not exceed the worth v(S) associated with Ssee Equation (1)
in Section 2). Actually, this is not a substantial difference given that, in any possible worth
distribution for G|LC corresponding to any solution concept illustrated in Section 2, the
payoff of each player is bounded.
Similarly, it is easy to see that there might be cases where property (2) does not hold
in the context of constrained games. Indeed, VLC (S) might be not closed whenever LC
contains some strict inequality that excludes the boundary of VLC (S). However, it is known
that such cases are undesirable for some solution concepts, and hence we shall consider
constraints based on non-strict inequalities only. Property (3) is the combination of the
first two properties, and thus the above lines of reasoning still apply.
The differences in the remaining three properties, instead, do characterize the framework
of constrained games and are at the basis of its modeling capabilities. In fact, the ability to
handle sets of consequences that are not comprehensive and convex, and that are possibly
empty for some coalition, is an important peculiarity of constrained games from a knowledge
representation perspective. Indeed, we may lose comprehensiveness each time a constraint
on the payoff distribution is given which states that some players are required to get at least
a certain worth; we may lose convexity (as well as comprehensiveness) each time integrality
constraints are involved. Moreover, we may deal with an empty set of consequences for
some coalition S whenever there is no feasible way to distribute the worth associated with
S according to the constraints that players in S must satisfy.
Example 3.6. Consider the TU game G = hN, vi such that N = {1, 2, 3}, v({1, 2, 3}) = 3,
and v(S) = 0 for each S  {1, 2, 3}. Consider a scenario where the worth in G is restricted
648

fiMixed-Integer Constrained Coalitional Games

to be an integer value (i.e., payoff distributions are taken from Z{1,2,3} ), and where players
1 and 2 require to get at least 2. These constraints can be modeled as follows:

x1 + x2  2
LC =
x1 , x2 , x3  Z
Note that (LC)[{1, 2, 3}] = {x  Z{1,2,3} | x1 + x2  2}, (LC)[{1, 2}] = {x  Z{1,2} |
x1 +x2  2}, (LC)[{1, 3}] = Z{1,3} , (LC)[{2, 3}] = Z{2,3} , (LC)[{1}] = Z{1} , (LC)[{2}] =
Z{2} , and (LC)[{3}] = Z{3} . Then, the constrained game G|LC = hN, VLC i is such that:
VLC ({1, 2, 3}) =
=
VLC ({1, 2})
=
VLC ({1, 3})
=
=
VLC ({2, 3})
VLC ({i})
=

{x  R{1,2,3} | x1 + x2 + x3  3}  (LC)[{1, 2, 3}] =
{x  Z{1,2,3} | x1 + x2 + x3  3, x1 + x2  2};
{x  R{1,2} | x1 + x2  0}  (LC)[{1, 2}] = ;
{x  R{1,3} | x1 + x3  0}  (LC)[{1, 3}] = {x  Z{1,3} | x1 + x3  0};
{x  R{2,3} | x2 + x3  0}  (LC)[{2, 3}] = {x  Z{2,3} | x2 + x3  0};
{x  R{i} | xi  0}  (LC)[{i}] = {x  Z{i} | xi  0}; (i  {1, 2, 3})

Despite the very simple constraints considered for G, it is immediate to check that (e.g.)
VLC (N ) is not comprehensive and not convex, and that VLC ({1, 2}) is empty. Indeed, the
integrality constraints immediately lead to loose comprehensiveness and convexity. Moreover, the fact that players 1 and 2 require to get at least 2 implies that the coalition {1, 2}
will never form to deviate from the grand-coalition, given that these two players cannot
guarantee themselves any worth when acting without player 3 (indeed, v({1, 2}) = 0). 
3.2.2 Individual Rationality in Constrained Games
A further important issue to be pointed out for constrained games is related to the individual
rationality requirement over the set of imputations. Let G = hN, V i be an NTU game, and
recall from Section 2 that any imputation x  X(G) must be such that for each player
i  N , xi  max{ yi | yi  V ({i}) }.
Consider a constrained game G|LC where G = hN, Vv i is the underlying TU game. By
Definition 3.1, the set VLC ({i}) coincides with Vv ({i})  (LC)[{i}]. Then, because of the individual rationality requirement, for each player i, xi  max{ yi | yi  Vv ({i})(LC)[{i}] }.
Note that a special case occurs when VLC ({i}) = Vv ({i})  (LC)[{i}] = . In this case,
indeed, max{ yi | yi  VLC ({i}) } is not defined (as a real value). An approach might be
therefore to observe that the game is over-constrained, and then stop the analysis. This
approach is, in fact, consistent with several NTU formalizations requiring that the set of
consequences is non-empty, for each possible coalition (see Section 3.2.1).
However, in Example 3.6 we have already pointed out that empty sets of consequences
may naturally emerge from constrained games, because VLC (S) =  reflects the fact that
coalition S cannot form to deviate from the grand-coalition, for there is no worth distribution
that can be in principle granted to its members alone (according to the underlying TU
game), and that satisfies the constraints at hand. Consequently, a finer-grained perspective
should be considered to deal with the individual rationality requirement, in this special case
where VLC ({i}) = , for some player i  N .
The basic observation is that VLC ({i}) =  necessarily implies that xi > v({i}) holds, for
each imputation x  VLC (N ). Thus, in these extreme scenarios, the individual rationality
649

fiGreco, Malizia, Palopoli, & Scarcello

constraint is conceptually satisfied (though formally undefined) for each possible imputation
x, since constraints in LC require xi to be larger than v({i}). Technically, we stress here that
the same conclusion is implied by defining max{} = , which is the standard extension
of max over empty sets.
In the light of the above perspective, we can show that individual rationality is preserved when constraints are added to a given TU game.
Proposition 3.7. Let G = hN, vi be a TU game and let x be a payoff vector that is
individually rational w.r.t. G (i.e., xi  v({i}), for each player i  N ). Then, for each set
LC of constraints, x is individually rational w.r.t. the constrained game G|LC .

4. Solution Concepts for Constrained Games
Constrained coalitional games are special cases of NTU games, and therefore they inherit
from them the various solution concepts we have discussed in Section 2. Thus, for a constrained (and, as such, NTU) game G|LC , it is of interest to compute the core, the bargaining
set, the nucleolus, the kernel, and the Shapley value. In this section, we will study the properties of these concepts, by highlighting similarities and differences featured by constrained
games as opposed to TU games.
In a nutshell, we will show that the properties of TU games stated in Proposition 2.7
still hold over constrained games for all solution concepts, but for the bargaining set that
might be empty in some games. Moreover, the portion of the core of a TU game G that
satisfies all the constraints is preserved, in the sense that it is a subset of the core of
the constrained game G|LC built on top of G. On the other hand, for the other solutions
concepts, the preservation property holds in special cases only.
Before illustrating our results, it is useful to state a property relating the imputation
set of a constrained game with the imputation set of the underlying TU game.
Proposition 4.1. Let G|LC be a constrained game where G = hN, vi.
(LC)[N ]  X(G|LC ).

Then, X(G) 

Proof. Let x be a payoff vector in X(G)  (LC)[N ]. Since x  X(G) then x  Vv (N ).
We are also assuming that x  (LC)[N ] and hence we have that x  VLC (N )recall, by
Definition 3.1, that VLC (N ) = Vv (N )  (LC)[N ]. Being x  X(G), x is also efficient w.r.t.
G, meaning that for each y  Vv (N ), there is a player i  N with xi  yi . Moreover, since
VLC (N )  Vv (N ), x is also efficient w.r.t. G|LC . Finally, by Proposition 3.7, we know that x
is individually rational w.r.t. G|LC . Thus, x  X(G|LC ).
Based on the above result, to show that an imputation x  X(G) also belongs to X(G|LC ),
in the following we shall just show that x satisfies the constraints in LC, thereby avoiding
to explicitly reason on the efficiency and the individual rationality of x.
4.1 Relationships Among Solution Concepts
We start our analysis by investigating whether the properties of the basic solution concepts
(as they appear from Proposition 2.7) are preserved in the setting of constrained games.

650

fiMixed-Integer Constrained Coalitional Games

4.1.1 Counterparts of Proposition 2.7.(1) and Proposition 2.7.(2)
Let us begin by focusing on the first two properties in Proposition 2.7, which pertain to the
nucleolus. In the TU framework, the nucleolus always consists of exactly one imputation.
In the constrained framework, the properties of this solution concept are intimately related
to the closeness of (LC) (and, in turn, of X(G|LC )), i.e., to whether (LC) contains its
own boundaries. Recall from Section 3 that (LC) might not be closed only due to the
occurrence of some strict inequalities in LC.
Proposition 4.2. There exists a constrained game G|LC (with int(LC) = ) such that
X(G|LC ) 6=  and where N (G|LC ) =  (for the excess function eK in Equation (2) on
page 640).
Proof. Consider the game G over players {1, 2}, where v({1, 2}) = 1 and v({1}) = v({2}) =
0. Given the constraint LC = {x1 < 12 , x1  R}, one may note that X(G|LC ) 6= . Indeed,
observe that max{x1 | x1  VLC ({1})} = max{x2 | x2  VLC ({2})} = 0, since VLC ({i}) =
Vv ({i})  (LC)[{i}] = {xi  R{i} | xi  0}  (LC)[{i}] = {xi  R{i} | xi  0}, for
each i  {1, 2}. Thus, a payoff vector x  X(G|LC ) is just required to satisfy x1  0 and
x2  0, in order to be individually rational. In particular, we claim that X(G|LC ) = {x 
R{1,2} | x1 + x2 = 1, x1 < 12 , x1  0, x2  0}. Indeed, any vector x  VLC (N ) = {x  RN |
x1 + x2  1, x1 < 12 } such that x1 < 12 and x2 < 12 is not efficient, given that there is a
vector y  VLC (N ) such that x1 < y1 < 12 and x2 < y2 < 12 , with y1 + y2 < 1. Moreover,
any vector x  VLC (N ) such that x1 < 12 , x2 > 12 , and x1 + x2 < 1 is also not efficient,
given the existence of a vector y  VLC (N ) such that x1 < y1 = x1 + 1x22 x1 < 12 and
x2 < y2 = x2 + 1x22 x1 , with (therefore) y1 + y2 = 1.
Consider now an imputation x with x1 + x2 = 1 and x1 < 12 (and hence x2 > 12 ).
Then, we can always build an imputation y 6= x such that y1 = x1 + ( 12  x1 )/2 > x1 and
y2 = 1  y1 < x2 ; just notice here that y1 < 12 holds. For this new imputation, it is the case
that (y)  (x) holds w.r.t. the excess function eK in Equation (2). Indeed, by recalling
that VLC ({i}) = {xi  R{i} | xi  0} and that xi  0 and yi  0 hold, for each i  {1, 2}, we
have (x) = (0, x1 , x2 ) and (y) = (0, y1 , y2 ). Thus, there is no imputation x that
belongs to N (G|LC ), i.e., N (G|LC ) = . Note that (LC) is not closed.
In practical applications of linear programming, one may deal with non-strict inequalities
only (see, e.g., Papadimitriou & Steiglitz, 1998); in these cases (i.e., whenever X(G|LC ) is
closed and hence compact, since it is always bounded), the nucleolus is not empty. This
property was observed to hold by Kalai (1975) along with the relationship of the nucleolus
with the kernel. These properties can be restated in our context as follows.
Proposition 4.3 (cf. Kalai, 1975). Let G|LC be a constrained game with X(G|LC ) 6= .
Then,
(1) if X(G|LC ) is compact, then |N (G|LC )|  1;
(2) N (G|LC )  K (G|LC ) (hence, K (G|LC ) 6=  whenever X(G|LC ) is compact).
In the following, examples and counterexamples will be built avoiding the use of strict
inequalities.
651

fiGreco, Malizia, Palopoli, & Scarcello

4.1.2 Counterparts of Propositions 2.7.(3), (4), and (5)
Let us now move to analyze the counterpart of Proposition 2.7.(3). To this end, we first
notice that, unlike in the TU case, the bargaining set can sometimes be empty.
Proposition 4.4. There exists a constrained game G|LC (with int(LC) = ) such that
X(G|LC ) 6=  and B(G|LC ) = .
Proof. Consider the TU game G over players {1, 2, 3, 4}, whose worths are as follows:
v({1, 2, 3, 4}) = 3, v({1, 2}) = 2, v({2, 3, 4}) = 3, v({1, 3, 4}) = 3, v({2}) = 1, and v(S) = 0
for any other coalition S  {1, 2, 3, 4}. Consider moreover the following set of constraints:

x1 + x2 + x3 + x4 = 3




x
 2 + x3 + x4 = 3
x1 + x3 = 1
LC =


x + x4 = 1


 1
x1 , x2 , x3 , x4  R

Let x be the payoff vector with x1 = 0 and x2 = x3 = x4 = 1. Observe that x satisfies
the constraints in LC. Moreover, x is an imputation of X(G); thus, by Proposition 4.1, x
belongs to X(G|LC ). In fact, x is the only vector in (LC) and, therefore, it is the only
imputation in X(G|LC ). Thus, to prove that B(G|LC ) = , we have just to show that x is
not contained in B(G|LC ). To this end, consider the objection (y, {1, 2}) of player 1 against
player 3, where y1 = 13 and y2 = 53 . Note that y1 + y2 = v({1, 2}) = 2, y2 > 1 and y1 > 0,
and thus y is {1, 2}-feasible. Moreover, recall that v({3}) = v({3, 4}) = v({2, 3}) = 0. It
follows that counterobjections of 3 against 1 to (y, {1, 2}) may be only constructed over
the coalition {2, 3, 4}. Assume that (z, {2, 3, 4}) is one such a counterobjection. For player
2, which belongs to the intersection of the two coalitions {1, 2} and {2, 3, 4}, z2  y2 > 1
holds. Because of the constraint z2 + z3 + z4 = 3, this entails z3 + z4 < 2. However, this
is impossible since we should have also z3  x3 = 1 and z4  x4 = 1. Thus, there are
no possible counterobjections to the objection (y, {1, 2}) to x. It follows that x does not
belong to B(G|LC ) and, hence, B(G|LC ) = , even though X(G|LC ) 6= .
As a consequence, we derive that the counterpart of Proposition 2.7.(3) does not hold
over constrained games. Indeed, we may just consider the game G|LC defined in the proof
of Proposition 4.4 and observe that, since X(G|LC ) 6= , by Proposition 4.3, we know that
K (G|LC ) 6= .
Corollary 4.5. There is a constrained game G|LC (with int(LC) = ) such that B(G|LC ) = 
while K (G|LC ) 6=  (and thus K (G|LC ) 6 B(G|LC )).
Below we complete the picture pertaining to the bargaining set, by showing that the
core is always included in it. This provides the counterpart of Proposition 2.7.(4).
Proposition 4.6. Let G|LC be a constrained game. Then, C (G|LC )  B(G|LC ).
Proof. Consider an imputation x  C (G|LC ) and assume by contradiction that x 
/ B(G|LC ).
By this, there must exist an objection (y, S) to x. Therefore, it must be the case that y is an
S-feasible payoff vector in G|LC and yk > xk , for each k  S. This implies that x 
/ C (G|LC ):
a contradiction. Thus, x  B(G|LC ).
652

fiMixed-Integer Constrained Coalitional Games

Figure 1: Illustration of the Solution Concepts in Example 4.8.
We finally stress that the counterpart of Proposition 2.7.(5) is already known from the
work by Kalai (1975), and can be restated in the settings of constrained games as follows.
Proposition 4.7 (cf. Kalai, 1975). Let G|LC be a constrained game. Then, C (G|LC ) 6= 
implies N (G|LC )  C (G|LC ).
4.2 Preservation of Solution Concepts
We continue our investigation by turning to the problem of assessing whether an outcome
that is stable (under some solution concept) in a TU game remains stable when constraints
are issued. A crucial issue here is to what extent the imputation set is affected by the
constraints imposed over the game. This issue is illustrated next.
Example 4.8. Consider the TU game G = hN, vi where N = {1, 2}, v({1, 2}) = 2, and
v({1}) = v({2}) = 0. It is immediate to check that X(G) = {x  R{1,2} | x1 + x2 = 2  x1 
0  x2  0}. The solution concepts for G are as follows (see Figure 1 for an illustration):
Core. For any imputation x  X(G) and for each coalition S  {1, 2}, it is the case that
x(S)  v(S). Thus, C (G) = X(G).
Bargaining Set. Since C (G)  B(G) (recall Proposition 2.7) and since B(G)  X(G), we
immediately have that B(G) = C (G) = X(G).
Nucleolus. Let x  X(G) be an imputation. Considering the standard excess function
for TU games, we have that either (x) = (0, x2 , x1 ) or (x) = (0, x1 , x2 ),
depending on whether x1  x2 or x2 > x1 . Indeed, just recall that v({1, 2}) =
x({1, 2}) = 2 and v({1}) = v({2}) = 0. Thus, the lexicographically minimum excess
vector is obtained at the imputation x such that x1 = x2 = 1, i.e., N (G) = {x}.
Kernel. Since N (G)  K (G) (recall Proposition 2.7), we have that x  K (G). Consider
now an imputation x  X(G) such that x 6= x. Assume that x1 > 1 (the same line
of reasoning applies to the case where x2 > 1), and thus x2 < 1. For the standard
excess function on TU games, s1,2 (x) = x1 and s2,1 (x) = x2 are the surpluses at x,
653

fiGreco, Malizia, Palopoli, & Scarcello

because v({1}) = v({2}) = 0. Then, s2,1 > s1,2 holds, and in order to have x  K (G),
it should be x1 = v({1}) = 0, which is not the case, because x1 > 1. It follows that
K (G) = {x}.
Shapley Value. Note that the two players of G are symmetric and hence their Shapley
value must be the same. Thus, (G) = (1, 1).
Now, consider the constraints LC = {x1 +x2  1, x1 , x2  R}. Then, it is easily checked that
X(G|LC ) = {x  R{1,2} | x1 + x2 = 1  x1  0  x2  0}, and hence X(G)  X(G|LC ) = . By
applying the same line of reasoning as above (and by considering Kalais excess function in
Equation (2) for the nucleolus and the kernel), we derive that C (G|LC ) = B(G|LC ) = X(G|LC )
and N (G|LC ) = K (G|LC ) = {y}, where y1 = y2 = 12 (see, again, Figure 1).
Moreover, as for the Shapley NTU values of G|LC , note that only vectors  = (1 , 2 )
with 1 = 2 =  > 0 are such that G|LC  is definedfor
every vector
P G|LC . In fact, for 	
 = (1 , 2 ) with 1 6= 2 the value v|LC  (N ) = sup
iN i zi | z  V (N ) is infinite.
Indeed, in pre-imputations players are not necessarily individually rational, and hence in
this game one player may get an unbounded negative value, as long as the other one gets
an unbounded positive value such that their sum is 2. Now, for every  = (, ), the worth
function of the TU game G|LC  is v|LC  ({1}) = v|LC  ({2}) = 0, and v|LC  (N ) = . Since
the two players are symmetric, the Shapley values of this family of games are of the form
(G|LC  ) = ( 2 , 2 ). Therefore, no consequence x  V |LC (N ) different from ( 12 , 12 ) admits a
vector  = (1 , 2 ), with 1 = 2 , such that i xi = (G|LC  )i for both players 1 and 2. We
conclude that the singleton {y} is also the set of all Shapley NTU values of G|LC .
Thus, all the solutions concepts for the constrained game G|LC are completely unrelated
to those of G.

Note that, in the above example, the fact that no solution concept is preserved is not
by chance. Indeed, recall that core, bargaining set, nucleolus, and kernel are defined as
refinements of the set of all possible imputations. Therefore, in the extreme scenario where
X(G)  X(G|LC ) =  holds (for a constrained game G|LC built on top of the TU game G),
none of these solution concepts can be preserved.
Fact 4.9. Let G|LC be a constrained game such that X(G)  X(G|LC ) = . Then,
(1) C (G)  C (G|LC ) = ;
(2) B(G)  B(G|LC ) = ;
(3) N (G)  N (G|LC ) = ; and,
(4) K (G)  K (G|LC ) = .
Moreover, recall that Shapely NTU values are refinements of the set of all possible payoff
distributions associated with the grand-coalition (and, in particular, of the pre-imputations
for TU games). Thus, if (G) 6 VLC (N ) (as in Example 4.8), this solution concept cannot
be preserved. In general, since (G) is a pre-imputation, the following holds.
Fact 4.10. Let G|LC be a constrained game, with G = hN, vi. Assume that VLC (N )  {x 
Vv (N ) | x is efficient } = . Then, (G) 6 (G|LC ).
654

fiMixed-Integer Constrained Coalitional Games

In the light of the above observations, it is however of interest to analyze whether
preservation properties hold with respect to (pre)imputations of both G and G|LC .
As an example, it is of interest to establish the relationship between payoff vectors in
C (G) X(G|LC ) (i.e., vectors that are in the core of the TU gameand thus are imputations
for this gameand that are also imputations for the constrained game) and payoff vectors
in C (G|LC )  X(G) (i.e., vectors that are in the core of the constrained gameand thus are
imputations for this gameand that are also imputations for the TU game). Exploring
these relationships, for each solution concept, is addressed in the rest of this section.
4.2.1 Core
Our first result concerns the core, and shows that imputations that are in the core of the
TU game and satisfy the constraints are also in the core of the resulting constrained game.
Proposition 4.11. Let G|LC be a constrained game. Then, C (G)  X(G|LC )  C (G|LC ) 
X(G).
Proof. Let G = hN, vi be a TU game, and recall from Section 2 that G can be equivalently
viewed as the NTU game hN, Vv i. Assume that x is a payoff vector in C (G), and hence in
X(G). Then, there is no coalition S  N and no vector y  Vv (S) such that yi > xi , i  S.
By Definition 3.1, for the NTU game G|LC = hN, VLC i, it is the case that VLC (S)  Vv (S),
for each S  N . Therefore, there is no coalition S  N and no vector y  VLC (S) such that
yi > xi , i  S. That is, if x  X(G|LC ), then x belongs to C (G|LC ).
However, the above inclusion can be strict in some cases, even if no imputation is affected
by the constraints, i.e., even if X(G) = X(G|LC ).
Proposition 4.12. There exists a constrained game G|LC (with int(LC) = ) such that
X(G) = X(G|LC ), C (G) =  and C (G|LC ) 6= . Thus, C (G)  X(G|LC )  C (G|LC )  X(G).
Proof. Consider the TU game G = hN, vi such that N = {1, 2, 3}, v({1}) = 1, v({2}) = 1,
v({3}) = 2, v({1, 2}) = 3, v({1, 3}) = 0, v({2, 3}) = 0, and v({1, 2, 3}) = 4. Notice that
X(G) = {x} with x1 = 1, x2 = 1, and x3 = 2; and that C (G) = . In particular, for
the latter equality, consider the pair (y, {1, 2}) such that y1 = y2 = 32 . Since y({1, 2}) =
v({1, 2}), y1 > x1 and y2 > x2 , we have that (y, {1, 2}) is an objection to x, which therefore
does not belong to C (G).
Consider now the following set of constraints:

x1 + x2  2
LC =
x1 , x2  R
It is easily seen that x satisfies LC. Thus, x  X(G|LC ) holds by Proposition 4.1. Moreover,
since (LC)[{i}] = R{i} holds for each player i  N , because there is no constraint on
worths of singleton coalitions, the individual rationality constraint on G|LC prescribes that
for each x  X(G|LC ): x1  v({1}) = 1, x2  v({2}) = 1, and x3  v({3}) = 2. Since
v({1, 2, 3}) = 4, x is in fact the only imputation in X(G|LC ). Thus, X(G) = X(G|LC ).
To conclude the proof, let us now observe that, in the constrained game G|LC , there is
no {1, 2}-feasible vector z with z1 > x1 and z2 > x2 ; indeed, just observe that z1 + z2  2
holds because of the constraints, while x1 + x2 = 2. That is, there is no objection to x,
which is therefore an imputation in C (G|LC ).
655

fiGreco, Malizia, Palopoli, & Scarcello

4.2.2 Bargaining Set
As far as the bargaining set is concerned, we can show that there are constrained games
whose bargaining set is completely unrelated with that of the underlying TU games. This
is because objections and counterobjections are not necessarily restricted to the set of
the possible imputations. Thus, constraints may radically alter the feasibility properties
of certain payoff vectors, yet without affecting the imputation set. This is shown in the
following two propositions.
Proposition 4.13. There exists a constrained game G|LC (with int(LC) = ) such that
X(G) = X(G|LC ), and B(G)  X(G|LC ) 6 B(G|LC )  X(G).
Proof. Consider the TU game G = hN, vi such that N = {1, 2, 3, 4, 5}, v({1, 2, 3, 4, 5}) = 8,
v({2, 3, 4}) = 8, v({1, 3, 4}) = 7, v({1, 2}) = 2, v({5}) = 1, and v(S) = 0 for each other
coalition S  N . Consider the imputation x such that x1 = 0, x2 = 1, x3 = 3, x4 = 3, and
x5 = 1. We claim that x  B(G). Indeed, let (y, S) be an objection to x. This objection can
be carried out through three different coalitions, each of them having a counterobjection:
 First, we can have S = {2, 3, 4}, y2 > x2 = 1, y3 > x3 = 3, y4 > x4 = 3, and y2 + y3 +
y4  v({2, 3, 4}) = 8. In this case (y, S) is an objection against player 1 or against
player 5. In the former case, (z, {1}) with z1 = x1 = 0 is a trivial counterobjection to
(y, S); in the latter case, (z, {5}) with z5 = x5 = 1 is a counterobjection to (y, S).
 Second, we can have S = {1, 3, 4}, y1 > x1 = 0, y3 > x3 = 3, y4 > x4 = 3, and
y1 + y3 + y4  v({1, 3, 4}) = 7. In this case, (y, S) is an objection of some player in S
against player 2 or against player 5. As we observed above, (z, {5}) with z5 = x5 = 1
is a trivial counterobjection to any objection against 5. Thus, let us assume that
(y, S) is an objection against player 2. If (y, S) is an objection of player 3 or 4,
we may just consider the pair (z, {1, 2}) with z1 = y1 and z2 = x2 . Indeed, note
that y1 < 1 holds and, thus, z1 + z2 < 1 + x2 = 2 = v({1, 2}). Therefore, z is
{1, 2}-feasible, and (z, {1, 2}) is a counterobjection to (y, S). On the other hand, if
(y, S) is an objection of player 1 against player 2 to x, we may consider the pair
(w, {2, 3, 4}) such that w2 = x2 , w3 = y3 , and w4 = y4 . Note that y3 + y4 < 7 and,
thus, w2 + w3 + w4 < x2 + 7 = 1 + 7 = v({2, 3, 4}). Then, w is {2, 3, 4}-feasible, and
(w, {2, 3, 4}) is a counterobjection to (y, S).
 Finally, we can have S = {1, 2}, y1 > x1 = 0, y2 > x2 = 1, and y1 +y2  v({1, 2}) = 2.
In this case, (y, S) is an objection of some player in S against 3, 4, or 5. Let us consider
the first two cases, since (z, {5}) with z5 = x5 = 1 is a trivial counterobjection to
objections against 5. If (y, S) is an objection of player 1 (against player 3 or 4), we
may consider the pair (z, {2, 3, 4}) such that z2 = y2 , z3 = x3 , and z4 = x4 . Note that
y2 < 2 and, thus, z2 +z3 +z4 < 2+x3 +x4 = 2+6 = v({2, 3, 4}) = 8. Hence, (z, {2, 3, 4})
is a counterobjection to (y, S). If (y, S) is an objection of player 2 (against player 3 or
4), we may consider the pair (w, {1, 3, 4}) such that w1 = y1 , w3 = x3 , and w4 = x4 .
Note that y1 < 1 and, thus, w1 + w3 + w4 < 1 + x3 + x4 = 1 + 6 = v({1, 3, 4}) = 7.
Hence, (w, {1, 3, 4}) is a counterobjection to (y, S).

656

fiMixed-Integer Constrained Coalitional Games

Consider now the following set of constraints:

x2 + x3 + x4  7
LC =
x2 , x3 , x4  R
It is immediate to check that X(G) = X(G|LC ); indeed, the individual rationality over
player 5 forces x5  1; given that v({1, 2, 3, 4, 5}) = 8, the above constraint is therefore
logically implied for all individually rational vectors in VLC (N ). However, LC plays a crucial
role concerning the formation of the coalition {2, 3, 4}. Indeed, consider the objection
(y, {1, 2}) of player 1 against player 3 to x, where y1 = 12 and y2 = 32 . Any counterobjection
(z, T ) to (y, {1, 2}) must be such that T = {2, 3, 4}. Thus, z2  y2 = 32 , z3  x3 = 3, and
z4  x4 = 3 must hold. It follows that z2 + z3 + z4 > 7 and, hence, z 6 VLC (T ). Since (y, S)
is a justified objection, x 6 B(G|LC ).
Proposition 4.14. There exists a constrained game G|LC (with int(LC) = ) such that
X(G) = X(G|LC ), and B(G|LC )  X(G) 6 B(G)  X(G|LC ).
Proof. Consider the TU game G = hN, vi such that N = {1, 2, 3}, v({1}) = v({2}) = 1,
v({3}) = 0, v({1, 3}) = v({2, 3}) = 4, v({1, 2}) = 5, and v({1, 2, 3}) = 3. Consider the
imputation x such that x1 = x2 = x3 = 1. We observe that x 
/ B(G). Indeed, consider
an objection (y, {1, 2}) of player 1 against player 3 such that y1 = 1 + 12 and y2 = 3 + 12
(observe that y({1, 2}) = v({1, 2}). Player 3 cannot counterobject either as a singleton,
since v({3}) < x3 , or through coalition {2, 3}, since for each vector z  R{2,3} such that
z2  y2 > 3 and z3  x1 = 1, we have z({2, 3}) > 4 = v({2, 3}). It follows that x 6 B(G).
Consider now the following set of constraints:

x1 + x2  4
LC =
x1 , x2  R
It is immediate to check that X(G) = X(G|LC ). Moreover, let us notice that no player has
a justified objection against player 1 or 2 to x, since they can counterobject as singletons;
indeed, just observe that v({i}) = 1 = xi , for i  {1, 2}. Consider, then, an objection
(y, {1, 2}) of player 1 against player 3, such that y1  x1 = 1 and y2  x2 = 1. Since, y must
belong to VLC ({1, 2}), we have that y2  3 holds. Thus, the pair (z, {2, 3}) with z2 = 3  y2
and z3 = x3 = 1 is a counterobjection to (y, {1, 2}), because z({2, 3}) = 4 = v({2, 3}). By
the symmetry in the game definition, the same line of reasoning as above applies to show
that also player 2 has no justified objections against player 3. Therefore, x  B(G|LC ).
4.2.3 Nucleolus and Kernel
Let us move to analyze the nucleolus and the kernel. As in the case of the bargaining set,
no preservation property holds, as demonstrated next.
Proposition 4.15. There exists a constrained game G|LC (with int(LC) = ) such that
X(G) = X(G|LC ) 6= , K (G)  K (G|LC ) = , and N (G)  N (G|LC ) =  (for Kalais excess
function in Equation (2) on page 640).

657

fiGreco, Malizia, Palopoli, & Scarcello

Proof. Consider the TU game G = hN, vi such that N = {1, 2, 3}, v({1, 2, 3}) = 3,
v({1, 2}) = 5, v({1, 3}) = 4, v({2, 3}) = 3, and v(S) = 0, for each other coalition S  N .
Consider an imputation x that belongs to K (G), and consider the expressions: s1,3 (x)
s3,1 (x) = (5  x1  x2 )  (3  x2  x3 ) = 2  x1 + x3 and s1,2 (x)  s2,1 (x) = (4  x1  x3 ) 
(3  x2  x3 ) = 1  x1 + x2 . By Definition 2.5, we then get that 2  x1 + x3 > 0 implies
x3 = 0, that 2  x1 + x3 < 0 implies x1 = 0, that 1  x1 + x2 > 0 implies x2 = 0, and that
1  x1 + x2 < 0 implies x1 = 0. By simple algebraic calculations, the above relationships
together with the individual rationality of x (i.e., x1  0, x2  0, and x3  0) entail that
x1  x2 = 1 and x1  x3 = 2 must hold. In turn, since x1 + x2 + x3 = 3, the latter two
equations uniquely determine the value of x. In particular, K (G) is the singleton {x} such
that x1 = 2, x2 = 1 and x3 = 0. Moreover, since N (G)  K (G) and |N (G)| = 1 (see
Proposition 2.7), we have that N (G) = K (G).
Consider now the following set of constraints:

x1 + x2  3



x1 + x3  3
LC =
x + x3  3


 2
x1 , x2 , x3  R

Notice that the above constraints do not modify the imputation set, that is, X(G) =
X(G|LC ) 6= . Moreover, observe that V |LC = Vv , where v  is the worth function of the game
G  = hN, v  i in which v  ({1, 2, 3}) = v  ({1, 2}) = v  ({1, 3}) = v  ({2, 3}) = 3, and v  (S) = 0
for all other coalitions S  N . By this, the excess function eK reported in Equation (2) coincides with the canonical TU excess, and the definitions of kernel NTU and nucleolus NTU
coincide with those for TU games (cf. Kalai, 1975). So the kernel and nucleolus of G|LC are
those of G  . Finally, it is easily checked that K (G  ) is the singleton {x } such that x1 = 1,
x2 = 1 and x3 = 1 (and, thus, K (G  ) = N (G  )). It follows that K (G)  K (G|LC ) =  and
N (G)  N (G|LC ) = .
4.2.4 Shapley Value
Let us conclude our analysis with the Shapley value. Below, we show that this solution concept is preserved whenever the set of all pre-imputations is not modified by the constraints.
Proposition 4.16. Let G|LC be a constrained game. If the sets of pre-imputations of G and
G|LC coincide, then (G|LC ) = {(G)}.

Proof. Let pX(G) = {x  RN | x(N ) = v(N )} be the set of all pre-imputations of the TU
G = hN, vi; in fact, recall that pX(G) contains all the efficient payoff vectors in Vv (N ) = {x 
RN | x(N )  v(N )}. Let pX(G|LC ) = {x  Rn | x(N )  v(N )x  (LC)[N ]x is efficient}
be the set of all pre-imputations of G|LC . Since pX(G) = pX(G|LC ), it must be the case that
(LC)[N ]  Vv (N ) = {x  Rn | x(N )  v(N )}. Therefore, VLC (N ) = Vv (N )  (LC)[N ] =
Vv (N ). For each coalition S and vector y  RS , consider now the vector x  RN with
xi = yi , for each i  S, and xi = (v(N )  y(S))/|N \ S|, for each i  (N \ S). Note that
x(N ) = v(N ) and, hence, x  Vv (N ) and x  (LC)[N ]. Therefore, y belongs to (LC)[S].
Thus, (LC)[S] = RS and, hence, VLC (S) = Vv (S)  (LC)[S] = Vv (S), for each S  N .
Finally, since VLC (N ) = Vv (N ) also holds (and thus VLC (S) = Vv (S), for each S  N ), it
follows that (G|LC ) = {(G)} (see, e.g., McLean, 2002).
658

fiMixed-Integer Constrained Coalitional Games

However, the Shapley value (G) is not preserved in general, even if (G) is an imputation, and if imputation sets are not affected by the constraints.
Proposition 4.17. There exists a constrained game G|LC (with int(LC) = ) such that
(G)  X(G), X(G) = X(G|LC ), and (G) 
/ (G|LC ).
Proof. Consider the TU game G = hN, vi such that N = {1, 2, 3}, v({1, 2, 3}) = 3,
v({1, 2}) = 4, v({1, 3}) = 3, v({2, 3}) = 3, and v(S) = 0, for each other coalition S  N . By
simple calculations, one may compute the Shapley value (G), and notice that (G)1 = 7/6,
(G)2 = 7/6, and (G)3 = 4/6. Thus, (G)  X(G).
Consider now the following set of constraints:

x1 + x2  3
LC =
x1 , x2  R
and notice that they do not modify the imputation set, that is, X(G) = X(G|LC ) 6= .
Indeed, the inequality x1 + x2  3 is logically implied by the worth of the grand-coalition
(which forces x1 + x2 + x3  3) and by the individual rationality of all players (i.e., x1  0,
x2  0, and x3  0). For the sake of completeness, note that the constrained game G
does not fit the hypothesis of Proposition 4.16 since pX(G) 6= pX(G|LC ) (indeed, any payoff
vector x with x1 + x2 > 3 and x(N )  v(N ) = 3 is a pre-imputation for G but not for G|LC ,
because x1 + x2  3 is not satisfied).
Moreover, observe that V |LC = Vv , where v  is the worth function of the game G  =
hN, v  i in which v  ({1, 2, 3}) = v  ({1, 2}) = v  ({1, 3}) = v  ({2, 3}) = 3, and v  (S) = 0 for all
other coalitions S  N . This suffices to conclude that (G|LC ) = {(G  )} (see, e.g., McLean,
2002). However, it is easily checked that (G  ) is such that (G  )1 = (G  )2 = (G  )3 = 1.
Thus, (G) 
/ (G|LC ).

5. Complexity Analysis
In this section, we shall look at the core and the bargaining set for (constrained) coalitional
games from a computational viewpoint. In particular, our aim is to shed light on the impact
of issuing constraints w.r.t. the intrinsic complexity of these notions, and to assess whether
any price has to be paid for the increased expressiveness of constrained gamesfor the sake
of completeness, background notions on complexity theory are reported in the Appendix.
We argue that it is in fact sensible to analyze these computational properties, as this
corresponds to analyzing the feasibility of using such concepts under the thesis of bounded
rationality, that is, that decisions taken by realistic agents cannot involve unbounded resources to support reasoning (Simon, 1972). Moreover, it is worthwhile noting that studying
such matters might hopefully guide the design of effective computation algorithms.
We leave as future work a complexity analysis of the other solution concepts, where
it would be interesting to consider various kinds of Kalais excess functions with different
computational properties.
5.1 Setup and Problems Analyzed
In the analysis that follows, we assume games to be provided in characteristic function form,
i.e., we deal with scenarios where coalition worths are returned by some given function (von
659

fiGreco, Malizia, Palopoli, & Scarcello

Neumann & Morgenstern, 1944). For instance, the games discussed in Example 3.4 and
in Example 3.5 are in characteristic function form. Moreover, by following the general
framework proposed by Bilbao (2000), we assume that the input for any reasoning problem
consists of a constrained game G|LC where the worth function v is given as an oracle. In
particular, we shall consider two types of oracles:
(1) Oracles computable in polynomial time in the size ||G|LC || of the game representation.
5 For instance, the game in Example 3.4 fits this framework, as well as the game in
Example 3.5, provided that the cost function com(S) (of establishing a communication
infrastructure over the agents in S) comes as an oracle computable in polynomial time.
(2) Oracles computable in non-deterministic polynomial time in the size ||G|LC || of the
game representation. For instance, the game in Example 3.5 may fit this setting
in the cautious perspective where we require that, for any coalition S, the value
v(S) = 100  com(S) can actually be obtained in some imputation. That is, if we
add the condition that there is an element x  (LC) such that for each task tj ,
there is a player i  S with ji 6= 0 (in x), i.e., that the task T can actually be
performed by coalition S while conforming with all the costs constraints. Here, we
also require of course that com(S) is computable in non-deterministic polynomial
time. Note that such powerful worth-functions can be used to encode NP-complete
problems reflecting results of complex algorithmic procedures, such as those arising
in allocation, scheduling and routing scenarios, to name a few.
Let us remark that the framework where the worth function is an oracle computable in
polynomial time encompasses all those settings where games are (implicitly) described over
some kind of compact structures, and where simple calculations on such encodings are to
be performed to compute the worth of any given coalitionnoticeable and very influential
settings of this type are the graph and hypergraph games (Deng & Papadimitriou, 1994),
the marginal contribution nets (Ieong & Shoham, 2005), the games in multi-issue domains
(Conitzer & Sandholm, 2004), and the weighted voting games (Elkind & Pasechnik, 2009;
Elkind, Goldberg, Goldberg, & Wooldridge, 2009). Therefore, our membership results will
immediately carry over to the various classes of games cited above, whereas hardness results
are specific to the oracle setting, and do not hold in general for these (sub)settings.
Within the setting discussed above, we shall next focus on checking whether a given
imputation satisfies the conditions needed to be in the core or in the bargaining set. Thus,
given a constrained game G|LC and a vector x, the following problems will be considered:
 Core-Check: Is x in C (G|LC )?
 BargainingSet-Check: Is x in B(G|LC )?
In addition, recall from Section 4 that the core and the bargaining set might be empty
for constrained games. Thus, it is sensible as well to study the following problems:
5. As usual, it is implicitly assumed that the game representation includes the list of players, so that,
for every coalition S, ||S||  ||G|LC ||. Otherwise, one should more formally say, e.g., that oracles are
computable in polynomial time in the combined size of G|LC and S.

660

fiMixed-Integer Constrained Coalitional Games

Problem

Constrained

Constrained
(int(LC)  {xi |i  N })

Constrained
(int(LC) = )

TU

Core-Check
BargainingSet-Check
Core-NonEmptiness
BargainingSet-NonEmptiness

DP -complete
P
2 -complete
P
2 -complete
P
3 -complete

co-NP-complete
P
2 -complete
P
2 -complete
P
3 -complete

co-NP-complete
P
2 -complete
P
2 -complete
P
3 -complete

co-NP-complete
P
2 -complete
co-NP-complete
trivial

Figure 2: Complexity Results for Constrained Games. Hardness results hold even on cohesive games with worth functions given as polynomial-time oracles. Membership
results hold on non-deterministic polynomial-time worth-function oracles, without any assumption on the representation of real numbers.

 Core-NonEmptiness: Is C (G|LC ) 6= ?
 BargainingSet-NonEmptiness: Is B(G|LC ) 6= ?
Overview of the Results. A summary of our results is reported in Figure 2. Note there
that four settings emerge from our analysis: TU games, constrained games without integer
variables (i.e., int(LC) = ), constrained games without auxiliary integer variables (i.e.,
int(LC)  {xi | i  N }), and arbitrary constrained games. In fact, we stress that hardness
results are established without the use of auxiliary real variables, while membership results
(for constrained games) hold even if variables of this kind actually occur. Thus, auxiliary
real variables play no computational role in the setting of constrained games.
Concerning the checking problems, Figure 2 evidences that Core-Check is co-NPhard for TU games, and in co-NP for constrained games where auxiliary integer variables
are not allowedas said above, there is no bound in the membership result on the number
of considered auxiliary real variables. By allowing the use of auxiliary integer variables,
Core-Check becomes DP -hard, and in fact complete for this class. Thus, auxiliary integer
variables cause a slight increase of complexity for this solution concept. On the other hand,
it emerged that the occurrence of real variableseither player variables or auxiliary ones
and of integer player variables is completely immaterial from a computational perspective.
As far as the BargainingSet-Check is concerned, we can deliver the good news that
adding constraints does not alter the complexity w.r.t. the TU case. Indeed, this problem
P
is P
2 -hard for TU games, and it is in 2 whichever constraints are considered.
Concerning the non-emptiness problems, we show instead that constraints may radically
alter the computational properties. Indeed, CoreNonEmptiness raises one level up
in the polynomial hierarchy, from co-NP in absence of constraints (Malizia, Palopoli, &
Scarcello, 2007) to P
2 , while BargainingSet-NonEmptiness is trivial on TU games
(since this concept is always non-empty there), but it becomes P
3 -complete on constrained
games. Interestingly, in both cases, auxiliary and integer variables do not play any role.
Indeed, hardness results are established for the basic case where int(LC) =  (and without
auxiliary variables), while membership results hold for arbitrary constraints.
In the following, all hardness results will be shown to hold in the simplest case of
(deterministic) polynomial-time worth-function oracles. Moreover, membership results will
not assume any a-priori bound on the representation size of real numbers. To this end, some
661

fiGreco, Malizia, Palopoli, & Scarcello

non-trivial technical matters will be faced next, to show that algorithms can safely work
with as few as polynomially many bits, for any solution concept considered in this paper.
5.2 Hardness Results (on Cohesive Games with Polynomial-Time Oracles)
In this section, we shall establish our hardness results. In particular, in order to highlight
the intrinsic difficulty associated with the solution concepts, constructions are reported
over kinds of worth functions that are simple not only from a computational viewpoint,
in that they are given via oracles computable in polynomial time, but also from an algebraic
viewpoint, as they induce cohesive games.
We recall here that a (TU) game is cohesive
if its worth function v is such that, for each
P
partition S of the players in N , v(N )  SS v(S) holds (Osborne & Rubinstein, 1994)a
condition often imposed in order to guarantee that the grand-coalition actually forms. Note
that earlier proofs of complexity results on compactly specified games (see, e.g., Deng &
Papadimitriou, 1994; Greco, Malizia, Palopoli, & Scarcello, 2009b; Ieong & Shoham, 2005)
do generally exploit constructions over games that are not cohesive and, hence, they do not
entail the hardness results stated in this paper. In fact, our results interestingly show that
cohesivity does not simplify reasoning with solution concepts for coalitional games.
In order to establish hardness results, we exploit a number of reductions that refer to
Boolean formulae. Let  be a Boolean formula, and let vars() = {W1 , . . . , Wn } be the set
of Boolean variables occurring in . Recall that a literal is either a Boolean variable Wi or
its negation Wi . The former is called a positive literal, while the latter is called a negative
literal. We denote by vars() = {Wi | Wi  vars()} the set of negative literals for the
variables occurring in . Literals are associated with game players in most proofs. For a
set of players S, define (S) to be the truth assignment where Wi  vars() is true if Wi
occurs in S, and false, otherwise. The fact that (S) satisfies  is denoted by (S) |= .
Moreover, we say that a coalition S  vars()vars() is consistent w.r.t. a set of variables
Y  vars() if, for each Wi  Y , |{Wi , Wi }  S| = 1 holds. In the case where Y = vars(),
we simply say that S is consistent.
We start by demonstrating hardness results for the various membership-checking problems. The first result is the co-NP-hardness of Core-Check, which is established on the
basis of rather standard arguments reported below just for the sake of completeness. In
particular, the reader may find it useful to check that the reduction exploited in the proof is
based on games that are cohesive, which makes it different from earlier complexity results
given in the literature for specific kinds of compactly specified games.
Theorem 5.1. Core-Check is co-NP-hard, even for cohesive TU games with polynomialtime oracles and if the input vector is an imputation.
Proof. Recall that deciding whether a Boolean formula  over the variables X1 , . . . , Xn
is not satisfiable, i.e., deciding whether there exists no truth assignment to the variables
making  true, is a co-NP-complete problem (Johnson, 1990).
Given such a formula , we build in polynomial time the TU game G() = hN, vi, where
N = vars()  {w, e} and where, for each set of players S, v is such that:

 1 if S = N,
v(S) =
1 if e 
/ S  w  S  (S) |= , and

0 otherwise.
662

fiMixed-Integer Constrained Coalitional Games

Consider, now, the vector x where xe = 1 and xp = 0 for each other player p, and note
that x is an imputation. We claim that: x  C (G()) if and only if  is not satisfiable.
() x  C (G()) implies that there is no coalition S and S-feasible payoff vector y with
yi > xi , for each i  S. Consider any coalition/assignment S such that e 
/ S and
w  S, and observe that x(S) = 0. Since x  C (G()), we must have v(S) = 0, which
entails that (S) does not satisfy , by definition of the worth function. Given that
there is a one-to-one correspondence between coalitions S (with e 
/ S and w  S)
and truth assignments for , we conclude that  is not satisfiable.
() If x 
/ C (G()), there must exist a coalition S  N such that x(S) < v(S), which
is only possible if x(S) = 0 and v(S) = 1. By construction of the worth function, it
follows that S  N , e 
/ S, w  S and (S) |= . That is,  is satisfiable.
Finally, observe that the role of player w is to guarantee that the game is cohesive.
Indeed, for any partition S of N , there is at most one set S  S that contains w, and hence
that may get 1 as its coalition worth.
When considering constrained games and arbitrary input vectors (i.e., not necessarily
imputations), Core-Check turns out to be slightly more difficult than in the previous
case. In fact, we stress here that the use of auxiliary integer variables is crucial in order to
establish the result illustrated next.
Theorem 5.2. Core-Check is DP -hard, even for cohesive constrained games with polynomial-time oracles.
Proof. Given a pair of Boolean formulae (,  ), deciding whether  is not satisfiable and 
is satisfiable is a prototypical DP -complete problem (Johnson, 1990). Assume, w.l.o.g., that
 = c1 . . .cm , with ci = ti,1 ti,2 ti,3 , for each i  {1, . . . , m}. That is,  is in conjunctive
normal form and every clause contains exactly three literals. Moreover, let vars( ) =
{Y1 , . . . , Y } and vars() = {X1 , . . . , Xn }, and assume w.l.o.g. that vars()  vars( ) = .
Consider the TU game G() = hN, vi built in the proof of Theorem 5.1, and recall that
N = vars()  {w, e} and that the vector x (where xe = 1 and xp = 0, for each player
p  N with p 6= e) belongs to C (G()) if and only if  is not satisfiable.
Consider then the following set of constraints:

1  TYj  0, j  {1, . . . , }



(ti,1 ) + (ti,2 ) + (ti,3 )  1, i  {1, . . . , m}
LC =
x  R, p  N


 p
TYj  Z, j  {1, . . . , }

where (ti,h ) denotes the expression 1  Tti,h if ti,h is a negative literal, and the expression
Tti,h if ti,h is a positive literal. Note that players in N are actually not constrained in LC.
Therefore, if (LC) = , then (LC)[N ] =  trivially holds (since (LC)[N ] is the restriction
of an empty set over RN ). Otherwise, i.e., if (LC) 6= , then (LC)[N ] = RN and therefore
these constraints are immaterial. Of course, if (LC) = , then there is no imputation
of G()|LC ; otherwise, all the solution concepts for G() are preserved in G()|LC , since
constraints do not play any role in this case.
663

fiGreco, Malizia, Palopoli, & Scarcello

Observe now that, for each j  {1, . . . , }, TYj is constrained over the domain {0, 1}
as to encode the truth value of the Boolean variable Yj . Clearly, LC can be computed in
polynomial time from , and it is immediate to check that (LC) 6=  if and only if  is
satisfiable. It follows that the vector x is in the core of G()|LC if and only if x belongs to
the core of G() (i.e.,  is not satisfiable) and (LC) 6=  (i.e.,  is satisfiable).
We now turn to the study of the bargaining set. Notice that for the class of graph games
(which is an instance of the more general framework we are considering here) completeness
for BargainingSet-Check in P
2 has recently been established by Greco et al. (2009b).
Clearly enough, this result already implies that BargainingSet-Check is P
2 -hard on
TU games with polynomial-time oracles. Below, we show that this hardness result still
holds on games with polynomial-time oracles which are moreover cohesive.
Theorem 5.3. BargainingSet-Check is P
2 -hard, even for cohesive TU games with
polynomial-time oracles and if the input vector is an imputation.
Proof. We show a polynomial-time reduction from the problem of deciding whether a quantified Boolean formula H = Y1 , . . . , Yn Z1 , . . . , Zq  is valid, which is a well-known P
2complete problem (Johnson, 1990). Let Y = {Y1 , . . . , Yn } and Z = {Z1 , . . . , Zq } denote the
sets of universally and existentially quantified variables, respectively.
Based on H, we build a game G(H) = hN, vi, where N = vars()  vars()  {a, a }
and where, for each set of players S, v is such that:

2 if S = N,



1 if |S| = n and S is consistent w.r.t. {Y1 , . . . , Yn },
v(S) =
1 if S is consistent, |{a, a }  S| = 1, and (S) |= ,



0 otherwise.
Let x be the imputation with xa = xa = 1 and xp = 0, for each other player p.
The construction of G(H) and x is defined as to guarantee two basic properties, which are
intuitively illustrated next:

(1) Recall that an objection (y, S) of player i against player j to x is such that i  S,
j
/ S, y(S)  v(S) and yk > xk , for each k  S. Since v(S) > x(S) must hold for any
objection (y, S), it is the case that objections are one-to-one associated with truth
assignments for the variables in Y; indeed, this is to have v(S) = 1 (and x(S) = 0).
Let (Y \ S) be the truth assignment associated with coalition S.
(2) Recall that a counterobjection (z, T ) to an objection (y, S) of player i against player j
to x is such that i 
/ T , j  T , z(T )  v(T ), zk  yk , for each k  T  S, and zk  xk ,
for each k  T \ S. If (y, S) is an objection against a player j 
/ {a, a }, then (z, {j})
with zj = 0 is a trivial counterobjection. On the other hand, counterobjections (z, T )
to objections (y, S) against a or a are necessarily such that T S = , because z(T ) 
1 and xa = xa = 1. In particular, z(T ) = 1 must hold. Thus, these counterobjections
are one-to-one associated with all the possible satisfying truth assignments for the
variables in H, which are moreover obtained as extensions of the assignment (Y \ S).

664

fiMixed-Integer Constrained Coalitional Games

By Definition 2.3, x is in the bargaining set of G(H) if and only if for each objection
(i.e., assignment (Y \ S) to the variables in Y), there is a counterobjection (i.e., satisfying
assignment obtained by extending (Y \ S)). Therefore, the following claim holds, whose
formal proof is reported in the Appendix:
Claim A. x  B(G(H)) if and only if H is valid.
To conclude the proof, note that the game is cohesive. Indeed, for each coalition S
where v(S) = 1, it is the case that |S  {Y1 , . . . , Yn , Y1 , . . . , Yn }| = n. Thus, given any three
coalitions S1 , S2 and S3 with v(S1 ) = v(S2 ) = v(S3 ) = 1, it must be the case that two
of them overlap over some players. Therefore, any partition S of N contains at most two
coalitions getting a worth greater than 0, and the result follows since v(N ) = 2.
In the remainder of the section we prove our hardness results for non-emptiness problems.
We start by showing that adding constraints to the game causes the complexity of the nonemptiness problem for the core to raise one level up in the polynomial hierarchyfrom
co-NP in absence of constraints (Malizia et al., 2007) to P
2 . Note that in the proof
below, integer and auxiliary variables do not play any role.
Theorem 5.4. Core-NonEmptiness is P
2 -hard, even for cohesive constrained games
with polynomial-time oracles, and where integer and auxiliary variables are not allowed.
Proof. Deciding whether a quantified Boolean formula F = X1 , . . . , Xn Y1 , . . . , Yq  is
valid is a well-known P
2 -complete problem (Johnson, 1990).
Based on F , we build in polynomial time the game G(F ) = hN, vi, where N = vars()
vars()  {a} and where, for each set of players S, v is such that:

 3  n if S = N,
v(S) =
n
if S is consistent and (S) 6|= ,

0
otherwise.

In addition, we build in polynomial time a set LC that, for each 1  i  n, contains the
following constraints:

xXi + xXi = 1




x Xi  0



xXi  0
LC =
xa = 2  n





,x  R
x

 Xi Xi
xa  R
First, note that LC forces xXi + xXi = 1, and forces xa to take value 2  n. Thus, since
v(N ) = 3  n, any imputation x for the constrained game G(F )|LC does not distribute any
worth to the players associated with the variables in {Y1 , . . . , Yq }. An imputation x is then
associated with an assignment (x) to the variables in {X1 , . . . , Xn } such that Xi is true
in (x) if and only if xXi < 1note that we are associating 1 with false, here.
To understand the salient features of the reduction, recall now that an objection (y, S)
to an imputation x is such that y  VLC (S) and yk > xk for all k  S. Since y(S) > x(S)
holds, we have only to take care of coalitions S  N such that S is consistent and (S) is
not a satisfying truth assignment. Recall that VLC (S) = {x  RS | x(S)  v(S)}  (LC)[S];
665

fiGreco, Malizia, Palopoli, & Scarcello

thus, for any such objection (y, S) with Xi  S (resp., Xi  S), we have yXi  1 (resp.,
yXi  1). Therefore, S cannot include players in {X1 , X1 , ..., Xn , Xn } getting a worth 1 in
x. It follows that the set of all possible objections (y, S) to any imputation x corresponds to
a superset of all truth assignments (S) which are not satisfying and which are extensions
of (x). This correspondence allows us to establish the following result (whose formal proof
is deferred to the Appendix).
Claim B. C (G(F )|LC ) 6=  if and only if F is valid.
To conclude the proof, we notice that G(F )|LC is cohesive. Indeed, each coalition S with
v(S) = n must be consistent, and thus |S  (vars()  vars())| = n + q. Therefore, given
any three coalitions S1 , S2 and S3 with v(S1 ) = v(S2 ) = v(S3 ) = n, it must be the case
that two of them overlap over some players. It follows that any partition S of N contains
at most two coalitions getting worth n.
The non-emptiness problems for the bargaining set is trivial over TU games, since this
concept is always non-empty there. This is no longer the case over constrained games, where
this problem turns out to be quite difficult. As in the proof of Theorem 5.4, integer and
auxiliary variables play no role in the result shown below.
Theorem 5.5. BargainingSet-NonEmptiness is P
3 -hard,even for cohesive constrained
games with polynomial-time oracles,and where integer and auxiliary variables are not allowed.
Proof. Deciding the validity of the formula P = X1 , . . . , Xm Y1 , . . . , Yn Z1 , . . . , Zq  is a
well-known P
3 -complete problem (Johnson, 1990).
Based on P , we build in polynomial time a game G(P ) = hN, vi, where N = vars() 
vars()  {a, w} and where, for each set of players S, v is such that:


 m + 1 if S = N


1
if w  S  |S| = n + 1




S is consistent w.r.t. {Y1 , . . . , Yn },

v(S) =
1
if S = {Xi , Xi }, for some i


1
if a  S  S \ {a} is consistent 





(S) |= , and


0
otherwise.
We also build in polynomial time a set LC that, for each 1  i  m, contains the following
constraints:

xXi + xXi = 1




x Xi  0



xXi  0
 xa = 1




 xXi , xXi  R

xa  R

First, we observe that, because of the above constraints and of the fact that v(N ) =
m+1, in any imputation of this game all players Yj , 1  j  n, and all players Zr , 1  r  q,
get payoff 0. Moreover, any imputation x for which there is an index i, 1  i  m, such
that xXi > 0 and xXi > 0 cannot belong to the bargaining set of G(P )|LC , for the objection
666

fiMixed-Integer Constrained Coalitional Games

1
(y, {w, Y1 , ..., Yn }) against player a such that yYj = n+1
is justified. Indeed, if (z, T ) were
a counterobjection with a  T , we would have za  xa = 1 (indeed, xa = 1 is prescribed
by LC). Moreover, because of the definition of the worth function, T would be such that
T \ {a} is consistent, i.e., for each i  {1..., m}, |T  {Xi , Xi }| = 1. Assume that Xi  T
(the same line of reasoning applies if Xi  T ). Then, zXi  xXi > 0 must hold and we
would have z(T ) > 1, which is impossible since v(T )  1 and since v(T )  z(T ) holds for
any counterobjection. Thus, the set of imputations x that might possibly belong to the
bargaining set are restricted to those where variables xXi and xXi take distinct values from
the set {0, 1}. As a result, we can associate any such imputation x of the constrained game
G(P )|LC with an assignment (x) to the variables in {X1 , . . . , Xm } such that Xi is true in
(x) if and only if xXi = 0. Note that we are associating 0 with true here.
In fact, in order to show the correctness of the reduction, we may basically follow the
spirit of the proof of Theorem 5.4. For any imputation x (with the properties illustrated
above), the set of the possible objections (y, S) corresponds to the set of all possible truth
assignments (Y \ S) for the variables in Y = {Y1 , ..., Yn }. Objections that might be
possibly justified are then restricted to those against player a, for which counterobjections
correspond to satisfying assignments extending (x) and (Y \ S). Thus, the following can
be shown, whose detailed proof is reported in the Appendix.

Claim C. B(G(P )|LC ) 6=  if and only if P is valid.
Finally, note that the game is cohesive. Indeed, consider any partition S of the players
in N , and a coalition S  S where v(S) = 1. In the case where a  S and S is consistent
w.r.t. vars(), then there cannot exist any other coalition S   S with v(S  ) = 1 and
with S  = {Xi , Xi } for some i. In addition, there can exist at most one further coalition
S   SP
with v(S  ) = 1 (for |S  | = n + 1, w  S  , and S  is consistent w.r.t. {Y1 , . . . , Yn }).
Thus, SS v(S)  2. Similarly,
P if there is no coalition S  S such that a  S and S is
consistent w.r.t. vars(), then SS v(S)  m + 1. Indeed, S might contain the coalitions
{X1 , X1 }, . . . , {Xm , Xm }, plus at most one coalition that is consistent w.r.t. {Y1 , . . . , Yn }
and which gets worth 1. In particular, S cannot contain two coalitions S  and S  consistent
w.r.t. {Y1 , . . . , Yn } and with v(S  ) = v(S  ) = 1, as w should be contained in both.
5.3 Membership Results
We now complete the picture of the complexity arising in the context of constrained games
by proving membership results that, together with the proofs in the previous section, provide
the completeness results reported in Figure 2. In particular, we shall consider the case where
the worth function v is an oracle that can be computed in deterministic polynomial time
in the size ||G|LC || of the constrained game, while deferring a discussion about how these
results can be extended to the case where v is an oracle computable in non-deterministic
polynomial time to Section 5.3.1.
We start our analysis by stating the complexity of checking whether a vector is an
imputation.
Lemma 5.6. Deciding whether a vector is an imputation is in DP for constrained games.
In particular, the problem is in co-NP for constrained games without auxiliary integer
variables, and in P for constrained games without integer variables.
667

fiGreco, Malizia, Palopoli, & Scarcello

Proof. Let G = hN, vi be a TU game and let LC be a set of constraints. Let x be a vector
assigning a payoff value to each player in N . Recall that x is an imputation in X(G|LC )
if: (1) x  VLC (N ) = {x  RN | x(N )  v(N )}  (LC)[N ]; (2) x is efficient; and (3) x is
individually rational.
(1) Checking whether x(N )  v(N ) is feasible in polynomial time. Moreover, checking
whether x  (LC)[N ] is feasible in NP. Indeed, we can consider the set of linear
inequalities LC derived from LC by replacing all player variables by their values according to x. Note that LC is a mixed integer linear program defined over the variables
(if any) in real (LC)  int(LC) \ {xi | i  N }, and that x  (LC)[N ] if and only if LC
is satisfiable. By well-known results on mixed integer linear programming (see, e.g.,
Nemhauser & Wolsey, 1988), LC admits a solution if and only if it admits a solution
that can be represented with polynomially many bits (in the size of LC ). Thus, the
problem can be solved by first guessing in NP a vector x assigning a value to each
variable in real (LC)  int(LC) \ {xi | i  N }, and by subsequently checking whether x
satisfies all the constraints in LC (which is feasible in polynomial time). Of course, if
int(LC)  {xi | i  N }, then LC is a linear program without integer variables. In this
special case, the satisfiability of LC can be checked in P (see, e.g., Papadimitriou &
Steiglitz, 1998).
(2) Recall that x is efficient if for each x  VLC (N ), there is a player i  N such that
xi  xi . Consider the set of linear inequalities LC derived from LC by adding the
|N | + 1 inequalities: x(N )  v(N ), and xi > xi for each i  N . Then, x is efficient if
and only if LC is not satisfiable. This latter task is feasible in co-NP, since LC is a
mixed integer linear program whose satisfiability can be checked in NPsee (1). In
the special case where int(LC) = , LC does not contain integer variables and, hence,
its (un)satisfiability can be checked in polynomial time.
(3) Recall that x is individually rational if for each player i  N , xi  max{ xi | xi 
VLC ({i}) }. Consider the set of linear inequalities LC
i derived from LC by adding the
two inequalities xi  v({i}) and xi > xi . The individual rationality holds if and only
if LC
i is not satisfiable, for each i  N . As in the point (2) above, this task is feasible
in co-NP in general, and in polynomial time whenever int(LC) = .
We can now conclude that deciding whether x is an imputation is the conjunction of
problem (1), which is feasible in NP, and of problems (2) and (3), which are feasible in
co-NP. Thus, the problem is in DP .
In the case where int(LC)  {xi | i  N } holds, (1) is feasible in polynomial time and,
hence, deciding whether x is an imputation is in co-NP.
Finally, if int(LC) = , problems (1), (2), and (3) are feasible in polynomial time.
Let us now consider the membership of Core-Check. This proof is routine and is
reported for the sake of completeness only.
Theorem 5.7. Core-Check is in DP . In particular, it is in co-NP for constrained
games without auxiliary integer variables.

668

fiMixed-Integer Constrained Coalitional Games

Proof. Let x be the input vector for the game G|LC , where G = hN, vi. We have to check
that x satisfies the conditions of the core and that x is indeed an imputation.
Concerning the former task, recall that the complementary problem of deciding whether
x is not in the core amounts to finding a coalition S and a vector x  VLC (S) such that
xi > xi , i  S. Consider the set of linear inequalities LCS derived from LC by adding the
|S| + 1 inequalities x(S)  v(S), and xi > xi i  S. Then, x is not in the core if there is
a coalition S such that LCS is satisfiable. This task can be therefore solved by guessing in
NP a coalition S together with a vector x assigning a value to each variable in LCS , and
by subsequently checking that x does indeed satisfy all the constraints in LCS . It follows
that deciding whether x satisfies the conditions of the core is feasible in co-NP.
Concerning the task of checking whether x is an imputation, we use the results in
Lemma 5.6. Thus, for general games, Core-Check can be solved by the conjunction of a
problem in co-NP and a problem in DP . Of course, this is again a problem feasible in DP .
Moreover, if int(LC)  {xi | i  N } holds, then Core-Check is feasible in co-NP.
Deriving the membership result for BargainingSet-Check on constrained games requires a more sophisticated line of reasoning. We start by recalling that, for TU games, it
is has been shown that BargainingSet-Check is in P
2 (Greco et al., 2009b). In fact,
this result has been established by exploiting a characterization for the bargaining set that
does not hold in the presence of constraints. Below, by exploiting a completely different
proof technique, we shall show that, surprisingly, the presence of the constraints does not
alter the computational properties of this problem.
For the following proofs, we recall that given a set LC of linear (in)equalities over n
real variables, the set (LC) is a polyhedron in Rn , whose faces are given by the halfspaces
associated with the (in)equalities in LC, and whose vertices are given by the intersection of n
inequalities from LC, and hence can be represented with polynomially many bits in the size
of LC (see, e.g., Papadimitriou & Steiglitz, 1998; Nemhauser & Wolsey, 1988). A bounded
polyhedron is called a polytope. Moreover, we use the following notation. Let S  N be a
set of players and let yS be the set of variables {yk | k  S}. We denote by LCyS the copy
of the system of mixed-integer linear inequalities LC where every player variable xi , with
i  S, is renamed as yi , and every other variable v in LC is renamed as vyS .
Lemma 5.8. Let G = hN, vi be a TU game, LC be a set of constraints, and x be an
imputation for G|LC that does not belong to B(G|LC ). Then, there exists a justified objection
to x that is representable with polynomially many bits.
/ S,
Proof. Since x 
/ B(G|LC ), there are two players i and j, a coalition S with i  S and j 
and an S-feasible vector y such that (y, S) is a justified objection of i against j to x. Let
LCi,j,S be the system consisting of the (in)equalities in LCyS plus the |S| + 1 inequalities:
y(S)  v(S) and yk > xk , k  S. Then, the set (LCi,j,S )[yS ] consists of all the S-feasible
vectors y such that (y, S) is an objection of i against j to x.
Let us now consider possible candidate counterobjections. For any T  N with j  T
and i 
/ T , let LCi,j,S,T be the system including the (in)equalities in LCyS and in LCzT , plus
the inequalities y(S)  v(S), yk > xk , k  S, z(T )  v(T ), zk  yk , k  T  S, and
zk  xk , k  T \ S. Note that (LCi,j,S,T )[yS ] contains all vectors y over the index set S
such that there exists a counterobjection through T , and hence of the form (z, T ), to the
669

fiGreco, Malizia, Palopoli, & Scarcello

Figure 3: Illustration of Claim D, with coalitions T1 , T2 , and T3 .
objection (y, S) of i against j to x. It follows that the set of all vectors y such that (y, S)
is a justified objection of i against j to x is the set:
[
(LCi,j,S )[yS ] \
(LCi,j,S,T )[yS ].
T |iT
/ jT

To conclude the proof we claim the following.
S
i,j,S,T )[y ] contains a point (i.e., a justified obClaim D. (LCi,j,S )[yS ] \ T |iT
S
/ jT (LC
jection to x) that can be represented with polynomially many bits.
To prove the claim, let us consider the following geometrical arguments: Consider first
the case where LCi,j,S and LCi,j,S,T (for each T | i 
/ T  j ST ) contain no integer variables,
i,j,S,T )[y ]. The
and let P be a maximal convex subset of (LCi,j,S )[yS ] \ T |iT
S
/ jT (LC
S
vertices of P , which are points of R , are given by the intersection of at most |S| (independent) halfspaces that are facets of (LCi,j,S )[yS ] or of some (LCi,j,S,T )[yS ], and thus
they can be represented with polynomially many bits. In fact, P might not contain its own
boundaries. Thus, if some of its vertices actually belongs to P , then the result straightforwardly holds. On the other hand, if P is a possibly open segment with endpoints y a and y b
(representable with polynomially many bits), then the middle point ym necessarily belongs
to P (since P is convex) and can be represented with polynomially many bits. Finally, if
the polytope P has more than two vertices (as shown in Figure 3), then it must have at
least three vertices y a , y b , and y c that do not belong to the same face of P . Therefore,
the barycenter y of the triangle with vertices y a , y b , and y c belongs to P , and it can be
represented with polynomially many bits, because this is the case for y a , y b , and y c .
670

fiMixed-Integer Constrained Coalitional Games

To conclude the proof, we observe that integer variables in LCi,j,S and LCi,j,S,T (for
each T | i 
/ T  j  T ) can be easily preprocessed. Roughlythe technical details are
reported in the Appendix, since (LCi,j,S )[yS ] is a polytope by construction of LCi,j,S and
since, therefore, its vertices can be represented with polynomially many bits, all integer
components of interest (basically those falling within (LCi,j,S )[yS ]) can be represented
with polynomially many bits, as well. Thus, to find a point with polynomially many bits
as asked for in Claim D, we can iterate over all the possible combinations
of integer values
S
i,j,S
i,j,S,T )[y ] by
and, at each step, evaluate the expression (LC
)[yS ] \ T |iT
S
/ jT (LC
replacing all integer values with the combination of values at hand. Of course, the resulting
expression does not involve integer variables, all the inequalities in it are still representable
with polynomially many bits, and therefore the above line of reasoning applies.
Armed with the above lemma, we can state the complexity of BargainingSet-Check.
Theorem 5.9. BargainingSet-Check is in P
2.
Proof. We show that the complementary problem of deciding whether a vector x is not in
the bargaining set of a given constrained game G|LC is in P
2 . We start by checking whether
x is an imputation in DP (cf. Lemma 5.6)recall that DP is contained in P
2 . If this is
the case, by Lemma 5.8 we guess in non-deterministic polynomial time a justified objection
to x, that is, a coalition S, two players i  S and j 
/ S, and a vector y such that (y, S)
is an objection of i against j to x. Consider the system LC of the (in)equalities obtained
from LCi,j,S (recall its definition in the proof of Lemma 5.8) by replacing player variables
associated with the coalition S by the respective values in y. Of course, (y, S) is an objection
if and only if LC is satisfiable. By well-known results on mixed integer linear programming
(see, e.g., Nemhauser & Wolsey, 1988), LC admits a solution if and only if it admits a
solution that can be represented with polynomially many bits. Therefore, within the same
non-deterministic step, we can also guess an assignment (call it w ) to all the variables in
LC , and then check in polynomial time that w actually satisfies all the constraints (i.e.,
that y is actually an objection).
To conclude the algorithm for solving BargainingSet-Check, we now have to check
that there is no counterobjection (z, T ) to the objection (y, S) of i against j to x. This task
requires a co-NP oracle call. In particular, the oracle works by checking the complementary
condition in NP. To this end, in a non-deterministic step, it first guesses a coalition T with
j  T and i 
/ T . Consider now the system LC including the (in)equalities in LCzT , plus
the inequalities z(T )  v(T ), zk  yk , k  T  S, and zk  xk , k  T \ S. Then, there
is a counterobjection (z, T ) to (y, S) for some vector z if and only if LC is satisfiable. As
in the case above, a solution to LC is guaranteed to exist which can be represented with
polynomially many bits, so that this solution (call it w ) can be guessed within the same
non-deterministic step by the oracle. In fact, to check that w actually satisfies LC is
trivially feasible in polynomial time.
We now turn to analyze non-emptiness problems. We start with the non-emptiness
of the core, which is a co-NP-complete problem for TU games (Malizia et al., 2007).
Constraints do play a role here, since we have shown that Core-NonEmptiness is P
2hard (cf. Theorem 5.4). Below, we confirm that this is the exact complexity of this problem.

671

fiGreco, Malizia, Palopoli, & Scarcello

Theorem 5.10. Core-NonEmptiness is in P
2.
Proof. Let us again adopt the notation used in the proof of Lemma 5.8. Let S  N be a
coalition, and LCS be the set of mixed-integer linear (in)equalities including the (in)equalities
in LCxN and LCyS , plus the inequalities y(S)  v(S) and yi > xi , for each i  S. We get:
[
C (G|LC ) = X(G|LC ) \
(LCS )[xN ].
SN

Let LCX be the set of the (in)equalities in LCxN plus the inequality x(N )  v(N ). Moreover,
for each player i, let LCi be the set of the (in)equalities LCxN and LCy , plus the inequalities
{i}

x(N )  v(N ) and xi < yi  v({i}). Then, the set (LCi )[xN ] consists of all the vectors
that are not individually rational (w.r.t. player i). Thus,

C (G|LC ) =

X

(LC )[xN ] \

[

i

!

(LC )[xN ]

iN

\

[

(LCS )[xN ].

SN

In particular, note that the efficiency condition on imputations is guaranteed. Indeed,
the points that are not efficient are removed, because they belong to the set (LCN )[xN ],
which is considered above for S = N .
By applying the same line of reasoning as in Claim D (in Lemma 5.8) on the above
expressions, we have that, if C (G|LC ) is not empty, then it contains an imputation that is
representable with polynomially many bits. Thus, we can decide the non-emptiness of the
core by first guessing in NP a vector x. Then, we may call a DP oracle (corresponding
to the invocation of an NP and a co-NP oracle) to check that x is an imputation (cf.
Lemma 5.6), and finally we can verify that x is in the core with a further call to a co-NP
oracle. In particular, this latter oracle works by checking the complementary condition in
NP, i.e., it checks whether x is not in the core. To this end, the oracle guesses in a nondeterministic step a coalition S. Consider now the system LC formed by the (in)equalities
in LCyS plus the |S| + 1 inequalities: y(S)  v(S) and yk > xk , k  S. Then, there is an
objection (y, S) to x for some vector y if and only if LC is satisfiable. Again, LC admits a
solution if and only if it admits a solution that can be represented with polynomially many
bits. Therefore, within the same non-deterministic step, we can also guess an assignment
(call it w ) to all the variables in LC , and then check in polynomial time that w actually
satisfies all the constraints.
Now, we can complete our picture with the bargaining set.
Theorem 5.11. BargainingSet-NonEmptiness is in P
3.
Proof. Consider again the setting in the proof of Lemma 5.8. Let i and j be two players
in N . For any coalition S with i  S and j 6 S, let LCi,j,S be the system consisting of the
(in)equalities in LCxN and in LCyS plus the |S| + 1 inequalities: y(S)  v(S) and yk > xk ,
k  S. Moreover, for each pair of sets of players S and T with i  S \ T and j  T \ S,
let LCi,j,S,T be the system of mixed integer inequalities including the inequalities of the
systems LCxN , LCyS , and LCzT , plus the inequalities y(S)  v(S), yk > xk for each k  S,
672

fiMixed-Integer Constrained Coalitional Games

z(T )  v(T ), zk  yk for each k  T  S, and zk  xk for each k  T \ S. That is, we
proceed in the same way as in the proof of Lemma 5.8, but here the components of vector
x are variables of this linear program, while in the previous lemma they were fixed values.
Observe now that (LCi,j,S,T )[xN  yS ] contains all pairs hx, yi such that there exists a
counterobjection (z, T ) to the objection (y, S) of i against j to x, and that (LCi,j,S )[xN yS ]
consists of all pairs hx, yi such that y is an S-feasible vector with i  S and j 6 S such that
(y, S) is an objection to x. Then, the set
[
(i, j, S) = (LCi,j,S )[xN  yS ] \
(LCi,j,S,T )[xN  yS ]
T |iT
/ jT

is the set of all pairs hx, yi such that (y, S) is a justified objection of i against j to x.
Therefore,
[
B(G|LC ) = X(G|LC ) \
(i, j, S)[xN ],
SN iSj S
/

where, by considering efficiency and individual rationality (see the notation in the proof of
Theorem 5.10), we have
 [
(LCi )[xN ].
X(G|LC ) = (LCX )[xN ] \ (LCN )[xN ] \
iN

By slightly adapting the proof of Claim D (in Lemma 5.8), one may show that if the
bargaining set is not empty, there exists a vector x  B(G|LC ) which can be represented
with polynomially many bits. Therefore, BargainingSet-NonEmptiness can be solved
by first guessing in non-deterministic polynomial time such a vector x. Then, we may call
a DP oracle to check that x is an imputation (cf. Lemma 5.6), and finally we can verify
that x is indeed in the bargaining set with a further call to a P
2 oracle, in order to solve
BargainingSet-Check on input x (cf. Theorem 5.9).
5.3.1 Extension to More General Worth Functions
In all the membership results above, we have assumed that worth functions are polynomial-time computable and, within this setting, we have shown that various hardness results
are indeed tight. Thus, the reader might be inclined to believe that, by considering more
powerful worth functions, the complexity for these problems may consistently increase. Surprisingly, this is not the case. Indeed, we can show that nothing has to be paid if more
powerful worth functions that encode NP-complete problems are considered.
To this end, let vG|LC denote the worth function of a game G|LC , and define the worthfunction graph for any class C of constrained games as the set of tuples WC = {h(G|LC , S), wi |
G|LC  C  vG|LC (S) = w}. Recall, e.g., from the work by Johnson (1990), that such a
function is computable in non-deterministic polynomial time if there is an integer k such
that WC is (i) k-balanced, i.e., ||w||  (||G|LC || + ||S||)k , and (ii) k-decidable, i.e., there
is a non-deterministic Turing machine that decides whether a given tuple t belongs to WC
in O(||t||k ) time. More precisely, since vG|LC is a partial (standard) single-valued function
(multi-valued functions are also considered in the literature), the class of functions that we
consider is called NPSV (see, e.g., Selman, 1994).
673

fiGreco, Malizia, Palopoli, & Scarcello

The complexity of various solution concepts for TU games within a setting where worth
functions are given as oracles computable in NPSV has been analyzed in an extended
version of the work by Greco et al. (2009b). There, it emerged that all the membership
results in Figure 2 hold on any class C of games having such worth functions. Very roughly,
the basic observation is that if we consider NPSV worth-functions, any non-deterministic
algorithm M that guesses in polynomial-time some coalition S for a game G|LC  C, can
at the same time (with just a polynomial-time delay) guess a worth w and an additional
string c (of polynomial size w.r.t. ||G|LC || + ||S||), which acts as a certificate to decide
whether the tuple h(G|LC , S), wi belongs to the NP set WC . Thus, the complexity of any
(non-deterministic) algorithm that uses the value vG|LC (S) after a guess of the coalition S is
not affected by replacing a polynomial-time worth-functions with NPSV worth-functions.
By exploiting this line of reasoning, it is easy to adapt proofs of membership results in order
to deal with such more general worth functions.
Theorem 5.12. The membership results in Figure 2 hold on any class C of games whose
worth functions are in NPSV.

6. Discussion and Conclusion
Imposing linear constraints on the outcomes of games is an approach that has been explored
by several authors in the context of non-cooperative strategic games (e.g., Charnes, 1953;
Semple, 1997; Ryan, 1998). However, in the context of cooperative games this approach
has received considerably less attention and, indeed, no general framework was proposed in
the literature and no analysis of its properties was conducted so far.
In this paper, we have faced the issue by conducting a systematic study of constrained
games within a framework where constraints are defined as mixed-integer linear (in)equalities imposed over an underlying TU game. Seemingly close to the class of constrained
games is the class of linear programming games (see, e.g., Owen, 1975), where the worth
v(S) of a coalition S is implicitly given as a linear program (e.g., as the maximum of a
given objective function over a feasible region (LC) defined in terms of a set of linear
(in)equalities LC). Of course, this approach differs from the setting of constrained games
where the role of LC is, instead, to govern the distribution of the worths within an NTU
perspective. Moreover, differently from classical NTU formalizations, constrained games
allow to define non-convex and non-comprehensive sets of worth distributions, which is an
appealing modeling capability that emerged to be useful in several application domains.
Finally, the resulting game framework has been analyzed with respect to the preservation
and the computational properties of some relevant solution concepts.
It is worthwhile noticing that the framework we have discussed in this paper shares the
spirit of the recent arguments by Shoham (2008), who advocated the use of a broader vocabulary than the fairly terse one characterizing the early foundations of the game theory. Also
relevant are those proposals that reconsidered basic concepts of cooperative games in the
light of a modeling perspective that is closer to the requirements of computer science applications: seminal and influential directions of this type give rise, in particular, to coalitional
skill games (Bachrach & Rosenschein, 2008), qualitative coalitional games (Wooldridge &
Dunne, 2004), coalitional resource games (Wooldridge & Dunne, 2006), Bayesian coalitional
games (Ieong & Shoham, 2008), multi-attribute coalitional games (Ieong & Shoham, 2006),
674

fiMixed-Integer Constrained Coalitional Games

temporal qualitative coalitional games (Agotnes, van der Hoek, & Wooldridge, 2006), and
cooperative Boolean games (Dunne, van der Hoek, Kraus, & Wooldridge, 2008). In the
light of the above approaches, an interesting avenue of further research may be to consider
more expressive kinds of constraints, formulated for instance via logic-based languages, and
where preference criteria can be adopted in place of hard constraints.
Other avenues of research are related to some technical questions that were not explored
in the paper. First, our complexity analysis focused on the notions of the core and the
bargaining set, which are founded on the concepts of objections and counterobjections. Of
course, it would be interesting to complement our results with the analysis of the kernel, the
nucleolus, and the Shapely value. Actually, hardness results for the kernel and the nucleolus
of TU (graphical) games have recently been illustrated by Greco et al. (2009b), and indeed
they trivially provide lower bounds for the complexity of such solution concepts in the
setting of constrained games. However, providing tighter computational bounds requires
a deeper understanding of the computational aspects underlying Kalais axiomatization,
which is outside the scope of this paper. Furthermore, for the Shapley value, it is of interest
to study other extensions that have been provided in the literature for NTU games and to
assess their behavior when applied to constrained games.
Moreover, our hardness results have been shown to hold even by restricting the underlying TU games to use cohesive worth functions only. It might be of interest to study the
complexity when different specific kinds of functions are considered (for instance, monotone,
superadditive, weakly superadditive, or convex ones6 ). Similarly, assessing to which extent
considering such specific kinds of worth functions affects the analytical properties studied
in Section 4 is an interesting question which we leave for further research.
Finally, from a modeling viewpoint, we recall that the framework proposed in the paper
exploits one set of linear (in)equalities to constrain the outcomes of all coalitions. Thus, in
the light of adding modeling power to this framework, it might be of interest to study a natural generalization where each coalition is equipped with its specific set of linear (in)equalities.
In particular, this setting would call for conceiving suitable mechanisms to compactly represent (exponentially many) different sets of constraints, and for defining formal measures
for the expressivity of such compact representations for constraint-based NTU games.
Acknowledgments
A coalitional game framework for dealing with linear constraints imposed on TU games
was first illustrated by the authors in an extended abstract published in the proceedings of
the 8th International Conference on Autonomous Agents and Multiagent Systems (Greco,
Malizia, Palopoli, & Scarcello, 2009a). There, some solution concepts have been defined
and studied, which were based on proposing ad-hoc adaptations of solution concepts for
TU games. Following the suggestions of the anonymous referees, the constrained game
framework proposed in the present paper fits instead the framework of NTU games, in its
most general form. Thus, the solution concepts studied in this paper are just given as
suitable specializations of the standard solution concepts defined for NTU games.
6. The worth function v : 2N 7 R is monotone if v(S)  v(T ) holds, for each pair of coalitions S, T  N
such that S  T ; v is superadditive if v(S  T )  v(S) + v(T ) holds, for each pair of coalitions S, T  N
such that S  T = ; v is weakly superadditive if v(S  {i})  v(S) + v({i}), S  N and i  N \ S; v
is convex if v(S  T ) + v(S  T )  v(S) + v(T ), S, T  N (see, e.g., Peleg & Sudholter, 2007).

675

fiGreco, Malizia, Palopoli, & Scarcello

Appendix A. Computational Complexity
In this appendix we recall some basic definitions of complexity theory, by referring the
reader to the work by Johnson (1990) for more on this topic.
A.1 The Complexity of Decision Problems: P, NP, and co-NP
Decision problems are maps from strings (encoding the input instance over a fixed alphabet,
e.g., the binary alphabet {0, 1}) to the set {yes, no}. The class P is the set of decision
problems that can be solved by a deterministic Turing machine in polynomial time with
respect to the input size, that is, with respect to the length of the string that encodes the
input instance. For a given input x, its size is usually denoted by ||x||.
Throughout the paper, we often refer to computations carried out by non-deterministic
Turing machines, too. Recall that these are Turing machines that, at some points of the
computation, may not have one single next action to perform, but a choice between several
possible next actions. A non-deterministic Turing machine answers a decision problem if
on any given input x: (i ) there is at least one sequence of choices leading to halt in an
accepting state if x is a yes instance; and (ii ) all possible sequences of choices lead to
some rejecting state if x is a no instance.
The class of decision problems that can be solved by non-deterministic Turing machines
in polynomial time is denoted by NP. Problems in NP enjoy a remarkable property: any
yes instance x has a certificate of its being a yes instance, which has polynomial length
and which can be checked in polynomial time (in the size ||x||). As an example, the problem
of deciding whether a Boolean formula  over the variables X1 , . . . , Xn is satisfiable, i.e.,
deciding whether there exists some truth assignment to the variables making  true, is a
well-known problem in NP; in fact, any satisfying truth assignment for  is obviously a
certificate that  is a yes instance, i.e., that  is satisfiable.
The class of problems whose complementary problems are in NP is denoted by co-NP.
As an example, the problem of deciding whether a Boolean formula  is not satisfiable is
in co-NP. Of course, the class P is contained both in NP and co-NP.
The class DP is the class of problems that can be defined as a conjunction of two
problems, one from NP and one from co-NP, respectively. For instance, it is in DP to
decide whether, for a given pair of Boolean formulae (,  ),  is satisfiable and  is not.
A.2 Further Complexity Classes: The Polynomial Hierarchy
Throughout the paper, we also refer to a particular type of computation called computation
with oracles. Intuitively, oracles are subroutines that have unary cost.
P
P
The classes P
k , k , and k , forming the polynomial hierarchy, are defined as follows:
P
P
P
P
k1 , P = Pk1 , and P = co-P where
P
0 = 0 = P and for all k  1, k = NP
k
k
k
co-P
denotes
the
class
of
problems
whose
complementary
problem
is
solvable
in P
k
k.
P
P
Here, k (resp., k ) models computability by a non-deterministic (resp., deterministic)
P
polynomial-time Turing machine that may use an oracle in P
k1 . Note that 1 coincides
with NP, and that P
1 coincides with co-NP.
A well-known problem at the k-th level of the polynomial hierarchy is deciding the
validity of a quantified Boolean formula with k quantifier alternations. A quantified Boolean
676

fiMixed-Integer Constrained Coalitional Games

formula (short: QBF) with k quantifier alternations has the form Q1 X1 Q2 X2 ...Qk Xk ,
where k  1, Xi (1  i  k) is a set of variables, Qi  {, } (1
Sk  i  k), Qi 6= Qi+1
(1  i < k), and  is Boolean formula over the variables in i=1 Xi . The set of all
quantified Boolean formulae with k quantifier alternations and Q1 =  (resp., Q1 = ) is
denoted by QBFk, (resp., QBFk, ). Deciding the validity of a quantified Boolean formula
P
in QBFk, (resp., QBFk, ) is a well-known problem in P
k (resp., k ). Note that for
k = 1, this problem coincides with the problem of deciding whether the Boolean formula 
is satisfiable (resp., not satisfiable), which is indeed in NP (resp., co-NP).
A.3 Reductions Among Decision Problems
A decision problem A1 is polynomially reducible to a decision problem A2 , denoted by
A1 p A2 , if there is a polynomial time computable function h such that, for every x, h(x)
is defined and x is a yes instance of A1 if and only if h(x) is a yes instance of A2 . A
decision problem A is complete for the class C of the polynomial hierarchy (beyond P) if A
belongs to C and every problem in C is polynomially reducible to A. Thus, problems that
are complete for the class C are the most difficult of the problems in C.
It is worthwhile observing that the problems discussed in this section are known to be
complete for the classes in which the membership has been pointed out. In particular,
deciding the validity of a QBFk, (resp., QBFk, ) formula is the prototypical P
k -complete
(resp., P
-complete)
problem.
k

Appendix B. Proofs in Section 3
Proposition 3.2 Let G = hN, vi be a TU game and let X  X(G) be an arbitrary finite
set of imputations. Then, there is a finite set of constraints LC such that X(G|LC ) = X .
Proof. Consider the game G = hN, vi, the set X = {x1 , . . . , xk } of imputations of G, and
the set of constraints:

xi = x1i  y 1 +    + xki  y k , 1  i  |N |




 0  yj  1, 1  j  k
LC =
y1 +    + yk = 1


x , . . . , xn  R


 11
y , . . . , yk  Z
where x1i , . . . , xki (for 1  i  |N |) are constants.
It is immediate to check that VLC (N ) = X . Moreover, we observe that each vector
xj  VLC (N ) (1  j  k) is efficient, since it cannot be dominated by any other vector in
X (just notice that X is a set of imputations for G). Finally, notice that each imputation
x  X is individually rational w.r.t. G. Thus, by Proposition 3.7, x is individually rational
w.r.t. the constrained game too. It follows that VLC (N ) = X(G|LC ).
Proposition 3.3 There exists a class C = {G|nLC }n>0 of constrained games such that each
game G|nLC is over n + 1 players, LC consists of 2  n + 1 inequalities, and |X(G|LC )| = 2n .

677

fiGreco, Malizia, Palopoli, & Scarcello

Proof. Consider the class C = {G|nLC }n>0 where the game G n = hN, vi is such that N =
{1, . . . , n, n + 1}, v(N ) = n, v(S)
Pn= 0, for each coalition S  N , and LC = {0n xi n1, xi 
Z, 1  i  n}  {xn+1  n  i=1 xi }. It can be easily checked that |X(G|LC )| = 2 .

Proposition 3.7 Let G = hN, vi be a TU game and let x be a payoff vector that is individually rational w.r.t. G (i.e., xi  v({i}), for each player i  N ). Then, for each set LC of
constraints, x is individually rational w.r.t. the constrained game G|LC .
Proof. Let x be a payoff vector such that xi  v({i}), for each player i  N . Consider
the constrained game G|LC and a player i  N . If VLC ({i}) = Vv ({i})  (LC)[{i}] = ,
we trivially have that xi > . Otherwise, i.e., if VLC ({i}) 6= , we can just notice that
max{ yi | yi  VLC ({i}) }  v({i}). Thus, we have that xi  max{ yi | yi  VLC ({i}) }.

Appendix C. Proofs of Claims in Section 5
Claim A. x  B(G(H)) if and only if H is valid.
Proof. Let us study the structure of a possible objection to x. Recall that (y, S) is an
objection of player i against player j to x if and only if: i  S, j 
/ S, y(S)  v(S) and
yk > xk , for each k  S. Thus, we observe that v(S) = 1 must hold, in order to improve the
payoffs of its members, and because a worth value equal to 2 can only be obtained by the
grand-coalition. In addition, since xa = xa = 1 and since y(S)  v(S) = 1, it must also be
the case that {a, a }  S = , because these players get 1 in the current imputation x. Due
to the definition of the worth function, this entails that S is consistent over the variables Y,
i.e., it is a set of n players corresponding to literals over the universally quantified variables.
We thus associate with each possible objection (y, S) to x (where y(S)  1 and yk > 0,
k  S) a truth-value assignment to the variables in Y such that, 1  i  n, Yi is assigned
false if Yi  S (and true if Yi  S). According to our notation, this means that such an
objection is associated with the truth-value assignment (Y \ S). But we can define the
converse, as well. For any truth-value assignment Y for the universally quantified variables,
its associated objection is the pair (y, S) such that S = {Yk  Y | Y (Yk ) = false}  {Yk |
1
Yk  Y, Y (Yk ) = true}, and yp = |S|
, for each p  S. Note that (y, S) is an objection of

any player in S against player a or a to x, and that (Y \ S) = Y .
Indeed, if (y, S) is an objection against a player j 
/ {a, a }, then (z, {j}) with zj = 0
is a trivial counterobjection, since v({j}) = xj = 0 and j 
/ S. It follows that the set of
objections that are possibly justified has to be restricted to those against player a or player
a . Next, we consider the case of an objection against a, but exactly the same arguments
hold for objections against a . Let (y, S) be an objection of i against player a to x. Any
counterobjection (z, T ) must now be with a  T (and i 
/ T ). Thus, in order to have
za  xa = 1, it must be the case that v(T )  1 and, actually, that v(T ) = 1, due to the
definition of the worth function. In particular, the latter (with the fact that za = 1) entails
that, for each player p 6= a with p  T , it holds that zp = 0. Thus, T  S must be empty,
because all members of S get something according to y, T \{a} is consistent, and (T ) |= .
In particular, since T  S = , according to this satisfying assignment, Yi is true in (T )
if and only if Yi 
/ S. It follows that (T ) coincides with (Y \ S) over the universally
quantified variables, and thus it is in fact an extension of this truth-value assignment to
678

fiMixed-Integer Constrained Coalitional Games

the set of all variables occurring in the formula . Conversely, note that every satisfying
assignment for  that extends (Y \ S) corresponds to such a counterobjection to (y, S).
Given the above observations, we show the claim: x  B(G(H))  H is valid.
() Assume that x  B(G(H)). Let Y be any truth-value assignment for the universally
quantified variables, and let (y, S) be the objection to x associated with Y . In
particular, (Y \ S) = Y , by construction. Since x  B(G(H)), there exists a valid
counterobjection (z, T ) to (y, S), and we have seen above that its corresponding truthvalue assignment (T ) is an extension of (Y \ S) to the set of all variables vars(),
and that (T ) |= . It follows that H is valid.
() Assume that x 
/ B(G(H)). Then, there is a justified objection (y, S) against a (or
a ) to x. It follows from the discussion above that there is no truth-value assignment
that is able to extend the assignment (Y \ S) to all the variables vars(), and to
satisfy . Indeed, such an extension would be associated with a counterobjection to
(y, S). It follows that H is not valid.
Claim B. C (G(F )|LC ) 6=  if and only if F is valid.
Proof.
() Assume that x  C (G(F )|LC ), i.e., that S  N , there is no S-feasible payoff vector
such that yi > xi for each i  S. We claim that (x) is a truth assignment to the
variables in {X1 , . . . , Xn } witnessing the validity of F . Indeed, assume, for the sake
of contradiction, that there is a truth assignment Y to the variables in {Y1 , . . . , Yq }
such that (x)  Y 6|= . Consider the coalition S such that S is consistent and
(S) = (x)  Y . By definition of the worth function, v(S) = n. Moreover, observe
that x(S) < n holds, by definition of the assignment (x) and given that xYj = 0 and
xYj = 0, for each imputation x and variable Yj (1  j  q). Note, in fact, that if
Xi  S then Xi is true in (x) and then xXi < 1, and if Xi  S then Xi is false in
miniS (1xi )
(x) and then xXi = 0 (because in this case xXi = 1 holds). Now, let  =
n+q
and notice that  > 0, since xi < 1 is, in particular, prescribed by the definition of
(x). Consider the vector y  RS such that yi = xi +  for each i  S. Note that
y(S)  n because |S| = n + q; moreover, y  VLC (S) holds because v(S) = n and
because constraints are satisfied at y (just notice that S contains exactly one player
in {Xi , Xi }, for each variable Xi , which is associated with a payoff less than or equal
to 1 in y and that constraints xXi + xXi = 1 do not play any role here because only
one player Xi or Xi is in S and hence given a variable yXi (resp., yXi ) with yXi  1
(resp., yXi  1) always exists a non negative value for yXi (resp., yXi ) such that
yXi + yXi = 1). Since yi > xi , for each i  S, we then conclude that x 
/ C (G(F )|LC ),
which is impossible.
() Assume that there is a truth assignment  to the variables in {X1 , . . . , Xn } witnessing
the validity of F , and let x be an imputation such that (x) coincides with , where
in particular xXi = 1 (resp., xXi = 0) if Xi is false (resp., true) in . We claim
that x  C (G(F )|LC ). Indeed, assume for the sake of contradiction, that there is a
coalition S and an S-feasible payoff vector y such that yi > xi for each i  S. Since
679

fiGreco, Malizia, Palopoli, & Scarcello

v(S)  y(S) > x(S) and since x(S)  0, given the definition of the worth function,
it is actually the case that S is consistent (and, thus, (S) is a truth assignment)
and that (S) is not satisfying. In particular, recall that VLC (S) = {x  RS | x(S) 
v(S)}  (LC)[S]; thus, for each player Xi  S (resp., Xi  S), we have yXi  1 (resp.,
yXi  1). Therefore, S cannot include any player in {X1 , X1 , ..., Xn , Xn } getting a
worth 1 in x. It follows that (S) is an extension of (x), which is moreover not
satisfying. Thus, (x) would not witness the validity of F , which is impossible.
Claim C. B(G(P )|LC ) 6=  if and only if P is valid.
Proof. Consider any imputation x where xa = 1, and where xXi and xXi take distinct values
from the set {0, 1}, for each variable Xi  {X1 , ..., Xm }. Any objection (y, S) to x must be
such that v(S) = 1 (which is indeed the maximum available worth over each coalition S 
N ) and there is no player i  S with xi = 1. It follows that objections are necessarily of the
form (y, S) where w  S, |S| = n+1, and S is consistent w.r.t. {Y1 , . . . , Yn }. In other words,
any objection (y, S) to x is such that S contains w plus one universal player per universally
quantified variable, and thus it is uniquely associated with a truth-value assignment to the
universally quantified variables Y = {Y1 , . . . , Yn }. Let (Y \ S) denote this assignment,
where we set Yj = true if and only if Yj 
/ S, for any 1  j  n. We define also the converse:
given any truth value assignment Y to the universally quantified variables, its associated
objection is the pair (y, S) such that S = {Yj | Y (Yj ) = false}{Yj | Y (Yj ) = true}{w},
1
, for every k  S.
and yk = |S|
Now, if (y, S) is an objection against a player j 
/ {a, X1 , . . . , Xm , X1 , . . . , Xm }, then
(z, {j}) with zj = 0 is a trivial counterobjection. Indeed, such a player j does not belong
to S and may be either an element of {Y1 , . . . , Yn } or an element of {Z1 , . . . , Zq }. In either
cases, v({j}) = xj = 0. On the other hand, if (y, S) is an objection against a player Xi (or,
Xi ), then (z, {Xi , Xi }) with zXi = xXi and zXi = xXi is again a counterobjection, because
v({Xi , Xi }) = z({Xi , Xi }) = 1 and {Xi , Xi }  S = . It follows that the set of objections
that are possibly justified has to be restricted to the objections against player a. Let (y, S)
be an objection of i  S against player a to x. Any counterobjection (z, T ) must have
a  T . Thus, in order to have za  xa = 1, it must be the case that v(T )  1 and, actually,
that v(T ) = 1, due to the definition of the worth function. In particular, the latter entails
that for each player p 6= a with p  T , it holds that zp = 0. Thus, T  S must be empty
and, in particular, the only possibility is that T \ {a} is consistent, and (T ) |= . Finally,
since T  S =  and x(p) = 0 for each p  T with p 6= a, we have that (T ) is a satisfying
assignment for  where: Xi is true in (T ) if and only if Xi is true in (x); Yi is true in
(T ) if and only if Yi 
/ S, and thus Yi is true in (Y \ S). That is, (T ) is a complete
assignment for  that extends both partial assignments (x) and (Y \ S).
By exploiting the above observations, we can now prove the claim.
() Assume that there exists x  B(G(P )|LC ). We have seen that such an imputation x
is associated with a truth-value assignment (x) to the variables in {X1 , . . . , Xm }
recall that an imputation x for which there is an index i, 1  i  m, such that xXi > 0
and xXi > 0 cannot belong to the bargaining set of G(P )|LC . Moreover, we have seen
that every assignment Y to the universally quantified variables corresponds to a
680

fiMixed-Integer Constrained Coalitional Games

possible objection (y, S) to x, and since x belongs to the bargaining set there must
exist a valid counterobjection (z, T ) to (y, S) associated with a satisfying truth-value
assignment for  that extends both partial assignments (x) and Y . This means
that x is a witness of the validity of P .
() If P is valid then there is an assignment X to the variables in {X1 , . . . , Xm } that
witnesses its validity. Consider the imputation x such that, 1  i  m, xXi = 0
and xXi = 1 if X (Xi ) = true, and xXi = 1 and xXi = 0 otherwise. Moreover,
xa = 1 and all other players get 0. Since, for every extension of X to the universally
quantified variables (corresponding to a possible objection (y, S) to x), there exists a
further extension to all variables that satisfies  (corresponding to a counterobjection
to (y, S)), it follows that x  B(G(P )|LC ).
S
i,j,S,T )[y ] contains a point (i.e., a justified obClaim D. (LCi,j,S )[yS ] \ T |iT
S
/ jT (LC
jection to x) that can be represented with polynomially many bits.
Proof. The case where (LCi,j,S )[yS ] and (LCi,j,S,T )[yS ] (for each T | i 
/ T  j  T ) do not
contain integer variables has already been addressed in the proof of Lemma 5.8. We next
show how to preprocess such integer variables, if they occur in the programs at hand.
Recall first that (LCi,j,S )[yS ] is bounded, since LCi,j,S contains the |S| + 1 inequalities:
y(S)  v(S) and yk > xk , k  S. This implies that we can assume, w.l.o.g., that (LCi,j,S )
is bounded in its turn. Indeed, by standard arguments in linear programming it follows that
any point in (LCi,j,S )[yS ] can be obtained as the projection of a point in (LCi,j,S ) whose
auxiliary components (i.e., those not associated with the variables in yS ) are bounded by a
polynomial in the size of LCi,j,S . Thus, this bound can be made explicit in the definition of
LCi,j,S , without altering the projection (LCi,j,S )[yS ].
Second, we observe that we can also assume, w.l.o.g, that (LCi,j,S,T ) is bounded too,
for each T such that i 
/ T  j  T . Indeed, in the definition of LCi,j,S,T , we may constrain
each variable in yS to range within the minimum and maximum values it may assume in
(LCi,j,S )[yS ]note that these extreme values can be represented with polynomially many
bits, since they are achieved S
on some vertices of (LCi,j,S )[yS ]. This modification does not
i,j,S
i,j,S,T )[y ]. Thus, (LCi,j,S,T )[y ] is bounded,
alter the set (LC
)[yS ] \ T |iT
S
S
/ jT (LC
so that (LCi,j,S,T ) can be assumed to be bounded, toosee above.
We can now resume the main proof and show how integer variables can be easily prefC denote the
processed. Let LC be any program in {LCi,j,S }  {LCi,j,S,T | i 
/ T  j  T }, let L
fC) can be represented
linear relaxation of LC, and recall that each vertex of the polytope (L
f
with polynomially many bits. Since (LC) is contained in (LC), such values of the components of the vertices are bounds for every integer component of any vector in (LC), which
can thus be represented with polynomially many bits. Let U be the set of all the admissible
values of all such integer components. Let I(LC) denote the set of all the possible assignments of values from the integer variables of LC to U , and for any assignment z  I(LC),
let LChzi denote the linear program where each integer variable in int(LC) is replaced by its
corresponding value in z. Now, for any pair of assignments z and w belonging to I(LCi,j,S )
and to I(LCi,j,S,T ), respectively, let us say that w matches with z (w.r.t. yS ) if z and w
coincide on their restrictions over yS int(LCi,j,S )int(LCi,j,S,T ). S
Furthermore, let W be the
i,j,S,T )).
set of all non-integer variables in yS , that is, yS \ (int(LCi,j,S )  T |iT
/ jT int(LC
681

fiGreco, Malizia, Palopoli, & Scarcello

S
i,j,S,T )[y ] contains a point that can be
Then, the set (LCi,j,S )[yS ] \ T |iT
S
/ jT (LC
represented with polynomially many bits (resp., is empty) if and only if there is an element
z in I(LCi,j,S ) such that (resp., for each element z in I(LCi,j,S )):


[
[
(LCi,j,S hzi)[W] \ 
(LCi,j,S,T hwi)[W]
T |iT
/ jT

wI(LCi,j,S,T ) | w matches with z

contains an element that can be represented with polynomially many bits (resp., it is empty).
Note that the above expression has the same form as the original one, but no integer
variable occurs in it. To conclude, just observe that LCi,j,S hzi and LCi,j,S,T hwi (T | i 
/
T  j  T ) can be represented with polynomially many bits (w.r.t. the size of the original
mixed-integer linear programs), since they are obtained by mapping integer variables into
values that are representable with polynomially many bits.

References
Agotnes, T., van der Hoek, W., & Wooldridge, M. (2006). Temporal qualitative coalitional
games. In Nakashima, H., Wellman, M. P., Weiss, G., & Stone, P. (Eds.), Proceedings
of the 5th International Conference on Autonomous Agents and Multiagent Systems
(AAMAS 2006), pp. 177184, Hakodate, Japan.
Aumann, R. J. (1961). The core of a cooperative game without side payments. Transactions
of the American Mathematical Society, 98, 539552.
Aumann, R. J. (1985). An axiomatization of the non-transferable utility value. Econometrica, 53 (3), 599612.
Aumann, R. J., & Dreze, J. H. (1974). Cooperative games with coalition structures. International Journal of Game Theory, 3 (4), 217237.
Aumann, R. J., & Hart, S. (Eds.). (1992, 1994, 2002). Handbook of Game Theory With
Economic Applications, Volume 1,2 and 3, Vol. 11 of Handbooks in Economics.
North-Holland, Amsterdam, The Netherlands.
Aumann, R. J., & Maschler, M. (1964). The bargaining set for cooperative games. In
Advances in Game Theory, pp. 443476. Princeton University Press, Princeton, NJ,
USA.
Aumann, R. J., & Peleg, B. (1960). Von Neumann-Morgenstern solutions to cooperative
games without side payments. Bulletin of the American Mathematical Society, 66 (3),
173179.
Bachrach, Y., & Rosenschein, J. S. (2008). Coalitional skill games. In Padgham, L., Parkes,
D. C., Muller, J., & Parsons, S. (Eds.), Proceedings of the 7th International Conference on Autonomous Agents and Multiagent Systems (AAMAS 2008), pp. 10231030,
Estoril, Portugal.
Bilbao, J. M. (2000). Cooperative Games on Combinatorial Structures, Vol. 26 of Theory
and Decision Library C. Kluwer Academinc Publishers, Reading, MA, USA.
Byford, M. C. (2007). A constrained coalitional approach to price formation. In North
American Summer Meetings of the Econometric Society, Durham, NC, USA.
682

fiMixed-Integer Constrained Coalitional Games

Charnes, A. (1953). Constrained games and linear programming. Proceedings of the National
Academy of Sciences of the United States of America, 39 (7), 639641.
Conitzer, V., & Sandholm, T. (2004). Computing shapley values, manipulating value division schemes, and checking core membership in multi-issue domains. In McGuinness,
D. L., & Ferguson, G. (Eds.), Proceedings of the 19th National Conference on Artificial
Intelligence (AAAI-04), pp. 219225, San Jose, CA, USA.
Davis, M., & Maschler, M. (1965). The kernel of a cooperative game.. Naval Research
Logistics Quarterly, 12, 223259.
Deng, X., & Papadimitriou, C. H. (1994). On the complexity of cooperative solution concepts. Mathematics of Operations Research, 19 (2), 257266.
Dunne, P. E., van der Hoek, W., Kraus, S., & Wooldridge, M. (2008). Cooperative boolean
games. In Padgham, L., Parkes, D. C., Muller, J., & Parsons, S. (Eds.), Proceedings
of the 7th International Conference on Autonomous Agents and Multiagent Systems
(AAMAS 2008), pp. 10151022, Estoril, Portugal.
Edgeworth, F. Y. (1881). Mathematical Psychics: An essay on the mathematics to the moral
sciences. C. Kegan Paul & Co., London.
Elkind, E., Goldberg, L. A., Goldberg, P. W., & Wooldridge, M. (2009). On the computational complexity of weighted voting games. Annals of Mathematics and Artificial
Intelligence, 56 (2), 109131.
Elkind, E., & Pasechnik, D. (2009). Computing the nucleolus of weighted voting games.
In Mathieu, C. (Ed.), Proceedings of the 20th Annual ACM-SIAM Symposium on
Discrete Algorithms (SODA09), pp. 327335, New York, NY, USA.
Gillies, D. B. (1959). Solutions to general non-zero-sum games. In Tucker, A. W., & Luce,
R. D. (Eds.), Contributions to the Theory of Games, Volume IV, Vol. 40 of Annals of
Mathematics Studies, pp. 4785. Princeton University Press, Princeton, NJ, USA.
Greco, G., Malizia, E., Palopoli, L., & Scarcello, F. (2009a). Constrained coalitional games:
formal framework, properties, and complexity results (extended abstract). In Sierra,
C., Castelfranchi, C., Decker, K. S., & Sichman, J. S. (Eds.), Proceedings of the
8th International Conference on Autonomous Agents and Multiagent Systems (AAMAS 2009), pp. 12951296, Budapest, Hungary.
Greco, G., Malizia, E., Palopoli, L., & Scarcello, F. (2009b). On the complexity of compact coalitional games. In Boutilier, C. (Ed.), Proceedings of the 21th International Joint Conference on Artificial Intelligence (IJCAI-09), pp. 147152, Pasadena,
CA, USA. An extended version is available as the technical report arXiv:0810.3136
(http://arxiv.org/abs/0810.3136).
Hart, S. (2004). A comparison of non-transferable utility values. Theory and Decision,
56 (12), 3546.
Ieong, S., & Shoham, Y. (2005). Marginal contribution nets: a compact representation
scheme for coalitional games. In Riedl, J., Kearns, M. J., & Reiter, M. K. (Eds.), Proceedings of the 6th ACM Conference on Electronic Commerce (EC05), pp. 193202,
Vancouver, BC, Canada.
683

fiGreco, Malizia, Palopoli, & Scarcello

Ieong, S., & Shoham, Y. (2006). Multi-attribute coalitional games. In Feigenbaum, J.,
Chuang, J., & Pennock, D. M. (Eds.), Proceedings of the 7th ACM Conference on
Electronic Commerce (EC06), pp. 170179, Ann Arbor, MI, USA.
Ieong, S., & Shoham, Y. (2008). Bayesian coalitional games. In Fox, D., & Gomes, C. P.
(Eds.), Proceedings of the 23rd National Conference on Artificial Intelligence (AAAI08), pp. 95100, Chicago, IL, USA.
Jiang, T., & Baras, J. S. (2007). Fundamental tradeoffs and constrained coalitional games
in autonomic wireless networks. In Proceedings of the 5th International Symposium on
Modeling and Optimization in Mobile, Ad Hoc, and Wireless Networks (WiOpt07),
pp. 18, Limassol, Cyprus.
Johnson, D. S. (1990). A catalog of complexity classes. In van Leeuwen, J. (Ed.), Handbook
of Theoretical Computer Science, Volume A: Algorithms and Complexity, pp. 67161.
The MIT Press, Cambridge, MA, USA.
Kalai, E. (1975). Excess functions for cooperative games without sidepayments. SIAM
Journal of Applied Mathematics, 29 (1), 6071.
Malizia, E., Palopoli, L., & Scarcello, F. (2007). Infeasibility certificates and the complexity
of the core in coalitional games. In Veloso, M. M. (Ed.), Proceedings of the 20th
International Joint Conference on Artificial Intelligence (IJCAI-07), pp. 14021407,
Hyderabad, India.
Maschler, M. (1992). The bargaining set, kernel, and nucleolus. In Aumann, R. J., & Hart,
S. (Eds.), Handbook of Game Theory, Volume 1, Vol. 11 of Handbooks in Economics,
chap. 18. North-Holland, Amsterdam, The Netherlands.
McLean, R. P. (2002). Values of non-transferable utility games. In Aumann, R. J., & Hart,
S. (Eds.), Handbook of Game Theory, Volume 3, Vol. 11 of Handbooks in Economics,
chap. 55. North-Holland, Amsterdam, The Netherlands.
Nemhauser, G. L., & Wolsey, L. A. (1988). Integer and combinatorial optimization. WileyInterscience Series in Discrete Mathematics and Optimization. Wiley-Interscience,
New York, NY, USA.
Orshan, G., & Zarzuelo, J. M. (2000). The bilateral consistent prekernel for ntu games.
Games and Economic Behavior, 32 (1), 6784.
Osborne, M. J., & Rubinstein, A. (1994). A Course in Game Theory. The MIT Press,
Cambridge, MA, USA.
Owen, G. (1975). On the core of linear production games. Mathematical Programming,
9 (1), 358370.
Papadimitriou, C., & Steiglitz, K. (1998). Combinatorial Optimization: Algorithms and
Complexity (2nd edition). Dover Publications.
Peleg, B. (1963). Bargaining sets of cooperative games without side payments. Israel Journal
of Mathematics, 1 (4), 197200.
Peleg, B., & Sudholter, P. (2007). Introduction to the Theory of Cooperative Games (2nd
edition). Theory and Decision Library. Springer, Berlin, Germany.

684

fiMixed-Integer Constrained Coalitional Games

Rahwan, T., Ramchurn, S. D., Jennings, N. R., & Giovannucci, A. (2009). Anytime algorithm for optimal coalition structure generation. Journal of Artificial Intelligence
Research, 34, 521567.
Ryan, M. J. (1998). Constrained games, intervening duality and experimenter-experiment
interactions. European Journal of Operational Research, 110 (2), 326341.
Schmeidler, D. (1969). The nucleolus of a characteristic function game. SIAM Journal of
Applied Mathematics, 17 (6), 11631170.
Selman, A. L. (1994). A taxonomy of complexity classes of functions. Journal of Computer
and System Sciences, 48 (2), 357381.
Semple, J. (1997). Constrained games for evaluating organizational performance. European
Journal of Operational Research, 96 (1), 103112.
Serrano, R. (1997). Reinterpreting the kernel. Journal of Economic Theory, 77 (1), 5880.
Shapley, L. S. (1953). A value for n-person games. In Kuhn, H. W., & Tucker, A. W. (Eds.),
Contributions to the Theory of Games, Volume II, Vol. 28 of Annals of Mathematics
Studies, pp. 307317. Princeton University Press, Princeton, NJ, USA.
Shapley, L. S. (1969). Utility comparison and the theory of games. In La Decision, pp.
251263. Editions du Centre National de le Recherche Scientifique, Paris.
Shoham, Y. (2008). Computer science and game theory. Communications of the ACM,
51 (8), 7479.
Simon, H. A. (1972). Theories of bounded rationality. In McGuire, C. B., & Radner, R.
(Eds.), Decision and Organization, Vol. 12 of Studies in Mathematical and Managerial
Economics, pp. 161176. North-Holland, Amsterdam, The Netherlands.
von Neumann, J., & Morgenstern, O. (1944). Theory of Games and Economic Behavior
(1st edition). Princeton University Press, Princeton, NJ, USA.
Weber, R. J. (1994). Games in coalitional form. In Aumann, R. J., & Hart, S. (Eds.),
Handbook of Game Theory, Volume 2, Vol. 11 of Handbooks in Economics, chap. 36.
North-Holland, Amsterdam, The Netherlands.
Winter, E. (2002). The shapley value. In Aumann, R. J., & Hart, S. (Eds.), Handbook of
Game Theory, Volume 3, Vol. 11 of Handbooks in Economics, chap. 53. North-Holland,
Amsterdam, The Netherlands.
Wooldridge, M., & Dunne, P. E. (2004). On the computational complexity of qualitative
coalitional games. Artificial Intelligence, 158 (1), 2773.
Wooldridge, M., & Dunne, P. E. (2006). On the computational complexity of coalitional
resource games. Artificial Intelligence, 170 (10), 835871.

685

fi