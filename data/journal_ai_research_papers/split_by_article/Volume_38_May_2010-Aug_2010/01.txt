Journal of Artificial Intelligence Research 38 (2010) 49-84

Submitted 11/09; published 05/10

Change in Abstract Argumentation Frameworks:
Adding an Argument
Claudette Cayrol
Florence Dupin de Saint-Cyr
Marie-Christine Lagasquie-Schiex

ccayrol@irit.fr
bannay@irit.fr
lagasq@irit.fr

IRIT, Universite Paul Sabatier,
118 route de Narbonne, 31062 Toulouse, France

Abstract
In this paper, we address the problem of change in an abstract argumentation system.
We focus on a particular change: the addition of a new argument which interacts with
previous arguments. We study the impact of such an addition on the outcome of the argumentation system, more particularly on the set of its extensions. Several properties for this
change operation are defined by comparing the new set of extensions to the initial one, these
properties are called structural when the comparisons are based on set-cardinality or setinclusion relations. Several other properties are proposed where comparisons are based on
the status of some particular arguments: the accepted arguments; these properties refer to
the evolution of this status during the change, e.g., Monotony and Priority to Recency.
All these properties may be more or less desirable according to specific applications. They
are studied under two particular semantics: the grounded and preferred semantics.

1. Introduction
Argumentation has become an influential approach to handle Artificial Intelligence problems
including defeasible reasoning (see e.g., Pollock, 1992; Dung, 1995; Bondarenko, Dung,
Kowalski, & Toni, 1997; Chesnevar, Maguitman, & Loui, 2000; Prakken & Vreeswijk, 2002;
Amgoud & Cayrol, 2002; Nute, 2003), and modeling agents interactions (see e.g., Amgoud,
Maudet, & Parsons, 2000; Kakas & Moratis, 2003). Argumentation is basically concerned
with the exchange of interacting arguments. This set of arguments may come either from
a dialogue between several agents but also from the available (and possibly contradictory)
pieces of information at the disposal of one unique agent. Usually, the interaction between
arguments takes the form of a conflict, called attack. For example, a logical argument
can be a pair hset of assumptions, conclusioni, where the set of assumptions entails the
conclusion according to some logical inference schema. A conflict occurs, for instance, when
the conclusion of an argument contradicts an assumption of another argument.
The main issue for any argumentation system is the selection of acceptable sets of arguments, called extensions, based on the way arguments interact (intuitively, an acceptable
set of arguments must be in some sense coherent and strong enough, e.g., able to defend
itself against all attacking arguments). So, the outcome of an argumentation system is
often defined by the set of its extensions but, depending on the applications, it may be also
defined as the set of arguments that belongs to every extension. It is convenient to explore
the concept of extension through argumentation frameworks, and especially Dungs (1995)
c
2010
AI Access Foundation. All rights reserved.

fiCayrol, Dupin de Saint-Cyr & Lagasquie-Schiex

framework, which abstracts from the arguments nature, and represents interaction under
the form of a binary relation attack on a set of arguments.
Recent works have considered the dynamics of such abstract argumentation frameworks
(Cayrol, Dupin de Saint-Cyr, & Lagasquie-Schiex, 2008; Rotstein, Moguillansky, Garca, &
Simari, 2008b; Boella, Kaci, & van der Torre, 2009a, 2009b). The problem is to study how
the outcome changes when the set of arguments and/or the set of attacks between them
are changed. In this paper, we focus on the case when a new argument and its interactions
are added to an argumentation system. We study the impact of such an addition on the
set of initial extensions. This leads us to identify some properties of the change operation
with respect to the modification it induces on the outcome. This study has two main
applications, the first one concerns computational issues, while the second one concerns the
definition of dialogue strategies. On one hand, the interest for computational processing
is that knowledge about the properties of the change may help to deduce what are the
modifications in the extensions. For instance, it is useful to know conditions under which
change will not modify the previous extensions. On the other hand, knowing the impact of
adding an argument may help choosing the good one in order to achieve a given goal. For
instance, in a multi-agent setting, i.e., when several agents may present several arguments,
the results presented in this paper will help one agent to determine which arguments she
should present in order that the outcome of the dialogue satisfies desired properties. For
example, if she wants to widen the debate, the argument that must be added should induce
a change producing larger extensions (i.e. that contain more arguments, see Section 3 and
Section 5).
The paper is organized as follows. Section 2 recalls the basic concepts in argumentation.
Section 3 settles a definition of change in argumentation. Many features can be taken into
account in order to characterize a change operation. We first propose a class of properties
based on the impact of the change on the structure of the resulting set of extensions (see
Section 3.2). In a second step, we define several other properties regarding the arguments
themselves, particularly those which are accepted after change (see Section 3.3). These
properties are defined regardless of the semantics.
Then, we focus on a particular change: the addition of a new argument which may
interact with previously introduced arguments. Section 4 is dedicated to the study of the
properties of this addition in the case of two particular semantics, the grounded and the
preferred semantics. We give conditions under which a given property is satisfied. Section 5
discusses the related approaches in the literature. All the proofs (and two important lemmas) are given in Appendix A. Some additional examples are presented in Appendix B for
illustrating the other change operations.
Note that this paper generalizes a previous work (Cayrol et al., 2008), where argument
addition, called revision, was restricted to one argument having only one interaction
with the existing argumentation system. Here, the added argument may interact with any
number of previous arguments. Moreover, a broader analysis of this generalized addition
is provided by considering new properties such as, e.g., Monotony, and by establishing new
connections between the different properties.
50

fiChange in Argumentation Systems

2. Basic Concepts in Argumentation Frameworks
The present work lies in the frame of the general theory of abstract argumentation frameworks proposed by Dung (1995). Such an abstract framework assumes that a set of arguments is given, as well as the different conflicts between them, and focuses on the definition
of the status of arguments.
Definition 1 (Argumentation framework) An argumentation framework hA, Ri is a
pair, where A is a non-empty set and R is a binary relation on A, called attack relation.
Let A, B  A, (A, B)  R or equivalently ARB means that A attacks B, or B is attacked
by A.
In the following, hA, Ri is an argumentation framework, and we assume that the set of
arguments A is finite. First, it is easy to extend the concept of attack to sets of arguments.
Definition 2 (Attack from and to a set) Let A  A and S  A.1
 S attacks A iff X  S such that XRA.
 A attacks S iff X  S such that ARX.
The main issue of any argumentation system is the selection of acceptable sets of arguments. Intuitively, an acceptable set of arguments must be in some sense coherent and
strong enough (e.g., able to defend itself against every attacking argument). An argumentation semantics defines the properties required for a set of arguments to be acceptable (this
is a collective acceptability). The selected sets of arguments under a given semantics are
called extensions of that semantics. The set of extensions characterizes the outcome of an
argumentation system. We recall the basic concepts used for defining usual semantics:
Definition 3 (Conflict-free, defense) Let A  A and S  A.
 S is conflict-free iff A, B  S such that ARB.
 S defends A iff S attacks each argument which attacks A. The set of arguments which
S defends will be denoted by F(S). F is called the characteristic function of hA, Ri.
The literature proposes an increasing variety of semantics, refining Dungs traditional
ones (Baroni, Giacomin, & Guida, 2005; Caminada, 2006; Dung, Mancarella, & Toni, 2006;
Coste-Marquis, Devred, & Marquis, 2005). In this paper, only the most well-known traditional semantics are considered: the grounded, preferred and stable semantics.
Definition 4 (Acceptability semantics) Let E  A.
 E is admissible iff E is conflict-free and defends all its elements (i.e. E  F(E)).
 E is a preferred extension iff E is a maximal (w.r.t. set-inclusion) admissible set.
1. In this paper, we use  to denote strict inclusion and  to denote classical inclusion.

51

fiCayrol, Dupin de Saint-Cyr & Lagasquie-Schiex

 E is the grounded extension iff E is the least fixed point (w.r.t. set-inclusion) of the
characteristic function F.
 E is a stable extension iff E is conflict-free and attacks each argument which does not
belong to E.
An argumentation framework can be represented as a directed graph, called attack
graph, where nodes are the arguments and edges represent the attack relation. Throughout
the paper, examples are using this graph representation.
Example 1
A = {A, B, C, D, F } and R = {(A, B), (B, A), (B, C), (C, D), (D, F ), (F, C)}.
The admissible sets are {}, {A}, {B} and {B, D}.
B
C
D
The preferred extensions are {A} and {B, D}.
The
grounded extension is {}.
A
F
{B, D} is the unique stable extension.
Using the graph-based representation of an argumentation framework, we extend the
definition of individual attack as follows:
Definition 5 (indirect attack and defense) Let G denote the attack graph associated
with hA, Ri. Let A, B  A.
 A indirectly attacks B iff there is an odd-length path from A to B in the attack graph
G.
 A indirectly defends B iff there is an even-length path (with non-zero length) from A
to B in the attack graph G.
Note that the case when A attacks B is considered as a particular case of indirect attack.
Dung (1995) has proved the following results.
Proposition 1 Let hA, Ri be an argumentation framework.
1. There is at least one preferred extension, always a unique grounded extension, while
there may be zero, one or many stable extensions.
2. Each admissible set is included in a preferred extension.
3. Each stable extension is a preferred extension, the converse is false.
4. The grounded extension is included in each preferred extension.
5. Each argument which is not attacked belongs to the grounded extension (hence to each
preferred and to each stable extension).
6. If R is finite, the grounded extension can be computed by iteratively applying the
function F from the empty set.
52

fiChange in Argumentation Systems

The presence of cycles in the attack graph has often raised some problems, namely for the
stable semantics, for which it may happen that no extension exists. Note that some authors
only consider attack graphs without odd-length cycles, arguing that an odd-length cycle
carries counterintuitive information. The following results give properties of the preferred,
grounded and stable extensions depending on the existence of cycles in the attack graph.
Proposition 2 (Dunne & Bench-Capon, 2001, 2002) Let G denote the attack graph associated with hA, Ri.
1. If G contains no cycle, hA, Ri has a unique preferred extension, which is also the
grounded extension and the unique stable extension.
2. If {} is the unique preferred extension of hA, Ri, G contains an odd-length cycle.
3. If hA, Ri has no stable extension, G contains an odd-length cycle.
4. If G contains no odd-length cycle, preferred and stable extensions coincide.
5. If G contains no even-length cycle, hA, Ri has a unique preferred extension.
Now that acceptable sets of arguments have been defined, it is possible to define a status
for an individual argument.
Definition 6 (Argument status) Let hA, Ri be an argumentation framework and A 
A. Given a semantics s:
 A is skeptically accepted under s iff A belongs to each extension of hA, Ri under s.
 A is credulously accepted under s iff A belongs to at least one extension of hA, Ri
under s.
 A is rejected under s iff A does not belong to any extension of hA, Ri under s.
Obviously, credulous and skeptical acceptance coincide under the grounded semantics.

3. Change in Argumentation
We introduce a formal definition of change in argumentation which enables to distinguish
between four types of change. Then we define properties for change in argumentation. First,
we consider the impact of a change operation on the structure of the set of extensions, and
we study how this structure is modified. This point of view leads to the definition of
structural properties. Then, we consider the impact of a change operation on the set of
arguments which are accepted. Finally, the connections between both classes of properties
are studied.
Note that for most of the properties that we introduce, the definition is general in the
sense that it can be applied to any type of change. In Section 4 (where we give conditions
for satisfying these properties), we will focus on the particular case of the addition of an
argument and its interactions.
53

fiCayrol, Dupin de Saint-Cyr & Lagasquie-Schiex

3.1 Definition
In this section, we give a definition of change in argumentation. The change may concern
the set of arguments and/or the set of attacks between them. So, at least four cases can be
encountered:
Definition 7 (Change operations) Let hA, Ri be an argumentation framework.
 adding only one interaction i0 between two existing arguments of A (i0 = (X, Y ) with
X  A and Y  A) is a change operation defined by:
hA, Rii i0 = hA, R  {i0 }i
 removing only one existing interaction i0 of hA, Ri (i0  R) is a change operation
defined by:
hA, Rii i0 = hA, R \ {i0 }i
 adding only one argument Z 6 A and a set of interactions concerning Z denoted by
Iz is a change operation defined by:
a

hA, Rii (Z, Iz ) = hA  {Z}, R  Iz i
Here, Iz is supposed to be a non-empty set of pairs of arguments (either of the form
(X, Z) or (Z, X) with X  A)2
 removing only one argument Z  A which interacts with other arguments is a change
operation defined by:
a
hA, Rii Z = hA \ {Z}, R \ Iz i
Here, Iz denotes the set of all the interactions concerning Z, that is the set {(Z, X) |
(Z, X)  R}  {(X, Z)|(X, Z)  R}3
Note that the case of adding a new argument (resp. removing an existing argument)
which does not interact with any other argument is trivial: it has only to be added to (resp.
removed from) each extension. Indeed, change is more interesting when the concerned
argument interacts with previous ones.
In a very recent work about dynamics of argumentation (Boella et al., 2009a, 2009b),
the four types of change defined above have been introduced under different names, respectively attack refinement, attack abstraction, argument refinement and argument abstraction. However, only the operations of attack refinement, attack abstraction and argument
abstraction have been studied and in a more restricted context (see Section 5 for a discussion).
In the following, we identify an argumentation framework hA, Ri with its associated
attack graph G. We write X  G instead of X is an argument represented by a node of G.
The set of extensions of hA, Ri is denoted by E (with E1 , . . . , En denoting the extensions).
2. Note that, by this definition, it is impossible to have (Z, Z) in Iz .
3. Note that if Z is removed, the set of interactions concerning Z must be also removed.

54

fiChange in Argumentation Systems

A change operation produces a new framework hA , R i represented by a graph G  , with
a new set of extensions E (with E1 , . . . , Ep denoting the extensions).
As explained above, changing an argumentation framework may modify the set of extensions. Given a semantics, the modifications are more or less important. It depends on
the kinds of interactions that are added or removed and more precisely on the status of the
arguments involved in these interactions.
The impact of a change can be studied from two points of view:
 the first one concerns the structure of the set of extensions and it can address either
the comparison of the number of extensions before and after the change, or, if this
number remains unchanged, the comparison of the contents of the extensions before
and after the change;
 the second point of view concerns the status of some particular arguments.
So, in the next sections, we propose two classes of general properties for a change
operation, one for each point of view. The proposed properties characterize the relation
between a particular framework and the resulting framework after a change.
3.2 Structural Properties
Structural properties, presented in this section, are based on the impact of the change on
the structure of the set of extensions. Note that for each property, the definition is general
in the sense that the type of change operation is not specified: it can consist in adding
one interaction, removing one interaction, adding an argument and a set of interactions
concerning this argument, or removing one argument. However, for sake of clarity, each
a
property will be illustrated in this section with examples for the change operation i ; the
reader will find some examples for the other change operations in Appendix B.
Let hA, Ri be an argumentation framework and E be the set of extensions of hA, Ri
(under a given semantics s). Various situations may be encountered in the general case.
E may be empty (implying that s is the stable semantics), may be reduced to a singleton
{E1 } (where E1 may be empty), or may contain more than one extension {E1 , . . . , En }. The
situation with only one non-empty extension is convenient for the determination of the
status of an argument. By contrast, when several extensions exist, different choices are
available. Table 1 summarizes the various definitions presented below.
We first consider the decisive property for a change operation, meaning that G  has a
unique non-empty extension, while it was not the case for G.
Definition 8 (Decisive change) The change from G to G  is decisive iff E = , or E =
{{}}, or E = {E1 , . . . , En }, n  2, and E = {E  }, E  6= {}.
Example 2
1. Under the stable (resp. grounded or preferred) semantics, the change
Iz = {(Z, A)} is decisive since:
A

B

Z

C

E =  (resp. E = {{}}),
E = {{Z, B}}
55

ai with Z

and

fiCayrol, Dupin de Saint-Cyr & Lagasquie-Schiex

Property for a change operation
the change is decisive
the change is restrictive
the change is questioning
the change is destructive
the change is expansive
the change is conservative
the change is altering

Characterization of the property
E =  or E = {{}} or |E| > 2
and |E | = 1 and E 6= {{}}
|E| > |E | > 2
|E| < |E |
E 6=  and E 6= {{}}
E =  or E = {{}}
|E| = |E | and

Ej  E , Ei  E, Ei  Ej
E = E
|E| = |E | and
Ei  E s.t. Ej  E , Ei 6 Ej

Table 1: Structural properties for a change operation
2. Under the grounded semantics, the change
since:
Z

A

B

C

B

Z

C

F

D

B

ai

with Z and Iz = {(Z, A)} is decisive

ai

with Z and Iz = {(Z, A), (B, Z)} is

E = {{A}, {B, D}},
E = {{Z, B, D}}

4. Under the preferred semantics, the change
decisive since:
A

with Z and Iz = {(Z, A)} is decisive

E = {{}},
E = {{Z, B}}

3. Under the preferred semantics, the change
since:
A

ai

E = {{A}, {B}},
E = {{B}} (note that Z is rejected)

Z

A weaker requirement is the decrease of the number of choices. A change such that G 
has strictly less extensions than G, but still has at least two, is called restrictive4 . Note
that the restrictive property does not make sense under the grounded semantics, since there
is always a unique grounded extension.
Definition 9 (Restrictive change) The change from G to G  is restrictive iff E = {E1 ,
. . . , En }, n  2, and E = {E1 , . . . , Ep }, with n > p  2.
Example 3
1. Under the preferred (or stable) semantics, the change
is restrictive since:
A

B

C

Z

F

D

ai

with Z and Iz = {(Z, A)}

E = {{A, C, F }, {A, D}, {B, D}, {B, F }},
E = {{Z, C, F }, {Z, B, D}, {Z, B, F }}

4. In the work of Cayrol et al. (2008), this kind of change was called selective.

56

fiChange in Argumentation Systems

2. Under the preferred semantics, the change
restrictive since:
A

B

C

Z

ai

with Z and Iz = {(Z, A), (B, Z)} is

E = {{A}, {B}, {C}},
E = {{B}, {C, Z}} (note that Z is not skeptically
accepted)

An opposite point of view enables to consider changes which raise ambiguity, by increasing the number of extensions. This is the case for instance when G has at least one
non-empty extension and G  has strictly more extensions than G. A slightly different situation occurs when G has no extension or an empty one, while G  has more than one extension.
In that case, change brings some information, but is not decisive. Such changes are called
questioning. As for the restrictive property, the questioning property does not make sense
under the grounded semantics.
Definition 10 (Questioning change) The change from G to G  is questioning iff E =
{E1 , . . . , Ep }, with p  2, and either E = , or E = {E1 , . . . , En } and p > n  1.
Example 4
1. Under the preferred (or stable) semantics, the change
is questioning since:
A

B

D

Z

C

F

B

Z

C

D

G

F

ai

A

D

B

C

with Z and Iz = {(Z, A)} is questioning

E = ,
E = {{Z, B, F }, {Z, B, G}}

3. Under the preferred semantics, the change
(Z, B), (B, Z)} is questioning since:
Z

with Z and Iz = {(Z, A)}

E = {{A, D, F }},
E = {{Z, B, C}, {Z, B, F }, {Z, D, C}, {Z, D, F }}

2. Under the stable semantics, the change
since:
A

ai

ai

with Z and Iz = {(Z, A), (A, Z),

E = {{A, D}, {B, D}},
E = {{A, D}, {B, D}, {Z}} (note that Z is not skeptically accepted)

Pursuing along the previous line, we consider changes leading to a kind of decisional
dead-end. This is the case when G has at least one non-empty extension and G  has no
extension, or an empty one5 . Such a change is called destructive.
Definition 11 (Destructive change) The change from G to G  is destructive iff E =
{E1 , . . . , En }, n  1, Ei 6= {} and E =  or E = {{}}.
Example 5
5. These are two different cases but they have the same impact: there is no possible decision because no
argument is accepted.

57

fiCayrol, Dupin de Saint-Cyr & Lagasquie-Schiex

1. Under the stable semantics, the change
since:
A

B

D

H

Z

C

G

F

ai

with Z and Iz = {(Z, A)} is destructive

E = {{A, D, F }, {A, D, G}},
E = 
a

2. Under the preferred (or grounded) semantics, the change i with Z and Iz = {(Z, A),
(B, Z)} is destructive since:
B

A

E = {{A}},
E = {{}}

Z

a

3. Under the preferred semantics, the change i with Z and Iz = {(Z, A), (Z, B), (F, Z)}
is destructive since:
B

A

C

Z

F

D

E = {{A}, {B, D}},
E = {{}}

So far, the considered changes have an impact on the number of extensions. Now, we
are interested in changes which may modify the content of extensions, without modifying
the number of extensions. The most interesting situation occurs when each extension of G 
strictly includes one extension of G, the number of extensions being the same. Such changes
are called expansive.
Definition 12 (Expansive change) The change from G to G  is expansive iff G and G 
have the same number of extensions and each extension of G  strictly includes an extension
of G.
Example 6 Under the preferred (or stable) semantics, the change
{(B, Z)} is expansive since:
A

B

C

Z

D

ai

with Z and Iz =

E = {{A, C}, {A, D}},
E = {{Z, A, C}, {Z, A, D}}

In the particular case when the set of extensions remains unchanged, the change is called
conservative.
Definition 13 (Conservative change) The change from G to G  is conservative iff G and
G  have exactly the same extensions, that is E = E .
Example 7
1. Under the preferred semantics, the change
vative since:
A

B

C

Z

B

Z

with Z and Iz = {(B, Z)} is conser-

ai

with Z and Iz = {(A, Z)} is conser-

E = {{}},
E = {{}}

2. Under the preferred semantics, the change
vative since:
A

ai

C

E = {{A, C}},
E = {{A, C}}

58

fiChange in Argumentation Systems

3. Under the preferred semantics, the change
vative since:
A

B

C

Z

D

ai

with Z and Iz = {(A, Z)} is conser-

E = {{A, C}, {A, D}},
E = {{A, C}, {A, D}}

Otherwise, it may happen that G and G  have the same number of extensions but some
extensions (and sometimes all of them) are altered. This is called an altering change.
Definition 14 (Altering change) The change from G to G  is altering iff G and G  have
the same number of extensions and there exists at least one extension Ei of G such that Ej
extension of G  , Ei * Ej .
It is the case for instance when each extension of G  has a non-empty intersection with
(but does not include) an extension of G.
Example 8
1. Under the grounded semantics, the change
since:
A

B

Z

C

D

B

C

with Z and Iz = {(Z, A)} is altering

ai

with Z and Iz = {(Z, E), (F, Z)} is

E = {{A, D},
E = {{Z, B, D}}

2. Under the preferred semantics, the change
altering since:
A

ai

D

E

F

Z

E = {{A, C, E}},
E = {{A, C}} (note that Z is rejected)

The above discussion can be summarized on Table 2. In this table, it can be checked
that cells with #i correspond to situations which cannot occur:
#1 and #2 The only acceptability semantics in which an argumentation framework may
have no extension is the stable semantics. However, with the stable semantics, an
argumentation framework cannot have an empty extension when its set of arguments
is not empty. And, by assumption, the cases #1 and #2 correspond to argumentation
frameworks with non-empty sets of arguments (because by assumption either Iz 6= 
or there exists one interaction i = (X, Y ), so there is at least one X in G and this X
and eventually Z belong to G  ). So these cases do not occur for any change operation
and any acceptability semantics considered in this paper.
Note that the structural properties presented on Table 2 are mutually exclusive (that is
a change operation cannot satisfy two of them).
59

fiCayrol, Dupin de Saint-Cyr & Lagasquie-Schiex

E =



E=

{{}}

{{}}

conservative
#2

#1
conservative

{E1 }

{E1 , . . . , Ep }
p2

decisive

questioning

conservative
expansive
altering

{E1 }

destructive
{E1 , . . . , En }
n2

decisive

questioning
n < p:
questioning
n > p:
restrictive
n = p:
conservative
expansive
altering

With Ei 6= {} and Ei 6= {}. Each cell of the table contains the name of the corresponding
property for a change operation.

Table 2: Structural properties of a change operation
3.3 Status-Based Properties
In this section, we are interested in the impact of a change operation on the status of some
particular arguments.
 First, we are interested in the status of the arguments which were accepted before
change. This leads to propose a property called Monotony, which can be defined
for any type of change.
 Another interesting issue concerns the status of the argument which is added in a
a
change. Obviously, it concerns only the change operation i ; This leads to propose a
property called Priority to Recency which only makes sense for one type of change.
3.3.1 Monotony
Inspired by what has been done in the field of non-monotonic inference, we define a property
of monotony for expressing that arguments accepted before change remain accepted after
change. Since our aim is to define general properties, we make no assumption about the
number of extensions, and we have to consider different cases for acceptance of an argument
(credulously or skeptically accepted).
A monotony definition is straightforward under a semantics providing only one extension
(such as the grounded semantics, for instance). Following Definition 6, an argument A is
accepted (credulously or skeptically) in hA, Ri iff it belongs to the (unique) extension of
G. So, in that particular case, monotony means that the extension of G is included in the
extension of G  . When there are several extensions, monotony can take different forms. A
credulous form corresponds to the case where each argument credulously accepted from G
60

fiChange in Argumentation Systems

is also credulously accepted from G  . A skeptical form corresponds to the case when each
argument skeptically accepted from G is also skeptically accepted from G  . So these ideas
lead to the following definition:
Definition 15 (Monotony)
 The change from G to G  satisfies Monotony iff each extension of G is included in at
least one extension of G  .
 The change from G to G  satisfies Credulous Monotony6 iff the union of the extensions
of G is included in the union of the extensions of G  .
 The change from G to G  satisfies Skeptical Monotony iff the intersection of the extensions of G is included in the intersection of the extensions of G  .
a

For the change operation i , Examples 2.1, 2.2, 4.3, 6, 7 illustrate the case when the
a
property of Monotony holds; and, again for the change operation i , Examples 2.3, 2.4,
3.1, 3.2, 4.1, 4.2, 5, 8.1, 8.2 illustrate the case when the property of Monotony does not
hold7 .
Obviously, Monotony implies Credulous Monotony. However, Monotony does not imply
Skeptical Monotony (see Example 4. 3) and Skeptical Monotony does not imply Monotony
(see Examples 2.3, 2.4, 3.1, 3.2). Under a semantics providing only one extension, the three
notions of Monotony coincide.
The Monotony property is defined at the level of extensions. A similar notion can be
defined at the level of arguments:
Definition 16 (Partial Monotony for an argument) Let X be an argument.
The change from G to G  satisfies Partial Monotony for X iff when X belongs to an extension
of G, it also belongs to at least one extension of G  .
It is easy to prove that Monotony (resp. Credulous Monotony) implies Partial Monotony
for each argument of G. It is not the case with the property of Skeptical Monotony (see the
argument A in Example 2.4).
3.3.2 Priority to Recency
The next property concerns the status of the argument which is added in a change. Inspired by what has been done in the field of belief revision (see Alchourron, Gardenfors, &
Makinson, 1985), and the postulate concerning the priority of the new piece of information,
we define a property for expressing that the new argument is accepted after change. This
a
property called Priority to Recency8 makes sense only for the change operation i .
6. Credulous Monotony is related to the well-known decision problem of credulous acceptance in argumentation (see Definition 6).
7. In Appendix B, the reader will find some examples illustrating the property of Monotony for the other
change operations.
8. This property is not a characteristic postulate in AGMs sense; it has just been inspired by the Success
postulate proposed by Alchourron et al. (1985).

61

fiCayrol, Dupin de Saint-Cyr & Lagasquie-Schiex

a

Definition 17 (Priority to Recency) The change i from G to G  satisfies Priority to
Recency iff G  has at least one extension and the added argument Z belongs to each extension
of G  .
Examples 2.1 to 2.3, 3.1, 4.1, 4.2, 6, 8.1 are examples of change satisfying Priority to
Recency. Examples 2.4, 3.2, 4.3, 5, 7, 8.2 are examples of change that do not satisfy Priority
to Recency.
3.4 Connections between Properties
Some links between structural properties and status-based properties can be established.
The following propositions enumerate results that hold for any type of change.
Proposition 3
 A conservative change always satisfies Monotony and Skeptical Monotony.
 An expansive change always satisfies Monotony and Skeptical Monotony.
 A decisive change which satisfies Monotony also satisfies Skeptical Monotony.
 In the particular case of a semantics providing only one extension, a change satisfies
Monotony (and Skeptical Monotony) iff it is either decisive, or expansive, or conservative.
Proposition 4
 A destructive change never satisfies Monotony.
 An altering change never satisfies Monotony.
 A restrictive change never satisfies Monotony.
a

Moreover, in the particular case of the change i , other connections between structural
properties and Priority to Recency can be established.
Proposition 5
 A conservative change
 A destructive change

ai

ai

never satisfies Priority to Recency.

never satisfies Priority to Recency.

And in the particular case of grounded, stable and preferred semantics, we have:
Proposition 6 Under the grounded, stable and preferred semantics, an expansive change
ai always satisfies Priority to Recency.
From the above results and examples given in Sections 3.2 and 3.3, inclusion links
a
between different changes of the type i are synthesized on Figure 19 . Table 3 gives the
references of the examples and propositions used for identifying these links.
9. The inclusion of Expansive changes into the operations that satisfy Priority to Recency that is
shown in Figure 1, was checked only for the stable, grounded and preferred semantics  see Proposition 6
(hence, it may not hold for other semantics).

62

fiChange in Argumentation Systems

Monotony
Destructive
Conservative

Questioning
Expansive
Decisive

Priority to recency
Restrictive

Altering

Figure 1: Inclusion links between changes of the type

conservative
decisive
destructive
expansive
altering
questioning
restrictive

Priority to Recency
Never satisfied (Conseq. 5)
May hold (Ex. 2.1 to 2.3)
and not (Ex. 2.4)
Never satisfied (Conseq. 5)
Hold under stable, grounded, preferred sem. (Prop. 6)
May hold (Ex. 8.1)
and not (Ex. 8.2)
May hold (Ex. 4.1)
and not (Ex. 4.3)
May hold (Ex. 3.1)
and not (Ex. 3.2)

ai

Monotony
Always satisfied(Conseq. 3)
May hold (Ex. 2.1)
and not (Ex. 2.3)
Never satisfied (Conseq. 4)
Always (Conseq. 3)
Never (Conseq. 4)
May hold (Ex. 4.3)
and not (Ex. 4.1)
Never (Conseq. 4)

a

Table 3: Synthesis about connections between structural and status-based properties of i

63

fiCayrol, Dupin de Saint-Cyr & Lagasquie-Schiex

4. Characterizing Argument Addition under Grounded or Preferred
Semantics
a

In this section, we focus on the change i , i.e., the addition of exactly one argument Z
that interacts with at least one argument belonging to A. Indeed, adding an argument
which may interact with the existing ones is a very frequently encountered type of change
in real-life situations. Besides, this type of change is sufficiently complex to provide a rich
analysis of properties and results.
a
Moreover, we consider the change i under the grounded and the preferred semantics.
We have chosen these two semantics because they are the most well-known traditional
semantics for which the existence of extensions is guaranteed.
Our purpose is to identify conditions under which a given property is satisfied for a
a
change operation i . These conditions concern the added argument and the associated
interactions, and may depend on the semantics.
Arguably, some properties seem more desirable than others according to the context.
For instance, a decisive change operation will reduce ignorance, since after the change one
and only one extension remains, enabling to determine the status of each argument (which
was not always the case before the change). An expansive change will raise the number of
accepted arguments, which is interesting for achieving a goal of persuasion for instance. A
conservative change keeps the extensions unchanged, and so is interesting if we want to add
an argument without changing our state of knowledge. The properties of Monotony and
Priority to Recency are desirable when we focus on some particular arguments, which we
want to get in the resulting extensions.
In constrast, a questioning or destructive operation will increase ignorance, which seems
to be less interesting.
An altering operation enforces to have a new look at the problem, since nothing is
kept from the state before change (the same number of extension remains but they are all
different from the previous ones). According to this discussion, we provide:
 sufficient conditions (CS) under which some interesting properties hold (e.g., decisive,
expansive, conservative, monotonic, satisfying Priority to Recency);
 necessary conditions (CN) for some undesirable properties (e.g., questioning, destructive, altering), in order to avoid those properties.
In the following subsections, we consider the change
ment Z and the interactions Iz , such that:

ai with the addition of the argu-

a

hA, Rii (Z, Iz ) = hA  {Z}, R  Iz i
4.1 Argument Addition under the Grounded Semantics
Under the grounded semantics, we have E = {E} and E = {E  }.
The following result gives a condition under which a given accepted argument X remains
a
accepted after the change i (hence Partial Monotony holds for X).
Proposition 7 Under the grounded semantics, if X belongs to E, and Z does not indirectly
a
attack X, then i satisfies Partial Monotony for X (i.e. X belongs to E  ).
64

fiChange in Argumentation Systems

Example 9 Under the grounded semantics:
C

B

Z

E = {{A, B}}, E = {{Z, B}}
Z does not indirectly attack B and B  E, so B  E 

A

ai

The following result gives a condition under which the change
Recency.

satisfies Priority to

Proposition 8 Under the grounded semantics, if Z is not attacked by G, then
Priority to Recency (i.e. Z belongs to E  ).

ai satisfies

Example 10 Under the grounded semantics:
A

B

Z

D

C

E = {{A, C}}, E = {{Z}}

Let us first study the particular case when E = {}.
Proposition 9 Under the grounded semantics,
 if E = {} then the following equivalence holds: E  = {} iff Z is attacked by G;
S
 moreover, if E = {} and Z is not attacked by G, then E  = {Z}  i1 F i ({Z}).
So, in case E = {}, we have:

ai is conservative).

 Either Z is attacked by G and then E  = {} (and the change

 Or Z is not attacked by G and then E  contains Z and all the arguments which are
a
indirectly defended by Z (and the change i is decisive).
As a consequence of Proposition 9, we have:
Corollary 1 Under the grounded semantics,
 if E = {} and Z is not attacked by G, then the change
 if the change

ai

ai

is decisive;

is decisive, then Z is not attacked by G and hence Z attacks G.

Example 11 Under the grounded semantics, the following change
A

B

D

C

Z

ai

is decisive:

E = {{}}, E = {{Z, A, D}}

Now, we study the particular case when E =
6 {}.
The following result gives a condition under which the change

ai satisfies Monotony.

Proposition 10 Under the grounded semantics, if E =
6 {} and Z does not attack E, then
ai satisfies Monotony (i.e. E  E  ).
And more precisely, we have two conditions (one for a conservative change
a
another one for an expansive change i ):
65

ai

and

fiCayrol, Dupin de Saint-Cyr & Lagasquie-Schiex

Proposition 11 Under the grounded semantics, if E =
6 {} and Z does not attack E, we
have:
 if E does not defend Z, then E  = E. (The change

ai

is conservative).

S
 if E defends Z, then E  = E  {Z}  i1 F i ({Z}). Moreover, in that case, if Z does
a
not attack G, E  reduces to E  {Z}. (The change i is expansive).
Example 12 Under the grounded semantics, the following change
A

B

ai

is expansive:

C

E = {{A}}, E = {{Z, A, D}}
Z

F

D

As a consequence of Proposition 11, we have another condition under which the change

ai satisfies Priority to Recency:

Corollary 2 Under the grounded semantics, if E =
6 {}, Z does not attack E, and E defends
a
Z, then i satisfies Priority to Recency (i.e. Z belongs to E  ).
Example 13 Under the grounded semantics:
A

B

C

E = {{A}}, E = {{Z, A}}
Z

F

D

Note that Corollary 2 does not hold if E does not defend Z.
Example 14 Under the grounded semantics:
A

B

C

Z

F

D

E = E  = {A}.
So, E = E = {{A}}.

Another interesting point is the fact that some properties of the change
satisfied under the grounded semantics:
Proposition 12 Under the grounded semantics, a change
restrictive.

ai

ai cannot be

is never questioning, nor

a

The case of a destructive change i is also interesting because it is sufficient to add an
attack against each unattacked argument for obtaining such a change:
Proposition 13 Under the grounded semantics, if E =
6 {}, if Z attacks each unattacked
a
argument Ai of G and if Z is attacked in G  then the change i is destructive; the converse
also holds.
66

fiChange in Argumentation Systems

4.2 Argument Addition under the Preferred Semantics
Under the preferred semantics, there is always at least one extension. E may be reduced
to a singleton {E1 } (where E1 may be empty), or may contain more than one extension
{E1 , . . . , En }. Similarly, E may be reduced to a singleton {E1 } (where E1 may be empty),
or may contain more than one extension {E1 , . . . , En }.
a
The following result gives a condition under which the change i satisfies Priority to
Recency.
a

Proposition 14 Under the preferred semantics, if Z is not attacked by G, then i satisfies
Priority to Recency (i.e. Z belongs to each Ei ).
Example 15
A

B

Z

C

A

B

Under the preferred semantics:
E = {{A, C}, {B}},
E = {{Z, B}, {Z, C}}
C

Z

E = {{A, C}, {B}},
E = {{Z, A, C}}

The following proposition establishes that admissible sets of G can be kept in some cases
a
(so, in these cases the change i can be neither altering, nor restrictive):
Proposition 15 Under the preferred semantics,
 if Z does not attack Ei , then Ei remains admissible in G  ;
 if Z does not attack Ei and Ei defends Z, then Ei  {Z} is admissible in G  .
Example 16 Under the preferred semantics:
Z

A

B

C

E = {{}},
{}{Z} is admissible in G  but E = {{Z, B}}.

Example 12 (continued) Under the preferred semantics, E = {{A}}, {A}  {Z} is
admissible in G  , nevertheless, E = {{Z, A, D}}.
Note that other preferred extensions may appear in G  .
Example 17 Under the preferred semantics:
A

B

C

E = {{A}},
E = {{Z, A}, {Z, C}}

Z

As a consequence of Proposition 15, we have another condition under which the change

ai satisfies Priority to Recency.

Corollary 3 Under the preferred semantics, if Z attacks no extension of G, and if each Ei
a
defends Z, then i satisfies Priority to Recency (i.e. Z belongs to each Ei ).
67

fiCayrol, Dupin de Saint-Cyr & Lagasquie-Schiex

Example 18 Under the preferred semantics:
A

B

C

F

Z

D

E = {{A, C}, {A, D}},
E = {{Z, A, C}, {Z, A, D}}

The following result gives a condition under which the change

ai is decisive.

Proposition 16 Under the preferred semantics, if E = {{}} and Z is not attacked by G
a
and there is no even-length cycle in G then E = {E  } and Z belongs to E  (so, i is
decisive).
Example 11 (continued) Under the preferred semantics, E = {{}}, E = {{Z, A, D}}
Note that, if even-length cycles exist in the graph, the change
extensions; this change would be a questioning one:
A

B

D

Z

C

F

ai

may induce several

E = {{}},
E = {{Z, A, D}, {Z, A, F }}

For this reason, we have considered graphs without even-length cycle in Proposition 16.
a
The following result gives a necessary condition for i to be a decisive change (and
also a condition for being a conservative change).
Proposition 17 Under the preferred semantics, if Z attacks no argument of G and E =
a
{{}}, then E = {{}}; or equivalently, if E = {{}} the change i by Z is decisive only if
Z attacks G.
The following result relates to the case where there exists a non empty extension in G
a
and also gives conditions for i either to be a conservative change, or to be an expansive
one.
Proposition 18 Under the preferred semantics, if Z attacks no argument of G, and E 6=
{{}}, then for each i:
 if Ei defends Z, then Ei  {Z} is an extension of G  ;
 if Ei does not defend Z, then Ei is an extension of G  ;
moreover, G and G  have the same number of extensions.
Example 6 (continued) Under the preferred semantics, the change
= {{A, C}, {A, D}} and E = {{Z, A, C}, {Z, A, D}}

ai

is expansive: E

As a consequence of the previous results, we have a condition under which the change

ai satisfies Monotony.

Proposition 19 Under the preferred semantics, if Z attacks no extension of G then the
a
change i satisfies Monotony.
68

fiChange in Argumentation Systems

In the particular case of a non controversial argumentation framework, we obtain a cona
dition under which the change i satisfies Skeptical Monotony. The notion of controversial
argument has been introduced by Dung, who has proved that an argumentation framework
without any controversial argument has nice properties. Roughly speaking, an argument X
is controversial if it indirectly attacks and indirectly defends a same argument Y .
Proposition 20 Under the preferred semantics, assume that G contains no controversial
a
argument. If Z does not attack i1 Ei , then the change i satisfies Skeptical Monotony,
that is i1 Ei  i1 Ei .
As under the grounded semantics, there exists a proposition about the destructive change

ai :

Proposition 21 Under the preferred semantics, if E 6= {{}}, if there is no even-length
cycle in G  , if each unattacked argument Ai of G is attacked in G  and if Z is attacked in G 
a
then the change i is destructive.
4.3 Synthesis of the Results
Tables 4 and 5, display a summary of necessary (CN) or sufficient (CS) conditions for a
a
property to hold for a change i (in some cases, several CS  resp. CN  may be given
denoted by CS, CS , . . .  resp. CN, CN , . . .).
In these tables, E, E , E, E  , Ei , Ej denote respectively the set of extensions before change,
after change, the grounded extension before change, after change, a preferred extension
before change and after change.
a
Table 4 concerns the structural properties for a change i .
a
Table 5 concerns the status-based properties for a change i .
These tables underline the fact that we have been able to identify sufficient conditions
(CS) under which some interesting properties hold (e.g., decisive, expansive, conservative,
monotonic, satisfying Priority to Recency). For the properties of changes that are less
desirable such as questioning, destructive, altering, we have focused our search on necessary
conditions (CN), allowing us to enunciate sufficient conditions in order to avoid them.

5. Discussion and Future Works
In this paper, we study change in argumentation. We propose properties to characterize
the impact of a change operation on the outcome of an argumentation framework. Then,
we focus on a particular type of change: the addition of a new argument that may interact
with previously introduced arguments10 . And we establish conditions under which a given
property is satisfied.
The study of change is an important issue in Artificial Intelligence, but it traditionally
concerns belief change. When an agent receives a new piece of information, she must
adapt her beliefs; this adaptation is not always easy because it may imply to drop some
previous knowledge. The seminal work of Alchourron, Gardenfors and Makinson (AGM)
(1985) has settled a formal framework for reasoning about belief change and introduced
10. We do not consider knowledge from which arguments and interactions could be built.

69

fiCayrol, Dupin de Saint-Cyr & Lagasquie-Schiex

Properties of the change

ai

Grounded semantics

Preferred semantics

Decisive
(E =  or E = {{}} or |E| > 2)
and |E | = 1 and E 6= {{}}

CS and CN: E = {} and Z not
attacked. (Prop.9)

CS: E = {{}} and Z not attacked and no even-length cycle in G. (Prop.16)
if E = {{}} CN: Z attacks G.
(Prop.17)

Restrictive
|E| > |E | > 2

Never (Prop.12)

CN:  an even-length cycle in
G and Z attacks at least one Ei
(Prop.15)

Questioning
|E| < |E |

Never (Prop.12)

CN:  an even-length cycle in
G  and Z attacks G (Prop.17,
Prop.18)

CN and CS: E =
6 {} and Z attacks each unattacked argt in
G and Z is attacked (Prop.13)

CS: E 6= {{}} and Z is attacked and no even-length cycle in G  and Z attacks each
unattacked argt in G (Prop.21)
CN: E 6= {{}} and Z is attacked and  an odd-length cycle in G  and Z attacks each
unattacked argt in G (Prop.1.5,
Prop.2.2)

CS: E =
6 {} and Z does not
attack E and E defends Z
(Prop.11)

CS: E 6= {{}} and Z does not
attack G and i, Ei defends Z
(Prop.18)

CS: E = {} and Z attacked by
G (Prop.9)
CS : E =
6 {} and Z does not
attack E and E does not defend
Z (Prop.11)

CS: E = {{}} and Z does not
attack G (Prop.17)
CS : E 6= {{}} and Z does not
attack G and i, Ei does not defend Z (Prop.18)

CN: E =
6 {} and Z attacks E
(Prop.10)

CN: E 6= {{}} and Ei s.t. Z
attacks Ei (Prop.15)

Destructive
E 6=  and E 6= {{}} and (E =
 or E = {{}})

Expansive
|E| = |E | and Ej  E , Ei 
E, s.t. Ei  Ej
Conservative
E = E

Altering
|E| = |E | and Ei  E s.t. Ej 
E , Ei 6 Ej

Table 4: Synthesis of the necessary and sufficient conditions (CN and CS) for structural
a
properties  Case of i

70

fiChange in Argumentation Systems

a
Properties of the change i
Monotony
Ei  E, Ej  E , s.t. Ei  Ej

Grounded Semantics

Preferred Semantics

CS: E = {}

CS: Z does not attack any Ei
(Prop.19)

CS : E =
6 {} and Z does not
attack E (Prop.10)
Priority to Recency
|E |  1 and Ej  E , Z  Ej

Partial Monotony for X
If Ei  E s.t. X  Ei , then
Ej  E s.t. X  Ej
Skeptical Monotony
i1 Ei  j1 Ej

CS: Z not attacked (Prop.8)
CS : E =
6 {}, Z does not attack
E and E defends Z (Prop.11)

CS: Z not attacked (Prop.14),
CS : Ei  E, Z does not
attack Ei and Ei defends Z
(Corol.3)

CS: X  E and Z does not indirectly attack X (Prop.7)

cf. Monotony (because, X,
Partial Monotony for X is implied by Monotony)

cf. Monotony (because, for the
grounded semantics, Skeptical
Monotony is Monotony)

CS: no controversial argt in G
and Z does not attack i1 Ei
(Prop.20)

Table 5: Synthesis of the necessary and sufficient conditions (CN and CS) for status-based
a
properties  Case of i

the concept of belief revision together with two other types of belief change, namely
contraction and expansion. Expansion consists only in adding information without
checking its consistency with previous beliefs. Contraction is an operation designed for
removing information. Revision consists in adding information while preserving consistency.
This last operation is the most interesting one since, in belief theory, inconsistency leads to
unexploitable information.
Although the change operations defined in Section 3 could be thought of as being related
to the AGM theory11 , the comparison is not appropriate because of two main reasons:
 The basic underlying formalism is different: in standard belief revision, logical formulae are used for knowledge representation whereas, in this paper, an argumentation
framework represents the current knowledge. In the first case, the outcome is a new
set of logical formulae, whereas, in the second case, the outcome is a new argumentation framework which induces a new set of extensions, each extension being a set of
arguments.
 Revision is a task in knowledge representation which is strongly related to concepts
such as inference and consistency. The postulates for standard belief revision (AGM)
are built on the consistency notion, since revision aims at incorporating a new piece
11. Note that other important cognitive tasks linked to belief change theory have already been studied in
the field of argumentation, see for instance the work on merging of Coste-Marquis, Devred, Konieczny,
Lagasquie-Schiex, and Marquis (2007).

71

fiCayrol, Dupin de Saint-Cyr & Lagasquie-Schiex

of information while preserving consistency. However, in the framework of argumentation, the notion of consistency has not a clear and standard accepted meaning (even
if some authors propose to take into account a kind of degree of inconsistency in
the argumentation context as in the works of Matt & Toni, 2008; Besnard & Hunter,
2008).
Moreover, revision has also been studied in the framework of non-monotonic theories (Witteveen & van der Hoek, 1997) and argumentation theory is linked to nonmonotony, but postulates for non-monotonic theories are also based on consistency
and inference notions that are not explicitly present in an abstract argumentation
system. So, these postulates are not suited for our problem. Some of the belief revision postulates can be restated (this is the case for the property called Priority to
Recency which has been inspired by the AGM Success postulate ), but other principles must be proposed (for instance, we have identified a property called Monotony
which checks a kind of preservation of the existing extensions by the change process).
Our work is an extension of a previous work (Cayrol et al., 2008) which presented a
preliminary step towards a formal characterization of the notion of change in argumentation
frameworks. In the work of Cayrol et al. (2008), a change was defined as the addition of
one argument and only one interaction and we studied only the structural properties and
Priority of Recency (called classicity by Cayrol et al., 2008). In the new version of this
work, proposed in the current paper, we are further taking into account the addition of
several interactions (so some properties given by Cayrol et al., 2008 do not hold here)
and defining new properties around the notion of Monotony. We also look further into
the connections between all the proposed properties and into the conditions (necessary or
sufficient) for obtaining or avoiding these properties.
There are many other approaches that deal with adding new pieces of information
within an argumentation system. The point of view adopted in this family of works is
different from ours because of the status of the new piece of information that is added. For
instance, Wassermann (1999), as well as Falappa, Garca, and Simari (2004) and Paglieri
and Castelfranchi (2005), define under which conditions, expressed in terms of arguments,
unjustified beliefs should become accepted. Pollock and Gilliess (2000) approach studies the
properties of knowledge revision under the argumentation point of view, i.e., the problem
is to generate a knowledge base in which each piece of information is justified by good
arguments. The same kind of problem is studied by Amgoud and Vesic (2009) in the context
of argument-based decision. Argument-based decision takes as input a set of options, a set of
arguments and a defeat relation among them, and returns a status for each option together
with a total preorder on the set of options. These authors study under which conditions an
option may change its status when a new argument is received and under which conditions
this new argument is useless.
Recently, Rotstein, Moguillansky, Falappa, Garca, and Simari (2008a) have proposed
a warrant-prioritized revision operation, which consists in adding an argument to a theory
in such a way that this argument is warranted afterwards. Even if the underlying ideas are
similar, this work differs from our approach in at least two points:
 First, in the work of Rotstein et al. (2008a), arguments are given a structure through
the sub-argument relation, and properties such as minimality, consistency and atom72

fiChange in Argumentation Systems

icity. And the definition of warranted arguments relies upon an evaluation of argumentation lines. In contrast, our approach remains at the most abstract level, and
our sets of accepted arguments are computed with the well-known extension-based
semantics.
 Secondly, the warrant-prioritized argument revision is designed in order to satisfy the
AGM Postulate, corresponding to our property of Priority to recency, since the
added argument must be warranted in the revised theory. Our work follows another
direction. We propose an extensive theoretical study of the impact of an addition
on the outcome of an abstract argumentation framework, which enables us to define
several properties for a change operation.
Concerning the more general question of handling dynamics in argumentation, our proposal can be related to recent works of Boella et al. (2009a, 2009b), and of Rotstein et al.
(2008b):
 The work of Boella et al. (2009a, 2009b) studies how the extensions of an argumentation system remain unchanged when the set of arguments or the attacks between
them are changed.
The four types of change we have proposed in Definition 7 have been introduced under
different names, respectively attack refinement, attack abstraction, argument refinement and argument abstraction. However, only the operations of attack refinement,
attack abstraction and argument abstraction have been studied, and from a more
restrictive point of view:
 Boella et al. (2009a, 2009b) consider only the case when the semantics provides
exactly one extension.
 The principles which are defined correspond to conditions under which a change
is conservative, in our terminology. No other property is considered.
As we focus on the addition of an argument and its interactions, the work of Boella
et al. (2009a, 2009b) can be viewed as complementary to our work.
 Rotstein et al. (2008b) introduce the notion of dynamics by considering arguments
built from evidence. Evidence is used to determine whether an argument is active (i.e.
can be used to draw inferences) or inactive. The question addressed by Rotstein et al.
(2008b) is: How a variation of the set of evidence affects the nature of arguments
(active or not)?. This question cannot be handled at a pure abstract level and
concerns internal dynamics. By contrast, we remain at an abstract level: we are
interested by the impact of a change of the abstract framework on the outcome of
that framework.
A promising application of our work could be to design dialogue strategies. Indeed, a
dialogue may be defined as an exchange (called move) of arguments between two or more,
human or artificial, agents under a given protocol. The protocol is a program that defines
the set of allowed moves at each step of the dialogue. Each agent has its own aim and
73

fiCayrol, Dupin de Saint-Cyr & Lagasquie-Schiex

may develop its own strategy. Most of the works about dialogue strategies consider that
a strategy selects exactly one move (the move which must be done next). For instance,
Bench-Capon (1998) proposes a selection strategy (for agents) leading to more cooperative
dialogues. Other approaches study strategies in the context of persuasion dialogues, where
two agents argue in order to persuade each other that a given initial argument is true (or
false according to the agent opinion). In that case, a strategy helps to choose which argument must be defeated in order that the initial argument should be accepted (or rejected).
Amgoud and Maudet (2002) have proposed heuristics that select the less attackable arguments in a persuasion dialogue. In a similar way, Riveret, Prakken, Rotolo, and Sartor
(2008) have proposed an optimal strategy in order to win a debate based on the probability
of success of the argument and on the cost of this argument for the agent. Hunter (2004),
with a more global approach, has defined a strategy which builds an optimal subtree of
arguments maximizing the resonance with the agent goals and minimizing their cost.
Our approach takes another point of view. We do not define any protocol and we do not
restrict to a dialogue type. Given a set of arguments which may interact, we are interested
in the outcome of the argumentation system, that is the set of extensions under a given
semantics. In other words, we study the impact of the addition of an argument with respect
to two points of view: first, the structural modification induced on the set of extensions,
second, the impact on the acceptability of arguments. Although the concern of acceptability
evolution looks similar to the aim of the existing dialogue approaches presented above, our
proposal is more general, since in our work, we are not interested in finding strategies in
order to make accepted a precise argument but we are rather interested in establishing
general conditions for the preservation of acceptability. For instance, under the grounded
and preferred semantics, we provide a sufficient condition for maintaining an argument
accepted after the arrival of a new one (Monotony property) and a sufficient condition for
a new argument to be accepted (Priority to Recency).
The structural point of view of our analysis is completely original with respect to the
existing literature. Indeed, we analyze the impact of a new argument on the set of extensions
and this amounts to consider the addition of an argument as an operation performed in order
to modify the form of the change outcome (by doing an expansive change, or a decisive
change for instance). The work reported in this paper enables us to choose the right way of
changing (which argument must be affected by the change, with which kind of interaction)
in order to obtain the new outcome. This is why we plan to focus more on strategies for
directing a dialogue (i.e., to be integrated in a protocol) than on strategies for taking part
in it (i.e., concerning an agent). For instance, if a dialogue arbitrator wants the debate to
be more open then she should rather force the next speaker to use arguments appropriate
for an expansive change. If she wants the debate to be more focused then only arguments
appropriate for a restrictive (and even decisive) change should be accepted.
There are several directions of further research:

1. We plan to study the other change operations defined in this paper, corresponding to
the removal of one argument with its interactions and to the addition or the removal
of an interaction (for instance, by exploiting properties of symmetry between all the
change operations).
74

fiChange in Argumentation Systems

2. We would like to generalize our change operations to the case of the addition or the
removal of a subgraph of arguments (which would be a kind of iterated change).
3. We think that the decisive property is a desirable property for a change operation.
So, we intend to investigate the question How to make the minimal change12 to a
given argumentation framework so that it has a unique non-empty extension?.

Acknowledgments
We would like to thank the reviewers for their help and their very interesting suggestions.

Appendix A. Proofs
Lemma 1
 If X  G s.t. (Z, X)  Iz , the change operation

ai

introduces no new cycle in G  .

 If X  G s.t. (X, Z)  Iz , the change operation

ai

introduces no new cycle in G  .

In other words, if Z does not attack any argument of G, or if Z is not attacked by G,
a
the change operation i introduces no new cycle in G  .
Proof of Lemma 1: If follows directly from the fact that only one argument is added.



Proofs Related to Section 3.4 (Connections between Properties)
Proof of Proposition 3: It follows directly from the definitions of the properties (Definitions 8,
12, 13, 15).

Proof of Proposition 4: It follows directly from the definitions of the properties (Definitions 11,
9, 14, 15).

Proof of Proposition 5: It follows directly from the definitions of the properties (Definitions 11,
13, 17).

Proof of Proposition 6:
Grounded semantics: Let us show that if E ( E  then Z  E  . Assume that E ( E  and that
Z 6 E  . We are going to prove that E   E (which is in contradiction with the assumption
E ( E  ), by proving that F i ({})  F i ({}), by induction on i  1.
 Basic case (i = 1): Z 6 E  so Z is attacked by G. Thus, if X  F  ({}) then X is
in G and by definition X is unattacked in G  . Then X is also unattacked in G. So,
F  ({})  F({}).
 Induction hypothesis (for 1  i  p, F i ({})  F i ({})):
12. In terms of number of edges to add or to remove and/or in terms of number of arguments to add or to
remove.

75

fiCayrol, Dupin de Saint-Cyr & Lagasquie-Schiex

 Let us first show that for any subset of arguments S in G such that F  (S)  G, we
have F  (S)  F(S): Let X  F  (S), it means that S defends X in G  and X  G.
If there exists Y in G which attacks X in G, then Y also attacks X in G  . And as
S defends X in G  , then S attacks Y . So S also defends X in G. So F  (S)  F(S).
 Let us compute F p+1 ({}) = F  (F p ({})). By induction hypothesis, F p ({}) 
F p ({}). As F  is monotonic, we have F p+1 ({})  F  (F p ({})). Now let S denote
the set F p ({}), S  E so S  G. We have assumed that E ( E  and Z 6 E 
so S  E   G. Then, as F  is monotonic, we have F  (S)  F  (E  ) = E   G
Due to the previous point, we can conclude that F  (S)  F(S). Then, we obtain
F p+1 ({})  F(F p ({})) = F p+1 ({}).
Preferred semantics: Given an expansive change of G by Z and Iz , let us suppose that there
exists an extension Ej of G  that does not contain Z. Then this extension is included in G.
As the change is expansive, there exists an extension Ei of G strictly included in Ej . Ei is a
maximal admissible set for inclusion. Since the inclusion of Ei inside Ej is strict, therefore
Ej is not admissible in G. Ej being an extension of G  , it has no conflict, hence Ej does not
defend each of its elements in G. It exists X  Ej that is attacked by Y in G (and thus in G  )
and that is not defended by Ej in G. This means that Ej does not attack Y . But, since Ej is
included in G it can not attack Y in G  . If there is no edge between an element of Ej and Y in
G, there is neither such an edge in G  . (Note that Y can be attacked by Z but Z is not in Ej )
Stable semantics: Assume that there exists an extension Ej of G  that does not contain Z. As
the change is expansive, there exists an extension Ei of G strictly included in Ej . Since the
inclusion is strict, there exists Y in Ej , which does not belong to Ei . And as we have assumed
that Ej does not contain Z, Y is in G. Ei is a stable extension of G, so Ei attacks Y . Then,
as Ei is included in Ej there is a conflict in Ej , which contradicts the fact that Ej is a stable
extension.


Proofs Related to Section 4.1 (Under the Grounded Semantics)
Proof of Proposition 7: E is the grounded extension of G. Due to the fact that R is finite, we
have E = i1 F i ({}). We prove by induction on i  1 that if X belongs to F i ({}) and Z does not
indirectly attack X, then X belongs to F i ({}).
 Basic case (i = 1): If X  F({}) then X is not attacked in G. Since Z does not attack X,
then X remains unattacked in G  and so belongs to F  ({}).
 Induction hypothesis (for 1  i  p, the proposition holds): Let X  F p+1 ({}). We have to
prove that X  F p+1 ({})(= F  (F p ({}))). Assume that X is attacked by Y in G  . As Z does
not attack X, Y is in G. As X  F p+1 ({}) = F(F p ({})), F p ({}) defends X by attacking
Y . So there exists W  F p ({}) which attacks Y , which in turn attacks X. As Z does not
indirectly attack X, we are sure that Z does not indirectly attack W . Using the induction
hypothesis for W , we have W  F p ({}). So, we have proved that F p ({}) defends X in G 
and so X  F p+1 ({}).

Proof of Proposition 8: If Z is not attacked by G, then Z is not attacked in G  . So, due to
Proposition 1.5, the grounded extension of G  contains Z.

Proof of Proposition 9:
76

fiChange in Argumentation Systems

 If E = {} then each argument of G is attacked. If Z is attacked by G, then each argument of
G  is attacked and due to Proposition 1.5 and Proposition 1.6, E  = {}. If Z is not attacked
by G, Z is not attacked in G  , then Z belongs to E  , which is not empty.
 If E = {} and Z is not attacked by G, Z  E  . As F  is monotonic,
and E  is a fixed point
S

i

of F , we have F ({Z})  E for each i  1, and then {Z}  i1 F i ({Z})  E  . Let S
S
denote {Z}  i1 F i ({Z}). Now, we have to prove that E   S. As E  is the least fixed


point of F  , it is sufficient to
S proveithat S is a fixed point of F . Obviously, F (S) = {X 

G s.t. X is not attacked}  i1 F ({Z}). Since E = {}, {X  G s.t. X is not attacked } =
S
{Z}, so F  (S) = S and S is a fixed point of F  . We have proved that E  = {Z} i1 F i ({Z}).

Proof of Corollary 1:
 It follows directly from Proposition 9. Due to Definition 8, under the grounded semantics, the
change is decisive when E = {} and E  6= {}.
 And as Z interacts with G, if Z is not attacked by G, Z must attack G.

Proof of Proposition 10: Due to the fact that R is finite, we have E = i1 F i ({}) and E  =
i1 F i ({}). We prove by induction on i  1 that F i ({})  F i ({}).
 Basic case (i = 1): If Y  F({}) then Y is not attacked in G and due to the fact that Z does
not attack E, Y is not attacked in G  and Y  F  ({}).
 Induction hypothesis (for 1  i  p, F i ({})  F i ({})): let S = F p ({}) and S  = F p ({}).
First, we prove that F(S)  F  (S). Let Y  F(S). Obviously, F(S)  E. So Y  E and
Z does not attack Y since Z does not attack E. So, if Y is attacked by A in G  then Y is
attacked by A in G. As Y  F(S), S defends Y by attacking A. And so S defends Y in G  ,
that is Y  F  (S).
Using the induction hypothesis, we have S  S  . Moreover, by definition F  is monotonic. So
F(S) = F p+1 ({})  F  (S)  F  (S  ) = F p+1 ({}). So, E  E  .

Proof of Proposition 11: E =
6 {} and Z does not attack E. Let us first notice that (1) If
Y  F  (E) and Y  G, then Y  F(E) = E. Indeed, Y  F  (E) means that E defends Y in G  . So,
if Y  G, E also defends Y in G, i.e., Y  F(E) = E.
 Due to Proposition 10, we have E  E  . So, we just have to prove that if E does not defend
Z, then E   E. Indeed, we will prove that F  (E) = E. Then, by definition of E  (least fixed
point), it will follow that E   E. Let Y  F  (E), as E does not defend Z, hence Y  G,
according to (1), Y  F(E) = E. Conversely, let Y  E = F(E), and let A be an argument
that attacks Y in G  . As Z does not attack E, A 6= Z, so A  G, and E defends Y by attacking
A. So, E defends Y in G  and Y  F  (E).
 First, we prove that if E defends Z then F  (E) = E {Z}. Due to (1), if Y  F  (E) and Y  G,
then Y  F(E) = E. Now, if E defends Z, we have also Z  F  (E). So, F  (E)  E  {Z}.
Conversely, let Y  F(E) = E. E defends Y in G. As Z does not attack E, Z does not attack
Y , and then E also defends Y in G  , so Y  F  (E). And Z  F  (E), so E  {Z}  F  (E).
In the particular case when Z does not attack G, Z cannot defend any argument. So, F  (E 
{Z}) = F  (E) and then F  (E  {Z}) = E  {Z}. That means that E  {Z} is a fixed point of
77

fiCayrol, Dupin de Saint-Cyr & Lagasquie-Schiex

F  , and by definition of E  , we have E   E  {Z}. Due to Proposition 10, we have E  E  .
So, we have also E  {Z}  E  . Finally, E  reduces to E  {Z}.
S
In the general case, Z attacks G. Let S denote E  {Z}  i1 F i ({Z}). We will prove that
S
E  = S. Obviously, we have S  E  since E  {Z} = F  (E)  E  , and E  contains i1 F i (E  ),
S
hence contains i1 F i ({Z}), since F  is monotonic. Conversely, we will prove that S is a
fixed point of F  and by definition of E  (least fixed point), it will follow that E   S.
Since F  is monotonic, we have F  (E)  F  (S), F  ({Z})  F  (S) and for each i  2
F i ({Z})  F  (S). So, as F  (E) = E  {Z}, we have S  F  (S). Conversely, let Y  F  (S)
and assume that Y 
/ E  {Z} = F  (E). Then, there exists an
S attacker A of Y and A is not
attacked by E. As Y  F  (S), S must attack A. So {Z}  i1 F i ({Z}) attacks A, which
S
means that Y  i1 F i ({Z}). So, we have proved that if Y  F  (S), either Y  E  {Z} or
S
Y  i1 F i ({Z}), that is Y  S.

Proof of Corollary 2: It is a direct consequence of Proposition 11.



Proof of Proposition 12: It is a direct consequence of the definitions: the restrictive and questioning changes need a number of extensions strictly greater than one, and there exists only one
grounded extension.

Proof of Proposition 13: E =
6 {}, so there are unattacked arguments denoted by Ai in G. Ai ,

Ai is attacked in G and Z is attacked in G  . So there is no unattacked argument in G  , so i  1
F i ({}) = {} and E  = {}. So the change is destructive.
Conversely, if the change is destructive, by definition we have E =
6 {} and E  = {}. Then, due to

Proposition 1.5, there is no unattacked argument in G . So, Z is attacked and each Ai (unattacked
argument in G) is also attacked in G  .


Proofs Related to Section 4.2 (Under the Preferred Semantics)
Proof of Proposition 14: If Z is not attacked by G, then Z is not attacked in G  . So, due to
Proposition 1, each preferred extension of G  contains Z.

Proof of Proposition 15:
 Ei is conflict-free in G, so also in G  . Let A  Ei being attacked in G  . As Z does not attack
Ei , A is attacked in G and as Ei is admissible in G, Ei defends A. So, Ei remains admissible in
G.
 Z does not attack Ei , and Ei defends Z, so Ei does not attack Z and then Ei  {Z} is conflictfree in G  . Let A  Ei  {Z} being attacked in G  . Either A  Ei and as we have just proved
in the first item that Ei is admissible in G  , Ei defends A. Or A = Z, and we have assumed
that Ei defends Z. In each case, Ei  {Z} is admissible in G  .


Lemma 2 If Ei is an extension of G  not containing Z, then Ei is admissible in G.
Proof of Lemma 2:
78

fiChange in Argumentation Systems

As Ei does not contain Z, Ei  G. Ei is conflict-free in G  so Ei is also conflict-free in G. Let
Y  Ei being attacked by an argument A, A  G. As Ei is admissible, it defends Y . So, there is an
argument B  Ei attacking A. As Ei  G, B  G. So, we have proved that Ei is admissible in G.

Proof of Corollary 3: From Proposition 15, Ei  E, Ei  {Z} is admissible in G  . So, there exists
j  1 such that Ei  {Z}  Ej . From Lemma 2, if Ek is an extension of G  not containing Z, then Ek
is admissible in G. So, there exists i  1 such that Ek  Ei . So, we have Ek  Ei  Ei  {Z}  Ej . As
a consequence, there would be a strict inclusion between two extensions of G  , which is impossible.
So, there cannot exist Ek extension of G  not containing Z, and so each extension of G  contains Z.

Proof of Proposition 16: If Z is not attacked by G, then Z is not attacked in G  and Z belongs
to each preferred extension. Moreover, if there is no even-length cycle in G, due to Lemma 1, there
is no even-length cycle in G  . So, due to Proposition 2.5, G  has only one preferred extension which
is not empty (it contains at least Z).


Lemma 3 If Z attacks no argument of G and Ei is a non empty extension of G  , then
Ei \ {Z} is admissible in G.
Proof of Lemma 3:
 Ei is conflict-free in G  so Ei \ {Z} is also conflict-free in G  and in G.
 Let Y  Ei \ {Z}. Assume that there is an argument A attacking Y . Then A 6= Z since Z
attacks no argument of G. Ei is a non-empty preferred extension of G  , so there is an argument
B  Ei attacking A, and B 6= Z (always because Z attacks no argument of G). So, we have
B  Ei \ {Z}, and Ei \ {Z} defends Y . So, Ei \ {Z} is admissible in G.

Proof of Proposition 17: Suppose that Z attacks no argument of G and E = {{}}.
(reductio ad absurdum): Assume that there exists a non-empty extension of G  denoted by E  .
So there exists Y such that Y  E  . Either Y = Z, or Y  G. In both cases, Y is attacked, because
all arguments of G are attacked (since E = {{}}) and Z attacks no argument of G. So E  must
defend Y . If Y = Z, E  cannot be reduced to Y (because Z attacks no argument and cannot defend
itself). So E  \ {Z} 6= {}. If Y 6= Z, Y  E  \ {Z}, and E  \ {Z} =
6 {}. Due to Lemma 3, E  \ {Z} is
admissible in G and so E  \ {Z}  E with E being a preferred extension of G. So G has a non-empty
extension, which is in contradiction with the assumption.

Proof of Proposition 18:
 Z attacks no argument of G, so due to Proposition 15, i, Ei is admissible in G  . So there
exists a preferred extension Ej of G  including Ei . E 6= {{}}, so i, Ei 6= {} and so Ej 6= {}.
But Z 6 Ei , so Ei  Ej \ {Z}. Due to Lemma 3, Ej \ {Z} is admissible in G, so there exists
k  1 such that Ei  Ej \ {Z}  Ek . Using the definition of a preferred extension (-maximal
among the admissible sets), we can conclude that Ei = Ej \ {Z} = Ek . So, either Ej = Ei (if
Z 6 Ej ), or Ej = Ei  {Z} (if Z  Ej ). In the first case, Ei is an extension of G  . In the second
case, Ei  {Z} is an extension of G  . Moreover, if Z  Ej , Ej defends Z (which is attacked by
G, since it does not attack G) and as Z attacks no argument, Ei = Ej \ {Z} defends Z. So, if
79

fiCayrol, Dupin de Saint-Cyr & Lagasquie-Schiex

Ei does not defend Z, Ei is an extension of G  . On the other hand, if Ei defends Z, Ei  {Z} is
conflict-free in G  . So, Ei  {Z} is admissible in G  and it is the case when Z  Ej and Ei  {Z}
is an extension of G  .
 Now, we prove that G and G  have the same number of extensions. From the first part of
the proof, we know that each extension of G is included in an extension of G  . Moreover, two
distinct extensions of G cannot be included in a same extension of G  . Indeed, the union of
two non-empty preferred extensions defends all its elements and strictly contains each of these
extensions. So the union of two extensions cannot be conflict-free.
So,we know that G  has at least as many extensions as G and that G  has at least one nonempty extension. So, Ej  E , Ej 6= {}. Due to Lemma 3, Ej \ {Z} is admissible in G. So,
for each Ej , there exists Ei , an extension of G such that Ej \ {Z}  Ei . From the first part of
the proof, we have:
 Either Ei defends Z, and Ei  {Z} is an extension of G  . As Ej \ {Z}  Ei , we have
Ej  Ei  {Z}, and as Ej is maximal admissible in G  , Ej = Ei  {Z}.
 Or Ei does not defend Z, Ei is an extension of G  . As Ej is maximal admissible in G  , we
have Z 6 Ej and Ej = Ej \ {Z} = Ei .
So, G and G  have the same number of extensions.

Proof of Proposition 19:
 If E = {{}}, obviously each change satisfies Monotony.
 If G has a non-empty extension, Proposition 15 can be applied. So each extension of G
remains admissible in G  and is included in a preferred extension of G  . So, the change satisfies
Monotony.

Proof of Proposition 20: Let E = i1 Ei and E  = i1 Ei .
Let Eg (resp. Eg ) denote the grounded extension of G (resp G  ). Due to Proposition 1.4, we know
that Eg  E and Eg  E  . Dung (1995) has proved that when there is no controversial argument,
the grounded extension is exactly the intersection of the preferred extensions. So, if G contains no
controversial argument, we have Eg = E.
Now, if Z does not attack i1 Ei , Z does not attack Eg , so due to Proposition 10, if E =
6 {}
then we have Eg  Eg when E = {} then i1 Ei = {} and the inclusion trivially holds. So, we have

E = Eg  Eg  E  , and then i1 Ei  i1 Ei .
Proof of Proposition 21: E 6= {{}} and there is no even-length cycle in G  so there is no evenlength cycle in G; as a consequence, according to Proposition 2.5 there is only one extension E in G;
moreover, E =
6 {}. Since there is no even-length cycle in G  , we know that there is only one extension


E in G . Assume that Z and each unattacked argument Ai in G are attacked in G  ; so there is no
unattacked argument in G  .
Assume that E  6= {}. Let X  E  . X is attacked in G  . Let Y1 denote an attacker of X. As E 
is admissible, E  defends X. So E  contains X2 which attacks Y1 . As there is no even-length cycle
in G  , we know that X2 6= X. And X2 is not unattacked.
So we are able to built an infinite sequence of distinct arguments:
X is attacked by Y1 attacked by X2 . . . Yp attacked by Xp+1 attacked by Yp+1 . . .
The Xi s (resp. Yi s) are distinct due to the absence of even-length cycles in G  .
It contradicts the assumption that A is finite. So E  = {} and the change is destructive.
80



fiChange in Argumentation Systems

Appendix B. Illustration of Properties for the Other Change Operations
The following examples illustrate the structural properties and the property of Monotony for
a
change operations distinct from i (let us recall that the property of Priority to Recency
does not make sense for these other change operations).
For

ai
a

a

First, we notice that if hA, Rii (Z, Iz ) = hA , R i then hA , R ii Z = hA, Ri. So in
a
each example of Section 3.2, a change i can also be illustrated.
 Example 4.1 show a decisive change
property of Monotony.

ai and a change ai which does not satisfy the
a

a

Example 5.2 shows a decisive change i and a change i which satisfies the property
of Monotony .
 Example 4.3 shows a restrictive change
the property of Monotony

ai and a change ai which does not satisfy

 Examples 2.3, 3.1, 5.1 show a questioning change
not satisfy the property of Monotony

ai

and a change

ai

which does

 Examples 2.1, 2.2, 4.2 show a destructive change
not satisfy the property of Monotony

ai

and a change

ai

which does

 Example 8.2 shows an expansive change
property of Monotony

ai

and a change

ai

which satisfies the
a

a

 Examples 7.1, 7.2, 7.3 show a conservative change i and a change i which satisfies
the property of Monotony
a

a

 Examples 6, 8.1 show an altering change i and a change i which does not satisfy
the property of Monotony
For

i

and

i

 With hA = {A, B, C}, R = {(A, B), (B, C), (C, A)}i, hA, Rii (A, C) is a decisive
change (before the change E = {{}}, after the change E = {{A}}); and the inverse
operation hA, R  {(A, C)}ii (A, C) is destructive.
In this example,

i satisfies the property of Monotony and i does not.

 With hA = {A, B, C}, R = {(A, B), (B, C)}i, hA, Rii (C, A) is a destructive change
(before the change E = {{A, C}}, after the change E = {{}}); and the inverse
operation hA, R  {(C, A)}ii (C, A) is decisive.
In this example,

i does not satisfy the property of Monotony and i satisfies it.

 With hA = {A, B, C}, R = {(A, B), (B, C)}i, hA, Rii (A, C) is an altering change
(before the change E = {{A, C}}, after the change E = {{A}}); and the inverse
operation hA, R  {(A, C)}ii (A, C) is expansive.
81

fiCayrol, Dupin de Saint-Cyr & Lagasquie-Schiex

In this example,

i does not satisfy the property of Monotony and i satisfies it.

 With hA = {A, B, C}, R = {(A, B)}i, hA, Rii (C, B) is a conservative change (before the change E = {{A, C}}, after the change E = {{A, C}}); and the inverse
operation hA, R  {(A, C)}ii (A, C) is conservative.
In this example,

i and i satisfy the property of Monotony.

 With hA = {A, B, C, D}, R = {(A, B), (B, A), (B, C), (D, C)}i, hA, Rii (C, D) is
a questioning change (before the change E = {{A, D}, {B, D}}, after the change
E = {{A, D}, {B, D}, {A, C}}); and the inverse operation hA, R{(C, D)}ii (C, D)
is restrictive.
In this example,

i satisfies the property of Monotony and i does not.

 With hA = {A, B, C, D}, R = {(A, B), (B, A), (B, C), (D, C), (C, D)}i, the change
hA, Rii (A, D) is a restrictive one (before the change E = {{A, D}, {B, D}, {A, C}},
after the change E = {{B, D}, {A, C}}).
The inverse operation hA, R  {(A, D)}ii (A, D) is questioning.
In this example,

i does not satisfy the property of Monotony and i satisfies it.

 With hA = {A, B, C}, R = {(A, B), (B, C)}i, hA, Rii (A, B) is an altering change
(before the change E = {{A, C}}, after the change E = {{A, B}}).
In this example,

i does not satisfy the property of Monotony.

 With hA = {A, B, C, D}, R = {(A, B), (B, C), (C, A)}i, hA, Rii (D, A) is a expansive change (before the change E = {{D}}, after the change E = {{D, B}}).
In this example,

i satisfies the property of Monotony.

References
Alchourron, C. E., Gardenfors, P., & Makinson, D. (1985). On the logic of theory change:
partial meet contraction and revision functions. Journal of Symbolic Logic, 50, 510
530.
Amgoud, L., & Cayrol, C. (2002). Inferring from inconsistency in preference-based argumentation frameworks. Journal of Automated Reasoning, 29, 125169.
Amgoud, L., & Maudet, N. (2002). Strategical considerations for argumentative agents
(preliminary report). In Proc. of NMR, pp. 409417.
Amgoud, L., Maudet, N., & Parsons, S. (2000). Modelling dialogues using argumentation.
In Proc. of ICMAS, pp. 3138.
Amgoud, L., & Vesic, S. (2009). On Revising Argumentation-Based Decision Systems. In
Proc. of ECSQARU, Vol. LNAI 5590, pp. 7182. Springer-Verlag.
Baroni, P., Giacomin, M., & Guida, G. (2005). Scc-recursiveness: a general schema for
argumentation semantics. Artifical Intelligence, 168, 162210.
Bench-Capon, T. (1998). Specification and implementation of Toulmin dialogue game. In
Proc. of JURIX, pp. 520.
82

fiChange in Argumentation Systems

Besnard, P., & Hunter, A. (2008). Elements of argumentation. MIT Press.
Boella, G., Kaci, S., & van der Torre, L. (2009a). Dynamics in argumentation with single
extensions: Abstraction principles and the grounded extension. In Proc. of ECSQARU
(LNAI 5590), pp. 107118.
Boella, G., Kaci, S., & van der Torre, L. (2009b). Dynamics in argumentation with single
extensions: Attack refinement and the grounded extension. In Proc. of AAMAS, pp.
12131214.
Bondarenko, A., Dung, P., Kowalski, R., & Toni, F. (1997). An abstract, argumentationtheoretic approach to default reasoning. Artificial Intelligence, 93, 63101.
Caminada, M. (2006). Semi-stable semantics. In Proc. of COMMA, pp. 121128.
Cayrol, C., Dupin de Saint-Cyr, F., & Lagasquie-Schiex, M. (2008). Revision of an argumentation system. In Proc. of KR 2008, pp. 124134. AAAI Press.
Chesnevar, C., Maguitman, A., & Loui, R. (2000). Logical models of argument. ACM
Computing surveys, 32 (4), 337383.
Coste-Marquis, S., Devred, C., Konieczny, S., Lagasquie-Schiex, M., & Marquis, P. (2007).
On the merging of Dungs argumentation systems. Artificial Intelligence, Argumentation in Artificial Intelligence, 171 (10-15), 730753.
Coste-Marquis, S., Devred, C., & Marquis, P. (2005). Prudent semantics for argumentation
frameworks. In Proc. of ICTAI, pp. 568572.
Dung, P. M. (1995). On the acceptability of arguments and its fundamental role in nonmonotonic reasoning, logic programming and n-person games. Artificial Intelligence,
77, 321357.
Dung, P. M., Mancarella, P., & Toni, F. (2006). A dialectic procedure for sceptical
assumption-based argumentation. In Proc. of COMMA, pp. 145156.
Dunne, P., & Bench-Capon, T. (2001). Complexity and combinatorial properties of argument systems. Tech. report, U.L.C.S.
Dunne, P., & Bench-Capon, T. (2002). Coherence in finite argument system. Artificial
Intelligence, 141 (1-2), 187203.
Falappa, M., Garca, A., & Simari, G. (2004). Belief dynamics and defeasible argumentation
in rational agents. In Proc. of NMR, pp. 164170.
Hunter, A. (2004). Making argumentation more believable. In Proc. of AAAI, pp. 269274.
Kakas, A. C., & Moratis, P. (2003). Argumentation based decision making for autonomous
agents. In Proc. of AAMAS, pp. 883890.
Matt, P., & Toni, F. (2008). A game-theoretic measure of argument strength for abstract
argumentation. In Proc. of JELIA (LNAI 5293), pp. 285297.
Nute, D. (2003). Defeasible logic. In Proc. of INAP 2001, LNAI 2543, pp. 151169.
Paglieri, F., & Castelfranchi, C. (2005). Revising beliefs through arguments: Bridging the
gap between argumentation and belief revision in MAS. In Argumentation in MultiAgent Systems, pp. 7894. Springer.
83

fiCayrol, Dupin de Saint-Cyr & Lagasquie-Schiex

Pollock, J., & Gillies, A. (2000). Belief revision and epistemology. Synthese, 122 (1-2),
6992.
Pollock, J. L. (1992). How to reason defeasibly. Artificial Intelligence, 57, 142.
Prakken, H., & Vreeswijk, G. (2002). Logics for defeasible argumentation. In Handbook of
Philosophical Logic, Vol. 4, pp. 218319. Kluwer Academic.
Riveret, R., Prakken, H., Rotolo, A., & Sartor, G. (2008). Heuristics in argumentation: a
game-theoretical investigation. In Proc. of COMMA, pp. 324335.
Rotstein, N. D., Moguillansky, M. O., Falappa, M. A., Garca, A. J., & Simari, G. R. (2008a).
Argument theory change: revision upon warrant. In Proc. of COMMA, pp. 336347.
IOS Press.
Rotstein, N. D., Moguillansky, M. O., Garca, A. J., & Simari, G. R. (2008b). An abstract
argumentation framework for handling dynamics. In Proc. of NMR, pp. 131139.
Wassermann, R. (1999). Full acceptance through argumentation - A preliminary report. In
Proc. of IJCAI Workshop Practical Reasoning and Rationality.
Witteveen, C., & van der Hoek, W. (1997). A general framework for revising nonmonotonic
theories. In Proc. of LPNMR (LNAI 1265), pp. 258272. Springer.

84

fi