Journal of Artificial Intelligence Research 19 (2003) 399-468

Submitted 1/02; published 10/03

Efficient Solution Algorithms for Factored MDPs
Carlos Guestrin

guestrin@cs.stanford.edu

Computer Science Dept., Stanford University

Daphne Koller

koller@cs.stanford.edu

Computer Science Dept., Stanford University

Ronald Parr

parr@cs.duke.edu

Computer Science Dept., Duke University

Shobha Venkataraman

shobha@cs.cmu.edu

Computer Science Dept., Carnegie Mellon University

Abstract
This paper addresses the problem of planning under uncertainty in large Markov Decision
Processes (MDPs). Factored MDPs represent a complex state space using state variables and
the transition model using a dynamic Bayesian network. This representation often allows an
exponential reduction in the representation size of structured MDPs, but the complexity of exact
solution algorithms for such MDPs can grow exponentially in the representation size. In this paper,
we present two approximate solution algorithms that exploit structure in factored MDPs. Both
use an approximate value function represented as a linear combination of basis functions, where
each basis function involves only a small subset of the domain variables. A key contribution of this
paper is that it shows how the basic operations of both algorithms can be performed efficiently
in closed form, by exploiting both additive and context-specific structure in a factored MDP. A
central element of our algorithms is a novel linear program decomposition technique, analogous to
variable elimination in Bayesian networks, which reduces an exponentially large LP to a provably
equivalent, polynomial-sized one. One algorithm uses approximate linear programming, and the
second approximate dynamic programming. Our dynamic programming algorithm is novel in that
it uses an approximation based on max-norm, a technique that more directly minimizes the terms
that appear in error bounds for approximate MDP algorithms. We provide experimental results
on problems with over 1040 states, demonstrating a promising indication of the scalability of our
approach, and compare our algorithm to an existing state-of-the-art approach, showing, in some
problems, exponential gains in computation time.

1. Introduction
Over the last few years, Markov Decision Processes (MDPs) have been used as the basic
semantics for optimal planning for decision theoretic agents in stochastic environments. In
the MDP framework, the system is modeled via a set of states which evolve stochastically.
The main problem with this representation is that, in virtually any real-life domain, the
state space is quite large. However, many large MDPs have significant internal structure,
and can be modeled compactly if the structure is exploited in the representation.
Factored MDPs (Boutilier, Dearden, & Goldszmidt, 2000) are one approach to representing large, structured MDPs compactly. In this framework, a state is implicitly described
by an assignment to some set of state variables. A dynamic Bayesian network (DBN) (Dean
& Kanazawa, 1989) can then allow a compact representation of the transition model, by
exploiting the fact that the transition of a variable often depends only on a small number
c
2003
AI Access Foundation and Morgan Kaufmann Publishers. All rights reserved.

fiGuestrin, Koller, Parr & Venkataraman

of other variables. Furthermore, the momentary rewards can often also be decomposed as
a sum of rewards related to individual variables or small clusters of variables.
There are two main types of structure that can simultaneously be exploited in factored
MDPs: additive and context-specific structure. Additive structure captures the fact that
typical large-scale systems can often be decomposed into a combination of locally interacting components. For example, consider the management of a large factory with many
production cells. Of course, in the long run, if a cell positioned early in the production line
generates faulty parts, then the whole factory may be affected. However, the quality of the
parts a cell generates depends directly only on the state of this cell and the quality of the
parts it receives from neighboring cells. Such additive structure can also be present in the
reward function. For example, the cost of running the factory depends, among other things,
on the sum of the costs of maintaining each local cell.
Context-specific structure encodes a different type of locality of influence: Although a
part of a large system may, in general, be influenced by the state of every other part of this
system, at any given point in time only a small number of parts may influence it directly.
In our factory example, a cell responsible for anodization may receive parts directly from
any other cell in the factory. However, a work order for a cylindrical part may restrict this
dependency only to cells that have a lathe. Thus, in the context of producing cylindrical
parts, the quality of the anodized parts depends directly only on the state of cells with a
lathe.
Even when a large MDP can be represented compactly, for example, by using a factored
representation, solving it exactly may still be intractable: Typical exact MDP solution algorithms require the manipulation of a value function, whose representation is linear in the
number of states, which is exponential in the number of state variables. One approach is
to approximate the solution using an approximate value function with a compact representation. A common choice is the use of linear value functions as an approximation  value
functions that are a linear combination of potentially non-linear basis functions (Bellman,
Kalaba, & Kotkin, 1963; Sutton, 1988; Tsitsiklis & Van Roy, 1996b). Our work builds on
the ideas of Koller and Parr (1999, 2000), by using factored (linear) value functions, where
each basis function is restricted to some small subset of the domain variables.
This paper presents two new algorithms for computing linear value function approximations for factored MDPs: one that uses approximate dynamic programming and another
that uses approximate linear programming. Both algorithms are based on the use of factored linear value functions, a highly expressive function approximation method. This
representation allows the algorithms to take advantage of both additive and context-specific
structure, in order to produce high-quality approximate solutions very efficiently. The capability to exploit both types of structure distinguishes these algorithms differ from earlier
approaches (Boutilier et al., 2000), which only exploit context-specific structure. We provide
a more detailed discussion of the differences in Section 10.
We show that, for a factored MDP and factored value functions, various critical operations for our planning algorithms can be implemented in closed form without necessarily
enumerating the entire state space. In particular, both our new algorithms build upon a
novel linear programming decomposition technique. This technique reduces structured LPs
with exponentially many constraints to equivalent, polynomially-sized ones. This decomposition follows a procedure analogous to variable elimination that applies both to additively
400

fiEfficient Solution Algorithms for Factored MDPs

structured value functions (Bertele & Brioschi, 1972) and to value functions that also exploit context-specific structure (Zhang & Poole, 1999). Using these basic operations, our
planning algorithms can be implemented efficiently, even though the size of the state space
grows exponentially in the number of variables.
Our first method is based on the approximate linear programming algorithm (Schweitzer
& Seidmann, 1985). This algorithm generates a linear, approximate value function by
solving a single linear program. Unfortunately, the number of constraints in the LP proposed
by Schweitzer and Seidmann grows exponentially in the number of variables. Using our LP
decomposition technique, we exploit structure in factored MDPs to represent exactly the
same optimization problem with exponentially fewer constraints.
In terms of approximate dynamic programming, this paper makes a twofold contribution.
First, we provide a new approach for approximately solving MDPs using a linear value
function. Previous approaches to linear function approximation typically have utilized a
least squares (L2 -norm) approximation to the value function. Least squares approximations
are incompatible with most convergence analyses for MDPs, which are based on max-norm.
We provide the first MDP solution algorithms  both value iteration and policy iteration 
that use a linear max-norm projection to approximate the value function, thereby directly
optimizing the quantity that appears in our provided error bounds. Second, we show how
to exploit the structure of the problem to apply this technique to factored MDPs, by again
leveraging on our LP decomposition technique.
Although approximate dynamic programming currently possesses stronger theoretical
guarantees, our experimental results suggest that approximate linear programming is a
good alternative. Whereas the former tends to generate better policies for the same set of
basis functions, due to the simplicity and computational advantages of approximate linear
programming, we can add more basis functions, obtaining a better policy and still requiring
less computation than the approximate dynamic programming approach.
Finally, we present experimental results comparing our approach to the work of Boutilier
et al. (2000), illustrating some of the tradeoffs between the two methods. In particular, for
problems with significant context-specific structure in the value function, their approach
can be faster due to their efficient handling of their value function representation. However,
there are cases with significant context-specific structure in the problem, rather than in
the value function, in which their algorithm requires an exponentially large value function
representation. In such classes of problems, we demonstrate that by using a value function that exploits both additive and context-specific structure, our algorithm can obtain a
polynomial-time near-optimal approximation of the true value function.
This paper starts with a presentation of factored MDPs and approximate solution algorithms for MDPs. In Section 4, we describe the basic operations used in our algorithms,
including our LP decomposition technique. In Section 5, we present the first of our two
algorithms: the approximate linear programming algorithm for factored MDPs. The second
algorithm, approximate policy iteration with max-norm projection, is presented in Section 6.
Section 7 describes an approach for efficiently computing bounds on policy quality based on
the Bellman error. Section 8 shows how to extend our methods to deal with context-specific
structure. Our paper concludes with an empirical evaluation in Section 9 and a discussion
of related work in Section 10.
401

fiGuestrin, Koller, Parr & Venkataraman

This paper is a greatly expanded version of work that was published before in Guestrin
et al. (2001a), and some of the work presented in Guestrin et al. (2001b, 2002).

2. Factored Markov Decision Processes
A Markov decision process (MDP) is a mathematical framework for sequential decision
problems in stochastic domains. It thus provides an underlying semantics for the task of
planning under uncertainty. We begin with a concise overview of the MDP framework, and
then describe the representation of factored MDPs.
2.1 Markov Decision Processes
We briefly review the MDP framework, referring the reader to the books by Bertsekas and
Tsitsiklis (1996) or Puterman (1994) for a more in-depth review. A Markov Decision Process
(MDP) is defined as a 4-tuple (X, A, R, P ) where: X is a finite set of |X| = N states; A is
a finite set of actions; R is a reward function R : X  A 7 R, such that R(x, a) represents
the reward obtained by the agent in state x after taking action a; and P is a Markovian
transition model where P (x0 | x, a) represents the probability of going from state x to state
x0 with action a. We assume that the rewards are bounded, that is, there exists Rmax such
that Rmax  |R(x, a)| , x, a.
Example 2.1 Consider the problem of optimizing the behavior of a system administrator
(SysAdmin) maintaining a network of m computers. In this network, each machine is
connected to some subset of the other machines. Various possible network topologies can be
defined in this manner (see Figure 1 for some examples). In one simple network, we might
connect the machines in a ring, with machine i connected to machines i + 1 and i  1. (In
this example, we assume addition and subtraction are performed modulo m.)
Each machine is associated with a binary random variable Xi , representing whether it
is working or has failed. At every time step, the SysAdmin receives a certain amount of
money (reward) for each working machine. The job of the SysAdmin is to decide which
machine to reboot; thus, there are m + 1 possible actions at each time step: reboot one of the
m machines or do nothing (only one machine can be rebooted per time step). If a machine
is rebooted, it will be working with high probability at the next time step. Every machine
has a small probability of failing at each time step. However, if a neighboring machine fails,
this probability increases dramatically. These failure probabilities define the transition model
P (x0 | x, a), where x is a particular assignment describing which machines are working or
have failed in the current time step, a is the SysAdmins choice of machine to reboot and x0
is the resulting state in the next time step.
We assume that the MDP has an infinite horizon and that future rewards are discounted
exponentially with a discount factor   [0, 1). A stationary policy  for an MDP is a
mapping  : X 7 A, where (x) is the action the agent takes at state x. In the computer
network problem, for each possible configuration of working and failing machines, the policy
would tell the SysAdmin which machine to reboot. Each policy is associated with a value
function V  RN , where V (x) is the discounted cumulative value that the agent gets if
it starts at state x and follows policy . More precisely, the value V of a state x under
402

fiEfficient Solution Algorithms for Factored MDPs

Server

Server

Star

Bidirectional Ring

Ring and Star

Server

3 Legs

Ring of Rings

Figure 1: Network topologies tested; the status of a machine is influence by the status of
its parent in the network.

policy  is given by:
V (x) = E

" 
X

t



(t)

(t)

 R X , (X

t=0


#

 (0)
) X = x ,


where X(t) is a random variable representing the state of the system after t steps. In our
running example, the value function represents how much money the SysAdmin expects to
collect if she starts acting according to  when the network is at state x. The value function
for a fixed policy is the fixed point of a set of linear equations that define the value of a
state in terms of the value of its possible successor states. More formally, we define:
Definition 2.2 The DP operator, T , for a stationary policy  is:
T V(x) = R(x, (x)) + 

X

P (x0 | x, (x))V(x0 ).

x0

The value function of policy , V , is the fixed point of the T operator: V = T V .
The optimal value function V  describes the optimal value the agent can achieve for
each starting state. V  is also defined by a set of non-linear equations. In this case, the
value of a state must be the maximal expected value achievable by any policy starting at
that state. More precisely, we define:
Definition 2.3 The Bellman operator, T  , is:
T  V(x) = max[R(x, a) + 
a

X

P (x0 | x, a)V(x0 )].

x0

The optimal value function V  is the fixed point of T  : V  = T  V  .
For any value function V, we can define the policy obtained by acting greedily relative
to V. In other words, at each state, the agent takes the action that maximizes the one-step
403

fiGuestrin, Koller, Parr & Venkataraman

utility, assuming that V represents our long-term utility achieved at the next state. More
precisely, we define:
Greedy(V)(x) = arg max[R(x, a) + 
a

X

P (x0 | x, a)V(x0 )].

(1)

x0

The greedy policy relative to the optimal value function V  is the optimal policy   =
Greedy(V  ).
2.2 Factored MDPs
Factored MDPs are a representation language that allows us to exploit problem structure
to represent exponentially large MDPs very compactly. The idea of representing a large
MDP using a factored model was first proposed by Boutilier et al. (1995).
In a factored MDP, the set of states is described via a set of random variables X =
{X1 , . . . , Xn }, where each Xi takes on values in some finite domain Dom(Xi ). A state x
defines a value xi  Dom(Xi ) for each variable Xi . In general, we use upper case letters
(e.g., X) to denote random variables, and lower case (e.g., x) to denote their values. We
use boldface to denote vectors of variables (e.g., X) or their values (x). For an instantiation
y  Dom(Y) and a subset of these variables Z  Y, we use y[Z] to denote the value of the
variables Z in the instantiation y.
In a factored MDP, we define a state transition model  using a dynamic Bayesian
network (DBN) (Dean & Kanazawa, 1989). Let Xi denote the variable Xi at the current
time and Xi0 , the same variable at the next step. The transition graph of a DBN is a
two-layer directed acyclic graph G whose nodes are {X1 , . . . , Xn , X10 , . . . , Xn0 }. We denote
the parents of Xi0 in the graph by Parents (Xi0 ). For simplicity of exposition, we assume
that Parents (Xi0 )  X; thus, all arcs in the DBN are between variables in consecutive
time slices. (This assumption is used for expository purposes only; intra-time slice arcs
are handled by a small modification presented in Section 4.1.) Each node Xi0 is associated
with a conditional probability distribution (CPD) P (Xi0 | Parents (Xi0 )). The transition
probability P (x0 | x) is then defined to be:
P (x0 | x) =

Y

P (x0i | ui ) ,

i

where ui is the value in x of the variables in Parents (Xi0 ).
Example 2.4 Consider an instance of the SysAdmin problem with four computers, labelled
M1 , . . . , M4 , in an unidirectional ring topology as shown in Figure 2(a). Our first task in
modeling this problem as a factored MDP is to define the state space X. Each machine
is associated with a binary random variable Xi , representing whether it is working or has
failed. Thus, our state space is represented by four random variables: {X1 , X2 , X3 , X4 }.
The next task is to define the transition model, represented as a DBN. The parents of the
next time step variables Xi0 depend on the network topology. Specifically, the probability that
machine i will fail at the next time step depends on whether it is working at the current
time step and on the status of its direct neighbors (parents in the topology) in the network
at the current time step. As shown in Figure 2(b), the parents of Xi0 in this example are Xi
and Xi1 . The CPD of Xi0 is such that if Xi = false, then Xi0 = false with high probability;
404

fiEfficient Solution Algorithms for Factored MDPs

X1

X1
R

X2

M1

R

M4

M2

M3

(a)

2

X3
R

X4
R

1

3

P (Xi0 = t | Xi , Xi1 , A):
h
1

h

2

X2

X3
h

3

X4
h

4

(b)

Action is reboot:
machine i other machine

4

Xi1
Xi
Xi1
Xi
Xi1
Xi
Xi1
Xi

=f
=f
=f
=t
=t
=f
=t
=t






1

0.0238

1

0.475

1

0.0475

1

0.95

(c)

Figure 2: Factored MDP example: from a network topology (a) we obtain the factored
MDP representation (b) with the CPDs described in (c).

that is, failures tend to persist. If Xi = true, then Xi0 is a noisy or of its other parents (in
the unidirectional ring topology Xi0 has only one other parent Xi1 ); that is, a failure in any
of its neighbors can independently cause machine i to fail.
We have described how to represent factored the Markovian transition dynamics arising
from an MDP as a DBN, but we have not directly addressed the representation of actions.
Generally, we can define the transition dynamics of an MDP by defining a separate DBN
model a = hGa , Pa i for each action a.
Example 2.5 In our system administrator example, we have an action ai for rebooting
each one of the machines, and a default action d for doing nothing. The transition model
described above corresponds to the do nothing action. The transition model for ai is
different from d only in the transition model for the variable Xi0 , which is now Xi0 = true
with probability one, regardless of the status of the neighboring machines. Figure 2(c) shows
the actual CPD for P (Xi0 = W orking | Xi , Xi1 , A), with one entry for each assignment to
the state variables Xi and Xi1 , and to the action A.
To fully specify an MDP, we also need to provide a compact representation of the reward
function. We assume that the reward function is factored additively into a set of localized
reward functions, each of which only depends on a small set of variables. In our example, we
might have a reward function associated with each machine i, which depends on Xi . That
is, the SysAdmin is paid on a per-machine basis: at every time step, she receives money for
machine i only if it is working. We can formalize this concept of localized functions:
Definition 2.6 A function f has a scope Scope[f ] = C  X if f : Dom(C) 7 R.
If f has scope Y and Y  Z, we use f (z) as shorthand for f (y) where y is the part of the
instantiation z that corresponds to variables in Y.
405

fiGuestrin, Koller, Parr & Venkataraman

We can now characterize the concept of local rewards. Let R1a , . . . , Rra be a set of
functions, where the scope of each Ria is restricted to variable cluster Uai  {X1 , . . . , Xn }.
P
The reward for taking action a at state x is defined to be Ra (x) = ri=1 Ria (Uai )  R. In
our example, we have a reward function Ri associated with each machine i, which depends
only Xi , and does not depend on the action choice. These local rewards are represented
by the diamonds in Figure 2(b), in the usual notation for influence diagrams (Howard &
Matheson, 1984).

3. Approximate Solution Algorithms
There are several algorithms to compute the optimal policy in an MDP. The three most
commonly used are value iteration, policy iteration, and linear programming. A key component in all three algorithms is the computation of value functions, as defined in Section 2.1.
Recall that a value function defines a value for each state x in the state space. With an
explicit representation of the value function as a vector of values for the different states,
the solution algorithms all can be implemented as a series of simple algebraic steps. Thus,
in this case, all three can be implemented very efficiently.
Unfortunately, in the case of factored MDPs, the state space is exponential in the number
of variables in the domain. In the SysAdmin problem, for example, the state x of the system
is an assignment describing which machines are working or have failed; that is, a state x
is an assignment to each random variable Xi . Thus, the number of states is exponential in
the number m of machines in the network (|X| = N = 2m ). Hence, even representing an
explicit value function in problems with more than about ten machines is infeasible. One
might be tempted to believe that factored transition dynamics and rewards would result in
a factored value function, which can thereby be represented compactly. Unfortunately, even
in trivial factored MDPs, there is no guarantee that structure in the model is preserved in
the value function (Koller & Parr, 1999).
In this section, we discuss the use of an approximate value function, that admits a
compact representation. We also describe approximate versions of these exact algorithms,
that use approximate value functions. Our description in this section is somewhat abstract,
and does not specify how the basic operations required by the algorithms can be performed
explicitly. In later sections, we elaborate on these issues, and describe the algorithms in
detail. For brevity, we choose to focus on policy iteration and linear programming; our
techniques easily extend to value iteration.
3.1 Linear Value Functions
A very popular choice for approximating value functions is by using linear regression, as first
proposed by Bellman et al. (1963). Here, we define our space of allowable value functions
V  H  RN via a set of basis functions:
Definition 3.1 A linear value function over a set of basis functions H = {h1 , . . . , hk }
P
is a function V that can be written as V(x) = kj=1 wj hj (x) for some coefficients w =
(w1 , . . . , wk )0 .
We can now define H to be the linear subspace of RN spanned by the basis functions H.
It is useful to define an N  k matrix H whose columns are the k basis functions viewed as
406

fiEfficient Solution Algorithms for Factored MDPs

vectors. In a more compact notation, our approximate value function is then represented
by Hw.
The expressive power of this linear representation is equivalent, for example, to that
of a single layer neural network with features corresponding to the basis functions defining
H. Once the features are defined, we must optimize the coefficients w in order to obtain a
good approximation for the true value function. We can view this approach as separating
the problem of defining a reasonable space of features and the induced space H, from the
problem of searching within the space. The former problem is typically the purview of
domain experts, while the latter is the focus of analysis and algorithmic design. Clearly,
feature selection is an important issue for essentially all areas of learning and approximation.
We offer some simple methods for selecting good features for MDPs in Section 11, but it is
not our goal to address this large and important topic in this paper.
Once we have a chosen a linear value function representation and a set of basis functions,
the problem becomes one of finding values for the weights w such that Hw will yield
a good approximation of the true value function. In this paper, we consider two such
approaches: approximate dynamic programming using policy iteration and approximate
linear programming. In this section, we present these two approaches. In Section 4, we
show how we can exploit problem structure to transform these approaches into practical
algorithms that can deal with exponentially large state spaces.
3.2 Policy Iteration
3.2.1 The Exact Algorithm
The exact policy iteration algorithm iterates over policies, producing an improved policy at
each iteration. Starting with some initial policy  (0) , each iteration consists of two phases.
Value determination computes, for a policy  (t) , the value function V(t) , by finding the
fixed point of the equation T(t) V(t) = V(t) , that is, the unique solution to the set of linear
equations:
X
P (x0 | x,  (t) (x))V(t) (x0 ), x.
V(t) (x) = R(x,  (t) (x)) + 
x0

The policy improvement step defines the next policy as
 (t+1) = Greedy(V(t) ).
It can be shown that this process converges to the optimal policy (Bertsekas & Tsitsiklis,
1996). Furthermore, in practice, the convergence to the optimal policy is often very quick.
3.2.2 Approximate Policy Iteration
The steps in the policy iteration algorithm require a manipulation of both value functions
and policies, both of which often cannot be represented explicitly in large MDPs. To define
a version of the policy iteration algorithm that uses approximate value functions, we use
the following basic idea: We restrict the algorithm to using only value functions within the
provided H; whenever the algorithm takes a step that results in a value function V that is
outside this space, we project the result back into the space by finding the value function
within the space which is closest to V. More precisely:
407

fiGuestrin, Koller, Parr & Venkataraman

Definition 3.2 A projection operator  is a mapping  : RN  H.  is said to be a
projection w.r.t. a norm kk if V = Hw such that w  arg minw kHw  Vk.
That is, V is the linear combination of the basis functions, that is closest to V with respect
to the chosen norm.
Our approximate policy iteration algorithm performs the policy improvement step exactly. In the value determination step, the value function  the value of acting according to
the current policy  (t)  is approximated through a linear combination of basis functions.
We now consider the problem of value determination for a policy  (t) . At this point,
it is useful to introduce some notation: Although the rewards are a function of the state
and action choice, once the policy is fixed, the rewards become a function of the state
only, which we denote as R(t) , where R(t) (x) = R(x,  (t) (x)). Similarly, for the transition
model: P(t) (x0 | x) = P (x0 | x,  (t) (x)). We can now rewrite the value determination step
in terms of matrices and vectors. If we view V(t) and R(t) as N -vectors, and P(t) as an
N  N matrix, we have the equations:
V(t) = R(t) + P(t) V(t) .
This is a system of linear equations with one equation for each state, which can only be
solved exactly for relatively small N . Our goal is to provide an approximate solution, within
H. More precisely, we want to find:
w(t) = arg min kHw  (R(t) + P(t) Hw)k ;
w







= arg min (H  P(t) H) w(t)  R(t)  .
w

Thus, our approximate policy iteration alternates between two steps:
w(t) = arg min kHw  (R(t) + P(t) Hw)k ;
w

 (t+1) = Greedy(Hw(t) ).

(2)
(3)

3.2.3 Max-norm Projection
An approach along the lines described above has been used in various papers, with several
recent theoretical and algorithmic results (Schweitzer & Seidmann, 1985; Tsitsiklis & Van
Roy, 1996b; Van Roy, 1998; Koller & Parr, 1999, 2000). However, these approaches suffer
from a problem that we might call norm incompatibility. When computing the projection,
they utilize the standard Euclidean projection operator with respect to the L2 norm or a
weighted L2 norm.1 On the other hand, most of the convergence and error analyses for MDP
algorithms utilize max-norm (L ). This incompatibility has made it difficult to provide
error guarantees.
We can tie the projection operator more closely to the error bounds through the use
of a projection operator in L norm. The problem of minimizing the L norm has been
studied in the optimization literature as the problem of finding the Chebyshev solution2 to
1. Weighted L2 norm projections are stable and have meaningful error bounds when the weights correspond
to the stationary distribution of a fixed policy under evaluation (value determination) (Van Roy, 1998),
but they are not stable when combined with T  . Averagers (Gordon, 1995) are stable and non-expansive
in L , but require that the mixture weights be determined a priori. Thus, they do not, in general,
minimize L error.
2. The Chebyshev norm is also referred to as max, supremum and L norms and the minimax solution.

408

fiEfficient Solution Algorithms for Factored MDPs

an overdetermined linear system of equations (Cheney, 1982). The problem is defined as
finding w such that:
w  arg min kCw  bk .
(4)
w

We use an algorithm due to Stiefel (1960), that solves this problem by linear programming:
Variables: w1 , . . . , wk ,  ;
Minimize:  ;
P
(5)
Subject to:   kj=1 cij wj  bi and
Pk
  bi  j=1 cij wj , i = 1...N.



P


The constraints in this linear program imply that    kj=1 cij wj  bi  for each i, or
equivalently, that   kCw  bk . The objective of the LP is to minimize . Thus, at the
solution (w ,  ) of this linear program, w is the solution of Equation (4) and  is the L
projection error.
We can use the L projection in the context of the approximate policy iteration in the
obvious way. When implementing the projection operation of Equation (2), we can use
the L projection (as in Equation (4)), where C = (H  P(t) H) and b = R(t) . This
minimization can be solved using the linear program of (5).
A key point is that this LP only has k + 1 variables. However, there are 2N constraints,
which makes it impractical for large state spaces. In the SysAdmin problem, for example,
the number of constraints in this LP is exponential in the number of machines in the network
(a total of 2  2m constraints for m machines). In Section 4, we show that, in factored MDPs
with linear value functions, all the 2N constraints can be represented efficiently, leading to
a tractable algorithm.
3.2.4 Error Analysis
We motivated our use of the max-norm projection within the approximate policy iteration
algorithm via its compatibility with standard error analysis techniques for MDP algorithms.
We now provide a careful analysis of the impact of the L error introduced by the projection step. The analysis provides motivation for the use of a projection step that directly
minimizes this quantity. We acknowledge, however, that the main impact of this analysis
is motivational. In practice, we cannot provide a priori guarantees that an L projection
will outperform other methods.
Our goal is to analyze approximate policy iteration in terms of the amount of error
introduced at each step by the projection operation. If the error is zero, then we are
performing exact value determination, and no error should accrue. If the error is small, we
should get an approximation that is accurate. This result follows from the analysis below.
More precisely, we define the projection error as the error resulting from the approximate
value determination step:








 (t) = Hw(t)  R(t) + P(t) Hw(t)  .


Note that, by using our max-norm projection, we are finding the set of weights w(t) that
exactly minimizes the one-step projection error  (t) . That is, we are choosing the best
409

fiGuestrin, Koller, Parr & Venkataraman

possible weights with respect to this error measure. Furthermore, this is exactly the error
measure that is going to appear in the bounds of our theorem. Thus, we can now make the
bounds for each step as tight as possible.
We first show that the projection error accrued in each step is bounded:
Lemma 3.3 The value determination error is bounded: There exists a constant P  Rmax
such that P   (t) for all iterations t of the algorithm.
Proof: See Appendix A.1.
Due to the contraction property of the Bellman operator, the overall accumulated error
is a decaying average of the projection error incurred throughout all iterations:
Definition 3.4 The discounted value determination error at iteration t is defined as: 
(t1)
(0)
 (t) + 
;  = 0.

(t)

=

Lemma 3.3 implies that the accumulated error remains bounded in approximate policy
(t)
(1 t )
iteration:   P 1
. We can now bound the loss incurred when acting according
to the policy generated by our approximate policy iteration algorithm, as opposed to the
optimal policy:
Theorem 3.5 In the approximate policy iteration algorithm, let  (t) be the policy generated
at iteration t. Furthermore, let V(t) be the actual value of acting according to this policy.
The loss incurred by using policy  (t) as opposed to the optimal policy   with value V  is
bounded by:
(t)
2
t


kV  V(t) k   kV  V(0) k +
.
(6)
(1  )2
Proof: See Appendix A.2.
In words, Equation (6) shows that the difference between our approximation at iteration
t and the optimal value function is bounded by the sum of two terms. The first term is
present in standard policy iteration and goes to zero exponentially fast. The second is the
discounted accumulated projection error and, as Lemma 3.3 shows, is bounded. This second
term can be minimized by choosing w(t) as the one that minimizes:





Hw(t)  R(t) + P(t) Hw(t) 



,

which is exactly the computation performed by the max-norm projection. Therefore, this
theorem motivates the use of max-norm projections to minimize the error term that appears
in our bound.
The bounds we have provided so far may seem fairly trivial, as we have not provided
a strong a priori bound on  (t) . Fortunately, several factors make these bounds interesting despite the lack of a priori guarantees. If approximate policy iteration converges, as
b is the policy
occurred in all of our experiments, we can obtain a much tighter bound: If 
after convergence, then:
 


V  V   2b
,
b
 
(1  )
where b is the one-step max-norm projection error associated with estimating the value
b . Since the max-norm projection operation provides b
of 
 , we can easily obtain an a
410

fiEfficient Solution Algorithms for Factored MDPs

posteriori bound as part of the policy iteration procedure. More details are provided in
Section 7.
One could rewrite the bound in Theorem 3.5 in terms of the worst case projection error P , or the worst projection error in a cycle of policies, if approximate policy iteration
gets stuck in a cycle. These formulations would be closer to the analysis of Bertsekas and
Tsitsiklis (1996, Proposition 6.2, p.276). However, consider the case where most policies
(or most policies in the final cycle) have a low projection error, but there are a few policies
that cannot be approximated well using the projection operation, so that they have a large
one-step projection error. A worst-case bound would be very loose, because it would be
dictated by the error of the most difficult policy to approximate. On the other hand, using
our discounted accumulated error formulation, errors introduced by policies that are hard
to approximate decay very rapidly. Thus, the error bound represents an average case
analysis: a decaying average of the projection errors for policies encountered at the successive iterations of the algorithm. As in the convergent case, this bound can be computed
easily as part of the policy iteration procedure when max-norm projection is used.
The practical benefit of a posteriori bounds is that they can give meaningful feedback on
the impact of the choice of the value function approximation architecture. While we are not
explicitly addressing the difficult and general problem of feature selection in this paper, our
error bounds motivate algorithms that aim to minimize the error given an approximation
architecture and provide feedback that could be useful in future efforts to automatically
discover or improve approximation architectures.
3.3 Approximate Linear Programming
3.3.1 The Exact Algorithm
Linear programming provides an alternative method for solving MDPs. It formulates the
problem of finding a value function as a linear program (LP). Here the LP variables are
V1 , . . . , VN , where Vi represents V(xi ): the value of starting at the ith state of the system.
The LP is given by:
Variables: V1 , . . . , VN ;
P
Minimize:
xi (xi ) Vi ;
P
Subject to: Vi  [R(xi , a) +  j P (xj | xi , a)Vj ] xi  X, a  A,

(7)

where the state relevance weights  are positive. Note that, in this exact case, the solution
obtained is the same for any positive weight vector. It is interesting to note that steps of
the simplex algorithm correspond to policy changes at single states, while steps of policy
iteration can involve policy changes at multiple states. In practice, policy iteration tends
to be faster than the linear programming approach (Puterman, 1994).
3.3.2 Approximate Linear Program
The approximate formulation for the LP approach, first proposed by Schweitzer and Seidmann (1985), restricts the space of allowable value functions to the linear space spanned
by our basis functions. In this approximate formulation, the variables are w1 , . . . , wk : the
weights for our basis functions. The LP is given by:
411

fiGuestrin, Koller, Parr & Venkataraman

Variables: w1 , . . . , wk ;
P
P
Minimize:
(x) i wi hi (x) ;
Px
P
P
0
0
Subject to:
i wi hi (x)  [R(x, a) + 
x0 P (x | x, a)
i wi hi (x )] x  X, a  A.
(8)
In other words, this formulation takes the LP in (7) and substitutes the explicit state
P
value function by a linear value function representation i wi hi (x), or, in our more compact
notation, V is replaced by Hw. This linear program is guaranteed to be feasible if a constant
function  a function with the same constant value for all states  is included in the set
of basis functions.
In this approximate linear programming formulation, the choice of state relevance weights,
, becomes important. Intuitively, not all constraints in this LP are binding; that is, the
constraints are tighter for some states than for others. For each state x, the relevance
weight (x) indicates the relative importance of a tight constraint. Therefore, unlike the
exact case, the solution obtained may differ for different choices of the positive weight vector
. Furthermore, there is, in general, no guarantee as to the quality of the greedy policy
generated from the approximation Hw. However, the recent work of de Farias and Van
Roy (2001a) provides some analysis of the error relative to that of the best possible approximation in the subspace, and some guidance as to selecting  so as to improve the quality
of the approximation. In particular, their analysis shows that this LP provides the best
approximation Hw of the optimal value function V  in a weighted L1 sense subject to the
constraint that Hw  T  Hw , where the weights in the L1 norm are the state relevance
weights .
The transformation from an exact to an approximate problem formulation has the effect of reducing the number of free variables in the LP to k (one for each basis function
coefficient), but the number of constraints remains N  |A|. In our SysAdmin problem, for
example, the number of constraints in the LP in (8) is (m + 1)  2m , where m is the number
of machines in the network. Thus, the process of generating the constraints and solving the
LP still seems unmanageable for more than a few machines. In the next section, we discuss
how we can use the structure of a factored MDP to provide for a compact representation
and an efficient solution to this LP.

4. Factored Value Functions
The linear value function approach, and the algorithms described in Section 3, apply to any
choice of basis functions. In the context of factored MDPs, Koller and Parr (1999) suggest
a particular type of basis function, that is particularly compatible with the structure of a
factored MDP. They suggest that, although the value function is typically not structured,
there are many cases where it might be close to structured. That is, it might be wellapproximated using a linear combination of functions each of which refers only to a small
number of variables. More precisely, we define:
Definition 4.1 A factored (linear) value function is a linear function over the basis set
h1 , . . . , hk , where the scope of each hi is restricted to some subset of variables Ci .
Value functions of this type have a long history in the area of multi-attribute utility theory (Keeney & Raiffa, 1976). In our example, we might have a basis function hi for each
412

fiEfficient Solution Algorithms for Factored MDPs

machine, indicating whether it is working or not. Each basis function has scope restricted
to Xi . These are represented as diamonds in the next time step in Figure 2(b).
Factored value functions provide the key to performing efficient computations over the
exponential-sized state spaces we have in factored MDPs. The main insight is that restricted scope functions (including our basis functions) allow for certain basic operations to
be implemented very efficiently. In the remainder of this section, we show how structure in
factored MDPs can be exploited to perform two crucial operations very efficiently: one-step
lookahead (backprojection), and the representation of exponentially many constraints in
the LPs. Then, we use these basic building blocks to formulate very efficient approximation algorithms for factored MDPs, each presented in its own self-contained section: the
approximate linear programming for factored MDPs in Section 5, and approximate policy
iteration with max-norm projection in Section 6.
4.1 One-step Lookahead
A key step in all of our algorithms is the computation of the one-step lookahead value of
some action a. This is necessary, for example, when computing the greedy policy as in
Equation (1). Lets consider the computation of a Q function, Qa (x), which represents the
expected value the agent obtains after taking action a at the current time step and receiving
a long-term value V thereafter. This Q function can be computed by:
Qa (x) = R(x, a) + 

X

P (x0 | x, a)V(x).

(9)

x0

That is, Qa (x) is given by the current reward plus the discounted expected future value.
Using this notation, we can express the greedy policy as: Greedy(V)(x) = maxa Qa (x).
Recall that we are estimating the long-term value of our policy using a set of basis
P
functions: V(x) = i wi hi (x). Thus, we can rewrite Equation (9) as:
Qa (x) = R(x, a) + 

X

P (x0 | x, a)

X

x0

wi hi (x).

(10)

i

P

The size of the state space is exponential, so that computing the expectation x0 P (x0 |
P
x, a) i wi hi (x) seems infeasible. Fortunately, as discussed by Koller and Parr (1999),
this expectation operation, or backprojection, can be performed efficiently if the transition
model and the value function are both factored appropriately. The linearity of the value
function permits a linear decomposition, where each summand in the expectation can be
viewed as an independent value function and updated in a manner similar to the value
iteration procedure used by Boutilier et al. (2000). We now recap the construction briefly,
by first defining:
Ga (x) =

X
x0

P (x0 | x, a)

X

wi hi (x0 ) =

i

X
i

wi

X

P (x0 | x, a)hi (x0 ).

x0

Thus, we can compute the expectation of each basis function separately:
gia (x) =

X

P (x0 | x, a)hi (x0 ),

x0

413

fiGuestrin, Koller, Parr & Venkataraman

P

and then weight them by wi to obtain the total expectation Ga (x) = i wi gia (x). The
intermediate function gia is called the backprojection of the basis function hi through the
transition model Pa , which we denote by gia = Pa hi . Note that, in factored MDPs, the
transition model Pa is factored (represented as a DBN) and the basis functions hi have
scope restricted to a small set of variables. These two important properties allow us to
compute the backprojections very efficiently.
We now show how some restricted scope function h (such as our basis functions)
can be backprojected through some transition model P represented as a DBN  . Here
h has scope restricted to Y; our goal is to compute g = P h. We define the backprojected scope of Y through  as the set of parents of Y0 in the transition graph G ;
 (Y0 ) = Yi0 Y0 Parents (Yi0 ). If intra-time slice arcs are included, so that Parents (Xi0 ) 
{X1 , . . . , Xn , X10 , . . . , Xn0 }, then the only change in our algorithm is in the definition of backprojected scope of Y through  . The definition now includes not only direct parents of Y 0 ,
but also all variables in {X1 , . . . , Xn } that are ancestors of Y 0 :
 (Y0 ) = {Xj | there exist a directed path from Xj to any Xi0  Y0 }.
Thus, the backprojected scope may become larger, but the functions are still factored.
We can now show that, if h has scope restricted to Y, then its backprojection g has
scope restricted to the parents of Y0 , i.e.,  (Y0 ). Furthermore, each backprojection can
be computed by only enumerating settings of variables in  (Y0 ), rather than settings of
all variables X:
g(x) = (P h)(x);
=

X

P (x0 | x)h(x0 );

x0

=

X

P (x0 | x)h(y0 );

x0

=

X
y0

=

X

X

P (y0 | x)h(y0 )

P (u0 | x);

u0 (x0 y0 )

P (y0 | z)h(y0 );

y0

= g(z);
P

where z is the value of  (Y0 ) in x and the term u0 (x0 y0 ) P (u0 | x) = 1 as it is the
sum of a probability distribution over a complete domain. Therefore, we see that (P h) is a
function whose scope is restricted to  (Y0 ). Note that the cost of the computation depends
linearly on |Dom( (Y0 ))|, which depends on Y (the scope of h) and on the complexity of
the process dynamics. This backprojection procedure is summarized in Figure 3.
Returning to our example, consider a basis function hi that is an indicator of variable Xi :
it takes value 1 if the ith machine is working and 0 otherwise. Each hi has scope restricted to
Xi0 , thus, its backprojection gi has scope restricted to Parents (Xi0 ):  (Xi0 ) = {Xi1 , Xi }.
4.2 Representing Exponentially Many Constraints
As seen in Section 3, both our approximation algorithms require the solution of linear programs: the LP in (5) for approximate policy iteration, and the LP in (8) for the approximate
414

fiEfficient Solution Algorithms for Factored MDPs

Backproja (h) 

where basis function h has scope C.

Define the scope of the backprojection: a (C0 ) = Xi0 C0 Parentsa (Xi0 ).
0
For each assignment
P
Q y  a (C ):0 0
a
g (y) = c0 C0 i|X 0 C0 Pa (c [Xi ] | y)h(c0 ).
i

Return g a .

Figure 3: Backprojection of basis function h.
linear programming algorithm. These LPs have some common characteristics: they have
a small number of free variables (for k basis functions there are k + 1 free variables in approximate policy iteration and k in approximate linear programming), but the number of
constraints is still exponential in the number of state variables. However, in factored MDPs,
these LP constraints have another very useful property: the functionals in the constraints
have restricted scope. This key observation allows us to represent these constraints very
compactly.
First, observe that the constraints in the linear programs are all of the form:


X

wi ci (x)  b(x), x,

(11)

i

where only  and w1 , . . . , wk are free variables in the LP and x ranges over all states. This
general form represents both the type of constraint in the max-norm projection LP in (5)
and the approximate linear programming formulation in (8).3
The first insight in our construction is that we can replace the entire set of constraints
in Equation (11) by one equivalent non-linear constraint:
  max
x

X

wi ci (x)  b(x).

(12)

i

The second insight is that this new non-linear constraint can be implemented by a set of
linear constraints using a construction that follows the structure of variable elimination in
cost networks. This insight allows us to exploit structure in factored MDPs to represent
this constraint compactly.
We tackle the problem of representing the constraint in Equation (12) in two steps:
first, computing the maximum assignment for a fixed set of weights; then, representing the
non-linear constraint by small set of linear constraints, using a construction we call the
factored LP.
4.2.1 Maximizing Over the State Space
The key computation in our algorithms is to represent a non-linear constraint of the form
in Equation (12) efficiently by a small set of linear constraints. Before presenting this construction, lets first consider a simpler problem: Given some fixed weights wi , we would
P
like to compute the maximization:  = maxx i wi ci (x)  b(x), that is, the state x, such
P

3. The complementary constraints in (5),   b(x)  i wi ci (x), can be formulated using an analogous
construction to the one we present in this section by changing the sign of ci (x) and b(x). The approximate
linear programming constraints of (8) can also be formulated in this form, as we show in Section 5.

415

fiGuestrin, Koller, Parr & Venkataraman

P

that the difference between i wi ci (x) and b(x) is maximal. However, we cannot explicitly enumerate the exponential number of states and compute the difference. Fortunately,
structure in factored MDPs allows us to compute this maximum efficiently.
In the case of factored MDPs, our state space is a set of vectors x which are assignments to the state variables X = {X1 , . . . , Xn }. We can view both Cw and b as functions
of these state variables, and hence also their difference. Thus, we can define a function
P
F w (X1 , . . . , Xn ) such that F w (x) = i wi ci (x)  b(x). Note that we have executed a
representation shift; we are viewing F w as a function of the variables X, which is parameterized by w. Recall that the size of the state space is exponential in the number
of variables. Hence, our goal in this section is to compute maxx F w (x) without explicitly
considering each of the exponentially many states. The solution is to use the fact that F w
P
has a factored representation. More precisely, Cw has the form i wi ci (Zi ), where Zi is
a subset of X. For example, we might have c1 (X1 , X2 ) which takes value 1 in states where
X1 = true and X2 = false and 0 otherwise. Similarly, the vector b in our case is also a sum
P
of restricted scope functions. Thus, we can express F w as a sum j fjw (Zj ), where fjw may
or may not depend on w. In the future, we sometimes drop the superscript w when it is
clear from context.
P
Using our more compact notation, our goal here is simply to compute maxx i wi ci (x)
b(x) = maxx F w (x), that is, to find the state x over which F w is maximized. Recall that
P
w
Fw = m
j=1 fj (Zj ). We can maximize such a function, F , without enumerating every state
using non-serial dynamic programming (Bertele & Brioschi, 1972). The idea is virtually
identical to variable elimination in a Bayesian network. We review this construction here,
as it is a central component in our solution LP.
Our goal is to compute
X
max
fj (x[Zj ]).
x1 ,...,xn

j

The main idea is that, rather than summing all functions and then doing the maximization,
we maximize over variables one at a time. When maximizing over xl , only summands
involving xl participate in the maximization.
Example 4.2 Assume
F = f1 (x1 , x2 ) + f2 (x1 , x3 ) + f3 (x2 , x4 ) + f4 (x3 , x4 ).
We therefore wish to compute:
max

x1 ,x2 ,x3 ,x4

f1 (x1 , x2 ) + f2 (x1 , x3 ) + f3 (x2 , x4 ) + f4 (x3 , x4 ).

We can first compute the maximum over x4 ; the functions f1 and f2 are irrelevant, so we
can push them out. We get
max f1 (x1 , x2 ) + f2 (x1 , x3 ) + max[f3 (x2 , x4 ) + f4 (x3 , x4 )].

x1 ,x2 ,x3

x4

The result of the internal maximization depends on the values of x2 , x3 ; thus, we can introduce a new function e1 (X2 , X3 ) whose value at the point x2 , x3 is the value of the internal
max expression. Our problem now reduces to computing
max f1 (x1 , x2 ) + f2 (x1 , x3 ) + e1 (x2 , x3 ),

x1 ,x2 ,x3

416

fiEfficient Solution Algorithms for Factored MDPs

VariableElimination (F, O)
//F = {f1 , . . . , fm } is the set of functions to be maximized;
//O stores the elimination order.

For i = 1 to number of variables:
//Select the next variable to be eliminated.

Let l = O(i) ;
//Select the relevant functions.

Let e1 , . . . , eL be the functions in F whose scope contains Xl .
//Maximize over current variable Xl .

Define a new function e = maxxl
L
j=1 Scope[ej ]  {Xl }.

PL

j=1 ej

; note that Scope[e] =

//Update set of functions.

Update the set of functions F = F  {e} \ {e1 , . . . , eL }.
//Now, all functions have empty scope
P and their sum is the maximum value of f1 +    + fm .

Return the maximum value

ei F

ei .

Figure 4: Variable elimination procedure for computing the maximum value f1 +    + fm ,
where each fi is a restricted scope function.

having one fewer variable. Next, we eliminate another variable, say X3 , with the resulting
expression reducing to:
max f1 (x1 , x2 ) + e2 (x1 , x2 ),
x1 ,x2

where

e2 (x1 , x2 ) = max[f2 (x1 , x3 ) + e1 (x2 , x3 )].
x3

Finally, we define
e3 = max f1 (x1 , x2 ) + e2 (x1 , x2 ).
x1 ,x2

The result at this point is a number, which is the desired maximum over x1 , . . . , x4 . While
the naive approach of enumerating all states requires 63 arithmetic operations if all variables
are binary, using variable elimination we only need to perform 23 operations.
The general variable elimination algorithm is described in Figure 4. The inputs to
the algorithm are the functions to be maximized F = {f1 , . . . , fm } and an elimination
ordering O on the variables, where O(i) returns the ith variable to be eliminated. As in
the example above, for each variable Xl to be eliminated, we select the relevant functions
e1 , . . . , eL , those whose scope contains Xl . These functions are removed from the set F and
P
we introduce a new function e = maxxl L
j=1 ej . At this point, the scope of the functions in
F no longer depends on Xl , that is, Xl has been eliminated. This procedure is repeated
until all variables have been eliminated. The remaining functions in F thus have empty
scope. The desired maximum is therefore given by the sum of these remaining functions.
The computational cost of this algorithm is linear in the number of new function
values introduced in the elimination process. More precisely, consider the computation of
a new function e whose scope is Z. To compute this function, we need to compute |Dom[Z]|
different values. The cost of the algorithm is linear in the overall number of these values,
introduced throughout the execution. As shown by Dechter (1999), this cost is exponential
417

fiGuestrin, Koller, Parr & Venkataraman

in the induced width of the cost network, the undirected graph defined over the variables
X1 , . . . , Xn , with an edge between Xl and Xm if they appear together in one of the original
functions fj . The complexity of this algorithm is, of course, dependent on the variable
elimination order and the problem structure. Computing the optimal elimination order
is an NP-hard problem (Arnborg, Corneil, & Proskurowski, 1987) and elimination orders
yielding low induced tree width do not exist for some problems. These issues have been
confronted successfully for a large variety of practical problems in the Bayesian network
community, which has benefited from a large variety of good heuristics which have been
developed for the variable elimination ordering problem (Bertele & Brioschi, 1972; Kjaerulff,
1990; Reed, 1992; Becker & Geiger, 2001).
4.2.2 Factored LP
In this section, we present the centerpiece of our planning algorithms: a new, general
approach for compactly representing exponentially large sets of LP constraints in problems
with factored structure  those where the functions in the constraints can be decomposed
as the sum of restricted scope functions. Consider our original problem of representing
the non-linear constraint in Equation (12) compactly. Recall that we wish to represent
P
the non-linear constraint   maxx i wi ci (x)  b(x), or equivalently,   maxx F w (x),
without generating one constraint for each state as in Equation (11). The new, key insight
is that this non-linear constraint can be implemented using a construction that follows the
structure of variable elimination in cost networks.
Consider any function e used within F (including the original fi s), and let Z be its scope.
For any assignment z to Z, we introduce variable uez , whose value represents ez , into the
linear program. For the initial functions fiw , we include the constraint that ufzi = fiw (z). As
fiw is linear in w, this constraint is linear in the LP variables. Now, consider a new function
e introduced into F by eliminating a variable Xl . Let e1 , . . . , eL be the functions extracted
from F, and let Z be the scope of the resulting e. We introduce a set of constraints:
uez



L
X
ej
j=1

u(z,xl )[Zj ]

xl .

(13)

Let en be the last function generated in the elimination, and recall that its scope is empty.
Hence, we have only a single variable uen . We introduce the additional constraint   uen .
The complete algorithm, presented in Figure 5, is divided into three parts: First, we
generate equality constraints for functions that depend on the weights wi (basis functions).
In the second part, we add the equality constraints for functions that do not depend on the
weights (target functions). These equality constraints let us abstract away the differences
between these two types of functions and manage them in a unified fashion in the third
part of the algorithm. This third part follows a procedure similar to variable elimination
described in Figure 4. However, unlike standard variable elimination where we would inP
troduce a new function e, such that e = maxxl L
j=1 ej , in our factored LP procedure we
introduce new LP variables uez . To enforce the definition of e as the maximum over Xl of
PL
j=1 ej , we introduce the new LP constraints in Equation (13).
Example 4.3 To understand this construction, consider our simple example above, and
assume we want to express the fact that   maxx F w (x). We first introduce a set of
418

fiEfficient Solution Algorithms for Factored MDPs

FactoredLP (C, b,O)
// C = {c1 , . . . , ck } is the set of basis functions.
// b = {b1 , . . . , bm } is the set of target functions.
//O stores the elimination order.
P
P
//Return a (polynomial) set of constraints  equivalent to   i wi ci (x) + j bj (x), x .
//Data structure for the constraints in factored LP.

Let  = {} .
//Data structure for the intermediate functions generated in variable elimination.

Let F = {} .
//Generate equality constraint to abstract away basis functions.

For each ci  C:
Let Z = Scope[ci ].
For each assignment z  Z, create a new LP variable ufzi and add a
constraint to :
ufzi = wi ci (z).
Store new function fi to use in variable elimination step: F = F  {fi }.
//Generate equality constraint to abstract away target functions.

For each bj  b:
Let Z = Scope[bj ].
f
For each assignment z  Z, create a new LP variable uzj and add a
constraint to :
f
uzj = bj (z).
Store new function fj to use in variable elimination step: F = F  {fj }.
//Now, F contains all of the functions involved in the LP, our constraints become:  
P
e (x), x , which we represent compactly using a variable elimination procedure.
e F i
i

For i = 1 to number of variables:

//Select the next variable to be eliminated.

Let l = O(i) ;
//Select the relevant functions.

Let e1 , . . . , eL be the functions in F whose scope contains Xl , and let
Zj = Scope[ej ].
//Introduce linear constraints for the maximum over current variable Xl .

Define a new function e with scope Z = L
j=1 Zj  {Xl } to represent
PL
maxxl j=1 ej .
Add constraints to  to enforce maximum: for each assignment z  Z:
uez 

L
X

e

j
u(z,x
l )[Zj ]

xl .

j=1

//Update set of functions.

Update the set of functions F = F  {e} \ {e1 , . . . , eL }.
//Now, all variables have been eliminated and all functions have empty scope.

Add last constraint to :


X

ei .

ei F

Return .

Figure 5: Factored LP algorithm for the compact representation of the exponential set of
P
P
constraints   i wi ci (x) + j bj (x), x.
419

fiGuestrin, Koller, Parr & Venkataraman

variables ufx11 ,x2 for every instantiation of values x1 , x2 to the variables X1 , X2 . Thus, if
X1 and X2 are both binary, we have four such variables. We then introduce a constraint
defining the value of ufx11 ,x2 appropriately. For example, for our f1 above, we have uft,t1 = 0
and uft,f1 = w1 . We have similar variables and constraints for each fj and each value z in
Zj . Note that each of the constraints is a simple equality constraint involving numerical
constants and perhaps the weight variables w.
Next, we introduce variables for each of the intermediate expressions generated by variable elimination. For example, when eliminating X4 , we introduce a set of LP variables
uex12 ,x3 ; for each of them, we have a set of constraints
uex12 ,x3  ufx32 ,x4 + ufx43 ,x4
one for each value x4 of X4 . We have a similar set of constraint for uex21 ,x2 in terms of
ufx21 ,x3 and uex12 ,x3 . Note that each constraint is a simple linear inequality.
We can now prove that our factored LP construction represents the same constraint as
non-linear constraint in Equation (12):
Theorem 4.4 The constraints generated by the factored LP construction are equivalent to
the non-linear constraint in Equation (12). That is, an assignment to (, w) satisfies the
factored LP constraints if and only if it satisfies the constraint in Equation (12).
Proof: See Appendix A.3.
P
Returning to our original formulation, we have that j fjw is Cw  b in the original
set of constraints. Hence our new set of constraints is equivalent to the original set:  
P
maxx i wi ci (x)  b(x) in Equation (12), which in turn is equivalent to the exponential
P
set of constraints   i wi ci (x)  b(x), x in Equation (11). Thus, we can represent this
exponential set of constraints by a new set of constraints and LP variables. The size of
this new set, as in variable elimination, is exponential only in the induced width of the cost
network, rather than in the total number of variables.
In this section, we presented a new, general approach for compactly representing exponentially-large sets of LP constraints in problems with factored structure. In the remainder
of this paper, we exploit this construction to design efficient planning algorithms for factored
MDPs.
4.2.3 Factored Max-norm Projection
We can now use our procedure for representing the exponential number of constraints in
Equation (11) compactly to compute efficient max-norm projections, as in Equation (4):
w  arg min kCw  bk .
w

The max-norm projection is computed by the linear program in (5). There are two sets
P
P
of constraints in this LP:   kj=1 cij wj  bi , i and   bi  kj=1 cij wj , i. Each of
these sets is an instance of the constraints in Equation (11), which we have just addressed
in the previous section. Thus, if each of the k basis functions in C is a restricted scope
function and the target function b is the sum of restricted scope functions, then we can
use our factored LP technique to represent the constraints in the max-norm projection LP
compactly. The correctness of our algorithm is a corollary of Theorem 4.4:
420

fiEfficient Solution Algorithms for Factored MDPs

Corollary 4.5 The solution ( , w ) of a linear program that minimizes  subject to the
constraints in FactoredLP(C, b,O) and FactoredLP(C, b,O), for any elimination
order O satisfies:
w  arg min kCw  bk ,
w

and

 = min kCw  bk .
w

The original max-norm projection LP had k + 1 variables and two constraints for each
state x; thus, the number of constraints is exponential in the number of state variables.
On the other hand, our new factored max-norm projection LP has more variables, but
exponentially fewer constraints. The number of variables and constraints in the new factored
LP is exponential only in the number of state variables in the largest factor in the cost
network, rather than exponential in the total number of state variables. As we show in
Section 9, this exponential gain allows us to compute max-norm projections efficiently when
solving very large factored MDPs.

5. Approximate Linear Programming
We begin with the simplest of our approximate MDP solution algorithms, based on the
approximate linear programming formulation in Section 3.3. Using the basic operations
described in Section 4, we can formulate an algorithm that is both simple and efficient.
5.1 The Algorithm
As discussed in Section 3.3, approximate linear program formulation is based on the linear
programming approach to solving MDPs presented in Section 3.3. However, in this approximate version, we restrict the space of value functions to the linear space defined by
our basis functions. More precisely, in this approximate LP formulation, the variables are
w1 , . . . , wk  the weights for our basis functions. The LP is given by:
Variables: w1 , . . . , wk ;
P
P
Minimize:
(x) i wi hi (x) ;
x
P
P
P
0
0
Subject to:
i wi hi (x)  [R(x, a) + 
x0 P (x | x, a)
i wi hi (x )] x  X, a  A.
(14)
In other words, this formulation takes the LP in (7) and substitutes the explicit state value
P
function with a linear value function representation i wi hi (x). This transformation from
an exact to an approximate problem formulation has the effect of reducing the number
of free variables in the LP to k (one for each basis function coefficient), but the number
of constraints remains |X|  |A|. In our SysAdmin problem, for example, the number of
constraints in the LP in (14) is (m + 1)  2m , where m is the number of machines in the
network. However, using our algorithm for representing exponentially large constraint sets
compactly we are able to compute the solution to this approximate linear programming
algorithm in closed form with an exponentially smaller LP, as in Section 4.2.
P
P
First, consider the objective function x (x) i wi hi (x) of the LP (14). Naively
representing this objective function requires a summation over a exponentially large state
space. However, we can rewrite the objective and obtain a compact representation. We
first reorder the terms:
421

fiGuestrin, Koller, Parr & Venkataraman

FactoredALP (P , R, , H, O, )
//P is the factored transition model.
//R is the set of factored reward functions.
// is the discount factor.
//H is the set of basis functions H = {h1 , . . . , hk }.
//O stores the elimination order.
// are the state relevance weights.
//Return the basis function weights w computed by approximate linear programming.
//Cache the backprojections of the basis functions.

For each basis function hi  H; for each action a:
Let gia = Backproja (hi ).
//Compute factored state relevance weights.

For each basis function hi , compute the factored state relevance weights
i as in Equation (15) .
//Generate approximate linear programming constraints

Let  = {}.
For each action a:
}, Ra , O).
Let  =   FactoredLP({g1a  h1 , . . . , gka  hkP

P

//So far, our constraints guarantee that   R(x, a) +  x0 P (x0 | x, a) i wi hi (x0 ) 
P
w hi (x); to satisfy the approximate linear programming solution in (14) we must add
i i
a final constraint.

Let  =   { = 0}.
//We can now obtain the solution weights by solving an LP.

Let w be the solution of the linear program: minimize
the constraints .
Return w.

P
i

i wi , subject to

Figure 6: Factored approximate linear programming algorithm.

422

fiEfficient Solution Algorithms for Factored MDPs

X

(x)

X

x

wi hi (x) =

X

i

X

wi

(x) hi (x).

x

i

Now, consider the state relevance weights (x) as a distribution over states, so that (x) > 0
P
and x (x) = 1. As in backprojections, we can now write:
i =

X

X

(x) hi (x) =

x

(ci ) hi (ci );

(15)

ci Ci

where (ci ) represents the marginal of the state relevance weights  over the domain
Dom[Ci ] of the basis function hi . For example, if we use uniform state relevance weights as
1
in our experiments  (x) = |X|
 then the marginals become (ci ) = |C1i | . Thus, we can
P
rewrite the objective function as i wi i , where each basis weight i is computed as shown
in Equation (15). If the state relevance weights are represented by marginals, then the cost
of computing each i depends exponentially on the size of the scope of Ci only, rather than
exponentially on the number of state variables. On the other hand, if the state relevance
weights are represented by arbitrary distributions, we need to obtain the marginals over the
Ci s, which may not be an efficient computation. Thus, greatest efficiency is achieved by
using a compact representation, such as a Bayesian network, for the state relevance weights.
Second, note that the right side of the constraints in the LP (14) correspond to the Qa
functions:
X
X
Qa (x) = Ra (x) + 
P (x0 | x, a)
wi hi (x0 ).
x0

i

Using the efficient backprojection operation in factored MDPs described in Section 4.1 we
can rewrite the Qa functions as:
Qa (x) = Ra (x) + 

X

wi gia (x);

i

gia

where
is the backprojection of basis function hi through the transition model Pa . As we
discussed, if hi has scope restricted to Ci , then gia is a restricted scope function of a (C0i ).
We can precompute the backprojections gia and the basis relevance weights i . The
approximate linear programming LP of (14) can be written as:
Variables: w1 , . . . , wk ;
P
Minimize:
 w ;
Pi i i
P
a
a
Subject to:
w
i i hi (x)  [R (x) + 
i wi gi (x)] x  X, a  A.

(16)

Finally, we can rewrite this LP to use constraints of the same form as the one in Equation (12):
Variables: w1 , . . . , wk ;
P
Minimize:
i i wi ;
P
Subject to: 0  maxx {Ra (x) + i wi [gia (x)  hi (x)]} a  A.

(17)

We can now use our factored LP construction in Section 4.2 to represent these non-linear
constraints compactly. Basically, there is one set of factored LP constraints for each action
a. Specifically, we can write the non-linear constraint in the same form as those in Equation (12) by expressing the functions C as: ci (x) = hi (x)gia (x). Each ci (x) is a restricted
423

fiGuestrin, Koller, Parr & Venkataraman

scope function; that is, if hi (x) has scope restricted to Ci , then gia (x) has scope restricted
to a (C0i ), which means that ci (x) has scope restricted to Ci  a (C0i ). Next, the target
function b becomes the reward function Ra (x) which, by assumption, is factored. Finally,
in the constraint in Equation (12),  is a free variable. On the other hand, in the LP in (17)
the maximum in the right hand side must be less than zero. This final condition can be
achieved by adding a constraint  = 0. Thus, our algorithm generates a set of factored
LP constraints, one for each action. The total number of constraints and variables in this
new LP is linear in the number of actions |A| and only exponential in the induced width
of each cost network, rather than in the total number of variables. The complete factored
approximate linear programming algorithm is outlined in Figure 6.
5.2 An Example
We now present a complete example of the operations required by the approximate LP algorithm to solve the factored MDP shown in Figure 2(a). Our presentation follows four steps:
problem representation, basis function selection, backprojections and LP construction.
Problem Representation: First, we must fully specify the factored MDP model for the
problem. The structure of the DBN is shown in Figure 2(b). This structure is maintained
for all action choices. Next, we must define the transition probabilities for each action.
There are 5 actions in this problem: do nothing, or reboot one of the 4 machines in the
network. The CPDs for these actions are shown in Figure 2(c). Finally, we must define the
reward function. We decompose the global reward as the sum of 4 local reward functions,
one for each machine, such that there is a reward if the machine is working. Specifically,
Ri (Xi = true) = 1 and Ri (Xi = false) = 0, breaking symmetry by setting R4 (X4 = true) =
2. We use a discount factor of  = 0.9.
In this simple example, we use five simple basis functions.
Basis Function Selection:
First, we include the constant function h0 = 1. Next, we add indicators for each machine
which take value 1 if the machine is working: hi (Xi = true) = 1 and hi (Xi = false) = 0.
Backprojections:
The first algorithmic step is computing the backprojection of the
basis functions, as defined in Section 4.1. The backprojection of the constant basis is
simple:
g0a =

X

Pa (x0 | x)h0 ;

x0

=

X

Pa (x0 | x) 1 ;

x0

= 1.
Next, we must backproject our indicator basis functions hi :
gia =

X
x0

=

Pa (x0 | x)hi (x0i ) ;

X

Y

Pa (x0j | xj1 , xj )hi (x0i ) ;

x01 ,x02 ,x03 ,x04 j

424

fiEfficient Solution Algorithms for Factored MDPs

=

X
x0i

=

X

X

Pa (x0i | xi1 , xi )hi (x0i )

Y

Pa (x0j | xj1 , xj ) ;

x0 [X0 {Xi0 }] j6=i

Pa (x0i | xi1 , xi )hi (x0i ) ;

x0i

= Pa (Xi0 = true | xi1 , xi ) 1 + Pa (Xi0 = false | xi1 , xi ) 0 ;
= Pa (Xi0 = true | xi1 , xi ) .
Thus, gia is a restricted scope function of {Xi1 , Xi }. We can now use the CPDs in Figure 2(c) to specify gia :
reboot = i

(Xi1 , Xi ) =

reboot 6= i

(Xi1 , Xi ) =

gi

gi

Xi = true Xi = false
Xi1 = true
1
1
;
Xi1 = false
1
1
Xi1 = true
Xi1 = false

Xi = true Xi = false
0.9
0.09
.
0.5
0.05

LP Construction:
To illustrate the factored LPs constructed by our algorithms, we
define the constraints for the approximate linear programming approach presented above.
First, we define the functions cai = gia  hi , as shown in Equation (17). In our example,
these functions are ca0 =   1 = 0.1 for the constant basis, and for the indicator bases:
reboot = i

(Xi1 , Xi ) =

reboot 6= i

(Xi1 , Xi ) =

ci

ci

Xi = true Xi = false
Xi1 = true
0.1
0.9
;
Xi1 = false
0.1
0.9
Xi1 = true
Xi1 = false

Xi = true Xi = false
0.19
0.081
.
0.55
0.045

Using this definition of cai , the approximate linear programming constraints are given by:
0  max
x

X

Ri +

X

i

wj caj , a .

(18)

j

We present the LP construction for one of the 5 actions: reboot = 1. Analogous constructions
can be made for the other actions.
In the first set of constraints, we abstract away the difference between rewards and basis
functions by introducing LP variables u and equality constraints. We begin with the reward
functions:
R1
1
uR
x1 = 1 , ux1 = 0 ;

R2
2
uR
x2 = 1 , ux2 = 0 ;

R3
3
uR
x3 = 1 , ux3 = 0 ;

R4
4
uR
x4 = 2 , ux4 = 0 .

We now represent the equality constraints for the caj functions for the reboot = 1 action. Note
that the appropriate basis function weight from Equation (18) appears in these constraints:

425

fiGuestrin, Koller, Parr & Venkataraman

uc0 = 0.1 w0 ;
ucx11 ,x4 = 0.9 w1 ,
ucx11 ,x4 = 0.1 w1 ,
ucx11 ,x4 = 0.9 w1 ;
ucx11 ,x4 = 0.1 w1 ,
c
c
c
ux21 ,x2 = 0.19 w2 , ux21 ,x2 = 0.55 w2 , ux21 ,x2 = 0.081 w2 , ucx21 ,x2 = 0.045 w2 ;
ucx32 ,x3 = 0.19 w3 , ucx32 ,x3 = 0.55 w3 , ucx32 ,x3 = 0.081 w3 , ucx32 ,x3 = 0.045 w3 ;
ucx43 ,x4 = 0.19 w4 , ucx43 ,x4 = 0.55 w4 , ucx43 ,x4 = 0.081 w4 , ucx43 ,x4 = 0.045 w4 .
Using these new LP variables, our LP constraint from Equation (18) for the reboot = 1 action
becomes:
0

max

X1 ,X2 ,X3 ,X4

4
4
X
X
c
c0
i
uR
+
u
+
uXjj1 ,Xj .
Xi
i=1

j=1

We are now ready for the variable elimination process. We illustrate the elimination of
variable X4 :
0

max

X1 ,X2 ,X3

3
3
h
i
X
X
c
Ri
c1
c4
c0
4
uXi + u +
uXjj1 ,Xj + max uR
X4 + uX1 ,X4 + uX3 ,X4 .
i=1

X4

j=2

h

i

c1
c4
4
We can represent the term maxX4 uR
X4 + uX1 ,X4 + uX3 ,X4 by a set of linear constraints,
one for each assignment of X1 and X3 , using the new LP variables ueX11 ,X3 to represent this
maximum:

uex11 ,x3

c1
c4
4
 uR
x4 + ux1 ,x4 + ux3 ,x4 ;

uex11 ,x3

c1
c4
4
 uR
x4 + ux1 ,x4 + ux3 ,x4 ;

uex11 ,x3

c1
c4
4
 uR
x4 + ux1 ,x4 + ux3 ,x4 ;

uex11 ,x3

c1
c4
4
 uR
x4 + ux1 ,x4 + ux3 ,x4 ;

uex11 ,x3

c4
c1
4
 uR
x4 + ux1 ,x4 + ux3 ,x4 ;

uex11 ,x3

c1
c4
4
 uR
x4 + ux1 ,x4 + ux3 ,x4 ;

uex11 ,x3

c1
c4
4
 uR
x4 + ux1 ,x4 + ux3 ,x4 ;

uex11 ,x3

c1
c4
4
 uR
x4 + ux1 ,x4 + ux3 ,x4 .

We have now eliminated variable X4 and our global non-linear constraint becomes:
0

3
3
X
X
c
c0
i
uR
+
u
+
uXjj1 ,Xj + ueX11 ,X3 .
Xi
X1 ,X2 ,X3

max

j=2

i=1

Next, we eliminate variable X3 . The new LP constraints and variables have the form:
c3
e1
3
ueX21 ,X2  uR
X3 + uX2 ,X3 + uX1 ,X3 ,  X1 , X2 , X3 ;

thus, removing X3 from the global non-linear constraint:
2
X
c2
e2
c0
i
uR
Xi + u + uX1 ,X2 + uX1 ,X2 .
X1 ,X2

0  max

i=1

426

fiEfficient Solution Algorithms for Factored MDPs

250000

Number of LP constraints

200000

# explicit constraints =
(n+1) 2 n

Explicit LP
Factored LP
150000

100000

50000

# factored constraints =
12n2 + 5n - 8
0
0

2

4

6
8
10
Number of machines in ring

12

14

16

Figure 7: Number of constraints in the LP generated by the explicit state representation
versus the factored LP construction for the solution of the ring problem with
basis functions over single variables and approximate linear programming as the
solution algorithm.

We can now eliminate X2 , generating the linear constraints:
c2
e2
2
ueX31  uR
X2 + uX1 ,X2 + uX1 ,X2 ,  X1 , X2 .

Now, our global non-linear constraint involves only X1 :
e3
c0
1
0  max uR
X1 + u + uX1 .
X1

As X1 is the last variable to be eliminated, the scope of the new LP variable is empty and
the linear constraints are given by:
e3
1
u e4  u R
X1 + uX1 ,  X1 .

All of the state variables have now been eliminated, turning our global non-linear constraint
into a simple linear constraint:
0  uc0 + ue4 ,
which completes the LP description for the approximate linear programming solution to
the problem in Figure 2.
In this small example with only four state variables, our factored LP technique generates
a total of 89 equality constraints, 115 inequality constraints and 149 LP variables, while
the explicit state representation in Equation (8) generates only 80 inequality constraints
and 5 LP variables. However, as the problem size increases, the number of constraints and
LP variables in our factored LP approach grow as O(n2 ), while the explicit state approach
grows exponentially, at O(n2n ). This scaling effect is illustrated in Figure 7.

6. Approximate Policy Iteration with Max-norm Projection
The factored approximate linear programming approach described in the previous section
is both elegant and easy to implement. However, we cannot, in general, provide strong
427

fiGuestrin, Koller, Parr & Venkataraman

guarantees about the error it achieves. An alternative is to use the approximate policy
iteration described in Section 3.2, which does offer certain bounds on the error. However,
as we shall see, this algorithm is significantly more complicated, and requires that we place
additional restrictions on the factored MDP.
In particular, approximate policy iteration requires a representation of the policy at each
iteration. In order to obtain a compact policy representation, we must make an additional
assumption: each action only affects a small number of state variables. We first state this
assumption formally. Then, we show how to obtain a compact representation of the greedy
policy with respect to a factored value function, under this assumption. Finally, we describe
our factored approximate policy iteration algorithm using max-norm projections.
6.1 Default Action Model
In Section 2.2, we presented the factored MDP model, where each action is associated with
its own factored transition model represented as a DBN and with its own factored reward
function. However, different actions often have very similar transition dynamics, only differing in their effect on some small set of variables. In particular, in many cases a variable
has a default evolution model, which only changes if an action affects it directly (Boutilier
et al., 2000).
This type of structure turns out to be useful for compactly representing policies, a property which is important in our approximate policy iteration algorithm. Thus, in this section
of the paper, we restrict attention to factored MDPs that are defined using a default transition model d = hGd , Pd i (Koller & Parr, 2000). For each action a, we define Effects[a]  X0
to be the variables in the next state whose local probability model is different from d , i.e.,
those variables Xi0 such that Pa (Xi0 | Parentsa (Xi0 )) 6= Pd (Xi0 | Parentsd (Xi0 )).
Example 6.1 In our system administrator example, we have an action ai for rebooting
each one of the machines, and a default action d for doing nothing. The transition model
described above corresponds to the do nothing action, which is also the default transition
model. The transition model for ai is different from d only in the transition model for the
variable Xi0 , which is now Xi0 = true with probability one, regardless of the status of the
neighboring machines. Thus, in this example, Effects[ai ] = Xi0 .
As in the transition dynamics, we can also define the notion of default reward model. In
P
this case, there is a set of reward functions ri=1 Ri (Ui ) associated with the default action
d. In addition, each action a can have a reward function Ra (Ua ). Here, the extra reward of
action a has scope restricted to Rewards[a] = Uai  {X1 , . . . , Xn }. Thus, the total reward
P
associated with action a is given by Ra + ri=1 Ri . Note that Ra can also be factored as a
linear combination of smaller terms for an even more compact representation.
We can now build on this additional assumption to define the complete algorithm.
Recall that the approximate policy iteration algorithm iterates through two steps: policy
improvement and approximate value determination. We now discuss each of these steps.
6.2 Computing Greedy Policies
The policy improvement step computes the greedy policy relative to a value function V (t1) :
 (t) = Greedy(V (t1) ).
428

fiEfficient Solution Algorithms for Factored MDPs

Recall that our value function estimates have the linear form Hw. As we described in
Section 4.1, the greedy policy for this type of value function is given by:
Greedy(Hw)(x) = arg max Qa (x),
a

P

where each Qa can be represented by: Qa (x) = R(x, a) + i wi gia (x).
If we attempt to represent this policy naively, we are again faced with the problem
of exponentially large state spaces. Fortunately, as shown by Koller and Parr (2000), the
greedy policy relative to a factored value function has the form of a decision list. More
precisely, the policy can be written in the form ht1 , a1 i, ht2 , a2 i, . . . , htL , aL i, where each ti
is an assignment of values to some small subset Ti of variables, and each ai is an action.
The greedy action to take in state x is the action aj corresponding to the first event tj in
the list with which x is consistent. For completeness, we now review the construction of
this decision-list policy.
The critical assumption that allows us to represent the policy as a compact decision list
is the default action assumption described in Section 6.1. Under this assumption, the Qa
functions can be written as:
a

Qa (x) = R (x) +

r
X

Ri (x) +

i=1

X

wi gia (x),

i

where Ra has scope restricted to Ua . The Q function for the default action d is just:
P
P
Qd (x) = ri=1 Ri (x) + i wi gid (x).
We now have a set of linear Q-functions which implicitly describes a policy . It is
not immediately obvious that these Q functions result in a compactly expressible policy.
An important insight is that most of the components in the weighted combination are
identical, so that gia is equal to gid for most i. Intuitively, a component gia corresponding
to the backprojection of basis function hi (Ci ) is only different if the action a influences
one of the variables in Ci . More formally, assume that Effects[a]  Ci = . In this case,
all of the variables in Ci have the same transition model in a and d . Thus, we have
that gia (x) = gid (x); in other words, the ith component of the Qa function is irrelevant
when deciding whether action a is better than the default action d. We can define which
components are actually relevant: let Ia be the set of indices i such that Effects[a]  Ci 6= .
These are the indices of those basis functions whose backprojection differs in Pa and Pd .
In our example DBN of Figure 2, actions and basis functions involve single variables, so
Iai = i.
Let us now consider the impact of taking action a over the default action d. We can
define the impact  the difference in value  as:
a (x) = Qa (x)  Qd (x);
= Ra (x) +

X

h

i

wi gia (x)  gid (x) .

(19)

iIa

This analysis shows that a (x) is a function whose scope is restricted to




Ta = Ua  iIa a (C0i ) .
429

(20)

fiGuestrin, Koller, Parr & Venkataraman

DecisionListPolicy (Qa )
//Qa is the set of Q-functions, one for each action;
//Return the decision list policy .
//Initialize decision list.

Let  = {}.
//Compute the bonus functions.

For each action a, other than the default action d:
Compute the bonus for taking action a,
a (x) = Qa (x)  Qd (x);
as in Equation (19). Note that a has scope restricted to Ta , as in
Equation (20).
//Add states with positive bonuses to the (unsorted) decision list.

For each assignment t  Ta :
If a (t) > 0, add branch to decision list:
 =   {ht, a, a (t)i}.
//Add the default action to the (unsorted) decision list.

Let  =   {h, d, 0i}.
//Sort decision list to obtain final policy.

Sort the decision list  in decreasing order on the  element of ht, a, i.
Return .

Figure 8: Method for computing the decision list policy  from the factored representation
of the Qa functions.

In our example DBN, Ta2 = {X1 , X2 }.
Intuitively, we now have a situation where we have a baseline value function Qd (x)
which defines a value for each state x. Each action a changes that baseline by adding or
subtracting an amount from each state. The point is that this amount depends only on Ta ,
so that it is the same for all states in which the variables in Ta take the same values.
We can now define the greedy policy relative to our Q functions. For each action a, define
a set of conditionals ht, a, i, where each t is some assignment of values to the variables Ta ,
and  is a (t). Now, sort the conditionals for all of the actions by order of decreasing :
ht1 , a1 , 1 i, ht2 , a2 , 2 i, . . . , htL , aL , L i.
Consider our optimal action in a state x. We would like to get the largest possible bonus
over the default value. If x is consistent with t1 , we should clearly take action a1 , as it
gives us bonus 1 . If not, then we should try to get 2 ; thus, we should check if x is
consistent with t2 , and if so, take a2 . Using this procedure, we can compute the decisionlist policy associated with our linear estimate of the value function. The complete algorithm
for computing the decision list policy is summarized in Figure 8.
P
Note that the number of conditionals in the list is a |Dom(Ta )|; Ta , in turn, depends
on the set of basis function clusters that intersect with the effects of a. Thus, the size
of the policy depends in a natural way on the interaction between the structure of our
430

fiEfficient Solution Algorithms for Factored MDPs

process description and the structure of our basis functions. In problems where the actions
modify a large number of variables, the policy representation could become unwieldy. The
approximate linear programming approach in Section 5 is more appropriate in such cases,
as it does not require an explicit representation of the policy.
6.3 Value Determination
In the approximate value determination step our algorithm computes:
w(t) = arg min kHw  (R(t) + P(t) Hw)k .
w

By rearranging the expression, we get:
w(t) = arg min k(H  P(t) H) w  R(t) k .
w

This equation is an instance of the optimization in Equation (4). If P(t) is factored, we can
conclude that C = (H  P(t) H) is also a matrix whose columns correspond to restrictedscope functions. More specifically:
(t)

ci (x) = hi (x)  gi (x),
(t)

where gi is the backprojection of the basis function hi through the transition model P(t) ,
as described in Section 4.1. The target b = R(t) corresponds to the reward function, which
for the moment is assumed to be factored. Thus, we can again apply our factored LP in
Section 4.2.3 to estimate the value of the policy  (t) .
Unfortunately, the transition model P(t) is not factored, as a decision list representation for the policy  (t) will, in general, induce a transition model P(t) which cannot be
represented by a compact DBN. Nonetheless, we can still generate a compact LP by exploiting the decision list structure of the policy. The basic idea is to introduce cost networks
corresponding to each branch in the decision list, ensuring, additionally, that only states
consistent with this branch are considered in the cost network maximization. Specifically,
we have a factored LP construction for each branch hti , ai i. The ith cost network only
considers a subset of the states that is consistent with the ith branch of the decision list.
Let Si be the set of states x such that ti is the first event in the decision list for which x
is consistent. That is, for each state x  Si , x is consistent with ti , but it is not consistent
with any tj with j < i.
Recall that, as in Equation (11), our LP construction defines a set of constraints that
P
imply that   i wi ci (x)  b(x) for each state x. Instead, we have a separate set of
constraints for the states in each subset Si . For each state in Si , we know that action ai is
taken. Hence, we can apply our construction above using Pai  a transition model which is
factored by assumption  in place of the non-factored P(t) . Similarly, the reward function
P
becomes Rai (x) + ri=1 Ri (x) for this subset of states.
The only issue is to guarantee that the cost network constraints derived from this transition model are applied only to states in Si . Specifically, we must guarantee that they are
applied only to states consistent with ti , but not to states that are consistent with some
tj for j < i. To guarantee the first condition, we simply instantiate the variables in Ti to
take the values specified in ti . That is, our cost network now considers only the variables in
431

fiGuestrin, Koller, Parr & Venkataraman

FactoredAPI (P , R, , H, O, , tmax )
//P is the factored transition model.
//R is the set of factored reward functions.
// is the discount factor.
//H is the set of basis functions H = {h1 , . . . , hk }.
//O stores the elimination order.
// Bellman error precision.
//tmax maximum number of iterations.
//Return the basis function weights w computed by approximate policy iteration.
//Initialize weights

Let w(0) = 0.
//Cache the backprojections of the basis functions.

For each basis function hi  H; for each action a:
Let gia = Backproja (hi ).
//Main approximate policy iteration loop.

Let t = 0.
Repeat
//Policy improvement part of the loop.
//Compute decision list policy for iteration t weights.

Let (t) = DecisionListPolicy(Ra + 

P

i

(t)

wi gia ).

//Value determination part of the loop.
//Initialize constraints for max-norm projection LP.

Let + = {} and  = {}.
//Initialize indicators.

Let I = {}.
//For every branch of the decision list policy, generate the relevant set of constraints, and
update the indicators to constraint the state space for future branches.

For each branch htj , aj i in the decision list policy (t) :
//Instantiate the variables in Tj to the assignment given in tj .
a

a

Instantiate the set of functions {h1  g1 j , . . . , hk  gk j } with the
partial state assignment tj and store in C.
Instantiate the target functions Raj with the partial state assignment tj and store in b.
Instantiate the indicator functions I with the partial state assignment tj and store in I 0 .
//Generate the factored LP constraints for the current decision list branch.

Let + = +  FactoredLP(C, b + I 0 , O).
Let  =   FactoredLP(C, b + I 0 , O).
//Update the indicator functions.

Let Ij (x) = 1(x = tj ) and update the indicators I = I  Ij .
//We can now obtain the new set of weights by solving an LP, which corresponds to the
max-norm projection.

Let w(t+1) be the solution of the linear program: minimize , subject
to the constraints {+ ,  }.
Let t = t + 1.
Until BellmanErr(Hw(t) )   or t  tmax or w(t1) = w(t) .
Return w(t) .

Figure 9: Factored approximate policy iteration with max-norm projection algorithm.

432

fiEfficient Solution Algorithms for Factored MDPs

{X1 , . . . , Xn }Ti , and computes the maximum only over the states consistent with Ti = ti .
To guarantee the second condition, we ensure that we do not impose any constraints on
states associated with previous decisions. This is achieved by adding indicators Ij for each
previous decision tj , with weight . More specifically, Ij is a function that takes value
 for states consistent with tj and zero for other all assignments of Tj . The constraints
for the ith branch will be of the form:
  R(x, ai ) +

X

wl (gl (x, ai )  h(x)) +

X

1(x = tj ),

x  [ti ],

(21)

j<i

l

where x  [ti ] defines the assignments of X consistent with ti . The introduction of these
indicators causes the constraints associated with ti to be trivially satisfied by states in Sj
for j < i. Note that each of these indicators is a restricted-scope function of Tj and can
be handled in the same fashion as all other terms in the factored LP. Thus, for a decision
list of size L, our factored LP contains constraints from 2L cost networks. The complete
approximate policy iteration with max-norm projection algorithm is outlined in Figure 9.
6.4 Comparisons
It is instructive to compare our max-norm policy iteration algorithm to the L2 -projection
policy iteration algorithm of Koller and Parr (2000) in terms of computational costs per
iteration and implementation complexity. Computing the L2 projection requires (among
other things) a series of dot product operations between basis functions and backprojected
basis functions hhi gj i. These expressions are easy to compute if P refers to the transition
model of a particular action a. However, if the policy  is represented as a decision list, as is
the result of the policy improvement step, then this step becomes much more complicated.
In particular, for every branch of the decision list, for every pair of basis functions i and j,
and for each assignment to the variables in Scope[hi ]  Scope[gja ], it requires the solution of
a counting problem which is ]P -complete in general. Although Koller and Parr show that
this computation can be performed using a Bayesian network (BN) inference, the algorithm
still requires a BN inference for each one of those assignments at each branch of the decision
list. This makes the algorithm very difficult to implement efficiently in practice.
The max-norm projection, on the other hand, relies on solving a linear program at every
iteration. The size of the linear program depends on the cost networks generated. As we
discuss, two cost networks are needed for each point in the decision list. The complexity
of each of these cost networks is approximately the same as only one of the BN inferences
in the counting problem for the L2 projection. Overall, for each branch in the decision
list, we have a total of two of these inferences, as opposed to one for each assignment of
Scope[hi ]  Scope[gja ] for every pair of basis functions i and j. Thus, the max-norm policy
iteration algorithm is substantially less complex computationally than the approach based
on L2 -projection. Furthermore, the use of linear programming allows us to rely on existing
LP packages (such as CPLEX), which are very highly optimized.
It is also interesting to compare the approximate policy iteration algorithm to the approximate linear programming algorithm we presented in Section 5. In the approximate
linear programming algorithm, we never need to compute the decision list policy. The
policy is always represented implicitly by the Qa functions. Thus, this algorithm does not
433

fiGuestrin, Koller, Parr & Venkataraman

require explicit computation or manipulation of the greedy policy. This difference has two
important consequences: one computational and the other in terms of generality.
First, not having to compute or consider the decision lists makes approximate linear
programming faster and easier to implement. In this algorithm, we generate a single LP
with one cost network for each action and never need to compute a decision list policy. On
the other hand, in each iteration, approximate policy iteration needs to generate two LPs
for every branch of the decision list of size L, which is usually significantly longer than |A|,
with a total of 2L cost networks. In terms of representation, we do not require the policies
to be compact; thus, we do not need to make the default action assumption. Therefore, the
approximate linear programming algorithm can deal with a more general class of problems,
where each action can have its own independent DBN transition model. On the other hand,
as described in Section 3.2, approximate policy iteration has stronger guarantees in terms
of error bounds. These differences will be highlighted further in our experimental results
presented in Section 9.

7. Computing Bounds on Policy Quality
We have presented two algorithms for computing approximate solutions to factored MDPs.
b where w
b
All these algorithms generate linear value functions which can be denoted by Hw,
are the resulting basis function weights. In practice, the agent will define its behavior by
b One issue that remains is how this
b = Greedy(Hw).
acting according to the greedy policy 

b compares to the true optimal policy  ; that is, how the actual value Vb
policy 
 of policy
b compares to V  .

In Section 3, we showed some a priori bounds for the quality of the policy. Another
possible procedure is to compute an a posteriori bound. That is, given our resulting weights
b we compute a bound on the loss of acting according to the greedy policy 
b rather than
w,
the optimal policy. This can be achieved by using the Bellman error analysis of Williams
and Baird (1993).
The Bellman error is defined as BellmanErr(V) = kT  V  Vk . Given the greedy
b = Greedy(V), their analysis provides the bound:
policy 
 

V  V   2BellmanErr(V) .
b
 
1

(22)

b to evaluate the quality of our resulting
Thus, we can use the Bellman error BellmanErr(Hw)
greedy policy.
Note that computing the Bellman error involves a maximization over the state space.
Thus, the complexity of this computation grows exponentially with the number of state
variables. Koller and Parr (2000) suggested that structure in the factored MDP can be
exploited to compute the Bellman error efficiently. Here, we show how this error bound can
be computed by a set of cost networks using a similar construction to the one in our maxb that can be represented
norm projection algorithms. This technique can be used for any 
as a decision list and does not depend on the algorithm used to determine the policy. Thus,
we can apply this technique to solutions determined approximate linear programming if the
action descriptions permit a decision list representation of the policy.
b the Bellman error is given by:
For some set of weights w,
434

fiEfficient Solution Algorithms for Factored MDPs

b
FactoredBellmanErr (P , R, , H, O, w)
//P is the factored transition model.
//R is the set of factored reward functions.
// is the discount factor.
//H is the set of basis functions H = {h1 , . . . , hk }.
//O stores the elimination order.
//w
b are the weights for the linear value function.
//Return the Bellman error for the value function Hw.
b
//Cache the backprojections of the basis functions.

For each basis function hi  H; for each action a:
Let gia = Backproja (hi ).
//Compute decision list policy for value function
Hw.
b
a
b = DecisionListPolicy(Ra +  P w
Let 
i bi gi ).
//Initialize indicators.

Let I = {}.
//Initialize Bellman error.

Let  = 0.
//For every branch of the decision list policy, generate the relevant cost networks, solve it with
variable elimination, and update the indicators to constraint the state space for future branches.

b
For each branch htj , aj i in the decision list policy :

//Instantiate the variables in Tj to the assignment given in tj .
a

a

Instantiate the set of functions {w
b1 (h1 g1 j ), . . . , w
bk (hk gk j )} with the
partial state assignment tj and store in C.
Instantiate the target functions Raj with the partial state assignment
tj and store in b.
Instantiate the indicator functions I with the partial state assignment
tj and store in I 0 .
//Use variable elimination to solve first cost network, and update Bellman error, if error
for this branch is larger.

Let  = max (, VariableElimination(C  b + I 0 , O)).
//Use variable elimination to solve second cost network, and update Bellman error, if error
for this branch is larger.

Let  = max (, VariableElimination(C + b + I 0 , O)).
//Update the indicator functions.

Let Ij (x) = 1(x = tj ) and update the indicators I = I  Ij .
Return .
b
Figure 10: Algorithm for computing Bellman error for factored value function Hw.

435

fiGuestrin, Koller, Parr & Venkataraman

b
b  Hwk
b ;
BellmanErr(Hw)
= kT  Hw


= max

P

P

P

maxx i wi hi (x)  Rb (x)   x0 Pb (x0 | x) j wj hj (x0 ) ,
P
P
P
maxx Rb (x) +  x0 Pb (x0 | x) j wj hj (x0 )  i wi hi (x)

!

If the rewards Rb and the transition model Pb are factored appropriately, then we can
compute each one of these two maximizations (maxx ) using variable elimination in a cost
b is a decision list policy and it does not
network as described in Section 4.2.1. However, 
induce a factored transition model. Fortunately, as in the approximate policy iteration
algorithm in Section 6, we can exploit the structure in the decision list to perform such
maximization efficiently. In particular, as in approximate policy iteration, we will generate
two cost networks for each branch in the decision list. To guarantee that our maximization
is performed only over states where this branch is relevant, we include the same type of
indicator functions, which will force irrelevant states to have a value of , thus guaranteeing that at each point of the decision list policy we obtain the corresponding state with
the maximum error. The state with the overall largest Bellman error will be the maximum
over the ones generated for each point the in the decision list policy. The complete factored
algorithm for computing the Bellman error is outlined in Figure 10.
One last interesting note concerns our approximate policy iteration algorithm with maxnorm projection of Section 6. In all our experiments, this algorithm converged, so that
w(t) = w(t+1) after some iterations. If such convergence occurs, then the objective function
(t+1) of the linear program in our last iteration is equal to the Bellman error of the final
policy:
Lemma 7.1 If approximate policy iteration with max-norm projection converges, so that
w(t) = w(t+1) for some iteration t, then the max-norm projection error (t+1) of the last
b = Hw(t) :
iteration is equal to the Bellman error for the final value function estimate Hw
b = (t+1) .
BellmanErr(Hw)

Proof: See Appendix A.4.
Thus, we can bound the loss of acting according to the final policy  (t+1) by substituting
(t+1)

into the Bellman error bound:
Corollary 7.2 If approximate policy iteration with max-norm projection converges after
b associated with a greedy policy 
b =
t iterations to a final value function estimate Hw
b
b instead of the optimal policy   is
Greedy(Hw),
then the loss of acting according to 
bounded by:
(t+1)
 

V  V   2
,
b
 
1

b.
where Vb is the actual value of the policy 

Therefore, when approximate policy iteration converges we can obtain a bound on the
quality of the resulting policy without needing to compute the Bellman error explicitly.
436

.

fiEfficient Solution Algorithms for Factored MDPs

8. Exploiting Context-specific Structure
Thus far, we have presented a suite of algorithms which exploit additive structure in the
reward and basis functions and sparse connectivity in the DBN representing the transition
model. However, there exists another important type of structure that should also be
exploited for efficient decision making: context-specific independence (CSI). For example,
consider an agent responsible for building and maintaining a house, if the painting task can
only be completed after the plumbing and the electrical wiring have been installed, then
the probability that the painting is done is 0, in all contexts where plumbing or electricity
are not done, independently of the agents action. The representation we have used so far in
this paper would use a table to represent this type of function. This table is exponentially
large in the number of variables in the scope of the function, and ignores the context-specific
structure inherent in the problem definition.
Boutilier et al. (Boutilier et al., 1995; Dearden & Boutilier, 1997; Boutilier, Dean, &
Hanks, 1999; Boutilier et al., 2000) have developed a set of algorithms which can exploit CSI
in the transition and reward models to perform efficient (approximate) planning. Although
this approach is often successful in problems where the value function contains sufficient
context-specific structure, the approach is not able to exploit the additive structure which
is also often present in real-world problems.
In this section, we extend the factored MDP model to include context-specific structure.
We present a simple, yet effective extension of our algorithms which can exploit both CSI
and additive structure to obtain efficient approximations for factored MDPs. We first extend
the factored MDP representation to include context-specific structure and then show how
the basic operations from Section 4 required by our algorithms can be performed efficiently
in this new representation.
8.1 Factored MDPs with Context-specific and Additive Structure
There are several representations for context-specific functions. The most common are
decision trees (Boutilier et al., 1995), algebraic decision diagrams (ADDs) (Hoey, St-Aubin,
Hu, & Boutilier, 1999), and rules (Zhang & Poole, 1999). We choose to use rules as our
basic representation, for two main reasons. First, the rule-based representation allows a
fairly simple algorithm for variable elimination, which is a key operation in our framework.
Second, rules are not required to be mutually exclusive and exhaustive, a requirement that
can be restrictive if we want to exploit additive independence, where functions can be
represented as a linear combination of a set of non-mutually exclusive functions.
We begin by describing the rule-based representation (along the lines of Zhang and
Pooles presentation (1999)) for the probabilistic transition model, in particular, the CPDs
of our DBN model. Roughly speaking, each rule corresponds to some set of CPD entries
that are all associated with a particular probability value. These entries with the same
value are referred to as consistent contexts:
Definition 8.1 Let C  {X, X0 } and c  Dom(C). We say that c is consistent with
b  Dom(B), for B  {X, X0 }, if c and b have the same assignment for the variables in
C  B.
The probability of these consistent contexts will be represented by probability rules:
437

fiGuestrin, Koller, Parr & Venkataraman

Electrical

Electrical

Done

Not done

Done

Not done

Plumbing

P(Painting) = 0

Plumbing

P(Painting) = 0
Not done

Done

Not done

Painting

P(Painting) = 0

Done

Not done

P(Painting) = 0

P(Painting) = 0.95

P(Painting) = 0

(a)

Done
P(Painting) = 0.9

(b)

4 = hElectrical : 0i
5 = hElectrical  Plumbing : 0i
6 = hElectrical  Plumbing  Painting : 0i
7 = hElectrical  Plumbing  Painting : 0.9i
(d)

1 = hElectrical : 0i
2 = hElectrical   Plumbing : 0i
3 = hElectrical  Plumbing : 0.95i
(c)

Figure 11: Example CPDs for variable the Painting = true represented as decision trees:
(a) when the action is paint; (b) when the action is not paint. The same CPDs
can be represented by probability rules as shown in (c) and (d), respectively.

Definition 8.2 A probability rule  = hc : pi is a function  : {X, X0 } 7 [0, 1], where the
context c  Dom(C) for C  {X, X0 } and p  [0, 1], such that (x, x0 ) = p if (x, x0 ) is
consistent with c and is equal to 1 otherwise.
In this case, it is convenient to require that the rules be mutually exclusive and exhaustive, so that each CPD entry is uniquely defined by its association with a single rule.
Definition 8.3 A rule-based conditional probability distribution (rule CPD) Pa is a function Pa : ({Xi0 }  X) 7 [0, 1], composed of a set of probability rules {1 , 2 , . . . , m } whose
contexts are mutually exclusive and exhaustive. We define:
Pa (x0i | x) = j (x, x0 ),
where j is the unique rule in Pa for which cj is consistent with (x0i , x). We require that,
for all x,
X
Pa (x0i | x) = 1.
x0i

We can define Parentsa (Xi0 ) to be the union of the contexts of the rules in Pa (Xi0 | X). An
example of a CPD represented by a set of probability rules is shown in Figure 11.
Rules can also be used to represent additive functions, such as reward or basis functions.
We represent such context specific value dependencies using value rules:
438

fiEfficient Solution Algorithms for Factored MDPs

Definition 8.4 A value rule  = hc : vi is a function  : X 7 R such that (x) = v when
x is consistent with c and 0 otherwise.
Note that a value rule hc : vi has a scope C.
It is important to note that value rules are not required to be mutually exclusive and
exhaustive. Each value rule represents a (weighted) indicator function, which takes on a
value v in states consistent with some context c, and 0 in all other states. In any given state,
the values of the zero or more rules consistent with that state are simply added together.
Example 8.5 In our construction example, we might have a set of rules:
1 = hPlumbing = done : 100i;
2 = hElectricity = done : 100i;
3 = hPainting = done : 100i;
4 = hAction = plumb : 10i;
..
.
which, when summed together, define the reward function R = 1 + 2 + 3 + 4 +   .
In general, our reward function Ra is represented as a rule-based function:
Definition 8.6 A rule-based function f : X 7 R is composed of a set of rules {1 , . . . , n }
P
such that f (x) = ni=1 i (x).
In the same manner, each one of our basis functions hj is now represented as a rule-based
function.
This notion of a rule-based function is related to the tree-structure functions used by
Boutilier et al. (2000), but is substantially more general. In the tree-structure value functions, the rules corresponding to the different leaves are mutually exclusive and exhaustive.
Thus, the total number of different values represented in the tree is equal to the number
of leaves (or rules). In the rule-based function representation, the rules are not mutually
exclusive, and their values are added to form the overall function value for different settings
of the variables. Different rules are added in different settings, and, in fact, with k rules,
one can easily generate 2k different possible values, as is demonstrated in Section 9. Thus,
the rule-based functions can provide a compact representation for a much richer class of
value functions.
Using this rule-based representation, we can exploit both CSI and additive independence
in the representation of our factored MDP and basis functions. We now show how the basic
operations in Section 4 can be adapted to exploit our rule-based representation.
8.2 Adding, Multiplying and Maximizing Consistent Rules
In our table-based algorithms, we relied on standard sum and product operators applied to
tables. In order to exploit CSI using a rule-based representation, we must redefine these
standard operations. In particular, the algorithms will need to add or multiply rules that
ascribe values to overlapping sets of states.
We will start by defining these operations for rules with the same context:
439

fiGuestrin, Koller, Parr & Venkataraman

Definition 8.7 Let 1 = hc : v1 i and 2 = hc : v2 i be two rules with context c. Define the
rule product as 1  2 = hc : v1  v2 i, and the rule sum as 1 + 2 = hc : v1 + v2 i.
Note that this definition is restricted to rules with the same context. We will address this
issue in a moment. First, we will introduce an additional operation which maximizes a
variable from a set of rules, which otherwise share a common context:
Definition 8.8 Let Y be a variable with Dom[Y ] = {y1 , . . . , yk }, and let i , for each i =
1, . . . , k, be a rule of the form i = hc  Y = yi : vi i. Then for the rule-based function
f = 1 +    + k , define the rule maximization over Y as maxY f = hc : maxi vi i .
After this operation, Y has been maximized out from the scope of the function f .
These three operations we have just described can only be applied to sets of rules that
satisfy very stringent conditions. To make our set of rules amenable to the application
of these operations, we might need to refine some of these rules. We therefore define the
following operation:
Definition 8.9 Let  = hc : vi be a rule, and Y be a variable. Define the rule split
Split(6 Y ) of  on a variable Y as follows: If Y  Scope[C], then Split(6 Y ) = {};
otherwise,
Split(6 Y ) = {hc  Y = yi : vi | yi  Dom[Y ]} .
Thus, if we split a rule  on variable Y that is not in the scope of the context of , then we
generate a new set of rules, with one for each assignment in the domain of Y .
In general, the purpose of rule splitting is to extend the context c of one rule  coincide
with the context c0 of another consistent rule 0 . Naively, we might take all variables in
Scope[C0 ]  Scope[C] and split  recursively on each one of them. However, this process
creates unnecessarily many rules: If Y is a variable in Scope[C0 ]  Scope[C] and we split 
on Y , then only one of the |Dom[Y ]| new rules generated will remain consistent with 0 : the
one which has the same assignment for Y as the one in c0 . Thus, only this consistent rule
needs to be split further. We can now define the recursive splitting procedure that achieves
this more parsimonious representation:
Definition 8.10 Let  = hc : vi be a rule, and b be a context such that b  Dom[B].
Define the recursive rule split Split(6 b) of  on a context b as follows:
1. {}, if c is not consistent with b; else,
2. {}, if Scope[B]  Scope[C]; else,
3. {Split(i 6 b) | i  Split(6 Y )}, for some variable Y  Scope[B]  Scope[C] .

In this definition, each variable Y  Scope[B]  Scope[C] leads to the generation of k =
|Dom(Y )| rules at the step in which it is split. However, only one of these k rules is used
in the next recursive step because only one is consistent with b. Therefore, the size of the
P
split set is simply 1 + Y Scope[B]Scope[C] (|Dom(Y )|  1). This size is independent of the
order in which the variables are split within the operation.
440

fiEfficient Solution Algorithms for Factored MDPs

Note that only one of the rules in Split(6 b) is consistent with b: the one with context
c  b. Thus, if we want to add two consistent rules 1 = hc1 : v1 i and 2 = hc2 : v2 i, then
all we need to do is replace these rules by the set:
Split(1 6 c2 )  Split(2 6 c1 ),
and then simply replace the resulting rules hc1  c2 : v1 i and hc2  c1 : v2 i by their sum
hc1  c2 : v1 + v2 i. Multiplication is performed in an analogous manner.
Example 8.11 Consider adding the following set of consistent rules:
1 = ha  b : 5i,
2 = ha  c  d : 3i.
In these rules, the context c1 of 1 is a  b, and the context c2 of 2 is a  c  d.
Rules 1 and 2 are consistent, therefore, we must split them to perform the addition
operation:


 ha  b  c : 5i,
ha  b  c  d : 5i,
Split(1 6 c2 ) =

 ha  b  c  d : 5i.
Likewise,

(

Split(2 6

c1 ) =

ha  b  c  d : 3i,
ha  b  c  d : 3i.

The result of adding rules 1 and 2 is
ha  b  c : 5i,
ha  b  c  d : 5i,
ha  b  c  d : 8i,
ha  b  c  d : 3i.

8.3 Rule-based One-step Lookahead
Using this compact rule-based representation, we are able to compute a one-step lookahead
plan efficiently for models with significant context-specific or additive independence.
As in Section 4.1 for the table-based case, the rule-based Qa function can be represented
as the sum of the reward function and the discounted expected value of the next state.
Due to our linear approximation of the value function, the expectation term is, in turn,
represented as the linear combination of the backprojections of our basis functions. To
exploit CSI, we are representing the rewards and basis functions as rule-based functions.
To represent Qa as a rule-based function, it is sufficient for us to show how to represent the
backprojection gj of the basis function hj as a rule-based function.
P (h )
Each hj is a rule-based
function,
which can be written as hj (x) = i i j (x), where
D
E
(h )
(h )
(h )
i j has the form ci j : vi j . Each rule is a restricted scope function; thus, we can
simplify the backprojection as:
441

fiGuestrin, Koller, Parr & Venkataraman

RuleBackproja () ,

where  is given by hc : vi, with c  Dom[C].

Let g = {}.
Select the set P of relevant probability rules:
P = {j  P (Xi0 | Parents(Xi0 )) | Xi0  C and c is consistent with cj }.
Remove the X0 assignments from the context of all rules in P.
// Multiply consistent rules:
While there are two consistent rules 1 = hc1 : p1 i and 2 = hc2 : p2 i:
If c1 = c2 , replace these two rules by hc1 : p1 p2 i;
Else replace these two rules by the set: Split(1 6 c2 )  Split(2 6 c1 ).
// Generate value rules:
For each rule i in P:
Update the backprojection g = g  {hci : pi vi}.
Return g.

Figure 12: Rule-based backprojection.
gja (x) =

X

Pa (x0 | x)hj (x0 ) ;

x0

=

X

Pa (x0 | x)

x0

=

XX
i

=

X (hj )

i

(x0 );

i
(hj )

0

Pa (x | x)i

(x0 );

x0

X (hj )

vi

(hj )

Pa (ci

| x);

i
(h )

(h )

where the term vi j Pa (ci j | x) can be written as a rule function. We denote this back(h )
projection operation by RuleBackproja (i j ).
The backprojection procedure, described in Figure 12, follows three steps. First, the
relevant rules are selected: In the CPDs for the variables that appear in the context of ,
we select the rules consistent with this context, as these are the only rules that play a role
in the backprojection computation. Second, we multiply all consistent probability rules to
form a local set of mutually-exclusive rules. This procedure is analogous to the addition
procedure described in Section 8.2. Now that we have represented the probabilities that
can affect  by a mutually-exclusive set, we can simply represent the backprojection of 
by the product of these probabilities with the value of . That is, the backprojection of  is
a rule-based function with one rule for each one of the mutually-exclusive probability rules
i . The context of this new value rule is the same as that of i , and the value is the product
of the probability of i and the value of .
Example 8.12 For example, consider the backprojection of a simple rule,
 = h Painting = done : 100i,
through the CPD in Figure 11(c) for the paint action:
RuleBackprojpaint () =

X

Ppaint (x0 | x)(x0 );

x0

442

fiEfficient Solution Algorithms for Factored MDPs

X

=

Ppaint (Painting0 | x)(Painting0 );

Painting0

= 100

3
Y

i (Painting = done, x) .

i=1

Note that the product of these simple rules is equivalent to the decision tree CPD shown in
Figure 11(a). Hence, this product is equal to 0 in most contexts, for example, when electricity
is not done at time t. The product in non-zero only in one context: in the context associated
with rule 3 . Thus, we can express the result of the backprojection operation by a rule-based
function with a single rule:
RuleBackprojpaint () = hPlumbing  Electrical : 95i.
Similarly, the backprojection of  when the action is not paint can also be represented by a
single rule:
RuleBackprojpaint () = hPlumbing  Electrical  Painting : 90i.
Using this algorithm, we can now write the backprojection of the rule-based basis function hj as:
gja (x) =

X

(hj )

RuleBackproja (i

),

(23)

i

where gja is a sum of rule-based functions, and therefore also a rule-based function. For
simplicity of notation, we use gja = RuleBackproja (hj ) to refer to this definition of backproP
jection. Using this notation, we can write Qa (x) = Ra (x) +  j wj gja (x), which is again a
rule-based function.
8.4 Rule-based Maximization Over the State Space
The second key operation required to extend our planning algorithms to exploit CSI is to
modify the variable elimination algorithm in Section 4.2.1 to handle the rule-based representation. In Section 4.2.1, we showed that the maximization of a linear combination
of table-based functions with restricted scope can be performed efficiently using non-serial
dynamic programming (Bertele & Brioschi, 1972), or variable elimination. To exploit structure in rules, we use an algorithm similar to variable elimination in a Bayesian network with
context-specific independence (Zhang & Poole, 1999).
Intuitively, the algorithm operates by selecting the value rules relevant to the variable
being maximized in the current iteration. Then, a local maximization is performed over
this subset of the rules, generating a new set of rules without the current variable. The
procedure is then repeated recursively until all variables have been eliminated.
More precisely, our algorithm eliminates variables one by one, where the elimination process performs a maximization step over the variables domain. Suppose that we
are eliminating Xi , whose collected value rules lead to a rule function f , and f involves
additional variables in some set B, so that f s scope is B  {Xi }. We need to compute
the maximum value for Xi for each choice of b  Dom[B]. We use MaxOut (f, Xi ) to denote a procedure that takes a rule function f (B, Xi ) and returns a rule function g(B) such
443

fiGuestrin, Koller, Parr & Venkataraman

MaxOut (f, B)
Let g = {}.
Add completing rules to f : hB = bi : 0i, i = 1, . . . , k.
// Summing consistent rules:
While there are two consistent rules 1 = hc1 : v1 i and 2 = hc2 : v2 i:
If c1 = c2 , then replace these two rules by hc1 : v1 + v2 i;
Else replace these two rules by the set: Split(1 6 c2 )  Split(2 6 c1 ).
// Maximizing out variable B:
Repeat until f is empty:
If there are rules hc  B = bi : vi i, bi  Dom(B) :
Then remove these rules from f and add rule hc : maxi vi i to g;
Else select two rules: i = hci  B = bi : vi i and j = hcj  B = bj : vj i
such that ci is consistent with cj , but not identical, and replace
them with Split(i 6 cj )  Split(j 6 ci ) .
Return g.

Figure 13: Maximizing out variable B from rule function f .
that: g(b) = maxxi f (b, xi ). Such a procedure is an extension of the variable elimination
algorithm of Zhang and Poole (Zhang & Poole, 1999).
The rule-based variable elimination algorithm maintains a set F of value rules, initially
containing the set of rules to be maximized. The algorithm then repeats the following steps
for each variable Xi until all variables have been eliminated:
1. Collect all rules which depend on Xi into fi  fi = {hc : vi  F | Xi  C}  and
remove these rules from F.
2. Perform the local maximization step over Xi : gi = MaxOut (fi , Xi );
3. Add the rules in gi to F; now, Xi has been eliminated.
The cost of this algorithm is polynomial in the number of new rules generated in the
maximization operation MaxOut (fi , Xi ). The number of rules is never larger and in many
cases exponentially smaller than the complexity bounds on the table-based maximization in
Section 4.2.1, which, in turn, was exponential only in the induced width of the cost network
graph (Dechter, 1999). However, the computational costs involved in managing sets of rules
usually imply that the computational advantage of the rule-based approach over the tablebased one will only be significant in problems that possess a fair amount of context-specific
structure.
In the remainder of this section, we present the algorithm for computing the local
maximization MaxOut (fi , Xi ). In the next section, we show how these ideas can be applied
to extending the algorithm in Section 4.2.2 to exploit CSI in the LP representation for
planning in factored MDPs.
The procedure, presented in Figure 13, is divided into two parts: first, all consistent
rules are added together as described in Section 8.2; then, variable B is maximized. This
maximization is performed by generating a set of rules, one for each assignment of B, whose
contexts have the same assignment for all variables except for B, as in Definition 8.8. This
set is then substituted by a single rule without a B assignment in its context and with value
equal to the maximum of the values of the rules in the original set. Note that, to simplify
444

fiEfficient Solution Algorithms for Factored MDPs

the algorithm, we initially need to add a set of value rules with 0 value, which guarantee
that our rule function f is complete (i.e., there is at least one rule consistent with every
context).
The correctness of this procedure follows directly from the correctness of the rule-based
variable elimination procedure described by Zhang and Poole, merely by replacing summations with product with max, and products with products with sums. We conclude this
section with a small example to illustrate the algorithm:
Example 8.13 Suppose we are maximizing a for the following set of rules:
1
2
3
4

= ha : 1i,
= ha  b : 2i,
= ha  b  c : 3i,
= ha  b : 1i.

When we add completing rules, we get:
5 = ha : 0i,
6 = ha : 0i.
In the first part of the algorithm, we need to add consistent rules: We add 5 to 1 (which
remains unchanged), combine 1 with 4 , 6 with 2 , and then the split of 6 on the context
of 3 , to get the following inconsistent set of rules:
2
3
7
8
9

= ha  b : 2i,
= ha  b  c : 3i,
= ha  b : 2i,
(from adding 4 to the consistent rule from Split(1 6 b))
= ha  b : 1i,
(from Split(1 6 b))
= ha  b  c : 0i,
(from Split(6 6 a  b  c)).

Note that several rules with value 0 are also generated, but not shown here because they are
added to other rules with consistent contexts. We can move to the second stage (repeat loop)
of MaxOut. We remove 2 , and 8 , and maximize a out of them, to give:
10 = hb : 2i.
We then select rules 3 and 7 and split 7 on c (3 is split on the empty set and is not
changed),
11 = ha  b  c : 2i,
12 = ha  b  c : 2i.
Maximizing out a from rules 12 and 3 , we get:
13 = hb  c : 3i.
We are left with 11 , which maximized over its counterpart 9 gives
12 = hb  c : 2i.
Notice that, throughout this maximization, we have not split on the variable C when b  ci ,
giving us only 6 distinct rules in the final result. This is not possible in a table-based
representation, since our functions would then be over the 3 variables a,b,c, and therefore
must have 8 entries.
445

fiGuestrin, Koller, Parr & Venkataraman

8.5 Rule-based Factored LP
In Section 4.2.2, we showed that the LPs used in our algorithms have exponentially many
P
constraints of the form:   i wi ci (x)  b(x), x, which can be substituted by a single,
P
equivalent, non-linear constraint:   maxx i wi ci (x)  b(x). We then showed that, using
variable elimination, we can represent this non-linear constraint by an equivalent set of
linear constraints in a construction we called the factored LP. The number of constraints in
the factored LP is linear in the size of the largest table generated in the variable elimination
procedure. This table-based algorithm can only exploit additive independence. We now
extend the algorithm in Section 4.2.2 to exploit both additive and context-specific structure,
by using the rule-based variable elimination described in the previous section.
Suppose we wish to enforce the more general constraint 0  maxy F w (y), where F w (y) =
P w
j fj (y) such that each fj is a rule. As in the table-based version, the superscript w means
that fj might depend on w. Specifically, if fj comes from basis function hi , it is multiplied
by the weight wi ; if fj is a rule from the reward function, it is not.
In our rule-based factored linear program, we generate LP variables associated with
contexts; we call these LP rules. An LP rule has the form hc : ui; it is associated with a
context c and a variable u in the linear program. We begin by transforming all our original
rules fjw into LP rules as follows: If rule fj has the form hcj : vj i and comes from basis
function hi , we introduce an LP rule ej = hcj : uj i and the equality constraint uj = wi vj .
If fj has the same form but comes from a reward function, we introduce an LP rule of the
same form, but the equality constraint becomes uj = vj .
P
Now, we have only LP rules and need to represent the constraint: 0  maxy j ej (y).
To represent such a constraint, we follow an algorithm very similar to the variable elimination procedure in Section 8.4. The main difference occurs in the MaxOut (f, B) operation in
Figure 13. Instead of generating new value rules, we generate new LP rules, with associated
new variables and new constraints. The simplest case occurs when computing a split or
adding two LP rules. For example, when we add two value rules in the original algorithm,
we instead perform the following operation on their associated LP rules: If the LP rules
are hc : ui i and hc : uj i, we replace these by a new rule hc : uk i, associated with a new LP
variable uk with context c, whose value should be ui + uj . To enforce this value constraint,
we simply add an additional constraint to the LP: uk = ui + uj . A similar procedure can
be followed when computing the split.
More interesting constraints are generated when we perform a maximization. In the
rule-based variable elimination algorithm in Figure 13, this maximization occurs when we
replace a set of rules:
hc  B = bi : vi i, bi  Dom(B),
by a new rule





c : max vi .
i

Following the same process as in the LP rule summation above, if we are maximizing
ei = hc  B = bi : ui i, bi  Dom(B),
we generate a new LP variable uk associated with the rule ek = hc : uk i. However, we
cannot add the nonlinear constraint uk = maxi ui , but we can add a set of equivalent linear
446

fiEfficient Solution Algorithms for Factored MDPs

constraints
uk  ui , i.
Therefore, using these simple operations, we can exploit structure in the rule functions
P
to represent the nonlinear constraint en  maxy j ej (y), where en is the very last LP
rule we generate. A final constraint un =  implies that we are representing exactly the
constraints in Equation (12), without having to enumerate every state.
The correctness of our rule-based factored LP construction is a corollary of Theorem 4.4
and of the correctness of the rule-based variable elimination algorithm (Zhang & Poole,
1999) .
Corollary 8.14 The constraints generated by the rule-based factored LP construction are
equivalent to the non-linear constraint in Equation (12). That is, an assignment to (, w)
satisfies the rule-based factored LP constraints if and only if it satisfies the constraint in
Equation (12).
The number of variables and constraints in the rule-based factored LP is linear in the
number of rules generated by the variable elimination process. In turn, the number of rules
is no larger, and often exponentially smaller, than the number of entries in the table-based
approach.
To illustrate the generation of LP constraints as just described, we now present a small
example:
Example 8.15 Let e1 , e2 , e3 , and e4 be the set of LP rules which depend on the variable
b being maximized. Here, rule ei is associated with the LP variable ui :
e1
e2
e3
e4

= ha  b : u1 i,
= ha  b  c : u2 i,
= ha  b : u3 i,
= ha  b  c : u4 i.

In this set, note that rules e1 and e2 are consistent. We combine them to generate the
following rules:
e5 = ha  b  c : u5 i,
e6 = ha  b  c : u1 i.
and the constraint u1 + u2 = u5 . Similarly, e6 and e4 may be combined, resulting in:
e7 = ha  b  c : u6 i.
with the constraint u6 = u1 + u4 . Now, we have the following three inconsistent rules for
the maximization:
e3 = ha  b : u3 i,
e5 = ha  b  c : u5 i,
e7 = ha  b  c : u6 i.
Following the maximization procedure, since no pair of rules can be eliminated right away,
we split e3 and e5 to generate the following rules:
e8 = ha  b  c : u3 i,
e9 = ha  b  c : u3 i,
e5 = ha  b  c : u5 i.
447

fiGuestrin, Koller, Parr & Venkataraman

We can now maximize b out from e8 and e5 , resulting in the following rule and constraints
respectively:
e10 = ha  c : u7 i,
u7  u5 ,
u7  u3 .
Likewise, maximizing b out from e9 and e6 , we get:
e11 = ha  c : u8 i,
u8  u3 ,
u8  u6 ;
which completes the elimination of variable b in our rule-based factored LP.
We have presented an algorithm for exploiting both additive and context-specific structure in the LP construction steps of our planning algorithms. This rule-based factored LP
approach can now be applied directly in our approximate linear programming and approximate policy iteration algorithms, which were presented in Sections 5 and 6.
The only additional modification required concerns the manipulation of the decision
list policies presented in Section 6.2. Although approximate linear programming does not
require any explicit policy representation (or the default action model), approximate policy iteration require us to represent such policy. Fortunately, no major modifications are
required in the rule-based case. In particular, the conditionals hti , ai , i i in the decision
list policies are already context-specific rules. Thus, the policy representation algorithm in
Section 6.2 can be applied directly with our new rule-based representation. Therefore, we
now have a complete framework for exploiting both additive and context-specific structure
for efficient planning in factored MDPs.

9. Experimental Results
The factored representation of a value function is most appropriate in certain types of
systems: Systems that involve many variables, but where the strong interactions between
the variables are fairly sparse, so that the decoupling of the influence between variables
does not induce an unacceptable loss in accuracy. As argued by Herbert Simon (1981)
in Architecture of Complexity, many complex systems have a nearly decomposable,
hierarchical structure, with the subsystems interacting only weakly between themselves. To
evaluate our algorithm, we selected problems that we believe exhibit this type of structure.
In this section, we perform various experiments intended to explore the performance
of our algorithms. First, we compare our factored approximate linear programming (LP)
and approximate policy iteration (PI) algorithms. We also compare to the L2 -projection
algorithm of Koller and Parr (2000). Our second evaluation compares a table-based implementation to a rule-based implementation that can exploit CSI. Finally, we present
comparisons between our approach and the algorithms of Boutilier et al. (2000).
9.1 Approximate LP and Approximate PI
In order to compare our approximate LP and approximate PI algorithms, we tested both on
the SysAdmin problem described in detail in Section 2.1. This problem relates to a system
448

fiEfficient Solution Algorithms for Factored MDPs

administrator who has to maintain a network of computers; we experimented with various
network architectures, shown in Figure 1. Machines fail randomly, and a faulty machine
increases the probability that its neighboring machines will fail. At every time step, the
SysAdmin can go to one machine and reboot it, causing it to be working in the next time
step with high probability. Recall that the state space in this problem grows exponentially
in the number of machines in the network, that is, a problem with m machines has 2m states.
Each machine receives a reward of 1 when working (except in the ring, where one machine
receives a reward of 2, to introduce some asymmetry), a zero reward is given to faulty
machines, and the discount factor is  = 0.95. The optimal strategy for rebooting machines
will depend upon the topology, the discount factor, and the status of the machines in the
network. If machine i and machine j are both faulty, the benefit of rebooting i must be
weighed against the expected discounted impact of delaying rebooting j on js successors.
For topologies such as rings, this policy may be a function of the status of every single
machine in the network.
The basis functions used included independent indicators for each machine, with value
1 if it is working and zero otherwise (i.e., each one is a restricted scope function of a single
variable), and the constant basis, whose value is 1 for all states. We selected straightforward
variable elimination orders: for the Star and Three Legs topologies, we first eliminated
the variables corresponding to computers in the legs, and the center computer (server) was
eliminated last; for Ring, we started with an arbitrary computer and followed the ring
order; for Ring and Star, the ring machines were eliminated first and then the center one;
finally, for the Ring of Rings topology, we eliminated the computers in the outer rings
first and then the ones in the inner ring.
We implemented the factored policy iteration and linear programming algorithms in
Matlab, using CPLEX as the LP solver. Experiments were performed on a Sun UltraSPARCII, 359 MHz with 256MB of RAM. To evaluate the complexity of the approximate policy
iteration with max-norm projection algorithm, tests were performed with increasing the
number of states, that is, increasing number of machines on the network. Figure 14 shows
the running time for increasing problem sizes, for various architectures. The simplest one
is the Star, where the backprojection of each basis function has scope restricted to two
variables and the largest factor in the cost network has scope restricted to two variables.
The most difficult one was the Bidirectional Ring, where factors contain five variables.
Note that the number of states is growing exponentially (indicated by the log scale in
Figure 14), but running times increase only logarithmically in the number of states, or
polynomially in the number of variables. We illustrate this behavior in Figure 14(d), where
we fit a 3rd order polynomial to the running times for the unidirectional ring. Note that
the size of the problem description grows quadratically with the number of variables: adding
a machine to the network also adds the possible action of fixing that machine. For this
problem,
the computation
cost of our factored algorithm empirically grows approximately


as O (n  |A|)1.5 , for a problem with n variables, as opposed to the exponential complexity
 poly (2n , |A|)  of the explicit algorithm.
For further evaluation, we measured the error in our approximate value function relative
to the true optimal value function V  . Note that it is only possible to compute V  for small
problems; in our case, we were only able to go up to 10 machines. For comparison, we
also evaluated the error in the approximate value function produced by the L2 -projection
449

fiGuestrin, Koller, Parr & Venkataraman

500

400

Ring
3 Legs

300

Ring of Rings

300
Total Time (minutes)

Total Time (minutes)

400

Star

200

Ring and Star
200

100

100

0

0
1E+00

1E+02

1E+04

1E+06 1E+08 1E+10
number of states

1E+12

1

1E+14

100

10000
1000000
number of states

(a)
1200

500

1000

Fitting a polynomial:

800

time = 0.0184|X| - 0.6655|X| +
9.2499|X| - 31.922

3

Ring:

Total Time (minutes)

Total Time (minutes)

1E+10

(b)

600

400

100000000

Unidirectional
Bidirectional

300
200

2

2

Quality of the fit: R = 0.999
600

400

100

200
0
1E+00

1E+02

1E+04

1E+06

1E+08

1E+10

1E+12

1E+14

0
0

number of state s

(c)

10

20
30
40
number of variables |X|

50

60

(d)

Figure 14: (a)(c) Running times for policy iteration with max-norm projection on variants
of the SysAdmin problem; (d) Fitting a polynomial to the running time for the
Ring topology.

algorithm of Koller and Parr (2000). As we discussed in Section 6.4, the L2 projections in
factored MDPs by Koller and Parr are difficult and time consuming; hence, we were only
able to compare the two algorithms for smaller problems, where an equivalent L2 -projection
can be implemented using an explicit state space formulation. Results for both algorithms
are presented in Figure 15(a), showing the relative error of the approximate solutions to
the true value function for increasing problem sizes. The results indicate that, for larger
problems, the max-norm formulation generates a better approximation of the true optimal
value function V  than the L2 -projection. Here, we used two types of basis functions: the
same single variable functions, and pairwise basis functions. The pairwise basis functions
contain indicators for neighboring pairs of machines (i.e., functions of two variables). As
expected, the use of pairwise basis functions resulted in better approximations.
450

fiEfficient Solution Algorithms for Factored MDPs

0.4

Max norm, single basis
L2, single basis

0.3

Bellman Error / Rmax

Max norm, pair basis
L2, pair basis

Relative error:

0.2

0.1

0
3

4

5

6

7

8

9

10

number of variables

0.3

0.2

Ring
3 Legs

0.1

0
1E+00

Star

1E+02

1E+04

1E+06

1E+08

1E+10

1E+12

1E+14

numbe r of sta tes

(a)

(b)

Figure 15: (a) Relative error to optimal value function V  and comparison to L2 projection
for Ring; (b) For large models, measuring Bellman error after convergence.

For these small problems, we can also compare the actual value of the policy generated
by our algorithm to the value of the optimal policy. Here, the value of the policy generated
by our algorithm is much closer to the value of the optimal policy than the error implied by
the difference between our approximate value function and V  . For example, for the Star
architecture with one server and up to 6 clients, our approximation with single variable
basis functions had relative error of 12%, but the policy we generated had the same value
as the optimal policy. In this case, the same was true for the policy generated by the L2
projection. In a Unidirectional Ring with 8 machines and pairwise basis, the relative
error between our approximation and V  was about 10%, but the resulting policy only had
a 6% loss over the optimal policy. For the same problem, the L2 approximation has a value
function error of 12%, and a true policy loss was 9%. In other words, both methods induce
policies that have lower errors than the errors in the approximate value function (at least
for small problems). However, our algorithm continues to outperform the L2 algorithm,
even with respect to actual policy loss.
For large models, we can no longer compute the correct value function, so we cannot
evaluate our results by computing kV   Hwk . Fortunately, as discussed in Section 7,
the Bellman error can be used to provide a bound on the approximation error and can be
computed efficiently by exploiting problem-specific structure. Figure 15(b) shows that the
Bellman error increases very slowly with the number of states.
It is also valuable to look at the actual decision-list policies generated in our experiments.
First, we noted that the lists tended to be short, the length of the final decision list policy
grew approximately linearly with the number of machines. Furthermore, the policy itself
is often fairly intuitive. In the Ring and Star architecture, for example, the decision list
says: If the server is faulty, fix the server; else, if another machine is faulty, fix it.
Thus far, we have presented scaling results for running times and approximation error for
our approximate PI approach. We now compare this algorithm to the simpler approximate
451

fiGuestrin, Koller, Parr & Venkataraman

400

200

PI single basis
PI single basis

160

LP single basis

140

LP pair basis

120

LP triple basis

Discounted reward of final policy
(averaged over 50 trials of 100 steps)

Total running time (minutes)

180

100
80
60
40
20
0
0

5

10

15

20

25

30

35

numbe r of machine s

LP single basis
LP pair basis

300

LP triple basis

200

100

0
0

10

20

30

40

numbe r of machine s

(a)

(b)

Figure 16: Approximate LP versus approximate PI on the SysAdmin problem with a Ring
topology: (a) running time; (b) estimated value of policy.

LP approach of Section 5. As shown in Figure 16(a), the approximate LP algorithm for
factored MDPs is significantly faster than the approximate PI algorithm. In fact, approximate PI with single-variable basis functions variables is more costly computationally than
the LP approach using basis functions over consecutive triples of variables. As shown in
Figure 16(b), for singleton basis functions, the approximate PI policy obtains slightly better
performance for some problem sizes. However, as we increase the number of basis functions
for the approximate LP formulation, the value of the resulting policy is much better. Thus,
in this problem, our factored approximate linear programming formulation allows us to use
more basis functions and to obtain a resulting policy of higher value, while still maintaining
a faster running time. These results, along with the simpler implementation, suggest that
in practice one may first try to apply the approximate linear programming algorithm before
deciding to move to the more elaborate approximate policy iteration approach.
9.2 Comparing Table-based and Rule-based Implementations
Our next evaluation compares a table-based representation, which exploits only additive
independence, to the rule-based representation presented in Section 8, which can exploit
both additive and context-specific independence. For these experiments, we implemented
our factored approximate linear programming algorithm with table-based and rule-based
representations in C++, using CPLEX as the LP solver. Experiments were performed on
a Sun UltraSPARC-II, 400 MHz with 1GB of RAM.
To evaluate and compare the algorithms, we utilized a more complex extension of the
SysAdmin problem. This problem, dubbed the Process-SysAdmin problem, contains three
state variables for each machine i in the network: Loadi , Statusi and Selectori . Each computer runs processes and receives rewards when the processes terminate. These processes
are represented by the Loadi variable, which takes values in {Idle, Loaded, Success}, and the
computer receives a reward when the assignment of Loadi is Success. The Statusi variable,
452

fitotal running time (minutes)

Efficient Solution Algorithms for Factored MDPs

200
Table-based, single+ basis
Rule-based, single+ basis

150

Table-based, pair basis
100

Rule-based, pair basis

50
0
1E+00

1E+07

1E+14

1E+21

1E+28

1E+35

1E+42

number of states

total running time (minutes)

(a)
250
200

Table-based, single+ basis
Rule-based, single+ basis

150

Table-based, pair basis
100
Rule-based, pair basis
50
0
1E+00 1E+04 1E+08 1E+12 1E+16 1E+20 1E+24 1E+28
number of states

(b)

total running time (minutes)

600
2
(x-1)

(x-1)

y = 7E- 17 x * 18 + 2E- 06 x * 18
+ 0.1124
2
R = 0.995

500

Table-based, single+ basis
Rule-based, single+ basis

400
300

3

2

y = 0.2294x - 4.5415x +
30.974x - 67.851
R 2= 0.9995

200
100
0
0

5

10
number of machines

15

20

(c)
Figure 17: Running time for Process-SysAdmin problem for various topologies: (a) Star;
(b) Ring; (c) Reverse star (with fit function).

453

fiGuestrin, Koller, Parr & Venkataraman

CPLEX time / Total time

1
0.8
Table-based, single+ basis
0.6
Rule-based, single+ basis
0.4
0.2
0
0

5

10

15

20

number of machines

Figure 18: Fraction of total running time spent in CPLEX for the Process-SysAdmin problem with a Ring topology.

representing the status of machine i, takes values in {Good, Faulty, Dead}; if its value is
Faulty, then processes have a smaller probability of terminating and if its value is Dead,
then any running process is lost and Loadi becomes Idle. The status of machine i can become Faulty and eventually Dead at random; however, if machine i receives a packet from
a dead machine, then the probability that Statusi becomes Faulty and then Dead increases.
The Selectori variable represents this communication by selecting one of the neighbors of i
uniformly at random at every time step. The SysAdmin can select at most one computer
to reboot at every time step. If computer i is rebooted, then its status becomes Good
with probability 1, but any running process is lost, i.e., the Loadi variable becomes Idle.
Thus, in this problem, the SysAdmin must balance several conflicting goals: rebooting a
machine kills processes, but not rebooting a machine may cause cascading faults in network.
Furthermore, the SysAdmin can only choose one machine to reboot, which imposes the additional tradeoff of selecting only one of the (potentially many) faulty or dead machines in
the network to reboot.
We experimented with two types of basis functions: single+ includes indicators over
all of the joint assignments of Loadi , Statusi and Selectori , and pair which, in addition,
includes a set of indicators over Statusi , Statusj , and Selectori = j, for each neighbor j
of machine i in the network. The discount factor was  = 0.95. The variable elimination
order eliminated all of the Loadi variables first, and then followed the same patterns as in
the simple SysAdmin problem, eliminating first Statusi and then Selectori when machine i
is eliminated.
Figure 17 compares the running times for the table-based implementation to the ones
for the rule-based representation for three topologies: Star, Ring, and Reverse star.
The Reverse star topology reverses the direction of the influences in the Star: rather
than the central machine influencing all machines in the topology, all machines influence
the central one. These three topologies demonstrate three different levels of CSI: In the
454

fiEfficient Solution Algorithms for Factored MDPs

Star topology, the factors generated by variable elimination are small. Thus, although the
running times are polynomial in the number of state variables for both methods, the tablebased representation is significantly faster than the rule-based one, due to the overhead of
managing the rules. The Ring topology illustrates an intermediate behavior: single+
basis functions induce relatively small variable elimination factors, thus the table-based
approach is faster. However, with pair basis the factors are larger and the rule-based
approach starts to demonstrate faster running times in larger problems. Finally, the Reverse star topology represents the worst-case scenario for the table-based approach. Here,
the scope of the backprojection of a basis function for the central machine will involve all
computers in the network, as all machines can potentially influence the central one in the
next time step. Thus, the size of the factors in the table-based variable elimination approach are exponential in the number of machines in the network, which is illustrated by
the exponential growth in Figure 17(c). The rule-based approach can exploit the CSI in this
problem; for example, the status of the central machine Status0 only depends on machine
j if the value selector is j, i.e., if Selector0 = j. By exploiting CSI, we can solve the same
problem in polynomial time in the number of state variables, as seen in the second curve in
Figure 17(c).
It is also instructive to compare the portion of the total running time spent in CPLEX
for the table-based as compared to the rule-based approach. Figure 18 illustrates this
comparison. Note that amount of time spent in CPLEX is significantly higher for the
table-based approach. There are two reasons for this difference: first, due to CSI, the LPs
generated by the rule-based approach are smaller than the table-based ones; second, rulebased variable elimination is more complex than the table-based one, due to the overhead
introduced by rule management. Interestingly, the proportion of CPLEX time increases as
the problem size increases, indicating that the asymptotic complexity of the LP solution is
higher than that of variable elimination, thus suggesting that, for larger problems, additional
large-scale LP optimization procedures, such as constraint generation, may be helpful.
9.3 Comparison to Apricodd
The most closely related work to ours is a line of research that began with the work of
Boutilier et al. (1995). In particular, the approximate Apricodd algorithm of Hoey et
al. (1999), which uses analytic decision diagrams (ADDs) to represent the value function
is a strong alternative approach for solving factored MDPs. As discussed in detail in Section 10, the Apricodd algorithm can successfully exploit context-specific structure in the
value function, by representing it with the set of mutually-exclusive and exhaustive branches
of the ADD. On the other hand, our approach can exploit both additive and context-specific
structure in the problem, by using a linear combination of non-mutually-exclusive rules. To
better understand this difference, we evaluated both our rule-based approximate linear
programming algorithm and Apricodd in two problems, Linear and Expon, designed by
Boutilier et al. (2000) to illustrate respectively the best-case and the worst-case behavior
of their algorithm. In these experiments, we used the web-distributed version of Apricodd (Hoey, St-Aubin, Hu, & Boutilier, 2002), running it locally on a Linux Pentium III
700MHz with 1GB of RAM.
455

fiGuestrin, Koller, Parr & Venkataraman

500

Rule-based

40
30

3

2

y = 0.1473x - 0.8595x + 2.5006x - 1.5964
2

R = 0.9997

20

Apricodd
2

y = 0.0254x + 0.0363x
+ 0.0725

10

Apricodd

400
Time (in seconds)

Time (in seconds)

50

x

2

x

y = 3E-05 * 2 - 0.0026 * 2 + 5.6737
R2 = 0.9999

300
200

Rule-based
y = 5.275x3 - 29.95x2 +
53.915x - 28.83
R2 = 1

100

2

R = 0.9983

0

0

6

8

10
12
14
16
Number of variables

18

6

20

8

10

12

Number of variables

(a)

(b)

Figure 19: Comparing Apricodd to rule-based approximate linear programming on the (a)
Linear and (b) Expon problems.

These two problems involve n binary variables X1 , . . . , Xn and n deterministic actions
a1 , . . . , an . The reward is 1 when all variables Xk are true, and is 0 otherwise. The problem
is discounted by a factor  = 0.99. The difference between the Linear and the Expon
problems is in the transition probabilities. In the Linear problem, the action ak sets the
variable Xk to true and makes all succeeding variables, Xi for i > k, false. If the state space
of the Linear problem is seen as a binary number, the optimal policy is to set repeatedly the
largest bit (Xk variable) which has all preceding bits set to true. Using an ADD, the optimal
value function for this problem can be represented in linear space, with n+1 leaves (Boutilier
et al., 2000). This is the best-case for Apricodd, and the algorithm can compute this value
function quite efficiently. Figure 19(a) compares the running time of Apricodd to that of
one of our algorithms with indicator basis functions between pairs of consecutive variables.
Note that both algorithms obtain the same policy in polynomial time in the number of
variables. However, in such structured problems, the efficient implementation of the ADD
package used in Apricodd makes it faster in this problem.
On the other hand, the Expon problem illustrates the worst-case for Apricodd. In this
problem, the action ak sets the variable Xk to true, if all preceding variables, Xi for i < k, are
true, and it makes all preceding variables false. If the state space is seen as a binary number,
the optimal policy goes through all binary numbers in sequence, by repeatedly setting the
largest bit (Xk variable) which has all preceding bits set to true. Due to discounting, the
n
optimal value function assigns a value of  2 j1 to the jth binary number, so that the
value function contains exponentially many different values. Using an ADD, the optimal
value function for this problem requires an exponential number of leaves (Boutilier et al.,
2000), which is illustrated by the exponential running time in Figure 19(b). However,
the same value function can be approximated very compactly as a factored linear value
function using n + 1 basis functions: an indicator over each variable Xk and the constant
base. As shown in Figure 19(b), using this representation, our factored approximate linear
programming algorithm computes the value function in polynomial time. Furthermore, the
456

fiEfficient Solution Algorithms for Factored MDPs

30

60

Running time (minutes)

Discounted value of policy
(avg. 50 runs of 100 steps)

Rule-based LP

50

Apricodd
40
30
20
10
0

Rule-based LP

25

Apricodd
20
15
10
5
0

0

2

4
6
8
Number of machines

10

12

0

2

4
6
8
Number of machines

(a)

12

10

12

(b)

50

30

45

Rule-based LP

Rule-based LP

40

Discounted value of policy
(avg. 50 runs of 100 steps)

Running time (minutes)

10

Apricodd

35
30
25
20
15
10

25

Apricodd

20
15
10
5

5
0

0
0

2

4
6
8
Number of machines

10

12

(c)

0

2

4
6
8
Number of machines

(d)

Figure 20: Comparing Apricodd to rule-based approximate linear programming with single+ basis functions on the Process-SysAdmin problem with Ring topology
(a) running time and (b) value of the resulting policy; and with Star topology
(c) running time and (d) value of the resulting policy.

policy obtained by our approach was optimal for this problem. Thus, in this problem, the
ability to exploit additive independence allows an efficient polynomial time solution.
We have also compared Apricodd to our rule-based approximate linear programming
algorithm on the Process-SysAdmin problem. This problem has significant additive structure in the reward function and factorization in the transition model. Although this type of
structure is not exploited directly by Apricodd, the ADD approximation steps performed by
the algorithm can, in principle, allow Apricodd to find approximate solutions to the problem. We spent a significant amount of time attempting to find the best set of parameters
for Apricodd for these problems.4 We settled on the sift method of variable reordering
and the round approximation method with the size (maximum ADD size) criteria. To
4. We are very grateful to Jesse Hoey and Robert St-Aubin for their assistance in selecting the parameters.

457

fiGuestrin, Koller, Parr & Venkataraman

allow the value function representation to scale with the problem size, we set the maximum
ADD size to 4000 + 400n for a network with n machines. (We experimented with a variety
of different growth rates for the maximum ADD size; here, as for the other parameters,
we selected the choice that gave the best results for Apricodd.) We compared Apricodd
with these parameters to our rule-based approximate linear programming algorithm with
single+ basis functions on a Pentium III 700MHz with 1GB of RAM. These results are
summarized in Figure 20.
On very small problems (up to 45 machines), the performance of the two algorithms is
fairly similar in terms of both the running time and the quality of the policies generated.
However, as the problem size grows, the running time of Apricodd increases rapidly, and
becomes significantly higher than that of our algorithm . Furthermore, as the problem size
increases, the quality of the policies generated by Apricodd also deteriorates. This difference
in policy quality is caused by the different value function representation used by the two
algorithms. The ADDs used in Apricodd represent k different values with k leaves; thus,
they are forced to agglomerate many different states and represent them using a single value.
For smaller problems, such agglomeration can still represent good policies. Unfortunately,
as the problem size increases and the state space grows exponentially, Apricodds policy
representation becomes inadequate, and the quality of the policies decreases. On the other
hand, our linear value functions can represent exponentially many values with only k basis
functions, which allows our approach to scale up to significantly larger problems.

10. Related Work
The most closely related work to ours is a line of research that began with the work of
Boutilier et al. (1995). We address this comparison separately below, but we begin this
section with some broader background references.
10.1 Approximate MDP Solutions
The field of MDPs, as it is popularly known, was formalized by Bellman (1957) in the
1950s. The importance of value function approximation was recognized at an early stage
by Bellman himself (1963). In the early 1990s the MDP framework was recognized by AI
researchers as a formal framework that could be used to address the problem of planning
under uncertainty (Dean, Kaelbling, Kirman, & Nicholson, 1993).
Within the AI community, value function approximation developed concomitantly with
the notion of value function representations for Markov chains. Suttons seminal paper on
temporal difference learning (1988), which addressed the use of value functions for prediction
but not planning, assumed a very general representation of the value function and noted
the connection to general function approximators such as neural networks. However, the
stability of this combination was not directly addressed at that time.
Several important developments gave the AI community deeper insight into the relationship between function approximation and dynamic programming. Tsitsiklis and Van
Roy (1996a) and, independently, Gordon (1995) popularized the analysis of approximate
MDP methods via the contraction properties of the dynamic programming operator and
function approximator. Tsitsiklis and Van Roy (1996b) later established a general convergence result for linear value function approximators and T D(), and Bertsekas and
458

fiEfficient Solution Algorithms for Factored MDPs

Tsitsiklis (1996) unified a large body of work on approximate dynamic programming under
the name of Neuro-dynamic Programming, also providing many novel and general error
analyses.
Approximate linear programming for MDPs using linear value function approximation
was introduced by Schweitzer and Seidmann (1985), although the approach was somewhat
deprecated until fairly recently due the lack of compelling error analyses and the lack of an
effective method for handling the large number of constraints. Recent work by de Farias
and Van Roy (2001a, 2001b) has started to address these concerns with new error bounds
and constraint sampling methods. Our approach, rather than sampling constraints, utilizes
structure in the model and value function to represent all of the constraints compactly.
10.2 Factored Approaches
Tatman and Shachter (1990) considered the additive decomposition of value nodes in influence diagrams. A number of approaches to factoring of general MDPs have been explored in
the literature. Techniques for exploiting reward functions that decompose additively were
studied by Meuleau et al. (1998), and by Singh and Cohn (1998).
The use of factored representations such as dynamic Bayesian networks was pioneered
by Boutilier et al. (1995) and has developed steadily in recent years. These methods rely
on the use of context-specific structures such as decision trees or analytic decision diagrams
(ADDs) (Hoey et al., 1999) to represent both the transition dynamics of the DBN and
the value function. The algorithms use dynamic programming to partition the state space,
representing the partition using a tree-like structure that branches on state variables and
assigns values at the leaves. The tree is grown dynamically as part of the dynamic programming process and the algorithm creates new leaves as needed: A leaf is split by the
application of a DP operator when two states associated with that leaf turn out to have
different values in the backprojected value function. This process can also be interpreted
as a form of model minimization (Dean & Givan, 1997).
The number of leaves in a tree used to represent a value function determines the computational complexity of the algorithm. It also limits the number of distinct values that can
be assigned to states: since the leaves represent a partitioning of the state space, every state
maps to exactly one leaf. However, as was recognized early on, there are trivial MDPs which
require exponentially large value functions. This observation led to a line of approximation
algorithms aimed at limiting the tree size (Boutilier & Dearden, 1996) and, later, limiting
the ADD size (St-Aubin, Hoey, & Boutilier, 2001). Kim and Dean (2001) also explored
techniques for discovering tree-structured value functions for factored MDPs. While these
methods permit good approximate solutions to some large MDPs, their complexity is still
determined by the number of leaves in the representation and the number of distinct values
than can be assigned to states is still limited as well.
Tadepalli and Ok (1996) were the first to apply linear value function approximation
to Factored MDPs. Linear value function approximation is a potentially more expressive
approximation method because it can assign unique values to every state in an MDP without
requiring storage space that is exponential in the number of state variables. The expressive
power of a tree with k leaves can be captured by a linear function approximator with k basis
functions such that basis function hi is an indicator function that tests if a state belongs
459

fiGuestrin, Koller, Parr & Venkataraman

in the partition of leaf i. Thus, the set of value functions that can be represented by a
tree with k leaves is a subset of the set of value functions that can be represented by a
value function with k basis functions. Our experimental results in Section 9.3 highlight this
difference by showing an example problem that requires exponentially many leaves in the
value function, but that can be approximated well using a linear value function.
The main advantage of tree-based value functions is that their structure is determined
dynamically during the solution of the MDP. In principle, as the value function representation is derived automatically from the model description, this approach requires less insight
from the user. In problems for which the value function can be well approximated by a relatively small number of values, this approach provides an excellent solution to the problem.
Our method of linear value function approximation aims to address what we believe to be
the more common case, where a large range of distinct values is required to achieve a good
approximation.
Finally, we note that Schuurmans and Patrascu (2001), based on our earlier work on
max-norm projection using cost networks and linear programs, independently developed
an alternative approach to approximate linear programming using a cost network. Our
method embeds a cost network inside a single linear program. By contrast, their method
is based on a constraint generation approach, using a cost network to detect constraint
violations. When constraint violations are found, a new constraint is added, repeatedly
generating and attempting to solve LPs until a feasible solution is found. Interestingly,
as the approach of Schuurmans and Patrascu uses multiple calls to variable elimination in
order to speed up the LP solution step, it will be most successful when the time spent
solving the LP is significantly larger than the time required for variable elimination. As
suggested in Section 9.2, the LP solution time is larger for the table-based approach. Thus,
Schuurmans and Patrascus constraint generation method will probably be more successful
in table-based problems than in rule-based ones.

11. Conclusions
In this paper, we presented new algorithms for approximate linear programming and approximate dynamic programming (value and policy iteration) for factored MDPs. Both
of these algorithms leverage on a novel LP decomposition technique, analogous to variable elimination in cost networks, which reduces an exponentially large LP to a provably
equivalent, polynomial-sized one.
Our approximate dynamic programming algorithms are motivated by error analyses
showing the importance of minimizing L error. These algorithms are more efficient and
substantially easier to implement than previous algorithms based on the L2 -projection. Our
experimental results suggest that they also perform better in practice.
Our approximate linear programming algorithm for factored MDPs is simpler, easier to
implement and more general than the dynamic programming approaches. Unlike our policy
iteration algorithm, it does not rely on the default action assumption, which states that
actions only affect a small number of state variables. Although this algorithm does not have
the same theoretical guarantees as max-norm projection approaches, empirically it seems to
be a favorable option. Our experiments suggest that approximate policy iteration tends to
generate better policies for the same set of basis functions. However, due to the computa460

fiEfficient Solution Algorithms for Factored MDPs

tional advantages, we can add more basis functions to the approximate linear programming
algorithm, obtaining a better policy and still maintaining a much faster running time than
approximate policy iteration.
Unlike previous approaches, our algorithms can exploit both additive and contextspecific structure in the factored MDP model. Typical real-world systems possess both
of these types of structure. thus, this feature of our algorithms will increase the applicability of factored MDPs to more practical problems. We demonstrated that exploiting
context-specific independence, by using a rule-based representation instead of the standard
table-based one, can yield exponential improvements in computational time when the problem has significant amounts of CSI. However, the overhead of managing sets of rules make
it less well-suited for simpler problems. We also compared our approach to the work of
Boutilier et al. (2000), which exploits only context-specific structure. For problems with
significant context-specific structure in the value function, their approach can be faster due
to their efficient handling of the ADD representation. However, there are problems with
significant context-specific structure in the problem representation, rather than in the value
function, which require exponentially large ADDs. In some such problems, we demonstrated that by using a linear value function our algorithm can obtain a polynomial-time
near-optimal approximation of the true value function.
The success of our algorithm depends on our ability to capture the most important
structure in the value function using a linear, factored approximation. This ability, in turn,
depends on the choice of the basis functions and on the properties of the domain. The
algorithms currently require the designer to specify the factored basis functions. This is a
limitation compared to the algorithms of Boutilier et al. (2000), which are fully automated.
However, our experiments suggest that a few simple rules can be quite successful for designing a basis. First, we ensure that the reward function is representable by our basis. A
simple basis that, in addition, contained a separate set of indicators for each variable often
did quite well. We can also add indicators over pairs of variables; most simply, we can choose
these according to the DBN transition model, where an indicator is added between variables
Xi and each one of the variables in Parents(Xi ), thus representing one-step influences. This
procedure can be extended, adding more basis functions to represent more influences as
required. Thus, the structure of the DBN gives us indications of how to choose the basis
functions. Other sources of prior knowledge can also be included for further specifying the
basis.
Nonetheless, a general algorithm for choosing good factored basis functions still does
not exist. However, there are some potential approaches: First, in problems with CSI, one
could apply the algorithms of Boutilier et al. for a few iterations to generate partial treestructured solutions. Indicators defined over the variables in backprojection of the leaves
could, in turn, be used to generate a basis set for such problems. Second, the Bellman
error computation, which can be performed efficiently as shown in Section 7, does not only
provide a bound on the quality of the policy, but also the actual state where the error is
largest. This knowledge can be used to create a mechanism to incrementally increase the
basis set, adding new basis functions to tackle states with high Bellman error.
There are many other possible extensions to this work. We have already pursued extensions to collaborative multiagent systems, where multiple agents act simultaneously to
maximize the global reward (Guestrin et al., 2001b), and factored POMDPs, where the
461

fiGuestrin, Koller, Parr & Venkataraman

full state is not observed directly, but indirectly through observation variables (Guestrin,
Koller, & Parr, 2001c). However, there are other settings that remain to be explored. In
particular, we hope to address the problem of learning a factored MDP and planning in a
competitive multiagent system.
Additionally, in this paper we have tackled problems where the induced width of the cost
network is sufficiently low or that possess sufficient context-specific structure to allow for
the exact solution of our factored LPs. Unfortunately, some practical problems may have
prohibitively large induced width. We plan to leverage on ideas from loopy belief propagation algorithms for approximate inference in Bayesian networks (Pearl, 1988; Yedidia,
Freeman, & Weiss, 2001) to address this issue.
We believe that the methods described herein significantly further extend the efficiency,
applicability and general usability of factored models and value functions for the control of
practical dynamic systems.

Acknowledgements
We are very grateful to Craig Boutilier, Dirk Ormoneit and Uri Lerner for many useful
discussions, and to the anonymous reviewers for their detailed and thorough comments. We
also would like to thank Jesse Hoey, Robert St-Aubin, Alan Hu, and Craig Boutilier for
distributing their algorithm and for their very useful assistance in using Apricodd and in
selecting its parameters. This work was supported by the DoD MURI program, administered by the Office of Naval Research under Grant N00014-00-1-0637, by Air Force contract
F30602-00-2-0598 under DARPAs TASK program, and by the Sloan Foundation. The first
author was also supported by a Siebel Scholarship.

Appendix A. Proofs
A.1 Proof of Lemma 3.3
There exists a setting to the weights  the all zero setting  that yields a bounded maxnorm projection error P for any policy (P  Rmax ). Our max-norm projection operator
chooses the set of weights that minimizes the projection error  (t) for each policy  (t) . Thus,
the projection error  (t) must be at least as low as the one given by the zero weights P
(which is bounded). Thus, the error remains bounded for all iterations.
A.2 Proof of Theorem 3.5
First, we need to bound our approximation of V(t) :




V(t)  Hw(t) 












 T(t) Hw(t)  Hw(t) 




+ V(t)  T(t) Hw(t) 








(t)
(t) 
 T(t) Hw  Hw  +  V(t)  Hw(t) 






; (triangle inequality;)

; (T(t) is a contraction.)

Moving the second term to the right hand side and dividing through by 1  , we obtain:




V(t)  Hw(t) 






1 
 (t)


.
T(t) Hw(t)  Hw(t)  =

1
1
462

(24)

fiEfficient Solution Algorithms for Factored MDPs

For the next part of the proof, we adapt a lemma of Bertsekas and Tsitsiklis (1996, Lemma
6.2, p.277) to fit into our framework. After some manipulation, this lemma can be reformulated as:
kV   V(t+1) k   kV   V(t) k +


2 


V(t)  Hw(t)  .

1

(25)

The proof is concluded by substituting Equation (24) into Equation (25) and, finally, induction on t.
A.3 Proof of Theorem 4.4
First, note that the equality constraints represent a simple change of variable. Thus, we
can rewrite Equation (12) in terms of these new LP variables ufzii as:
  max

X

x

ufzii ,

(26)

i

where any assignment to the weights w implies an assignment for each ufzii . After this stage,
we only have LP variables.
It remains to show that the factored LP construction is equivalent to the constraint in
Equation (26). For a system with n variables {X1 , . . . , Xn }, we assume, without loss of
generality, that variables are eliminated starting from Xn down to X1 . We now prove the
equivalence by induction on the number of variables.
The base case is n = 0, so that the functions ci (x) and b(x) in Equation (12) all have
empty scope. In this case, Equation (26) can be written as:


X

uei .

(27)

i

In this case, no transformation is done on the constraint, and equivalence is immediate.
Now, we assume the result holds for systems with i1 variables and prove the equivalence
for a system with i variables. In such a system, the maximization can be decomposed into
two terms: one with the factors that do not depend on Xi , which are irrelevant to the
maximization over Xi , and another term with all the factors that depend on Xi . Using this
decomposition, we can write Equation (26) as:
 



max

X ej

x1 ,...,xi

uzj ;

j

max 

x1 ,...,xi1




X

X

uezll + max
xi

l : xi 6zl

e
uzjj  .

(28)

j : xi zj

At this point we can define new LP variables uez corresponding to the second term on
the right hand side of the constraint. These new LP variables must satisfy the following
constraint:
uez  max
xi

X ej
j=1

463

u(z,xi )[Zj ] .

(29)

fiGuestrin, Koller, Parr & Venkataraman

This new non-linear constraint is again represented in the factored LP construction by a
set of equivalent linear constraints:
uez 

X ej
j=1

u(z,xi )[Zj ] , z, xi .

(30)

The equivalence between the non-linear constraint Equation (29) and the set of linear constraints in Equation (30) can be shown by considering binding constraints. For each new
LP variable created uez , there are |Xi | new constraints created, one for each value xi of Xi .
For any assignment to the LP variables in the right hand side of the constraint in EquaP
ej
tion (30), only one of these |Xi | constraints is relevant. That is, one where `j=1 u(z,x
i )[Zj ]
is maximal, which corresponds to the maximum over Xi . Again, if for each value of z more
than one assignment to Xi achieves the maximum, then any of (and only) the constraints
corresponding to those maximizing assignments could be binding. Thus, Equation (29) and
Equation (30) are equivalent.
Substituting the new LP variables uez into Equation (28), we get:


max

x1 ,...,xi1

X

uezll + uez ,

l : xi 6zl

which does not depend on Xi anymore. Thus, it is equivalent to a system with i1 variables,
concluding the induction step and the proof.
A.4 Proof of Lemma 7.1
First note that at iteration t + 1 the objective function (t+1) of the max-norm projection
LP is given by:








(t+1) = Hw(t+1)  R(t+1) + P(t+1) Hw(t+1)  .


However, by convergence the value function estimates are equal for both iterations:
w(t+1) = w(t) .
So we have that:








(t+1) = Hw(t)  R(t+1) + P(t+1) Hw(t)  .


In operator notation, this term is equivalent to:






(t+1) = Hw(t)  T(t+1) Hw(t)  .


Note that,  (t+1) = Greedy(Hw(t) ) by definition. Thus, we have that:
T(t+1) Hw(t) = T  Hw(t) .
Finally, substituting into the previous expression, we obtain the result:






(t+1) = Hw(t)  T  Hw(t)  .


464

fiEfficient Solution Algorithms for Factored MDPs

References
Arnborg, S., Corneil, D. G., & Proskurowski, A. (1987). Complexity of finding embeddings
in a K-tree. SIAM Journal of Algebraic and Discrete Methods, 8 (2), 277  284.
Becker, A., & Geiger, D. (2001). A sufficiently fast algorithm for finding close to optimal
clique trees. Artificial Intelligence, 125 (1-2), 317.
Bellman, R., Kalaba, R., & Kotkin, B. (1963). Polynomial approximation  a new computational technique in dynamic programming. Math. Comp., 17 (8), 155161.
Bellman, R. E. (1957). Dynamic Programming. Princeton University Press, Princeton, New
Jersey.
Bertele, U., & Brioschi, F. (1972). Nonserial Dynamic Programming. Academic Press, New
York.
Bertsekas, D., & Tsitsiklis, J. (1996). Neuro-Dynamic Programming. Athena Scientific,
Belmont, Massachusetts.
Boutilier, C., Dean, T., & Hanks, S. (1999). Decision theoretic planning: Structural assumptions and computational leverage. Journal of Artificial Intelligence Research, 11, 1 
94.
Boutilier, C., & Dearden, R. (1996). Approximating value trees in structured dynamic
programming. In Proc. ICML, pp. 5462.
Boutilier, C., Dearden, R., & Goldszmidt, M. (1995). Exploiting structure in policy construction. In Proc. IJCAI, pp. 11041111.
Boutilier, C., Dearden, R., & Goldszmidt, M. (2000). Stochastic dynamic programming
with factored representations. Artificial Intelligence, 121 (1-2), 49107.
Cheney, E. W. (1982). Approximation Theory (2nd edition). Chelsea Publishing Co., New
York, NY.
de Farias, D., & Van Roy, B. (2001a). The linear programming approach to approximate
dynamic programming. Submitted to Operations Research.
de Farias, D., & Van Roy, B. (2001b). On constraint sampling for the linear programming approach to approximate dynamic programming. To appear in Mathematics of
Operations Research.
Dean, T., Kaelbling, L. P., Kirman, J., & Nicholson, A. (1993). Planning with deadlines in
stochastic domains. In Proceedings of the Eleventh National Conference on Artificial
Intelligence (AAAI-93), pp. 574579, Washington, D.C. AAAI Press.
Dean, T., & Kanazawa, K. (1989). A model for reasoning about persistence and causation.
Computational Intelligence, 5 (3), 142150.
Dean, T., & Givan, R. (1997). Model minimization in Markov decision processes. In
Proceedings of the Fourteenth National Conference on Artificial Intelligence (AAAI97), pp. 106111, Providence, Rhode Island, Oregon. AAAI Press.
Dearden, R., & Boutilier, C. (1997). Abstraction and approximate decision theoretic planning. Artificial Intelligence, 89 (1), 219283.
465

fiGuestrin, Koller, Parr & Venkataraman

Dechter, R. (1999). Bucket elimination: A unifying framework for reasoning. Artificial
Intelligence, 113 (12), 4185.
Gordon, G. (1995). Stable function approximation in dynamic programming. In Proceedings
of the Twelfth International Conference on Machine Learning, pp. 261268, Tahoe
City, CA. Morgan Kaufmann.
Guestrin, C. E., Koller, D., & Parr, R. (2001a). Max-norm projections for factored MDPs.
In Proceedings of the Seventeenth International Joint Conference on Artificial Intelligence (IJCAI-01), pp. 673  680, Seattle, Washington. Morgan Kaufmann.
Guestrin, C. E., Koller, D., & Parr, R. (2001b). Multiagent planning with factored MDPs.
In 14th Neural Information Processing Systems (NIPS-14), pp. 15231530, Vancouver,
Canada.
Guestrin, C. E., Koller, D., & Parr, R. (2001c). Solving factored POMDPs with linear value
functions. In Seventeenth International Joint Conference on Artificial Intelligence
(IJCAI-01) workshop on Planning under Uncertainty and Incomplete Information,
pp. 67  75, Seattle, Washington.
Guestrin, C. E., Venkataraman, S., & Koller, D. (2002). Context specific multiagent coordination and planning with factored MDPs. In The Eighteenth National Conference
on Artificial Intelligence (AAAI-2002), pp. 253259, Edmonton, Canada.
Hoey, J., St-Aubin, R., Hu, A., & Boutilier, C. (1999). SPUDD: Stochastic planning using decision diagrams. In Proceedings of the Fifteenth Conference on Uncertainty in
Artificial Intelligence (UAI-99), pp. 279288, Stockholm, Sweden. Morgan Kaufmann.
Hoey, J., St-Aubin, R., Hu, A., & Boutilier, C. (2002). Stochastic planning using decision
diagrams  C implementation. http://www.cs.ubc.ca/spider/staubin/Spudd/.
Howard, R. A., & Matheson, J. E. (1984). Influence diagrams. In Howard, R. A., & Matheson, J. E. (Eds.), Readings on the Principles and Applications of Decision Analysis,
pp. 721762. Strategic Decisions Group, Menlo Park, California.
Keeney, R. L., & Raiffa, H. (1976). Decisions with Multiple Objectives: Preferences and
Value Tradeoffs. Wiley, New York.
Kim, K.-E., & Dean, T. (2001). Solving factored Mdps using non-homogeneous partitioning. In Proceedings of the Seventeenth International Joint Conference on Artificial
Intelligence (IJCAI-01), pp. 683  689, Seattle, Washington. Morgan Kaufmann.
Kjaerulff, U. (1990). Triangulation of graphs  algorithms giving small total state space.
Tech. rep. TR R 90-09, Department of Mathematics and Computer Science, Strandvejen, Aalborg, Denmark.
Koller, D., & Parr, R. (1999). Computing factored value functions for policies in structured
MDPs. In Proceedings of the Sixteenth International Joint Conference on Artificial
Intelligence (IJCAI-99), pp. 1332  1339. Morgan Kaufmann.
Koller, D., & Parr, R. (2000). Policy iteration for factored MDPs. In Proceedings of the
Sixteenth Conference on Uncertainty in Artificial Intelligence (UAI-00), pp. 326 
334, Stanford, California. Morgan Kaufmann.
466

fiEfficient Solution Algorithms for Factored MDPs

Meuleau, N., Hauskrecht, M., Kim, K., Peshkin, L., Kaelbling, L., Dean, T., & Boutilier, C.
(1998). Solving very large weakly-coupled Markov decision processes. In Proceedings
of the 15th National Conference on Artificial Intelligence, pp. 165172, Madison, WI.
Pearl, J. (1988). Probabilistic Reasoning in Intelligent Systems: Networks of Plausible Inference. Morgan Kaufmann, San Mateo, California.
Puterman, M. L. (1994). Markov decision processes: Discrete stochastic dynamic programming. Wiley, New York.
Reed, B. (1992). Finding approximate separators and computing tree-width quickly. In
24th Annual Symposium on Theory of Computing, pp. 221228. ACM.
Schuurmans, D., & Patrascu, R. (2001). Direct value-approximation for factored MDPs.
In Advances in Neural Information Processing Systems (NIPS-14), pp. 15791586,
Vancouver, Canada.
Schweitzer, P., & Seidmann, A. (1985). Generalized polynomial approximations in Markovian decision processes. Journal of Mathematical Analysis and Applications, 110, 568
 582.
Simon, H. A. (1981). The Sciences of the Artificial (second edition). MIT Press, Cambridge,
Massachusetts.
Singh, S., & Cohn, D. (1998). How to dynamically merge Markov decision processes. In
Jordan, M. I., Kearns, M. J., & Solla, S. A. (Eds.), Advances in Neural Information
Processing Systems, Vol. 10. The MIT Press.
St-Aubin, R., Hoey, J., & Boutilier, C. (2001). APRICODD: Approximate policy construction using decision diagrams. In Advances in Neural Information Processing Systems
13: Proceedings of the 2000 Conference, pp. 10891095, Denver, Colorado. MIT Press.
Stiefel, E. (1960). Note on Jordan elimination, linear programming and Tchebycheff approximation. Numerische Mathematik, 2, 1  17.
Sutton, R. S. (1988). Learning to predict by the methods of temporal differences. Machine
Learning, 3, 944.
Tadepalli, P., & Ok, D. (1996). Scaling up average reward reinforcmeent learning by approximating the domain models and the value function. In Proceedings of the Thirteenth
International Conference on Machine Learning, Bari, Italy. Morgan Kaufmann.
Tatman, J. A., & Shachter, R. D. (1990). Dynamic programming and influence diagrams.
IEEE Transactions on Systems, Man and Cybernetics, 20 (2), 365379.
Tsitsiklis, J. N., & Van Roy, B. (1996a). Feature-based methods for large scale dynamic
programming. Machine Learning, 22, 5994.
Tsitsiklis, J. N., & Van Roy, B. (1996b). An analysis of temporal-difference learning with
function approximation. Technical report LIDS-P-2322, Laboratory for Information
and Decision Systems, Massachusetts Institute of Technology.
Van Roy, B. (1998). Learning and Value Function Approximation in Complex Decision
Processes. Ph.D. thesis, Massachusetts Institute of Technology.
467

fiGuestrin, Koller, Parr & Venkataraman

Williams, R. J., & Baird, L. C. I. (1993). Tight performance bounds on greedy policies based
on imperfect value functions. Tech. rep., College of Computer Science, Northeastern
University, Boston, Massachusetts.
Yedidia, J., Freeman, W., & Weiss, Y. (2001). Generalized belief propagation. In Advances
in Neural Information Processing Systems 13: Proceedings of the 2000 Conference,
pp. 689695, Denver, Colorado. MIT Press.
Zhang, N., & Poole, D. (1999). On the role of context-specific independence in probabilistic
reasoning. In Proceedings of the Sixteenth International Joint Conference on Artificial
Intelligence (IJCAI-99), pp. 12881293. Morgan Kaufmann.

468

fi