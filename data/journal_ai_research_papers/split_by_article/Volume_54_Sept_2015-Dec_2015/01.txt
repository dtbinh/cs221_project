Journal of Artificial Intelligence Research 59 (2015) 59-82

Submitted 05/15; published 09/15

Solving #SAT and MaxSAT by Dynamic Programming
Sigve Hortemo Sther
Jan Arne Telle
Martin Vatshelle

sigve.sether@ii.uib.no
telle@ii.uib.no
martin.vatshelle@ii.uib.no

Department of Informatics, University of Bergen
Bergen, Norway

Abstract
We look at dynamic programming algorithms for propositional model counting, also
called #SAT, and MaxSAT. Tools from graph structure theory, in particular treewidth,
have been used to successfully identify tractable cases in many subfields of AI, including
SAT, Constraint Satisfaction Problems (CSP), Bayesian reasoning, and planning. In this
paper we attack #SAT and MaxSAT using similar, but more modern, graph structure
tools. The tractable cases will include formulas whose class of incidence graphs have not only
unbounded treewidth but also unbounded clique-width. We show that our algorithms extend
all previous results for MaxSAT and #SAT achieved by dynamic programming along
structural decompositions of the incidence graph of the input formula. We present some
limited experimental results, comparing implementations of our algorithms to state-of-the-art
#SAT and MaxSAT solvers, as a proof of concept that warrants further research.

1. Introduction
The propositional satisfiability problem (SAT) is a fundamental problem in computer science
and in AI. Many real-world applications such as planning, scheduling, and formal verification
can be encoded into SAT and a SAT solver can be used to decide if there exists a solution.
To decide how many solutions there are, the propositional model counting problem (#SAT),
which finds the number of satisfying assignments, could be useful. If there are no solutions,
it may be interesting to know how close we can get to a solution. When the propositional
formula is encoded in Conjunctive Normal Form (CNF) this may be solved by the maximum
satisfiability problem (MaxSAT), which finds the maximum number of clauses that can
be satisfied by some assignment. In this paper we investigate classes of CNF formulas
where these two problems, #SAT and MaxSAT, can be solved in polynomial time. Tools
from graph structure theory, in particular treewidth, have been used to successfully identify
tractable cases in many subfields of AI, including SAT, Constraint Satisfaction Problems
(CSP), Bayesian reasoning, and planning (Bacchus, Dalmao, & Pitassi, 2003; Darwiche,
2001; Fischer, Makowsky, & Ravve, 2008; Samer & Szeider, 2010). In this paper we
attack #SAT and MaxSAT using similar, but more modern, graph structure tools. The
tractable cases will include formulas whose class of incidence graphs have not only unbounded
treewidth but also unbounded clique-width.
Both #SAT and MaxSAT are significantly harder than simply deciding if a satisfying
assignment exists. #SAT is #P-hard (Garey & Johnson, 1979) even when restricted
to Horn 2-CNF formulas, and to monotone 2-CNF formulas (Roth, 1996). MaxSAT is
NP-hard even when restricted to Horn 2-CNF formulas (Jaumard & Simeone, 1987), and to
c
2015
AI Access Foundation. All rights reserved.

fiSther, Telle & Vatshelle

2-CNF formulas where each variable appears at most 3 times (Raman, Ravikumar, & Rao,
1998). Both problems become tractable under certain structural restrictions obtained by
bounding width parameters of graphs associated with formulas (Fischer, Makowsky, & Ravve,
2008; Ganian, Hlineny, & Obdrzalek, 2013; Samer & Szeider, 2010; Szeider, 2003). The
work we present here is inspired by recent results in the work of Paulusma, Slivovsky, and
Szeider (2013) and also in the work of Slivovsky and Szeider (2013) showing that #SAT
is solvable in polynomial time when the incidence graph1 I(F ) of the input formula F has
bounded modular treewidth, and more strongly, bounded symmetric clique-width.
These tractability results work by dynamic programming along a decomposition of I(F ).
There are two steps involved: (1) find a good decomposition, and (2) perform dynamic
programming along the decomposition. The goal is to have a fast runtime, and this is usually
expressed as a function of some known graph width parameter of the incidence graph I(F )
of the formula F , like its tree-width. Step (1) is solved by a known graph algorithm for
computing a decomposition of low (tree-)width, while step (2) solves #SAT or MaxSAT
by dynamic programming with runtime expressed in terms of the (tree-)width k of the
decomposition.
The algorithms we give in this paper also work by dynamic programming along a
decomposition, but in a slightly different framework. Since we are not solving a graph
theoretic problem, expressing runtime by a graph theoretic parameter may be a limitation.
Therefore, our strategy will be to develop a framework based on the following strategy
(A) consider, for #SAT or MaxSAT, the amount of information needed to combine
solutions to subproblems into global solutions, then
(B) define the notion of good decompositions based on a parameter that minimizes this
information, and then
(C) design a dynamic programming algorithm along such a decomposition with runtime
expressed by this parameter
Both in the work of Paulusma et al. (2013) and in that of Slivovsky and Szeider (2013)
two assignments are considered to be equivalent if they satisfy the same set of clauses.
When carrying out (A) for #SAT and MaxSAT this led us to the concept of ps-value of a
CNF formula. Let us define it and give an intuitive explanation. A subset C of the clauses
of a CNF formula F is called projection satisfiable if there is some complete assignment
satisfying every clause in C but not satisfying any clause not in C. The ps-value of F is
the number of projection satisfiable subsets of clauses. Let us consider its connection to
dynamic programming, which in general applies when an optimal solution can be found
by combining optimal solutions to certain subproblems. For #SAT and MaxSAT these
subproblems, at least in the cases we consider, take the form of a subformula of F induced
by a subset S of clauses and variables, i.e. first remove from F all variables not in S and
then remove all clauses not in S. Consider for simplicity the two subproblems FS and FS
defined by S and its complement S. When combining the solutions to FS and FS , in order
1. I(F ) is the bipartite incidence graph between the clauses of F on the one hand and the variables of F on
the other hand. Information about positive or negative occurrences of variables is not encoded in I(F ) so
sometimes a signed or directed version is used that includes also this information.

60

fiSolving #SAT and MaxSAT by Dynamic Programming

to find solutions to F , it seems clear that we must consider a number of cases at least as
big as the ps-values of the two disjoint subformulas crossing between S and S, i.e. the
subformulas obtained by removing from clauses in S the variables of S, and by removing
from clauses in S the variables of S. See Figure 2 for an example.
We did not find in the literature a study of the ps-value of CNF formulas, so we start by
asking for a characterization of formulas having low ps-value. We were led to the concept of
the mim-value of I(F ), which is the size of a maximum induced matching of I(F ), where
an induced matching is a subset M of edges with the property that any edge of the graph
is incident to at most one edge in M . Note that this value can be much lower than the
size of a maximum matching, e.g. any complete bipartite graph has mim-value 1. We show
that the ps-value of F is upper bounded by the number of clauses of F raised to the power
of the mim-value of I(F ), plus 1. For a CNF formula F where I(F ) has mim-value 1 the
interpretation of this result is straightforward: its clauses can be totally ordered such that for
any two clauses C < C 0 the variables occurring in C are a subset of the variables occurring
in C 0 , and this has the implication that the number of subsets of clauses for which some
complete assignment satisfies exactly this subset is at most the number of clauses plus 1.
Families of CNF formulas having small ps-value are themselves of algorithmic interest,
but in this paper we continue with part (B) of the above strategy, and focus on how to
decompose a CNF formula F based on the concept of ps-value. A common way to decompose
a mathematical object is to recursively partition its ground set into two parts, giving a
binary tree whose root represents the ground set and whose leaves are bijectively mapped
to the elements of the ground set. Taking the ground set of F to be the set containing its
clauses and its variables, this is how we will decompose F , in other words by a binary tree
whose leaves are in 1-1 correspondence with the variables and clauses. A node of the binary
tree represents the subset X of variables and clauses at the leaves of its subtree. Which
decomposition trees are good for efficiently solving #SAT and MaxSAT? In accordance
with the above discussion under part (A) the answer is that the good decomposition trees
are those where all subformulas crossing between X and X, for some X defined by a node
of the tree, have low ps-value. See Figure 2 for an example. To define this informal notion
precisely we use the concept of a branch decomposition over the ground set of a formula with
cut function being the ps-value of the formulas crossing the cut. Branch decompositions are
by now a standard notion in graph and matroid theory, originating in the work of Robertson
and Seymour on graph minors (Robertson & Seymour, 1991). This way we arrive at the
definition of the ps-width of a CNF formula F , and of the decompositions of F that achieve
this ps-width. It is important to note that a formula can have ps-value exponential in
formula size while ps-width is polynomial, and that in general the class of formulas of low
ps-width is much larger than the class of formulas of low ps-value.
To finish the above strategy, we must carry out part (C) and show how to solve #SAT
and MaxSAT by dynamic programming along the branch decomposition of the formula,
and express its runtime as a function of the ps-width. This is not complicated, as dynamic
programming when everything has been defined properly simply becomes an exercise in
brute-force computation of the sufficient and necessary information, but it is technical and
quite tedious. It leads to the following theorem.
Theorem 2. Given a formula F over n variables and m clauses, and a decomposition of F
of ps-width k, we solve #SAT and weighted MaxSAT in time O(k 3 m(m + n)).
61

fiSther, Telle & Vatshelle

Thus, given a decomposition having a ps-width k that is polynomially-bounded in the
number of variables n and clauses m of the formula, we get polynomial-time algorithms.
Let us compare our result to the strongest previous result in this direction, namely the
work of Slivovsky and Szeider (2013) for #SAT. Their algorithm takes as input a branch
decomposition over the vertex set of I(F ), which is the same as the ground set of F , and
evaluates its runtime by the cut function they call index. They show that this cut function is
closely related to the symmetric clique-width scw of the given decomposition, giving runtime
(n + m)O(scw) . Considering the clique-width cw of the given decomposition the runtime of the
cw
work of Slivovsky and Szeider (2013) becomes (n + m)O(2 ) since symmetric clique-width
and clique-width is related by the essentially tight inequalities 0.5cw  scw  2cw (Courcelle,
2004). Their algorithm is thus a polynomial-time algorithm if given a decomposition with
constantly bounded scw. The result of Theorem 2 encompasses this, since our Corollary 1
ties ps-width to mim-width and the work of Vatshelle (2012) shows that mim-width is upper
bounded by clique-width, see also the work of Rao (2008) for symmetric clique-width, so
that a decomposition of I(F ) having constantly bounded (symmetric) clique-width also has
polynomially bounded ps-width. In this way, given the decomposition assumed as input in
the work of Slivovsky and Szeider (2013), the algorithm of Theorem 2 will have runtime
O(m3cw s), for cw the clique-width of the given decomposition.
In the work of Brault-Baron, Capelli, and Mengel (2014), appearing after a preliminary
presentation of our results (Sther, Telle, & Vatshelle, 2014), it is argued that the framework
behind Theorem 2 gives a uniform explanation of all tractability results for #SAT in the
literature, in particular those using dynamic programming based on structural decompositions
of the incidence graph. The work of Brault-Baron et al. (2014) also goes beyond this, giving
a polynomial-time algorithm, not by dynamic programming, to solve #SAT on -acyclic
CNF formulas, being exactly those formulas whose incidence graphs are chordal bipartite.
They show that these formulas do not have bounded ps-width and that their incidence
graphs do not have bounded mim-width. See Figure 1 which gives an overview of the results
in this paper and in other papers.
Using the concept of mim-width of graphs, introduced in the thesis of Vatshelle (2012), and
the connection between ps-value and mim-value alluded to earlier, we show that a rich class of
formulas, including classes of unbounded clique-width, have polynomially bounded ps-width
and are thus covered by Theorem 2. Firstly, this holds for classes of formulas having incidence
graphs that can be represented as intersection graphs of certain objects, like interval graphs
(Belmonte & Vatshelle, 2013). Secondly, it holds also for the much larger class of bipartite
graphs achieved by taking bigraph bipartizations of these intersection graphs, obtained by
imposing a bipartition on the vertex set and keeping only edges between the partition classes.
Some such bigraph bipartizations have been studied previously, in particular the interval
bigraphs. The interval bigraphs contain all bipartite permutation graphs, and these latter
graphs have been shown to have unbounded clique-width (Brandstadt & Lozin, 2003). See
Figure 1.
Let us discuss step (1), finding a good decomposition. Note that Theorem 2 assumes
that the input formula is given along with a decomposition of some ps-width k. The value k
need not be optimal, so any heuristic finding a reasonable branch decomposition could be
used in practice. Computing decompositions of optimal ps-width is probably not doable in
62

fiSolving #SAT and MaxSAT by Dynamic Programming

iden
The inc

F

h of F
ce grap

ps-width mk

#SAT poly. Paper A.
#SAT poly. Paper B.

chordal
bipartite

#SAT and MaxSAT poly.
This paper.

-acyclic

ps-width m2
MIM-width k
clique-width k
symmetric
clique-width k/2
modular
treewidth k/2

ps-width m
k-trapezoid
bigraph

circular arc
bigraph
interval bigraph
bipartite
permutation

Figure 1: We believe, as argued in the work of Brault-Baron et al. (2014), that any dynamic
programming approach working along a structural decomposition to solve #SAT
(or MaxSAT) in polynomial time cannot go beyond the green box. Paper A is by
Brault-Baron et al. (2014) and Paper B is by Slivovsky and Szeider (2013). On
the left of the two dashed lines are 4 classes of graphs with bound k/2 or k on
some structural graph width parameter, and 5 classes of bipartite graphs. On the
right are -acyclic CNF formulas and 3 classes of CNF formulas with ps-width
varying from linear in the number of clauses m, to m2 and mk . There is an arc
from P to Q if any formula F or incidence graph I(F ) having property P also has
property Q. This is a Hasse diagram, so lack of an arc in the transitive closure
means this relation provably does not hold.
polynomial-time, but the complexity of this question is not adressed in this paper. However,
we are able to efficiently decide if a CNF formula has a certain linear structure guaranteeing
low ps-width. By combining an alternative definition of interval bigraphs (Hell & Huang,
2004) with a fast recognition algorithm (Muller, 1997; Rafiey, 2012) we arrive at the
following. Say that a CNF formula F has an interval ordering if there exists a total ordering
of variables and clauses such that for any variable x occurring in clause C, if x appears
before C then any variable between them also occurs in C, and if C appears before x then x
occurs also in any clause between them.
Theorem 6. Given a formula F over n variables and m clauses each of at most t literals.
In time O((m + n)mn) we can decide if F has an interval ordering (yes iff I(F ) is an
interval bigraph), and if yes we solve #SAT and weighted MaxSAT with an additional
runtime of O(min{m2 , 4t }(m + n)m).
Formulas with an interval ordering are precisely those whose incidence graphs are interval
bigraphs, so Theorem 6 encompasses classes of formulas whose incidence graphs have
unbounded clique-width.
Could parts of our algorithms be of interest for practical applications? Answering this
question is beyond the scope of the present paper. However, we have performed some limited
testing, in particular for formulas with a linear structure, as a simple proof of concept. All
our code can be found online (Sther, Telle, & Vatshelle, 2015). We have designed and
implemented a heuristic for step (1) finding a good decomposition, in this case a linear
63

fiSther, Telle & Vatshelle

one where the binary tree describing the decomposition is a path with attached leaves. We
have also implemented step (2) dynamic programming solving #SAT and MaxSAT along
such decompositions. We then run (1) followed by (2) and compare against one of the
best MaxSAT solvers from the Max-SAT-2014 event of the SAT-2014 conference and the
latest version of the #SAT solver called sharpSAT (Thurley, 2006). These solvers beat our
implementation on most inputs, which is not suprising since our code does not include any
techniques beyond our algorithm. Nevertheless, we were able to generate some classes of
CNF formulas having interval orderings where our implementation is by far the better. This
lends support to our belief that methods related to ps-value warrants further research to
investigate if they could be useful in practice.
Our paper is organized as follows. In Section 2 we give formal definitions of ps-value
and ps-width of a CNF formula and show the central combinatorial lemma linking ps-value
of a formula to the size of the maximum induced matching in the incidence graph of the
formula. In Section 3 we present dynamic programming algorithms that given a formula and
a decomposition solves #SAT and weighted MaxSAT, proving Theorem 2. In Section 4
we investigate classes of formulas having decompositions of low ps-width, basically proving
the correctness of the hierarchy presented in Figure 1. In Section 5 we consider formulas
having an interval ordering and prove Theorem 6. In Section 6 we present the results of the
implementations and testing. We end in Section 7 with some open problems.

2. Framework
We consider propositional formulas in Conjunctive Normal Form (CNF). A literal is a
propositional variable or a negated variable, x or x, a clause is a set of literals, and a
formula is a multiset of clauses. For a formula F , cla(F ) denotes the clauses in F . The
incidence graph of a formula F is the bipartite graph I(F ) having a vertex for each clause
and variable, with variable x adjacent to any clause C in which it occurs. We consider
only input formulas where I(F ) is connected, as otherwise we would solve our problems
on the separate components of I(F ). For a clause C, lit(C) denotes the set of literals
in C and var(C) denotes
the variables of the literals in lit(C). For a formula F , var(F )
S
denotes the union Ccla(F ) var(C). For a set X of variables, an assignment of X is a
function  : X  {0, 1}. For a literal `, we define  (`) to be 1   (var(`)) if ` is a negated
variable (` = x for some variable x) and to be  (var) otherwise (` = x for some variable
x). A clause C is said to be satisfied by an assignment  if there exists at least one literal
`  lit(C) so that  (`) = 1. Any clause which an assignment  does not satisfy is said to be
falsified by  . We notice that this means an empty clause will be falsified by all assignments.
A formula is satisfied by an assignment  if  satisfies all clauses in cla(F ).
The problem #SAT, given a formula F , asks how many distinct assignments of var(F )
satisfy F . The optimization problem weighted MaxSAT, given a formula
P F and weight
function w : cla(F )  N, asks what assignment  of var(F ) maximizes C w(C) for all
C  cla(F ) satisfied by  . The problem MaxSAT asks for the maximum number of satisfied
clauses that can be achieved, equivalent to weighted MaxSAT where all clauses have weight
one. For weighted MaxSAT, we assume the sum of all the weights are at most 2O(cla(F )) ,
and thus we can do summation on the weights in time linear in cla(F ).
64

fiSolving #SAT and MaxSAT by Dynamic Programming

For a set A, with elements from a universe U we denote by A the elements in U \ A, as
the universe is usually given by the context.
2.1 Cut of a Formula
In this paper, we will solve MaxSAT and #SAT by the use of dynamic programming.
We will be using a divide and conquer technique where we solve the problem on smaller
subformulas of the original formula F and then combine the solutions to each of these smaller
formulas to form a solution to the entire formula F . Note however, that the solutions found
for a subformula will depend on the interaction between the subformula and the remainder
of the formula. We use the following notation for subformulas.
For a clause C and set X of variables, by C|X we denote the clause {`  C : var(`)  X}.
We say C|X is the clause C induced by X. Unless otherwise specified, all clauses mentioned
in this paper are from the set cla(F ) (e.g., if we write C|X  cla(F 0 ), we still assume C 
cla(F )). For a formula F and subsets C  cla(F ) and X  var(F ), we say the subformula
FC,X of F induced by C and X is the formula consisting of the clauses {Ci |X : Ci  C}. That
is, FC,X is the formula we get by removing all clauses not in C followed by removing each
literal of a variable not in X. For a set C of clauses, we denote by C|X the set {C|X : C  C}.
As with a clause, for an assignment  over a set X of variables, we say the assignment 
induced by X 0  X is the assignment  |X 0 where the domain is restricted to X 0 .
For a formula F and sets C  cla(F ), X  var(F ), and S = C  X, we call S a cut of F
and note that it breaks F into four subformulas FC,X , FC,X , FC,X , and FC,X . See Figure 2.
One important fact we may observe from this definition is that a clause C in F is satisfied
by an assignment  of var(F ), if and only if C (induced by X or X) is satisfied by  in at
least one of the formulas of any cut of F .
2.2 Projection Satisfiable Sets and ps-value of a Formula
For a formula F and assignment  of some of the variables in var(F ), we denote by sat(F,  )
the inclusion maximal set C  cla(F ) so that each clause in C is satisfied by  . If for a
set C  cla(F ) we have sat(F,  ) = C for some  over all the variables in var(F ), then C
is known as a projection (Kaski, Koivisto, & Nederlof, 2012; Slivovsky & Szeider, 2013)
and we say C is projection satisfiable in F . We denote by PS(F ) the family of all projection
satisfiable sets in F . That is,
PS(F ) = {sat(F,  ) :  is an assignment of the entire set var(F )}.
The cardinality of this set, |PS(F )|, is referred to as the ps-value of F .
To get a grasp of the structure of formulas having low ps-value we consider induced
matchings in the incidence graph of a formula. The incidence graph of a formula F is the
bipartite graph I(F ) having a vertex for each clause and variable, with variable x adjacent
to any clause C in which it occurs. An induced matching in a graph is a subset M of edges
with the property that any edge of the graph is incident to at most one edge in M . In other
words, for any 3 vertices a, b, c, if ab is an edge in M and bc is an edge then there does not
exist an edge cd in M . The number of edges in M is called the size of the induced matching.
The following result provides an upper bound on the ps-value of a formula in terms of the
maximum size of an induced matching of its incidence graph.
65

fiSther, Telle & Vatshelle

Lemma 1. Let F be a CNF formula with no clause containing more than t literals, and
let k be the maximum size of an induced matching in I(F ). We then have |PS(F )| 
min{|cla(F )|k + 1, 2tk }.
Proof. We first argue that |PS(F )|  |cla(F )|k + 1. Let C  PS(F ) and Cf = cla(F ) \ C.
Thus, there exists a complete assignment  such that the clauses not satisfied by  are
Cf = cla(F ) \ sat(F,  ). Since every variable in var(F ) appears in some clause of F this
means that  |var(Cf ) is the unique assignment of the variables in var(Cf ) which do not satisfy
0
0
any clause of Cf . Let Cf  Cf be an inclusion minimal set such that var(Cf ) = var(Cf ),
hence  |var(Cf ) is also the unique assignment of the variables in var(Cf ) which do not satisfy
0
0
any clause of Cf . An upper bound on the number of different such minimal Cf , over all
0
C  PS(F ), will give an upper bound on |PS(F )|. For every C  Cf there is a variable vC
0
0
appearing in C and no other clause of Cf , otherwise Cf would not be minimal. Note that we
have an induced matching M of I(F ) containing all such edges vC , C. By assumption, the
0
induced matching M can have at most k edges and hence |Cf |  k. It is easy to show by
induction on k that there are at most |cla(F )|k + 1 sets of at most k clauses and the lemma
follows.
We now argue that |PS(F )|  2tk . As the maximum induced matching has size k there
is some set C of k clauses so that var(C) = var(F ). As each clause C  C has |var(C)|  t,
we have |var(F )| = |var(C)|  tk. As there are no more than 2|var(F )| assignments for F ,
the PS-value of F is upper bounded by 2tk .
2.3 The ps-width of a Formula
We define a branch decomposition of a formula F to be a pair (T, ) where T is a rooted
binary tree and  is a bijective function from the leaves of T to the clauses and variables
of F . If all the non-leaf nodes (also referred to as internal nodes) of T induce a path, we
say that (T, ) is a linear branch decomposition. For a non-leaf node v of T , we denote
by (v) the set {(l) : l is a leaf in the subtree rooted in v}. Based on this, we say that the
decomposition (T, ) of formula F induces certain cuts of F , namely the cuts defined by (v)
for each node v in T .
For a formula F and branch decomposition (T, ), for each node v in T , by Fv we denote
the formula induced by the clauses in cla(F ) \ (v) and the variables in (v), and by Fv
we denote the formula on the complement sets; i.e. the clauses in (v) and the variables
in var(F ) \ (v). In other words, if (v) = C  X with C  cla(F ) and X  var(F ) then
Fv = FC,X and Fv = FC,X . To simplify the notation, we will for a node v in a branch
decomposition and a set C of clauses denote by C|v the set C|var(Fv ) . We define the ps-value
of the cut (v) to be
ps((v)) = max{|P S(Fv )|, |P S(Fv )|}
We define the ps-width of a branch decomposition to be
psw(T, ) = max{ps((v)) : v is a node of T }
We define the ps-width of a formula F to be
psw(F ) = min{psw(T, ) : (T, ) is a branch decomposition of F }
66

fiSolving #SAT and MaxSAT by Dynamic Programming

v
x4
x3 c4 x5 c2
x1

x2

c1

C
c1 = {x1 , x2 }
c3 = {x2 , x4 , x5 }

c3
FC,X = Fv

X

FC,X

FC,X

x1 x2

x3 x4
x5

FC,X = Fv

c2 = {x1 , x2 , x3 }
c4 = {x2 , x3 , x5 }

X

C

Figure 2: On top is a branch decomposition of a formula F with var(F ) = {x1 , x2 , x3 , x4 , x5 }
and the 4 clauses cla(F ) = {c1 , c2 , c3 , c4 } as given in the boxes. The node
v of the tree defines the cut (v) = C  X where C = {c1 , c3 } and X =
{x1 , x2 }. There are 4 subformulas defined by this cut: FC,X , FC,X , FC,X , FC,X .
For example, FC,X = {{x1 , x2 }, {x2 }} and FC,X = {, {x4 , x5 }}. We have
Fv = FC,X and Fv = FC,X with projection satisfiable sets of clauses PS(Fv ) =
{{c2 |v }, {c4 |v }, {c2 |v , c4 |v }} and PS(Fv ) = {, {c3 |v }} and the ps-value of this cut
is ps((v)) = max{|P S(Fv )|, |P S(Fv )|} = 3.

Note that the ps-value of a cut is a symmetric function. That is, the ps-value of cut S
equals the ps-value of the cut S. See Figure 2 for an example.

3. Dynamic Programming for MaxSAT and #SAT
Given a branch decomposition (T, ) of a CNF formula F over n variables and m clauses
and of total size s, we will give algorithms that solve MaxSAT and #SAT on F in time
O(psw(T, )3 m(m + n)). Our algorithms are strongly inspired by the work of Slivovsky and
Szeider (2013), but in order to achieve a runtime polynomial in ps-width, and also to solve
MAXSAT, we must make some crucial changes. In particular, we must index the dynamic
progranming tables by PS-sets rather than the shapes used in the work of Slivovsky and
Szeider (2013).
Let us discuss some special terminology to be used in this section. In this dynamic
programming section, we will combine partial solutions to subformulas into solutions for
the input formula F . To improve readability we introduce notation P S 0 and sat0 that
allows us to refer directly to the clauses of F , also when working on the subformulas.
67

fiSther, Telle & Vatshelle

Thus, for a formula F and branch decomposition (T, ), for each node v in T , and induced
subformula Fv of F , by PS0 (Fv ) we denote the subsets of clauses C from cla(F ) \ (v) so
that PS(Fv ) = C|var(Fv ) . Similarly, for an assignment  over var(Fv ), by sat0 (Fv ,  ) we
denote the set of clauses C from cla(F ) \ (v) so that sat(Fv ,  ) = C|var(Fv ) . Note that
|PS0 (Fv )| = |PS(Fv )| and |sat0 (Fv ,  )| = |sat(Fv ,  )|. We take the liberty to call also these
sets projection satisfiable and refer to them as PS-sets in the text, but it will be clear from
context that we mean clauses of cla(F ) and not cla(Fv ).
Let us discuss some implementation details. We regard PS-sets as boolean vectors of
length |cla(F )|, and assume we can identify clauses and variables by integer numbers. So,
checking if a clause is in a PS-set can be done in constant time, and checking if two PS-sets
are equal can be done in O(|cla(F )|) time. To manage our PS-sets, we use a binary trie
datastructure (Fredkin, 1960). We can add and retrieve a PS-set to and from a trie in
O(|cla(F )|) time. Trying to add a PS-set to a trie already containing an equivalent PS-set
will not alter the content of the trie, so our tries will only contain distinct PS-sets. As
retrieval of an element in our trie takes O(|cla(F )|) time, by assigning a distinct integer
to each PS-set at the time it is added to the trie, we have a O(|cla(F )|)-time mapping
from PS-sets to distinct integers. This will be used implicitly in our algorithms when we
say we index by PS-sets; when implementing the algorithm we will instead index by the
corresponding integer the PS-set is mapped to.
In a pre-processing step we will need the following which, for each node v in T computes
the sets of projection satisfiable subsets of clauses PS0 (Fv ) and PS0 (Fv ) of the two crossing
subformulas Fv and Fv .
Theorem 1. Given a CNF formula F with a branch decomposition (T, ) of ps-width k, we
can in time O(k 2 m(m + n)) compute the sets PS0 (Fv ) and PS0 (Fv ) for each v in T .

Proof. We notice that for a node v in T with children c1 and c2 , we can express PS0 (Fv ) as


C1  PS0 (Fc1 ), and
0
PS (Fv ) = (C1  C2 )  cla(Fv ) :
.
C2  PS0 (Fc2 )

Similarly, for sibling s and parent p of v in T , the set PS0 (Fv ) can be expressed as


Cp  PS0 (Fp ), and
0
PS (Fv ) = (Cp  Cs )  cla(Fv ) :
.
Cs  PS0 (Fs )
By transforming these recursive expressions into a dynamic programming algorithm, as
done in Procedure 1 and Procedure 2 below, we are able to calculate all the desired sets as
long as we can compute the sets for the base cases PS0 (Fl ) when l is a leaf of T , and PS0 (Fr )
for the root r of T . However, these formulas contain at most one variable, and thus we can
easily construct their set of projection satisfiable clauses in linear amount of time for each
of the formulas. For the rest of the formulas, we construct the formulas using Procedure 1
and Procedure 2. As there are at most twice as many nodes in T as there are clauses and
variables in F , the procedures will run at most O(|cla(F )| + |var(F )|) times. In each run
of the algorithms, we iterate through at most k 2 pairs of projection satisfiable sets, and do a
constant number of set operations that might take O(|cla(F )|) time each. This results in a
total runtime of O(k 2 |cla(F )|(|cla(F )| + |var(F )|)) = O(k 2 m(m + n)) for all the nodes of
T combined.
68

fiSolving #SAT and MaxSAT by Dynamic Programming

Procedure 1: Generating PS0 (Fv )
input: PS0 (Fc1 ) and PS0 (Fc2 ) for children c1 and c2 of v
in branch decomposition
output: PS0 (Fv )
L  empty trie of projection satisfiable clause-sets
for each (C1 , C2 )  PS0 (Fc1 )  PS0 (Fc2 ) do
add (C1  C2 )  cla(Fv ) to L
return L
Procedure 2: Generating PS0 (Fv )
input: PS0 (Fs ) and PS0 (Fp ) for sibling s and parent p of v
in branch decomposition
output: PS0 (Fv )
L  empty trie of projection satisfiable clause-sets
for each (Cs , Cp )  PS0 (Fs )  PS0 (Fp ) do
add (Cs  Cp )  cla(Fv ) to L
return L
We now move on to the dynamic programming proper. We first give the algorithm for
MaxSAT and then briefly describe the changes necessary for solving weighted MaxSAT
and #SAT.
Our algorithm uses the technique of expectation introduced in the work of Bui-Xuan,
Telle, and Vatshelle (2010, 2011). Some partial solutions might be good when combined
with certain partial solutions, but bad when combined with others. In the technique of
expectation we categorize how partial solutions can interact, and then optimize our selection
of partial solutions based on the expectation that this interaction occurs. In our dynamic
programming algorithm for MaxSAT, we apply this technique by making expectations on
each cut regarding what set of clauses will be satisfied by variables of the opposide side of
the cut.
For a node v in the decomposition of F and PS-sets C  PS0 (Fv ) and C 0  PS0 (Fv ), we
say that an assignment  of var(F ) meets the expectation C and C 0 if sat0 (Fv ,  |v ) = C
and sat0 (Fv ,  |v ) = C 0 . For each node v of the branch decomposition, our algorithm uses a
table Tabv that for each pair (C, C 0 )  PS0 (Fv )  PS0 (Fv ) stores in Tabv (C, C 0 ) the maximum
number of clauses in (v) that are satisfied, over all assignments meeting the expectation
of C and C 0 . As the variables in var(F ) \ (v) satisfy exactly C 0 , for any assignment that
meets this expectation, an equivalent formulation of the content of Tabv (C, C 0 ) is that it
must satisfy the following constraint:
Over all assignments  of var(F )  (v) such that sat0 (Fv ,  ) = C ,
fi	
fi

Tabv (C, C 0 ) = max fi sat0 (F,  0 )  (v)  C 0 fi

(1)



By bottom-up dynamic programming along the tree T we compute the tables of each
node of T . For a leaf l in T , generating Tabl can be done easily in linear time since the
formula Fv contains at most one variable. For an internal node v of T , with children c1 , c2 ,
69

fiSther, Telle & Vatshelle

we compute Tabv by the algorithm described in Procedure 3. There are 3 tables involved in
this update, one at each child and one at the parent. A pair of entries, one from each child
table, may lead to an update of an entry in the parent table. Each table entry is indexed by
a pair, thus there are 6 indices involved in a single potential update. A trick first introduced
in the work of Bui-Xuan et al. (2011) allows us to loop over triples of indices and for each
triple compute the remaining 3 indices forming the 6-tuple involved in the update, thereby
reducing the runtime.
Procedure 3: Computing Tabv for inner node v with children c1 , c2
input: Tabc1 , Tabc2
output: Tabv
1. initialize Tabv : PS0 (Fv )  PS0 (Fv )  {1}
2. for each (Cc1 , Cc2 , Cv0 ) in PS0 (Fc1 )  PS0 (Fc2 )  PS0 (Fv ) do
3.
Cc0 1  (Cc2  Cv0 )  (c1 )
4.
Cc0 2  (Cc1  Cv0 )  (c2 )
5.
Cv  (Cc1  Cc2 ) \ (v)
6.
t  Tabc1 (Cc1 , Cc0 1 ) + Tabc2 (Cc2 , Cc0 2 )
7.
if Tabv (Cv , Cv0 ) < t then Tabv (Cv , Cv0 )  t
8. return Tabv
Lemma 2. For a CNF formula F of m clauses and an inner node v, of a branch decomposition (T, ) of ps-width k, Procedure 3 computes Tabv satisfying Constraint (1) in time
O(k 3 m).
Proof. We assume Tabc1 and Tabc2 satisfy Constraint (1). Procedure 3 loops over all triples
in PS0 (Fc1 )  PS0 (Fc2 )  PS0 (Fv ). From the definition of ps-width of (T, ) there are at most
k 3 such triples. Each operation inside an iteration of the loop take O(m) time and there is
a constant number of such operations. Thus the runtime is O(k 3 m).
Before we show the correctness of the output, let us look a bit at the workings of
Procedure 3. For any assignment  over var(F ), and cut, the assignment  will only meet
the expectation of a single pair of PS-sets. Let (X1 , X10 ), (X2 , X20 ) and (Xv , Xv0 ) be the pairs
an assignment  meets the expectation for with respect to the cuts induced by c1 , c2 , and v,
respectively. We notice that
Xv = sat0 (Fv ,  |v )

= sat0 (Fv ,  |c1 ]  |c2 )

= sat0 (Fv ,  |c1 )  sat0 (Fv ,  |c2 )

= (sat0 (Fc1 ,  |c1 ) \ (v))  (sat0 (Fc2 ,  |c2 ) \ (v))

(2)

= (X1 \ (v))  (X2 \ (v))
= (X1  X2 ) \ (v).

This can also be seen from Figure 3. By symmetry, we find similar values for X10 and X20 ;
namely X10 = (X2  Xv0 )  (c1 ) and X20 = (X1  Xv0 )  (c2 ). So, these latter three sets
will be implicit based on the three former sets with respect to the cuts induced by v, c1
and c2 . We will therefore, for convenience of this proof, say that an assignment  meets the
70

fiSolving #SAT and MaxSAT by Dynamic Programming

= X1 = sat (Fc1 ,  |c1 )

clauses in cla(F ) \ (v)

= X2 = sat (Fc2 ,  |c2 )
= Xv = sat (Fv ,  |v )

clauses in (c2 )

clauses in (c1 )

Figure 3: As shown by the chain of equalities in (2) in the proof of Lemma 2, the clauses in
sat0 (Fv ,  |v ) are precisely the clauses in (sat0 (Fc1 ,  |c1 )  sat0 (Fc2 ,  |c2 )) \ (v).
expectation of a triple (C1 , C2 , C 0 ) of PS-sets, when  meets the expectation of the implicit
three pairs on each of their respective cuts. We notice that for each choice of triples of
PS-sets (Cc1 , Cc2 , Cv0 ) Procedure 3 computes the implicit three other sets and names them
Cc0 1 , Cc0 2 and Cv accordingly.
We will now show that for all pairs (C, C 0 )  PS0 (Fv )  PS0 (Fv ) the value of Tabv (C, C 0 )
is correct. Let 0 be an assignment over var(F ) that satisfies the maximum number of
clauses, while meeting the expectation of C and C 0 . Thus, the value of Tabv (C, C 0 ) is correct
if and only if it stores exactly the number of clauses from (v) that 0 satisfies.
Let (C1 , C10 ) and (C2 , C20 ) be the pairs of PS-sets that 0 meet the expectation of for the
cut ((c1 ), (c1 )) and ((c2 ), (c2 )), respectively. As 0 meets these expectations, the value
of Tabc1 (C1 , C10 ) and Tabc2 (C2 , C20 ) must be at least as large as the number of clauses 0
satisfies in (c1 ) and (c2 ), respectively. Thus, the number of clauses 0 satisfies in both
(c1 ) and (c2 ) is at most as large as the sum of these two entries. Since Procedure 3, in
the iteration where Cv0 = C 0 , Cc1 = C1 and Cc2 = C2 , ensures that Tabv (C, C 0 ) is at least
the sum of Tabc1 (C1 , C10 ) and Tabc2 (C2 , C20 ), we know Tabv (C, C 0 ) is at least as large as the
correct value.
Now assume for contradiction that the value of the cell Tabv (C, C 0 ) is too large. That
means that at some iteration of Procedure 3 it is being assigned the value Tabc1 (Cc1 , Cc0 1 ) +
Tabc2 (Cc2 , Cc0 2 ) when this sum is too large. Let 1 and 2 be the assignments of var(F )
meeting the expectation of Cc1 and Cc0 1 and meeting the expectation of Cc2 , Cc0 2 , respectively,
where the number of clauses of (c1 ) and (c2 ), respectively, equals the according table
entries of Tabc1 and Tabc2 . If we now take the assignment x = 1 |c1 ] 2 |c2 ] 0 |v , we have
an assignment that meets the expectation of C and C 0 , and who satisfies more clauses in
(v) than 0 , contradicting the choice of 0 . So Tabv (C, C 0 ) can be neither smaller nor larger
than the number of clauses in (v) 0 satisfies, so it is exactly the same.
Theorem 2. Given a formula F over n variables and m clauses, and a branch decomposition
(T, ) of F of ps-width k, we solve MaxSAT, #SAT, and weighted MaxSAT in time
O(k 3 m(m + n)).
Proof. To solve MaxSAT, we first compute Tabr for the root node r of T . This requires
that we first compute PS0 (Fv ) and PS0 (Fv ) for all nodes v of T , and then, in a bottom up
manner, compute Tabv for each of the O(m + n) nodes in T . The former part we can do in
71

fiSther, Telle & Vatshelle

O(k 2 m(m + n)) time by Theorem 1, and the latter part we do in O(k 3 m(m + n)) time by
Lemma 2.
At the root r of T we have (r) = var(F )  cla(F ). Thus Fr =  and Fr does not have
any variables, so that P S(Fr )  P S(Fr ) contains only (, ). As all assignments over var(F )
meet the expectation of  and  on the cut ((r), (r)), and cla(F )  (r) = cla(F ), by
Constraint (1) the value of Tabr (, ) is the maximal number of clauses in F any assignment
of var(F ) satisfies. And hence, this number is the solution to MaxSAT.
For a weight function w : cla(F )  N, by redefining Constraint (1) for Tabv to maximize
w(sat0 (F,  )  (v)) instead of |sat0 (F,  ))(v)|, we are able to solve the more general
problem weighted MaxSAT in the same way.
For the problem #SAT, we care only about assignments satisfying all the clauses of
F , and we want to decide the number of distinct assignments doing so. This requires a
few alterations. Firstly, alter the definition of the contents of Tabv (C, C 0 ) in Constraint
(1) to be the number of assignments  over var(F )  (v) where sat0 (Fv ,  ) = C and all
clauses in (v) is either in C 0 or satisfied by  . Secondly, when computing Tabl for the
leaves l of T , we set each of the entries of Tabl to either zero, one, or two, according to the
definition. Thirdly, we alter the algorithm to compute Tabv (Procedure 3) for inner nodes.
We initialize Tabv (C, C 0 ) to be zero at the start of the algorithm, and substitute lines 6 and
7 of Procedure 3 by the following line which increases the table value by the product of the
table values at the children
Tabv (Cv , Cv )  Tabv (Cv , Cv ) + Tabc1 (Cc1 , Cc1 )  Tabc2 (Cc2 , Cc2 )
This will satisfy our new constraint of Tabv for internal nodes v of T . The value of Tabr (, )
at the root r of T will be exactly the number of distinct assignments satisfying all clauses of
F.
The bottleneck giving the cubic factor k 3 in the runtime of Theorem 2 is the number
triples in PS0 (Fv )  PS0 (Fc1 )  PS0 (Fc2 ) for any node v with children c1 and c2 . When (T, ) is
a linear branch decomposition, it is always the case that either c1 or c2 is a leaf of T . In this
case either |PS0 (Fc1 )| or |PS0 (Fc2 )| is a constant. Therefore, for linear branch decompositions
PS0 (Fv )  PS0 (Fc1 )  PS0 (Fc2 ) will contain no more than O(k 2 ) triples. Thus we can reduce
the runtime of the algorithm by a factor of k.
Theorem 3. Given a formula F over n variables and m clauses, and a linear branch
decomposition (T, ) of F of ps-width k, we solve #SAT, MaxSAT, and weighted MaxSAT
in time O(k 2 m(m + n)).

4. CNF Formulas of Polynomial ps-width
In this section we investigate classes of CNF formulas having decompositions with ps-width
polynomially bounded in the total size s of the formula. In particular, we show that this
holds whenever the incidence graph of the formula has constant mim-width (maximum
induced matching-width, introduced in Vatshelle, 2012). We also show that a large class of
bipartite graphs, using what we call bigraph bipartizations, have constant mim-width.
72

fiSolving #SAT and MaxSAT by Dynamic Programming

In order to lift the upper bound of Lemma 1 on the ps-value of F , i.e |PS(F )|, to the
ps-width of F , we use mim-width of the incidence graph I(F ), which is defined using branch
decompositions of graphs. A branch decomposition of the formula F , as defined in Section
2, can also be seen as a branch decomposition of the incidence graph I(F ). Nevertheless, for
completeness, we formally define branch decompositions of graphs and mim-width.
A branch decomposition of a graph G is a pair (T, ) where T is a rooted binary tree
and  a bijection between the leaf set of T and the vertex set of G. For a node w of T
let the subset of V (G) in bijection  with the leaves of the subtree of T rooted at w be
denoted by Vw . We say the decomposition defines the cut (Vw , Vw ). The mim-value of a cut
(Vw , Vw ) is the size of a maximum induced matching of G[Vw , Vw ]. The mim-width of (T, )
is the maximum mim-value over all cuts (Vw , Vw ) defined by a node w of T . The mim-width
of graph G, denoted mimw(G), is the minimum mim-width over all branch decompositions
(T, ) of G. As before a linear branch decomposition is a branch decomposition where inner
nodes of the underlying tree induces a path.
Since a decomposition of I(F ) of can be seen also as a decomposition of F , we immediately
get from Lemma 1 the following corollary.
Corollary 1. For any CNF formula F over m clauses, with no clause containing more than
t literals, the ps-width of F is at most min{mk + 1, 2tk } for k = mimw(I(F )).
Many classes of graphs have intersection models, meaning that they can be represented
as intersection graphs of certain objects, i.e. each vertex is associated with an object and
two vertices are adjacent iff their objects intersect. The objects used to define intersection
graphs usually consist of geometrical objects such as lines, circles or polygons. Many well
known classes of intersection graphs have constant mim-width, as in the following which
lists only a subset of the classes proven to have such bounds (Belmonte & Vatshelle, 2013;
Vatshelle, 2012).
Theorem 4. (Belmonte & Vatshelle, 2013; Vatshelle, 2012) Let G be a graph. If G is a:
interval graph then mimw(G)  1.
circular arc graph then mimw(G)  2.
k-trapezoid graph then mimw(G)  k.
Moreover there exist linear decompositions satisfying the bound, that can be found in polynomial time (for k-trapezoid assume the intersection model is given).
Let us briefly mention the definition of these graph classes. A graph is an interval graph
if it has an intersection model consisting of intervals of the real line. A graph is a circular arc
graph if it has an intersection model consisting of arcs of a circle. To build a k-trapezoid we
start with k parallel line segments (s1 , e1 ), (s2 , e2 ), ..., (sk , ek ) and add two non-intersecting
paths s and e by joining si to si+1 and ei to ei+1 respectively by straight lines for each
i  {1, ..., k  1}. The polygon defined by s and e and the two line segments (s1 , e1 ), (sk , ek )
forms a k-trapezoid. A graph is a k-trapezoid graph if it has an intersection model consisting
of k-trapezoids. See the work of Brandstadt, Le, and Spinrad (1999) for information about
graph classes and their containment relations.
Combining Corollary 1 and Theorem 4 we get the following
Corollary 2. Let F be a CNF formula containing m clauses with maximum clause-size t.
If I(F ) is a:
73

fiSther, Telle & Vatshelle

interval graph then psw(F )  min{m + 1, 2t }.
circular arc graph then psw(F )  min{m2 + 1, 4t }.
k-trapezoid graph then psw(F )  min{mk + 1, 2tk }.
Moreover there exist linear decompositions satisfying the bound, that can be found in polynomial time (for k-trapezoid assume the intersection model is given).
The incidence graphs of formulas are bipartite graphs, which is not the case for the
majority of graphs in the above-mentioned graph classes. In the following we show how to
extend the results of Corollary 2 to large classes of bipartite graphs. For a graph G and
subset of vertices A  V (G) the bipartite graph G[A, A] is the subgraph of G containing all
edges of G with exactly one endpoint in A. For any graph G and A  V (G) we call G[A, A]
a bigraph bipartization of G, and note that G has a bigraph bipartization for each subset of
vertices. For a graph class X we define the class of X bigraphs as the bipartite graphs H for
which there exists G  X such that H is isomorphic to a bigraph bipartization of G. For
example, a bipartite graph H is an interval bigraph if there is some interval graph G and
some A  V (G) with H isomorphic to G[A, A].
The following result will allow us to lift the results of Corollary 2 from the given graphs
to the bigraph bipartizations of the same graphs.
Theorem 5. Assume that we are given a CNF formula F of m clauses and maximum
clause-size t, a graph G, a subset A  V (G), and (T, G ) a (linear) branch decomposition
of G of mim-width k. If I(F ) is connected and isomorphic to G[A, A] (thus I(F ) a bigraph
bipartization of G) then we can in linear time produce a (linear) branch decomposition (T, F )
of F having ps-width at most min{mk + 1, 2tk }
Proof. Since each variable and clause in F has a corresponding node in I(F ), and each node
in I(F ) has a corresponding node in G, by defining F to be the function mapping each leaf
l of T to the variable or clause in F corresponding to the node G (l), we get that (T, F ) is
a branch decomposition of F . Consider a cut (B, B) induced by a node of (T, F ). Note
that the mim-value of G[B, B] is at most k. I(F ) is connected which means that we have
either A or A corresponding to the set of variables of F . Assume wlog the former. Thus
C = A  B  cla(F ) are the clauses in B, with C = cla(F ) \ C and X = A  B  var(F )
are the variables in B, with X = var(F ) \ X. The mim-values of G[C, X] and G[C, X] are
at most k, since these are induced subgraphs of G[B, B], and taking induced subgraphs
cannot increase the size of the maximum induced matching. Hence by Lemma 1, we have
|PS(FC,X )|  |cla(F )|k + 1, and likewise we have |PS(FC,X )|  |cla(F )|k + 1, with the
maximum of these two being the ps-value of this cut. Since the ps-width of the decomposition
is the maximum ps-value of each cut the theorem follows.
Combining Theorems 5 and 4 we immediately get the following.
Corollary 3. Let F be a CNF formula containing m clauses with maximum clause-size t.
If I(F ) is a:
interval bigraph then psw(F )  min{m + 1, 2t }.
circular arc bigraph then psw(F )  min{m2 + 1, 4t }.
k-trapezoid bigraph then psw(F )  min{mk + 1, 2tk }.
Moreover there exist linear decompositions satisfying the bound.
74

fiSolving #SAT and MaxSAT by Dynamic Programming

In the next section we address the question of finding such linear decompositions in
polynomial time. We succeed in the case of interval bigraphs, but for circular arc bigraphs
and k-trapezoid bigraphs we must leave this as an open problem.

5. Interval Bigraphs and Formulas Having Interval Orders
We will in this section show that for formulas whose incidence graph is an interval bigraph
we can in polynomial time find linear branch decompositions having small ps-width. Let
us recall the definition of interval ordering. A CNF formula F has an interval ordering if
there exists a linear ordering of variables and clauses such that for any variable x occurring
in clause C, if x appears before C then any variable between them also occurs in C, and
if C appears before x then x occurs also in any clause between them. See Figure 4 for an
example.
Order:
x1 c 1 x2 x3 c 2 c 3 x4 x5

Clauses:

Bipartized interval rep.

Incidence graph

x1
c1
x2
x3
c2
c3
x4
x5

c1 = {x1 , x2 }
c2 = {x2 , x3 , x5 }
c3 = {x3 , x4 , x5 }

c1

x1

c2 c3

x2 x3

x4 x5

Figure 4: A CNF formula having an interval ordering. Its incidence graph is an interval
bigraph, since it is isomorphic to the bigraph bipartization, defined by the blue
intervals, of the interval graph with intersection model on the left.
From the work of Hell and Huang (2004) it follows that a formula F has an interval ordering
if and only if I(F ) is a interval bigraph.
Theorem 6. Given a CNF formula F over n variables and m clauses each of at most t
literals. In time O((m + n)mn) we can decide if F has an interval ordering (yes iff I(F ) is
an interval bigraph), and if yes we solve #SAT and weighted MaxSAT with an additional
runtime of O(min{m2 , 4t }(m + n)m).
Proof. Using the characterization in the work of Hell and Huang (2004) and the algorithm
of Rafiey (2012) we can in time O((m + n)mn) decide if F has an interval ordering and if
yes, then we find it. From this interval ordering we build an interval graph G such that I(F )
is a bigraph bipartization of G, and construct a linear branch decomposition of G having
mim-width 1 (Belmonte & Vatshelle, 2013). From such a linear branch decomposition we
75

fiSther, Telle & Vatshelle

get from Theorem 5 that we can construct another linear branch decomposition of F having
ps-width O(m). We then run the algorithm of Theorem 3.

6. Experimental Results
We present some simple experimental results, intended as proof of concept. It is our belief
that some of the ideas behind our algorithms, like the notion of ps-value, are useful in
practice, but it will require a thorough investigation to confirm such a belief. Our results
indicate that the worst-case runtime bounds of the dynamic programming, Theorems 2 and
3, are probably higher than what would commonly be seen in practice.
In the past decade, SAT solvers have become very powerful, and are currently able
to handle very large practical instances. Techniques from these SAT solvers have been
applied to develop relatively powerful MaxSAT and #SAT solvers (Biere, Heule, & van
Maaren, 2009). In our experiments we compare implementations of our algorithms against
state-of-the-art MaxSAT and #SAT solvers. We do not enhance our implementations with
any other techniques, not even simple pre-processing, and on the vast majority of instances
our implementations fall far behind in a comparison. However, when focusing on formulas
with a certain linear order our implementations compare favorably.
As explained in Section 1, there are two steps involved: (1) find a good decomposition
of the input CNF formula F , and (2) perform DP (dynamic programming) along the
decomposition. Let us start by describing a very simple heuristic for step (1). It takes
as input the bipartite graph I(F ) with vertex set cla(F )  var(F ), and outputs a linear
order  on the vertex set. The below heuristic GreedyOrder is a greedy algorithm that
for increasing values of i chooses (i) to be a vertex having the highest number of already
chosen neighbors, and among these choosing one with fewest non-chosen neighbors. This
defines a linear branch decomposition (T, ) of the CNF formula F , with non-leaf nodes
of the binary tree T inducing a path, with T rooted at one end of this path, and with 
mapping the ith leaf encountered by a breadth-first search starting at the root of T to the
clause or variable (i), for all 1  i  |cla(F )  var(F )|.

Algorithm GreedyOrder
input: G = (V, E), a (bipartite) graph
output: , a linear ordering of V
L = , R = V , i = 1
for all v  V set Ldegree(v) = 0
while R is not empty do
choose v: from vertices in R with max Ldegree take one of smallest degree
set (i) = v, increment i, add v to L and remove v from R
for all w  R with vw  E increment Ldegree(w)

76

fiSolving #SAT and MaxSAT by Dynamic Programming

All our implementations can be found online (Sther, Telle, & Vatshelle, 2015). We
have implemented GreedyOrder in Java, together with a straight-forward implementation of
the DP algorithm of Theorem 3.
Given a CNF formula, this allows us to solve MaxSAT and #SAT by first running
GreedyOrder and then the DP. We compare our implementation to the best solvers we could
find online, respectively CCLS-to-akmaxsat (Luo, Cai, Wu, Jie, & Su, 2014) which was
among the best solvers of the Ninth Max-SAT Evaluation (2014), and the latest version of
the #SAT solver called sharpSAT (Thurley, n.d., 2006). These solvers handily beat our
implementation on most inputs. We have therefore generated some CNF formulas having
interval orderings, as in Theorem 6, to check if at least on these instances we do better.
Note that for step (1) we have not implemented the polynomial-time algorithm recognizing
formulas having interval orders, relying instead on the GreedyOrder heuristic.
6.1 Generation of Instances
Before presenting our results, let us describe the generation of the set of instances, which
are of three types. We start with type 1. The generation of these formulas is based on the
definition of interval orderings given by the interval bigraph definition, see e.g. the left side
of Figure 4. To generate a formula of type 1 with n variables and m clauses, we generate
n + m intervals of the real line by iterating through points i from 1 to 2(n + m) as left and
right endpoints of the intervals:
 At step i, check which of the 4 cases below are legal (e.g. 3 is legal if there exists a
live variable, i.e. with left endpoint < i and no right endpoint) and randomly make
one of those legal choices:
1. start interval of new variable with left endpoint i
2. start interval of new clause with left endpoint i
3. end interval of randomly chosen live variable by right endpoint i
4. end interval of randomly chosen live clause by right endpoint i
Towards the end of the process boundary conditions are enforced to reach exactly m
clauses, with n expected to be slightly smaller than m. For each clause interval we randomly
choose each variable having overlapping interval as being either positive or negative in this
clause. The resulting CNF formula will have an interval ordering given by the rightmost
endpoints of intervals. To hide this ordering the clauses and variables are randomly permuted
to make the final CNF formula.
The formulas of type 2 are generated in a very similar fashion as type 1, except we
guarantee that all clauses have the same size t, which by Lemma 1 could be of big help. The
only change is to case 4 above which instead of being a choice becomes enforced for a live
clause that at step i has accumulated exactly t overlapping variable intervals. We also let
each clause interval represent 4 clauses over the same variable set but on randomly chosen
literals, at the aim of increasing the probability of each instance not being satisfiable.
The formulas of type 3 are the CNF-representation of a conjunction of XOR functions
where each XOR has a fixed number t of literals and the variables of the XOR functions
77

fiSther, Telle & Vatshelle

overlap in such a way that the incidence graph will be the bipartization of a circular arc
graph.
A formula of type 3 is generated from three input parameters n, t, s. It has n variables
represented by successive points 1 to n on the circle. The first XOR function has interval
from 1 to t thus containing variables with points 1 to t, the second has interval s + 1 to s + t,
and in general the ith has interval i  s + 1 to i  s + t, with appropriate modulo addition
and some boundary condition at the end to ensure n/s XOR functions. Variables are chosen
randomly to appear positive or negative in each XOR. Each XOR is then transformed in
the standard way to a CNF formula with 2t1 clauses to give us a resulting CNF formula
with n/s  2t1 clauses. Again, variables and clauses are randomly permuted to hide the
ordering giving the circular arc bigraph representation.
Note that all the resulting formulas have a quite simple structure, and that a state-ofthe-art SAT solver, like lingeling (Biere, 2014), handles all generated instances within a
few seconds.
6.2 Results
We are now ready to present our results. We ran all the solvers on a Dell Optiplex 780
running Ubuntu 12.04 64-Bit. The machine has 8GB of memory and an Intel Core 2 Quad
Q9650 processor with OpenJDK java 6 (IcedTea6 1.13.5).
For instances of type 1 the GreedyOrder heuristic fails terribly and becomes a huge
bottleneck. The greedy choice based on degrees of vertices in I(F ) is too simple. However,
when given the correct interval order to our solver(s) they performed better.
Instances of type 2 are generated similar to those of type 1 but all clauses have small size,
which by Lemma 1 could be of help. In this case the number of clauses is approximately

Runtime in seconds

600

400

CCLS
sharpSAT
our MaxSAT
and #SAT
(practically equal)

200

0
0

1000
2000
Number of variables

3000

Figure 5: Runtimes of instances of type 2. Here our MaxSAT solver is clearly faster than
CCLS to akmaxsat. The vertical axis represents time in seconds. Runs taking
more than 600 seconds were stopped before completion and are drawn on the
dotted line.

78

fiSolving #SAT and MaxSAT by Dynamic Programming

four times the number of variables, and as a consequence a great number of the instances
were not satisfiable, making the work of the #SAT-solvers easier than that of the MaxSAT
solvers. All generated instances of type 2 were solved within seconds by sharpSAT, see
Figure 5. As the size of the instances grow, we see a clear tendency for the runtimes of
CCLS to akmaxsat to increase much more rapidly than both our solvers. The runtimes of
our two solvers were almost identical. The GreedyOrder heuristic on these instances seems
to produce decompositions/orders of low PS-width.
The type 3 instances shown in Figure 6 were generated with k = 5 and s = 3. All
instances are satisfiable, which may explain why CCLS to akmaxsat is very fast. Choosing
k = 3 and s = 2 there will be some not satisfiable instances and CCLS to akmaxsat would
then often spend more than 600 seconds and time out. As the size of the instances grow, we
see a clear tendency for the runtimes of sharpSAT to increase much more rapidly than our
solvers. The runtimes of our two solvers were almost identical.

Runtime in seconds

600

400

CCLS
sharpSAT
our MaxSAT
and #SAT
(practically equal)

200

0
60

80
100
120
Number of variables

140

Figure 6: Runtimes of instances of type 3. Here our #SAT solver is clearly faster than
sharpSAT. The vertical axis represents time in seconds. Runs taking more than
600 seconds were stopped before completion and are drawn on the dotted line.

7. Conclusion
In this paper we have proposed a structural parameter of CNF formulas, called ps-width
or projection-satisfiable-width. We showed that weighted MaxSAT and #SAT can be
solved in polynomial time if given a decomposition of the formula of polynomially bounded
ps-width. Using the concept of interval bigraphs we also showed a polynomial time algorithm
that actually finds such a decomposition, for formulas having an interval ordering. Could
one devise such an algorithm also for the larger class of circular arc bigraphs, or maybe
even for the even larger class of k-trapezoid bigraphs? In other words, is the problem of
recognizing if a bipartite input graph is a circular arc bigraph, or a k-trapezoid bigraph,
polynomial-time solvable?
79

fiSther, Telle & Vatshelle

It could be of practical interest to design a heuristic algorithm which given a formula finds
a decomposition of relatively low ps-width, as has been done for boolean-width (Hvidevold,
Sharmin, Telle, & Vatshelle, 2011). One could then check if benchmarks covering real-world
SAT instances have low ps-width, and perform a study on the correlation between low
ps-width and their practical hardness by MaxSAT and #SAT solvers, as has been done
for treewidth and SAT solvers (Mateescu, 2011). We presented some simple experimental
results, but it will require a thorough investigation to check if ideas from our algorithms
could be useful in practice. Finally, we hope the essential combinatorial result enabling the
improvements in this paper, Lemma 1, may have other uses as well.

References
Bacchus, F., Dalmao, S., & Pitassi, T. (2003). Algorithms and complexity results for#SAT
and bayesian inference. In Foundations of computer science, 2003. proceedings. 44th
annual ieee symposium on (pp. 340351).
Belmonte, R., & Vatshelle, M. (2013). Graph classes with structured neighborhoods and
algorithmic applications. Theor. Comput. Sci., 511 , 54-65.
Biere, A. (2014). Yet another local search solver and lingeling and friends entering the SAT
competition 2014. SAT Competition 2014 , 39.
Biere, A., Heule, M., & van Maaren, H. (2009). Handbook of satisfiability. In (Vol. 185,
chap. 20). IOS Press.
Brandstadt, A., Le, V. B., & Spinrad, J. P. (1999). Graph classes: A survey (Vol. 3).
Philadelphia: SIAM Society for Industrial and Applied Mathematics.
Brandstadt, A., & Lozin, V. V. (2003). On the linear structure and clique-width of bipartite
permutation graphs. Ars Comb., 67 .
Brault-Baron, J., Capelli, F., & Mengel, S. (2014). Understanding model counting for
-acyclic CNF-formulas. CoRR, abs/1405.6043 . Retrieved from http://arxiv.org/
abs/1405.6043
Bui-Xuan, B.-M., Telle, J. A., & Vatshelle, M. (2010). H-join decomposable graphs and
algorithms with runtime single exponential in rankwidth. Discrete Applied Mathematics,
158 (7), 809-819.
Bui-Xuan, B.-M., Telle, J. A., & Vatshelle, M. (2011). Boolean-width of graphs. Theoretical
Computer Science, 412 (39), 51875204.
Courcelle, B. (2004). Clique-width of countable graphs: a compactness property. Discrete
Mathematics, 276 (1-3), 127148. Retrieved from http://dx.doi.org/10.1016/S0012
-365X(03)00303-0 doi: 10.1016/S0012-365X(03)00303-0
Darwiche, A. (2001). Recursive conditioning. Artificial Intelligence, 126 (1), 541.
Fischer, E., Makowsky, J. A., & Ravve, E. V. (2008). Counting truth assignments of
formulas of bounded tree-width or clique-width. Discrete Applied Mathematics, 156 (4),
511-529.
80

fiSolving #SAT and MaxSAT by Dynamic Programming

Fredkin, E. (1960). Trie memory. Communications of the ACM , 3 (9), 490499.
Ganian, R., Hlineny, P., & Obdrzalek, J. (2013). Better algorithms for satisfiability problems
for formulas of bounded rank-width. Fundam. Inform., 123 (1), 59-76.
Garey, M. R., & Johnson, D. S. (1979). Computers and intractability: A guide to the theory
of NP-completeness. W. H. Freeman.
Hell, P., & Huang, J. (2004). Interval bigraphs and circular arc graphs. Journal of Graph
Theory, 46 (4), 313-327.
Hvidevold, E. M., Sharmin, S., Telle, J. A., & Vatshelle, M. (2011). Finding good
decompositions for dynamic programming on dense graphs. In D. Marx & P. Rossmanith
(Eds.), Ipec (Vol. 7112, p. 219-231). Springer.
Jaumard, B., & Simeone, B. (1987). On the complexity of the maximum satisfiability
problem for Horn formulas. Inf. Process. Lett., 26 (1), 1-4.
Kaski, P., Koivisto, M., & Nederlof, J. (2012). Homomorphic hashing for sparse coefficient
extraction. In Proceedings of the 7th international conference on parameterized and
exact computation (pp. 147158).
Luo, C., Cai, S., Wu, W., Jie, Z., & Su, K. (2014). CCLS: An efficient local search
algorithm for weighted maximum satisfiability. IEEE Transactions on Computers. doi:
10.1109/TC.2014.2346195
Mateescu, R. (2011). Treewidth in industrial SAT benchmarks (Tech. Rep.). Tech. rep.
Cambridge, UK: Microsoft Research. Retrieved from http://research.microsoft
.com/pubs/145390/MSR-TR-2011-22.pdf
Muller, H. (1997). Recognizing interval digraphs and interval bigraphs in polynomial time.
Discrete Applied Mathematics, 78 (1-3), 189-205.
Ninth Max-SAT Evaluation. (2014). Retrieved from http://www.maxsat.udl.cat/14/
(accessed 16-January-2015)
Paulusma, D., Slivovsky, F., & Szeider, S. (2013). Model counting for CNF formulas of
bounded modular treewidth. In N. Portier & T. Wilke (Eds.), Stacs (Vol. 20, p. 55-66).
Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik.
Rafiey, A. (2012).
abs/1211.2662 .

Recognizing interval bigraphs by forbidden patterns.

CoRR,

Raman, V., Ravikumar, B., & Rao, S. S. (1998). A simplified NP-complete MAXSAT
problem. Inf. Process. Lett., 65 (1), 1-6.
Rao, M. (2008). Clique-width of graphs defined by one-vertex extensions. Discrete
Mathematics, 308 (24), 61576165.
Robertson, N., & Seymour, P. D. (1991). Graph minors X. obstructions to tree-decomposition.
J. COMBIN. THEORY SER. B , 52 (2), 153190.
Roth, D. (1996). A connectionist framework for reasoning: Reasoning with examples. In

81

fiSther, Telle & Vatshelle

W. J. Clancey & D. S. Weld (Eds.), Aaai/iaai, vol. 2 (p. 1256-1261). AAAI Press /
The MIT Press.
Sther, S. H., Telle, J. A., & Vatshelle, M. (2014). Solving MaxSAT and #SAT on
structured CNF formulas. In C. Sinz & U. Egly (Eds.), SAT 2014 (Vol. 8561, pp. 16
31). Springer. Retrieved from http://dx.doi.org/10.1007/978-3-319-09284-3 3
doi: 10.1007/978-3-319-09284-3 3
Sther, S. H., Telle, J. A., & Vatshelle, M. (2015). online implementations. Retrieved from
http://people.uib.no/ssa032/pswidth/
Samer, M., & Szeider, S. (2010). Algorithms for propositional model counting. J. Discrete
Algorithms, 8 (1), 50-64.
Slivovsky, F., & Szeider, S. (2013). Model counting for formulas of bounded clique-width. In
L. Cai, S.-W. Cheng, & T. W. Lam (Eds.), Isaac (Vol. 8283, p. 677-687). Springer.
Szeider, S. (2003). On fixed-parameter tractable parameterizations of SAT. In E. Giunchiglia
& A. Tacchella (Eds.), Sat 2003 (Vol. 2919, p. 188-202). Springer.
Thurley, M. (n.d.). sharpSAT. Retrieved from https://sites.google.com/site/
marcthurley/sharpsat (accessed 16-January-2015)
Thurley, M. (2006). sharpSATcounting models with advanced component caching and
implicit BCP. In Theory and applications of satisfiability testing-sat 2006 (pp. 424429).
Springer.
Vatshelle, M. (2012). New width parameters of graphs. Unpublished doctoral dissertation,
The University of Bergen.

82

fi