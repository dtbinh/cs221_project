Journal of Artificial Intelligence Research 54 (2015) 193231

Submitted 6/15; published 10/15

Expressiveness of Two-Valued Semantics for
Abstract Dialectical Frameworks
Hannes Strass

strass@informatik.uni-leipzig.de

Computer Science Institute, Leipzig University
Augustusplatz 10, 04109 Leipzig, Germany

Abstract
We analyse the expressiveness of Brewka and Woltrans abstract dialectical frameworks
for two-valued semantics. By expressiveness we mean the ability to encode a desired set
of two-valued interpretations over a given propositional vocabulary A using only atoms
from A. We also compare ADFs expressiveness with that of (the two-valued semantics of)
abstract argumentation frameworks, normal logic programs and propositional logic. While
the computational complexity of the two-valued model existence problem for all these
languages is (almost) the same, we show that the languages form a neat hierarchy with
respect to their expressiveness. We then demonstrate that this hierarchy collapses once we
allow to introduce a linear number of new vocabulary elements. We finally also analyse and
compare the representational succinctness of ADFs (for two-valued model semantics), that
is, their capability to represent two-valued interpretation sets in a space-efficient manner.

1. Introduction
More often than not, different knowledge representation languages have conceptually similar and partially overlapping intended application areas. What are we to do if faced with
an application and a choice of several possible knowledge representation languages which
could be used for the application? One of the first axes along which to compare different
formalisms that comes to mind is computational complexity: if a language is computationally too expensive when considering the problem sizes typically encountered in practice,
then this is a clear criterion for exclusion. But what if the available language candidates
have the same computational complexity? If their expressiveness in the computationalcomplexity sense of What kinds of problems can the formalism solve? is the same, we
need a more fine-grained notion of expressiveness. In this paper, we use such a notion and
study the expressiveness of abstract dialectical frameworks (ADFs) (Brewka & Woltran,
2010; Brewka, Ellmauthaler, Strass, Wallner, & Woltran, 2013), a recent generalisation of
abstract argumentation frameworks (AFs) (Dung, 1995).
Argumentation frameworks are the de-facto standard formalism in abstract argumentation, a field that studies how (abstract) arguments relate to each other in terms of directed
conflicts (attacks), and how these conflicts can be resolved without looking into the
arguments. While AFs are popular and well-studied, it has been noted many times in the
literature that their expressive capabilities are somewhat limited. This has only recently
been made technically precise by Dunne, Dvorak, Linsbichler, and Woltran (2014, 2015),
who basically showed that introducing new, purely technical arguments is sometimes inevitable when using AFs for representation purposes. However, due to their very nature,
the dialectical meaning of such technical arguments might be  ironically  debatable.
c
2015
AI Access Foundation. All rights reserved.

fiStrass

Not surprisingly, quite a number of generalisations of AFs have been proposed (for an
overview we refer to Brewka, Polberg, & Woltran, 2014). As one of the most general AF
alternatives, the aforementioned abstract dialectical frameworks (ADFs) have emerged. In
that formalism, not only arguments (called statements there) are abstract, but also links
between arguments. While in AFs the links are necessarily attacks, in ADFs each statement
has an associated acceptance condition  a Boolean function over its parent statements
 that specifies exactly when the statement can be accepted. In this way, acceptance
conditions ultimately express the meaning of links in an ADF. Even the restricted subclass
of bipolar ADFs  where intuitively all links are supporting or attacking  is a proper
generalisation of AFs, and a quite expressive one as we shall see in this paper.
ADFs could be called the lovechild of AFs and logic programs, since they combine
intuitions and semantics from Dung-style abstract argumentation as well as logic programming (Brewka et al., 2013; Strass, 2013; Alviano & Faber, 2015). While on the abstract
level, ADFs are intended to function as argumentation middleware  a sufficiently expressive target formalism for translations from more concrete (application) formalisms. As
part of the ADF success story, we just mention a reconstruction of the Carneades model
of argument (Brewka & Gordon, 2010), an instantiation of simple defeasible theories into
ADFs (Strass, 2015a), and recent applications of ADFs for legal reasoning and reasoning
with cases by Al-Abdulkarim, Atkinson, and Bench-Capon (2014, 2015).
In this paper, we approach abstract dialectical frameworks as knowledge representation
formalisms, since they are used to represent knowledge about arguments and relationships
between these arguments. We employ this view to analyse the representational capabilities
of ADFs. Due to their roots in AFs and logic programs, we also compare the representational capabilities of those formalisms in the same setting. In this initial study we restrict
ourselves to looking at two-valued semantics, more specifically the ADF (stable) model semantics, which corresponds to AF stable extension semantics, and the supported and stable
model semantics for logic programs. We add propositional logic to have a well-known reference point. Analysing these precise formalisms additionally makes sense to us because the
computational complexity of their respective model existence problems is the same (with
one exception):
 for AFs, deciding stable extension existence is NP-complete (Dimopoulos, Nebel, &
Toni, 2002);
 for normal logic programs, deciding the existence of supported/stable models is NPcomplete (Bidoit & Froidevaux, 1991; Marek & Truszczynski, 1991);
 for ADFs, deciding the existence of (supported) models is NP-complete (Brewka
et al., 2013), deciding the existence of stable models is P2 -complete for general
ADFs (Brewka et al., 2013) and NP-complete for the subclass of bipolar ADFs (Strass
& Wallner, 2015);
 the propositional satisfiability problem is NP-complete.
In view of these almost identical complexities, we use an alternative measure of the
expressiveness of a knowledge representation formalism F: Given a set of two-valued
interpretations, is there a knowledge base in F that has this exact model set? This notion
194

fiExpressiveness of Two-Valued Semantics for ADFs

lends itself straightforwardly to compare different formalisms (Gogic, Kautz, Papadimitriou,
& Selman, 1995):
Formalism F2 is at least as expressive as formalism F1 if and only if every
knowledge base in F1 has an equivalent knowledge base in F2 .
So here expressiveness is understood in terms of realisability, What kinds of model sets
can the formalism express? (In model theory, this is known as definability.)
It is easy to see that propositional logic can express any set of two-valued interpretations,
it is universally expressive. The same is easy (but less easy) to see for normal logic programs
under supported model semantics. For normal logic programs under stable model semantics,
it is clear that not all model sets can be expressed, since two different stable models are
always incomparable with respect to the subset relation.1 In this paper, we study such
expressiveness properties for all the mentioned formalisms under different semantics. It
turns out that the languages form a more or less strict expressiveness hierarchy, with AFs
at the bottom, ADFs and LPs under stable semantics higher up and ADFs and LPs under
supported model semantics at the top together with propositional logic.
To show that a language F2 is at least as expressive as a language F1 we will mainly
use two different techniques. In the best case, we can use a syntactic compact and faithful
translation from knowledge bases of F1 to those of F2 . Compact means that the translation
does not change the vocabulary, that is, does not introduce new atoms. Faithful means that
the translation exactly preserves the models of the knowledge base for respective semantics
of the two languages. In the second best case, we assume the knowledge base of F1 to be
given in the form of a set X of desired models and construct a semantic realisation of X
in F2 , that is, a knowledge base in F2 with model set precisely X. To show that language
F2 is strictly more expressive than F1 , we additionally have to present a knowledge base kb
from F2 of which we prove that F1 cannot express the model set of kb.
Analysing the expressiveness of argumentation formalisms is a quite recent strand of
work. Its ascent can be attributed to Dunne et al. (2014, 2015), who studied realisability
for argumentation frameworks (allowing to introduce new arguments as long as they are
never accepted). Likewise, Dyrkolbotn (2014) analysed AF realisability under projection
(allowing to introduce new arguments) for three-valued semantics. Baumann, Dvorak, Linsbichler, Strass, and Woltran (2014) studied the expressiveness of the subclass of compact
AFs, where each argument is accepted at least once. Finally, and most recently, Puhrer
(2015) analysed the realisability of three-valued semantics for ADFs. Previous more preliminary works include that of Brewka, Dunne, and Woltran (2011), who translated ADFs
into AFs for the ADF model and AF stable extension semantics, however this translation
introduces additional arguments and is therefore not compact; and ours (Strass, 2013),
where we studied the syntactic intertranslatability of ADFs and LPs, but did not look at
expressiveness or realisability.
The gain that is achieved by our analysis in this paper is not only that of increased
clarity about fundamental properties of these knowledge representation languages  What
can these formalisms express, actually?  but has several further applications. As Dunne
et al. (2015) remarked, a major application is in constructing knowledge bases with the aim
1. However, the stable model semantics becomes universally expressive once we allow nested expressions of
the form not not p in rule bodies (Lifschitz, Tang, & Turner, 1999; Lifschitz & Razborov, 2006).

195

fiStrass

of encoding a certain model set. As a necessary prerequisite to this, it must be known that
the intended model set is realisable in the first place. For example, in a recent approach to
revising argumentation frameworks (Coste-Marquis, Konieczny, Mailly, & Marquis, 2014),
the authors avoid this problem by assuming to produce a collection of AFs whose model sets
in union produce the desired model set. While the work of Dunne et al. (2015) showed that
this is indeed necessary in the case of AFs and stable extension semantics, our work shows
that for ADFs under the model semantics, a single knowledge base (ADF) is always enough
to realise any given model set. What is more, if we assume that the intended model set is
given in the form of a propositional formula, then the size of the realising ADF is at most
linear in the size of the formula. This is only one example  we will on several occasions
also consider the sizes of realisations, as is not uncommon in logic-based AI (Darwiche &
Marquis, 2002; Lifschitz & Razborov, 2006; French, van der Hoek, Iliev, & Kooi, 2013; Shen
& Zhao, 2014). Indeed, representation size is a fundamental practical aspect of knowledge
representation languages: universal expressiveness is of little use if the model sets to express
require exponential-size knowledge bases even in the best case!
Of course, the fact that the languages we study have the same computational complexity
means that there in principle exist polynomial intertranslations for the respective decision
problems. But such intertranslations may involve the introduction of a polynomial number
of new atoms. In theory, an increase from n atoms to nk atoms for some k > 1 is of
no consequence. In practice, it has a profound impact: the number n of atoms directly
influences the search space that any implementation potentially has to cover. There, a step
from 2n to
 k1 n
k
k1
2n = 2n n = 2n
amounts to an exponential increase in search space size. Being able to realise a model set
compactly, without new atoms, therefore attests that a formalism F has a certain basic
kind of efficiency property, in the sense that the F-realisation of a model set does not
unnecessarily enlarge the search space of algorithms operating on it.
It might seem that it is a restricting assumption to view formalisms as sets F of knowledge bases kb where F is associated with a two-valued semantics. However, this language
representation model is universal in the sense that it is just another way of expressing languages as sets of words over {0, 1}. Using an n-element vocabulary An = {a1 , . . . , an }, a binary word w = x1 x2    xn of length n is encoded as the set Mw = {ai  An | xi = 1}  An .
For example, using the vocabulary A3 = {a1 , a2 , a3 }, the binary word 101 of length 3 corresponds to the set M101 = {a1 , a3 }. Consequently, a set Ln of words of length n can
be represented by a set XLn  2An of subsets of An : XLn = {Mw | w  Ln }. With the
above example vocabulary, the word set L3 = {101, 110, 011} is represented by the model
set XL3 = {{a1 , a3 } , {a1 , a2 } , {a2 , a3 }}. Conversely, each sequence (Xn )n0 of sets with
S
Xn  2An uniquely determines a language L = n0 Ln over {0, 1}: for each n  N, we
have Ln = {wM | M  Xn } with wM = x1 x2    xn where for each i  {1, . . . , n}, xi = 1 if
ai  M and xi = 0 if ai 
/ M . In this paper we use language to refer to object-level
languages while formalism refers to meta-level languages, such as propositional logic,
argumentation frameworks, abstract dialectical frameworks, and logic programs.
Formally, the syntax of ADFs is defined via Boolean functions. However, we are interested in representations of ADFs. So we have to fix a representation of ADFs via fixing
196

fiExpressiveness of Two-Valued Semantics for ADFs

a representation of Boolean functions. We choose to use (unrestricted) propositional formulas, as is customary in most of the literature (Brewka & Woltran, 2010; Brewka et al.,
2013; Polberg et al., 2013; Polberg, 2014; Gaggl & Strass, 2014; Linsbichler, 2014; Strass &
Wallner, 2015; Puhrer, 2015; Gaggl, Rudolph, & Strass, 2015). Exceptions to this custom
are the works of Brewka et al. (2011), who use Boolean circuits, and one of ours (Strass,
2013) where we used characteristic models (that is, used a representation that is equivalent
to representing the formulas in disjunctive normal form). For the subclass of bipolar ADFs,
yet no uniform representation exists, which is another question we address in this paper.
By propositional formulas over a vocabulary A we mean formulas over the Boolean
basis {, , }, that is, trees whose leaves (sinks) are atoms from A or the logical constants
true > or false , and internal nodes are either unary () or binary (,). We also make
occasional use of Boolean circuits, where trees above is replaced by directed acyclic
graphs; in particular, we allow unbounded fan-in, that is, reusing sub-circuits. As usual,
the depth of a formula (circuit) is the length of the longest path from the root to a leaf
(sink). Figure 1 below shows formula and circuit examples of depth 3.



p



















q

p

q

p

q

Figure 1: Representing (p  q)  (q  p) as a formula tree (left) and a circuit (right).

Analysing the expressive power and representation size of Boolean circuits is an established sub-field of computational complexity (Arora & Barak, 2009). This has led to a
number of language classes whose members can be recognised by Boolean circuits satisfying
S
certain restrictions. We will need the class AC0 , which contains all languages L = n0 Ln
for which there exist d, k  N such that for each n  N, there exists a Boolean circuit Cn of
depth at most d and size at most nk where the models of Cn exactly express Ln .2 In other
words, every language L  AC0 can be recognised by a family of polynomial-size Boolean
circuits of a fixed maximal depth that is independent of word length.
The paper proceeds as follows. We first define the notion of expressiveness (and succinctness) formally and then introduce the formalisms we will study. After reviewing several
intertranslatability results for these languages, we step-wise obtain the results that lead to
the expressiveness hierarchy, while at times also looking at representational efficiency. We
finally show that allowing to linearly expand the vocabulary leads to a collapse of the
hierarchy. The paper concludes with a discussion of possible future work.

2. To be more precise, for each n  N, the models of Cn are exactly XLn , which in turn expresses Ln .

197

fiStrass

2. Background
We presume a finite set A of atoms (statements, arguments), the vocabulary. A knowledge
representation formalism interpreted over A is then some set F; a (two-valued) semantics
A
for F is a mapping  : F  22 that assigns sets of two-valued models to knowledge bases
kb  F. (So A is implicit in .) Strictly speaking, a two-valued interpretation is a mapping
from the set of atoms into the two truth values true and false, but for technical ease we
represent two-valued interpretations by the sets containing the atoms that are true. Below,
we write (F) = {(kb) | kb  F}; intuitively, (F) is the set of interpretation sets that
formalism F can express, with any knowledge base whatsoever. For example, for F = PL
A
propositional logic and  = mod the usual model semantics, we have (PL) = 22 since
obviously any set of models is realisable in propositional logic.3 This leads us to compare
different pairs of languages and semantics with respect to the semantics range of models.
Our concept of formalism concentrates on semantics and decidedly remains abstract. We
first define the expressiveness relation among formalisms.
Definition 1. Let A be a finite vocabulary, F1 , F2 be formalisms that are interpreted over
A
A
A and 1 : F1  22 and 2 : F2  22 be two-valued semantics. We define
F11 e F22

iff

1 (F1 )  2 (F2 )

Intuitively, formalism F2 under semantics 2 is at least as expressive as formalism F1 under
semantics 1 , because all model sets that F1 can express under 1 are also contained in
those that F2 can produce under 2 . (If the semantics are clear from the context we will
omit them; this holds in particular for argumentation frameworks and propositional logic,
where we only look at a single semantics.) As usual,
 F1 <e F2 iff F1 e F2 and F2 6e F1 ;
 F1 
=e F2 iff F1 e F2 and F2 e F1 .
The relation e is reflexive and transitive by definition, but not necessarily antisymmetric.
That is, there might different formalisms F1 6= F2 that are equally expressive: F1 
=e F2 .
We next introduce the succinctness relation as defined by Gogic et al. (1995).
Definition 2. Let A be a finite vocabulary; let F1 and F2 be formalisms that are interpreted over A, have size measures kk1 and kk2 , and two-valued semantics 1 and 2 ,
respectively. Define F11 s F22 if and only if there is a k  N such that for all kb1  F1 with
1 (kb1 )  1 (F1 )  2 (F2 ), there is a kb2  F2 with 1 (kb1 ) = 2 (kb2 ) and kkb2 k2  kkb1 kk1 .
Intuitively, F11 s F22 means that F2 under 2 is at least as succinct as F1 under 1 .
Put another way, for F11 s F22 to hold, any knowledge base from F1 with an equivalent
counterpart in F2 must have an equivalent counterpart that is at most polynomially larger.
Note that succinctness talks only about those model sets that both can express, so it is
most meaningful when comparing languages that are equally expressive, that is, whenever
3. For a set X  2A we can simply define X =
mod (X ) = X.

W

M X

198

M with M =

V

aM

a

V

aA\M

a and clearly

fiExpressiveness of Two-Valued Semantics for ADFs

1 (F1 ) = 2 (F2 ). As usual, we define F1 <s F2 iff F1 s F2 and F2 6s F1 , and F1 
=s F2
iff F1 s F2 and F2 s F1 . The relation s is reflexive, but not necessarily antisymmetric
or transitive.
The final general definition is about formalisms polynomially expressing languages.
Here, we already make use of the previously introduced bijection between interpretations
and binary words and use the term languages to synonymously refer to both.
S
Definition 3. A formalism F can polynomially express a language L = n0 Ln under
A

semantics  : F  22 if and only if there is a k  N such that for each positive n  N there
is a knowledge base kbn  F of that formalism such that (kbn ) = Ln and kkbn k  O(nk ).
We next introduce some specific object-level languages that we will use. First of all,
the language Parity contains all odd-element subsets of the vocabulary. Formally, for
An = {a1 , . . . , an } with n  1 we have
Parityn = {M  An | m  N : |M | = 2m + 1}
S
As explained before, then Parity = nN,n1 Parityn . It is a textbook result that Parity
is expressible by polynomial-size propositional formulas (Jukna, 2012); for example, we can
define Parity
(a1 ) = a1 and for n  2 set
1
Parity
(a1 , . . . , an ) = (Parity
(a1 , . . . , an )  Parity
(an +1 , . . . , an )) 
n
n
n
(Parity
(a1 , . . . , an )  Parity
(an +1 , . . . , an ))
n
n
 
 
with n = n2 and n = n2 . (This construction yields a formula of logarithmic depth and
therefore polynomial size.) It is also a textbook result (although not nearly as easy to
see) that Parity cannot be expressed by depth-bounded polynomial-size circuits, that is,
Parity 
/ AC0 (Jukna, 2012).
As another important class, threshold languages are defined for n, k  N with n  1 and
k  n:
Thresholdn,k = {M  An | k  |M |}
That is, Thresholdn,k contains
 all interpretations over n atoms where at least k atoms
are true. The special case k = n2 leads to the majority languages,
Majorityn = Thresholdn,d n e
2

that contain all interpretations where at least half of the atoms in the vocabulary are true.
We next introduce the particular knowledge representation languages we study in this
paper. All will make use of a vocabulary A; the results of the paper are all considered
parametric in such a given vocabulary.
2.1 Logic Programs
For a vocabulary A we define not A = {not a | a  A} and accordingly the set of literals over
A as A = A  not A. A normal logic program rule over A is then of the form a  B where
a  A and B  A . The set B is called the body of the rule, we abbreviate B + = B  A and
199

fiStrass

B  = {a  A | not a  B}. A logic program (LP) P over A is a set of logic program rules
over A. An interpretation M  A satisfies the body B of a rule a  B  P iff B +  M and
B   M = . M is a supported model for P iff M = {a  A | a  B  P, M satisfies B}.
For a logic program P we denote the set of its supported models by su(P ). The intuition
behind this semantics is that the atoms that are true in a model are all and only those that
have some kind of support.
However, this support might be cyclic self-support. For instance, the logic program
{a  {a}} has two supported models,  and {a}, where the latter is undesired in many
application domains. As an alternative, Gelfond and Lifschitz (1988) proposed the stable
model semantics, that does not allow self-support: A set M  A is a stable model for P iff
M is the -least supported model of P M , where P M is obtained from P by (1) eliminating
each rule whose body contains a literal not a with a  M , and (2) deleting all literals of
the form not a from the bodies of the remaining rules (Gelfond & Lifschitz, 1988). We
write st(P ) for the set of stable models of P . It follows from the definition that st(P )
is a -antichain: for all M1 6= M2  st(P
P) we have M1 6 M2 . As size measure we define
ka  Bk = |B| + 1 for rules and kP k = rP krk for programs.
As an example, consider the vocabulary A = {a, b, c} and over it the logic program
P = {a  {b} , b  {a} , c  {not a}}. We find su(P ) = {{c} , {a, b}} and st(P ) = {{c}}.
2.2 Argumentation Frameworks
Dung (1995) introduced argumentation frameworks as pairs F = (A, R) where A is a set
of (abstract) arguments and R  A  A a relation of attack between the arguments. The
purpose of semantics for argumentation frameworks is to determine sets of arguments (called
extensions) which are acceptable according to various standards. For a given extension
S  A, the arguments in S are considered to be accepted, those that are attacked by
some argument in S are considered to be rejected, and all others are neither, their status is
undecided. We will only be interested in so-called stable extensions, sets S of arguments that
do not attack each other and attack all arguments not in the set. For stable extensions, each
argument is either accepted or rejected by definition, thus the semantics is two-valued. More
formally, a set S  A of arguments is conflict-free iff there are no a, b  S with (a, b)  R.
A set S is a stable extension for (A, R) iff it is conflict-free and for all a  A \ S there is an
argument b  S with (b, a)  R. For an AF F , we denote the set of its stable extensions by
st(F ). Again, it follows from the definition of a stable extension that the set st(F ) is always
a -antichain. The size of an argumentation framework F = (A, R) is kF k = |A| + |R|.
For example, the AF F = ({a, b, c} , {(a, b), (b, a), (b, c)}) can be visualised using the
c and has the set of stable extensions st(F ) = {{a, c} , {b}}.
b
directed graph a
2.3 Abstract Dialectical Frameworks
An abstract dialectical framework is a tuple D = (A, L, C) where A is a set of statements
(representing positions one can take or not take in a debate), L  A  A is a set of links
(representing dependencies between the positions), C = {Ca }aA is a collection of total
functions Ca : 2par (a)  {t, f }, one for each statement a  A. The function Ca is called
acceptance condition of a and expresses whether a can be accepted, given the acceptance
200

fiExpressiveness of Two-Valued Semantics for ADFs

status of its parents par (a). In this paper, we represent each Ca by a propositional formula
a over par (a). As mentioned earlier, propositional formulas are built using negation ,
conjunction  and disjunction ; connectives for material implication , logical equivalence
 and exclusive disjunction = are regarded as abbreviations. To specify an acceptance
condition, then, we take Ca (M  par (a)) = t to hold iff M is a model for a , M |= a .
Brewka and Woltran (2010) introduced a useful subclass of ADFs: an ADF D = (A, L, C)
is bipolar iff all links in L are supporting or attacking (or both). A link (b, a)  L is supporting in D iff for all M  par (a), we have that Ca (M ) = t implies Ca (M  {b}) = t.
Symmetrically, a link (b, a)  L is attacking in D iff for all M  par (a), we have that
Ca (M  {b}) = t implies Ca (M ) = t. If a link (b, a) is both supporting and attacking then
b has no influence on a, the link is redundant (but does not violate bipolarity). We will
sometimes use this circumstance when searching for ADFs; there we simply assume that
L = A  A, then links that are actually not needed can be expressed by acceptance conditions that make them redundant.
There are numerous semantics for ADFs; we will only be interested in two of them,
(supported) models and stable models. A set M  A is a model of D iff for all a  A
we find that a  M iff Ca (M ) = t. The definition of stable models is inspired by logic
programming and slightly more complicated (Brewka et al., 2013). Define an operator by4
D (X, Y ) = (ac(X, Y ), re(X, Y )) for X, Y  A, where
ac(X, Y ) = {a  A | Z  A : X  Z  A \ Y  Ca (Z) = t}
re(X, Y ) = {a  A | Z  A : X  Z  A \ Y  Ca (Z) = f }
The intuition behind the operator is as follows: A pair (X, Y ) represents a partial interpretation of the set of statements where those in X are accepted (true), those in Y are rejected
(false), and those in A \ (X  Y ) are neither. The operator checks for each statement a
whether all total interpretations that can possibly arise from (X, Y ) agree on their truth
value for the acceptance condition of a. That is, if a has to be accepted no matter how the
statements in A \ (X  Y ) are interpreted, then a  acc(X, Y ). The set rej (X, Y ) is defined
symmetrically, so the pair (acc(X, Y ), rej (X, Y )) constitutes a refinement of (X, Y ).
For M  A, the reduced ADF DM = (M, LM , C M ) is defined by LM = L  M  M and
for each a  M setting M
/ M ], that is, replacing all b 
/ M by false in the
a = a [b/ : b 
acceptance formula of a. A model M for D is a stable model of D iff the least fixpoint of the
operator DM is given by (M, ). As usual, su(D) and st(D) denote the respective model
sets; while ADF models can be
P-related, ADF stable models cannot. The size of an ADF
D over A is given by kDk = aA ka k; the size kk of a formula  is the number of its
nodes.
As an example ADF D, consider vocabulary A = {a, b, c} and the acceptance formulas
a = c, b = c, and c = a  b. While D has a single supported model, su(D) = {{a, b, c}},
we find st(D) =  since the atoms in the model support each other circularly.
2.4 Translations Between the Formalisms
We will review all known translations between the mentioned formalisms.
4. This operator is closely related to the ultimate approximation operators of Denecker, Marek, and
Truszczynski (2004), as we observed earlier (Strass, 2013).

201

fiStrass

2.4.1 From AFs to BADFs
Brewka and Woltran (2010) showed how to translate AFs into ADFs: For an AF FV= (A, R),
define the ADF associated to F as DF = (A, R, C) with C = {a }aA and a = (b,a)R b
for a  A. Clearly, the resulting ADF is bipolar: parents are always attacking. Brewka
and Woltran proved that this translation is faithful for the AF stable extension and ADF
model semantics (Proposition 1). Brewka et al. (2013) later proved the same for the AF
stable extension and ADF stable model semantics (Theorem 4). It is easy to see that the
translation can be computed in polynomial time and induces at most a linear blowup.
2.4.2 From ADFs to PL
Brewka and Woltran (2010) also showed that ADFs under supported model semantics
can be faithfully translated into propositional logic: when acceptance conditions of statements a  A are represented by propositional formulas a , then the supported models
of an ADF D over A are given by the classical propositional models of the formula set
D = {a  a | a  A}.
2.4.3 From AFs to PL
In combination, the previous two translations yield
and
n a polynomial
V
 fifaithfulotranslation
fi
chain from AFs into propositional logic: (A,R) = a 
(b,a)R b fi a  A .
2.4.4 From ADFs to LPs
In earlier work (Strass, 2013), we showed that ADFs can be faithfully translated into normal
logic programs. For an ADF D = (A, L, C), its standard LP is
PD = {a  (M  not (par (a) \ M )) | a  A, Ca (M ) = t}
It follows from Lemma 3.14 of Strass (2013) that this translation preserves the supported
model semantics. The translation is size-preserving for the acceptance condition representation of Strass (2013) via characteristic models; when representing acceptance conditions
via propositional formulas, this cannot be guaranteed as we will show later.5
2.4.5 From AFs to LPs
The translation chain from AFs to ADFs to LPs is compact, and faithful for AF stable
semantics and LP stable semantics (Osorio, Zepeda, Nieves, & Cortes, 2005), and AF stable
semantics and LP supported semantics (Strass, 2013). It is size-preserving since the single
rule for each atom contains all attackers once: P(A,R) = {a  {not b | (b, a)  R} | a  A}.
5. Already for complexity reasons, we cannot expect that this translation is also faithful for the stable
semantics. And indeed, the ADF D = ({a} , {(a, a)} , {a = a  a}) has a stable model {a} while its
standard logic program P (D) = {a  {a} , a  {not a}} has no stable model. However, it holds that
st(P (D))  st(D) (Denecker et al., 2004; Strass, 2013).

202

fiExpressiveness of Two-Valued Semantics for ADFs

2.4.6 From LPs to PL
It is well-known that logic programs under supported model semantics can be translated to
propositional logic (Clark, 1978). A logic program P becomes the propositional theory P ,


_
^
^

P = {a  a | a  A} where a =
b
b for a  A.
aBP

bB +

bB 

For the stable model semantics, additional formulas have to be added, but the extended
translation works all the same (Lin & Zhao, 2004).
2.4.7 From LPs to ADFs
The Clark completion of a normal logic program directly yields an equivalent ADF over
the same signature (Brewka & Woltran, 2010). Clearly the translation is computable in
polynomial time and the blowup (with respect to the original logic program) is at most
linear. The resulting translation is faithful for the supported model semantics, which follows
from Lemma 3.16 of Strass (2013).
2.5 Representing Bipolar Boolean Functions
While bipolarity has hitherto predominantly been defined and used in the context of
ADFs (Brewka & Woltran, 2010), it is easy to define the concept for Boolean functions in
general. Let A be a set of atoms and f : 2A  {t, f } be a Boolean function. An atom a  A
is supporting iff for all M  A, f (M ) = t implies f (M  {a}) = t; we then write a  sup(f ).
An atom a  A is attacking iff for all M  A, f (M ) = f implies f (M  {a}) = f ; we then
write a  att(f ). A Boolean function f : 2A  {t, f } is semantically bipolar iff each a  A is
supporting or attacking or both. Throughout the paper, we will sometimes take a Boolean
function to be given by an interpretation set and then say that the set is bipolar.
We will now define bipolar propositional formulas for representing bipolar ADFs. This
is important not only for our study, but also since (for three-valued semantics), bipolarity is
the key to BADFs low complexity in comparison to general ADFs (Strass & Wallner, 2015).
Up to now, we usually assumed that to specify a bipolar ADF, in addition to statements,
links and acceptance conditions, the user specifies for each link whether it is supporting
or attacking (Strass & Wallner, 2015). Here we introduce an arguably simpler way, where
support and attack is represented in the syntax of the propositional formula encoding the
acceptance function.
Formally, the polarity of an atom a  A in a formula is determined by the number of
negations on the path from the root of the formula tree to the atom. The polarity is positive
if the number is even and negative if the number is odd.
Definition 4. A propositional formula  over A is syntactically bipolar if and only if no
atom a  A occurs both positively and negatively in .
Recall that we only use formulas over the basis {, , } and thus there are no hidden
negations, e.g. from material implication. For formulas in negation normal form (that is,
where negation is only applied to atomic formulas), the polarities of the atoms can be read
off the formula directly.
203

fiStrass

We will now address the question how to represent bipolar Boolean functions. Clearly all
Boolean functions can be represented by propositional formulas; we modify this construction
later and thus reproduce it here: for a Boolean function f : 2A  {t, f }, its associated
formula is
^
^
_
a
(1)
M with M =
a
f =
aM

M A,f (M )=t

aA\M

That is, each M has exactly one model M , and f enumerates those models.
So in particular, all bipolar Boolean functions can be represented by propositional formulas as well. However, this only guarantees us the existence of such representations but
gives us no way to actually obtain them. Our first fundamental result shows how we can
construct a syntactically bipolar propositional formula from a given semantically bipolar
Boolean function. The converse is straightforward, and thus the two notions of bipolarity
are closely related. For a formula , its associated Boolean function f returns t if and only
if it gets as input a model of .
Theorem 1. Let A be a set of atoms.
1. For each syntactically bipolar formula  over A, its Boolean function f is semantically
bipolar.
2. For each semantically bipolar Boolean function f : 2A  {t, f }, a syntactically bipolar
formula f with ff = f is given by
f =

_

M

with M =

M A,
f (M )=t

^
aM,
aatt(f
/
)

a

^

a

(2)

aA\M,
asup(f
/
)

Proof.
1. Obvious: every atom occurring only positively is supporting, every atom occurring only negatively is attacking.
2. Let f : 2A  {t, f } be semantically bipolar. Note first that by (2), for any M  A
we have |= M  M . It is easy to see that f is syntactically bipolar: Since f
is semantically bipolar, each a  A is: (1) attacking and not supporting, then it
occurs only negatively in f ; or (2) supporting and not attacking, then it occurs only
positively in f ; or (3) supporting and attacking, then it does not occur in f . It
remains to show that ff = f ; we show |= f  f .
|= f  f : Let v : A  {t, f } with v(f ) = t. Then there is an M  A such that
f (M ) = t and v(M ) = t. (Clearly v = vM .) By |= M  M we get v(M ) = t
and thus v(f ) = t.
|= f  f : For each model v of f , there is an M  A with f (M ) = t such that
v(M ) = t. To show that each model of f is a model of f , we show that for
all M  A with f (M ) = t, each model v of M is a model of f . Let |A| = n.
Then each M contains exactly n literals. For the corresponding M there is
a k  N with 0  k  n such that M contains exactly n  k literals. For two
204

fiExpressiveness of Two-Valued Semantics for ADFs

interpretations v1 : A  {t, f } and v2 : A  {t, f }, define the difference between
them as (v1 , v2 ) = {a  A | v1 (a) 6= v2 (a)}. (Note that for |A| = n we always
have |(v1 , v2 )|  n.) We will use induction on k to show the following: for each
M  A with f (M ) = t, each v : A  {t, f } with v(M ) = t and |(v, vM )| = k
we find that v(f ) = t. This covers all models v of f (since |(v, vM )|  |A|)
and thus establishes the claim.
k = 0: (v, vM ) =  implies v = vM whence v(f ) = vM (f ) = vM (M ) = t by
definition of M and f .
k
k + 1: Let M  A with f (M ) = t, and v : A  {t, f } with v(M ) = t and
|(v, vM )| = k + 1. Since k + 1 > 0, there is some a  (v, vM ), that is, an
a  A with v(a) 6= vM (a).
(a) a is supporting and not attacking. Then necessarily v(a) = t. (If v(a) = f ,
then vM (a) 6= v(a) implies vM (a) = t, that is, a  M whence {M } |= a
and v(M ) = f , contradiction.) Define the interpretation w : A  {t, f }
such that w(a) = f and w(c) = v(c) for c  A \ {a}. Clearly (v, w) = {a}
and |(w, vM )| = k. Hence the induction hypothesis applies to w and
w(f ) = t. Now w(a) = f , v(a) = t and w(f ) = t. Since a is supporting, also v(f ) = t.
(b) a is attacking and not supporting. Symmetric to the opposite case above.
(c) a is both supporting and attacking. Define interpretation w : A  {t, f }
such that w(a) = vM (a) and w(c) = v(c) for c  A \ {a}. It follows
that |(w, vM )| = k, whence the induction hypothesis applies to w and
w(f ) = t. Since a is both supporting and attacking (thus redundant),
we get that v(f ) = w(f ) = t.

This result paves the way for analysing the succinctness of bipolar ADFs, since now we
have a quite natural way of representing them.

3. Relative Expressiveness
We now analyse and compare the relative expressiveness of argumentation frameworks
(AFs), (bipolar) abstract dialectical frameworks ((B)ADFs), normal logic programs (LPs)
and propositional logic (PL). We first look at the different families of semantics  supported
and stable models  in isolation and afterwards combine the results for the two semantics.
For the formalisms F  {ADF, LP} that have both supported and stable semantics, we will
indicate the semantics  via a superscript as in Definition 1. For AFs we only consider the
stable semantics, as this is (to date) the only semantics for AFs where all interpretations are
guaranteed to map all arguments to either true (accepted) or false (rejected, i.e. attacked by
an accepted argument). For propositional logic PL we consider the usual model semantics.
With the syntactic translations we reviewed in the previous section, we currently have
the following expressiveness relationships. For the supported semantics,
AF e BADFsu e ADFsu 
=e LPsu e PL
and for the stable semantics,
205

fiStrass

AF e LPst <e PL and AF e BADFst e ADFst <e PL
Note that LPst <e PL and ADFst <e PL hold since sets of stable models have an antichain
property, in contrast to model sets of propositional logic.
For the succinctness relation, we have
AF s BADFsu s ADFsu s PL and LPsu s ADFsu
3.1 Supported Semantics
As depicted above, we know that expressiveness from AFs to propositional logic does not
decrease. However, it is not yet clear if any of the relationships is strict. In what follows
we will show that two of them are strict, working our way top-down from most to least
expressive.
3.1.1 ADF vs. PL
We first show that ADFs can realise any set of models by showing how a given propositional
formula can be used to construct an equivalent ADF of linear size.6
Theorem 2. PL e ADFsu and PL s ADFsu .
Proof. Let  be a propositional formula over vocabulary A. Define the ADF D over A by
setting, for all a  A,
a = a   = (a  )  (a  )
Thus ka k  O(kk), whence kD k  O(|A|  kk). It remains toVshow su(D ) = mod ().
Recall that for any ADF D over A, su(D) = mod (D ) for D = aA (a  a ). Applying
the definition of a in D yields
V
D = aA (a  (a  ))
Now for any a  A, the formula (a  (a  ))Vis equivalent to . (The proof is by case
distinction on a.) Thus D is equivalent to aA , that is, to , and it follows that
su(D ) = mod (D ) = mod ().

For example, consider the vocabulary A = {a, b} and the propositional formula  = a  b.
The canonical construction above yields ADF D with acceptance formulas a = a  (a  b)
and b = b  (a  b). Now we have:
a = a  (a  b) = (a  (a  b))  ((a  b)  a)  a  (a  b)  a  b
Intuitively, a = a  b expresses that a cannot be false, and is true if b is true. By a
symmetrical argument, the acceptance formula of b is equivalent to b  a. It is readily
checked that su(D ) = {{a, b}} as desired. Since we know from Section 2.4.2 that the
converse translation is also possible (ADFsu s PL), we get the following.
Corollary 3. PL 
=s ADFsu
6. If we consider the vocabulary A to be part of the input, the size increase is quadratic.

206

fiExpressiveness of Two-Valued Semantics for ADFs

When the acceptance conditions are written as propositional formulas, the construction to
realise X  2A in the proof of Theorem 2 defines a space-efficient equivalent of
_
_
M
a =
M 
M X,aM

M A,M X,a
/
M
/

as acceptance formula of a, where M is as in Footnote 3.
3.1.2 ADF vs. LP
Since ADFs under supported semantics can be faithfully translated into logic programs,
which can be likewise further translated to propositional logic, we have the following.
Corollary 4. ADFsu 
=e LPsu 
=e PL
However, this does not extend to the succinctness relation, as logic programs stipulate a
particular syntactic form that is essentially a fixed-depth circuit. More specifically, it is
easy to see that any language that is polynomially expressible by normal logic programs
under supported semantics is in AC0 . For the stable semantics of so-called canonical logic
programs, this has recently been shown by Shen and Zhao (2014) (Proposition 2.1). The
case we are interested in (supported semantics) works similarly, but we still present the
proof for completeness. The main technical result towards proving that is a lemma showing
how to turn a logic program into an equivalent Boolean circuit of a fixed depth.
Lemma 5. For every normal logic program P , there exists a circuit CP over the basis
{, , } such that:
1. CP accepts all and only the supported models of P ,
2. the size of CP is linear the size of P ,
3. CP has depth 4.
Proof. Let A = {a1 , . . . , an } be the vocabulary of P , and its Clark completion be P =
{ai  i | ai  A} where
V the i are DNFs over literals from A. Clearly the circuit for P
must compute CP = ai A (ai  i ) where ai  i can be replaced by (ai i )(ai i )
with i a CNF over literals from A. The construction can be depicted as follows, where
the inner layers are shown for one i only, and dotted lines represent potential edges.

i  ai

...

i


...



a1

a1

...







ai  i
...



ai

ai
207

...

...



an

an

fiStrass

Now (1) follows since su(P ) = mod (P ) and CP accepts all and only the models of P .
For (2), if P contains m = |P | rules, then m  kP k and the total number of inner gates is
bounded by n(2m + 3)  n(2  kP k + 3). (3) is clear.

While the statement of Lemma 5 is actually much stronger and gives a constant upper
bound of the resulting circuit depth for arbitrarily-sized logic programs, it readily follows
that the set of polynomially logic-program expressible languages is a subset of the languages
expressible by alternating Boolean circuits with unbounded fan-in and constant depth.
Proposition 6. If L is polynomially expressible by normal logic programs under supported
semantics, then L  AC0 .
It follows immediately that normal logic programs cannot polynomially express the
language Parity.7 This is the supported-semantics counterpart of Theorem 3.1 in (Shen
& Zhao, 2014).
Corollary 7. Parity has no polynomial size normal logic program representation.
Proof. By Proposition 6 and Parity 
/ AC0 (Jukna, 2012).



It follows that propositional logic is strictly more succinct than normal logic programs
under supported semantics.
Corollary 8. PL 6s LPsu and thus LPsu <s PL.
From our considerations since Theorem 2, it follows that if  has a small conjunctive
normal form (a conjunction of clauses) and disjunctive normal form (disjunction of monomials) representation, then there is also a small normal logic program representation for
mod ().
3.1.3 ADF vs. BADF
It is quite obvious that the canonical ADF constructed in Theorem 2 is not bipolar, since
a as well as every atom mentioned by  occurs both positively and negatively in a . This
raises the question whether the construction can be adapted to bipolar ADFs.
It turns out that the subclass of bipolar ADFs is strictly less expressive. Towards the
proof of this result we start out with a new concept: that of the conjugate of a model set
with respect to an atom. This concept will be used to characterise ADF realisability and
precisely captures the if-and-only-if part of ADFs supported model semantics: From the
translation of an ADF D into propositional logic V
(cf. Section 2.4.2) we can see that the result
is basically a conjunction of equivalences: D = aA (a  a ). While the conjunction part
will be captured by set intersection, the conjugate will capture the equivalence part.
Definition 5. Let A be a vocabulary, X  2A and a  A. The a-conjugate of X is the set
hai(X) = {M  A | M  X, a  M }  {M  A | M 
/ X, a 
/ M}
7. Logic programs under supported models are universally expressive, so they can express Parity, just not
in polynomial size.

208

fiExpressiveness of Two-Valued Semantics for ADFs

Alternatively, we could write hai(X) = {M  A | M  X  a  M }. Intuitively, hai(X)
contains all interpretations M where containment of a in M coincides exactly with containment of M in X. Formulated in terms of propositional formulas, if X is the model set of
formula  over A, then hai(X) is the model set of formula a  . Note that the vocabulary
A is implicit in the conjugate function.
Example 1. Consider the vocabulary A2 = {a, b}. The functions hai() and hbi() operate
A
on the set 22 2 of interpretation sets over A2 and are shown in Table 1.


a  b
a  b
a  b
ab
a
b
a
b
a=b
ab
ab
a  b
ab
ba
>

hai()
a
a  b
a  b
a  b
ab
>
ab

a=b
b
b
ba
a  b
ab
ab
a

hbi()
b
a  b
a  b
a  b
ba
ab
>
a=b

a
a
ab
a  b
ab
ab
b

Table 1: Conjugation functions for A2 = {a, b}. Interpretation sets are represented using
formulas over A2 , and connective = denotes exclusive disjunction XOR.
For two-valued ADF semantics, this conjugation function plays an essential semantical
role, since it provides the bridge between models of the acceptance functions and models of
the ADF. But it is also interesting in itself: We first show some properties of the conjugation
function associated to an atom, since some of them will be used in the proof later on. First
of all, it is an involution, that is, its own inverse (and thus in particular a bijection). Next,
it is compatible with the complement operation (logical negation on the formula level).
Finally, it also preserves the evenness of the cardinality of the input set.
Proposition 9. Let A be a vocabulary, X  2A and a  A.
1. hai(hai(X)) = X.

(involution)

2. 2A \ hai(X) = hai 2A \ X .


(compatible with negation)

3. |X| is even iff |hai(X)| is even.

(preserves evenness)

Proof. Let |A| = n, X  2A and a  A.
209

fiStrass

1. Let M  A. We have
M  hai(hai(X)) iff M  hai(X)  a  M
iff (M  X  a  M )  a  M
iff M  X  (a  M  a  M )
iff M  X
2. Denote
S, = {M  A | M  X, a  M }
S,/ = {M  A | M  X, a 
/ M}
S,
= {M  A | M 
/ X, a  M }
/
S,
/ X, a 
/ M}
/
/ = {M  A | M 
and observe that
2A = S, ] S,/ ] S,
/ ] S,
/
/
X = S, ] S,/
hai(X) = S, ] S,
/
/
where ] denotes disjoint union. Now

2A \ hai(X) = 2A \ S, ] S,
/
/
= S,/ ] S,
/
= {M  A | M  X, a 
/ M } ] {M  A | M 
/ X, a  M }
fi
fi

	 
	
A
= M AfiM 
/ 2 \ X, a 
/ M ] M  A fi M  2A \ X, a  M

= hai 2A \ X
3. We show that |X| + |hai(X)| is even. Firstly,
S,/ ] S,
/ M } = 2A\{a}
/
/ = {M  A | a 
fi
fi fi
fi
n1 . Thus
fi
whence fiS,/ fi + fiS,
/
/ =2
fi
fi
fi
fi
fi
|X| + |hai(X)| = |S, | + fiS,/ fi + |S, | + fiS,
/
/
fi
fi fi
fi
fi
= 2  |S, | + fiS,/ fi + fiS,
/
/
= 2  |S, | + 2n1
is even.



For our current purpose of characterising the expressiveness of bipolar ADFs, we now
use the concept of conjugation to make ADF realisability for the model semantics slightly
more accessible. We show that each ADF realisation of a model set X over an n-element
vocabulary A can equivalently be characterised by an n-tuple (Y1 , . . . , Yn ) of supersets of X
whose intersection is exactly X. The crux of the proof of this result is how the acceptance
conditions of the realising ADF and the Yi are related through the conjugation function.
210

fiExpressiveness of Two-Valued Semantics for ADFs

Proposition 10. Let A = {a1 , . . . , an } be a vocabulary and X  2A be a set of interpretations. Denote an ADF over A by the sequence (1 , . . . , n ) of its acceptance formulas (for
each i  {1, . . . , n}, formula i over A is the acceptance formula of ai ), and further define
CX = {(mod (1 ), . . . , mod (n )) | su(1 , . . . , n ) = X}
fi
(
!
)
n
fi
\
fi
YX = (Y1 , . . . , Yn ) fi Y1 , . . . , Yn  2A ,
Yi = X
fi
i=1

The sets CX and YX are in one-to-one correspondence; in particular |CX | = |YX |.
Proof. We provide a bijection between CX and YX . Consider the function
 A n
 A n
with (B1 , . . . , Bn ) 7 (ha1 i(B1 ) , . . . , han i(Bn ))
 22
f : 22
which is an involution by Proposition 9. Using the results of Section 2.4.2, we get that
(mod (1 ), . . . , mod (n ))  CX iff su(1 , . . . , n ) = X


^
iff mod 
(ai  i ) = X
1in

iff

\

mod (ai  i ) = X

1in

iff

\

hai i(mod (i )) = X

1in

iff (ha1 i(mod (1 )) , . . . , han i(mod (n )))  YX
iff f (mod (1 ), . . . , mod (n ))  YX
Thus f (CX ) = YX whence f (YX ) = f (f (CX )) = CX and f |CX : CX  YX is bijective.



This one-to-one correspondence is important since we will later analyse the precise
number of realisations of given model sets. Furthermore, this result shows the role of the
conjugation function for characterising two-valued model realisability for general ADFs. We
can now adapt this characterisation result to the case of bipolar ADFs. More precisely, we
give several necessary and sufficient conditions when a given model set is bipolarly realisable.
With this characterisation in hand, we can later show that a specific interpretation set fails
the necessary conditions and thus cannot be the model set of any BADF.
 Below, fiwe denote
	
the set of all supersets of a set X of interpretation sets over A by X  = Y  2A fi X  Y .
Proposition 11. Let A = {a1 , . . . , an } be a vocabulary and X  2A be a set of interpretations. The following are equivalent:
1. X is bipolarly realisable.
2. there exist Y1 , . . . , Yn  X  such that:
T
(a) ( ni=1 Yi ) = X, and
211

fiStrass

(b) for each 1  i  n, the set hai i(Yi ) is bipolar.
3. there exist Y1 , . . . , Yn  X  such that
T
(a) ( ni=1 Yi ) = X, and
(b) for each 1  i, j  n, at least one of :
 for all M  A, (M  Yi  ai  M )  (M  {aj }  Yi  ai  M  {aj }); or
 for all N  A, (N  Yi = ai  N )  (N  {aj }  Yi = ai  N  {aj }).
Proof. (1)  (2): If X is bipolarly realisable, then there exists a bipolar ADF D = (A, L, C)
with su(D) = X. In particular, there exist bipolar Boolean functions C1 , . . . , Cn such
that M  X if and only if for all 1  i  n we find ai  M iff Ci (M ) = t. For each
1  i  n define YT
i = hai i(Ci ). By assumption, hai i(Yi ) = hai i(hai i(Ci )) = Ci is bipolar; furthermore ( ni=1 Yi ) = X follows from the above.
(2)  (3): Let i  {1, . . . , n} and assume that hai i(Yi ) is bipolar. This means that for all
aj  A, we find that aj is supporting or attacking (or both) in hai i(Yi ). Now aj is
supporting in haj i(Yi ) iff for all M  A we find:
M  hai i(Yi )  M  {aj }  hai i(Yi ) , that is,
(M  Yi  ai  M )  (M  {aj }  Yi  ai  M  {aj })
Similarly, aj is attacking in hai i(Yi ) iff for all N  A we find:
N
/ hai i(Yi )  N  {aj } 
/ hai i(Yi ) , that is,
(N  Yi  ai  N )  (N  {aj }  Yi  ai  N  {aj })
Thus for all aj  A, we find that at least one of the following:
 for all M  A, (M  Yi  ai  M )  (M  {aj }  Yi  ai  M  {aj }); or
 for all N  A, (N  Yi = ai  N )  (N  {aj }  Yi = ai  N  {aj }).
(3)  (1): We construct an ADF D = (A, L, C) as follows: for each i  {1, . . . , n} we define Ci = hai i(Yi ) and finally set L = A  A. Each Ci is bipolar by the equivalences
established in the previous proof item, and su(D) T
= X follows from the fact that
hai i(Ci ) = hai i(hai i(Yi )) = Yi and the presumption ( ni=1 Yi ) = X.


We now apply this characterisation result to show that there is an interpretation set
over three atoms that cannot be realised by bipolar ADFs under the model semantics. This
is the smallest example in terms of the number of atoms (actually, one of the two smallest
examples)  all interpretation sets over a binary vocabulary are bipolarly realisable.
Proposition 12. For vocabulary A3 = {1, 2, 3}, there is no bipolar ADF that realises
X = Even3 = {, {1, 2} , {1, 3} , {2, 3}}.
212

fiExpressiveness of Two-Valued Semantics for ADFs

Proof. Assume to the contrary that X is bipolarly realisable. Then there exist Y1 , Y2 , Y3  X 
A
from Proposition 11. There are 2|2 ||X| = 284 = 24 = 16 candidates for each Yi , that is,
every Yi must be of the form X ] Z with
Z  {{1} , {2} , {3} , {1, 2, 3}} = 2A \ X
For eleven out of those sixteen model set candidates for each Yi , the set hii(Yi ) is not
bipolar. To show that a model set hii(Yi ) is not bipolar, we provide a statement j  A3
that is neither supporting nor attacking; we say that such a statement is dependent.
1. For Y1 = X, we get h1i(Y1 ) = {{1, 2} , {1, 3} , {2} , {3}}, which is not bipolar since
statement 2 is dependent: If 2 was supporting, then {3}  h1i(Y1 ) would imply
{2, 3}  h1i(Y1 ); if 2 was attacking, then  
/ h1i(Y1 ) would imply {2} 
/ h1i(Y1 ). For
the remaining cases, the justifications for a specific statement being dependent are
equally easy to read off the model set; for brevity we just indicate the statements.
2. For Y1 = X  {{1}}, we get h1i(Y1 ) = {{1, 2} , {1, 3} , {1} , {2} , {3}}, which is not
bipolar since statement 2 is dependent.
3. For Y1 = X  {{2}}, we get h1i(Y1 ) = {{1, 2} , {1, 3} , {3}}, which is not bipolar since
statement 2 is dependent.
4. The case Y1 = X  {{3}} is symmetric to the previous one: we get the model set
h1i(Y1 ) = {{1, 2} , {1, 3} , {2}}, which is not bipolar since statement 3 is dependent.
5. For Y1 = X  {{1, 2, 3}}, we get h1i(Y1 ) = {{1, 2, 3} , {1, 2} , {1, 3} , {2} , {3}}, which
is not bipolar since statement 2 is dependent.
6. For Y1 = X  {{1} , {2}}, we get h1i(Y1 ) = {{1, 2} , {1, 3} , {1} , {3}}, which is not
bipolar since statement 3 is dependent.
7. The case Y1 = X  {{1} , {3}} is again symmetric to the previous one.
8. For Y1 = X  {{2} , {3}}, we get h1i(Y1 ) = {{1, 2} , {1, 3}}, which is not bipolar since
statement 2 is dependent.
9. For Y1 = X  {{1} , {1, 2, 3}}, we get h1i(Y1 ) = {{1, 2, 3} , {1, 2} , {1, 3} , {1} , {2} , {3}},
which is not bipolar since statement 2 is dependent.
10. For Y1 = X  {{2} , {1, 2, 3}}, we get h1i(Y1 ) = {{1, 2, 3} , {1, 2} , {1, 3} , {3}}, which
is not bipolar since statement 2 is dependent.
11. Y1 = X  {{3} , {1, 2, 3}} is again symmetric to the previous case.
There remains a set C of five candidates (due to symmetry they are the same for each i):
C = {X ] {{1} , {2} , {3}} ,
X ] {{1} , {2} , {1, 2, 3}} ,
X ] {{1} , {3} , {1, 2, 3}} ,
X ] {{2} , {3} , {1, 2, 3}} ,
X ] {{1} , {2} , {3} , {1, 2, 3}}}
213

fiStrass

Basically, the candidates are those where at least three out of the four interpretations in
D = {{1} , {2} , {3} , {1, 2, 3}} are contained in addition to those already in X. Now clearly
by the assumption that the Yi realise X we have Y
1 , Y2 , Y3 
 C. But then there is some
T3
M  D with M  Yi for all 1  i  3 and thus M 
i=1 Yi = X. However, D  X = .
Contradiction. Thus such Yi do not exist and X is not bipolarly realisable.

As the only other interpretation set over A3 that is not bipolarly realisable, we found
the complement of Even3 above, the Parity language over three atoms.
Proposition 13. For vocabulary A3 = {1, 2, 3}, there is no bipolar ADF that realises
Parity3 = {{1} , {2} , {3} , {1, 2, 3}}.
Together with the straightforward statement of fact that Even3 can be realised by a
non-bipolar ADF, Proposition 12 leads to the next result.
Theorem 14. BADFsu <e ADFsu
Proof. Model set Even3 from Proposition 12 is realisable under model semantics by ADF
DEven3 with acceptance conditions
1 = (2 = 3),

2 = (1 = 3),

3 = (1 = 2)

However, there is no bipolar ADF realising Even3 , as is witnessed by Proposition 12.



Another consequence of our characterisation of two-valued model realisability in Proposition 10 is that we can get a precise number of distinct realisations of a given model set.
This is significant in that it further illustrates the rather intricate difficulty underlying bipolar non-realisability: we cannot necessarily use the model set Even3 above to determine a
single reason for bipolar non-realisability, that is, a single link (b, a) that is neither supporting nor attacking in all realisations. Rather, the culprit(s) might be different in each
realisation, and to show bipolar non-realisability, we have to prove that for all realisations,
there necessarily exists some reason for non-bipolarity. And the number of different ADF
realisations of a given model set X can be considerable.8
A
Proposition
fi A
fi 15. Let A be a vocabulary with |A| = n, and X  2 an interpretation set
with fi2 \ X fi = m. The number of distinct ADFs D with su(D) = X is

r(n, m) = (2n  1)m
Proof. According to Proposition
10,T each realisation
by a tufi of
fi X can be characterised
n
n such tuples.
ple (Y1 , . . . , Yn )  X  with X = ni=1 Yi . Since fiX  fi = 2m , there are (2m )T
However,Ttowards r(n, m), this wrongly counts all tuples (Y1 , . . . , Yn ) with ( ni=1 Yi ) ) X,
that is, |( ni=1 Yi ) \ X| > 0 (at least once); it remains to subtract
any i  {1, . . . , n},
n them. For T
we can overestimate the number of tuples (Y1 , . . . , Yn )  X  such that |( ni=1 Yi ) \ X|  i
by the expression
 
n
m
q(n, m, i) =
2mi
(3)
i
8. When counting ADFs over A, we do not take into account different link relations, but take L = A  A
and only count different acceptance functions, through which redundant links can be modelled.

214

fiExpressiveness of Two-Valued Semantics for ADFs


This is seen as follows: Let I  2A \ X be a fixed i-element set. (Intuitively, the interpretation-set X  I contains
i interpretations too many.)
There are mi such sets.
fi exactly
fi

n
For each such I, we have fiI fi = 2mi . Thus there are 2mi possible ways to choose n
elements (the Y1 , . . . , Yn ) out of I  . No matter how the Yj are chosen, their intersection
contains I and thus has at least i elements too many. However, all sets that have at least
i + 1 elements too many are counted twice and have to be subtracted. If we subtract
q(n, m, i + 1), then we have not counted the sets that have at least i + 2 elements too many
and have to add q(n, m, i + 2),
by the inclusion-exclusion principle, the number
n etc. Hence
T
of tuples (Y1 , . . . , Yn )  X  with ni=1 Yi = X is given by
r(n, m) = q(n, m, 0)  q(n, m, 1) + q(n, m, 2)  . . .  q(n, m, m)
m
X
=
(1)i q(n, m, i)
i=0
m
X

 
n
m
=
(1)
2mi
i
i=0


m
X m
=
(2n )mi (1)i
i
i

(by (3) above)
(reordering factors)

i=0
n

= (2  1)m

(binomial theorem) 

So the main contributing factor is the number m of interpretations that are excluded from
the desired model set X. For Proposition 12, for instance, there are (23  1)4 = 74 = 2401
ADFs with the model set Even3 . According to Theorem 14, none of them is bipolar. Obvin
ously, the maximal number of realisations is achieved by X =  whence r(n, 2n ) = (2n  1)2 .
On the other hand, the model set X = 2A has exactly one realisation, r(n, 0) = 1. Note
that the number of (syntactically distinct) realisations for the other universally expressive
formalisms, logic programs and propositional logic, is unbounded in general since we can
add an arbitrary number of tautologies.
We finally show a reduction of the problem of bipolar realisability to propositional
satisfiability. This approaches the problem from another angle (a possible implementation
deciding bipolar realisability using a SAT solver), and provides the proof of Theorem 3 by
Strass (2015b), which was not contained in that work.
For a given vocabulary A and set X  2A be a set of interpretations, it is our aim
to construct a propositional formula X that is satisfiable if and only if X is bipolarly
realisable. The propositional signature we use is the following: For each a  A and M  A,
there is a propositional variable pM
a that expresses whether Ca (M ) = t. This allows to
encode all possible acceptance conditions for the statements in A. To enforce bipolarity, we
use additional variables to model supporting and attacking links: for all a, b  A, there is
a,b
a variable pa,b
sup saying that a supports b, and a variable patt saying that a attacks b. So the
vocabulary of X is given by
fi
n
o
a,b fi
a,b
P = pM
,
p
,
p
M

A,
a

A,
b

A
fi
a
sup att
To guarantee the desired set of models, we constrain the acceptance conditions as dictated
by X: For any desired set M and statement a, the containment of a in M must correspond
215

fiStrass

exactly to whether Ca (M ) = t; this is encoded in 
X . Conversely, for any undesired set
/
M and statement a, there must not be any such correspondence, which 
X expresses. To
enforce bipolarity, we state that each link must be supporting or attacking. To model the
meaning of support and attack, we encode all ground instances of their definitions.
Definition 6. Let A be a vocabulary and X  2A be a set of interpretations. Define the
following propositional formulas:

/
BADF
= 
X
X  X  bipolar


^
^
^


pM

pM
a
a 
X =
M X

aM

aA\M




^

/

X =

_


M A,M X
/

bipolar =

^ 

_

pM
a 

aM


pM
a

aA\M



a,b
a,b
a,b
pa,b
sup  patt  sup  att



a,bA

a,b
sup

= pa,b
sup 

a,b
att

pa,b
att

^ 



(a, b  A)



(a, b  A)

M {a}

pM
b  pb

M A

=



^ 

M {a}

pb

 pM
b

M A

The corresponding result shows the reduction to be correct.
Theorem 16. Let A be a vocabulary and X  2A be a set of interpretations. X is bipolarly
realisable if and only if BADF
is satisfiable.
X
Proof. if: Let I  P be a model for X . For each a  A, we define an acceptance condition as follows: for M  A, set Ca (M ) = t iff pM
a  I. It is easy to see that bipolar
guarantees that these acceptance conditions are all bipolar. The ADF is now given
su = (A, A  A, C). It remains to show that any M  A is a model of D su if and
by DX
X
only if M  X.
su . Consider any a  A.
if: Let M  X. We have to show that M is a model of DX
M
1. a  M . Since I is a model of 
X , we have pa  I and thus by definition
Ca (M ) = t.
M / I and thus by definition
2. a  A \ M . Since I is a model of 
X , we have pa 
Ca (M ) = f .
/
only if: Let M 
/ X. Since I is a model of 
X , there is an a  M such that
Ca (M ) = f or an a 
/ M such that Ca (M ) = t. In any case, M is not a model of
su .
DX

only if: Let D be a bipolar ADF with su(D) = X. We use D to define a model I for X .
First, for M  A and a  A, set pM
a  I iff Ca (M ) = t. Since D is bipolar, each link
is supporting or attacking and for all a, b  A we can find a valuation for pa,b
sup and
pa,b
.
It
remains
to
show
that
I
is
a
model
for

.
X
att
216

fiExpressiveness of Two-Valued Semantics for ADFs

1. I is a model for 
X : Since D realises X, each M  X is a model of D and thus
for all a  A we have Ca (M ) = t iff a  M .
/
2. I is a model for 
/ X is not a model
X : Since D realises X, each M  A with M 
of D. Thus for each such M , there is an a  A witnessing that M is not a model
of D: (1) a  M and Ca (M ) = f , or (2) a 
/ M and Ca (M ) = t.

3. I is a model for bipolar : straightforward since D is bipolar by assumption.



Remarkably, the decision procedure does not only give an answer, but in the case of a
positive answer we can read off the BADF realisation from the satisfying evaluation of the
constructed formula. We illustrate the construction with an example seen earlier.
Example 2. Consider A3 = {1, 2, 3} and the model set Even3 = {, {1, 2} , {1, 3} , {2, 3}}.
The construction of Theorem 16 yields these formulas:
{1}





Even3 = p1  p2  p3 
{1,2}

 p2

{1,3}

 p2

p1
p1

{1,2}

{2,3}

p1

/

Even3 = (p1
{1,2}



(p1

{1,3}



(p1

 p3

{1,3}

 p3

{2,3}

 p3

 p2

{2,3}

{1}

 p3 ) 

{2}

 p2

{1}

{2}

 p2

 p3 ) 

{3}

 p2

{3}

 p3 ) 

{1,2,3}

(p1

{2}

{3}

{1,2,3}

 p2

{1,2,3}

 p3

)

The remaining formulas about bipolarity are independent of Even3 , we do not show them
here. We have implemented the translation of the proof of Theorem 16 and used the solver
clasp (Gebser, Kaminski, Kaufmann, Ostrowski, Schaub, & Schneider, 2011) to verify that
Even3 is unsatisfiable.
3.1.4 BADF vs. LP
Earlier, we used the language Parity to show that propositional logic is (and thus by
PL 
=s ADFsu general ADFs are) exponentially more succinct than normal logic programs
(under supported models). However, for bipolar ADFs, by Proposition 13 there is no BADF
D over A3 = {1, 2, 3} with model set su(D) = Parity3 = {{1} , {2} , {3} , {1, 2, 3}}, that is,
BADFs cannot even express Parity. Fortunately, the Majority language does the trick
in this case.
Theorem 17. BADFsu 6s LPsu
Proof. We show that the language Majority can be polynomially expressed by BADFsu ,
but not by LPsu . The latter fact follows from Majority 
/ AC0 (Jukna, 2012) and Proposition 6. We show the first part by constructing a series of BADFs Dn over An = {a1 , . . . , an }
(n  N, n  1) such that su(Dn ) = Majorityn . We use results of (Friedman, 1986; Boppana, 1986), who show that for all positive n  N and k  n, the language Thresholdn,k
has negation-free propositional formulas Threshold
of polynomial size s, where we use the
n,k

 
4.27
bound of Boppana, s  O k n log n . Define D1 by a1 = >, and for n  2 set k = n2
and for 1  i  n,
ai = ai  Threshold
(a1 , . . . , ai1 , ai+1 , . . . , an )
n1,k
217

fiStrass

Intuitively, the formula ai checks whether the remaining variables could achieve a majority
without ai . If so, then ai can be set arbitrarily; otherwise, ai must be set to true. Clearly
the Boolean function computed by ai is bipolar, since ai is supporting and all other parents
are attacking. For the size of Dn , we observe that


kDn k  O n Threshold 
n1,k

whence the overall size is polynomial. It remains to show that su(Dn ) = Majorityn .
: Let M  Majorityn . We have to show M  su(Dn ), that is, a  M iff M |= a
for all a  An . For a  M , it is immediate that M |= a , so let aj 
/ M for some
j  {1, .. . ,n}. We have to show M 6|= aj . Since M  Majorityn , we have |M | = m
for k = n2  m  n  1 and M  Thresholdn1,k , that is, we have
M |= Threshold
(a1 , . . . , aj1 , aj+1 , . . . , an )
n1,k
Together with M 6|= aj , it follows that M 6|= aj .
 
: Let M 
/ Majorityn . Then |M | = m for 0  m < n2 = k. In particular, there is
some aj  An \ M . Now m < k implies that there is no N  Thresholdn1,k with
(a1 , . . . , aj1 , aj+1 , . . . , an ) whence it follows
|N | = m = |M |. Thus M 6|= Threshold
n1,k
that M |= aj . Together with M 6|= aj we conclude that M 
/ su(Dn ).

Since every BADF is an ADF of the same size, we get:
Corollary 18. ADFsu 6s LPsu
In combination with the translation from logic programs to ADFs (implying the relation
LPsu s ADFsu ), this means that also ADFs are strictly more succinct than logic programs.
Corollary 19. LPsu <s ADFsu
3.1.5 BADF vs. AF
It is comparably easy to show that BADF models are strictly more expressive than AFs,
since sets of supported models of bipolar ADFs do not have the antichain property.
Proposition 20. AF <e BADFsu
Proof. Consider vocabulary A = {a} and BADF D = (A, {(a, a)} , {a }) with a = a. It is
straightforward to check that its model set is su(D) = {, {a}}. Since model sets of AFs
under stable extension semantics satisfy the antichain property, there is no equivalent AF
over A.

This yields the following overall relationships:
AF <e BADFsu <e ADFsu 
=e LPsu 
=e PL
For a concise overview of relative succinctness, we present the results and open problems
at a glance in Table 2 below.9
9. We remark that the three open problems in Table 2 are really only two: It is easy to show that ADFs
and propositional logic behave equivalently in relation to bipolar ADFs, since they are equally expressive
and equally succinct; that is, it holds that ADFsu s BADFsu if and only if PL s BADFsu .

218

fiExpressiveness of Two-Valued Semantics for ADFs

su

BADF
ADFsu
LPsu
PL

BADFsu
=
?
?
?

ADFsu
s
=
<s

=s

LPsu
6s
6s
=
6s

PL
s

=s
<s
=

Table 2: Relative succinctness results for (bipolar) ADFs under the model semantics, normal
logic programs under the supported semantics, and classical propositional logic. An entry 
in row F1 and column F2 means F1  F2 .
3.2 Stable Semantics
As before, we recall the current state of knowledge:
AF e BADFst e ADFst <e PL and AF e LPst <e PL
We first show that BADFs are strictly more expressive than AFs.
Proposition 21. AF <e BADFst
Proof. Consider the set X2 = {{a, b} , {a, c} , {b, c}} of desired models. Dunne et al. (2015)
proved that X2 is not realisable with stable AF semantics. However, the model set X2 is
realisable with BADF DX2 under stable semantics:
a = b  c,

b = a  c,

c = a  b

Let us exemplarily show that M = {a, b} is a stable model (the other cases are completely
symmetric): The reduct DM is characterised by the two acceptance formulas a = b  
and b = a  . We then easily find that DM (, ) = (M, ) = DM (M, ).

Intuitively, the argument for AF non-realisability of X2 is as follows: Since a and b occur
in an extension together, there can be no attack between them. The same holds for the
pairs a, c and b, c. But then the set {a, b, c} is conflict-free and thus there must be a stable
extension containing all three arguments, which is not allowed by X2 . The reason is AFs
restriction to individual attack, as set attack (also called joint or collective attack) suffices
to realise X2 as seen above.
The construction that we used in the proof above to realize X2 comes from the work
of Eiter, Fink, Puhrer, Tompits, and Woltran (2013) in logic programming, and can be
generalised to realise any non-empty model set satisfying the antichain property.
st = (A, L, C) where C for a  A
Definition 7. Let X  2A . Define the following BADF DX
a
is given by


_
^

a =
b
M X,aM

bA\M

and thus L = {(b, a) | M  X, a  M, b  A \ M }.
219

fiStrass

The next result shows that the construction indeed works.
st ) = X.
Theorem 22. Let X with  =
6 X  2A be a -antichain. We find that st(DX

Proof. Let M  A.
st )  st(D st ); we use a case distinction.
: Let M 
/ X. We show that M 
/ su(DX
X

1. There is an N  X with M ( N . Then there is an a  N \ M . Consider its
acceptance
V formula a . Since a  N and N  X, the formula a has a disjunct
a,N = bA\N b. Now M  N implies A \ N  A \ M and M is a model for
st ).
a,N . Thus M is a model for a although a 
/ M , hence M 
/ su(DX
2. For all N  X, we have M 6 N . Then X 6=  implies M 6= , so let a  M .
For each
V N  X with a  N , the acceptance formula a contains a disjunct
a,N = bA\N b. By assumption, for each N  X there is a bN  M \ N .
Clearly bN  A \ N and bN is evaluated to true by M . Hence for each N  X
with a  N , the disjunct a,N is evaluated to false by M . Thus a is false under
st ).
M and M 
/ su(DX
st ), that is: for all a  A, we find a  M
: Let M  X. We first show that M  su(DX
iff M is a model for a .
st
1. Let a  M . By
V construction, we have that a in DX contains a disjunct of the
form a,M = bA\M b. According to the interpretation M , all such b  A \ M
are false and thus a,M is true whence a is true.

2. Let a  A \ M and consider its acceptance formula a . Assume to the contrary
that M is a model for V
a . Then there is some N  X with a  N such that M
is a model for a,N = bA\N b, that is, A \ N  A \ M . Hence M  N ; and,
since a  N \ M , even M ( N , whence X is not a -antichain. Contradiction.
Thus M is no model for a .
st with respect to M . There, M contains the
Now consider the reduct DM of DX
a
M
disjunct a,M = a,M [b/ : b 
/ M ] where all b  A \ M have been replaced by false,
M =   . . .   and M is equivalent to true. Thus each a  M is true
whence a,M
a
st ).
in the least fixpoint of DM and thus M  st(DX


The restriction to non-empty model sets is immaterial for relative expressiveness, since we
can use the construction of Theorem 2 and the fact that st(D)  su(D) for any ADF D to
realize the empty model set. As the stable model semantics for ADFs and logic programs
both have the antichain property, we get:
Corollary 23. ADFst e BADFst and LPst e BADFst
This leads to the following overall relationships:
AF <e BADFst 
=e ADFst 
=e LPst <e PL
We remark that the antichain property provides a characterisation of realisability with the
stable semantics; that is, a model set is stable-realisable iff it is a -antichain.
220

fiExpressiveness of Two-Valued Semantics for ADFs

3.3 Supported vs. Stable Semantics
Now we put the supported and stable pictures together. From the proof of Theorem 22,
st of an antichain X, the supported
we can read off that for the canonical realisation DX
st ) = st(D st ) = X. With this observation, also
and stable semantics coincide, that is, su(DX
X
bipolar ADFs under the supported semantics can realize any antichain, and we have this:
Proposition 24. BADFst e BADFsu
As we have seen in Proposition 20, there are bipolar ADFs with supported-model sets
that are not antichains. We get:
Corollary 25. BADFst <e BADFsu
This result allows us to close the last gap and put together the big picture on relative
expressiveness in Figure 2 below.
ADFsu 
=e PL
=e LPsu 
BADFsu
BADFst 
=e LPst
=e ADFst 
AF
Figure 2: The expressiveness hierarchy. Expressiveness strictly increases from bottom to
top. F  denotes formalism F under semantics , where su is the supported and st
the stable model semantics; formalisms are among AFs (argumentation frameworks), ADFs
(abstract dialectical frameworks), BADFs (bipolar ADFs), LPs (normal logic programs) and
PL (propositional logic).

4. Allowing Vocabulary Expansion
Up to here, we only considered compact realisations, that do not introduce new vocabulary elements. In this section, we allow the introduction of a small number of new
atoms/arguments/statements. More precisely, small means the number is linear in the
size of the source knowledge base (representing the model set that we wish to realize in a
target language). For the purpose of realisability, the new vocabulary elements are projected
out of the resulting models.
As it turns out, adding additional arguments already makes AFs universally expressive
(under projection). More technically, we will now show that for each propositional formula
 over vocabulary A, there exists an AF F over an expanded vocabulary A  A such
that the models of  and the stable extensions of F correspond one-to-one. Roughly,
this is possible since AFs can be regarded as a syntactic variant of classical propositional
logic that has as its only connective the logical NOR  (Gabbay, 2011; Brewka et al.,
2011). Using this connective, negation is expressed by  =    and disjunction by
221

fiStrass

   = (  ) = (  )  (  ). These equivalences can be used to translate arbitrary propositional formulas (over , , ) into the syntactical -fragment; to guarantee
that the size increase is at most linear, we introduce names a for subformulas  (Tseitin,
1968). The next definition combines all of these ideas.
Definition 8. Let  be a formula using , ,  over vocabulary A. Define the sets A and
R inductively as follows:
A> = {a> }

R> = 

A = {a }

R = {(a , a )}

Ap = {p, ap } for p  A

Rp = {(p, ap ), (ap , p)} for p  A

A = {a }  A

R = {(a , a )}  R

A = {a , a , a }  A  A R = {(a , a ), (a , a )}  R  R
A = {a , a }  A  A

R = {(a , a ), (a , a ), (a , a )}  R  R

The AF associated to  is given by F = (A  A , R  {(a , a )}  R ).
The argument a> is unattacked and thus part of every stable extension (is true in every
interpretation); the argument a attacks itself and thus cannot be part of any stable extension (is false in every interpretation). The mutually attacking arguments p and ap for
p  A serve to guess a valuation of A, while a and a guarantee that only (and all)
valuations that are models of  can lead to stable extensions of F : intuitively, a must be
attacked, and the only candidate to do so is a . The arguments and attacks for the Boolean
connectives express their usual truth-theoretic semantics, as our first technical result for this
translation shows.
Lemma 26. Let  be a formula over vocabulary A and F its associated AF. For each
stable extension M of F and a , a  A , we have:
 a  M iff a 
/ M;
 a  M iff both a  M and a  M ;
 a  M iff one of a  M or a  M ;
 a  M iff neither a  M nor a  M .
Proof.
 By definition, the only attacker of an argument of the form a is the argument
a . Thus a  M iff a 
/ M.
 The only attackers of a are the arguments a and a . By the case above, we have
a  M iff a 
/ M , and a  M iff a 
/ M . Consequently, a  M and a  M iff
a 
/ M and a 
/ M iff a  M .
 The only attacker of a is the argument a . Similarly to the previous cases, we
can show that a  M iff a 
/ M and a 
/ M , and that a  M iff a 
/ M . In
combination, a  M iff a  M or a  M .
222

fiExpressiveness of Two-Valued Semantics for ADFs

 The only attackers of a are the arguments a and a . It directly follows that
a  M iff neither a  M nor a  M .

These correspondences can be used to show by induction that the newly introduced
arguments capture the semantics of the formulas they encode (for all subformulas  of ).
Lemma 27. Let  be a formula over A and F its associated AF. For each stable extension
M of F and a  A , we have a  M iff M  A is a model of .
Proof. Let M be a stable extension of F . We use structural induction on .
 = >: Trivial: a>  M since it has no attackers.
 = : Trivial: a 
/ M since the set {a } is not conflict-free.
 = p  A: Trivial: p  M iff M |= p by definition.
 = : a  M iff a  M iff a 
/ M iff M 6|=  iff M |=  iff M |= .
 =   : a  M iff a  M iff a  M and a  M iff M |=  and M |=  iff M |=   
iff M |= .
 =   : a  M iff a  M iff a  M or a  M iff M |=  or M |=  iff M |=   
iff M |= .
 =   : a  M iff a  M iff a 
/ M and a 
/ M iff M 6|=  and M 6|=  iff M |=   
iff M |= .

This lets us show the main result of this section, namely that the AF stable extension
semantics is universally expressive under projection.
Theorem 28. Let  be a formula over vocabulary A and F its associated AF.
1. For each model M  A of , there exists a stable extension E of F with M = E  A.
2. For each stable extension E of F , the set E  A is a model of .
Proof.

1. Let M  A be a model of . Define the set
E = {a | a  A , M |= }

Observe that M = E  A. By presumption, a  E. It remains to show that E is a
stable extension, that is, E is conflict-free and attacks all arguments b 
/ E.
E is conflict-free: Assume to the contrary that there is an attack r = (a, b)  R with
a, b  E. By definition, there are only these cases:
 a is arbitrary and b = . But then by definition of E we get M |= ,
contradiction.
 r = (p, ap ) or r = (ap , p) for p  A. But then by definition of E we get
M |= p and M |= p, contradiction.
223

fiStrass

 r = (a , a ). But then by definition of E we get M |=  and M |= ,
contradiction.
 r = (a , a ) or r = (a , a ). Then M |=  , and M |=  or M |= ,
contradiction.
 r = (a , a ). Then M |=   , whence M |= ( ). But also M |=  ,
contradiction.
 r = (a , a ) or r = (a , a ). Then M |=   , and M |=  or M |= .
But then also M |=   , contradiction.
E attacks all arguments not in E: Let b  (A  A  {a }) \ E be an argument. By
definition, there is a formula  such that b = a and M 6|= . We use structural
induction.
 If  =  then a  E attacks a by definition.
 If  = , then M |=  whence a  E attacks a by definition.
 If  =   , then M |=  or M |=  whence a  E or a  E. In any
case, E attacks a by definition.
 If  =   , then M |=    whence a  E attacks a by definition.
 If  =   , then M |=    whence a  E or a  E.
In any case, E attacks a by definition.
2. Let E be a stable extension of F . Since E is conflict-free, a 
/ E. Since E is stable,
E attacks a , which yields a  E. By Lemma 27, E  A is a model of .

In particular, F has no stable extension iff  is unsatisfiable. While this shows that the
construction of Definition 8 works as intended, it remains to show that the number of new
arguments is at most linear in the formula size. We can even show that the total increase
in size is only linear, thus also the number of new arguments is linear.
Proposition 29. For any formula , we find that kF k  O(kk).
Proof. We first note that
kF k = k(A  A , R  {(a , a )}  R )k
= |A  A | + |R  {(a , a )}  R |
= |A | + 1 + |R | + 2
= |A | + |R | + 3
We now use structural induction on  to show that for all formulas , we find |A |  5  kk
and |R |  4  kk. It then follows that kF k  (5 + 4)  kk + 3 = 9  kk + 3  O(kk).
 = >:
|A> | = |{a> }| = 1  5 = 5  k>k
|R> | = || = 0  4 = 4  k>k
224

fiExpressiveness of Two-Valued Semantics for ADFs

 = :
|A | = |{a }| = 1  5 = 5  kk
|R | = |{(a , a )}| = 1  4 = 4  kk
 = a  A:
|Aa | = |{a, aa }| = 2  5 = 5  kak
|Ra | = |{(a, aa ), (aa , a)}| = 2  4 = 4  kak
 = :
|A | = |A  {a }|  |A | + 1  (5  kk) + 1  5  (kk + 1) = 5  kk
|R | = |R  {(a , a )}|  |R | + 1  (4  kk) + 1  4  (kk + 1) = 4  kk
 =   :
|A |  |A | + |A | + 3  (|A | + 1) + (|A | + 1) + 3
 (5  kk + 1) + (5  kk + 1) + 3 = 5  kk + 5  kk + 5
= 5  (kk + kk + 1) = 5  k  k
|R |  |R | + |R | + 2  (|R | + 1) + (|R | + 1) + 2
 (4  kk + 1) + (4  kk + 1) + 2 = 4  kk + 4  kk + 4
= 4  (kk + kk + 1) = 4  kk
 =   :
|A |  |A | + |A | + 2  5  kk + 5  kk + 2
 5  kk + 5  kk + 5 = 5  (kk + kk + 1) = 5  kk
|R |  |R | + |R | + 3  (4  kk) + (4  kk) + 3
 4  kk + 4  kk + 4 = 4  (kk + kk + 1) = 4  kk



Hence under projection, the AF stable extension semantics can realise as much as propositional logic can. With the results of the previous section (AF e PL), this means that
allowing to introduce a linear number of new vocabulary elements (that are later projected
out), all languages considered in this paper are equally (universally) expressive.
However, we must note that equal expressiveness does not mean equal efficiency: When
we assume that a knowledge base of size n leads to a search space of size O(2n ), then a
linear increase in knowledge base size (that is, from n to c  n for some constant c) leads to
a polynomial increase in search space size (that is, from O(2n ) to O(2cn ) = O((2n )c ).
225

fiStrass

5. Discussion
We compared the expressiveness of abstract argumentation frameworks, abstract dialectical
frameworks, normal logic programs and propositional logic. We showed that expressiveness
under different semantics varies for the formalisms and obtained a neat expressiveness hierarchy. These results inform us about the capabilities of these languages to encode sets
of two-valued interpretations, and help us decide which languages to use for specific applications. Furthermore, we have seen that the results are sensitive to the vocabulary one is
permitted to use, as the hierarchy collapses when we allow to introduce even only a linear
number of new atoms.
Concerning succinctness, we have shown that ADFs (under model semantics) are exponentially more succinct than normal logic programs (under supported model semantics),
and that even bipolar ADFs (under model semantics)  although being less expressive 
can succinctly express some model sets where equivalent normal logic programs (under supported model semantics) over the same vocabulary must necessarily blow up exponentially
in size. It is open whether the converse direction also holds, that is, whether BADFs are
exponentially more succinct than logic programs (if LPsu s BADFsu ) or the two are just
mutually incomparable in terms of succinctness (if LPsu 6s BADFsu ). For the stable semantics, relative succinctness of logic programs and BADFs is completely open, partly due
to the technical aspect that the two stable semantics are conceptually different, as ADFs
in fact employ ultimate stable models (Denecker et al., 2004; Brewka et al., 2013; Strass
& Wallner, 2015). Furthermore, for general ADFs, the computational complexity of the
model existence problem of stable semantics is higher than for normal logic programs,10 so
a succinctness comparison with regard to stable models would be of limited significance.
It is easy to see that AFs have a somewhat special role as they are representationally
succinct in any case: for a vocabulary An , there is syntactically no possibility to specify a knowledge base (an AF) of exponential size, since the largest AF over An has size
k(An , An  An )k = n + n2 and is thus polynomially large. So anything that can be expressed with an AF can be expressed in reasonable space by definition. However, this
strength of AFs should be taken with a grain of salt, since they are comparably inexpressive. This can (in addition to the results we presented) already be seen from a simple
counting argument: even if all syntactically different AFs over An were semantically differ2
ent (which they are not), they could express at most 2n different model sets, which is  for
n
increasing n  negligible in relation to the 22 possible model sets over An .
In their original paper, Gogic et al. (1995) also used a relaxed version of succinctness,
where they allowed to introduce a linear number of new variables. It follows from our results
in Section 4 that all formalisms we consider here are equally succinct under this relaxed
notion.
Parts of the expressiveness results for normal logic programs carry over to further LP
classes. For example, canonical logic programs provide a limited form of nesting by allowing
literals of the form not not a in rule bodies (Lifschitz et al., 1999). This makes it quite easy
to see how normal logic programs under supported semantics can be translated to equivalent
canonical logic programs, namely by replacing each positive body atom a by not not a in
10. P
2 -hard for ADFs (Strass & Wallner, 2015) as opposed to in NP for normal LPs (Bidoit & Froidevaux,
1991; Marek & Truszczynski, 1991).

226

fiExpressiveness of Two-Valued Semantics for ADFs

all rule bodies. Recently, Shen and Zhao (2014) showed that canonical logic programs and
propositional logic programs are succinctly incomparable (under an assumption11 ), and also
provide interesting avenues for further succinctness studies. We can also add succinctness
questions of our own: firstly that of comparing disjunctive logic programs under stable
models with general ADFs under stable models, since the two have an equally complex
(P2 -complete) model existence problem (Eiter & Gottlob, 1995; Brewka et al., 2013). What
is more, there have been alternative proposals for stable model semantics for ADFs:
 ours (Strass, 2013) (Definition 3.2, later called approximate stable models by Strass
& Wallner, 2015), for which model existence is NP-complete (Strass & Wallner, 2015)
and thus potentially easier than that of the stable models of Brewka et al. (2013)
(called ultimate stable models by Strass & Wallner, 2015);
 the grounded model semantics by Bogaerts, Vennekens, and Denecker (2015) (Definition 6.8), whose model existence problem is also P2 -complete (Bogaerts et al.,
2015);
 the F-stable model semantics by Alviano and Faber (2015) (Definition 10).
It follows from Theorem 5.9 of Bogaerts et al. (2015) that grounded models and F-stable
models coincide. Still, they are demonstrably different from both approximate and ultimate stable models for ADFs (Alviano & Faber, 2015),12 and their relative succinctness in
comparison to normal/disjunctive logic programs is unanalysed.
There is more potential for further work. First of all, a nice characterisation of bipolar
ADF realisability is still missing; we are unsure whether much improvement over Proposition 11 is possible. Incidentally, for AFs the exact characterisation of compact stable extension realisability constitutes a major open problem (Dunne et al., 2015; Baumann et al.,
2014). Second, there are further semantics for abstract dialectical frameworks whose expressiveness could be studied; Dunne et al. (2015) and Dyrkolbotn (2014) already analyse many
of them for argumentation frameworks. This work is thus only a start and the same can
be done for the remaining semantics. For example the admissible, complete and preferred
semantics are all defined for AFs, (B)ADFs and LPs (Strass, 2013; Brewka et al., 2013),
and Puhrer (2015) has already made a huge step into that direction by characterising realisability. Third, there are further formalisms in abstract argumentation (Brewka et al., 2014)
whose expressiveness is by and large unexplored to the best of our knowledge. Finally, the
representational succinctness of the subclass of bipolar ADFs (using bipolar propositional
formulas to represent them) under supported model semantics is mostly open (cf. Table 2),
with some evidence pointing toward meaningful capabilities.

Acknowledgements
This paper combines, extends and improves results of our previous work (Strass, 2014,
2015b, 2015c). We wish to thank Stefan Woltran for providing a useful pointer to related
1
11. P 6 NC/poly
, the Boolean circuit equivalent of the assumption NP 6 P.
12. In the terminology of Alviano and Faber (2015), approximate stable models (Strass, 2013) are called
S-stable models and ultimate stable models (Brewka et al., 2013) are called B-stable models. Both are
shown to be different from F-stable models.

227

fiStrass

work on realisability in logic programming, Bart Bogaerts for pointing out that grounded
models and F-stable models are the same, Jorg Puhrer for several suggestions for improvement of the manuscript, and Frank Loebe for helpful discussions. This research was partially
supported by Deutsche Forschungsgemeinschaft (DFG, project BR 1817/7-1).

References
Al-Abdulkarim, L., Atkinson, K., & Bench-Capon, T. J. M. (2014). Abstract dialectical
frameworks for legal reasoning. In Hoekstra, R. (Ed.), Proceedings of the TwentySeventh Annual Conference on Legal Knowledge and Information Systems (JURIX),
Vol. 271 of Frontiers in Artificial Intelligence and Applications, pp. 6170. IOS Press.
Al-Abdulkarim, L., Atkinson, K., & Bench-Capon, T. J. M. (2015). Evaluating an approach
to reasoning with cases using abstract dialectical frameworks. In Proceedings of the
Fifteenth International Conference on Artificial Intelligence and Law (ICAIL).
Alviano, M., & Faber, W. (2015). Stable model semantics of abstract dialectical frameworks revisited: A logic programming perspective. In Yang, Q., & Wooldridge, M.
(Eds.), Proceedings of the Twenty-Fourth International Joint Conference on Artificial
Intelligence (IJCAI), pp. 26842690, Buenos Aires, Argentina. IJCAI/AAAI.
Arora, S., & Barak, B. (2009). Computational Complexity: A Modern Approach. Cambridge
University Press.
Baumann, R., Dvorak, W., Linsbichler, T., Strass, H., & Woltran, S. (2014). Compact
argumentation frameworks. In Proceedings of the Twenty-First European Conference
on Artificial Intelligence (ECAI), pp. 6974, Prague, Czech Republic.
Bidoit, N., & Froidevaux, C. (1991). Negation by default and unstratifiable logic programs.
Theoretical Computer Science, 78 (1), 85112.
Bogaerts, B., Vennekens, J., & Denecker, M. (2015). Grounded fixpoints and their applications in knowledge representation. Artificial Intelligence, 224, 5171.
Boppana, R. B. (1986). Threshold functions and bounded depth monotone circuits. Journal
of Computer and System Sciences, 32 (2), 222229.
Brewka, G., Dunne, P. E., & Woltran, S. (2011). Relating the semantics of abstract dialectical frameworks and standard AFs. In Proceedings of the Twenty-Second International
Joint Conference on Artificial Intelligence (IJCAI), pp. 780785. IJCAI/AAAI.
Brewka, G., Ellmauthaler, S., Strass, H., Wallner, J. P., & Woltran, S. (2013). Abstract
dialectical frameworks revisited. In Proceedings of the Twenty-Third International
Joint Conference on Artificial Intelligence (IJCAI), pp. 803809. IJCAI/AAAI.
Brewka, G., & Gordon, T. F. (2010). Carneades and abstract dialectical frameworks: A reconstruction. In Proceedings of the Third International Conference on Computational
Models of Argument (COMMA), Vol. 216 of FAIA, pp. 312. IOS Press.
Brewka, G., Polberg, S., & Woltran, S. (2014). Generalizations of Dung frameworks and
their role in formal argumentation. IEEE Intelligent Systems, 29 (1), 3038. Special
Issue on Representation and Reasoning.
228

fiExpressiveness of Two-Valued Semantics for ADFs

Brewka, G., & Woltran, S. (2010). Abstract dialectical frameworks. In Proceedings of the
Twelfth International Conference on the Principles of Knowledge Representation and
Reasoning (KR), pp. 102111.
Clark, K. L. (1978). Negation as failure. In Gallaire, H., & Minker, J. (Eds.), Logic and
Data Bases, pp. 293322. Plenum Press.
Coste-Marquis, S., Konieczny, S., Mailly, J.-G., & Marquis, P. (2014). On the revision of
argumentation systems: Minimal change of arguments statuses. In Proceedings of the
Fourteenth International Conference on Principles of Knowledge Representation and
Reasoning (KR), pp. 5261.
Darwiche, A., & Marquis, P. (2002). A knowledge compilation map. Journal of Artificial
Intelligence Research, 17, 229264.
Denecker, M., Marek, V. W., & Truszczynski, M. (2004). Ultimate approximation and
its application in nonmonotonic knowledge representation systems. Information and
Computation, 192 (1), 84121.
Dimopoulos, Y., Nebel, B., & Toni, F. (2002). On the computational complexity
of assumption-based argumentation for default reasoning. Artificial Intelligence,
141 (1/2), 5778.
Dung, P. M. (1995). On the Acceptability of Arguments and its Fundamental Role in
Nonmonotonic Reasoning, Logic Programming and n-Person Games. Artificial Intelligence, 77, 321358.
Dunne, P. E., Dvorak, W., Linsbichler, T., & Woltran, S. (2014). Characteristics of multiple
viewpoints in abstract argumentation. In Proceedings of the Fourteenth International
Conference on the Principles of Knowledge Representation and Reasoning (KR), pp.
7281, Vienna, Austria.
Dunne, P. E., Dvorak, W., Linsbichler, T., & Woltran, S. (2015). Characteristics of multiple
viewpoints in abstract argumentation. Artificial Intelligence, 228, 153178.
Dyrkolbotn, S. K. (2014). How to argue for anything: Enforcing arbitrary sets of labellings
using AFs. In Proceedings of the Fourteenth International Conference on the Principles
of Knowledge Representation and Reasoning (KR), pp. 626629, Vienna, Austria.
Eiter, T., Fink, M., Puhrer, J., Tompits, H., & Woltran, S. (2013). Model-based recasting in
answer-set programming. Journal of Applied Non-Classical Logics, 23 (12), 75104.
Eiter, T., & Gottlob, G. (1995). On the computational cost of disjunctive logic programming:
Propositional case. Annals of Mathematics and Artificial Intelligence, 15 (34), 289
323.
French, T., van der Hoek, W., Iliev, P., & Kooi, B. (2013). On the succinctness of some
modal logics. Artificial Intelligence, 197, 5685.
Friedman, J. (1986). Constructing O(n log n) size monotone formulae for the k-th elementary symmetric polynomial of n Boolean variables. SIAM Journal on Computing, 15,
641654.
Gabbay, D. M. (2011). Dungs argumentation is essentially equivalent to classical propositional logic with the Peirce-Quine dagger. Logica Universalis, 5 (2), 255318.
229

fiStrass

Gaggl, S. A., & Strass, H. (2014). Decomposing Abstract Dialectical Frameworks. In Parsons, S., Oren, N., & Reed, C. (Eds.), Proceedings of the Fifth International Conference
on Computational Models of Argument (COMMA), Vol. 266 of FAIA, pp. 281292.
IOS Press.
Gaggl, S. A., Rudolph, S., & Strass, H. (2015). On the computational complexity of naivebased semantics for abstract dialectical frameworks. In Yang, Q., & Wooldridge, M.
(Eds.), Proceedings of the Twenty-Fourth International Joint Conference on Artificial
Intelligence (IJCAI), pp. 29852991, Buenos Aires, Argentina. IJCAI/AAAI.
Gebser, M., Kaminski, R., Kaufmann, B., Ostrowski, M., Schaub, T., & Schneider, M.
(2011). Potassco: The Potsdam Answer Set Solving Collection. AI Communications,
24 (2), 105124. Available at http://potassco.sourceforge.net.
Gelfond, M., & Lifschitz, V. (1988). The stable model semantics for logic programming.
In Proceedings of the International Conference on Logic Programming (ICLP), pp.
10701080. The MIT Press.
Gogic, G., Kautz, H., Papadimitriou, C., & Selman, B. (1995). The comparative linguistics
of knowledge representation. In Proceedings of the Fourteenth International Joint
Conference on Artificial Intelligence (IJCAI), pp. 862869. Morgan Kaufmann.
Jukna, S. (2012). Boolean Function Complexity: Advances and Frontiers, Vol. 27 of Algorithms and Combinatorics. Springer.
Lifschitz, V., & Razborov, A. (2006). Why are there so many loop formulas?. ACM Transactions on Computational Logic, 7 (2), 261268.
Lifschitz, V., Tang, L. R., & Turner, H. (1999). Nested expressions in logic programs. Annals
of Mathematics and Artificial Intelligence, 25 (34), 369389.
Lin, F., & Zhao, Y. (2004). ASSAT: Computing answer sets of a logic program by SAT
solvers. Artificial Intelligence, 157 (1-2), 115137.
Linsbichler, T. (2014). Splitting abstract dialectical frameworks. In Parsons, S., Oren, N., &
Reed, C. (Eds.), Proceedings of the Fifth International Conference on Computational
Models of Argument (COMMA), Vol. 266 of FAIA, pp. 357368. IOS Press.
Marek, V. W., & Truszczynski, M. (1991). Autoepistemic logic. Journal of the ACM, 38 (3),
587618.
Osorio, M., Zepeda, C., Nieves, J. C., & Cortes, U. (2005). Inferring acceptable arguments
with answer set programming. In Proceedings of the Sixth Mexican International
Conference on Computer Science (ENC), pp. 198205.
Polberg, S. (2014). Extension-based semantics of abstract dialectical frameworks. In Endriss,
U., & Leite, J. (Eds.), Proceedings of the Seventh European Starting AI Researcher
Symposium (STAIRS), Vol. 264 of FAIA, pp. 240249. IOS Press.
Polberg, S., Wallner, J. P., & Woltran, S. (2013). Admissibility in the abstract dialectical
framework. In Leite, J., Son, T. C., Torroni, P., van der Torre, L., & Woltran, S.
(Eds.), Proceedings of the Fourteenth International Workshop on Computational Logic
in Multi-Agent Systems (CLIMA XIV), Vol. 8143 of LNAI, pp. 102118. Springer.
230

fiExpressiveness of Two-Valued Semantics for ADFs

Puhrer, J. (2015). Realizability of three-valued semantics for abstract dialectical frameworks. In Yang, Q., & Wooldridge, M. (Eds.), Proceedings of the Twenty-Fourth
International Joint Conference on Artificial Intelligence (IJCAI), pp. 31713177. IJCAI/AAAI, Buenos Aires, Argentina.
Shen, Y., & Zhao, X. (2014). Canonical logic programs are succinctly incomparable with
propositional formulas. In Proceedings of the Fourteenth International Conference
on the Principles of Knowledge Representation and Reasoning (KR), pp. 665668,
Vienna, Austria.
Strass, H. (2013). Approximating operators and semantics for abstract dialectical frameworks. Artificial Intelligence, 205, 3970.
Strass, H. (2014). On the relative expressiveness of argumentation frameworks, normal
logic programs and abstract dialectical frameworks. In Konieczny, S., & Tompits,
H. (Eds.), Proceedings of the Fifteenth International Workshop on Non-Monotonic
Reasoning (NMR).
Strass, H. (2015a). Instantiating rule-based defeasible theories in abstract dialectical frameworks and beyond. Journal of Logic and Computation, Advance Access published 11
February 2015, http://dx.doi.org/10.1093/logcom/exv004.
Strass, H. (2015b). The relative expressiveness of abstract argumentation and logic programming. In Proceedings of the Twenty-Ninth AAAI Conference on Artificial Intelligence
(AAAI), pp. 16251631, Austin, TX, USA.
Strass, H. (2015c). Representational succinctness of abstract dialectical frameworks. In
Black, E., Modgil, S., & Oren, N. (Eds.), Proceedings of the Third International Workshop on Theory and Applications of Formal Argumentation (TAFA).
Strass, H., & Wallner, J. P. (2015). Analyzing the computational complexity of abstract
dialectical frameworks via approximation fixpoint theory. Artificial Intelligence, 226,
3474.
Tseitin, G. S. (1968). On the complexity of derivations in the propositional calculus. Structures in Constructive Mathematics and Mathematical Logic, Part II, Seminars in
Mathematics (translated from Russian), 115125.

231

fi