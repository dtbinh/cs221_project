Journal of Artificial Intelligence Research 39 (2010) 373-427

Submitted 4/10; published 10/10

A Constraint Satisfaction Framework for Executing
Perceptions and Actions in Diagrammatic Reasoning
Bonny Banerjee
B. Chandrasekaran

banerjee.28@osu.edu
chandra@cse.ohio-state.edu

Laboratory for Artificial Intelligence Research
Department of Computer Science & Engineering
The Ohio State University, Columbus, OH 43210, USA

Abstract
Diagrammatic reasoning (DR) is pervasive in human problem solving as a powerful adjunct to symbolic reasoning based on language-like representations. The research reported
in this paper is a contribution to building a general purpose DR system as an extension
to a soar-like problem solving architecture. The work is in a framework in which DR is
modeled as a process where subtasks are solved, as appropriate, either by inference from
symbolic representations or by interaction with a diagram, i.e., perceiving specied information from a diagram or modifying/creating objects in a diagram in specied ways
according to problem solving needs. The perceptions and actions in most DR systems built
so far are hand-coded for the specic application, even when the rest of the system is built
using the general architecture. The absence of a general framework for executing perceptions/actions poses as a major hindrance to using them opportunistically  the essence of
open-ended search in problem solving.
Our goal is to develop a framework for executing a wide variety of specied perceptions and actions across tasks/domains without human intervention. We observe that
the domain/task-specic visual perceptions/actions can be transformed into domain/taskindependent spatial problems. We specify a spatial problem as a quantied constraint
satisfaction problem in the real domain using an open-ended vocabulary of properties, relations and actions involving three kinds of diagrammatic objects  points, curves, regions.
Solving a spatial problem from this specication requires computing the equivalent simplied quantier-free expression, the complexity of which is inherently doubly exponential.
We represent objects as conguration of simple elements to facilitate decomposition of
complex problems into simpler and similar subproblems. We show that, if the symbolic
solution to a subproblem can be expressed concisely, quantiers can be eliminated from
spatial problems in low-order polynomial time using similar previously solved subproblems. This requires determining the similarity of two problems, the existence of a mapping
between them computable in polynomial time, and designing a memory for storing previously solved problems so as to facilitate search. The ecacy of the idea is shown by time
complexity analysis. We demonstrate the proposed approach by executing perceptions and
actions involved in DR tasks in two army applications.

1. Introduction
The research reported in this paper is a contribution to building problem solving agents
in articial intelligence (AI) that use diagrams, much as people do, but most of AI does
not, given the almost exclusive emphasis in AI on language-like or predicate-symbolic representations. Diagrammatic reasoning (DR) is an emerging area of research in a number
c
2010
AI Access Foundation. All rights reserved.

fiBanerjee & Chandrasekaran

of elds, including AI (Glasgow, Narayanan, & Chandrasekaran, 1995; Chandrasekaran,
Kurup, & Banerjee, 2005), logic (Barwise & Etchemendy, 1998; Allwein & Barwise, 1999),
and psychology (Tversky, 2000; Tricket & Trafton, 2006). While all research in DR is in
one way or other dealing with diagrams, dierent research issues are addressed by dierent
researchers. The research reported in this paper considers DR as a problem solving activity
in which an agent (human or articial) makes use of two forms of representation  a spatial
representation in the form of 2D diagrams and a symbolic representation that contains information in a predicate-symbolic form similar to logic and natural language. A schematic
DR architecture, as proposed by Chandrasekaran et al. (2002, 2004, 2005), is illustrated in
Figure 1.
Problem
Spatial problem in
specification language

Spatial
Problem
Solver

Problem
Solver
Solution to the
spatial problem

Diagram

Solution

Inference
Rules
Symbolic
Information
Traditional AI
problem solver

Figure 1: The diagrammatic reasoning architecture.

1.1 Diagrammatic Reasoning as a Problem Solving Activity
The DR architecture shares the idea of problem solving as search in problem state space
(Laird, Rosenbloom, & Newell, 1986; Newell, 1990). In this approach, starting from an
initial state, the agent applies operators to bring about state transitions to reach the goal
state. A goal is either reached or decomposed into subgoals by the use of general and
domain knowledge. Reaching a goal or subgoal requires information which is generated in
the traditional problem solving architectures (e.g., soar in Laird, Newell, & Rosenbloom,
1987, act-r in Anderson, 1993) by inference using predicate-symbolic representation. In the
DR architecture, the agent can extract information from diagrams by applying perceptionlike operations in addition to inference using predicate-symbolic representation to reach the
goal/subgoal. The agent can also create or modify objects in a diagram that propose new
states from which the goal might be reached with subsequent perceptions and inferences.
To illustrate our conceptualization of DR, let us consider a real-world problem. An
army commander, planning strategic operations, uses a terrain map to chalk out a path for
his troops to safely travel from one base camp location L1 to another L2 within a given
time. The information he has is regarding the nature of the terrain (e.g., slow-go or no-go
regions, altitude of dierent parts of the terrain, the speed at which his troops can travel in
dierent kinds of terrain) and an estimate of the maximum repower range of the enemy.
The commander, being a veteran in the eld, is well aware of the possibility that his troops
might be ambushed along any path by the enemy who might be hiding in the neighboring
regions. His problem solving might proceed as follows. A diagram consisting of the part of
374

fiExecuting Perceptions and Actions in Diagrammatic Reasoning

the terrain map of interest for this particular problem is given, along with the peripheries
of the no-go regions and the two points, L1 and L2 (see Figure 2(a)). The commander
draws one of the shorter paths from L1 to L2 maintaining a maximum distance from the
neighboring no-go regions (see Figure 2(b)). He knows what kinds of spatial relations
between points on the route and the points where the enemy could be hiding correspond to
ambush potential. He then uses that knowledge to perceive (and mark) the portions of the
path that are prone to ambush due to enemies hiding behind the neighboring no-go regions
(see Figure 2(c)). If no such portion is found, the path is inferred to be safe. If the length
of a safe path can be traversed in the given time, it is considered a suitable path for the
operation. If the path drawn is not safe or does not satisfy the time constraint, another path
is drawn (see Figure 2(d)) and analyzed. This procedure continues until all paths have been
exhausted. If a suitable path is still not found, the least risky path might be considered
for the operation. In the worst case, the commander might infer that this operation is not
possible. A problem in a similar vein, as described above, has been considered by Forbus,
Usher, and Chapman (2003).
In the above example, it is noteworthy how the problem solver (the commander) opportunistically brings together symbolic knowledge (such as, the repower range of enemies)
and perception and action on a diagram to solve a real-world problem. Such a phenomenon
is characteristic of DR whenever it is used to solve problems in dierent domains, such as,
economics, geometry, engineering, computer-aided design, military, and so on. We observe
that executing the perceptions and actions require solving purely spatial problems with
no involvement of domain knowledge. These spatial problems can be described in terms
of diagrammatic objects, such as, points, curves, and regions, and spatial properties (e.g.,
length of a curve) and relations (e.g., point on a curve) involving them. For example, perceiving the portions of a path prone to ambush due to enemies hiding behind a mountain
range requires computing the set of points q on a curve (the path) c1 such that q is within
a specied distance (the repower range) d from some point p on a curve (the mountain
range) c2 (see Figure 22(b)). Formally, this can be written as
RiskyP ortionsof P ath(q, c1 , c2 , d)  On(q, c1 )p, On(p, c2 )DistanceLessT han(p, q, d)
DistanceLessT han(p, q, d)  Distance(p, q)  d
where p is a point. In this paper, we propose a general and ecient framework for spatial
problem solving to autonomously execute perceptions and actions in DR.
1.2 What Do We Mean by a Diagram?
Definition 1. Diagram. A diagram D is a set of labeled 2D objects {O1 , O2 , ...On } all
located clearly inside (i.e., no intersection or touching) a common region (or bounding box)
B. The objects are of three types  points, curves, regions.
Definition 2. Diagrammatic Object. A diagrammatic object O is a 3-tuple < L, T , E >
where L is a label, T is a type (point, curve or region), and E is its spatial extent. The
spatial extent of a diagrammatic object is the set of points constituent of the object.
375

fiBanerjee & Chandrasekaran

(a) The given diagram consisting of two points, L1
and L2 , and three region obstacles.

(b) One of the shorter paths between L1 and L2
avoiding the obstacles is drawn.

(c) Portions of the path prone to ambush are perceived and marked.

(d) Another path is drawn and will be analyzed
for risk.

Figure 2: Diagrammatic reasoning by an army commander for nding a safe path for transporting his troops from L1 to L2 within a given time.

Definition 3. Diagrammatic Image. The diagrammatic image, I, of a diagram is the
set of points constituent of all objects in the diagram. Thus, if D= {O1 , O2 , ...On } is a
diagram where Oi =<L(Oi ),T (Oi ),E(Oi ) >, then its diagrammatic image I(D) is given by
n

I(D) =
E(Oi )
i1

This denition of a diagram, due to Chandrasekaran et al. (2002, 2004, 2005), supports
the functional representation of a diagram in an articial agent. A diagram on an external
medium (e.g., piece of paper, computer screen) is, at one level, an image consisting of pixels
with dierent intensities. At another level, it is an interpreted representation consisting of
spatial objects in some domain of interest. The abstract diagram is ideal, i.e., the points
are dimensionless, curves have no thickness, etc. In an external diagram, points and curves
consist of at least one pixel with nite dimensions. We will need to interchange between
the two forms of diagrams for reasoning and interaction purposes. In the rest of the paper,
376

fiExecuting Perceptions and Actions in Diagrammatic Reasoning

the term diagram will refer to an abstract diagram only, unless otherwise stated. We are
interested only in diagrams that are line drawings with no color or intensity variation. Such
diagrams form a substantial class of diagrams in everyday use.
1.3 Perceptions and Actions in Diagrammatic Reasoning
Definition 4. Perception. A perception is an act of extracting a new piece of information from a diagram. The new piece of information satisfies constraints specified in terms
of properties and relations among existing objects in the diagram and is a boolean or a real
number or a diagrammatic object(s). Thus, a perception P is a mapping from a diagram D
to a set of booleans {T rue, F alse} or real numbers  or a set of diagrammatic objects D
satisfying constraints C.
C

P : D {T rue, F alse}    D ,

I(D )  I(D)

Definition 5. Action. An action is an act of introducing a new object(s), or modifying
or deleting an existing object(s) in a diagram satisfying constraints specified in terms of
properties and relations among existing objects. Thus, an action A is a mapping from a
diagram D to a new set of diagrammatic objects D satisfying constraints C.
C

A : DD ,

I(D) = I(D )

In the last couple of decades, numerous DR systems have been built for dierent applications in dierent domains. In the following we review some well-known DR systems
where a problem solving agent reasons using diagrams. This review will help realize the
role of perception and action in DR, and the spatial problems implicit in such perceptions
and actions.
Sketchy (Pisan, 1995) is a computer implementation of a model of graph understanding. It recognizes the diagrammatic objects - points, lines, regions, and a vocabulary of
properties and relations that includes coordinate at point, right of, above, inside, steeper,
bigger, vertical, change in slope, touches, intersects, on line, on border, forms border, etc. for
representing conceptual relationships in domains, such as, thermodynamics and economics.
A domain translator is responsible for converting domain-specic conceptual questions into
domain-independent graphical relations. Examples of perception from a supply-demand
graph in economics include how price eects the supply, demand, and market price of the
product, which requires solving visual problems, such as, At what point is supply equal to
demand? (corresponding spatial problem: compute the intersection of two curves), What
is the price for the supply line when the quantity is 350? (corresponding spatial problem:
compute a point on a curve whose one coordinate is given), Are the quantity and price
directly proportional? (corresponding spatial problem: check whether the slope of a curve
between two points is a positive constant or not), Are the quantity and price inversely
proportional? (corresponding spatial problem: check whether the slope of a curve between
two points is a negative constant or not), etc. Actions in this model are not required due
to the nature of its task. Examples of graphs understood by sketchy are shown in Figure
3.
377

fiBanerjee & Chandrasekaran

(a) Graph from economics

(b) Graph from thermodynamics

Figure 3: Examples of graphs understood by sketchy. Reproduced with permission from
Pisan (1994).

Figure 4: An example of a deected frame analysis (from civil engineering) by redraw.
Reproduced with permission from Tessler et al. (1995).

378

fiExecuting Perceptions and Actions in Diagrammatic Reasoning

The redraw system (Tessler et al., 1995) combines diagrammatic and symbolic reasoning to qualitatively determine the deected shape of a frame structure under a load, a
structural analysis problem in civil engineering. It uses a vocabulary of properties and relations including get-angular-displacement, get-displacement, symmetrical-p, connected-to,
near, left, above, rotate, bend, translate, smooth, etc. on three kinds of diagrammatic objects  lines, splines, circles. Though most properties and relations are domain-independent,
some, such as, bend reect the assumptions implicit in the domain and the task and can
be dened accordingly. Perceptions and actions are called inspection and manipulation operators in the system. The underlying representation is a combination of a grid-based and
Cartesian coordinates  shapes are represented using the grid where each element in the
grid corresponds to a point in the diagram while lines are represented by a set of coordinate
points. Examples of perception and action include deecting a beam in the same direction
as the load, checking whether a beam and column are perpendicular at a particular rigid
joint, etc. which require solving visual problems, such as, Bend Beam3 in the negative
direction of the y-axis (corresponding spatial problem: compute a curve with a given slope
at a given point), Make the angle between Beam3 and Column3 at Joint3 90 degrees without modifying Beam3 (corresponding spatial problem: compute a curve such that it makes
a particular angle at a given point with a given curve), Get the angle between Beam3 and
Column3 at the ends connected by Joint3 (corresponding spatial problem: compute the
angle between two curves at a given point), etc. An example of a deected frame analysis
by redraw is shown in Figure 4.
The archimedes system (Lindsay, 1998) assists a human in demonstrating theorems
in Euclidean geometry by modifying/creating diagrams according to his instructions and
thereafter perceiving/inferencing from the diagram. It operates on two diagrammatic objects - points and line segments, and recognizes shapes, such as, square, triangle, path,
etc. The underlying representation is array- or grid-based. The perceptions, called retrieval
processes, are of dierent classes, such as, verify relationship, test for a condition, etc. The
actions, called construction processes, are also of dierent classes, such as, create an object
with certain properties, transform an object, etc. Executing the perceptions and actions require solving spatial problems, such as, create a segment parallel to a given segment through
a given point, rotate an object and check whether it coincides with another object, etc. An
example of a geometry theorem demonstrated by archimedes is shown in Figure 5.
The diamond (Jamnik, 2001), a system for proving mathematical theorems, uses a
sequence of actions on diagrams assisted by a human to prove specic ground instances and
then generalizes by induction. It uses a mixture of Cartesian and topological representations
to represent a dot (equivalent to a point in Cartesian representation) as a diagrammatic
object in the discrete space, and a line and an area (or region) as diagrammatic objects in the
continuous space. Elementary shapes, such as, row, column, ell, and frame, are constructed
from dots, while derived shapes, such as, square, triangle, rectangle, etc. are constructed
from the elementary or other derived shapes. The vocabulary consists of atomic or onestep operations (e.g., rotate, translate, cut, join, project from 3D to 2D, remove, insert a
segment, etc.). Spatial problems in this system are composite operations composed from the
atomic ones, such as, draw a right-angled triangle, translate and rotate a triangle, etc. The
system does not need to execute perceptions as information from a diagram is perceived by
379

fiBanerjee & Chandrasekaran

Figure 5: An example of a geometry theorem demonstrated by archimedes.

Figure 6: An example of a mathematical theorem proven by diamond. The theorem is
after Nelson (1993).

380

fiExecuting Perceptions and Actions in Diagrammatic Reasoning

a human who decides what actions to be applied during the proof search. An example of a
mathematical theorem proven by diamond is shown in Figure 6.
Georep (Ferguson & Forbus, 2000) takes as input a line drawing in vector graphics
representation and creates a predicate calculus representation of the drawings spatial relations. Five primitive shape types are recognized, namely line segments, circular arcs, circles
and ellipses, splines (open and closed), and positioned text. Properties and relations, such
as, proximity detection, orientation detection (e.g., horizontal, vertical, above, beside), parallelism, connectivity (e.g., detecting corner, intersection, mid-connection, touch), etc. are
deployed to accomplish its task. The underlying representation is vector graphics or line
drawings. Systems, such as, magi (Ferguson, 1994), juxta (Ferguson & Forbus, 1998),
and coadd are built using georep for symmetry detection, critiquing diagrams based on
their captions, and producing a description of the units, areas, and tasks from a course of
action diagram, respectively. georep, due to the limitation of its task, does not need to
execute any action. Examples of visual problems in georep include guring out which cup
contains more liquid (corresponding spatial problem: compare the areas of polygons representing the cups), determine whether a gure is symmetric or not (corresponding spatial
problem: check whether one polygon is congruent to the reection of the other polygon),
etc. An example of ambush analysis by georep is shown in Figure 7.

Figure 7: An example of ambush analysis by georep. Reproduced with permission from
Forbus et al. (2003).

The preceding discussion leads to the observation that all DR systems require perceiving from and/or acting on diagrams, and that every perception/action requires solving
a domain-independent spatial problem. Thus, a general-purpose DR system for solving
problems for applications across multiple domains would require solving a large variety of
non-trivial domain-independent spatial problems. These spatial problems can be described
381

fiBanerjee & Chandrasekaran

in terms of three diagrammatic objects  points, curves, regions, and spatial properties and
relations involving them.
1.4 The Problem
How are the perceptions and actions solved in a DR system? Typically, the human developing a DR system identies a priori the problem solving steps including a set of perceptions
and actions, and hand-codes ecient algorithms for solving each of them. If the problem
solving steps need to be altered in future and as a result, a new perception arises, the
developer has to write another algorithm for obtaining its solution. Thus, algorithms need
to be hand-coded for each perception/action. Clearly, this is inconvenient and time consuming in developing a DR system, and does not allow fast and easy experimentation with
dierent problem solving strategies for the same problem. These drawbacks are further
magnied when the goal is to build a general-purpose DR system where a very large variety of perceptions and actions are possible which is not feasible to ascertain a priori, and
develop and store algorithms for. Hence, our goal is to investigate a spatial problem solver
(SPS) for eciently solving spatial problems implicit in perceptions/actions without human
intervention.1
1.5 Contributions
In this paper, we make the following contributions:
1. We observe that the wide variety of visual perceptions/actions for DR applications can
be transformed into domain/task-independent spatial problems. We developed a language
for specifying spatial problems (i.e., spatial relations or actions) as quantied constraint
satisfaction problems (QCSPs) in rst-order logic using a xed set of mathematical/logical
operators in the real domain and an open-ended vocabulary of properties, relations and
actions. Any spatial relation or action involving only points that can be expressed using
those operators and real variables in rst-order logic can be included in the vocabulary.
Further, any spatial relation or action involving curves and/or regions that can be expressed
using the relations On(p, c) and/or Inside(p, r) where p is a point, c is a curve, r is a region,
and any relation/action involving only points in rst-order logic can be included in our
vocabulary. The vocabulary grows richer as more spatial relations and actions are specied.
2. Any spatial relation or action that can be included in the vocabulary is solvable by our
SPS. Real QCSPs are known to be computationally intractable, so a substantial part of the
spatial problem solving literature concentrates on constraint satisfaction problems (CSPs).
We developed a general framework for solving spatial problems specied as QCSPs. The
framework bypasses the process of quantier elimination (QE)  the computational bottleneck and a doubly exponential problem  by taking the help of previously solved similar
spatial problems. We show that, if the symbolic solution to a problem can be expressed
1. The reader should keep the DR architecture in mind. As shown in Figure 1, there are two problem
solvers  the main problem solver which will be always referred to as the problem solver (this might
be a human) and the spatial problem solver which will be referred to as the SPS (this strictly has no
human intervention). The problem solver is responsible for the entire problem solving strategy including
converting domain-specific perceptions and actions into domain-independent spatial problems. The SPS
is responsible only for solving the domain-independent spatial problems that it receives from the problem
solver. It is important to not get confused between the roles played by the two.

382

fiExecuting Perceptions and Actions in Diagrammatic Reasoning

concisely, quantiers can be eliminated from spatial problems in low-order polynomial time
using similar previously solved problems. The framework leaves room to be more ecient
and convenient by incorporating future results in at least two possible directions  learning
constraints from examples (automatic constraint acquisition) and carefully exploiting a rich
portfolio of QE algorithms.
The rest of the paper is organized as follows. In the next section, we discuss the language
for specifying a spatial problem to the SPS. Section 3 describes the SPS. Section 4 analyzes
the computational complexity of the SPS. Section 5 shows how the proposed SPS can be
augmented to a traditional AI problem solver (soar) for reasoning with diagrams in two
real-world applications. Finally, we end with discussion and conclusion.

2. Specification Language
In this section, we discuss a high-level language that is nite, extensible, human-usable,
and expressive enough to describe a wide variety of 2D spatial problems relevant to DR.
The problems specied in this language will be accepted as input by the SPS and solved
without human intervention. The specication language is independent of the SPS, i.e.,
the problem specication remains unchanged even if the underlying representation and
reasoning strategy of the SPS change.
2.1 Diagrammatic Objects
The specication language recognizes three kinds of diagrammatic objects  points, curves,
regions.
Point. A point is the basic diagrammatic object. The other objects are dened in terms
of a set of points.
Curve. A curve is the set of points on it. We approximate a curve piecewise-linearly.
Thus, if curve c is approximated by the sequence of n points {p1 , p2 , ...pn }, then c is the set
of points that lies on its constituent line segments, i.e.
c  {p : On(p, {p1 , p2 })  On(p, {p2 , p3 })  ...On(p, {pn1 , pn })}
where p  (x, y), x, y  , and {pi , pi+1 } is the line segment from pi to pi+1 . We call the
points {p1 , p2 , ...pn } vertex points. For the sake of simplicity of specication, the problem
solver will write the sequence of vertex points {p1 , p2 , ...pn } to specify a curve c.
Region. A region is the set of points inside its boundary. The boundary of a region is a
closed curve which is approximated piecewise-linearly. Thus, a region is a simple (convex
or concave) polygon. Any simple polygon can be triangulated such that a point inside the
region is inside one of the triangles. Thus, if the boundary of region r is approximated by
the sequence of n points {p1 , p2 , ...pn }, then
r  {p : Inside(p, (r)[1])  Inside(p, (r)[2])  ...Inside(p, (r)[m])}
where m is the number of triangles in region r after triangulation, (r)[i] is the ith triangle
of r, and p  (x, y), x, y  . For the sake of simplicity of specication, the problem solver
will write the sequence of vertex points {p1 , p2 , ...pn } of the boundary curve to specify a
383

fiBanerjee & Chandrasekaran

region r. Whether a sequence of vertex points corresponds to a curve or a region will be
determined automatically by the system from the context of the property/relation predicate.
More on how we dene On and Inside in section 3.1.
Further, the SPS can be asked to recognize the kind of diagrammatic object(s) obtained
as the solution to a spatial problem. This is achieved by the function Recognize(Dext )
where Dext is an external diagram (i.e., constituted of pixels unlike an abstract diagram).
For example, the set of all points behind a curve c with respect to a given point p can be a
region object or a curve object depending on the nature of c and its location with respect
to p. In order to recognize the output, the SPS colors the corresponding set of pixels on an
external diagram where each pixel at some predetermined resolution corresponds to a point.
The set of colored pixels are grouped such that two adjacent pixels always belong to the
same group. Each group of pixels constitutes a diagrammatic object. The boundary pixels
of each group is determined. If a group consists of less than three pixels, we consider it as
a point object. If a group consists of more than two pixels and its width (both horizontal
and vertical) is always less than three pixels, we consider it as a curve object. Otherwise,
the group constitutes a region object.
2.2 Vocabulary
Unlike certain well-known qualitative spatial reasoning calculi (e.g., intersection calculus
in Egenhofer, 1991, cardinal direction calculus in Frank, 1991, region connection calculus
in Randell, Cui, & Cohn, 1992), we are not interested in nding a minimal set of spatial
relations nor is our vocabulary based on a closed set of predicates. Rather, our vocabulary
is based on a closed set of operators (to be discussed shortly in section 2.3). The spatial
relations and actions that can be included in our vocabulary are as follows:
1. Any spatial relation or action involving only points that can be expressed using the
xed set of operators and real variables in rst-order logic.
2. Any spatial relation or action involving points, curves or regions that can be expressed
in rst-order logic using the xed set of operators, real variables, any relation/action from
#1, and the relations On(p, c) and/or Inside(p, r) where p is a point, c is a curve, r is a
region.
3. Any spatial relation or action involving points, curves or regions that can be expressed
in rst-order logic using the xed set of operators, real variables, and any relation/action
from #1 and #2.
Thus, our vocabulary is open-ended and addition of new properties and relations is
encouraged when a problem cannot be easily expressed using the existing ones. The observation is that, a human often encounters new perceptions/actions but most of them can be
specied using the already known ones. However, having a large vocabulary helps specify
new ones more conveniently. From the DR literature (Pisan, 1995; Tessler et al., 1995; Lindsay, 1998; Jamnik, 2001; Ferguson & Forbus, 2000; Chandrasekaran et al., 2004; Banerjee &
Chandrasekaran, 2004), we have identied a vocabulary of properties, relations and actions
based on their wide usage for expressing a variety of real-world spatial problems in dierent
domains. The same vocabulary will be used in this paper as a starting point for specifying
spatial problems. In what follows are a few examples of properties, relations and actions in
our vocabulary.
384

fiExecuting Perceptions and Actions in Diagrammatic Reasoning

Properties. Associated with each kind of object are a few properties  location of a
point; location, closedness and length of a curve; and location, area and periphery of a
region, where the periphery of a region refers to its boundary curve. The user can also
dene particular shapes (e.g., circle, triangle, annulus, etc.) for curves and regions as
appropriate for reasoning in his domain. Dierent shapes might have their own specic
properties, such as, radius of a circle, height of a triangle, etc. which can be easily associated
with the objects in our vocabulary by the user. DR also requires solving spatial problems
concerning a discrete set of points. For such problems, properties, such as, Centroid(S)
and V ariance(S), where S is a set of points, are included in the vocabulary.
Relations. The vocabulary also contains a few widely used relations (or relational
predicates) involving points, such as, Lef tof (p1 , p2 ), T opof (p1 , p2 ), Collinear(p1 , p2 , p3 ),
Between(p1 , p2 , p3 ) where p1 , p2 , p3 are points. Any other relation involving points can be
included in the vocabulary as needed. On(p, c), where p is a point and c a curve, is the
fundamental relation involving a curve while Inside(p, r), where p is a point and r a region, is the fundamental relation involving a region in our vocabulary as any other relation
involving curves or regions uses On and/or Inside. Some of the relational predicates involving curves or regions in our vocabulary are Intersect(c1 , c2 ), IntersectionP oints(q, c1 , c2 ),
T ouches(c1 , c2 ), Subcurveof (c1 , c2 ) where c1 , c2 are curves, and Subregionof (r1 , r2 ) where
r1 , r2 are regions.
Actions. Further, there is a set of predicates for identifying emergent objects or modications of existing objects. For example, T ranslate(q, O, tx , ty ) returns a translation of object
O for tx units along x-axis and ty units along y-axis, Rotate(q, O, c, ) returns a rotation of
the object O with respect to point c as center for  degrees in the anti-clockwise direction,
Ref lect(q, O, {a, b}) returns a reection of object O with respect to the line segment {a, b}
(i.e., from point a to point b), Scale(q, O, c, sx , sy ) returns a scaling of the object O with
respect to point c for sx units along x-axis and sy units along y-axis. When O is a curve or
region, each of these predicates is dened using the corresponding action involving a point
and the predicates On and/or Inside.

2.3 The Language
This is the language in which the problem solver (human or articial) species a spatial
problem to the SPS. The internal representations of objects, properties, relations, and the
problem-solving strategies are hidden from the problem solver. The specication language
remains unchanged even if the underlying representation or problem-solving strategy is
changed. We use rst-order predicate logic as the specication language, previously reported
by Banerjee and Chandrasekaran (2007).
Operators. The language recognizes a set of boolean operators {, , }, a set of arithmetic operators {+, , , }, a set of relational operators {<, >, =, =}, and the quantiers
{, }. The brackets () are used to express precedence while the brackets {} are used to
express a set. In this paper, we will often use certain combination of operators, such as, ,
, , etc. for the sake of brevity.
385

fiBanerjee & Chandrasekaran

Domain. The language allows the problem solver to specify the domain as a set from
which the variables can assume values. Unless otherwise stated, the domain is the real plane
2 for a point variable and the real line  for a non-diagrammatic variable.
Functions. Further, the language recognizes two functions  M aximize(f, {x, y, ...}, C)
and M inimize(f, {x, y, ...}, C), which maximizes and minimizes the function f with respect
to the variables {x, y, ...} satisfying the boolean combination of constraints C (which might
involve quantiers) and returns the maximum and minimum value of f respectively along
with the conditions on the variables.
Quantified Constraint Satisfaction Problem. An instance of a constraint satisfaction problem (CSP) consists of a tuple < V, D, C > where V is a nite set of variables,
D is a domain, and C= {C 1 , ...C k } is a set of constraints. A constraint C i consists of a pair
< S i , Ri > where S i is a list of mi variables and Ri is a mi -ary relation over the domain D.
The question is to decide whether or not there is an assignment mapping each variable to
a domain element such that all the constraints are satised. All of the variables in a CSP
can be thought of as being implicitly existentially quantied.
A useful generalization of the CSP is the quantied constraint satisfaction problem,
where variables may be both existentially and universally quantied. An instance of the
QCSP consists of a quantied formula in rst-order logic, which consists of an ordered list
of variables with associated quantiers along with a set of constraints. A QCSP can be
expressed as follows:
(v1 , ...vm )  Q(xn , ...x1 ) (v1 , ...vm , x1 , ...xn )
Q(xn , ...x1 )  Qn xn , ...Q1 x1
where Qi  {, }, {x1 , ...xn } is the set of quantied variables, {v1 , ...vm } is the set of free
variables, V= {v1 , ...vm , x1 , ...xn }, and  is a quantier-free expression called the matrix.
Such representation of a quantied expression , where it is written as a sequence of quantiers followed by the matrix, is referred to as prenex form. Example of a QCSP is as follows:
Subcurveof (c1 , c)  p, On(p, c1 )  On(p, c)
where c1 , c are curves in 2 . In this example, there are two constraints:
< {p, c1 }, On >
< {p, c}, On >
Further, V= {p} and D = 2 . The variables c, c1 are given. The question here is to
decide whether there is an assignment mapping p to an element in 2 such that the logical
combination of constraints is not satised. If such an assignment exists, then c1 is not a
subcurve of c; otherwise it is.
Decision, Function and Optimization problems. In the proposed specication
language, a spatial problem  is expressed as a QCSP where V consists of variables of type
point, curve or region and D = 2 . Solving a spatial problem involves:
1. When there are no free variables in V (i.e., all variables in V are quantied), deciding
whether or not there exists a mapping from V to D satisfying C.
386

fiExecuting Perceptions and Actions in Diagrammatic Reasoning

2. When there are free variables in V, computing the conditions on the free variables
such that a mapping from V to D satisfying C exists.
Thus, a spatial problem can be classied as a decision or a function or an optimization
problem in the real domain. The rst case constitutes a decision problem and yields a True
or False solution. The second case constitutes a function problem which involves computing
the diagrammatic object(s) described by the conditions on the free variables. If a spatial
problem requires computing the best mapping from V to D satisfying C, it is called an
optimization problem.
Let us consider an example. Given a curve c and two points p, q, the spatial problem
BehindCurve(q, c, p) is dened as deciding whether or not q is behind c with respect to
p. This might be specied as deciding whether or not the curve c and line segment {p, q}
intersect. Thus,
BehindCurve(q, c, p)  Intersect(c, {p, q})
For particular instances of q, p, c, the solution to this problem is T rue or F alse, hence
it is a decision problem (see Figure 8). For particular instances of p, c, and generalized
coordinates of q i.e., q  (x, y), the solution to the same problem is a logical combination
of conditions involving x and y, which when plotted constitutes a region object (see Figure
9). Hence, it is a function problem. While a decision problem merely requires checking
whether or not a given instance of an object satises the constraints or not, a function
problem requires computing all conditions for a general object to satisfy the constraints.

Figure 8: The BehindCurve as a decision problem. One of the points q is behind c with
respect to p while the other one is not.

Again, given a curve c and two points p, q, the spatial problem F urthestBehindCurve(q,
c, p) is dened as deciding whether or not q is the furthest point behind c with respect to
p. This might be specied as deciding whether or not q lies behind c with respect to p and
387

fiBanerjee & Chandrasekaran

Figure 9: The BehindCurve as a function problem. The shaded region r is behind c with
respect to p.

distance between p and q is maximum. Thus,
F urthestBehindCurve(q, c, p)  BehindCurve(q, c, p)  b, BehindCurve(b, c, p) 
CompareDistance(b, p, q, p)
CompareDistance(a, b, c, d)  Distance(a, b)  Distance(c, d)
For particular instances of q, p, c, the solution to this problem is T rue or F alse, hence it
is a decision problem. For particular instances of p, c, and generalized coordinates of q i.e.,
q  (x, y), the solution to the same problem is a logical combination of conditions involving
x and y, which when plotted constitutes a single point object, assuming there is only one
furthest point behind c with respect to p, which is dependent on the nature of c and how
the Distance function is dened (see Figure 10).
An alternative way of specifying the same problem F urthestBehindCurve(q, c, p) is by
explicitly asking to maximize the distance between p and q where q satises the constraint
BehindCurve(q, c, p), written as:
F urthestBehindCurve(q, c, p)  M aximize(Distance(q, p), {q}, BehindCurve(q, c, p))
This outputs the conditions involving x and y, which constitutes a single point object. The
M aximize (or M inimize) function assumes the pool of candidates from which to choose the
best are those that satisfy the set of constraints. This fact has to be stated explicitly if not
using the M aximize (or M inimize) function which makes the specication more dicult
to come up with and also cumbersome. On the ip side, the specication of a problem
using the M aximize (or M inimize) function cannot be used as a decision problem. That
is, whether or not a particular instance of an object is the best candidate that satises the
388

fiExecuting Perceptions and Actions in Diagrammatic Reasoning

q

Figure 10: The F urthestBehindCurve as an optimization problem. The point q is the
furthest point behind c with respect to p.

constraints cannot be computed from this specication, unlike the former specication. A
problem of this type, which computes the best candidate out of a pool of candidates, is
called an optimization problem.
Definition 6. Spatial Problem. A spatial problem (or problem) is a QCSP where a
variable (quantified or free) can only be of type point, and the domain is 2 .
Thus, a spatial problem  is a mapping from a diagram D satisfying a logical combination of constraints C to a set of booleans {T rue, F alse} or real numbers  or diagrammatic
objects D , i.e.,
C

 : D{T rue, F alse}  D
Solving a spatial problem requires eliminating the quantiers and solving algebraic equations/inequalities to arrive at the most simplied expression. The computational bottleneck
in solving a spatial problem is quantier elimination (QE) which is inherently doubly exponential (Davenport & Heintz, 1988). More recently, Brown and Davenport (2007) have
shown that real QE is doubly-exponential even when there is only one free variable and all
polynomials in the quantied input are linear. In this paper, we will concentrate primarily on QE as part of spatial problem solving and hence, our solution will be an equivalent
quantifier-free expression but not necessarily the most simplified one. Theoretically, the
best complexity for QE achieved so far is O(s(l+1)(ki +1) d(l+1)ki ) where s is the number
of polynomials, their maximum degree is d and coecients are real, l is the number
 of free
variables, ki is the number of variables in the ith quantier block while k =
ki is the
number of quantied variables (Basu, Pollack, & Roy, 2003). However, this algorithm is
too complicated to yet have a practical implementation. The most general and elaborately
implemented method for real QE is the cylindrical algebraic decomposition or CAD (Collins
389

fiBanerjee & Chandrasekaran

k1

& Hong, 1991), complexity of which is (sd)O(1) . Another implemented method, QE by
virtual substitution (Weispfenning, 1988), is restricted to formulas in which the quantied
variables occur at most quadratically. The complexity of this method is doubly exponential
in the number of blocks of variables delimited by alternations of the existential and universal quantiers. Thus, while there exist general algorithms for QE, for large real-world
problems, it soon becomes too time consuming.

3. Spatial Problem Solver
In this paper, we concentrate on developing an ecient SPS without sacricing its generality.
The goal of our design of the SPS is to bypass the general QE algorithms as much as possible,
either by taking the help of previously solved similar problems in memory to obtain the
solution or by using a set of more practical algorithms each of which is developed for a
limited class of problems. Here we describe the overall control mechanism of the SPS (see
Figure 11).
In many domains, such as, military, spatial problems involve diagrammatic objects that
are arbitrary shaped (e.g., mountainous regions) and often cannot be approximated enough
by well-dened shapes so that the solution can reliably depend on the specics of the shape.
For example, the solution to the problem of nding all places behind a mountain where one
can hide from the enemy depends critically on the particular shape of the mountain. Due
to such nature of domains, we choose to represent curves piecewise-linearly and regions
as polygons. Piecewise-linear curves and polygonal regions are unions of line segments
and triangular regions respectively, which facilitate decomposition of complex problems
into simpler and similar subproblems. We observe that similar subproblems involving
both existential and universal quantiers occur regularly in the spatial problem solving
process which are solved by one of the QE algorithms (e.g., CAD), thereby incurring doubly
exponential time. We minimize this enormous computational cost by reusing the solutions
of subproblems previously solved.
Given a spatial problem  in the specication language, the SPS replaces numerical values in the problem by symbolic variables, and then transforms the symbolic problem from
specication to a modeling language (to be described shortly) by progressively replacing
objects/predicates by base objects/predicates in their internal denitions. If a denition
cannot be found, it ags an error and halts till provided. As a rst step, the SPS decomposes  into disjunctions and/or conjunctions of subproblems i in prenex form. As we will
see later, all of these subproblems i are similar to each other in that if one of them can be
solved, solution to any of the others can be computed from it. Next, it searches the memory
for problems similar to i . The memory contains symbolic problems and their corresponding quantier-free symbolic solutions. If i can be mapped to one of these problems, its
solution is readily obtained by reverse-mapping from the corresponding symbolic solution
in memory. Obtaining a solution in such a way completely bypasses the QE process, which
is the computational bottleneck of the SPS, thereby reducing the computational costs considerably. If SPS cannot map i to any problem in memory, it sends i to the problem
classier that classies and sends it to the appropriate QE algorithm. The problem classier and combination of QE algorithms have been borrowed from Mathematica (Wolfram,
2003). Once the SPS solves a new subproblem, the subproblem and its solution are stored
390

fiExecuting Perceptions and Actions in Diagrammatic Reasoning

Problem I in
specification language

Convert problem to modeling language: Search
vocabulary and replace terms in specification by their
definitions, if exists; otherwise request their definition

Problem I in
modeling language
Decompose problem I into conjunctions and/or
disjunctions of subproblems in prenex form

For the first subproblem I1 ,
search memory for a
similar subproblem

Match found

Memory

Match not found

Compute the solution of
subproblem I1 with the
help of the solution to
the matched problem

Problem classifier and
combination of constraint
solvers and quantifier
elimination algorithms

Subproblem I1
and its
solution

Compute solutions of other subproblems
from the solution of I1 and combine them

Solution

Figure 11: Flow diagram of our spatial problem solver.
in memory so that the solution can be used when a similar problem is encountered in future.
Thus, the SPS grows more ecient as it solves more problems. Finally, the SPS computes
the solution to the given problem  by combining the solutions of all its subproblems.
Unfortunately, for some problems, quantiers cannot be eliminated symbolically in reasonable time. The SPS tries for a prescribed time, after which it resorts to more practical
391

fiBanerjee & Chandrasekaran

methods, such as, techniques especially suited for low degree polynomials (e.g., Dolzmann,
Sturm, & Weispfenning, 1998) and approximate methods for obtaining a subset of the solution sucient for immediate purposes (e.g., Ratschan, 2006; Lasaruk & Sturm, 2006). It
has been shown, in integer linear programming (e.g., Leyton-Brown, Nudelman, & Shoham,
2002) and satisability testing (e.g., Xu, Hutter, Hoos, & Leyton-Brown, 2008), that the
best on-average solver can be out-performed by carefully exploiting a portfolio of possibly
poorer on-average solvers, and accordingly, researchers have experimented with dierent
ways of selecting a portfolio of solvers (see for example, Xu et al., 2008; Pulina & Tacchella,
2007; Sayag, Fine, & Mansour, 2006; Streeter, Golovin, & Smith, 2007; Gebruers, Hnich,
Bridge, & Freuder, 2005; OMahony, Hebrard, Holland, Nugent, & OSullivan, 2008). As
none of these work involve solving QCSPs over the real domain, they are not directly usable
for our purposes and will not be further discussed in this paper. However, we do expect
the same result to extend to QCSP solvers over the real domain, and building and smartly
selecting from a portfolio of QCSP solvers is a promising line of future research. In our
approach, once a subproblem is deemed symbolically unsolvable in the prescribed time,
its specication is stored in memory so that in future, a similar problem can be directly
subjected to practical methods, thereby saving the prescribed time.
3.1 Modeling Language
This is the language in which a problem is described in terms of the underlying representations of objects/properties/relations in a form that can be readily subjected to algebraic
manipulation. The location of a point p is represented as a pair (x, y), x, y  , as its
coordinates.
Notation. The x- and y-coordinates of a point p are denoted by p.x and p.y respectively.
The distance between two points, p and q, is given by
Distance(p, q) 



(p.x  q.x)2 + (p.y  q.y)2

The location of a curve c is represented by the sequence of vertex points {p1 , p2 , ...pn }.
Notation. The number of vertex points in a curve c is denoted by #(c), the ith vertex
point is denoted by c[i], and the ith line segment is denoted by {c[i], c[i + 1]}.
A line segment ls is specied by its pair of vertex (or terminal) points. The x- and
y-coordinates of ls are represented parametrically as
fx (ls, t)  ls[1].x + t  (ls[2].x  ls[1].x)
fy (ls, t)  ls[1].y + t  (ls[2].y  ls[1].y)
where t is a parameter, 0  t  1. The relation On(p, ls), where p is a point, is given by
On(p, ls)  t, 0  t  1  fx (ls, t) = p.x  fy (ls, t) = p.y
Length of a line segment ls is given by

392

fiExecuting Perceptions and Actions in Diagrammatic Reasoning

Length(ls)  Distance(ls[1], ls[2])
Length of a curve c is given by


#(c)1

Length(c) 

Length({c[i], c[i + 1]})

i1

The location of a region r is represented by the location of its periphery which is a
piecewise linear closed curve. As discussed in section 2.1, internally a region is triangulated
(computable in linear time as shown in Chazelle, 1991; Seidel, 19912 ) with the aim of
reducing and simplifying computations (more on this in section 3.2).
Notation. On triangulation, the number of triangles in a region r is denoted by # (r)
while the ith triangle in r is denoted by (r)[i].
The area of a triangle  is given by
Area() 

1
2

3


[i].x  [i\3 + 1].y  [i\3 + 1].x  [i].y

i1

Note that the area of a triangle is positive if the sequence of vertex points on its periphery are
given in a counter-clockwise direction, otherwise it is negative. Area of a region r is given by
# (r)

Area(r) 



Area((r)[i])

i1

The relation Inside(p, ), where p is a point and  is a triangle, is given by
Inside(p, )  3i1 Lef tof (p, {[i], [i\3 + 1]})
Lef tof (p, ls)  Area({ls[1], ls[2], p}) > 0
where ls is a line segment.
The action T ranslate(q, c, tx , ty ) where q  (x, y), c is a curve, and tx , ty are real numbers, is given by
T ranslate(q, p, tx , ty )  q.x = p.x + tx  q.y = p.y + ty
T ranslate(q, c, tx , ty )  a, On(a, c)  T ranslate(q, a, tx , ty )
Definition 7. Base Object. A base object is the simplest form of a diagrammatic object.
A point is its own simplest form. A line segment is the simplest form of a curve. A
triangular region is the simplest form of a region. Thus, internally, there are three base
objects  point, line segment, triangle.
Definition 8. Base Predicate. A base predicate is a predicate which accepts only the base
objects as arguments.
2. Vik (2001) discusses an implementation in Mathematica.

393

fiBanerjee & Chandrasekaran

Examples of base predicates include Lef tof (p1 , p2 ), Between(p1 , p2 , p3 ), On(p, ls),
Inside(p, ), where p, p1 , p2 , p3 are points, ls is a line segment,  is a triangular region.
#(c)1

Lemma 1. On(p, c)  i1

On(p, {c[i], c[i + 1]})

Proof. The proof follows from our representation of a curve, as described in section 2.1.
# (r)


Lemma 2. Inside(p, r)  i1
Inside(p, (r)[i])

Proof. The proof follows from our representation of a region, as described in section 2.1.
The relations included in the vocabulary are internally dened in terms of base predicates. For example, the predicate, Intersect(c1 , c2 ) where c1 , c2 are curves, is dened in
terms of base predicates as
Intersect(c1 , c2 )
 a, On(a, c1 )  On(a, c2 )
#(c )1

 a, i11

#(c )1

On(a, {c1 [i], c1 [i + 1]})  j12

On(a, {c2 [j], c2 [j + 1]})

3.2 Decomposing a Problem
Definition 9. Decomposition. Decomposition is the process of replacing the relational
predicates, involving free variables of types curve and region, in a spatial problem (quantified expression) by conjunctions/disjunctions of base predicates and taking those conjunctions/disjunctions to the front of the expression. The expression following those conjunctions/disjunctions is a subproblem.
Example. Decomposition of the problem Intersect(c1 , c2 )  a, On(a, c1 )  On(a, c2 )
occurs as follows:
Intersect(c1 , c2 )  a, On(a, c1 )  On(a, c2 )
#(c )1

 a, i11

#(c )1

On(a, {c1 [i], c1 [i+1]})j12

On(a, {c2 [j], c2 [j+1]}) (bef ore decomposition)

#(c )1 #(c2 )1
j1 a, On(a, {c1 [i], c1 [i+1]})On(a, {c2 [j], c2 [j+1]})

 i11

#(c )1

 i11

#(c )1

j12

(af ter decomposition)

Intersect ({c1 [i], c1 [i + 1]}, {c2 [j], c2 [j + 1]})

where Intersect ({c1 [i], c1 [i + 1]}, {c2 [j], c2 [j + 1]}) is a subproblem. However, the question
#(c )1 #(c )1
arises  is Intersect(c1 , c2 )  i11 j12 Intersect ({c1 [i], c1 [i+1]}, {c2 [j], c2 [j +1]})?
That is, can we replace the  by a ?
Theorem 1. A problem is equivalent before and after decomposition if and only if it does
not contain the following forms:
394

fiExecuting Perceptions and Actions in Diagrammatic Reasoning

F1:

p, On(p, c)  Inside(p, r)

F2:

p, On(p, c)  Inside(p, r)

F3:

p, Inside(p, r)  Inside(p, r1 )

F4:

p, Inside(p, r)  Inside(p, r1 )

(complement of F1)

(complement of F3)

where c is a curve, r, r1 are regions, and c, r, r1 are free variables.
Proof. As discussed in section 2.2, in our framework, On(p, c) and Inside(p, r) are the two
fundamental relations using which any other relation involving a curve or region is specied.
Also, in our framework, point is the only quantiable variable, {, } are the only quantiers, and {, , } are the boolean operators sucient to express any boolean expression.
Thus, any spatial problem involving only curves (and points but no regions) is a logical
combination of smaller problems of the following form:
Qp, Rel(p, c) where Q  {, }, Rel  {On, On}
Any spatial problem involving only regions (and points but no curves) is a logical combination of smaller problems of the following form:
Qp, Rel(p, c) where Q  {, }, Rel  {Inside, Inside}
Any spatial problem involving both curves and regions (and points) is a logical combination
of smaller problems of the following form:
Qp, Rel1 (p, c)  Rel2 (p, r)
where Q  {, }, Rel1  {On, On}, Rel2  {Inside, Inside},   {, }
Any spatial problem involving two curves, c and c1 , (and points) is a logical combination
of smaller problems of the following form:
Qp, Rel1 (p, c)  Rel2 (p, c1 )
where Q  {, }, Rel1  {On, On}, Rel2  {On, On},   {, }
Again, any spatial problem involving two regions, r and r1 , (and points) is a logical combination of smaller problems of the following form:
Qp, Rel1 (p, r)  Rel2 (p, r1 )
where Q  {, }, Rel1  {Inside, Inside}, Rel2  {Inside, Inside},   {, }
We symbolically solved each of the above problems (56 total) in two ways  directly and by
decomposing  for p  (x, y), c  {p1 , p2 , ...pn } (n  2), pi  (xpi , ypi ), c1  {a1 , a2 , ...au }
395

fiBanerjee & Chandrasekaran

(u  2), ai  (xai , yai ), r  {q1 , q2 , ...qm } (m  3), qi  (xqi , yqi ), and r1  {b1 , b2 , ...bv }
(v  3), bi  (xbi , ybi ). It turned out that the solutions from the two ways were equivalent
for all problems, except the four cases stated in the theorem statement. Note that F 2 is
the specication for computing whether a curve c is entirely inside a region r or not. Let
lsi be the ith line segment of c (1  i  n  1) and j be the j th triangular region of r
(1  j  m  2). We found
p, On(p, c)  Inside(p, r)
m2
 p, (n1
i1 On(p, lsi ))  (j1 Inside(p, j ))
m2
 p, n1
i1 j1 (On(p, lsi )  Inside(p, j ))
m2
 n1
i1 j1 (p, On(p, lsi )  Inside(p, j ))

That is because, for c to be entirely inside r, it is not necessary for all line segments of c to
be inside a triangle of r; a line segment of c can span across multiple triangles of r and c
can still be inside r. Figure 12(a) shows an example where c is inside r but a line segment
of c spans across two triangles of r. In such a case, the solution to the problem will be
T rue when computed directly but will be F alse when computed via decomposition. The
rst case F 1 in the theorem statement can be explained similarly. The forms F 1 and F 2
can be rewritten as follows:
F1 :

p, On(p, c)  Inside(p, r)
 p, On(p, c)  Inside(p, r) where r  B  r

F2 :

p, On(p, c)  Inside(p, r)
 p, On(p, c)  Inside(p, r) where r  B  r

where B is the rectangular region (boundary) containing the diagram as discussed in section
1.2. Note that each of the rewritten forms is equivalent before and after decomposition.
Again, F 4 is the specication for computing whether a region r is entirely inside a region
r1 or not. Let 1,i be the ith triangle of r1 (1  i  v  2) and j be the j th triangular
region of r (1  j  m  2). We found
p, Inside(p, r)  Inside(p, r1 )
v2
 p, (m2
j1 Inside(p, j ))  (i1 Inside(p, 1,i ))
v2
 p, m2
j1 i1 (Inside(p, j )  Inside(p, 1,i ))
v2
 m2
j1 i1 (p, Inside(p, j )  Inside(p, 1,i ))

396

fiExecuting Perceptions and Actions in Diagrammatic Reasoning

r

r
c

(a) Curve c is inside region r but each line
segment of c is not inside one triangle of r.

r1

(b) Region r is inside region r1 but each triangle of r is not inside one triangle of r1 .

Figure 12: Examples to show the decomposition of curves and regions for problems containing the forms F 1, F 2, F 3, F 4.

That is because, for r to be entirely inside r1 , it is not necessary for all triangles of r to
be inside a triangle of r1 ; a triangle of r can span across multiple triangles of r1 and r can
still be inside r1 . Figure 12(b) shows an example where r is inside r1 but a triangle of r
spans across two triangles of r1 . In such a case, the solution to problem will be T rue when
computed directly but will be F alse when computed via decomposition. The third case
F 3 in the theorem statement can be explained similarly. The forms F 3 and F 4 can be
rewritten as follows:
F3 :

p, Inside(p, r)  Inside(p, r1 )
 p, Inside(p, r)  Inside(p, r1 ) where r1  B  r1

F4 :

p, Inside(p, r)  Inside(p, r1 )
 p, Inside(p, r)  Inside(p, r1 ) where r1  B  r1

Again, each of the rewritten forms is equivalent before and after decomposition.

Theorem 2. Any subproblem resulting from decomposing a problem contains base predicates
only.
Proof. A problem  is decomposable due to the presence of relational predicates, involving
free variables of types curve and region, in its specication. As stated in section 2.2, a
problem involving a curve or region can be specied in our framework using a relation(s)
involving only points and the relation On or Inside. Thus, a relation Rel(q, c) involving a
point q and a curve c can be rewritten as:
Rel(q, c)  a, On(a, c)  Rel (q, a)
or
397

fiBanerjee & Chandrasekaran

Rel(q, c)  a, On(a, c)  Rel (q, a)
where Rel is a base predicate involving the points q and a. In both cases, the expression
on the right-hand side of  contains base predicates only. Let  be a problem involving
points and curves but no regions. Let us replace in  each occurrence of non-base predicates
involving a curve, such as, Rel(q, c), by their equivalent expression consisting of On and
base predicates involving points and line segments only. Then the resulting expression for 
consists of base predicates involving points only and On. By lemma 1, a non-base On can
be rewritten as disjunctions of base On. Therefore, the resulting expression for  consists
of base predicates involving points only.
Similarly, a relation Rel(q, r) involving a point q and a region r can be rewritten as:
Rel(q, r)  a, Inside(a, r)  Rel (q, a)
or
Rel(q, r)  a, Inside(a, r)  Rel (q, a)
where Rel is a base predicate involving the points q and a. If  is a problem involving
points and regions but no curves, replacing each occurrence of non-base predicates involving
a region, such as, Rel(q, r), by their equivalent expression consisting of Inside and base
predicates involving points only, and then using lemma 2, results in an expression for 
consisting of base predicates involving points and triangular regions only. Both the above
processes can be employed when  involves both curves and regions. Thus, any subproblem
resulting from decomposing a problem will contain base predicates only.
3.3 Mapping to a Similar Problem
Definition 10. Similarity. We define two spatial problems (quantified expressions) to be
similar if there exists a one-to-one correspondence between their variables (free and quantified).
Given two similar problems, 1 and 2 , and the solution 1 of 1 , the goal is to construct
a one-to-one mapping  between the variables of 1 and 2 such that the solution of 2
can be obtained by replacing the variables in 1 by the corresponding variables, thereby
completely bypassing the QE process  the computational bottleneck of SPS. The one-toone mapping exists if 1 and 2 are logically equivalent. However, equivalence checking
for logical expressions is NP-hard (Dershowitz & Jouannaud, 1990; Goldberg & Novikov,
2003). Thus, equivalence checking cannot be used to determine similarity eciently.
Problem features. Let  be the quantier free expression when  is expressed in
prenex form, i.e.,
(v1 , ...vm )  Q(xn , ...x1 ) (v1 , ...vm , x1 , ...xn )
where no variable xi appears more than once in Q and Q contains no redundant variables.
A quantier block qb of Q is a maximal contiguous subsequence of Q where every variable
in qb has the same quantier type. The quantier blocks are ordered by their sequence of
appearance in Q; qb1  qb2 i qb1 is equal to or appears before qb2 in Q. Each quantied
398

fiExecuting Perceptions and Actions in Diagrammatic Reasoning



...
P1

V

P2

P3

V

P4



P6

P5
Figure 13: Parse tree for the matrix of a problem in conjunctive normal form.

variable xi in  appears in some quantier block qb(xi ), and the ordering of the quantier blocks imposes a partial order on the quantied variables. The variables in the same
quantier block are unordered.
Let 1  Q1 1 and 2  Q2 2 while 1 and 2 be the parse trees for 1 and 2 respectively. For example, the matrix  of a problem  in conjunctive normal form might look like:
  P1  (P2  P3 )  (P4  P5  P6 )  ...
where each Pi is a predicate. If  is a subproblem, each Pi is a base predicate. The parse
tree of the above sentence is shown in Figure 13.
Two trees, 1 and 2 , are isomorphic if there exists a bijection  : 1  2 that preserves adjacency and root vertex, i.e., (u) is adjacent to (w)  u is adjacent to w, and
(root(1 )) = root(2 ). It follows that two isomorphic trees have the same maximum height
and the same number of vertices at any height. Let l be the maximum height of  and i
be the number of vertices at height i. The function , dened as

(< 1 , ... >) =




i i

i1

where i is an integer, <> denotes a sequence, and i is the ith smallest prime number,
maps a sequence of integers to an unique integer. From a problem , a tuple () can be
constructed as follows:

399

fiBanerjee & Chandrasekaran

() =

< l,
(# vertices at dierent heights of parse tree),
# quantier blocks,
order of quantier blocks,
(# variables in dierent quantier blocks) >

Definition 11. Structural Equivalence. Two spatial problems (quantified expressions),
1 and 2 , are structurally equivalent if they satisfy all of the following conditions:
1. (1 ) = (2 )
2. 1 and 2 are isomorphic to each other, where 1 and 2 are the parse trees of the matrices
of 1 and 2 respectively.
3. The contents (predicate or boolean operator {, , }) of each pair of corresponding nodes
of 1 and 2 are identical.
4. There exists a one-to-one correspondence between the variables in the arguments of
predicates contained in each pair of corresponding nodes of 1 and 2 . Moreover, any two
mappings obtained from two pairs of corresponding nodes of 1 and 2 do not contradict
each other.
As we will see in section 4, structural equivalence of two problems can be computed
in time linear in the size of their parse trees. Note that if two problems are structurally
equivalent, they will be logically equivalent but not vice versa. For example, the expressions (P  P )  Q and Q, where P and Q are base predicates, are logically equivalent, but
not structurally equivalent since their parse trees are not isomorphic. In general, logical
equivalence does not imply structural equivalence when there are redundancies (redundant
variables and/or predicates) in one or both problems. For the sake of computational eciency, we will use structural equivalence to determine the similarity of two problems.
Theorem 3. All subproblems obtained by decomposing a problem are always similar.
Proof. Let us assume, for a contradiction, there exists a problem  that decomposes into
subproblems such that two of them, j and k , are dissimilar. Without loss of generality,
assume that all subproblems of  except k are similar to j . Then,

n

 (ni11=1 ni22=1 ... ipp=1 Qi1 i2 ...ip i1 i2 ...ip )  Qk k ,   {, },
j  {i1 i2 ...ip |0  i1  n1 , 0  i2  n2 , ...0  ip  np },
Qj  {Qi1 i2 ...ip |0  i1  n1 , 0  i2  n2 , ...0  ip  np }
n

 ni11=1 ni22=1 ... ipp=1 (Qi1 i2 ...ip Qk )(i1 i2 ...ip  k )
 ni11=1 ni22=1 ... ipp=1 Qi1 i2 ...ip i1 i2 ...ip
n

Thus, all subproblems of  are similar which contradicts our assumption. Hence the proof
follows.
Intuitively, in the proposed framework, while a curve is represented by an arbitrary number of vertices, a line segment is always represented by its two end points. Similarly, while
400

fiExecuting Perceptions and Actions in Diagrammatic Reasoning

the periphery of a region is represented by an arbitrary number of vertices, the periphery
of a triangular region is always represented by three vertices. Hence, two line segments or
triangular regions are always represented similarly and dier only in the coordinates of their
constituent vertices, unlike two curves or regions. The base predicates are dened in terms
of base objects  points, line segments, and triangular regions. Thus, when a predicate is
dened as conjunctions or disjunctions of base predicates, the base predicates are always
similar. Decomposition of a problem into subproblems merely replaces one or more of its
predicates by similar base predicates. Hence, all the subproblems have to be similar.
3.4 Memory Organization
Memory in the SPS is hierarchically organized and stores problems in disjoint classes based
progressively on a problems features in  (see Figure 14). After decomposing a problem
into subproblems and computing their , if the subproblems have the same value for ,
SPS checks whether or not their parse trees are isomorphic and a mapping exists between
their variables. Since the memory hierarchy has a constant height, insertion of a problem or
searching for a potential class of similar problems can be executed in constant time. Also,
the features that classify the problems are discriminative enough to create a large number
of classes (leaf nodes), each class containing only a few problems, thereby reducing search
to a few problems belonging to a class.

4. Computational Complexity
We will now analyze the time complexity of the algorithms used in our framework. In our
implementation, a problem  is a data structure consisting of two elds  P arseT ree and
Solution. The P arseT ree stores the lexicographically sorted parse tree of the matrix of
 while the Solution stores the symbolic solution to  in a concise form. A parse tree
can be constructed in time O(t) where t is the number of base predicates and boolean
operators {, , } in . The boolean operators occupy the non-leaf nodes in the parse tree
while the base predicates occupy the leaf nodes. Lexicographically sorting a tree requires
lexicographically sorting the contents of the children of each non-leaf node in the tree. Let
t be the number of boolean operators and ti be the number of children of the ith boolean
t

operator. Thus,
ti = t  1. Note that since each base predicate is always followed by
i1

a boolean operator, t = t where  is a constant. Lexicographically sorting a list of the
contents of the children of a node requires O(ti logti ) time. Thus, the total time required
t

for repeating this process for all non-leaf nodes is
O(ti logti ). Since the average number
i1



of children per node is

i1



tree is

t

i1

1
t

t


O(

ti =

t1
, the total time required to lexicographically sort a
t

t1
t1
log  ) = O(t).

t
t
401

fiBanerjee & Chandrasekaran

l
l1

...

lk

[ (# vertices at different

[ (# vertices at different

levels of parse tree)

levels of parse tree)

D

1

...

Dm

#(qb)

q1

...

#(qb)

qr

...

order of qbs

o1

...

...

order of qbs

os

...

[ (# variables in

[ (# variables in

different qb's)

different qb's)

E

1

...

Et

...

Problems

Problems

Figure 14: Hierarchical problem classication in memory. At each height in the hierarchy,
the branches correspond to the dierent values of the features captured by .
For example, l1 through lk correspond to the k dierent maximum heights of
parse trees for the matrices of spatial problems.

Given two problems  1 , 2 , the algorithm Similar(1 , 2 ) computes whether 1 and
2 are similar to each other or not (see Figure 15). Since computing  requires O(t) time,
line 1 requires O(t) time. Since checking whether two trees are isomorphic or not requires
O(t) time (as shown in Aho, Hopcroft, & Ullman, 1974), line 6 requires O(t) time. Lines 9
through 11 requires O(t) time. Thus, the algorithm runs in O(t) time.
Given an unsolved problem  and a similar solved problem similar , the algorithm
ComputeSolutionF romSimilarP roblem(, similar ) computes the solution to  by variable mapping from similar (see Figure 16). V ariableM ap is a list where each entry is
a pair < v, vsimilar >, v being a free variable in  and vsimilar is the corresponding free
variable in similar . Let the size of V ariableM ap be k  . The lines 5 through 11 requires
O(tk  ) time since the number of nodes in similar is t and the number of arguments in any
predicate is small. Lines 12 through 13 requires O(k  ) time where  is the size of the
solution to similar . Thus, the algorithm runs in O(tk  + k  ) time.
Finally, given an unsolved problem  and a memory M emory that stores problems hierarchically (as described in section 3.4), the algorithm EliminateQuantif iers(, M emory)
computes the solution to  by variable mapping from a similar problem in M emory, if such
a problem exists; otherwise solves  using a problem classier and combination of constraint
402

fiExecuting Perceptions and Actions in Diagrammatic Reasoning

Similar(1 , 2 )
1. if (1 ) = (2 ),
2.
return F alse
3. else
4.
1  1 .P arseT ree
5.
2  2 .P arseT ree
6.
if Isomorphic(1 , 2 ) = F alse,
7.
return F alse
8.
else
9.
for each node in 1
10.
if the predicate or boolean operator at the corresponding node in 2 does
not match,
11.
return F alse
12. return T rue

Figure 15: Algorithm for deciding whether two problems  1 , 2  are similar or not by
computing structural equivalence. A problem is a quantied expression.

ComputeSolutionF romSimilarP roblem(, similar )
1.   .P arseT ree
2. similar  similar .P arseT ree
3. similar  similar .Solution
4.   similar
5. for each node in similar
6.
if the node contains a predicate (say P ),
7.
for j  1 to # arguments in P
8.
v  variable occupying j th argument of P in 
9.
vsimilar  variable occupying j th argument of P in similar
10.
if V ariableM ap.Contains(v) = F alse,
11.
V ariableM ap.Add(< v, vsimilar >)
12. for i  1 to |V ariableM ap|
13.
Replace all occurrences of V ariableM ap[i, 2] in  by V ariableM ap[i, 1]
14. return 

Figure 16: Algorithm for computing the solution to a problem  by mapping variables
from a similar problem similar . The problem is a quantied expression and the
solution is the equivalent quantier-free expression.

solvers and QE algorithms (as described in section 3). The algorithm is shown in Figure
17.
403

fiBanerjee & Chandrasekaran

Let there be n subproblems to a problem. In a problem, some of the predicates are already base predicates while the rest are not which can be written as conjunctions/disjunctions
of base predicates thereby leading to decomposition of a problem into subproblems. For
example, in section 1.1, the problem RiskyP ortionsof P ath(q, c1 , c2 , d) is dened in terms
of the base predicate DistanceLessT han(p, q, d) (i.e., Distance(p, q)  d) and the nonbase predicates On(q, c1 ) and On(p, c2 ). Each of these non-base predicates can be written
as disjunctions of base predicates, such as, On(q, {c1 [i], c1 [i + 1]}) and On(q, {c2 [j], c2 [j +
1]}), respectively, thereby leading to decomposition of RiskyP ortionsof P ath into subproblems. Each of the subproblems inherits the base predicates from the problem (e.g.,
DistanceLessT han(p, q, d)) and also includes the new base predicates (e.g., On(q, {c1 [i], c1 [i+
1]}), On(q, {c2 [j], c2 [j + 1]})) obtained from the non-base predicates. Let  be the number
of polynomials in the base predicates of a problem and  be the number of polynomials due
to the newly obtained base predicates in a subproblem. Since all subproblems are similar,
each of them will have  +  polynomials. The total number of polynomials s in a problem
is O( + n).
Let d be the maximum degree of any polynomial in a subproblem. Since all subproblems
are similar, each of them will have maximum degree d. The maximum degree of polynomials
in a problem will also be d if objects are represented piecewise-linearly, in which case d  2.
If the objects are not represented piecewise-linearly, the degree will be much larger than
two which might lead to a situation where the problem might not be solvable in reasonable
time.
Let k be the number of quantied variables in a problem. Then each subproblem
also has k quantied variables. Let the computational complexity of using a general QE
algorithm for solving a problem be T (n) while that for solving a subproblem is T (1), where
k1
T is a doubly exponential function, such as, when using CAD, T (n) = (sd)O(1) . Note
that T (n)  nT (1), i.e., it is more ecient to solve each subproblem using a general QE
algorithm than to solve the whole problem using the same algorithm.
In algorithm EliminateQuantif iers(, M emory), lines 4 through 7 require O(n) time.
Lines 8 and 9 require O(t) time each. Since line 13 requires O(t) time, lines 11 through
16 require O(mt) time. Line 18 requires time T (1) while lines 20 through 23 require
O((n1)(tk  +k  )) time. Thus, the entire algorithm runs in O(T (1)+mt+(n1)(tk  +k  ))
time. Note that  is the size of the symbolic solution, and if the symbolic solution
can be expressed concisely,  is small. Since the number of boolean operators is of the
order of number of base predicates and each base predicate is dened in terms of at
least one polynomial, t = O(s) = O( + n). Thus, the complexity of the algorithm is
O(T (1) + (m + (n  1)k  )s + (n  1)k  ). It can be seen that
nT (1) > T (1) + (m + (n  1)k  )s + (n  1)k 
or,

(( + )d)O(1)

k1

m
> ( n1
+ k  )( + n) + k 

is true provided  is not large. That is, it is more ecient to solve a problem by variable
mapping than to solve each subproblem using a general QE algorithm provided the size of
the stored symbolic solution is not large. For every decomposable problem, the complexity
of QE can be reduced as above.
404

fiExecuting Perceptions and Actions in Diagrammatic Reasoning

EliminateQuantif iers(, M emory)
1. .Solution  
2. Decompose  into subproblems i  Qi i , 1  i  n
p

np
n1
n2

nk
where   i1 =1 i2 =1 ... ip =1 Qi i , n =
k1

3.
4.
5.
6.
7.
8.
9.
10.
11.
12.
13.
14.
15.
16.
17.
18.
19.
20.
21.
22.
23.

i1
for k  p to 1
for j  1 to nk
i  the ith operator ( or ) in decomposed  from right to left
ii+1
Construct the parse tree for the matrix 1
Compute ()
f lag  0
for j  1 to m
M emory,j  j th problem in M emory
if Similar(M emory,j , 1 ) = T rue,
similar  M emory,j
f lag  1
break loop
if f lag = 0,
1 .Solution  ComputeSolutionF romQEAlgorithms(1 )
similar  1
for i  (2  f lag + 2)\3 to n
i .Solution  ComputeSolutionF romSimilarP roblem(i , similar )
.Solution  .Solution i i .Solution
return .Solution

Figure 17: Algorithm for computing the solution to a spatial problem  taking the help
of previously solved similar problems in M emory, thereby bypassing quantier
elimination whenever possible. The problem is a quantied expression and the
solution is the equivalent quantier-free expression.

When a problem is encountered by the SPS for the rst time, it is solved by decomposing into subproblems, solving the rst subproblem using a general QE algorithm and
then obtaining the solution of the rest of the subproblems by mapping their variables to
the rst subproblem. Since a subproblem and its solution are stored in memory, if a similar
subproblem is encountered in future, the SPS bypasses the QE algorithm completely and
solves it by variable mapping. In such a case, line 18 of the algorithm is never executed,
and the time complexity of solving the problem is
(m + nk  )s + nk 

405

fiBanerjee & Chandrasekaran

which is a considerable savings compared to the complexity of solving the entire problem
k1
using a general QE algorithm (e.g., complexity of CAD is (sd)O(1) ), provided  is not
large. As the SPS solves more problems, the probability to encounter a similar problem in
memory increases thereby leading to the above scenario which incurs a complexity of low
order polynomial as compared to doubly exponential.3
Example. To illustrate the problem solving process, let us consider the spatial problem BehindCurve(q, c, p) (described in section 2.3). For a point p  (px , py ) and a curve
c  {p1 , p2 , ...pn } where pi  (xi , yi ) is a point, decomposition of the problem occurs as
follows:

 BehindCurve(q, c, p)
 Intersect(c, {p, q})
 a, On(a, c)  On(a, {p, q})
 a, (n1
i=1 On(a, {pi , pi+1 }))  On(a, {p, q})
 n1
i=1 (a, On(a, {pi , pi+1 })  On(a, {p, q}))

 n1
i=1 (Qi i )

 n1
i=1 i
Thus there are (n  1) subproblems i , where
i  On(a, {pi , pi+1 })  On(a, {p, q})
Qi  a
i  a, On(a, {pi , pi+1 })  On(a, {p, q})
From Figure 18, (i ) =< 2, 21 33 , 1, <  >, 21 > for i = 1, 2, ...n  1. By theorem 3,
all i s are similar since they are the subproblems of the same problem. If the SPS does
3. It should be noted that approximating a continuous curve by a sequence of line segments has its drawbacks. For example, a point p that is on a continuous curve c might not be on the piecewise-linear
approximation of c. The SPS can accept a parameter that specifies the maximum length of a line
segment to be used in the approximation. As of our current implementation, we leave the onus of determining this maximum length on the problem solver. In this context, it deserves mention that loss
of information is inevitable in almost any kind of approximation. For example, when the space in a
diagram is approximated by a finite number of pixels, as shown by Banerjee and Chandrasekaran (2010),
the diagrammatic objects lose certain spatial information that might be detrimental to spatial problem
solving which can be avoided by knowing the minimum allowable resolution (or maximum length of one
side of a square pixel).

406

fiExecuting Perceptions and Actions in Diagrammatic Reasoning



On(a,{p1,p2})

On(a,{p,q})

Figure 18: Parse tree for the matrix of the rst subproblem of the BehindCurve problem.

not nd a problem in memory similar to the rst subproblem 1 , it is sent to the problem
classier who sends it to the appropriate QE algorithm. The problem denition, its tuple
, parse tree, and solution are then stored in memory as follows:
1 (q, {p1 , p2 }, p)  a, On(a, {p1 , p2 })  On(a, {p, q})
1 ((x, y), {(x1 , y1 ), (x2 , y2 )}, (px , py ))
 (px  x < 0  px  x1  0  x1  x  0  py x1  py x + px y  x1 y  px y1 + xy1 = 0)  (x  px <
0  x1  px  0  x  x1  0  py x1  py x + px y  x1 y  px y1 + xy1 = 0)  ...
where the arguments of 1 are the free variables. The other subproblems are solved by
replacing the variables in 1 by the mapped variables. If a problem similar to 1 is found
in memory, 1 will also be solved by replacing the mapped variables, just as the other
subproblems.
Note that, for example, the BehindCurve problem, in the absence of an appropriate
vocabulary of properties/relations, would have been specied as (see redlog in Weispfenning, 2001):
BehindCurve((x, y), {(p1,x , p1,y ), (p2,x , p2,y ), ...(pn,x , pn,y )}, (px , py ))
 ax , ay , t, 0  t  1  px + t(x  px ) = ax  py + t(y  py ) = ay  n1
i1 (ti , 0  ti 
1  pi,x + ti (pi+1,x  pi,x ) = ax  py + ti (pi+1,y  pi,y ) = ay )
Here the total number of quantiers is n + 3, dependent on the number of line segments
forming the curve which can be huge for complicated curves as in many real-world applications. In our SPS, due to appropriate decomposition of problems into subproblems, the
number of quantiers in any subproblem is always xed (4 in this case) irrespective of the
spatial complexity of the object(s) (curve in this case). The symbolic solutions of these
simple subproblems can be stored for future use which is not possible in systems like redlog. Needless to say, though solving the problem using both the systems produce the same
solution, ours is much faster.
407

fiBanerjee & Chandrasekaran

5. Applications
In this section, we illustrate how the SPS can be deployed in conjunction with a problem
solver, human or articial (such as, soar), for solving spatial problems without human intervention as needed for DR. Two applications will be considered  entity re-identication
and ambush analysis  that are deemed very important in the military domain. The subproblems that the SPS autonomously decomposes each spatial problem into will be shown.
Problems in military domain involve a wide variety of objects with arbitrary properties and
relations, and hence, help to illustrate the expressiveness of the specication language and
the eciency and generality of the SPS.
For the implementation, we used bisoar, due to Kurup and Chandrasekaran (2007), a
bimodal version of soar (Laird et al., 1987), where the problem solver uses two kinds of operators  predicate-symbolic operators that are applied on information in predicate-symbolic
form and perception-like operators that are applied on a diagram  to bring about state
transitions to reach the goal state from an initial state. A human is responsible for providing
the broad problem solving strategy for a class of problems; given a specic problem from
that class, bisoar uses the predicate-symbolic and perception-like operators accordingly.
Since we have used bisoar in a number of dierent domains (e.g., military, Euclidean geometry, physics, civil engineering; Banerjee & Chandrasekaran, 2007 provide some examples)
and still continue to do so, it knows several dierent problem solving strategies and operators, both predicate-symbolic and perception-like. The emphasis of this section is not on
how eciently bisoar solves problems but on how eciently the perception-like operators
can be executed without incorporating any knowledge that jeopardizes the generality of a
general-purpose problem solver. For each spatial problem, we will compare the performance
of our proposed SPS with the CAD algorithm in terms of actual computation time which
is determined by taking the average of at least 10 runs. As we will see, the SPS excels by
a signicant margin in most cases.
5.1 Entity Re-identification
The entity re-identication problem is a core task in the US Armys All-Source Analysis
System (ASAS). ASAS receives a new report about sighting of an entity T3 of type T (e.g.
tanks). The task is to decide if the new sighting is the same as any of the entities in
its database of earlier sightings, or an entirely new entity. Reasoning has to dynamically
integrate information from dierent sources  database of sightings, mobility of vehicles,
sensor reports, terrain and map information  to make the decision. We will follow a novel
capability using failure of expectation: If H were true, O should have been observed, but
since it was not, H is likely not the case, where H and O are hypotheses and observations
respectively (Josephson & Josephson, 1996; Chandrasekaran et al., 2004). In the following,
we consider a simple version of the problem to illustrate how the task is solved using DR
and the spatial problems involved therein.
Figure 19(a) shows the terrain of interest  mountainous with the closed regions marking
impassable areas for entities of type T (e.g., tanks). Let T3 be an entity newly sighted at
time t3 located at point p3 while T1 , T2 are the two entities that were located at points p1 ,
p2 when last sighted at times t1 , t2 respectively. T1 and T2 were retrieved from the database
as having the potential to be T3 based on their partial identity information. Also, in the
408

fiExecuting Perceptions and Actions in Diagrammatic Reasoning

T2

T1

T3

(a) Terrain, impassable regions, and sighted tanks.

(c) A short path between T1 and T3 .

(b) A short path between T2 and T3 .

(d) A path from the only plausible homotopy
class.

Figure 19: Reasoning steps for entity re-identication
area of interest, there are three enemy regions or obstacles {r1 , r2 , r3 } (as shown in Figure
19(a)) with a given repower/sight range d of the enemy. Reasoning proceeds as follows. If
T1 can reach p3 within the time t3  t1 , then T3 might be T1 . Similarly for T2 . Since each
mountainous region (or obstacle) is a hiding place for enemies with a repower range d,
the existence of an entity shows that it most probably did not traverse through a territory
within the repower range. Further, there might be sensor elds that report to the database
when they sense entities. If no entity was sensed by a sensor eld between the times t1 and
t3 , then T1 could not have followed a path that passed through that sensor eld. Such
constraints have to be taken into account while reasoning. All information might not be
available in the database at once. In what follows is a simple scenario and a discussion of
the spatial problems as they occur.
The problem solver (e.g., a commander) wants to know whether there exists a contiguous
safe region containing the points p1 and p3 . He species the problem Saf eRegion as follows:
Saf eRegion(q, {r1 , r2 , ...rn }, d)

409

fiBanerjee & Chandrasekaran

 a, (ni1 Inside(a, ri ))  Distance(q, a)  d
# (ri )


 a, (ni1 j1

# (ri )


 a, (ni1 j1

Inside(a, (ri )[j]))  Distance(q, a)  d

Inside(a, (ri )[j]))  Distance(q, a)  d

# (ri )

a, Inside(a, (ri )[j])  Distance(q, a)  d

# (ri )

a, Inside(a, (ri )[j])  Distance(q, a)  d

# (ri )

Saf eRegion (q, {(ri )[j]}, d)


 ni1 j1

 ni1 j1

 ni1 j1

where q  (x, y). Decomposition of the problem by the SPS is shown above. The subproblem is symbolically solved and the solution stored in memory along with the subproblem
specication. In order to compare the actual times required to solve the problem, we constructed a very simple diagram consisting of four polygonal regions depicting obstacles (see
Figure 20(a)). The four regions are
r1  {(10, 10), (30, 10), (30, 30), (10, 30)},
r2  {(20, 0), (0, 0), (10, 20)},
r3  {(0, 20), (10, 40), (10, 40)},
r4  {(50, 20), (70, 20), (80, 40), (60, 50), (40, 40)},
while d  2. Triangulation of the regions produced seven triangles. Once a subproblem is
symbolically solved and stored, solving the problem required 0.25 seconds while solving the
same using the CAD algorithm required 5.5 seconds.
The diagram with the shaded safe region is input to the Recognize function which computes the vertices and boundaries of the shaded region, as shown in Figure 20(b). Next the
problem solver wants to know whether there exists a path between points p1 and p3 safely
avoiding the obstacles and enemy repower range, and whether that path can be traversed
in time t3  t1 . Let v be the velocity of the sighted entity  a piece of symbolic knowledge
available from the database. Then, the maximum length of path traversable in the given
time is L = v  (t3  t1 ). Let l  L be a rational number. Then, the problem of path
existence between two points s and t such that the path lies inside a region r and is less
than a given length l can be specied as:
P athExists(s, t, r, l)
 q, Inside(q, r)  Distance(s, q) + Distance(q, t)  l
# (r)


 q, (i1
Inside(q, (r)[i]))  Distance(s, q) + Distance(q, t)  l

410

fiExecuting Perceptions and Actions in Diagrammatic Reasoning

r3

r3

r4

r4

r1

r1

r2

r2



(a) The unshaded polygons are obstacles. The
shaded region is the safe region, as computed by
the SPS.

(b) The points shown are vertices of the boundaries of the safe region as computed by the
Recognize function.

s

s

r3

r3

r4

r1

r2

r4

r1

r2

t

t



(c) Paths lying in the safe region and less than a
given length between two points, as computed by
the SPS.

(d) Paths lying in the safe region and less than a
given length between two points, as computed by
the CAD algorithm.

Figure 20: A simplied scenario to illustrate the performance of the proposed SPS as compared to the CAD algorithm for entity re-identication.

# (r)


 i1
q, Inside(q, (r)[i])  Distance(s, q) + Distance(q, t)  l

# (r)


 i1
P athExists (s, t, (r)[i], l)

411

fiBanerjee & Chandrasekaran

Decomposition of the problem by the SPS is shown above. The subproblem is symbolically
solved and stored. Again, we resort to the simple diagram in Figure 20 to compare the actual
computation times for the P athExists(s, t, r, l) problem, where s  (0, 45), t  (20, 5),
r  Recognize(Saf eRegion((x, y), {r1 , r2 , ...rn }, 2)), and dierent sets of regions ri and
dierent values of l. Triangulation of r produced 8, 7, 7, 9 and 24 triangles for {r1 }, {r2 },
{r3 }, {r4 } and {r1 , r2 , r3 , r4 } respectively. Once a subproblem is symbolically solved and
stored, the computation times required for solving the problem using the proposed SPS is
signicantly less than that using the CAD algorithm (see Table 1).

Table 1: Comparison of computation times (in seconds) between the CAD algorithm and
our proposed SPS for the P athExists(s, t, r, l) problem, where s  (0, 45), t 
(20, 5), r  Recognize(Saf eRegion((x, y), {r1 , r2 , ...rn }, 2)). A 2.8 GHz PC with
4 GB RAM, 5356 MB virtual memory and 32-bit operating system was used. The
implementation was done in M athematica. Below, res refers to result, T 
refers to T rue, F  refers to F alse, and OOM  refers to out of memory.

l
100
 500
1000
1009
1010
2000
4000
 8000
16000

{r1 }
CAD,SPS,res
2.78, 0.41, F
2.77, 0.42, F
2.66, 0.39, F
2.28, 0.42, T
2.28, 0.41, T
1.88, 0.39, T
1.88, 0.34, T
1.88, 0.33, T
1.88, 0.33, T

{r2 }
CAD,SPS,res
498.22, 0.53, F
482.77, 0.44, F
118.97, 0.55, T
119.28, 0.52, T
120.06, 0.53, T
120.38, 0.42, T
120.73, 0.39, T
121.58, 0.34, T
121.45, 0.34, T

{r3 }
CAD,SPS,res
470.74, 0.5, F
476.97, 0.5, F
135.03, 0.49, T
134.75, 0.5, T
135.02, 0.52, T
135.3, 0.38, T
135.08, 0.34, T
135.03, 0.33, T
135.13, 0.36, T

{r4 }
CAD,SPS,res
OOM, 0.47, F
OOM, 0.48, F
OOM, 0.49, T
OOM, 0.52, T
OOM, 0.47, T
OOM, 0.44, T
OOM, 0.31, T
OOM, 0.39, T
OOM, 0.36, T

{r1 , r2 , r3 , r4 }
CAD,SPS,res
OOM, 1.42, F
OOM, 1.42, F
OOM, 1.42, F
OOM, 1.42, F
OOM, 1.41, T
OOM, 1.19, T
OOM, 1.0, T
OOM, 0.98, T
OOM, 0.92, T

In general, the P athExists(s, t, r, l) problem can be specied as:
P athExists(s, t, r, l)
 q1 , q2 , ...qn , (a, On(a, {s, q1 , q2 , ...qn , t})  Inside(a, r))  Length({s, q1 , q2 , ...qn , t})  l
 q1 , q2 , ...qn , (a, On(a, c)  Inside(a, r))  Length(c)  l
 q1 , q2 , ...qn , (a, On(a, c)  Inside(a, r))  Length(c)  l
# (r)


 q1 , q2 , ...qn , (a, On(a, c)  (k1
Inside(a, (r)[k])))  Length(c)  l

# (r)


 q1 , q2 , ...qn , (a, On(a, c)  (k1
Inside(a, (r)[k])))  Length(c)  l

412

fiExecuting Perceptions and Actions in Diagrammatic Reasoning

# (r)


 k1
q1 , q2 , ...qn , (a, On(a, c)  Inside(a, (r)[k]))  Length(c)  l

# (r)


 k1
P athExists (s, t, (r)[k], l)

where c  {s, q1 , q2 , ...qn , t} and r  Br. Note that even though c is a curve, On(a, c)
cannot be decomposed since c is not a free variable (see denition of Decomposition in
section 3.2). Also, note that the above problem contains the form F 2 discussed in T heorem
1, so r has been used.
If there exists a path between points p1 and p3 safely avoiding the obstacles and enemy
repower range such that it can be traversed in time t3  t1 , then the problem solver wants
to compute the path(s). The problem can be specied as:
F indP ath(q, s, t, r, l)
 Inside(q, r)  Distance(s, q) + Distance(q, t)  l
# (r)


 (i1
Inside(q, (r)[i]))  Distance(s, q) + Distance(q, t)  l

# (r)


 i1
Inside(q, (r)[i])  Distance(s, q) + Distance(q, t)  l

# (r)


 i1
F indP ath (q, s, t, (r)[i], l)

where q  (x, y). Since there are no quantiers, solving the problem by decomposition and
variable mapping does not achieve reduction in computation time by anysignicant amount.
The region consisting of all paths that satisfy the constraints (l  1010) is shown in
Figure 20(c). The quality of the solution depends on the Recognize function. For example,
the solution shown in Figure 20(d) is more accurate than in Figure 20(c) as the Recognize
function failed to determine the vertices of the safe region accurately. An alternate denition
of the semi-linear motion planning problem can be found in Weispfenning (2001), where a
semi-linear path consists of n translations along straight lines each of which is parallel to
one of the given k vectors.
From the results, the problem solver infers that T3 might be T1 . Next he repeats the
same for entities T3 and T2 , and nds that there exists a path between points p2 and p3
safely avoiding the obstacles and enemy repower range such that it can be traversed in
time t3  t2 . So T3 might be T2 as well. The sensor database informs that there are two
sensor elds  SENSOR1, SENSOR2  in the area of interest but there has been no report from
them of any passing vehicle. Problem solver wants to verify whether any of the paths passes
through any of the sensor elds. He species the problem Intersect(r1 , r2 ) to compute the
intersection of two regions r1 and r2 .
IntersectRegions(r1 , r2 )
 q, Inside(q, r1 )  Inside(q, r2 )
# (r1 )


 q, (i1

# (r2 )


Inside(q, (r1 )[i]))  (i1

Inside(q, (r2 )[j]))

413

fiBanerjee & Chandrasekaran

# (r1 )


 i1

# (r2 )


j1

IntersectRegions ((r1 )[i], (r2 )[j])

He
computes
the
problem
IntersectRegions(paths13 , s1 ) where paths13  Recognize(F indP ath(q, p1 , p3 , r, l)) and
s1 is the region covered by SENSOR1. In our scenario in Figure 19(c), the solution is T rue.
Next the problem solver wants to know whether there exists a path between points p1 and
p3 safely avoiding the obstacles and enemy repower range such that it can be traversed in
time t3  t1 . He computes P athExists(p1 , p3 , r13 , l), where r13  Recognize(paths13  s1 ),
which returns T rue. The inference follows that T3 might be T2 . The same reasoning is
repeated for T3 and T2 ; Intersect(paths23 , s2 ) returns T rue while P athExists(p2 , p3 , r23 , l)
returns F alse (see Figure 19(b)). The inference follows that T3 cannot be T1 . Hence, the
problem solver identies T3 as T2 .
The entity reidentication problem could also have been solved by computing the shortest paths between the pairs p1 , p3 and p2 , p3 avoiding the sensors and checking whether
their lengths satisfy the time constraints. That requires computing the shortest path between two points p1 and p3 safely avoiding the obstacles and enemy repower range (i.e.,
lying entirely within the safe region r). Since such a path will not have any loop and will
share its intermediate vertices, if any, with the vertices of r, the path can have at most
#(r) intermediate vertices. Let S  r  {p1 , p3 }, m  #(S), and c  {q1 , q2 , ...qm } be
the shortest path, where q1  p1 , qm  p3 , qi  r (2  i  m  1). Then, the problem of
computing the shortest path can be specied as
F indShortestP ath(r, c)
 M inimize(Length(c), {c[2], c[3], ...c[m  1]}, CurveInsideRegion(c, r))
where CurveInsideRegion(c, r) is the constraint that can be specied and decomposed as
follows.
CurveInsideRegion(c, r)
 a, On(a, c)  Inside(a, r)
 a, On(a, c)  Inside(a, r)
 a, On(a, c)  Inside(a, r)
#(c)1

 a, (i1

# (r)

a, On(a, {c[i], c[i + 1]})  Inside(a, (r)[j])

# (r)

CurveInsideRegion ({c[i], c[i + 1]}, (r)[j])

#(c)1


j1

#(c)1


j1

 i1
 i1

# (r)


On(a, {c[i], c[i + 1]}))  (j1
Inside(a, (r)[j])))

414

fiExecuting Perceptions and Actions in Diagrammatic Reasoning

where r  Br. Since the above problem is of the form F 2, r had to be used. Once a subproblem is symbolically solved and stored, solving the problem CurveInsideRegion(c, r),
where
c  {(0, 45), (14, 42), (35, 42), (15, 35), (34, 32), (36, 19), (47, 15), (87, 15), (30, 7), (20, 5)},
r  Recognize(Saf eRegion((x, y), {r1 , r2 , r3 , r4 }, 2)),
by SPS required 3.11 seconds while solving the same using the CAD algorithm required 175.01 seconds (see Figure 21(a)). The shortest path obtained by solving the
F indShortestP ath(r, c) problem is shown in Figure 21(b).

(a) A path c between two points lying inside the
shaded region r.

(b) Shortest path between two points as computed
from the F indShortestP ath(r, c) problem.

Figure 21: Paths between two points lying inside the safe (shaded) region.

5.2 Ambush Analysis
There are two main factors  range of repower and sight  that determine the area covered
by a military unit. Presence of terrain features, such as, mountains, limit these factors
and allow units to hide from opponents. These hidden units not only enjoy the advantage
of concealing their resources and intentions from the opponents but can also attack the
opponents catching them unawares if they are traveling along a path that is within the
sight and repower range of the hidden units, thereby ambushing them. Thus, it is of
utmost importance for any military unit to a priori determine the areas or portions of a
path prone to ambush before traversing them. We had already described in section 1.1 how
a problem solver (e.g., an army commander) reasons using diagrams to gure out the safest
path to transport his troops from one base camp to another in a given time. In this section,
given a curve or region as a hiding place and the repower and sight ranges, we show how
415

fiBanerjee & Chandrasekaran

the regions and portions of path prone to ambush is eciently computed by the proposed
SPS.
Given a curve c and the repower and sight range d, the spatial problem
RiskyRegion(q, c, d) is dened as the set of all points covered by that range from c. Thus,
the problem specication is:
RiskyRegion(q, c, d)
 a, On(a, c)  Distance(a, q)  d
#(c)1

 a, (i1

On(a, {c[i], c[i + 1]}))  Distance(a, q)  d

#(c)1

a, On(a, {c[i], c[i + 1]})  Distance(a, q)  d

#(c)1

RiskyRegion (q, {c[i], c[i + 1]}, d)

 i1
 i1

where q  (x, y). In order to compare the actual computation times required to solve the
problem, we constructed a very simple diagram consisting of two curves, path and mntn,
where
path  {(25, 10), (5, 10), (3, 15), (7, 17), (2, 18), (2, 18), (7, 15),
(3, 12), (5, 10), (40, 10)}
mntn  {(5, 5), (7, 2), (9, 9), (6, 12), (0, 4), (2, 3), (15, 5), (25, 12), (30, 20)}
The solution to the problem RiskyRegion(q, mntn, d) is the shaded region shown in Figure
22(a) where mntn is an obstacle for hiding (e.g., mountain range) and d  15. The problem
RiskyRegion(q, r, d) for a region r can be specied by replacing the predicate On(p, c) by
Inside(p, r).
Again, given a curve c1 as a path, a curve c2 for hiding, and a repower range d, the
problem RiskyP ortionsof P ath(q, c1 , c2 , d) is dened as parts of c1 covered by that range
from c2 . Thus,
RiskyP ortionsof P ath(q, c1 , c2 , d)
 On(q, c1 )  p, On(p, c2 )  Distance(p, q)  d
#(c )1

 p, (i11
d
#(c )1

j12

#(c )1

j12

 i11
 i11

#(c )1

On(q, {c1 [i], c1 [i+1]}))(j12

#(c )1

#(c )1

On(p, {c2 [j], c2 [j +1]}))Distance(p, q) 

p, On(q, {c1 [i], c1 [i+1]}))On(p, {c2 [j], c2 [j +1]})Distance(p, q)  d
RiskyP ortionsof P ath (q, {c1 [i], c1 [i + 1]}, {c2 [j], c2 [j + 1]}, d)

416

fiExecuting Perceptions and Actions in Diagrammatic Reasoning

(a) The shaded region, as computed from the
problem RiskyRegion(q, mntn, 15), is the risky
region prone to ambush due to enemies hiding at
mntn. The portions of path inside the risky region are the risky portions of the path.

(b) The bold parts of path, as computed
from the problem RiskyP ortionsof P ath(q, path,
mntn, 15), are the risky portions of the path.
The shaded region, as computed from the problem BehindCurvewrtRiskyP ath(q, mntn, path),
is where enemies could be hiding from troops traveling on path.

(c) Troops traveling on rskyprtn1 , a risky portion (in bold) of path, should be careful of being
ambushed by enemies hiding in the shaded region because rskyprtn1 is within firepower range
from that region, computed from the problem
BehindCurvewrtRiskyP athDistance(q, mntn,
rskyprtn1 , 20).

(d) Troops traveling on rskyprtn2 , a risky portion (in bold) of path, should be careful of being
ambushed by enemies hiding in the shaded region because rskyprtn2 is within firepower range
from that region, computed from the problem
BehindCurvewrtRiskyP athDistance(q, mntn,
rskyprtn2 , 20).

Figure 22: A simplied scenario to illustrate the performance of the proposed SPS for ambush analysis.

417

fiBanerjee & Chandrasekaran

where q  (x, y). Alternatively, the same problem can be specied as
RiskyP ortionsof P ath(q, c1 , r2 , d)
 On(q, c1 )  Inside(q, r2 )
#(c )1

 (i11

# (r2 )


On(q, {c1 [i], c1 [i + 1]}))  (j1

# (r2 )

On(q, {c1 [i], c1 [i + 1]})  Inside(q, (r2 )[j])

# (r2 )

RiskyP ortionsof P ath (q, {c1 [i], c1 [i + 1]}, (r2 )[j], d)

#(c )1


j1

#(c )1


j1

 i11

 i11

Inside(q, (r2 )[j]))

where r2  Recognize(RiskyRegion((x, y), c2 , d)) and q  (x, y).
The solution
to the problem RiskyP ortionsof P ath(q, path, mntn, d), where d  15, is the parts
of path inside the shaded region shown in Figure 22(a). Figure 22(b) shows the
risky portions of the path  rskyprtn1 , rskyprtn2  in bold as obtained from
Recognize(RiskyP ortionsof P ath(q, c1 , c2 , d)).
rskyprtn1  {(16, 10), (5, 10), (3.7, 12.6)}
rskyprtn2  {(3, 12), (5, 10), (16.1, 10)}
Note that the latter specication is free from quantiers while the former is not. However,
the solution computed from the latter specication might have less accuracy than the same
from the former due to the use of Recognize function. If the hiding place is a region r
instead of the curve c2 , the problem RiskyP ortionsof P ath(q, c1 , r, d) can be specied by
replacing the predicate On(p, c2 ) by Inside(p, r). The portions of the path marked in Figure
2(c) is computed from this specication.
The region behind c2 where the enemies might be hiding is the set of all points that are
behind c2 with respect to each point on the risky portions of curve c1 . Thus, if c is a risky
portion of a path, we have
BehindCurvewrtRiskyP ath(q, c2 , c)
 a, On(a, c)  BehindCurve(q, c2 , a)
 a, On(a, c)  Intersect(c2 , {a, q})
 a, On(a, c)  (b, On(b, c2 )  On(b, {a, q}))
#(c)1

 a, b, (i1
#(c)1

 i1

#(c )1

j12

#(c )1

On(a, {c[i], c[i + 1]}))  (j12

On(b, {c2 [j], c2 [j + 1]}))  On(b, {a, q})

(a, b, On(a, {c[i], c[i + 1]})  On(b, {c2 [j], c2 [j + 1]})  On(b, {a, q}))

418

fiExecuting Perceptions and Actions in Diagrammatic Reasoning

#(c)1

 i1

#(c )1

j12

BehindCurvewrtRiskyP ath (q, {c2 [j], c2 [j + 1]}, {c[i], c[i + 1]})

where
q  (x, y). The solution to the problem BehindCurvewrtRiskyP ath(q, mntn, rskyprtn1 )
BehindCurvewrtRiskyP ath(q, mntn, rskyprtn2 ) is the shaded region shown in Figure 22(b). If the hiding place is a region r instead of the curve c2 , the problem
BehindCurvewrtRiskyP ath(q, r, c) can be specied by replacing the predicate On(p, c2 )
by Inside(p, r).
However, the enemies might be hiding not anywhere behind a mountain but within
a distance from where they can ambush the friendly units. Hence, a more reasonable problem for the commander from the friendly side to compute would be
BehindCurvewrtRiskyP athDistance(q, c2 , c, d) where d is the distance from where the
enemies can ambush them. The problem is specied as:
BehindCurvewrtRiskyP athDistance(q, c2 , c, d)
 a, On(a, c)  BehindCurve(q, c2 , a)  Distance(a, q)  d
 a, On(a, c)  Intersect(c2 , {a, q})  Distance(a, q)  d
 a, On(a, c)  (b, On(b, c2 )  On(b, {a, q}))  Distance(a, q)  d
#(c)1

#(c )1

 a, b, (i1 On(a, {c[i], c[i + 1]}))  (j12
Distance(a, q)  d
#(c)1

On(b, {c2 [j], c2 [j + 1]}))  On(b, {a, q}) 

#(c )1

 i1 j12
(a, b, On(a, {c[i], c[i + 1]})  On(b, {c2 [j], c2 [j + 1]})  On(b, {a, q})) 
Distance(a, q)  d
#(c)1

 i1
1]}, d)

#(c )1

j12

BehindCurvewrtRiskyP athDistance (q, {c2 [j], c2 [j + 1]}, {c[i], c[i +

where
q

(x, y).
The solutions to the problems BehindCurvewrtRiskyP athDistance(q, mntn, rskyprtn1 , d)
and BehindCurvewrtRiskyP athDistance(q, mntn, rskyprtn2 , d), where d  20, are the
shaded regions shown in Figure 22(c), 22(d) respectively. If the hiding place is a region r
instead of the curve c2 , the problem BehindCurvewrtRiskyP athDistance(q, r, c, d) can be
specied by replacing the predicate On(p, c2 ) by Inside(p, r). A comparison between the
CAD algorithm and our proposed SPS of actual times required to compute the problems
relevant to ambush analysis as discussed above is shown in Table 2.

419

fiBanerjee & Chandrasekaran

Table 2: Comparison of computation times (in seconds) between the CAD algorithm and
our SPS for the dierent problems relevant to ambush analysis. A 2.8 GHz PC
with 4 GB RAM, 5356 MB virtual memory and 32-bit operating system was used.
The implementation was done in M athematica. All of the following are function
problems where q  (x, y).
P roblem
RiskyRegion(q, mntn, 15)
RiskyP ortionsof P ath(q, path, mntn, 15)
BehindCurve(q, mntn, (5, 10))
BehindCurvewrtRiskyP ath(q, mntn, path)
BehindCurvewrtRiskyP ath(q, mntn, rskyprtn1 )
BehindCurvewrtRiskyP ath(q, mntn, rskyprtn2 )
BehindCurvewrtRiskyP athDistance(q, mntn, rskyprtn1 , 20)
BehindCurvewrtRiskyP athDistance(q, mntn, rskyprtn2 , 20)

SPS
0.11
0.3
0.27
50.2
8.04
10.92
6.16
6.3

CAD
0.11
0.48
0.71
102.88
11.89
17.48
16.08
15.33

6. Discussion
Spatial problem solving has been an area of active research since Sutherlands sketchpad
(1963). The need to access, communicate and manipulate spatial information precisely
(much as engineers and scientists do) using a high-level language (much as common people
use) has been one of the frontiers in AI. It has been well-known that such capabilities
are oered by rst-order predicate logic and that, rst-order logic is generally intractable
except for limited domains. Under the umbrella of Qualitative Spatial Reasoning (QSR),
researchers have investigated a plethora of spatial calculi, the most prominent of which are
mereotopological calculi (Clarke, 1981; Bennett, 1997), cardinal direction calculus (Frank,
1991, 1992; Skiadopoulos & Koubarakis, 2004), double cross calculus (Freksa, 1992), 4and 9-intersection calculi (Egenhofer, 1991; Egenhofer & Franzosa, 1991), ip-op calculus
(Ligozat, 1993), dipole calculus (Moratz, Renz, & Wolter, 2000; Schlieder, 1995; Dylla &
Moratz, 2005), and the various region connection calculi (Randell et al., 1992; Bennett, Isli,
& Cohn, 1997; Gerevini & Nebel, 2002; Cohn, Bennett, Gooday, & Gotts, 1997; Duntsch,
Wang, & McCloskey, 1999; Gerevini & Renz, 1998). There are two main points of distinction
between QSR and our approach to spatial problem solving as reported in this paper.
1. The dierent QSR calculi emphasize dierent aspects of space, such as, ontological issues, topology, distance, orientation, shape, etc. Depending on the spatial aspect of interest, the calculus is based on a minimal set of spatial relations.
For example, the 9-intersection calculus (Egenhofer & Franzosa, 1991) is
based on nine spatial relations {r0 , r1 , r3 , r6 , r7 , r10 , r11 , r14 , r15 } between two spatial regions, the double cross calculus (Freksa, 1992) is based on fteen spatial relations
{lf, lp, lc, ll, lb, sf, sp, sc, sl, sb, rf, rp, rc, rl, rb} among three points, etc. Our framework
is not based on a minimal set of spatial relations; it is based on a xed set of mathematical/logical operators (see section 2.3). Any spatial relation among points that can be
expressed using real variables and the xed set of operators in rst-order logic is included in
our vocabulary. Any spatial relation involving curves and/or regions that can be expressed
420

fiExecuting Perceptions and Actions in Diagrammatic Reasoning

in rst-order logic using spatial relations among points and the relations On and Inside is
included in our vocabulary.
2. The spatial problems of interest to the QSR community are CSPs involving either
points (e.g., double cross calculus) or regions (e.g., 4- and 9-intersection calculi, region
connection calculi) and a closed set of their properties/relations often limited to the binary
domain. A general-purpose SPS for helping a human perceive from and act on diagrams
in dierent real-world applications will need to solve QCSPs involving points, curves and
regions and an open-ended vocabulary of their properties/relations/actions over the entire
real domain, which is what our framework oers. Since QE is the computational bottleneck
of our SPS, we concentrate our eorts on the real QE algorithms, as discussed towards the
end of section 2.3.
Naturally, the question arises  how convenient is it for a human to specify a spatial
problem as a QCSP? While we acknowledge that the process of specifying a spatial problem
as a QCSP is not as eortless as explaining it to another human in a natural language, we
have taken the rst step in making the process less strenuous by oering a vocabulary of
predicates that is open-ended. Not all QCSP-solving systems, such as, redlog (Dolzmann
& Sturm, 1999) and qepcad (Brown, 2003), oer such a vocabulary for spatial problem
solving which makes it dicult for a user to specify a problem as he has to dig deep into an
ocean of equations and inequalities and cannot communicate naturally in terms of high-level
predicates.4 We are still far from building systems that can understand communication in
natural language. However, research in automatic constraint acquisition from examples
is already underway. Vu and OSullivan (2008) discuss recent advances in that direction.
While we did not use any of those ideas or results in our work, it is not dicult to see how
those ideas in conjunction with the work reported in this paper will be able to build a more
convenient and ecient spatial problem solving framework.

7. Conclusion
DR requires perceiving specied information from a diagram or modifying/creating objects
in a diagram in specied ways according to problem solving needs. A number of DR systems
have been built in the last couple of decades, in each of which the developers have ascertained
a priori and hand-coded the required perceptions and actions. This approach of building
DR systems defeats the very purpose of open-ended exploration  the essence of human-like
problem solving. Our goal, in this paper, was to develop a general and ecient framework
for executing perceptions and actions as relevant to reasoning with 2D diagrams across a
wide variety of domains and tasks. We make two important contributions:
1. We observe that the wide variety of visual perceptions/actions for DR applications can
be transformed into domain/task-independent spatial problems. This observation makes it
possible to use the well-established constraint satisfaction framework for spatial problem
solving. We developed a language in which to specify spatial problems as QCSPs in the
real domain using an open-ended vocabulary of properties, relations and actions involving
three kinds of diagrammatic objects  points, curves, regions. Solution to a spatial problem
is the equivalent simplied quantier-free expression. That reduces the goal to developing
a general and ecient SPS for solving 2D spatial problems without human intervention.
4. To be fair, redlog and qepcad were not developed for solving only spatial problems but any QCSP.

421

fiBanerjee & Chandrasekaran

2. The spatial problems were specied as QCSPs in rst-order logic. QE, an inherently
doubly exponential problem, was the computational bottleneck of the SPS. We represented
the objects (points, curves, regions) as conguration of simple elements to facilitate decomposition of complex problems into simpler and similar subproblems. We showed that, if
the symbolic solution to a subproblem can be expressed concisely, QE can be achieved in
low-order polynomial time by storing problems and their solutions in memory so that when
a similar problem is encountered in future, it can be solved by mapping its solution from a
similar previously solved problem. The SPS grows more ecient as it solves more problems.
Even though we used the CAD algorithm for QE and compared the complexity results with
that of CADs, this approach is by no means limited to any particular algorithm. The complexity of any QE algorithm can be signicantly improved for spatial problem solving by
using the idea of problem decomposition and variable mapping, as discussed in this paper.
The framework leaves room to be more ecient and convenient by incorporating future
results in at least two possible directions  learning constraints from examples (automatic
constraint acquisition) and carefully exploiting a rich portfolio of QE algorithms for solving
new problems.

Acknowledgments
This research was partially supported by participation in the Advanced Decision Architectures Collaborative Technology Alliance sponsored by the U.S. Army Research Laboratory
under Cooperative Agreement DAAD19-01-2-0009. We thank the anonymous reviewers for
their constructive comments.

References
Aho, A. V., Hopcroft, J. E., & Ullman, J. D. (1974). The Design and Analysis of Computer
Algorithms. Addison-Wesley.
Allwein, G., & Barwise, J. (1999). Logical reasoning with diagrams. Journal of Logic,
Language and Information, 8 (3), 387390.
Anderson, J. R. (1993). Rules of the Mind. Lawrence Erlbaum Associates, Hillsdale, NJ.
Banerjee, B., & Chandrasekaran, B. (2004). Perceptual and action routines in diagrammatic
reasoning for entity re-identication. In Proc. 24th Army Science Conf., Orlando, FL.
Banerjee, B., & Chandrasekaran, B. (2007). A constraint satisfaction framework for visual
problem solving. In Benhamou, F., Jussien, N., & OSullivan, B. (Eds.), Trends in
Constraint Programming, chap. 26, pp. 383393. ISTE, London.
Banerjee, B., & Chandrasekaran, B. (2010). A spatial search framework for executing
perceptions and actions in diagrammatic reasoning. In Goel, A. K., Jamnik, M., &
Narayanan, N. H. (Eds.), Diagrammatic Representation and Inference, Lecture Notes
in AI, Vol. 6170, pp. 144159. Springer, Heidelberg.
Barwise, J., & Etchemendy, J. (1998). A computational architecture for heterogeneous
reasoning. In Gilboa, I. (Ed.), Proc. 7th Conf. Theoretical Aspects of Rationality and
Knowledge, pp. 127. Morgan Kaufmann.
422

fiExecuting Perceptions and Actions in Diagrammatic Reasoning

Basu, S., Pollack, R., & Roy, M.-F. (2003). Algorithms in real algebraic geometry. SpringerVerlag.
Bennett, B. (1997). Logical Representations for Automated Reasoning about Spatial Relationships. Ph.D. thesis, School of Computer Studies, The University of Leeds.
Bennett, B., Isli, A., & Cohn, A. G. (1997). When does a composition table provide a
complete and tractable proof procedure for a relational constraint language?. In Proc.
IJCAI Workshop Spatial and Temporal Reasoning, Nagoya, Japan.
Brown, C. W. (2003). QEPCAD B: A program for computing with semi-algebraic sets using
cylindrical algebraic decomposition. ACM SIGSAM Bulletin, 37 (4), 97108.
Brown, C. W., & Davenport, J. H. (2007). The complexity of quantier elimination and
cylindrical algebraic decomposition. In Proc. Intl. Symp. Symbolic and Algebraic Computation, pp. 5460. ACM, NY.
Chandrasekaran, B., Josephson, J. R., Banerjee, B., Kurup, U., & Winkler, R. (2002).
Diagrammatic reasoning in support of situation understanding and planning. In Proc.
23rd Army Science Conf., Orlando, FL.
Chandrasekaran, B., Kurup, U., & Banerjee, B. (2005). A diagrammatic reasoning architecture: Design, implementation and experiments. In Proc. AAAI Spring Symp.,
Reasoning with Mental and External Diagrams: Computational Modeling and Spatial
Assistance, pp. 108113, Stanford University, CA.
Chandrasekaran, B., Kurup, U., Banerjee, B., Josephson, J. R., & Winkler, R. (2004). An
architecture for problem solving with diagrams. In Blackwell, A., Marriott, K., &
Shimojima, A. (Eds.), Lecture Notes in AI, Vol. 2980, pp. 151165. Springer-Verlag.
Chazelle, B. (1991). Triangulating a simple polygon in linear time. Discrete and Computational Geometry, 6, 485524.
Clarke, B. L. (1981). A calculus of individuals based on connection. Notre Dame Journal
of Formal Logic, 22, 204218.
Cohn, A. G., Bennett, B., Gooday, J. M., & Gotts, N. (1997). RCC: A calculus for region
based qualitative spatial reasoning. GeoInformatica, 1, 275316.
Collins, G. E., & Hong, H. (1991). Partial cylindrical algebraic decomposition for quantier
elimination. Journal of Symbolic Computation, 12 (3), 299328.
Davenport, J. H., & Heintz, J. (1988). Real quantier elimination is doubly exponential.
Journal of Symbolic Computation, 5 (1-2), 2935.
Dershowitz, N., & Jouannaud, J. P. (1990). Rewrite systems. In Handbook of Theoretical
Computer Science, Vol. B, chap. 6, pp. 243320. Elsevier, North Holland: Amsterdam.
Dolzmann, A., & Sturm, T. (1999). REDLOG user manual, edition 2.0 for version 2.0.
Tech. rep. MIP-9905, FMI, Universitt Passau, Passau, Germany.
Dolzmann, A., Sturm, T., & Weispfenning, V. (1998). Real quantier elimination in practice.
In Matzat, B. H., Greuel, G.-M., & Hiss, G. (Eds.), Algorithmic Algebra and Number
Theory, pp. 221247. Springer, Berlin.
423

fiBanerjee & Chandrasekaran

Duntsch, I., Wang, H., & McCloskey, S. (1999). Relation algebras in qualitative spatial
reasoning. Fundamenta Informaticae, 39 (3), 229249.
Dylla, F., & Moratz, R. (2005). Exploiting qualitative spatial neighborhoods in the situation
calculus. In Freksa, C., Knau, M., Krieg-Brckner, B., Nebel, B., & Barkowsky, T.
(Eds.), Spatial Cognition IV. Reasoning, Action, and Interaction, Vol. 3343 of Lecture
Notes in Computer Science, pp. 304322. Springer.
Egenhofer, M. J. (1991). Reasoning about binary topological relations. In Gunther, O.,
& Schek, H.-J. (Eds.), Proc. 2nd Symp. Large Spatial Databases, Vol. 525 of Lecture
Notes in Computer Science, pp. 143160. Springer.
Egenhofer, M. J., & Franzosa, R. D. (1991). Point set topological relations. Intl. Journal
of Geographical Information Systems, 5, 161174.
Ferguson, R. W. (1994). MAGI: Analogy-based encoding using symmetry and regularity.
In Proc. 16th Annual Conf. Cognitive Science Society, pp. 283288, Atlanta, GA.
Ferguson, R. W., & Forbus, K. D. (1998). Telling juxtapositions: Using repetition and
alignable dierence in diagram understanding. In Holyoak, K., Gentner, D., & Kokinov, B. (Eds.), Advances in Analogy Research, pp. 109117. Soa, New Bulgarian
University.
Ferguson, R. W., & Forbus, K. D. (2000). GEOREP: A exible tool for spatial representation
of line drawings. In Proc. 18th Natl. Conf. AI, pp. 510516, Austin, TX.
Forbus, K. D., Usher, J., & Chapman, V. (2003). Qualitative spatial reasoning about sketch
maps. In Riedl, J., & Hill, R. (Eds.), Proc. 15th Annual Conf. Innovative Applications
of AI, pp. 8592, Acapulco, Mexico. AAAI Press, Menlo Park, CA. ISBN 978-1-57735188-7.
Frank, A. U. (1991). Qualitative spatial reasoning with cardinal directions. In Kaindl, H.
(Ed.), Proc. 7th Austrian Conf. AI, Vol. 287 of Informatik-Fachberichte, pp. 157167.
Springer.
Frank, A. U. (1992). Qualitative spatial reasoning about distances and directions in geographic space. Journal of Visual Languages and Computing, 3, 343371.
Freksa, C. (1992). Using orientation information for qualitative spatial reasoning. In Frank,
A. U., Campari, I., & Formentini, U. (Eds.), Spatio-Temporal Reasoning, Vol. 639 of
Lecture Notes in Computer Science, pp. 162178. Springer.
Gebruers, C., Hnich, B., Bridge, D., & Freuder, E. (2005). Using CBR to select solution
strategies in constraint programming. In Proc. 6th Intl. Conf. Case-based Reasoning,
pp. 222236. Springer.
Gerevini, A., & Nebel, B. (2002). Qualitative spatio-temporal reasoning with rcc-8 and
allens interval calculus: Computational complexity. In Proc. 15th European Conf. AI,
pp. 312316. IOS Press.
Gerevini, A., & Renz, J. (1998). Combining topological and qualitative size constraints
for spatial reasoning. In Proc. 4th Intl. Conf. Principles and Practice of Constraint
Programming, pp. 220234. Springer.
424

fiExecuting Perceptions and Actions in Diagrammatic Reasoning

Glasgow, J., Narayanan, N. H., & Chandrasekaran, B. (1995). Diagrammatic Reasoning:
Cognitive and Computational Perspectives. AAAI Press.
Goldberg, E., & Novikov, Y. (2003). On complexity of equivalence checking. Tech. rep.
CDNL-TR-2003-0826, Cadence Berkeley Labs, CA.
Jamnik, M. (2001). Mathematical Reasoning with Diagrams: From Intuition to Automation.
CSLI Press, Stanford University, CA.
Josephson, J. R., & Josephson, S. G. (1996). Abductive Inference: Computation, Philosophy,
Technology. Cambridge University Press, Cambridge, MA.
Kurup, U., & Chandrasekaran, B. (2007). A bimodal cognitive architecture: Explorations in
architectural explanation of spatial reasoning. In AAAI Spring Symp. Control Mechanisms for Spatial Knowledge Processing in Cognitive/Intelligent Systems, Stanford
University, CA.
Laird, J. E., Newell, A., & Rosenbloom, P. S. (1987). SOAR: An architecture for general
intelligence. Artificial Intelligence, 33, 164.
Laird, J. E., Rosenbloom, P. S., & Newell, A. (1986). Universal Subgoaling and Chunking.
Kluwer Academic Publishers.
Lasaruk, A., & Sturm, T. (2006). Weak quantier elimination for the full linear theory
of the integers. A uniform generalization of Presburger arithmetic. Technical report
MIP-0604, FMI, Universitt Passau, Germany.
Leyton-Brown, K., Nudelman, E., & Shoham, Y. (2002). Learning the empirical hardness
of optimization problems: The case of combinatorial auctions. In Proc. 8th Intl. Conf.
Principles and Practice of Constraint Programming, pp. 556572.
Ligozat, G. (1993). Qualitative triangulation for spatial reasoning. In Frank, A. U., &
Campari, I. (Eds.), Spatial Information Theory: A Theoretical Basis for GIS, Vol. 716
of Lecture Notes in Computer Science, pp. 5468. Springer.
Lindsay, R. K. (1998). Using diagrams to understand geometry. Computational Intelligence,
14 (2), 238272.
Moratz, R., Renz, J., & Wolter, D. (2000). Qualitative spatial reasoning about line segments.
In Proc. 14th European Conf. AI, pp. 234238. IOS Press.
Nelson, R. B. (1993). Proofs without Words: Exercises in Visual Thinking. The Mathematical Association of America, Washington, DC.
Newell, A. (1990). Unified Theories of Cognition. Harvard University Press, Cambridge,
MA.
OMahony, E., Hebrard, E., Holland, A., Nugent, C., & OSullivan, B. (2008). Using casebased reasoning in an algorithm portfolio for constraint solving. In van Dongen, M.
R. C., Lecoutre, C., & Roussel, O. (Eds.), Proc. 3rd Intl. CSP Solver Competition,
pp. 5362.
Pisan, Y. (1994). Visual reasoning with graphs. In 8th Intl. Workshop Qualitative Reasoning
about Physical Systems, Nara, Japan.
425

fiBanerjee & Chandrasekaran

Pisan, Y. (1995). A visual routines based model of graph understanding. In Proc. 17th
Annual Conf. Cognitive Science Society, pp. 692697, Pittsburgh. Lawrence Erlbaum
Associates. ISBN: 0-8058-2159-7.
Pulina, L., & Tacchella, A. (2007). A multi-engine solver for quantied boolean formulas.
In Proc. 13th Intl. Conf. Principles and Practice of Constraint Programming, pp.
574589.
Randell, D. A., Cui, Z., & Cohn, A. G. (1992). A spatial logic based on regions and connection. In Nebel, B., Swartout, W., & Rich, C. (Eds.), Proc. 3rd Intl. Conf. Principles
of Knowledge Representation and Reasoning, pp. 165176. Morgan Kaufmann.
Ratschan, S. (2006). Ecient solving of quantied inequality constraints over the real
numbers. ACM Trans. Computational Logic, 7 (4), 723748.
Sayag, T., Fine, S., & Mansour, Y. (2006). Combining multiple heuristics. In Proc. 23rd
Intl. Symp. Theoretical Aspects of Computer Science, Vol. 2884 of Lecture Notes in
Computer Science, pp. 242253. Springer.
Schlieder, C. (1995). Reasoning about ordering. In Frank, A. U., & Kuhn, W. (Eds.),
Spatial Information Theory: A Theoretical Basis for GIS, Vol. 988 of Lecture Notes
in Computer Science, pp. 341349. Springer.
Seidel, R. (1991). A simple and fast incremental randomized algorithm for computing
trapezoidal decompositions and for triangulating polygons. Computational Geometry:
Theory and Applications, 1 (1), 5164.
Skiadopoulos, S., & Koubarakis, M. (2004). Composing cardinal direction relations. Artificial Intelligence, 152 (2), 143171.
Streeter, M. J., Golovin, D., & Smith, S. F. (2007). Combining multiple heuristics online.
In Proc. 22nd Conf. AI, pp. 11971203. AAAI Press.
Sutherland, I. E. (1963). Sketchpad: A man-machine graphical communication system. In
Proc. Spring Joint Computer Conf., pp. 329346.
Tessler, S., Iwasaki, Y., & Law, K. (1995). Qualitative structural analysis using diagrammatic reasoning. In Glasgow, J., Narayanan, N. H., & Chandrasekaran, B. (Eds.),
Diagrammatic Reasoning: Cognitive and Computational Perspectives, chap. 21, pp.
711730. AAAI Press, Menlo Park, CA. ISBN 0-262-57112-9.
Tricket, S. B., & Trafton, J. G. (2006). Toward a comprehensive model of graph comprehension: Making the case for spatial cognition. In Barker-Plummer, D., Cox, R., &
Swoboda, N. (Eds.), Lecture Notes in AI, Vol. 4045, pp. 286300. Berlin: SpringerVerlag.
Tversky, B. (2000). Some ways that maps and diagrams communicate. In Freksa, C.,
Brauer, W., Habel, C., & Wender, K. F. (Eds.), Spatial Cognition II: Integrating
Abstract Theories, Empirical Studies, Formal Methods, and Practical Applications,
Vol. 1849 of Lecture Notes in Computer Science, pp. 7279. Berlin: Springer-Verlag.
Vik, S. (2001). An implementation of a near-linear polygon triangulation algorithm for
general polygons. Senior thesis at Macalester College, St. Paul, Minnesota. Available
online at http://sigbjorn.vik.name/projects/Triangulation.pdf.
426

fiExecuting Perceptions and Actions in Diagrammatic Reasoning

Vu, X. H., & OSullivan, B. (2008). A unifying framework for generalized constraint acquisition. Intl. Journal on AI Tools, 17 (5), 803833.
Weispfenning, V. (1988). The complexity of linear problems in elds. Journal of Symbolic
Computation, 5 (12), 327.
Weispfenning, V. (2001). Semilinear motion planning in REDLOG. Applicable Algebra in
Engineering, Communication and Computing, 12, 455475.
Wolfram, S. (2003).
The Mathematica Book (5th edition).
http://documents.wolfram.com/.

Available online at

Xu, L., Hutter, F., Hoos, H. H., & Leyton-Brown, K. (2008). SATzilla: Portfolio-based
algorithm selection for SAT. Journal of Artificial Intelligence Research, 32, 565606.

427

fi