Journal of Artificial Intelligence Research 55 (2016) 743-798

Submitted 06/15; published 03/16

Knowledge Representation in Probabilistic
Spatio-Temporal Knowledge Bases
Francesco Parisi

FPARISI @ DIMES . UNICAL . IT

Department of Informatics, Modeling,
Electronics and System Engineering
University of Calabria, Rende, Italy

John Grant

GRANT @ CS . UMD . EDU

Department of Computer Science and UMIACS
University of Maryland, College Park, USA

Abstract
We represent knowledge as integrity constraints in a formalization of probabilistic spatiotemporal knowledge bases. We start by defining the syntax and semantics of a formalization called
PST knowledge bases. This definition generalizes an earlier version, called SPOT, which is a
declarative framework for the representation and processing of probabilistic spatio-temporal data
where probability is represented as an interval because the exact value is unknown. We augment
the previous definition by adding a type of non-atomic formula that expresses integrity constraints.
The result is a highly expressive formalism for knowledge representation dealing with probabilistic spatio-temporal data. We obtain complexity results both for checking the consistency of PST
knowledge bases and for answering queries in PST knowledge bases, and also specify tractable
cases. All the domains in the PST framework are finite, but we extend our results also to arbitrarily
large finite domains.

1. Introduction
Recent years have seen a great deal of interest in tracking moving objects. This is a fundamental
issue for many applications providing location-based and context-aware services, such as emergency call-out assistance, live traffic reports, food and drink finder, location-based advertising, mobile tourist guidance, pervasive healthcare, and analysis of animal behavior (Ahson & Ilyas, 2010;
Petrova & Wang, 2011; Karimi, 2013). Such innovative services are becoming so widely diffused
that MarketsandMarkets forecasts that the location-based services market will grow from $8.12
billion in 2014 to $39.87 billion in 2019 (MarketsandMarkets, 2014).
An important aspect of the systems providing location-based and context-aware services is that
they need to manage spatial and temporal data together. For this reason, researchers have investigated in detail the representation and processing of spatio-temporal data, both in AI (Cohn &
Hazarika, 2001; Gabelaia, Kontchakov, Kurucz, Wolter, & Zakharyaschev, 2005; Yaman, Nau,
& Subrahmanian, 2004, 2005a; Knapp, Merz, Wirsing, & Zappe, 2006) and databases (Agarwal,
Arge, & Erickson, 2003; Pelanis, Saltenis, & Jensen, 2006). However, in many cases the location
of objects is uncertain: such cases can be handled by using probabilities (Parker, Yaman, Nau, &
Subrahmanian, 2007b; Tao, Cheng, Xiao, Ngai, Kao, & Prabhakar, 2005). Sometimes the probabilities themselves are not known exactly. Indeed, the position of an object at a given time is estimated
by means of a location estimation method such as proximity (where the location of an object is
derived from its vicinity to one or more antennas), fingerprinting (where radio signal strength meac
2016
AI Access Foundation. All rights reserved.

fiPARISI & G RANT

surements produced by a moving object are matched against a radio map that is built before the
system is working), and dead reckoning (where the position of an object is derived from the last
known position, assuming that the direction of motion and either the speed or the travelled distance
are known) (Ahson & Ilyas, 2010; Karimi, 2013). However, since location estimation methods have
limited accuracy and precision, what can be asserted is that an object is at a given position at a
given time with a probability whose value belongs to an interval. The SPOT (Spatial PrObabilistic Temporal) framework was introduced by Parker, Subrahmanian, and Grant (2007a) to provide
a declarative framework for the representation and processing of probabilistic spatio-temporal data
with probabilities that are not known exactly.
The SPOT framework is able to represent atomic statements of the form object id is/was/will
be inside region r at time t with probability in the interval [`, u]. This allows the representation
of information concerning moving objects in several application domains. A cell phone provider
is interested in knowing which cell phones will be in the range of some towers at a given time and
with what probability (Bayir, Demirbas, & Eagle, 2010). A transportation company is interested
in predicting the vehicles that will be on a given road at a given time (and with what probability)
in order avoid congestion (Karbassi & Barth, 2003). Finally, a retailer is interested in knowing the
positions of the shoppers moving in a shopping mall in order to offer suitable customized coupons
on discounts (Kurkovsky & Harihar, 2006).
The framework introduced by Parker et al. (2007a) was then extended by Parker, Infantes, Subrahmanian, and Grant (2008) and Grant, Parisi, Parker, and Subrahmanian (2010) to include the
specific integrity constraint that, for a given moving object, only some points are reachable from a
given starting point in one time unit. This captures the scenario where objects have speed limits and
only some points are reachable by objects depending on the distance between the points. However,
even such an extended SPOT framework is not yet general enough to represent additional knowledge concerning the movements of objects. Examples of knowledge we may be aware of but cannot
represent in the SPOT framework are, for instance, the fact that
(i) there cannot be two distinct objects in a given region in a given time interval (as it happens
during airport passenger screening);
(ii) some object cannot reach a given region starting from a given location in less than a given
amount of time (as happens for the vehicles whose route options as well as their speed are
limited);
(iii) an object can go away from a given region only if it stayed there for at least a given amount of
time (as happens in production lines where assembling several parts requires a given amount
of time).
To overcome such limitation and allow this kind of knowledge to be represented, we define probabilistic spatio-temporal (PST) knowledge bases (KBs) consisting of atomic statements, such as
those representable in the SPOT framework and spatio-temporal denial (abbreviated to std) formulas, a general class of formulas that account for all the three cases above, and many more (including
the reachability constraint of Parker et al., 2008; Grant et al., 2010).
The focus of this paper is the systematic study of knowledge representation in probabilistic
spatio-temporal data. We start by defining the concept of a PST KB and provide its formal semantics, which is given in terms of worlds, interpretations, and models (Section 2). We define the
concept of a consistent PST KB, and characterize the complexity of checking consistency, showing
744

fiK NOWLEDGE R EPRESENTATION IN P ROBABILISTIC S PATIO -T EMPORAL K NOWLEDGE BASES

that it is NP-complete in general, and even in the presence of binary std-formulas only (Section 3).
Then we present a sufficient condition for checking consistency that relies on the feasibility of a
set of mixed-binary linear inequalities (Section 3.2), and a necessary condition using instead a set
of linear inequalities (Section 3.3). After showing that the special case of unary std-formulas is
tractable (Section 3.4), we deal with the restricted but expressive class of binary std-formulas and
identify cases where the consistency checking problem is tractable (Section 3.5). We then address
the problem of answering selection queries in PST KBs under both the optimistic and the cautious
semantics (Section 4). We show that checking consistency can be exploited to answer such kinds of
queries in PST KBs, and characterize the complexity of the query answering problem (Section 4.2).
After that, we derive several sets of linear inequalities for answering queries (Section 4.3). Finally,
we extend the framework to the case where time, space, and the number of objects are increased to
arbitrarily large finite domains, and show that each PST KB is either eventually consistent or eventually inconsistent (Section 5). We then discuss related work (Section 6). Section 7 summarizes the
paper. We also suggest research projects in Section 8.

2. The PST Framework
This section introduces the syntax and semantics of PST KBs generalizing the SPOT framework introduced by Parker et al. (2007a) and further extended by Parker et al. (2008) and Grant et al. (2010).
Basically, we define a PST KB by augmenting the previous framework with non-atomic formulas
(i.e., spatio-temporal denial formulas) that represent integrity constraints. This way we can make
statements whose meaning is that certain object trajectories cannot occur.
2.1 Syntax
We assume the existence of three types of constant symbols: object symbols, time value symbols,
and spatial region symbols. The constants are in ID = {id1 , . . . , idm }, T = [0, 1, . . . , tmax]
(where tmax is an integer), and the set of r  Space = {p1 , . . . , pn }. Each r is a region of Space.
We apply the unique name assumption; so, for instance idi and idj for i 6= j are different objects;
similarly, pi and pj for i 6= j are different points. We also use variables for each type: object
variables, time variables, and spatial variables.
A spatio-temporal atom (st-atom, for short) is an expression of the form loc(X, Y, Z), where:
(i) X is an object variable or a constant id  ID,
(ii) Y is a space 1 variable or a constant r  Space,
(iii) Z is a time variable or a constant t in T .
We say that st-atom loc(X, Y, Z) is ground if all of its arguments X, Y, Z are constants. For instance, loc(id, r, t), where id  ID, r  Space, and t  T is a ground st-atom. The intuitive
meaning of loc(id, r, t) is that object id is/was/will be inside region r at time t.
Definition 1 (PST atom). A PST atom is a ground st-atom loc(id, r, t) annotated with a probability
interval [`, u]  [0, 1] (with both ` and u rational numbers), and denoted as loc(id, r, t)[`, u].
1. We write Space to refer to the set of points used in a PST KB. We write space to refer to the spatial aspect of
probabilistic spatio-temporal knowledge.

745

fiPARISI & G RANT

7

loc(id1 , c, 9)[.9, 1]
loc(id1 , a, 1)[.4, .7]
loc(id1 , b, 1)[.4, .9]
loc(id1 , d, 15)[.6, 1]
loc(id1 , e, 18)[.7, 1]
loc(id2 , b, 2)[.5, .9]
loc(id2 , c, 12)[.9, 1]
loc(id2 , d, 18)[.6, .9]
loc(id2 , d, 20)[.2, .9]

6
5

e
c

4

d

3
2

b

1

a

0
0

1

2

3

4

5

6

7

(a)

(b)

Figure 1: (a) A map of an airport area (names of regions are on their bottom-right corner);
PST atoms.

(b)

Intuitively, the PST atom loc(id, r, t)[`, u] says that object id is/was/will be inside region r at
time t with probability in the interval [`, u]. Hence, PST atoms can represent information about the
past and the present, but also information about the future, such as from methods for predicting the
destination of moving objects (Mittu & Ross, 2003; Hammel, Rogers, & Yetso, 2003; Southey, Loh,
& Wilkinson, 2007), or from querying predictive databases (Akdere, Cetintemel, Riondato, Upfal,
& Zdonik, 2011; Parisi, Sliva, & Subrahmanian, 2013).
In the original SPOT definition, for ease of implementation, Space was a grid within which
only rectangular regions were considered; however, in our general framework, Space is arbitrary
and a region is any nonempty subset of Space. Still, for convenience we use such rectangular
regions in our running example.
Example 1. Consider an airport security system which collects data from biometric sensors as
well as from Bluetooth or WiFi enabled devices. Biometric data such as faces recognized by sensors (Li & Jain, 2011) are matched against given profiles (such as those of checked-in passports,
or of wanted criminals). Similarly, device identifiers (e.g., MAC addresses) recognized in the areas
covered by network antennas are matched against profiles collected by the airport hotspots (such as
logins, possibly associated with passport numbers). A simplified plan of an airport area is reported
in Figure 1(a), where regions a, b, c, d, e covered by sensors and/or antennas are highlighted. Once
entered in this area, passengers typically move through the path delimited by queue dividers (represented by dotted lines in the figure, and overlapping with regions a and b), and reach the room on
the upper-half right side where security checks are performed (region c is included in this room).
Next, passengers can spend some time in the hall room (overlapping with region d), and finally go
towards the exit (near region e).
Suppose that the security system uses the SPOT framework to represent the information where
every PST atom consists of the profile id resulting from the matching phase, the region where the
sensor/antenna recognizing the profile is operating, the time point at which the profile is recognized,
and the lower and upper probability bounds of the recognizing process. For instance, PST atom
loc(id1 , c, 9)[.9, 1] says that a profile having id id1 was in region c at time 9 with probability in the
746

fiK NOWLEDGE R EPRESENTATION IN P ROBABILISTIC S PATIO -T EMPORAL K NOWLEDGE BASES

interval [.9, 1] (the high-accuracy sensors used at security check points located in region c entail
a narrow probability interval with upper bound equal to 1). Atom loc(id1 , a, 1)[.4, .7] says that
id1 was recognized in region a at the earlier time 1 with probability in [.4, .7]. Assume that the
information is represented as the set of atoms in Figure 1(b), which includes the two atoms above.
2
PST atoms can be used to represent the output of a process aimed at tracking objects on the basis
of sensor measurements. Generally, sensors are characterized by a likelihood function providing the
conditional probability of obtaining a measurement given the value of a parameter , such as the
distance between the tracked object and the sensor. For instance, the likelihood function l() can
represent the probability of detecting an object that has a distance of  meters from the sensor
position. However, a likelihood function is generally not a probability distribution when viewed as
a function of . We may have l(1 ) = .9, l(2 ) = .4, l(3 ) = .1, and l(  3 ) = 0, with distances
1 < 2 < 3 . This information can be encoded by using PST atoms loc(id, ri , t)[l(i ), l(i )] for
each region ri determined by the distance i (more general probability intervals can be used if the
likelihood values are not know exactly).2 However, several object tracking techniques combine the
information of the likelihood function with the prior position distribution to obtain a probability
distribution over Space. PST atoms can represent this kind of information by defining a PST atom
with a single probability for each point in Space. 3 We refer the reader to the Related Work section
for a detailed discussion on object tracking techniques and the relationship with our framework.
Although PST atoms express much useful information, they cannot express additional knowledge that integrity constraints can provide. In this paper we add integrity constraints to the original
PST framework to form PST KBs. The integrity constraints have the form of spatio-temporal denial formulas (std formulas for short). We will soon see that such formulas are expressive enough
to capture a large set of conditions. Basically, an std formula is a universally quantified negation of
conjunctions of st-atoms and built-in predicates. We note that std formulas are related to a subclass
of the first-order formulas introduced by Doder, Grant, and Ognjanovic (2013), except that they
(the std formulas) allow built-in predicates as well. In any case, the focus of Doder et al. is the
axiomatization of various probabilistic spatio-temporal logics.
Definition 2 (Std-formula). An std-formula is an expression of the form
k


 ^
loc(Xi , Yi , Zi )  (X)  (Y)  (Z)
 X, Y, Z 
i=1

where:
 X is a set of object variables, Y is a set of space variables, and Z is a set of time variables;
 loc(Xi , Yi , Zi ), with i  [1..k], are st-atoms, where the Xi , Yi , Zi may be variables or constants of the appropriate type, such that, if Xi (resp., Yi , Zi ) is a variable, then it occurs
in X (resp, Y, Z). Moreover, each variable in X, Y, and Z occurs in at least one st-atom
loc(Xi , Yi , Zi ), with i  [1..k];
2. We note that PST KBs resulting from PST atoms encoding information provided by the likelihood function may be
inconsistent because of the fact that the likelihood function need not be a probability distribution. This will turn out
to be clearer after introducing the formal semantics of PST KBs in Section 2.2.
3. PST KBs resulting from PST atoms encoding the output of tracking turn out to be consistent.

747

fiPARISI & G RANT

 (X) is a conjunction of built-in predicates of the form Xi  Xj , where Xi and Xj are either
variables occurring in X or ids in ID, and  is an operator in {=, 6=};
 (Y) is a conjunction of built-in predicates of the form Yi  Yj , where Yi and Yj are either
variables occurring in Y or regions (i.e., non-empty subsets of Space), and  is a comparison
operator in {=, 6=, ov, nov} (where ov stands for overlaps and nov stands for does not
overlap);
 (Z) is a conjunction of built-in predicates of the form Zi  Zj where each Zi and Zj is either
a time value in T or a variable in Z that may be followed by +n where n is a positive integer
and  is an operator in {=, 6=, <, }.
Example 2. In our running example, in region c security checks on one individual at a time are
performed. The constraint there cannot be two distinct objects in region c at any time between 1
and 20 can be expressed by the following std-formula:
f1 = X1 , X2 , Z1 [loc(X1 , c, Z1 )  loc(X2 , c, Z1 )  X1 6= X2  Z1  1  20  Z1 ].
Due to the distance and the several obstacles between the entrance and the exit, we also have
the constraint no object can reach region e starting from region a in less than 10 time units, that
can be expressed as:
f2 = X1 , Z1 , Z2 [loc(X1 , a, Z1 )  loc(X1 , e, Z2 )  Z1 < Z2  Z2 < Z1 + 10].
Moreover, as the security check on each individual takes at least 2 time units, we know that
object id can go away from region c only if it stayed there for at least 2 time units, that can be
expressed as:
f3 = Y1 , Y2 , Z1 , Z2 , Z3 [loc(id, Y1 , Z1 )  loc(id, c, Z2 )  loc(id, Y2 , Z3 )  Y1 nov c  Y2 nov c 
Z2 = Z1 + 1  Z2 < Z3  Z2 + 2  Z3 ].
2
In our work later it will be useful to distinguish std-formulas based on the number (k) of statoms in them. In particular, unary std-formulas have k = 1 and binary std-formulas have k = 2.
In Example 2 above f1 and f2 are binary std-formulas while f3 is a ternary std-formula.
In the initial SPOT framework (Parker et al., 2007a) only PST atoms were considered. Moreover, it was assumed that all points in Space are reachable from all other points by all objects. To
overcome this limitation, Grant et al. (2010) extended the SPOT framework by introducing reachability definitions. A reachability atom is written as reachableid (p, q) where id  ID is an object
id, and p, q  Space. Intuitively, the reachability atom says that it is possible for the object id
to reach location q from location p in one unit of time. Hence, what is reachable in one time unit
depends not only on the locations p and q, but also the object id. As we now show, reachability can
be expressed in our formalism as an integrity constraint. However, in order to formulate reachability
in our framework of denial formulas, we need to deal with what is not reachable, rather than what
is reachable.
Example 3. Let r be the region consisting of all points q that are not reachable from p in one time
unit. The corresponding std-formula is:
X1 , Z1 , Z2 [loc(X1 , {p}, Z1 )  loc(X1 , r, Z2 )  Z2 = Z1 + 1].
2
This integrity constraint is used only if not all points are reachable from p in one time unit. We
can also express which points can not be reached from p in any number of time units, not just 1, by
changing Z1 + 1 to Z1 + i.
748

fiK NOWLEDGE R EPRESENTATION IN P ROBABILISTIC S PATIO -T EMPORAL K NOWLEDGE BASES

Example 4. In our running example, the following std-formula states that the points in region
r = {(x, y)|0  x  5  y = 3} (i.e., those close to the upper-side of the wall dividing the hall
room and the one where there are queue dividers) are not reachable in less than 3 time units from
any point in r0 = {(x, y)|0  x  5  y = 2} (i.e., the points close to the other side of that wall):
f4 = X1 , Z1 , Z2 [loc(X1 , r0 , Z1 )  loc(X1 , r, Z2 )  Z1 < Z2  Z2 < Z1 + 3].
2
We are now ready to formally define PST KBs.
Definition 3 (PST KB). Given the sets ID, T , and Space, a PST KB K is a pair hA, Fi, where
A is a finite set of PST atoms and F is finite set of std-formulas using object symbols in ID, time
values in T , and spatial regions consisting of sets of points in Space.
Example 5. In our running example, ID = {id1 , id2 }, T = [0, 20], Space is the set of points (x, y)
such that 0  x  7 and 0  y  7, and PST KB Kex is the pair hAex , Fex i, where Aex is the
set consisting of the PST atoms in Figure 1(b), and Fex is the set {f1 , f2 , f3 , f4 } of std-formulas
defined in Examples 2 and 4.
2
2.2 Semantics
The semantics of a PST KB is defined through the concept of worlds. Before introducing this
concept, we define ground std-formulas.
Given an std-formula f having the form in Definition 2, we denote by f the set of all substitutions of variables in X, Y, and Z with constants in ID, S, and T , respectively, where S
is the set of all subsets of Space that contain a single point. 4 Moreover, given substitution
  f , we denote as (f ) the ground std-formula resulting from applying  to f : (f ) =


 Vk

i=1 loc((Xi ), (Yi ), (Zi ))  ((X))  ((Y))  ((Z)) . The ground conjunction
of built-in predicates ((X))  ((Y))  ((Z)) evaluates to either true or false. When it is true
we omit it. So (f ) is either the negation of a conjunction of ground st-atoms or the truth value true
(when the conjunction of built-in predicates evaluates to false).
Example 6. Consider the formula f1 = X1 , X2 , Z1 [loc(X1 , c, Z1 )loc(X2 , c, Z1 )X1 6= X2 
Z1  1  20  Z1 ] introduced in Example 2, and the substitution  = {X1 /id1 , X2 /id2 , Z1 /6},
where id1 , id2  ID and 6  tmax. Thus, (f1 ) = [loc(id1 , c, 6)  loc(id2 , c, 6)], where the
conjunction of ground built-in predicates id1 6= id2  6  1  6  20, evaluating to true, is not
reported in (f1 ).
2
Definition 4 (World). A world w is a function, w : ID  T  Space.
Basically, a world w specifies a trajectory for each id  ID. That is, for each id  ID, w says
where in Space object id was/is/will be at each time t  T . In particular, this means that an object
can be in only one location at a time.5 However, a location may contain multiple objects. It is easy
to see that world w can be represented by the set {loc(id, {p}, t)| w(id, t) = p} of ground st-atoms.
4. We use only such singleton subsets of Space in order to reduce the number of possible instantiations of variables Y
from exponential to linear in the size of Space, without serious effect on the meanings of the std-formulas.
5. In some examples it may be useful to allow objects to enter or leave the space under consideration. This can be
accomplished, for instance, by having one or more external points outside of the space where objects may be located.
To simplify matters we assume that Space contains all these points.

749

fiPARISI & G RANT

Example 7. World w1 describing the trajectories of id1 and id2 for time units in [0, 20] is such
that w1 (id1 , t) = (4, 1) for t  [0, 5], w1 (id1 , t) = (7, 2) for t  [6, 7], w1 (id1 , t) = (7, 4) for
t  [8, 10], w1 (id1 , t) = (4, 4) for t  [11, 16], w1 (id1 , t) = (1, 6) for t  [17, 20], w1 (id2 , t) =
(4, 1) for t  [0, 11], w1 (id2 , t) = (7, 5) for t  [12, 15], w1 (id2 , t) = (7, 7) for t  [16, 16],
w1 (id2 , t) = (4, 5) for t  [17, 20].
2
Definition 5 (Satisfaction). Given a world w and a ground st-atom a = loc(id, r, t), we say that w
satisfies a (denoted
 r. Moreover, we say that w satisfies a conjunction of
Vk as w |= a) iff w(id, t) V
ground st-atoms i=1 ai (denoted as w |= ki=1 ai ) iff w |= ai i  [1..k]. Finally, world w satisfies
std-formula f (denoted as w |= f ) iff for each substitution   f , w |= (f ).
Note that, as there is a negation in front of f , w |= (f ) iff w does not satisfy a ground st-atom
in (f ) or the conjunction of ground built-in predicates in (f ) evaluates to false.
Example 8. World w1 of Example 7 satisfies the st-atom loc(id1 , b, 0), as w1 (id1 , 0) = (4, 1)
belongs to region b (see Figure 1(a)). Moreover, w1 |= [loc(id1 , b, 0)  loc(id1 , e, 15)] as w1 6|=
loc(id1 , e, 15), since w1 (id1 , 15) = (4, 4) 6 e.
2
In the following, we will denote as W(K) the set of all worlds of the PST KB K. Moreover, in
order to simplify formulas, we will assume that w ranges over W(K).
An interpretation I for a PST KB K is a probability distribution function (PDF) over W(K),
that is, a function assigning a probability value to each world in W(K). I(w) is the probability that
w describes the actual trajectories of all the objects.6 Some interpretations are models of K in which
case we write M instead of I.
Definition 6 (Model). A model M for a PST KB K = hA, Fi is an interpretation for K such that:
P
M (w)  [`, u];
  loc(id, r, t)[`, u]  A,
w | w|=loc(id,r,t)

  f  F,

P

M (w) = 0.

w | w6|=f

The first condition in the definition above means that, for each atom a = loc(id, r, t)[`, u]  A,
the sum of the probabilities assigned by M to the worlds satisfying the st-atom loc(id, r, t) have to
belong to the probability interval [`, u] specified by a. The second condition means that every world
not satisfying a formula f  F must be assigned by M probability equal to 0.
Example 9. Let w1 be the world introduced in Example 7. Let w2 be as w1 except that w2 (id1 , 1) =
(3, 2), and let w3 be as w2 except that w3 (id2 , 2) = (2, 2), w3 (id2 , t) = (0, 3) for t  [18..20]. Let
M be such that M (w1 ) = .7 M (w2 ) = .2 M (w3 ) = .1, and M (w) = 0 for all the other worlds in
W(Kex ). It can be checked that M satisfies both conditions of DefinitionP6 for the PST KB Kex of
our running example. For instance, for atom loc(id1 , a, 1)[.4, .7]  Aex , w|w|=loc(id1 ,a,1) M (w) =
M (w1 ) = .7  [.4, .7] (note that, at time 1, w2 (id1 , 1) = w3 (id1 , 1) = (3, 2) that is not in region a).
Moreover, it is easy to check that w1 , w2 , w3 satisfy every std-formula in Fex . Thus, M is a model
for Kex .
2
We say that PST KB K is consistent iff if there is a model for it. The set of models for K will
be denoted as M(K).
6. As a PDF, I(w) is non-negative and sums to 1 over worlds.

750

fiK NOWLEDGE R EPRESENTATION IN P ROBABILISTIC S PATIO -T EMPORAL K NOWLEDGE BASES

Definition 7 (Consistency). PST KB K is consistent iff M(K) 6= .
Example 10. PST KB Kex of our running example is consistent, as there exists the model M of
Example 9 for it.
2

3. Checking the Consistency of PST KBs
In this section, we address the fundamental problem of checking the consistency of PST KBs.
Given a PST KB K = hA, Fi, the consistency checking problem is deciding whether M(K) 6= ,
that is, whether there is a model for K.
In Section 3.1 we show that the consistency checking problem is NP-complete. Our goal in the
rest of this section is to find more efficient ways to determine consistency. In Section 3.2 we find a
sufficient condition using a set of mixed-binary linear inequalities. Then, in Section 3.3 we find a
necessary condition using a different set of linear inequalities. We deal with the special case where
all the std-formulas are unary in Section 3.4. Finally we investigate in detail the case where the
std-formulas are either unary or binary in Section 3.5.
For our complexity analysis we take the size of a PST KB K = hA, Fi, whose PST atoms and
std-formulas are built from the constants in ID, T , and Space, as the number of PST atoms and
std-formulas in K plus the number of items in ID, T , and Space, that is, |K| = |A| + |F| + |ID| +
|T | + |Space|.
3.1 Checking Consistency is NP-Complete
Before considering the case of general PST KBs, we first note that the consistency checking problem was addressed in the initial SPOT framework of Parker et al. (2007a) where only PST atoms
were considered. This is the special case of our PST KB concept where F = . It was shown there
that the consistency of a PST KB K = hA, i (using our notation) can be checked in polynomial
time w.r.t. the size of K by solving a set of linear inequalities whose variables vid,t,p represent the
probability that object id is at point p at time t.
The reason for presenting the result of Parker et al. is twofold: first, we compare the complexity
of the consistency checking problem for general PST KBs with that of the initial SPOT framework;
second, we use it to prove some tractability results for PST KBs.
Fact 1 (Parker et al.). Let K = hA, i be a PST KB (where the set of std-formulas is empty). Then
K is consistent iff there is a feasible solution of CC(K), where CC(K) consists of the following
(in)equalities:
P
(1)  loc(id, r, t)[`, u]  A: ` 
vid,t,p  u;
pr

(2)  id  ID, t  T :

P

vid,t,p = 1;

pSpace

(3)  id  ID, t  T, p  Space: vid,t,p  0.
Basically, inequalities (1) ensure that a solution of CC(K) places the object in r with a probability between ` and u, as required by the atom (id, r, t, [`, u]). Inequalities (2) and (3) ensure that
for each id and t, the vid,t,p variables jointly represent a probability distribution. Fact 1 is correct
because every model M for K corresponds to a solution  for CC(K) such that the sum of the
751

fiPARISI & G RANT

probabilities assigned by M to the worlds for K satisfying an st-atom loc(id, {p}, t) is equal to the
value assigned to variable vid,t,p by .
Now we state our first result: the consistency checking problem is NP-complete.
Theorem 1. Given a PST KB K = hA, Fi, deciding whether K is consistent is NP-complete.
Proof. (Membership). We show that checking the consistency of K can be reduced to deciding an
instance K of (an extension to) the Probabilistic Satisfiability (PSAT) problem (Hailperin, 1984;
Nilsson, 1986), which is in NP (Georgakopoulos, Kavvadias, & Papadimitriou, 1988). Given a set of
m clauses C1 , . . . , Cm , each of them consisting of a disjunction of one or more literals constructed
from the propositional variables x1 , . . . , xn , and probability values Pr(C1 ), . . . , Pr(Cm ) for each
clause, PSAT is the problem of deciding whether there is a probability distribution  over the set of
the 2n truth assignments for the propositional variables x1 , . . . , xn such that for each clause Ci , the
sum of the probabilities assigned by  to the truth assignments satisfying Ci is equal to Pr(Ci ), with
i  [1..m]. PSAT is a generalization of SAT, which is obtained from PSAT by assigning probability
equal to one to each clause. Georgakopoulos et al. formulated PSAT in terms of the feasibility of
a system of m + 1 linear equations using 2n variables corresponding to the probabilities assigned
by  to truth assignments. To show the existence of polynomial-size witness, the following result
from linear programming theory was exploited by Georgakopoulos et al.: if a system of  linear
equalities has a feasible solution, then it admits at least one feasible solution with at most  nonzero variables (Papadimitriou & Steiglitz, 1982). In what follows we consider an extension to
PSAT where each clause Ci is associated with a probability interval [Pr` (Ci ), Pru (Ci )], instead
of a single value. The membership in NP for this extension straightforwardly follows from the
membership proof provided by Georgakopoulos et al. for PSAT, as using probability intervals can
be still formulated as the linear system introduced by Georgakopoulos et al. after reducing doublesided inequalities to equalities with single bounded slack variables (Jaumard, Hansen, & de Aragao,
1991).
Given a PST KB K = hA, Fi, we define an instance K of PSAT where each clause is associated with a probability interval. Let U be the set of all propositional variables xid,p,t such that
id  ID, p  Space, and t  T (i.e., each st-atom loc(id, {p}, t) corresponds to propositional
variable xid,p,t  U ). The conjunction K of clauses associated with probability intervals is defined
as follows:
W
 For each PST atom a = loc(id, r, t)[`, u]  A, K consists of the clause Ca =
xid,p,t .
pr

The probability interval [Pr` (Ca ), Pru (Ca )] is equal to [`, u].
 For each f  F and   f such that (f ) = [

k
V

loc((Xi ), (Yi ), (Zi ))], K consists of

i=1

clause C(f ) =

k
W
i=1

x(Xi ),(Yi ),(Zi ) , whose probability interval is [1, 1].

 For each id  ID and t  T , K consists of the clause Cid,t =

W

xid,p,t , whose

pSpace

probability interval is [1, 1].
 For each id  ID, t  T , and pi , pj  Space, with pi 6= pj , K consists of the clause
Cid,t,pi ,pj = xid,pi ,t  xid,pj ,t whose probability interval is [1, 1].
752

fiK NOWLEDGE R EPRESENTATION IN P ROBABILISTIC S PATIO -T EMPORAL K NOWLEDGE BASES

It is easy to see that for each world w  W(K), there is a truth assignment w for the variables
in U such that w (xid,p,t ) is true iff w(id, t) = p. However, there are truth assignments which do
not correspond to any world in W(K) (for instance, those where both  (xid,pi ,t ) and  (xid,pj ,t ),
with pi 6= pj , are true). We now show that K is consistent iff K is satisfiable.
() Given a model M for K, we show that there is a PDF  over the set of truth assignments such
that for each clause C of K , the sum of the probabilities assigned by  to the truth assignments
satisfying C belongs to [Pr` (C), Pru (C)]. Let  be such that for each truth assignment w corresponding to a world w  W(K), (w ) = M (w) and ( ) = 0 for all other truth assignments  not
corresponding to a world. It is easy to check that the conditions of Definition 6 entail that clauses
of the form Ca and C(f ) are satisfied by , and clauses of the form Cid,t and Cid,t,pi ,pj are satisfied
as well since only w1 , . . . w|W(K)| may have been assigned by  a probability different from 0 and
every world w  W(K) by definition assigns exactly one point in Space to each id, t pair.
() Let  be a PDF over the set of truth assignments such that for each clause C of K , the sum
of probabilities assigned by  to the truth assignments satisfying C belongs to [Pr` (C), Pru (C)].
A model M for K can be defined as M (w) = (w ) where  is the truth assignment corresponding to world w  W(K). Since the clauses of the form Cid,t (resp., Cid,t,pi ,pj ) are satisfied by
, all truth assignments  such that  (xid,p,t )=false for all p  Space (resp.,  (xid,pi ,t )=true and
 (xid,pj ,t )=true, with pi , pj  Space, pi 6= pj ) are assigned by  probability 0. Hence, all other
truth assignments correspond to a world, and the fact that the clauses of the form Ca and C(f ) are
satisfied by  entails that the conditions of Definition 6 hold.
(Hardness). We show a reduction to our problem from the NP-hard Hamiltonian path problem (Papadimitriou, 1994), that is, the problem of checking whether there is a path  in a directed graph G
such that  visits each vertex of G exactly once.
Given a directed graph G = hV, Ei, where V = {v0 , . . . , vk } is the set of its vertices, and E
is a set of pairs (vi , vj ) with vi , vj  V , we construct an instance of our problem as follows. Let
ID = {id}, Space = V , and T = [0, . . . , k]. K is the pair hA, Fi such that A consists of the PST
atom loc(id, {v0 }, 0)[1, 1] and F consists of std-formulas f1i (with i  [0..k]) and f2 such that:
 f1i = Z1 , Z2 [loc(id, {vi }, Z1 )  loc(id, Space\V 0 , Z2 )  Z2 = Z1 + 1] where V 0 is the
set of vertices vj s.t. (vi , vj )  E. This formula says that the only points id can reach starting
from vi in one time step are those in V 0 . (f1i does not exist if V 0 = Space.)
 f2 = Y1 , Z1 , Z2 [loc(id, Y1 , Z1 )  loc(id, Y1 , Z2 )  Z1 6= Z2 ], saying that id can not be at
the same location for distinct time values.
We show that K is consistent iff there is a Hamiltonian path in G.
() As there is only one id in A, every world w  W(K) is such that w places id on a vertex
in V at each time value t  T . As K is consistent, there is a model M  M(K) such that M
assigns probability greater than zero only to worlds w such that f  F, w |= f . In particular,
let w be one such world. The fact that w |= f1i entails that t  [0, k  1], w(id, t) = vi and
w(id, t + 1) = vj iff (vi , vj )  E. Moreover, the fact that w |= f2 entails that t, t0  [0, k], t 6= t0 ,
w(id, t) 6= w(id, t0 ), meaning that id is never placed by w on the same vertex at different time
units. Since loc(id, v0 , 0)[1, 1]  A, every world which is assigned probability greater than zero
by M is such that w(id, 0) = v0 . It follows that every world w  W(K) which is assigned by
M  M(K) a probability greater than zero encodes a Hamiltonian path of G whose first vertex is
v0 . In fact, w  W(K) such that M (w) > 0 the following properties hold: (i) w(id, 0) = v0 ,
753

fiPARISI & G RANT

(ii) t  [0, k  1], w(id, t) = vi , w(id, t + 1) = vj iff (vi , vj )  E. (iii) t, t0  [0, k], t 6= t0 ,
w(id, t) 6= w(id, t0 ). Conditions (i) and (ii) entail that  = w(id, 0), w(id, 1), . . . , w(id, k) is a
path on G starting from vertex v0 , while condition (iii) entails that each vertex v  V occurs exactly
once in .
() Let  be a Hamiltonian path of G. We denote by [i] (with i  [0..k]) the i-th vertex of .
W.l.o.g. we assume that the first vertex of  is v0 , that is, [0] = v0 . We now show that K is
consistent by finding a model for it. Let M be a function over W such that for all worlds w  W,
M (w) = 0, except for the world w which is such that: w (id, 0) = [0] = v0 , t  [1, k],
w (id, t) = [t]. It is easy to see that w |= F. In fact, for each i  [0..k], f1i is satisfied by w , since
the fact that  is a path on G entails that t  [0, k 1], w (id, t) = vi and w (id, t+1) = vj only if
edge (vi , vj ) is an edge of G. Moreover, f2 is satisfied by w , since the fact that  is a Hamiltonian
path entails that w places id on different locations (i.e., vertices of G) at different times. Since

w
aP
probability different from 0. Let M (w ) = 1. Therefore, as
P |= F, it can be assigned by M

w|w|=loc(id,v0 ,0) M (w) = M (w )+ w|w6=w w|=loc(id,v0 ,0) M (w) = 1, the condition required by
atom loc(id, v0 , 0)[1, 1]  A holds too. Thus, M is a model for K.
We note that NP-hardness holds already for binary std-formulas. In Section 3.5 we will find
conditions that make the consistency checking problem tractable for binary std-formulas. The reduction shown in the membership proof, from the consistency checking problem to PSAT, would
allow us to define additional tractable cases if the PSAT instances resulting from such a reduction
were tractable. However, as will be discussed in Section 6, the tractable cases that have been identified for PSAT (Georgakopoulos et al., 1988; Andersen & Pretolani, 2001) do not carry over to our
framework.
3.2 Sufficient Condition for Checking Consistency
We present a set of mixed-binary linear inequalities whose feasibility entails the consistency of PST
KB K = hA, Fi. As explained in Section 3.1, Parker et al. (2007a) showed that the consistency
of a PST KB K = hA, i (using our notation) can be checked in polynomial time w.r.t. the size of
K by solving a set of linear inequalities whose variables vid,t,p represent the probability that object
id is at point p at time t. Here, we start from this set of linear inequalities and augment it with
some inequalities ensuring that if the so-obtained set of linear inequalities has a feasible solution
then every ground std-formula derived from F is satisfied. To achieve this, we need to introduce the
binary variables i , thus obtaining a set of mixed-binary linear inequalities.
Definition 8 (MBL(K)). Let K = hA, Fi. MBL(K) consists of the following (in)equalities:
P
(1)  loc(id, r, t)[`, u]  A: ` 
vid,t,p  u;
pr

(2)  id  ID, t  T :

P

vid,t,p = 1;

pSpace

(3)  id  ID, t  T, p  Space: vid,t,p  0;
(4) for each f  F and   f such that (f ) = [

k
V
i=1

number of st-atoms in f , the (in)equalities:
754

loc((Xi ), (Yi ), (Zi ))], where k is the

fiK NOWLEDGE R EPRESENTATION IN P ROBABILISTIC S PATIO -T EMPORAL K NOWLEDGE BASES

P
(a) i  [1..k] :
p(Yi ) v(Xi ),(Zi ),p  i ;
Pk
(b)
i=1 i = k  1;
(c) i  [1..k] : i  {0, 1}.
Basically, inequalities (1) ensure that a solution of MBL(K) places the object in r with a probability between ` and u, as required by the atom (id, r, t, [`, u]). Inequalities (2) and (3) ensure
that for each id and t, the vid,t,p variables jointly represent a probability distribution. Moreover, for
each ground st-atom loc((Xi ), (Yi ), (Zi )) of the ground std-formula (f ), inequalities (4)(a)
and (4)(c) entail that the probability v(Xi ),(Zi ),p that object (Xi ) is in any point p in region (Yi )
at time (Zi ) is either constrained to be 0 or free to take any value not greater than 1. Intuitively
enough, if v(Xi ),(Zi ),p is enforced to be zero (i.e., i = 0), then object (Xi ) can not be in region
(Yi ) at time (Zi ). On the other hand, if v(Xi ),(Zi ),p is left free to take any value less than or
equal to one (i.e., i = 1), then (Xi ) may or may not be in region (Yi ) at time (Zi ). Finally,
equality (4)(b) entails that there is at least one of the k ground st-atoms loc((Xi ), (Yi ), (Zi )) of
(f ) such that (Xi ) is not placed in a point in (Yi ) at time (Zi ).
Example 11. Consider the ground std-formula (f1 ) = [loc(id1 , c, 6)  loc(id2 , c, 6)] of Example 6. Then, the inequalities in MBL(K) corresponding to (f1 ) are:
P
P
(4b) 1 + 2 = 1;
(4c) 1 , 2  {0, 1}.
2
(4a) pc vid1 ,6,p  1 ;
pc vid2 ,6,p  2 ;
The following theorem states that MBL(K) can be used to check if K is consistent.
Theorem 2. If there is a feasible solution of MBL(K) then K is consistent.
Proof. Let  be a solution of MBL(K), and (vid,t,p ) the value assigned to variable vid,t,p by
.
Q We define the function M over W(K) such that, for each world w  W(K), M (w) =
idID,tT,w(id,t)=p (vid,t,p ), that is M (w) is the product of the values assigned by solution
 to variables vid,t,p such that w(id, t) = p. It can be shown that, (in)equalities (2) and (3)
of the definition
of MBL(K) entail that M is a PDF over W(K). Moreover,
since (vid,t,p ) is
P
P
M
(w),
for
each
atom
loc(id,
r,
t)[`,
u]

A,
equal
to
w|w|=loc(id,r,t) M (w) =
P P w|w|=loc(id,t,p)
P
pr
w|w|=loc(id,t,p) M (w) =
pr (vid,t,p )  [`, u]. Given f  F and   f such that (f )
Vk
is logically equivalent to the negation of the conjunction of the st-atoms
i=1 loc((Xi ), (Yi ),
P
(Zi )), the inequalities (4)(a-c) entail that there is i  [1..k] such that p(Yi ) (v(Xi ),(Zi ),p ) =
0. Thus p  (Yi ), (v(Xi ),(Zi ),p ) = 0. Hence, for each world w  W(K) such that w((Xi ),
(Zi )) = p, M (w) = 0 due to the presence of the factor
P (v(Xi ),(Zi ),p ) = 0 in the product defining M (w). Therefore, for each std-formula f  F, w | w6|=f M (w) = 0; hence M is a model for
K and so K is consistent.
A consequence of Theorem 2 is that well-known techniques for solving linear optimization
problems can be adopted to address the consistency checking problem, thus taking advantage of
results from more than 50 years of research on integer linear programming (Junger et al., 2010).
The following example shows that the converse of Theorem 2 does not hold (K may be consistent even if there is no feasible solution of MBL(K)).
Example 12. Let ID = {id}, T = [0, 1], Space = {p0 , p1 }, and K = hA, Fi where:
A = {loc(id, {p0 }, 0)[0.5, 0.5], loc(id, {p1 }, 1)[0.5, 0.5]} and
F = {[loc(id, {p0 }, 0)  loc(id, {p1 }, 1)}.
755

fiPARISI & G RANT

Thus, W = {w1 , w2 , w3 , w4 } where: w1 (id, 0) = p0 , w1 (id, 1) = p0 , w2 (id, 0) = p0 , w2 (id, 1) =
p1 , w3 (id, 0) = p1 , w3 (id, 1) = p0 , w4 (id, 0) = p1 , w4 (id, 1) = p1 .
It is easy to check that the M for which M (w1 ) = 0.5, M (w2 ) = 0, M (w3 ) = 0, M (w4 ) = 0.5 is
a model for K. Then MBL(K) includes the following inequalities:
0.5  vid,0,p0  0.5; 0.5  vid,1,p1  0.5; vid,0,p0 + vid,0,p1 = 1; vid,1,p0 + vid,1,p1 = 1;
vid,0,p0  1 ; vid,1,p1  2 ; 1 + 2 = 1; 1 , 2  {0, 1};
vid,0,p0  0, vid,0,p1  0, vid,1,p0  0, vid,1,p1  0.
The first two inequalities force both vid,0,p0 and vid,1,p1 to be 0.5. So in the second line both 1 and
2 must equal 1. But this contradicts 1 + 2 = 1. Hence MBL(K) has no feasible solution.
2
3.3 Necessary Condition for Checking Consistency
In the following, given a PST KB K, we introduce a set NC(K) of linear inequalities such that if K
is consistent then there is a feasible solution of NC(K). That is, the existence of a feasible solution
of NC(K) turns out to be a necessary condition for the consistency of K.
As MBL(K) (see Definition 8), NC(K) uses rational variables vid,t,p representing the probability
that object id is at point p at time t. As no other kinds of variables are used in the definition of
NC(K), in this case we obtain a pure system of linear inequalities.
Definition 9 (NC(K)). Let K = hA, Fi be a PST KB. NC(K) consists of the following (in)equalities:
P
vid,t,p  u;
(1)  loc(id, r, t)[`, u]  A: ` 
pr

(2)  id  ID, t  T :

P

vid,t,p = 1;

pSpace

(3)  id  ID, t  T, p  Space: vid,t,p  0;
V
(4) for each f  F (with k conjuncts) and   f s.t. (f ) = [ ki=1 loc((Xi ), (Yi ), (Zi ))],
the inequalities:
Pk
p1  (Y1 ), p2  (Y2 ), . . . , pk  (Yk ),
i=1 v(Xi ),(Zi ),pi  k  1.
Herein, (in)equalities (1)-(3) are the same as those of MBL(K) of Definition 8, and have the
same meaning. In addition,
V NC(K) contains inequalities (4) which impose that, for each ground stdformula of the form  ki=1 loc(idi , ri , ti ) and for each k-tuple of points hp1 , p2 , . . . , pk i belonging
respectively to the regions hr1 , r2 , . . . , rk i, the sum of the probabilities vidi ,pi ,ti that object idi is at
point pi at time ti , with i  [1..k], is not greater than k  1. As stated in the following theorem, the
set consisting of inequalities (4) along with inequalities (1)-(3) turns out to have no feasible solution
only if the corresponding PST KB is inconsistent.
Theorem 3. If there is no feasible solution of NC(K), then K is not consistent.
Proof. Suppose that NC(K) has no feasible solution. If this is due to the fact there is no feasible
solution of CC(hA, i (introduced in Fact 1), then PST KB hA, i is not consistent, and thus K =
hA, Fi is not consistent as well (since the set M(hA, Fi) of the models for K = hA, Fi is a subset
of the set M(hA, i) of the models for K0 = hA, i).
Otherwise, there is a feasible solution of CC(hA, i) and thus NC(K) has no feasible solution
due to the fact that at least one of the inequalities in item (4) of Definition 9 is not satisfied by every
756

fiK NOWLEDGE R EPRESENTATION IN P ROBABILISTIC S PATIO -T EMPORAL K NOWLEDGE BASES

solution  for
V CC(hA, i). That is, for each solution  for CC(hA, i), there is a ground std- formula
(f ) =  ki=1 loc((Xi ), (Yi ), (Zi )) such that there exist p1  (Y1 ), p2  (Y2 ), . . . , pk 
P
(Yk ), for which ki=1 (v(Xi ),(Zi ),pi ) > k  1.
Since every model M 0 for K0 = hA, i corresponds to a solution  for CC(hA, i) such that the
sum of the probabilities assigned
by M 0 to the worlds satisfying an st-atom loc(id, {p}, t) is equal
Pk
to (vid,t,p ), the fact that i=1 (v(Xi ),(Zi ),pi ) > k  1 holds entails that, for each model M 0 for
K0 , the sum of the probabilities assigned by M 0 to the worlds satisfying at least one of the st-atoms
in (f ) is greater than k  1, that is,
M 0  M(K0 ),

k
X

X

M 0 (w) > k  1

(1)

i=1 w|=loc((Xi ),(Yi ),(Zi ))

We now recall and use the following well-known result on the minimum probability of a conjunction of probabilistic events among which no correlation is known. Given n probabilistic events
e1 , . . . , en whose (marginal)
probabilities are Pr(e1 ), . . . , Pr(en ) respectively, Pr(e1      en ) 
P
max (0, 1  n + ni=1 Pr(ei )). This is one of the Frechet inequalities (the other one provides an
upper bound on the maximum probability) and is implicitly reported already in Booles work (1854).
In our setting, viewing st-atoms as probabilistic events, the Frechet inequality entails that for
each model M 0 for K0 , the probability that a set S of st-atoms together satisfy a world is greater
than or equal to the maximum between zero and 1  |S| plus the sum of the probabilities of each
st-atom a  S according to M 0 . That is,


X
W(K0 )

w
a  S, w |= a


X

M 0 (w)  max 0, 1  |S| +


X
W(K0 ),

aS w 
w |= a



M 0 (w)


(2)

Equation (1) entails that for each model M 0 for K0 , the term on the right-hand side of Equation (2) evaluates to a value greater than zero when the set S of st-atoms of (f ) is considered.
Therefore, for each model M 0 for K0 , the sum of the probabilities of the worlds satisfying all the
st-atoms in (f ) is greater than zero. Since the set M(hA, Fi) of the models for K = hA, Fi is a
subset of the set M(hA, i) of the models for K0 = hA, i, this property also holds for any model
for K0 . Thus, no such M 0 can be a model of K. Hence K is inconsistent.
An example of the usage of Theorem 3 is given below, where by checking that NC(K) has no
feasible solution we conclude that the PST KB K is not consistent.
Example 13. Let ID = {id}, T = [0, 1, 2], and Space = {p0 , p1 , p2 }. Let K = hA, Fi such that
 A consists of the PST atoms loc(id, {p0 }, 0)[0.4, 1], loc(id, {p1 }, 0)[0.5, 1], loc(id, {p0 }, 1)
[0.8, 1], loc(id, {p0 }, 2) [0.8, 1], meaning that, id is at p0 and at p1 at time 0 with probability greater than or equal to 0.4 and 0.5, respectively, and it is at p0 at times 1 and 2 with
probability greater than or equal to 0.8.
 F consists of the std-formula: [loc(id, {p0 , p1 }, 0)  loc(id, {p0 }, 1)  loc(id, {p0 }, 2)],
saying that id cannot be at p0 at both times 1 and 2 if it was in the region consisting of the
points p0 and p1 at time point 0.
757

fiPARISI & G RANT

It is easy to see that NC(K) contains, among others, the following inequalities:
0.4  vid,0,p0  1
0.5  vid,0,p1  1
0.8  vid,1,p0  1
0.8  vid,2,p0  1
vid,0,p0 + vid,1,p0 + vid,2,p0  2
vid,0,p1 + vid,1,p0 + vid,2,p0  2
where the last two inequalities derive from item (4) of Definition 9. Clearly, these inequalities
cannot be satisfied given that 0.5  vid,0,p1 , 0.8  vid,1,p0 , and 0.8  vid,2,p0 . Thus, since NC(K)
has no feasible solution, we can conclude that K is inconsistent.
2
However, we cannot say anything about the consistency of K if there is a feasible solution
of NC(K). The following examples show a case where NC(K) has a feasible solution and K is
consistent, and a case where NC(K) has a feasible solution but K is inconsistent.
Example 14. Consider the PST KB of Example 13 where A is modified such that the probability
that id is at p0 at times 1 and 2 is greater than or equal to 0.5, instead of 0.8. It is easy to see that
there is a feasible solution of NC(K) in this case. Theorem 3 cannot be used to decide whether K is
consistent or not. As a matter of fact, K is consistent as shown in what follows. Let w1 , w2 and w3
be worlds for K such that
w1 (id, 0) = p1 , w1 (id, 1) = p1 , w1 (id, 2) = p0 ,
w2 (id, 0) = p0 , w2 (id, 1) = p0 , w2 (id, 2) = p1 ,
w3 (id, 0) = p2 , w3 (id, 1) = p0 , w3 (id, 2) = p2 ,
and let M be the PDF over W(K) such that M (w1 ) = 0.5, M (w2 ) = 0.4, M (w3 ) = 0.1, and
M (w) = 0 for any other world w  W(K). It is straightforward to check that M is a model for
K.
2
Example 15. Again, let ID = {id}, T = [0, 1, 2], and Space = {p0 , p1 , p2 }. Let K = hA, Fi
be such that A = {loc(id, {p0 }, 0)[0.5, 1], loc(id, {p0 }, 1)[0.5, 1], loc(id, {p0 }, 2)[0.5, 1]}, i.e., id
is at p0 at any time in T with a probability greater than 0.5, and F consists of the std-formulas:
[loc(id, {p0 }, 0)  loc(id, {p0 }, 1)],
[loc(id, {p0 }, 1)  loc(id, {p0 }, 2)], and
[loc(id, {p0 }, 0)  loc(id, {p0 }, 2)],
saying that id cannot be at p0 at time 1 or 2 if it was already there at any previous time value.
A solution for NC(K) is obtained by assigning the variables vid,t,p0 and vid,t,p1 the value 0.5
(where t  [0, 2]), and the other variables the value 0. As NC(K) has a feasible solution, Theorem 3
says nothing about the fact that K is consistent or not. However, it can be checked that K is not
consistent. Let Pt be the set of worlds in W(K) placing id at p0 at time t, with t  T . The
std-formulas in F entail that every world belonging to two of these three sets must be assigned
probability equal to 0 by any model for K. That is, F entails that P0 , P1 , P2 are pairwise disjoint
sets if we consider only the worlds that can be assigned a probability greater than zero by any model.
Now observe that the PST atoms in A require that the sum of the probabilities of the worlds in each
of these three sets is at least equal to 0.5. Therefore, the overall sum of the probabilities assigned to
the worlds in all of these three sets would be greater than or equal to 1.5, which entails that there is
no model for K.
2
Theorem 3 shows that the consistency of K implies the the existence of a feasible solution
of NC(K) and the previous examples show that this is the only relationship between these two
758

fiK NOWLEDGE R EPRESENTATION IN P ROBABILISTIC S PATIO -T EMPORAL K NOWLEDGE BASES

concepts. However, we can make a stronger statement in a special case. For PST KBs where F
consists of a single ground std-formula (of any arity) constructed from st-atoms referring to singlepoint regions, NC(K) has a feasible solution iff the KB is consistent.

Theorem 4. Let K = hA, Fi where F = { loc(id1 , {p1 }, t1 )      loc(idn , {pn }, tn )]}. Then,
K is consistent iff there is a feasible solution of NC(K).
Proof. Using Theorem 3 we need to prove that if there is a feasible solution of NC(K) then K is
consistent.
Let f be the std-formula in F. We first observe that if f contains a pair of st-atoms referring to
the same id and time value but different points in Space, then K is consistent. Indeed, in this case,
f is satisfied by every world, and thus it does not impose any restriction on the interpretations for
K (see Definition 4). Given this, in the following w.l.o.g. we assume that for every distinct pair of
st-atoms loc(idi , {pi }, ti ), loc(idj , {pj }, tj ) in f , if idi = idj then ti 6= tj .
Let  be a solution for NC(K), and K0 = hA, i. Then,  is a solution for CC(K0 ) (from Fact
1) and corresponds to a model M 0 for K0 such that (i) the sum of the probabilities assigned by M 0
to the worlds satisfying an st-atom
loc(id, {p}, t) (i.e., the marginal probability of loc(id, {p}, t)) is
P
equal to (vid,t,p ), and (ii) ki=1 (vidi ,ti ,pi )  k  1. Viewing each st-atom loc(idi , {pi }, ti ) in f
as a probabilistic event whose (marginal) probability is (vidi ,ti ,pi ), the Frechet inequality (recalled
in the proof of Theorem 3) entails thatPthe minimum probability that the st-atoms in f occur all
together is equal to max(0, 1  k + ki=1 (vidi ,ti ,pi )). This is equal to zero since the second
argument of function max is not greater than zero due to the fact that (ii) holds. The fact that the
minimum probability that the st-atoms in f simultaneously occur is equal to zero suffices to ensure
that there is at least one model M 00 for K0 such that M 00 assigns probability equal to zero to all the
worlds for K0 that do not satisfy f . As f is the only std-formula in F, and every world not satisfying
f is assigned a probability equal to zero by M 00 , it follows that M 00 is a model for K too.
The following example shows that considering even a binary std-formula containing an st-atom
referring to a region consisting of two points, it may happen that there is a feasible solution of
NC(K) even if K is not consistent.
Example 16. Let ID = {id}, T = [0, 1], and Space = {p0 , p1 , p2 }. Let K = hA, Fi be such that
A = {loc(id, {p0 }, 0)[0.4, 1], loc(id, {p1 }, 0)[0.4, 1], loc(id, {p0 }, 1)[0.4, 1], }, and F is the stdformula [loc(id, {p0 , p1 }, 0)  loc(id, {p2 }, 1)] saying that id cannot move to point p2 at time 1 if
it was in either p0 or p1 at time 0. It is easy to see that NC(K) is feasible but K is not consistent. 2
In Section 3.5, we will present a method for deciding in polynomial time the consistency of
PST KBs where binary std-formulas satisfying some acyclicity conditions are used. It turns out
that the consistency of the PST KBs of both Examples 15 and 16 can be decided in polynomial
time using our approach.
3.4 Unary Std-Formulas are Tractable
We start by identifying a tractable case of the consistency checking problem: when all std-formulas
are unary, that is, each formula in F consists of only one st-atom and possibly a conjunction of
built-in predicates (i.e., in Definition 2, k = 1).
759

fiPARISI & G RANT

Example 17. The constraint there is no object in region r at any time between 5 and 10 can be
expressed by the following unary std-formula: X1 , Z1 [loc(X1 , r, Z1 )  Z1  5  10  Z1 ].
The constraint object id is always in region r can be expressed as:
Y1 , Z1 [loc(id, Y1 , Z1 )  Y1 nov r]. 7
2
The following theorem states that checking consistency is tractable if only unary std-formulas
are considered.
Theorem 5. Let K = hA, Fi be a PST KB such that F consists of unary std-formulas only. Then,
deciding whether K is consistent is in P T IM E.
Proof. The statement follows from the fact that if F consists of unary std-formulas only, K =
hA, Fi is equivalent to (i.e., it has exactly the same set of models as) K0 = hA0 , i, where A0
consists of the atoms in A plus the atom loc((Xi ), (Yi ), (Zi ))[0, 0] for each
S ground std-formula
(f ) = [loc((Xi ), (Yi ), (Zi ))], where f  F and   f . Since, f F f is polynomial
w.r.t. the size of K, the size of A0 (and thus of K0 ) increases by a polynomial number of atoms.
Hence, we can apply Fact 1, which entails that the consistency of PST KBs with F =  can be
decided in P T IM E.
3.5 Tractable Binary Std-Formulas
In the following we focus on PST KBs where all std-formulas are binary. This is a restricted
but expressive class of std-formulas that allow us to impose several practical constraints in many
application contexts. As a matter of fact, both f1 and f2 of Example 2 as well as f4 of Example 4
are binary std-formulas. Furthermore, using the approach suggested in the proof of Theorem 5, we
can assume that unary std-formulas are encoded as PST atoms. Thus, all the results stated in this
section straightforwardly apply to the case where both unary and binary std-formulas are in the PST
KB.
We start by noting that consistency checking was proved to be feasible by Grant et al. (2010)
for the case where reachability definitions (but no other integrity constraints) were allowed. As we
showed in Example 3 a reachability definition can be expressed by a binary std-formula. Hence,
in the special case where all the binary std-formulas represent reachability definitions, consistency
checking is tractable.
In the general case of a PST KB K = hA, Fi such that F consists of binary std-formulas, we
define an undirected graph, called the std-graph, where each maximal independent set represents a
world for K satisfying all the std-formulas in F. 8 We will later use this graph to characterize binary
std-formulas for which the consistency checking problem turns out to be tractable.
Definition 10 (std-graph). Given a PST KB K = hA, Fi such that F consists of binary stdformulas, the std-graph G(K) is an undirected graph hV, Ei whose sets of vertices V and edges
E are such that:
1) V consists of the set of all ground st-atoms of the form loc(id, {p}, t) where id  ID, p 
Space, and t  T ;
7. Recall that every substitution for Y1 must be a region containing a single point.
8. A maximal independent set in the std-graph is a maximal independent set in an undirected graph whose vertices are
st-atoms. The formal relationship between maximal independent sets in the std-graph and worlds of a PST KB is
given in Proposition 1.

760

fiK NOWLEDGE R EPRESENTATION IN P ROBABILISTIC S PATIO -T EMPORAL K NOWLEDGE BASES

2) E consists of
i) an edge between every pair of ground st-atoms in V referring to the same object and
time value, that is, for each p1 , p2  Space, p1 6= p2 , id  ID, t  T , hloc(id, {p1 }, t),
loc(id, {p2 }, t)i  E;
ii) an edge hloc(id1 , {p1 }, t1 ), loc(id2 , {p2 }, t2 )i between every pair of ground st-atoms in
V such that  loc(id1 , r1 , t1 )  loc(id2 , r2 , t2 )] with p1  r1 and p2  r2 belongs to
the set of ground std-formulas that can be derived from F.
We will just write G instead of G(K) where K is known.
Basically, each edge of G connects a pair of st-atoms that cannot belong together in any world
satisfying the std-formulas in F. In particular, an edge of type i) connects two st-atoms representing
the fact that an object is in two places at the same time  this is not admitted according to the
definition of world (see Definition 4). An edge of type ii) connects two st-atoms representing a fact
(i.e., object id1 is at point p1 at time t1 and object id2 is at point p2 at time t2 ) not consistent with a
ground std-formula entailed by F.
The structure of G is as follows. For each hid, ti pair, G contains a clique 9 of size |Space|
which consists of a vertex loc(id, {p}, t) for each point in Space and edges of type i)  in the
following, we refer to
 this clique as the clique for hid, ti pair or the hid, ti clique. For each ground
std-formula f =  loc(id1 , r1 , t1 )  loc(id2 , r2 , t2 )] that can be derived from F, G contains a
clique of size |r1 | + |r2 | which consists of a vertex loc(id1 , {p1 }, t1 ) for each point in r1 , a vertex
loc(id2 , {p2 }, t2 ) for each point in r2 , and edges of both types i) and ii)  we refer to this clique as
the clique for std-formula f .
Example 18. Let ID = {id1 , id2 }, T = [0, 1, 2], and Space = {p1 , p2 , p3 , p4 }. Assume that F
consists of the following std-formulas:
 f1 = X1 , X2 , Z1 [loc(X1 , {p2 , p4 }, Z1 )  loc(X2 , {p2 , p4 }, Z1 )  X1 6= X2  0  Z1 
Z1  1], saying that there cannot be two distinct objects in the region consisting of points
{p2 , p4 } at times 0 and 1;
 f2 = Z1 [loc(id1 , {p3 , p4 }, 0)  loc(id1 , {p1 }, Z1 )  1  Z1  Z1  2], saying that object
id1 cannot reach point p1 starting from region {p3 , p4 } at time 0 in 1 or 2 time units.
The std-graph G is shown in Figure 2(a), where, for the sake of readability, vertices are labelled
with the names of the points in Space to which they refer, while the id and time value of each vertex
is reported on the column and the row to which it belongs (for instance, vertex loc(id1 , {p1 }, 0) is
represented by the circle in the upper-left corner). Observe that G consists of 10 (maximal) cliques,
one for each of the 6 hid, ti pairs, and one for each of the 4 ground std-formulas derived from F.
Specifically, each hid, ti-clique, with id  {id1 , id2 } and t  [1..2], consists of the four vertices
loc(id, {pk }, t) with k  [1..4], while the cliques for the ground std-formulas are the following sets:
{loc(id1 , {p2 }, 0), loc(id2 , {p2 }, 0), loc(id1 , {p4 }, 0), loc(id2 , {p4 }, 0)},
{loc(id1 , {p2 }, 1), loc(id2 , {p2 }, 1), loc(id1 , {p4 }, 1), loc(id2 , {p4 }, 1)},
{loc(id1 , {p3 }, 0), loc(id1 , {p4 }, 0), loc(id1 , {p1 }, 1)}, and
{loc(id1 , {p3 }, 0), loc(id1 , {p4 }, 0), loc(id1 , {p1 }, 2)}.
2
761

fiPARISI & G RANT

id1

id2

p1

p2

p2

p1

p3

p4

p4

p3

p1

p2

p2

p1

p3

p4

p4

p3

id1,0

id2,0

p1

p2

p2

p1

id1,1

id2,1

p3

p4

p4

p3

id1,2

id2,2

t=0

t=1

t=2

(a)

(b)

Figure 2: (a) Std-graph G; (b) Auxiliary-graph AG.
It is worth noting that the cliques for the hid, ti pairs as well as those for the std-formulas are
not maximal cliques in general, as shown in the following.
Example 19. Continuing Example 18, assume that F is augmented with the following (ground)
std-formulas:
 f3 = [loc(id2 , {p3 }, 1)  loc(id2 , {p2 }, 2)]
 f4 = [loc(id2 , {p4 }, 1)  loc(id2 , {p2 }, 2)]
Thus, the clique for std-formula f3 consists of the set {loc(id2 , {p3 }, 1), loc(id2 , {p2 }, 2)}, while
that for f4 consists of the set {loc(id2 , {p4 }, 1), loc(id2 , {p2 }, 2)}. Both these cliques are not maximal ones, as they are included in the clique consisting of the set of vertices
{loc(id2 , {p3 }, 1), loc(id2 , {p4 }, 1), loc(id2 , {p2 }, 2)}. This is basically due to the fact that the
constraint imposed by f3 and f4 can be expressed more succinctly, as [loc(id2 , {p3 , p4 }, 1) 
loc(id2 , {p2 }, 2)] whose associated clique is maximal.
2
The following proposition follows from the definition of std-graph and the fact that every object
must be at a unique point for each time value.
Proposition 1. Let K = hA, Fi be a PST KB where F consists of binary std-formulas only. Every
maximal independent set of G consisting of a vertex from each hid, ti clique is in a one-to-one
correspondence with a world w  W such that w |= F.
9. Note that we use the terminology clique for a complete subgraph of G, and maximal clique for a clique not contained
in any other clique. We point this out since maximal cliques are often called simply cliques.

762

fiK NOWLEDGE R EPRESENTATION IN P ROBABILISTIC S PATIO -T EMPORAL K NOWLEDGE BASES

Observe that if there is no maximal independent set of G having the property stated in Proposition 1, then G must contain a maximal clique including at least two hid, ti cliques (this happens for
instance if F contains an std-formula [loc(id, Space, t1 )  loc(id, Space, t2 )]). In this case, no
world satisfies F and the PST KB is trivially inconsistent. In the general case, there may be an exponential number of maximal independent sets of G having the property stated in Proposition 1, and
the fact that the PST KB is consistent or not can be decided using G as explained in what follows.
3.5.1 C LIQUE -ACYCLIC S TD -G RAPHS
Our characterization of tractable cases of the consistency checking problem focuses on KBs with
binary std-formulas such that their std-graphs have a property, that we call clique-acyclic. We start
with some preliminary definitions.
Definition 11 (Binary maximal clique). For std-graph G we call a clique binary maximal iff it
contains vertices from two hid, ti pairs and is not properly included in any clique that contains
vertices from the same hid, ti pairs.
In particular, the std-graph G of Figure 2(a) has 4 binary maximal cliques all involving id1 .
Definition 12 (Clique-subgraph). We call a subgraph of std-graph G a clique subgraph iff it contains
all the vertices of G, one edge from each hid, ti clique as well as one new distinct edge from each
binary maximal clique.
So any clique-subgraph of the std-graph of the graph G of Figure 2(a) has 10 edges, one from
each of the 6 hid, ti pairs and one from each binary maximal clique.
Definition 13 (Clique-acyclic std-graph). Std-graph G is said to be clique-acyclic iff all of its cliquesubgraphs are acyclic graphs (that is, forests). G is called clique-cyclic if it is not clique-acyclic.
Basically, clique-acyclicity means that no cycle can be found in the std-graph after compressing
all binary maximal cliques into single edges and using just one edge of each hid, ti-clique. It is easy
to see that the std-graph shown in Figure 2(a) is clique-acyclic. As stated in the next proposition,
clique-acyclicity can be checked using the following auxiliary graph which basically compresses a
clique-subgraph to its essential structure. It will be clear from the definition that the same auxiliary
graph is obtained from all clique-subgraphs of a graph G.
Definition 14 (Auxiliary graph). The auxiliary graph for G is the undirected graph AG = hV 0 , E 0 i
such that:
 V 0 consists of a vertex for each hid, ti pair, with id  ID and t  T ;
 E 0 consists of all the edges for binary maximal cliques in a clique-subgraph where each
previous vertex loc(id, {p}, t) is replaced by the corresponding hid, ti pair. We will denote as
C(e) the binary maximal clique C from which the edge e originated.
The auxiliary graph for the std-graph of Figure 2(a) is shown in Figure 2(b). As an example,
C(e) for edge e = h(id1 , 0), (id1 , 1)i consists of the following set of vertices
{loc(id1 , {p3 }, 0), loc(id1 , {p4 }, 0), loc(id1 , {p1 }, 1)}.
The following proposition follows from Definitions 13 and 14.
763

fiPARISI & G RANT

Proposition 2. Std-graph G is clique-acyclic iff the auxiliary graph AG is acyclic (that is, AG is a
forest).
In the following, we introduce a set of linear inequalities that can be used to check the consistency of PST KBs where the std-formulas are binary and the auxiliary graph is acyclic. Then in
the next subsection we will do the same for a special case of a cyclic auxiliary graph. In both cases
we will be working with a single connected component of the auxiliary graph. Suppose that AG
has n connected components C1 , . . . , Cn and let Ki be the PST KB corresponding to Ci for each
i. If K has a model M we show how to obtain a model Mi for Ki . Let wi be a world appropriate
to the hid, ti pairs for Ki .PLet Wi be all the worlds of K that extend wi to the hid, ti values not
in Ki . Define Mi (wi ) = wWi M (w). Going in the other direction, suppose that M1 , . . . , Mn
are models for the PST KBs corresponding to Ci , . . . , Cn respectively. For any world w for K, let
w1 , . . . , wn be the restrictions of w to C1 , . . . , Cn respectively. Defining M (w) = ni=1 M (wi ) is
then a model of K. We have shown the following result.
Proposition 3. K is consistent iff all of the PST KBs corresponding to the connected components
of G (and hence of AG) are consistent.
Hence in our proofs it suffices to assume that AG has a single connected component.10
Definition 15 (BC(K)). Let K = hA, Fi be a PST KB such that F consists of binary std-formulas
only. BC(K) consists of the following (in)equalities:
P
vid,t,p  u;
(1)  loc(id, r, t)[`, u]  A: ` 
pr

(2)  id  ID, t  T :

P

vid,t,p = 1;

pSpace

(3)  id  ID, t  T, p  Space: vid,t,p  0;
P
vid,t,p  1.
(4) For each edge e of AG:
loc(id,{p},t)C(e)

The following theorem states that checking whether BC(K) has a feasible solution is equivalent
to deciding the consistency of PST KBs K where std-formulas are binary and generate an acyclic
auxiliary graph. The intuition behind this result is as follows. If there is a feasible solution of
BC(K), then inequalities (1)-(3) entail that for each hid, ti pair, the events that object id at time t is
at point p  Space can be arranged to fit the whole probability space without overlapping. Roughly
speaking this would suffice to define a model for a PST KB without std-formulas by combining
the distributions obtained for each hid, ti pair. Considering std-formulas means that some events
cannot occur together, that is, they cannot coexist in the same portion of the probability space.
Intuitively, the fact that inequality (4) of BC(K) is satisfied for an edge e entails that the events
corresponding to the st-atoms in C(e) can be arranged in distinct portions of the probability space
(avoiding overlaps). If the auxiliary graph AG is acyclic, this reasoning can be inductively repeated
for each edge of AG without ever reconsidering the arrangement of events corresponding to the
st-atoms considered previously. The satisfiability of inequality (4) of BC(K) is also a necessary
10. We do not indicate this in the statement of the following theorem because if AG has several connected components,
the proof works for each one and then Proposition 3 is applied.

764

fiK NOWLEDGE R EPRESENTATION IN P ROBABILISTIC S PATIO -T EMPORAL K NOWLEDGE BASES

condition for the consistency of K as the fact that it is not satisfied for an edge e of AG intuitively
means that the events corresponding to the st-atoms in C(e), even taken alone, cannot be arranged
in the probability space without overlapping.
Theorem 6. Let K = hA, Fi be a PST KB where F consists of binary std-formulas only. If AG is
acyclic, then K is consistent iff there is a feasible solution of BC(K).
Proof. We will use the notation K0 for K with F removed, that is, K0 = hA, i. Then, M(K) is a
subset of M(K0 ).
() We prove the contrapositive: if there is no feasible solution of BC(K), then K is inconsistent. The simplest case is where BC(K) has no feasible solution due to the fact that BC(K0 ) has no
feasible solution. Then there are no inequalities (4), hence K0 is not consistent, and thus K is not
consistent as well.
Otherwise, there is a feasible solution of BC(K0 ) and thus BC(K) has no feasible solution due
to the fact that at least one of the inequalities
of item (4) of Definition 15 is not satisfied. Therefore,
P
there is an edge e of AG such that loc(id,{p},t)C(e) vid,t,p > 1. To show that K is inconsistent we
show that no interpretation can be a model of K. So suppose that M is an interpretation that is a
model for K. Since a pair A1 , A2 of st-atoms belong to C(e) iff (a) [A1  A2 ] belongs to the set of
ground formulas that can be derived by F, or (b) A1 = loc(id, {p1 }, t) and A2 = loc(id, {p2 }, t)
where p2 6= p1 , there is no world w  W(K) such that M (w) > 0, w |= A1 , and w |= A2 (in
particular, in case (b) there is no world w  W(K) such that w |= A1 , and w |= A2 , whether or
not M (w) > 0). That is, every world w for K which is assigned a non-zero probability by M is
such that it satisfies at most one st-atom in C(e). Hence, W(K) can be partitioned into |C(e)| + 2
pairwise disjoint sets as follows:
(i) the set of worlds w  W(K) such that M (w) = 0 (this set includes all the worlds satisfying
at least two st-atoms in C(e))
(ii) the set of worlds w  W(K) such that M (w) > 0 and w does not satisfy any st-atom in C(e);
(iii) for each st-atom Ai  C(e), the set of worlds w  W(K) such that M (w) > 0, w |= Ai , and
w 6|= Aj where Aj  C(e) (and is different from Ai ).
Therefore, the sum of the probabilities of the worlds satisfying at least one st-atom in C(e) is equal
to the sum, for each st-atom A in C(e), of the sum of the probabilities of the worlds satisfying atom
A  C(e) but no other st-atoms in C(e), that is
X
w  W(K)
w |= loc(id, {p}, t)
loc(id, {p}, t)  C(e)

M (w) =

X

X

loc(id,{p},t)C(e)

w  W(K)
w |= loc(id, {p}, t)
w 6|= loc(id0 , {p0 }, t0 )
loc(id0 , {p0 }, t0 )  C(e)

M (w).

Now recall that any model for K is also a model for K0 . The above-mentioned partitioning of
W(K) also holds for W(K0 ). Therefore, there is a solution  for BC(K0 ), one-to-one corresponding
to a model M for K0 , such that the sum of the probabilities assigned by M to the worlds for K0 satisfying an st-atom loc(id, {p}, t) is equal to the value assigned to variable vid,t,p by . In particular,
765

fiPARISI & G RANT

for a given st-atom loc(id, {p}, t)  C(e), we have that
X
X
M (w) =
W(K0 )

M (w) = vid,t,p .

W(K0 )

w
w |= loc(id, {p}, t)

w
w |= loc(id, {p}, t)
loc(id, {p}, t)  C(e)
w 6|= loc(id0 , {p0 }, t0 )
loc(id0 , {p0 }, t0 )  C(e)

Considering all the st-atoms in C(e) we obtain that
X
X
M (w) =
W(K0 )

X

loc(id,{p},t)C(e)

w
w |= loc(id, {p}, t)
loc(id, {p}, t)  C(e)

=

X

M (w) =

W(K0 )

w
w |= loc(id, {p}, t)
w 6|= loc(id0 , {p0 }, t0 )
loc(id0 , {p0 }, t0 )  C(e)

vid,t,p > 1.

loc(id,{p},t)C(e)

The inequality above holds since the inequality (4) of Definition 15 is not satisfied for edge e.
Finally, since the following inequality holds due to the definition of model
X
X
M (w) 
M (w),
wW(K0 )

w  W(K0 )
w |= loc(id, {p}, t)

and the latter is strictly greater than one, it follows that M is not a PDF over W(K0 ), meaning that
M is a not model for K0 . Hence no interpretation can be a model for K and so K is inconsistent.
() We now prove that if the auxiliary graph AG is acyclic and BC(K) has a feasible solution,
then K is consistent. We prove this by mathematical induction on the number of edges of AG.
Base case: The number of edges is 0, so AG consists of a set of isolated vertices. The fact
that AG contains no edges means that the set of ground std-formulas that can be derived from F is
empty. Thus there is a feasible solution of BC(K) iff there is a feasible solution of CC(K0 ). Using
Fact 1, we obtain that K is consistent.
Inductive step: We prove that if the statement holds for  edges of AG, then it holds for  + 1
edges. So we are given an acyclic graph AG with  + 1 edges, that we write as AG +1 . By
acyclicity we can choose a subgraph, AG  with  edges such that the new edge connects a vertex
to an isolated vertex of AG  and AG  is clearly acyclic. Let K = hA, F  i be the PST KB where
F  consists of the subset of ground std-formulas derived from F so that the std-graph G  has the
auxiliary graph AG  . The induction hypothesis is that if there is a feasible solution of BC(K ),
then K is consistent.
We write K+1 = hA, F +1 i where F +1 consists of the ground std-formulas in F  plus those
corresponding to the new edge e, so that AG +1 turns out to be the auxiliary graph for G(K+1 ).
Assuming the induction hypothesis, we now show that if there is a feasible solution of BC(K+1 ),
then K+1 is consistent.
Let  be a solution for BC(K+1 ). Obviously,  is also a solution for BC(K ), as it consists
of a subset of the (in)equalities in BC(K+1 ). The fact that  is a solution for BC(K ) means that
there is a model M  for K such that the sum of the probabilities assigned by M  to the worlds for
766

fiK NOWLEDGE R EPRESENTATION IN P ROBABILISTIC S PATIO -T EMPORAL K NOWLEDGE BASES

K satisfying an st-atom loc(id, {p}, t) is equal to the value (vid,t,p ) assigned to variable vid,t,p by
. Since  is a solution also for BC(K+1 ), and thus inequality (4) of Definition 15 holds, it follows
that
X
X
X
(vid,t,p )  1.
M  (w) =
loc(id,{p},t)C(e)

w  W(K ),
w |= loc(id, {p}, t)

loc(id,{p},t)C(e)

That is, M  is a model for K with the property that the sum of the probabilities of the worlds
satisfying at least one st-atom in C(e) is less than or equal to one.
If M  is such that it assigns probability equal to zero to every world in W(K ) containing at
least two st-atoms in C(e), then we are done, since M  turns out to be a model for K+1 too.
Otherwise, starting from M  , we show that a model M +1 for K+1 can be constructed by
reasoning as follows.
We recall that the new edge e being added to AG  to obtain AG +1 is of the form h(id1 , t1 ),
(id2 , t2 )i. Let C1 (e) and C2 (e) be the sets of st-atoms in C(e) of the form loc(id1 , {p}, t1 ) and
loc(id2 , {p}, t2 ), respectively. Hence, C(e) = C1 (e)  C2 (e) and C1 (e)  C2 (e) = . Let
 = hw1 , w2 , . . . , wn i be a permutation of the worlds w  W(K ) which are assigned by M 
a probability greater than zero (i.e., M  (w) > 0) and such that the first k worlds in  satisfy an statom in C1 (e). Note that, W(K ) = W(K+1 ), and that a world in W(K ) consists of at most one
atom in C1 (e), as it is a function whose domain is ID  T (see Definition 4) and all of the st-atoms
in C1 (e) refer to the same id andP
time value. Let us denote by i the sum of the probabilities of the
first i worlds in , that is, i = ij=1 M  (wj ), where wj is in . Thus, k is equal to the sum of
the probabilities assigned by M  to the worlds satisfying an st-atom in C1 (e), i.e.,
X

k =

X

M  (w) =

w  W(K ),
w |= loc(id, {p}, t),
loc(id, {p}, t)  C1 (e)

(vid,t,p ).

loc(id,{p},t)C1 (e)

Let S be the subset of Space consisting of points p such that variables vid2 ,t2 ,p are assigned a
value greater than zero by , that is, S = {p | p  Space, (vid2 ,t2 ,p ) > 0}. Observe that these
variables correspond to st-atoms referring to endpoint (id2 , t2 ) of edge e. Let  = hp1 , p2 , . . . , pm i
be a permutation of the points in S such that the first h points p correspond to the variables vid2 ,t2 ,p
such that loc(id2 , {p}, t2 ) 6 C2 (e), and the subsequent points in  (with index in [h + 1, .., m])
correspond to the variables vid2 ,t2 ,p such that loc(id2 , {p}, t2 )  C2 (e). Let i be the sum of the
Pi
values assigned by  to the first i points in , that is, i =
j=1 (vid2 ,t2 ,pj ) where pi  .
Observe thatPm = 1 since equality (2) of Definition 15 holds for BC(K+1 ), and that h =
1
(vid,t,p ). The fact that inequality (4) of Definition 15 holds for BC(K+1 )
loc(id2 ,{p},t2 )C2 (e)

entails that,
1  h + k =

X

(vid,t,p ) +

loc(id,{p},t)C2 (e)

X

(vid,t,p )  1.

loc(id,{p},t)C1 (e)

Therefore, we obtain that k  h . Intuitively, this means that it is possible to define a PDF over
the worlds for K+1 so that no world satisfies two st-atoms in C(e), while keeping satisfied all the
PST atoms and std-formulas satisfied by M  . This is formally described below.
767

fiPARISI & G RANT

We define a model M +1 for K+1 as follows. Let U = hu1 , u2 , . . . , uz i be the sequence
consisting of the values in {1 , . . . , n }  {1 , . . . , m } ordered in ascending order. We define the
following z non-zero probability worlds for K+1 . For each ui  U , let wi be a world such that:
 id  ID \ {id2 }, t  T \ {t2 }, wi (id, t) = wj (id, t), where wj  W(K ) and j is the
smallest subscript such that j  ui .
 wi (id2 , t2 ) = pj , where pj  S and j is the smallest subscript such that j  ui .
We define M +1 as the PDF over W(K+1 ) such that (i) M +1 (w1 ) = v1 , (ii) M +1 (wi ) =
vi  vi1 for each i  [1..z], and (iii) for all the other worlds w  W(K+1 ), M +1 (w) = 0.
We now show that M +1 is a model for K+1 . First, observe that M +1 is a model for K .
In fact, for each id  ID \ {id2 }, id  T \ {t2 }, and p in Space, the probability that object id is
at time value t at point p according to M +1 is equal to the probability that id is at time value t at
point p according to M  , that is
X
X
id  ID \ {id2 }, t  T \ {t2 }, p  Space,
M +1 (w) =
M  (w).
w  W(K ),
w(id, t) = p

w  W(K+1 ),
w(id, t) = p

Moreover, for the hid2 , t2 i pair,
X
p  Space,

M +1 (w) = (vid2 ,t2 ,p ) =

X

M  (w).

w  W(K ),
w(id, t) = p

w  W(K+1 ),
w(id, t) = p

This ensures that, for each PST atom a = loc(id, r, t)[`, u]  A, the sum of the probabilities
assigned by M +1 to the worlds satisfying the st-atom loc(id, r, t) belong to the probability interval
[`, u] specified by a, since the same hold for M  . Moreover, none of the worlds which is assigned
a probability equal to zero by M  is assigned a probability greater than zero by M +1 , as  only
consists of worlds which are assigned a non-zero probability by M  . Therefore, M +1 is a model
for K .
Finally, to show that M +1 is a model for K+1 , it suffices to observe that k  h entails that
there is no world wi for K+1 (with i  [1..z]) which is assigned a probability greater than zero
and which satisfies two atoms in C(e). This completes the proof.
The following example shows the usage of the result of Theorem 7 to check the consistency of
a PST KB.
Example 20. Continuing Example 18, assume that K is a PST KB where F is the set of stdformulas given in Example 18 and A consist of the following set PST atoms:
loc(id1 , {p3 , p4 }, 0)[.7, 1], loc(id1 , {p1 }, 1)[.2, .5], loc(id1 , {p1 }, 2)[.3, .8], loc(id2 , {p2 }, t)[.7, 1]
for t  [0..2]. It can be checked that for this PST KB the corresponding set of linear inequalities BC(K) has a feasible solution. Thus, since the auxiliary graph AG(K) shown in Figure 2(b) is
acyclic, it follows that K is consistent.
Consider now the PST KB K0 obtained from K by replacing the atom loc(id1 , {p1 }, 2)[.3, .8]
with loc(id1 , {p1 }, 2)[.8, .8], where the lower probability is .8 instead of .3. In this case, BC(K0 )
includes the inequalities 0.7  vid1 ,0,p3 + vid1 ,0,p4  1 and 0.8  vid1 ,2,p1  0.8 (due to PST
atoms), and vid1 ,0,p3 + vid1 ,0,p4 + vid1 ,1,p1  1 (due to the edge h(id1 , 0), (id1 , 2)i of AG(K)).
Clearly, there is no feasible solution of BC(K0 ), and thus K0 is not consistent.
2
768

fiK NOWLEDGE R EPRESENTATION IN P ROBABILISTIC S PATIO -T EMPORAL K NOWLEDGE BASES

We note the fact that the acyclicity of AG is not used in the left-to-right proof of Theorem 6.
Therefore, whether or not AG(F) is acyclic, for PST KBs where the std-formulas are binary, the
necessary condition stated in the following theorem can be used for checking consistency.
Theorem 7. Let K = hA, Fi be a PST KB where F consists of binary std-formulas only. If there
is no feasible solution of BC(K), then K is not consistent.
The condition that BC(K) has no feasible solution is stronger than that NC(K) has no feasible
solution, used in Theorem 3 for general std-formulas, since it can be easily checked that every
solution of BC(K) is a solution of NC(K), but the converse does not hold in general. Thus, there
are PST KBs K, such that using Theorem 3 we cannot conclude anything about the consistency of
K, as NC(K) has a feasible solution, but we can show that K is inconsistent by using the result of
Theorem 7.
Example 21. We have already observed that the fact that the PST KB K of Example 16 is not
consistent cannot be concluded by checking whether there is a feasible solution of NC(K). However,
it is easy to see that BC(K) has no feasible solution in this case, and thus we can conclude that the
PST KB of Example 16 is not consistent by applying the result of Theorem 7.
2
Although the necessary condition in Theorem 6 can be still used to check the consistency when
the auxiliary graph is cyclic (see Theorem 7), the sufficient condition of Theorem 6 entails that a
PST KB K is consistent only if the corresponding set BC(K) of linear inequalities has a feasible
solution and the auxiliary graph is acyclic. In the following, we identify a class of std-graphs for
which the consistency checking problem remains tractable even if the std-graph is clique-cyclic (and
thus the auxiliary graph is cyclic).
3.5.2 S IMPLE C LIQUE -C YCLIC S TD -G RAPHS
In this section we provide a set of linear inequalities for checking the consistency of a PST KB
whose std-graph satisfies the following property.
Definition 16 (Simple clique-cyclic std-graph). Std-graph G is said to be simple clique-cyclic iff
its auxiliary graph AG is a simple graph 11 and each cyclic connected component of G contains a
single maximal clique that is not an hid, ti clique.
The following is an example of a simple clique-cyclic std-graph. We provide both the std-graph
and its auxiliary graph.
Example 22. For the PST KB K = hA, Fi of Example 15, we obtain the std-graph G shown
in Figure 3(a). The auxiliary graph AG is shown in Figure 3(b). G consists of a single connected component where there is one maximal clique Cl that is not an hid, ti clique, namely
Cl = {loc(id, {p0 }, 0), loc(id, {p0 }, 1), loc(id, {p0 }, 2)}. It is easy to see that G is simple cliquecyclic.
2
The following theorem states that checking the consistency of a PST KB whose std-graph is
simple clique-cyclic can be accomplished by checking whether there is a feasible solution of a set
of linear inequalities.
We start by defining this new linear system: CL(K).
11. There are no loops and no multiple edges between vertices.

769

fiPARISI & G RANT

id
p1

t=0
p2

p0

p1

id1,0

t=1
p2

p0

id1,1
p1

id

t=2

id1,2

p2

p0

(a)

(b)

Figure 3: (a) Std-graph and (b) auxiliary graph for the PST KB of Example 15.
Definition 17 (CL(K)). Let K = hA, Fi be a PST KB such that F consists of binary std-formulas
only. CL(K) consists of the following (in)equalities:
(1) loc(id, r, t)[`, u]  A: ` 

P

vid,t,p  u;

pr

(2) id  ID, t  T :

P

vid,t,p = 1;

pSpace

(3) p  Space, id  ID, t  T : vid,t,p  0;
(4) (a) For each
P acyclic connected component of G (and hence AG), for each edge e of AG:
vid,t,p  1.
loc(id,{p},t)C(e)

(b) For each cyclic connected component
of G (and hence AG), for the maximal clique Cl
P
that is not an hid, ti clique:
vid,t,p  1.
loc(id,{p},t)Cl

The intuition behind the result stated in the following theorem is similar to that given for the
tractable case of Theorem 6. Indeed, if G is simple clique-cyclic and CL(K) has a feasible solution,
then the events corresponding to the st-atoms in each edge e of an acyclic connected component AG,
as well as the events corresponding to the st-atoms in each maximal clique of a connected component of AG, can be arranged in the probability space avoiding overlaps. This basically suffices to
define a model for K.
Theorem 8. Let K = hA, Fi be a PST KB where F consists of binary std-formulas only. If G is
simple clique-cyclic, then K is consistent iff there is a feasible solution of CL(K).
770

fiK NOWLEDGE R EPRESENTATION IN P ROBABILISTIC S PATIO -T EMPORAL K NOWLEDGE BASES

Proof. As explained earlier we will deal only with a single cyclic connected component of G.
() The proof follows by reasoning as in the left-to-right proof of Theorem 6.
() Let  be a solution for CL(K). Obviously,  is alsoP
a solution for CC(K0 ) where K0 =
0
0
0
hA,
P i, and there is a model M for K such that (vid,t,p ) = wW(K0 ),w|=loc(id,{p},t) M (w) and
loc(id,{p},t)Cl (vid,t,p )  1. Given this, we show that starting from  we can define a new model
M for K0 which is also a model for K.
For each hid, ti pair, we define S(id, t) as the subset of Space consisting of points p such that
vid,t,p is assigned a value greater than zero by , i.e., S(id, t) = {p | p  Space, (vid,t,p ) > 0}.
We distinguish between the following two sets of hid, ti pairs: IDT1 (resp. IDT2 ) is the set of
hid, ti pairs for which there is not (resp. there is) a point p in S(id, t) such that loc(id, {p}, t)  Cl.
We separately consider the pairs in IDT1 and IDT2 , and for each hid, ti pair belonging to one of
these sets, define a sequence of points in S(id, t) along with a sequence of cumulative probability
values that will be used to build the model M .
We start with the set IDT1 . Let hidi , ti i, with i  [1..|IDT1 |] be the i-th pair of IDT1 (after
i
ordering the pairs in IDT1 according to any fixed order). Let i = hp1i , . . . , pm
i i be a permutation
of the points in S(idi , tP
i ), and let i (k) be the sum of the values assigned by  to the first k points
in i , that is, i (k) = kj=1 (vidi ,ti ,pj ). Thus, hi (1), . . . , i (mi )i is a sequence of (cumulative)
i

i
probability values associated with the sequence of points hp1i , . . . , pm
i i from the i-th pair of IDT1 .
Now consider the pairs in IDT2 , i.e, those occurring in some st-atom in Cl. Denote with
hidi , ti i, with i  [1..|IDT2 |], the i-th pair of IDT2 (according to any fixed order). For the first
1
pair in IDT2 , let 1 = hp11 , . . . , ph1 1 , ph1 1 +1 , . . . , pm
1 i be a permutation of the points in S(id1 , t1 )
such that the first h1 points p correspond to the variables vid1 ,t1 ,p such that loc(id1 , {p}, t1 )  Cl
1
(consequently, the other points p  {ph1 1 +1 , . . . , pm
1 } correspond to variables vid1 ,t1 ,p such that
loc(id1 , {p}, t1 ) 6 Cl).
i
For each hidi , ti i with i  [2..|IDT2 |], let i = hp1i , . . . , pgi i , pigi +1 , . . . , pigi +hi , pigi +hi +1 , . . . , pm
i i
g
+h
+1
g
m
be a sequence of the points in S(idi , ti ) such that (i) each point p in {p1i , . . . , pi i , pi i i , . . . , pi i }
(resp. p in {pgi i +1 , . . . , pgi i +hi }) corresponds to a variable vidi ,ti ,p such that loc(idi , {p}, ti ) 6 Cl
(resp. loc(idi , {p}, ti )  Cl); and (ii) all the points in the sequence are distinct except for pgi i and
pgi i +hi +1 that may refer to the same point in S(idi , ti ). Denoting as i (k) the sum of the values
P
assigned by  to the first k points in i (i.e., i (k) = kj=1 (vidi ,ti ,pj )), we choose the sequences
i
2 , . . . , |IDT2 | such that, for each i  [2..|IDT2 |], i (gi ) = i1 (gi1 +hi1 ) (assume that g1 = 0).
Note that we can make such a choice since the following holds:

|IDT2 | hi
X X

|IDT2 |

(vidi ,ti ,pk ) =

X

i

i=1 k=1

|IDT2 |

i (gi + hi )  i (gi ) =

i=1

X

X

(vidi ,ti ,p )  1.

i=1 loc(idi ,{p},ti )Cl

The way the sequences h1 , . . . , |IDT2 | i and hi (1), . . . , i (mi )i are defined will allow us to build
a model M for K0 such that no world which is assigned a probability greater than zero satisfies two
distinct st-atoms in Cl. This will ensure that M is a model for K too.
We now
S define such a model M . LetSV = hv1 , v2 , . . . , vz i be the sequence consisting of the
values in iIDT1 {i (1), . . . , i (mi )}  iIDT2 {i (1), . . . , i (mi )} ordered in ascending order.
We define the following z non-zero probability worlds for K0 (note that a world for K0 is also a
world for K). For each vj  V , let wj be a world such that:
771

fiPARISI & G RANT

 for each hidi , ti i  IDT1 , we define wj (idi , ti ) = pki , where pki is the left-most value in
hi (1), . . . , i (mi )i such that i (k)  vj .
 for each hidi , ti i  IDT2 , we define wj (idi , ti ) = pki , where pki is the left-most value in
hi (1), . . . , i (mi )i such that i (k)  vj .
Finally, we define M as the PDF over W(K0 ) such that (i) M (w1 ) = v1 , (ii) M (wj ) = vj  vj1
for each j  [1..z], and (iii) M (w) = 0 for all the other worlds w  W(K0 ). It is easy to check
0
0
that M is a model
P for K that corresponds to the same solution  for CC(K ), that is, M is such that
(vid,t,p ) = wW(K0 ),w|=loc(id,{p},t) M (w). Moreover, as the construction shown above ensures
that no non-zero probability world for K0 satisfies two distinct st-atoms in Cl, it follows that M is a
model for K.
Theorem 8 can be used, for instance, to decide if the PST KB of Example 15 is consistent.
Example 23. For the PST KB K = hA, Fi of Example 15, CL(K) is the linear system obtained
from CC(hA, i) by augmenting it with the inequality vid,0,p0 + vid,1,p0 + vid,2,p0  1. Since CL(K)
also contains the inequality 0.5  vid,t,p0 for each t  [0..2] (due to the presence of the PST atom
loc(id, {p0 }, t)[0.5, 1] in A), it follows that CL(K) has no feasible solution, from which we conclude
that K is not consistent (here G is the clique-cyclic std-graph shown in Figure 3(a)).
2
We conclude the section with the following theorem stating that checking consistency for the
PST KBs identified in Section 3.5 is tractable.
Theorem 9. Let K = hA, Fi be a PST KB where F consists of binary std-formulas only. If G is
clique-acyclic or simple clique-cyclic, then checking the consistency of K is in P T IM E.
Proof. If G consists of one connected component, the statement follows from the facts that building
G, as well as checking whether G is acyclic (resp. simple clique-cyclic), can be accomplished in
polynomial time w.r.t. the size of K and checking whether there is a feasible solution of BC(K)
(resp., CL(K)) is polynomial too. If G consists of more than one connected component, the statement follows from the facts that finding all connected components of G can be done in polynomial
time, and, using Proposition 3, we only need to check the consistency of the PST KBs corresponding to each of the connected components in order to decide the consistency of the whole PST
KB.

4. Querying PST Knowledge Bases
This section investigates the complexity of checking answer to queries. Section 4.1 contains the
basic definitions. Section 4.2 contains the major result about the complexity of checking answers
to queries. Finally, Section 4.3 gives sufficient and necessary conditions for answering queries and
tractable cases.
4.1 Optimistic and Cautious Answers
The problem of querying SPOT data has been investigated by Parker et al. (2007a, 2009), Parisi,
Parker, Grant, and Subrahmanian (2010), and Grant, Molinaro, and Parisi (2013) in more specific
772

fiK NOWLEDGE R EPRESENTATION IN P ROBABILISTIC S PATIO -T EMPORAL K NOWLEDGE BASES

frameworks corresponding to PST KBs (of the form hA, i), where only PST atoms were considered. In this section, we address the problem of answering selection queries in general (consistent) PST KBs. These kinds of queries were considered by Parker et al. (2007a, 2009), and Parisi
et al. (2010), while Grant et al. (2013) focused on count queries.
A selection query is an expression of the form (?id, q, ?t, [`, u]), where q is a region and [`, u] is
a probability interval. Intuitively, a selection query says: Given a region q and a probability interval
[`, u], find all objects id and times t such that id is inside q at time t with a probability in the interval
[`, u]. There are two semantics for interpreting this statement, leading to two types of answers to
selection queries. Optimistic answers are objects and time values that may be in the query region
with probability in the specified interval, whereas cautious answers consist only of those objects
and time values that are guaranteed to be in that region with probability in the given interval. Thus,
the cautious answers are a subset of the optimistic ones.
The following definition extends the original definition of optimistic and cautious selection
query answers to the general case of consistent PST knowledge bases.
Definition 18 (Optimistic/Cautious Query Answers). Let K be a consistent PST KB, and Q =
(?id, q, ?t, [`, u]) a selection query. Then,
 hid, ti
Pis an optimistic answer to Q w.r.t. K iff there exists a model M  M(K) s.t.
M (w)  [`, u].
w|=loc(id,q,t)

 hid, ti
Pis a cautious answer to Q w.r.t. K iff for every model M  M(K),
M (w)  [`, u].
w|=loc(id,q,t)

Example 24. Let q1 = {(7, 3), (7, 4)} (q1 overlaps with region c, see Figure 1). Model M of
Example 9 entails that hid1 , 9i is an optimistic answer to Q = (?id, q1 , ?t, [.7, 1]), as w1 (id1 , 9) =
w2 (id1 , 9) = w3 (id1 , 9) = (7, 4)  q1 and M (w1 ) + M (w2 ) + M (w3 ) = 1  [.7, 1].
Let q2 be any region including region c. hid1 , 9i is a cautious answer to Q0 = (?id, q2 , ?t, [.7, 1]), as
according to any model for Kex , id1 must be in region c (and thus in q2 ) at time 9 with probability
in [.9, 1] (due to loc(id1 , c, 9)[.9, 1]  Aex ). Clearly, hid1 , 9i is also an optimistic answer to Q0 . 2
4.2 Complexity of Query Answering
The following theorem shows how consistency checking can be used to answer selection queries
under both the optimistic and the cautious semantics.
Theorem 10. Let K = hA, Fi be a consistent PST KB, and Q = (?id, q, ?t, [`, u]). Then,
1) hid, ti is an optimistic answer to Q w.r.t. K iff hA  {loc(id, q, t)[`, u]}, Fi is consistent.
2) hid, ti is a cautious answer to Q w.r.t. K iff both hA  {loc(id, q, t)[0, ` ]}, Fi and hA 
{loc(id, q, t)[u + , 1]}, Fi are not consistent, where  is the smallest rational number with
precision m3 , where m = |A| + |F|  |ID|  |T |  |Space| + |ID|  |T | + |ID|  |T |  |Space|.
Proof. Statement 1) easily follows from Definitions 6 and 18.
Statement 2) follows from the fact that hid, ti is a cautious answer to Q w.r.t. K iff i) hid, ti is
not an optimistic answer to Q0 = (?id, q, ?t, [0, ` ]) w.r.t. K, and ii) hid, ti is not an optimistic
773

fiPARISI & G RANT

answer to Q00 = (?id, q, ?t, [u + , 1]) w.r.t. K, where  is a small non-zero constant whose size
is polynomial w.r.t. the size of K. To show the existence of , we observe that (i) checking the
consistency of K can be reduced to deciding the PSAT instance K consisting of m clauses, where
m = |A| + |F|  |ID|  |T |  |Space| + |ID|  |T | + |ID|  |T |  |Space|, as shown in the membership
proof of Theorem 1; and (ii) if a satisfying probability distribution for an instance of PSAT with
m clauses exists, then there is one with at most m + 1 non-zero probabilities, and with entries
consisting of rational numbers with precision O(m2 ) (Georgakopoulos et al., 1988; Papadimitriou
& Steiglitz, 1982); Then, choosing  equal to the smallest rational number with precision m3 suffices
to obtain a sufficiently small non-zero constant, whose size is polynomial w.r.t. the size of K,
such that hA  {loc(id, q, t)[0, ` ]}, Fi (resp., hA  {loc(id, q, t)[u + , 1]}, Fi) is consistent iff
hA  {loc(id, q, t)[0, ` ]}, Fi (resp., hA  {loc(id, q, t)[u + , 1]}, Fi) is consistent, where  is
an infinitely small value greater than zero.
The following corollary follows from Theorems 1 and 10.
Corollary 1. Let K = hA, Fi be a consistent PST KB. Given a query Q = (?id, q, ?t, [`, u]), then
1) deciding whether hid, ti is an optimistic answer to Q w.r.t. K is in NP.
2) deciding whether hid, ti is a cautious answer to Q w.r.t. K is coNP.
The problem of deciding whether a pair hid, ti is an optimistic/cautious answer to a selection
query Q can be solved in polynomial time for PST KBs whose F component is empty (Parker et al.,
2007a, 2009; Parisi et al., 2010). However, in the presence of integrity constraints this problem
becomes hard.
Theorem 11. Let K = hA, Fi be a consistent PST KB. Given a query Q = (?id, q, ?t, [`, u]), then
1) deciding whether hid, ti is an optimistic answer to Q w.r.t. K is NP-hard.
2) deciding whether hid, ti is a cautious answer to Q w.r.t. K is coNP-hard.
Proof. We first prove item 1). We show a reduction to our problem from the NP-hard Hamiltonian
path problem (Papadimitriou, 1994). Given a directed graph G = hV, Ei, where V = {v0 , . . . , vk }
is the set of k +1 vertexes of G and E is the set of its edges, we construct an instance of our problem
as follows. Let ID = {id}, Space = V  {p0 , . . . , pk1 }  {pT , pF }, and T = [0, . . . , 2k + 1].
K is the pair hA, Fi such that A consist of the PST atom loc(id, v0 , 0)[1, 1] and F consists of the
following formulas:
 i  [0..k  1], f1i = Z1 , Z2 [loc(id, {vi }, Z1 )  loc(id, Space \ V 0 , Z2 )  Z2 = Z1 + 1]
where V 0 = {vj |(vi , vj )  E}{pi , pT , pF }. That is, the locations id can reach starting from
vi in one time step are only the locations vj s.t. (vi , vj )  E or any point in {pi , pT , pF }.
 f1k = Z1 , Z2 [loc(id, {vk }, Z1 )  loc(id, Space \ V 00 , Z2 )  Z2 = Z1 + 1] where V 00 =
{vj |(vk , vj )  E}  {pT , pF }. This formula says that the locations id can reach starting from
vk in one time step are only locations vj such that (vk , vj )  E or those in {pT , pF }.
 i  [0..k1], f2i = Z1 , Z2 [loc(id, {pi }, Z1 )loc(id, Space\{vi+1 }, Z2 )Z2 = Z1 +1],
saying that the only location id can reach starting from pi in one time step is vi+1 .
774

fiK NOWLEDGE R EPRESENTATION IN P ROBABILISTIC S PATIO -T EMPORAL K NOWLEDGE BASES

 f3 = Y1 , Z1 , Z2 [loc(id, Y1 , Z1 )  loc(id, Y1 , Z2 )  Z1 6= Z2  Y1 6= {pT }  Y1 6= {pF }],
saying that id can not be on the same location at distinct time values, if the location is different
from both pT and pF .
 f4 = Z1 , Z2 [loc(id, {p0 , . . . , pk1 }, Z1 )  loc(id, {pT }, Z2 )], saying that id can not be at
pT if is was/is/will be at a location in {p0 , . . . , pk1 }.
 f5 = Y2 , Z1 , Z2 [loc(id, {pT }, Z1 )  loc(id, Y2 , Z2 )  Y2 6= {pT }  Z1 < Z2 ], saying that
id can not go away from pT after reaching this location.
 f6 = Y2 , Z1 , Z2 [loc(id, {pF }, Z1 )  loc(id, Y2 , Z2 )  Y2 6= {pF }  Z1 < Z2 ], saying that
id can not go away from pF after reaching this location.
Finally, let Q = (?id, {pT }, ?t, [1, 1]), and let the pair to be checked as an the optimistic answer of
Q be hid, 2k + 1i.
First of all, observe that M(K) 6= . In fact, consider the world w  W(K) such that w(id, 0) =
v0 , w(id, 1) = p0 , w(id, 2) = v1 , w(id, 3) = p1 , . . . , w(id, t) = vt/2 , w(id, t + 1) = pt/2+1 , (in
both cases t is even) . . . , w(id, 2k2) = vk1 , w(id, 2k1) = pk , w(id, 2k) = vk , w(id, 2k+1) =
pF . It is easy to see that w |= F. In fact, for each t  [0..2k], id moves towards reachable locations
in one time point: if id is at vi , with i  [0..k  1], it moves to pi (that is, f1i is satisfied by w); if
id is at pi , with i  [0..k  1], it moves to vi+1 (that is, f2i is satisfied by w); and when is at vk it
moves to pF (that is, f1k is satisfied by w). Moreover, id is not placed by w on the same location at
different times (that is, f3 is satisfied), neither at both a location in {p1 , . . . , pk1 } and at pT (that
is, f4 is satisfied too). Moreover, id does not move from pF after reaching this location (that is, f6
is satisfied), and does not reach location pT (thus, also f5 is satisfied by w). Now, consider the PDF
I over W(K) assigning probability equal to 1 to w, and probability equal to 0 to every other world
in W(K). Clearly, I is a model for K: it assigns non-zero probability only to worlds satisfying F,
and it ensures that atom loc(id, v0 , 0)[1, 1] is satisfied by w which is assigned probability equal to
1.
We now show that hid, 2k + 1i is an optimistic answer to Q w.r.t. K iff there is a Hamiltonian
path in G.
()
P As hid, 2k + 1i is an optimistic answer to Q w.r.t. K, there is a model M  M(K) s.t.
(w) = 1. Let W  W(K) be the set of worldsP
w such that w(id, 2k + 1) =
w|w|=loc(id,pT ,2k+1) M P
pT and M (w) > 0. As wW M (w) = 1 and M is a model (thus, w|w|=loc(id,v0 ,0) M (w) = 1
due to loc(id, v0 , 0)[1, 1])  A), it follows that every world w  W is such that w(id, 0) = v0 .
Moreover, since M is a model, and thus f4 is satisfied by every world w  W , it holds that
t  [0..2k + 1], w(id, t) 6 {p0 , . . . , pk  1}, meaning that id is never placed at a location in
{p0 , . . . , pk1 } by w. Moreover, since for each w  W , w(id, 0) = v0 , and since f1i and f2i
(with i  [1..k]), and f3 are satisfied by every world in W , it follows that (i) for each t  [0, k],
w(id, t)  V (i.e., id is placed on a vertex of G at each time point in [0, k]), and (ii) for each
t, t0  [0, k], w(id, t) 6= w(id, t0 ) (id is not placed on the same vertex of G at different times in
[0, k]). Given this, at time t = k + 1, f1k and f3 entail that id is placed by any world in W at location
pT or pF . As f5 (resp., f6 ) entails that id can not go away from pT (resp., pF ) after reaching this
location, and since w(id, 2k + 1) = pT , it follows that every world w  W is such that for each
t  [k + 1, 2k + 1], w(id, t) = pT . Hence, each w  W is such that M (w) > 0, w(id, 0) = v0 ,
t  [1, k], w(id, t)  V , t, t0  [0, k], w(id, t) 6= w(id, t0 ), t  [k + 1, 2k + 1], w(id, t) = pT .
Therefore, w(id, 0), w(id, 1), . . . , w(id, k) is a Hamiltonian path of G.
775

fiPARISI & G RANT

() Let  be a Hamiltonian path of G. We denote as [i] (with i  [0..k]) the i-th vertex of
. W.l.o.g. we assume that the first
Pvertex of  is v0 , that is, [0] = v0 . We show that there
is a model M  M(K) such that w|w|=loc(id,pT ,2k+1) M (w) = 1, that is, hid, 2k + 1i is an
optimistic answer to Q w.r.t. K. Let M be a function over W such that for all worlds w  W,
M (w) = 0 except for the world w which is such that: w (id, 0) = [0] = v0 , t  [1, k],
w (id, t) = [t], t  [k + 1, 2k + 1], w (id, t) = pT . It is easy to see that w |= F. In fact, for
each i  [1..k], f1i as well as f2i are satisfied by w , since the fact that  is a path on G entails that
t  [0, k  1], w (id, t) = vi and w (id, t + 1) = vj only if edge (vi , vj ) is an edge of G and
w (id, k + 1) = pT which is reachable from any location in V . Moreover, f3 is satisfied by w ,
since the fact that  is a Hamiltonian path entails that w places id on different locations at different
times, except for location pT . Formula f4 is satisfied by w , since w does not place id at any
location in {p0 , . . . , pk1 }. Formula f5 is satisfied by w , since w does not place id on a location
different from pT after time point k + 1, when id reaches pT . Finally, f6 is satisfied by w as well,
since w does not place id on location pF . Since wP|= F, it can be assigned by M a probability
different from 0. Let M (w ) = 1. Moreover, as w|w|=loc(id,v0 ,0) M (w) = M (w ) = 1, the
condition required by loc(id, v0 , 0)[1, 1]  A holds too, proving that M is model for K.
We now prove item 2). We show a reduction to our problem from the complement of the
Hamiltonian path problem. Given a directed graph G, we construct an instance of our problem
as in the proof of 1), except that Q = (?id, {pT }, ?t, [0, 1  ]), where  > 0 is as stated in
Theorem 10. As shown in the proof of 1), K is consistent. Moreover, there is no Hamiltonian
path in G iff the pair hid, 2k + 1i is not an the optimistic answer to Q0 = (?id, {pT }, ?t, [1, 1]).
Now observe that hid, 2k + 1i is not an the optimistic answer to Q0 iff hid, 2k + 1i is a cautious
answer to Q = (?id, {pT }, ?t, [0, 1  ]) for  > 0 sufficiently small. By reasoning as in the
proof of Theorem 10, we can choose
P = , which ensures that if there is an M  M(K) such that
P
M
(w)
<
1,
then
w|w|=loc(id,pT ,t) M (w)  1  .
w|w|=loc(id,pT ,t)

Our query answering problem is related to the decision version of the entailment problem in
probabilistic logic (Nilsson, 1986; Georgakopoulos et al., 1988), which is as follows. Given a conjunction  of clauses, each of them associated with a probability, and an additional clause C with
given lower and upper bounds on the admissible values for its probability, decide whether there is
a probability distribution satisfying the probability of all the clauses in  and the lower and upper
bounds for C. As in probabilistic logic, where the entailment problem can be reduced to PSAT (Nilsson, 1986; Georgakopoulos et al., 1988), we have shown that the query answering problem in PST
KBs can be reduced to the consistency checking problem. However, there is an important difference
between the query answering problem and the probabilistic entailment problem: we assume that the
input PST KBs is consistent, while the entailment problem is defined for any  (even if  is not
satisfiable). As a consequence, the coNP-hardness of the probabilistic entailment problem straightforwardly follows from the NP-hardness of PSAT ( is unsatisfiable iff any contradiction C with
any lower and upper bounds is entailed by ). That is, satisfiability is a source of complexity for the
probabilistic entailment problem. However, in our setting, we are given a consistent PST KB and
thus checking the consistency cannot be a source of complexity for the query answering problem. In
fact, Theorem 11 can be viewed as strengthening the coNP-hardness of the probabilistic entailment
problem, as it is proved in a more specific setting corresponding to the case where the input formula
 is known to be satisfiable.
776

fiK NOWLEDGE R EPRESENTATION IN P ROBABILISTIC S PATIO -T EMPORAL K NOWLEDGE BASES

4.3 Sets of Linear Inequalities for Answering Queries
The following corollary of Theorems 2 and 10 states that the set of mixed-binary linear inequalities
MBL() introduced in Definition 8 can be also exploited for answering queries.
Corollary 2. Let K = hA, Fi be a consistent PST KB, and Q = (?id, q, ?t, [`, u]) a query. Then,
1) if there is a feasible solution of MBL(hA{loc(id, q, t)[`, u]}, Fi), then hid, ti is an optimistic
answer to Q w.r.t. K.
2) if MBL(hA  {loc(id, q, t)[0, `  ]}, Fi) or MBL(hA  {loc(id, q, t)[u + , 1]}, Fi) has a
feasible solution, then hid, ti is not a cautious answer to Q w.r.t. K (where  is as given in
Theorem 10).
Similarly, from Theorems 3 and 10 the following corollary follows, stating that the linear system
NC() introduced in Definition 9 can be also used for answering queries.
Corollary 3. Let K = hA, Fi be a consistent PST KB, and Q = (?id, q, ?t, [`, u]) a query. Then,
1) if there is no feasible solution of NC(hA  {loc(id, q, t)[`, u]}, Fi), then hid, ti is not an
optimistic answer to Q w.r.t. K.
2) if both NC(hA  {loc(id, q, t)[0, ` ]}, Fi) and NC(hA  {loc(id, q, t)[u + , 1]}, Fi) have
no feasible solution, then hid, ti is a cautious answer to Q w.r.t. K (where  is as given in
Theorem 10).
Moreover, we obtain the following corollary of Theorems 4 and 10.

Corollary 4. Let K = hA, Fi be a consistent PST KB where F = { loc(id1 , {p1 }, t1 ) 
loc(id2 , {p2 }, t2 )      loc(idn , {pn }, tn )]}, and Q = (?id, q, ?t, [`, u]) be a query. Then,
1) hid, ti is an optimistic answer to Q w.r.t. K iff there is a feasible solution of NC(hA 
{loc(id, q, t)[`, u]}, Fi).
2) hid, ti is a cautious answer to Q w.r.t. K iff both NC(hA  {loc(id, q, t)[0, ` ]}, Fi) and
NC(hA  {loc(id, q, t)[u + , 1]}, Fi) have no feasible solution, where  is as given in Theorem 10.
From Theorems 6 and 10 we obtain the following result.
Corollary 5. Let K = hA, Fi be a consistent PST KB where F consists of binary std-formulas
only, and Q = (?id, q, ?t, [`, u]) be a query. If AG is acyclic, then
1) hid, ti is an optimistic answer to Q w.r.t. K iff there is a feasible solution of BC(hA 
{loc(id, q, t)[`, u]}, Fi).
2) hid, ti is a cautious answer to Q w.r.t. K iff both BC(hA  {loc(id, q, t)[0, ` ]}, Fi) and
BC(hA  {loc(id, q, t)[u + , 1]}, Fi) have no feasible solution, where  is as given in Theorem 10.
Moreover, the results of Theorem 7, where the shape of the auxiliary graph is not considered,
and Theorem 10 entail the following.
777

fiPARISI & G RANT

Corollary 6. Let K = hA, Fi be a consistent PST KB where F consists of binary std-formulas
only, and Q = (?id, q, ?t, [`, u]) be a query. Then
1) if there is no feasible solution of BC(hA  {loc(id, q, t)[`, u]}, Fi), then hid, ti is not an
optimistic answer to Q w.r.t. K
2) if both BC(hA  {loc(id, q, t)[0, ` ]}, Fi) and BC(hA  {loc(id, q, t)[u + , 1]}, Fi) have
no feasible solution, then hid, ti is a cautious answer to Q w.r.t. K (where  is as given in
Theorem 10).
Still, from Theorems 8 and 10 we obtain the following corollary.
Corollary 7. Let K = hA, Fi be a consistent PST KB where F consists of binary std-formulas
only, and Q = (?id, q, ?t, [`, u]) be a query. If AG is simple-clique cyclic, then
1) hid, ti is an optimistic answer to Q w.r.t. K iff there is a feasible solution of CL(hA 
{loc(id, q, t)[`, u]}, Fi).
2) hid, ti is a cautious answer to Q w.r.t. K iff both CL(hA  {loc(id, q, t)[0, ` ]}, Fi) and
CL(hA  {loc(id, q, t)[u + , 1]}, Fi) have no feasible solution, where  is as given in Theorem 10.
Finally, we state the following corollary of Theorems 9 and 10 concerning cases where computing selection queries is tractable. Although the result is stated assuming that only binary stdformulas are in the PST KB, it holds for the more general case where both unary and binary stdformulas are in the PST KB since, using the approach suggested in the proof of Theorem 5, we can
assume that unary std-formulas are encoded as PST atoms.
Corollary 8. Let K = hA, Fi be a PST KB where F consists of binary std-formulas only. If
G is clique-acyclic or simple clique-cyclic, then deciding whether hid, ti is an optimistic/cautious
answer to selection query Q = (?id, q, ?t, [`, u]) is in PTIME.

5. Domain Enlargement
Up to this point we have assumed that the three domains ID = {id1 , . . . , idm }, T = [0, 1, . . . ,
tmax], and Space = {p1 , . . . , pn } are fixed. In this context we have investigated the consistency
of a PST KB. In this section we investigate what happens to a PST KB if one or more domains
are modified. The modification consists of possibly adding new time values, or spatial points, or
objects. In fact, we are interested in what happens as we add arbitrarily many (but a finite number
of) entities. In Section 5.1 we consider the case where we deal with a longer time period and add
additional time values beyond tmax. In Section 5.2 we again deal with time but in this case we
allow for a finer division of time values. Section 5.3 deals with the case where Space is enlarged,
that is, new points are added. Finally, in Section 5.4 we deal both with additional objects as well as
combinations of domain enlargement.
5.1 Extending Time Beyond tmax
We start with a PST KB K using ID, T , and Space. Suppose now that we extend T beyond tmax;
we write T 0 = [0, 1, . . . , tmax, . . . , t0 ]. This means that the syntax must also be extended with the
778

fiK NOWLEDGE R EPRESENTATION IN P ROBABILISTIC S PATIO -T EMPORAL K NOWLEDGE BASES

constants tmax + 1, . . . , t0 ; however, K does not use any of the new constants. But the semantics is
different now because each world w0 must be a function w0 : ID  T 0  Space. We write W for
the set of worlds using T and W 0 for the set of worlds using T 0 . The connection between W and
W 0 is that every w  W can be extended to many worlds in W 0 by choosing a point in Space for
each new time value for each object. But from any one world w0  W 0 there is a unique restriction
to a world in W . Satisfaction for the worlds in W 0 is defined in the same way as satisfaction for the
worlds in W (with W 0 substituted for W ).
Our interest in the semantics is due to the concept of interpretation where an interpretation
assigns each world a probability. Let W = {w1 , . . . , wz } where z = nm(tmax+1) and let W 0 =
0
{w10 , . . . , wy0 } where y = nm(t +1) . For every wi  W , we define the set of worlds Wi0 =
{wj0 |wj0  W 0 and wj0 is an extension of wi }. This means that the restriction of every wj0  Wi0 is
wi . Next, letPI1 be an interpretation on W . We call an interpretation I10 an extension of I1 if for all i,
1  i  z, w0 W 0 I10 (w0 ) = I1 (wi ). That is, the probability value of I1 (wi ) is distributed among
i
the extensions of wi for each i. We can also go in the other direction. If I20 is an interpretation
on
P
0
0
W , we define its restriction to W , I2 , by using the same formula, that is, I2 (wi ) = w0 W 0 I2 (w0 )
i
for all i, 1  i  z.
This framework allows us to investigate what happens to the consistency and inconsistency of
K as we go from T to T 0 . We start with inconsistency. We state the next theorem in two different
forms because both are useful in various contexts.
Theorem 12. Let K contain only time values in T .
a) If K is inconsistent with time T , then K remains inconsistent if T is expanded to T 0 .
b) If T 0 is an expansion of T and K is consistent with T 0 then it is consistent with T .
Proof. As the second part is the contrapositive of the first, it suffices to prove just one part. We
prove the second one. So assume that K, which uses only time values in T , is consistent when T
is expanded to T 0 . This means that there is an interpretation M 0 for K (using W 0 ) that is a model
of K. WeP
obtain an interpretation M (for W ) from M 0 using the formula given above, that is,
M (wi ) = w0 W 0 M 0 (w0 ) for all i, 1  i  z. We need to show that M is a model of K.
i
Consider first the atomic formulas in
wi , wi |= loc(id, r, t) iff w0 |=
PA. Clearly, for any worldP
0
0
0
0
loc(id, r, t) for all w  Wi . Hence, w|w|=loc(id,r,t) M (w) =
w0 |w0 |=loc(id,r,t) M (w ). This
takes care of A.
P
P
Next, let f  F. Then w0 |w0 6|=f M 0 (w0 ) = 0. We need to show that also w|w6|=f M (w) = 0.
Let wi  W be a world such that wi 6|= f . This means that there is a substitution  using only time
values in T such that wi 6|= (f ). But  remains a substitutionPwhen T 0 is used for time. So for all
wj0  Wi0 , wj0 6|= (f ). As M 0 is a model of K and hence F, w0 |w0 6|=f M 0 (w0 ) = 0 and the result
follows from the definition of M .
Next we consider the case where a PST KB defined using T is consistent. It turns out that
consistency need not be preserved when T is expanded to T 0 . Consider the case of the following
single integrity constraint:
X1 X2 Y1 Z1 [loc(X1 , Y1 , Z1 )  loc(X2 , Y1 , Z1 )  X1 6= X2  tmax < Z1 ] and suppose that
|ID| > |Space|. The std-formula states that two different objects cannot be in the same location
after time tmax. The condition tmax < Z1 is false for all substitutions for Z1 ; hence the integrity
constraint is automatically true. But once T is enlarged to any T 0 (> T ), say t0 = tmax + 1, there is
779

fiPARISI & G RANT

an inconsistency because there are not enough points in Space for all the objects to occupy distinct
points. We now show that for a given consistent K we can always extend T = [0, . . . , tmax] to
T big = [0, . . . , tmax, . . . , tbig] such that if K is consistent with T big then K remains consistent for
any T 0 with T 0 = [0, . . . , tmax, . . . , t0 ]. Essentially, we must make sure that for every time variable
there is a substitution that makes each conjunct true in each f . For example, if the previous example
is modified to
X1 X2 Y1 Z1 Z2 [loc(X1 , Y1 , Z1 )  loc(X2 , Y1 , Z2 )  X1 6= X2  tmax < Z1  Z2 = Z1 + 4] then
we must have enough time values to include tmax + 5. We show how to do this systematically in
the proof of the next theorem.
Theorem 13. For a consistent PST KB K defined with time values T = [0, . . . , tmax], there is always a finite time value tbig  tmax that can be computed in linear time, such that if K is consistent
using T big = [0, . . . , tmax, . . . , tbig] then K is consistent for all T 0 = [0, . . . , tmax, . . . , t0 ].
Proof. We obtain a time value tf for each integrity constraint f  F. For each f we initialize
tf = tmax + 1. If f contains at most one time variable Z then we are done for f . So suppose that f
has at least one conjunct with two distinct time variables. That must have one of the following four
forms (where any +0 is omitted): 1) Zi + m = Zj + n, 2) Zi + m 6= Zj + n, 3) Zi + m < Zj + n,
or 4) Zi + m  Zj + n. The process involves adding a certain number to tf for each such conjunct.
For type 1) add |m  n|, for type 2) add 1, for type 3) add max(0, m  n + 1), and for type 4) add
max(0, n  m). Then, by adding all the numbers for such conjuncts we obtain a tf value for each
f  F. Let tbig = maxf F {tf }. This process is linear in the size of F.
We must show that if K is consistent for T big then it is consistent for any T 0 = [0, . . . , tmax,
. . . , t0 ]. If t0  tbig then consistency follows from Theorem 12b). So assume that tbig  t0 and
K is consistent for T big . This means that there is an interpretation M big that is a model for K.
Just as in the proof of Theorem 12, the issue concerns only the constraints in F. We write W big
for
all worlds using T big and write wb for an arbitrary world in W big . For any f  F,
P the set of big
M (wb ) = 0. We obtain M 0 from M big in an arbitrary way as long as the formula
b
b
Pw |w 6|=f 0 0
(w ) = M big (wib ) is satisfied. To show that M 0 is a model for K with T 0 , we need to
w0 Wi0 M
P
show that w0 |w0 6|=f M (w0 ) = 0. So let wi0  W 0 be such that wi0 6|= f . Then there is a substitution
0 such that wi0 6|= 0 (f ). This 0 may include any time values in T 0 . But our construction assures
that there is already a substitution b using only values in T big so that the world wib which is the
restriction of wi0 to T big is such that wib 6|= b (f ). Hence M 0 is a model for K with T 0 .
These results allow us to consider the case of arbitrarily large (finite) time.
Definition 19. We call K eventually consistent (resp. inconsistent) for time if there is an integer
L such that K is consistent (resp. inconsistent) for all T  = [0, . . . , L, . . . , ].
Corollary 9. Every K is either eventually consistent for time or eventually inconsistent for time.
Proof. If K is inconsistent with time T then by Theorem 12a) it is eventually inconsistent for time.
If K is consistent with time T then there are two cases. If K is still consistent with time T big
as computed in the proof of Theorem 13 then it is eventually consistent for time. Otherwise we
conclude from Theorem 12a) that it is eventually inconsistent for time.
Consider now how our results can be used for query answering when we expand time from
T = [0, . . . , tmax] to T 0 = [0, . . . , tmax, . . . , t0 ]. In order to avoid confusion we write K where
780

fiK NOWLEDGE R EPRESENTATION IN P ROBABILISTIC S PATIO -T EMPORAL K NOWLEDGE BASES

the time is T and K0 when the time is T 0 . First, if K is inconsistent, according to Theorem 12a),
K0 is also inconsistent. So consider the case where K is consistent (recall that queries are evaluated
on consistent PST KBs). Note that when we check if the pair hid, ti is an answer to Q with the
expansion of T to T 0 , this considers also time values t where tmax < t  t0 . Using Theorem 10
we obtain:
 hid, ti is an optimistic answer to Q w.r.t. K0 iff hA  {loc(id, q, t)[`, u]}, Fi is consistent
using T 0 . We do not need to check separately that K0 is consistent because K0  hA 
{loc(id, q, t)[`, u]}, Fi.
 But to check for a cautious answer, we first check that K0 is consistent, and if so, then
hid, ti is a cautious answer to Q w.r.t. K0 iff hA  {loc(id, q, t)[0, `  ]}, Fi and hA 
{loc(id, q, t)[u + , 1]}, Fi are not consistent using T 0 , where  is as given in Theorem 10.
In a similar vein, Theorem 11 carries over also to the case of extended time.
5.2 Extending Time by More Frequent Time Values
In the second type of time extension we consider more frequent time values, so that there are more
than tmax + 1 time values between 0 and tmax. For illustration, we will use T 0 = [0, 0.5, 1, 1.5,
. . . , tmax]. Again, the syntax must be changed as well to include the new constants 0.5, 1.5, and
so on; however, the original K is defined using T = [0, 1, . . . , tmax] and does not contain any new
constant. The situation for worlds is similar to what happened in the previous subsection: every
w : ID  T  Space is a unique restriction of many worlds, ws, w0 : ID  T 0  Space. Also,
satisfaction for the worlds in W 0 using T 0 is defined the same way as for the worlds in W using T .
Our first result is the same for this type of time extension as for the previous one.
Theorem 14. Let K contain only time values in T .
a) If K is inconsistent with time T , then K remains inconsistent if T is expanded to T 0 .
b) If T 0 is an expansion of T and K is consistent with T 0 then it is consistent with T .
Proof. Analogous to the proof of Theorem 12.
Next we consider the case where K is consistent (using T ). Again, consistency need not be
preserved in going from T to T 0 . Consider the case of the following std-formula:
Y1 Z1 [loc(id1 , Y1 , Z1 )  Z1 > 0  Z1 < 1).
This formula states that id1 cannot be at any location between 0 and 1. The condition 0 < Z1 Z1 <
1 is false for all substitutions in T , hence the integrity constraint is true. But if we expand to T 0 then
the substitution of 0.5 for Z1 makes the formula state that id1 cannot be at any location at time 0.5,
making it inconsistent. However, we can extend T to more frequent time values T f r such that if K
is consistent for T f r then it will be consistent for any subdivision of the original time values.
Theorem 15. For a consistent PST KB K defined with time values T = [0, . . . , tmax], there is
always an integer value  that can be computed in linear time, such that if K is consistent using
T f r = [0, 1 , 2 , . . . , 1, +1
 , . . . , tmax] then K remains consistent for every subdivision of T .
781

fiPARISI & G RANT

Proof. The proof is analogous to the proof of Theorem 13. We calculate an integer f for each
integrity constraint f  F and let  = maxf F {f }. The idea is to make sure that there are
enough time values to allow any (Z) that can become true by some subdivision of time intervals
to become true by substitution. In the worst case every time variable may require a new subdivision
of the time values. Hence we can choose f = 2k where k is the number of time variables in f .
The rest of the proof is analogous to the proof of Theorem 13.
As in the previous section where we wanted to consider arbitrarily large time values, now we
consider dividing time intervals arbitrarily many times.
Definition 20. We call K divisionally consistent (resp. inconsistent) for time if there is an integer
L such that K is consistent (resp. inconsistent) for all T = [0, 1 , 2 , . . . , tmax] where  > L.
Corollary 10. Every K is either divisionally consistent for time or divisionally inconsistent for time.
Proof. Analogous to the proof of Corollary 9.
Results analogous to the time expansion done in Section 5.1 hold here also for query answering
and complexity.
5.3 Space Enlargement
In this subsection we consider what happens to the consistency or inconsistency of K if Space
is enlarged, say from Space = {p1 , . . . , pn } to Space0 = {p1 , . . . , pn , . . . , pv }. The change in
semantics is different in this case than when we expanded T . If w : ID  T  Space is a world
(for Space), it remains a world for Space0 . So writing W for the set of worlds using Space and
W 0 for the set of worlds using Space0 , we obtain W  W 0 . There is no change in the definition of
satisfaction, but the number of interpretations becomes greatly enlarged. Still, every interpretation
I using Space can be extended to a unique I 0 using Space0 by assigning I 0 (w0 ) = 0 for all w0 
W0 \ W.
As in the case of time, we start with the case where K is inconsistent. But unlike for time, when
Space is enlarged K may become consistent. Consider the simple example where K consists of a
single atom: a = loc(id1 , {p1 , . . . , pn }, 1)[.2, .7]. K is inconsistent. But if we add just a single point
to Space so Space0 = {p1 , . . . , pn , pn+1 } then K becomes consistent: for instance if w10 is the world
where w10 (id1 , 1) = p1 and the other values are arbitrary, and w20 is the world where w20 (id1 , 1) =
pn+1 and the other values are arbitrary, then assigning I 0 (w10 ) = 0.5 and I 0 (w20 ) = 0.5 with I 0 (w0 ) =
0 for all other worlds makes I 0 a model. A similar situation may occur with integrity constraints.
Consider K that contains a single std-formula: f : X1 Y1 Z1 [loc(X1 , Y1 , Z1 )Y1 ov {p1 , . . . , pn }]
Since every region overlaps with Space, f , by itself, is inconsistent. But again, if we enlarge Space
by one point pn+1 to Space0 we can find a model I 0 as follows. Let I 0 (w0 ) = 0 for every world
0
w0 where w0 (id, t) 
PSpace for0 some hid, ti-pair, and I (w0 ) = 1 where w0 (id, t) = pn+1 for all
hid, ti pairs. Then w0 |w0 6|=f I (w) = 0; hence the inconsistency is removed. However, suppose
that in addition to f , K also contains the atom a = loc(id1 , {p1 }, 0)[1, 1] in A, that is, now A = {a}
and F = {f }. The PST atom a states that id1 must be at p1 at time 0. In that case we cannot make
K consistent by adding any number of points to Space because a and f are in conflict. Hence there
is no general statement about what happens to an inconsistent PST KB when Space is extended to
Space0 .
782

fiK NOWLEDGE R EPRESENTATION IN P ROBABILISTIC S PATIO -T EMPORAL K NOWLEDGE BASES

Next we consider the case where K is consistent (using Space). In this case we can show that it
remains consistent when Space is expanded to Space0 .
Theorem 16. If K is consistent with Space, then K remains consistent when Space is enlarged to
Space0 .
Proof. Let M be a model for K (using Space). M assigns a probability M (w) to each world w.
When Space is extended to Space0 , many new worlds are added. We define M 0 (w) = M (w) if w
is a world where only Space is used and M 0 (w) = 0 otherwise. Thus by basically excluding the
worlds using points other than Space in the sense that they are given probability 0, M 0 is a model
of K using Space0 . Hence consistency is preserved.
Again, just as in the case of time, we are interested in what happens for arbitrarily large finite
spaces.
Definition 21. We call K eventually consistent (resp. inconsistent) for space if there is an integer
L such that K is consistent (resp. inconsistent) for all Space = {p1 , . . . , pn , . . . , pL , . . . , p }.
Corollary 11. Every K is either eventually consistent for space or eventually inconsistent for space.
Proof. There are two cases. We start with the first case where K is consistent with Space. Then,
by Theorem 16 it remains consistent for any larger Space0 . Hence it is eventually consistent for
space. Consider now the second case where K is inconsistent with Space. There are two subcases.
First, suppose that K becomes consistent with some larger Space0 . Then, just as in the first case, by
Theorem 16 K is eventually consistent for space. The second subcase is where K never becomes
consistent no matter how Space is extended to Space0 . This means that K is eventually inconsistent
for space.
We showed earlier by examples that an inconsistent K (with Space) may become consistent if
Space is enlarged. We can calculate a bound for the size of the needed space such that after that
bound is reached the consistency or inconsistency does not change with further spatial enlargement.
Theorem 17. For every inconsistent K using Space = {p1 , . . . , pn }, there is an explicit bound L
that is tractable to compute such that if K using Space0 = {p1 , . . . , pL } is inconsistent, it remains
inconsistent for any enlargement of Space0 .
Proof. We already know from the above corollary that such an L exists. We now show how to
compute it. First of all, if no enlargement of Space resolves the inconsistency of K then K is
eventually inconsistent for space and we can choose L = n. Thus we need to deal in more detail
only with the case where an enlargement of Space resolves the inconsistency of K, that is, K is
eventually consistent for space. So we consider how adding points to Space can make K consistent.
There are three cases:
1. the inconsistency is due to A alone,
2. the inconsistency is due to a combination of elements from both A and F, and
3. the inconsistency is due to F only.
783

fiPARISI & G RANT

Consider first that in Case 1 an inconsistency must be due to atoms with some fixed id and t
values. So we assume that we are dealing only with atoms using a specific pair of values: id and
t. Adding a point or points to Space can resolve an inconsistency only if the atoms using id and t
give Space a probability less than 1. For instance, let A = {loc(id, r1 , t, [0, 0.4]), loc(id, r2 , t, [0.1,
0.3])} where r1  r2 = Space. Then, enlarging Space to Space0 = Space  {pn+1 } resolves
the inconsistency. This is true in general, not just for this example, because once pn+1 is added
to Space, {p1 , . . . , pn } becomes a proper subset of the relevant Space0 and may consistently have
probability less than 1. Now, consider that A may have inconsistencies involving multiple pairs of
id and t values. But that does not matter because the addition of the single point pn+1 to Space
resolves all such inconsistencies. So in Case 1 we can choose L = n + 1.
In Case 2 an inconsistency of K is due to a combination of elements from A and F. As every
atom a in A refers to a specific region r for a specific object id and time value t, for an inconsistency
to occur with some f  F, some substitution of f must act as an atom (with probability interval
[0, 0]). For instance, let a = loc(id, r1 , t, [0, 0.4]) and f = X1 [loc(X1 , r2 , t)] where r1  r2 =
Space. The instance of f that causes the inconsistency is [loc(id, r2 , t)] which has the same effect
by the semantics as the atom loc(id, r2 , t, [0, 0]). This is true in general, not just for this example.
In this way Case 2 reduces to Case 1 and we can choose L = n + 1.
The last case, Case 3, is where an inconsistency is due just to F. The problem in this case is
due to the fact that F requires more points than are in Space. So we need to consider what can be
expressed about the number of spatial points by std-formulas. This cannot be done by writing many
spatial variables because if formula f has m spatial variables, say Y1 , . . . , Ym , there is no way to
express that they must all refer to different points. However, we can express that Space does not
have enough points by writing f0 = X1 Y1 Z1 [loc(X1 , Y1 , Z1 )  Y1 ov Space]. Again, adding a
single point to Space resolves the inconsistency. We can also write std-formulas that require at least
a certain number of points. We can express the constraint that a point can be occupied by at most
one object at one time by using the following 3 std-formulas:
f1 = X1 Y1 Z1 Z2 [loc(X1 , Y1 , Z1 )  loc(X1 , Y1 , Z2 )  Z1 6= Z2 ]
f2 = X1 X2 Y1 Z1 [loc(X1 , Y1 , Z1 )  loc(X2 , Y1 , Z1 )  X1 6= X2 ]
f3 = X1 X2 Y1 Z1 Z2 [loc(X1 , Y1 , Z1 )  loc(X2 , Y1 , Z2 )  X1 6= X2  Z1 6= Z2 ]
f1 states that no object can be at the same point at two different times; f2 states that at no time can
two objects be at the same point; f3 states that two different objects cannot be at the same point
at two different times. Hence using std-formulas we can reference the number of objects times the
number of time points. Let L = n + |ID|  (tmax + 1). Thus Space0 = {p1 , . . . , pL } consists
of a point for each object and time point in addition to the original n points in Space, so that we
can place objects in Space0 even when none of the points in Space can be used and each object
needs a new point at each time point. Clearly, L > n + 1, so this L works for Cases 1 and 2 as
well. So this is the value of L that we choose for the tractable explicit bound. Thus if K using
Space0 = {p1 , . . . , pL } is still inconsistent, no points added to Space0 can make it consistent.
5.4 Extending the Number of Objects or Several Entities
The last case where the number of constants may be increased is for ID. Since a world w is a
function w : ID  T  Space, the expansion of objects is similar to the expansion of time, not
784

fiK NOWLEDGE R EPRESENTATION IN P ROBABILISTIC S PATIO -T EMPORAL K NOWLEDGE BASES

to the expansion of space. So the extension and restriction of interpretations going from an ID to a
larger ID0 is analogous to the addition of time values to T . Without getting into the details which are
analogous to the cases for time given earlier, we can state that if K is inconsistent with ID, it remains
inconsistent if ID is expanded to ID0 . To show that consistency need not be preserved, consider f =
X1 X2 . . . Xm+1 [loc(X1 , Y1 , Z1 )loc(X2 , Y2 , Z2 ). . .loc(Xm+1 , Ym+1 , Zm+1 )X1 6= X2 
X1 6= X3  . . .  Xi 6= Xj  . . .  Xm 6= Xm+1 ] for i 6= j. Recalling that ID = {id1 , . . . , idm } we
find that K = {f } is consistent with ID because it states that there cannot be more than m distinct
objects. But it becomes inconsistent if ID is enlarged to ID0 = {id1 , . . . , idm , idm+1 }. But we can
always find a q  m in linear time such that if K is consistent for ID0 = {id1 , . . . , idm , . . . , idq }
then K is consistent for any enlargement of ID0 . Obtaining the value q is easier than obtaining
tbig for time. It is just a matter of counting up the number of X variables in each f  F and
taking the maximum such value, if bigger than m. Hence if we define eventually consistent (resp.
inconsistent) for objects in the same way as for time, we obtain the result that every K is either
eventually consistent for objects or eventually inconsistent for objects.
So far we have only considered individual enlargements of either time values or points in space
or objects. But we may be interested also in combining several types of extensions. As the expansion
of time and objects are similar, we start by combining them.
Definition 22. We call K using ID, T , and Space eventually consistent (resp. inconsistent) for
objects and general time if there are integers L1 , L2 , and L3 such that K is consistent (resp.
inconsistent) for all ID = {id1 , . . . , idm , . . . , idL1 , . . . , id }, Space = {p1 , . . . , pn }, and T =
tmax+1
[0, 1 , 2 , . . . , 1, +1
, . . . , . . . , ] where  > L2 and  > L3 .
 , . . . tmax,

The combination of the expansion of objects and time both in magnitude and divisionally works
essentially in the same way as the expansion of only one of these items. That is, if the set of all
worlds for the original K is W and the set for all worlds with the expansion to ID and T is W 0 ,
then for every world in W there is a set of extensions in W 0 and for every world in W 0 there is a
unique world in W that is its restriction. The key issue is that Space remains unchanged.
Now let K contain time values in T , regions in Space and objects in ID. Suppose that T is
expanded to T 0 where the expansion may be both in magnitude and division and ID is expanded to
ID0 and find that K, in the context of T 0 and ID0 with Space unchanged, is consistent. Just as in the
proof of Theorem 12 we start with a model M 0 for K using T 0 and ID0 and obtain the corresponding
model M for K using the starting T and ID. Thus, by the contrapositive, if K is inconsistent with
T , Space and ID, it remains inconsistent with T 0 , Space and ID0 . This shows that any inconsistent
K is eventually inconsistent for objects and general time. In case K is consistent with T , Space and
ID and becomes inconsistent with the expansion to T 0 , Space and ID0 , then again it is eventually
inconsistent for objects and general time. The only alternative is for K to remain consistent no
matter how T and ID are expanded. Hence our earlier results can be put together as the following
result.
Theorem 18. Every PST KB K is either eventually consistent for objects and general time or it is
eventually inconsistent for objects and general time.
However, the situation is different in the cases where we combine space with time or with objects
as we show using an example.12
12. This example was suggested by one of the reviewers.

785

fiPARISI & G RANT

Example 25. Consider the PST KB K = h, {f }i defined using ID = {id1 , . . . , idm }, T =
[0, 1, . . . , tmax], and Space = {p1 , . . . , pn } with m  n where f is the std-formula f2 used
in the proof of Theorem 17 which states that two different objects cannot be at the same point
at the same time. Because of the condition m  n, K is consistent. Expand ID to ID0 =
{id1 , . . . , idm , . . . , idn+1 } leaving T and Space unchanged and call the new KB K0 . Now there
are too many objects for the number of points; hence K0 is inconsistent. Next, expand Space to
Space00 = {p1 , . . . , pn , pn+1 } while leaving ID0 and T unchanged and call the new KB K00 . K00 is
consistent.
2
This example shows that we cannot claim eventual (in)consistency if both the number of objects
and the number of points may increase as we can just continue the process indefinitely. An analogous result holds in case both the number of time values and the number of points may increase.

6. Related Work
We first discuss related works on classical probabilistic logic that does not have explicit spatial and
temporal components. Then we discuss the relationship between our work and other spatio-temporal
approaches. Finally, we relate our framework to object tracking.
6.1 Probabilistic Logic
As discussed in Section 3, a PST KB can be expressed in classical propositional logic (Hailperin,
1984; Nilsson, 1986; Paris, 1994), and in particular the consistency checking problem can be
formulated in terms of Probabilistic Satisfiability (PSAT), whose first formulation is attributed to
Boole (1854). After its presentation to the AI community by Nilsson (1986), the study of PSAT
from the point of view of efficient algorithms and computational complexity was first addressed
by Georgakopoulos et al. (1988), who showed that PSAT is in NP and NP-hard even for binary
clauses. The tractable results identified by Georgakopoulos et al. concern the special case where
each clause involves at most two literals (2PSAT) and the graph of clauses is outerplanar,13 where
the graph of clauses contains a vertex for each literal and two kinds of edges: i) an edge between
each pair of literals built from the same propositional variable, and (ii) an edge for each pair of
literals appearing in the same clause. We note that the PSAT formula K encoding PST KB K
(see the proof of Theorem 1) contains more than two literals per clause even if we focus on binary
std-formulas (K becomes a 2PSAT formula only if we assume that Space consists of just two
points).
The result provided by Georgakopoulos et al. relies on reducing 2PSAT to a tractable instance
of 2MAXSAT (weighted maximum satisfiability problem with at most two literals per clause). Using this reduction and the result of Conforti and Cornuejols (1992) on the tractability of problems
that can be formulated as an integer program whose matrix is balanced, the following general result
was provided by Conforti and Cornuejols: PSAT is tractable for a balanced set of clauses, that is,
for a set of clauses whose corresponding {0, 1} clause-variable matrix is balanced. However, this
result also doesnt help in finding tractable cases for PST KBs K through reduction to PSAT K , as
considering three points is Space suffices to make the matrix corresponding to K not balanced (it
entails the presence of an odd cycle in the graph of clauses that, as observed by Andersen & Pre13. A graph is said to be outerplanar if it can be embedded in the plane so that all of its vertices lie on the same face.
That is, it can be drawn in the plane without crossings in such a way that no vertex is totally surrounded by edges.

786

fiK NOWLEDGE R EPRESENTATION IN P ROBABILISTIC S PATIO -T EMPORAL K NOWLEDGE BASES

tolani, 2001, characterizes non-balanced matrices). Motivated by the fact that the tractable cases for
PSAT identified by Georgakopoulos et al. and Conforti and Cornuejols rely on using a polynomial
time algorithm whose complexity is characterized by a high polynomial degree (specifically, the
complexity is O(n6 log n) where n is the number of propositional variables), Andersen and Pretolani identified more efficient algorithms for the classes of balanced sets of clauses that can be
represented by either hypertrees (where each hyperarc corresponds to the set of literals in a clause)
or such that the co-occurrence graph is a partial k-tree (Bodlaender, 1998).
It is worth noting that none of the tractable cases identified in this paper can be derived from
the results for PSAT described above by reducing K to the PSAT formula K . In fact, our tractable
cases derive from the specific structure of PST KBs. On the other hand, our tractability results
entail the tractability of PSAT instances that can be reduced to a tractable instance of the consistency
checking problem. In particular, we can decide in polynomial time PSAT instances K having the
structure specified in our reduction from the consistency checking problem to PSAT, and such that
the consistency checking problem for the corresponding PST KB K turns out to be tractable.
In principle, the fact that there is a reduction from the consistency checking problem to PSAT
enables well-known techniques for solving (general) instances of PSAT based on column generation (Kavvadias & Papadimitriou, 1990; Jaumard et al., 1991) to be used for addressing the consistency of PST KBs. The same holds for the problem of answering selection queries in PST
KBs that, as shown in Section 4, can be addressed by solving suitable instances of the consistency
checking problem. Recent approaches to solve PSAT using SAT (Finger & Bona, 2011) or Integer
Linear Programming (Cozman & di Ianni, 2015) for column selection report experiments showing
a phase transition behaviour (first observed by Finger and Bona for PSAT) depending on the fraction between the number of clauses and propositional variables as well as the number of probability
assignments. Using these techniques PSAT instances with hundreds of propositional variables and
clauses can be solved in reasonable time. However, we believe that reducing the consistency checking (or query answering) problem to PSAT and then applying these techniques as they are would
not be a successful approach, as the number of propositional variables and clauses that would be
generated would be huge even for small-size PST KBs. To avoid this problem, we conjecture that
the specific structure of (PSAT formulas encoding) PST KBs could be exploited to devise more
efficient techniques for solving the consistency checking and the query answering problems. In this
regard, it would be interesting to investigate the connection between our framework and the emerging field of lifted probabilistic inference (Kersting, 2012), where the structure of FOL-constructs
(such as indistinguishable individuals) is exploited to speed up the reasoning process, and see if
some results can carry over into PST KBs.
The use of integrity constraints to encode domain knowledge has been studied by Lukasiewicz
(1999, 2001) and Flesca, Furfaro, and Parisi (2014), for probabilistic frameworks which however
do not explicitly deal with space and time. The problem of probabilistic deduction in the presence
of conditional constraints over basic events was addressed by Lukasiewicz (1999), who identified
tractable instances of probabilistic KBs, whose conditional constraints define conditional constraint
trees, to support deduction over paths of premise/conclusions basic events. The problem of checking
the consistency of relational probabilistic databases (where tuples can be viewed as basic events)
in the presence of denial constraints was addressed by Flesca et al., who provided tractability results for constraints whose conflict hypergraph (Chomicki, Marcinkowski, & Staworko, 2004) is acyclic (Fagin, 1983) as well as for a special kind of cyclic hypergraphs, which can encode neither
clique-acyclic std-graphs nor simple clique-cyclic std-graphs. An important probabilistic logic pro787

fiPARISI & G RANT

gramming approach with conditional constraints was proposed by Lukasiewicz (2001), who studied
the complexity of the satisfiability and the entailment problems for several types of formulas but
without identifying tractable cases. Differently from the above-cited papers, the atomic information
in our framework has a structure involving objects, space, and time, and thus atoms may also be
intrinsically related because they are about the same object, or space, or time value.
6.2 Spatio-Temporal Approaches
Substantial work has been done on spatio-temporal logics (Gabelaia et al., 2005; Knapp et al.,
2006) which combine spatial and temporal formalisms. This includes important contributions on
qualitative spatio-temporal representation and reasoning (Muller, 1998; Wolter & Zakharyaschev,
2000; Cohn & Hazarika, 2001), which focus on describing entities and qualitative relationships
between them while dealing with discrete time. Cohn, Li, Liu, and Renz (2014) provided an upto-date overview of the work done in the field of qualitative spatial reasoning, where recently the
important problem of combining topological and directional information for extended spatial objects
has been addressed. However, these works are not intended for reasoning about moving objects
whose location at a given time is uncertain (they do not put probabilities into the mix). Yaman
et al. (2004, 2005a, 2005b) focused on spatio-temporal logical theories that describe known plans
of moving objects by sets of go atoms, each of them stating that an object can go from location
L1 to L2 , leaving L1 and reaching L2 at some time in some intervals, and travelling with a speed
in a given interval. Later, Parker et al. (2007b) extended this logic to include some probabilistic
information about such plans. The SPOT framework of Parker et al. (2007a) further extended that
work to uncertainty about where objects might be at a given time.
Past work on the SPOT framework investigated efficient algorithms for computing optimistic
and cautious answers to selection queries (Parker et al., 2009; Parisi et al., 2010). The initial SPOT
framework on which we build by adding integrity constraints has been implemented and tested on
real US Navy databases containing ship location data (Parker et al., 2009; Parisi et al., 2010). Aggregate queries have been recently investigated by Grant et al. (2013), who proposed three semantics
along with computational methods for evaluating them. As SPOT databases provide information
on moving objects, one important aspect addressed by Parker et al. (2008) and then further investigated by Grant et al. (2010) is that of revising SPOT data so that information on these objects may
be changed as objects move. Grant et al. (2010) proposed several strategies for revising SPOT data
such as finding maximal consistent subsets, minimally modifying the spatial, temporal, object, or
probability components of PST atoms. A full logic including negation, disjunction and quantifiers
for managing SPOT data was recently proposed by Doder et al. (2013), who focused on finding
sound and complete sets of axioms for several fragments of the logic. Grant, Parisi, and Subrahmanian (2013) provided a comprehensive survey on the SPOT framework where other related research
is also reviewed.
While there is much work on spatio-temporal databases (Agarwal et al., 2003; Pelanis et al.,
2006) and probabilistic spatio-temporal databases (Tao et al., 2005; Zhang, Chen, Jensen, Ooi, &
Zhang, 2009; Zheng, Trajcevski, Zhou, & Scheuermann, 2011), these works mainly focus on devising indexing mechanisms and scaling query computation, instead of representing knowledge in
a declarative fashion. In particular, Chung, Lee, and Chen (2009) use indexing to speed the computation of range queries and derive a PDF for the location of an object moving in a one-dimensional
space by using its past moving behavior or the moving velocity distribution. Zhang et al. (2009)
788

fiK NOWLEDGE R EPRESENTATION IN P ROBABILISTIC S PATIO -T EMPORAL K NOWLEDGE BASES

provide a B x -tree index which is a variant of a B + -tree applicable to moving objects whose location
and velocity are uncertain. Two types of pruning are introduced by Yang, Lu, and Jensen (2010)
to efficiently solve queries asking for all sets of k objects that have at least a threshold probability
of containing the k nearest objects to a given object. Dealing with a similar problem, Chen, Qin,
and Liu (2010) propose a TPR-tree for indexing. Finally, Zheng et al. (2011) deal primarily with
objects moving along road networks, and introduce an indexing mechanism for efficiently processing probabilistic range queries. However, none of these works systematically addresses the issue of
considering integrity constraints over probabilistic spatio-temporal data.
6.3 Object Tracking
Object tracking is one of the most important problems in computer vision (Szeliski, 2010) where
the consecutive positions of a tracked object are estimated as it moves in different frames of a
video. Numerous approaches for object tracking have been proposed, mainly differing from each
other on the type of object representation used (e.g., centroid, primitive geometric shapes), image
features selected (e.g., colour, optical flow), and object detection method adopted (e.g., background
subtraction, segmentation). However, the tracking algorithm to be chosen in a given application
strongly depends on the application domain (Yilmaz, Javed, & Shah, 2006). Moreover, as object
tracking algorithms may incur errors, due for instance to loss of information caused by projection
of the 3D world on a 2D image, noise in images, partial and full object occlusions, the estimation of
the position of tracked moving objects is inherently uncertain (even if a camera focuses on a fixed,
specific area). Several important statistical methods for object tracking in computer vision (e.g., see
Broida & Chellappa, 1986; Beymer & Konolige, 1999; Rosales & Sclaroff, 1999) are based on the
well-known Kalman filter (1960) and its extensions to deal with the non-linear case, as well as on
particle filtering (Kitagawa, 1987).
Filtering techniques have been extensively used for object tracking in the presence of sensors,
not only cameras. As a matter of fact, object tracking has been extensively addressed in the more
general setting where the position (i.e., the state) of one or more objects is estimated by a recursive
Bayesian filter given the measurements up to that time coming from different kinds of sensors
(including, for instance, radar, sonar, infrared, and other types of sensors possibly along with visual
sensors) (Stone, Corwin, & Barlow, 1999). Basically, at each observed time point t, the output
of the filter is a probability distribution (i.e., the posterior) on the position of the target object,
which is computed by combining the motion updated at a time prior to t with the likelihood for
the observation received at time t, where the likelihood represents the probability of each sensor
measurement conditioned on the object position (Bar-Shalom, Kirubarajan, & Li, 2002).
The Kalman filter has been used for discrete-time estimation of continuous spatial positions of
objects whose movement equations can be assumed to be linear with Gaussian noise. It has also
been used successfully in non-linear systems by applying linearization and unscented transformation (Julier, Jeffrey, & Uhlmann, 2004). For discrete space and non-linear systems, particle filtering
has been successfully used, providing a solution that can be applied to any state-space model and
which generalizes the traditional Kalman filtering methods (Arulampalam, Maskell, Gordon, &
Clapp, 2002). A general framework for particle filtering based on Sequential Importance Sampling with Resampling was proposed by Liu and Chen (1998), though a number of different types
of particle filters exist and some have been shown to outperform others when used for particular
applications (Arulampalam et al., 2002).
789

fiPARISI & G RANT

Differently from Kalman filtering, where the estimated position of an object at each observed
time point is represented as a continuous distribution, particle filters are based on a histogram representation of the probability density, which is approximated by a finite number of particles (i.e.,
samples): each particle represents a position of space, and weights associated with particles (or the
proportion of the number of particles) define a histogram of the probability distribution over space.
This fits with the representation paradigm of PST KBs: as PST KBs allow us to represent, for each
object and time point, a PDF over Space by defining a PST atom with a single valued probability
interval (that is, ` = u) for each point in Space, it can be used easily to represent the output of object tracking techniques based on particle filtering. For filtering techniques returning a continuous
distribution over Space, a discretization step should be applied.
While the output of object tracking techniques can be represented using PST KBs, there are
important aspects that these techniques can deal with that PST KBs cannot do. In particular, filtering techniques use conditional independence to represent a PDF of an objects positions conditional
on its positions at the previous time. PST KBs can encode the output of this inference process,
but lack the expressive power to do that kind of inference. For instance, tracking techniques can
represent the knowledge that if an object is in a region r1 at time t1 then it is probably in region
r2 at time t2 with a probability depending on the time elapsed between t1 and t2 . Indeed trackers
can rely on a motion model according to which the distribution for an objects location spreads out
with the elapsed time since the last measurement: the distribution for the objects locations will be
narrowly focused on locations near the measured position at t1 if t2 is close to t1 , but it will diffuse
if t2 is faraway t1 . While tracking techniques can do this sort of things quite naturally, PST KBs
can only capture some aspects of this behavior. For instance, we can express the fact that the object
is probably in region r1 at t1 , and use an integrity constraint imposing that it can travel no more
than d distance units in 1 time point. This would increase the probability of finding the object at
time t2 in a region less than d units away from r1 , and it would decrease the probability of finding
the object in a region farther away than d units. However, this is different from what can be inferred
by tracking techniques using conditional independence.
On the other hand, tracking techniques do not combine very well with interval probabilities.
In fact they typically return the PDF of an objects position at each observed time point. In contrast, using general PST atoms (with probability intervals), for each object and time point, all the
(possibly infinite in number) PDFs that are compatible with the probability intervals specified by
the atoms are succinctly represented. For instance, assuming Space = {p1 , p2 } and the PST atom
loc(id, {p1 }, t)[0, 0.5], all the PDFs f over Space assigning a probability f (p1 ) in [0, 0.5] and
f (p2 ) = 1  f (p1 ) are represented. However, the set of PDFs represented can be restricted by using
single valued probability intervals or by adding integrity constraints using std-formulas.
We note that the PST formalism allows us to impose integrity constraints over KBs that can
be obtained by integrating position data coming from different sources. Consider for instance the
integration of several PST KBs, each of them consisting of PST atoms encoding the output of
an autonomous tracking system. The so-obtained integrated KB is still a PST KB, and integrity
constraints can be used to express knowledge on the overall system, that could not be expressed
considering the tracking systems separately. For instance, suppose we have an integrated PST KB
consisting of the position data of monitored cars that are collected using black-box tracking systems
installed over cars by insurance companies. Then std-formulas can be used to express correlations
among monitored cars. For instance, knowing that in region r there is a licensed inspection station
able to inspect at most k cars at the same time, we can impose the constraint that there cannot be
790

fiK NOWLEDGE R EPRESENTATION IN P ROBABILISTIC S PATIO -T EMPORAL K NOWLEDGE BASES

more than k cars in r at any time. This constraint would be meaningless if we considered the KB of
each car tracking system separately, but it is useful for restricting the set of consistent interpretations
of the PST KB obtained by integrating the several sources.

7. Summary
We believe that this is the first comprehensive paper that focuses systematically on knowledge representation in the form of integrity constraints for probabilistic spatio-temporal data.14 The knowledge
is represented both in the form of spatio-temporal atoms describing the location of objects in time
with a probability interval as well as spatio-temporal denial formulas describing the integrity constraints the system must satisfy. Within this framework we investigated the consistency checking
problem as well as the problem of answering selection queries in consistent PST KBs. Although
both these problems turned out to be hard in the general case, we devised several sets of linear
inequalities which allow us to decide consistency as well as answer queries by checking their feasibility. In addition, we identified different classes of spatio-temporal denial formulas for which
both checking consistency and answering queries are tractable. Finally, we discussed an extension
of the framework to arbitrarily large finite numbers of objects, time values, and points in space and
showed that the behavior of consistency and inconsistency is uniform.

8. Future Work and Conclusion
There are further issues that can be investigated. Following Parisi and Grant (2014b), where we
studied the problem of restoring the consistency of PST KBs of the form KhA, i (where the set of
std-formulas is empty), we will consider the problem of repairing an inconsistent PST KB where
inconsistency is due to the presence of std-formulas that are not satisfied. In this regard it would be
interesting to devise methods for answering queries in inconsistent PST KBs. Recently there has
been some research on probabilistic reasoning under inconsistency (Picado-Muino, 2011; Thimm,
2013; Potyka & Thimm, 2014) that can help in this regard. It would also be interesting to look
into the possibility of semantic query optimization for PST KBs, and to study the use of previous
knowledge to efficiently check for consistency and process queries after updates.
Another direction for future work is the investigation of probabilistic std-formulas for expressing
constraints that hold with a probability in a given interval. Intuitively, this would allow us to state
for instance that two objects are not in the same region at the same time with probability greater
then a given threshold, instead of stating that they cannot be in such a situation. This kind of
probabilistic constraint could be expressed using pstd-formulas of the form f [`, 1] where f is an
std-formula (i.e., f [1, 1] captures the meaning of an std-formula). Then the change in semantics
means changing
the definition of model. Only the second part of Definition 6 has to be modified to
P
f  F, w|w|=f M (w)  [`, 1]. Clearly, lower bounds on the complexity of consistency checking
and query answering problems still hold for this extension. It is easy to check that the upper bound
provided by Theorem 1 holds since a reduction to PSAT can still be provided by mapping pstdformulas to clauses associated with a probability interval. As regards tractable cases, we conjecture
that the results of Theorems 6 and 8 still hold for pstd-formulas of the form f [`, 1] if the right-hand
side of inequality (4) of Definitions 15 and 17, respectively, is replaced with the lower probability
bound ` of the ground pstd-formula f [`, 1] generating the inequality. However, allowing general
14. This is a substantially revised and expanded version of the work by Parisi and Grant (2014a).

791

fiPARISI & G RANT

probability intervals associated with std-formulas introduces new issues in the semantics: f [`, u]
would entail that f [1  u, 1  `] holds. Providing a clear and intuitive semantics for this kind of
std-formula, as well as for probabilistic std-formulas allowing probability intervals to be associated
with each conjunct (instead of the whole formula), is deferred to future work.
The PST formalism is propositional even though the atoms have substantial content. We have
added std-formulas for integrity constraints; these are a special class of first-order logic formulas. It would be interesting to consider other works on more general first-order probabilistic logics (Halpern, 1990; Lukasiewicz & Kern-Isberner, 1999; Kern-Isberner & Thimm, 2010). These
logics were developed for a different purpose but an attempt could be made to represent spatiotemporal information in them. There are other works as well that could be enhanced with spatiotemporal information, such as Markov Logic (Richardson & Domingos, 2006), or Bayesian Logic
Programs (Kersting & Raedt, 2007). In particular, Milch et al. (2005) introduces a first-order language called BLOG (Bayesian LOGic) for defining probability models over worlds with unknown
objects and identity uncertainty, which finds a natural application in object tracking for unknown
objects. It may be possible to find a generalization of the PST formalism that includes some of
these concepts. In doing so, an aspect that we need to take care of is the fact that Markov logic
and Bayesian logic programs deal with a unique probability distribution, while we deal with all the
probability distributions compatible with the PST atoms and std-formulas.
Researchers in AI have been studying spatial and temporal reasoning for many years (Allen,
1984; Randell, Cui, & Cohn, 1992; Galton, 2009). An interesting project will be the incorporation
of these concepts into the PST framework. The new syntax and semantics will include adding rules
to the language. These additions will allow both for adding other types of information as well as new
integrity constraints. For instance, using the concepts of qualitative direction and orientation proposed for spatial reasoning (Galton, 2009) would allow us to explicitly represent knowledge about
the region toward which an object is moving. Another important concept needed in many applications is the explicit representation of qualitative and quantitative distance between objects as well as
of information about the speed (i.e., maximum or average) of objects. Additional structured information about objects such as the type (e.g., vessel, vehicle, person, etc.) would be in general useful
to exhaustively reason about moving objects. However, depending on the addition made to increase
the expressive power of the extended framework, important consequences on the complexity of the
consistency checking problem may arise. Spatial and temporal aspects of formalisms for qualitative
spatial and temporal reasoning are more expressive than what we have in our framework (Gabelaia
et al., 2005; Knapp et al., 2006). The trade-off between expressiveness and complexity within the
hierarchy of formalisms obtained by combining well-known spatial and temporal logics is analyzed
by Gabelaia et al. (2005), where it is shown that the complexity of the satisfiability problem for
spatio-temporal logics (not dealing with probabilities) can vary from NP-complete to undecidable.
Using these formalisms in the PST framework may drastically increase the computational complexity of the problems studied in this paper. Nevertheless, we believe that some attempt should
later be made to include even simpler concepts of qualitative spatio-temporal reasoning to the PST
framework, particularly trying to exploit restrictions recently studied by Huang, Li, and Renz (2013)
to identify tractable fragments.
In this paper, we proposed a framework where four features of moving objects are taken into
account: the spatial component, the temporal component, the inherent uncertainty of acquired data,
and integrity constraints from the application domain. The expressiveness of these features could be
improved to represent additional knowledge that may be of interest in practical applications, partic792

fiK NOWLEDGE R EPRESENTATION IN P ROBABILISTIC S PATIO -T EMPORAL K NOWLEDGE BASES

ularly using ideas from papers dealing with spatio-temporal reasoning. In the endeavor of a concrete
implementation of our framework, ideas from the PostGIS spatial database system which extends
PostgreSQL would be useful. We believe it will be worthwhile later to incorporate more concepts
in the PST framework. We took a first step in extending the PST framework by the addition of
integrity constraints, and hope that researchers will use our work as a starting point in investigations
of the important role of integrity constraints in probabilistic spatio-temporal knowledge bases.

Acknowledgments
We wish to thank the referees for numerous helpful comments that helped us in substantially improving this paper.

References
Agarwal, P. K., Arge, L., & Erickson, J. (2003). Indexing moving points. J. Comput. Syst. Sci.,
66(1), 207243.
Ahson, S. A., & Ilyas, M. (2010). Location-Based Services Handbook: Applications, Technologies,
and Security. CRC Press, Hoboken, NJ.
Akdere, M., Cetintemel, U., Riondato, M., Upfal, E., & Zdonik, S. B. (2011). The case for predictive database systems: Opportunities and challenges. In Proceedings of the 5th Biennial
Conference on Innovative Data Systems Research (CIDR), pp. 167174.
Allen, J. F. (1984). Towards a general theory of action and time. Artif. Intell., 23(2), 123154.
Andersen, K. A., & Pretolani, D. (2001). Easy cases of probabilistic satisfiability. Ann. Math. Artif.
Intell., 33(1), 6991.
Arulampalam, M. S., Maskell, S., Gordon, N. J., & Clapp, T. (2002). A tutorial on particle filters for
online nonlinear/non-gaussian bayesian tracking. IEEE Transactions on Signal Processing,
50(2), 174188.
Bar-Shalom, Y., Kirubarajan, T., & Li, X.-R. (2002). Estimation with Applications to Tracking and
Navigation. John Wiley & Sons, Inc., New York, NY, USA.
Bayir, M. A., Demirbas, M., & Eagle, N. (2010). Mobility profiler: A framework for discovering
mobility profiles of cell phone users. Pervasive and Mobile Computing, 6(4), 435  454.
Beymer, D., & Konolige, K. (1999). Real-time tracking of multiple people using continuous detection. In Proceedings of the Workshop on Frame-rate Applications, Methods and Experiences
with Regularly Available Technology and Equipment (FRAME-RATE), in conjunction with
the 7th IEEE International Conference on Computer Vision (ICCV).
Bodlaender, H. L. (1998). A partial k-arboretum of graphs with bounded treewidth. Theor. Comput.
Sci., 209(1-2), 145.
Boole, G. (1854). An Investigation of the Laws of Thought on Which are Founded the Mathematical
Theories of Logic and Probabilities. Macmillan, London.
Broida, T. J., & Chellappa, R. (1986). Estimation of object motion parameters from noisy images.
IEEE Trans. Pattern Anal. Mach. Intell., 8(1), 9099.
793

fiPARISI & G RANT

Chen, Y.-F., Qin, X.-L., & Liu, L. (2010). Uncertain distance-based range queries over uncertain
moving objects. J. Comput. Sci. Technol., 25(5), 982998.
Chomicki, J., Marcinkowski, J., & Staworko, S. (2004). Computing consistent query answers using
conflict hypergraphs. In Proceedings of the 2004 ACM CIKM International Conference on
Information and Knowledge Management (CIKM), pp. 417426.
Chung, B. S. E., Lee, W.-C., & Chen, A. L. P. (2009). Processing probabilistic spatio-temporal
range queries over moving objects with uncertainty. In Proceedings of the 12th International
Conference on Extending Database Technology (EDBT), pp. 6071.
Cohn, A. G., & Hazarika, S. M. (2001). Qualitative spatial representation and reasoning: An
overview. Fundam. Inform., 46(1-2), 129.
Cohn, A. G., Li, S., Liu, W., & Renz, J. (2014). Reasoning about topological and cardinal direction
relations between 2-dimensional spatial objects. J. Artif. Intell. Res. (JAIR), 51, 493532.
Conforti, M., & Cornuejols, G. (1992). A class of logic problems solvable by linear programming.
In Proceedings of the 33rd Annual Symposium on Foundations of Computer Science (FOCS),
pp. 670675.
Cozman, F. G., & di Ianni, L. F. (2015). Probabilistic satisfiability and coherence checking through
integer programming. Int. J. Approx. Reasoning, 58, 5770.
Doder, D., Grant, J., & Ognjanovic, Z. (2013). Probabilistic logics for objects located in space and
time. J. of Logic and Computation, 23(3), 487515.
Fagin, R. (1983). Degrees of acyclicity for hypergraphs and relational database schemes. Journal
of the ACM, 30(3).
Finger, M., & Bona, G. D. (2011). Probabilistic satisfiability: Logic-based algorithms and phase
transition. In Proceedings of the 22nd International Joint Conference on Artificial Intelligence
(IJCAI), pp. 528533.
Flesca, S., Furfaro, F., & Parisi, F. (2014). Consistency checking and querying in probabilistic
databases under integrity constraints. J. Comput. Syst. Sci., 80(7), 14481489.
Gabelaia, D., Kontchakov, R., Kurucz, A., Wolter, F., & Zakharyaschev, M. (2005). Combining
spatial and temporal logics: Expressiveness vs. complexity. J. Artif. Intell. Res., 23, 167243.
Galton, A. (2009). Spatial and temporal knowledge representation. Earth Science Informatics, 2(3),
169187.
Georgakopoulos, G. F., Kavvadias, D. J., & Papadimitriou, C. H. (1988). Probabilistic satisfiability.
J. Complexity, 4(1), 111.
Grant, J., Molinaro, C., & Parisi, F. (2013). Aggregate count queries in probabilistic spatio-temporal
databases. In Proceedings of the 7th International Conference on Scalable Uncertainty Management (SUM), pp. 255268.
Grant, J., Parisi, F., Parker, A., & Subrahmanian, V. S. (2010). An agm-style belief revision mechanism for probabilistic spatio-temporal logics. Artif. Intell., 174(1), 72104.
Grant, J., Parisi, F., & Subrahmanian, V. S. (2013). Research in probabilistic spatiotemporal
databases: The SPOT framework. In Advances in Probabilistic Databases for Uncertain
Information Management, Vol. 304 of Studies in Fuzziness and Soft Computing, pp. 122.
Springer.
794

fiK NOWLEDGE R EPRESENTATION IN P ROBABILISTIC S PATIO -T EMPORAL K NOWLEDGE BASES

Hailperin, T. (1984). Probability logic. Notre Dame Journal of Formal Logic, 25(3), 198212.
Halpern, J. Y. (1990). An analysis of first-order logics of probability. Artif. Intell., 46(3), 311350.
Hammel, T., Rogers, T. J., & Yetso, B. (2003). Fusing live sensor data into situational multimedia
views. In Proceedings of the 9th International Workshop on Multimedia Information Systems
(MIS), pp. 145156.
Huang, J., Li, J. J., & Renz, J. (2013). Decomposition and tractability in qualitative spatial and
temporal reasoning. Artif. Intell., 195, 140164.
Jaumard, B., Hansen, P., & de Aragao, M. P. (1991). Column generation methods for probabilistic
logic. ORSA Journal on Computing, 3(2), 135148.
Julier, S. J., Jeffrey, & Uhlmann, K. (2004). Unscented filtering and nonlinear estimation. Proceedings of the IEEE, 92, 401422.
Junger, M., Liebling, T., Naddef, D., Nemhauser, G., Pulleyblank, W., Reinelt, G., Rinaldi, G., &
Wolsey, L. (Eds.). (2010). 50 Years of Integer Programming 1958-2008: From the Early Years
to the State-of-the-Art. Springer, Heidelberg.
Kalman, R. E. (1960). A new approach to linear filtering and prediction problems. Transactions of
the ASMEJournal of Basic Engineering, 82(Series D), 3545.
Karbassi, A., & Barth, M. (2003). Vehicle route prediction and time of arrival estimation techniques
for improved transportation system management. In Proceedings of the 2013 IEEE Intelligent
Vehicles Symposium, pp. 511516.
Karimi, H. A. (2013). Advanced location-based technologies and services. CRC Press, Hoboken,
NJ.
Kavvadias, D. J., & Papadimitriou, C. H. (1990). A linear programming approach to reasoning
about probabilities. Ann. Math. Artif. Intell., 1, 189205.
Kern-Isberner, G., & Thimm, M. (2010). Novel semantical approaches to relational probabilistic
conditionals. In Proceedings of the 12th International Conference on Principles of Knowledge
Representation and Reasoning (KR).
Kersting, K., & Raedt, L. D. (2007). Bayesian logic programming: Theory and tool. In Getoor, L.,
& Taskar, B. (Eds.), An Introduction to Statistical Relational Learning. MIT Press.
Kersting, K. (2012). Lifted probabilistic inference. In Proceedings of the 20th European Conference
on Artificial Intelligence (ECAI), pp. 3338.
Kitagawa, G. (1987). Non-gaussian state-space modeling of nonstationary time series. Journal of
the American Statistical Association, 82(400), 10321041.
Knapp, A., Merz, S., Wirsing, M., & Zappe, J. (2006). Specification and refinement of mobile
systems in mtla and mobile uml. Theor. Comput. Sci., 351(2), 184202.
Kurkovsky, S., & Harihar, K. (2006). Using ubiquitous computing in interactive mobile marketing.
Personal Ubiquitous Comput., 10(4), 227240.
Li, S. Z., & Jain, A. K. (Eds.). (2011). Handbook of Face Recognition, 2nd Edition. Springer.
Liu, J. S., & Chen, R. (1998). Sequential monte carlo methods for dynamic systems. Journal of the
American Statistical Association, 93, 10321044.
795

fiPARISI & G RANT

Lukasiewicz, T. (2001). Probabilistic logic programming with conditional constraints. ACM Trans.
on Computational Logic, 2(3), 289339.
Lukasiewicz, T. (1999). Probabilistic deduction with conditional constraints over basic events. J.
Artif. Intell. Res. (JAIR), 10, 199241.
Lukasiewicz, T., & Kern-Isberner, G. (1999). Probalilistic logic programming under maximum
entropy. In Proceedings of the 5th European Conference on Symbolic and Quantitative Approaches to Reasoning and Uncertainty (ECSQARU), pp. 279292.
MarketsandMarkets (2014). Location Based Services (LBS) Market (Mapping, Discovery and
Infotainment, Location Analytics, Leisure and Social Networking, Location Based Advertising, Augmented Reality and Gaming, Tracking) - Worldwide Forecasts and Analysis (2014 - 2019). http://www.marketsandmarkets.com/Market-Reports/
location-based-service-market-96994431.html.
Milch, B., Marthi, B., Russell, S. J., Sontag, D., Ong, D. L., & Kolobov, A. (2005). BLOG: probabilistic models with unknown objects. In Proceedings of the 19th International Joint Conference on Artificial Intelligence (IJCAI), pp. 13521359.
Mittu, R., & Ross, R. (2003). Building upon the coalitions agent experiment (coax) - integration
of multimedia information in gccs-m using impact. In Proceedings of the 9th International
Workshop on Multimedia Information Systems (MIS), pp. 3544.
Muller, P. (1998). A qualitative theory of motion based on spatio-temporal primitives. In Proceedings of the 6th International Conference on Principles of Knowledge Representation and
Reasoning (KR), pp. 131143.
Nilsson, N. J. (1986). Probabilistic logic. Artif. Intell., 28(1), 7187.
Papadimitriou, C. H., & Steiglitz, K. (1982). Combinatorial optimization: algorithms and complexity. Prentice-Hall, Inc., Upper Saddle River, NJ, USA.
Papadimitriou, C. M. (1994). Computational complexity. Addison-Wesley, Reading, Massachusetts.
Paris, J. (1994). The Uncertain Reasoners Companion: A Mathematical Perspective. Cambridge
University Press.
Parisi, F., & Grant, J. (2014a). Integrity constraints for probabilistic spatio-temporal knowledgebases. In Proceedings of the 8th International Conference on Scalable Uncertainty Management (SUM), pp. 251264.
Parisi, F., & Grant, J. (2014b). Repairs and consistent answers for inconsistent probabilistic spatiotemporal databases. In Proceedings of the 8th International Conference on Scalable Uncertainty Management (SUM), pp. 265279.
Parisi, F., Parker, A., Grant, J., & Subrahmanian, V. S. (2010). Scaling cautious selection in spatial
probabilistic temporal databases. In Methods for Handling Imperfect Spatial Information,
Vol. 256 of Studies in Fuzziness and Soft Computing, pp. 307340. Springer.
Parisi, F., Sliva, A., & Subrahmanian, V. S. (2013). A temporal database forecasting algebra. Int. J.
of Approximate Reasoning, 54(7), 827860.
Parker, A., Infantes, G., Grant, J., & Subrahmanian, V. S. (2009). SPOT databases: Efficient consistency checking and optimistic selection in probabilistic spatial databases. IEEE Transactions
on Knowledge and Data Engineering (TKDE), 21(1), 92107.
796

fiK NOWLEDGE R EPRESENTATION IN P ROBABILISTIC S PATIO -T EMPORAL K NOWLEDGE BASES

Parker, A., Infantes, G., Subrahmanian, V. S., & Grant, J. (2008). An AGM-based belief revision
mechanism for probabilistic spatio-temporal logics. In Proceedings of the 23rd AAAI Conference on Artificial Intelligence (AAAI), pp. 511516.
Parker, A., Subrahmanian, V. S., & Grant, J. (2007a). A logical formulation of probabilistic spatial
databases. IEEE Transactions on Knowledge and Data Engineering (TKDE), 19(11), 1541
1556.
Parker, A., Yaman, F., Nau, D. S., & Subrahmanian, V. S. (2007b). Probabilistic go theories. In
Proceedings of the 20th International Joint Conference on Artificial Intelligence (IJCAI), pp.
501506.
Pelanis, M., Saltenis, S., & Jensen, C. S. (2006). Indexing the past, present, and anticipated future
positions of moving objects. ACM Trans. Database Syst., 31(1), 255298.
Petrova, K., & Wang, B. (2011). Location-based services deployment and demand: aroadmap
model. Electronic Commerce Research, 11(1), 529.
Picado-Muino, D. (2011). Measuring and repairing inconsistency in probabilistic knowledge bases.
Int. J. Approx. Reasoning, 52(6), 828840.
Potyka, N., & Thimm, M. (2014). Consolidation of probabilistic knowledge bases by inconsistency
minimization. In Proceedings of the 21st European Conference on Artificial Intelligence
(ECAI), pp. 729734.
Randell, D. A., Cui, Z., & Cohn, A. G. (1992). A spatial logic based on regions and connection. In
Proceedings of the 3rd International Conference on Principles of Knowledge Representation
and Reasoning (KR), pp. 165176.
Richardson, M., & Domingos, P. (2006). Markov logic networks. Mach. Learn., 62(1-2), 107136.
Rosales, R., & Sclaroff, S. (1999). 3D trajectory recovery for tracking multiple objects and trajectory
guided recognition of actions. In Proceedings of the 6th Conference on Computer Vision and
Pattern Recognition (CVPR, pp. 21172123.
Southey, F., Loh, W., & Wilkinson, D. F. (2007). Inferring complex agent motions from partial trajectory observations. In Proceedings of the 20th International Joint Conference on Artificial
Intelligence (IJCAI), pp. 26312637.
Stone, L. D., Corwin, T. L., & Barlow, C. A. (1999). Bayesian Multiple Target Tracking (1st edition).
Artech House, Inc., Norwood, MA, USA.
Szeliski, R. (2010). Computer Vision: Algorithms and Applications. Springer-Verlag New York,
Inc., New York, NY, USA.
Tao, Y., Cheng, R., Xiao, X., Ngai, W. K., Kao, B., & Prabhakar, S. (2005). Indexing multidimensional uncertain data with arbitrary probability density functions. In Proceedings of
the 31st International Conference on Very Large Data Bases (VLDB), pp. 922933.
Thimm, M. (2013). Inconsistency measures for probabilistic logics. Artif. Intell., 197, 124.
Wolter, F., & Zakharyaschev, M. (2000). Spatio-temporal representation and reasoning based on
rcc-8. In Proceedings of the 7th International Conference on Principles of Knowledge Representation and Reasoning (KR), pp. 314.
797

fiPARISI & G RANT

Yaman, F., Nau, D. S., & Subrahmanian, V. S. (2004). A logic of motion. In Proceedings of the 9th
International Conference on Principles of Knowledge Representation and Reasoning (KR),
pp. 8594.
Yaman, F., Nau, D. S., & Subrahmanian, V. S. (2005a). Going far, logically. In Proceedings of the
19th International Joint Conference on Artificial Intelligence (IJCAI), pp. 615620.
Yaman, F., Nau, D. S., & Subrahmanian, V. (2005b). A motion closed world assumption. In Proceedings of the 19th International Joint Conference on Artificial Intelligence (IJCAI), pp.
621626.
Yang, B., Lu, H., & Jensen, C. S. (2010). Probabilistic threshold k nearest neighbor queries over
moving objects in symbolic indoor space. In Proceedings of the 13th International Conference on Extending Database Technology (EDBT), pp. 335346.
Yilmaz, A., Javed, O., & Shah, M. (2006). Object tracking: A survey. ACM Comput. Surv., 38(4).
Zhang, M., Chen, S., Jensen, C. S., Ooi, B. C., & Zhang, Z. (2009). Effectively indexing uncertain
moving objects for predictive queries. Proceedings of the VLDB Endowment (PVLDB), 2(1),
11981209.
Zheng, K., Trajcevski, G., Zhou, X., & Scheuermann, P. (2011). Probabilistic range queries for
uncertain trajectories on road networks. In Proceedings of the 14th International Conference
on Extending Database Technology (EDBT), pp. 283294.

798

fi