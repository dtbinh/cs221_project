Journal of Artificial Intelligence Research 46 (2013) 651686

Submitted 10/12; published 04/13

Description Logic Knowledge and Action Bases
Babak Bagheri Hariri
Diego Calvanese
Marco Montali

BAGHERI @ INF. UNIBZ . IT
CALVANESE @ INF. UNIBZ . IT
MONTALI @ INF. UNIBZ . IT

KRDB Research Centre for Knowledge and Data
Free University of Bozen-Bolzano
Piazza Domenicani 3, 39100 Bolzano, Italy

Giuseppe De Giacomo
Riccardo De Masellis
Paolo Felli

DEGIACOMO @ DIS . UNIROMA 1. IT
DEMASELLIS @ DIS . UNIROMA 1. IT
FELLI @ DIS . UNIROMA 1. IT

Dipartimento di Ingegneria Informatica Automatica e Gestionale
Sapienza Universita di Roma
Via Ariosto 25, 00185 Roma, Italy

Abstract
Description logic Knowledge and Action Bases (KAB) are a mechanism for providing both a
semantically rich representation of the information on the domain of interest in terms of a description logic knowledge base and actions to change such information over time, possibly introducing
new objects. We resort to a variant of DL-Lite where the unique name assumption is not enforced
and where equality between objects may be asserted and inferred. Actions are specified as sets
of conditional effects, where conditions are based on epistemic queries over the knowledge base
(TBox and ABox), and effects are expressed in terms of new ABoxes. In this setting, we address
verification of temporal properties expressed in a variant of first-order -calculus with quantification across states. Notably, we show decidability of verification, under a suitable restriction inspired
by the notion of weak acyclicity in data exchange.

1. Introduction
Recent work in business processes, services and databases is bringing forward the need of considering both data and processes as first-class citizens in process and service design (Nigam & Caswell,
2003; Bhattacharya, Gerede, Hull, Liu, & Su, 2007; Deutsch, Hull, Patrizi, & Vianu, 2009; Vianu,
2009; Meyer, Smirnov, & Weske, 2011). In particular, the so-called artifact-centric approaches,
which advocate a sort of middle ground between a conceptual formalization of dynamic systems
and their actual implementation, are promising to be effective in practice (Cohn & Hull, 2009). The
verification of temporal properties in the presence of data represents a significant research challenge (for a survey, see Calvanese, De Giacomo, & Montali, 2013), since taking into account how
data evolve over time results in systems that have an infinite number of states. Neither finite-state
model checking (Clarke, Grumberg, & Peled, 1999) nor most of the current techniques for infinitestate model checking, which mostly tackle recursion (Burkart, Caucal, Moller, & Steffen, 2001),
apply to this case. Recently, there have been some advancements on this issue (Cangialosi, De Giacomo, De Masellis, & Rosati, 2010; Damaggio, Deutsch, & Vianu, 2011; Bagheri Hariri, Calvanese,
De Giacomo, De Masellis, & Felli, 2011; Belardinelli, Lomuscio, & Patrizi, 2011), in the context
of suitably constrained relational database settings.
c
2013
AI Access Foundation. All rights reserved.

fiBAGHERI H ARIRI , C ALVANESE , D E G IACOMO , D E M ASELLIS , F ELLI , & M ONTALI

While most of this work is based on maintaining information in a relational database, for more
sophisticated applications it is foreseen to enrich data-intensive business processes with a semantic
level, where information can be maintained in a semantically rich knowledge base which allows for
operating with incomplete information (Calvanese, De Giacomo, Lembo, Montali, & Santoso, 2012;
Limonad, De Leenheer, Linehan, Hull, & Vaculin, 2012). This leads us to look into how to combine
first-order data, ontologies, and processes, while maintaining basic inference tasks (specifically
verification) decidable. In this setting, we capture the domain of interest in terms of semantically
rich formalisms as those provided by ontological languages based on Description Logics (DLs)
(Baader, Calvanese, McGuinness, Nardi, & Patel-Schneider, 2003). Such languages natively deal
with incomplete knowledge in the modeled domain. This additional flexibility comes with an added
cost, however: differently from relational databases, to evaluate queries we need to resort to logical
implication. Moreover, incomplete information combined with the ability of evolving the system
through actions results in a notoriously fragile setting w.r.t. decidability (Wolter & Zakharyaschev,
1999b, 1999a; Gabbay, Kurusz, Wolter, & Zakharyaschev, 2003). In particular, due to the nature
of DL assertions (which in general are not definitions but constraints on models), we get one of
the most difficult kinds of domain descriptions for reasoning about actions (Reiter, 2001), which
amounts to dealing with complex forms of state constraints (Lin & Reiter, 1994).
To overcome this difficulty, virtually all solutions that aim at robustness are based on a so-called
functional view of knowledge bases (Levesque, 1984): the KB provides the ability of querying
based on logical implication (ask), and the ability of progressing it to a new KB through forms
of updates (tell) (Baader, Ghilardi, & Lutz, 2012; Calvanese, De Giacomo, Lenzerini, & Rosati,
2011). Notice that this functional view is tightly related to an epistemic interpretation of the KB
(Calvanese, De Giacomo, Lembo, Lenzerini, & Rosati, 2007a). Indeed our work is also related to
that on Epistemic Dynamic Logic (van Ditmarsch, van der Hoek, & Kooi, 2007), and, though out of
the scope of this paper, the decidability results presented here could find application in the context
of that research as well.
We follow this functional view of KBs. However, a key point of our work is that at each execution step external information is incorporated into the system in form of new individuals (denoted
by function terms), that is, our systems are not closed w.r.t. the available information. This makes
our framework particularly interesting and challenging. In particular, the presence of these individuals requires a specific treatment of equality, since as the system progresses and new information is
acquired, distinct function terms may be inferred to denote the same object.
Specifically, we introduce the so-called Knowledge and Action Bases (KABs). A KAB is
equipped with an ontology or, more precisely, a TBox expressed, in our case, in a variant of DLLiteA (Calvanese, De Giacomo, Lembo, Lenzerini, & Rosati, 2007b), which extends the core of the
Web Ontology Language OWL 2 QL (Motik, Cuenca Grau, Horrocks, Wu, Fokoue, & Lutz, 2012)
and is particularly well suited for data management. Such a TBox captures intensional information
on the domain of interest, similarly to UML class diagrams or other conceptual data models, though
as a software component to be used at run-time. The KAB includes also an ABox, which acts as a
storage or state. The ABox maintains the data of interest, which are accessed by relying on query answering based on logical implication (certain answers). Notably, our variant of DL-LiteA is without
the unique name assumption (UNA), and we allow for explicit equality assertions in the ABox. In
this way we can suitably treat function terms to represent individuals acquired during the execution.
Technically, the need of dealing with equality breaks the first-order rewritability of DL-LiteA query
answering, and requires that, in addition to the rewriting process, inference on equality is performed
652

fiD ESCRIPTION L OGIC K NOWLEDGE AND ACTION BASES

(Artale, Calvanese, Kontchakov, & Zakharyaschev, 2009). As a query language, we use unions of
conjunctive queries, possibly composing their certain answers through full FOL constructs. This
gives rise to an epistemic query language that asks about what is known by the current KB (Calvanese et al., 2007a). Apart from the KB, the KAB contains actions, whose execution changes
the state of the KB, i.e., its ABox. Such actions are specified as sets of conditional effects, where
conditions are (epistemic) queries over the KB and effects are expressed in terms of new ABoxes.
Actions have no static pre-conditions, whereas a process is used to specify which actions can be
executed at each step. For simplicity, we model such processes as condition/action rules, where the
condition is again expressed as a query over the KB.
In this setting, we address the verification of temporal/dynamic properties expressed in a firstorder variant of -calculus (Park, 1976; Stirling, 2001), where atomic formulae are queries over
the KB which can refer both to constants and to function terms, and where a controlled form of
quantification across states is allowed. Notice that all previous decidability results on actions over
DL KBs assumed that no information is coming from outside of the system, in the sense that no
new individual terms are added while executing actions (Calvanese et al., 2011; Baader et al., 2012;
Rosati & Franconi, 2012). In this paper, instead, we allow for arbitrary introduction of new terms.
Unsurprisingly, we show that even for very simple KABs and temporal properties, verification is
undecidable. However, we also show that for a rich class of KABs, verification is in fact decidable
and reducible to finite-state model checking. To obtain this result, following Cangialosi et al. (2010),
and Bagheri Hariri et al. (2011), we rely on recent results in data exchange on the finiteness of the
chase of tuple-generating dependencies (Fagin, Kolaitis, Miller, & Popa, 2005), though, in our case,
we need to extend the approach to deal with (i) incomplete information, (ii) inference on equality,
and (iii) quantification across states in the verification language.
The paper is organized as follows. In Section 2 we give preliminaries about DL-LiteA without
UNA , which is going to be our knowledge base formalism. Section 3 describes the KAB framework in detail, while Section 4 discusses its execution semantics. In Section 5 we introduce the
verification formalism for KABs. In Section 6, we show that verification of KABs is in general undecidable, even considering very simple temporal properties and KABs. In Section 7, we give our
main technical result: verification of weakly acyclic KABs is decidable in E XP T IME. In Section 8,
we extensively survey related work. Section 9 concludes the paper.

2. Knowledge Base Formalism
Description Logics (DLs) (Baader et al., 2003) are knowledge representation formalisms that are
tailored for representing the domain of interest in terms of concepts (or classes), denoting sets of
objects, and roles (or relations), denoting binary relations between objects. DL knowledge bases
(KBs) are based on an alphabet of concept and role names, and an alphabet of individuals. A
DL KB is formed by two distinct parts: a TBox, which represents the intensional level of the KB
and contains a description of the domain of interest in terms of universal assertions over concepts
and roles; and an ABox, which represents the instance level of the KB and contains extensional
information on the participation of individuals to concepts and roles.
For expressing KBs we use DL-LiteNU , a variant of the DL-LiteA language (Poggi, Lembo,
Calvanese, De Giacomo, Lenzerini, & Rosati, 2008; Calvanese, De Giacomo, Lembo, Lenzerini, &
Rosati, 2013) in which we drop the unique name assumption (UNA) in line with the standard Web
Ontology Language (OWL 2) (Bao et al., 2012). Essentially, DL-LiteNU extends the OWL 2 QL
653

fiBAGHERI H ARIRI , C ALVANESE , D E G IACOMO , D E M ASELLIS , F ELLI , & M ONTALI

profile of OWL 2, by including functionality assertions and the possibility to state equality between
individuals.
The syntax of concept and role expressions in DL-LiteNU is as follows:
R  P | P  ,
V  R | R,

B  N | R,
C  B | B,

where N denotes a concept name, P a role name, and P  an inverse role.
Formally, in a DL-LiteNU KB (T, A), the TBox T is a finite set of TBox assertions of the form
B v C,

R v V,

(funct R),

called respectively concept inclusions, role inclusions, and functionality assertions. We follow
the usual assumption in DL-Lite, according to which a TBox may contain neither (funct P ) nor
(funct P  ) if it contains R v P or R v P  , for some role R (Poggi et al., 2008; Calvanese et al.,
2013). This condition expresses that roles in functionality assertions cannot be specialized.
DL-LiteNU TBoxes are able to capture the essential features of conceptual modeling formalisms,
such as UML Class Diagrams (or Entity-Relationship schemas), namely ISA between classes and
associations (relationships), disjointness between classes and between associations, typing of associations, and association multiplicities (in particular, mandatory participation and functionality).
The main missing feature is completeness of hierarchies, which would require the introduction of
disjunction and would compromise the good computational properties of DL-Lite.
The ABox A in a DL-LiteNU KB (T, A) is a finite set of ABox assertions of the form
N (t1 ),

P (t1 , t2 ),

t1 = t2 ,

called respectively, concept (membership) assertions, role (membership) assertions, and equality
assertions, where t1 , t2 are terms denoting individuals (see below). The presence of equality assertions in the ABox requires a specific treatment of equality that goes beyond the usual reasoning
techniques for DL-Lite based on first-order rewritability, although reasoning remains polynomial
(Artale et al., 2009). On the other hand, we do not allow for explicit disequality, though one can use
membership in disjoint concepts to assert that two individuals are different.
DL-LiteNU admits complex terms for denoting individuals. Such terms are inductively defined
by starting from a finite set of constants, and applying a finite set of (uninterpreted) functions of
various arity greater than 0. As a result, the set of individual terms is countably infinite. We
call function terms those terms involving functions. Also, the structure of terms has an impact on
inference over equality, which is a congruence relation on the structure of terms, i.e., if ti = t0i , for
i  {1, . . . , n}, and f is a function symbol of arity n, then f (t1 , . . . , tn ) = f (t01 , . . . , t0n ). Apart
from this aspect related to equality, we can treat individuals denoted by terms simply as ordinary
individual constants in DLs.
We adopt the standard semantics of DLs based on FOL interpretations I = (I , I ), where I
is the interpretation domain and I is the interpretation function such that tI  I , N I  I , and
P I  I I , for each term t,concept name N , and role name P . Coherently with the congruence
relation on terms, we have that (f (t1 , . . . , tn ))I = (f (t01 , . . . , t0n ))I , whenever tIi = t0i I , for i 
{1, . . . , n}.
Complex concepts and roles are interpreted as follows:
(R)I
(B)I

= {o | o0 .(o, o0 )  RI },
= I \ B I ,

(P  )I
(R)I
654

= {(o1 , o2 ) | (o2 , o1 )  P I },
=  I  I \ R I .

fiD ESCRIPTION L OGIC K NOWLEDGE AND ACTION BASES

An interpretation I satisfies an assertion of the form:
 B v C, if B I  C I ;
 R v V , if RI  V I ;
 (funct R), if for all o, o1 , o2 we have that, if {(o, o1 ), (o, o2 )}  RI , then o1 = o2 ;
 N (t1 ), if tI1  N I ;
 P (t1 , t2 ), if (tI1 , tI2 )  P I ;
 t1 = t2 , if tI1 = tI2 .
I is a model of a KB (T, A) if it satisfies all assertions in T and A. KB (T, A) is satisfiable if it has
a model. We also say that an ABox A is consistent w.r.t. a TBox T if the KB (T, A) is satisfiable.
An assertion  is logically implied by a KB (T, A), denoted (T, A) |= , if every model of (T, A)
satisfies  as well.
The following characterization of satisfiability and logical implication in DL-LiteNU is an easy
consequence of results by Artale et al. (2009).
Theorem 1 Checking satisfiability and logical implication in DL-LiteNU are PT IME-complete.
Proof. The PT IME lower bound is an immediate consequence of the same lower bound established
by Artale et al. (2009) for DL-LiteNU in which we do not allow the use of complex individual terms.
For the upper bound, Artale et al. (2009) provide a PT IME algorithm that is based on first using
functionality assertions to exhaustively propagate equality, and then resorting to a PT IME algorithm
(in combined complexity) for reasoning in DL-Lite in the absence of UNA. We can adapt that
algorithm by changing the first step, so as to propagate, again in PT IME, equality over terms in the
active domain not only due to functionalities, but also due to congruence.
Next we introduce queries. As usual (cf. OWL 2), answers to queries are formed by constants/terms denoting individuals explicitly mentioned in the ABox. The (active) domain of an
ABox A, denoted by ADOM(A), is the (finite) set of constants/terms appearing in concept, role, and
equality assertions in A. The (predicate) alphabet of a KB (T, A), denoted ALPH((T, A)) is the set
of concept and role names occurring in T  A.
A union of conjunctive queries (UCQ) q over a KB (T, A) is a FOL formula of the form
~y1 .conj 1 (~x, ~y1 )      ~yn .conj n (~x, ~yn ) with free variables ~x and existentially quantified variables ~y1 , . . . , ~yn . Each conj i (~x, y~i ) in q is a conjunction of atoms of the form N (z), P (z, z 0 ) where
N and P respectively denote a concept and a role name occurring in ALPH((T, A)), and z, z 0 are
constants in ADOM(A) or variables in ~x or y~i , for some i  {1, . . . , n}. The certain answers to q
over (T, A) is the set ANS (q, T, A) of substitutions1  of the free variables of q with constants/terms
in ADOM(A) such that q evaluates to true in every model of (T, A), i.e., q is logically implied by
(T, A). Following the notation used for assertions, we denote this as (T, A) |= q. If q has no free
variables, then it is called boolean and its certain answers are either the empty substitution denoting
true or nothing denoting false.
Again, as an easy consequence of the results by Artale et al. (2009), we obtain the following
characterization of query answering in DL-LiteNU .
Theorem 2 Computing ANS (q, T, A) of an UCQ q over a DL-LiteNU KB (T, A) is PT IME-complete
in the size of T and A.
1. As customary, we can view each substitution simply as a tuple of constants, assuming some ordering of the free
variables of q.

655

fiBAGHERI H ARIRI , C ALVANESE , D E G IACOMO , D E M ASELLIS , F ELLI , & M ONTALI

Proof. As in the proof of Theorem 1, we can first propagate in PT IME equality over terms in the
active domain by using functionality and congruence closure, and then resort to query answering in
DL-Lite in the presence of UNA, which is in PT IME in the combined size of the TBox T and the
ABox resulting from the above equality propagation (actually, in AC0 in the size of this ABox).
We also consider an extension of UCQs, called ECQs, which are queries of the query language
EQL-Lite(UCQ) (Calvanese et al., 2007a), that is, the FOL query language whose atoms are UCQs
evaluated according to the certain answer semantics above. An ECQ over a KB (T, A) is a possibly
open formula of the form
Q  [q] | [x = y] | Q | Q1  Q2 | x.Q,
where [q] denotes the certain answers of a UCQ q over (T, A), [x = y] denotes the certain answers
of x = y over (T, A), that is, the set {hx, yi  ADOM(A) | (T, A) |= (x = y)}, logical operators
have the usual meaning, and quantification ranges over elements of ADOM(A).
Formally we define the relation Q holds in (T, A) under substitution  of all free variables in
Q, written T, A,  |= Q, inductively as follows:
T, A, 
T, A, 
T, A, 
T, A, 
T, A, 

|= [q]
|= [x = y]
|= Q
|= Q1  Q2
|= x.Q

if
if
if
if
if

(T, A) |= q,
(T, A) |= (x = y),
T, A,  6|= Q,
T, A,  |= Q1 and T, A,  |= Q2 ,
exists t  ADOM(A) such that T, A, [x/t] |= Q,

where [x/t] denotes the substitution obtained from  by assigning to x the constant/term t (if x is
already present in  its value is replaced by t, if not, the pair x/t is added to the substitution).
The certain answer to Q over (T, A), denoted ANS (Q, T, A), is the set of substitutions  for the
free variables in Q such that Q holds in (T, A) under , i.e.,
ANS (Q, T, A)

= { | T, A,  |= Q}.

Following the line of the proof by Calvanese et al. (2007a), but considering Theorem 2 for the
basic step of evaluating an UCQ, we get:
Theorem 3 Computing ANS (Q, T, A) of an ECQ Q over a DL-LiteNU KB (T, A) is PT IMEcomplete in the size of T and A.
We recall that DL-Lite enjoys a rewritability property, which states that for every UCQ q and
for every DL-Lite KB (T, A),
ANS (q, T, A)

= ANS (rew T (q), , A),

where rew T (q) is a UCQ computed by the reformulation algorithm of Calvanese et al. (2007b).
Notice that, in this way, we have compiled away the TBox. This result can be extended to ECQs
as well, i.e., for every ECQ Q, ANS (Q, T, A) = ANS (rew T (Q), , A) where the query rew T (Q) is
obtained from Q by substituting each atom [q] (where q is an UCQ) by [rew T (q)] (Calvanese et al.,
2007a). In our setting, we can again exploit rewritability, but only after having pre-processed the
ABox (in PT IME) by propagating equalities between individual terms in ADOM(A) according to
functionality assertions and congruence of terms.
656

fiD ESCRIPTION L OGIC K NOWLEDGE AND ACTION BASES

We say that two ABoxes A1 and A2 are equivalent w.r.t. TBox T and predicate alphabet ,
denoted by
A1 T, A2 ,
if for every ABox assertion 2  A2 which is either a concept assertion N (t) with N  , role
assertion P (t1 , t2 ) with P  , or equivalence assertion t1 = t2 , we have (T, A1 ) |= 2 ; and viceversa, for every ABox assertion 1  A1 , which is either a concept assertion N (t) with N  ,
role assertion P (t1 , t2 ) with P  , or equivalence assertion t1 = t2 , we have (T, A2 ) |= 1 .
Notice that if A1 T, A2 , then for every ECQ Q whose concept and role names belong to  we
have that ANS (Q, T, A1 ) = ANS (Q, T, A2 ). Notice also that, by applying Theorem 3 to the boolean
query [] corresponding to the ABox assertion , for each  in A1 and A2 , we obtain that ABox
equivalence can be checked in PT IME.

3. Knowledge and Action Bases
A Knowledge and Action Base (KAB) is a tuple K = (T, A0 , , ) where T and A0 form the
knowledge component (or knowledge base), and  and  form the action component (or action
base). In practice, K stores the information of interest into a KB, formed by a fixed TBox T and
an initial ABox A0 , which evolves by executing actions  according to the sequencing established
by process . During the evolution new individuals can be acquired by the KB. Such individuals
are witnesses of new pieces of information inserted into the KAB from the environment the KAB
runs in (i.e., the external world). We represent these new objects as function terms. As the KAB
evolves, the identity of individuals should be intuitively preserved and this induces the necessity of
remembering equalities between terms denoting individuals discovered in the past. We describe in
detail the components of the KAB.
3.1 TBox
T is a DL-LiteNU TBox, used to capture the intensional knowledge about the domain of interest.
Such a TBox is fixed once and for all, and does not evolve during the execution of the KAB.
3.2 ABox
A0 is a DL-LiteNU ABox, which stores the extensional information of interest. Notice that A0 is
the ABox of the initial state of the KAB, and as the KAB evolves due to the effect of actions, the
ABox, which is indeed the state of the system, evolves accordingly to store up-to-date information.
Through actions we acquire new information from the external world by using calls to external
services represented through functions. Given that we have no information about these services,
except for their name and the parameters that are passed to them, the functions remain uninterpreted.
We only assume that the result of such service calls depends only on the passed parameters. Hence,
we represent the new individuals returned by service calls as function terms. The presence of
function terms has an impact on the treatment of equality, since in principle we need to close equality
w.r.t. congruence. While this closure generates an infinite number of logically implied equality
assertions, we are going to keep such assertions implicit, computing them only when needed.
657

fiBAGHERI H ARIRI , C ALVANESE , D E G IACOMO , D E M ASELLIS , F ELLI , & M ONTALI

3.3 Actions
 is a finite set of actions. An action    modifies the current ABox A by adding or deleting
assertions, thus generating a new ABox A0 . An action  has the form
act(~x) : {e1 , . . . , en },
where act(~x) is the signature of  and {e1 , . . . , en } is a (finite) set of effects forming the effect
specification of . The action signature is constituted by a name act and a list ~x of individual input
parameters, which need to be instantiated with actual individuals at execution time.2 An effect ei
has the form
[qi+ ]  Q
A0i ,
(1)
i
where
 qi+ is an UCQ, i.e., a positive query, which extracts the bulk data to process (obtained as the
certain answers of qi+ ); the free variables of qi+ include the action parameters;
+
 Q
i is an arbitrary ECQ, whose free variables occur all among the free variables of qi , which
refines, by using negation and quantification, the result of qi+ . The query [qi+ ]  Q
i as a
whole extracts individual terms to be used to form the new state of the KAB (notice that the
UCQ-ECQ division is also a convenience to have readily available the positive part of the
condition, which we will exploit later);

 A0i is a set of (non-ground) ABox assertions, which include as terms: constants in A0 , free
variables of qi+ , and function terms f (~x) having as arguments ~x free variables of qi+ . These
terms, once grounded with the values extracted from [qi+ ]  Q
i , give rise to (ground) ABox
assertions, which contribute to form the next state of the KAB.
More precisely, given the current ABox A of K and a substitution  for the input parameters of the
action , we denote by  the action instantiated with the actual parameters coming from . By
firing  on the state A, we get a new state A0 which is computed by simultaneously applying all
instantiated effects of  as follows:
 Each effect ei in  of form (1) extracts from A the set ANS (([qi+ ]  Q
i ), T, A) of tuples of
terms in ADOM(A) and, for each such tuple , asserts a set A0i  of ABox assertions obtained
from A0i  by applying the substitution  for the free variables of qi+ . For each function term
f (~x) appearing in A0i , a new ground term is introduced having the form f (~x). These
terms represent new constants coming from the external environment the KAB is running
in.
We denote by ei (A) the overall set of ABox assertions, i.e.,
[

ei (A) =

A0i .

ANS (([qi+ ]Q
i ),T,A)

2. We disregard a specific treatment of output parameters, and assume instead that the user can freely pose queries over
the KB, extracting whatever information she/he is interested in.

658

fiD ESCRIPTION L OGIC K NOWLEDGE AND ACTION BASES

 Moreover, let EQ(T, A) = {t1 = t2 | ht1 , t2 i  ANS ([x1 = x2 ], T, A)}. Observe that, due
to the semantics of queries, the terms in EQ(T, A) must appear explicitly in ADOM(A), that
is, the possibly infinite number of equalities due to congruence do not appear in EQ(T, A),
though they are logically implied. Hence, the equalities in EQ(T, A) are the equality assertions involving terms in ADOM(A) that either appear explicitly in A, or are obtained by
closing these under functionality and congruence of terms.
The overall effect of the action  with parameter substitution  over A is the new ABox A0 =
DO (T, A, ) where
[
ei (A).
DO (T, A, ) = EQ(T, A) 
1in

Notice that the presence of function terms in action effects makes the domain of the ABoxes obtained by executing actions continuously changing and in general unbounded in size. Notice also
that we do have a persistence assumption on equalities, i.e., we implicitly copy all equalities holding in the current state to the new one. This implies that, as the system evolves, we acquire new
information on equalities between terms, but never lose information on equalities already acquired.
Finally, we observe that in the above execution mechanism no persistence/frame assumption (except for equality) is made. In principle at every move we substitute the whole old state, i.e., ABox,
with a new one. On the other hand, it should be clear that we can easily write effect specifications
that copy big chunks of the old state into the new one. For example, [P (x, y)]
P (x, y) copies
the entire set of assertions involving the role P . In some sense, the execution mechanism adopted
in this paper is very basic and does not address any of the elaboration tolerance issues typical of
reasoning about actions, such as the frame problem, ramification problem or qualification problem
(Reiter, 2001)3 . This is not because we consider them irrelevant, on the contrary, they are relevant
and further research on such issues is desirable. We adopt this basic mechanism simply because
it is general enough to expose all difficulties we need to overcome in order to get decidability of
verification in this setting.
3.4 Process
The process component of a KAB is a possibly nondeterministic program that uses the KAB ABoxes
to store its (intermediate and final) computation results, and the actions in  as atomic instructions.
The ABoxes can be arbitrarily queried through the KAB TBox T , while they can be updated only
through actions in . To specify such a process component we adopt a rule-based specification.
Specifically, a process is a finite set  of condition/action rules. A condition/action rule   
is an expression of the form
Q 7 ,
where  is an action in  and Q is an ECQ, whose free variables are exactly the parameters of
. The rule expresses that, for each tuple  for which condition Q holds, the action  with actual
parameters  can be executed. Processes do not force the execution of actions but constrain them:
the user of the process will be able to choose any action that the rules forming the process allow.
Moreover, our processes inherit entirely their states from the KAB knowledge component (TBox
and ABox) (see, e.g., Cohn & Hull, 2009).
3. But see also the work by Kowalski and Sadri (2011).

659

fiBAGHERI H ARIRI , C ALVANESE , D E G IACOMO , D E M ASELLIS , F ELLI , & M ONTALI

Villain v Character
livesIn v Character
livesIn v City
Character v livesIn
(funct livesIn)
enemy v Villain
enemy v Superhero
defeated v Villain
defeated v Superhero
defeated v enemy
alterEgo v Superhero
alterEgo v Character
(funct alterEgo)

0..1

alterEgo
enemy

Superhero

Character

1..1

livesIn

City

Villain

{subset}
defeated

Figure 1: KABs TBox for Example 1
We observe that we adopt a basic rule-based specification here because, in spite of its simplicity,
it is able to expose all the difficulties of our setting. Other choices are also possible, in particular,
the process could maintain its own state besides the one of the KAB. As long as such an additional
state is finite, or embeddable into the KAB itself, the results here would easily extend to such a case.
Example 1 Let us consider a KAB K = (T, A0 , , ) describing a super-heroes comics world,
where we have cities in which characters live. Figure 1 shows the TBox T and its rendering as a
UML Class Diagram. For the relationship between UML Class Diagrams and Description Logics
in general and DL-Lite in particular, we refer to the work by Berardi, Calvanese, and De Giacomo
(2005) and by Calvanese, De Giacomo, Lembo, Lenzerini, Poggi, Rodrguez-Muro, and Rosati
(2009). As for the dynamics of the domain, characters can be superheroes or (super)villains, who
fight each other. As in the most classic plot, superheroes help the endeavors of law enforcement
fighting villains threatening the city they live in. When a villain reveals himself for perpetrating
his nefarious purposes against the citys peace, he consequently becomes a declared enemy of all
superheroes living in that city. Each character lives in one city at the time. A common trait of
superheroes is a secret identity: a superhero is said to be the alter ego of some character, which is
his identity in common life. Hence, the ABox assertion alterEgo(s, p) means that the superhero s is
the alter ego of character p. Villains always try to unmask superheroes, i.e., find their secret identity,
in order to exploit such a knowledge to defeat them. Notice the subtle difference here: we use the
alterEgo(s, p) assertion to model the fact that s is the alter ego of p, whereas only by asserting s = p
we can capture the knowledge that s and p semantically denote the same individual.  may include
actions like the following ones:
BecomeSH(p, c) : { [Character(p)  livesIn(p, c)  v.Villain(v)  livesIn(v, c)]
{Superhero(sh(p)), alterEgo(sh(p), p)},
CopyAll }
states that if there exists at least one villain living in the city c, a new superhero sh(p) can be created,
with the purpose of protecting c. Such a superhero has p as alter ego. CopyAll is a shortcut for
explicitly copying all concept and role assertions to the new state (equality assertions are always
660

fiD ESCRIPTION L OGIC K NOWLEDGE AND ACTION BASES

implicitly copied). Action
Unmask(s, p) : { [alterEgo(s, p)]
CopyAll }

{s = p},

states that superhero s, who is the alter ego of p, gets unmasked by asserting the equality between s
and p (it is now known that s = p). Action
Fight(v, s) : { p.[Villain(v)  Character(p)  alterEgo(s, p)]  [s = p]
CopyAll }

{defeated(v, s)},

states that when villain v fights superhero s, he defeats s if s has been unmasked, i.e., it is known
that s is equal to his alter ego. Action
Challenge(v, s) :
{ [Villain(v)  Superhero(s)  p.alterEgo(s, p)  livesIn(p, sc)]  [defeated(v, s)]
{livesIn(v, sc), enemy(v, s)},
CopyAll }
states that when villain v challenges superhero s and has not defeated him, next he lives in the same
city as s and is an enemy of s. Action
ThreatenCity(v, c) :
{ [Villain(v)  Superhero(s)  p.alterEgo(s, p)  livesIn(p, c)]
{enemy(v, s)  livesIn(v, c)}
CopyAll }
states that when villain v threatens city c, then he becomes an enemy of all and only superheroes
that live in c.
A process  might include the following rules:
[Character(p)]  [s.Superhero(s)  livesIn(s, c)]
[Superhero(s)  Character(c)]
[enemy(v, s)]  [v 0 .defeated(v 0 , s)]
[Villain(v)  Superhero(s)]
[Villain(v)  City(c)]  v 0 ([Villain(v 0 )  livesIn(v 0 , c)]  [v = v 0 ])

7
7

7
7
7

BecomeSH(p, c),
Unmask(s, c),
Fight(v, s),
Challenge(v, s),
ThreatenCity(v, c).

For instance, the first rule states that a character can become a superhero if the city does not already
have one, whereas the last one states that a villain can threaten a city, if the city does not have
another villain that is (known to be) distinct from him/her.
Notice that, during the execution, reasoning on the KB is performed. For instance, consider an
initial ABox
A0 = { Superhero(batman), Villain(joker), alterEgo(batman, bruce),
livesIn(bruce, gotham), livesIn(batman, gotham), livesIn(joker, city1) }.
In this state, bruce and batman live in the same city, and batman is the alter-ego of bruce, but it is not
known whether they denote the same individual. Executing Challenge(joker, batman) in A0 , which
is indeed allowed by the process , generates a new ABox with added assertions enemy(joker,
batman), livesIn(joker, gotham), and gotham = city1 is implied by the functionality on livesIn.

661

fiBAGHERI H ARIRI , C ALVANESE , D E G IACOMO , D E M ASELLIS , F ELLI , & M ONTALI

4. KAB Transition System
The semantics of KABs is given in terms of possibly infinite transition systems that represent the
possible evolutions of the KAB over time, as actions are executed according to the process. Notice
that such transition systems must be equipped with semantically rich states, since a full KB is associated to them. Formally we define the kind of transition system we need as follows: A transition
system  is a tuple of the form (U, T, , s0 , abox , ), where:
 U is a countably infinite set of terms denoting individuals, called universe;
 T is a TBox;
  is a set of states;
 s0   is the initial state;
 abox is a function that, given a state s   returns an ABox associated to s which has as
individuals terms of U, and which conforms to T ;
      is a transition relation between pairs of states.
For convenience,
S we introduce the active domain of the whole transition system, defined as
ADOM () = s ADOM (abox (s)). Also we introduce the (predicate) alphabet ALPH () of  as
the set of concepts and roles occurring in T or in the co-domain of abox .
The KAB generates a transition system of this form during its execution. Formally, given a
KAB K = (T, A0 , , ), we define its (generated) transition system K = (U, T, , s0 , abox , )
as follows:
 U is formed by all constants and all function terms inductively formed starting from
ADOM (A0 ) by applying the functions occurring in the actions in ;
 T is the TBox of the KAB;
 abox is the identity function (i.e., each state is simply an ABox);
 s0 = A0 is the initial state;
  and  are defined by mutual induction as the smallest sets satisfying the following property: if s  , then for each rule Q 7 , evaluate Q and, for each tuple  returned, if
DO (T, abox (s), ) is consistent w.r.t. T , then s  s0 where s0 = DO (T, abox (s), ).
Notice that the alphabet ALPH(K ) of K is simply formed by the set ALPH(K) of concepts and
roles that occur in K.
The KAB transition system K is an infinite tree with infinitely many different ABoxes in
its nodes, in general. In fact, to get a transition system that is infinite, it is enough to perform
indefinitely a simple action that adds new terms at each step, e.g., an action of the form
() : { [C(x)]

{C(f (x))}, CopyAll }.

Hence the classical results on model checking (Clarke et al., 1999), which are developed for finite
transition systems, cannot be applied directly for verifying KABs.
662

fiD ESCRIPTION L OGIC K NOWLEDGE AND ACTION BASES

5. Verification Formalism
To specify dynamic properties over KABs, we use a first-order variant of -calculus (Stirling, 2001;
Park, 1976). -calculus is virtually the most powerful temporal logic used for model checking of
finite-state transition systems, and is able to express both linear time logics such as LTL and PSL,
and branching time logics such as CTL and CTL* (Clarke et al., 1999). The main characteristic of
-calculus is its ability of expressing directly least and greatest fixpoints of (predicate-transformer)
operators formed using formulae relating the current state to the next one. By using such fixpoint
constructs one can easily express sophisticated properties defined by induction or co-induction.
This is the reason why virtually all logics used in verification can be considered as fragments of
-calculus. Technically, -calculus separates local properties, asserted on the current state or on
states that are immediate successors of the current one, from properties talking about states that are
arbitrarily far away from the current one (Stirling, 2001). The latter are expressed through the use
of fixpoints.
In this work, we use a first-order variant of -calculus, where we allow local properties to be
expressed as ECQs, and at the same time we allow for arbitrary first-order quantification across
states. Given the nature of ECQs used for formulating local properties, first-order quantification
ranges over terms denoting individuals. Formally, we introduce the logic LA defined as follows:
  Q |  | 1  2 | x. | hi | Z | Z.,
where Q is a possibly open ECQ and Z is a second order predicate variable (of arity 0). We make use
of the following abbreviations: x. = (x.), 1  2 = (1  2 ), [] = hi,
and Z. = Z.[Z/Z]. The formulae Z. and Z. respectively denote the least and
greatest fixpoint of the formula  (seen as the predicate transformer Z.). As usual in -calculus,
formulae of the form Z. (and Z.) must obey to the syntactic monotonicity of  w.r.t. Z, which
states that every occurrence of the variable Z in  must be within the scope of an even number of
negation symbols. This ensures that the least fixpoint Z. (as well as the greatest fixpoint Z.)
always exists.
The semantics of LA formulae is defined over possibly infinite transition systems of the form
hU, T, , s0 , abox , i seen above. Since LA also contains formulae with both individual and
predicate free variables, given a transition system , we introduce an individual variable valuation
v, i.e., a mapping from individual variables x to U, and a predicate variable valuation V , i.e., a
mapping from the predicate variables Z to subsets of . With these three notions in place, we
assign meaning to formulae by associating to , v, and V an extension function ()
v,V , which maps

formulae to subsets of . Formally, the extension function ()v,V is defined inductively as follows:
(Q)
v,V
()
v,V
(1  2 )
v,V
(x.)
v,V
(hi)
v,V
(Z)
v,V
(Z.)
v,V

=
=
=
=
=
=
=

{s   | ANS (Qv, T, abox (s)) = true},
 \ ()
v,V ,

(1 )
v,V  (2 )v,V ,
{s   | t.t  ADOM(abox (s)) and s  ()
v[x/t],V },

0
0
0
{s   | s .s  s and s  ()v,V },
V (Z),
T
{E   | ()
v,V [Z/E]  E}.

Here Qv stands for the (boolean) ECQ obtained from Q by substituting its free variables according
to v. Intuitively, ()
v,V assigns to such constructs the following meaning:
663

fiBAGHERI H ARIRI , C ALVANESE , D E G IACOMO , D E M ASELLIS , F ELLI , & M ONTALI

 The boolean connectives have the expected meaning.
 The quantification of individuals is done over the terms of the current ABox. Notice that
such terms can be referred in later states where the associated ABox does not include such
terms anymore.
 The extension of hi consists of the states s such that, for some state s0 with transition
s  s0 , the formula  holds in s0 under valuation v .
 The extension of [] consists of the states s such that, for all states s0 with transition s  s0 ,
the formula  holds in s0 under valuation v.
 The extension of Z. is the smallest subset E of  such that, when assigning to Z the
extension E , the resulting extension of  (under valuation v) is contained in E . That is, the
extension of Z. is the least fixpoint of the operator ()
v,V [Z/E] , where V [Z/E] denotes the
predicate valuation obtained from V by forcing the valuation of Z to be E.
 Similarly, the extension of Z. is the greatest subset E of  such that, when assigning to
Z the extension E , the resulting extension of  contains E . That is, the extension
of Z.
S

=
{E

|E 
.
Formally,
(Z.)
is the greatest fixpoint of the operator ()
v,V
v,V [Z/E]
()
v,V [Z/E] }.
When  is a closed formula, ()
v,V does not depend on v or V , and we denote the extension of 

simply by () . A closed formula  holds in a state s   if s  () . In this case, we write
, s |= . A closed formula  holds in , denoted by  |= , if , s0 |= . We call model
checking the problem of verifying whether  |=  holds.
The next example shows some simple temporal properties that can be expressed in LA .
Example 2 Considering the KAB of Example 1, we can easily express temporal properties as the
following ones.
 From now on all current superheroes that live in Gotham will live in Gotham forever (a form
of safety):
x.[Superhero(x)  livesIn(x, gotham)]  Z.([livesIn(x, gotham)]  []Z).
 Eventually all current superheroes will be unmasked (a form of liveness):
x.[Superhero(x)]  Z.([alterEgo(x, x)]  []Z).
 There exists a possible future situation where all current superheroes will be unmasked (another form of liveness):
x.[Superhero(x)]  Z.([alterEgo(x, x)]  hiZ).
 Along every future, it is always true, for every superhero, that there exists an evolution that
eventually leads to unmask him (a form of liveness that holds in every moment):
Y.(x.[Superhero(x)]  Z.([alterEgo(x, x)]  hiZ))  []Y.
664

fiD ESCRIPTION L OGIC K NOWLEDGE AND ACTION BASES

Consider two transition systems sharing the same universe and the same predicate alphabet.
We say that they are behaviorally equivalent if they satisfy exactly the same LA formulas. To
formally capture such an equivalence, we make use of the notion of bisimulation (Milner, 1971),
suitably extended to deal with query answering over KBs.
Given two transition systems 1
=
hU, T, 1 , s01 , abox 1 , 1 i and 2
=
hU, T, 2 , s02 , abox 2 , 2 i sharing the same universe U, the same TBox T , and such that
ALPH (1 ) = ALPH (2 ) = , a bisimulation between 1 and 2 is a relation B  1  2 such
that (s1 , s2 )  B implies that:
1. abox (s1 ) T, abox (s2 );
2. if s1 1 s01 , then there exists s02 such that s2 2 s02 and (s01 , s02 )  B;
3. if s2 2 s02 , then there exists s01 such that s1 1 s01 and (s01 , s02 )  B.
We say that two states s1 and s2 are bisimilar if there exists a bisimulation B such that (s1 , s2 ) 
B. Two transition systems 1 with initial state s01 and 2 with initial state s02 are bisimilar if
(s01 , s02 )  B. The following theorem states that the formula evaluation in LA is indeed invariant
w.r.t. bisimulation, so we can equivalently check any bisimilar transition systems.
Theorem 4 Let 1 and 2 be two transition systems that share the same universe, the same TBox,
and the same predicate alphabet, and that are bisimilar. Then, for two states s1 of 1 and s2 of 2
(including the initial ones) that are bisimilar, and for all closed LA formulas , we have that
s1  ()1

iff

s2  ()2 .

Proof. The proof is analogous to the standard proof of bisimulation invariance of -calculus (Stirling, 2001), though taking into account our bisimulation, which guarantees that ECQs are evaluated
identically over bisimilar states. Notice that the assumption that the two transition systems share the
same universe and the same predicate alphabet makes it easy to compare the answers to queries.
Making use of such a notion of bisimulation, we can, for example, redefine the transition system
generated by a KAB K = (T, A0 , , ) while maintaining bisimilarity, by modifying the definition
of K = hU, T, , s0 , abox , i given in Section 4 as follows.
(i) We modify DO() so that no function term t0 is introduced in the generated ABox A0 if in the
current ABox4 A there is already a term t such that (T, A) |= t = t0 .
(ii) If the ABox A0 = DO(T, abox (s), ) obtained from the current state s is logically equivalent
to the ABox abox (s00 ), for some already generate state s00 , we do not generate a new state, but
simply add s  s00 to K .

6. Verification of KABs
It is immediate to see that verification of KABs is undecidable in general as it is easy to represent
Turing machines using a KAB. Actually we can do so using only a fragment of the capabilities of
KABs, as shown in the next lemma.
Lemma 5 Checking formulas of the form Z.(N (a)  hiZ), where N is an atomic concept and
a is an individual occurring in A0 , is undecidable already for a KAB K = (T, A0 , , ) where:
4. Note that all terms that are present in the current ABox are preserved in the new ABox, together with equalities
between terms.

665

fiBAGHERI H ARIRI , C ALVANESE , D E G IACOMO , D E M ASELLIS , F ELLI , & M ONTALI

{First(c)}
{value(c, x)}
{value(c, av0 )}
{cell(cr , aq0 )}
{cell(n(c), aq0 ), next(c, n(c)), Last(n(c))}
{Last(c)}
{cell(c, #)}
{cell(cr , #)}
{Stop(0)}

[First(c)]
[cell(c, #)  value(c, x)]
[cell(c, aq )  value(c, av )]
[cell(c, aq )  value(c, av )  next(c, cr )]
[cell(c, aq )  value(c, av )  Last(c)]
[cell(c, #)  Last(c)]
[cell(c, #)  First(c)]
[cell(c, #)  next(c, cr )]
[cell(c, aqf )]

Figure 2: Effects of the action used to encode a transition (q, v, q 0 , v 0 , R) of a Turing Machine
 T is the empty TBox,
 the actions in  make no use of negation nor equality,
  is the trivial process that poses no restriction on executability of actions.
Proof. Given a Turing machine M = hQ, , q0 , , qf , i, we show how to construct a corresponding
KAB KM = (, A0 , , ) that mimics the behavior of M. Specifically, we encode the halting
problem for M as a verification problem over KM . Roughly speaking, KM maintains the tape
and state information in the (current) ABox, and encodes the transitions of M as actions. Our
construction makes use of a tape that initially contains a unique cell, represented by the constant
0, and is extended on-the-fly as needed: cells to the right of 0 are represented by function terms of
the form n(n(   (0)    )), while cells to the left of 0 are represented by function terms of the form
p(p(   (0)    )). Then, we make use of one constant aq for each state q  Q, of one constant av
for each tape symbol value v  , of a special constant #, and of the following concepts and roles:
 cell(c, h) models a cell of the tape, where c is a cell identifier, and h corresponds to the current
state of M, if the head of M currently points to c, or to # if the head does not currently point
to c;
 next(cl , cr ) models the relative position of cells, stating that cr is the cell immediately following cl ;
 value(c, v) models that cell c currently contains value v, with v  ;
 First(c) and Last(c) respectively denote the current first cell and last cell of the portion of
tape explored so far.
 Stop(c) is used to detect when M halts.
The initial state of KM contains a unique cell and is defined as
A0 = { cell(0, aq0 ), value(0, a ), First(0), Last(0) }.
As for the action component,  contains an action with no parameters for each transition in , while
the process  poses no restriction on executability of actions, i.e., it contains a rule true 7 () for
each such action .
We now provide the specification of actions, detailing the case of a right shift transition
(q, v, q 0 , v 0 , R). The corresponding action specification consists of the set of effects shown in
Figure 2. The first effect maintains the first position of the tape unaltered. The second and third
666

fiD ESCRIPTION L OGIC K NOWLEDGE AND ACTION BASES

effects deal with the cell values. They remain the same except for the current cell, that is updated
according to the transition. The next three effects deal with the right shift and the Turing Machine
state. If the current cell has a next cell and therefore is not the last one, then the head is moved
to the next cell and the state change of M is recorded there. In this case the last cell remains the
same. If instead the current cell is the last one, before moving the head the tape must be properly
extended. The function n/1 is used to create the identifier of this new successor cell, starting from
the identifier of the current one. Furthermore, since the transition corresponds to a right shift of one
cell, the first cell and all the cells immediately following a cell marked # will be marked # in the
next state. Finally, the last effect is used to identify the case in which M has reached a final state.
This is marked by inserting into the new state the special assertion Stop(0).
The construction for a left shift transition is done symmetrically, using the function p/1 to create
a new predecessor cell. By construction, KM satisfies the conditions of the theorem. Observe that,
in the transition system KM generated by KM , every action corresponding to every transition of
M can be executed in each ABox/state s of KM , and since T is empty, it will actually generate a
successor state of s. However, in each state, only the (unique) action that corresponds to the actually
executed transition of M will generate a successor state containing an ABox assertion of the form
cell(c, aq ), for some state q of M. Therefore, only those ABoxes/states properly corresponding to
configurations of M could eventually lead to an ABox/state in KM where Stop(0) holds. And the
latter will happen if and only if M halts. More precisely, one can show by induction on the length
respectively of a halting computation of M and of the shortest path from the initial state of KM
to a state where Stop(0) holds, that M halts if and only if KM |= Z.([Stop(0)]  hiZ), which
concludes the proof.
From the previous lemma, which shows undecidability already in a special case, we immediately
obtain the following result.
Theorem 6 Verification of LA formulae over KABs is undecidable.
We observe that Lemma 5 uses a KB that is constituted only by an ABox containing concept
and role assertions, and makes use only of conjunctive queries in defining actions effects. Moreover, the formula that we check makes no use of quantification at all, and can simply be seen as a
propositional CTL formula of the form EF p, expressing that proposition p eventually holds along
one path.

7. Verification of Weakly Acyclic KABs
In spite of Theorem 6, next we introduce a notable class of KABs for which verification of arbitrary
LA properties is decidable. To do so, we rely on a syntactic restriction that resembles the notion of
weak acyclicity in data exchange (Fagin et al., 2005)5 , and that guarantees boundedness of ABoxes
generated by the execution of the KAB and, in turn, decidability of verification.
Now we are ready to introduce the notion of weak acyclicity in our context. We introduce the
edge-labeled directed dependency graph of a KAB K = (T, A0 , , ), defined as follows. Nodes,
called positions, are obtained from the TBox T: there is a node for every concept name N in T , and
two nodes for every role name P in T , corresponding to the domain and to the range of P . Edges
5. We use the original definition of weak acyclicity. However, our results can be applied also to other variants of weak
acyclicity (see discussion in Section 9).

667

fiBAGHERI H ARIRI , C ALVANESE , D E G IACOMO , D E M ASELLIS , F ELLI , & M ONTALI

Villain

livesIn,1

livesIn,2

City

enemy,1

Character

alterEgo,2

defeats,2

*
defeats,1

*

*

alterEgo,1

*
SuperHero

enemy,2

Figure 3: Weakly acyclic dependency graph for Example 1.
are drawn by considering every effect specification [q + ]  Q
A0 of each action contained in
, tracing how values are copied or contribute to generate new values as the system progresses. In
particular, let p be a position corresponding to a concept/role component in the rewriting rew T (q + )
of q + with variable x. For every position p0 in A0 with the same variable x, we include a normal
edge p  p0 . For every position p00 in A0 with a function term f (~t) such that x  ~t, we include a

special edge p 
 p00 . We say that K is weakly-acyclic if its dependency graph has no cycle going
through a special edge.
Example 3 The KAB of Example 1 is weakly acyclic. Its dependency graph, shown in Figure 3,
does not contain any cycle going through special edges. For readability, self-loops are not shown
in the Figure (but are present for all nodes), and dashed edges are used to compactly represent the
contributions given by the rewriting of the queries. E.g., the dashed edge form Villain to Character
denotes that for every outgoing edge from Character, there exists an outgoing edge from Villain
with the same type and target. Hence, w.r.t. weak acyclicity dashed edges can be simply replaced
by normal edges.
We are now ready to state the main result of this work, which we are going to prove in the remainder
of this section.
Theorem 7 Verification of LA properties for a weakly acyclic KAB is decidable in E XP T IME in
the size of the KAB.
We observe that the restriction imposed by weak acyclicity (or variants) is not too severe, and in
many real cases KABs are indeed weakly acyclic or can be transformed into weakly acyclic ones
at cost of redesign. Indeed, weakly acyclic KABs cannot indefinitely generate new values from the
old ones, which then depend on a chain of unboundedly many previous values. In other words,
current values depend only on a bounded number of old values. While unbounded systems exist in
theory, e.g., Turing machines, higher level processes, as those in business process management or
service-oriented modeling, typically require such a boundedness in practice. How to systematically
transform systems into weakly acyclic ones remains an open issue.
In the remainder of this section we present the proof of Theorem 7. We do so in several steps:
1. Normalized KAB. First we introduce a normalized form K of the KAB K, which isolates the
contribution of equalities and of the TBox in actions effects of the KAB. An important point
is that normalizing the KAB preserves weak acyclicity.
668

fiD ESCRIPTION L OGIC K NOWLEDGE AND ACTION BASES

2. Normalized DO(). Then, we introduce a normalized version DO NORM () of DO(), which avoids
to consider equalities in generating the bulk set of tuples to be used in the effects to generate
the next ABox. The transition system K,NORM generated through this normalized version
DO NORM () of DO () by the normalized KAB K is bisimilar to the transition system K generated through DO() by K. Hence the two transition systems satisfy the same LA formulae.

3. Positive dominant. The next step is to introduce what we call the positive dominant K++ of
the normalized KAB K. This is obtained from K essentially by dropping equalities, negations,
and TBox. However K++ contains enough information in the positive part so that, when we
drop all of these features, the active domain of the transition system K++ generated by
K++ overestimates the active domain of the transition system K,NORM generated by the
normalized KAB K. Moreover, if the normalized (and hence the original) KAB is weakly
acyclic, so is its positive dominant. Finally if the positive dominant is weakly acyclic then the
size of the active domain of its transition system K++ is polynomially bounded by the size
of its initial ABox, and hence so is the size of the active domain of K,NORM . This implies
that the size of K,NORM is finite and at most exponential in the size of its initial ABox.
4. Putting it all together. Tying these results together, we get the claim.
In the following, we detail each of these steps.
7.1 Normalized KAB
Given a KAB K = (T, A0 , , ), we build a KAB K = (T, A0 , , ), called the normalized form
of K, by applying a sequence of transformations that preserve the semantics of K while producing
a KAB of a format that is easier to study.
1. We view each ABox A as partitioned into a part collecting all concept and role assertions, and
a part collecting all equality assertions. We denote with A6E Q the former and with EQ(T, A)
the latter, after having closed it w.r.t. (the functionality assertions in) the TBox T . Notice that
such a closure can be computed in polynomial time in the size of A and T .
2. In K all individuals appearing in equality assertions in an ABox also occur in special concept assertions of the form Dummy(t), where the concept Dummy is unrelated to the other
concepts and roles in the KAB. We do so by:
 adding concept assertions Dummy(t) for each t in an equality assertion in A0 that does
not appear elsewhere;
 adding to the right-hand part of each action effect ei a concept assertion Dummy(t) for
each t in an equality assertion in the right-hand part of ei ;
 adding to each action an effect specification of the form
[Dummy(x)]

{Dummy(x)}.

Notice that, as the result of this transformation, we get ABoxes containing the additional
concept Dummy, which however is never queried by actions effects and by the rules forming
the process. The impact of the transformation is simply that now the ADOM(A) of the ABoxes
669

fiBAGHERI H ARIRI , C ALVANESE , D E G IACOMO , D E M ASELLIS , F ELLI , & M ONTALI

A in the KAB transition system can be readily identified as the set of terms occurring in
concept and role assertion only (without looking at equality assertions).
Given an ABox A, we denote by A the result of the two above transformations, which respectively add to A the closure of equalities and the extension of Dummy.
3. We manipulate each resulting effect specification
[q + ]  Q

A0

as follows:
3.1. We replace [q + ]  Q by [rew T (q + )]  rew T (Q ) (Calvanese et al., 2007a), exploiting
the results by Calvanese et al. (2007b) and by Artale et al. (2009), which guarantee that,
for every ECQ Q and every ABox A where equalities are closed under functionality and
congruence, we have that
ANS (Q, T, A)

= ANS (rew T (Q), , A).

3.2. We replace each effect specification [rew T (q + )]  rew T (Q )
A0 , resulting from
+

Step 3.1, by a set of effect specifications [qi ]  rew T (Q )
A0 , one for each CQ qi in
+
the UCQ rew T (q ).
3.3. For each effect specification [qi+ ]  rew T (Q )
A0 , we re-express qi+ so as to make
equalities used to join terms explicit and so as to remove constants from qi+ . Specifically,
we replace the effect specification by
[qi++ ]  q =  rew T (Q )

A0 ,

where:
 qi++ is the CQ without repeated variables obtained from qi+ by (i) replacing for each
variable x occurring in qi+ , the j-th occurrence of x except for the first one, by x[j] ;
and (ii) replacing each constant c with a new variable xc ;
V
V
 q = = [x = x[j] ]  [xc = c] where (i) the first conjunction contains one equality
[x = x[j] ] for each variable x in qi+ and for each variable x[j] introduced in the step
above, and (ii) the second conjunction contains one equality for each constant c in
qi+ .
To clarify the latter consider the following example:
Example 4 Given a query
.
[qi+ ] = [N (x)  P1 (x, y)  P2 (c, x)],
Step 3.3 above replaces it by [qi++ ]  q = , where
.
qi++ = N (x)  P1 (x[2] , y)  P2 (xc , x[3] ),
670

.
q = = [x = x[2] ]  [x = x[3] ]  [xc = c].

fiD ESCRIPTION L OGIC K NOWLEDGE AND ACTION BASES

As for the correctness
of Step 3.3, it is immediate to notice that [qi+ ] is equivalent to [qi++ 
V
V
[j]
(x = x ) (xc = c)]. The equivalence between the latter and [qi++ ]q = is a consequence
of the construction by Artale et al. (2009), which shows that query entailment in the presence
of equalities can be reduced to query evaluation by saturating equalities w.r.t. transitivity,
reflexivity, symmetry, and functionality.
Given an action , we denote by  the action normalized as above.
Since all transformations preserve logical equivalence (as long as we do not query Dummy),
we have
Lemma 8 DO(T, A, ) T,ALPH(K) DO(T, A, ).
Also the normalization of a KAB preserves weak acyclicity, which is a crucial consideration for
later results.
Lemma 9 If K is weakly acyclic, then also K is weakly acyclic.
Proof. Consider each effect specification [q + ]  Q
A0 belonging to an action in K. The
contribution of this effect specification to the dependency graph G of K is limited to each CQ qi in
the UCQ rew T (q + ), and to the set of concept and role assertions of A0 . We observe that each such
qi corresponds to a query qi++ in K in which each variable of qi occurs exactly once. For every free
variable x of qi that also appears in A0 , and for every occurrence of x in qi itself, an edge is included
in G. In the dependency graph G of K, only one of such edges appears, corresponding to the single
occurrence of the variable x in qi++ .
Notice that Dummy can be omitted from the dependency graph of G since, by definition of K,
Dummy does not occur in the left-hand side of effects except for the trivial effect [Dummy(x)]
{Dummy(x)}. This is not true for K, where Dummy is needed. Therefore, G is indeed a subgraph
of G, and hence weak acyclicity of G implies weak acyclicity of G.
7.2 Normalized DO()
Next we give a simplified version of DO(), which we call DO NORM (). We start by observing that
we can reformulate the definition of DO() given in Section 3. For that, we first need to define a
suitable notion of join of two queries. Let q1 and q2 be two ECQs, which may have free variables in
common, and let A1 and A2 be two ABoxes. Then we define ANS (q1 , , A1 ) ./ ANS (q2 , , A2 ) as
the set of substitutions  over the free variables in q1 and q2 such that qi holds in , Ai under , i.e.,
, Ai ,  |= qi , for i  {1, 2}. Then, given an action  with parameters substitution  and an ABox
A, we have
[
DO (T, A, ) =
APPLY (T, A, e, ),
e in 

where for an effect specification e : [q ++ ]  q =  Q
APPLY (T, A, e, )

[

=

A0 , we have
A0 

ANS (q ++ ,,A)./ANS ((q = Q ),,A)

671

 EQ(T, A).

fiBAGHERI H ARIRI , C ALVANESE , D E G IACOMO , D E M ASELLIS , F ELLI , & M ONTALI

Instead, we define DO NORM () as
DO NORM (T, A, )

=

[

APPLY NORM (T, A, e, ),

e in 

where, for an effect specification e : [q ++ ]  q =  Q
APPLY NORM (T, A, e, )

A0 , we have
[

=

A0 

 EQ(T, A).

ANS (q ++ ,,A6E Q )./ANS ((q = Q ),,A)

Notice that the only difference between DO() and DO NORM () is that in the latter we use only A6E Q
instead of A to compute the answers to the CQs q ++ .
The following lemma shows that the applications of DO() and of DO NORM () give rise to logically
equivalent ABoxes.
Lemma 10 DO(T, A, ) T,ALPH(K) DO NORM (T, A, ).
Proof. In order to prove the claim, it is enough to show that for each concept/role assertion 2  DO NORM (T, A, ) whose concept/role name belongs to ALPH(K), we have that
(T, DO(T, A, )) |= 2 , and for each concept/role assertion 1  DO(T, A, ) whose concept/role name belongs to ALPH(K), we have that (T, DO NORM (T, A, )) |= 1 . We actually prove
a slightly stronger result:
(1) For each ABox assertion 2  APPLY NORM (T, A, e, ), we have that (T, APPLY(T, A, e, )) |=
2 .
(2) For each ABox assertion 1  APPLY(T, A, e, ), we have that (T, APPLY NORM (T, A, e, )) |=
1 .
For (1), by monotonicity of q ++ and the fact that A6E Q  A, we have that
[
[
A0 
is contained in
A0 ,
(ANS (q ++ ,,A6E Q )./ANS ((q = Q ),,A))

(ANS (q ++ ,,A)./ANS ((q = Q ),,A))

hence the claim follows.
For (2), consider an ABox assertion   APPLY(T, A, e, ). By definition of APPLY(), we know
that there exists an effect e : [q ++ ]  q =  Q
A0 and an assignment  to the free variables
++
=
of q
(which include also the free variables of q  Q ) such that   (ANS (q ++ , , A) ./
=
ANS ((q  Q ), , A)) and   A0 . Let {x1 , . . . , xn } be all free variables in q ++ , and
 = {x1  t1 , . . . , xn  tn , }. For each variable xi , let N (xi ) be the (unique) concept atom
in q ++  in which xi occurs (similar considerations hold when xi occurs in a role atom). Then,
either N (ti )  A6E Q , or for some t0i , N (t0i )  A6E Q and (ti = t0i )  EQ(T, A). In the former
case, let t00i denote ti , while in the latter case let t00i denote t0i . Then, consider the substitution
 0 = {x1  t001 , . . . , xn  t00n , }. By construction, we have that  0  ANS (q ++ , , A6E Q ), and since
  ANS ((q =  Q ), , A), and (t00i = ti )  EQ(T, A) for each i  {1, . . . , n}, we also have that
 0  ANS (q ++ , , A6E Q ) ./ ANS ((q =  Q ), , A). Since
   A0 ,
672

fiD ESCRIPTION L OGIC K NOWLEDGE AND ACTION BASES

  and  0 are identical modulo EQ(T, A) and
 EQ(T, A)  APPLY NORM (T, A, e, ),
we can infer that (T, APPLY NORM (T, A, e, )) |= . Hence the claim holds.
By combining Lemma 8 and Lemma 10, we get that DO() on K and DO NORM () on K behave
equivalently, when starting from equivalent ABoxes.
Lemma 11 If A1 T,ALPH(K) A2 then DO(T, A1 , ) T,ALPH(K) DO NORM (T, A2 , ).
Proof. The claim is a direct consequence of Lemma 8, Lemma 10, the equivalence between A1 and
A2 , and the observation that logical equivalence is transitive.
Given a KAB K and its normalized version K, we call the transition system generated in the
same way as K , but using DO NORM () on K instead of DO() on K, the normalized transition system
generated by K, and denote it with K,NORM .
Lemma 12 Given a KAB K, the transition systems K and K,NORM are bisimilar.
Proof. Let K = (U, T, , s0 , abox , ) and K,NORM = (U, T, NORM , s0 , abox NORM , NORM ).
We define the relation B    NORM as follows: (s1 , s2 )  B iff abox (s1 ) T,ALPH(K)
abox NORM (s2 ) and show that B is a bisimulation. To do so, we prove that B is closed under the
definition of bisimulation itself. Indeed, if (s1 , s2 )  B, then:
 abox (s1 ) T,ALPH(K) abox (s2 ) by definition.
 If s1  s01 then there exists an action  and a substitution  such that s01 =
DO (T, abox (s1 ), ) (notice that abox (s1 ) = s1 ) and s01 is consistent w.r.t. T . Now let
us consider s02 = DO NORM (T, abox (s2 ), ). Since abox (s1 ) T,ALPH(K) abox (s2 ), then
by Lemma 11, we have s01 T,ALPH(K) s02 . Therefore, s02 is consistent w.r.t. T , and hence
s2 NORM s02 , and (s01 , s02 )  B.
 Similarly, if s2 NORM s02 then there exists an action  and a substitution  such that
s02 = DO NORM (T, abox (s2 ), ) and s02 is consistent w.r.t. T . Now let us consider s01 =
DO (T, abox (s1 ), ). Since s2 T,ALPH(K) s1 , then by by Lemma 11, we have s02 T,ALPH(K)
s01 Therefore, s01 is consistent w.r.t. T , and hence s1  s01 , and, considering that equivalence
enjoys symmetry, we have (s01 , s02 )  B.
This proves the claim.
The direct consequence of the above lemma is that, by considering the Bismulation Invariance
Theorem 4, we can faithfully check LA formulas over K,NORM instead of K .
7.3 Positive Dominant
Our next step is to show that for a weakly acyclic KAB K, the normalized transition system K,NORM
is finite. We do so by considering another transition system, which is behaviorally unrelated to
K,NORM , and hence to K , but whose active domain bounds the active domain of K,NORM . We
obtain such a transition system essentially by ignoring all negative information and equalities. This
allows us to refer back to the literature on data exchange to show boundedness. We call such a
transition system positive dominant.
Given a normalized KAB K = (T, A0 , , ), we define the positive dominant of K as the KAB
6E Q

K+ = (, A0 , { + }, {true 7  + }).
673

fiBAGHERI H ARIRI , C ALVANESE , D E G IACOMO , D E M ASELLIS , F ELLI , & M ONTALI

The only action  + is without parameters and its effect specification is constituted by CopyAll and
by one effect of the form
6E Q
[qi++ ]
A0i
for each effect [qi++ ]  qi=  Q
A0i in every action of . Observe that the parameters of the
i
actions in  become simply free variables in  + .
Notice that  + is applicable at every step because the process trivially always allows it. The
resulting state is always consistent, since K+ has an empty TBox. Moreover, no equality assertion
is ever generated. The transition system K+ is constituted by a single run, which incrementally
accumulates all the facts that can be derived by the iterated application of  + over such increasing
ABox. This behavior closely resembles the chase of tuple-generating dependencies (TGDs) in data
exchange, where an application of  + corresponds to a parallel chase step (Deutsch, Nash, &
Remmel, 2008).
From a technical point of view, notice that K+ is already in normalized form (i.e., K+ = K+ ),
and that DO() and DO NORM () are identical since neither equality nor negation are considered. Hence
K+ = K+ ,NORM .
The next lemma shows that K+ preserves weak acyclicity of K.
Lemma 13 If K is weakly acyclic then also its positive dominant K+ is weakly acyclic.
Proof. The claim follows from the fact that, by construction, the dependency graph G + of K+ is
equal to G. Indeed, both qi++ and its connection with Ai are preserved by K+ . Hence, we get the
claim.
Next we show that if K+ is weakly acyclic the active domain of the ABoxes in its transition
system K+ are polynomially bounded by the active domain of the initial ABox.
Lemma 14 If K+ is weakly acyclic, then there exists a polynomial P() such that
6E Q

|ADOM(K+ )| < P(|ADOM(A0 )|).
Proof. We observe that there exists a strict connection between the execution of K+ and the chase
of a set of TGDs in data exchange. Therefore, the proof closely resembles the one by Fagin et al.
(2005, Thm. 3.9), where it is shown that for weakly acyclic TGDs, every chase sequence is bounded.
Let K+ = (U, , , A0 6E Q , abox , ), let G + = (V, E) be the dependency graph of K+ , and
let n = |ADOM(A0 6E Q )|. For every node p  V , we consider an incoming path to be any (finite
or infinite) path ending in p. Let rank (p) be the maximum number of special edges on any such
incoming path. Since K+ is weakly acyclic by hypothesis, G + does not contain cycles going through
special edges, and therefore rank (p) is finite. Let r be the maximum among rank (pi ) over all
nodes. We observe that r  |V |; indeed no path can lead to the same node twice using special
edges, otherwise G + would contain a cycle going through special edges, thus breaking the weak
acyclicity hypothesis. Next we observe that we can partition the nodes in V according to their rank,
obtaining a set of sets {V0 , V1 , . . . , Vr }, where Vi is the set of all nodes with rank i.
Let us now consider a state A obtained from A0 6E Q by applying the only action  + contained
in K+ an arbitrary number of times. We now prove, by induction on i, the following claim: for
every i there exists a polynomial Pi such that the total number of distinct values c that occur in A at
positions in Vi is at most Pi (n).
674

fiD ESCRIPTION L OGIC K NOWLEDGE AND ACTION BASES

(Base case) Consider p  V0 . By definition, p has no incoming path containing special edges.
Therefore, no new values are stored in p along the run A0 6E Q      A. Indeed p can just store
values that are part of the initial ABox A0 6E Q . This holds for all nodes in V0 and hence we can fix
P0 (n) = n.
(Inductive step) Consider p  Vi , with i  {1, . . . , r}. The first kind of values that may be stored
inside p are those values that were stored inside p itself in A0 6E Q . The number of such values is at
most n. In addition, a value may be stored in p for two reasons: either it is copied from some other
position p0  Vj with i 6= j, or it is generated as a possibly new function term, built when applying
effects that contain a function in their head.
We first determine the number of fresh individuals that can be generated from function terms.
The possibility of generating and storing a new value in p as a result of an action is reflected by
the presence of special edges. By definition, any special edge entering p must start from a node
0
p0  V0      Vi1 . By
P induction hypothesis, the number of distinct values that can exist in p
is bounded by H(n) = j{0,...,i1} Pj (n). Let ba be the maximum number of special edges that
enter a position, over all positions in the TBox; ba bounds the arity taken by each function term
contained in . Then for every choice of ba values in V0      Vi1 (one for each special edge that
can enter a position), the number of new values generated at position p is bounded by tf  H(n)ba ,
where tf is the total number of facts contained in all effects of  + . Note that this number does not
depend on the data in A0 6E Q . By considering all positions in Vi , the total number of values that can
be generated is then bounded by F(n) = |Vi |  tf  H(n)ba . Clearly, F() is a polynomial, because
tf and ba are determined by  + .
We count next the number of distinct values that can be copied to positions of Vi from positions
of Vj , with j 6= i. A copy is represented in the graph as a normal edge going from a node in Vj
to a node in Vi , with j 6= i. We observe first that such normal edges can start only from nodes in
V0   Vi1 , that is, they cannot start from nodes in Vj with j > i. We prove this by contradiction.
Assume that there exists p0  p  E, such that p  Vi and p0  Vj with j > i. In this case, the
rank of p would be j > i, which contradicts the fact that p  Vi . As a consequence, the number
of distinct values that can be copied to positions in Vi is bounded by the total number of values in
V0      Vi1 , which corresponds to H(n) from our previous consideration.
Putting it all together, we define Pi (n) = n + F(n) + H(n). Since Pi () is a polynomial, the
claim is proven.
Notice that, in the above claim, i is bounded by r, which is a constant. Hence, there exists a
fixed polynomial P() such that the number of distinct values that can exist in every state s  
is bounded by P(n). K+ is inflationary, because when  + is applied it copies all concept and role
assertions from the current to the next state. Since K+ contains only a single run, P(n) is a bound
for ADOM(K+ ) as well.
The following lemma shows the key feature of the positive dominant.
Lemma 15 ADOM(K )  ADOM(K+ ).
6E Q

Proof. Let K = (T, A0 , , ) and K+ = (, A0 , { + }, {true 7  + }).
We first observe that, for every ABox A in K , ADOM(A) = ADOM(A6E Q ) by definition of K
(this is the role of the special concept Dummy).
675

fiBAGHERI H ARIRI , C ALVANESE , D E G IACOMO , D E M ASELLIS , F ELLI , & M ONTALI

We show by induction on the construction of K (U, T, 1 , A0 , abox , 1 ) and K+ =
6E Q

(U, , 2 , A0 , abox , 2 ), that for each state A1  1 we have that there exists a state A2  2
such that A1 6E Q  A2 .
6E Q
The base case holds for the initial states A0 and A0 of the two transition systems by definition.
For the inductive case, we have to show that, given A1  1 and A2  2 with A1 6E Q  A2 , for
each A01  1 with A1 1 A01 , the unique state A02  2 with A2 2 A02 is such that A01  A02 . To
show this, note that A1 1 A01 if there exists an action  of K and a substitution  for the parameters
of  such that A01 = DO NORM (T, A1 , ). Similarly, taking into account that  + has no parameters
and is always executable in K+ , we have that A02 = DO(T, A2 ,  + ) = DO NORM (T, A2 ,  + ). By
construction of K+ , for each effect e1   of the form
e1 : [q ++ ]  q =  Q

A0e1 ,

there is an effect e2   + of the form
e2 : [q ++ ]

6E Q

A0e1 ,

where A0e1 6E Q is obtained from A0e1 by removing all equality assertions. By induction hypothesis,
we have that A1 6E Q  A2 . By observing that ANS ([q ++ ], , A1 6E Q ) ./ ANS ((q =  Q ), , A1 ) 
6E Q
ANS ([q ++ ], , A2 ), we then obtain that A0e1
 A0e2 , where A0e1 = APPLY NORM (T, A1 , e1 , ) and
A0e2 = APPLY(, A2 , e2 , ). Hence, we get the claim that A01 6E Q  A02 .
Now since for an ABox A of K the active domain ADOM(A) of A and ADOM(A6E Q ) are identical by construction, and since ADOM(K ) and ADOM(K+ ) are simply the union of the active
domains of all generated ABoxes, we get the claim.
7.4 Putting it All Together
If a KAB K is weakly acyclic, then, by Lemma 9, its normalized form K is weakly acyclic as well
and, by Lemma 13, so is its positive dominant K+ . Hence, by Lemma 14, the size of the active
domain ADOM(K+ ) of the transition system K+ of K+ is polynomially related to the size of its
initial ABox.
Now, by Lemma15, this implies that also the size of the active domain ADOM(K,NORM ) of the
transition system K of K is polynomially related to the size of its initial ABox. Hence, the number
of possible states of K is finite, and in fact at most exponential in the size of the initial ABox. It
follows that checking LA formulae over K can be done in E XP T IME w.r.t. the size of K.
Finally, by Lemma 12, K and K are bisimilar, and by the Bisimulation Invariance Theorem 4,
K and K satisfy exactly the same LA formulae. Hence, to check a LA formula on K it
is sufficient to check it over K , which can be done in E XP T IME. This concludes the proof of
Theorem 7.

8. Related Work
We provide now a detailed review of work that is related to the framework and the results presented
in the previous sections.
676

fiD ESCRIPTION L OGIC K NOWLEDGE AND ACTION BASES

8.1 Combining Description Logics and Temporal Logics
Our work is deeply related to the research that studies combinations of description logics and temporal logics. Indeed, actions progress knowledge over time and, although temporal logics do not
mention actions, we can easily used them for describing progression mechanisms, including transition systems (see, e.g., Clarke et al., 1999; Calvanese, De Giacomo, & Vardi, 2002).
Such research has mostly explored the combination of standard description logics with standard
temporal logics at the level of models, which is certainly the most natural form of combination from
a logical point of view. Technically, this form of combination gives rise to a combined logic with
a two-dimensional semantics, where one dimension is for time and the other for the DL domain
(Schild, 1993; Wolter & Zakharyaschev, 1999b, 1999a; Gabbay et al., 2003). Unfortunately, from
a computational point of view, this form of combination suffers from a key undecidability result,
which makes it too fragile for many practical purposes: the possibility of specifying that roles
preserve their extension over time (the so called rigid roles) causes undecidability6 . Referring
to the domain of interest in Example 1, this would result, for example, in the undecidability of
theories that specify that each instance of Character livesIn the same City forever. Moreover, this
undecidability result already holds for concept satisfiability w.r.t. a fixed TBox (i.e., where the same
TBox axioms must hold at all time points), without ABoxes, and with only a single rigid role (Wolter
& Zakharyaschev, 1999b, 1999a; Gabbay et al., 2003). That is, it holds for a reasoning service that
is much simpler than conjunctive query answering (Calvanese, De Giacomo, & Lenzerini, 2008),
even with a fixed TBox and no data (no ABox assertions, hence no individual terms) and for one of
the simplest kinds of temporal formulae, namely forever something is true (safety) (Clarke et al.,
1999).
Decidability can be regained by: (i) dropping TBoxes altogether, but the decision problem is
still hard for non-elementary time (Gabbay et al., 2003); (ii) allowing temporal operators only on
concepts (Schild, 1993; Artale & Franconi, 1998, 2005; Gutierrez-Basulto, Jung, & Lutz, 2012;
Jamroga, 2012), and in this case the complexity depends crucially on the description logic; (iii) allowing temporal operators only on TBox and ABox assertions (Lutz, Wolter, & Zakharyaschev,
2008; Baader et al., 2012). In fact cases (ii) and (iii) can be mixed (Baader & Laux, 1995; Wolter
& Zakharyaschev, 1998).
Allowing for temporal operators over assertions only (case (iii) above), is tightly related to the
functional approach adopted in this paper: the fact that we admit temporal operators only in front of
assertions allows us to consider temporal models whose time points are actually sets of models of
description logic assertions. Hence it keeps the temporal component distinct from the description
logic one, exactly as we do here. In particular, the results by Baader et al. (2012) can be directly
compared with ours. Apart from the obvious differences in the formalism used, one key point to get
decidability there is that the individual terms mentioned in the ABox assertions are fixed a priori. It
is possible that, by adapting the techniques presented here, those results could be extended to allow
functions for denoting terms, hence allowing for adding fresh individual terms during the temporal
evolution.

6. To lose decidability, it suffices to be able to specify/verify the persistence of binary predicates/roles, which allows
one to build an infinite grid and hence to encode any Turing-machine computation (Robinson, 1971; van Emde Boas,
1997).

677

fiBAGHERI H ARIRI , C ALVANESE , D E G IACOMO , D E M ASELLIS , F ELLI , & M ONTALI

8.2 Combining Description Logics and Actions
Somehow hampered by the undecidability results mentioned at the beginning of the section, also
combinations of description logics and action theories have been studied in the years. In particular,
Liu, Lutz, Milicic, and Wolter (2006b, 2006a) study combinations of description logics and action
theories at the level of models, but only w.r.t. the two classical problems in reasoning about actions,
namely projection and executability. Both of these problems require to explicitly give a sequence of
actions and then check a property of the resulting final state (projection), or check the executability
of the sequence of actions, each of which comes with a certain precondition (Reiter, 2001). More
sophisticated temporal properties (in particular, forever something is true mentioned above) would
lead to undecidability. By the way, notice that such undecidability result also deeply questions from
the computational point of view the possibility of adding (sound and complete) automated reasoning
capabilities to proposals such as OWL-S (Semantic Markup for Web Services) (Martin, Paolucci,
McIlraith, Burstein, McDermott, McGuinness, Parsia, Payne, Sabou, Solanki, Srinivasan, & Sycara,
2004).
Possibly the first proposal based implicitly on the functional view of the KB was the pioneering
work by De Giacomo, Iocchi, Nardi, and Rosati (1999), which adopts an epistemic description logic
(based on certain answers) combined with an action formalism to describe routines of a mobile
robot. Again, one important point there is that individual terms are bounded and fixed a priori.
The functional view approach was first spelled out by Calvanese, De Giacomo, Lenzerini, and
Rosati (2007), and by Calvanese et al. (2011). In that work, only projection and executability are
studied, however there is a distinction between the KB in the states and the actions (there specified
as updates), so that the framework gives rise to a single transition system whose states are labeled
by KBs (in fact the TBox is fixed while the ABox changes from state to state). However, again,
the individual terms considered are fixed a priori and hence the resulting transition system is finite.
So, although not studied in that work, sophisticated forms of temporal properties as those proposed
here are readily verifiable in that setting. Interestingly, apart from the KBs and action, in that work
also Golog-like programs are considered. These are programs whose atomic actions are defined
by the action formalism, and are combined using (usual and less usual) programming constructs,
such as sequence, while-loop, if-then-else, and nondeterministic pick of a value (Levesque, Reiter,
Lesperance, Lin, & Scherl, 1997; De Giacomo, Lesperance, & Levesque, 2000). An important
characteristic of these programs is that they have a finite number of control states (notice that the
memory storage of these programs is kept in the action theory, or the KB in our case). Although out
of the scope of this paper, this finiteness allows for easily extending our results to such program as
well.
An interesting alternative way to combine description logics and reasoning about actions is the
one reported by Gu and Soutchanski (2010). There, a description logics KB7 is used as a special
FOL theory describing the initial situation in a situation calculus basic action theory (Reiter, 2001).
Notice that as a result, TBox assertions do not act as state constraints (Lin & Reiter, 1994), which
would lead to undecidability as discussed above (Wolter & Zakharyaschev, 1999b, 1999a; Gabbay
et al., 2003), in fact they essentially do not persist in any way through actions.

7. They actually mainly focus on concepts only but in a description logic that includes the universal role, which allows
one to express TBox assertions as concepts (Baader et al., 2003).

678

fiD ESCRIPTION L OGIC K NOWLEDGE AND ACTION BASES

8.3 Description Logics Update
Observe that effects of an action in our setting can be seen as a basic form of update of the previous
state (Katsuno & Mendelzon, 1991). Although our mechanism sidesteps the semantic and computational difficulties of description logic KB update (Liu et al., 2006b; De Giacomo, Lenzerini, Poggi,
& Rosati, 2009; Calvanese, Kharlamov, Nutt, & Zheleznyakov, 2010; Lenzerini & Savo, 2012) by
simply rejecting the execution of actions that would lead to an inconsistent state. Adopting proper
forms of update in our setting is an interesting issue for future research.
8.4 Artifacts and Data-Aware Processes
Our work is also closely related to research in verification of artifact-centric business processes
(Nigam & Caswell, 2003; Bhattacharya et al., 2007). Artifact-centric approaches model business
processes by giving equal importance to the control-flow perspective and the data of interest. An
artifact is typically represented as a tuple of a schema, which models the artifact type, together
with a set of actions/services that specify how the information maintained in the artifact can be
manipulated over time. Each action is usually represented in terms of pre- and post-conditions
that are respectively used to determine when the action is eligible for execution, and to relate the
current artifact state with the successor state obtained after the action execution. Pre- and postconditions are modeled as first-order formulae, and post-conditions employ existentially quantified
variables to account for external inputs from the environment. Differently from KABs, most of
the approaches targeting artifact-centric processes assume complete information about data, using
a relational database to maintain the artifacts information. As in this paper, the aim of such works
is to verify whether a relational artifact-centric process meets some temporal/dynamic property,
formalized using first-order variants of branching or linear temporal logics.
In the work by Deutsch et al. (2009), the infinite domain of the artifacts database is equipped
with a dense linear order, which can be mentioned in pre-conditions, post-conditions, and properties.
Runs can receive unbounded external input from an infinite domain. Decidability of verification is
achieved by avoiding branching time properties, and by restricting the formulae used to specify
pre-, post-conditions and properties. In particular, the approach refers to read-only and read-write
database relations differently, querying the latter only by checking whether they contain a given tuple of constants. The authors show that this restriction is tight, and that integrity constraints cannot
be added to the framework, since even a single functional dependency leads to undecidability of
verification. Damaggio et al. (2011) extend this approach by disallowing read-write relations, but
this allows the extension of the decidability result to integrity constraints expressed as embedded
dependencies with terminating chase, and to any decidable arithmetic. This is a major difference
with our approach, where all concepts of the KAB are considered as read-write relations, and can
be arbitrarily queried to determine the progression of the system. Differently from these works,
Belardinelli et al. (2011) consider a first-order variant of CTL with no quantification across states
as verification formalism. The framework supports the incorporation of new values from the external environment as parameters of the actions; the corresponding execution semantics considers
all the possible actual values, thus leading to an infinite-state transition systems. As for decidability of verification, the authors show that, under the assumption that each state of the system
(constituted by the union of artifacts relational instances) has a bounded active domain, it is possible to construct a faithful abstract transition system which, differently from the original one, has
a finite number of states. Belardinelli, Lomuscio, and Patrizi (2012) improve the results by Belar679

fiBAGHERI H ARIRI , C ALVANESE , D E G IACOMO , D E M ASELLIS , F ELLI , & M ONTALI

dinelli et al. (2011) by introducing a semantic property of uniformity which, roughly speaking,
says that the transition system representing the execution of the process under study is not able to
distinguish among states that have the same constants and the same patterns of data. Under the assumptions of uniformity and state boundedness, decidability of verification is achieved for a richer
logic, namely CTL with quantification across states, interpreted under the active domain semantics.
The notion of state boundedness has also been adopted by the independently developed framework
of Bagheri Hariri, Calvanese, De Giacomo, Deutsch, and Montali (2012, 2013), where first-order
variants of -calculus, similar to the one considered here, are considered. There, beside differences
in the way data and external information are modeled, sufficient syntactic conditions that guarantee state boundedness are proposed. All these works are developed within the relational database
setting, and do not extend trivially to systems where actions change DL knowledge bases.
The connection between data-/artifact-centric business processes and data exchange that we exploit in this paper was first established by Cangialosi et al. (2010), and by De Giacomo, De Masellis,
and Rosati (2012). There the transition relation itself is described in terms of TGDs, which map the
current state, represented as a relational database instance, to the next one. Null values are used to
model the incorporation of new, unknown data into the system. The process evolution is essentially
a form of chase. Under suitable weak acyclicity conditions this chase terminates, guaranteeing, in
turn, that the system is finite-state. Decidability is then shown for a first-order -calculus without
first-order quantification across states. This approach was extended by Bagheri Hariri et al. (2011),
where TGDs were replaced by actions and a rule-based process that follow the same structure of
the KAB action component. In this revised framework, values imported from the external environment are represented by uninterpreted function terms, which play the same role as nulls in the
work by Cangialosi et al. (2010), and by De Giacomo et al. (2012). Since Bagheri Hariri et al.
(2011), Cangialosi et al. (2010), and De Giacomo et al. (2012) all rely on a purely relational setting, this choice leads to an ad-hoc interpretation of equality, where each null value/function term
is considered only equal to itself. Differently from these works, here we allow for sophisticated
schema constraints, i.e., the TBox itself, and provide at the same time a more fine-grained treatment
of equality, where individuals can be inferred to be equal due to the application of such schema
constraints and/or the execution of some action. This treatment of equality differentiates this work
also from the one of Bagheri Hariri, Calvanese, De Giacomo, and De Masellis (2011), which introduces a preliminary version of the framework here presented, where UNA is assumed and equality
is not considered. More specifically, Bagheri Hariri et al. (2011) propose semantic artifacts as a
means to represent artifacts and corresponding processes at a higher level of abstraction than relational artifacts, representing the artifact data with a semantically rich knowledge base operating
with incomplete information. KABs constitute a more general framework, which can be seamlessly
customized to account for semantic artifacts. A major difference with the work by Bagheri Hariri
et al. (2011) is also constituted by the verification formalism. In particular, both works focus on a
form of -calculus where ECQs are used to query the states of the system, but Bagheri Hariri et al.
(2011) do not support quantification across states, as done here.
Calvanese et al. (2012) investigate a framework for data-centric processes that mixes the approach proposed by Bagheri Hariri et al. (2013) for relational artifacts with the notion of knowledge
bases as used here. In particular, semantically-governed data-aware processes are introduced as a
mechanism to model a dynamic system working over a relational database, providing at the same
time a conceptual representation of the manipulated data in terms of a DL-Lite knowledge base. By
relying on ontology-based data access (Calvanese et al., 2009), declarative mappings are used to
680

fiD ESCRIPTION L OGIC K NOWLEDGE AND ACTION BASES

connect the knowledge base with the underlying relational database. Differently from KABs, the
system evolves at the relational layer, and the knowledge base is used to understand and ultimately
govern such an execution at a higher level of abstraction.
We observe that the results presented here fully subsume those by Bagheri Hariri et al. (2011),
where the underlying description logic is OWL 2 QL. On the one hand, if we remove the possibility
of asserting functionality of roles in the knowledge component, and of equating individuals as a result of an action in the action component, we precisely obtain the setting presented by Bagheri Hariri
et al. (2011). On the other hand, for both frameworks the established complexity upper bounds are
the same.

9. Conclusions
In this paper we have studied verification of knowledge and action bases, which are dynamic systems
constituted by a knowledge base, expressed in description logics, and by an action specification that
changes the knowledge base over time. We have obtained an interesting decidability result by
relying on the notion of weak acyclicity, based on a connection with the theory of chase of TGDs in
relational databases.
In our work, we have used the original notion of weak acyclicity. However, it is easy to adopt
more advanced forms of acyclicity, since our results depend only on the ability of finding a finite
bound on the number of distinct function terms that are generated (when applying the chase). While
the majority of approaches that adopt forms of weak-acyclicity focus on databases (Marnette &
Geerts, 2010; Meier, Schmidt, Wei, & Lausen, 2010), Cuenca Grau, Horrocks, Krotzsch, Kupke,
Magka, Motik, and Wang (2012) investigate sophisticated forms of acyclicity in the context of
knowledge bases without UNA. Their results can thus be seamlessly applied to KABs. Interestingly,
to manage the impact of equalities in a setting without UNA, they resort to the singularization technique presented by Marnette (2009), which closely resembles the normalization of KABs introduced
in Section 7.
Weak acyclicity allows us to gain decidability by bounding the number of distinct function
terms that occur in the transition system. An alternative approach to gain decidability is to bound the
number of distinct terms occurring in the ABox assertions of a state. Variants of this notion of state
boundedness have been proposed recently in other contexts (Belardinelli et al., 2012; De Giacomo,
Lesperance, & Patrizi, 2012; Bagheri Hariri et al., 2013). It is of great interest to explore such an
approach in the setting presented here of actions acting on a description logic knowledge base.
We observe that our decidability result (as well as the ones commented here and in Section 8),
comes with an algorithm for verification that is exponential in the size of the initial ABox. This precludes a direct application of these techniques to large-scale systems, without a careful analysis of
how these can be modularized in small units to be verified (almost) separately. This is an important
direction for further investigation.
Acknowledgments
This research has been partially supported by the EU under the ICT Collaborative Project ACSI
(Artifact-Centric Service Interoperation), grant agreement n. FP7-257593, and under the large-scale
integrating project (IP) Optique (Scalable End-user Access to Big Data), grant agreement n. FP7318338.
681

fiBAGHERI H ARIRI , C ALVANESE , D E G IACOMO , D E M ASELLIS , F ELLI , & M ONTALI

References
Artale, A., Calvanese, D., Kontchakov, R., & Zakharyaschev, M. (2009). The DL-Lite family and
relations. J. of Artificial Intelligence Research, 36, 169.
Artale, A., & Franconi, E. (1998). A temporal description logic for reasoning about actions and
plans. J. of Artificial Intelligence Research, 9, 463506.
Artale, A., & Franconi, E. (2005). Temporal description logics. In Gabbay, D., Fisher, M., & Vila, L.
(Eds.), Handbook of Temporal Reasoning in Artificial Intelligence, Foundations of Artificial
Intelligence. Elsevier.
Baader, F., Calvanese, D., McGuinness, D., Nardi, D., & Patel-Schneider, P. F. (Eds.). (2003). The
Description Logic Handbook: Theory, Implementation and Applications. Cambridge University Press.
Baader, F., Ghilardi, S., & Lutz, C. (2012). LTL over description logic axioms. ACM Trans. on
Computational Logic, 13(3), 21:121:32.
Baader, F., & Laux, A. (1995). Terminological logics with modal operators. In Proc. of the 14th
Int. Joint Conf. on Artificial Intelligence (IJCAI95), pp. 808814.
Bagheri Hariri, B., Calvanese, D., De Giacomo, G., & De Masellis, R. (2011). Verification of
conjunctive-query based semantic artifacts. In Proc. of the 24th Int. Workshop on Description Logic (DL 2011), Vol. 745 of CEUR Electronic Workshop Proceedings, http:
//ceur-ws.org/.
Bagheri Hariri, B., Calvanese, D., De Giacomo, G., De Masellis, R., & Felli, P. (2011). Foundations
of relational artifacts verification. In Proc. of the 9th Int. Conference on Business Process
Management (BPM 2011), Vol. 6896 of Lecture Notes in Computer Science, pp. 379395.
Springer.
Bagheri Hariri, B., Calvanese, D., De Giacomo, G., Deutsch, A., & Montali, M. (2012). Verification of relational data-centric dynamic systems with external services. Corr technical report arXiv:1203.0024, arXiv.org e-Print archive. Available at http://arxiv.org/abs/
1203.0024.
Bagheri Hariri, B., Calvanese, D., De Giacomo, G., Deutsch, A., & Montali, M. (2013). Verification
of relational data-centric dynamic systems with external services. In Proc. of the 32nd ACM
SIGACT SIGMOD SIGART Symp. on Principles of Database Systems (PODS 2013).
Bao, J., et al. (2012). OWL 2 Web Ontology Language document overview (second edition). W3C
Recommendation, World Wide Web Consortium. Available at http://www.w3.org/
TR/owl2-overview/.
Belardinelli, F., Lomuscio, A., & Patrizi, F. (2011). Verification of deployed artifact systems via data
abstraction. In Proc. of the 9th Int. Joint Conf. on Service Oriented Computing (ICSOC 2011),
Vol. 7084 of Lecture Notes in Computer Science, pp. 142156. Springer.
Belardinelli, F., Lomuscio, A., & Patrizi, F. (2012). An abstraction technique for the verification
of artifact-centric systems. In Proc. of the 13th Int. Conf. on the Principles of Knowledge
Representation and Reasoning (KR 2012), pp. 319328.
Berardi, D., Calvanese, D., & De Giacomo, G. (2005). Reasoning on UML class diagrams. Artificial
Intelligence, 168(12), 70118.
682

fiD ESCRIPTION L OGIC K NOWLEDGE AND ACTION BASES

Bhattacharya, K., Gerede, C., Hull, R., Liu, R., & Su, J. (2007). Towards formal analysis of artifactcentric business process models. In Proc. of the 5th Int. Conference on Business Process
Management (BPM 2007), Vol. 4714 of Lecture Notes in Computer Science, pp. 288234.
Springer.
Burkart, O., Caucal, D., Moller, F., & Steffen, B. (2001). Verification of infinite structures.. In
Handbook of Process Algebra. Elsevier Science.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., Poggi, A., Rodrguez-Muro, M., &
Rosati, R. (2009). Ontologies and databases: The DL-Lite approach. In Tessaris, S., & Franconi, E. (Eds.), Reasoning Web. Semantic Technologies for Informations Systems  5th Int.
Summer School Tutorial Lectures (RW 2009), Vol. 5689 of Lecture Notes in Computer Science, pp. 255356. Springer.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., & Rosati, R. (2007a). EQL-Lite: Effective first-order query processing in description logics. In Proc. of the 20th Int. Joint Conf. on
Artificial Intelligence (IJCAI 2007), pp. 274279.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., & Rosati, R. (2007b). Tractable reasoning and efficient query answering in description logics: The DL-Lite family. J. of Automated
Reasoning, 39(3), 385429.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., & Rosati, R. (2013). Data complexity
of query answering in description logics. Artificial Intelligence, 195, 335360.
Calvanese, D., De Giacomo, G., Lembo, D., Montali, M., & Santoso, A. (2012). Ontology-based
governance of data-aware processes. In Proc. of the 6th Int. Conf. on Web Reasoning and Rule
Systems (RR 2012), Vol. 7497 of Lecture Notes in Computer Science, pp. 2541. Springer.
Calvanese, D., De Giacomo, G., & Lenzerini, M. (2008). Conjunctive query containment and answering under description logics constraints. ACM Trans. on Computational Logic, 9(3),
22.122.31.
Calvanese, D., De Giacomo, G., Lenzerini, M., & Rosati, R. (2007). Actions and programs over description logic ontologies. In Proc. of the 20th Int. Workshop on Description Logic (DL 2007),
Vol. 250 of CEUR Electronic Workshop Proceedings, http://ceur-ws.org/, pp. 29
40.
Calvanese, D., De Giacomo, G., Lenzerini, M., & Rosati, R. (2011). Actions and programs over
description logic knowledge bases: A functional approach. In Lakemeyer, G., & McIlraith,
S. A. (Eds.), Knowing, Reasoning, and Acting: Essays in Honour of Hector Levesque. College
Publications.
Calvanese, D., De Giacomo, G., & Montali, M. (2013). Foundations of data aware process analysis:
A database theory perspective. In Proc. of the 32nd ACM SIGACT SIGMOD SIGART Symp.
on Principles of Database Systems (PODS 2013).
Calvanese, D., De Giacomo, G., & Vardi, M. Y. (2002). Reasoning about actions and planning in
LTL action theories. In Proc. of the 8th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR 2002), pp. 593602.
Calvanese, D., Kharlamov, E., Nutt, W., & Zheleznyakov, D. (2010). Updating ABoxes in DL-Lite.
In Proc. of the 4th Alberto Mendelzon Int. Workshop on Foundations of Data Management
683

fiBAGHERI H ARIRI , C ALVANESE , D E G IACOMO , D E M ASELLIS , F ELLI , & M ONTALI

(AMW 2010), Vol. 619 of CEUR Electronic Workshop Proceedings, http://ceur-ws.
org/, pp. 3.13.12.
Cangialosi, P., De Giacomo, G., De Masellis, R., & Rosati, R. (2010). Conjunctive artifact-centric
services. In Proc. of the 8th Int. Joint Conf. on Service Oriented Computing (ICSOC 2010),
Vol. 6470 of Lecture Notes in Computer Science, pp. 318333. Springer.
Clarke, E. M., Grumberg, O., & Peled, D. A. (1999). Model checking. The MIT Press, Cambridge,
MA, USA.
Cohn, D., & Hull, R. (2009). Business artifacts: A data-centric approach to modeling business
operations and processes. Bull. of the IEEE Computer Society Technical Committee on Data
Engineering, 32(3), 39.
Cuenca Grau, B., Horrocks, I., Krotzsch, M., Kupke, C., Magka, D., Motik, B., & Wang, Z. (2012).
Acyclicity conditions and their application to query answering in description logics. In
Proc. of the 13th Int. Conf. on the Principles of Knowledge Representation and Reasoning
(KR 2012), pp. 243253.
Damaggio, E., Deutsch, A., & Vianu, V. (2011). Artifact systems with data dependencies and
arithmetic. In Proc. of the 14th Int. Conf. on Database Theory (ICDT 2011), pp. 6677.
De Giacomo, G., De Masellis, R., & Rosati, R. (2012). Verification of conjunctive artifact-centric
services. Int. J. of Cooperative Information Systems, 21(2), 111139.
De Giacomo, G., Iocchi, L., Nardi, D., & Rosati, R. (1999). A theory and implementation of
cognitive mobile robots. J. of Logic and Computation, 9(5), 759785.
De Giacomo, G., Lenzerini, M., Poggi, A., & Rosati, R. (2009). On instance-level update and erasure in description logic ontologies. J. of Logic and Computation, Special Issue on Ontology
Dynamics, 19(5), 745770.
De Giacomo, G., Lesperance, Y., & Levesque, H. J. (2000). ConGolog, a concurrent programming
language based on the situation calculus. Artificial Intelligence, 121(12), 109169.
De Giacomo, G., Lesperance, Y., & Patrizi, F. (2012). Bounded situation calculus action theories
and decidable verification. In Proc. of the 13th Int. Conf. on the Principles of Knowledge
Representation and Reasoning (KR 2012), pp. 467477.
Deutsch, A., Hull, R., Patrizi, F., & Vianu, V. (2009). Automatic verification of data-centric business
processes. In Proc. of the 12th Int. Conf. on Database Theory (ICDT 2009), pp. 252267.
Deutsch, A., Nash, A., & Remmel, J. B. (2008). The chase revisited. In Proc. of the 27th ACM
SIGACT SIGMOD SIGART Symp. on Principles of Database Systems (PODS 2008), pp. 149
158.
Fagin, R., Kolaitis, P. G., Miller, R. J., & Popa, L. (2005). Data exchange: Semantics and query
answering. Theoretical Computer Science, 336(1), 89124.
Gabbay, D., Kurusz, A., Wolter, F., & Zakharyaschev, M. (2003). Many-dimensional Modal Logics:
Theory and Applications. Elsevier Science Publishers.
Gu, Y., & Soutchanski, M. (2010). A description logic based situation calculus. Ann. of Mathematics
and Artificial Intelligence, 58(1-2), 383.
684

fiD ESCRIPTION L OGIC K NOWLEDGE AND ACTION BASES

Gutierrez-Basulto, V., Jung, J. C., & Lutz, C. (2012). Complexity of branching temporal description
logics. In Proc. of the 20th Eur. Conf. on Artificial Intelligence (ECAI 2012), pp. 390395.
Jamroga, W. (2012). Concepts, agents, and coalitions in alternating time. In Proc. of the 20th Eur.
Conf. on Artificial Intelligence (ECAI 2012), pp. 438443.
Katsuno, H., & Mendelzon, A. (1991). On the difference between updating a knowledge base and
revising it. In Proc. of the 2nd Int. Conf. on the Principles of Knowledge Representation and
Reasoning (KR91), pp. 387394.
Kowalski, R. A., & Sadri, F. (2011). Abductive logic programming agents with destructive
databases. Ann. of Mathematics and Artificial Intelligence, 62(12), 129158.
Lenzerini, M., & Savo, D. F. (2012). Updating inconsistent description logic knowledge bases. In
Proc. of the 20th Eur. Conf. on Artificial Intelligence (ECAI 2012), pp. 516521.
Levesque, H. J., Reiter, R., Lesperance, Y., Lin, F., & Scherl, R. (1997). GOLOG: A logic programming language for dynamic domains. J. of Logic Programming, 31, 5984.
Levesque, H. J. (1984). Foundations of a functional approach to knowledge representation. Artificial
Intelligence, 23, 155212.
Limonad, L., De Leenheer, P., Linehan, M., Hull, R., & Vaculin, R. (2012). Ontology of dynamic
entities. In Proc. of the 31st Int. Conf. on Conceptual Modeling (ER 2012).
Lin, F., & Reiter, R. (1994). State constraints revisited. J. of Logic Programming, 4(5), 655678.
Liu, H., Lutz, C., Milicic, M., & Wolter, F. (2006a). Reasoning about actions using description
logics with general TBoxes. In Proc. of the 10th Eur. Conference on Logics in Artificial
Intelligence (JELIA 2006), Vol. 4160 of Lecture Notes in Computer Science. Springer.
Liu, H., Lutz, C., Milicic, M., & Wolter, F. (2006b). Updating description logic ABoxes. In Proc. of
the 10th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR 2006),
pp. 4656.
Lutz, C., Wolter, F., & Zakharyaschev, M. (2008). Temporal description logics: A survey. In Proc.
of the 15th Int. Symp. on Temporal Representation and Reasoning (TIME 2008), pp. 314.
Marnette, B. (2009). Generalized schema-mappings: from termination to tractability. In Proc.
of the 28th ACM SIGACT SIGMOD SIGART Symp. on Principles of Database Systems
(PODS 2009), pp. 1322.
Marnette, B., & Geerts, F. (2010). Static analysis of schema-mappings ensuring oblivious termination. In Proc. of the 13th Int. Conf. on Database Theory (ICDT 2010), pp. 183195.
Martin, D., Paolucci, M., McIlraith, S., Burstein, M., McDermott, D., McGuinness, D., Parsia, B.,
Payne, T., Sabou, M., Solanki, Srinivasan, N., & Sycara, K. (2004). Bringing semantics to
web services: The OWL-S approach. In Proc. of the 1st Int. Workshop on Semantic Web
Services and Web Process Composition (SWSWPC 2004).
Meier, M., Schmidt, M., Wei, F., & Lausen, G. (2010). Semantic query optimization in the presence
of types. In 111-122 (Ed.), Proc. of the 29th ACM SIGACT SIGMOD SIGART Symp. on
Principles of Database Systems (PODS 2010).
Meyer, A., Smirnov, S., & Weske, M. (2011). Data in business processes. EMISA Forum, 31(3),
531.
685

fiBAGHERI H ARIRI , C ALVANESE , D E G IACOMO , D E M ASELLIS , F ELLI , & M ONTALI

Milner, R. (1971). An algebraic definition of simulation between programs. In Proc. of the 2nd Int.
Joint Conf. on Artificial Intelligence (IJCAI71), pp. 481489.
Motik, B., Cuenca Grau, B., Horrocks, I., Wu, Z., Fokoue, A., & Lutz, C. (2012). OWL 2 Web Ontology Language profiles (second edition). W3C Recommendation, World Wide Web Consortium. Available at http://www.w3.org/TR/owl2-profiles/.
Nigam, A., & Caswell, N. S. (2003). Business artifacts: An approach to operational specification.
IBM Systems Journal, 42(3), 428445.
Park, D. M. R. (1976). Finiteness is Mu-ineffable. Theoretical Computer Science, 3(2), 173181.
Poggi, A., Lembo, D., Calvanese, D., De Giacomo, G., Lenzerini, M., & Rosati, R. (2008). Linking
data to ontologies. J. on Data Semantics, X, 133173.
Reiter, R. (2001). Knowledge in Action: Logical Foundations for Specifying and Implementing
Dynamical Systems. The MIT Press.
Robinson, R. (1971). Undecidability and nonperiodicity of tilings on the plane. Inventiones Math.,
12, 177209.
Rosati, R., & Franconi, E. (2012). Generalized ontology-based production systems. In Proc. of the
13th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR 2012), pp.
435445. AAAI Press.
Schild, K. (1993). Combining terminological logics with tense logic. In Proc. of the 6th Portuguese
Conf. on Artificial Intelligence (EPIA93), Vol. 727 of Lecture Notes in Computer Science,
pp. 105120. Springer.
Stirling, C. (2001). Modal and Temporal Properties of Processes. Springer.
van Ditmarsch, H., van der Hoek, W., & Kooi, B. (2007). Dynamic epistemic logic. Springer.
van Emde Boas, P. (1997). The convenience of tilings. In Sorbi, A. (Ed.), Complexity, Logic, and
Recursion Theory, Vol. 187 of Lecture Notes in Pure and Applied Mathematics, pp. 331363.
Marcel Dekker Inc.
Vianu, V. (2009). Automatic verification of database-driven systems: a new frontier. In Proc. of the
12th Int. Conf. on Database Theory (ICDT 2009), pp. 113.
Wolter, F., & Zakharyaschev, M. (1998). Satisfiability problem in description logics with modal
operators. In Proc. of the 6th Int. Conf. on the Principles of Knowledge Representation and
Reasoning (KR98), pp. 512523.
Wolter, F., & Zakharyaschev, M. (1999a). Modal description logics: Modalizing roles. Fundamenta
Informaticae, 39(4), 411438.
Wolter, F., & Zakharyaschev, M. (1999b). Temporalizing description logic. In Gabbay, D., &
de Rijke, M. (Eds.), Frontiers of Combining Systems, pp. 379402. Studies Press/Wiley.

686

fi