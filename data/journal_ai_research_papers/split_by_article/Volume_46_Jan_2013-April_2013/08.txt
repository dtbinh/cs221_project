Journal of Artificial Intelligence Research 46 (2013) 303341

Submitted 09/12; published 03/13

Boolean Equi-propagation for Concise and Efficient SAT
Encodings of Combinatorial Problems
Amit Metodi
Michael Codish

amit.metodi@gmail.com
mcodish@cs.bgu.ac.il

Department of Computer Science
Ben-Gurion University of the Negev, Israel

Peter J. Stuckey

pjs@csse.unimelb.edu.au

Department of Computer Science and Software Engineering
and NICTA Victoria Laboratory
The University of Melbourne, Australia

Abstract
We present an approach to propagation-based SAT encoding of combinatorial problems, Boolean equi-propagation, where constraints are modeled as Boolean functions which
propagate information about equalities between Boolean literals. This information is then
applied to simplify the CNF encoding of the constraints. A key factor is that considering
only a small fragment of a constraint model at one time enables us to apply stronger, and
even complete, reasoning to detect equivalent literals in that fragment. Once detected,
equivalences apply to simplify the entire constraint model and facilitate further reasoning
on other fragments. Equi-propagation in combination with partial evaluation and constraint simplification provide the foundation for a powerful approach to SAT-based finite
domain constraint solving. We introduce a tool called BEE (Ben-Gurion Equi-propagation
Encoder) based on these ideas and demonstrate for a variety of benchmarks that our approach leads to a considerable reduction in the size of CNF encodings and subsequent
speed-ups in SAT solving times.

1. Introduction
In recent years, Boolean SAT solving techniques have improved dramatically. Todays SAT
solvers are considerably faster and able to manage larger instances than yesterdays. Moreover, encoding and modeling techniques are better understood and increasingly innovative.
SAT is currently applied to solve a wide variety of hard and practical combinatorial problems, often outperforming dedicated algorithms. The general idea is to encode a (typically,
NP) hard problem instance, , to a Boolean formula,  , such that the satisfying assignments of  correspond to the solutions of . Given such an encoding, a SAT solver can be
applied to solve .
Tailgating the success of SAT technology are a variety of tools which can be applied to
specify and then compile problem instances to corresponding SAT instances. The general
objective of such tools is to facilitate the process of providing high-level descriptions of how
the (constraint) problem at hand is to be solved. Typically, a constraint-based modeling
language is introduced and used to model instances. Drawing on the analogy to programming languages, given such a description, a compiler can then provide a low-level executable
c
2013
AI Access Foundation. All rights reserved.

fiMetodi, Codish, & Stuckey

for the underlying machine. Namely, in our context, a formula for the underlying SAT or
SMT solver.
For example, Cadoli and Schaerf (2005) introduce NP-SPEC, a logic-based specification
language which allows specifying combinatorial problems in a declarative way. At the core of
this system is a component which translates specifications to CNF formula. Similarly Sugar
(Tamura, Taga, Kitagawa, & Banbara, 2009) is a SAT-based constraint solver. To solve
a finite domain constraint satisfaction problem it is first modeled in a constraint language
(also called Sugar) and then encoded to a CNF formula and solved using the MiniSAT
solver (Een & Sorensson, 2003). MiniZinc (Nethercote, Stuckey, Becket, Brand, Duck, &
Tack, 2007) is a constraint modeling language that is compiled by a variety of solvers to
the low-level target language FlatZinc for which there exist many solvers. In particular,
FlatZinc instances are solved by fzntini (Huang, 2008) by encoding them to CNF and
in fzn2smt by encoding to SMT-LIB (Barrett, Stump, & Tinelli, 2010).
Simplifying CNF formulae prior to the application of SAT solving is of the utmost
importance and there are a wide range of techniques that can be applied to achieve this
goal. See for example the work of Li (2003), Een and Biere (2005), Heule, Jarvisalo, and
Biere (2011), and Manthey (2012), and the references therein their work. All of these
techniques exhibit a clear trade-off between the amount of simplification obtained and the
time it requires. Moreover, the stronger techniques become prohibitive when the SAT model
involves hundreds of thousands of variables and millions of clauses. So in CNF simplification
tools, time limits on simplification techniques are imposed and/or approximations are used.
This paper takes a new approach to CNF simplification. Typically, a CNF is not a random collection of clauses, but rather has a structure derived from an application or specific
problem domain. When SAT solving is applied to encode and solve finite domain constraint
problems, the original constraint model is a manifest of this structure. Usually, the constraints are discarded once encoded to CNF. We advocate that maintaining the constraints
provides important structural information that can be applied to drive the process of CNF
simplification. To be specific, the constraints in a model induce a partitioning of their CNF
encoding to a conjunction of sub-formulae which we call portions.
The novelty in our approach to CNF simplification is that instead of considering the CNF
as a whole, we assume that it is partitioned into a conjunction of smaller portions. Then
simplification is repeatedly applied to individual portions. This facilitates a propagationbased process because the simplification of one portion propagates information to all of the
portions and this information may trigger further simplification in other portions.
Because portions are typically much smaller than the entire CNF we can effectively apply
stronger simplification algorithms. We introduce the notion of equi-propagation. Similar to
how unit propagation is about inferring unit clauses which can then be applied to simplify
CNF formulae, equi-propagation is about inferring equational consequences between literals
(and Boolean constants).
There is a wide body of research on CNF simplification that can be applied to implement
equi-propagation which is sometimes called equivalent literal substitution, for example by
Gelder (2005). Techniques typically involve binary clause based simplifications using, among
others, hyper binary resolution and binary implication graphs. See for example, the work
of Heule et al. (2011) and the references therein. The guiding principle in all of these works
304

fiBoolean Equi-propagation

is that techniques must be simple and efficient because of the prohibitive size of the CNF
to which they must apply.
Our approach is different and we focus on far richer forms of inference not even related
to the CNF structure of a formula. At one extreme we apply complete equi-propagation
which detects all equivalences implied by a formula. Clearly complete equi-propagation is
NP-hard. However, complete equi-propagators are feasible as we apply them only to small
portions of the formula. When complete equi-propagation is too slow we consider ad-hoc
techniques. All of these forms of equi-propagation have in common that they are not driven
by the CNF structure (e.g. binary clauses) but rather by the underlying constraint structure
from which a CNF was, or is being, generated.
The rest of this paper is structured as follows. Section 2 introduces a modeling language
for finite domain constraints which consists of just 5 constraint constructs and is sufficient
to illustrate the contribution of the paper. We argue that the constraints in a model induce
a natural partition of their CNF encoding to smaller portions and that this partition can be
used to drive the simplification of the CNF encoding. Section 3 presents equi-propagation
which is the first ingredient for our contribution. Equi-propagation is about learning information that will apply to simplify CNF encodings. Section 4 describes a practical basis for
implementing equi-propagation. Section 5 introduces the second ingredient: partial evaluation. Given the information derived using equi-propagation, partial evaluation applies
to simplify the constraints and in particular to remove Boolean variables from their CNF
encodings. Section 6 describes a tool, called BEE (Metodi & Codish, 2012) (Ben-Gurion
Equi-propagation Encoder) that is based on equi-propagation and partial evaluation. We
introduce here our full constraint language which is similar to Sugar and to the subset
of FlatZinc relevant for finite domain constraint problems. We also spell out the special
treatment of the all-different constraint in BEE. Section 7 demonstrates the application of
BEE. Section 8 presents an experimental evaluation. and Finally Section 9 presents our
conclusion.
This paper extends earlier work presented by Metodi, Codish, Lagoon, and Stuckey
(2011), which first introduced equi-propagation, and also the BEE tool paper (Metodi &
Codish, 2012). The BEE tool is available for download (Metodi, 2012).

2. Constraint Based Boolean Modeling
This section provides the basis for our contribution: a constraint-based modeling language,
together with a Boolean interpretation for each constraint in the language. This enables us
to view a constraint model as a conjunction of Boolean formulae and provides a structure
which drives the subsequent encoding to CNF.
We first introduce a simple and small fragment of a typical finite domain constraint-based
modeling language. This serves to illustrate our approach. Later, in Section 6, we show
the full language. We then discuss several options for Boolean representation of integers.
In this paper we adopt a particular unary representation, called the order encoding. Our
contribution is independent of this choice, although equi-propagation works well with it.
Finally we finish the section so that each of the constraints in the language fragment can
be viewed as a Boolean formula, and a constraint model as their conjunction.
305

fiMetodi, Codish, & Stuckey

(1)
(2)
(3)
(4)
(5)

new int(I, c1 , c2 )
int neq(I1 , I2 )
allDiff([I1 , . . . , In ])
int plus(I1 , I2 , I)
int array plus([I1 , . . . , In ], I)

0  c1  I  c2
I1 6= I2
V
i<j Ii 6= Ij
I1 + I2 = I
I1 +    + In = I

Figure 1: A core constraint language
2.1 Constraint Language Fragment
We focus on a small fragment of a typical constraint modeling language detailed in Figure 1.
This serves to present the main ideas of the paper. Constraint (1) is about declaring finite
domain integer variables in the range [c1 ...c2 ]. For simplicity in the presentation we will
further assume that c1  0. Constraints (23) are about difference of integer variables,
and constraints (45) are about sums of integer variables. As syntactic sugar we also allow
writing integer constants in constraints. For example, int neq(I, 5) which is short for
new int(I0 , 5, 5), int neq(I, I0 ).
2.2 Modeling Kakuro: an Example
A Kakuro puzzle is an n  m board of black and white cells. The black cells contain hints
and the white cells are to be filled by numbers between 1 and 9 (the bound 9 is often
generalized by a larger value r). The hints specify constraints on the sums of the values in
blocks of white cells to the right and/or below the hint. The numbers assigned to the white
cells in such a block are required to be all different. Figure 2 illustrates a 4  4 Kakuro
puzzle (left) and its solution (right).
To model a Kakuro puzzle we view it as a set of blocks (of white cells) where each block
B is a set of integer variables and is associated with a corresponding integer value, hint(B).
Each block B is associated with two constraints: the integers in B must sum to hint(B)
and must be all-different. Figure 3 illustrates the constraints corresponding to the Kakuro
instance in Figure 2.
2.3 Representing Integers
A fundamental design choice when encoding finite domain constraints concerns the representation of integer variables. Gavanelli (2007) surveys several of the possible choices (the

Figure 2: A 4  4 Kakuro puzzle (right) and its solution (left).
306

fiBoolean Equi-propagation

new
new
new
new
new
new
new

int(I1 , 1, 9)
int(I2 , 1, 9)
int(I3 , 1, 9)
int(I4 , 1, 9)
int(I5 , 1, 9)
int(I6 , 1, 9)
int(I7 , 1, 9)

int
int
int
int
int
int

array
array
array
array
array
array

plus([I1 , I2 ], 13)
plus([I1 , I3 ], 5)
plus([I3 , I4 , I5 ], 12)
plus([I2 , I4 , I6 ], 19)
plus([I6 , I7 ], 3)
plus([I5 , I7 ], 4)

allDiff([I1 , I2 ])
allDiff([I1 , I3 ])
allDiff([I3 , I4 , I5 ])
allDiff([I2 , I4 , I6 ])
allDiff([I6 , I7 ])
allDiff([I5 , I7 ])

Figure 3: Constraints for the Kakuro instance of Figure 2.

direct-, support- and log- encodings) and introduces the log-support encoding. Given a choice
of representation constraints are bit-blasted and interpreted as Boolean formulae. We focus
for now on the use a unary representation, the so-called, order-encoding (see, e.g. Crawford
& Baker, 1994; Bailleux & Boufkhad, 2003) which has many nice properties when applied
to small finite domains.
In the order-encoding, an integer variable X in the domain [0, . . . , n] is represented by
a bit vector X = [x1 , . . . , xn ]. Each bit xi is interpreted as X  i so in particular the bit
sequence X constitutes a monotonic non-increasing Boolean sequence. For example, the
value 3 in the interval [0, 5] is represented in 5 bits as [1, 1, 1, 0, 0].
An important property of a Boolean representation for finite domain integers is the
ability to represent changes in the set of values a variable can take. It is well-known
that the order-encoding facilitates the propagation of bounds. Consider an integer variable
X = [x1 , . . . , xn ] with values in the interval [0, n]. To restrict X to take values in the range
[a, b] (for 1  a  b  n), it is sufficient to assign xa = 1 and xb+1 = 0 (if b < n). The
variables xa0 and xb0 for 0  a0 > a and b < b0  n are then determined true and false,
respectively, by unit propagation. For example, given X = [x1 , . . . , x9 ], assigning x3 = 1 and
x6 = 0 propagates to give X = [1, 1, 1, x4 , x5 , 0, 0, 0, 0], signifying that dom(X) = {3, 4, 5}.
We observe an additional property of the order-encoding for X = [x1 , . . . , xn ]: its ability
to specify that a variable cannot take a specific value 0  v  n in its domain by equating
two variables: xv = xv+1 . This indicates that the order-encoding is well-suited not only to
propagate lower and upper bounds, but also to represent integer variables with an arbitrary,
finite set, domain. For example, given X = [x1 , . . . , x9 ], equating x2 = x3 imposes that
X 6= 2. Likewise x5 = x6 and x7 = x8 impose that X 6= 5 and X 6= 7. Applying
these equalities to X gives, X = [x1 , x2 , x2 , x4 , x5 , x5 , x7 , x7 , x9 ] (note the repeated literals),
signifying that dom(X) = {0, 1, 3, 4, 6, 8, 9}.
The order-encoding has many additional nice features that can be exploited to simplify
constraints and their encodings to CNF. To illustrate one, consider a constraint of the form
A + B = 5 where A and B are integer values in the range between 0 and 5 represented in
the order-encoding. At the bit level (in the order encoding) we have: A = [a1 , . . . , a5 ] and
B = [b1 , . . . , b5 ]. The constraint is satisfied precisely when B = [a5 , . . . , a1 ]. Instead of
encoding the constraint to CNF, we substitute the bits b1 , . . . , b5 by the literals a5 , . . . , a1 ,
and remove the constraint. In section 3 we formalize this process of discovering equalities
between literals implied by a constraint and using them to simplify CNF encodings.
307

fiMetodi, Codish, & Stuckey

2.4 Bit Blasting
Given a constraint model and the decision on how to represent finite domain integer variables
at the bit level (we chose the order encoding), bit-blasting is the process of instantiating integer variables by corresponding bit vectors and interpreting constraints as Boolean
formulae.
Each integer variable, I, declared by a constraint of the form new int(I, c1 , c2 ) where
0  c1  c2 is represented as a bit-vector I = [1, . . . , 1, Xc1 +1 , . . . , Xc2 ]. So, we may view a
constraint model as consisting only of Boolean variables and each constraint c corresponds
to a Boolean formula denoted as [[c]], the bit-blasted version of c. The specific definition
of [[]] is not important. Just for illustration, note that one could define
^
[[new int(I, c1 , c2 )]] =
(xi+1  xi )
c1 i<c2

where I = [1, . . . , 1, Xc1 +1 , . . . , Xc2 ] as well as
[[int neq(I1 , I2 )]] =

n
_

(xi xor yi )

i=1

where to simplify presentation we assume that I1 = [x1 , . . . , xn ] and I2 = [y1 , . . . , yn ] are
represented in the same number of bits. The mapping [[]] extends in the natural way to apply
to conjunctions of constraints. So, given a constraint model such as the one in Figure 3,
integer variables are instantiated to unary (order encoding) bit vectors and each constraint
is viewed as a Boolean formula. The constraint model takes a Boolean representation as
the conjunction of these formulae.

3. Boolean Equi-propagation
In this section we present an approach to propagation-based SAT encoding, Boolean equipropagation, which propagates information about equalities between Boolean literals (and
constants). We prove that Boolean equi-propagation is stronger than unit propagation as
it determines at least as many fixed literals as unit propagation. We demonstrate, with an
example, the power of equi-propagation and show that it leads to a considerable reduction
in the size of the CNF encoding.
3.1 Boolean Equi-propagation
Let B be a set of Boolean variables. A literal is a Boolean variable b  B or its negation
b. The negation of a literal `, denoted `, is defined as b if ` = b and as b if ` = b.
The Boolean constants 1 and 0 represent true and false, respectively. The set of literals
is denoted L and L0,1 = L  {0, 1}. The set of (free) Boolean variables that appear in a
Boolean formula  is denoted vars(). We extend the vars function to sets of formulae in
the natural way.
An assignment, A, is a partial mapping
from Boolean
to 	constants, often
fi
 fi
	  variables
fi
fi
viewed as the following set of literals: b A(b) = 1  b A(b) = 0 . For a formula
 and b  B, we denote by [b] (likewise [b]) the formula obtained by substituting all
308

fiBoolean Equi-propagation

occurrences of b  B in  by true (false). This notation extends in the natural way for
sets of literals. We say that A satisfies  if vars()  vars(A) and [A] evaluates to true.
A Boolean Satisfiability (SAT) problem consists of a Boolean formula  and determines if
there exists an assignment which satisfies .
A Boolean equality is a constraint ` = `0 where `, `0  L0,1 . An equi-formula E is a set
of Boolean equalities understood as a conjunction. The set of Boolean equalities is denoted
Leq
0,1 and the set of equi-formulae is denoted E.
Example 1. Suppose B = {x, y, z}. Then L0,1 = {0, 1, x, x, y, y, z, x}. An example
assignment is A = {x, z}, while B = {x, y, z, y} is not an assignment (since it includes
{y, y}). Given the formula  = x  (y  z) then [x] is the formula 0  (y  z) or
equivalently y  z. The formula [A] = 1  (y  1) which is equivalent to true, but A does
not satisfy  since vars() = {x, y, z} 6 {x, z} = vars(A). An example equi-formula for B
is {x = 0, y = z} or equivalently x  (y  z).
3.1.1 Equi-propagation
is a process of inferring equational consequences from a Boolean formula and given equational information. An equi-propagator for a formula  is an extensive function  : E  E
defined such that for all E  E,
o
n
fi
fi
E   (E)  e  Leq
0,1   E |= e
That is, a conjunction of equalities, at least as strong
true by o E. We say
n as E, made
eq fifi
that an equi-propagator  is complete if  (E) = e  L0,1   E |= e . We denote
a complete equi-propagator for  as  . We assume that equi-propagators are monotonic:
E1  E2   (E1 )   (E2 ). In particular, this follows, by definition, for complete
equi-propagators. In Section 3.3 we discuss several methods to implement complete and
incomplete equi-propagators.
Example 2. Consider the constraint
C = new int(X, 0, 4)  new int(Y, 0, 4)  int neq(X, Y)
and its corresponding Boolean representation  = [[C]] on the bit representation where
X = [x1 , x2 , x3 , x4 ] and Y = [y1 , y2 , y3 , y4 ]
Assume the setting where
E=



y1 = 1, y2 = 1, y3 = 0, y4 = 0

	

signifying that Y = 2. Then,  (E) = E  {x2 = x3 } indicating that X 6= 2. This occurs
since   E is equivalent to (x2  x1 )  (x3  x2 )  (x4  x3 )  (x1  x2  x3  x4 ) and
  E |= x2 = x3 .
The following theorem states that complete equi-propagation is at least as powerful as
unit propagation.
309

fiMetodi, Codish, & Stuckey

Theorem 3. Let  be a complete equi-propagator for a Boolean formula . Then, any
literal that is made true by unit propagation for any clausal representation of  using the
equations in E is also determined true by  (E).
Proof. Let  be a Boolean formula, E an equi-formula, and let C and CE be any clausal
representations of  and of E respectively. Clearly  |= C and E |= CE . Let b be a
positive literal determined by unit propagation of C  CE . Then by correctness of unit
propagation, C  CE |= b. Hence,   E |= b and thus  (E) |= b = 1. The case for a
negative literal b is the same, except that we infer b = 0.
The following example illustrates that equi-propagation can be more powerful than unit
propagation.
Example 4. Consider  = (x1  x2 )  (x1  x2 )  (x1  x2  x3 ). The clausal
representation is (x1 x2 )(x1 x2 )(x1 x2 )(x1 x2 x3 ) and no unit propagation
is possible, since there are no unit clauses. Equi-propagation (with no additional equational
information) gives:  () = {x1 = 1, x2 = 1, x3 = 0}.
3.1.2 Boolean Unifiers
It is sometimes convenient to view an equi-formula E in a generic solved-form as a Boolean
substitution, E , which is a (most general) unifier for the equations in E. Boolean substitutions generalize assignments in that variables can be bound also to literals.fi A Boolean
	
substitution is an idempotent mapping  : B  L0,1 where dom() = b  B fi (b) 6= b
is finite. Note in particular that idempotence implies that (b) 6= b for every b  B.
Note also that  is defined for all B and that its domain, dom(), includes those elements
for which
it is non-identity.
A Boolean substitution, , is viewed as the set  =
fi

	
b 7 (b) fi b  dom()
.
We
can
apply  to another 	substitution 0 , to obtain substifi

tution (  0 ) = b 7 (0 (b)) fi b  dom()  dom(0 ) . A unifier for equi-formula E
is a substitution  such that |= (e), for each e  E. A most-general unifier for E is a
substitution  such that for any unifier 0 of E, there exists substitution  where 0 =   .
Example 5. Consider the equi-formula E  {b1 = b2 , b3 = b4 , b5 = b6 , b6 = b4 , b7 =
1, b8 = b7 } then a unifier  for E is {b2 7 b1 , b4 7 b3 , b5 7 b3 , b6 7 b3 , b7 7 1, b8 7 0}.
Note that (E) is the trivially true equi-formula {b1 = b1 , b3 = b3 , b3 = b3 , b3 = b3 , 1 =
1, 0 = 1}.
Consider the enumeration L0,1 = {0, 1, b1 , b1 , b2 , b2 , . . .} and let  be the total (strict)
order on L0,1 such that 0  1  b1  b1  b2  b2    . We define a canonical most-general
unifier unifyE for any satisfiable equi-formula E where:
fi

	
unifyE (b) = min `  L0,1 fi E |= b = `
That is, the substitution unifyE maps each b to the smallest literal equivalent to b given
E. We can compute unifyE in almost linear (amortized) time using a variation of the
union-find algorithm (Tarjan, 1975).
Example 6. For the equi-formula E and substitution  from Example 5 we have that
unifyE = .
310

fiBoolean Equi-propagation

The following proposition provides the foundation for equi-propagation based Boolean
simplification. It allows us to apply equational information to simplify a given formula. In
particular, if E is an equi-formula about literals occurring in  then unifyE () is smaller
than  in that it contains fewer variables.
Proposition 1. Let  be a Boolean formula and E  E be a satisfiable equi-formula. Then,
a.   E  unifyE ()  E;
b.   E is satisfiable if and only if unifyE () is satisfiable; and
c. if  is a satisfying assignment for unifyE () then unifyE is a satisfying assignment
for   E.
Proof. (a) Let  = unifyE and assume that  is a satisfying assignment of E, then we can
view  as a substitution, and as a unifier of E. Hence, since  is a most general unifier, there
exists a substitution  such that  =  . Clearly (b) = (b) for all variables b in the range
of . Hence,  and  agree on all variables in () which implies that (()) = (())
meaning that (()) = (). So,  is a satisfying assignment of ()  E if and only
if  is a satisfying assignment of   E. (b) The () direction follows from (a) and the
() direction from (c). (c) Assume  is a satisfying assignment of unifyE (). Clearly
  unifyE satisfies  by construction. Also   unifyE satisfies E since unifyE (E) is
trivial. Hence   unifyE is a satisfying assignment of   E.
3.1.3 The Equi-propagation Process
The equi-propagation process presented now is a central theme in this paper: Let  =
1      n be a partitioning of a Boolean formula to n portions, let 1 , . . . , n be corresponding equi-propagators, and take initial E = . Satisfiability of  can be determined
as follows:
1. So long as possible, select i such that i (E) ) E and update E = i (E).
2. Finally, when the equi-propagators apply no more, check if unifyE () is satisfiable.
3. If  is a satisfying assignment for unifyE () then unifyE  is a satisfying assignment
for .
We typically apply this equi-propagation theme to the Boolean representation  =
1      n of a constraint model C = C1      Cn where i = [[Ci ]]. Here we require that
each Ci is a small conjunction of constraints. Typically, the integer variables referred
to in each Ci are also declared in Ci (sometimes this requires duplicating the variable
declarations). For an individual constraint c we denote by c+ the conjunction of constraints
including c and the declarations for integer variables it refers to. The specifics of these
declarations will be clear from the context.
Example 7. Let C be the following constraint model:

new int(X, 1, 3)  new int(Y, 1, 3)  new int(Z, 1, 3) 
C=
int plus(X, Y, 3)  int plus(Y, Z, 4)  int neq(Y, Z)
We have
311



fiMetodi, Codish, & Stuckey

1. int plus+ (X, Y, 3) = int plus(X, Y, 3)  new int(X, 1, 3)  new int(Y, 1, 3),
2. int plus+ (Y, Z, 4) = int plus(Y, Z, 4)  new int(Y, 1, 3)  new int(Z, 1, 3),
3. int neq+ (Y, Z) = int neq(Y, Z)  new int(Y, 1, 3)  new int(Z, 1, 3).
As a basis for equi-propagation we take  = 1  2  3 where 1 = [[int plus+ (X, Y, 3)]],
2 = [[int plus+ (Y, Z, 4)]], and 3 = [[int neq+ (Y, Z)]]. Denoting X = [1, x2 , x3 ], Y =
[1, y2 , y3 ], and Z = [1, z2 , z3 ] and applying corresponding complete equi-propagators and
starting with E0 =  we have:
1. E1 = 1 (E0 ) = E0  {x3 = 0, y3 = 0, x2 = y2 };
2. E2 = 2 (E1 ) = E1  {z2 = 1, y2 = z3 };
3. E3 = 3 (E2 ) = E2  {y2 = 0}.
At this point equi-propagation applies no more, and unifyE3 = {x2 7 1, x3 7 0, y2 7
0, y3 7 0, z2 7 1, z3 7 1} . Now, unifyE3 () is a tautology (all of the Boolean variables
are determent by equi-propagation).
The following theorem clarifies that the order in which equi-propagators are applied in
the equi-propagation process does not influence the final result.
Theorem 8. The equi-propagation process is confluent.
Proof. Let  = 1      n be a Boolean formula and 1 , . . . , n corresponding equipropagators. Let E1 = ir (ir1 (. . . i1 () . . .)) and E2 = js (js1 (. . . j1 () . . .))
be two different applications of the equi-propagation process. So by construction, for each
of the given equi-propagators, we have a property (?): i (E1 ) = E1 and i (E2 ) = E2 .
Now assume, in contradiction, that E1 6= E2 . Then w.l.o.g. there exists e  E2 where e
not  E1 (swap the roles of E1 and E2 if E2  E1 ). E1 ( E2 . Let us focus on the first
step in the equi-propagation process leading to E2 that introduced the equation e  E2 not
introduced to E1 : So, there exists an ` < s such that E = j` (j`1 (. . . j1 () . . .))  E1
and e  `+1 (E) but e 6 E1 . But, if E  E1 , then by the monotonicity of `+1 , we have
that `+1 (E)  `+1 (E1 ) and hence e  `+1 (E1 ) in contradiction to the construction
with property (?).
The following proposition provides an alternative, more efficient to implement, definition
for complete equi-propagation.
Proposition 2. Let  be a Boolean formula and  a complete equi-propagator for .
Define for E  E,
n
o
fi
fi unify () |= e
 (E) = E  e  Leq
E
0,1
Then,  (E) =  (E). That is,  implements a complete equi-propagator for .
312

fiBoolean Equi-propagation

Proof. Forthefi first direction, ():
	 By definition, we have that  (E)  E. We also have
 (E)  e fi unifyE () |= e
because by Proposition 1(a)   E |= unifyE (). So,
 (E)   (E). For the other direction, (): Let e   (E). If e  E then the proof
is straightforward. Otherwise, let unifyE () |= e and assume in contrary that e 6  (E),
or in other words that   E 6|= e. This means that there exists an assignment  that
satisfies   E but does not satisfy e. By Lemma 1(a),  also satisfies unifyE ()  E and in
particular  satisfies unifyE (). From our assumption that unifyE () |= e we now have
that  satisfies e. Contradiction.
Computing  is considerably more efficient than  since we can simply examine the
formula  after the application of unifyE to determine new Boolean equality consequences.
Finally we comment: Our intention is that the equi-propagation process be applied not
only to make a SAT instance smaller but also to obtain an easier to solve representation.
However, decreasing the size of the CNF is not the main objective. In fact, often we explicitly
introduce redundancies to improve a SAT encoding. For example, consider an if-thenelse construct, xITE(s,t,f), where propositional variable: s indicates the selector, t
indicates the true branch, f indicates the false branch, and x indicates the result. The
corresponding CNF is {{s, t, x}, {s, t, x}, {s, f, x}, {s, f, x}}. Een and Sorensson
(2006) propose to add redundant clauses, {t, f, x} and {t, f, x}. They comment that
this improves the encoding and they observe that redundant clauses are often introduced
to achieve arc-consistency in the SAT encoding. We show that given a clausal encoding of
some formula , application of equi-propagation can only strengthen unit propagation.
Theorem 9. Let C be a set of clauses, and suppose C |= E where E is an equi-formula.
Then unit propagation on unifyE (C) is at least as strong as unit propagation on C.
Proof. Unit propagation on C starting from assignment A0 repeatedly chooses a clause
c  {l}  C where {l0 | l0  c}  Ai and sets Ai+1 := Ai  {l}. Unit propagation terminates
with Ak when no such clauses occur. Note that failure is detected when Ak contains both
a literal and its negation.
We show that using a order of unit propagation on unifyE (C) determined by that which
occurs on C starting from assignment B0 = unifyE (A0 ) we always obtain an assignment
Bi where Bi  unifyE (Ai ). The proof is by induction on the unit propagation steps in C.
The base case holds by construction.
Assume c  {l}  C where {l0 | l0  c}  Ai . Then by induction Bi  unifyE (Ai ) 
{unifyE (l0 ) | l0  c}. Either unifyE (l)  Bi in which case we set Bi+1 = Bi and the
induction holds. Or unifyE (l) 6 Bi . Now since c  {l}  C we have that {unifyE (l0 ) | l0 
c}{unifyE (l)}  unifyE (C). Hence by unit propagation on unifyE (C) and Bi we obtain
Bi+1 := Bi  {unifyE (l)}. Hence the induction holds.
Given that unit propagation reaches a unique fixpoint then any unit propagation order
on unifyE (A0 ) will end up with an assignment B where B  Bk  unify(Ak )
3.2 The Power of Equi-propagation
To illustrate the impact of equi-propagation we come back to the Kakuro example from
Section 2.2 (recall Figure 2). In fact solving such puzzles via SAT encodings is quite easy,
with and without equi-propagation. So the example should only be viewed as illustrating
313

fiMetodi, Codish, & Stuckey

a. 1

b. 2

c. 3

Figure 4: Applying complete equi-propagation to a Kakuro Instance using different models

the impact of equi-propagation on the size of the encoding. We compare 3 different models
of the problem, which each give different equi-propagation.
We consider, as a baseline for this discussion, the following Boolean representation
derived from a constraint model where the declarations which are not specified explicitly
are of the form new int(I, 1, h) where h is the smallest hint for a block that includes I or
the number 9 if that is smaller.
^
^
1 =
[[int neq+ (Ii , Ij )]] 
[[int array sum+ (B, hint(B))]]
{I1 , . . . , Ik }  Blocks
1i<j k

B  Blocks

Notice that there is one int neq conjunct for each pair of white cells in the same block,
and one int array sum conjunct for each block. Applying the equi-propagation process to
1 with complete equi-propagators determines six integer values as depicted in Figure 4(a).
Figure 4(b) illustrates the impact of applying the equi-propagation process where the
equi-propagators are for allDiff constraints instead of for the individual int neq constraints. This determines seven integer variables and is formalized taking the following
Boolean representation of the constraint model (and introducing an equi-propagator for
each conjunct).
^
^
2 =
[[allDiff+ (B)]] 
[[int array sum+ (B, hint(B))]]
B  Blocks

B  Blocks

Figure 4(c) illustrates the impact of applying the equi-propagation process where the equipropagators are for pairs, each consisting of an allDiff constraint together with its corresponding sum constraint. This form of equi-propagation is most powerful. It fixes integer
values for all of the white cells (in this example). We stress that equi-propagation reasons
only about equalities between Boolean literals and constants. Here we take the model as:
^

3 =
[[allDiff+ (B)]]  [[int array sum+ (B, hint(B))]]
B  Blocks

To further demonstrate the impact of equi-propagation, Table 1 provides data for 15
additional instances,1 categorized as: easy, medium and hard. The first two columns
in the table indicate the instance category and ID. From the five columns headed Integer
1. Instances available from http://4c.ucc.ie/~hcambaza/page1/page7/page7.html (generated by Helmut
Simonis).

314

fihard

medium

easy

Boolean Equi-propagation

ID
168
169
170
171
172
188
189
190
191
192
183
184
185
186
187

Integer Variables
init 1 2 3 BEE
init
484 439 280
0 385 3872
467 456 440
0 440 3736
494 485 469
0 469 3952
490 406 393
0 422 3920
506 495 484
0 492 4048
476 461 455
0 461 3808
472 437 425
62 449 3776
492 481 480
0 480 3936
478 452 448 161 448 3824
499 481 478 136 478 3992
490 365 345
0 371 3920
506 489 484
23 486 4048
482 482 455 206 467 3856
472 466 454
0 466 3776
492 475 473
69 473 3936
Average compilation time in sec.

Boolean Variables
1
2
3
1440
843
0
1823 1682
0
1961 1798
0
1280 1148
0
1676 1573
0
1939 1915
0
2017 1911
81
1998 1920
0
1864 1821
197
2455 2417
214
1151 1059
0
1613 1495
21
2181 2111
220
2115 2062
0
1991 1959
48
3.739 2.981 0.916

BEE
1170
1692
1805
1341
1634
1934
1976
1936
1828
2420
1168
1545
2144
2086
1960
0.477

Table 1: Applying SAT-based complete equi-propagation on Kakuro encoding
Variables, the first four specify the number of unassigned white cells in the initial stage and
after each of the three complete equi-propagation processes described above. From the five
columns headed Boolean variables, the first four indicate the corresponding information
regarding the number of Boolean variables in the bit representations of the integers. So,
the smaller the number in the table, the more variables have been removed due to equipropagation. In particular, the 3 model completely solves 9 of the 15 instances. The two
columns titled BEE show the corresponding information obtained using a weaker form of
equi-propagation that is described in Section 4 below. The last row of the table indicates
the average time it takes to perform equi-propagation (in seconds) using each of the three
schemes, 1 , 2 , 3 , and the weaker scheme titled BEE. We will come back to discuss this
later after detailing how equi-propagation is performed. The results in the table indicate
the clear benefit in performing equi-propagation based on coarser portions of the model.
3.3 Implementing Equi-propagators
To implement complete equi-propagators we need to infer Boolean equalities implied by a
given Boolean formula, , and equi-formula, E. Based on Proposition 2, it is sufficient to
test for the condition
unifyE () |= (`1  `2 )
(1)
We consider three techniques: using a SAT solver, using BDDs, and using ad-hoc rules
applied to the Boolean representations of individual constraints.
It is straightforward to implement a complete equi-propagator using a SAT solver. To
test Condition (1) we consider the formula  =   (`1 6 `2 ). If  is not satisfiable, then
Condition (1) holds. In this way, Condition (1) can be checked for all relevant equations
315

fiMetodi, Codish, & Stuckey

involving variables from unifyE () (and constants 0,1). A major obstacle with this SATbased approach is that testing for a single equivalence, `1  `2 , is at least as hard as testing
for the satisfiability of . In fact testing for unsatisfiability is typically more expensive.
Hence the importance of our assumption that  is only a small fragment of the CNF of
interest. In practice SAT-based equi-propagation is surprisingly fast. For illustration, in
the last row of Table 1 the average times for SAT-based complete equi-propagation for the
different models are indicated in the columns 1 , 2 , and 3 . It is interesting to observe
that the strongest technique, using 3 , is the fastest. This is because there are fewer (but
larger) conjuncts and hence fewer queries to the SAT solver.
We can implement a complete equi-propagator using binary decision diagrams (BDDs)
as follows. We construct a BDD for formula  at the beginning of equi-propagation. When
new equational information E 0 is added to E we simplify the BDD for  by conjoining
the BDD with a BDD for E 0 and then projecting out the variables that no longer appear in
unifyE (). Note that this simplification can increase the size of the BDD. In practice,
rather than these two steps, we can use the Restrict operation of Coudert and Madre
(1990) (bdd simplify in Somenzi, 2009) to create the new BDD more efficiently.
Given the BDD for unifyE (), we can explicitly test Condition (1) using a standard
BDD containment test (e.g., bddLeq in Somenzi, 2009). Just as in the SAT-based approach, this test is performed for all relevant equations involving variables from unifyE ()
(and constants 0,1). Alternately we can use the method of Bagnara and Schachte (1998)
(extended to extract literal equalities as opposed to just variable equalities) to extract all
the fixed literals and equivalent literal consequences of the BDD.
Example 10. Consider the BDD shown in Figure 5(a) which represents the formula:
  new int(A, 0, 3)  new int(B, 0, 3)  int neq(A, B). Figure 5(b) depicts the The BDD
for unifyE () where E = {B1 = 1, B2 = 1, B3 = 0 }. Here it is easy to see that equipropagation determines that A2 = A3 . Let E 0 = E  {A2 = A3 }. Then Figure 5(c) shows
the simplified BDD for unifyE 0 ().
A major obstacle with this BDD-based approach concerns the size of the formula
unifyE (). For some constraints, the corresponding BDD is guaranteed to be polynomial (in the size of the constraint). The following result holds for an arbitrary constraint
, so it also holds for unifyE ().
Proposition 3. Let c be a constraint about k integer variables each represented with n bits
in the order encoding. Then, the number of nodes in the BDD representing [[c]] is bound by
O(nk ).
Proof. (Sketch) There are only n + 1 legitimate states for each n bit unary variable, and
the BDD cannot have more nodes than possible states.
Constraints like new int, int neq, and int plus involve at most 3 integer variables and
hence their BDD-based complete equi-propagators are polynomially bounded. However,
this is not the case for global constraints such as allDiff and int array plus where the
arity is not fixed. Moreover, it is well known that the allDiff constraint does not have a
polynomial sized BDD (Bessiere, Katsirelos, Narodytska, & Walsh, 2009).
316

fiBoolean Equi-propagation
7654
0123
A1:

:

:
7654
0123
7654
0123
B1
B1


 

0123
7654
0123 7654
7654
0123
r A 2 rrr A2: A2
r
r
:
r r
rr
rrr rrrr
 :
r
0123 7654
0123
0123
0123
7654
0123
B2 L 7654
B2
B2: 7654
B2: 7654
, LLB 2

::
L
:
L
:
,
 LLL
::
:
,  L
7654
0123
7654
0123
0123
,
A3: A3 l 7654
A3
,   : l -ll
,   l l : l
7654
0123
7654
0123
B3 S
S S B3;; - S S ;;
S S;-

7654
0123
A1
.
  .
.

.
 
.

0123
7654
0123
7654
A2
A2
.

.

.
. 
. 
0123
0123
7654
A3.
A3 > 7654
>>
>> .
>> .
>> .
>>
>.

7654
0123
A1
+
+

T





+



+

+
7654
0123
A2



T

T

(a) BDD for int nequ (A, B)

(b) Simpld wrt B=[1, 1, 0]

(c) Simpld wrt A2 =A3

Figure 5: BDDs for (a)   new int3 (A, [0, 3])  new int3 (B, [0, 3])  int neq(A, B) (b)
unifyE () where E = {B1 =1, B2 =1, B3 =0} and (c) unifyE 0 () where E 0 =
E  {A2 =A3 }. Full (dashed) lines correspond to true (false) edges. Edges to the
false node F are omitted for brevity.

Given the potential exponential run-time when performing SAT-based equi-propagation,
and the potential exponential size of BDD-based equi-propagators, we consider a third
approach where we implement equi-propagation by a collection of ad-hoc transition rules
for each type of constraint. While this approach is not complete  there are equations
implied by a constraint that are not detected  the implementation is fast, and works well
in practice. This is the topic of the next section.

4. Ad-hoc Equi-Propagation
We consider a rule-based approach to define equi-propagators. The definition is given as a
set of ad-hoc rules specified for each type of constraint. The novelty is that the approach
is not based on CNF, as in previous works, but rather driven by the bit blasted constraints
that are to be encoded to CNF. Our presentation focuses on the case where finite domain
integers are represented in the order encoding. For an integer X = [x1 , . . . , xn ], we often
write: X  i to denote the equation xi = 1, X < i to denote the equation xi = 0, X 6= i to
denote the equation xi = xi+1 , and X = i to denote the pair of equations xi = 1, xi+1 = 0.
Moreover, to simplify notation when specifying the rules below, we view X = [x1 , . . . , xn ] as
a larger vector padded with sentinel cells such that all cells to the left of x1 take value 1
and all cells to the right of xn take the value 0. Basically this facilitates the specification
of the end cases in our formalism. We now consider each of the 5 constraints in the
language fragment presented in Section 2.
317

fiMetodi, Codish, & Stuckey

c = new int([x1 , . . . , xn ], 0, n)
if in E
then add in c (E)
xi = 1 x1 = 1, . . . , xi1 = 1
xi = 0 xi+1 = 0, . . . , xn = 0

(a)

c = int neq(X, Y ) where
X = [x1 , . . . , xn ] and Y = [y1 , . . . , yn ]

if in E
then add in c (E)
X=i
Y 6= i
xi = yi+1 , yi = xi+1
X 6= i, Y 6= i
xi = yi+1 , yi = xi+1
X 6= i, Y 6= i
(b)

Figure 6: Ad-hoc rules for (a) new int and (b) int neq
c = int plus(X, Y, Z) where X = [x1 , . . . , xn ],
Y = [y1 , . . . , ym ], and Z = [z1 , . . . , zn+m ]

c = allDiff([Z1 , Z2 , Z3 , . . . , Zn ])
if in E
then add in c (E)
Z1 , Z2  {i, j}

Z1 =
6 Z2 , Zk 6= i
Zk =
6 j (k > 2)

if in E
X  i, Y  j
X < i, Y < j
Z  k, X < i
Z < k, X  i
X=i
Z=k

(a)

then add in c (E)
Z i+j
Z <i+j1
Y ki
Y <ki
zi+1 = y1 , . . . , zi+m = ym
x1 = yk , . . . , xk = y1
(b)

Figure 7: Ad-hoc rules for (a) allDiff and (b) int plus

(1) The two rules in Figure 6(a) derive from the monotonicity in the order encoding
representation. These basically correspond to unit propagation, but at the constraint level.
(2) The first rule in Figure 6(b) considers cases when X is a constant (the symmetric
case can be handled by exchanging X and Y ). The other two rules capture templates
that commonly arise in the equi-propagation process. To illustrate the justification of the
third rule consider all possible truth values for the variables xi and xi+1 : (a) If xi = 0
and xi+1 = 1 then both integers in the relation take the form [. . . , 0, 1, . . .] violating their
specification as ordered, so this is not possible. (b) If xi = 1 and xi+1 = 0 then both
numbers take the form [1, . . . , 1, 0, . . . , 0] and are equal, violating the neq constraint. The
only possible bindings for xi and xi+1 are those where xi = xi+1 .
(3) In Figure 7(a) we illustrate a single rule for the allDiff constraint which considers
Hall sets of size 2. Here each Zi represents an integer in the order encoding and we focus
on the case when Z1 and Z2 are restricted by the equations in E to take only two possible
values, i or j. This can be expressed in E because [x1 , . . . , xn ]  {i, j} (for i < j) means
that xk = 1 for k < i, xk = xk+1 for i  k < j, and xk = 0 for j < k  n. Z1 6= Z2 then
means adding the single equation xi = yi (because Z1 and Z2 can take only two values).
In addition to this rule, we apply the rules for int neq(Zi , Zj ) for each pair of integers Zi
and Zj in the constraint.
318

fiBoolean Equi-propagation




z1 =1, . . . , z4 =1,
E0 =
z5 =0, . . . , z18 =0
X = [x1 , . . . , x4 , x5 , x6 , . . . , x9 ],
Y = [y1 , . . . , y4 , y5 , y6 , . . . , y9 ],
Z = [1, 1, 1, 1, 0, . . . , 0]
E2 = E1  {y6 =0, . . . , y9 =0}
X = [x1 , . . . , x4 , x5 , x6 , . . . , x9 ],
Y = [y1 , . . . , y4 , 0, . . . , 0],
Z = [1, 1, 1, 1, 0, . . . , 0]
E4 = E3  {x6 =0, . . . , x9 =0}
X = [x1 , . . . , x4 , 0, . . . , 0],
Y = [y1 , . . . , y4 , 0, . . . , 0],
Z = [1, 1, 1, 1, 0, . . . , 0]

x2 =y3 ,
y2 =x3


int neq

Z<5, X0


int plus

Z<5, Y 0


int plus

Z=4


int plus

E1 = E0  {y5 =0}
X = [x1 , . . . , x4 , x5 , x6 , . . . , x9 ],
Y = [y1 , . . . , y4 , 0, y6 , . . . , y9 ],
Z = [1, 1, 1, 1, 0, . . . , 0]

E3 = E2  {x5 =0}
X = [x1 , . . . , x4 , 0, x6 , . . . , x9 ],
Y = [y1 , . . . , y4 , 0, . . . , 0],
Z = [1, 1, 1, 1, 0, . . . , 0]

E5 = E4  {x1 =y4 , . . . , x4 =y1 }
X = [x1 , x2 , x3 , x4 , 0, . . . , 0],
Y = [x4 , x3 , x2 , x1 , 0, . . . , 0],
Z = [1, 1, 1, 1, 0, . . . , 0]

y5 =0


new int

x =0

5
new int



E6 = E5  {x2 =x3 }
X = [x1 , x2 , x2 , x4 , 0, . . . , 0],
Y = [x4 , x2 , x2 , x1 , 0, . . . , 0],
Z = [1, 1, 1, 1, 0, . . . , 0]

Figure 8: Ad-hoc equi-propagation described in Example 11
(4) The first four rules of Figure 7(b) capture the standard propagation behavior for
interval arithmetics. The last two rules apply when one of the integers in the relation is a
constant. There are symmetric cases when replacing the role of X and Y .
(5) There are no special ad-hoc rules for equi-propagation of an int array plus constraint. These are simply viewed as a decomposition to a set of int plus constraints. Then
simplification is performed at that level using the rules for int plus. The decomposition
of int array plus is explained in Section 6.
Example 11 (ad-hoc equi-propagation). Consider the following (partial) constraint model,
from the context of the Kakuro example of Section 2.2, where we represent variables X, Y
and Z as X = [x1 , . . . , x9 ], Y = [y1 , . . . , y9 ] and Z = [z1 , . . . , z18 ] and assume some previous equi-propagation (on other constraints) has determined the current equi-formula E0 to
specify that integer variable Z = 4:

C=

new int(X, 0, 9)  new int(Y, 0, 9)  new int(Z, 0, 18) 
int plus(X, Y, Z)  int neq(X, Y)



Figure 8 illustrates, step-by-step, the equi-propagation process on C using the ad-hoc rules
defined above. Each step corresponds to the application of one of the above defined ad-hoc
equi-propagation rules as indicated by the label on the transition. At each stage we illustrate
the derived equations (top part) and their application (as a unifier) to the state variables
X, Y and Z (lower part).
319

fiMetodi, Codish, & Stuckey

c = ordered([x1 , . . . , xn ]) (new int)
if
then replace with
n1
true
x1 = 1
ordered([1, x2 . . . , xn ])
xn = 0
ordered([x1 , . . . , xn1 , 0])
, . . . , xn ])

xi = xi+1 ordered([x1 , . . . , xi , 
xi+1
Figure 9: Simplification rules for new int (crossed out elements have been removed).
To summarize, let us come back to Table 1. The numbers presented in the two columns
headed BEE specify the number of variables remaining after application of ad-hoc equipropagation. We also observe that our definition of ad-hoc equi-propagation is trivially
monotonic.

5. Constraint Model Partial Evaluation
Partial evaluation, together with equi-propagation, is the second important component in
our approach to compile constraint models to CNF. Partial evaluation is about simplifying a given constraint model in view of information that becomes available due to equipropagation. Typically, in the constraint simplification process, we apply alternating steps
of equi-propagation and partial evaluation. Examples of partial evaluation include constant
elimination and removing constraints which are tautologies. In this section we detail the
partial evaluation rules that apply for the five constraint types defined in the language
fragment presented in Section 2.
(1) A new int(I, c1 , c2 ) constraint specifies that an integer I = [x1 , . . . , xn ] is represented
in the order encoding and in particular that the corresponding bit sequence is sorted (not
increasing). We denote this as ordered([x1 , . . . , xn ]). Partial evaluation focuses on this
aspect of the constraint and ignores the bounds c1 , c2 specified in the constraint. The table
in Figure 9 specifies four simplification rules that apply. The first rule identifies tautologies,
the second and third rules remove leading ones and trailing zeros, and the fourth removes
(one of two) equated bits. In this figure, and in the subsequent, a crossed out element in a
sequence, indicates that it has been removed from the sequence.
(2) The simplification rules for a int neq constraint shown in Figure 10(a) are symmetric
when exchanging the role of X and Y . The first two rules identify tautologies. The third
rule is about X and Y which have an equal bit at position i. The corresponding bits can
be removed from the representation of X and Y , resulting in a shorter list of bits in their
representations. The last two rules are about removing leading ones and trailing zeroes and
are illustrated by the following example.
Example 12. Figure 10(b) shows two steps of partial evaluation, for a int neq constraint,
first removing leading ones, then removing trailing zeroes.

320

fiBoolean Equi-propagation

c = int neq(X, Y ) where
X = [x1 , . . . , xn ] and Y = [y1 , . . . , yn ]
if
then replace with
X = i, Y 6= i
true
xi = yi
true
int neq(
x
[x1 , . . . , 
xi = yi
i , . . . , xn ],
yi , . . . , yn ])
[y1 , . . . , 
int neq([1, xi+1 , . . . , xn ],
Xi2
[yi , yi+1 , . . . , yn ])
int neq([x1 , . . . , xi , 0],
Xi
[y1 , . . . , yi , yi+1 ])




int neq(
 [x1 , . . . , x4 , 0, 0, 0],  P.E

int neq
[1, 1, 1, y4 , . . . , y7 ])


int neq(
 [x3 , x4 , 0, 0, 0],  P.E

int neq
[1, y4 , . . . , y7 ])


int neq(
 [x3 , x4 , 0], 
[1, y4 , y5 ])

(a)

(b)

Figure 10: (a) Simplification rules for int neq and (b) an example of their application.
c = allDiff([Z1 , . . . , Zn ]) where
Zi = [zi,1 , . . . , zi,m ] (1  i  n)
if
then replace with
n1
true
^  dom(Z1 )  
allDiff([Z2 , . . . , Zn ])
dom(Zk ) = 
k>1 [
|
dom(Zi )| = 2
allDiff([Z3 , . . . , Zn ])
i{1,2}

^
k

Zk 6= i

allDiff(
[z1,1 , . . . , 
z1,i+1
, . . . , z1,m ]
...
[zn,1 , . . . , 
zn,i+1
, . . . , zn,m ])

Figure 11: Simplification rules for allDiff

(3) Four rules for simplifying allDiff constraints are illustrated in Figure 11. The first,
is about detecting tautologies. The second, identifies cases when one of the integers in the
constraint (assume Z1 ) has a domain disjoint from all of the others. This rule also captures
the case when Z1 is a constant. The third rule removes a Hall set of size 2 (assume {Z1 , Z2 })
from the constraint. Note that the corresponding equi-propagation rule detects that the
values of Z3 , . . . , Zn are different from the values of {Z1 , Z2 } and then the next fourth rule
applies. The fourth rule is for the case when none of the integers in the constraint can take
a certain value i. This rule also captures the case when all of the numbers have leading
ones or trailing zeroes. The last two rules are illustrated in Example 14.
(4 & 5) The simplification rules shown in Figure 12 are symmetric when exchanging the
role of X and Y . The first two apply where (at least) one of X, Y and Z is a constant.
Because we have already applied equi-propagation to the constraint, it is a tautology. See
Example 13. The last two rules apply to remove leading ones and trailing zeroes. The
321

fiMetodi, Codish, & Stuckey

c = int plus(X, Y, Z) where X = [x1 , . . . , xn ],
Y = [y1 , . . . , ym ], and Z = [z1 , . . . , zn+m ]
if
then replace with
X=i
true
Z=k
true
int plus([xi+1 , . . . , xn ], Y,
X  i, Z  i
[zi+1 , . . . , zn+m ])
int plus([x1 , . . . , xi ], Y,
X  i, Z  i + m
[z1 , . . . , zi+m ])

Figure 12: Simplification rules for int plus.
(a) int plus(I1 , I2 , K)
(b) allDiff([I1 , I2 , I3 , I4 , I5 , I6 , I7 , I8 ])
(c) int array plus([I2 , I3 , I4 , I5 ], K)
Figure 13: Constraint Model for Examples 1315
simplification rules of an int array plus constraint are straightforward generalizations of
the ones for int plus. See Example 15.
To summarise the rule based approach to apply equi-propagation and partial evaluation
we present the following sequence of three examples which focus on the simplification of the
three constraints given as Figure 13 where the integer variables I1 , . . . , I8 are defined in the
range between 1 and 8 and where K = 14.
Example 13. Consider equi-propagation of constraint (a) from Figure 13 where E0 specifies
that K = 14:




k1 =1, . . . , k14 =1
k15 = 0, k16 = 0
I1 = [1, i1,2 , . . . , i1,8 ],
I2 = [1, i2,2 , . . . , i2,8 ],
K = [1, 1, . . . , 1, 0, 0]
| {z }



14

 i1,2 =1, . . . , i1,6 =1,

i2,2 =1, . . . , i2,6 =1,


i1,7 =i2,8 , i1,8 =i2,7
I1 = [1, 1, 1, 1, 1, 1, i1,7 , i1,8 ],
I2 = [1, 1, 1, 1, 1, 1, i1,8 , i1,7 ],
K = [1, 1, . . . , 1, 0, 0]
| {z }
E1 = E0 

E0 =

K=14


int plus

14

Given E1 , the constraint is a tautology and removed by partial evaluation:



int plus(

P.E

 
[1, 1, 1, 1, 1, 1, i1,7 , i1,8 ],

int plus
[1, 1, 1, 1, 1, 1, i1,8 , i1,7 ], 14)



Example 14. Consider equi-propagation of constraint (b) from Figure 13 given E1 from
Example 13:
E1
I1 = [1, 1, 1, 1, 1, 1, i1,7 , i1,8 ],
I2 = [1, 1, 1, 1, 1, 1, i1,8 , i1,7 ]

i1,7 =i2,8 ,
i2,7 =i1,8


int neq

322

E2 = E1  {i1,7 =i1,8 }
I1 = [1, 1, 1, 1, 1, 1, i1,7 , i1,7 ],
I2 = [1, 1, 1, 1, 1, 1, i1,7 , i1,7 ]

fiBoolean Equi-propagation

Given E2 , the equi-propagation rule for allDiff detects that {I1 , I2 } is a Hall set (where
the two variables take values 6 and 8). and adds to E2 the set of equations, E 0 , that specify
that I3 , I4 , I5 , I6 , I7 , I8 6= 6, 8. The result is E3 = E2  E 0 and the result of this step gives
the following bindings (where the impact of E 0 is underlined):
I1
I2
I3
I4

= [1, 1, 1, 1, 1, 1, i1,7 , i1,7 ]
= [1, 1, 1, 1, 1, 1, i1,7 , i1,7 ]
= [1, i3,2 , i3,3 , i3,4 , i3,5 , i3,7 , i3,7 , 0]
= [1, i4,2 , i4,3 , i4,4 , i4,5 , i4,7 , i4,7 , 0]

I5
I6
I7
I8

= [1, i5,2 , i5,3 , i5,4 , i5,5 , i5,7 , i5,7 , 0]
= [1, i6,2 , i6,3 , i6,4 , i6,5 , i6,7 , i6,7 , 0]
= [1, i7,2 , i7,3 , i7,4 , i7,5 , i7,7 , i7,7 , 0]
= [1, i8,2 , i8,3 , i8,4 , i8,5 , i8,7 , i8,7 , 0]

Given E3 , partial evaluation of the constraint first removes the Hall set:
P.E

[allDiff([I1 , I2 , I3 , I4 , I5 , I6 , I7 , I8 ])]  [allDiff([I3 , I4 , I5 , I6 , I7 , I8 ])]
allDiff

and then applies to remove three redundant bits in the underlying representation of each
remaining integer (which is not equal to 0, 6, 8):











allDiff([
[1, i3,2 , i3,3 , i3,4 , i3,5 , i3,7 , i3,7 , 0],
[1, i4,2 , i4,3 , i4,4 , i4,5 , i4,7 , i4,7 , 0],
[1, i5,2 , i5,3 , i5,4 , i5,5 , i5,7 , i5,7 , 0],
[1, i6,2 , i6,3 , i6,4 , i6,5 , i6,7 , i6,7 , 0],
[1, i7,2 , i7,3 , i7,4 , i7,5 , i7,7 , i7,7 , 0],
[1, i8,2 , i8,3 , i8,4 , i8,5 , i8,7 , i8,7 , 0]])









 P.E

 allDifferent














allDiff([
[i3,2 , i3,3 , i3,4 , i3,5 , i3,7 ],
[i4,2 , i4,3 , i4,4 , i4,5 , i4,7 ],
[i5,2 , i5,3 , i5,4 , i5,5 , i5,7 ],
[i6,2 , i6,3 , i6,4 , i6,5 , i6,7 ],
[i7,2 , i7,3 , i7,4 , i7,5 , i7,7 ],
[i8,2 , i8,3 , i8,4 , i8,5 , i8,7 ]])












Example 15. Consider equi-propagation of constraint (c) from Figure 13 given E3 from
Example 14. The rules that apply derive from the decomposition of the int array plus
constraint to it int plus parts. These dictate that I3 , I4 , I5  5:
E3
I2
I3
I4
I5

= [1, 1, 1, 1, 1, 1, i1,7 , i1,7 ],
= [1, i3,2 , i3,3 , i3,4 , i3,5 , i3,7 , i3,7 , 0],
= [1, i4,2 , i4,3 , i4,4 , i4,5 , i4,7 , i4,7 , 0],
= [1, i5,2 , i5,3 , i5,4 , i5,5 , i5,7 , i5,7 , 0]


int array
plus

E4
I2
I3
I4
I5

= E3  {i3,7 =0, i4,7 =0, i5,7 =0}
= [1, 1, 1, 1, 1, 1, i1,7 , i1,7 ],
= [1, i3,2 , i3,3 , i3,4 , i3,5 , 0, 0, 0],
= [1, i4,2 , i4,3 , i4,4 , i4,5 , 0, 0, 0],
= [1, i5,2 , i5,3 , i5,4 , i5,5 , 0, 0, 0]

Applying partial evaluation simplifies the constraint as follows:







int array plus([
[1, 1, 1, 1, 1, 1, i1,7 , i1,7 ],
[1, i3,2 , i3,3 , i3,4 , i3,5 , 0, 0, 0],
[1, i4,2 , i4,3 , i4,4 , i4,5 , 0, 0, 0],
[1, i5,2 , i5,3 , i5,4 , i5,5 , 0, 0, 0]], 14 )







P.E
 

 int array
plus








int array plus([
[i1,7 , i1,7 ],
[i3,2 , i3,3 , i3,4 , i3,5 ],
[i4,2 , i4,3 , i4,4 , i4,5 ],
[i5,2 , i5,3 , i5,4 , i5,5 ]], 5 )








To summarize Examples 1315 observe that in the initial constraint model 3 constraints
about 8 integers are represented in 56 bits. After constraint simplification 2 constraints
remain and the 8 integers are represented using 28 bits:
I1
I2
I3
I4

= [1, 1, 1, 1, 1, 1, i1,7 , i1,7 ]
= [1, 1, 1, 1, 1, 1, i1,7 , i1,7 ]
= [1, i3,2 , i3,3 , i3,4 , i3,5 , 0, 0, 0]
= [1, i4,2 , i4,3 , i4,4 , i4,5 , 0, 0, 0]

I5
I6
I7
I8
323

= [1, i5,2 , i5,3 , i5,4 , i5,5 , 0, 0, 0]
= [1, i6,2 , i6,3 , i6,4 , i6,5 , i6,7 , i6,7 , 0]
= [1, i7,2 , i7,3 , i7,4 , i7,5 , i7,7 , i7,7 , 0]
= [1, i8,2 , i8,3 , i8,4 , i8,5 , i8,7 , i8,7 , 0]

fiMetodi, Codish, & Stuckey

6. Compiling Constraints with BEE
BEE (Ben-Gurion Equi-propagation Encoder) is a tool which applies to encode finite domain
constraint models to CNF. BEE was first introduced by Metodi and Codish (2012). During
the encoding process, BEE performs optimizations based on equi-propagation and partial
evaluation to improve the quality of the target CNF. BEE is implemented in (SWI) Prolog
and can be applied in conjunction with the CryptoMiniSAT solver (Soos, 2010) through a
Prolog interface (Codish, Lagoon, & Stuckey, 2008). CryptoMiniSAT offers direct support
for xor clauses, and BEE takes advantage of this feature. BEE can be downloaded (Metodi,
2012) where one can also find the examples from this paper and others.
The source language for the BEE compiler is also called BEE. It is a constraint modeling
language similar to FlatZinc (Nethercote et al., 2007), but with a focus on a subset of the
language relevant for finite domain constraint problems. Five of the constraint constructs
in the BEE language are those introduced in Section 2.1. The full language is presented in
Table 2.
In BEE Boolean constants true and false are viewed as (integer) values 1 and 0.
Constraints are represented as (a list of) Prolog terms. Boolean and integer variables are
represented as Prolog variables, which may be instantiated when simplifying constraints.
in Table 2, X and Xs (possibly with subscripts) denote a literal (a Boolean variable or its
negation) and a vector of literals, I (possibly with subscript) denotes an integer variable,
and c (possibly with subscript) denotes an integer constant. On the right column of the
table are brief explanations regarding the constraints. The table introduces 26 constraint
templates.
Constraints (1-2) are about variable declarations: Booleans and integers. Constraint (3)
expresses a Boolean as an integer value. Constraints (4-8) are about Boolean (and reified
Boolean) statements. The special cases of Constraint (5) for bool array or([X1 , . . . , Xn ])
and bool array xor([X1 , . . . , Xn ]) facilitate the specification of clauses and of xor clauses
(supported directly in the CryptoMiniSAT solver by Soos, 2010). Constraint (8) specifies
that sorting a bit pair [X1 , X2 ] (decreasing order) results in the pair [X3 , X4 ]. This is a basic
building block for the construction of sorting networks (Batcher, 1968) used to encode cardinality (linear Boolean) constraints during compilation as described by Asn, Nieuwenhuis,
Oliveras, and Rodrguez-Carbonell (2011) and by Codish and Zazon-Ivry (2010). Constraints (9-14) are about integer relations and operations. Constraints (15-20) are about
linear (Boolean, Pseudo Boolean, and integer) operations. Constraints (21-26) are about
lexical orderings of Boolean and integer arrays.
A main design choice of BEE is that all integer variables are represented in the orderencoding. So, BEE is suitable for problems in which the integer variables take small or
medium sized values. The compilation of a constraint model to a CNF using BEE goes
through three phases.
1. Unary bit-blasting: integer variables (and constants) are represented as bit vectors in
the order-encoding.
2. Constraint simplification: three types of actions are applied: equi-propagation, partial
evaluation, and decomposition of constraints. Simplification is applied repeatedly until
no rule is applicable.
324

fiBoolean Equi-propagation

Declaring Variables
(1)
(2)
(3)

declare Boolean X
declare integer I, c1  I  c2
(X  I = 1)  (X  I = 0)

new bool(X)
new int(I, c1 , c2 )
bool2int(X, I)

op  {or, and, xor, iff}

Boolean (reified) Statements
(4)
(5)
(6)
(7)
(8)

bool eq(X1 , X2 ) or bool eq(X1 , X2 )
bool array op([X1 , . . . , Xn ])
bool array op reif([X1 , . . . , Xn ], X)
bool op reif(X1 , X2 , X)
comparator(X1 , X2 , X3 , X4 )

X1 = X2 or X1 = X2
X1 op X2    op Xn
X1 op X2    op Xn  X
X1 op X2  X
sort([X1 , X2 ]) = [X3 , X4 ]

Integer relations (reified)
rel  {leq, geq, eq, lt, gt, neq}
and arithmetic
op  {plus, times, div, mod, max, min}, op0  {plus, times, max, min}
(9)
(10)
(11)
(12)
(13)
(14)

int
int
int
int
int
int

rel(I1 , I2 )
rel reif(I1 , I2 , X)
array allDiff([I1 , . . . , In ])
abs(I1 , I)
op(I1 , I2 , I)
array op0 ([I1 , . . . , In ], I)

I1 rel I2
I
V1 rel I2  X
i<j Ii 6= Ij
|I1 | = I
I1 op I2 = I
I1 op0    op0 In = I

Linear Constraints
(15)
(16)
(17)
(18)
(19)
(20)

rel{leq, geq, eq, lt, gt}

bool array sum rel([X1 , . . . , Xn ], I)
bool array pb rel([c1 , . . . , cn ], [X1 , . . . , Xn ], I)
bool array sum modK([X1 , . . . , Xn ], c, I)
int array sum rel([I1 , . . . , In ], I)
int array lin rel([c1 , . . . , cn ], [I1 , . . . , In ], I)
int array sum modK([I1 , . . . , In ], c, I)

( Xi ) rel I
( ci  Xi ) rel I
(( Xi ) mod c) = I
( Ii ) rel I
( ci  Ii ) rel I
(( Ii ) mod c) = I

Lexical Order
(21)
(22)
(23)
(24)
(25)
(26)

bool arrays lex(Xs1 , Xs2 )
bool arrays lexLt(Xs1 , Xs2 )
bool arrays lex reif(Xs1 , Xs2 , X)
bool arrays lexLt reif(Xs1 , Xs2 , X)
int arrays lex(Is1 , Is2 )
int arrays lexLt(Is1 , Is2 )

Xs1 precedes (leq) Xs2 in the lex order
Xs1 precedes (lt) Xs2 in the lex order
X  Xs1 precedes (leq) Xs2 in the lex order
X  Xs1 precedes (lt) Xs2 in the lex order
Is1 precedes (leq) Is2 in the lex order
Is1 precedes (lt) Is2 in the lex order

Table 2: Syntax of BEE Constraints.
3. CNF encoding: the best suited encoding technique is applied to the simplified constraints.
Bit-blasting and equi-propagation in BEE follow the general descriptions from Sections 2.4 and 3.1. Bit-blasting is implemented through Prolog unification. Each declaration of the form new int(I, c1 , c2 ) triggers a unification I = [1, . . . , 1, Xc1 +1 , . . . , Xc2 ] (to
ease presentation we assume that integer variables are represented in a positive interval
starting from 0 but there is no such limitation in practice as BEE also supports negatives
integers). BEE applies ad-hoc equi-propagators as described in Section 4. When an equality
of the form X = L (between a variable and a literal or a constant) is detected, then equipropagation is implemented by unifying X and L. This unification applies to all occurrences
of X and in this sense propagates to other constraints involving X.
Decomposition is about replacing complex constraints (for example about arrays) with
simpler constraints (for example about array elements). Consider, for instance, the constraint int array plus(As, Sum). It is decomposed to a list of int plus constraints applying
a straightforward divide and conquer recursive definition. At the base case, if As=[A] then
325

fiMetodi, Codish, & Stuckey

c = allDiff ([Z1 , Z2 , Z3 , . . . , Zn ])
if in E
then add in c (E)
i  dom(Z1 )
i
/ dom(Zk ) (k > 1)

Z1 = i the authors

{i, j}  dom(Zk ) = 
(k > 2)

dom(Z1 )  {i, j}
dom(Z2 )  {i, j}
Z1 6= Z2
Zk 6= i, Zk 6= j
(k > 2)

Figure 14: Simplification rules for allDiff .
the constraint is replaced by a constraint of the form int eq(A,Sum) which equates the bits
of A and Sum, or if As = [A1 , A2 ] then it is replaced by int plus(A1 , A2 , Sum). In the general
case As is split into two halves, then constraints are generated to sum these halves, and
then an additional int plus constraint is introduced to sum the two sums.
As another example, consider the int plus(A1 , A2 , A) constraint. One approach, supported by BEE, decomposes the constraint as an odd-even merger (from the context of
odd-even sorting networks) (Batcher, 1968). Here, the sorted sequences of bits A1 and A2
are merged to obtain their sum A. This results in a model with O(n log n) comparator
constraints (and later in an encoding with O(n log n) clauses). Another approach, also
supported in BEE, does not decompose the constraint but encodes it directly to a CNF of
size O(n2 ), as in the context of so-called totalizers (Bailleux & Boufkhad, 2003). A hybrid
approach, leaves the choice to BEE, depending on the size of the domains of the variables
involved. Finally, we note that the user can configure BEE to fix the way it compiles this
constraint (and others).
CNF encoding is the last phase in the compilation of a constraint model. Each of the
remaining simplified (bit-blasted) constraints is encoded directly to a CNF. These encodings
are standard and similar to those applied in various tools. The BEE encodings are similar
to those applied in Sugar (Tamura et al., 2009).
6.1 The All-Different Constraint in BEE
The all-different constraint specifies that a set of integer variables take all different values
from their specified domains. This constraint has received much attention in the literature
(see for example the survey in van Hoeve, 2001). BEE provides special treatment for this
constraint.
In many applications, all-different constraints are applied to model the special case when
the constraint is about permutation. Namely, when [I1 , . . . , In ] are all different but may
take precisely n different values. BEE identifies this special case and applies two additional
ad-hoc equi-propagation rules for this case. The table of Figure 14 illustrates these rules.
We annotate the constraint with a * to emphasize that it has been detected that it is
about permutation. The first rule is about the case when only one integer (assume Z1 ) can
take the value i. The second rule is about the case where all variables except two, assume Z1 ,
Z2 , cannot take two values, assume i, j. Now, because the constraint is about permutation,
326

fiBoolean Equi-propagation

we can determine that Z1 and Z2 must take the two values i and j. To illustrate the second
rule consider the following example.
Example 16. Consider a constraint allDiff(I1 , . . . , I5 ) on 5 integer variables taking values in the interval [0, 4] (exactly 5 values) where E0 specifies that I3 , I4 and I5 cannot take
the values 0 and 1. Therefore we introduce equations which restrict I1 and I2 to take the
values 0 and 1, and the corresponding ad-hoc rule for permutation applies:
E0
I1
I2
I3
I4
I5



 x3,1 =1, x4,1 =1, 
x5,1 =1, x3,2 =1,
=


x4,2 =1, x5,2 =1
= [x1,1 , . . . , x1,4 ],
= [x2,1 , . . . , x2,4 ],
= [1, 1, x3,3 , x3,4 ],
= [1, 1, x4,3 , x4,4 ],
= [1, 1, x5,3 , x5,4 ]

dom(Ik )  {0, 1}=
k>2




allDiff

E1
I1
I2
I3
I4
I5



 x1,2 =0, . . . , x1,4 =0, 
x2,2 =0, . . . , x2,4 =0
= E0 


x1,1 =x2,1
= [x1,1 , 0, . . . , 0],
= [x1,1 , 0, . . . , 0],
= [1, 1, x3,3 , x3,4 ],
= [1, 1, x4,3 , x4,4 ],
= [1, 1, x5,3 , x5,4 ]

To facilitate the implementation of ad-hoc equi-propagation of all-different constraints,
BEE adopts a dual representation for integer variables occurring in these constraints combining the order encoding and the, so-called, direct encoding. This is essentially the
same as the encoding proposed by Gent and Nightingale (2004). When declaring an integer variable I, the bit-blast in the order encoding applies the corresponding unification
I = [x1 , . . . , xn ]. When encountering I in an allDiff constraint, an additional bit-blast
introduces I0 = [d0 , . . . , dn ] in the direct encoding, and a channeling formula channel(I, I0 )
is introduced.
The direct encoding is a unary representation I0 = [d0 , . . . , dn ] where each bit di is true
if and only if I0 = i. So, exactly one of the bits takes the value true. For example, the value
3 in the interval [0, 5] is represented in 6 bits as [0, 0, 0, 1, 0, 0]. In the dual representation
the following channeling formula captures the relation between the two representations of
an integer variable I = [x1 , . . . , xn ] and I0 = [d0 , . . . , dn ].

channel([x1 , . . . , xn ], [d0 , . . . , dn ]) =

d0 = x1
 dn = xn




n1
^

(di  xi  xi+1 )

i=1

Consider an allDiff constraint about m integer variables that can take different values between 0 and n. During constraint simplification, the allDiff([I1 , . . . , Im ]) constraint
is viewed through its direct encoding as a bit matrix where each row consists of the bits
[di0 , . . . , din ] for Ii in the direct encoding. The element dij is true iff Ii takes the value j.
The j th column specifies which of the Ii take the value j and hence, at most one variable
in a column may take the value true. This representation has one main advantage: in the
direct encoding we can decompose allDiff([I1 , . . . , Im ]), to a conjunction of n + 1 constraints, one for each column 0  j  n, of the form bool array sum leq([d1j , . . . , dmj ], 1),
which is arc-consistent. As soon as di,j = 1 (Ii = j) we have di,j 0 = 0 (Ii 6= j 0 ) for all
2
j0 6= j. In contrast
fi in the	 order encoding alone the decomposition to O(m ) constraints
int neq(Ii , Ij ) fi i < j
is not arc-consistent. We illustrate the advantage of the dual
encoding for the allDiff constraint in Section 8.1.
327

fiMetodi, Codish, & Stuckey

:- use module(bee compiler, [bCompile/2]).
:- use module(sat solver, [sat/1]).
solve(Instance, Solution) :encode(Instance, Map, Constraints),
bCompile(Constraints, CNF),
sat(CNF),
decode(Map, Solution).

Figure 15: A generic application of BEE.

7. Using BEE
A typical BEE application has the form depicted as Figure 15 where the predicate solve/2
takes a problem Instance and provides a Solution. The specifics of the application are
in the call to encode/3 which given the Instance generates the Constraints that solve
it together with a Map relating instance variables with constraint variables. The calls to
bCompile/2 and sat/1 compile the constraints to a CNF and solve it applying a SAT solver.
If the instance has a solution, the SAT solver binds the constraint variables accordingly.
Then, the call to decode/2, using the Map, provides a Solution in terms of the Instance
variables. The definitions of encode/3 and decode/2 are application dependent and provided by the user. The predicates bCompile/2 and sat/1 are part of the tool and provide
the interface to BEE and the underlying SAT solver.
7.1 Example BEE Application: Magic Graph Labeling
We illustrate the application of BEE using Prolog as a modeling language to solve a graph
labeling problem. Graph labeling is about finding an assignment of integers to the vertices
and edges of a graph subject to certain conditions. Graph labellings were introduced in
the 60s and hundreds of papers on a wide variety of related problems have been published
since then. See for example the survey by Gallian (2011) with more than 1200 references.
Graph labellings have many applications. For instance in radars, X-ray crystallography,
coding theory, etc.
We focus here on the vertex-magic total labeling (VMTL) problem where one should
find for the graph G = (V, E) a labeling that is a one-to-one map V  E  {1, 2, . . . , |V | +
|E|} with the property that the sum of the labels of a vertex and its incident edges is
a constant K independent of the choice of vertex. A problem instance takes the form
vmtl(G, K) specifying the graph G and a constant K. In the context of Figure 15, the
query solve(vmtl(G, K), Solution) poses the question: Does there exist a vmtl labeling
for G with magic constant K? It binds Solution to indicate such a labeling if one exists,
or to unsat otherwise. Figure 16 illustrates an example problem instance together with
its solution.
Figure 17 illustrates a Prolog program that implements the encode/3 predicate for the
VMTL problem. The call to predicate declareInts/4 introduces the constraints which
declare the integer variables for each vertex and edge in the graph, and generates the
map. The call to predicate sumToK/5 introduces the constraints that require the sum of
the labels for each vertex with its incident edges to equals K. The auxiliary predicate
328

fiBoolean Equi-propagation

An Instance
Instance = vmtl(G, K),
G = (V, E),
V = [1, 2, 3, 4],
E = [(1, 2), (1, 3),
(2, 3), (3, 4)],
K = 14

The Graph
4

2

36
 666



A Solution


1

V1
 V2

 V3
V4

= 4,
= 5,
= 1,
= 6,

E(1,2)
E(1,3)
E(2,3)
E(3,4)


= 7,
= 3, 

= 2, 
=8

Figure 16: A VMTL instance with a solution.
encode(vmtl((Vs,Es),K),Map,Constraints):append(Vs,Es,VEs), length(VEs,N),
declareInts(VEs,N,Map,Constraints-Cs2),
sumToK(Vs,Es,Map,K,Cs2-Cs3),
getVars(VEs,Map,Vars),
Cs3=[int array allDiff(Vars)].
declareInts([], , ,Cs-Cs).
declareInts([ID|IDs],N,[(ID,X)|Map],[new int(X,1,N)|CsH]-CsT):declareInts(IDs,N,Map,CsH-CsT).
sumToK([], , , ,Cs-Cs).
sumToK([VID|Vs],Es,Map,K,[int array plus(Vars,K)|CsH]-CsT):findall((X,Y),(member((X,Y),Es),(X=VID ; Y=VID)),EsIDs),
getVars([VID|EsIDs],Map,Vars),
sumToK(Vs,Es,Map,K,CsH-CsT).
getVars([], ,[]).
getVars([ID|IDs],Map,[Var|Vars]):member((ID,Var),Map),
getVars(IDs,Map,Vars).

Figure 17: encode/3 predicate for the VMTL application of BEE
The Map
((1, 2), E1 ),(1, V1 ),
((1, 3), E2 ),(2, V2 ),
((2, 3), E3 ),(3, V3 ),
((3, 4), E4 ),(4, V4 )

The Constraints
new int(V1 , 1, 8), new int(E1 , 1, 8), int array plus([V1 , E1 , E2 ], K),
new int(V2 , 1, 8), new int(E2 , 1, 8), int array plus([V2 , E1 , E3 ], K),
new int(V3 , 1, 8), new int(E3 , 1, 8), int array plus([V3 , E2 , E3 , E4 ], K),
new int(V4 , 1, 8), new int(E4 , 1, 8), int array plus([V4 , E4 ], K),
new int(K, 14, 14), allDiff([V1 , V2 , V3 , V4 , E1 , E2 , E3 , E4 ])

Figure 18: A VMTL instance with the constraints and map generated by encode/3.

getVars/3 receives a list of identifiers (vertices and edges) and extracts the corresponding
list of integer variables from the map.
Given the VMTL instance from Figure 16, the call to predicate encode/3 from Figure 17
generates the map and the constraints detailed in Figure 18.
329

fiMetodi, Codish, & Stuckey

Solving the constraints from Figure 18 binds the Map as follows, indicating a solution
(in unary order encoding):


(1,
 (2,
M =
(3,
(4,

[1, 1, 1, 1, 0, 0, 0, 0]),
[1, 1, 1, 1, 1, 0, 0, 0]),
[1, 0, 0, 0, 0, 0, 0, 0]),
[1, 1, 1, 1, 1, 1, 0, 0]),

((1, 2),
((1, 3),
((2, 3),
((3, 4),



[1, 1, 1, 1, 1, 1, 1, 0]),
[1, 1, 1, 0, 0, 0, 0, 0]), 
[1, 1, 0, 0, 0, 0, 0, 0]), 
[1, 1, 1, 1, 1, 1, 1, 1])

Using BEE to compile the constraints from Figure 18 generates a CNF which contains 301
clauses and 48 Boolean variables. Encoding the same set of constraints without applying
simplification rules generates a larger CNF which contains 642 clauses and 97 Boolean
variables.
In Section 8.3 we report that using BEE enables us to solve interesting instances of the
VMTL problem not previously solvable by other techniques.
7.2 BumbleBEE
The BEE distribution includes also a command line solver, which we call BumbleBEE.
BumbleBEE enables one to specify a BEE model in an input file where each line contains
a single constraint from the model and the last line specifies the type of goal. BumbleBEE
reads the input file, compiles the constraint model to CNF, solves the CNF using the
embedded CryptoMiniSAT solver (Soos, 2010) and outputs a set of bindings to the declared
variables in the model (or a message indicating that the constraints are not satisfiable).
Figure 19 contains on the left the BumbleBEE input file for the VMTL instance from
Figure 16 and on the right the BumbleBEE output, which is a solution for the constraint
model. In the example, the last line of the input file specifies the goal to the solver. The
options are:
1. solve satisfy: solve for a single satisfying assignment to the constraint model;
2. solve satisfy(c): solve for (at most) c satisfying assignments to the constraint model
where c is an integer value. When c  0 this option will solve for all solutions.
3. solve minimize(I): solve for a solution which minimizes the value of the integer
variable I. The solver outputs the intermediate solutions (with decreasing values of
I) encountered during the search for the minimum value of I.
4. solve maximize(I): similar to minimize, but maximizes.
Further details and more examples can be found in the BEE distribution (Metodi & Codish,
2012).

8. Experiments
We report on our experience in applying BEE. To appreciate the ease in its use the reader
is encouraged to view the example encodings available with the tool (Metodi & Codish,
2012). All experiments run on an Intel Core 2 Duo E8400 3.00GHz CPU with 4GB memory
under Linux (Ubuntu lucid, kernel 2.6.32-24-generic). BEE is written in Prolog and run
330

fiBoolean Equi-propagation

Content of BumbleBEE input file
new int(V1, 1, 8)
new int(V2, 1, 8)
new int(V3, 1, 8)
new int(V4, 1, 8)
new int(E1, 1, 8)
new int(E2, 1, 8)
new int(E3, 1, 8)
new int(E4, 1, 8)
int array plus([V1, E1, E2], 14)
int array plus([V2, E1, E3], 14)
int array plus([V3, E2, E3, E4], 14)
int array plus([V4, E4], 14)
int array allDiff([V1, V2, V3, V4, E1, E2, E3, E4])
solve satisfy

BumbleBEE output

V1 = 4
V2 = 5
V3 = 1
V4 = 6
E1 = 7
E2 = 3
E3 = 2
E4 = 8
        
==========

Figure 19: Solving VMTL instance using BumbleBEE.

using SWI Prolog v6.0.2 64-bits. Comparisons with Sugar (v1.15.0) are based on the use of
identical constraint models, apply the same SAT solver (CryptoMiniSAT v2.5.1), and run
on the same machine. Times are reported in seconds.
8.1 Quasigroup Completion Problems
A Quasigroup Completion Problem (QCP) proposed by Gomes, Selman, and Crato (1997)
as a constraint satisfaction benchmark, is given as an n  n board of integer variables (in
the range [1, n]) in which some are assigned integer values. The task is to assign values to
all variables, so that no column or row contains the same value twice. The constraint model
is a conjunction of allDiff constraints. Ansotegui, del Val, Dotu, Fernandez, and Manya
(2004) argue the advantage of the direct encoding for QCP.
We consider 15 instances from the 2008 CSP competition.2 Table 3 considers three
settings: BEE with its dual encoding for allDiff constraints, BEE using only the order
encoding (equivalent to using int neq constraints instead of allDiff), and Sugar. The
table shows: the instance identifier (sat or unsat), compilation time (comp) in seconds,
clauses in the encoding (clauses), variables in the encoding (vars), and SAT solving time
(SAT) in seconds.
The results indicate that: (1) Application of BEE using the dual representation for
allDiff is 38 times faster and produces 20 times fewer clauses (in average) than when
using the order-encoding alone (despite the need to maintain two encodings); (2) Without
the dual representation, solving encodings generated by BEE is only slightly faster than
Sugar but BEE still generates CNF encodings 4 times smaller (on average) than those
generated by Sugar. Observe that 3 instances are found unsatisfiable by BEE (indicated
2. http://www.cril.univ-artois.fr/CPAI08/. The competition instances are specified using binary disequalities, but here we use the model with allDiff.

331

fiMetodi, Codish, & Stuckey

instance

25-264-0 sat
25-264-1 sat
25-264-2 sat
25-264-3 sat
25-264-4 sat
25-264-5 sat
25-264-6 sat
25-264-7 sat
25-264-8 sat
25-264-9 sat
25-264-10 unsat
25-264-11 unsat
25-264-12 unsat
25-264-13 unsat
25-264-14 unsat
Total

BEE (dual
comp clauses
(sec)
0.23 6509
0.20 7475
0.21 6531
0.21 6819
0.21 7082
0.21 7055
0.21 7712
0.21 7428
0.21 6603
0.21 6784
0.21 6491
0.12
1
0.16
1
0.12
1
0.23 5984

encoding)
vars
SAT
(sec)
1317
0.33
1508
3.29
1329
0.07
1374
0.83
1431
0.34
1431
3.12
1551
0.34
1496
0.13
1335
0.18
1350
0.19
1296
0.04
0
0.00
0
0.00
0
0.00
1210
0.07
8.93

BEE (order
comp clauses
(sec)
0.36 33224
0.30 34323
0.30 35238
0.29 32457
0.29 32825
0.30 33590
0.33 39015
0.30 36580
0.27 31561
0.27 35404
0.30 33321
0.28 37912
0.29 39135
0.29 35048
0.28 31093

encoding)
vars
SAT
(sec)
887
8.95
917
97.50
905
2.46
899
18.52
897
19.08
897
46.15
932
69.81
937
19.93
896
10.32
903
34.08
930
10.92
955
0.09
984
0.08
944
0.09
885
11.60
349.58

clauses

Sugar
vars

126733
127222
127062
127757
126777
126973
128354
127106
124153
128423
126999
125373
127539
127026
126628

10770
10798
10787
10827
10779
10784
10850
10794
10687
10853
10785
10744
10815
10786
10771

SAT
(sec)
34.20
13.93
8.06
44.03
85.92
41.04
12.67
7.01
9.69
38.80
57.75
0.47
0.57
0.56
15.93
370.63

Table 3: QCP results for 25  25 instances with 264 holes
by a CNF with a single clause and no variables). We comment that Sugar pre-processing
times are higher than those of BEE and not indicated in the table.
8.2 Word Design for DNA
This is Problem 033 of CSPLib which seeks the largest parameter n, such that there exists
a set S of n eight-letter words over the alphabet  = {A, C, G, T } with the following
properties: (1) Each word in S has exactly 4 symbols from {C, G}; (2) Each pair of
distinct words in S differ in at least 4 positions; and (3) For every x, y  S: xR (the reverse
of x) and y C (the word obtained by replacing each A by T , each C by G, and vice versa)
differ in at least 4 positions.
Mancini, Micaletto, Patrizi, and Cadoli (2008) provide a comparison of several stateof-the-art solvers applied to the DNA word problem with a variety of encoding techniques.
Their best reported result is a solution with 87 DNA words, obtained in 554 seconds, using
an OPL (van Hentenryck, 1999) model with lexicographic order to break symmetry. Frutos,
Liu, Thiel, Sanner, Condon, Smith, and Corn (1997) present a strategy to solve this problem
where the four letters are modeled by bit-pairs [t, m]. Each eight-letter word can then be
viewed as the combination of a t-part, [t1 , . . . , t8 ], which is a bit-vector, and a m-part,
[m1 , . . . , m8 ], also a bit-vector. The authors report a solution composed from two pairs
of (t-part and m-part) sets3 [T1 , M1 ] and [T2 , M2 ] where |T1 | = 6, |M1 | = 16, |T2 | = 2,
|M2 | = 6. This forms a set S with (6  16) + (2  6) = 108 DNA words. Marc van Dongen
reports a larger solution with 112 words.4
Building on the approach described by Frutos et al. (1997), we pose conditions on sets
of t-parts and m-parts, T and M , so that their Cartesian product S = T  M will
satisfy the requirements of the original problem. From the three conditions below, T is
required to satisfy (10 ) and (20 ), and M is required to satisfy (20 ) and (30 ). For a set of
3. Their notions of t-part and m-part are slightly different than ours.
4. See http://www.cs.st-andrews.ac.uk/~ianm/CSPLib/.

332

fiBoolean Equi-propagation

bit-vectors V , the conditions are: (10 ) Each bit-vector in V sums to 4; (20 ) Each pair of
distinct bit-vectors in V differ in at least 4 positions; and (30 ) For each pair of bit-vectors
(not necessarily distinct) u, v  V , uR (the reverse of u) and v C (the complement of v)
differ in at least 4 positions. This is equivalent to requiring that (uR )C differs from v in at
least 4 positions.
It is this strategy that we model in our BEE encoding. An instance takes the form
dna(n1 , n2 ) signifying the numbers of bit-vectors, n1 and n2 in the sets T and M . Without
loss of generality, we impose, to remove symmetries, that T and M are lexicographically
ordered. A solution is the Cartesian product S = T  M .
Using BEE, we find, in a fraction of a second, sets of t-parts of size 14 and m-parts of
size 8. This provides a solution of size 14  8 = 112 to the DNA word problem. Running
Comet (v2.0.1) we find a 112 word solution in about 10 seconds using a model by Hakan
Kjellerstrand.5 Using BEE, we also prove that there does not exist a set of 15 t-parts (0.15
seconds), nor a set of 9 m-parts (4.47 seconds). These facts were unknown prior to BEE.
Proving that there is no solution to the DNA word problem with more than 112 words,
without the restriction to the two part t-m strategy, is still an open problem.
8.3 Vertex Magic Total Labeling
MacDougall, Miller, Slamin, and Wallis (2002) conjecture that the n vertex complete graph,
Kn , for n  5 has a vertex magic total labeling with magic constants for a specific range of
values of k, determined by n. This conjecture is proved correct for all odd n and verified by
brute force for n = 6. We address the cases for n = 8 and n = 10 which involve 15 instances
(different values of k) for n = 8, and 23 (different values of k) for n = 10. Starting from
the simple constraint model (illustrated by the example in Figure 16), we add additional
constraints to exploit the fact that the graphs are symmetric: (1) We assume that the edge
with the smallest label is e1,2 ; (2) We assume that the labels of the edges incident to v1
are ordered and hence introduce constraints e1,2 < e1,3 <    < e1,n ; (3) We assume that
the label of edge e1,3 is smaller than the labels of the edges incident to v2 (except e1,2 ) and
introduce constraints accordingly. In this setting BEE can solve all except 2 instances with
a 4 hour timeout and Sugar can solve all except 4.
Table 4 gives results for the 10 hardest instances for K8 the 20 hardest instances for K10
with a 4 hour time-out. BEE compilation times are on the order of 0.5 sec/instance for K8
and 2.5 sec/instance for K10 . Sugar encoding times are slightly larger. The instances are
indicated by the magic constant, k; the columns for BEE and Sugar indicate SAT solving
times (in seconds). The bottom two lines indicate average encoding sizes (numbers of clauses
and variables).
The results indicate that the Sugar encodings are (in average) about 60% larger, while
the average SAT solving time for the BEE encodings is about 2 times faster (average excluding instances where Sugar times-out).
To address the two VMTL instances not solvable using the BEE models described above
(K10 with magic labels 259 and 258), we partition the problem fixing the values of e1,2
and e1,3 and maintaining all of the other constraints. Analysis of the symmetry breaking
constraints indicates that this results in 198 new instances for each of the two cases. The
5. See http://www.hakank.org/comet/word_design_dna1.co.

333

fiMetodi, Codish, & Stuckey

instance
BEE
K8
k
SAT (sec)
143
1.26
142
10.14
141
7.64
140
14.68
139
25.60
138
12.99
137
22.91
136
14.46
135
298.54
134
331.80
Average CNF size:
clauses
248000
vars
5688

Sugar
SAT (sec)
2.87
1.62
2.94
6.46
6.67
2.80
298.58
251.82
182.90


instance
BEE
K10
k
SAT (sec)
277
5.31
276
7.11
275
13.57
274
4.93
273
45.94
272
22.74
271
7.35
270
6.03
269
5.20
268
94.44
267
88.51
266
229.80
265
1335.31
264
486.09
263
236.68
262
1843.70
261
2771.60
260
4873.99
259

258

Average CNF size:
clauses
1229000
vars
15529

402000
9370

Sugar
SAT (sec)
9.25
9.91
19.63
9.24
9.03
86.45
9.49
55.94
11.05
424.89
175.70
247.56
259.45
513.61
648.43
6429.25
7872.76



1966000
25688

Table 4: VMTL results for K8 and K10 (4 hour timeout)

original VMTL instance is solved if any one of of these 198 instances is solved. So, we solve
them in parallel. Fixing e1,2 and e1,3 fuels the compiler so the encodings are considerably
smaller. The instance for k = 259 is solved in 1379.50 seconds where e1,2 = 1 and e1,3 = 6.
The compilation time is 2.09 seconds and the encoding consists in just over 1 million clauses
and 15 thousand variables.
To the best of our knowledge, the hard instances from this suite are beyond the reach of
all previous approaches to program the search for magic labels. The SAT based approach
presented by Jager (2010) cannot handle these.6 The comparison with Sugar indicates the
impact of the compiler.
8.4 Balanced Incomplete Block Designs
This is Problem 028 of CSPlib (BIBD) where an instance is defined by a 5-tuple of positive
integers [v, b, r, k, ] and requires to partition v distinct objects into b blocks such that each
block contains k different objects, exactly r objects occur in each block, and every two
distinct objects occur in exactly  blocks.
6. Personal communication (Gerold Jager), March 2012.

334

fiBoolean Equi-propagation

Figure 20: BIBD symmetry breaking.
The naive model for a BIBD instance [v, b, r, k, ] introduces the following constraints
on a v by b Boolean incidence matrix: (1) exactly r ones in each row, (2) exactly k ones in
each column, and (3) exactly  ones in each scalar product of two (different) rows.
This model does not contain a sufficient degree of information to trigger the equipropagation process. In order to take advantage of the BEE simplifications we added
symmetry breaking as described by Frisch, Jefferson, and Miguel (2004) and illustrated
in Figure 20: Each row is viewed as sequence of four parts A . . . D with sizes , (r  ),
(r  ), and (b  2r + ). The first row is fixed by assigning parts A and B with ones
(marked in black) and parts C and D with zeros (marked in white). The second row is
fixed by assign parts A and C with ones (marked in black) and parts B and D with zeros
(marked in white). For the third and all subsequent rows (marked in gray), the sum constraints are decomposed into summing each part (A . . . D) and then summing the results as
follows: A + B = , A + C = , C + D = r  , and B + D = r  . This ensures that the
row contains exactly r ones and that the scalar product with the first (and second) row is
. We denote this constraint model SymB (for symmetry breaking).
instance
[v, b, r, k, ]
[7, 420, 180, 3, 60]
[7, 560, 240, 3, 80]
[12, 132, 33, 3, 6]
[15, 45, 24, 8, 12]
[15, 70, 14, 3, 2]
[16, 80, 15, 3, 2]
[19, 19, 9, 9, 4]
[19, 57, 9, 3, 1]
[21, 21, 5, 5, 1]
[25, 25, 9, 9, 3]
[25, 30, 6, 5, 1]
Total (sec)

comp
(sec)
1.65
3.73
0.95
0.51
0.56
0.81
0.23
0.34
0.02
0.64
0.10

BEE (SymB)
clauses
SAT
(sec)
698579
1.73
1211941 13.60
180238
0.73
116016
8.46
81563
0.39
109442
0.56
39931
0.09
113053
0.17
0
0.00
92059
1.33
24594
0.06
36.66

Sugar (SymB)
comp
clauses
SAT
(sec)
(sec)
12.01 2488136 13.24
11.74 2753113 36.43
83.37 1332241
7.09
4.24
466086

23.58
540089
1.87
64.81
623773
2.26
2.27
125976
0.49



31.91
3716
0.01
42.65
569007
8.52
16.02
93388
0.42
> 722.93

SatELite (SymB)
comp
clauses SAT
(sec)
(sec)
1.67
802576 2.18
2.73 1397188 5.18
1.18
184764 0.57
0.64
134146

1.02
79542 0.20
1.14
105242 0.35
0.4
44714 0.09
10.45
111869 0.14
0.01
0 0.00
1.01
97623 8.93
1.2
23828 0.05
> 219.14

Table 5: BIBD results (180 sec. timeout)
Table 5 shows results comparing BEE (compilation time, clauses in encoding, and SAT
solving time) with Sugar using the SymB model. We also compare BEE with SatELite (Een
335

fiMetodi, Codish, & Stuckey

& Biere, 2005), a CNF minimizer, where the input to SatELite is the CNF encoding for
the SymB model generated by BEE without applying any simplifications. Here compilation
time (comp) indicates the SatELite pre-processing time. The final row indicates the total
of compilation and SAT solving time over the entire suite for each approach. In all cases
time is measured in seconds.
This experiment indicates that BEE generates a significantly smaller CNF than Sugar
which affects the SAT solving time. Moreover, the Sugar compilation time is extremely
long. When comparing BEE with SatELite we can see that both output a CNF which
is similar in size but as SatELite is applied on the entire CNF, for some instances its
compilation time is significantly longer than its solving time.
instance
[v, b, r, k, ]
[7, 420, 180, 3, 60]
[7, 560, 240, 3, 80]
[12, 132, 33, 3, 6]
[15, 45, 24, 8, 12]
[15, 70, 14, 3, 2]
[16, 80, 15, 3, 2]
[19, 19, 9, 9, 4]
[19, 57, 9, 3, 1]
[21, 21, 5, 5, 1]
[25, 25, 9, 9, 3]
[25, 30, 6, 5, 1]
Total

BEE (SymB)
comp
SAT
1.65
1.73
3.73 13.60
0.95
0.73
0.51
8.46
0.56
0.39
0.81
0.56
0.23
0.09
0.34
0.17
0.02
0.00
0.64
1.33
0.10
0.06
36.66

[M06]
0.54
0.66
5.51

12.22
107.43
53.23

1.26


>900.00

Minion
SymB
1.36
1.77


1.42
13.40
38.30
1.71
0.67

1.37
>600.00

SymB+
0.42
0.52
1.76
75.87
0.31
0.35
0.31
0.35
0.15
0.92
0.31
81.24

Table 6: BIBD results, comparison with Minion (times in seconds; 180 sec. timeout).
Table 6 shows results comparing BEE using the SymB model with the Minion constraint
solver (Gent, Jefferson, & Miguel, 2006). We consider three different models for Minion:
[M06] indicates results using the BIBD model described by Gent et al. (2006), SymB uses
the same model we use for the SAT approach, SymB+ , is an enhanced symmetry breaking
model with all of the tricks applied also in the [M06] model. For the columns with no
timeouts we show total times (for BEE this includes compile time and SAT solving). Note
that by using a clever modeling of the problem we have improved also the previous run-times
for Minion.
This experiment indicates that BEE is significantly faster than Minion on its BIBD
models ([M06]). Only when tailoring our SymB model, does Minion becomes competitive
with ours.
8.5 Combining BEE with SatELite
We now demonstrate the impact of combining BEE and SatELite. We describe experiments involving two of the benchmarks where SatELite is applied to simplify the output of
BEE. The idea is to first apply the more powerful, but local, techniques, performed by BEE.
This reduces the size of the CNF and is fast. Then we apply SatELite which takes global
considerations on the CNF as a whole. We wish to determine if the smaller, simplified,
336

fiBoolean Equi-propagation

CNF is more amenable to further simplification using SatELite. The results indicate that
although CNF size is slightly decreased, solving times are most often increased, sometimes
drastically.
Tables 7 and 8 show our results. In both tables the four columns under the BEE
heading indicate: BEE compilation time, size of the encoding (clauses and variables), and the
subsequent SAT solving time. Similarly, the four columns under the  SatELite heading
indicate the application of SatELite to the output of BEE: the SatELite processing time,
the size of the resulting CNF (clauses and variables), and the subsequent SAT solving time.
Table 7 illustrates the results for the BIBD benchmark of Section 8.4 and Table 8, the results
for the 10 hardest VMTL instances for K8 and for K10 described in Section 8.3. Observe
that applying SatELite to the output of BEE decreases the CNF size only slightly and does
not improve the SAT solving time. In fact, to the contrary, in most cases it renders a CNF
which takes more time to solve. In several cases, SAT solving time increases drastically to
introduce a timeout.
instance
[v, b, r, k, ]
[7, 420, 180, 3, 60]
[7, 560, 240, 3, 80]
[12, 132, 33, 3, 6]
[15, 45, 24, 8, 12]
[15, 70, 14, 3, 2]
[16, 80, 15, 3, 2]
[19, 19, 9, 9, 4]
[19, 57, 9, 3, 1]
[21, 21, 5, 5, 1]
[25, 25, 9, 9, 3]
[25, 30, 6, 5, 1]

comp
(sec)
1.65
3.73
0.95
0.51
0.56
0.81
0.23
0.34
0.02
0.64
0.10

BEE
clauses
vars
698579
1211941
180238
116016
81563
109442
39931
113053
0
92059
24594

41399
58445
31947
19507
19693
26223
9273
6576
0
22098
2160

SAT
(sec)
1.73
13.60
0.73
8.46
0.39
0.56
0.09
0.17
0.00
1.33
0.06

comp
(sec)
1.88
3.14
1.20
0.66
0.98
1.13
0.38
12.49
0.00
0.97
1.14

 SatELite
clauses
vars
696914
1209788
179700
115938
78630
104760
39805
112314
0
91736
24028

38749
54043
28351
17642
15877
21116
7988
6230
0
18540
1926

SAT
(sec)
3.41
6.97
0.91

0.35
0.50
0.16
0.37
0.00
10.34
0.09

Table 7: BIBD results, BEE combined with SatELite (180 sec. timeout)
Our results demonstrate that the application of SatELite to remove redundancies
from a CNF is often non-beneficial. Presumably the difference we see from our application
of SatELite to other CNF benchmarks results from the fact that BEE produces highly
optimized CNF output, while many CNF benchmarks have significant inefficiency in their
original encoding. If BEE removes a variable from the CNF, then it also instantiates that
variable, either to a constant or to an equivalent variable, and as such does not remove
potential propagations from the encoding, as captured by Theorem 9.

9. Conclusion
There is a considerable body of work on CNF simplification techniques with a clear trade-off
between amount of reduction achieved and invested time. Most of these approaches determine binary clauses implied by the CNF, which is certainly enough to determine Boolean
equalities. The problem is that determining all binary clauses implied by the CNF is
prohibitive when the SAT model may involve many (hundreds of) thousands of variables.
337

fiMetodi, Codish, & Stuckey

instance

K8

K10

143
142
141
140
139
138
137
136
135
134
267
266
265
264
263
262
261
260
259
258

comp
(sec)
0.51
0.27
0.20
0.19
0.18
0.18
0.18
0.18
0.18
0.18
0.65
0.65
0.65
0.65
0.65
0.65
0.65
0.65
0.65
0.65

BEE
clauses
vars
248558
248414
248254
248078
247886
247678
247454
247214
246958
246686
1228962
1228660
1228338
1227996
1227634
1227252
1226850
1226428
1225986
1225524

5724
5716
5708
5700
5692
5684
5676
5668
5660
5652
15529
15529
15529
15529
15529
15529
15529
15529
15529
15529

SAT
(sec)
1.26
10.14
7.64
14.68
25.6
12.99
22.91
14.46
298.54
331.8
88.51
229.8
1335.31
486.09
236.68
1843.7
2771.6
4873.99



comp
(sec)
2.60
2.59
2.59
2.60
2.59
2.60
2.59
2.59
2.58
2.59
3.02
3.01
3.02
3.02
3.01
3.02
3.04
3.02
3.03
3.01

 SatELite
clauses
vars
248250
248107
247947
247771
247579
247371
247147
246907
246651
246379
1228368
1228066
1227744
1227402
1227040
1226658
1226256
1225834
1225392
1224930

5452
5445
5437
5429
5421
5413
5405
5397
5389
5381
14990
14990
14990
14990
14990
14990
14990
14990
14990
14990

SAT
(sec)
0.98
3.22
32.81
3.50
6.18
12.18
77.16
97.69
705.48

430.00
259.55
540.48
63.74
1008.06
1916.73





Table 8: VTML results, BEE combined with SatELite (4 hour timeout)

Typically only some of the implied binary clauses are determined, such as those visible by
unit propagation. The trade-off is regulated by the choice of the techniques applied to infer
binary clauses, considering the power and cost. See for example the work of Een and Biere
(2005) and the references therein. There are also approaches (Li, 2003) that detect and use
Boolean equalities during run-time, which are complementary to our approach.
In our approach, the beast is tamed by introducing a notion of locality. We do not
consider the full CNF. Instead, by maintaining the original representation, a conjunction of
constraints, each viewed as a Boolean formula, we can apply powerful reasoning techniques
to separate parts of the model and maintain efficient pre-processing.
To this end, we introduce BEE, a compiler that follows this approach to encode finite
domain constraints to CNF. Applying optimizations based on ad-hoc equi-propagation and
partial evaluation rules on a high level view of the problem allows us to simplify the problem
more aggressively than is possible with a CNF representation. The resulting CNF models
can be significantly smaller than those resulting from straight translation.
It is well-understood that making a CNF smaller is not the ultimate goal: often smaller
CNFs are harder to solve. Indeed, one often introduces redundancies to improve SAT
encodings: so removing them is counterproductive. Our experience is that BEE reduces
the size of an encoding in a way that is productive for the subsequent SAT solving. In
particular, by removing variables that can be determined at compile time to be definitely
equal (or definitely different) in any solution.
338

fiBoolean Equi-propagation

BEE uses ad-hoc equi-propagation and partial evaluation rules which keeps compilation
times typically small (measured in seconds) even for instances which result in several millions
of CNF clauses. And the reduction in SAT solving time can be larger by orders of magnitude.
Hence, we believe that Boolean equi-propagation makes an important contribution to the
encoding of CSPs to SAT.
BEE is currently tuned to represent integers in the order encoding. Ongoing work
aims to extend BEE for binary and additional number representations such as mixed radix
bases as considered by Een and Sorensson (2006) and further by Codish, Fekete, Fuhs, and
Schneider-Kamp (2011).
Acknowledgments
We thank Vitaly Lagoon for the many insightful discussions concerning this research.
NICTA is funded by the Australian Government as represented by the Department of
Broadband, Communications and the Digital Economy and the Australian Research Council through the ICT Centre of Excellence Program.

References
Ansotegui, C., del Val, A., Dotu, I., Fernandez, C., & Manya, F. (2004). Modeling choices in
quasigroup completion: SAT vs. CSP. In McGuinness, D. L., & Ferguson, G. (Eds.),
AAAI, pp. 137142, San Jose, California, USA. AAAI Press / The MIT Press.
Asn, R., Nieuwenhuis, R., Oliveras, A., & Rodrguez-Carbonell, E. (2011). Cardinality
networks: a theoretical and empirical study. Constraints, 16 (2), 195221.
Bagnara, R., & Schachte, P. (1998). Factorizing equivalent variable pairs in ROBDDbased implementations of Pos. In Haeberer, A. M. (Ed.), Algebraic Methodology and
Software Technology, 7th International Conference, AMAST 98, Amazonia, Brasil,
January 4-8, 1999, Proceedings, Vol. 1548 of Lecture Notes in Computer Science, pp.
471485.
Bailleux, O., & Boufkhad, Y. (2003). Efficient CNF encoding of Boolean cardinality constraints. In Rossi, F. (Ed.), CP, Vol. 2833 of LNCS, pp. 108122, Kinsale, Ireland.
Springer.
Barrett, C., Stump, A., & Tinelli, C. (2010). The Satisfiability Modulo Theories Library
(SMT-LIB). www.SMT-LIB.org.
Batcher, K. E. (1968). Sorting networks and their applications. In AFIPS Spring Joint
Computing Conference, Vol. 32 of AFIPS Conference Proceedings, pp. 307314, Atlantic City, NJ, USA. Thomson Book Company, Washington D.C.
Bessiere, C., Katsirelos, G., Narodytska, N., & Walsh, T. (2009). Circuit complexity and
decompositions of global constraints. In Proceedings of IJCAI 2009, pp. 412418.
Cadoli, M., & Schaerf, A. (2005). Compiling problem specifications into SAT. Artificial
Intelligence, 162 (1-2), 89120.
339

fiMetodi, Codish, & Stuckey

Codish, M., Fekete, Y., Fuhs, C., & Schneider-Kamp, P. (2011). Optimal base encodings
for pseudo-Boolean constraints. In Abdulla, P. A., & Leino, K. R. M. (Eds.), TACAS,
Vol. 6605 of Lecture Notes in Computer Science, pp. 189204. Springer.
Codish, M., Lagoon, V., & Stuckey, P. J. (2008). Logic programming with satisfiability.
TPLP, 8 (1), 121128.
Codish, M., & Zazon-Ivry, M. (2010). Pairwise cardinality networks. In Clarke, E. M., &
Voronkov, A. (Eds.), LPAR (Dakar), Vol. 6355 of Lecture Notes in Computer Science,
pp. 154172. Springer.
Coudert, O., & Madre, J. C. (1990). A unified framework for the formal verification of
sequential circuits. In ICCAD, pp. 126129.
Crawford, J. M., & Baker, A. B. (1994). Experimental results on the application of satisfiability algorithms to scheduling problems. In Hayes-Roth, B., & Korf, R. E. (Eds.),
AAAI, Vol. 2, pp. 10921097, Seattle, WA, USA. AAAI Press / The MIT Press.
Een, N., & Biere, A. (2005). Effective preprocessing in SAT through variable and clause
elimination. In Bacchus, F., & Walsh, T. (Eds.), SAT, Vol. 3569 of Lecture Notes in
Computer Science, pp. 6175. Springer.
Een, N., & Sorensson, N. (2003). An extensible SAT-solver. In Giunchiglia, E., & Tacchella, A. (Eds.), SAT, Vol. 2919 of Lecture Notes in Computer Science, pp. 502518.
Springer.
Een, N., & Sorensson, N. (2006). Translating pseudo-Boolean constraints into SAT. JSAT,
2 (1-4), 126.
Frisch, A. M., Jefferson, C., & Miguel, I. (2004). Symmetry breaking as a prelude to implied
constraints: A constraint modeling pattern. In Proc. 16th Euro. Conf. on AI, 171175,
pp. 171175. Press.
Frutos, A. G., Liu, Q., Thiel, A. J., Sanner, A. M. W., Condon, A. E., Smith, L. M., &
Corn, R. M. (1997). Demonstration of a word design strategy for DNA computing on
surfaces. Journal of Nucleic Acids Research, 25 (23), 47484757.
Gallian, J. A. (2011). A dynamic survey of graph labeling. The Electronic Journal of
Combinatorics, 18.
Gavanelli, M. (2007). The log-support encoding of CSP into SAT. In Bessiere, C. (Ed.),
CP, Vol. 4741 of LNCS, pp. 815822, Providence, RI, USA. Springer.
Gelder, A. V. (2005). Toward leaner binary-clause reasoning in a satisfiability solver. Ann.
Math. Artif. Intell., 43 (1), 239253.
Gent, I. P., Jefferson, C., & Miguel, I. (2006). Minion: A fast scalable constraint solver.
In Brewka, G., Coradeschi, S., Perini, A., & Traverso, P. (Eds.), ECAI, Vol. 141 of
Frontiers in Artificial Intelligence and Applications, pp. 98102. IOS Press.
Gent, I. P., & Nightingale, P. (2004). A new encoding of alldifferent into SAT. Proceedings
of the 3rd International Workshop on Modeling and Reformulating Constraint Satisfaction Problems, http://www-users.cs.york.ac.uk/frisch/Reformulation/04/
proceedings.pdf.
340

fiBoolean Equi-propagation

Gomes, C. P., Selman, B., & Crato, N. (1997). Heavy-tailed distributions in combinatorial
search. In Smolka, G. (Ed.), CP, Vol. 1330 of LNCS, pp. 121135. Springer.
Heule, M., Jarvisalo, M., & Biere, A. (2011). Efficient CNF simplification based on binary
implication graphs. In Sakallah, K. A., & Simon, L. (Eds.), SAT, Vol. 6695 of Lecture
Notes in Computer Science, pp. 201215. Springer.
Huang, J. (2008). Universal Booleanization of constraint models. In CP2008, Vol. 5202 of
Lecture Notes in Computer Science, pp. 144158.
Jager, G. (2010). An effective SAT encoding for magic labeling. In Faigle, U., Schrader, R.,
& Herrmann, D. (Eds.), CTW, pp. 97100.
Li, C. (2003). Equivalent literal propagation in the DLL procedure. Discrete Applied
Mathematics, 130 (2), 251276.
MacDougall, J., Miller, M., Slamin, M., & Wallis, W. (2002). Vertex-magic total labelings
of graphs. Utilitas Mathematica, 61, 321.
Mancini, T., Micaletto, D., Patrizi, F., & Cadoli, M. (2008). Evaluating ASP and commercial
solvers on the CSPLib. Constraints, 13 (4), 407436.
Manthey, N. (2012). Coprocessor 2.0 - a flexible CNF simplifier - (tool presentation). In
Cimatti, A., & Sebastiani, R. (Eds.), SAT, Vol. 7317 of Lecture Notes in Computer
Science, pp. 436441. Springer.
Metodi, A. (2012). BEE. http://amit.metodi.me/research/bee/.
Metodi, A., & Codish, M. (2012). Compiling finite domain constraints to SAT with BEE.
TPLP, 12 (4-5), 465483.
Metodi, A., Codish, M., Lagoon, V., & Stuckey, P. J. (2011). Boolean equi-propagation for
optimized SAT encoding. In Lee, J. H.-M. (Ed.), CP, Vol. 6876 of LNCS, pp. 621636.
Springer.
Nethercote, N., Stuckey, P. J., Becket, R., Brand, S., Duck, G. J., & Tack, G. (2007).
Minizinc: Towards a standard CP modeling language. In Bessiere, C. (Ed.), CP2007,
Vol. 4741 of Lecture Notes in Computer Science, pp. 529543, Providence, RI, USA.
Springer-Verlag.
Somenzi, F. (2009). CUDD: Colorado University Decision Diagram package. (Online,
accessed 13 April 2011). http://vlsi.colorado.edu/~fabio/CUDD/.
Soos, M. (2010). CryptoMiniSAT, v2.5.1. http://www.msoos.org/cryptominisat2.
Tamura, N., Taga, A., Kitagawa, S., & Banbara, M. (2009). Compiling finite linear CSP
into SAT. Constraints, 14 (2), 254272.
Tarjan, R. (1975). Efficiency of a good but not linear set union algorithm. JACM, 22 (2),
215225.
van Hentenryck, P. (1999). The OPL Optimization Programming Language. MIT Press.
van Hoeve, W. J. (2001). The alldifferent constraint: A survey.. CoRR:http://arxiv.org/
abs/cs.PL/0105015.

341

fi