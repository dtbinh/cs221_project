Journal of Artificial Intelligence Research 8 (1998) 1-21

Submitted 8/97; published 1/98

Monotonicity and Persistence in Preferential Logics
Joeri Engelfriet

Vrije Universiteit, Faculty of Mathematics and Computer Science
De Boelelaan 1081a, 1081 HV Amsterdam, The Netherlands

joeri@cs.vu.nl

Abstract

An important characteristic of many logics for Artificial Intelligence is their nonmonotonicity. This means that adding a formula to the premises can invalidate some of the
consequences. There may, however, exist formulae that can always be safely added to the
premises without destroying any of the consequences: we say they respect monotonicity.
Also, there may be formulae that, when they are a consequence, can not be invalidated
when adding any formula to the premises: we call them conservative. We study these
two classes of formulae for preferential logics, and show that they are closely linked to the
formulae whose truth-value is preserved along the (preferential) ordering. We will consider some preferential logics for illustration, and prove syntactic characterization results
for them. The results in this paper may improve the eciency of theorem provers for
preferential logics.

1. Introduction
Over the past decades, many non-classical logics for Artificial Intelligence have been defined
and investigated. The need for such logics arose from the unsuitability of classical logics to
describe defeasible reasoning. These classical logics are monotonic, which means that their
consequence relation (j) satisfies:
8ff; fi; '

: (ff j fi ) ff ^ ' j fi )

(Monotonicity)

This means that whenever we learn new information (') and add this to what we already
know (ff), all the old theorems (fi ) are still derivable. This is clearly undesirable when
describing defeasible reasoning. Therefore, monotonicity is not satisfied by many logics for
Artificial Intelligence.
On the other hand, monotonicity is a very attractive feature from a practical point of
view. When learning new information, we do not have to start all over again, but we can
retain our old conclusions, and focus on deriving possible new ones. Furthermore, when we
have a lot of information, we are allowed to focus on only part of it. Conclusions derived
from this part are then automatically also valid when considering all the information we
have (this is sometimes called local reasoning).
Even though it is clear that we do not want monotonicity to hold in general, it might
be worthwhile to investigate restricted variants of monotonicity. In the past, such variants
have been defined which allow us to keep the old theorems, when either the new information follows from the old premise (this variant is called Cautious Monotonicity by Kraus,
Lehmann, & Magidor, 1990) or its negation can not be derived from the old premise (this
is called Rational Monotonicity by Kraus et al., 1990).

c 1998 AI Access Foundation and Morgan Kaufmann Publishers. All rights reserved.

fiEngelfriet

We will take a somewhat different perspective, and consider two classes of formulae: the
class of formulae that can always be added to a premise without invalidating old conclusions
(we say these formulae respect monotonicity), and the class of formulae which can always be
retained as conclusions, no matter which new information is added to the premise (we say
these formulae are conservative). The advantages of monotonicity sketched above would
still hold when we restrict ' to the class of formulae that respect monotonicity, or when
we restrict fi to be conservative. Whether such classes exist, and what these classes are,
depends of course on the particular nonmonotonic logic considered. We will focus here on
an important class of nonmonotonic logics: the class of preferential logics (Shoham, 1987,
1988). These logics are based on a monotonic logic (such as propositional logic, predicate
logic or modal logic) augmented with a preference order on its models. The nonmonotonic
consequences of a formula ff are those formulae which are true in all models of ff which
are minimal in the preference order among all models of ff (an extensive discussion of
preferential logics is provided by van Benthem, 1989). We will give a formal definition.

Definition 1 (Preferential logic) A preferential logic consists of a language L, a class

of models Mod together with a satisfaction relation j= between models and formulae, and
a partial order  on Mod. A model m 2 Mod is called a minimal model of a formula ff
(denoted m j= ff) if m j= ff and for all models n, if n  m and n j= ff then n = m.
Preferential entailment (j= ) between formulae is defined as follows: for ff; fi 2 L : ff j= fi
if fi is true in all minimal models of ff.

Our presentation uses a partial order, i.e., a reexive, antisymmetric and transitive
relation. Shoham (1987) uses a strict partial order, i.e., an irreexive transitive relation,
with a slightly different notion of minimal model. The presentations can be translated into
each other.
It will turn out that formulae whose truth is preserved when going to more preferred
or less preferred models, play an important role with respect to the two classes of formulae
defined above (the class of formulae that respect monotonicity, and the class of conservative
formulae). We will first give a definition.

Definition 2 (Persistence) Given a preferential logic (L; Mod; j=; ), a formula ff 2 L is
called downward persistent in this logic, if

8m; n 2 Mod : (m j= ff

and n  m) ) n j= ff;

and it is called upward persistent if
8m; n 2 Mod : (n j= ff

and n  m) ) m j= ff:

In the next section, we will introduce some preferential logics to illustrate the material
in the rest of the paper. In Section 3 we will consider formulae that respect monotonicity,
and in Section 4 conservative formulae will be treated. The practical implications of the
results of this paper are discussed in Section 5. Section 6 gives conclusions and suggestions
for further research. Part of the material in this paper appeared in (Engelfriet, 1996b).
2

fiMonotonicity and Persistence in Preferential Logics

2. Some Preferential Logics

In this section we will describe the following preferential logics: Ground S5, Minimal Temporal Epistemic Logic and Circumscription. Since we have already defined preferential
entailment in general, for each logic we only have to give its ingredients, i.e., L; Mod; j=,
and . The preferential entailment relation is then fixed by Definition 1. The first logic we
will consider is Ground S5.

2.1 Ground S5

Ground S5 is a nonmonotonic modal logic for auto-epistemic reasoning, originally proposed
by Halpern and Moses (1985). Their aim was to formalize statements of the form "I only
know '". It allows, for example, to derive that an agent which only knows p, does not
know q. Ground S5 falls into the general scheme of ground nonmonotonic modal logics
(Donini, Nardi, & Rosati, 1997). A lot of interest is devoted to logics of minimal knowledge
(Levesque, 1990; Schwarz & Truszczynski, 1994; Chen, 1997; Halpern, 1997).
Semantically, states in which an agent only knows ', are states in which ' is known, but
otherwise the amount of knowledge is minimal. We will use a modal propositional language
to express the knowledge of the agent, and S5 will be the monotonic logic. We will give a
treatment of Ground S5 slightly different, but equivalent to the one given by Halpern and
Moses (1985).

Definition 3 (Epistemic language) Let P be a (finite or countably infinite) set of propositional atoms. The language LS5 is the smallest set closed under:


if p 2 P then p 2 LS5 ;



if ';

2 LS5

then K'; ' ^ ; :' 2 LS5 .

Furthermore, we introduce the following abbreviations:

'_

 :(:' ^ :

); ' !

 :' _

; M'  :K :'; >  p _ :p; ?  :>:

If every atom occurring in a formula ' is in the scope of a K operator, we call ' subjective.

An example of a subjective formula is :Kp ^ K (q ! p), whereas K (p ^ q) _ s is not
subjective. In the rest of this paper we will only be interested in subjective formulae: they
describe (just) the knowledge and ignorance of the agent.
In the usual S5 semantics, a model is a triple (W; R; ), where W is a set of worlds, R is
an equivalence relation on W and  is a function that assigns a propositional valuation to
each world in W . We may however, in the case of one agent, restrict ourselves to normal S5
models, in which the relation is universal (each world is accessible from every world), and
worlds are identified with propositional valuations (a proof of soundness and completeness
of S5 with respect to these semantics is given by Meyer & van der Hoek, 1995).

Definition 4 (S5 semantics) Let P be a (finite or countably infinite) set of propositional

atoms. A propositional valuation is a function from P into f0; 1g where 0 stands for false
and 1 for true. The set of all such valuations will be denoted by Mod(P ). A normal S5
3

fiEngelfriet

model M is a non-empty subset of Mod(P ). The truth of an S5 formula ' in such a model,
evaluated in a world m 2 M , denoted (M; m) j=S5 ', is defined inductively:
1: (M; m) j=S5 p
, m(p) = 1, for p 2 P
2: (M; m) j=S5 ' ^ , (M; m) j=S5 ' and (M; m) j=S5
3: (M; m) j=S5 :' , it is not the case that (M; m) j=S5 '
4: (M; m) j=S5 K' , (M; m0 ) j=S5 ' for every m0 2 M
We have the following elementary results on subjective formulae. The proofs are straightforward.

Proposition 5 (Subjective formulae)

1. Let ' be a subjective formula. For a normal S5 model M and m1 ; m2 2 M it holds:
(M; m1 ) j=S5 ' , (M; m2 ) j=S5 ':
We define M j=S5 ' if (M; m) j=S5 ' for some, or, equivalently, all m 2 M . The set
of all normal S5 models, sometimes called information states, is denoted by IS.
2. An S5 formula ' is subjective if and only if it is equivalent to a formula of the form
K' with ' 2 LS5.
A subjective formula describes the knowledge of an agent, but we want to formalize that
this is all the agent knows. Therefore we are looking for models in which the knowledge of
the agent is minimal, or in other words, in which the ignorance of the agent is maximal. We
introduce a preference order over information states which favors models with less knowledge. The definition of this ordering is based on the observation that the more valuations
the agent considers possible, the less knowledge the agent has. Indeed, for any propositional
formula ' we have: if M1 j= K' and M1  M2 then M2 j= K'.
Definition 6 (Degree of knowledge) We define the degree-of-knowledge ordering  on
normal S5 models as follows: for M1 ; M2 2 IS : M1  M2 , M1  M2 .
Ground S5 is the preferential logic based on this ordering.
Definition 7 (Ground S5) Ground S5 is the preferential logic with the subjective formulae of LS5 as its language, IS as its class of models, the satisfaction relation of Proposition 5
and the ordering of Definition 6. We will denote preferential entailment (as defined in Definition 1) of Ground S5 by j=GS5 .
The reader can now check that, for instance, Kp j=GS5 :Kq. The (unique) minimal
S5 model of Kp consists of all propositional valuations in which p is true, and this indeed
contains a model in which q is false. The entailment relation is nonmonotonic since Kp ^
Kq 6j=GS5 :Kq. Another example illustrates the minimality of the agent's knowledge: Kp _
Kq j=GS5 :(Kp ^ Kq).
Let us define a consequence relation j by ' j if K' j=GS5 K . Then it turns out
that this is the consequence relation of Halpern and Moses (1985), apart from the fact that
they only defined it for premises which have a unique minimal model. Premises with a
unique minimal model are called honest. To give an example, the formula Kp is honest,
but Kp _ Kq is not: both the S5 model consisting of all valuations in which p is true, and
the model with all valuations in which q is true, are minimal models.
4

fiMonotonicity and Persistence in Preferential Logics

2.2 Minimal Temporal Epistemic Logic

In Ground S5, we are only able to express something about `all the agent knows' at a
particular instant. We will extend this logic in such a way that we are also able to say
something about the changing knowledge of the agent over time. Originally, this extended
logic was intended as a means of specifying nonmonotonic reasoning processes and of reasoning about their properties (Engelfriet & Treur, 1994, 1996; Engelfriet, 1996a). The idea
is that a temporal formula describes the nonmonotonic inferences the agent has to perform
during the course of a reasoning process (analogously to the use of temporal logic for specifying computer processes). But these inferences should also be the only cause of increases
in the agent's knowledge. Therefore, we again have to minimize the agent's knowledge, but
now over time (analogously to the use of minimization for dealing with the frame problem
in temporal logics for describing action and change, Shoham, 1988). To this end, we will
temporalize the epistemic language, epistemic models and the degree-of-knowledge ordering.
In order to describe past and future we introduce temporal operators P; H; F; G and
2, denoting respectively \sometimes in the past", \always in the past", \sometimes in the
future", \always in the future" and \always". We do not want to describe the agent's knowledge of the future and past, but the future and past of the agent's knowledge. Therefore,
temporal operators are not allowed to occur within the scope of the epistemic K operator.

Definition 8 (Temporal epistemic language) The language
closed under:


if ' 2 LS5 then ' 2 LTEL ;



if ff; fi 2 LTEL then ff ^ fi; :ff; Pff; Fff 2 LTEL .

LTEL

is the smallest set

Again the abbreviations for _; !; > and ? are introduced, as well as:

Gff  :F (:ff); Hff  :P (:ff) and 2ff  Hff ^ ff ^ Gff:
If in the first clause we restrict ourselves to subjective formulae, we get the set of subjective
TEL formulae.

In the rest of this paper we will be interested in subjective TEL formulae since they
describe how the knowledge of the agent is changing over time. Based on the set of natural
numbers (N) as ow of time, and normal S5 models as formalization of states in a temporal
model, the following semantics is introduced for temporal epistemic logic (TEL):

Definition 9 (Semantics of TEL) A TEL model is a function M : N ! IS . The truth
of a formula ' 2 LTEL in M at time point t 2 N, denoted (M; t) j= ', is defined inductively
as follows:

1:
2:
3:
4:
5:

(M; t) j= '
(M; t) j= ' ^
(M; t) j= :'
(M; t) j= P'
(M; t) j= F'

, M(t) j=S5 ', if ' 2 LS5
, (M; t) j= ' and (M; t) j=
, it is not the case that (M; t) j= '
, 9s 2
such that s < t and (M; s) j= '
, 9s 2
such that t < s and (M; s) j= '

N
N

5

fiEngelfriet

A formula ' is true in a model M , denoted M j= ', if (M; 0) j= '. A TEL model M
is called conservative (or a TELC model) if for all s < t 2 N : M(s)  M(t), with the
ordering  of Definition 6. The set of TELC models is denoted by TCIS.

Note that the above definition is in principle ambiguous: a formula like Kp ^ Kq is
an S5 formula which can be interpreted according to the first semantic clause, but it can
also be seen as a conjunction, to be interpreted according to the second clause. As the
interpretation of the conjunction (and the same holds for negation) is the same in S5 as in
TEL, this ambiguity is harmless.
We will briey explain the reason we have defined M j= ' if (M; 0) j= '. Later on, we
will make the general assumption on preferential logics that the language contains negation,
and that m j= :' if and only if m 6j= ' (Assumption 1). If we define M j= ' if (M; t) j= '
for all t 2 N, then this assumption would not hold for TEL. The two definitions can be
translated into each other, since (M; 0) j= ' if and only if (M; t) j= :P > ! ' for all t 2 N
and (M; t) j= ' for all t 2 N if and only if (M; 0) j= ' ^ G'. This is also one of the reasons
we gave a slightly different presentation of Ground S5 (using subjective formulae).
In conservative models, the propositional knowledge of an agent can only increase in
time. We will restrict ourselves to these models, i.e., an agent can not forget or revise its
(propositional) knowledge. Indeed, for a propositional formula ' and a TELC model M , if
(M; t) j= K' then (M; s) j= K' for all s > t. This restriction can be made when the agent
is reasoning about a fixed (non-changing) situation, and we are abstracting from particular
implementation details (such as the use of backtracking implementations for nonmonotonic
logics). We now extend the ordering and minimal consequence relation to TELC models.
The ordering is extended in a pointwise fashion.

Definition 10 (Minimal temporal epistemic logic)
1. We extend the degree-of-knowledge ordering to TELC models by defining
MN ,

for all s 2 N : M(s)  N (s):

2. Minimal temporal epistemic logic (MTEL) is the preferential logic with the subjective
TEL formulae as its language, TCIS as its class of models, the satisfaction relation
(M j= ') of Definition 9 and the ordering of item 1. We will denote preferential
entailment (as defined in Definition 1) of MTEL by j=MTEL.

The idea behind using MTEL for specifying reasoning processes is that a subjective
TEL formula ' describes the reasoning of an agent over time (it can, for example, describe
the use of nonmonotonic inference rules, see Proposition 11). The minimal models of '
represent the process of the agent reasoning in time. We can then use minimal consequence
to infer properties of this reasoning process.
It is easy to see that MTEL is a generalization of Ground S5: for subjective S5 formulae
'; we have that ' j=MTEL if and only if ' j=GS5 . As an example of the use of the
notion of minimal temporal epistemic consequence, it has been shown by Engelfriet and
Treur (1993) that it can capture default logic (Reiter, 1980b).
6

fiMonotonicity and Persistence in Preferential Logics

Proposition 11 (Default logic in MTEL) Let a finite, propositional default theory  =

hW; D i

be given and let

^

^

= f2(Kff ^ G(:K :fi ) ! G(K )) j (ff; fi )= 2 Dg ^ fKff j ff 2 W g:
Then ' is a sceptical consequence of  in default logic if and only if j=MTEL F (K').
The conjuncts of the form 2(Kff ^ G(:K :fi ) ! G(K )) ensure the application of the
default rules. In words: if the agent knows the prerequisite (ff), and the justification (fi )
remains consistent with what the agent knows throughout the future, then the agent must
conclude the consequent ( ) in the next moment in time (and it will know  henceforth).

2.3 Circumscription

One of the earliest approaches to nonmonotonic reasoning is circumscription (McCarthy,
1977, 1980; Davis, 1980; Lifschitz, 1994; Etherington, 1988), a preferential logic based on
first-order predicate logic. The main idea behind circumscription is a kind of completeness
of information given to us: \the premises as stated give us `the whole truth' about the
matter" (van Benthem, 1989). This leads to at least two kinds of minimality: predicateminimality and domain-minimality. The intuition behind predicate-minimality is that for
some relevant property (predicate), all objects that have this property, are explicitly said
to have this property in the premise. This allows us to formulate defaults stating that all
normal objects have some property. Minimizing abnormality will allow us to conclude an
object has this property, unless we can deduce from the premise that this object is abnormal.
The intuition behind domain-minimality, is that the domain (of discourse) contains no other
objects than those that can be deduced to exist from the premise. (This intuition is strongly
tied to the domain-closure assumption of Reiter, 1980a). These two kinds of minimality are
formalized by two variants of Circumscription. Both of them will be treated below.
The classical logic underlying circumscription is first-order predicate logic. We assume
a standard first-order language L with a finite number of predicate symbols, including
equality. We will also assume that the language contains no function or constant symbols.
This is not a severe limitation, since we can eliminate function and constant symbols by
introducing new predicate symbols (Davis, 1980). We will first give the definition of the
orderings and then define predicate and domain circumscriptive consequence.

Definition 12

1. Let P be a predicate symbol in the language L. For a structure M for the language,
P M denotes the interpretation of P in M (so P M is a subset of dom(M )n , where
dom(M ) is the domain of M , and n is the arity of P ). For two structures M; N ,
we say M is P -preferred to N , denoted M P N , if they have the same domain,
the same interpretation of predicate symbols other than P , and P M  P N . Predicate
circumscription of P is the preferential logic which uses first-order predicate logic for
the language, models and satisfaction relation, augmented with the ordering P . We
will denote preferential entailment (as defined in Definition 1) in this logic by j=PC
P .
2. For two structures M; N for the language L, we say N is a substructure of M , denoted
N d M , if the domain of N is a subset of the domain of M , and the interpretation
7

fiEngelfriet

of each predicate symbol in N is the restriction of the corresponding interpretation in
M to dom(N ). Domain circumscription is the preferential logic which uses first-order
predicate logic for the language, models and satisfaction relation, augmented with the
ordering d . We will denote preferential entailment in this logic by j=DC .
3. If we restrict the model class to finite structures, the resulting preferential logics are
called finite predicate circumscription and finite domain circumscription.

We refer the reader to the references given above for standard results and motivation of
circumscription.

3. Respecting Monotonicity

In this section we will study formulae which respect monotonicity. We will first give a
formal definition.

Definition 13 (Respecting monotonicity) Given a preferential logic, we say a formula
' respects monotonicity, if

8ff; fi

: ff j= fi ) ff ^ ' j= fi:

Next, we will make some basic assumptions about the (underlying logic of the) preferential logic.

Assumption 1 From now on we will assume that any preferential logic satisfies the following:


the language has conjunction (^) and m j= ' ^

, m j= '



the language has implication (!) and m j= ' !



the language has negation (:) and m j= :' , m 6j= '.

and m j= .

, m 6j= '

or m j= .

We can then immediately identify a class of formulae that respect monotonicity:

Proposition 14 Downward persistent formulae respect monotonicity.
Proof: Suppose ' is downward persistent. Let ff; fi be formulae and suppose ff j= fi . Let

m be a minimal model of ff ^ '. Then it is also a minimal model of ff. For suppose it is not,
then there exists n  m, n 6= m and n j= ff. Since m j= ' and ' is downward persistent, we
have n j= '. But then n j= ff ^ ' which contradicts the assumption that m was a minimal
model of ff ^ '. Since m is a minimal model of ff and ff j= fi , we have m j= fi . We have
proved that ff ^ ' j= fi . Thus, ' respects monotonicity.
2
Of course, valid and unsatisfiable sentences are downward persistent. But the question is whether non-trivial downward persistent formulae exist. For the preferential logics
introduced in Section 2, the answer is armative.
8

fiMonotonicity and Persistence in Preferential Logics

Definition 15 (DIAM) Define the class of S5 formulae DIAM by:
DIAM ::= M (') j DIAM ^ DIAM j DIAM _ DIAM j M (DIAM)
where ' is propositional.

Formulae from DIAM essentially only contain the M operator (the `diamond' of S5, and
not the `box' operator K ). Formulae in this class are the only subjective formulae (up to
equivalence) which are downward persistent in Ground S5 (this was proved by Engelfriet,
1996a).

Theorem 16 A subjective S5 formula ' is downward persistent in Ground S5 if and only
if it is S5-equivalent to a formula in DIAM.

So in Ground S5 there is a non-empty class of downward persistent formulae, that
respect monotonicity by Proposition 14. Essentially, these formulae only say something
about the ignorance of the agent. One might think that formulae from DIAM are completely
uninteresting, and never yield any new insights in Ground S5. The converse of monotonicity
for these formulae, ff ^ ' j=GS5 fi ) ff j=GS5 fi , however, does not hold, even when ' is
consistent with ff. We do not have that Kp _ Kq j=GS5 Kq, whereas we do have that
(Kp _ Kq) ^ M (:p) j=GS5 Kq with M (:p) 2 DIAM. So knowledge of ignorance can be
useful.
An analogous result holds for minimal temporal epistemic logic.

Definition 17 (TD)
1. Define
TD ::= DIAM j TD ^ TD j TD _ TD j F (TD) j G(TD) j P (TD) j H (TD)
2. For two subjective TEL formulae '; :

'

,def

for all TELC models M : M j= ' , M j= :

TD stands for `temporal diamond' formulae. The following was also proved by Engelfriet
(1996a).

Theorem 18 In MTEL, a formula ' is downward persistent if and only if it is equivalent
(in the sense of ) to a formula in TD.

As in the case of Ground S5, these formulae express (temporal) ignorance of the agent.

Definition 19 (Positive and universal formulae) A first-order predicate formula is negative in a predicate P , if all occurrences of the predicate P are in the scope of an odd number
of negations. A formula is universal if it is of the form 8x1 : : : xn where is quantifier
free.
9

fiEngelfriet

The following result links these formulae to downward persistence in circumscription.
The first is a variant of Lyndon's theorem and is folklore (we leave the details to the
reader); the second result is known as the Los-Tarski theorem (Chang & Keisler, 1990,
Theorem 3.2.2).

Theorem 20
1. A first-order predicate formula ' is downward persistent in predicate circumscription
(of P ) if and only if it is equivalent to a formula that is negative in P .
2. A first-order predicate formula ' is downward persistent in domain circumscription if
and only if it is equivalent to a universal formula.

So downward persistent formulae in predicate circumscription essentially only say something about elements not having property P (besides the other properties they mention),
and downward persistent formulae in domain circumscription essentially only mention universal properties (and do not say anything about the existence of objects).
For our examples, we have shown that non-trivial classes of formulae that respect monotonicity exist. The question is whether there are more such formulae, besides those that are
downward persistent. We will give a criterion that ensures that there are no more formulae
that respect monotonicity.

Definition 21 (Expressibility of preference) A preferential logic satisfies expressibility of preference if the following holds:

8m 2 Mod : 9'm 2 L : 8n 2 Mod : (n j= 'm , m  n):

The formula 'm expresses: \I am less preferred than m," and describes exactly those
models which are larger in the preferential ordering. The criterion of expressibility of
preference poses a requirement on the expressiveness of the language, given its semantics.
We will prove that in preferential logics that satisfy the condition in this definition, the
downward persistent formulae are the only ones that respect monotonicity. The above
condition can be generalized by taking into account equivalent models; we have not done
this immediately as it makes things rather cumbersome. If whenever n  m and m  k
(where m  k means that m and k satisfy the same formulae), there exists a model l such
that l  n and l  k, then we can generalize the condition to: 8m 2 Mod : 9'm 2 L : 8n 2
Mod : (n j= 'm , 9k 2 Mod : m  k & k  n).

Theorem 22 (Only if : : : ) For a preferential logic that satisfies expressibility of preference we have: if a formula respect monotonicity, then it is downward persistent.

Proof: Suppose a formula ' is not downward persistent, then there exist models m and

n such that m j= ', n 6j= ' and n  m. Define ff = 'n ^ (' ! 'm ) and fi = :'. First
we claim that ff j= fi . Since n  n, we have n j= 'n , and as n 6j= ' we get n j= ff.
Furthermore, for any model k, if k j= ff then in particular k j= 'n so n  k. Therefore,
n is the only minimal model of ff, and since n 6j= ', we have n j= fi . On the other hand,
ff ^ ' 6j= fi : n  m so m j= 'n and m  m so m j= 'm from which we conclude that m j= ff
10

fiMonotonicity and Persistence in Preferential Logics

so m j= ff ^ '. Furthermore, for any model k, if k j= ff ^ ', then k j= ' and k j= ' ! 'm
so k j= 'm . From this it follows that m  k, but this means that m is a (actually, the
only) minimal model of ff ^ ' and m j= ' so m 6j= fi . We conclude that ' does not respect
monotonicity, since we have found formulae ff and fi such that ff j= fi but ff ^ ' 6j= fi . 2
It may seem that the condition of expressibility of preference is too restrictive. However,
we will see that it is useful for the examples.

Proposition 23 For Ground S5, MTEL and finite predicate and domain circumscription,
only downward persistent formulae respect monotonicity.

Proof: Remark that all of these logics satisfy Assumption 1. First consider Ground S5.
Let us first take the language to be finite (that is, P is finite). Take any
S5 model M .
V
m
m
For each
propositional valuation m, define the formula ff by ff = fp 2 P j m j=
pg ^ Vf:Vp j p 2 P; m 6j= pg. This is a well-defined formula since P is finite. Now construct
'M = fK (:ffm ) j m 2= M g, which is again a well-defined formula since Mod(P ) is
finite. It can easily be seen that any S5 model N satisfies 'M if and only if M  N . So
expressibility of preference is satisfied, whence Theorem 22 ensures that only downward
persistent formulae respect monotonicity for this finite language. Now let P be arbitrary,
and suppose ' in this language respects monotonicity. Then it is easy to see that if we
restrict the language to atoms occurring in ', it still respects monotonicity, so it is downward
persistent in the restricted language. It follows easily that ' is also downward persistent in
the full language.
For MTEL, the same considerations make it sucient to give a formula 'M for a finite
language only, so let us take P finite. Then every S5 model M(i) is a finite set of propositional valuations. Since the sequence fM(i)g is decreasing with respect to set-inclusion
(as M is conservative), there will be an index k such that M(j ) = M(k) for all j > k.
To improve readability of the formula 'M we define the formulae ati to be P i > ^ H i+1 ?
(where P i stands for a sequence of P operators of length i). It is easy to see that for any
model N we have (N ; j ) j= ati if and only if j = i. Now define:
'M = Vf2(ati ! 'M(i) ) j 0  i  kg, where 'M(i) is the formula as defined in the case of
Ground S5 for the S5 model M(i) . It is easy to show that N j= 'M if and only if M  N .
For finite circumscription, we need the more general definition of expressibility of preference hinted at before (in first-order logic, there may be equivalent models: different models
that satisfy the same first-order formulae). Here we need not restrict the language. In
predicate circumscription, the required formula 'M for a finite structure M expresses: (i)
the exact number of elements of the domain of M , (ii) for which of these elements P holds,
and (iii) for all other predicates Q it expresses for which elements Q holds, and for which its
negation holds. In domain circumscription, the required formula 'M for a finite structure
M expresses the fact that there are (at least) as many elements as in M , and for each
predicate Q, it expresses for which of these elements Q holds, and for which elements its
negation holds.
2
It is not possible to find the required formula 'M in (non-finite) circumscription in
general: for infinite structures we are not in general able to express the number of elements,
11

fiEngelfriet

and we can not describe the entire extensions of predicates in general. Indeed, the above
result does not hold for domain circumscription. It is still an open question whether it holds
for predicate circumscription.

Proposition 24 For domain circumscription, there exists a first-order predicate formula
which respects monotonicity but is not downward persistent.

Proof: Consider the first-order language L = f<; =g, and let ' be a sentence stating that

< is a dense linear ordering without begin- or endpoint. This is a complete theory (Rabin,
1977, Theorem 4), which means that for any ff 2 L, either ' j= ff or ' j= :ff. Now suppose
ff j=DC fi . If ' j= :ff then ff ^ ' is inconsistent, so ff ^ ' j=DC fi trivially. Otherwise we
have that ' j= ff so ff ^ ' is equivalent to '. But it is easy to see that ' does not have a
minimal model, so again we have ff ^ ' j=DC fi . However, ' is not downward persistent: it
holds in the real numbers, but not in the substructure of the natural numbers.
2
Until now we have considered formulae that can be added to any premise, but we can
also ask the question whether a formula respects monotonicity for a given, fixed premise.

Proposition 25 Given a preferential logic such that Mod is finite and for all m 2 Mod

there exists ffm 2 L such that n j= ffm if and only if n = m, let ff be a fixed formula in L.
Then we have for all ' 2 L:
8fi (ff j=

fi ) ff ^ ' j= fi ) , 8m 2 Mod(m j= ff ^ ' ) m j= ff):
Proof: The right to left direction is trivial (and does not depend on the assumption). For
the other direction, suppose that 8fi (ff j= Wfi ) ff ^ ' j= fi ). Let m 2 Mod be arbitrary
and suppose m j= ff ^ '. Now define fi = fffn j n j= ffg; this is a well-defined formula
since Mod was assumed finite. It is easy to see that ff j= fi : suppose n j= ff, then ffn
is one of the disjuncts of fi , and by definition of ffn , we have n j= ffn , so n j= fi . But the
assumption now gives that ff ^ ' j= fi . As m j= ff ^ ', we have m j= fi , so there is an
n 2 Mod with n j= ff and m j= ffn. But by definition of ffn this means that m = n so
m j= ff.
2
Proposition 25 states that a formula ' respects monotonicity for a fixed premise ff if
and only if the minimal models of ff ^ ' are minimal models of ff. Of course the criterion
on the right-hand side is hard to check; we can give another criterion, but for that, we first
need the following definition (Kraus et al., 1990):

Definition 26 (Smoothness) A preferential logic is called smooth, if the following holds:
8ff 2 L : 8m 2 Mod : (m j= ff ) 9n 2 Mod : n  m & n j= ff):
This condition, which is also called stopperedness or well-foundedness, and is akin to
the limit assumption (Lewis, 1973), forbids chains of ever-decreasing models satisfying a
formula. It is one of the basic properties in the framework of Kraus et al. (1990).
Proposition 27 Given a smooth preferential logic, we have: 8m 2 Mod(m j= ff ^ ' )
m j= ff) if and only if 8m 2 Mod(m j= ff ^ ' ) 9n 2 Mod(n  m; n j= ff and n j= ')).
12

fiMonotonicity and Persistence in Preferential Logics

The proof of this proposition is straightforward, and again it may not help much. As
far as the examples are concerned, the conclusion of Proposition 25 holds for both Ground
S5 and MTEL (the properties depend only on ff and ' so we may restrict the signature and
then use the proposition). Proposition 27 holds for Ground S5 (which is smooth). From
these propositions we can find some sucient conditions. If ' is downward persistent in
the models of ff, then Proposition 25 ensures that ' respects monotonicity with respect to
ff. If ff j= ' then Proposition 27 ensures that ' respects monotonicity with respect to ff
(but this also follows immediately with the rule of Cautious Monotonicity, which is satisfied
in smooth preferential logics, Kraus et al., 1990). It seems hard to find a simple criterion
necessary and sucient for respecting monotonicity for a given premise. We leave this for
further research.

4. Conservativity

In the previous section we have considered formulae that can always be added to a premise
without invalidating any of the conclusions. In this section we will focus on the conclusions,
and study formulae that, when they are concluded, can always be kept, no matter which
new information is added to the premise. We will call these formulae conservative.

Definition 28 (Conservative) Given a preferential logic, we say a formula fi is conservative, if

8ff; ' : ff j=

fi ) ff ^ ' j= fi:

We have the following result connecting upward persistent and conservative formulae,
in analogy with Proposition 14.

Proposition 29 Given a preferential logic that is smooth, if a formula is upward persistent,
it is conservative.

Proof: Let fi be upward persistent in a smooth preferential logic. Now suppose ff j= fi .
Take any model m such that m j= ff ^ ', then m j= ff so by smoothness, there is a model
n with n  m and n j= ff. Then, as ff j= fi , we have n j= fi . Since n  m and fi is
upward persistent, we have m j= fi . This shows that ff ^ ' j= fi , so fi is conservative. 2
Again, we can ask if the upward persistent formulae are the only conservative formulae,
and this is true under the same conditions as in the case of respecting monotonicity.
Proposition 30 (Only if : : : ) For a preferential logic that satisfies expressibility of preference we have: if a formula is conservative, then it is upward persistent.
Proof: Suppose fi is not upward persistent, then there are n; m 2 Mod such that n  m,
and n j= fi but m 6j= fi . Now take ff = 'n and ' = 'm . Then n is the only minimal model
of ff and n j= fi so ff j= fi , but m is a (actually, the only one) minimal model of ff ^ ', and
m 6j= fi , so ff ^ ' 6j= fi . Thus, fi is not conservative.
2
Let us first identify the upward persistent formulae for our examples. This is relatively
straightforward, since we have the following elementary result.
13

fiEngelfriet

Proposition 31 For any preferential logic, ' is upward persistent if and only if :' is
downward persistent.

This gives us the following.

Proposition 32
1. Define BOX ::= K (') j BOX ^ BOX j BOX _ BOX j K (BOX) with ' propositional.
Then a subjective S5 formula ' is upward persistent in Ground S5 if and only if it is
S5-equivalent to a formula in BOX.
2. Define TB ::= BOX j TB ^ TB j TB _ TB j F (TB) j G(TB) j P (TB) j H (TB). Then a
subjective TEL formula ' is upward persistent in MTEL if and only if it is equivalent
(in the sense of ) to a formula in TB.
3. A first-order formula is upward persistent in predicate circumscription (of P ) if and
only if it is equivalent to a formula that is positive in P (meaning that all occurrences
of the predicate P are in the scope of an even number of negations). A first-order
formula is upward persistent in domain circumscription if and only if it is equivalent
to an existential formula (a formula of the form 9x1 : : : xn where is quantifier
free).

Proof: Straightforward.

2

In the above definition, formulae from BOX essentially only contain the K operator (the
`box' of S5); TB stands for `temporal box' formulae. Now let us see what Propositions 29
and 30 say about the examples. Ground S5 satisfies expressibility of preference (for a finite
language) and is smooth, so the conservative formulae are exactly the upward persistent
formulae, which express only knowledge (and not ignorance). This can be lifted again
to an infinite language. The fact that in Ground S5, formulae that express propositional
knowledge, are conservative, was already noted by Donini et al. (1997). MTEL also satisfies
expressibility of preference (for a finite language), so any formula that is conservative, must
be upward persistent, and must be equivalent to a formula in TB, expressing knowledge
over time (not ignorance). This can be lifted to an infinite language. Unfortunately, MTEL
is not smooth: the formula F (Kp) is satisfiable, but has no minimal model. In MTEL,
we have that F (Kp) j=MTEL F (Kq), but F (Kp) ^ Kp 6j=MTEL F (Kq) (F (Kp) ^ Kp has a
minimal model, in which only p is known, from the first point in time onwards). This means
that the formula F (Kq) is not conservative, although it is upward persistent. It is easy to
see that in any preferential logic, valid formulae are always conservative, but in MTEL,
these are (almost) the only ones.

Definition 33 We call a TEL model M totally ignorant, if for all propositional formulae

' we have: if M j= F (K') then ' is a propositional tautology. Define the totally ignorant
model Mti by Mti (i) = Mod(P ) for all i.
In a totally ignorant model, no knowledge is ever gained. The totally ignorant model is
certainly a totally ignorant model, and if P is finite, it is the only one.
14

fiMonotonicity and Persistence in Preferential Logics

Proposition 34 For MTEL, in case P is infinite, we have that a formula is conservative
if and only if it is true in all models. When P is finite, a formula is conservative if and
only if it is true in all models except possibly the totally ignorant model.

Proof: We will prove that fi is conservative if and only if it is true in all models that are not

totally ignorant (both when P is finite and when it is infinite). First, suppose M is a model
that is not totally ignorant, in which fi is not true. So M j= F (K ) for some propositional
formula  that is not a propositional tautology. If P is finite, we can consider the formula
'M (see the proof of Proposition 23 for the definition of 'M ). If P is infinite, one can
show that M can be chosen in such a way that it is a `inherently finite' model, allowing the
construction of a formula 'M with the same properties as for the case when P is finite (using
essentially the same construction). The details of this argument are left to the reader. The
formula F (K ) does not have a minimal model ( must be known sometimes in the future,
but this moment can always be postponed, yielding a smaller model), so F (K ) j=MTEL fi .
On the other hand, it can easily be shown that the only minimal model of F (K ) ^ 'M is
M , which gives us F (K ) ^ 'M 6j=MTEL fi . This means that fi is not conservative.
Now suppose that fi is true in all models that are not totally ignorant, and suppose
ff j=MTEL fi . Let M be a minimal model of ff ^ '. If M is not totally ignorant, then
M j= fi . If it is totally ignorant, then also Mti j= ff ^ ' (it can be shown by induction that
all totally ignorant models satisfy the same formulae). But then Mti j= ff. Since no model
is preferred over Mti , this means that Mti j= ff so Mti j= fi , whence M j= fi . It follows
that ff ^ ' j=MTEL fi , so fi is conservative.
Let us look at the case when P is infinite. Suppose M 6j= fi , with M totally ignorant.
Now take a propositional atom p not occurring in fi . It can easily be shown that we can
find a model of Kp in which fi is not satisfied. This model is of course not totally ignorant.
This shows that if fi is true in all models that are not totally ignorant, then it is true in all
models. In case P is finite, Mti is the only totally ignorant model.
2
So in MTEL with an infinite P , valid formulae are the only conservative formulae.
These formulae are of course upward persistent (in a trivial way), and they are equivalent
to a formula in TB, for instance K (>). When the signature is finite, there are some extra
formulae that are conservative, for example if P = fp; qg, then the formula F (K (p _ q) _
K (:p _ q) _ K (p _ :q) _ K (:p _ :q)) is also conservative (it is true in all models except
the totally ignorant one). Of course, this formula is upward persistent, and it is in TB.
Finite predicate and domain circumscription satisfy both expressibility of preference
and smoothness, so the conservative formulae coincide with the upward persistent formulae
which have the syntactic characterization of Proposition 32.
Full circumscription satisfies neither of the conditions.

Proposition 35 In predicate and domain circumscription there are upward persistent formulae that are not conservative.

Proof: First consider predicate circumscription. Let the language consist of three predicates besides equality, namely P , Succ and < (and P is circumscribed). Define the formulae
15

fiEngelfriet

ff and ' as follows:
ff = 8x9!y(Succ(x; y))^
' = 8xy(Px ^ Succ(y; x) ! Py)
8x9!y (Succ(y; x))^
8xy (Succ(x; y ) ! x < y )^
8xyz (x < y ^ y < z ! x < z )^
8x(:(x < x))^
8xy (x < y _ y < x _ x = y )^
9xPx
8xy (Px ^ Succ(x; y ) ! Py )
The intuitive meaning of ff is that there are Succ-chains of elements, extending indefinitely
in both directions. If P occurs somewhere on such a chain, it must be true in all successors
as well. A model of ff can be made smaller (more preferred) by making P false in a point
and all of its predecessors (leaving it true in all successors). We will now make this argument
formal. The first claim is that ff has no P - minimal models. Let M be a model of ff. Then
there must be an x 2 dom(M ) with x 2 P M . Define A = fxg [ fy 2 P M j (y; x) 2<M g.
Let N be the structure with the same domain as M , the same extension of Succ and <, and
P N = P M n A. It is straightforward to verify that N is a model of ff, and that N P M
and N 6= M .
On the other hand, ff ^ ' has minimal models. Let M be the structure with dom(M ) = Z
(the integers), (a; b) 2 SuccM , b = a + 1, (a; b) 2<M , a < b in the natural ordering
on the integers, and P M = Z. It can easily be checked that M j= ff ^ '. Now suppose
N P M , N 6= M and N j= ff ^ '. This means that P N  Z (strict inclusion), and P N 6= ;
(as N j= 9xPx). But then there must be x; y 2 Z with y = x + 1, and either x 2 P N and
y 2= P N , or x 2= P N and y 2 P N , contradicting either N j= 8xy(Px ^ Succ(x; y) ! Py)
(N j= ff) or N j= '. Therefore M is a minimal model of ff ^ '.
Now define fi = 9x(x 6= x), which is trivially upward persistent. Since ff has no minimal
PC
models, we have ff j=PC
P fi , but M 6j= fi , so ff ^ ' 6j=P fi . This shows that fi is not
conservative.
For domain circumscription, the example is quite similar. Again take fi = 9x(x 6= x).
Now define the formulae ff and ' as follows:
ff = 8x9!y(Succ(x; y))^
' = 8y9x(Succ(x; y))
8xy (Succ(x; y ) ! x < y )^
8xyz (x < y ^ y < z ! x < z )^
8x(:(x < x))^
8xy (x < y _ y < x _ x = y )^
8xyz (Succ(x; z ) ^ Succ(y; z ) ! x = y )
One can now check that ff has no d -minimal models, but ff ^ ' does, so the same fi is
upward persistent but not conservative in domain circumscription. The details are left to
the reader.
2
Until now, we have looked at formulae which, once concluded, are never lost, regardless
of what new information comes in, but also regardless of what the initial premise was.
16

fiMonotonicity and Persistence in Preferential Logics

However, we can also consider the situation with the premise fixed (analogously to the last
part of the previous section): given a premise, which conclusions may be kept regardless of
new information?

Proposition 36 For a preferential logic that satisfies expressibility of preference, if
ff j= fi , then
(8' : ff ^ ' j= fi ) , ff j= fi:
Proof: Suppose ff j= fi .
\(" If ff j= fi then for any ' we have ff ^ ' j= fi so ff ^ ' j= fi .

\)" Suppose ff 6j= fi , then there exists m 2 Mod such that m j= ff but m 6j= fi . Then
m j= ff ^ 'm (!), so ff ^ 'm 6j= fi .
2
Note that the condition ff j= fi was not used in the proof; if ff 6j= fi the equivalence is
still true, as both sides are false. The proposition shows that the monotonic consequences
of a premise are the only ones conservative with respect to this fixed premise.

Corollary 37 Let fi be a conservative formula for a preferential logic that satisfies expressibility of preference, then ff j= fi , ff j= fi .
Proof: If ff j= fi then in any preferential logic it follows that ff j= fi . On the other hand, if
ff j= fi , then for any ' we have ff ^ ' j= fi , since fi is conservative. With Proposition 36
2

it follows that ff j= fi .

In the last two sections, we have derived a number of results on formulae that respect
monotonicity and conservative formulae and the links with persistent formulae. In the next
section we will discuss the impact of these results in practice.

5. Practical Implications

The results in this paper may improve the eciency of theorem provers for preferential
logics, depending on a number of factors. In the first place, it is important how the theorem
prover is used.
Consider the situation where we have a stand-alone theorem prover which gets different
(unrelated) queries. Furthermore, suppose the theorem prover is asked to prove ff1 ^ : : : ^
ffn j= fi . Then there are at least two possibilities for using the results in the paper.
First of all, suppose the preferential logic satisfies expressibility of preference. Then if fi
is upward persistent, we do not have to prove ff1 ^ : : : ^ ffn j= fi , as it is equivalent to
prove ff1 ^ : : : ^ ffn j= fi (Corollary 37). In most preferential logics, preferential entailment
is harder to compute than entailment in the underlying logic.
In the second place, sometimes local reasoning is possible (which is not possible in general
for non-monotonic logics): the theorem prover may derive the conclusion from part of the
premise. So it may be the case that there is a 1  k < n such that ff1 ^ : : : ^ ffk j= fi which
is easier to verify than the original query. Then if ffk+1 ; : : : ; ffn are downward persistent,
Proposition 14 implies that ff1 ^: : :^ffn j= fi . If fi is upward persistent (and the preferential
logic is smooth), Proposition 29 sanctions ff1 ^ : : : ^ ffn j= fi . For these results to be usable
17

fiEngelfriet

in a theorem prover, we need heuristic knowledge to decide if there is a promising split of
the premise into two parts A and B . For such a split, we can then try to prove A j= fi
and downward persistence of B or upward persistence of fi . In case ff1 ^ : : : ^ ffk j= fi can
not be proved, we may have to directly prove ff1 ^ : : : ^ ffn j= fi after all.
These two methods will of course only improve eciency if the determination of persistence is easier than the original query (we will treat this question below).
The second kind of situation is when we have a theorem prover which is used by an
agent which has a lot of knowledge about the world, and from time to time performs
observations to increase its knowledge. Then, although sometimes the agent will need to
perform revisions, we are often in the situation that (many) conclusions from a premise
(ff) have been proved, and the premise is augmented by a new formula ('). If this new
formula is downward persistent, then the agent can retain all the old conclusions (and may
only need to derive some new conclusions). If it is not, it can at least retain all the upward
persistent conclusions (if the preferential logic is smooth). We may also try to determine
if ' is downward persistent given ff, or if fi is conservative given ff. Again, these methods
only improve eciency if it is easier to determine if ' respects monotonicity (possibly given
ff) than recomputing all old conclusions, or if it is easier to determine that fi is conservative
(possibly given ff) than checking ff ^ ' j= fi .
The possible eciency improvement in both cases heavily depends on the cost of determining persistence relative to the cost of determining preferential consequence. Unfortunately, it is very hard to say anything about this issue in general. It depends on the
preferential logic at hand, on the representation of the logic (syntactically, as a proof calculus, or semantically, as models with a preference relation), and on other implementation
issues. For instance, it can be important how much information is retained from previous
queries: whether proofs or minimal models are stored. Let us consider the examples again.
Preferential entailment in both Ground S5 and MTEL is QP3 -complete (Engelfriet,
1996a), whereas full circumscription is undecidable (restricted versions of circumscription
exist which are decidable, but still highly complex). Unfortunately, determining downward
or upward persistence is not easier for these logics. We have seen that the classes of persistent formulae have syntactic representations of the form: ' is upward/downward persistent
if and only if it is equivalent to a formula in C , where C is a (syntactic) class of formulae.
Now, of course, determining equivalence to a formula in C is as complex as determining
persistence, but there may be subclasses of a class of persistent formulae, with a lower
complexity. For instance, determining membership of C is much easier, namely polynomial.
The members of C are persistent. So what we propose is to check membership of C , instead
of equivalence to a member of C . In that case, we will miss some persistent formulae (and
have to prove the original query), but this disadvantage is outweighed by the complexity
advantage of checking membership. The checking of membership can be improved upon by
adding some (easy) checks for equivalence to a formula in C . For instance, in Ground S5,
if we consider, for a formula ', for each propositional sub-formula, the nearest K operator
in which scope it lies, then if all of these K operators are in the scope of an odd number of
negations, we can conclude that ' is downward persistent. The formula :K (q _ Kp), for
example, satisfies this condition, and although it is not a member of DIAM, it is equivalent
to :Kq ^ :Kp 2 DIAM. This check is obviously polynomial.
18

fiMonotonicity and Persistence in Preferential Logics

Given a preferential logic, the designer of a theorem prover could proceed as follows.
First, syntactic classes of formulae that are downward and upward persistent have to be
identified. For Ground S5, MTEL and predicate and domain circumscription, these can be
found in Definitions 15, 17, 19 and Proposition 32. For other preferential logics, if such
classes are trivial (they may, for instance, only include tautologies and contradictions),
then the usefulness of the results is limited. Otherwise, the theorem prover could work
as follows. Given a query of the form ff ^ ' j= fi , first it is checked if ' belongs to the
syntactic class of downward persistent formulae or if fi belongs to the syntactic class of
upward persistent formulae (this latter test should only be performed if the preferential
logic is smooth). If fi is conservative and the logic satisfies expressibility of preference, it
tries to prove ff ^ ' j= fi (this usually has a lower complexity than the original query; for
Ground S5 and MTEL, monotonic consequence is NP-complete, Engelfriet, 1996a). The
answer of this query is the answer to the original query (see Corollary 37). Otherwise, if
' belongs to the syntactic class of downward persistent formulae or if fi belongs to the
syntactic class of upward persistent formulae (but the logic does not satisfy expressibility
of preference), then the theorem prover tries to prove ff j= fi . If this succeeds, it outputs
yes. Otherwise, it will try to answer the original query directly.
As stated before, the practical savings in part depend on representation and implementation aspects. It also depends on the application domain and use of the theorem prover:
if formulae in these syntactic classes occur often, the eciency improvement is higher than
if they are infrequent.

6. Conclusions and Further Research
We have looked at restrictions of monotonicity in preferential logics. While monotonicity
does not hold in general, we can identify (in general non-trivial) classes of formulae for
which restricted versions of monotonicity holds. This may make (nonmonotonic) deduction
in preferential logics easier, since we may sometimes keep conclusions, or identify which
conclusions may be kept, when adding new information to a premise. The results in this
paper may lead to more ecient implementations of preferential logics. Experimenting with
theorem provers which use these results is necessary in order to determine the eciency
improvement in practice.
It would be nice to find a better characterization of formulae that can be added to a
given, fixed premise without destroying conclusions.
Syntactic characterizations of persistent formulae were given for a number of example
preferential logics, but we would like to have a result for broader classes of preferential
logics, such as the class of ground nonmonotonic modal logics (Donini et al., 1997).

Acknowledgements
I would like to thank Riccardo Rosati for stimulating discussions and worthwhile suggestions. Also, I would like to thank Pascal van Eck, Jan Treur, Rineke Verbrugge, Elles
de Vries and Wieke de Vries for reading and commenting on earlier versions of this doc19

fiEngelfriet

ument. Furthermore, I would like to thank Heinrich Herre for suggesting the example in
Proposition 24. The anonymous referees helped to improve the paper.

References

Chang, C. C., & Keisler, H. J. (1990). Model Theory (3rd edition). Amsterdam: NorthHolland.
Chen, J. (1997). The generalized logic of only knowing (GOL) that covers the notion of
epistemic specifications. Journal of Logic and Computation, 7 (2), 159{174.
Davis, M. (1980). The mathematics of non-monotonic reasoning. Artificial Intelligence, 13,
73{80.
Donini, F. M., Nardi, D., & Rosati, R. (1997). Ground nonmonotonic modal logics. Journal
of Logic and Computation, 7 (4), 523{548.
Engelfriet, J. (1996a). Minimal temporal epistemic logic. Notre Dame Journal of Formal
Logic, 37 (2), 233{259.
Engelfriet, J. (1996b). Only persistence makes nonmonotonicity monotonous (extended abstract). In Alferes, J. J., Pereira, L. M., & Orlowska, E. (Eds.), Logics in Artificial
Intelligence, Proceedings JELIA'96, Vol. 1126 of Lecture Notes in Artificial Intelligence, pp. 164{175. Springer-Verlag.
Engelfriet, J., & Treur, J. (1993). A temporal model theory for default logic. In Clarke,
M., Kruse, R., & Moral, S. (Eds.), Proceedings 2nd European Conference on Symbolic
and Quantitative Approaches to Reasoning and Uncertainty, ECSQARU'93, Vol. 747
of Lecture Notes in Computer Science, pp. 91{96. Springer-Verlag. Extended and
revised version to appear as \An interpretation of default logic in minimal temporal
epistemic logic" in the Journal of Logic, Language and Information.
Engelfriet, J., & Treur, J. (1994). Temporal theories of reasoning. In MacNish, C., Pearce,
D., & Pereira, L. M. (Eds.), Logics in Artificial Intelligence, Proceedings JELIA'94,
Vol. 838 of Lecture Notes in Artificial Intelligence, pp. 279{299. Springer-Verlag. Also
in Journal of Applied Non-Classical Logics, 5(2):239{261, 1995.
Engelfriet, J., & Treur, J. (1996). Specification of nonmonotonic reasoning. In Gabbay,
D. M., & Ohlbach, H. J. (Eds.), Practical Reasoning, Proceedings FAPR'96, Vol. 1085
of Lecture Notes in Artificial Intelligence, pp. 111{125. Springer-Verlag.
Etherington, D. W. (1988). Reasoning with Incomplete Information. Los Altos, CA: Morgan
Kaufmann Publishers.
Halpern, J. Y. (1997). A theory of knowledge and ignorance for many agents. Journal of
Logic and Computation, 7 (1), 79{108.
Halpern, J. Y., & Moses, Y. (1985). Towards a theory of knowledge and ignorance: preliminary report. In Apt, K. R. (Ed.), Logics and Models of Concurrent Systems, Vol.
F13 of NATO ASI Series, pp. 459{476. Springer-Verlag.
20

fiMonotonicity and Persistence in Preferential Logics

Kraus, S., Lehmann, D., & Magidor, M. (1990). Nonmonotonic reasoning, preferential
models and cumulative logics. Artificial Intelligence, 44, 167{207.
Levesque, H. J. (1990). All I know: A study in autoepistemic logic. Artificial Intelligence,
42, 263{309.
Lewis, D. K. (1973). Counterfactuals. Oxford: Blackwell.
Lifschitz, V. (1994). Circumscription. In Gabbay, D. M., Hogger, C. J., & Robinson, J. A.
(Eds.), Handbook of Logic in Artificial Intelligence and Logic Programming, Vol. 3,
pp. 297{352. Oxford University Press.
McCarthy, J. (1977). Epistemological problems of artificial intelligence. In Reddy, R. (Ed.),
Proceedings 5th International Joint Conference on Artificial Intelligence, pp. 1038{
1044. Los Altos, CA: Morgan Kaufmann.
McCarthy, J. (1980). Circumscription | a form of non-monotonic reasoning. Artificial
Intelligence, 13, 27{39.
Meyer, J.-J. C., & van der Hoek, W. (1995). Epistemic Logic for Computer Science and
Artificial Intelligence, Vol. 41 of Cambridge Tracts in Theoretical Computer Science.
Cambridge University Press.
Rabin, M. O. (1977). Decidable theories. In Barwise, J. (Ed.), Handbook of Mathematical
Logic, pp. 595{629. Amsterdam: North-Holland.
Reiter, R. (1980a). Equality and domain closure in first-order data bases. Journal of the
ACM, 27, 235{249.
Reiter, R. (1980b). A logic for default reasoning. Artificial Intelligence, 13, 81{132.
Schwarz, G., & Truszczynski, M. (1994). Minimal knowledge problem: A new approach.
Artificial Intelligence, 67, 113{141.
Shoham, Y. (1987). Nonmonotonic logics: Meaning and utility. In McDermott, J. (Ed.),
Proceedings 10th International Joint Conference on Artificial Intelligence, pp. 388{
392. Los Altos, CA: Morgan Kaufmann.
Shoham, Y. (1988). Reasoning about Change. Cambridge, MA: MIT Press.
van Benthem, J. F. A. K. (1989). Semantic parallels in natural language and computation.
In Ebbinghaus, H. D., & al. (Eds.), Logic Colloquium'87, Granada, pp. 331{375.
Amsterdam: North-Holland.

21

fi