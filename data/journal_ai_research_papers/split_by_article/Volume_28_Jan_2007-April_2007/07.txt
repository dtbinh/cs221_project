Journal of Artificial Intelligence Research 28 (2007) 431-451

Submitted 07/06; published 04/07

Discovering Classes of Strongly Equivalent Logic Programs
Fangzhen Lin

flin@cs.ust.hk

Department of Computer Science and Engineering
Hong Kong University of Science and Technology
Clear Water Bay, Kowloon, Hong Kong

Yin Chen

gzchenyin@gmail.com

Department of Computer Science
South China Normal University
Guangzhou, P.R. China

Abstract
In this paper we apply computer-aided theorem discovery technique to discover theorems about strongly equivalent logic programs under the answer set semantics. Our discovered theorems capture new classes of strongly equivalent logic programs that can lead
to new program simplification rules that preserve strong equivalence. Specifically, with
the help of computers, we discovered exact conditions that capture the strong equivalence
between a rule and the empty set, between two rules, between two rules and one of the two
rules, between two rules and another rule, and between three rules and two of the three
rules.

1. Introduction
In this paper we apply computer-aided theorem discovery technique to discover theorems
about strongly equivalent logic programs under the answer set semantics. Our discovered
theorems capture new classes of strongly equivalent logic programs that can lead to new
program simplification rules that preserve strong equivalence.
Theorem discovery is a highly creative human process. Generally speaking, we can
divide it into two steps: (i) conjecture formulation, and (ii) conjecture verification, and
computers can help in both of these two steps. For instance, machine learning tools can
be used in the first step, i.e. in coming up with reasonable conjectures, and automated
deduction tools can be used in the second step, i.e. in verifying the correctness of these
conjectures.
While theorem discovery may make use of learning, these two tasks are fundamentally different. Theorem discovery starts with a theory, and aims at finding interesting
consequences of the theory, while learning is mostly about induction, i.e. it starts with
examples/consequences, and aims at finding a theory that would explain the given examples/consequences.
Using computers to discover theorems is an old aspiration. There have been some
success stories. For instance, AM (Lenat, 1979) was reported to be able to come up with
some interesting concepts and theorems in number theory, and the remarkable systems
described by Petkovsek, Wilf, and Zeilberger (1996) can discover many identities, especially
hypergeometric identities involving sums of binomial coefficients that are important for the
analyses of algorithms. Yet another example where interesting theorems can be discovered
c
2007
AI Access Foundation. All rights reserved.

fiLin & Chen

almost fully automatically is a recent work by Lin (2004) on discovering state invariants in
planning domains. Lin showed that there are ways to classify many state constraints that
are useful in planning according to their syntactic properties, and enumerate them easily
for many domains. Furthermore, for many of these constraints whether they are invariants
can be checked automatically. As a result, the system described by Lin (2004) can discover
many common constraints in planning domains, and for the logistics domain, it could even
discover a set of complete state invariants.
Following this line of research, in this paper, we consider the problem of discovering
classes of strongly equivalent sets of logic program rules under answer set semantics. As
noted by Lifschitz, Pearce, and Valverde (2001), if two sets of rules are strongly equivalent,
then we can replace one by the other in any logic program without changing the semantics
of the program. Thus identifying strongly equivalent sets of logic program rules is a useful
exercise that may have applications in program simplification.
This paper is organized as follows. In the next section, we briefly review the basic
concepts of logic programming under answer set semantics. Then in section 3 we state in
more precise terms the type of theorems that we want to discover. In section 4 we prove
some general theorems that will help us prove these theorems, and in section 5, we describe
some of the theorems that we discovered. We then discuss an application to logic program
simplification in section 6, and finally we conclude this paper in section 7.

2. Answer Set Programming
Traditional logic programming systems like Prolog solve problems by query answering. The
user encodes knowledge about a domain by a set of rules, and solves a problem by issuing
queries to the set of rules. In contrast, Answer Set Programming (ASP) (Niemela, 1999;
Lifschitz, 1999; Marek & Truszczynski, 1999) is a constraint-based programming paradigm.
It is based on logic programming with answer set semantics (Gelfond & Lifschitz, 1988,
1991). To solve a problem, the user encodes the domain knowledge as a logic program in
such a way that the answer sets of the program will correspond to the solutions to the original
problem. Compared to other constraint-based programming paradigms, ASP allows natural
encodings of recursive relations, and has built-in facilities for default reasoning. Several ASP
solvers have been developed (Niemela, Simons, & Syrjanen, 2000; Leone, Pfeifer, Faber,
Eiter, Gottlob, Perri, & Scarcello, 2006; Lin & Zhao, 2004; Lierler & Maratea, 2004). To
date, ASP has been used in space shuttle planning (Nogueira, Balduccini, Gelfond, Watson,
& Barry, 2001), evolutional linguistics (Erdem, Lifschitz, Nakhleh, & Ringe, 2003), and
others. In the following, we briefly review some basic notions in ASP.
Let L be a propositional language, i.e. a set of atoms. In this paper we shall consider
logic programs with rules of the following form:
h1 ;    ; hk  p1 ,    , pm , not pm+1 ,    , not pn

(1)

where hi s and pi s are atoms in L. So a logic program here can have default negation (not ),
constraints (when k = 0), and disjunctions in the head of its rules. In the following, if r is a
rule of the above form, we write Hdr to denote the set {h1 , ..., hk }, Psr the set {p1 , ..., pm },
and Ngr the set {pm+1 , ..., pn }. Thus a rule r can also be written as Hdr  Psr , not Ngr .
The semantics of these programs are given by answer sets (Gelfond & Lifschitz, 1991), which
432

fiDiscovering Classes of Strongly Equivalent Logic Programs

are defined by a fixed-point operator through what has been known as Gelfond-Lifschitz
transformation. Let X be a subset of L, and P a logic program. The Gelfond-Lifschitz
transformation of P on X, written P X , is the set of rules obtained from P according to the
following two rules:
1. If a rule of the form (1) is in P , and pi  X for some m + 1  i  n, then delete this
rule.
2. Delete all literals of the form not pi in the bodies of the remaining rules.
For instance, if P is the set of following rules:
a; b 
c  not a
then P {a} is {a; b }, and P {b} is {(a; b ), (c )}.
Clearly, for any X and P , P X is a set of rules which do not have the not  operator.
Now a set X is an answer set of P if X is a minimal set of atoms that satisfies every rule
in P X , where X satisfies a rule of the form
h 1 ;    ; h k  p1 ,    , p m
if for some 1  i  k, hi  X whenever {p1 , ..., pm }  X. For instance, for the above
program, both {a} and {b, c} are answer sets, and they are the only answer sets of the
program.
Two logic programs P1 and P2 are said to be equivalent if they have the same answer sets,
and strongly equivalent (Lifschitz et al., 2001) (under the language L), written P1 'se P2 ,
if for any logic program P in L, P  P1 and P  P2 are equivalent (thus we write P1 6'se P2
when P1 and P2 are not strongly equivalent). For example, {a  b} and {a  c} are
equivalent, but not strongly equivalent. It can be shown that {a  not a} 'se { not a}.
As in the abstract, we also say that a rule r is strongly equivalent to another rule r0 , written
r 'se r0 , if {r} 'se {r0 }, and two rules r1 and r2 are strongly equivalent to a rule r, written
{r1 , r2 } 'se r, if {r1 , r2 } 'se {r}, and so on.
The notion of strong equivalence is important for ASP for several reasons. First of all, it
helps us understand the answer set semantics. For instance, Turner (2003) showed that the
disjunctive rule (a; b ) is not strongly equivalent to any set of normal rules. This implies
that there cannot be a modular translation from disjunctive logic programs to normal logic
programs. However,
{(a; b ), ( a, b)}
is strongly equivalent to
{(a  not b), (b  not a), ( a, b)}.
This means that under the constraint ( a, b), the disjunctive rule (a; b ) can be replaced
by two rules without disjunction. Secondly, as we mentioned in the introduction, if P1 and
P2 are strongly equivalent, then they are interchangeable regardless of where they occur.
Thus if we have a large repertoire of pairs of strongly equivalent logic programs, we could
433

fiLin & Chen

use them to transform a given program into one that is most suitable to the need in hand.
In particular, it could help us simplify a program for the purpose of computing its answer
sets. As we shall see, our discovered theorems will contribute significantly to this repertoire.
Lifschitz et al. (2001) showed that checking for strong equivalence between two logic
programs can be done in the logic of here-and-there, a three-valued non-classical logic
somewhere between classical logic and intuitionistic logic. Lin (2002) provided a mapping
from logic programs to propositional theories and showed that two logic programs are
strongly equivalent iff their corresponding theories in propositional logic are equivalent.
This result will be used here both for generating example pairs of strongly equivalent logic
programs, and for verifying a conjecture. We repeat it here.
Let P1 and P2 be two finite logic programs, and L the set of atoms in them.
Theorem 1 (Lin, 2002) P1 'se P2 iff in propositional logic, the following sentence is valid:
^
^
^
p  p0 )  [
(
(r) 
(r)],
(2)
pL

rP1

rP2

where for each p  L, p0 is a new atom, and for each rule r of the form (1), (r) is the
conjunction of the following two sentences:
p1      pm  p0m+1      p0n  h1      hk ,

(3)

p01

(4)

  

p0m



p0m+1

  

p0n



h01

  

h0k .

Notice that if m = n = 0, then the left sides of the implications in (3) and (4) are considered
to be true, and if k = 0, then the right sides of the implications in (3) and (4) are considered
to be f alse.
In general checking if two sets of rules are strongly equivalent is coNP-complete (c.f.
Turner, 2001; Pearce, Tompits, & Woltran, 2001; Lin, 2002).

3. The Problem
As we mentioned above, one possible use of the notion of strongly equivalent logic programs
is in program simplification. For instance, given a logic program, for each rule r in it,
we may ask whether it can be deleted without knowing what other rules are in P , i.e.
whether {r} is strongly equivalent to the empty set. Or we may ask whether a rule r in
P can be deleted if one knows that another rule r0 is already in P , i.e. whether {r, r0 }
is strongly equivalent to {r0 }. In general, we may ask the following k-m-n question: Is
{r1 , ..., rk , u1 , ..., um } 'se {r1 , ..., rk , v1 , ..., vn }? Thus our theorem discovery task is to come
up, for a given k-m-n problem, a computationally effective condition that holds if and only
if the answer to the k-m-n question is positive.
Now suppose we have such a condition C, and suppose that when
{r1 , ..., rk , u1 , ..., um } 'se {r1 , ..., rk , v1 , ..., vn },
it is better to replace {u1 , ..., um } by {v1 , ..., vn } in the presence of r1 , ..., rk for the purpose
of, say computing the answer sets of a program. One way to use this result to simplify a
given program P is to first choose k rules in P , and for any other m rules in it, try to find
434

fiDiscovering Classes of Strongly Equivalent Logic Programs

n rules so that the condition C holds, and then replace the m rules in P by the simpler n
rules.
However, even if checking whether C holds would take a negligible constant time, using
the above procedure to simplify a given logic program will be practical only when k, m, n
are all very small or when k is almost the same as the number of the rules in the given
program, and m and n are very small. Thus it seems to us that it is worthwhile to solve
the k-m-n problem only when k, m, n are small. In particular, in this paper, we shall
concentrate on the 0-1-0 problem (whether a rule can always be deleted), the 0-1-1 problem
(whether a rule can always be replaced by another one), the 1-1-0 problem (in the presence
of a rule, whether another rule can be deleted), the 2-1-0 problem (in the presence of two
rules, whether a rule can always be deleted), and the 0-2-1 problem (if a pair of rules can
be replaced by a single rule).
An example of theorems that we want to discover about these problems is as follows:
For any rule r, r 'se  iff (Hdr  Ngr )  Psr 6= .

(5)

4. Some General Theorems
In this section, we prove some general theorems that will help us verify whether an assertion
like (5) above is true.
Let L be a propositional language, i.e. a set of atoms. From L, construct a first-order
language FL with equality, two unary predicates H1 and H2 , three unary predicates Hdr ,
Psr , and Ngr for each logic program rule r in L (we assume that each rule in L has a unique
name), and three unary predicates Xi , Yi , and Zi for each positive number i.
Notice that we have used Hdr , Psr , and Ngr to denote sets of atoms previously, but
now we overload them as unary predicates. Naturally, the intended interpretations of these
unary predicates are their respective sets.
Definition 1 Given a set L of atoms, an intended model of FL is one whose domain is L,
and for each rule r in L, the unary predicates Psr , Hdr , and Ngr are interpreted by their
corresponding sets of atoms, Psr , Hdr , and Ngr , respectively.
Conditions on rules in L, such as Psr  Ngr 6= , will be expressed by special sentences
called properties in FL .
Definition 2 A sentence of FL is a property about n rules if it is constructed from equality
and predicates Xi , Yi , and Zi , 1  i  n. A property  about n rules is true (holds) on a
sequence P = [r1 , ..., rn ] of n rules if [P ] is true in an intended model of FL , where [P ]
is obtained from  by replacing each Xi by Hdri , Yi by Psri , and Zi by Ngri .
Notice that since [P ] does not mention predicates Xi , Yi , Zi , H1 , and H2 , if it is true in
one intended model, then it is true in all intended models.
As we have mentioned above, we are interested in capturing the strong equivalence
between two programs by a computationally effective condition. More specifically, for some
small k, m, and n, we are interested in finding a property  about k + m + n rules such
that for any sequence of k + m + n rules, P = [r1 , ..., rk , u1 , ..., um , v1 , ..., vn ],
{r1 , ..., rk , u1 , ..., um } 'se {r1 , ..., rk , v1 , ..., vn } iff  is true on P .
435

(6)

fiLin & Chen

We shall now prove some general theorems that can help us verify the above assertion
for a class of formulas .
First of all, Theorem 1 can be reformulated in FL as follows by reading H1 (p) as p
holds, and H2 (p) as p0 holds:
Theorem 2 P1 'se P2 in L iff the following sentence
^
^
x(H1 (x)  H2 (x))  [
(r) 
(r)]
rP1

(7)

rP2

is true in all intended models of FL , where (r) is the conjunction of the following two
sentences:
[x(Psr (x)  H1 (x))  x(Ngr (x)  H2 (x))]  x(Hdr (x)  H1 (x)),

(8)

[x(Psr (x)  H2 (x))  x(Ngr (x)  H2 (x))]  x(Hdr (x)  H2 (x)).

(9)

In first order logic, if a prenex formula of the form ~x~y B is satisfiable, then it is
satisfiable in a structure with n elements, where B is a formula that contains no quantifiers,
constants, or function symbols, and n is the length of ~x if it is non-empty, and 1 when ~x
is empty. We can prove a similar result for our first-order languages and their intended
models here.
Definition 3 A sentence of FL is an extended property about n rules if it is constructed
from equality and predicates Xi , Yi , and Zi , 1  i  n, and H1 and H2 . An extended
property  about n rules is true (holds) on a sequence P = [r1 , ..., rn ] of n rules in a model
M if [P ] is true in M , where [P ] is obtained from  by replacing each Xi by Hdri , Yi by
Psri , and Zi by Ngri .
Definition 4 In the following, if P = [r1 , ..., rn ] is a tuple of rules in L, and L0 is a subset
of L, then we define the restriction of P on L0 to be [r10 , ..., rn0 ], where ri0 is
Hdri  L0  Psri  L0 , not (Ngri  L0 ).
Lemma 1 Let  be an extended property in FL about n rules, and of the form ~x~y Q,
where ~x is a tuple of w variables, and Q a formula that does not have any quantifiers. If
 holds on a sequence P of n rules in an intended model M of FL , then there is a subset
L0 of L such that L0 has at most w atoms (or one atom when w = 0), and  holds on the
restriction of P on L0 in an intended model of FL0 .
Proof: Suppose M is an intended model of FL such that M |= [P ]. Thus there is a tuple
p~ of w (or one when w = 0) atoms in L such that M |= ~y Q[P ](~x/~
p). Now let L0 be the set
0
of atoms in p~, and M defined as follows:
 Each of the predicates H1 , H2 , Xi , Yi , and Zi , i  1, is interpreted as the restriction
of its interpretation in M on L0 .
 For each rule r in L0 , the predicates Hdr , Psr , and Ngr are interpreted the same as
they are in M . This is well-defined as r is also a rule in L,
436

fiDiscovering Classes of Strongly Equivalent Logic Programs

Then M 0 is an intended model of FL0 . Let P 0 be the restriction of P on L0 . Then P 0 is a
tuple of rules in L0 . Since Q has no quantifiers (and the language has no function symbols),
for any instantiation ~u of ~y in L0 , M |= Q[P ](~x/~
p)(~y /~u) iff M 0 |= Q[P 0 ](~x/~
p)(~y /~u). Since
0
0
M |= ~y Q[P ](~x/~
p), we have M |= ~y Q[P ](~x/~
p), Thus M 0 |= ~x~y Q[P 0 ]. 
Using Theorem 2 and this lemma, we can show the following theorem which will enable
us to automate the verification of the if part of (6) when the property  is in the prenex
format.
Theorem 3 Without loss of generality, suppose m  n. If  is a property about k+m+n
rules of the form ~x~y Q, where ~x is a tuple of w variables, and Q a formula that does not
have any quantifiers, then the following two assertions are equivalent:
(a) For any sequence of k + m + n rules, P = [r1 , ..., rk , u1 , ..., um , v1 , ..., vn ], if  is true
on P , then {r1 , ..., rk , u1 , ..., um } 'se {r1 , ..., rk , v1 , ..., vn }.
(b) (b.1) If n > 0, then for any sequence P = [r1 , ..., rk , u1 , ..., um , v1 , ..., vn ] of rules with
at most w + 2(k + m) atoms, if  is true on P , then
{r1 , ..., rk , u1 , ..., um } 'se {r1 , ..., rk , v1 , ..., vn }.
(b.2) If n = 0, then for any sequence P = [r1 , ..., rk , u1 , ..., um ] of rules with at most
K atoms, if  is true on P , then
{r1 , ..., rk , u1 , ..., um } 'se {r1 , ..., rk },
where K is w + 2k if w + 2k > 0, and K = 1 otherwise.
Proof: If (a) then (b) is obvious. We assume that (b) is true, and show that (a) holds as
well. Suppose first that n > 0. Suppose P = [r1 , ..., rk , u1 , ..., um , v1 , ..., vn ] is a sequence of
k + m + n rules in a language L such that  is true on P , and
{r1 , ..., rk , u1 , ..., um } 6'se {r1 , ..., rk , v1 , ..., vn }.
Thus there is an intended model of FL that satisfies [P ], and an intended model M of FL
that satisfies the following sentence:
^
^
(x)H1 (x)  H2 (x)  [
(r) 
(r)],
rP1

rP2

where P1 = {r1 , ..., rk , u1 , ..., um }, and P2 = {r1 , ..., rk , v1 , ..., vn }. As we noted after Definition 2, M will also satisfy [P ]. Thus M satisfies the following sentence
^
^
^
^
[P ]  (x)H1 (x)  H2 (x)  {[
(r)  
(r)]  [
(r)  
(r)]}, (10)
rP1

rP3

rP2

rP4

where P3 = {v1 , ..., vn }, and P4 = {u1 , ..., um }.
Now for any rule r, there is an extended property (x, y) of one rule that does not
mention any quantifiers such that (r) is equivalent to x, y.[r]. Thus for any tuple Q of t
rules,Vthere is an extended property  of t rules that does not mention any quantifiers such
that rQ (r) is equivalent to ~y .[Q], where ~y is a tuple of 2t variables.
Thus there is
437

fiLin & Chen

 a tuple z~1 of 2(k + m) variables, a tuple z~2 of variables, an extended property 1 of
k + m + n rules that does not have any quantifiers, and whose free variables are in z~1
and z~2 ; and
 a tuple z~3 of 2(k + n) variables, a tuple v~4 of variables, and an extended property 2
of k + m + n rules that does not have any quantifiers, and whose free variables are in
z~3 and z~4
such that v~1 , v~2 , v~3 , v~4 do not have common variables in them, and (10) is equivalent to the
following sentence:
{  x(H1 (x)  H2 (x))  (z~1 z~2 1  z~3 z~4 2 )}[P ].
Since we have assumed that m  n, thus there is an extended property 3 about k + m + n
rules that does not mention any quantifiers and function symbols, and whose free variables
are among z~1 , z~2 , and z~4 such that the above sentence is equivalent to the following sentence:
(  x(H1 (x)  H2 (x))  z~1 (z~2 , z~4 )3 )[P ].
Now given the form of  assumed in the theorem, there is a tuple z~5 of w + 2(k + m)
variables, a tuple z~6 of variables, and an extended property  of k + m + n rules that does
not mention any quantifiers, and whose free variables are among z~5 , and z~6 such that the
above sentence is equivalent to (z~5 )(z~6 )[P ].
By Lemma 1, there is a subset L0 of L that has at most w + 2(k + m) atoms such that
(z~5 )(z~6 ) holds on P 0 , where P 0 is the restriction of P on L0 . If
P 0 = [r10 , ..., rk0 , u01 , ..., u0m , v10 , ..., vn0 ],
then this will mean that  is true on P 0 , and {r10 , ..., rk0 , u01 , ..., u0m } 6'se {r10 , ..., rk0 , v10 , ..., vn0 }.
This shows that if (b.1), then (a).
The proof that if (b.2) then (a) is exactly the same except now that
^
^
[
(r) 
(r)]
rP1

rP2

is equivalent to
[

^

rP2

^

(r) 

(r)].

rP1


The only if part of (6) can often be proved with the help of the following theorem.
Theorem 4 Let L1 and L2 be two languages, and f a function from L1 to L2 . If P1 and P2
are two programs in L1 that are strongly equivalent, then f (P1 ) and f (P2 ) are two programs
in L2 that are also strongly equivalent. Here f (P ) is obtained from P by replacing each
atom p in it by f (p).
Proof: By Theorem 1 and the fact that in propositional logic, if  is a tautology, and f a
function from L1 to L2 , then f () is also a tautology, where f () is the formula obtained
from  by replacing each atom p in it by f (p). 
For an example of using the theorems in this section for proving assertions of the form
(6), see Section 5.1.
438

fiDiscovering Classes of Strongly Equivalent Logic Programs

5. Computer-Aided Theorem Discovery
Given a k-m-n problem, our strategy for discovering theorems about it is as follows:
1. Choose a small language L;
2. Generate all possible triples
({r1 , ..., rk }, {u1 , ..., um }, {v1 , ..., vn })

(11)

of sets of rules in L such that {r1 , ..., rk , u1 , ..., um } 'se {r1 , ..., rk , v1 , ..., vn } in L;
3. Formulate a conjecture on the k-m-n problem that holds in the language L, i.e. a
condition that is true for a triple of the form (11) iff it is generated in Step 2;
4. Verify the correctness of this conjecture in the general case.
This process may have to be iterated. For instance, a conjecture formulated in Step 3 may
fail to generalize in Step 4, so we either need to formulate a new conjecture or start all over
again in step 1 using a larger language.
Ideally, we would like this process to be automatic. However, it is difficult to automate
Steps 3 and 4 - the number of possible patterns that we need to examine in order to come
up with a good conjecture in Step 3 is huge, and we do not have a general theorem that
enables us to automate the verification part in Step 4. While Theorem 3 enables us to
automate the proof of the sufficient part of the assertion (6) for a class of formulas , we
do not have a similar result for the necessary part - as we shall see below, Theorem 4 helps
a lot here, but it does not provide an automated procedure. Nonetheless, computers play
a crucial role in all steps, and in the following we report some of the theorems discovered
using the above procedure.
5.1 The 0-1-0 Problem
This problem asks if a given rule is strongly equivalent to the empty set, thus can always
be deleted from any program. We have the following experimental result:
Lemma 2 If a rule r mentions at most three distinct atoms, then r 'se  iff
(Hdr  Ngr )  Psr 6= .
Using Theorem 4, we can show the following result:
Lemma 3 If there is a rule r of the form (1) such that r 'se  and (Hdr  Ngr )  Psr 6= 
is not true, then there is such a rule that mentions at most three atoms.
Proof: Suppose r 'se , Hdr  Psr = , and Psr  Ngr = . Suppose L is the set of atoms
in r, and a, b, c are three new atoms. Let

p  Hdr
 a
b
p  Psr
f (p) =

c
otherwise
439

fiLin & Chen

By Theorem 4, we also have f (r) 'se . By the construction of f , we also have
Hdf (r)  Psf (r) = , and Psf (r)  Ngf (r) = , and that f (r) mentions at most three distinct
atoms. 
Theorem 5 (The 0-1-0 problem) Lemma 2 holds in the general case, i.e. without any
restriction on the number of atoms in r.
Proof: We notice that the condition in Lemma 2, (Hdr  Ngr )  Psr 6= , is equivalent to
the following property
x.(X1 (x)  Z1 (x))  Y1 (x)
being true on [r]. Thus the if part follows from Theorem 3 and Lemma 2. The only if
part follows from Lemma 2 and Lemma 3. 
The if part of the theorem is already well-known, first proved by Osorio et. al. (2001).
The only if part has also been proved recently by Inoue and Sakama (2004). While we
did not discover anything new in this case, it is reassuring that the methodology works.
We notice here that there is no need to consider the 0-n-0 problem for n > 1, because
for any n, {r1 , ..., rn } is strongly equivalent to  iff for each 1  i  n, {ri } is strongly
equivalent to .
5.2 The 1-1-0 and the 0-1-1 Problems
The 1-1-0 problem asks if a rule can always be deleted in the presence of another rule, and
the 0-1-1 problem asks if a rule can always be replaced by another one. We first solve the
1-1-0 problem, and the solution to the 0-1-1 problem will come as a corollary.
We have the following experimental result for the 1-1-0 problem:
Lemma 4 For any two rules r1 and r2 that mentions at most three atoms, {r1 , r2 } and
{r1 } are strongly equivalent iff one of the following two conditions is true:
1. r2 'se .
2. Psr1  Psr2 , Ngr1  Ngr2 , and Hdr1  Hdr2  Ngr2 .
Lemma 5 If there are two rules r1 and r2 such that {r1 , r2 } 'se {r2 }, but none of the
two conditions in Lemma 4 hold, then there are two such rules that mention at most three
atoms.
Proof: Suppose there are two rules r1 , r2 such that {r1 , r2 } 'se {r2 }, and none of the two
conditions in Lemma 4 hold. Let L be the set of atoms in r1 , r2 .
Without loss of generality, suppose a1 is an atom that makes the condition (2) in
Lemma 4 false. If Psr2 \ {a1 } is not empty, let a2 be an atom in it. Let L0 = {a1 , a2 , a3 },
where a3 is a new atom, and f be a function from L to L0 as following:

a = a1
 a1
a2
a  Psr2 \ {a1 }
f (a) =

a3
otherwise
440

fiDiscovering Classes of Strongly Equivalent Logic Programs

clearly, f (r1 ) and f (r2 ) mention at most three distinct atoms, and by Theorem 4,
{f (r1 ), f (r2 )} 'se f (r1 ).
We show that none of the two conditions in Lemma 4 hold for f (r1 ) and f (r2 ) either.
We show first that f (r2 ) 6'se . By Theorem 5, we need to show that
S = Psf (r2 )  (Hdf (r2 )  Ngf (r2 ) )
is empty. If a1  S, then by the construction of f , a1  Psr2  (Hdr2  Ngr2 ), a contradiction
with the assumption that r2 is not strongly equivalent to . Similarly, if a2  S, then by
the construction of f , a2  Psr2  (Hdr2  Ngr2 ), a contradiction with the assumption that
r2 is not strongly equivalent to . But then a3 cannot be in S as a3 cannot be in Psf (r2 ) .
Thus S must be empty.
We now show that it is not the case that Psf (r1 )  Psf (r2 ) , Ngf (r1 )  Ngf (r2 ) , and
Hdf (r1 )  Hdf (r2 ) Ngf (r2 ) . By our assumption, a1 is an atom that makes either Psr1  Psr2 ,
Ngr1  Ngr2 , or Hdr1  Hdr2  Ngr2 false. There are three cases here. Suppose a1 makes
Psr1  Psr2 false, i.e. a1  Psr1 but a1 6 Psr2 . Then by our construction of f , we also have
that a1  Psf (r1 ) but a1 6 Psf (r2 ) . The other two cases are similar. 
Theorem 6 (The 1-1-0 problem) Lemma 4 holds in the general case, without any restriction on the number of atoms in r1 and r2 .
Proof: The condition in Lemma 4 is equivalent to the following property
[x.(X2 (x)  Z2 (x))  Y2 (x)] 
{[x.Y1 (x)  Y2 (x)]  [x.Z1 (x)  Z2 (x)]  [x.X1 (x)  (X2 (x)  Z2 (x))]}
being true on [r1 , r2 ]. Thus the if part follows from Theorem 3 and Lemma 4, by noticing
that the above property can be written as x~y .Q as required by Theorem 3. The only
if part follows from Lemma 4 and Lemma 5. 
Thus if a rule r2 cannot be deleted on its own but can be deleted in the presence of
another rule r1 , then it must be the case that r2 is redundant given r1 : if the body of r2 is
satisfied, then the body of r1 is satisfied as well; furthermore, r2 can entail no more than
what can be entailed by r1 (Hdr1  Hdr2  Ngr2 ).
Osorio et al. (2001) proved that {r1 , r2 } 'se r1 if either Psr1 Ngr1 =  and Hdr1  Ngr2
or Psr1  Psr2 , Ngr1  Ngr2 , and Hdr1  Hdr2 . More recently, Eiter et al. (2004) showed
that {r1 , r2 } 'se r1 if r1 s-implies r2 (Wang & Zhou, 2005), i.e. if there exists a set
A  Ngr2 such that Hdr1  Hdr2  A, Ngr1  Ngr2 \ A, and Psr1  Psr2 .
As one can see, these are all special cases of the if part of Theorem 6. Our result is
actually more general. For instance, these special cases do not apply to
{(c  b, not c), ( b, not c)}
and
{c  b, not c},
but one can easily show that these two sets are strongly equivalent using our theorem.
From our solution to the 1-1-0 problem, we can derive a solution to the 0-1-1 problem.
441

fiLin & Chen

Theorem 7 (The 0-1-1 problem) For any two rules r1 and r2 , r1 'se r2 iff one of the
following two conditions is true:
1. r1 'se r2 'se .
2. Psr1 = Psr2 , Ngr1 = Ngr2 , and Hdr1  Ngr1 = Hdr2  Ngr2 .
Proof: By Theorem 1, it is easy to see that r1 'se r2 iff {r1 , r2 } 'se r1 and {r1 , r2 } 'se r2 .

Thus two rules r1 and r2 can always be interchanged if either both of them can be
deleted (strongly equivalent to the empty set) or they have the same body, and the same
consequences when the body is true. For instance, we have {a  B, not a} 'se { B, not a}
no matter what B is, because the two rules have the same body, and when the body is true,
the same consequence - a contradiction. As another example, we have
{a; b  not a} 'se {b  not a},
because the two rules have the same body, and, when the body is true, the same consequence,
b.
5.3 The 2-1-0, 0-2-1, and 0-2-2 Problems
The 2-1-0 problem asks if a rule can be deleted in the presence of another two rules, the
0-2-1 problem asks if two rules can be replaced by a single rule, and the 0-2-2 problem asks
if two rules can be replaced by another two rules. Similar to the previous subsection, the
solution to the 0-2-1 and 0-2-2 problems will follow from a solution to the 2-1-0 problem.
The experiment on the 2-1-0 problem was more difficult because as it turned out, we
have to consider a language with six atoms in this case. In principle, given a language L,
every subset of L can be the Hd, Ps, or Ng of a rule. Thus when the size of L is six, there
are in principle (26 )3  1 = 262, 143 possible rules, and 262, 1433 triples of them. However,
we can cut down the numbers significantly with the results that we already have proved.
First, we only have to consider rules that do not have common elements in any of the
two sets in {Hd, Ps, Ng}: if either Hd and Ps or Ps and Ng have a common element, then by
Theorem 5, this rule can be deleted; if Hd and Ng have common elements, then according
to Theorem 7, we obtain a strongly equivalent rule by deleting the common elements in Hd.
In the following, we call such rules canonical, that is, a rule r is canonical if
Hdr  Psr = Hdr  Ngr = Psr  Ngr = .
Secondly, we do not have to consider isomorphic rules: if there is a one-to-one onto
function from L to L that maps {r1 , r2 , r3 } to {r10 , r20 , r30 }, then these two sets of rules are
essentially the same except for the names of atoms in them.
Thus by considering only canonical rules and using a certain normal form for triples of
rules that avoids isomorphic rules, we ended up with roughly 120 million triples of rules to
consider for verifying the following result, which took about 10 hours on a Solaris server
consisting of 8 Sun Ultra-SPARC III 900Mhz CPUs with 8GB RAM.
For more details on the experiment on 2-1-0 problem, please refer to (Chen, Lin, & Li,
2005).
442

fiDiscovering Classes of Strongly Equivalent Logic Programs

Lemma 6 For any three canonical rules r1 , r2 and r3 that mention at most six atoms,
{r1 , r2 , r3 } 'se {r1 , r2 } iff one of the following three conditions is true:
1. {r1 , r3 } 'se r1 .
2. {r2 , r3 } 'se r2 .
3. There is an atom p such that:
3.1 p  (Psr1  Psr2 )  (Hdr1  Hdr2  Ngr1  Ngr2 )
3.2 Hdri \ {p}  Hdr3  Ngr3 and Psri \ {p}  Psr3 and Ngri \ {p}  Ngr3 , where
i = 1, 2
3.3 If p  Psr1  Ngr2 , then Hdr1  Hdr3 = 
3.4 If p  Psr2  Ngr1 , then Hdr2  Hdr3 = 
The following lemma is the reason why we need to consider a language with six atoms
for this problem.
Lemma 7 If there are three canonical rules r1 ,r2 and r3 such that {r1 , r2 , r3 } 'se {r1 , r2 },
but none of the three conditions in Lemma 6 hold, then there are three such rules that
mention at most six atoms.
Proof: The proof of this lemma is tedious as we have to consider several cases. Consider
the following statements about any three canonical rules r1 , r2 , r3 :
(I) {r1 , r2 , r3 } 'se {r1 , r2 }.
(II) {r1 , r3 } 6'se {r1 }, i.e. Psr1 6 Psr3 or Ngr1 6 Ngr3 or Hdr1  Ngr1 6 Hdr3  Ngr3
(III) {r2 , r3 } 6'se {r2 }, i.e. Psr2 6 Psr3 or Ngr2 6 Ngr3 or Hdr2  Ngr2 6 Hdr3  Ngr3
(IV) (Psr1  Psr2 )  (Hdr1  Hdr2  Ngr1  Ngr2 ) = 
(V) There is an atom p in the set (Psr1  Psr2 )  (Hdr1  Hdr2  Ngr1  Ngr2 ), and another
different atom q such that one of the following three conditions is true:
1. q  Hdr1  Ngr1 and q 6 Hdr3  Ngr3 .
2. q  Psr1 and q 6 Psr3 .
3. q  Ngr1 and q 6 Ngr3 .
Notice that this is the negation of condition (3.2) in Lemma 6.
(VI) Hdr1  Hdr3 6 Ngr3 , and there is an atom p  Psr1  Ngr2 such that for i = 1, 2,
Hdri \ {p}  Hdr3  Ngr3 , Psri \ {p}  Psr3 , and Ngri \ {p}  Ngr3 .
Since r1 and r2 are symmetric in the conditions in Lemma 6, to prove this lemma, we need
only to prove the following three assertions:
(a) If there are three canonical rules r1 , r2 , r3 which satisfy (I)-(IV), then there are three
canonical rules r10 , r20 , r30 which mention at most six atoms, and satisfy (I)-(IV) as well.
443

fiLin & Chen

(b) If there are three canonical rules r1 , r2 , r3 which satisfy (I)-(III)(V), then there are
three canonical rules r10 , r20 , r30 which mention at most six atoms, and satisfy (I)-(III)(V)
as well.
(c) If there are three canonical rules r1 , r2 , r3 which satisfy (I)-(III)(VI), then there are
three canonical rules r10 , r20 , r30 which mention at most six atoms, and satisfy (I)(III)(VI) as well.
We now prove the above three assertions one by one.
(a) Let a1 , a2 be two atoms that make (II) and (III) true. If (Psr3 (Psr1 Psr2 ))\{a1 , a2 }
is not empty, let a3 be an atom in it. If Psr3 \(Psr1 Psr2 {a1 , a2 }) is not empty, let a4
be an atom in it. If (Psr1 Psr2 )\(Psr3 {a1 , a2 }) is not empty, let a5 be an atom in it.
Finally let a6 be a new atom different from a1 to a5 , and L0 = {a1 , a2 , a3 , a4 , a5 , a6 }.
Let f be a function from L to L0 defined as following:

a1
a = a1




a
a = a2

2


a3
a  (Psr3  (Psr1  Psr2 )) \ {a1 , a2 }
f (a) =
a
a  Psr3 \ (Psr1  Psr2  {a1 , a2 })


 4


a
a  (Psr1  Psr2 ) \ (Psr3  {a1 , a2 })

 5
a6
otherwise
For each 1  i  3, let ri0 be as follows:
Psri0 = Psf (ri ) , Ngri0 = Ngf (ri ) , Hdri0 = Hdf (ri ) \ Ngf (ri ) .

(12)

We have that
 For each 1  i  3, ri0 is a canonical rule, and ri0 'se f (ri ). For this, we only
need to show f (ri ) 6'se  for each 1  i  3. To see this, notice that from
the definition of f , atoms other than a1 and a2 in Psr3 are mapped to {a3 , a4 },
and atoms other than a1 and a2 in Hdr3  Ngr3 are mapped to {a5 , a6 }. Thus
Psf (r3 )  (Hdf (r3 )  Ngf (r3 ) ) = . By Theorem 5, f (r3 ) 6'se . Now f (r1 ) 6'se 
and f (r2 ) 6'se , because (II) and (III) hold for f (r1 ), f (r2 ), f (r3 ) by definition
of f .
 (I) holds for r10 , r20 , r30 . This is because by Theorem 4,
{f (r1 ), f (r2 ), f (r3 )} 6'se {f (r1 ), f (r2 )},
and for each 1  i  3, ri0 'se f (ri ).
 (II) and (III) hold for r10 , r20 , r30 . As we mentioned, from the definition of f , (II)
and (III) hold for f (r1 ), f (r2 ), f (r3 ).
 (IV) holds for r10 , r20 , r30 . Again, we need only to show that (IV) holds for
f (r1 ), f (r2 ), f (r3 ). To see this, notice that atoms other than a1 and a2 in
Psr1  Psr2 are mapped to {a3 , a5 }, and atoms other than a1 and a2 in
Hdr1  Hdr2  Ngr1  Ngr2 are mapped to {a4 , a6 }.
444

fiDiscovering Classes of Strongly Equivalent Logic Programs

(b) Again let a1 , a2 be two atoms that make (II) and (III) true. Let p, q be the two witness
atoms in (V). If P os(r3 ) \ {a1 , a2 , p, q} is not empty, let a3 be an atom in it. Let a4
be a new atom, and L0 = {a1 , a2 , a3 , a4 , p, q}. Define f as follows:

a = a1

 a1


a2
a = a2



p
a=p
f (a) =
q
a=q





a
a  Psr3 \ {a1 , a2 , p, q}
3


a4
otherwise
Define ri0 by (12) as well for each 1  i  3.
 For each 1  i  3, ri0 is a canonical rule, and ri0 'se f (ri ). This can be seen in
the same way as for (a) above.
 By Theorem 4, {f (r1 ), f (r2 ), f (r3 )} 'se {f (r1 ), f (r2 )}, and thus
{r10 , r20 , r30 } 'se {r10 , r20 }.
So (I) holds for r10 , r20 , r30 .
 From definition of f , (II) and (III) hold for f (r1 ), f (r2 ), f (r3 ), and thus they hold
for r10 , r20 , r30 as well.
 Again from the definition of f , (V) holds for f (r1 ), f (r2 ), f (r3 ): there is an atom
p in the set (Psf (r1 )  Psf (r2 ) )  (Hdf (r1 )  Hdf (r2 )  Ngf (r1 )  Ngf (r2 ) ), and another
different atom q such that one of the following three conditions is true:
1. q  Hdf (r1 )  Ngf (r1 ) and q 6 Hdf (r3 )  Ngf (r3 ) .
2. q  Psf (r1 ) and q 6 Psf (r3 ) .
3. q  Ngf (r1 ) and q 6 Ngf (r3 ) .
(V) holds for r10 , r20 , r30 as well because for each 1  i  3,
Psri0 = Psf (ri ) , Ngri0 = Ngf (ri ) , Hdri0  Ngri0 = Hdf (ri )  Ngf (ri ) .
(c) Let a1 , a2 be two atoms that make (II) and (III) true. Let p be the witness atom in
(VI), and let q  Hdr1  Hdr3 but q 6 Ngr3 . If P os(r3 ) \ {a1 , a2 , p, q} is not empty, let
a3 be an atom in it. Let a4 is a new atom, and Let L0 = {a1 , a2 , a3 , a4 , p, q}, Define f
as follows:

a1
a = a1




a
a = a2

2


p
a=p
f (a) =
q
a=q





a
a  Psr3 \ {a1 , a2 , p, q}

 3
a4
otherwise
Again define ri0 by (12) as well for each 1  i  3.
 For each 1  i  3, ri0 is a canonical rule, and ri0 'se f (ri ). This can be seen in
the same way as for (a) above.
445

fiLin & Chen

 Again by Theorem 4, {f (r1 ), f (r2 ), f (r3 )} 'se {f (r1 ), f (r2 )}, and thus
{r10 , r20 , r30 } 'se {r10 , r20 }.
So (I) holds for r10 , r20 , r30 .
 Again from definition of f , (II) and (III) hold for f (r1 ), f (r2 ), f (r3 ), thus they
hold for r10 , r20 , r30 as well.
 By the definition of f , (VI) holds for f (r1 ), f (r2 ), f (r3 ): Hdf (r1 )  Hdf (r3 ) 6
Ngf (r3 ) , and there is an atom p  Psf (r1 )  Ngf (r2 ) such that for i = 1, 2, Hdf (ri ) \
{p}  Hdf (r3 )  Ngf (r3 ) , Psf (ri ) \ {p}  Psf (r3 ) , and Ngf (ri ) \ {p}  Ngf (r3 ) . (VI)
holds for r10 , r20 , r30 as well because
Psri0 = Psf (ri ) , Ngri0 = Ngf (ri ) , Hdri0  Hdf (ri ) .

Theorem 8 (The 2-1-0 problem) Lemma 6 holds in the general case, without any restriction on the number of atoms in r1 , r2 , r3 .
Proof: The assertion that r1 , r2 , and r3 are canonical rules and satisfy one of the three
conditions in Lemma 6 is equivalent to the following property
[x.(((X1 (x)  Y1 (x)))  ((X1 (x)  Z1 (x)))  ((Y1 (x)  Z1 (x))))] 
[x.(((X2 (x)  Y2 (x)))  ((X2 (x)  Z2 (x)))  ((Y2 (x)  Z2 (x))))] 
[x.(((X3 (x)  Y3 (x)))  ((X3 (x)  Z3 (x)))  ((Y3 (x)  Z3 (x))))] 
{[(x.Y1 (x)  Y3 (x))  (x.Z1 (x)  Z3 (x))  (x.X1 (x)  (X3 (x)  Z3 (x)))] 
[(x.Y2 (x)  Y3 (x))  (x.Z2 (x)  Z3 (x))  (x.X2 (x)  (X3 (x)  Z3 (x)))] 
[x.CON 1(x)  CON 2(x)  CON 3(x)  CON 4(x)]}
being true on [r1 , r2 , r3 ], where CON 1(x) stands for
(Y1 (x)  Y2 (x))  (X1 (x)  X2 (x)  Z1 (x)  Z2 (x))
CON 2(x) for
y.(x 6= y)  [(X1 (y)  (X3 (y)  Z3 (y)))  (Y1 (y)  Y3 (y))  (Z1 (y)  Z3 (y)) 
(X2 (y)  (X3 (y)  Z3 (y)))  (Y2 (y)  Y3 (y))  (Z2 (y)  Z3 (y))]
CON 3(x) for
Y1 (x)  Z2 (x)  y.((X1 (y)  X3 (y))),
and CON 4(x) for
Y2 (x)  Z1 (x)  y.((X2 (y)  X3 (y))).
Thus the if part follows from Theorem 3 and Lemma 6, by noticing that the above
property can be written as x~y .Q as required by Theorem 3. The only if part follows
from Lemma 6 and Lemma 7. 
446

fiDiscovering Classes of Strongly Equivalent Logic Programs

The conditions in Lemma 6 (Theorem 8) are rather complex, and the reason why it
is difficult to automate Step 3 of the procedure at the beginning of the section. These
conditions capture all possible cases when r3 is subsumed by r1 and r2 , and are difficult
to describe concisely by words. We give some examples.
Consider the following three rules:
r1 : (a2  a1 )
r2 : (a3  not a1 )
r3 : (a3  not a2 ).
We have that {r1 , r2 , r3 } 'se {r1 , r2 } because the condition (4) in Lemma 6 holds.
However, if we change r3 into r30 : a2  not a3 , then P1 = {r1 , r2 , r30 } and P2 = {r1 , r2 }
are not strongly equivalent: one could check that condition (4.3) in Lemma 6 does not hold,
and indeed, while P2  {a1  a2 } has a unique answer set {a3 }, P1  {a1  a2 } has two
answer sets {a3 } and {a1 , a2 }.
It is also easy to show by Theorem 8 that a3  not a2 is subsumed by
{(a1 ; a2 ; a3 ), (a2 ; a3  a1 )},
and a2 ; a3  is subsumed by
{(a2  a1 ), (a3  not a1 )}.
With the results that we have, the following theorem will yield a solution to the 0-2-1
problem.
Theorem 9 (the 0-2-1 problem) For any three rules r1 , r2 and r3 , {r1 , r2 } and {r3 } are
strongly equivalent iff the following three conditions are true:
1. {r1 , r2 , r3 } 'se {r1 , r2 }.
2. {r1 , r3 } 'se {r3 }.
3. {r2 , r3 } 'se {r3 }.
For example, We have
{(a2  a1 , not a3 ), (a1 ; a2  not a3 )} 'se {a2  not a3 }.
While we have
{( a2 , a3 ), ( a3 , not a2 )} 'se { a3 },
we have
{(a1  a2 , a3 ), (a1  a3 , not a2 )} 6'se {a1  a3 }.
Similarly, we have the following theorem
Theorem 10 (the 0-2-2 problem) For any four rules r1 , r2 , r3 , r4 , {r1 , r2 } and {r3 , r4 }
are strongly equivalent iff the following four conditions are true:
447

fiLin & Chen

1. {r1 , r2 , r3 } 'se {r1 , r2 }.
2. {r1 , r2 , r4 } 'se {r1 , r2 }.
3. {r3 , r4 , r1 } 'se {r3 , r4 }.
4. {r3 , r4 , r2 } 'se {r3 , r4 }.

6. Program Simplification
We have mentioned that one possible use of the notion of strongly equivalent logic programs
is in simplifying logic programs: if P 'se Q, and that Q is simpler than P , we can then
replace P in any program that contains it by Q.
Most answer set programming systems perform some program simplifications. However,
only Smodels (Niemela et al., 2000) has a stand-alone front-end called lparse that can be
used to ground and simplify a given logic program. It seems that lparse simplifies a grounded
logic program by computing first its well-founded model. It does not, however, perform any
program simplification using the notion of strong equivalence. For instance, lparse-1.0.13,
the current version of lparse, did nothing to the following set of rules:
{(a  not b), (b  not a), (a  a)}. Nor does it replace the first rule in the following
program {(a  not a), (a  not b), (b  not a)} by the constraint  not a.
It is unlikely that anyone would be intentionally writing rules like a  a or b  a, not a.
But these type of rules can arise as a result of grounding some rules with variables. For
instance, the following is a typical recursive rule used in logic programming encoding of the
Hamiltonian Circuit problem (Niemela, 1999; Marek & Truszczynski, 1999):
reached(X)  arc(Y, X), hc(Y, X), reached(Y ).
When instantiated on a graph with cyclic arcs like arc(a, a), this rule generates cyclic rules
of the form reached(X)  hc(X, X), reached(X). Unless deleted explicitly, these rules will
slow down many systems, especially those based on SAT. For instance, none of the graphs
tested using ASSAT have self-cycles consisting of an arc from a node to itself (Lin & Zhao,
2004). If these cycles are included, ASSAT would run significantly longer.
It is thus useful to consider using the results that we have here for program simplification.
Indeed, transformation rules such as deleting those that contain common elements in their
heads and positive bodies have been proposed (Brass & Dix, 1999), and studied from the
perspective of strong equivalence (Osorio et al., 2001; Eiter et al., 2004). Our results
add new such transformation rules. For instance, by Theorem 7, we can delete those
elements in the head of a rule that also appear in the negation-as-failure part of the rule.
Theorems 6, 8, and 9 can also be used to define some new transformation rules.

7. Concluding Remarks and Future Work
Donald Knuth, in his Forward to (Petkovsek et al., 1996), said
Science is what we understand well enough to explain to a computer. Art is
everything else we do. ...Science advances whenever an Art becomes a Science.
448

fiDiscovering Classes of Strongly Equivalent Logic Programs

And the state of the Art advances too, because people always leap into new
territory once they have understood more about the old.
We hope that with this work, we are one step closer to making discovering classes of strongly
equivalent logic programs a Science.
We have mentioned that the methodology used in this paper is similar to that in (Lin,
2004). In both cases, plausible conjectures are generated by testing them in domains of
small sizes, and general theorems are proved to aid the verification of these conjectures
in the general case. However, while plausible conjectures are generated automatically in
(Lin, 2004), they are done manually here. While the verifications of most conjectures in
(Lin, 2004) are done automatically as well, they are done only semi-automatically here.
Overcoming these two weaknesses is the focus of our future work. Specifically, we would
like to make Step 3 of the procedure in Section 5 automatic, and prove a theorem similar
to Theorem 3 to automate the proofs of the only if parts of theorems like Theorems 5 8, in the same way that Theorem 3 makes the proofs of the if parts of these theorems
automatic. This way, we would be able to discover more interesting theorems in this area,
and more easily!

Acknowledgments
An extended abstract of this paper appeared in Proceedings of IJCAI2005. We thank Yan
Zhang for his comments on an earlier version of the paper. We also thank the anonymous
reviewers for their useful comments, especially one of them for pointing out an error in
Lemma 4 in an earlier version of the paper. This work was supported in part by the
Research Grants Council of Hong Kong under Competitive Earmarked Research Grant
HKUST6170/04E. Part of the second authors work was done when he was a student at Sun
Yat-Sen University, Guangzhou, China, and a visiting scholar in Department of Computer
Science and Engineering, Hong Kong University of Science and Technology, Hong Kong.

References
Brass, S., & Dix, J. (1999). Semantics of (disjunctive) logic programs based on partial
evaluation. Journal of Logic Programming, 40 (1), 146.
Chen, Y., Lin, F., & Li, L. (2005). SELP - a system for studying strong equivalence
between logic programs. In Proceedings of the 8th International Conference on Logic
Programming and Nonmonotonic Reasoning(LPNMR 2005), pp. 442446.
Eiter, T., Fink, M., Tompits, H., & Woltran, S. (2004). Simplifying logic programs under
uniform and strong equivalence. In Proceedings of the 7th International Conference
on Logic Programming and Nonmonotonic Reasoning(LPNMR 2004), pp. 8799.
Erdem, E., Lifschitz, V., Nakhleh, L., & Ringe, D. (2003). Reconstructing the evolutionary
history of indo-european languages using answer set programming. In Proceedings of
the 5th International Symposium on Practical Aspects of Declarative Languages(PADL
2003), pp. 160176.
449

fiLin & Chen

Gelfond, M., & Lifschitz, V. (1988). The stable model semantics for logic programming. In
Proceedings of the 5th International Conference and Symposium on Logic Programming(ICLP/SLP), pp. 10701080.
Gelfond, M., & Lifschitz, V. (1991). Classical negation in logic programs and disjunctive
databases. New Generation Computing, 9 (3/4), 365386.
Inoue, K., & Sakama, C. (2004). Equivalence of logic programs under updates. In Proceedings of the 9th European Conference on Logics in Artificial Intelligence(JELIA), pp.
174186.
Lenat, D. B. (1979). On automated scientific theory formation: A case study using the AM
program. In Machine Intelligence 9, pp. 251283. Jean Hayes, Donald Michie, and L.
I. Mikulich, eds. Ellis Horwood.
Leone, N., Pfeifer, G., Faber, W., Eiter, T., Gottlob, G., Perri, S., & Scarcello, F. (2006).
The DLV system for knowledge representation and reasoning. ACM Transactions on
Computational Logic, 7 (3).
Lierler, Y., & Maratea, M. (2004). Cmodels-2: SAT-based answer set solver enhanced
to non-tight programs. In Proceedings of the 7th International Conference on Logic
Programming and Nonmonotonic Reasoning(LPNMR 2004), pp. 346350.
Lifschitz, V. (1999). Action languages, answer sets and planning. In The Logic Programming
Paradigm: A 25-Year Perspective. K.R. Apt, V.W. Marek, M. Truszczynski, D.S.
Warren, eds, Springer-Verlag.
Lifschitz, V., Pearce, D., & Valverde, A. (2001). Strongly equivalent logic programs. ACM
Transactions on Computational Logic, 2 (4), 526541.
Lin, F. (2002). Reducing strong equivalence of logic programs to entailment in classical
propositional logic. In Proceedings of the 8th International Conference on Principles
of Knowledge Representation and Reasoning(KR2002), pp. 170176.
Lin, F. (2004). Discovering state invariants. In Proceedings of the 9th International Conference on Principles of Knowledge Representation and Reasoning(KR2004), pp. 536
544.
Lin, F., & Zhao, Y. (2004). ASSAT: computing answer sets of a logic program by sat solvers.
Artificial Intelligence, 157 (1-2), 115137.
Marek, V. W., & Truszczynski, M. (1999). Stable logic programming - an alternative logic
programming paradigm. In The Logic Programming Paradigm: A 25-Year Perspective.
K.R. Apt, V.W. Marek, M. Truszczynski, D.S. Warren, eds, Springer-Verlag.
Niemela, I., Simons, P., & Syrjanen, T. (2000).
Smodels: a system for answer
set programming. In Proceedings of the 8th International Workshop on NonMonotonic Reasoning. Breckenridge, Colorado, USA. (CoRR: arXiv:cs.AI/0003033)
http://www.tcs.hut.fi/Software/smodels/.
Niemela, I. (1999). Logic programs with stable model semantics as a constraint programming
paradigm. Annals of Mathematics and Artificial Intelligence, 25 (3-4), 241273.
450

fiDiscovering Classes of Strongly Equivalent Logic Programs

Nogueira, M., Balduccini, M., Gelfond, M., Watson, R., & Barry, M. (2001). An A-Prolog
decision support system for the space shuttle. In Proceedings of the 3rd International
Symposium on Practical Aspects of Declarative Languages(PADL 2001), pp. 169183.
Osorio, M., Navarro, J. A., & Arrazola, J. (2001). Equivalence in answer set programming. In
Selected Papers of the 11th International Workshop on Logic Based Program Synthesis
and Transformation(LOPSTR 2001), pp. 5775.
Pearce, D., Tompits, H., & Woltran, S. (2001). Encodings for equilibrium logic and logic
programs with nested expressions. In Proceedings of 10th Portuguese Conference on
Artificial Intelligence(EPIA 2001), pp. 306320.
Petkovsek, M., Wilf, H. S., & Zeilberger, D. (1996). A = B. Wellesley, Mass. : A K Peters.
Turner, H. (2001). Strong equivalence for logic programs and default theories (made easy).
In Proceedings of the 6th International Conference on Logic Programming and Nonmonotonic Reasoning(LPNMR 2001), pp. 8192.
Turner, H. (2003). Strong equivalence made easy: nested expressions and weight constraints.
Theory and Practice of Logic Programming, 3 (4-5), 609622.
Wang, K., & Zhou, L. (2005). Comparisons and computation of well-founded semantics
for disjunctive logic programs. ACM Transactions on Computational Logic, 6 (2),
295327.

451

fi