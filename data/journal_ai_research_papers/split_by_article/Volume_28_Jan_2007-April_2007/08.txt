Journal of Artificial Intelligence Research 28 (2007) 299-348

Submitted 07/06; published 03/07

Supporting Temporal Reasoning by Mapping
Calendar Expressions to Minimal Periodic Sets
Claudio Bettini
Sergio Mascetti

bettini@dico.unimi.it
mascetti@dico.unimi.it

Dipartimento di Informatica e Comunicazione, Universita di Milano
Via Comelico, 39, 20135, Milan, Italy

X. Sean Wang

Sean.Wang@uvm.edu

Department of Computer Science, University of Vermont
33 Colchester Avenue, Burlington, VT, 05405 USA

Abstract
In the recent years several research efforts have focused on the concept of time granularity and its applications. A first stream of research investigated the mathematical models
behind the notion of granularity and the algorithms to manage temporal data based on
those models. A second stream of research investigated symbolic formalisms providing a set
of algebraic operators to define granularities in a compact and compositional way. However, only very limited manipulation algorithms have been proposed to operate directly
on the algebraic representation making it unsuitable to use the symbolic formalisms in
applications that need manipulation of granularities.
This paper aims at filling the gap between the results from these two streams of research,
by providing an efficient conversion from the algebraic representation to the equivalent
low-level representation based on the mathematical models. In addition, the conversion
returns a minimal representation in terms of period length. Our results have a major
practical impact: users can more easily define arbitrary granularities in terms of algebraic
operators, and then access granularity reasoning and other services operating efficiently
on the equivalent, minimal low-level representation. As an example, we illustrate the
application to temporal constraint reasoning with multiple granularities.
From a technical point of view, we propose an hybrid algorithm that interleaves the
conversion of calendar subexpressions into periodical sets with the minimization of the period length. The algorithm returns set-based granularity representations having minimal
period length, which is the most relevant parameter for the performance of the considered reasoning services. Extensive experimental work supports the techniques used in the
algorithm, and shows the efficiency and effectiveness of the algorithm.

1. Introduction
According to a 2006 research by Oxford University Press, the word time has been found
to be the most common noun in the English language, considering diverse sources on the
Internet including newspapers, journals, fictions and weblogs. What is somehow surprising
is that among the 25 most common nouns we find time granularities like day, week, month
and year. We are pretty sure that many other time granularities like business day, quarter,
semester, etc. would be found to be quite frequently used in natural languages. However,
the way computer applications deal with these concepts is still very naive and mostly hidden in program code and/or based on limited and sometimes imprecise calendar support.

c
2007
AI Access Foundation. All rights reserved.

fiBettini, Mascetti & Wang

Temporal representation and reasoning has been for a long time an AI research topic aimed
at providing a formal framework for common sense reasoning, natural language understanding, planning, diagnosis and many other complex tasks involving time data management.
Despite the many relevant contributions, time granularity representation and reasoning
support has very often been ignored or over-simplified. In the very active area of temporal
constraint satisfaction, most proposals implicitly assumed that adding support for granularity was a trivial extension. Only quite recently it was recognized that this is not the
case and specific techniques were proposed (Bettini, Wang, & Jajodia, 2002a). Even the
intuitively simple task of deciding whether a specific instant is part of a time granularity
can be tricky when arbitrary user-defined granularities like e.g., banking days, or academic
semesters are considered.
Granularities and periodic patterns in terms of granularities are playing a role even
in emerging application areas like inter-organizational workflows and personal information
management (PIM). For example, inter-organizational workflows need to model and monitor
constraints like: Event2 should occur no later than two business days after the occurrence
of Event1. In the context of PIM, current calendar applications, even on mobile devices,
allow the user to specify quite involved periodical patterns for the recurrence of events. For
example, it is possible to schedule an event every last Saturday of every two months. The
complexity of the supported patterns has been increasing in the last years, and the current
simple interfaces are showing their limits. They are essentially based on a combination of
recurrences based on one or two granularities taken from a fixed set (days, weeks, months,
and years). We foresee the possibility for significant extensions of these applications by
specifying recurrences over user-defined granularities. For example, the user may define (or
upload from a granularity library) the granularity corresponding to the academic semester
of the school he is teaching at, and set the date of the finals as the last Monday of each
semester. A bank may want to define its banking days granularity and some of the bank
policies may then be formalized as recurrences in terms of that granularity. Automatically
generated appointments from these policies may appear on the devices of bank employees
involved in specific procedures. We also foresee the need to show a user preferred view of
the calendar. With current standard applications the user has a choice between a businessday limited view and a complete view, but why not enabling a view based on the userss
consulting-days, for example? A new perspective in the use of mobile devices may also result
from considering the time span in which activities are supposed to be executed (expressed
in arbitrary granularities), and having software agents on board to alert about constraints
that may be violated, even based on contextual information like the user location or traffic
conditions. This scenario highlights three main requirements: a) a sufficiently expressive
formal model for time granularity, b) a convenient way to define new time granularities,
and c) efficient reasoning tools over time granularities.
Consider a). In the last decade significant efforts have been made to provide formal
models for the notion of time granularity and to devise algorithms to manage temporal
data based on those models. In addition to logical approaches (Montanari, 1996; Combi,
Franceschet, & Peron, 2004), a framework based on periodic-set representations has been
extensively studied (Bettini, Wang, & Jajodia, 2000), and more recently an approach based
on strings and automata was introduced (Wijsen, 2000; Bresolin, Montanari, & Puppis,
2004). We are mostly interested in the last two approaches because they support the effective
300

fiMapping Calendar Expressions to Minimal Periodic Sets

computation of basic operations on time granularities. In both cases the representation of
granularities can be considered as a low-level one, with a rather involved specification in
terms of the instants of the time domain.
Consider requirement b) above. Users may have a hard time in defining granularities
in formalisms based on low-level representations, and to interpret the output of operations.
It is clearly unreasonable to ask users to specify granularities by linear equations or other
mathematical formalisms that operate directly in terms of instants or of granules of a fixed
time granularity. Hence, a second stream of research investigated more high-level symbolic
formalisms providing a set of algebraic operators to define granularities in a compact and
compositional way. The efforts on this task started even before the research on formal
models for granularity (Leban, McDonald, & Forster, 1986; Niezette & Stevenne, 1992) and
continued as a parallel stream of research (Bettini & Sibi, 2000; Ning, Wang, & Jajodia,
2002; Terenziani, 2003; Urgun, Dyreson, Snodgrass, Miller, Soo, Kline, & Jensen, 2007).
Finally, let us consider requirement c) above. Several inferencing operations have been
defined on low-level representations, including equivalence, inclusion between granules in
different granularities, and even complex inferencing services like constraint propagation
(Bettini et al., 2002a). Even for simple operations no general method is available operating
directly on the high level representation. Indeed, in some cases, the proposed methods
cannot exploit the structure of the expression and require the enumeration of granules,
which may be very inefficient. This is the case, for example, of the granule conversion
methods presented by Ning e at. (2002). Moreover, we are not aware of any method to
perform other operations, such as equivalence or intersection of sets of granules, directly in
terms of the high level representation.
The major goal of this paper is to provide a unique framework to satisfy the requirements
a), b), and c) identified above, by adding to the existing results a smart and efficient
technique to convert granularity specifications from the high-level algebraic formalism to the
low-level one, for which many more reasoning tools are available. In particular, in this paper
we focus on the conversion from the high-level formalism called Calendar Algebra (Ning
et al., 2002) to the low-level formalism based on periodical sets (Bettini et al., 2000, 2002a).
Among the several proposals for the high-level (algebraic) specification of granularities, the
choice of Calendar Algebra has two main motivations: first, it allows the user to express
a large class of granularities; For a comparison of the expressiveness of Calendar Algebra
with other formalisms see (Bettini et al., 2000). Second, it provides the richest set of
algebraic operations that are designed to reflect the intuitive ways in which users define
new granularities. A discussion on the actual usability of this tool and on how it could
be enhanced by a graphical user interface can be found in Section 6.2. The choice of
the low-level formalism based on periodic-sets also has two main motivations: first, an
efficient implementation of all the basic operations already exists and has been extensively
experimented (Bettini, Mascetti, & Pupillo, 2005); second, it is the only one currently
supporting the complex operations on granularities needed for constraint satisfaction, as it
will be illustrated in more detail in Section 6.1.
The technical contribution of this paper is a hybrid algorithm that interleaves the conversion of calendar subexpressions into periodical sets with a step for period minimization.
A central phase of our conversion procedure is to derive, for each algebraic subexpression,
the periodicity of the output set. This periodicity is used to build the periodical represen301

fiBettini, Mascetti & Wang

tation of the subexpression that can be recursively used as operand of other expressions.
Given a calendar algebra expression, the algorithm returns set-based granularity representations having minimal period length. The period length is the most relevant parameter
for the performance both of basic operations on granularities and of more specialized ones
like the operations used by the constraint satisfaction service. Extensive experimental work
reported in this paper validates the techniques used in the algorithm, by showing, among
other things, that (1) even large calendar expressions can be efficiently converted, and (2)
less precise conversion formulas may lead to unacceptable computation time. This latter
property shows the importance of carefully and accurately designed conversion formulas.
Indeed, conversion formulas may seem trivial if the length of periodicity is not a concern.
In designing our conversion formulas, we made an effort to reduce the period length of the
resulting granularity representation, and thus render the whole conversion process computationally efficient.
In the next section we define granularities; several interesting relationships among them
are highlighted and the periodical set representation is formalized. In Section 3 we define
Calendar Algebra and present its operations. In Section 4 we describe the conversion
process: after the definition of the three steps necessary for the conversion, for each algebraic
operation we present the formulas to perform each step. In Section 5 we discuss the period
minimality issue, and we report experimental results based on a full implementation of
the conversion algorithm and of its extension ensuring minimality. In Section 6 we further
motivate our work by presenting a complete application scenario. Section 7 reports the
related work, and Section 8 concludes the paper.

2. Formal Notions of Time Granularities
Time granularities include very common ones like hours, days, weeks, months and years,
as well as the evolution and specialization of these granularities for specific contexts or
applications. Trading days, banking days, and academic semesters are just few examples
of specialization of granularities that have become quite common when describing policies
and constraints.
2.1 Time Granularities
A comprehensive formal study of time granularities and their relationships can be found
in (Bettini et al., 2000). In this paper, we only introduce notions that are essential to
show our results. In particular, we report here the notion of labeled granularity which was
proposed for the specification of a calendar algebra (Bettini et al., 2000; Ning et al., 2002);
we will show later how any labeled granularity can be reduced to a more standard notion of
granularity, like the one used by Bettini et al. (2002a).
Granularities are defined by grouping sets of instants into granules. For example, each
granule of the granularity day specifies the set of instants included in a particular day. A
label is used to refer to a particular granule. The whole set of time instants is called time
domain, and for the purpose of this paper the domain can be an arbitrary infinite set with
a total order relationship, .

302

fiMapping Calendar Expressions to Minimal Periodic Sets

Definition 1 A labeled granularity G is a pair (LG , M ), where LG is a subset of the
integers, and M is a mapping from LG to the subsets of the time domain such that for each
pair of integers i and j in LG with i < j, if M (i) 6=  and M (j) 6= , then (1) each element
in M (i) is less than every element of M (j), and (2) for each integer k in LG with i < k < j,
M (k) 6= .
The former condition guarantees the monotonicity of the granularity; the latter is
used to introduce the bounds (see Section 2.2).
We call LG the label set and for each i  LG we call G(i) a granule; if G(i) 6=  we call
it a non-empty granule. When LG is exactly the integers, the granularity is called fullinteger labeled. When LG = Z+ we have the same notion of granularity as used in several
applications, e.g., (Bettini et al., 2002a). For example, following this labeling schema, if
we assume to map day(1) to the subset of the time domain corresponding to January 1,
2001, day(32) would be mapped to February 1, 2001, b-day(6) to January 8, 2001 (the
sixth business day), and month(15) to March 2002. The generalization to arbitrary label
sets has been introduced mainly to facilitate conversion operations in the algebra, however
our final goal is the conversion of a labeled granularity denoted by a calendar expression
into a positive-integer labeled one denoted by a periodic formula.
2.2 Granularity Relationships
Some interesting relationships between granularities follows. The definitions are extended
from the ones presented by Bettini et al. (2000) to cover the notion of labeled granularity.
Definition 2 If G and H are labeled granularities, then G is said to group into H, denoted
G / H, if for each non-empty
granule H(j), there exists a (possibly infinite) set S of labels
S
of G such that H(j) = iS G(i).
Intuitively, G / H means that each granule of H is a union of some granules of G. For
example, day / week since a week is composed of 7 days and day / b-day since each business
day is a day.
Definition 3 If G and H are labeled granularities, then G is said to be finer than H,
denoted G  H, if for each granule G(i), there exists a granule H(j) such that G(i)  H(j).
For example business-day is finer than day, and also finer than week.
We also say that G partitions H if G / H and G  H. Intuitively G partitions H if
G / H and there are no granules of G other than those included in granules of H. For
example, both day and b-day group into b-week (business week, i.e., the business day in a
week), but day does not partition b-week, while b-day does.
Definition 4 A labeled granularity G1 is a label-aligned subgranularity of a labeled granularity G2 if the label set LG1 of G1 is a subset of the label set LG2 of G2 and for each i in
LG1 such that G1 (i) 6= , we have G1 (i) = G2 (i).
Intuitively, G1 has a subset of the granules of G2 and those granules have the same label in
the two granularities.
303

fiBettini, Mascetti & Wang

Granularities are said to be bounded when LG has a first or last element or when G(i) = 
for some i  LG . We assume the existence of an unbounded bottom granularity, denoted
by  which is full-integer labeled and groups into every other granularity in the system.
There are time domains such that, given any set of granularities, it is always possible
to find a bottom one; for example, it can be easily proved that this property holds for each
time domain that has the same cardinality as the integers. On the other hand, the same
property does not hold for other time domains (e.g. the reals). However, the assumption
about the existence of the bottom granularity is still reasonable since we address problems
in which granularities are defined starting from a bottom one. The definition of a calendar
as a set of granularities that have the same bottom granularity (Bettini et al., 2000) captures
this idea.
2.3 Granularity Conversions
When dealing with granularities, we often need to determine the granule (if any) of a
granularity H that covers a given granule z of another granularity G. For example, we
may wish to find the month (an interval of the absolute time) that includes a given week
(another interval of the absolute time).
This transformation is obtained with the up operation. Formally, for each label z  LG ,
H
0
0
dzeG is undefined if @z 0  LH s.t. G(z)  H(z 0 ) ; otherwise, dzeH
G = z , where z is the
0
0
unique index value such that G(z)  H(z ). The uniqueness of z is guaranteed by the
monotonicity 1 of granularities. As an example, dzemonth
second gives the month that includes
month
the second z. Note that while dzesecond is always defined, dzemonth
week is undefined if week
z falls between two months. Note that if G  H, then the function dzeH
G is defined for
week
each index value z. For example, since day  week, dzeday is always defined, i.e., for
each day we can find the week that contains it. The notation dzeH is used when the source
granularity can be left implicit (e.g., when we are dealing with a fixed set of granularities
having a distinguished bottom granularity).
Another direction of the above transformation is the down operation: Let G and H
H
be granularities such that
S G / H, and z an2 integer. Define bzcG as the set S of labels of
granules of G such that jS G(j) = H(z). This function is useful for finding, e.g., all the
days in a month.
2.4 The Periodical Granules Representation
A central issue in temporal reasoning is the possibility of finitely representing infinite granularities. The definition of granularity provided above is general and expressive but it may
be impossible to provide a finite representation of some of the granularities. Even labels
(i.e., a subset of the integers) do not necessarily have a finite representation.
A solution has been first proposed by Bettini et al. (2000). The idea is that most of the
commonly used granularities present a periodical behavior; it means that there is a certain
pattern that repeats periodically. This feature has been exploited to provide a method for
1. Condition (1) of Definition 1.
2. This definition is different from the one given by Bettini et al (2000) since it also considers non contiguous
granules of G.

304

fiMapping Calendar Expressions to Minimal Periodic Sets

finitely describing granularities. The formal definition is based on the periodically groups
into relationship.
Definition 5 A labeled granularity G groups periodically into a labeled granularity H
(G / H) if G / H and there exist positive integers N and P such that
(1) for each label i of H, i + N is a label of H unless i + N is greater than the greatest
label of H, and
S
(2) for each label i of H, if H(i) = kr=0 G(jr ) and H(i + N ) is a non-empty granule of
S
H then H(i + N ) = kr=0 G(jr + P ), and
(3) if H(s) is the first non-empty granule in H (if exists), then H(s + N ) is non-empty.
The groups periodically into relationship is a special case of the group into characterized
by a periodic repetition of the grouping pattern of granules of G into granules of H. Its
definition may appear complicated but it is actually quite simple. Since G groups into H,
any granule H(i) is the union of some granules of G; for instance assume it is the union of
the granules G(a1 ), G(a2 ), . . . , G(ak ). Condition (1) ensures that the label i + N exists (if
it not greater than the greatest label of H) while condition (2) ensures that, if H(i + N ) is
not empty, then it is the union of G(a1 + P ), G(a2 + P ), . . . , G(ak + P ). We assume that
r = 0 . . . k, (jr + P )  LG ; if not, the conditions are considered not satisfied. Condition
(3) simply says that there is at least one of these repetitions.
We call each pair P and N in Definition 5, a period length and its associated period
label distance. We also indicate with R the number of granules of H corresponding to each
groups of P consecutive granules of . More formally R is equal to the number of labels of
H greater or equal than i and smaller than i + N where i is an arbitrary label of H. Note
that R is not affected by the value of i.
The period length and the period label distance are not unique; more precisely, we
G the period label
indicate with PHG the period length of H in terms of G and with NH
distance of H in terms of G; the form PH and NH is used when G = . Note that the
period length is an integer value. For simplicity we also indicate with one period of a
granularity H a set of R consecutive granules of H.
In general, the periodically groups into relationship guarantees that granularity H can
be finitely described (in terms of granules of G).
Definition 6 If G / H, then H can be finitely described by providing: (i) a value for P
P
and N ; (ii) the set LP of labels of H in
S one period of H; (iii) for each a  L , the finite set
Sa of labels of G, such that H(a) = iSa G(i); (iv) the labels of first and last non-empty
granules in H, if their values are not infinite.
In this representation, the granules that have labels in LP are the only ones that need
to be explicitly represented; we call these granules the explicit granules.
If a granularity H can be represented as a periodic set of granules of a granularity G,
G ) for which the periodically groups
then there exists an infinite number of pairs (PHG , NH
into relation is satisfied. If the relation is satisfied for a pair (P, N ), then it can be proved
that it can also be satisfied for each pair (P, N ) with   N+ .

305

fiBettini, Mascetti & Wang

Definition 7 A periodic representation of a granularity H in terms of G is called minimal
if the period length P used in the representation has the smallest value among the period
G ) for which H periodically groups into G.
lengths appearing in all the pairs (PHG , NH
If H is fully characterized in terms of G, it is possible to derive the composition, in
terms of G, of any granule of H. Indeed, if LP is the set of labels of H with values in
G  1}, and we assume H to be unbounded, the description of an arbitrary
{b, . . . , b + NH
G] + 1
granule H(j) can be obtained by the following formula. Given j 0 = [(j  1) mod NH
and
k
k
j
 j
b1
b1
G + j0
G + j0  b


N
 NH
if

G
G
H

NH
NH
k=
k

j


b1

+ 1  N G + j 0 otherwise
G
NH

H

we have
H(j) =

[


G

PHG

iSk




k1
j1
G
+ i  PH 
.

G
G
NH
NH


Example 1 Figure 1 shows granularities day and week parts i.e., the granularity that,
for each week, contains a granule for the working days and a granule for the weekend. For
the sake of simplicity, we denote day and week parts with D and W respectively. Since
D / W , W is fully characterized in terms of D. Among different possible representations,
D = 7, N D = 2, LP = {3, 4},
in this example we decide to represent W in terms of D by PW
W
W
S3 = {8, 9, 10, 11, 12} and S4 = {13, 14}. The composition of each granule of W can then
be easily computed; For example the composition of W (6) is given by the formula presented
above with j 0 = 2 and k = 4. Hence W (6) = D(7  2 + 13  7  1)  D(7  2 + 14  7  1) =
D(20)  D(21).
D
-1 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30
j

b

k

2

3

4

j

W
1

5

6

7

8

Figure 1: Periodically groups into example

3. Calendar Algebra
Several high-level symbolic formalisms have been proposed to represent granularities (Leban
et al., 1986; Niezette & Stevenne, 1992).
In this work we consider the formalism proposed by Ning et al. (2002) called Calendar
Algebra. In this approach a set of algebraic operations is defined; each operation generates
a new granularity by manipulating other granularities that have already been generated.
The relationships between the operands and the resulting granularities are thus encoded in
the operations. All granularities that are generated directly or indirectly from the bottom
granularity form a calendar, and these granularities are related to each other through the
306

fiMapping Calendar Expressions to Minimal Periodic Sets

operations that define them. In practice, the choices for the bottom granularity include day,
hour, second, microsecond and other granularities, depending on the accuracy required in
each application context.
In the following we illustrate the calendar algebra operations presented by Ning et al.
(2002) together with some restrictions introduced by Bettini et al. (2004).
3.1 The Grouping-Oriented Operations
The calendar algebra consists of the following two kinds of operations: the grouping-oriented
operations and the granule-oriented operations. The grouping-oriented operations group
certain granules of a granularity together to form new granules in a new granularity.
3.1.1 The Grouping Operation
Let G be a full-integer labeled granularity, and m a positive integer. The grouping operation
Groupm (G) generates a new granularity G0 by partitioning the granules of G into m-granule
groups and making each group a granule of the resulting granularity. More precisely, G0 =
Groupm (G) is the granularity such that for each integer i,
im
[

G0 (i) =

G(j).

j=(i1)m+1

For example, given granularity day, granularity week can be generated by the calendar
algebra expression week = Group7 (day) if we assume that day(1) corresponds to Monday,
i.e., the first day of a week.
3.1.2 The Altering-tick Operation
Let G1 , G2 be full-integer labeled granularities, and l, k, m integers, where G2 partitions
m (G , G ) generates a new granularity
G1 , and 1  l  m. The altering-tick operation Alterl,k
2
1
by periodically expanding or shrinking granules of G1 in terms of granules of G2 . Since G2
partitions G1 , each granule of G1 consists of some contiguous granules of G2 . The granules
of G1 can be partitioned into m-granule groups such that G1 (1) to G1 (m) are in one group,
G1 (m + 1) to G1 (2m) are in the following group, and so on. The goal of the altering-tick
operation is to modify the granules of G1 so that the l-th granule of every m-granule group
will have |k| additional (or fewer when k < 0) granules of G2 . For example, if G1 represents
30-day groups (i.e., G1 = Group30 (day)) and we want to add a day to every 3-rd month
(i.e., to make March to have 31 days), we may perform Alter12
3,1 (day, G1 ).
The altering-tick operation can be formally described as follows. For each integer i such
i
that G1 (i) 6= , let bi and ti be the integers such that G1 (i) = tj=b
G2 (j) (the integers bi
i
m
0
and ti exist because G2 partitions G1 ). Then G = Alterl,k (G2 , G1 ) is the granularity such
that for each integer i, let G0 (i) =  if G1 (i) = , and otherwise let
0

0

G (i) =

ti
[
j=b0i

307

G2 (j),

fiBettini, Mascetti & Wang

where
b0i


=

bi + (h  1)  k, if i = (h  1)  m + l,
bi + h  k,
otherwise,
t0i = ti + h  k,

and


il
+ 1.
h=
m


Example 2 Figure 2 shows an example of the Alter operation. Granularity G1 is defined
by G1 = Group5 (G2 ) and granularity G0 is defined by G0 = Alter22,1 (G2 , G1 ), which means
shrinking the second one of every two granules of G1 by one granule of G2 .
G2
-9 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21

G1
-1

0

1

2

3

4

G
-

1

0

1

2

3

4

Figure 2: Altering-tick operation example
The original definition of altering-tick given by Ning et al. (2002) as reported above,
has the following problems when an arbitrary negative value for k is used: (1) It allows
the definition of a G0 that is not a full-integer labeled granularity and (2) It allows the
definition of a G0 that does not even satisfy the definition of granularity. In order to avoid
this undesired behavior, we impose the following restriction:
k > (mindist(G1, 2, G2)  1)
where mindist() is formally defined by Bettini et al. (2000).
Intuitively, mindist(G1, 2, G2) represents the minimum distance (in terms of granules
of G2) between two consecutive granules of G1.
3.1.3 The Shift Operation
Let G be a full-integer labeled granularity, and m an integer. The shifting operation
Shiftm (G) generates a new granularity G0 by shifting the labels of G by m positions. More
formally, G0 = Shiftm (G) is the granularity such that for each integer i, G0 (i) = G(i  m).
Note that G0 is also full-integer labeled.
3.1.4 The Combining Operation
Let G1 and G2 be granularities with label sets LG1 and LG2 respectively. The combining
operation Combine(G1 , G2 ) generates a new granularity G0 by combining all the granules
of G2 that are included in one granule of G1 into one granule of G0 . More formally, for each
i  L1 , let s(i) =  if G1 (i) = , and otherwise let s(i) = {j  LG2 | =
6 G2 (j)  G1 (i)}.

308

fiMapping Calendar Expressions to Minimal Periodic Sets

Then G0 = Combine(G1 , G2 ) is the granularity
with the label set LG0 = {i  LG1 |s(i) 6= }
S
such that for each i in LG0 , G0 (i) = js(i) G2 (j).
As an example, given granularities b-day and month, the granularity for business months
can be generated by b-month = Combine(month, b-day).
3.1.5 The Anchored Grouping Operation
Let G1 and G2 be granularities with label sets LG1 and LG2 respectively, where G2 is a
label-aligned subgranularity of G1 , and G1 is a full-integer labeled granularity. The anchored
grouping operation Anchored-group(G1 , G2 ) generates a new granularity G0 by combining
all the granules of G1 that are between two granules of G2 into one granule of G0 . More
formally, G0 = Anchored-group(G1 , G2 ) is the granularity with the label set LG0 = LG2
S 0 1
G1 (j) where i0 is the next label of G2 after i.
such that for each i  LG0 , G0 (i) = ij=i
For example, each academic year at a certain university begins on the last Monday in
August, and ends on the day before the beginning of the next academic year. Then, the
granularity corresponding to the academic years can be generated by AcademicY ear =
Anchored-group(day, lastMondayOfAugust).
3.2 The Granule-Oriented Operations
Differently from the grouping-oriented operations, the granule-oriented operations do not
modify the granules of a granularity, but rather enable the selection of the granules that
should remain in the new granularity.
3.2.1 The Subset Operation
Let G be a granularity with label set LG , and m, n integers such that m  n. The subset
operation G0 = Subsetnm (G) generates a new granularity G0 by taking all the granules of
G whose labels are between m and n. More formally, G0 = Subsetnm (G) is the granularity
with the label set LG0 = {i  LG | m  i  n}, and for each i  LG0 , G0 (i) = G(i).
For example, given granularity year, all the years in the 20th century can be generated by
0
20CenturyYear = Subset1999
1900 (year). Note that G is a label-aligned subgranularity of G,
and G0 is not a full-integer labeled granularity even if G is. We also allow the extensions of
setting m =  or n =  with semantics properly extended.
3.2.2 The Selecting Operations
The selecting operations are all binary operations. They generate new granularities by
selecting granules from the first operand in terms of their relationship with the granules of
the second operand. The result is always a label-aligned subgranularity of the first operand
granularity.
There are three selecting operations: select-down, select-up and select-by-intersect. To
facilitate the description of these operations, the lk (S) notation is used. Intuitively, if
S is a set of integers, lk (S) selects l elements starting from the k-th one (for a formal
description of the  operator see (Ning et al., 2002)).
Select-down operation. For each granule G2 (i), there exits a set of granules of G1 that
is contained in G2 (i). The operation Select-downlk (G1 , G2 ), where k 6= 0 and l > 0 are
309

fiBettini, Mascetti & Wang

integers, selects granules of G1 by using lk () on each set of granules (actually their labels)
of G1 that are contained in one granule of G2 . More formally, G0 = Select-downlk (G1 , G2 )
is the granularity with the label set
LG0 = iLG2 lk ({j  LG1 |  6= G1 (j)  G2 (i)}),
and for each i  LG0 , G0 (i) = G1 (i). For example, Thanksgiving days are the fourth
Thursdays of all Novembers; if Thursday and November are given, it can be generated by
Thanksgiving = Select-down14 (Thursday, November).
Select-up operation. The select-up operation Select-up(G1 , G2 ) generates a new granularity
G0 by selecting the granules of G1 that contain one or more granules of G2 . More formally,
G0 = Select-up(G1 , G2 ) is the granularity with the label set
6 G2 (j)  G1 (i)), }
LG0 = {i  LG1 |j  LG2 ( =
and for each i  LG0 , G0 (i) = G1 (i). For example, given granularities Thanksgiving
and week, the weeks that contain Thanksgiving days can be defined by ThanxWeek =
Select-up(week, Thanksgiving).
Select-by-intersect operation. For each granule G2 (i), there may exist a set of granules of G1 ,
each intersecting G2 (i). The Select-by-intersectlk (G1 , G2 ) operation, where k 6= 0 and l > 0
are integers, selects granules of G1 by applying lk () operator to all such sets, generating
a new granularity G0 . More formally, G0 = Select-by-intersectlk (G1 , G2 ) is the granularity
with the label set
LG0 = iLG2 lk ({j  LG1 | G1 (j)  G2 (i) 6= }),
and for each i  LG0 , G0 (i) = G1 (i). For example, given granularities week and month, the
granularity consisting of the first week of each month (among all the weeks intersecting the
month) can be generated by FirstWeekOfMonth = Select-by-intersect11 (week, month).
3.2.3 The Set Operations
In order to have the set operations as a part of the calendar algebra and to make certain
computations easier, we restrict the operand granularities participating in the set operations
so that the result of the operation is always a valid granularity: the set operations can be
defined on G1 and G2 only if there exists a granularity H such that G1 and G2 are both
label-aligned subgranularities of H. In the following, we describe the union, intersection,
and difference operations of G1 and G2 , assuming that they satisfy the requirement.
Union. The union operation G1  G2 generates a new granularity G0 by collecting all the
granules from both G1 and G2 . More formally, G0 = G1  G2 is the granularity with the
label set LG0 = LG1  LG2 , and for each i  LG0 ,

G1 (i), i  L1 ,
0
G (i) =
G2 (i), i  L2  L1 .
For example, given granularities Sunday and Saturday, the granularity of the weekend days
can be generated by WeekendDay = Sunday  Saturday.
310

fiMapping Calendar Expressions to Minimal Periodic Sets

Intersection. The intersection operation G1  G2 generates a new granularity G0 by taking
the common granules from both G1 and G2 . More formally, G0 = G1  G2 is the granularity
with the label set LG0 = LG1  LG2 , and for each i  LG0 , G0 (i) = G1 (i) (or equivalently
G2 (i)).
Difference. The difference operation G1 \ G2 generates a new granularity G0 by excluding
the granules of G2 from those of G1 . More formally, G0 = G1 \ G2 is the granularity with
the label set LG0 = LG1 \ LG2 , and for each i  LG0 , G0 (i) = G1 (i).

4. From Calendar Algebra to Periodical Set
In this section we first describe the overall conversion process and then we report the
formulas specific for the conversion of each calendar algebra operation. Finally, we present
a procedure for relabeling the resulting granularity, a sketch complexity analysis and some
considerations about the period length minimality.
4.1 The Conversion Process
Our final goal is to provide a correct and effective way to convert calendar expressions
into periodical representations. Under appropriate limitations, for each calendar algebra
operation, if the periodical descriptions of the operand granularities are known, it is possible
to compute the periodical characterization of the resulting granularity.
This result allows us to calculate, for any calendar, the periodical description of each
granularity in terms of the bottom granularity. In fact, by definition, the bottom granularity is fully characterized; hence it is possible to compute the periodical representation of
all the granularities that are obtained from operations applied to the bottom granularity.
Recursively, the periodical description of all the granularities can be obtained.
The calendar algebra presented in the previous section can represent all the granularities
that are periodical with finite exceptions (i.e., any granularity G such that bottom groups
periodically with finite exceptions into G). Since with the periodical representations defined
in Section 2 it is not possible to express the finite exceptions, we need to restrict the calendar
algebra so that it cannot represent them. This implies allowing the Subset operation to
be only used as the last step of deriving a granularity. Note that in the calendar algebra
presented by Ning et al. (2002) there was an extension to the altering-tick operation to allow
the usage of  as the m parameter (i.e., G0 = Alter
l,k (G2 , G1 )); the resulting granularity
has a single exception hence is not periodic. This extension is disallowed here in order to
generate periodical granularities only (without finite exceptions).
The conversion process can be divided into three steps: in the first one the period length
and period label distance are computed; in the second we derive the set LP of labels in one
period, and in the last one the composition of the explicit granules is computed. For each
operation we identify the correct formulas and algorithms for the three steps.
The first step consists in computing the period length and the period label distance of
the resulting granularity. Those values are calculated as a function of the parameters (e.g.
the grouping factor m, in the Group operation) and the operand granularities (actually
their period lengths and period label distances).

311

fiBettini, Mascetti & Wang

The second step in the conversion process is the identification of the label set of the
resulting granularity. In Section 2.4 we pointed out that in order to fully characterize a
granularity it is sufficient to identify the labels in any period of the granularity. In spite
of this theoretical result, to perform the computations required by each operation we need
the explicit granules of the operand granularities to be aligned. There are two possible
approaches: the first one consist in computing the explicit granules in any period and
then recalculate the needed granules in the correct position in order to eventually align
them. The second one consists in aligning all the periods containing the explicit granules
with a fixed granule in the bottom granularity. After considering both possibilities, for
performance reasons, we decided to adopt the second approach. We decided to use (1) as
the alignment point for all the granularities. A formal definition of the used formalism
follows.
Let G be a granularity and i be the smallest positive integer such that dieG is defined.
We call lG = dieG and LG the set of labels of G contained in lG . . . lG +NG 1. Note that this
definition of LG is an instance of the definition of LP given in Section 2.4. The definition
of LG provided here is useful for representing G and actually the final goal of this step is to
compute LG ; however LG is not suitable for performing the computations. The problem is
that if G(lG ) starts before (1) (i.e., min(blG cG ) < 1) then the granule G(lG + NG ) begins
at PG or before PG , and hence G(lG + NG ) is necessary for the computations; however
lG + NG 
/ LG .
To solve the problem we introduce the symbol LG to represent the set of all labels of
granules of G that cover one in (1) . . . (PG ). It is easily seen that if G(lG ) does not cover
(0), then LG = LG , otherwise LG = LG  {lG + NG }. Therefore the conversion between
L and L and vice versa is immediate.
The notion of L is still not enough to perform the computations. The problem is that
when a granularity G is used as an operand in an operation, the period length of the
resulting granularity G0 is generally bigger than the period length of G. Therefore it is
necessary to extend the notion of LG to the period length PG0 of G0 using PG0 in spite of
P 0
PG in the definition of L. The symbol used for this notion is LGG .
P 0
The idea is that when G is used as the operand in an operation that generates G0 , LGG is
computed from LG . This set is then used by the formula that we provide below to compute
LG0 .
The computation of LG0 is performed as follows: if G0 is defined by an operation that
0 .
returns a full-integer labeled granularity, then it is sufficient to compute the value of lG
0
0
0
Indeed it is easily seen that LG0 = {i  Z|lG  i  lG + NG0  1}. If G is defined by
any other algebraic operation, we provide the formulas to compute LG0 ; from LG0 we easily
derive LG0 .
Example 3 Figure 3 shows granularities , G and H; it is clear that PG = PH = 4 and
NG = NH = 3. Moreover, lG = lH = 6 and therefore LG = LH = {6, 7}. Since 0 
/ b6cG
H
then LG = LG . On the other hand, since 0  b6c , then LH = LH  {6 + 3}.
P0
Suppose that a granularity G0 has period length PG0 = 8; then LGG = {6, 7, 9, 10} and
P 0
LHG = {6, 7, 9, 10, 12}.

312

fiMapping Calendar Expressions to Minimal Periodic Sets

^

-6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9 10

G
1

3

4

6

7

9

10

12

H
1

3

4

6

7

9

10

12 13

Figure 3: L, l, L and LPG0 examples
The third (and last) step of the conversion process is the computation of the composition of the explicit granules. Once LG0 has been computed, it is sufficient to apply, for each
label of LG0 the formulas presented in Chapter 3.
In Sections 4.3 to 4.10 we show, for each calendar algebra operation, how to compute
the first and second conversion steps.
4.2 Computability Issues
In some of the formulas presented below it is necessary to compute the set S of labels of a
granularity G such that i  S G(i)  H(j) where H is a granularity and j is a specific label
of H. Since LG contains an infinite number of labels, it is not possible to check, i  LG
if G(i)  H(j). However it is easily seen that i  S k s.t. G(dkeG )  H(j). Therefore
i  S k s.t. G(dkeG ) is defined and k  bjcH .
Therefore we compute the set S by considering all the labels i of LG s.t. n  bjcH s.t.
dneG = i and G(i)  H(j). Since the set bjcH is finite3 , the computation can be performed
in a finite time. The consideration is analogous if S is the set such that i  S G(i)  H(j)
or i  S (G(i)  H(j) 6= ).
4.3 The Group Operation
Proposition 1 If G0 = Groupm (G), then:
PG m
1. PG0 = GCD(m,N
and NG0 =
G)
j
k

lG 1
+
1
;
2. lG0 =
m

3. i  LG0 G0 (i) =

NG
GCD(m,NG ) ;

Sim

j=(i1)m+1 G(j).

Example 4 Figure 4 shows an example of the group operation: G0 = Group3 (G). Since
PG = 1 and NG = 1, then PG0 = 3 and NG = 1. Moreover, since LG = {7}, then lG = 7
and therefore lG0 = 2 and LG0 = {2}. Finally G0 (2) = G(8)  G(7)  G(6) i.e.,
G0 (2) = (0)  (1)  (2).
3. With the calendar algebra it is not possible to define granularities having granules that maps to an
infinite set of time instants.

313

fiBettini, Mascetti & Wang

^

-6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20

G
-14-13-12-11-10 -9 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9 10 11 12

G
-4

-3

-2

-1

0

1

2

3

4

Figure 4: Group operation example
4.4 The Altering-tick Operation
Proposition 2 If G0 = Alterm
l,k (G2 , G1 ) then:
1.


N

G0

PG2  NG1
NG2  m
= lcm NG1 , m,
,
GCD(PG2  NG1 , PG1 ) GCD(NG2  m, |k|)

and


PG0 =

NG0  k
NG0  PG1  NG2
+
NG1  PG2
m






PG2
NG2

0

2. lG0 = dlG2 eG
G2 ;
3. i  LG0 G0 (i) =

St0i

j=b0i

G(j) where b0i and t0i are defined in Section 3.1.2.

Referring to step 2., note that when computing lG0 the explicit characterization of the
0
granules of G0 is still unknown. To perform the operation dlG2 eG
G2 we need to know at least
the explicit granules of one of its periods. We choose to compute the granules labeled by
1 . . . NG0 . When lG0 is derived, the granules labeled by lG0 . . . lG0 + NG0  1 will be computed
so that the explicit granules are aligned to (1) as required.
Example 5 Figure 5 shows an example of the altering-tick operation: G0 = Alter32,1 (G2 , G1 ).
Since PG1 = 4, NG1 = 1, PG2 = 4 and NG2 = 2, then NG0 = 6 and PG0 = 28.
G0 = 4
Moreover, since LG2 = {10, 9}, then lG2 = 10 and therefore lG0 = d10eG
2
and hence LG2 = {4, 3, . . . , 0, 1}. Finally G0 (4) = G1 (11)  G1 (10)  G1 (9) =
(1)  (0)  (1)  (3)  (4); analogously we derive G0 (3), G0 (2), G0 (1), G0 (0)
and G0 (1).

4.5 The Shift Operation
Proposition 3 If G0 = Shiftm (G), then:
1. PG0 = PG1 and NG0 = NG1 ;
2. lG0 = lG + m;
3. i  LG0 G0 (i) = G(i  m).
314

fiMapping Calendar Expressions to Minimal Periodic Sets

^

-3 -2 -1 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41

G1
-5

-4

-3

-2

-1

0

1

2

3

4

5

G2
-11 -10

-9

-8

-7

-6

-5

-4

-3

-2

-1

0

1

2

3

4

5

6

7

8

9

10

G
-4

-3

-2

-1

0

1

2

3

4

Figure 5: Alter operation example
Example 6 The shifting operation can easily model time differences. Suppose granularity
USEast-Hour stands for the hours of US Eastern Time. Since the hours of the US Pacific
Time are 3 hours later than those of US Eastern Time, the hours of US Pacific Time can
be generated by USPacific-Hour= Shift3 (USEast-Hour).
USEast-Hour
-6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8

USPacific-Hour
-9 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5

Figure 6: Shift operation example

4.6 The Combining Operation
Proposition 4 Given G0 = Combining(G1 , G2 ), then:
1. PG0 = lcm(PG1 , PG2 ) and NG0 =
P

0

P

lcm(PG1 ,PG2 )NG1
;
PG1
P

0

0

2. i  LGG1 let be se(i) = {j  LGG2 | =
6 G2 (j)  G1 (i)}; then LG0 = {i  LGG1 |e
s(i) 6= };
S
3. i  LG0 G0 (i) = js(i) G2 (j).
Example 7 Figure 7 shows an example of the combining operation: G0 = Combine(G1 , G2 ).
Since PG1 = 6, NG1 = 2, PG2 = 4 and NG2 = 2, then PG0 = 12 and NG0 = 4. Moreover,
P 0
since LG1 = {1} and 0  b1cG1 , then LG1 = {1, 3} and hence LGG1 = {1, 3, 5}. Since
0
s(i) 6=  for i  {1, 3, 5}, then LG0 = {1, 3, 5}; moreover, since 0  b1cG , then LG0 = {1, 3}.
Finally s(1) = {1, 0} and s(3) = {2, 3}; consequently, G0 (1) = G2 (1)  G2 (0) i.e.,
G0 (1) = (1)  (0)  (1) and G0 (3) = G2 (2)  G2 (3) i.e., G0 (3) = (4)  (5)  (7).

4.7 The Anchored Grouping Operation
Proposition 5 Given G0 = Anchored-group(G1 , G2 ), then:
1. PG0 = lcm(PG1 , PG2 ) and NG0 =

lcm(PG1 ,PG2 )NG2
;
PG2

315

fiBettini, Mascetti & Wang

^

-6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20

G1
1

3

5

7

G2
-3

-2

-1

0

1

2

3

4

5

6

7

8

9

G
1

3

5

7

Figure 7: Combine operation example
2.
(
LG0 =

P

0

LGG2 ,
if lG2 = lG1 ,
PG0
0
{lG2 }  LG2 , otherwise,

0
where lG
is the greatest among the labels of LG2 that are smaller than lG2 .
2

3. i  LG0 G0 (i) =

Si0 1
j=i

G1 (j) where i0 is the next label of G2 after i.

Example 8 Figure 8 shows an example of the anchored grouping operation: the USweek
(i.e., a week starting with a Sunday) is defined by the operation Anchored-group(day,
Sunday). Since Pday = 1 and PSunday = 7, then the period length of USweek is 7. MorePUSweek
over since lday = 11, lSunday = 14 and LSunday
= {14}, then LUSweek = {7}  {14}.
S
Clearly, since 0  b7cUSweek then LUSweek = {7}. Finally, USweek(7) = 13
j=7 day(j) =
S3
k=3 (k).

^

-18-17-16-15-14-13-12-11-10 -9 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9 10 11 12

day
-8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22

Sunday
-7

0

7

14

21

USweek
-7

0

7

14

Figure 8: Anchored Grouping operation example

4.8 The Subset Operation
The Subset operation only modifies the operand granularity by introducing the bounds.
The period length, the period label distance, L and the composition of the explicit granules
are not affected.

316

fiMapping Calendar Expressions to Minimal Periodic Sets

4.9 The Selecting Operations
4.9.1 The Select-down Operation
Proposition 6 Given G0 = Select-downlk (G1 , G2 ), then:
1. PG0 = lcm(PG1 , PG2 ) and NG0 =
2. i  LG2 let

lcm(PG1 ,PG2 )NG1
;
PG1

6 G1 (j)  G2 (i)}) .
A(i) = lk ({j  LG1 | =

Then

o
[ n
P 0
a  A(i)|a  LGG1 ;

LG0 =

P 0

iLGG
2

3. i  LG0 G0 (i) = G1 (i).
Example 9 Figure 9 shows an example of the Select-down operation in which granularity
G0 is defined as: G0 = Select-down12 (G1 , G2 ). Since PG1 = 4, NG1 = 2 and PG2 = 6
then PG0 = 12 and NG0 = 6. Moreover, since LG2 = {3} and 0  b3cG2 , then LG2 =
P 0
{3, 2} and LGG2 = {3, 2, 1}. Intuitively, A(3) = {5}, A(2) = {2} and
0
A(1) = {1}. Hence LG0 = {5, 2, 1} and therefore, since 0  b5cG , LG0 = {5, 2}.
Finally G0 (5) = G1 (5) = (0)  (1) and G0 (2) = G1 (2) = (6).
^

-9 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25

G1
-9

-8

-7

-6

-5

-4

-3

-2

-1

0

1

2

3

4

5

6

7

G2
-4

-3

-2

-1

0

1

G
-8

-5

-2

1

4

Figure 9: Select-down operation example

4.9.2 The Select-up Operation
Proposition 7 Given G0 = Select-up(G1 , G2 ), then:
1. PG0 = lcm(PG1 , PG2 ) and NG0 =

lcm(PG1 ,PG2 )NG1
;
PG1

2.
P

0

LG0 = {i  LGG1 |j  LG2 s.t.  =
6 G2 (j)  G1 (i)};
3. i  LG0 G0 (i) = G1 (i).

317

7

fiBettini, Mascetti & Wang

Example 10 Figure 10 shows an example of the Select-up operation: G0 = Select-up(G1 , G2 ).
Since PG1 = 6, NG1 = 3 and PG2 = 4 then PG0 = 12 and NG0 = 6. Moreover, since LG1 =
P0

{3, 2, 1} and 0  b3cG2 , then LG1 = {3, 2, 1, 0} and LGG1 = {3, 2, 1, 0, 1, 2, 3}.
Since G1 (3)  G2 (6), G1 (1)  G2 (4) and G1 (3)  G2 (0) then LG0 = {3, 1, 3}
0
and, since 0  b3cG , then LG0 = {3, 1} Finally G0 (3) = G1 (3) = (0)  (1) and
G0 (1) = G1 (1) = (4).
^

-9 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16

G1
-8 -7

-6

-5 -4

-3

-2 -1

0

1 2

3

4 5

G2
-10

-8

-6

-4

-2

0

2

G
-7

-3

-1

3

5

Figure 10: Select-up operation example

4.9.3 The Select-by-intersect Operation
Proposition 8 Given G0 = Select-by-intersectlk (G1 , G2 ), then:
1. PG0 = lcm(PG1 , PG2 ) and NG0 =

lcm(PG1 ,PG2 )NG1
;
PG1

2. then i  LG2 let
A(i) = lk ({j  LG1 |G1 (j)  G2 (i) 6= }) .
then
LG0 =

o
[ n
P 0
a  A(i)|a  LGG1 .
P 0

iLGG
2

3. i  LG0 G0 (i) = G1 (i).
Example 11 Figure 11 shows an example of the Select-by-intersect operation in which
G0 = Select-by-intersect12 (G1 , G2 ). Since PG1 = 4, NG1 = 2 and PG2 = 6 then PG0 = 12
and NG0 = 6. Moreover, since LG2 = {3} and 0  b3cG2 , then LG2 = {3, 2} and
P 0
LGG2 = {3, 2, 1}. Intuitively, A(3) = {6}, A(2) = {2} and A(1) = {0}. Hence
0
LG0 = {2, 0} and therefore, since 0 
/ b5cG , then LG0 = {2, 0}. Finally G0 (2) =
G1 (2) = (6) and G0 (0) = G1 (0) = (10).

318

fiMapping Calendar Expressions to Minimal Periodic Sets

^

-9 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25

G1
-9

-8

-7

-6

-5

-4

-3

-2

-1

0

1

2

3

4

5

6

7

G2
-4

-3

-2

-1

0

1

G
-8

-6

-2

0

4

6

Figure 11: Select-by-intersect operation example
4.10 The Set Operations
Since a set operation is valid if the granularities used as argument are both labeled aligned
granularity of another granularity, the following property is used.
Proposition 9 If G is a labeled aligned subgranularity of H, then

NG
PG

=

NH
PH .

Proposition 10 Given G0 = G1  G2 , G00 = G1  G2 and G000 = G1 \ G2 , then:
1. PG0 = PG00 = PG000 = lcm(PG1 , PG2 ) and
lcm(PG1 ,PG2 )NG1
=
NG0 = NG00 = NG000 =
PG
1

P

0

P

0

P

00

P

lcm(PG1 ,PG2 )NG2
;
PG2

00

P

000

P

000

2. LG0 = LGG1  LGG2 ; LG00 = LGG1  LGG2 ; LG000 = LGG1 \ LGG2 ;

G1 (i), i  LG1
0
3. i  LG0 G (i) =
G2 (i), otherwise,
i  LG00 G00 (i) = G1 (i) and i  LG000 G000 (i) = G1 (i)
Example 12 Figure 12 shows an example of the set operations. Note that both G1 and
G2 are labeled aligned subgranularities of H. Then G0 = G1  G2 , G00 = G1  G2 and
G000 = G1 \ G2 . Since PG1 = PG2 = 6 and NG1 = NG2 = 6 then PG0 = PG00 = PG000 = 6
and NG0 = NG00 = NG000 = 2. Moreover, since LG1 = {1, 2} and LG2 = {2, 3}, then
LG0 = {1, 2, 3}, LG00 = {2} and LG000 = {1}. Finally G0 (1) = G1 (1), G0 (2) = G1 (2) and
G0 (3) = G2 (3); G00 (2) = G1 (2) and G000 (1) = G1 (1).

4.11 Relabeling
Granularity processing algorithms are much simpler if restricted to operate on full-integer
labeled granularities. Moreover, a further simplification is obtained by using only the positive integers as the set of labels (i.e., L = Z+ ).
In this section we show how to relabel a granularity G to obtain a full-integer labeled
granularity G0 . A granularity G00 such that LG00 = Z+ can be obtained by using G00 =
0
Subset
1 (G )
Note that with the relabeling process some information is lost: for example, if G is
a labeled aligned subgranularity of H and G 6= H, then, after the relabeling, G is not a
319

fiBettini, Mascetti & Wang

^

-9 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25

H
-3

-2

-1

-2

-1

0

1

2

1

2

3

4

5

4

5

6

7

8

7

8

9

10

G1
10

G2
-3

-1

0

-1

0

2

3

2

3

5

6

5

6

8

9

8

9

G
-3

-2

1

4

7

10

G
-1

2

5

8

G
-2

1

4

7

10

Figure 12: Set operations example
labeled aligned subgranularity of H. The lost information is semantically meaningful in the
calendar algebra, and therefore the relabeling must be performed only when the granularity
will not be used as an operator in an algebraic operation.
Let G be a labeled granularity, i and j integers with i  LG s.t. G(i) 6= . The
relabeling operation Relabelji (G) generates a full-integer labeled granularity G0 by relabeling
G(i) as G0 (j) and relabel the next (and previous) granule of G by the next (and previous,
respectively) integer. More formally, for each integer k, if k = j, then let G0 (k) = G(i),
and otherwise let G0 (k) = G(i0 ) where G(i0 ) is the |j  k|-th granule of G after (before,
respectively) G(i). If the required |j  k|-th granule of G does not exist, then let G0 (k) = .
Note the G0 is always a full-integer labeled granularity.
The relabeling procedure can be implemented in the periodic representation we adopted
by computing the value of lG0 . It is easily seen that once lG0 is known, the full characterization of G0 can be obtained with: PG0 = PG ; NG0 = RG0 = RG and LG0 =
{lG0 , lG0 + 1, . . . , lG0 + NG0  2, lG0 + NG0  1}. It is clear that the explicit representation of
the granules is not modified.
j
k
ilG
0
0
To compute lG consider the label i = i  NG  NG ; i0 represents the label of LG such
that i  i0 is a multiple of NG . jTherefore
it is clear that the label j 0  LG0 s.t. G0 (j 0 ) = G(i0 )
k
G
can be computed by j 0 = j  il
 NG0 . Finally lG0 is obtained with lG0 = j 0  || where
NG
 is the distance, in terms of number of granules of G, from G(lG ) to G(i0 ).
4
Example 13 Figure 13 shows an example of the Relabel operation: G0 = Relabel
 33 (G).
336
0
Since PG = 4and R
i = 33 
5 = 8
5
 G = 2 then PG0 = 4 and NG0 0 = 2. Moreover,
0 ) is the next granule of G
and j 0 = 4  336

2
=
6.
Since
l
=
6
and
i
=
8
then
G(i
G
5
after G(lG ). Then  = 1 and hence lG0 = 6  1 = 7. It follows that LG0 = {7, 6}.
Finally G0 (7) = G(6) and G0 (6) = G(8).

The GSTP constraint solver imposes that the first non-empty granule of any granularity
( included) is labeled with 1. Therefore, when using the relabeling operation for producing
320

fiMapping Calendar Expressions to Minimal Periodic Sets

Figure 13: Relabeling example
granularities for GSTP, the parameter j must be set to 1. The parameter i has to be equal
to the smallest label among those that identify granules of G covering granules of  that
are all labeled with positive values. By definition of lG , i = lG if min(blG cG ) > 0; otherwise
i is the next label of G after lG .
4.12 Complexity Issues
For each operation the time necessary to perform the three conversion steps, depends on
the operation parameters (e.g. the grouping factor m, in the Group operation) and on
the operand granularities (in particular the period length, the period label distance and the
number of granules in one period).
A central issue is that if an operand granularity is not the bottom granularity, then its
period is a function of the periods of the granularities that are the operands in the operation
that defines it. For most of the algebraic operations, in the worst case the period of the
resulting granularity is the product of the periods of the operands granularity.
For all operations, the first step in the conversion process can be performed in a
constant or logarithmic time. Indeed the formulas necessary to derive the period length and
the period label distance involve (i) standard arithmetic operations, (ii) the computation of
the Greatest Common Divisor and (iii) the computation of the least common multiple. Part
(i) can be computed in a constant time while (ii) and (iii) can be computed in a logarithmic
time using Euclids algorithm.
For some operations, the second step can be performed in constant time (e.g. Group,
Shift or Anchored-group) or in linear time (e.g. set operations). For the other operations it
is necessary to compute the set S of labels of a granularity G such that i  S G(i)  H(j)
where H is a granularity and j  LH (analogously if S is the set such that i  S G(i) 
H(j) or i  S (G(i)  H(j) 6= )). This computation needs to be performed once for each
P 0
granule i  PHG . The idea of the algorithm for solving the problem has been presented
in Section 4.2. Several optimizations can be applied to that algorithm, but in the worst
case (when H covers the entire time domain) it is necessary to perform a number of deG
operations linear in the period length of the resulting granularity. If an optimized data
structure is used to represent the granularities, the deG operation can be performed in
constant time 4 , then the time necessary to perform the second step is linear in the period
length of the resulting granularity (O(PG0 )).
The last step in the conversion process is performed in linear time with respect to the
number of granules in a period of G0 .
4. If a non-optimized data structure is used, deG requires logarithmic time.

321

fiBettini, Mascetti & Wang

The complexity analysis of the conversion of a general algebraic expression needs to
consider the composition of the operations and hence their complexity. Finally, relabeling,
can be done in linear time.
A more detailed complexity analysis is out of the scope of this work.

5. Minimal Representation and Experimental Results
In this section we address the problem of guaranteeing that the converted representation
is minimal in terms of the period length. As we will show in Example 14 the conversion
formulas proposed in this paper do not guarantee a minimal representation of the result and
it is not clear if conversion formulas ensuring minimality exist. Our approach is to apply a
minimization step in the conversion.
The practical applicability of the minimization step depends on the period length of the
representation that is to be minimized. Indeed, in our tests we noted that the minimization
step is efficient if the conversion formulas proposed in Section 4 are adopted, while it is
impractical when the conversion procedure returns a period that is orders of magnitude
higher than the minimal one as would be the case if conversion formulas were constructed
in a naive way.
5.1 Period Length Minimization
As stated in Section 2, each granularity can have different periodical representations and,
for a given granularity, it is possible to identify a set of representations that are minimal
i.e. adopting the smallest period length.
Unfortunately, the conversions do not always return a minimal representation, as shown
by Example 14.
Example 14 Consider a calendar that has day as the bottom granularity. We can define
week as week = Group7 (day); by applying the formulas for the Group operation we obtain
Pweek = 7 and Nweek = 1.
We can now apply the Altering-tick operation to add one day to every first week every
two weeks. Let this granularity be G1 = Alter21,1 (day, week); applying the formulas for the
Altering-tick operation we obtain PG1 = 15 and NG1 = 2.
We can again apply the Altering-tick operation to create a granularity G2 by removing
one day from every first granule of G1 every two granules of G1 : G2 = Alter21,1 (day, G1 ).
Intuitively, by applying this operation we should get back to the granularity week, however
using the formulas for the Altering-tick operation we obtain PG2 = 14 and NG2 = 2; Hence
G2 is not minimal.
In order to qualitatively evaluate how close to the minimal representations the results
of our conversions are, we performed a set of tests using an algorithm (Bettini & Mascetti,
2005) for minimality checking. In our experimental results the conversions of algebraic
expressions defining granularities in real-world calendars, including many user-defined nonstandard ones, always returned exactly minimal representations. Non-minimal ones could
only be obtained by artificial examples like the one presented in Example 14.
Although a non-minimal result is unlikely in practical calendars, the minimality of the
granularity representation is known to greatly affect the performance of the algorithms for
322

fiMapping Calendar Expressions to Minimal Periodic Sets

granularity processing, e.g., granularity constraint processing (Bettini et al., 2002a), calendar calculations (Urgun et al., 2007), workflow temporal support (Combi & Pozzi, 2003).
Hence, we considered an extension of the conversion algorithm by adding a minimization
step exploiting the technique illustrated by Bettini et al. (2005) to derive a minimal representation.
The choice of using only the conversion algorithm or the extended one with minimizations, should probably be driven by performance considerations. In Section 5.3 we report
the results of our experiments showing that generally it is advantageous to apply the minimization step. In our implementation, presented in Section 5.2, it is possible to specify if
the minimization step should be performed.
5.2 Implementation of the CalendarConverter Web Service
The conversion formulas presented in Section 4 have been implemented into the CalendarConverter web service that converts Calendar Algebra representations into the equivalent
periodical ones. More precisely, given a calendar in which granularities are expressed by Calendar Algebra operations, the service converts each operation into an equivalent periodical
representation.
The service first rewrites each calendar algebra expression in order to express it only
in terms of the bottom granularity. For example, if the bottom granularity is hour, the
expression Monday = Select-down11 (day, week) is changed to
Monday = Select-down11 (Group24 (hour), Group7 (Group24 (hour)))
Then, Procedure 1 is run for each granularitys expression. The idea is that the periodical
representation of each subexpression is recursively computed starting from the expressions
having the bottom granularity as operand. Once each operand of a given operation has been
converted to periodical representation, the corresponding formula presented in Section 4 is
applied. We call this step the ConvertOperation procedure.
A trivial optimization of Procedure 1 consists in caching the results of the conversions
of each subexpression so that it is computed only once, even if the subexpression appears
several times (like Group24 (hour) in the above Monday definition).
5.3 Experimental Results
Our experiments address two main issues: first, we evaluate how the conversion formulas
impact on the practical applicability of the conversion procedure and, second, we evaluate
how useful is the minimization step.
For the first issue, we execute the conversion procedure with two different sets of conversion formulas and compare the results. The first set is laid out in Section 4. The other,
that is less optimized, is taken from the preliminary version of this paper (Bettini et al.,
2004).
Table 1 shows that when converting calendars having granularities with small minimal
period length (first two rows), using the formulas in Section 4 improves the performance
by one order of magnitude; However, conversions and minimizations are almost instantaneous with both approaches. On the contrary, when the minimal period length is higher,
323

fiBettini, Mascetti & Wang

Procedure 1 ConvertExpression
 Input: a calendar algebra expression ex; a boolean value minimize that is set to
true if the minimization step is to be executed;
 Output: the periodical representation of ex;
 Method:
1:
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:

if (ex is the bottom granularity) then
return the periodical representation of the bottom granularity
end if
operands := 
for (each operand op of ex) do
add ConvertExpression(op, minimize) to operands;
end for
result :=ConvertOperation(ex.getOperator(), operands)
if (minimize) then
minimize the periodical representation of result
end if
return result;

Table 1: Impact of the conversion formulas on the performance of the conversion and minimization procedures (time in milliseconds).

Calendar
Period
Bot
1 year
day
4 years
day
1 year
hour
4 years
hour
100 years day

Section 4 formulas
Conv. Min. Tot.
4
2
6
7
2
9
9
2
11
16
4
20
127
9 136

Less optimized formulas
Conv.
Min.
Tot.
62
32
94
76
55
131
2,244
126,904
129,148
4,362
908,504
912,866
3,764 1,434,524 1,438,288

(last three rows) the time required to minimize the periodical representation is up to five
orders of magnitude larger if the formulas proposed by Bettini et al. (2004) are used; as
a consequence, the entire conversion may require several minutes while, using the formulas
presented in Section 4, it still requires only a fraction of a second. If the period length is
even larger, the conversion procedure is impractical if the formulas presented by Bettini et
al. (2004) are used, and indeed in our experiments we did not obtain a result in less than
thirteen hours.
For the second issue, we perform a set of three experiments. In the first one we compare
the performance of the conversion procedure with the performance of the minimization step.

324

fiMapping Calendar Expressions to Minimal Periodic Sets

In the experiment we consider the case in which the conversion procedure produces minimal
representations. In this case the minimization step is always an overhead since it cannot
improve the performance of the conversion procedure.
Figure 14 shows the result of the experiment. Four calendars are considered, each one
containing a set of granularities of the Gregorian calendar. The four calendars differs in the
values of two parameters: the bottom granularity (it is second for cal-1 and cal-3 while it
is minute for cal-2 and cal-4) and the period in which leap years and leap years exceptions
are represented (it is 1, 4, 100 and 400 years for cal-1, cal-3, cal-2 and cal-4 respectively);
As a consequence, the minimal period length of the granularities month and year is about
3  107 for cal-1, 5  107 for cal-2, 108 for cal-3 and 2  108 for cal-4.

Figure 14: Impact of minimization over conversion; minimal conversions case.
As can be observed in Figure 14, the ratio between the time required to perform the
conversions and the time required for the minimization step varies significantly from a
minimum of 3% for cal-4 to a maximum of 23% for cal-3. The reason is that the complexity
of the conversion procedure is mainly affected by the period length of the granularity having
the largest period length. On the other hand, the complexity of the minimization step is
affected also by other features of the granularities such as their internal structure and the
number of integers that can divide at the same time the period label distance, the period
length and the number of granules in one period; For more details see (Bettini & Mascetti,
2005).
In the second experiment we consider the case in which the conversion procedure produces a non-minimal representation for a granularity in the input calendar; in this case it is
possible to benefit from the minimization step. For example, suppose that a granularity G
is converted and that it is then used as an argument of another Calendar Algebra operation
that defines a granularity H. The time required to compute the periodical representation
of H strongly depends on the period length of G; If the period length of G is reduced by
the execution of the minimization step, the conversion of H can be executed faster.
We produced this situation using a technique similar to the one of Example 14; we
created Calendar Algebra definitions of the Gregorian calendar in which the granularity
day is converted into a granularity having a non-minimal representation. Figure 15 shows
the performance obtained converting the same granularities that were used in Figure 14.
325

fiBettini, Mascetti & Wang

The difference was that in this case the definition of the granularity day is such that, after
the conversion procedure, its period is twice as large as the minimal one (i.e., 48 hours or
2880 minutes or 172800 seconds depending on the bottom granularity that is used). It can
be easily seen that in this case the use of the minimization step can improve the performance
of the entire algorithm. Indeed, when the minimization step is performed, the conversion
procedure requires about one half of the time that is required when no minimization is
performed.

Figure 15: Impact of minimization over conversion; non-minimal case.
In the third experiment we evaluate the impact of the minimal representation on the
performance of applications involving intensive manipulations of granularities. In the test we
use the GSTP solver as such an application; it computes solutions of temporal constraints
with granularities. A description of the architecture of the GSTP system is provided in
Section 6.1.
Figure 16 shows our experiments performed on four temporal constraint networks with
granularities. The four networks differs in the number of variables, in the number of constraints and in the granularities used to express the constraints. The networks labeled as
non-minimal use granularities definitions that are obtained with a technique similar to
the one used in Example 14, and have a period that is twice as large as the minimal one.
Figure 16 shows that the use of minimal representations greatly improves the performance of the GSTP solver. Indeed in our experiments the ratio between the time required
to solve the network using a non-minimal representation and a minimal one is between
three and five. Moreover, the more time required to solve the network, the greater the
improvement obtained using the minimal representation; this means that for very complex
temporal networks we expect the improvement to be even higher.
Considering the results of our experiments, we conclude that, in general, it is advisable
to perform the minimization step. In particular, it is very advantageous in the specific case
of GSTP, based on the following considerations: i) the time required to perform the minimization step is only a fraction of the time required to perform the conversion procedure, ii)
the conversions are performed off-line in most cases, with respect to granularity processing,
and conversion results are cached for future use, and iii) the period length strongly influ-

326

fiMapping Calendar Expressions to Minimal Periodic Sets

Figure 16: Impact of minimal representations on the performance of the GSTP solver.
ences the GSTP processing time that is in most cases much longer than the time needed
for conversion.

6. Applications
In this section we complement the motivations for this work with a sketch of the applications
enabled by the proposed conversion. Firstly we describe the GSTP system, as an example
of applications involving intensive manipulation of time granularities. GSTP is used to
check the consistency and to find solutions of temporal constraint satisfaction problems
with granularities5 ; It has also been applied to check the consistency of inter-organizational
workflow models (Bettini, Wang, & Jajodia, 2002b). Then, we discuss the use of Calendar
Algebra to define new granularities that may later be part of the input of reasoning services,
such as GSTP.
6.1 The GSTP System
The GSTP system has been developed at the University of Milan with the objective of
providing universal access to the implementation of a set of algorithms for multi-granularity
temporal constraint satisfaction (Bettini et al., 2002a). It allows the user to specify binary
constraints of the form Y  X  [m, n]G where m and n are the minimum and maximum
values of the distance from Y to X in terms of granularity G. Variables take values in the
positive integers, and unary constraints can be applied on their domains. For example, the
constraint: Event2 should occur 2 to 4 business days after the occurrence of Event1 can be
modeled by OccE2  OccE1  [2, 4]BDay. This problem is considered an extension of STP
(Dechter, Meiri, & Pearl, 1991) to multiple and arbitrary granularities. To our knowledge,
GSTP is the only available system to solve this class of temporal constraint satisfaction
problems.
Figure 17 shows the general architecture of the GSTP system. There are three main
modules: the constraint solver; the web service, which enables external access to the solver;
5. For a detailed description of the system, see (Bettini et al., 2005).

327

fiBettini, Mascetti & Wang

and a user interface that can be used locally or remotely to design and analyze constraint
networks.

Figure 17: The GSTP Architecture
The constraint solver is the C implementation of the ACG algorithm which has been
proposed by Bettini et al. (2002a), and it runs on a server machine. Following the approach of Bettini et al. (2002a), the solver uses the representation of granularities based on
periodical sets. This representation makes it possible to efficiently compute the core operations on granularities that are required to solve the constraint satisfaction problem. These
operations involve, for example, the union and the intersection of periodical sets. While
we cannot exclude that these operations may be computed in terms of alternative low level
representations, it seems much harder to obtain similar results if a high level representation,
such as Calendar Algebra, is used.
The second module of the system is the Web Service that defines, through a WSDL
specification, the parameters that can be passed to the constraint solver, including the
XML schema for the constraint network specification.
The third module is a remote Java-based user interface, which allows the user to easily
edit constraint networks, to submit them to the constraint solver, and to analyze results. In
particular, it is possible to have views in terms of specific granularities, to visualize implicit
constraints, to browse descriptions of domains, and to obtain a network solution. Fig. 18
shows a screenshot from the interface.
6.2 Defining New Granularities
While the GSTP solver can handle arbitrary granularities, new granularities must be added
by editing their explicit periodical representation. This is true in general for any multi328

fiMapping Calendar Expressions to Minimal Periodic Sets

Figure 18: The GSTP User Interface
granularity reasoning service based on a low-level representation of granularities, and it is
a painful task when the granularities have a large period. For example, in the experimental
results illustrated in Figure 16, we used a representation of the granularity month that
considers leap years and leap years exceptions in a period of 400 years. In this case, the
users have to specify the representation of 4800 granules i.e., the number of months in 400
years.
Because the period length of real world granularities is generally high, a graphical interface does not help if it only supports the user to individually select the explicit granules. An
effective solution requires the use of implicit or explicit operations on granules. Among the
various proposals, Calendar Algebra provides the richest set of such operators. A question
arises: is the definition of granularities in terms of Calendar Algebra really simpler than the
specification of the periodical representation? Calendar Algebra does not seem to be user
friendly: the exact semantics of each operator may not be immediate for an inexperienced
user and some time is required in order to learn how to use each operator.
In practice, we do not think that it is reasonable to ask an unexperienced user to
define granularities by writing Calendar Algebra expressions. Nevertheless, we do think
that Calendar Algebra can be used by specialized user interfaces to guide the user when
specifying granularities. In this sense, we believe that Calendar Algebra plays the same
role that SQL does in the definition of databases queries. Similarly to Calendar Algebra,
SQL is an abstraction tool that can be directly exploited in all its expressive power by an
advanced user, but can also be used by a less experienced user through a graphical user
interface, possibly with a reduced expressiveness.
As mentioned above, in the case of periodical representations, graphical user interfaces
are not sufficient for making the specification of new granularities practical. On the contrary, in the case of Calendar Algebra, user interfaces can strongly enhance the usability
of Calendar Algebra, making its practical use possible also for the definition of involved
granularities. There are at least two reasons for this difference. Firstly, the main difficulty
of Calendar Algebra is the understanding of the semantics of the operators and the choice
of the most appropriate one for a given task. An effective user interface can hide the existence of the algebraic operators to the user showing only how the operators modify existing

329

fiBettini, Mascetti & Wang

(a) Step 1.

(b) Step 2.

(c) Step 3.

Figure 19: A 3-steps wizard for visually defining a granularity using Calendar Algebra
granularities (i.e., the semantics of the operators). Secondarily, Calendar Algebra allows
the compact definition of granularities. This is due to the fact that the Calendar Algebra
operations are specifically designed to reflect the intuitive ways in which users define new
granularities.
Example 15 shows how a graphical user interface can be effectively used to define a new
granularity in terms of Calendar Algebra expression.
Example 15 This example shows how a graphical user interface can be used to support the
user in the definition of the granularity final as the set of days, each one corresponding to
330

fiMapping Calendar Expressions to Minimal Periodic Sets

the last Monday of every academic semester. We assume that the granularities Monday and
academicSemester have already been defined. The graphical user interface that we use in
this example is a wizard that guides the user step by step. In the first step (Figure 19(a)) the
user chooses the kind of operation he wants to perform. In the second step (Figure 19(b))
the user can provide more details about how he wants to modify the operand granularity
(Monday, in the example). The results of this choice is a Calendar Algebra expression that
is shown in the third step (Figure 19(c)); in this last window the user can also give a name
to the granularity that has been defined.
6.3 The Global Architecture

Figure 20: Integration of GSTP and CalendarConverter web services
Figure 20 shows a possible architecture for the integration of GSTP, the interface for
new granularity definitions and the CalendarConverter web service. A granularity repository
collects the Calendar Algebra definitions. Upon request by the GSTP system definitions are
converted in low-level representation by the CalendarConverter web service to be efficiently
processed. Clearly, caching techniques can be used to optimize the process.

7. Related Work
Several formalisms have been proposed for symbolic representation of granularities and
periodicity. Periodicity and its application in the AI and DB area have been extensively
investigated (Tuzhilin & Clifford, 1995; Morris, Shoaff, & Khatib, 1996; Kabanza, Stevenne,
& Wolper, 1990; Ladkin, 1986). Regarding symbolic representation, it is well known the
formalism proposed by Leban et al. (1986), that is based on the notion of collection, and
it is intended to represent temporal expressions occurring in natural language. A collection
is a structured set of time intervals where the order of the collection gives a measure of
the structure depth: an order 1 collection is an ordered list of intervals, and an order n
(n > 1) collection is an ordered list of collections having order n  1. Two operators,
331

fiBettini, Mascetti & Wang

called slicing and dicing are used to operate on collections by selecting specific intervals
or sub-collections, and by further dividing an interval into a collection, respectively. For
example, Weeks:during:January2006 divides the interval corresponding to January2006
into the intervals corresponding to the weeks that are fully contained in that month. This
formalism has been adopted with some extensions by many researchers in the AI (Koomen,
1991; Cukierman & Delgrande, 1998) and Database area (Chandra, Segev, & Stonebraker,
1994; Terenziani, 2003). In particular, the control statements if-then-else and while
have been introduced by Chandra et al. (1994) to facilitate the representation of certain
sets of intervals. For example, it is possible to specify: the fourth Saturday of April if not
an holiday, and the previous business day otherwise.
As for the deductive database community, a second influential proposal is the slice
formalism introduced by Niezette et al. (1992). A slice denotes a (finite or infinite) set of not
necessarily consecutive time intervals. For example, the slice all.Years + {2,4}.Months
+ {1}.Days . 2.Days denotes a set of intervals corresponding to the first 2 days of February
and April of each year.
A totally different approach is the calendar algebra described by Ning et al. (2002), and
considered in this paper. The representation is based on a rich set of algebraic operators
on periodic sets as opposed to slicing and dicing over nonconvex intervals.
None of the above cited papers provide a mapping to identify how each operator changes
the mathematical characterization of the periodicity of the argument expressions. The
problem of finding these mappings is not trivial for some operators.
In (Bettini & Sibi, 2000) the expressive power of the algebras proposed by Leban et
al. (1986) and Niezette et al. (1992) is compared and an extension to the first is proposed
in order to capture a larger set of granularities. Since the periodical representation is
used to compare expressiveness, a mapping from calendar expressions in those formalisms
to periodical representations can be found in the proofs of that paper. However, since
minimality is not an issue for the purpose of comparing expressiveness, in many cases the
mapping returns non-minimal representations.
Regarding alternative approaches for low-level representation, we already mentioned
that the ones based on strings (Wijsen, 2000) and automata (Dal Lago, Montanari, &
Puppis, 2003; Bresolin et al., 2004) may be considered as an alternative for the target of
our conversion. As a matter of fact, an example of the conversion of a Calendar Algebra
expression into a string based representation can be found in (Dal Lago & Montanari,
2001). A complete conversion procedure appeared during the revision process of this paper
in the PhD Dissertation by Puppis (2006). The aim of the conversion is to prove that the
granspecs formalism, used to represent granularities in terms of automata, has at least the
same expressiveness as the Calendar Algebra. Hence, obtaining minimal representations was
not the goal. Moreover, in their case minimization is not in terms of the period length, but in
terms of the automaton size and automaton complexity. About the complexity of reasoning,
given an automaton M , the worst case time complexity of the operations analogous to our up
and down depends linearly on ||M ||, a value computed from M itself and called complexity
of M . In this sense ||M || has the same role of our period length (P ), even if a precise
relationship between the two values is hard to obtain. In our approach we compute up in
logarithmic time with respect to P and down in linear time with respect to the dimension
of the result (that is bounded by P ). Other operations, like checking for equivalence, seem
332

fiMapping Calendar Expressions to Minimal Periodic Sets

to be more complex using automata (Bresolin et al., 2004). Techniques for minimization
in terms of automaton complexity are presented by Dal Lago et al. (2003), and the time
complexity is proved to be polynomial, even if the exact bound is not explicitly given. In
3
our approach, the worst case time complexity for the minimization is O(P 2 ) (Bettini &
Mascetti, 2005). Overall, the automata approach is very elegant and well-founded, but,
on one side it still misses an implementation in order to have some experimental data to
compare with, and on the other side only basic operations have been currently defined;
it would be interesting to investigate the definition on that formalism of more complex
operations like the ones required by GSTP.

8. Conclusion and Future Work
We have presented an hybrid algorithm that interleaves the conversion of Calendar Algebra
subexpressions into periodical sets with the minimization of the period length. We have
proved that the algorithm returns set-based granularity representations having minimal
period length, which is extremely important for the efficiency of operations on granularities. Based on the technical contribution of this paper, a software system is being developed
allowing users to access multi-granularity reasoning services by defining arbitrary time granularities with a high-level formalism. Our current efforts are mainly devoted to completing
and refining the development of the different modules of the architecture shown in Section 6.3.
As a future work, we intend to develop effective graphical user interfaces to support the
definition of Calendar Algebra expressions in a user friendly way. Example 15 described one
of the possible interfaces. Another open issue is how to convert a periodical representation
of a granularity into a user friendly Calendar Algebra expression. This conversion could
be useful, for example, to present the result of a computation performed using the periodical
representation. However, a naive conversion may not be effective since the resulting calendar
algebra expression could be as involved as the periodical representation from which it is
derived. For example, a conversion procedure is presented by Bettini et al. (2000) to prove
that the Calendar Algebra is at least as expressive as the periodical representation; however,
the resulting Calendar Algebra expression is composed by a number of Calendar Algebra
operations that is linear in the number of granules that are in one period of the original
granularity. On the contrary, an effective conversion should generate Calendar Algebra
expressions that are compact and easily readable by the user. This problem is somehow
related to the discovery of calendar-based association rules (Li, Ning, Wang, & Jajodia,
2001). Finally, we intend to investigate the usage of the automaton-based representation
as a low-level granularity formalism. It would be interesting to know whether, using this
representation, it is possible to compute the same operations that can be computed with
the periodical representation and if any performance gain could be achieved.

Acknowledgments
We thank the anonymous referees for their useful comments and suggestions. The work of
Bettini and Mascetti was partially supported by Italian MIUR InterLink project N.II04C0EC1D.
The work of Wang was partially supported by the US NSF grant IIS-0415023.

333

fiBettini, Mascetti & Wang

Appendix A. Proofs
A.1 Transitivity of the Periodically Groups Into Relationship
In order to prove the correctness of the conversions of algebraic expressions into periodical
sets, it is useful to have a formal result about the transitivity of the periodically groups into
relation. In addition to transitivity of / , Theorem 1 also says something about period
length values.
Theorem 1 Let G and H be two unbounded granularities such that G is periodic in terms
of the bottom granularity (i.e.,  / G) and H is periodic in terms of G (i.e., G / H). Let
G be the period length and the period label distance of H in terms of granules of
PHG and NH
G, and NG the period label distance of G in terms of . Then, if PHG = NG for some
positive integer , then H is periodic in terms of the bottom granularity (i.e.,  / H) and
PH = PG .
G

Proof. Since
Sni by hypothesis G / H and PH = NG , i if H(i) =
G
NH ) = r=0 G(ir + NG ). This can be also written as follows:
if

Sni

r=0 G(ir ),

then H(i +

H(i) = G(i0 )  ...  G(ini )

(1)

G
H(i + NH
) = G(i0 + NG )  ...  G(ini + NG )

(2)

then   Ns.t.:

Since  / G, if


G(ij ) =

ij
[

(ij,k )

(3)

(ij,k + PG )

(4)

k=0

then


G(ij + NG ) =

ij
[

k=0

This can be clearly extended using NG instead of NG .


G(ij + NG ) =

ij
[

(ij,k + PG )

(5)

k=0

Rewriting (1) substituting G(ij ) according to (3) and rewriting (2) substituting G(ij +
NG ) according to (5), we obtain:
if H(i) = (i0,0 )  . . .  (i0,i0 )  . . .  (ini ,0 )  ...  (ini ,in )
i
|
{z
}
|
{z
}
G(i0 )

G(ini )

334

fiMapping Calendar Expressions to Minimal Periodic Sets

G ) = (i
then H(i + NH
0,0 + PG )  . . .  (i0,i0 + PG )  . . .
{z
}
|
G(i0 +NG )

 (ini ,0 + PG )  . . .  (ini ,in + PG )
i
|
{z
}
G(ini +NG )

Hence the second condition of Definition 5 is satisfied. The third one is always satisfied for
unbounded granularities. The first one is satisfied too; in fact since G / H with a period
G , then for each label i of H, i + N G is a label of H. Hence, by definition
label distance of NH
H
G.
of periodically-groups-into  / H with PH = PG and NH = NH

A.2 Proof of Proposition 1
A.2.1 Part 1
From the definition of the Group operation, for all i  N:
0

G (i) =

im
[

G(j) = G(im  m + 1)  . . .  G(im) = G()  . . .  G( + m  1)

j=(i1)m+1

with  = im  m + 1. Furthermore, k  N:
(i+k)m

[

0

G (i + k) =

G(j) = G(im + km  m + 1)  . . .  G(im + km) =

j=(i+k1)m+1

= G( + km)  . . .  G( + km + m  1)
Hence,
0

0

If G (i ) =

m1
[

0

m1
[

0

G( + r) then G (i + k) =

r=0

G( + r + km).

(6)

r=0

G
This holds for each k. If we use k = GCMN(m,N
(note that k  N), then all the hypotheses
G)
of Theorem 1 are satisfied: (i)  / G (by hypothesis); (ii) G / G0 (since G / G0 , LG0 = Z,
mNG
NG
and (6) holds); (iii) PGG0 = GCM
(m,NG ) (since we use k = GCM (m,NG ) and, from (6) we

know that PGG0 = km). Therefore, by Theorem 1,  / G0 with PG0 =
NG0 =

mPG
GCM (m,NG )

NG
GCM (mNG ) .

A.2.2 Part 2
From the definition of the Group

j

k

j

G0





lG 1
+1
m
0
operation, G (i) =

By definition of l, we need to show that G0



lG  1
+1
m



lG 1
m

k 
+1 m

[

=
j=

335

S
= tj=b G(j) with b  lG  t.
Sim
j=(i1)m+1 G(i) ; hence:

j

lG 1
m

k
m+1

G(j)

and

fiBettini, Mascetti & Wang

We prove the thesis showing that (1)
lG .
(1) Since

j

lG 1
m

k



lG 1
m ,

j

lG 1
m

lG 1
G
 lm
m
lG 1[(lG 1)mod m]
G
 lm
1; it
m

(2) First we prove that
prove that

hence
k
j

j

lG 1
m

k

m+1  lG and that (2)

j

lG 1
m

k


+ 1 m 

k

 m + 1  lG
j
k
 1. Since lGm1 =

lG 1[(lG 1)mod m]
m

we have to

is equivalent to thej inequality
 [(lG  1)mod m] 
k

m + 1 that is true since (lG  1)mod m  m  1. Since
k

j
lG 1
+
1
 m  lG .
m

lG 1
m



lG
m

 1 it is trivial that

A.3 Proof of Proposition 2
A.3.1 Part 1
Proof sketch
We show that G2 / G0 with PGG02 = NG2 and then we apply Theorem 1 to obtain the thesis.
In particular we use


PG2  NG1
NG2  m
 = lcm NG1 , m,
,
GCD(PG2  NG1 , PG1 ) GCD(NG2  m, |k|)
and


PG2
  PG1  NG2
k

=
+
NG1  PG2
m
NG2
S
S
such that, for each i, if j, k : G0 (i) = kr=0 G2 (j + r), then G0 (i + ) = kr=0 G2 (j + r +
NG2 ).
Given an arbitrary granule G0 (i), we show that G0 (i + ) is the union of granules that
can be obtained by adding NG2 to the index of each granule of G2 contained in G0 (i). Note
that i +   LG0 since G0 is full-integer labeled. In order to show that this is correct we
consider the way granules of G0 are constructed by definition of altering-tick. More precisely,
we compute the difference between the label b0i+ of the first granule of G2 included in
G0 (i + ) and the label b0i of the first granule of G2 included in G0 (i); we show that this
difference is equal to the difference between the label t0i+ of the last granule of G2 included
in G0 (i + ) and the label t0i of the last granule of G2 included in G0 (i). This fact together
with the consideration that G2 is a full-integer labeled granularity, leads to the conclusion
that G0 (i) and G0 (i + ) have the same number of granules. It is then clear that the above
computed label differences are also equal to the difference between the label of an arbitrary
n-th granule of G2 included in G0 (i + ) and the label of the n-th granule
of G2 included
S
in G0 (i). If this difference is b0i+  b0i , then we have: if j, k : G0 (i) = kr=0 G2 (j + r), then

S
G0 (i + ) = kr=0 G2 j + r + b0i+  b0i . By showing that b0i+  b0i is a multiple of NG2
the thesis follows.
Proof details


336

fiMapping Calendar Expressions to Minimal Periodic Sets

Si
Sti+
Assume G1 (i) = tj=b
G2 (j) and G1 (i + ) = j=b
G2 (j). We need to compute
i
i+
0
0
bi+  bi . From the definition of the the altering-tick operation:
b0i

=

 

k
 bi + il
m


bi +

 il 
m

if i =

 il 
m

m + l,
(7)


+ 1 k otherwise.

and
b0i+

=




k
 bi+ + i+l
m


bi+ +

 i+l 
m

if i +  =

 i+l 
m

m + l,
(8)


+ 1 k otherwise.

 




Note that if i = il
m + l, then i +  = i+l
Indeed, i+l
+l =
m
m  m + l. 
m  m
 il  

il

il
+
m+l
and,
since

is
a
multiple
of
m,
then
+
m+l
=
+
m+
m
m
m
m
m
m

il
l =  + m m + l.
Hence, to compute b0i+  b0i we should consider two cases:
b0i+  b0i =



 
 

k  bi  il
k if i = il
m+l
 bi+ + i+l
m
m
m


bi+ +

 i+l 
m

(9)


 

+ 1 k  bi  il
m + 1 k otherwise.

In both cases (again considering the fact that  is a multiple of m):
b0i+  b0i = (bi+  bi ) +

k
m

(10)

We are left to compute bi+ bi , i.e., the distance in terms of granules of G2 , between G2 (bi )
Sti+
Si
G2 (j),
G2 (j) and G1 (i + ) = j=b
and G2 (bi+ ). Since, by hypothesis, G1 (i) = tj=b
i
i+
then the first granule of  making G2 (bi ) and the first granule of  making G1 (i) is the
same granule. The same can be observed for the first granule of  making G2 (bi+ ) and
the first granule of  making G1 (i + ). More formally:
min bbi cG2 = min bicG1
and
min bbi+ cG2 = min bi + cG1
Hence, we have:
min bbi+ cG2  min bbi cG2 = min bi + cG1  min bicG1

(11)

We have shown that the difference between the index of the first granule of  making
G2 (bi+ ) and the index of the first granule of  making G2 (bi ) is equal to the difference
between the index of the first granule of  making G1 (i + ) and the index of the first
granule of  making G1 (i). Then, we need to compute the difference between the index
of the first granule of  making G1 (i + ) and the index of the first granuleSof  making
G1 (i). Since  / G1 and  is a multiple of NG1 , for each i, if j,  : G1 (i) = r=0 (j + r),
337

fiBettini, Mascetti & Wang

S
P
P
then G1 (i + ) = r=0 (j + NGG1 ). Hence, this difference has value NGG1 , and for what
1
1
shown above this is also the value of the difference between the index of the first granule
of  making G2 (bi+ ) and the index of the first granule of  making G2 (bi ). Then, since
P
 / G2 with period length PG2 and since NGG1 is a multiple of PG2 , we have that, if:
1

(j)  G2 (i)
then:
(j +
Thus, bi+  bi =
Reconsidering 10:

  PG1
  PG1  NG2
)
)  G2 (i +
NG1
NG1  PG2

PG1 NG2
NG1 PG2 .

b0i+  b0i =

  PG1  NG2
k
+
.
NG1  PG2
m
P

N

Analogously we can compute t0i+  t0i = NGG1PGG2 + k
m .
1
2
0
0
0
0
Thus, bi+  bi = ti+  ti ; hence ti+  bi+ = ti  bi . Since G2 is a full integer labeled
granularity, then G0 (i) and G0 (i + ) are formed by the same number of granules.
St0i+
St0i
0
0
0
0
Since we now know G0 (i+) = j=b
G2 (j) = j=b
0 G2 (j +(bi+ bi )) and (bi+ bi )
0
i

i+

/ G0 ,

PGG02

PG1 NG2
NG1 PG2

is a multiple of NG2 , we have G2
=
and  / G2 . Hence, all the
hypothesis of Theorem 1 hold, and its application leads the thesis of this proposition.
A.3.2 Part 2
0

Since G2 partitions G0 (see table 2.2 of (Bettini et al., 2000)), then (1) dlG2 eG
G2 is al+
ways defined and (2) min({n  N |i  LG2 s.t. (n)  G2 (i)}) = min({m  N+ |j 
LG0 s.t. (m)  G0 (j)}). Therefore lG0 is the label of the granule of G0 that covers the
0
granule of G2 labeled with lG2 ; by definition of de operation, lG0 = dlG2 eG
G2 .
A.4 Proof of Proposition 3
A.4.1 Part 2
By definition of the Shift operation, G0 (i) = G(im). Hence G0 (lG +m) = G(lG +mm) =
G(lG ).
A.5 Proof of Proposition 4
A.5.1 Part 1
The thesis will follow from the application of Theorem 1. Indeed, we know that  / G2 and
we show that G2 / G0 with PGG02 multiple
 and  s.t., for
S of NG2 . For this we0 need to identify
S
0
each i, if there exists s(i) s.t. G (i) = js(i) G2 (j), then G (i + ) = js(i) G2 (j + NG2 ).
lcm(P

,P

)N

G1 G2
G1
Consider an arbitrary i  N and  =
. By definition of the combining
PG1
S
S
0
0
operation, we have G (i) = js(i) G2 (j) and G (i + ) = js(i+) G2 (j) with

s(i) = {j  LG2 | =
6 G2 (j)  G1 (i)}
338

fiMapping Calendar Expressions to Minimal Periodic Sets

and
s(i + ) = {j  LG2 | =
6 G2 (j)  G1 (i + )} .
We now show that s(i + ) is composed by all and only the elements of s(i) when the
lcm(PG1 ,PG2 )NG2
quantity 0 =
is added. For this purpose we need:
PG
2

j  s(i) (j + 0 )  s(i + )

(12)


 j + 0  s(i + ) j  s(i)

(13)

and

About 12, note that if j  s(i), then G2 (j)  G1 (i). Since  / G2 , if
G2 (j) =

k
[

(jr )

r=0

then
0



G2 j +  =

k
[

(jr + lcm(PG1 , PG2 ))

(14)

r=0

Since G1 (i)  G2 (j) =

Sk

r=0 (jr ),

and since  / G1 , then

G1 (j + ) 

k
[

(jr + lcm(PG1 , PG2 ))

(15)

r=0

From 14 and 15 we derive G1 (i + )  G2 (j + 0 ), and hence (j + 0 )  s(i + ).
Analogously
validitySof 13; Hence, for each i, if there exists s(i) s.t.
S can be proved the
0
0
G (i) = js(i) G2 (j), then G (i + ) = js(i) G2 (j + 0 ). Hence, considering the fact that
G2 / G0 , we can conclude G2 / G0 . Finally, since PGG02 is a multiple of NG2 , by Theorem 1
we obtain the thesis.
A.5.2 Part 2
Let

P 0
s(i) 6= }
LeG0 = {i  LGG1 |e
P

0

P

0

where i  LGG1 se(i) = {j  LGG2 | =
6 G2 (j)  G1 (i)};
We show that LeG0 = LG0 by proving that: (1) LeG0  LG0 and (2) LeG0  LG0 .
(1) Suppose by contradiction that exists k  LG0 \ LeG0 . Since k  LG0 and since G0
is derived by the Combine operation,
then q  LG2 |G2 (q)  G1 (k). By definition of the
S
0
Combine operation G (k) = js(k) G2 (j); since q  s(k), then G2 (q)  G0 (k). Hence (a)
q  LG2 |G2 (q)  G0 (k).
P 0
Moreover, since k 6 LeG0 , then se(k) = ; therefore @j  LGG2 |G2 (j)  G1 (k). By
definition of the Combine operation it is easily seen that G0  G1 . Using this and the
P 0
previous formula, we derive that (b) @j  LGG2 |G2 (j)  G0 (k).
339

fiBettini, Mascetti & Wang

P

0

From (a) and (b) it follows that q  LG2 \ LGG2 |G2 (q)  G0 (k). We show that this
leads to a contradiction.
P 0
P 0
P 0
P 0
Since q 6 LGG2 and labels of LGG2 are contiguous (i.e., @i  LG2 \ LGG2 s.t. min(LGG2 ) <
P

P

0

P

0

0

i < max(LGG2 )), then q < min(LGG2 ) or q > max(LGG2 ). We consider the first case, the
proof for the second is analogous.
P 0
P 0
If q < min(LGG2 ) then max(bqcG2 ) < 1 (otherwise q  LGG2 ).
0
0
Let be  = min(bmin(LG0 )cG ). Since k  LG0 , then   bkcG .
If   1, then G0 (k)  G2 (q) =  contradicting G0 (k)  G2 (q).
If  < 1, then G0 (lG0 )  (0) and we show that lG0  LeG0 . Indeed, by definition of
P 0
P 0
Combine, j  LGG2 |G2 (j)  G0 (LG0 ). Since G0  G1 we also have j  LGG2 |G2 (j) 
G1 (LG0 ); hence j  se(lG0 ) and then lG0  LeG0 .
Since 0  G0 (lG0 ) and max(bqcG2 )  0, then max(bqcG2 ) <  (otherwise G2 (q) 
0
0
G0 (lG0 )). Therefore, since min(bkcG )  , then bqcG2  blG0 cG = , in contradiction with
G2 (q)  G0 (k).
e
(2) Suppose by contradiction that k  LeG0 \ LG0 . Since k  LeG0 , by definition of L,
P

P

0

0

k  LGG1 and se(k) 6= ; Therefore, by definition of se, j  LGG2 |G2 (j)  G1 (k).
P

0

Since j  LGG2 , by definition of L, h with 0 < h  PG0 s.t. dheG2 = j. Since
0
G2 (j)  G1 (k), then dheG1 = k. By definition of the combine operation, dheG = k.
0
Moreover, since 0 < h  PG0 , by definition of L, dheG = k  LG0 , contradicting the
hypothesis.
A.6 Proof of Proposition 5
A.6.1 Part 1
The thesis will follow from the application of Theorem 1. Indeed, we show that G1 / G0 with
PGG01 multiple of NG1 . For this we need to identify  and  s.t., for each i, if there exists s(i)
S
S
lcm(PG1 ,PG2 )NG2
s.t. G0 (i) = js(i) G1 (j), then G0 (i+) = js(i) G1 (j +NG1 ). Let  =
.
PG2
0
S
S
0
(i+) 1
1
G1 (j) and G0 (i + ) = j=i+ G1 (j)
By definition of anchored grouping, G0 (i) = ij=i
where i0 is the first label of G2 after i and (i + )0 is the first label of G2 after i + . By
periodicity of G2 , (and since  is a multiple of NG2 ) the difference between the label of
the granule following G2 (i + ) and the label of the granule following G2 (i) is
Sk. More
0
0
0
0
0
formally, (i + )  i = , hence (i + ) = i + . Then, for each i, if G (i) = j=i G1 (j),
S 0 +1
S 0 1
then G0 (i + ) = ij=i+
G1 (j) = ij=i
G1 (j + ). By this result and considering G1 / G0 ,
we conclude G1 / G0 with PGG01 = . Note that by Proposition 9, NG1 =
PGG01

is a multiple of . Then, by Theorem 1, we have the thesis.

A.6.2 Part 2
Let

(
LeG0 =

P

0

if lG2 = lG1 ,
LGG2 ,
PG0
0
{lG2 }  LG2 , otherwise,

340

PG1 NG2
PG2 ,

hence

fiMapping Calendar Expressions to Minimal Periodic Sets

0
where lG
is the greatest among the labels of LG2 that are smaller than lG2 . We show that
2
e
LG0 = LG0 by proving that (1) LeG0  LG0 and (2) LG0  LeG0 .
P 0
(1) Suppose by contradiction that k  LeG0 \ LG0 . Then, since k  LeG0 , then k  LGG2
0 .
or k = lG
2
P

P

0

0

If k  LGG2 , then, by definition of LGG2 , h with 0 < h  PG0 s.t. dheG2 = k. By
S 0 1
definition of Anchored-group, G0 (k) = kj=k
G1 (j) where k 0 is the first label of G2 after
0
k. Therefore G (k)  G1 (k). Since G2 is a labeled aligned subgranularity of G1 and since
0
k  LG2 , then k  LG1 and G1 (k) = G2 (k). Hence G0 (k)  G2 (k). It follows that dheG = k
and therefore, by definition of L, k  LG0 in contrast with the hypothesis.
0 , then, by definition of L
eG0 , lG 6= lG . Therefore, since G2 is a labeled aligned
If k = lG
2
1
2
0 <l
;
then
h
with
0 < h < min(blG2 cG2 ) s.t. dheG1 = lG1 .
<
l
subgranularity of G1 lG
G
G
2
1
2
S
lG2 1
0 ) =
0
Since, by definition of Anchored-group, G0 (lG
G1 (j) and since lG
< lG1 < lG2 ,
j=l0
2
2
G2

0

0 )  G (l ). Hence dheG = l0
0
then G0 (lG
1 G1
G2 and therefore, by definition of L, lG2 = k  LG0
2
in contrast with the hypothesis.
P 0
(2) Suppose by contradiction that k  LG0 \ LeG0 . If k  LGG2 then, by definition of
LeG0 , k  LeG0 , in contrast with the hypothesis.
P 0
P 0
P 0
P 0
P 0
If k 
/ LGG2 , since @q  LG2 \LGG2 s.t. min(LGG2 )  q  max(LGG2 ), then k > max(LGG2 )
P

0

or k < min(LGG2 ).

P

0

If k > max(LGG2 ) then, by definition of L, min(bkcG2 ) > PG0 . Since G2 is a labeled
aligned subgranularity of G1 then G2 (k) = G1 (k) and hence min(bkcG1 ) > PG0 . Since
S 0 1
0
G0 (k) = kj=k
G1 (j) then min(bkcG ) > PG0 in contrast with the hypothesis k  LG0 .
P

0

0 , k < l0
0
If k < min(LGG2 ) then, by definition of lG
G2 or k = lG2 .
2
0
0
If k < lG
then, let k 0 be the next label of G2 after k. Since k < lG
then, by definition
2
2
0
0
0
0
0
G
lG2 , k  lG2 . By definition of lG2 then max(blG2 c 2 )  0. Since G2 is a labeled aligned
0 ) = G (l0 ); therefore max(bl0 cG1 )  0. Since G0 (k) =
subgranularity of G1 then G1 (lG
2 G2
G2
2
Sk0 1
0
0
G0 )  0 in contrast with the hypothesis
G
(j)
and
k

l
,
follows
that
max(bkc
1
j=k
G2
k  LG0 .
SlG2 1
0
0 ) =
0
Finally if k = lG
then G0 (lG
G1 (j). Since k = lG
 LG0 then h with
j=l0
2
2
2
0

G2

0 . Since G0 is the composition of granules of G , dheG1 is
0 < h  PG0 s.t. dheG = lG
1
2
P

0

defined. Let q = dheG1 . By definition of L, q  LGG1 and therefore q  lG1 . Since, by
0
0
definition of Anchored-group, G0 is the composition of granules of G1 and since dheG = lG
2
S
lG2 1
0 ). Therefore since G0 (l0 ) =
and dheG1 = q, then G1 (q)  G0 (lG
G
(j)
then
q
<
l
1
G2 .
G2
j=l0
2
G2

0
It follows that lG1  q < lG2 and hence lG1 6= lG2 . By definition of LeG0 , lG
= k  LeG0 in
2
contrast with the hypothesis.

A.7 Selecting operations
The selecting operations have a common part in the proof for the computation of the period
length and the period label distance.

341

fiBettini, Mascetti & Wang

lcm(P

,P

)N

G1 G2
G1
Let be  =
. The proof is divided into two steps: first we show that for
PG1
each select operation if i  LG0 then i +   LG0 (details for Select-down, Select-up and
Select-by-intersect operations can be found below). The second step is the application of
Theorem 1. Indeed, for each Select operation, the following holds: i  LG0 G0 (i) = G1 (i);
this implies G1 / G0 . From step 1 follows that i +   LG0 , hence G0 (i + ) = G1 (i + ).
By this result and considering G1 / G0 , we conclude that G1 / G0 with PGG01 =  which is a
multiple of NG1 by definition. Then, by Theorem 1 we have the thesis.

A.8 Proof of Proposition 6
A.8.1 Part 1
See Section A.7.
We prove that if   LG0 then 0 =  +   LG0 .
By definition of the select-down operation, if   LG0 then i  LG2 s.t.   lk (S(i))
where S(i) is an ordered set defined as follows: S(i) = {j  LG1 | =
6 G1 (j)  G2 (i)}.
In order to prove the thesis we need to show that i0  LG2 |0  lk (S(i0 )). Consider
i0 = i+

lcm(PG1 PG2 )NG2
PG2

we will note that i0  LG2 (this is trivially derived from the periodicity

of G2 ). To prove that 0  lk (S(i0 )) we show that S(i0 ) is obtained from S(i) by adding 
to each of its elements.
Indeed note that from periodicity of G1 , j  S(i) if:
j
[

(jr )

(16)

(jr + lcm(PG1 PG2 ))

(17)

G1 (j) =

r=0

then:
G1 j

0



=

j
[
r=0

Since j  S(i), G1 (j)  G2 (i) then, from (16), G2 (i) 
periodicity of G2 :

0



G2 i 

j
[

(jr + lcm(PG1 PG2 ))

Sj

r=0 (jr ).

Moreover, from

(18)

r=0

Since (17) and (18), G2 (i0 )  G1 (j 0 ); hence j  S(i), j 0 = (j + )  S(i0 ). Analogously
we can prove that j 0  S(i0 ), j = (j 0  )  S(i).
Thus S(i0 ) is obtained from S(i) by adding  to each of its elements; therefore if j  S(i)
has position n in S(i), so j 0  S(i0 ) has position n in S(i0 ). Hence it is trivial that if  has
position between k and k + l  1 in S(i), then 0 has position between k and k + l  1 in
S(i0 ). Hence if   LG0 , then 0  LG0 .

342

fiMapping Calendar Expressions to Minimal Periodic Sets

A.8.2 Part 2
Let
LeG0 =

o
[ n
P 0
a  A(i)|a  LGG1 ;
P 0

iLGG
2

where i  LG2 :

6 G1 (j)  G2 (i)}) .
A(i) = lk ({j  LG1 | =

We show that LeG0 = LG0 by proving that (1) LeG0  LG0 and (2) LeG0  LG0 .
P 0
(1)Suppose by contradiction that q  LeG0 \ LG0 . By definition of LeG0 , q  LGG1 ;
therefore h with 0 < h  PG0 s.t. dheG1 = q. Moreover, by definition of LeG0 and by
definition of Select-down, LeG0  LG0 hence q  LG0 . Since, by definition of Select-down
0
G0 (q) = G1 (q), then dheG = q; hence, by definition of L, q  LG0 in contradiction with
hypothesis.
(2)Suppose by contradiction that q  LG0 \ LeG0 . Since q  LG0 then, by definition of
Select-down
6 G1 (j)  G2 (i)})
i  LG2 s.t. q  lk ({j  LG1 | =
therefore, by definition of A(i), q  A(i).
0
Since q  LG0 then h with 0 < h  PG0 s.t. dheG = q. By definition of Select-down,
P 0
G0 (q) = G1 (q), then dheG1 = q and therefore q  LGG1 . Moreover, since G1 (q)  G2 (i),
P

P

0

0

P

0

then dheG2 = i and therefore i  LGG2 . Since q  A(i), q  LGG1 and i  LGG2 then, by
definition of LeG0 , q  LeG0 , in contrast with the hypothesis.
A.9 Proof of Proposition 7
A.9.1 Part 1
See Section A.7. We prove that if i  LG0 then i +   LG0 . From the periodicity of G1 ,
i+  LG1 (this is trivially derived from the periodicity of G1 ). Hence we only need to show
that j 0  LG2 | =
6 G2 (j)  G1 (i + ). Since i  LG0 then j  LG2 | =
6 G2 (j)  G1 (i).
From the periodicity of G2 , if:
G2 (j) =

j
[

(jr )

(19)

r=0

then:

 [
j
lcm(PG1 PG2 )NG2
G2 j +
=
(jr + lcm(PG1 PG2 ))
PG2
r=0

Moreover, from the (19) and since G1 (i)  G2 (j):
G1 (i) 

j
[
r=0

From the periodicity of G1 :
343

(jr )

(20)

fiBettini, Mascetti & Wang

G1 (i + ) 

j
[

(jr + lcm(PG1 PG2 ))

(21)

r=0


From (20) and (21) follows that G1 (i + )  G2 j +

lcm(PG1 PG2 )NG2
PG2



, that is the thesis.

A.9.2 Part 2
Let

P 0
6 G2 (j)  G1 (i)};
LeG0 = {i  LGG1 |j  LG2 s.t.  =

We show that LeG0 = LG0 by proving that (1) LeG0  LG0 and (2) LeG0  LG0 .
P 0
(1) Suppose by contradiction that k  LeG0 \ LG2 . Since k  LeG0 , then k  LGG1 ;
therefore h with 0 < h  PG0 s. t. dheG1 = k. Moreover, by definition of LeG0 and
by definition of Select-down, LeG0  LG0 hence q  LG0 . Since, by definition of Select-up,
0
G0 (k) = G1 (k), then dheG = k. Hence, by definition of L, k  LG0 , in contrast with the
hypothesis.
(2) Suppose by contradiction that k  LG0 \ LeG0 . Since k  LG0 , then h with 0 <
0
h  PG0 s.t. dheG = k. Since, by definition of Select-up, G0 (k) = G1 (k), then dheG1 = k;
P 0
Therefore, by definition of L, k  LGG1 . Moreover, since k  LG0 and LG0  LG0 , by
definition of the Select-up operation, then j  LG2 s.t.  6= G2 (j)  G1 (k). Hence by
definition of LeG0 , k  LeG0 , in contradiction with hypothesis.
A.10 Proof of Proposition 8
A.10.1 Part 1
See Section A.7. We prove that if   LG0 , then 0 =  +   LG0 .
By definition of the select-by-intersect operation, if   LG0 , then i  LG2 :  
lk (S(i)) where S(i) is an ordered set defined as follows: S(i) = {j  LG1 |G1 (j)G2 (i) 6= }.
In order to prove the thesis we need to show that i0  LG2 : 0  lk (S(i0 )). Consider
i0 = i +

lcm(PG1 PG2 )NG2
note that i0  LG2 (this
PG2
prove that 0  lk (S(i0 )) we show that

is trivially derived from the periodicity of

G2 ). To
S(i0 ) is obtained from S(i) by adding  to
each of its elements.
Indeed note that j if j  S(i), then G1 (j)  G2 (i) 6= . Hence l  Z : (l)  G1 (j)
and (l)  G2 (i). From the periodicity of G1 , G1 (j + )  (l + lcm(PG1 PG2 )). From
the periodicity of G2 , G2 (i0 )  (l + lcm(PG1 PG2 )). So G1 (j + )  G2 (i0 ) 6= , therefore
j  S(i), (j + )  S(i0 ).
Analogously we can prove that j 0  S(i0 ), (j 0  )  S(i). Hence S(i0 ) is obtained from
S(i) by adding  to each of its elements. Therefore, if j  S(i) has position n in S(i), then
j +   S(i0 ) has position n in S(i0 ); hence if j has position between k and k + l  1 in S(i),
then also j +  has position between k and k + l  1 in S(i0 ) and so j +   LG0 .
A.10.2 Part 2
The proof is analogous to the ones of Proposition 6.
344

fiMapping Calendar Expressions to Minimal Periodic Sets

A.11 Set Operations
A.11.1 Proof of Proposition 9
Given the periodical granularities H and G with G label aligned subgranularity of H, we
NH
G
prove that N
PG = PH . The thesis is proved by considering the common period length of H
and G i.e. Pc = lcm(PG , PH ).
Let NG0 be the difference between the label of the ith granule of one period of G and
the label of the ith granule of the next period, considering Pc as the period length of G.
0 is defined.
Analogously NH
S
S
By periodicity of G, if G(i) = kr=0 (ir ) then G(i + NG0 ) = kr=0 (ir + Pc ); since G is
S
an aligned subranularity of H, i  LH H(i) = G(i) = kr=0 (ij ) and, since H is periodic,
Sk
0 )=
0
0
H(i + NH
r=0 (ij + Pc ); from which we can easily derive that i + NG = i + NH , hence
0
0
NG = NH .
0 = N 0 , then
From the definition of Pc , ,   N s. t. PH = PG . Moreover, since NH
G
PG
PH
=
.
NH = NG . Therefore N
NG
H
A.11.2 Property used in the proofs for set operations
lcm(P

,P

)N

lcm(P

,P

)N

G1 G2
G1
G1 G2
G2
Let 1 be
and 2 be
. Since G1 and G2 are aligned subgranPG1
PG2
ularity of a certain granularity H, from Proposition 9 we can easily derive that 1 = 2 .

A.12 Proof of Proposition 10
A.12.1 Part 1
Union. Let 1 be

lcm(PG1 ,PG2 )NG2
lcm(PG1 ,PG2 )NG1
and 2 be
. The thesis
PG1
PG2
S
Sk
0
0
LG0 if, G (i) = r=0 (ir ), then G (i + ) = kr=0 (ir

will be proved by

+ lcm(PG1 , PG2 ))
showing that i 
0
with  = 1 = 2 . Since LG = LG1  LG2 , two cases will be considered:
S
 i  LG1 G0 (i) = G1 (i) = kr=0 (ir ). From the periodicity of G1 , G1 (i + 1 ) =
Sk
Sk
0
r=0 (ir + lcm(PG1 , PG2 )); hence G (i + 1 ) =
r=0 (ir + lcm(PG1 , PG2 )).
S
 i  LG2  LG1 G0 (i) = G2 (i) = kr=0 (ir ). From the periodicity of G2 , G2 (i + 2 ) =
Sk
Sk
0
r=0 (ir + lcm(PG1 , PG2 )); hence G (i + 2 ) =
r=0 (ir + lcm(PG1 , PG2 )).
S
Since 1 = 2 , then i  LG0 if G0 (i) = kr=0 (ir ), then G0 (i + 1 ) = G0 (i + 2 ) =
Sk
r=0 (ir + lcm(PG1 , PG2 )). Hence, by definition of / , we have the thesis.
S
Intersect. i  LG0 = LG1  LG2 G0 (i) = G1 (i) = kr=0 (ir ). From the periodicity of
G1 and G2 , i + 1  LG1 eSi + 2  LG2 ; since 1 = 2 , then i + 1  LG0 . Moreover
G0 (i + 1 ) = G1 (i + 1 ) = kr=0 (ir + lcm(PG1 , PG2 )); hence, by the definition of / , we
have the thesis.
S
Difference. i  LG0 = LG1  LG2 G0 (i) = G1 (i) = kr=0 (ir ). Since i  LG1 from the
periodicity of G1 i + 1  LG1 . Since i 
/ LG2 , from the periodicity of G2 , i + 2 
/ LG2
(if it would exists i + 2  LG2 , from periodicity of G2 would exists i  LG2 that is
0
0
not
Sk possible for hypothesis). Hence i + 1  LG . Moreover G (i + 1 ) = G1 (i + 1 ) =
r=0 (ir + lcm(PG1 , PG2 )); hence, by the definition of / , we have the thesis.
345

fiBettini, Mascetti & Wang

A.12.2 Part 2
P 0
P 0
Let LeG0 = LGG1  LGG2 .
We show that LeG0 = LG0 by proving that (1) LeG0  LG0 and (2) LeG0  LG0 .
P 0
(1) Suppose by contradiction that k  LeG0 \ LG0 . Since k  LeG0 then k  LGG1 or
P

0

P

P

0

0

P

0

k  LGG2 . Suppose that k  LGG1 (the proof is analogous if k  LGG2 ). Since k  LGG1 , then
0
 0 < h < PG0 s.t. dheG = k. Since, by definition of the Union operation G0 (k) = G1 (k),
0
then dheG = k. Hence, by definition of L, k  LG0 in contrast with the hypothesis.
(2) Suppose by contradiction that k  LG0 \ LeG0 . Since k  LG0 , then, by definition of
0
L,  0 < h < PG0 s.t. dheG = k. Moreover, by definition of the Union operation, k  LG1
P 0
P 0
or k  LG2 . Suppose that k  LGG1 (the proof is analogous if k  LGG2 ). By definition of the
P

0

Union operation, G0 (k) = G1 (k) therefore dheG1 = k and so, by definition of L, k  LGG1 .
e k  LeG0 in contradiction with the hypothesis.
Hence, by definition of L,

References
Bettini, C., & Mascetti, S. (2005). An efficient algorithm for minimizing time granularity
periodical representations. In Proc. of the 12th International Symposium on Temporal
Representation and Reasoning (TIME), pp. 2025. IEEE Computer Society.
Bettini, C., Mascetti, S., & Pupillo, V. (2005). A system prototype for solving multigranularity temporal csp. In Recent Advances in Constraints, Revised selected papers from the Workshop on Constraint Solving and Constraint Logic Programming
(CSCLP), volume 3419 of Lecture Notes in Computer Science, pp. 142156. Springer.
Bettini, C., Mascetti, S., & Wang., X. S. (2004). Mapping calendar expressions into periodical granularities. In Proc. of the 11th International Symposium on Temporal
Representation and Reasoning (TIME), pp. 96102. IEEE Computer Society.
Bettini, C., & Sibi, R. D. (2000). Symbolic representation of user-defined time granularities.
Annals of Mathematics and Artificial Intelligence, 30 (1-4), 5392.
Bettini, C., Wang, X. S., & Jajodia, S. (2000). Time Granularities in Databases, Data
Mining, and Temporal Reasoning. Springer.
Bettini, C., Wang, X. S., & Jajodia, S. (2002a). Solving multi-granularity temporal constraint networks. Artificial Intelligence, 140 (1/2), 107152.
Bettini, C., Wang, X. S., & Jajodia, S. (2002b). Temporal reasoning in workflow systems.
Distributed and Parallel Databases, 11 (3), 269306.
Bresolin, D., Montanari, A., & Puppis, G. (2004). Time granularities and ultimately periodic
automata. In Proc. of the 9th European Conference on Logics in Artificial Intelligence
(JELIA) volume 3229 of Lecture Notes in Computer Science, pp. 513525. Springer.
Chandra, R., Segev, A., & Stonebraker, M. (1994). Implementing calendars and temporal
rules in next generation databases. In Proc. of the 10th International Conference on
Data Engineering (ICDE), pp. 264273. IEEE Computer Society.
Combi, C., Franceschet, M., & Peron, A. (2004). Representing and reasoning about temporal
granularities. Journal of Logic and Computation, 14 (1), 5177.
346

fiMapping Calendar Expressions to Minimal Periodic Sets

Combi, C., & Pozzi, G. (2003). Temporal conceptual modelling of workflows. In Proc. of the
22nd International Conference on Conceptual Modeling (ER) volume 2813 of Lecture
Notes in Computer Science, pp. 5976. Springer.
Cukierman, D., & Delgrande, J. P. (1998). Expressing time intervals and repetition within
a formalization of calendars. Computational Intelligence, 14, 563597.
Dal Lago, U., & Montanari, A. (2001). Calendars, time granularities, and automata. In Proc.
of the 7th International Symposium on Spatial and Temporal Databases (SSTD),
volume 2121 of Lecture Notes in Computer Science, pp. 279298. Springer.
Dal Lago, U., Montanari, A., & Puppis, G. (2003). Towards compact and tractable
automaton-based representations of time granularities. In Proc. of the 8th Italian
Conference on Theoretical Computer Science (ICTCS), volume 2841 of Lecture Notes
in Computer Science, pp. 7285. Springer.
Dechter, R., Meiri, I., & Pearl, J. (1991). Temporal constraint networks. Artificial Intelligence, 49 (1-3), 6195.
Kabanza, F., Stevenne, J. M., & Wolper, P. (1990). Handling infinite temporal data. In Proc.
of the 9th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database
Systems (PODS), pp. 392403. ACM Press.
Koomen, J. (1991). Reasoning about recurrence. International Journal of Intelligent Systems, 6, 461496.
Ladkin, P. B. (1986). Primitives and units for time specification. In Proc. of the 5th National
Conference on Artificial Intelligence (AAAI), pp. 353359. Morgan Kaufmann.
Leban, B., McDonald, D., & Forster, D. (1986). A representation for collections of temporal
intervals. In Proc. of the 5th National Conference on Artificial Intelligence (AAAI),
pp. 367371. Morgan Kaufmann.
Li, Y., Ning, P., Wang, X. S., & Jajodia, S. (2001). Discovering calendar-based temporal
association rules. In Proc. of the 8th International Symposium on Temporal Representation and Reasoning (TIME), pp. 111118. IEEE Computer Society.
Montanari, A. (1996). Metric and Layered Temporal Logic for Time Granularity. Ph.D.
thesis, ILLC Dissertation Series 1996-02, University of Amsterdam.
Morris, R., Shoaff, W., & Khatib, L. (1996). Domain-independent temporal reasoning with
recurring events. Computational Intelligence, 12, 450477.
Niezette, M., & Stevenne, J. M. (1992). An efficient symbolic representation of periodic
time. In Proc. of the first International Conference on Information and Knowledge
Management (CIKM) volume 725 of Lecture Notes in Computer Science, pp. 161168.
Springer.
Ning, P., Wang, X. S., & Jajodia, S. (2002). An algebraic representation of calendars.
Annals of Mathematics and Artificial Intelligence, 36 (1-2), 538.
Puppis, G. (2006). Automata for Branching and Layered Temporal Structures. Ph.D. thesis,
Universita degli Studi di Udine.
Terenziani, P. (2003). Symbolic user-defined periodicity in temporal relational databases.
IEEE Transactions of Knowledge and Data Engineering, 15 (2), 489509.
347

fiBettini, Mascetti & Wang

Tuzhilin, A., & Clifford, J. (1995). On periodicity in temporal databases. Information
Systems, 20 (8), 619639.
Urgun, B., Dyreson, C. E., Snodgrass, R. T., Miller, J. K., Soo, M. D., Kline, N., & Jensen,
C. S. (2007). Integrating multiple calendars using TauZaman. Software-Practice
Experience, to appear.
Wijsen, J. (2000). A string-based model for infinite granularities. In Spatial and Temporal
Granularity: Papers from the AAAI Workshop. Technical Report WS-00-08, pp. 916.
AAAI Press.

348

fi