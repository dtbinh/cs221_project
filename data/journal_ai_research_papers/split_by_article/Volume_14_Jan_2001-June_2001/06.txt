Journal of Artificial Intelligence Research 14 (2001) 167{203

Submitted 12/99; published 04/01

What's in an Attribute?
Consequences for the Least Common Subsumer

Ralf Kusters

kuesters@ti.informatik.uni-kiel.de

Institut f
ur Informatik und Praktische Mathematik
Christian-Albrechts-Universit
at zu Kiel
24098 Kiel
Germany

Alex Borgida

borgida@cs.rutgers.edu

Department of Computer Science
Rutgers University
Piscataway, NJ 08855
USA

Abstract

Functional relationships between objects, called \attributes", are of considerable importance in knowledge representation languages, including Description Logics (DLs). A study
of the literature indicates that papers have made, often implicitly, different assumptions
about the nature of attributes: whether they are always required to have a value, or whether
they can be partial functions. The work presented here is the first explicit study of this
difference for subclasses of the Classic DL, involving the same-as concept constructor.
It is shown that although determining subsumption between concept descriptions has the
same complexity (though requiring different algorithms), the story is different in the case
of determining the least common subsumer (lcs). For attributes interpreted as partial
functions, the lcs exists and can be computed relatively easily; even in this case our results
correct and extend three previous papers about the lcs of DLs. In the case where attributes
must have a value, the lcs may not exist, and even if it exists it may be of exponential size.
Interestingly, it is possible to decide in polynomial time if the lcs exists.
1. Introduction

Knowledge representation systems based on Description Logics (DLs) have been the subject of continued attention in Artificial Intelligence, both as a subject of theoretical studies
(Borgida, 1994; Baader, 1996; Baader & Sattler, 2000; Giacomo & Lenzerini, 1996; Calvanese, Giacomo, & Lenzerini, 1999b) and in applications (Artale, Franconi, Guarino, &
Pazzi, 1996; Brachman, McGuinness, Patel-Schneider, & Borgida, 1999; McGuinness &
Patel-Schneider, 1998). More impressively, DLs have found applications in other areas involving information processing, such as databases (Borgida, 1995; Calvanese, Lenzerini,
& Nardi, 1999), semi-structured data (Calvanese, Giacomo, & Lenzerini, 1998, 1999a),
information integration (Calvanese, Giacomo, Lenzerini, Nardi, & Rosati, 1998; Borgida
& Kusters, 2000), as well as more general problems such as configuration (McGuinness
& Wright, 1998) and software engineering (Borgida & Devanbu, 1999; Devanbu & Jones,
1997). In fact, wherever the ubiquitous term \ontology" is used these days (e.g., for proc 2001 AI Access Foundation and Morgan Kaufmann Publishers. All rights reserved.

fi steres, Borgida
Ku

viding the semantics of web/XML documents), DLs are prime contenders because of their
clear semantics and well-studied computational properties.
In Description Logics, one takes an object-centered view, where the world is modeled as
individuals, connected by binary relationships (here called roles), and grouped into classes
(called concepts). For those more familiar with Predicate Logic, objects correspond to
constants, roles to binary predicates, and concepts to unary predicates. In every DL system,
the concepts of the application domain are described by concept descriptions that are built
from atomic concepts and roles using the \constructors" provided by the DL language. For
example, consider a situation where we want a concept describing individual cars that have
had frequent (at least 10) repairs, and also record the fact that for cars, their model is the
same as their manufacturer's model. Concepts can be thought of as being built up from
(possibly nested) simpler noun-phrases, so the above concept, called Lemon in the sequel,
might be captured as the conjunction of
(objects that are Cars)
(things all of whose model values are in concept Model)
(things all of whose madeBy values are in concept Manufacturer)
(things whose model value is the same as the model of the madeBy attribute)
(things with at least 10 repairs values)
(things all of whose repairs values are RepairReport).
Using the syntax of the classic language, we can abbreviate the above, while emphasizing
the term-like nature of descriptions and the constructors used in each:
(and Car
(all model Model)
(all madeBy Manufacturer)
(same-as (model) (madeBy  model))
(at-least 10 repairs)
(all repairs RepairReport))
So, for example, the concept term (at-least n p) has constructor at-least, and denotes
objects which are related by the relationship p to at least n other objects; in turn, (all p
C) has as instances exactly those objects which are related by p only to instances of C.
Finally, we present the same concept in a mathematical notation which is more succinct
and preferred in formal work on DLs:
Lemon := Car u
8model:Model u
8madeBy:Manufacturer u
madeBy # (model  madeBy) u
 10 repairs u
8repairs:RepairReport

Unlike preceding formalisms, such as semantic networks and frames (Quillian, 1968; Minsky,
1975), DLs are equipped with a formal semantics, which can be given by a translation into
168

fiWhat's in an Attribute?

first-order predicate logic (Borgida, 1994), for example. Moreover, DL systems provide their
users with various inference capabilities that allow them to deduce implicit knowledge from
the explicitly represented knowledge. For instance, the subsumption algorithms allow one to
determine subconcept-superconcept relationships: C is subsumed by D (C v D) if and only
if all instances of C are also instances of D, i.e., the first description is always interpreted
as a subset of the second description. For example, the concept Car obviously subsumes the
concept description Lemon, while (at-least 10 repairs) is subsumed by (at-least 8 repairs).
The traditional inference problems for DL systems, such as subsumption, inconsistency
detection, membership checking, are by now well-investigated. Algorithms and detailed
complexity results for realizing such inferences are available for a variety of DLs of differing
expressive power | see, e.g., (Baader & Sattler, 2000) for an overview.
1.1 Least Common Subsumer

The least common subsumer (lcs) of concepts is the most specific concept description subsuming the given concepts. Finding the lcs was first introduced as a new inference problem
for DLs by Cohen, Borgida, and Hirsh (1992). One motivation for considering the lcs is to
use it as an alternative to disjunction. The idea is to replace disjunctions like C1 t    t C
by the lcs of C1; : : : ; C . Borgida and Etherington (1989) call this operation knowledge-base
vivification. Although, in general, the lcs is not equivalent to the corresponding disjunction,
it is the best approximation of the disjunctive concept within the available language. Using
such an approximation is motivated by the fact that, in many cases, adding disjunction
would increase the complexity of reasoning.1
As proposed by Baader et al. (Baader & Kusters, 1998; Baader, Kusters, & Molitor,
1999), the lcs operation can be used to support the \bottom-up" construction of DL knowledge bases, where, roughly speaking, starting from \typical" examples an lcs algorithm
is used to compute a concept description that (i) contains all these examples, and (ii) is
the most specific description satisfying property (i). Baader and Kusters have presented
such an algorithm for cyclic ALN -concept descriptions; ALN is a relatively simple language allowing for concept conjunction, primitive negation, value restrictions, and number
restrictions. Also, Baader et al. (1999) have proposed an lcs algorithm for a DL allowing
existential restrictions instead of number restrictions.
Originally, the lcs was introduced as an operation in the context of inductive learning
from examples (Cohen et al., 1992), and several papers followed up this lead. The DLs
considered were mostly sublanguages of Classic which allowed for same-as equalities, i.e.,
expressions like (same-as (madeBy) (model  madeBy)). Cohen et al. proposed an lcs
algorithm for ALN and a language that allows for concept conjunction and same-as, which
we will call S . The algorithm for S was extended by Cohen and Hirsh (1994a) to CoreClassic, which additionally allows for value restrictions (see (Cohen & Hirsh, 1994b) for
experimental results). Finally, Frazier and Pitt (1996) presented an lcs algorithm for full
Classic.
n

n

1. Observe that if the language already allows for disjunction, we have lcs(C1 ; : : : ; Cn )  C1 t    t Cn . In
particular, this means that, for such languages, the lcs is not really of interest.

169

fi steres, Borgida
Ku

1.2 Total vs. Partial Attributes

In most knowledge representation systems, including DLs, functional relationships, here
called attributes (also called \features" in the literature), are distinguished as a subclass
of general relationships, at least in part because functional restrictions occur so frequently
in practice2 . In the above example, clearly madeBy and model are meant to be attributes,
thus making unnecessary number restrictions like (and (at-most 1 madeBy) (at-least
1 madeBy)). In addition, distinguishing attributes helps identify tractable subsets of DL
constructors: in Classic, coreferences between attribute chains (as in the above examples)
can be reasoned with eciently (Borgida & Patel-Schneider, 1994), while if we changed to
roles, e.g., allowed (same-as (repairs) (ownedBy  repairsPaidFor)), the subsumption problem becomes undecidable (Schmidt-Schau, 1989).
Whereas the distinction between roles and attributes in DLs is both theoretically and
practically well understood, we have discovered that another distinction, namely the one between attributes being interpreted as total functions (total attributes ) and those interpreted
as partial functions (partial attributes ), has \slipped through the cracks" of contemporary
research. A total attribute always has a value in \the world out there", even if we do not
know it in the knowledge base currently. A partial attribute may not have a value. This
distinction is useful in practice, since there is a difference between a car possibly, but not
necessarily, having a CD player, and the car necessarily having a manufacturer (which just
may not be known in the current knowledge base). The latter is modeled by defining the
attribute madeBy to be a total attribute. Note that with madeBy being a total attribute,
every individual in the world of discourse (not only cars) must have a filler for madeBy.
Since, however, no structural information is provided for fillers of madeBy of non-car individuals, all implications drawn about these fillers are trivial. Thus, making madeBy a total
attribute seems reasonable in this case. A car's CD player, on the other hand, should be
modeled by a partial attribute to express the fact that cars are not required to have a CD
player. To indicate that a particular car does have a CD player, one would have to add the
description (at-least 1 CDplayer).
1.3 New Results

As mentioned above, in conjunction with the same-as constructor, roles and attributes
behave very differently with respect to subsumption. The main objective of this paper is to
show that the distinction between total and partial attributes induces significantly different
behaviour in computing the lcs, in the presence of same-as. More precisely, the purpose of
this paper is twofold.
First, we show that with respect to the complexity of deciding subsumption there is no
difference between partial and total attributes. Borgida and Patel-Schneider (1994) have
shown that when attributes are total, subsumption of classic concept descriptions can
be decided in polynomial time. As shown in the present work, slight modifications of the
algorithm proposed by Borgida and Patel-Schneider suce to handle partial attributes.
2. Readers coming from the Machine Learning community should be aware of the difference between our
\attributes" (functional roles) and their \attributes", which are components of an input feature vector
that usually describes an exemplar.

170

fiWhat's in an Attribute?

Moreover, these modifications do not change the complexity of the algorithm. Thus, partial
and total attributes behave very similarly from the subsumption point of view.
Second, and this is the more surprising result of this paper, the distinction between
partial and total attributes does have a significant impact on the problem of computing the
lcs. Previous results on sublanguages of classic show that if partial attributes are used,
the lcs of two concept descriptions always exists, and can be computed in polynomial time.
If, however, only total attributes are involved, the situation is very different. The lcs need
no longer even exist, and in case it exists its size may grow exponential in the size of the
given concept descriptions. Nevertheless, the existence of the lcs of two concept descriptions
can be decided in polynomial time.
Specifically, in previous work (Cohen et al., 1992; Cohen & Hirsh, 1994a; Frazier &
Pitt, 1996) concerning the lcs computation in classic, constructions and proofs have been
made without realizing the difference between the two types of attributes. Without going
into details here, the main problem for lcs is that merely finite graphs have been employed,
making the constructions applicable only for the partial attribute case. In addition to fixing
these problems, this paper also presents the proper handling of inconsistent concepts in the
lcs algorithm for classic presented by Frazier and Pitt (1996).
Although our results about subsumption are not as intriguing, the proofs to show the
results on the lcs make extensive use of the corresponding subsumption algorithms, which
is one reason we present them beforehand in this paper.
Returning to the general differences between the cases of total and partial attributes,
one could say that the fundamental cause for the differences lies in the same-as constructor,
whose semantics normally requires that (i) the two chains of attributes each have a value,
and (ii) that these values coincide. In the case of total attributes, same-as obeys the principle
C v u # v implies C v u  w # v  w
where u,v, and w are sequences of total attributes, e.g., (madeBy  model), because condition
(i) is ensured by the total aspect of all the attributes. In the case of partial attributes, the
above implication does not hold, because w, and hence u  w, is no longer guaranteed to have
a value, implying that the same-as restriction may not hold. Clearly, this implication affects
the results of subsumption. As far as lcs is concerned, a certain graph (representing the lcs
of the two given concepts) may be infinite in the case of total attributes, thus jeopardizing
the existence of the lcs.
The more general significance of our result is that knowledge representation language
designers and users need to explicitly check at the beginning whether they deal with total or partial attributes because the choice can have significant effects. Although in some
situations total attributes are convenient, to guarantee the existence of attributes without
having to resort to number restrictions, our results show that they can have drawbacks.
All things considered, requiring all attributes to be total appears to be less desirable. Concerning classic, the technical results in this paper support the use of partial attributes
because these ensure the existence of the lcs and its computation in polynomial time as
well as the ecient decision of subsumption. Moreover, the current implementation of the
classic subsumption algorithm does not require major changes in order to handle partial
attributes.
171

fi steres, Borgida
Ku

The outline of this paper is as follows: In the following section, the basic notions necessary for our investigations are introduced. Then, in the two subsequent sections, subsumption and lcs computation in classic with partial attributes is investigated. More precisely,
in Section 3 we offer a subsumption algorithm for the sublanguage classic of classic,
which contains all main classic-constructors; in Section 4, we present an lcs algorithm
for classic concept descriptions, along the lines of that proposed by Cohen and Hirsh
(1994a), and formally prove its correctness, thereby resolving some shortcomings of previous
lcs algorithms, which did not handle inconsistencies properly. Finally, Section 5 covers the
central new result of this paper, i.e., the lcs computation in presence of total attributes.
For this section, we restrict our investigations to the sublanguage S of classic in order to
concentrate on the changes caused by going from partial to total attributes. Nevertheless,
we strongly conjecture that all the results proved in this section can easily be extended to
classic and classic using similar techniques as the one employed in the two previous
sections.
2. Formal Preliminaries

In this section, we introduce the syntax and semantics of the description languages considered in this paper and formally define subsumption and equivalence of concept descriptions.
Finally, the least common subsumer of concept descriptions is specified.
Definition 1 Let C , R, and A be disjoint finite sets representing the set of concept names,
the set of role names, and the set of attribute names. The set of all classic -concept
descriptions over C , R, and A is inductively defined as follows:
 Every element of C is a concept description (concept name, like Car).
 The symbol > is a concept description (top concept, denoting the universe of all
objects).
 If r 2 R is a role and n  0 is a nonnegative integer, then  n r and  n r are concept
descriptions (number restrictions, like  10 repairs).
 If C and D are concept descriptions, then C u D is a concept description (concept
conjunction).




If C is a concept description and r is a role or an attribute, then
description (value restriction, like 8madeBy:Manufacturer).

8r:C

is a concept

If k; h  0 are non-negative integers and a1 ; : : : ; a ; b1 ; : : : ; b 2 A are attributes, then
     a # b1      b is a concept description (same-as equality, like madeBy #
model  madeBy). Note that the two sequences may be empty, i.e., k = 0 or h = 0.
The empty sequence is denoted by ".
k

a1

k

h

h

Often we dispense with  in the composition of attributes. For example, the sequence
a1     a is simply written as a1    a . Moreover, we will use 8r1    r :C as abbreviation
of 8r1:8r2    8r :C , where we have 8":C in case n = 0, and this denotes C .
As usual, the semantics of classic is defined in a model-theoretic way by means of
interpretations.
k

n

k

n

172

fiWhat's in an Attribute?

Definition 2 An interpretation I consists of a nonempty domain I and an interpretation
function I . The interpretation function assigns extensions to atomic identifiers as follows:





The extension of a concept name E is some subset E I of the domain.
The extension of a role name r is some subset rI of I  I .

The extension of an attribute name a is some partial function aI from I to I , i.e.,
if (x; y1 ) 2 aI and (x; y2 ) 2 aI then y1 = y2 .
Given roles or attributes r , we use (r1    r )I to denote the composition of the binary
relations rI . If n = 0 then the result is "I , which denotes the identity relation, i.e., "I :=
f(d; d) j d 2 I g. For an individual d 2 I , we define rI (d) := fe j (d; e) 2 rI g. If the r 's
are attributes, we say that (r1    r )I is defined for d iff (r1    r )I (d) 6= ;; occasionally,
we will refer to (r1    r )(d)I as the image of d under (r1    r )I (d).
The extension C I of a concept description C is inductively defined as follows:
 >I := I ;
i

n

i

i

n

n

n

n

( n r)I := fd 2 I j cardinality(fe 2 I j (d; e) 2 rI g)  ng;
( n r)I := fd 2 I j cardinality(fe 2 I j (d; e) 2 rI g)  ng;
(C u D)I := C I \ DI ;
(8r:C )I := fd 2 I j rI (d)  C I g where r is a role or an attribute;
(a1    a # b1    b )I := fd 2 I j (a1    a )I and (b1    b )I are defined for d
and (a1    a )I (d) = (b1    b )I (d)g:
Note that in the above definition attributes are interpreted as partial functions. Since the
main point of this paper is to demonstrate the impact of different semantics for attributes,
we occasionally restrict the set of interpretations to those that map attributes to total
functions. Such interpretations are called t-interpretations and the attributes interpreted
in this way are called total attributes in order to distinguish them from partial ones.
We stress, as remarked in the introduction, that in the definition of (a1    a # b1    b )I ,
a1    a and b1    b must be defined on d in order for d to satisfy the same-as restriction.
Although this is the standard semantics for same-as equalities, one could also think of
relaxing this restriction. For example, the same-as condition might be specified to hold if
either both paths are undefined or both images are defined and have identical values. A
third definition might be satisfied if even just one of the paths is undefined. Each of these
definitions of the semantics of same-as might lead to different results. However, in this
paper we only pursue the standard semantics.
The subsumption relationship between concept descriptions is defined as follows.
Definition 3 A concept description C is subsumed by the concept description D (C v D
for short) if and only if for all interpretations I , C I  DI . If we consider only total
interpretations, we get t-subsumption: C v D iff C I  DI for all t-interpretations I .






k

h

k

h

k

h

k

k

h

t

173

h

fi steres, Borgida
Ku

Having defined subsumption, equivalence of concept descriptions is defined in the usual way:
 D if and only if C v D and D v C . T-equivalence C  D is specified analogously.
As already mentioned in the introduction, the main difference between partial and total
attributes with respect to subsumption is that u # v v u  w # v  w holds for all attribute
chains u; v; w, whereas it is not necessarily the case that u # v v u  w # v  w.
Finally, before introducing the lcs operation formally and concluding this section, we
comment on the expressive power of classic , since (syntactically) classic lacks some
common constructors. Although classic , as introduced here, does not contain the bottom
concept ? explicitly, it can be expressed by, e.g., ( 1 r) u ( 0 r). We will use ? as an
abbreviation for inconsistent concept descriptions. Furthermore, primitive negation, i.e.,
negation of concept names, can be simulated by number restrictions. For a concept name
E one can replace every occurrence of E by ( 1 r ) and the negation :E of E by ( 0 r )
where r is a new role name. Finally, for an attribute a the following equivalences hold:
( n a)  ? for n  2; ( 1 a)  (a # a); ( 0 a)  >; ( n a)  > for n  1; and
( 0 a)  (8a:?). These show that we do not lose any expressive power by not allowing
for number restrictions on attributes. Still, full classic is somewhat more expressive than
classic . This is mainly due to the introduction of individuals (also called nominals) in
classic. For the sake of completeness we give the syntax of the full classic language.3
This requires a further set, O, representing the set of individual names. Then we can define
two additional concept constructors
 fe1 ; :::; e g, for individuals e 2 O (enumeration as in fF all; Summer; Springg)
 p : e for a role or attribute p, and an individual e (fills as in currentSeason : Summer).
In a technical report, Kusters and Borgida (1999) extend some of the results presented in
this work to full classic, in the case when individuals have a non-standard semantics.
The least common subsumer of a set of concept descriptions is the most specific concept
subsuming all concept descriptions of the set:
Definition 4 The concept description D is the least common subsumer (lcs) of the concept
descriptions C1 ; : : : ; C (lcs(C1 ; : : : ; C ) for short) iff i) C v D for all i = 1; : : : ; n and ii)
for every D0 with that property D v D0 . Analogously, we define lcs (C1 ; : : : ; C ) using v
C

t

t

E

E

E

m

i

n

n

i

t

instead of v.

n

t

Note that the lcs of concept descriptions may not exist, but if it does, by definition it is
uniquely determined up to equivalence. In this sense, we may refer to the lcs.
In the following two sections, attributes are always interpreted as partial functions; only
in Section 5 do we consider total attributes.
3. Characterizing Subsumption in

classic

In this section we modify the characterization of t-subsumption for Classic, as proposed
by Borgida and Patel-Schneider (1994), to handle the case of partial attributes. We do
3. Even here we are omitting constructs dealing with integers and other so-called \host individuals", which
cannot have roles of their own and can only act as role/attribute fillers.

174

fiWhat's in an Attribute?

so in detail, because the tools used for deciding subsumption are intimately related to the
computation of lcs.
T-subsumption in Classic is decided by a multi-part process. First, descriptions are
turned into description graphs. Next, description graphs are put into canonical form, where
certain inferences are explicated and other redundancies are reduced by combining nodes
and edges in the graph. Finally, t-subsumption is determined between a description and a
canonical description graph.
In order to \inherit" the proofs, we have tried to minimize the necessary adjustments to
the specification in (Borgida & Patel-Schneider, 1994). For this reason, roughly speaking,
attributes are treated as roles unless they form part of a same-as equality. (Note that
attributes participating in a same-as construct must have values!) To some extent, this
will allow us to adopt the semantics of the original description graphs, which is crucial for
proofs. However, the two different occurrences of attributes, namely, in a same-as equality
vs. a role in a value-restriction, require us to modify and extend the definition of description
graphs, the normalization rules, and the subsumption algorithm itself.
In the following, we present the steps of the subsumption algorithm in detail. We start
with the definition of description graphs.
3.1 Description Graphs

Intuitively, description graphs reect the syntactic structure of concept descriptions. A
description graph is a labeled, directed multigraph, with a distinguished node. Roughly
speaking, the edges (a-edges ) of the graph capture the constraints expressed by same-as
equalities. The labels of nodes contain, among others, a set of so-called r-edges, which
correspond to value restrictions. Unlike the description graphs defined by Borgida and
Patel-Schneider, here the r-edges are not only labeled with role names but also with attribute
names. (We shall comment later on the advantage of this modification in order to deal with
partial attributes.) The r-edges lead to nested description graphs, representing the concepts
of the corresponding value restrictions.
Before defining description graphs formally, in Figure 1 we present a graph corresponding
to the concept description Lemon defined in the introduction. We use G(Manufacturer),
G(Model), as well as G(RepairReport) to denote description graphs for the concept names
Manufacturer, Model, and RepairReport. These graphs are very simple; they merely consist
of one node, labeled with the corresponding concept name. In general, such graphs can
be more complex since a value restriction like 8r:C leads to a (possibly complex) nested
concept description C .
Although number restrictions on attributes are not allowed, r-edges labeled with attributes, like model and madeBy, always have the restriction [0; 1] in order to capture the
semantics of attributes. Formally, description graphs, nodes, and edges are defined mutually
recursively as follows:
Definition 5 A description graph G is a tuple (N; E; n0 ; l), consisting of a finite set N of
nodes; a finite set E of edges (a-edges); a distinguished node n0 2 N (root of the graph);
and a function l from N into the set of labels of nodes. We will occasionally use the notation
G:N odes, G:Edges, and G:root to access the components N , E and n0 of the graph G.
175

fi steres, Borgida
Ku

f>g

madeBy

f>g

RepairReport)

G(

madeBy

repairs

model

[10; 1]

Model)

G(

model [0; 1]

fCar >g
;

madeBy [0; 1]

Manufacturer)

G(

Figure 1: A description graph for Lemon, where the large node is the root of the graph
An a-edge is a tuple of the form (n1 ; a; n2 ) where n1 , n2 are nodes and a is an attribute
name.
A label of a node is defined to be ? or a tuple of the form (C; H ), consisting of a finite
set C of concept names (the atoms of the node) and a finite set H of tuples (the r-edges of
the node). Concept names in a description graph stand for atomic concept names and >.
We will occasionally use the notation n:Atoms and n:REdges to access the components C
and H of the node n.
An r-edge is a tuple, (r; m; M; G0 ), consisting of a role or attribute name, r; a min, m,
which is a non-negative integer; a max, M , which is a non-negative integer or 1; and a
(recursively nested) description graph G0 . The graph G0 will often be called the restriction
graph of the node for the role r. We require the nodes of G0 to be distinct from all the nodes
of G and other nested description graphs of G. If r is an attribute, then we require: m = 0
and M 2 f0; 1g.

Given a description graph G and a node n 2 G:N odes, we define Gj to be the graph
(N; E; n; l); Gj is said to be rooted at n. A sequence p = n0a1 a2    a n with k  0 and
(n 1; a ; n ) 2 G:Edges, i = 1; : : : ; k, is called path in G from the node n0 to n (p 2 G
for short); for k = 0 the path p is called empty; w = a1    a is called the label of p (the
empty path has label "); p is called rooted if n0 is the root of G. Occasionally, we write
n0 a1    a n 2 G omitting the intermediate nodes.
Throughout this work we make the assumption that description graphs are connected.
A description graph is said to be connected if all nodes of the graph can be reached by a
rooted path and all nested graphs are connected. The semantics of description graphs (see
Definition 6) is not altered if nodes that cannot be reached from the root are deleted.
In order to merge description graphs we need the notion of \recursive set of nodes" of
a description graph G: The recursive set of nodes of G is the union of the nodes of G and
the recursive set of nodes of all nested description graphs of G.
Just as for concept descriptions, the semantics of description graphs is defined by means
of an interpretation I . We introduce a function  which assigns an individual of the domain
of I to every node of the graph. This ensures that all same-as equalities are satisfied.
n

k

n

i

i

i

k

k

k

k

k

176

fiWhat's in an Attribute?

Definition 6 Let G = (N; E; n0 ; l) be a description graph and let I be an interpretation.
An element, d, of I is in GI , iff there is some total function, , from N into I such
that
1.

d

= (n0);

2 N , (n) 2 nI ; and
3. for all (n1 ; a; n2 ) 2 E we have ((n1 ); (n2 )) 2 aI .
The extension nI of a node n with label ? is the empty set. An element, d, of I is in nI ,
2. for all

where

( ) = (C; H ), iff

l n

2 C , we have d 2 B I ; and
for all (r; m; M; G0 ) 2 H ,

1. for all
2.

n

B

(a) there are between m and M elements, d0 , of the domain such that
and
(b) d0 2 G0I for all d0 such that (d; d0 ) 2 rI .

(d; d0 ) 2 rI ;

Cohen and Hirsh (1994a) defined the semantics of description graphs in a different way,
avoiding the introduction of a total function . The problem with their definition is,
however, that it is only well-defined for acyclic graphs, which, for example, excludes sameas equalities of the form " # spouse  spouse, or even p # p  q.
The semantics of the graphs proposed by Borgida and Patel-Schneider (1994) is similar
to Definition 6. However, in that paper a-edges captured not only same-as equalities but
also all value restrictions on attributes. Still, in the context of partial attributes, we could
not define the semantics of description graphs by means of a total function  since some
attributes might not have fillers. Specifying the semantics of description graphs in terms
of partial mappings  would make the definition even longer. Furthermore, the proofs in
(Borgida & Patel-Schneider, 1994) would not carry over as easily. Therefore, in order to
keep  a total function, value restrictions of attributes are initially always translated into redges. The next section will present the translation of concept descriptions into description
graphs in detail.
Having defined the semantics of description graphs, subsumption and equivalence between description graphs (e.g., H v G) as well as concept descriptions and description
graphs (e.g., C v G) is defined in the same way as subsumption and equivalence between
concept descriptions.
3.2 Translating Concept Descriptions into Description Graphs

Following Borgida and Patel-Schneider (1994), a classic concept description is turned
into a description graph by a recursive process. In this process, nodes and description
graphs are often merged.
Definition 7 The merge of two nodes, n1  n2 , is a new node n with the following label:
if n1 or n2 have label ?, then the label of n is ?. Otherwise if both labels are not equal to
?, then n:Atoms = n1:Atoms [ n2:Atoms and n:REdges = n1:REdges [ n2:REdges.
177

fi steres, Borgida
Ku

If G1 = (N1 ; E1 ; n1 ; l1 ) and G2 = (N2 ; E2 ; n2 ; l2 ) are two description graphs with disjoint
recursive sets of nodes, then the merge of G1 and G2 , G := G1 G2 = (N; E; n0 ; l), is defined
as follows:

3.

:= n1  n2;
N := (N1 [ N2 [ fn0 g) n fn1 ; n2 g;
E := (E1 [ E2 )[n1 =n0 ; n2 =n0 ], i.e., E is the union of E1 and E2 where every occurrence

4.

l n

1.
2.

n0

of n1 ; n2 is substituted by n0 ;

( ) := l1(n) for all n 2 N1 n fn1g; l(n) := l2 (n) for all n 2 N2 n fn2 g; and l(n0) is

defined by the label obtained by merging n1 and

n2 .

Now, a classic -concept description C can be turned into its corresponding description
G(C ) by the following translation rules.
1. > is turned into a description graph with one node n0 and no a-edges. The only atom
of the node is > and the set of r-edges is empty.
2. A concept name is turned into a description graph with one node and no a-edges. The
atoms of the node contain only the concept name and the node has no r-edges.
3. A description of the form ( n r) is turned into a description graph with one node and
no a-edges. The node has as its atoms > and it has a single r-edge (r; n; 1; G(>))
where G(>) is specified by the first translation rule.
4. A description of the form ( n r) is turned into a description graph with one node
and no a-edges. The node has as its atom > and it has a single r-edge (r; 0; n; G(>)).
5. A description of the form a1    a # b1    b is turned into a graph with pairwise
distinct nodes n1; : : : ; n 1; m1; : : : ; m 1, the root m0 := n0, and an additional node
n = m := n; the set of a-edges consists of (n0 ; a1 ; n1 ), (n1 ; a2 ; n2 ); : : : ; (n 1 ; a ; n )
and (m0; b1 ; m1 ), (m1; b2 ; m2 ), : : :, (m 1; b ; m ), i.e., two disjoint paths which coincide on their starting point, n0, and their final point, n. (Note that for p = 0 the first
path is the empty path from n0 to n0 and for q = 0 the second path is the empty path
from n0 to n0.) All nodes have > as their only atom and no r-edges.
6. A description of the form 8r:C , where r is a role, is turned into a description graph
with one node and no a-edges. The node has the atom f>g and it has a single r-edge
(r; 0; 1; G(C )).
7. A description of the form 8a:C , where a is an attribute, is turned into a description
graph with one node and no a-edges. The node has the atom f>g and it has a single
r-edge (a; 0; 1; G(C )). (In the work by Borgida and Patel-Schneider, the concept
description 8a:C is turned into an a-edge. As already mentioned, this would cause
problems for attributes interpreted as partial functions when defining the semantics
by means of  as specified in Definition 6.)

graph

p

p

p

q

q

q

p

q

178

q

q

p

p

fiWhat's in an Attribute?

8. To turn a description of the form C u D into a description graph, construct G(C ) and
G(D ) and merge them.
Figure 1 shows the description graph built in this way for the concept Lemon of our example.
It can easily be verified that the translation preserves extensions:
Theorem 1 A concept description C and its corresponding description graph G(C ) are
equivalent, i.e.,C I = G(C )I for every interpretation I .
The main diculty in the proof of this theorem is in showing that merging two description
graphs corresponds to the conjunction of concept descriptions.
Lemma 1 For all interpretations I , if n1 and n2 are nodes, then (n1  n2 )I = nI1 \ nI2 ; if
I
G1 and G2 are description graphs then (G1  G2 )I = GI
1 \ G2 .
The proof of the preceding statement is rather simple and like the one in (Borgida & PatelSchneider, 1994).
3.3 Translating Description Graphs to Concept Descriptions

Although the characterization of subsumption does not require translating description
graphs back to concept descriptions, this translation is presented here to show that concept descriptions and description graphs are equivalent representations of classic concept
descriptions. In subsequent sections, we will in fact need to turn graphs into concept descriptions.
The translation of a description graph G can be specified in a rather straightforward
recursive definition. The main idea of the translation stems from Cohen and Hirsh (1994a),
who employed spanning trees to translate same-as equalities. A spanning tree of a (connected) graph is a tree rooted at the same node as the graph and containing all nodes of the
graph. In particular, it coincides with the graph except that some a-edges are deleted. For
example, one possible spanning tree T for G in Figure 1 is obtained by deleting the a-edge
labeled madeBy, whose origin is the root of G.
Now, let G be a connected description graph and T be a spanning tree for it. Then,
the corresponding concept description C is obtained as a conjunction of the following
descriptions:
1. C contains (i) a same-as equality v # v for every leaf n of T , where v is the label
of the rooted path in T to n; and (ii) a same-as equality v1  a # v2 for each a-edge
(n1 ; a; n2) 2 G:Edges not contained in T , where v is the label of the rooted path to
n in T , i = 1; 2.
2. for every node n in T , C contains a value restriction 8v:C , where v is the label of
the rooted path in T to n, and C denotes the translation of the label of n, i.e., C is
a conjunction obtained as follows:
 every concept name in the atoms of n is a conjunct in C ;
 for every r-edge (r; m; M; G0 ) of n, C contains (a) the number restrictions (mr)
and ( M r) (in case r is a role and M 6= 1) and (b) the value restriction 8r:C 0 ,
where C 0 is the recursively defined translation of G0 .
G

G

i

i

G

n

n

n

n

n

G

G

179

fi steres, Borgida
Ku

In case the set of atoms and r-edges of n is empty, define C := >.
Referring to the graph G in Figure 1, C contains the same-as equalities model  madeBy #
model  madeBy and madeBy # model  madeBy. Furthermore, if n0 denotes the root of G,
C has the value restrictions 8":C , 8model:>, and 8model madeBy:>, where C
corresponds to Lemon as defined in the introduction, but without the same-as equality. Note
that, although in this case the same-as equality model  madeBy # model  madeBy is not
needed, one cannot dispense with 1.(i) in the construction above, as illustrated by the following example: Without 1.(i), the description graph G(a # a) would be turned into the
description >, which is not equivalent to a # a since the same-as equality requires that the
path a has a value, which may not be the case.
It is easy to prove that the translation thus defined is correct in the following sense
(Kusters & Borgida, 1999).
n

G

n0

G

n0

Lemma 2 Every connected description graph G is equivalent to its translation C , i.e., for
all interpretations I : GI = C I .
G

G

3.4 Canonical Description Graphs

In the following we occasionally refer to \marking a node incoherent"; this means that the
label of this node is changed to ?. \Marking a description graph as incoherent" means that
the description graph is replaced by the graph G(?) corresponding to ?, i.e., the graph
consisting only of one node with label ?.
One important property of canonical description graphs is that they are deterministic,
i.e., every node has at most one outgoing edge (a-edge or r-edge) labeled with the same
attribute or role name. Following Borgida and Patel-Schneider (1994), in order to turn a
description graph into a canonical graph we need to merge a-edges and r-edges. In addition,
different from their work, it might be necessary to \lift" r-edges to a-edges.
To merge two a-edges (n; a; n1) and (n; a; n2 ) in a description graph G, replace them
with a single new edge (n; a; n0 ) where n0 is the result of merging n1 and n2. In addition,
replace n1 and n2 by n0 in all other a-edges of G.
In order to merge two r-edges (r; s1 ; k1 ; G1 ), (r; s2 ; k2 ; G2 ) replace them by the new r-edge
(r; max(s1 ; s2 ); min(k1 ; k2 ); G1  G2 ).
To lift up an r-edge (a; m; M; G ) of a node n in a concept graph G with an a-edge
(n; a; n1 ), remove it from n:REdges, and augment G by adding G :N odes to G:N odes,
G :Edges to G:Edges, as well as adding (n; a; G :Root) to G:Edges. A precondition for
applying this transformation is that M = 1, or M = 0 and G corresponds to the graph
G(?). The reason for this precondition is that if an r-edge of the form (a; 0; 0; G ) is lifted
without G being inconsistent, the fact that no a-successors are allowed is lost. Normalization rule 5 (see below) will guarantee that this precondition can always be satisfied.
A description graph G is transformed into canonical form by exhaustively applying the
following normalization rules. A graph is called canonical if none of these rules can be
applied.
1. If some node in G is marked incoherent, mark the description graph as incoherent.
(Reason: Even if the node is not a root, attributes corresponding to a-edges must always
a

a

a

a

a

a

a

180

fiWhat's in an Attribute?

have a value (since they participate in same-as equalities), and this value cannot belong to the

)
2. If some r-edge in a node has its min greater than its max, mark the node incoherent.
(Reason: 2
1
)
3. Add > to the atoms of every node, if absent.
4. If some r-edge in a node has its restriction graph marked incoherent, change its max
to 0. (Reason: ( 0 )
.)
5. If some r-edge in a node has a max of 0, mark its restriction graph as incoherent.
(Reason: See 4.)
6. If some r-edge is of the form (r; 0; 1; G0 ) where G0 only contains one node with empty
set of atoms or with the atoms set to f>g and no r-edges, then remove this r-edge.
(Reason:
.)
7. If some node has two r-edges labeled with the same role, merge the two edges, as
described above. (Reason:
(
).)
8. If some description graph has two a-edges from the same node labeled with the
same attribute, merge the two edges, as described above. (Reason:
(
).)
9. If some node in a graph has both an a-edge and an r-edge for the same attribute, then
\lift up the r-edge" if the precondition is satisfied (see above). (Reason: The value
restrictions imposed on attributes that participate in same-as equalities must be made explicit
and gathered at one place similar to the previous to cases.)
We need to show that the transformations to canonical form do not change the semantics
of the graph. The main diculty is in showing that the merging processes and the lifting
preserve the semantics. The only difference from (Borgida & Patel-Schneider, 1994) is that
in addition to merging r-edges and a-edges we also need to lift up r-edges. Therefore,
we omit the proofs showing that merging edges preserves extensions. The proofs of the
following two lemmas are routine and quite similar to the one of Lemma 5.
Lemma 3 Let G = (N; E; n0 ; l) be a description graph with two mergeable a-edges and let
G0 = (N 0 ; E 0 ; n0 ; l0 ) be the result of merging these two a-edges. Then, G  G0 .
empty set.



r u



r  ?

r

 8r:?

8r:>  >

8r:C u 8r:D  8r: C u D

8a:C u 8a:D 

8a: C u D

Lemma 4 Let n be a node with two mergeable r-edges and let n0 be the node with these
edges merged. Then, nI = n0I for every interpretation I .
Lemma 5 Let G = (N; E; n0 ; l) be a description graph with node n and a-edge (n; a; n00 ).
Suppose n has an associated r-edge (a; m; M; G ). Provided that the precondition for lifting
r-edges is satisfied and that G0 = (N 0 ; E 0 ; n0 ; l0 ) is the result of this transformation, then
G  G0 .
Proof. It is sucient to show that GIj = G0 Ij , since only the label of n is changed in G0
a

and only n obtains an additional a-edge, which points to the graph G not connected to
n

n

a

181

fi steres, Borgida
Ku

RepairReport

G

fModel >g
;

model

repairs

model

[10; 1]

fCar >g
;

madeBy

fManufacturer >g
;

Figure 2: The canonical description graph for Lemon, where the left-most node is the root.
the rest of G0 . W.l.o.g. we therefore may assume that n is the root of G, i.e., n = n0. Let
d 2 GI . Thus, there is a function  from N into I as specified in Definition 6 and an
individual e such that d = (n), e = (n00), and (d; e) 2 aI . This implies e 2 GI . Hence,
there exists a function 0 from G :N odes into I for G and e satisfying the conditions in
Definition 6. Since the sets of nodes of G and G are disjoint, we can define 00 to be the
union of  and 0, i.e., 00 (m) := (m) for all nodes m in G and 00(m) := 0(m) for all
nodes m in G . Since, by construction, for the additional a-edge (n; a; G :Root) 2 E 0 we
have (00(n); 00 (G :Root)) 2 aI , it follows that all conditions in Definition 6 are satisfied
for d and G0, and thus, d 2 G0I .
Now let d 2 G0I . Thus, there is a function 00 from N 0 into I according to Definition 6.
Let e := 00(G :Root) = 00(n00). Let G00 be the description graph we obtain from G0 by
deleting the nodes corresponding to G , which is the same graph as G without the r-edge
(a; m; M; G ). If we restrict 00 to the nodes of G00 , then it follows d 2 G00I . Furthermore,
restricting 00 to the nodes of G yields e 2 GI . In particular, G can not be marked
incoherent. Then, our precondition ensures M = 1. Thus, since e is the only a-successor of
d, we can conclude d 2 GI .
ut
a

a

a

a

a

a

a

a

a

a

a

a

a

Having dealt with the issue of merging and lifting, it is now easy to verify that \normalization" does not affect the meaning of description graphs.
Theorem 2 If G is a description graph and G0 is the corresponding canonical description
graph, then G  G0 .

As an example, the canonical description graph of the graph given in Figure 1 is depicted
in Figure 2.
3.5 Subsumption Algorithm

The final part of the subsumption process is checking to see if a canonical description graph
is subsumed by a concept description. As in Borgida and Patel-Schneider (1994), where
attributes are total, it turns out that it is not necessary to turn the potential subsumer
into a canonical description graph. The subsumption algorithm presented next can also be
considered as a characterization of subsumption.
182

fiWhat's in an Attribute?

Algorithm 1 (Subsumption Algorithm) Given a concept description D and description graph G = (N; E; n0 ; l), subsumes?(D; G) is defined to be true if and only if one of the
following conditions hold:
1. The description graph
2.

D

3.

D

4.

D

5.

D

G

is marked incoherent.

is a concept name or >, and D is an element of the atoms of n0 .

is ( n r) and i) some r-edge of n0 has r as its role, and min greater than or equal
to n; or ii) n = 0.

is ( n r) and some r-edge of n0 has r as its role, and max less than or equal to n.
is

   a # b1    b

, and there are rooted paths with label
in G ending at the same node.
a1

n

m

a1

a

n

and

b1

b

m

is 8r:C , for a role r, and either (i) some r-edge of n0 has r as its role and G0
as its restriction graph with subsumes?(C; G0 ); or (ii) subsumes?(C; G(>)). (Reason:
8r:>  >.)
7. D is 8a:C , for an attribute a, and (i) some a-edge of G is of the form (n0 ; a; n0 ), and
subsumes?(C; (N; E; n0 ; l)); or (ii) some r-edge of n0 has a as its attribute, and G0 as
its restriction graph with subsumes?(C; G0 ); or (iii) subsumes?(C; G(>)).

6.

D

8.

D

is E u F and both subsumes?(E; G) and subsumes?(F; G) are true.

There are only two differences between this algorithm and the one for total attributes presented by Borgida and Patel-Schneider (see also Algorithm 2). First, in the partial attribute
case, given D = 8a:C , one needs to look up the value restriction either in some a-edge or
some r-edge of G, since attributes can label both a-edges and r-edges. (In the total attribute
case, attributes can only label a-edges so that examining r-edges was not necessary.) The
second and most important distinction is the treatment of same-as equalities. As shown in
the above algorithm, with D = a1    a # b1    b one only needs to check whether there
exist two paths labeled v := a1    a and w := b1    b leading the same node in G. In the
total attribute case, however, it suces if there exist prefixes v0 and w0 of v and w with this
property, as long as the remaining suxes are identical.
Soundness and completeness of this algorithm is stated in the following theorem.
Theorem 3 Let C , D be classic descriptions. Then, C v D iff subsumes?(D; G ),
where G is the canonical form of G(C ).
The soundness of the subsumption algorithm, i.e., the if direction in the theorem stated
above, is pretty obvious. As in (Borgida & Patel-Schneider, 1994), the main point of the
only-if direction (proof of completeness) is that the canonical graph G is deterministic,
i.e., from any node, given a role or attribute name r, there is at most one outgoing r-edge
or a-edge with r as label. We point the reader to (Borgida & Patel-Schneider, 1994) for
the proof, since it is almost identical to the one for total attributes already published there.
These proofs reveal that, for the if direction of Theorem 3, description graphs need not be
normalized. Thus, one can also show:
n

m

n

m

C

C

C

183

fi steres, Borgida
Ku

Remark 1 Let G be some (not necessarily normalized description graph) and let
concept description. Then, subsumes?(D; G) implies G v D.

D

be a

classic

Borgida and Patel-Schneider argue that the canonical description graph G of a concept
description C can be constructed in time polynomial in the size of C . Furthermore, Algorithm 1 runs in time polynomial in the size of G and D. It is not hard to see that the
changes presented here do not increase the complexity. Thus, soundness and completeness
of the subsumption algorithm provides us with the following corollary.
Corollary 1 Subsumption for classic concept descriptions C and D, where attributes
are interpreted as partial functions, can be decided in time polynomial in the size of C and
D.
4. Computing the LCS in

classic

In this section, we will show that the lcs of two classic concept descriptions can be stated
in terms of a product of canonical description graphs. A similar result has been proven by
Cohen and Hirsh (1994a) for a sublanguage of classic , which only allows for concept
names, concept conjunction, value restrictions, and same-as equalities. In particular, this
sublanguage does not allow for inconsistent concept descriptions (which, for example, can be
expressed by conicting number-restrictions). Furthermore, the semantics of the description
graphs provided by Cohen and Hirsh restricts the results to the case when description graphs
are acyclic. This excludes, for example, same-as equalities of the form  # spouse  spouse.
In the following, we first define the product of description graphs. Then, we show that
for given concept descriptions C and D, the lcs is equivalent to a description graph obtained
as the product of G and G . Our constructions and proofs will be quite close to those in
(Cohen & Hirsh, 1994a).
C

D

4.1 The Product of Description Graphs

A description graph represents the constraints that must be satisfied by all individuals in the
extension of the graph. Intuitively, the product of two description graphs is the intersection
of these constraints|as the product of finite automata corresponds to the intersection of the
words accepted by the automata. However, in the definition of the product of description
graphs special care has to be taken of incoherent nodes, i.e., nodes labeled with ?. Also,
since attributes may occur both in r-edges and a-edges, one needs to take the product
between restriction graphs of r-edges, on the one hand, and the original graphs G1 or G2
(rooted at certain nodes), on the other hand.
Definition 8 Let G1 = (N1 ; E1 ; n1 ; l1 ) and G2 = (N2 ; E2 ; n2 ; l2 ) be two description graphs.
Then, the product G := G1  G2 := (N; E; n0 ; l) of the two graphs is recursively defined as
follows:
1.
2.
3.

:= N1  N2 ;
n0 := (n1 ; n2 );
E :=f((n; n0 ); a; (m; m0 )) j (n; a; m) 2 E1 and (n0 ; a; m0 ) 2 E2 g;
N

184

fiWhat's in an Attribute?

4. Let n 2 N1 and n0 2 N2 . If l1 (n) = ?, then let l((n; n0 )) := l2 (n0 ) and, analogously,
if l2 (n0 ) = ?, then l((n; n0 )) := l1 (n). Otherwise, for l1 (n) = (S1 ; H1 ) and l2 (n0 ) =
(S2 ; H2), define l((n; n0)) := (S; H ) where
(a)
(b)

S

:= S1 \ S2;

:=
(
(
)
(
)
) j (r; p1 ; q1 ; G1 ) 2 H1 , (r; p2 ; q2 ; G2 ) 2 H2 g [
f(a; 0; 1; G1 m  G2 ) j (n; a; m) 2 E1 , (a; p2 ; q2 ; G2 ) 2 H2 g [
f(a; 0; 1; G1  G2 m ) j (a; p1 ; q1 ; G1 ) 2 H1 , (n ; a; m) 2 E2 g.
H

0

0

0

f r; min p1 ; p2 ; max q1 ; q2 ; G1  G2
0

j

0

0

0

0

j

0

According to this definition, if in the tuple (n; n0) some node, say n, is incoherent, then
the label of (n; n0 ) coincides with the one for n0. The reason for defining the label in this
way is that lcs(?; C )  C for every concept description C . This has been overlooked by
Frazier and Pitt (1996), thus making their constructions and proofs only hold for concept
descriptions that do not contain inconsistent subexpressions.
Note that G, as defined here, might not be connected, i.e., it might contain nodes that
cannot be reached from the root n0. Even if G1 and G2 are connected this can happen
because all tuples (n1; n2 ) belong to the set of nodes of G regardless of whether they are
reachable from the root or not. However, as already mentioned in Section 3.1 we may
assume G to be connected.
Also note that the product graph can be translated back into a classic concept
description since the product of two description graphs is once again a description graph.
4.2 Computing the LCS

We now prove the main theorem of this subsection, which states that the product of two
description graphs is equivalent to the lcs of the corresponding concept descriptions.
Theorem 4 Let C1 and C2 be two concept descriptions, and let G1 and G2 be corresponding
canonical description graphs. Then, C 1  2  lcs(C1 ; C2 ).
G

G

Let G := G1  G2 . We will only sketch the proof showing that C subsumes C1 and,
by symmetry, also C2 (see (Kusters & Borgida, 1999) for details). By construction, if there
are two rooted paths to a common node in G, then G1 has corresponding paths leading to
the same node as well. Thus, by Theorem 3, the same-as equalities in C subsume the ones
in C1 . Now, let T be a spanning tree of G, (m1; m2 ) be a node in G, and v be the label of
the rooted path in T to (m1 ; m2 ). Then, by construction it follows that there exists a rooted
path in G1 to m1 labeled v. Furthermore, a rather straightforward inductive proof shows
that the concept description E corresponding to the label of (m1 ; m2 ) subsumes G1 j .
This implies 8v:E w G1 . As a result, we can conclude G w G1 .
The more interesting part of the proof is to show that C is not only a common subsumer
of C1 and C2, but the least common subsumer.
We now show by induction over the size of D, C1, and C2 that if D subsumes C1 and
C2 , then D subsumes C : We distinguish different cases according to the definition of
\subsumes?". Let G1 = (N1 ; E1 ; n1; l1 ) be the canonical description graph of C1, G2 =
(N2 ; E2 ; n2; l2 ) be the canonical description graph of C2 , and G = (N; E; n0 ; l) = G1  G2 .
In the following, we assume that C1 v D and C2 v D; thus, subsumes?(D; G1) and
Proof.

G

G

m1

G

G

185

fi steres, Borgida
Ku

?(D; G2). We show that subsumes?(D; G). Then, Remark 1 implies G v D, and
thus, C v D. Note that one cannot use Theorem 3 since G might not be a canonical
description graph.
1. If G is incoherent, then there is nothing to show.
2. If D is a concept name, >, or a number-restriction, then by definition of the label of
n0 it is easy to see that subsumes?(D; G).
3. If D is v # w, then there exist nodes m1 in G1 and m2 in G2 such that there are two
paths from n1 to m1 with label v and w, respectively, as well as two paths from n2 to
m2 with label v and w. Then, by definition of G it is easy to see that there are two
paths from n0 = (n1; n2 ) to (m1 ; m2) with label v and w, respectively. This shows
subsumes?(D; G).
4. If D is 8r:C , r a role or attribute, then one of several cases applies:
(i) n1 and n2 have r-edges with role or attribute r, and restriction graphs G01 and G02 ,
respectively, such that subsumes?(C; G01 ) and subsumes?(C; G02 );
(ii) without loss of generality, n1 has an a-edge pointing to m1 with attribute r, such
that subsumes?(C; G01 ), where G01 := G1 j ; and n2 has an r-edge with restriction
graph G02 such that subsumes?(C; G02 ).
In both cases (i) and (ii), subsumes?(C; G01  G02 ) follows by induction. Furthermore,
by definition of G there is an r-edge with role r and restriction graph G01  G02 for n0.
This implies subsumes?(D; G).
(iii) n1 and n2 have a-edges with attribute r leading to nodes m1 and m2 , respectively. Then, subsumes?(C; G1 j ) and subsumes?(C; G2 j ). By induction, we know
subsumes?(C; G1 j
 G2 j ). It is easy to see that Gj(
 G2 j . Fur) = G1 j
thermore, by definition there is an a-edge with attribute r from (n1; n2 ) to (m1 ; m2 )
in G. This shows subsumes?(D; G).
(iv) (without loss of generality) n1 has no r-edge and no a-edge with role or attribute
r . This implies subsumes?(C; G(>)), which also ensures subsumes?(D; G).
5. If D is E u F , then by definition of the subsumption algorithm, subsumes?(E; G1 ) and
subsumes?(E; G2 ) hold. By induction, we have subsumes?(E; G), and analogously,
subsumes?(F; G). Thus, subsumes?(D; G).
ut
As stated in Section 3.5, a canonical description graph for a classic concept description
can be computed in time polynomial in the size of the concept description. It is not hard
to verify that the product of two description graphs can be computed in time polynomial in
the size of the graphs. In addition, the concept description corresponding to a description
graph can be computed in time polynomial in the size of the graph. Thus, as a consequence
of Theorem 4 we obtain:
subsumes
G

m1

m1

m1

m2

m2

m1 ;m2

m1

m2

Corollary 2 The lcs of two classic concept descriptions always exists and can be computed in time polynomial in the size of the concept descriptions.
186

fiWhat's in an Attribute?

j , j 6= i

j , j 6= i

i

a

a

a

i

a

Figure 3: The canonical description graph for D , without node labels.
i

As intimated in (Cohen et al., 1992), this statement does not hold for sequences of concept
descriptions. Intuitively, generalizing the lcs algorithm to sequences of, say, n concept descriptions, means computing the product of n description graphs. The following proposition
shows that the size of such a product graph may grow exponentially in n. Thus, the lcs
computed in this way grows exponentially in the size of the given sequence. However, this
does not imply that this exponential blow-up is unavoidable. There might exist a smaller,
still equivalent representation of the lcs. Nevertheless, we can show that the exponential
growth is inevitable.
Proposition 1 For all integers n  2 there exists a sequence D1 ; : : : ; D of classic
concept descriptions such that the size of every classic concept description equivalent to
lcs(D1 ; : : : ; D ) is at least exponential in n where the size of the D 0 s is linear in n.
Proof. As in Cohen et al. (1992), for a given n, define the concept descriptions D as
follows:
D := u (" # a ) u u (a # a a ) u (" # a a )
6=
6=
n

n

i

i

i

j

j

i

j

i

i

i

j

i

i

where a1 ; : : : ; a denote attributes. The canonical description graph for D is depicted in
Figure 3. Using Algorithm 1 it is easy to see that D v v # w iff the number of a 0 s in v and
the number of a 0 s in w are equal modulo 2 where v; w are words over fa1 ; : : : ; a g. This
implies that
D1 ; : : : ; D v v # w
iff for all 1  i  n the number of a 0s in v and
(1)
0
the number of a s in w are equal modulo 2.
Let s  f1; : : : ; ng be a non-empty set. We define v := a    a k where i1 <    < i
are the elements of s and w := a 3 a 3    a k 3 with a 3 := a a a . Now let E be the lcs
of D1 ; : : : ; D , and let G be the corresponding canonical description graph with root n0.
From (1) we know that E v v # w for every s  f1; : : : ; ng. Algorithm 1 implies that
the paths from n0 in G labeled v and w exist and that they lead to the same node q .
Assume there are non-empty subsets s; t of f1; : : : ; ng, s 6= t, such that q = q . This would
imply E v v # v in contradiction to (1). Thus, s 6= t implies q 6= q . Since there are
2 1 non-empty subsets of f1; : : : ; ng, this shows that G contains at least 2 1 nodes.
The fact that the size of G is linear in the size of E completes the proof.
ut
This proposition shows that algorithms computing the lcs of sequences are necessarily worstcase exponential. Conversely, based on the polynomial time algorithm for the binary lcs
operation, an exponential time algorithm can easily be specified employing the following
identity lcs(D1 ; : : : ; D )  lcs(D ; lcs(D 1 ; lcs(   lcs(D2 ; D1 )   ).
n

i

i

i

i

n

n

i

i

i1

s

i1

s

n

i2

i

j

i

j

j

k

j

E

s

s

E

s

s

s

s

s

t

s

n

E

E

n

n

n

187

t

t

n

fi steres, Borgida
Ku

Corollary 3 The size of the lcs of sequences of classic concept descriptions can grow
exponentially in the size of the sequences and there exists an exponential time algorithm for
computing the lcs.
5. The LCS for Same-as and Total Attributes

In the previous sections, attributes were interpreted as partial functions. In this section,
we will present the significant changes in computing the lcs that occur when considering
total functions instead of partial functions. More precisely, we will look at a sublanguage
S of classic that only allows for concept conjunction and same-as equalities, but where
we have the general assumption that attributes are interpreted as total functions.
We restrict our attention to the language S in order to concentrate on the changes
caused by going from partial to total functions. We strongly conjecture, however, that the
results represented here can easily be transfered to classic by extending the description
graphs for S as in Section 4.
First, we show that in S the lcs of two concept descriptions does not always exist.
Then, we will present a polynomial decision algorithm for the existence of an lcs of two
concept descriptions. Finally, it will be shown that if the lcs of two concept descriptions
exists, then it might be exponential in the size of the given concept descriptions and it can
be computed in exponential time.
In the sequel, we will simply refer to the lcs by lcs. Since throughout the section
attributes are always assumed to be total, this does not lead to any confusion.
Once again, it may be useful to keep in mind that for total (though not partial) attributes
we have (u # v) v (u  w # v  w) for any u; w; v 2 A, where A is the set of finite words
over A, the finite set of attribute names. Indeed, all the differences between partial and
total attributes shown in this section finally trace back to this property.
t

t

t

t

t

5.1 The Existence of the LCS

In this subsection, we prove that the lcs of two concept descriptions in S does not always
exist. Nevertheless, there is always an infinite representation of the lcs, which will be used
in the next subsection to characterize the existence of the lcs.
To accomplish the above, we return to the graph-based characterization of t-subsumption
proposed by Borgida and Patel-Schneider (1994), and modified for partial attributes in Section 3. For a concept description C , let G denote the corresponding canonical description
graph, as defined in Section 3.4. Its semantics is specified as in Section 3.1, although now
the set of interpretations is restricted to allow attributes to be interpreted as total functions
only.
Since S contains no concept names and does not allow for value-restrictions, the nodes
in G do not contain concept names and the set of r-edges is empty. Therefore, G can
be defined by the triple (N; E; n0 ) where N is a finite set of nodes, E is a finite set over
N  A  N , and n0 is the root of the graph.
As a corollary of the results of Borgida and Patel-Schneider, subsumption C v D of
concept descriptions C and D in S can be decided with the following algorithm, which also
provides us with a characterization of t-subsumption.
C

C

C

t

188

fiWhat's in an Attribute?

G

C0 :

D0 :

c

G
a

a

b

b

d

d
c

Figure 4: The canonical graphs for C0 and D0
Algorithm 2 Let C , D be concept descriptions in S , and G = (N; E; n0 ) be the canonical
description graph of C . Then, subsumes ?(D; G ) is defined to be true if and only if one
of the following conditions hold:
C

t

1.

C

is v # w and there are words v0 ; w0 ; u 2 A such that v = v0 u and w = w0 u, and
there are rooted paths in G labeled v0 and w0 , respectively, ending at the same node.

D

C

) and subsumes ?(D2 ; G ) are true.
Apart from the additional constructors handled by Algorithm 1, Algorithm 2 only differs
from Algorithm 1 in that, for total attributes, as considered here, it is sucient if prefixes
of rooted paths v and w lead to a common node, as long as the remainder in both cases is
the same path.
2.

D

is D1 u D2 and both subsumes ?(D1 ; G
t

C

t

C

Theorem 5 There are concept descriptions in S such that the lcs of these concept descriptions does not exist in S .

This result corrects the statement of Cohen et al. (1992) that the lcs always exists, a
statement that inadvertently assumed that attributes were partial, not total.
As proof, we offer the following S -concept descriptions, which are shown not to have an
lcs:
C0 := a # b;
D0 := a # ac u b # bc u ad # bd:
The graphs for these concepts are depicted in Figure 4.
The following statement shows that an lcs E of C0 and D0 would satisfy a condition
which does not have a \regular structure". This statement can easily be verified using
Algorithm 2.
E v v#w
iff v = w or there exists a nonnegative integer n and u 2
A such that v = ac du and w = bc du or vice versa.
Given this description of the lcs of C0 and D0 , one can show, again, by employing Algorithm 2, that no finite description graph can be equivalent to E . However, we omit this
elementary proof here, because the absence of the lcs also follows from Theorem 6, where
infinite graphs are used to characterize the existence of an lcs. Note that in the partial
attribute case, the lcs of C0 and D0 is equivalent to a # a u b # b, a result that can be
t

n

189

n

fi steres, Borgida
Ku

obtained by the lcs algorithm presented in the previous section. The corresponding (finite) description graph consists of a root and two additional nodes, where the root has two
outgoing edges leading to the two nodes and labeled a and b, respectively.
To state Theorem 6, we first introduce infinite description graphs and show that there
always exists an infinite description graph representing the lcs of two S -concept descriptions.
An infinite description graph G is defined, like a finite graph, by a triple (N; E; n0 )
except that the set of nodes N and the set of edges E may be infinite. As in the finite case,
nvn0 2 G means that G contains a path from n to n0 labeled with the word v 2 A . The
semantics of infinite graphs is defined as in the finite case. Furthermore, infinite graphs are
translated into concept descriptions as follows: take an (infinite) spanning tree T of G, and,
as in the finite case, for every edge of G not contained in it, add to C a same-as equality.
Note that in contrast to the partial attribute case, C need not contain same-as equalities of
the form v # v since, for total attributes, v # v  >. Still, C might be a concept description
with an infinite number of conjuncts (thus, an infinite concept description). The semantics
of such concept descriptions is defined in the obvious way. Analogously to Lemma 2, one
can show that an (infinite) graph G and its corresponding (infinite) concept description C
are equivalent, i.e., C  G.
We call an (infinite) description graph G deterministic if, and only if, for every node n
in G and every attribute a 2 A there exists at most one a-successor for n in G. The graph
G is called complete if for every node n in G and every attribute a 2 A there is (at least)
one a-successor for n in G. Clearly, for a deterministic and complete (infinite) description
graph, every path is uniquely determined by its starting point and its label.
Algorithm 2 (which deals with finite description graphs G ) can be generalized to deterministic and complete (infinite) description graphs G in a straightforward way. To see
this, first note that a (finite) description graph coming from an S -concept description is
canonical iff it is deterministic in the sense just introduced. Analogously, a deterministic
infinite graph can be viewed as being canonical. Thus, requiring (infinite) graphs to be
deterministic satisfies the precondition of Algorithm 2. Now, if in addition these graphs are
complete, then (unlike the condition stated in the subsumption algorithm) it is no longer
necessary to consider prefixes of words because a complete graph contains a rooted path
for every word. More precisely, if v0 and w0 lead to the same node, then this is the case for
v = v 0 u and w = w0 u as well, thus making it unnecessary to consider the prefixes v 0 and w0
of v and w, respectively. Summing up, we can conclude:
Corollary 4 Let G = (N; E; n0 ) be a deterministic and complete (infinite) description
G

G

G

G

G

C

graph and

v; w

2 A. Then,
Gv v#w
iff
t

n0 vn

2 G and n0wn 2 G for some node n:

We shall construct an (infinite) graph representing the lcs of two concept descriptions in S
as the product of the so-called completed canonical graphs. This infinite representation of
the lcs will be used later to characterize the existence of an lcs in S , i.e., the existence of a
finite representation of the lcs.
We now define the completion of a graph. Intuitively, a graph is completed by iteratively
adding outgoing a-edges labeled with an attribute a for every node in the graph that does
not have such an outgoing a-edge. This process might extend a graph by infinite trees. As
an example, the completion of G (cf. Figure 4) is depicted in Figure 5 with A = fa; b; c; dg.
C0

190

fiWhat's in an Attribute?

G

1
C :
0

a

d



c

c

b

b

d

a

a

b

c

d

a

b

c

d

...
...
Figure 5: The complete graph for C0
Formally, completions are defined as follows: Let G be an (infinite) description graph.
The graph G0 is an extension of G if for every node n in G and for every attribute a 2 A
such that n has no outgoing edges labeled a, a new node m is added, as well as an edge
(n; a; m ). Now, let G0 ; G1 ; G2 ; : : : be a sequence of graphs such that G0 = G and G +1 is
an extension of G ; for i  0. If G = (N ; E ; n0), then
[ [
G1 := (
N;
E ; n0 )
n;a

i

n;a

i

i

i

i

0

i

0
construction, G1
i

i

i

is called the completion of G. By
is a complete graph. Furthermore, if
1
G is deterministic, then G is deterministic as well. Finally, it is easy to see that a graph
and its extension Sare equivalent. Thus, by induction, G1  G.
The nodes in 1 N , i.e., the nodes in G1 that are not in G, are called tree nodes; the
nodes of G are called non-tree nodes. By construction, for every tree node t in G1 there is
exactly one direct predecessor of t in G1, i.e., there is exactly one node n and one attribute
a such that (n; a; t) is an edge in G1 ; n is called a-predecessor of t. Furthermore, there is
exactly one youngest ancestor n in G of a tree node t in G1; n is the youngest ancestor of
t if there is a path from n to t in G1 which does not contain non-tree nodes except for n.
Note that there is only one path from n to t in G1. Finally, observe that non-tree nodes
have only non-tree nodes as ancestors.
Note that the completion of a canonical description graph is always complete and deterministic.
In the sequel, let C , D be two concept descriptions in S , G = (N ; E ; n ), G =
(N ; E ; n ) be their corresponding canonical graphs, and G1 , G1 be the completions of
G , G . The products G := G  G and G
1 := G1  G1 are specified as in Definition 1.
As usual, we may assume G and G1 are connected, i.e., they only contain nodes that are
reachable from the root (n ; n ); otherwise, one can remove all those nodes that cannot be
reached from the root without changing the semantics of the graphs.
We denote the product G1  G1 by G1 instead of G1 (or G1) because otherwise
this graph could be confused with the completion of G. In general, these graphs do not
t

i

i

C

D

C

D

D

C

D

C

C

D

C

D

C

D

191

D

C

D

C

C

D

fi steres, Borgida
Ku

coincide. As an example, take the products G  G and G1  G1 (see Figure 4 for the
graphs G and G ). The former product results in a graph that consists of a root with
two outgoing a-edges, one labeled a and the other one labeled b. (As mentioned before, this
graph corresponds to the lcs of C0 and D0 in the partial attribute case.) The product of
the completed graphs, on the other hand, is a graph that is obtained as the completion of
the graph depicted in Figure 6 (the infinite trees are omitted for the sake of simplicity).
As an easy consequence of the fact that G  G1 and Corollary 4, one can prove the
following lemma.
C0

Lemma 6

C0

D0

C

C

C0

D0

D0

C

v v # w iff n
t

C

vn

2 G1 and n
C

C

wn

2 G1 for a node n in G1 .
C

C

But then, by the construction of G1 we know:
Proposition 2 C v
for a node n in G1 .

t

v

# w and D v v # w iff (n
t

C

) 2 G1 and (n

; nD vn

C

)

; nD wn

2 G1

In particular, G1 represents the lcs of the concept descriptions C and D in the following
sense:
Corollary 5 The (infinite) concept description C 1 corresponding to G1 is the lcs of C
and D, i.e., i) C; D v C 1 and ii) C; D v E 0 implies C 1 v E 0 for every S -concept
description E 0 .
G

t

t

G

t

G

5.2 Characterizing the Existence of an LCS

Let C , D be concept descriptions in S and let the graphs G , G , G, G1 , G1, and G1
be defined as above.
We will show that G1 not only represents a (possibly infinite) lcs of the S -concept
descriptions C and D (Corollary 5), but that G1 can be used to characterize the existence
of a finite lcs. The existence depends on whether G1 contains a finite or an infinite number
of so-called same-as nodes.
Definition 9 A node n of an (infinite) description graph H is called a same-as node if
C

there exist two direct predecessors of
may be labeled differently.)

a

n

in

H.

D

(The a-edges leading to

c

c

c

d

d

d


b

d

d

d

c

c

c

Figure 6: A subgraph of G1  G1
C0

192

D0

C

n

D

from these nodes

fiWhat's in an Attribute?

For example, the graph depicted in Figure 6 contains an infinite number of same-as nodes.
We will show that this is a sucient and necessary condition for the lcs of C0 and D0 not
to exist.
It is helpful to observe that same-as nodes in G1 have one of the forms (g; f ), (f; t),
and (t; f ), where g and f are non-tree nodes and t is a tree node. There cannot exist a
same-as node of the form (t1; t2 ), where both t1 and t2 are tree nodes, since tree nodes
only have exactly one direct predecessor, and thus (t1; t2 ) does. Moreover, if G1 has an
infinite number of same-as nodes, it must have an infinite number of same-as nodes of the
form (f; t) or (t; f ), because there only exist a finite number of nodes in G1 of the form
(g; f ). For this reason, in the following lemma we only characterize same-as nodes of the
form (f; t). (Nodes of the form (t; f ) can be dealt with analogously.) To state the lemma,
recall that with n0un1vn2 2 H , for some graph H , we describe a path in H labeled uv
from n0 to n2 that passes through node n1 after u (i.e., n0un1 2 H and n1vn2 2 H ); this
is generalized the obvious way to interpret n0u1n1u2n2u3n3 2 H .
G

1

(nC ; nD )
v

w

(h1 ; p0 )

x

(h2 ; p0 )

G

..
.

6=
6
1=

v
h

w
h2

..
.x

(e1 ; q0 )

(e2 ; q0 )
a

e1

6=

e2

a
n

= (f; t)

Figure 7: same-as nodes in G1
Lemma 7 Given a node f in G and a tree-node t in G1 , the node n = (f; t) in G1 is a
same-as node iff
C




D

there exist nodes (h1 ; p0 ), (h2 ; p0 ) in G, h1 6= h2 ;
there exist nodes (e1 ; q0 ), (e2 ; q0 ) in G1 , where e1 , e2 are distinct nodes in G and
q0 is a node in G1 ; and
there exists an attribute a 2 A and v; w; x 2 A , v 6= w, where A is the set of attributes
in C ,
C

D



such that

(n

C

) (

) (

) ( ) and (n

) ( ) ( )
For the direct successors (h01 ; p00 ) and (h02 ; p00 ) of (h1 ; p0 )

; nD v h1 ; p0 x e1 ; q0 a f; t

C

) (

; nD w h2 ; p0 x e2 ; q0 a f; t

are paths in G1 (see Figure 7).
and (h2 ; p0 ) in this paths, we, in addition, require p00 to be a tree node in G1 .4
D

4. Note that since G
1 is deterministic, the successors of (h1 ; p0 ) and (h2 ; p0 ) in the two paths must in fact
be of the form (; p00 ).

193

fi steres, Borgida
Ku

The if direction is obvious. We proceed with the only-if direction and assume that
is a same-as node in G1. Let p0 be the (uniquely determined) youngest ancestor of t in
G1 . In particular, p0 is a node in G and there exists p0 xq0 at in G1 with a 2 A and
x 2 A such that the successor of p0 in this path is a tree node in G .
Since n is a same-as node and t can only be reached via q0 and the attribute a, there
must exist e1 , e2 in G , e1 6= e2 , with (e1 ; q0 )a(f; t); (e2 ; q0)a(f; t) 2 G1. Since G1 is
connected, there are paths from (n ; n ) to (e1 ; q0) and (e2 ; q0). Every path from n to q0
must pass through p0 and the sux of the label of this path is x. Consequently, there exist
nodes h1 ; h2 in G such that (h1 ; p0 )x(e1 ; q0 )a(f; t) and (h2 ; p0)x(e2 ; q0)a(f; t) are paths
in G1. In particular, xa is a label of a path from h1 to f in G , and the label xa only
consists of attributes contained in C . If h1 = h2, then this, together with the fact that G
is deterministic, would imply e1 = e2 . Hence, h1 6= h2 . Let v, w be the labels of the paths
from (n ; n ) to (h1 ; p0 ) and (h2 ; p0), respectively. As G is deterministic and h1 6= h2, it
follows that v 6= w.
ut
The main results of this section is stated in the next theorem. As a direct consequence of
this theorem, we obtain that there exists no lcs in S for the concept descriptions C0 and
D0 of our example.
Proof.
n

D

D

D

D

C

C

D

D

C

C

C

C

D

Theorem 6 The lcs of C and D exists iff the number of same-as nodes in G1 is finite.

We start by proving the only-if direction. For this purpose, we assume that G1
contains an infinite number of same-as nodes and show that there is no (finite) lcs for C
and D in S .
As argued before, we may assume that G1 contains an infinite number of same-as nodes
of the form (f; t) or (t; f ), where t is a tree node and f is a non-tree node. More precisely,
say G1 contains for every i  1 nodes n = (f ; t ) such that f is a node in G and t is
a tree node in G1. According to Lemma 7, for every same-as node n there exist nodes
h1 ; h2 ; e1 ; e2 in G , p0 in G , and q0 in G1 as well as a 2 A and x 2 A with the
properties required in Lemma 7.
Since G and G are finite description graphs, the number of tuples of the form
h1 ; h2 ; e1 ; e2 ; f ; a is finite. Thus, there must be an infinite number of i's yielding
the same tuple h1; h2 ; e1 ; e2 ; f; a. In particular, h1 6= h2 and e1 6= e2 are nodes in G and
there is an infinite number of same-as nodes of the form n = (f; t1 ). Finally, as in the
lemma, let v, w be the label of paths (in G) from (n ; n ) to (h1 ; p0 ) and (h2 ; p0 ).
Now, assume there is an lcs E of C and D in S . According to Corollary 5, E  C 1 .
Let G be the finite canonical graph for E with root n0. By Proposition 2 and Lemma 7
we know E v vx a # wx a. From Algorithm 2 it follows that there are words v0, w0 , and u
such that vx a = v0 u and wx a = w0 u, where the paths in G starting from n0 labeled v0 ,
w0 lead to the same node in G .
If u 6= ", then u = u0a for some word u0. Then, Algorithm 2 ensures E v vx # wx .
However, by Lemma 7 we know that the words vx and wx lead to different nodes in
G
1 , namely, (e1 ; q0 ) and (e2 ; q0 ), which, with Proposition 2, leads to the contradiction
E  G
1 6v vx # wx . Thus, u = ".
As a result, for every i  1 there exists a node q in G such that n0vx aq and n0wx aq
are paths in G . Because G is a finite description graph, there exist i; j  1, i 6= j , with
Proof.

i

i

i

i

C

D

;i

;i

;i

;i

C

C

;i

;i

i

i

;i

D

;i

i

D

i

D

;i

;i

i

i

C

i

C

;i

D

t

G

E

t

i

i

i

i

E

E

t

i

;i

t

i

i

;i

i

i

E

i

i

E

194

E

i

i

i

i

fiWhat's in an Attribute?

= q . By Algorithm 2, this implies E v vx a # wx a. On the other hand, the path in
starting from (n ; n ) with label vx a leads to the node n and the one for wx a leads
to n . Since n 6= n , Proposition 2 implies E 6v vx a # wx a, which is a contradiction. To
sum up, we have shown that there does not exist an lcs for C and D in S .
This shows that there is no lcs of C , D in S which completes the proof of the only-if
direction.
We now prove the if direction of Theorem 6. For this purpose, we assume that G1 has
only a finite number of same-as nodes. Note that every same-as node in G1 has only a
finite number of direct predecessors. To see this, two cases are distinguished: i) a node of
the form (g1 ; g2 ) in G has only predecessors in G; ii) if t is a tree node and g a non-tree node,
then a predecessor of (g; t) in G1 is of the form (g0 ; t0) where t0 is the unique predecessor
(tree or non-tree node) of t and g0 is a non-tree node. Since the number of nodes in G
and G is finite, in both cases we only have a finite number of predecessors. But then, the
spanning tree T of G1 coincides with G1 except for a finite number of edges because, if T
does not contain a certain edge, then this edge leads to a same-as node. As a result, C 1
is an S -concept description because it is a finite conjunction of same-as equalities. Finally,
Corollary 5 shows that C 1 is the lcs of C and D.
ut
If v # w is a conjunct in C 1 , then v and w lead from the root of G1 to a same-as node.
As mentioned before, same-as nodes are of the form (f; g); (f; t), or (t; f ), where t is a tree
node and f; g are non-tree nodes. Consequently, v and w must be paths in G or G .
Thus, they only contain attributes occurring in C or D.
qi

G
1

j

t

C

j

i

D

i

j

i

i

j

t

i

j

j

C

D

G

G

G

C

D

Corollary 6 If the lcs of two concept description C and D in S exists, then there is a
concept description in S only containing attributes occurring in C or D that is equivalent
to the lcs.

Therefore, when asking for the existence of an lcs, we can w.o.l.g. assume that the set of
attributes A is finite. This fact will be used in the following two subsections.
5.3 Deciding the Existence of an LCS

From the following corollary we will derive the desired decision algorithm for the existence
of an lcs of two concept descriptions in S . To state the corollary we need to introduce the
language L C (q1 ; q2) := fw 2 A j there is a path from the node q1 to q2 in G labeled wg.
Since description graphs can be viewed as finite automata, such a language will be regular.
Moreover, let aA denote the set faw j w 2 Ag for an attribute a 2 A, where A is a finite
alphabet.
G

C

Corollary 7 G1 contains an infinite number of same-as nodes iff either
(i) there exist nodes (h1 ; p0 ), (h2 ; p0 ) in G as well as nodes f , e1 , e2 in G , and attributes
a; b 2 A such that
C

1.

h1

6= h2 , e1 6= e2 ;

2.

p0

does not have a b-successor in G ;

3.

(e1 ; a; f ), (e2 ; a; f ) are edges in G

D

C

; and
195

fi steres, Borgida
Ku

4.

(

LGC h1 ; e1

) \ L C (h2 ; e2 ) \ bA is an infinite set of words;
G

or
(ii) the same statement as (i) but with r^oles of C and

D

switched.

We first prove the only-if direction. Assume that G1 contains an infinite number
of same-as nodes. Then, w.l.o.g., we find the configuration in G1 described in the proof
of Theorem 6. This configuration satisfies the conditions 1. and 3. stated in the corollary.
If, for i 6= j , the words x and x coincide, we can conclude n = n because G1 is a
deterministic graph. However, by definition, n 6= n . Hence, x 6= x . Because A is finite,
we can, w.l.o.g., assume that all x 's have b 2 A as their first letter for some fixed b. Thus,
condition 4. is satisfied as well. According to the configuration, the b-successor of (; p0 ) in
G
1 is of the form (; p00 ) where p00 is a tree node. Thus, p0 does not have a b-successor in
G , which means that condition 3. is satisfied.
We now prove the if direction of the corollary. For this purpose, let bx 2 L C (h1 ; e1 ) \
L C (h2 ; e2 ) \ bA . Since p0 has no b-successor in G it follows that there are tree nodes
t; t0 in G1 such that p0 bxtat0 2 G1 . Thus, we have (h1 ; p0 )bx(e1 ; t)a(f; t0 ) 2 G
1 and
0

(h2 ; p0 )bx(e2 ; t)a(f; t ) 2 G1. Since e1 6= e2, we can conclude (e1 ; t) 6= (e2 ; t). This means
that (f; t0) is a same-as node. Analogously, for by 2 L C (h1 ; e1 ) \ L C (h2 ; e2 ) \ bA there
are tree nodes s; s0 in G1 such that p0bysas0 2 G1 and (f; s0) is a same-as node in G1.
Since bx and by both start with b, and the b-successor of p0 in G1 is a tree node, x 6= y
implies s0 6= t0. Hence, (f; t0) and (f; s0) are distinct same-as nodes. This shows that if the
set L C (h1 ; e1 ) \ L C (h2 ; e2 ) \ bA is infinite, G1 must have an infinite number of same-as
nodes.
ut
For given nodes (h1 ; p0), (h2 ; p0 ) in G, attributes a; b 2 A, nodes f; e1; e2 2 G the conditions 1. to 3. in Corollary 7 can obviously be checked in time polynomial in the size of the
concept descriptions C and D. As for the last condition, note that an automaton accepting
the language L C (h1 ; e1 ) \ L C (h2 ; e2 ) \ bA can be constructed in time polynomial in the
size of C . Furthermore, for a given finite automaton it is decidable in time polynomial in
the size of the automaton if it accepts an infinite language (see the book by Hopcroft and
Ullman (1979) for details). Thus, condition 4. can be tested in time polynomial in the size
of C and D as well. Finally, since the size of G and G is polynomial in the size of C and D,
only a polynomial number of configurations need to be tested. Together with Corollary 7
these complexities provide us with the following corollary.
Proof.

i

j

i

i

j

j

i

j

i

D

G

G

D

D

D

G

D

G

D

D

G

G

C

G

G

C

Corollary 8 For given concept descriptions C and D in S it is decidable in time polynomial
in the size of C and D whether lcs of C and D exists in S .
5.4 Computing the LCS

In this subsection, we first show that the size of an lcs of two S -concept descriptions may
grow exponentially in the size of the concept descriptions. This is a stronger result than
that presented for partial attributes, where it was only shown that the lcs of a sequence of
concept descriptions in S can grow exponentially. Then, we present an exponential time lcs
algorithm for S -concept descriptions.
196

fiWhat's in an Attribute?

GC 0

:

GDk

:

a

c

c



a

b

a

d

d

c

c

b

a


d

d

k

Figure 8: The canonical description graphs for C 0 and D

k

In order to show that the lcs may be of exponential size, we consider the following
example, where A := fa; b; c; dg.We define
0 := a # b;
C
D
:= u=1 ac # ad u u=1 bc # bd u ac a # bc a:
The corresponding canonical description graphs G 0 and G k are depicted in Figure 8.
A finite graph representing the lcs of C 0 and D is depicted in Figure 9 for k = 2.
This graph can easily be derived from G10  G1k . The graph comprises two binary trees
of height k, and thus, it contains at least 2 nodes. In the following, we will show that
there is no canonical description graph G k (with root n0) representing the lcs E of C 0
and D with less than 2 nodes. Let x 2 fc; dg be a word of length k over fc; dg, and let
v := axa, w := bxa. Using the canonical description graphs G 0 and G k it is easy to see
that C 0 v v # w and D v v # w. Thus, E v v # w. By Algorithm 2, this means that
there are words v0; w0 ; u such that v = v0 u, w = w0 u, and there are paths from n0 labeled
v 0 and w0 in G k leading to the same node in G k . Suppose u 6= ". Then, Algorithm 2
implies E v ax # bx. But according to G , D 6v ax # bx. Therefore u must be the empty
k

k

i

k

i

i

i

i

k

k

i

D

C

k

D

C

k

E

k

k

k

k

D

C

t

t

k

t

k

E

k

E

t

D

a

c

t

b

d

d

c

2
c

d

a

c

a

a

d

d

a

a

c

a

d

a

c

a

Figure 9: A finite graph representing the lcs of C 0 and D2
197

fi steres, Borgida
Ku

word ". This proves that in G k there is a path from n0 labeled axa for every x 2 fc; dg .
Hence, there is a path for every ax. Now, let y 2 fc; dg be such that x 6= y. If the paths
for ax and ay from n0 in G k lead to the same node, then this implies E v ax # ay in
contradiction to C 0 6v ax # ay. As a result, ax and ay lead to different nodes in G k . Since
fc; dg contains 2 words, this shows that G k has at least 2 nodes. Finally, taking into
account that the size of a canonical description graph of a concept description in S is linear
in the size of the corresponding description we obtain the following theorem.
k

E

k

E

k

t

t

k

E

k

k

E

Theorem 7 The lcs of two S -concept descriptions may grow exponentially in the size of
the concepts.

The following (exponential time) algorithm computes the lcs of two S -concept descriptions
in case it exists.
Algorithm 3
Input: concept descriptions C , D in S , for which the lcs exists in S ;
Output: lcs of C and D in S ;
1. Compute G0 := G

G

C

D

;

2. For every combination

 of nodes (h1 ; p0 ), (h2 ; p0) in G = G  G , h1 6= h2 ;
 a 2 A, e1 ; e2 ; f in G , e1 6= e2 , where (e1 ; a; f ) and (e2 ; a; f ) are edges in G
C

D

C

extend G0 as follows: Let G
in

C

h1 ;t

,G

h2 ;t

be two trees representing the (finite) set of words

0
L := @L C (h1 ; e1 ) \ L C (h2 ; e2 ) \
G

[

G

b

62succ(

p0

)

1 (
f"g; if a 62 succ(p0)
bA A [

;

;

otherwise

where succ(p0 ) := fb j p0 has a b-successorg and the set of nodes of G 1 , G 2 , and
G0 are assumed to be disjoint. Now, replace the root of G 1 by (h1 ; p0 ), the root of
G 2 by (h2 ; p0 ), and extend G0 by the nodes and edges of these two trees. Finally,
add a new node n for every word v in L, and for each node of the trees G 1 and
G 2 reachable from the root of G 1 and G 2 by a path labeled v , add an edge with
label a from it to n . The extension is illustrated in Figure 10.
h ;t

h ;t

h ;t

h ;t

v

h ;t

h ;t

h ;t

h ;t

v

3. The same as in step 2, with r^oles of C and D switched.
4. Compute the canonical graph of G0 , which is called G0 again. Then, output the concept
description C 0 of G0 .
G

Proposition 3 The translation
of C and D.

CG0

of the graph G0 computed by Algorithm 3 is the lcs E
198

fiWhat's in an Attribute?

0

G

(h1 ; p0 )

(h2 ; p0 )

b

a

b

a

b

n

a
c

a

a
c

a

bc

n
d

a

a

d

bad

n

Figure 10: The extension at the nodes (h1 ; p0), (h2 ; p0 ) in G0 where L = fb; bc; badg
It is easy to see that if there are two paths in G0 labeled y1 and y2 leading from
the root (n ; n ) to the same node, then G1 contains such paths as well. Consequently,
(E  )G1 v G0.
Now, assume E v y1 # y2, y1 6= y2. By Proposition 2 we know that there are paths
in G1 labeled y1 and y2 leading to the same node n. W.l.o.g, we may assume that n is a
same-as node in G1. Otherwise, there exist words y10; y2 0; u with y1 = y10u, y2 = y20u such
that y10 and y20 lead to a same-as node. If we can show that G0 contains paths labeled y10
and y20 leading to the same node, then, by Algorithm 2, this is sucient for G0 v y1 # y2.
So let n be a same-as node. We distinguish two cases:
1. If n is a node in G = G  G , then the paths for y1 and y2 are paths in G. Since G
is a subgraph of G0 this holds for G0 as well. Hence, C 0 v y1 # y2.
2. Assume n is not a node in G. Then, since n is a same-as node, we know that n is of the
form (f; t) or (t; f ) where f is a non-tree node and t is a tree node. By symmetry, we
may assume that n = (f; t). Now it is easy to see that there exist nodes h1 ; h2 ; e1 ; e2 in
G , p0 in G , and a tree node q0 in G1 as well as a 2 A and x; v; w 2 A as specified
in Lemma 7 such that y1 = vxa and y2 = wxa. But then, with h1 ; h2 ; e1 ; e2 ; p0; f and
a the preconditions of Algorithm 3 are satisfied and x 2 L. Therefore, by construction
of G0 there are paths labeled y1 and y2, respectively, leading from the root to the same
node.
ut
We note that the product G of G and G can be computed in time polynomial in the
size of C and D. Furthermore, there is only a polynomial number of combinations of nodes
(h1 ; p0 ), (h2 ; p0) in G, e1 ; e2 ; f in G , a 2 A. Finally, the finite automaton for L can be
computed in time polynomial in the size of C and D. In particular, the set of states of this
automaton can polynomially be bounded in the size of C and D. If L contained a word
longer than the number of states, the accepting path in the automaton contains a cycle. But
then, the automaton would accept infinitely many words, in contradiction to the assumption
that L is finite. Thus, the length of all words in L can be bounded polynomially in the
size of C and D. In particular, this means that L contains only an exponential number of
words. Trees representing these words can be computed in time exponential in the size of
C and D .
Proof.

C

t

D

t

t

t

C

D

G

C

D

D

C

D

C

199

t

fi steres, Borgida
Ku

Corollary 9 If the lcs of two S -concept descriptions exists, then it can be computed in time
exponential in the size of the concept descriptions.
6. Conclusion

Attributes | binary relations that can have at most one value { have been distinguished
in many knowledge representation schemes and other object-centered modeling languages.
This had been done to facilitate modeling and, in description logics, to help identify tractable
sets of concept constructors (e.g., restricting same-as to attributes). In fact, same-as restrictions are quite important from a practical point of view, because they support the modeling
of actions and their components (Borgida & Devanbu, 1999).
A second distinction, between attributes as total versus partial functions, had not been
considered so essential until now. This paper has shown that this distinction can sometime
have significant effects.
In particular, we have first shown that the approach for computing subsumption of
Classic concepts with total attributes, presented by Borgida and Patel-Schneider (1994),
can be modified to accommodate partial attributes, by treating partial attributes as roles
until they participate in same-as restrictions, in which case they are \converted" to total attributes. As a result, we obtain polynomial-time algorithms for subsumption and
consistency checking in this case also.
In the case of computing least common subsumers, which was introduced as a technique
for learning non-propositional descriptions of concepts, we first noted that several of the
papers in the literature (Cohen & Hirsh, 1994a; Frazier & Pitt, 1996) (implicitly) used
partial attributes, when considering Classic. Furthermore, these papers used a weaker
version of the \concept graphs" employed in (Borgida & Patel-Schneider, 1994), which
make the results only hold for the case of same-as restrictions that do not generate \cycles".
Furthermore, the algorithm proposed by Frazier and Pitt (1996) does not handle inconsistent
concepts, which can easily arise in Classic concepts as a result of conicts between lower
and upper bounds of roles.
Therefore, we have provided an lcs algorithm together with a formal proof of correctness
for a sublanguage of Classic with partial attributes, which allows for same-as equalities
and inconsistent concepts | the algorithm and proofs can easily be extended to full Classic
(Kusters & Borgida, 1999). In this case, the lcs always exists, and it can be computed in
time polynomial in the size of the two initial concept descriptions. As shown by Cohen et al.
(1992), there are sequences of concept descriptions for which the lcs may grow exponentially
in the size of the sequence.
To complete the picture, and as the main part of the paper, we then examined the
question of computing lcs in the case of total attributes. Surprisingly, the situation here
is very different from the partial attribute case (unlike with subsumption). First, for the
language S the lcs may not even exist. (The existence of the lcs mentioned by Cohen et al.
(1992) is due to an inadvertent switch to partial semantics for attributes.) Nevertheless,
the existence of the lcs of two concept descriptions can be decided in polynomial time. But
if the lcs exists, it may grow exponentially in the size of the concept descriptions, and hence
the computation of the lcs may take time exponential in the size of the two given concept
descriptions.
200

fiWhat's in an Attribute?

As an aside, we note that it has been pointed out by Cohen et al. (1992) that concept
descriptions in S correspond to a finitely generated right congruence. Furthermore, in this
context the lcs of two concept descriptions is the intersection of right congruences. Thus,
the results presented in this paper also show that the intersection of finitely generated
right congruences is not always a finitely generated right congruence, and that there is a
polynomial algorithm for deciding this question. Finally, if the intersection can be finitely
generated, then the generating system may be exponential and can be computed with
an exponential time algorithm in the size of the generating systems of the given right
congruences.
The results in this paper therefore lay out the scope of the effect of making attributes
be total or partial functions in a description logic that supports the same-as constructor.
Moreover, we correct some problems and extend results in the previous literature.
We believe that the disparity between the results in the two cases should serve as a
warning to other researchers in knowledge representation and reasoning, concerning the
importance of explicitly considering the difference between total and partial attributes.
Acknowledgments

The authors wish to thank the anonymous reviewers for their helpful comments. This
research was supported in part by NSF Grant IRI-9619979. It was carried out while the
first author was at the Rutgers University and the RWTH Aachen.
References

Artale, A., Franconi, E., Guarino, N., & Pazzi, L. (1996). Part-Whole Relations in ObjectCentered Systems: An Overview. Data & Knowledge Engineering, 20 (3), 347{383.
Baader, F. (1996). A Formal Definition for the Expressive Power of Terminological Knowledge Representation Languages. Journal of Logic and Computation, 6 (1), 33{54.
Baader, F., & Kusters, R. (1998). Computing the Least Common Subsumer and the Most
Specific Concept in the Presence of Cyclic ALN -Concept Descriptions. In Herzog,
O., & Gunter, A. (Eds.), Proceedings of the 22nd Annual German Conference on
Artificial Intelligence, KI-98, Vol. 1504 of Lecture Notes in Computer Science, pp.
129{140 Bremen, Germany. Springer{Verlag.
Baader, F., Kusters, R., & Molitor, R. (1999). Computing Least Common Subsumers in
Description Logics with Existential Restrictions. In Dean, T. (Ed.), Proceedings of the
16th International Joint Conference on Artificial Intelligence (IJCAI'99), pp. 96{101
Stockholm, Sweden. Morgan Kaufmann Publishers.
Baader, F., & Sattler, U. (2000). Tableaux Algorithms for Description Logics. In Proceedings of the International Conference on Automated Reasoning with Analytic Tableaux
and Related Methods (TABLEAUX 2000), Vol. 1847 of Lecture Notes in Artifical Intelligence, pp. 1{18 University of St. Andrews, Scotland.
201

fi steres, Borgida
Ku

Borgida, A. (1994). On The Relationship Between Description Logic and Predicate Logic.
In Proceedings of the Third International Conference on Information and Knowledge
Management (CIKM'94), pp. 219{225 Gaithersburg, Maryland. ACM Press.
Borgida, A. (1995). Description logics in data management. IEEE Trans. on Knowledge
and Data Engineering, 7 (5), 671{682.
Borgida, A., & Devanbu, P. (1999). Adding more "DL" to IDL: towards more knowledgeable
component inter-operability. In Proceedings of the 1999 International Conference on
Software Engineering, pp. 378{387 Los Angeles, CA USA. ACM.
Borgida, A., & Etherington, D. (1989). Hierarchical Knowledge Bases and Ecient Disjunctive Reasoning. In Brachman, R., & H.J. Levesque, R. R. (Eds.), Proceedings
of the 1st International Conference on Principles of Knowledge Representation and
Reasoning (KR'89), pp. 33{43 Toronto, Canada. Morgan Kaufmann Publishers.
Borgida, A., & Kusters, R. (2000). What's not in a name: Some Properties of a Purely
Structural Approach to Integrating Large DL Knowledge Bases. In Baader, F., &
Sattler, U. (Eds.), Proceedings of the 2000 International Workshop on Description
Logics (DL2000), No. 33 in CEUR-WS Aachen, Germany. RWTH Aachen.
Borgida, A., & Patel-Schneider, P. (1994). A Semantics and Complete Algorithm for Subsumption in the CLASSIC Description Logic. Journal of Artificial Intelligence Research, 1, 277{308.
Brachman, R., McGuinness, D., Patel-Schneider, P., & Borgida, A. (1999). \Reducing"
CLASSIC to Practice: Knowledge Representation Theory Meets Reality. Artificial
Intelligence, 114 (1{2), 203{237.
Calvanese, D., Giacomo, G. D., & Lenzerini, M. (1998). What can Knowledge Representation do for Semi-Structured Data?. In Proceedings of the 16th National Conference
of the American Association for Artificial Intelligence, AAAI-98, pp. 205{210. AAAI
Press/The MIT Press.
Calvanese, D., Giacomo, G. D., & Lenzerini, M. (1999a). Modeling and Querying SemiStructured Data. Network and Information Systems, 2 (2), 253{273.
Calvanese, D., Giacomo, G. D., & Lenzerini, M. (1999b). Reasoning in Expressive Description Logics with Fixpoints based on Automata on Infinite Trees. In Dean, T. (Ed.),
Proceedings of the 16th International Joint Conference on Artificial Intelligence (IJCAI'99), pp. 84{89 Stockholm, Sweden. Morgan Kaufmann Publishers.
Calvanese, D., Giacomo, G. D., Lenzerini, M., Nardi, D., & Rosati, R. (1998). Description
Logic Framework for Information Integration. In Cohn, A., Schubert, L., & Shapiro, S.
(Eds.), Proceedings of the 6th International Conference on the Principles of Knowledge
Representation and Reasoning (KR-98), pp. 2{13 Trento, Italy. Morgan Kaufmann
Publishers.
Calvanese, D., Lenzerini, M., & Nardi, D. (1999). Unifying Class-Based Representation
Formalisms. Journal of Artificial Intelligence Research, 11, 199{240.
202

fiWhat's in an Attribute?

Cohen, W. W., & Hirsh, H. (1994a). Learnability of description logics with equality constraints. Machine Learning, 17 (2/3), 169{199.
Cohen, W. W., & Hirsh, H. (1994b). Learning the CLASSIC Description Logic: Theoretical and Experimental Results. In Doyle, J., Sandewall, E., & Torasso, P. (Eds.),
Proceedings of the Fourth International Conference on Principles of Knowledge Representation and Reasoning (KR'94), pp. 121{133 Bonn, Germany. Morgan Kaufmann
Publishers.
Cohen, W., Borgida, A., & Hirsh, H. (1992). Computing Least Common Subsumers in Description Logics. In Swartout, W. (Ed.), Proceedings of the 10th National Conference
on Artificial Intelligence, pp. 754{760 San Jose, CA. MIT Press.
Devanbu, P., & Jones, M. (1997). The Use of Description Logics in KBSE Systems. ACM
Transactions on Software Engineering and Methodology (TOSEM), 6 (2), 141{172.
Frazier, M., & Pitt, L. (1996). Classic learning. Machine Learning Journal, 25, 151{193.
Giacomo, G. D., & Lenzerini, M. (1996). TBox and ABox reasoning in expressive description logics. In Aiello, L., Doyle, J., & Shapiro, S. (Eds.), Proceedings of the 5th
International Conference on Principles of Knowledge Representation and Reasoning
(KR'96), pp. 316{327 Boston, USA. Morgan Kaufmann Publishers.
Hopcroft, J., & Ullman, J. (1979). Introduction to Automata Theory. Addison-Wesley Publ.
Co.
Kusters, R., & Borgida, A. (1999). What's in an Attribute? Consequences for the Least
Common Subsumer. Tech. rep. DCS-TR-404, Rutgers University, USA. Available via
ftp://ftp.cs.rutgers.edu/pub/technical-reports/.
McGuinness, D., & Patel-Schneider, P. (1998). Usability Issues in Knowledge Representation Systems. In Proceedings of the 15th National Conference on Artificial Intelligence
(AAAI-98) and of the 10th Conference on Innovative Applications of Artificial Intelligence (IAAI-98), pp. 608{614 Menlo Park. AAAI Press.
McGuinness, D., & Wright, J. (1998). An industrial strength Description Logic-based
configurator platform. IEEE Intelligent Systems, 13 (4), 66{77.
Minsky, M. (1975). A framework for representing knowledge. In Winston, P. (Ed.), The
Psychology of Computer Vision McGraw-Hill, New York.
Quillian, M. (1968). Semantic memory. In Minsky, M. (Ed.), Semantic Information Processing, pp. 216{270 Cambridge, Mass. MIT Press.
Schmidt-Schau, M. (1989). Subsumption in KL-ONE is undecidable. In Brachman, R. J.
(Ed.), Proceedings of the 1st International Conference on Principles of Knowledge
Representation and Reasoning (KR'89), pp. 421{431 Toronto, Ont. Morgan Kaufmann
Publishers.
203

fi