Journal of Artificial Intelligence Research 14 (2001) 137-166

Submitted 9/00; published 4/01

Reasoning within Fuzzy Description Logics
Umberto Straccia

straccia@iei.pi.cnr.it

I.E.I - C.N.R., Via G. Moruzzi, 1
I-56124 Pisa (PI), ITALY

Abstract
Description Logics (DLs) are suitable, well-known, logics for managing structured
knowledge. They allow reasoning about individuals and well defined concepts, i.e. set
of individuals with common properties. The experience in using DLs in applications has
shown that in many cases we would like to extend their capabilities. In particular, their
use in the context of Multimedia Information Retrieval (MIR) leads to the convincement
that such DLs should allow the treatment of the inherent imprecision in multimedia object
content representation and retrieval.
In this paper we will present a fuzzy extension of ALC, combining Zadehs fuzzy logic
with a classical DL. In particular, concepts becomes fuzzy and, thus, reasoning about
imprecise concepts is supported. We will define its syntax, its semantics, describe its
properties and present a constraint propagation calculus for reasoning in it.

1. Introduction
The representation of uncertainty and imprecision has received a considerable attention in
the Artificial Intelligence community in an attempt to extend existing knowledge representation systems to deal with the imperfect nature of real world information (which is likely
the rule rather than an exception). An impressive work has been carried out in the last
decades, resulting in a number of concepts being investigated, a number of problems being
identified and a number of solutions being developed (Bacchus, 1990; Dubois & Prade, 1996;
Kruse, Schwecke, & Heinsohn, 1991; Pearl, 1988).
For most knowledge representation formalisms, First-Order Logic (FOL) has been the
basis: its basic units individuals, their properties, and the relationship between them
naturally capture the way in which people encode their knowledge. Unfortunately, it is
severely limited both (i) by its ability to represent our uncertainty about the world due
to lack of knowledge about the real world a fact can only estimated to be true to e.g.
a probability degree; and (ii) by its ability to represent inherently imprecise knowledge
indeed, there are concepts, like hot, for which no exact definition exists and, thus, a fact
like 35 Celsius is hot, rather being true or false, has a truth-value in between true and
false.
In the last decade a substantial amount of work has been carried out in the context of
Description Logics (DLs).1 DLs are a logical reconstruction of the so-called frame-based
knowledge representation languages, with the aim of providing a simple well-established
Tarski-style declarative semantics to capture the meaning of the most popular features of
structured representation of knowledge. A main point is that DLs are considered as to be
1. Description Logics have also been referred to as Terminological Logics, Concept Logics, KL-ONE-like
languages. The web page of the description logic community is found at address http://dl.kr.org/dl.
c
2001
AI Access Foundation and Morgan Kaufmann Publishers. All rights reserved.

fiStraccia

attractive logics in knowledge based applications as they are a good compromise between
expressive power and computational complexity.
Nowadays, a whole family of knowledge representation systems has been build using DLs,
which differ with respect to their expressiveness, their complexity and the completeness of
their algorithms, and they have been used for building a variety of applications (Peltason,
1991; Brachman, 1992; Baader & Hollunder, 1991a; Horrocks, 1998).
Experience in using DLs in applications has also shown that in many cases we would
like to extend the representational and reasoning capabilities of them. In particular, the use
of DLs in the context of Multimedia Information Retrieval (MIR) points out the necessity
of extending DLs with capabilities which allow the treatment of the inherent imprecision
in multimedia object representation and retrieval (Meghini & Straccia, 1996; Meghini, Sebastiani, & Straccia, 1997, 1998). In fact, classical DLs are insufficient for describing real
multimedia retrieval situations, as the retrieval is usually not only a yes-no question: (i) the
representations of multimedia objects content and queries which the system (and the logic)
have access to are inherently imperfect; and (ii) the relevance of a multimedia object to a
query can thus be established only up to a limited degree. Because of this, we need a logic
in which, rather than deciding tout court whether a multimedia object satisfies a query or
not, we are able to rank the retrieved objects according to how strongly the system believes
in their relevance to a query.
To this end, we will extend DLs with fuzzy capabilities. The choice of fuzzy set theory
as a way of endowing a DL with the capability to deal with imprecision is not uncommon
(da Silva, Pereira, & Netto, 1994; Tresp & Molitor, 1998; Yen, 1991) and can be motivated
 from a semantics point of view, as fuzzy logics capture the notion of imprecise concept,
i.e. a concept for which a clear and precise definition is not possible. Fuzzy concepts
play a key role in e.g. content descriptions of multimedia objects (most of humans
concepts are imprecise). For instance, in the context of images, the (semantic) content
of an image region r may be described by means of a fuzzy statement like r is about
a Ferrari and establish that this sentence has truth-value 0.8, i.e. r is likely about a
Ferrari;
 from a proof theoretical point of view, as there exist well-known techniques for reasoning in fuzzy logics (Chen & Kundu, 1996; Lee, 1972; Xiachun, Yunfei, & Xuhua,
1995).
In the following we will present a quite general fuzzy DL, in the sense that it is based on
the DL ALC, a significant and expressive representative of the various DLs. This allows
us to adapt it easily to the different DLs presented in the literature. Another important
point is that we will show that the additional expressive power has no impact from a
computational complexity point of view. This is certainly important as the nice tradeoff between computational complexity and expressive power of DLs contributes to their
popularity.
Note that our fuzzy extension for the management of imprecise knowledge is complementary to other DL extensions for the management of uncertainty, e.g. probabilistic extension
(Heinsohn, 1994; Jager, 1994; Koller, Levy, & Pfeffer, 1997; Sebastiani, 1994) with some exceptions like shown by Hollunder (1994) where a possibilistic DL has been considered. Even
138

fiReasoning within Fuzzy DLs

though these probabilistic extensions enlarge the applicability of DLs they do not address
the issue of reasoning about individuals and imprecise concepts, as imprecise knowledge and
uncertain knowledge are orthogonal (Dubois & Prade, 1994). Moreover, reasoning in a
probabilistic framework is generally a harder task, from a computational point of view, than
the relative non probabilistic case and in most cases a complete axiomatization is missing
(Halpern, 1990; Roth, 1996). As a consequence, the computational problems have to be
addressed carefully (Koller et al., 1997).
We will proceed as follows. In the following section we first introduce ALC. In Section 3
we extend ALC to the fuzzy case and discuss some properties in Section 4, while in Section 5
we will present a constraint propagation calculus for reasoning in it. Section 6 concludes
and presents some topics for further research.

2. A Quick Look to ALC
The specific DL we will extend with fuzzy capabilities is ALC, a significant representative
of DLs. At first, we will introduce classical ALC, while in Section 3 our fuzzy extension of
ALC will be presented.
We assume three alphabets of symbols, called primitive concepts (denoted by A), primitive roles (denoted by R) and individuals (denoted by a and b).2
2.1 Concept and Role
Concepts are expressions that collect the properties, described by means of roles, of a set of
individuals. From a FOL point of view, concepts can be seen as unary predicates, whereas
roles are interpreted as binary predicates.
A concept (denoted by C or D) of the language ALC is build out of primitive concepts
according to the following syntax rules:
C, D 

>|
|
A|
C u D|
C t D|
C|
R.C|
R.C

(top concept)
(bottom concept)
(primitive concept)
(concept conjunction)
(concept disjunction)
(concept negation)
(universal quantification)
(existential quantification).

2.2 Interpretation
DLs have a clean, model-theoretic semantics, based on the notion of interpretation. An
interpretation I is a pair I = (I , I ) consisting of a non empty set I (called the domain)
and of an interpretation function I mapping different individuals into different elements of
I (called unique name assumption), primitive concepts into subsets of I and primitive
roles into subsets of I  I . The interpretation of complex concepts is defined as usual:
2. Through this work we assume that every metavariable has an optional subscript or superscript.

139

fiStraccia

>I
I
(C u D)I
(C t D)I
(C)I
(R.C)I
(R.C)I

=
=
=
=
=
=
=

I

C I  DI
C I  DI
I \ C I
{d  I : d0 .(d, d0 ) 6 RI or d0  C I }
{d  I : d0 .(d, d0 )  RI and d0  C I }.

Note that each concept C and role R can be mapped into an equivalent open first-order
formula FC (x) and FR (x, y), respectively:
F> (x) = T

(1)

F (x) = F

(2)

FA (x) = A(x)

(3)

FR (x, y) = R(x, y)

(4)

FCuD (x) = FC (x)  FD (x)

(5)

FCtD (x) = FC (x)  FD (x)

(6)

FC (x) = FC (x)

(7)

FR.C (x) = y.FR (x, y)  FC (y)

(8)

FR.C (x) = y.FR (x, y)  FC (y),

(9)

where T and F are two formulae representing the truth-value true and false, respectively
(e.g. T = p  p and F = p  p, for some letter p).
Two concepts C and D are said to be equivalent (denoted by C  D) when C I = DI
for all interpretations I. Note that, e.g. >   ; C u D  (C t D), and (R.C) 
(R.C).
2.3 Assertion
An assertion (denoted by ) is an expression of type a:C (a is C, also a is an instance of
C), or an expression of type (a, b):R ((a, b) is R, also (a, b) is an instance of R). For
instance, tom:Tall u Student asserts that Tom is a tall student, whereas (tim, tom):Friend
asserts that Tom is a friend of Tim. A primitive assertion is either an assertion of the
form a:A, where A is a primitive concept, or an assertion of the form (a, b):R. From a
semantics point of view, an interpretation I satisfies a:C (resp. (a, b):R) iff aI  C I (resp.
(aI , bI )  RI ).
2.4 Terminological Axiom
A terminological axiom (denoted by  ) is either a concept specialisation or a concept definition. A concept specialisation is an expression of the form A<C, where A is a primitive
concept and C is a concept. A specialisation allows stating the existence of a specialisation (more specific than) relation between concepts. For instance, Ferrari<SportCar u
140

fiReasoning within Fuzzy DLs

Ownedby.CarFanatic states that a Ferrari is a sport car that is owned by a car fanatic.
On the other hand, a concept definition is an expression of the form A: = C, where
A is a primitive concept and C is a concept. A concept definition allows stating the
equivalence between concepts. For instance, Tennis: = SportKind u (HasSportTool.>) u
(HasSportTool.TennisRacket) states that tennis is identified by a kind of sport having a
tennis racket as a sport tool. From a semantics point of view, an interpretation I satisfies a
concept specialisation A<C iff AI  C I . Similarly, an interpretation I satisfies a concept
definition A: = C iff AI = C I .
2.5 Knowledge Base, Entailment and Subsumption
A finite set K of assertions and terminological axioms will be called a Knowledge Base (KB).
With KA we will denote the set of assertions in K, whereas with KT we will denote the set
of terminological axioms in K, also called a terminology. A KB K is purely assertional if
KT = . Further, we will assume that a terminology KT is such that no concept A appears
more than once on the left hand side of a terminological axiom   KT and that no cyclic
definitions are present in KT .3
We will say that an interpretation I satisfies (is a model of ) a KB K iff I satisfies each
element in K. A KB K entails an assertion  (denoted by K |= ) iff every model of K
also satisfies . Furthermore, let KT be a terminology and let C, D be two concepts. We
will say that D subsumes C with respect to (w.r.t.) KT (denoted by C vKT D) iff for every
model I of KT , C I  DI holds.
The problem of determining whether K |=  is called entailment problem; the problem of determining whether C vKT D is called subsumption problem; and the problem of
determining whether K is satisfiable is called satisfiability problem.
It is well known (Buchheit, Donini, & Schaerf, 1993a; Donini, Lenzerini, Nardi, &
Schaerf, 1994; Nebel, 1990) that in ALC
K |= (a, b):R iff (a, b):R  K
K |= a:C iff K  {a:C} is not satisfiable
C v D iff a:C |= a:D, for a new a
0

C vKT D iff C v D

0

(10)
(11)
(12)
(13)

where C 0 and D0 are build from C and D by expanding the terminology KT to KT00 and
substituting every primitive concept occurring in C or D, which is defined in KT00 , with its
defining term in KT00 . The expansion of a KB K works as follows (Nebel, 1990).
1. Elimination of concept specialisation: each concept specialisation A<C  KT is replaced with a concept definition A: = C u A , where A is a new primitive concept.
A stands for the absent part of the definition of A. Let KT0 be the terminology, which
is obtained by replacing all concept specialisation by concept definitions.
3. We will say that A directly uses primitive concept B in KT , if there is   KT such that A is on the left
hand side of  and B occurs in the right hand side of  . Let uses be the transitive closure of the relation
directly uses in KT . KT is cyclic iff there is A such that A uses A in KT .

141

fiStraccia

2. Expansion of KT0 : every defined concept (i.e. the first argument of a concept definition)
which occurs in the defining term of a concept definition (i.e. the second argument of
a concept definition) is substituted by its defining term. This process is iterated until
there remain only undefined concepts in the second arguments of concept definitions.
This yields a terminology KT00 .
3. Expansion of KA : every primitive concept occurring in KA which is defined in KT00 is
0 .
substituted by its defining term in KT00 . This yields KA
0 |= 0 , where 0 is obtained by
The transformation has the nice property that K |=  iff KA
replacing every primitive concept occurring in , which is defined in KT00 , with its defining
term in KT00 . While this allows us to restrict our attention to purely assertional KBs only,
it is worth noting that the expansion process can be exponential (Nebel, 1988).
From (10)(13), it follows that the above problems can be reduced to the satisfiability
problem. There exists a well known technique based on constraint propagation solving this
problem (Schmidt-Schau & Smolka, 1991; Buchheit, Donini, & Schaerf, 1993b; Donini
et al., 1994).
We conclude with an example.

Example 1 Consider the following terminology KT .
SportKind
<
SportTool
<
IndividualSport <
TeamSport
<
Basketball
<
TennisRacket
<
Basket
:=

Tennis

>
>
SportKind
SportKind
SportTool
SportTool
SportKindu
(KindOfSport.>)u
(KindOfSport.TeamSport)u
(HasSportTool.>)u
(HasSportTool.Basketball)
: = SportKindu
(KindOfSport.>)u
(KindOfSport.IndividualSport)u
(HasSportTool.>)u
(HasSportTool.TennisRacket)

Suppose that there are two video sequences v1, v2, which are about basket and tennis, respectively. We may represent the semantic content of them through
Kv1 = {v1:Video u About.Basket}
Kv2 = {v2:Video u About.Tennis}.
Consider K = KT  Kv1  Kv2 . If we are interested in retrieving videos about sport, we may
query K through the query concept Q = Video u About.SportKind and the answer will be
the list containing both v1 and v2, as K |= v1:Q and K |= v2:Q hold.
142

fiReasoning within Fuzzy DLs

On the other hand, if we are looking for individual sport videos, then, given the query
concept Q0 = Video u About.KindOfSport.IndividualSport, it follows that only video v2 will
be retrieved. In fact, K|=
6 v1:Q0 and K |= v2:Q0 hold.
2

3. A Fuzzy DL
Our fuzzy extension directly relates to Zadehs work on fuzzy sets (Zadeh, 1965). A fuzzy set
S with respect to an universe U is characterised by a membership function S : U  [0, 1],
assigning an S-membership degree, S (u), to each element u in U . S (u) gives us an
estimation of the belonging of u to S. Typically, if S (u) = 1 then u definitely belongs to
S, while S (u) = 0.8 means that u is likely to be an element of S. Moreover, according to
Zadeh, the membership function has to satisfy three well known restrictions: for all u  U
and for all fuzzy sets S1 , S2 with respect to U
S1 S2 (u) = min{S1 (u), S2 (u)}
S1 S2 (u) = max{S1 (u), S2 (u)}
S1 (u)
= 1  S1 (u) ,
where S1 is the complement of S1 in U . Alternative restrictions on membership functions
have been proposed in the literature, but it is not our aim to investigate them here (the
interested reader may consult e.g. Dubois & Prade, 1980).
A justification of the choice of the min and the max was given by Bellman and Giertz
(1973), which have shown that under certain reasonable conditions min and max are the
unique possible choice for set intersection and set union, respectively.
When we switch to fuzzy logics, the notion of degree of membership S (u) of an element
u  U w.r.t. the fuzzy set S over U is regarded as the truth-value of the statement u is
S. Accordingly, in our fuzzy DL, (i) a concept C, rather than being interpreted as a
classical set, will be interpreted as a fuzzy set and, thus, concepts become imprecise; and,
consequently, (ii) the statement a is C, i.e. a:C, will have a truth-value in [0, 1] given by
the degree of membership of being the individual a a member of the fuzzy set C.
3.1 Fuzzy Interpretation
A fuzzy interpretation is now a pair I = (I , I ), where I is, as for the crisp case, the
domain, whereas I is an interpretation function mapping
1. individuals as for the crisp case, i.e. aI 6= bI , if a 6= b;
2. a concept C into a membership function C I : I  [0, 1];
3. a role R into a membership function RI : I  I  [0, 1].
If C is a concept then C I will naturally be interpreted as the membership degree function
of the fuzzy concept (set) C w.r.t. I, i.e. if d  I is an object of the domain I then
C I (d) gives us the degree of being the object d an element of the fuzzy concept C under
the interpretation I. Similarly for roles. Additionally, the interpretation function I has to
satisfy the following equations: for all d  I ,
143

fiStraccia

>I (d)
I (d)
(C u D)I (d)
(C t D)I (d)
(C)I (d)
(R.C)I (d)
(R.C)I (d)

=
=
=
=
=
=
=

1
0
min{C I (d), DI (d)}
max{C I (d), DI (d)}
1  C I (d)
inf d0 I {max{1  RI (d, d0 ), C I (d0 )}}
supd0 I {min{RI (d, d0 ), C I (d0 )}}.

These equations are the standard interpretation of conjunction, disjunction, negation and
quantification, respectively (see Lee, 1972; Tresp & Molitor, 1998).
Note that the semantics of R.C
(R.C)I (d) = supd0 I {min{RI (d, d0 ), C I (d0 )}}

(14)

is the result of viewing R.C as the open first order formula y.FR (x, y)  FC (y) (see (9))
and the existential quantifier  is viewed as a disjunction over the elements of the domain.
Similarly,
(R.C)I (d) = inf d0 I {max{1  RI (d, d0 ), C I (d0 )}}

(15)

is related to the open first order formula y.FR (x, y)  FC (y) (see (8)), where the universal
quantifier  is viewed as a conjunction over the elements of the domain.
We will say that two concepts C and D are said to be equivalent (denoted by C 
= D)
when C I = DI for all interpretations I. As for the crisp non fuzzy case, dual relationships
between concepts hold: e.g. > 
=  , (C u D) 
= (C t D) and (R.C) 
= (R.C).
3.2 Fuzzy Assertion
A fuzzy assertion (denoted by ) is an expression having one of the following form h  ni
or h  mi, where  is an ALC assertion, n  (0, 1] and m  [0, 1). From a semantics point
of view, a fuzzy assertion h  ni constrains the truth-value of  to be less or equal to n
(similarly for ). Consequently, e.g. hv1:Video u About.Basket  0.8i states that video v1 is
likely about basket. Formally, an interpretation I satisfies a fuzzy assertion ha:C  ni (resp.
h(a, b):R  ni) iff C I (aI )  n (resp. RI (aI , bI )  n). Similarly, an interpretation I satisfies
a fuzzy assertion ha:C  ni (resp. h(a, b):R  ni) iff C I (aI )  n (resp. RI (aI , bI )  n).
Two fuzzy assertions  1 and  2 are said to be equivalent (denoted by  1 
=  2 ) iff they are
satisfied by the same set of interpretations. Notice that the combination of both ha:C  mi
and ha:C  ni, with m  n, restricts the truth-value of a:C in between [m, n]. Moreover,
ha:C  ni 
= ha:C  1  ni. A primitive fuzzy assertion is a fuzzy assertion involving a
primitive assertion.
One might wonder why we do not allow expressions of the form h > ni or the form
h < ni. The reason simply relies on the observation that it is quite hard to imagine
situations in which we are able to assert such strict >, < relations. So we will leave them
out for ease.4
4. Of course, the whole can easily be extended in case we would like to consider these two types of assertions
too.

144

fiReasoning within Fuzzy DLs

Note that in the work of Straccia (1998), no fuzzy assertion of the form h  ni is
allowed.
3.3 Fuzzy Terminological Axiom
Fuzzy terminological axioms we will consider are a natural extension of classical terminological axioms to the fuzzy case. From a syntax point of view, a fuzzy terminological axiom
(denoted by  ) is either a fuzzy concept specialisation or a fuzzy concept definition. A fuzzy
concept specialisation is an expression of the form AC, where A is a primitive concept
and C is a concept. On the other hand, a fuzzy concept definition is an expression of the
form A: C, where A is a primitive concept and C is a concept. From a semantics point of
view, we consider the natural extension of classical set inclusion to the fuzzy case (Zadeh,
1965). A fuzzy interpretation I satisfies a fuzzy concept specialisation AC iff
d  I , AI (d)  C I (d),

(16)

whereas I satisfies a fuzzy concept definition A: C iff
d  I , AI (d) = C I (d).

(17)

Note that in the work of Straccia (1998) a fuzzy specialisation is non-standard. Indeed, Straccia (1998) considered fuzzy specialisations of the form hA  C  ni where
(A  C)I = mindI {max{1  AI (d), C I (d)}}. A drawback of this formulation is that
it is not clear where the n in hA  C  ni comes from, i.e. who defines the value n and
how it is determined. We prefer to rely here on the standard interpretation of fuzzy subsets.
3.4 Fuzzy Knowledge Base, Fuzzy Entailment and Fuzzy Subsumption
A fuzzy knowledge base is a finite set of fuzzy assertions and fuzzy terminological axioms.
As for the crisp case, with A we will denote the set of fuzzy assertions in , with T we
will denote the set of fuzzy terminological axioms in  (the terminology), if T =  then 
is purely assertional, and we will assume that a terminology T is such that no concept A
appears more than once on the left hand side of a fuzzy terminological axiom   T and
that no cyclic definitions are present in T .
An interpretation I satisfies (is a model of ) a set of fuzzy  iff I satisfies each element
of . A fuzzy KB  fuzzy entails a fuzzy assertion  (denoted by |) iff every model of
 also satisfies .
Furthermore, let T be a terminology and let C, D be two concepts. We will say
that D fuzzy subsumes C w.r.t. T (denoted by C T D) iff for every model I of T ,
d  I , C I (d)  DI (d) holds.
Finally, given a fuzzy KB  and an assertion , it is of interest to compute s best
lower and upper truth-value bounds. To this end we define the greatest lower bound of
 w.r.t.  (denoted by glb(, )) to be sup{n : |h  ni}. Similarly, we define the
least upper bound of  with respect to  (denoted by lub(, )) to be inf{n : |h  ni}
(sup  = 0, inf  = 1). Determining the lub and the glb is called the Best Truth-Value Bound
(BTVB) problem.
145

fiStraccia

4. Some Properties
In this section we discuss some properties of our fuzzy logic. Several properties described
by Straccia (2000b) for the propositional case are easily extended to our first order case too.
4.1 Concept Equivalence
 C u>=
 C, C t > =
 >, Cu =,
 Ct =
 C,
The first ones are straightforward: > =,




C = C, (C uD) = C tD, (C tD) = C uD, C1 u(C2 tC3 ) = (C1 uC2 )t(C1 uC3 )
and C1 t (C2 u C3 ) 
= (C1 t C2 ) u (C1 t C3 ). For concepts involving roles, we have R.C 
=



R.C, R.> = >, R. = and (R.C) u (R.D) = R.(C u D). Please, note that we
and
do not have C u C 
6
=
=, nor we have C t C 
= > and, thus, (R.C) u (R.C) 
I
(R.C) t (R.C) 6
= > hold. In general we can only say that (C u C) (d)  0.5, for any
interpretation I and d  I and, similarly, (C t C)I (d)  0.5, i.e. lub(, a:C u C) = 0.5
and glb(, a:C t C) = 0.5, respectively.
4.2 Entailment Relation
Of course, |h  ni iff glb(, )  n, and similarly |h  ni iff lub(, )  n hold.
Concerning roles, note that |h(a, b):R  ni iff h(a, b):R  mi   with m  n. Therefore,
glb(, R(a, b)) = max{n : hR(a, b)  ni  }

(18)

while the same is not true for the  case. While h(a, b):R  mi   and m  n imply
|h(a, b):R  ni, the converse is false (e.g. {ha:R.A  1i, hb:A  0i}|h(a, b):R  0i)).
Furthermore, from |ha:C  ni iff |ha:C  1  ni,
1  lub(, C(a)) =
=
=
=
=

1  inf{n : |ha:C  ni}
sup{1  n : |ha:C  ni}
sup{n : |ha:C  1  ni}
sup{n : |ha:C  ni}
glb(, a:C).

follows. Therefore,
lub(, a:C) = 1  glb(, a:C),

(19)

i.e. lub can be determined through glb (and vice-versa). The same reduction to glb does
not hold for lub(, (a, b):R) as (a, b):R is not an expression of our language.5
Modus ponens on concepts is supported: if m > 1n then {ha:C  mi, ha:C t D  ni}|
ha:D  ni holds.
Modus ponens on roles is supported: if m > 1  n then {h(a, b):R  mi, ha:R.D  ni}
|ha:D  ni and {ha:R.C  mi, ha:R.D  ni} |ha:R.(C u D)  min{n, m}i hold. Moreover, {ha:R.C  mi, ha:R.D  ni} |ha:R.(C u D)  min{n, m}i holds.
Modus ponens on specialisation is supported. The following degree bounds propagation
through a taxonomy is supported. If C  D then (i)   {ha:C  ni}|ha:D  ni; and
(ii)   {ha:D  ni}|ha:C  ni hold.
5. Of course, lub(, (a, b):R) = 1  glb(, (a, b):R) holds, where (R)I (d, d0 ) = 1  RI (d, d0 ).

146

fiReasoning within Fuzzy DLs

Note that, according to Straccia (1998)
if m > 1  n then {ha:A  mi, hA  C  ni}|ha:C  ni.
A drawback of the above property is that whatever the degree m is (as long as m > 1  n),
from ha:A  mi and hA  C  ni we infer ha:C  ni, where n is a priori fixed value.
4.3 Soundness of the Semantics
Our fuzzy semantics is sound w.r.t. crisp semantics. In fact, let  be a fuzzy KB in which
no h(a, b):R  ni occurs. We leave these fuzzy assertions out, as role negation is not present
in crisp ALC. Let us consider the following transformation ]() of fuzzy assertions into
assertions, where ]() takes the crisp assertional part of a fuzzy assertion:
]h  ni 7 
]ha:C  ni 7 a:C.
We extend ]() to fuzzy terminological axioms as follows: ] =  . Finally, ] = {] :  
}  {] :   T }.
It is quite easily to verify that
Proposition 1 Let  be a fuzzy KB in which no h(a, b):R  ni occurs and let  be a fuzzy
assertion h  ni. If |h  ni then ] |= ] (i.e. there cannot be fuzzy entailment
without entailment in ALC).
a
Proof: Consider a classical interpretation I satisfying ]. I is also a fuzzy interpretation
such that C I (d)  {0, 1}, RI (d, d0 )  {0, 1} hold. By induction on the structure of a
concept C it can be shown that I (classically) satisfies a:C iff C I (aI ) = 1. Similarly for
roles. Therefore, I is a fuzzy interpretation satisfying . By hypothesis, I satisfies h  ni
and n > 0. Therefore, the truth-value of  under I is 1, i.e. I satisfies . 2
For the general case,  has to be satisfiable as h(a, b):R  ni may introduce an inconsistency,
e.g. {h(a, b):R  0.3i, h(a, b):R  0.4i}|ha:A  1i, but {(a, b):R} 6|= a:A}.
The converse of Proposition 1 does not hold in general.
Example 2 Let  be the set  = {ha:A t B  0.6i, ha:A  0.3i}. It follows that ] =
{a:(A t B), a:A} which is unsatisfiable. Therefore, it can easily be verified that ] |= a:B,
but  |
6 ha:B  ni, for all n > 0.
2
Once we restrict the attention to normalised fuzzy assertions, a converse relation follows
immediately (Lee, 1972; Straccia, 2000b).
Indeed, we say that a fuzzy assertion  is KB-normalised iff
1. if  is h  ni then n > 0.5;
2. if  is h  ni then n < 0.5.
We say that a fuzzy assertion  is query-normalised iff
147

fiStraccia

1. if  is h  ni then n  0.5;
2. if  is h  ni then n  0.5.
Note that the definitions for KB-normalisation and query-normalisation are dual. The
following proposition follows from (Lee, 1972; Straccia, 2000b) and relies on the fact that
h  ni and h  mi are together inconsistent, if n > 0.5 and m < 0.5. In particular,
Straccia (2000b) shows that if  and  are a normalised fuzzy propositional KB and a
query-normalised fuzzy proposition, then Then | iff ] |= ]. The proof is given
by showing that from a deduction proving | a deduction proving ] |= ] can be
build and vice-versa. The extension to our case is straightforward as e.g. for n, m > 0.5,
ha:R.C  ni,h(a, b):R  mi|hb:C  ni iff a:R.C, (a, b):R |= b:C holds (the other firstorder cases involving  and  are similar).
Proposition 2 Let  be a fuzzy KB in which no h(a, b):R  ni occurs and each    is
KB-normalised. Let  be a query-normalised fuzzy assertion. Then | iff ] |= ]. a
Example 3 Let  be the set  = {ha:A u B  0.4i, ha:A  0.6i}. Let  be ha:B  0.7i.
Each fuzzy assertion in  is KB-normalised and  is query-normalised. It follows that
] = {a:(A u B), a:A} and ] = a:B. It is easily verified that | and that ] |= ],
thereby confirming Proposition 2.
2
4.4 Subsumption
At first, as for the classical case and with the same method seen before, subsumption
between two concepts C and D w.r.t. a terminology T , i.e. C T D, can be reduced to
the case of an empty terminology, i.e. C 0  D0 .
Example 4 Suppose we have two images i1 and i2 each being a snapshot of the car traffic
on a major street of an European city. An underlying image analysis tool recognizes, among
all the recognised objects, that in image i1 there is a Ferrari, while in image i2 there is a
Porsche. Furthermore, a semantic image indexing tool establishes that, to some degree n
image i1 is about a Ferrari, whereas to some degree m image i2 is about a Porsche. Please
note that, as a weight of a keyword in text is a quantitative description of the aboutness of
the text w.r.t. the keyword, a truth-degree gives a quantitative description of the aboutness
of an images w.r.t. an object, i.e. the aboutness is handled as an imprecise concept. So, let
us consider
 = {hi1:About.Ferrari  0.6i, hi2:About.Porsche  0.8i,
FerrariCar, PorscheCar}.
where the axioms specify that both a Ferrari and a Porsche are a car. According to the
expansion process,  will be replaced by
0 = {hi1:About.Ferrari  0.6i, hi2:About.Porsche  0.8i,
Ferrari: Car u Ferrari , Porsche: Car u Porsche },
which will be simplified to
148

fiReasoning within Fuzzy DLs

00 = {hi1:About.(Car u Ferrari )  0.6i,
hi2:About.(Car u Porsche )  0.8i}.
Now, if we are looking for images which are about cars, then from  we may infer that  |
hi1:About.Car  0.6i and |hi2:About.Car  0.8i. Furthermore, it is easily verified that
00 | hi1:About.Car  0.6i and 00 |hi2:About.Car  0.8i hold as well. Indeed, for any
fuzzy assertion , | iff 00 | holds.
2
We conclude this section with the analogue of Example 1 for the fuzzy case..
Example 5 Consider the terminology KT and the query concept Q in Example 1. Let
us define T as the fuzzy KB derived from KT in which each terminological axiom  has
been replaced with the fuzzy terminological axiom  . Moreover, let us suppose that an
underlying semantic video indexing tool furnishes the following semantic descriptions of the
two videos v1 and v2.
v1 = {hv1:Video  1i, hv1:About.Basket  0.9i}
v2 = {hv2:Video  1i, hv2:About.Tennis  0.6i},
i.e. video v1 is about basket with degree 0.9, whereas video v2 is about tennis with degree
0.6. Let us consider  = T  v1  v2 . It is easily verified that glb(, v1:Q) = 0.9,
whereas glb(, v2:Q) = 0.6 hold. Therefore, video v1 will be ranked before video v2 after
the retrieval process.
2

5. Decision Algorithms in Fuzzy ALC
Deciding whether |h  ni or |h  mi requires a calculus. Without loss of generality
we will consider purely assertional fuzzy KBs only.
We will develop a calculus in the style of the constraint propagation method, as this
method is usually proposed in the context of DLs (Buchheit et al., 1993a). The calculus
extends the fuzzy propositional calculus described by Chen and Kundu (1996) and by
Straccia (2000b) to our fuzzy DL case. We first address the entailment problem, then the
subsumption problem and finally the BTVB problem. Both the subsumption problem and
the BTVB problem will be reduced to the entailment problem.
5.1 A Decision Procedure for the Entailment Problem
Consider a new alphabet of ALC variables. An interpretation is extended to variables by
mapping these into elements of the interpretation domain. An ALC object (denoted by w)
is either an individual or a variable.6
A constraint (denoted by ) is an expression of the form w:C or (w, w0 ):R, where w, w0
are objects, C is an ALC concept and R is a role. A fuzzy constraint (denoted by ) is an
expression having one of the following four forms: h  ni, h > ni, h  ni, h < ni. Note
that assertions and fuzzy assertions are constraints and fuzzy constraints, respectively.
6. In the following, if there is no ambiguity, ALC variables and ALC objects are called variables and objects,
respectively.

149

fiStraccia

The definitions of satisfiability of a constraint, a fuzzy constraint, a set of constraints,
a set of fuzzy constraints, primitive constraint and primitive fuzzy constraint are obvious.
It is quite easily verified that the fuzzy entailment problem can be reduced to the
unsatisfiability problem of a set of fuzzy constraints:
|h  ni

iff

  {h < ni} not satisfiable

(20)

|h  ni

iff

  {h > ni} not satisfiable.

(21)

Our calculus, determining whether a finite set S of fuzzy constraints is satisfiable or not, is
based on a set of constraint propagation rules transforming a set S of fuzzy constraints into
simpler satisfiability preserving sets Si until either all Si contain a clash (indicating that
from all the Si no model of S can be build) or some Si is completed and clash-free, that is,
no rule can be further be applied to Si and Si contains no clash (indicating that from Si a
model of S can be build).
A set of fuzzy constraints S contains a clash iff it contains either one of the constraints in
Table 1 or S contains a conjugated pair of fuzzy constraints. Each entry in Table 2 says us
hw:  ni, where n > 0
hw:>  ni, where n < 1
hw: > ni, hw:> < ni, hw:C < 0i, hw:C > 1i
Table 1: Clashes

h  ni
h > ni

h < mi h  mi
nm
n>m
nm
nm

Table 2: Conjugated Pairs
under which condition the row-column pair of fuzzy constraints is a conjugated pair. Given
a fuzzy constraint , with  c we indicate a conjugate of  (if there exists one). Notice that
a conjugate of a fuzzy constraint may be not unique, as there could be infinitely many. For
instance, both ha:C < 0.6i and ha:C  0.7i are conjugates of ha:C  0.8i.
Concerning the rules, for each connective u, t, , ,  there is a rule for each relation , >
, , <, i.e. there are 20 rules. The rules have the form:
   if 

(22)

where  and  are sequences of fuzzy constraints and  is a condition. A rule fires only
if the condition  holds, if the current set S of fuzzy constraints contains fuzzy constraints
matching the precondition  and the consequence  is not already in S. After firing, the
constraints from  are added to S. The rules are the following:
150

fiReasoning within Fuzzy DLs

( )

hw:C  ni  hw:C  1  ni

(> )

hw:C > ni  hw:C < 1  ni

( )

hw:C  ni  hw:C  1  ni

(< )

hw:C < ni  hw:C > 1  ni

(u )

hw:C u D  ni  hw:C  ni, hw:D  ni

(u> )

hw:C u D > ni  hw:C > ni, hw:D > ni

(t )

hw:C t D  ni  hw:C  ni, hw:D  ni

(t< )

hw:C t D < ni  hw:C < ni, hw:D < ni

(t )

hw:C t D  ni  hw:C  ni | hw:D  ni

(t> )

hw:C t D > ni  hw:C > ni | hw:D > ni

(u )

hw:C u D  ni  hw:C  ni | hw:D  ni

(u< )

hw:C u D < ni  hw:C < ni | hw:D < ni

( )

hw1 :R.C  ni,  c  hw2 :C  ni
if  is h(w1 , w2 ):R  1  ni

(> )

hw1 :R.C > ni,  c  hw2 :C > ni
if  is h(w1 , w2 ):R < 1  ni

( )

hw1 :R.C  ni,  c  hw2 :C  ni
if  is h(w1 , w2 ):R  ni

(< )

hw1 :R.C < ni,  c  hw2 :C < ni
if  is h(w1 , w2 ):R < ni

( )

hw:R.C  ni  h(w, x):R  ni, hx:C  ni
if x new variable and there is no w0 such that both
h(w, w0 ):R  ni and hw0 :C  ni are already in the constraint set

(> )

hw:R.C > ni  h(w, x):R > ni, hx:C > ni
if x new variable and there is no w0 such that both
h(w, w0 ):R > ni and hw0 :C > ni are already in the constraint set

( )

hw:R.C  ni  h(w, x):R  1  ni, hx:C  ni
if x new variable and there is no w0 such that both
h(w, w0 ):R  1  ni and hw0 :C  ni are already in the constraint set

(< )

hw:R.C < ni  h(w, x):R > 1  ni, hx:C < ni
if x new variable and there is no w0 such that both
h(w, w0 ):R > 1  ni and hw0 :C < ni are already in the constraint set
151

(23)

fiStraccia

Examples of rule instances are the following:
( )

ha:R.C  0.7i, h(a, b):R  0.6i  hb:C  0.7i
 is h(a, b):R  0.3i
 c = h(a, b):R  0.6i is a conjugate of 

(< )

ha:R.C < 0.8i, h(a, b):R  0.9i  hb:C < 0.8i
 is h(a, b):R < 0.8i
 c = h(a, b):R  0.9i is a conjugate of 

( )

ha:R.C  0.8i  h(w, x):R  0.8i, hx:C  0.8i
x new variable

(< )

ha:R.C < 0.8i  h(w, x):R > 0.2i, hx:C < 0.8i
x new variable.

A set of fuzzy constraints S is said to be complete if no rule is applicable to it. Any complete
set of fuzzy constraints S2 obtained from a set of fuzzy constraints S1 by applying the above
rules (23) is called a completion of S1 . Due to the rules (t ), (t> ), (u ) and (u< ), more
than one completion can be obtained. These rules are called nondeterministic rules. All
other rules are called deterministic rules.
It is easily verified that the above calculus has the termination property, i.e. any completion of a finite set of fuzzy constraints S can be obtained after a finite number of rule
applications.
Example 6 Let us consider the following fuzzy KB:
 = {ha:R.D  0.7i, ha:R.C  0.4i, h(a, b):R  0.5i, hb:C  0.2i, hb:D  0.3i}
Let  be the assertion a:R.(D u C), let  be the fuzzy assertion h  0.4i, whereas let  0 be
the fuzzy assertion h  0.5i. It is easily verified that |, whereas  |
6  0 . We show that
0
 |
6  , by verifying that there is a clash-free completion of S =   {ha:R.(D u C) < 0.5i}
(precisely, there are two of them).
By applying rules (23), we have the following sequences.
(1)
(2)
(3)
(4)
(5)
(6)
(7)
(8)
(9)
(10)

ha:R.D  0.7i
ha:R.C  0.4i
h(a, b):R  0.5i
hb:C  0.2i
hb:D  0.3i
ha:R.(D u C) < 0.5i
h(a, x):R  0.7i, hx:D  0.7i
hx:C  0.4i
hb:D u C < 0.5i
hx:D u C < 0.5i
1 |  2
152

Hypothesis:S

( ) : (1)
( ) : (2), (7)
(< ) : (3), (6)
(< ) : (6), (7)

fiReasoning within Fuzzy DLs

where the two sequences 1 and 2 are defined as follows: for 1 we have the two sequences
(11) hb:D < 0.5i (u< ) : (9)
(12) hx:D < 0.5i (u< ) : (10)
(13) clash
(7), (12)

(14) hx:C < 0.5i (u< ) : (10)
(15) clash-free

and for 2 we have the two sequences
(16) hb:C < 0.5i (u< ) : (9)
(17) hx:D < 0.5i (u< ) : (10)
(18) clash
(7), (17)

(19) hx:C < 0.5i (u< ) : (10)
(20) clash-free

2
Example 7 Consider Example 4 and let us prove that 00 |h(About.Car)(i1)  0.6i. We
prove the above relation by verifying that all completions of S = 00  {hi1:About.Car < 0.6i}
contain a clash. In fact, we have the following sequence.
(1)
(2)
(3)
(4)
(5)
(6)
(7)

hi1:About.(Car u Ferrari )  0.6i
Hypothesis:S
hi2:About.(Car u Porsche )  0.8i
hi1:About.Car < 0.6i
h(i1, x):About  0.6i, hx:(Car u Ferrari )  0.6i ( ) : (1)
hx:Car < 0.6i
(< ) : (3), (4)
(u) : (4)
hx:Car  0.6i, hx:Ferrari  0.6i,
clash
(5), (6)

2
Proposition 3 A finite set of fuzzy constraints S is satisfiable iff there exists a clash free
completion of S.
a
Proof:
 .) Given the termination property, it is easily verified, by case analysis, that the
above rules are sound, i.e. if S1 is satisfiable then there is a satisfiable completion S2
of S1 and, thus, S2 contains no clash. For instance, let us show that the ( ) rule is
sound. Assume I is an interpretation satisfying hw1 :R.C  ni and h(w1 , w2 ):R  mi,
where m > 1  n. Let us show that I satisfies hw2 :C  ni. Since I satisfies hw1 :R.C  ni
it follows that max{1  RI (w1 I , w2 I ), C I (w2 I )}  n. But, RI (w1 I , w2 I )  m and, thus,
1  RI (w1 I , w2 I )  1  m < n. As a consequence, C I (w2 I )  n follows, i.e. I satisfies
hw2 :C  ni.
 .) Suppose that there exists a clash free completion S 0 of S. We build from S 0 an
interpretation I satisfying S 0 and, as S  S 0 , I satisfies S. I is called canonical model.
For any primitive constraint   S 0 , we collect its lower and upper bound restrictions
in S 0 as follows: let
N  [] = {n : h  ni  S 0 }
N > [] = {n : h > ni  S 0 }
N  [] = {n : h  ni  S 0 }
N < [] = {n : h < ni  S 0 }.
153

fiStraccia

We have to define I such that for each constraint , I satisfies the constraints collected
in the sets N () []: given N  [], the truth value n of  under I has to be such that
n  max N  [], whereas w.r.t. N > [], the truth value n of  under I has to be such that
n  max N > [] + , for a  > 0. Similarly, for the other cases, for instance, w.r.t. N < [],
the truth value n of  under I has to be such that n  max N > []  , for a  > 0. The
two tables below
N  [] N > []
glb[, ]


0
0

6= 
n +
6= 

n
0
6= 
6= 
if n > n then n else n0 + 
N  [] N < []



6= 
6= 

6= 
6= 

lub[, ]
1
m0  
m
if m < m0 then m else m0  

define for any   S 0 and  > 0, lub[, ] and glb[, ], the lower and upper bound constraints
which I has to satisfy. In the tables, with n, n0 , m, m0 we indicate max N  [], max N > [],
min N  [] and min N < [], respectively. In each table we distinguish between the four cases
where the sets are empty (no constraints) or not. For instance, if for a constraint w:A, only
hw:A  0.3i, hw:A > 0.4i, hw:A  0.5i and hw:A < 0.6i are in S 0 , then according to the first
table bellow (row 4), for a  > 0, glb[w:A, ] = 0.4 + , whereas lub[w:A, ] = 0.5.
We will define I such that AI (wI ) = glb[w:A, ]. To make sure that glb[w:A, ] 
I
A (wI )  lub[w:A, ], we have to choose an  > 0 small enough such that glb[w:A, ] 
lub[w:A, ], i.e. 0.4 +   0.5. The existence of such an  > 0 is guaranteed by the fact that
S 0 is clash-free. An additional condition that the choice of such an  has to satisfy concerns
the case of a constraint  of type (w, w0 ):R. Let us show the problem with an example.
Suppose S 0 is {h(w, w0 ):R > 0.3i, hw:R.B  0.6i, hw0 :B  0.5i}. Therefore, according to
the above tables, glb[(w, w0 ):R, 1 ] = 0.3 + 1 , lub[(w, w0 ):R, 1 ] = 1, glb[w0 :B, 2 ] = 0
and lub[w0 :B, 2 ] = 0.5. So, it seems that it is sufficient to choose an 1 > 0 such that
0.3 + 1  1, which is indeed not the case. In fact, hw:R.B  0.6i and hw0 :B  0.5i
introduces an upper bound on (w, w0 ):R, i.e. the truth-value of (w, w0 ):R under I has to be
less or equal to 0.4 = 1  0.6. That is, we have to choose an 1 > 0 such that 0.3 + 1  0.4.
Otherwise, the truth-value of w0 :B under I has to be greater or equal to 0.6, contradicting
lub[w0 :B, 2 ] = 0.5. Again, the existence of such an  is guaranteed as S 0 is clash-free.
Summing up: since S 0 is clash-free, it follows that for each primitive constraint , there
is [] > 0 such that
glb[, []]  lub[, []]
where if  is (w, w0 ):R then
for
for
for
for

each
each
each
each

hw:R.C
hw:R.C
hw:R.C
hw:R.C

 ni,
> ni,
 ni,
< ni,

if
if
if
if

hw0 :C
hw0 :C
hw0 :C
hw0 :C

 ni 6 S 0
> ni 6 S 0
 ni 6 S 0
< ni 6 S 0
154

then
then
then
then

glb[, []]  1  n;
glb[, []] < 1  n;
glb[, []]  n;
glb[, []] < n.

(24)

fiReasoning within Fuzzy DLs

Now, consider the following interpretation I such that
1. the domain I is the set of objects appearing in S 0 ;
2. wI = w, for all w  I ;
3. >I (wI ) = 1 and I (wI ) = 0, for all w  I ;
4. AI (wI ) = glb[w:A, [w:A]], for all primitive concepts A and for all w  I ; and
5. RI (wI , w0 I ) = glb[(w, w0 ):R, [(w, w0 ):R]], for all roles R and for all w, w0  I .
We show, on induction on the structure of fuzzy constraints   S 0 , that I satisfies S 0 .
Case hw:A > ni: By definition, AI (wI ) = glb[w:A, [w:A]] > n and, thus, I satisfies
hw:A > ni. The cases ,  and < are similar.
Case h(w, w0 ):R  ni: By definition, RI (wI , w0 I ) = glb[(w, w0 ):R, [(w, w0 ):R]]  n and,
thus, I satisfies h(w, w0 ):R  ni. The cases >,  and < are similar.
Case hw:C u D  ni: From hw:C u D  ni  S 0 and S 0 completed, hw:C  ni  S 0 and
hw:D  ni  S 0 follows. By induction, I satisfies both hw:C  ni and hw:D  ni and, thus,
I satisfies hw:C u D  ni. The cases >,  and < are similar.
The cases involving C and C t D can be shown similarly.
Case hw:R.C  ni: Let  be (w, w0 ):R and consider hw0 :C  ni. It follows that, either (i)
hw0 :C  ni  S 0 ; or (ii) hw0 :C  ni 6 S 0 . Case (i): by induction, I satisfies hw0 :C  ni and,
thus, max{1  RI (w, w0 ), C I (w0 )}  C I (w0 )  n. Case (ii): by construction RI (w, w0 ) =
glb[(w, w0 ):R, [(w, w0 ):R]] and RI (w, w0 )  1n (see Equation 24). It follows that max{1
RI (w, w0 ), C I (w0 )}  1RI (w, w0 )  n. Therefore, inf w0 I max{1RI (w, w0 ), C I (w0 )} 
n, i.e. I satisfies hw:R.C  ni.
The cases hw:R.C > ni, hw:R.C  ni and hw:R.C < ni can be shown similarly.
Case hw:R.C  ni: Since S 0 is complete, both h(w, w0 ):R  ni and hw0 :C  ni are in
S 0 . By induction, I satisfies both h(w, w0 ):R  ni and hw0 :C  ni. As a consequence,
min{RI (w, w0 ), C I (w0 )}  n follows and, thus, supw0 I min{RI (w, w0 ), C I (w0 )}  n, i.e.
I satisfies hw:R.C  ni.
The cases hw:R.C > ni, hw:R.C  ni and hw:R.C < ni can be shown similarly. 2
The following example shows how such an interpretation is build.
Example 8 Let us consider Example 6 and the fuzzy assertion  0 . We have shown that
 |
6  0 by constructing two clash-free completions from S. Let us consider the clash-free
completion S1 in branch 1 :
S1 =   { ha:R.(D u C) < 0.5i, h(a, x):R  0.7i, hx:D  0.7i, hx:C  0.4i,
hb:D u C < 0.5i, hx:D u C < 0.5i, hb:D < 0.5i, hx:C < 0.5i}
We show that S1 is satisfiable by building an interpretation as described in the proof of
Proposition 3. Accordingly, for i > 0,
155

fiStraccia

glb[(a, b):R, 1 ]
glb[b:C, 2 ]
glb[b:D, 3 ]
glb[(a, x):R, 4 ]
glb[x:D, 5 ]
glb[x:C, 6 ]

=
=
=
=
=
=

0.5
0.2
0.3
0.7
0.7
0.4

lub[(a, b):R, 1 ]
lub[b:C, 2 ]
lub[b:D, 3 ]
lub[(a, x):R, 4 ]
lub[x:D, 5 ]
lub[x:C, 6 ]

=
=
=
=
=
=

1
1
0.5  3
1
1
0.5  6 .

Therefore, we can freely choose 2 , 4 and 5 , whereas 3 and 6 have to be such that
0.3  0.5  3 and 0.4  0.5  6 . As both h(a, b):R  0.5i and ha:R.C  0.4i are in
S1 , while hb:C  0.4i 6 S1 , we have the additional restriction on the choice of 1 (see
Equation 24) that glb[(a, b):R, 1 ]  0.6. But, glb[(a, b):R, 1 ] = 0.5  0.6, for every 1 and,
thus, the choice of 1 is also free. A solution to the i is e.g. i = 0.1 and, thus, let I be the
following interpretation:
1. the domain I is the set {a, b, x};
2. wI = w, for all w  I ;
3. >I (wI ) = 1 and I (wI ) = 0, for all w  I ;
4. C I (b) = 0.2, DI (b) = 0.3, DI (x) = 0.7 and C I (x) = 0.4 (in all other cases, AI (w) =
0); and
5. RI (a, b) = 0.5 and RI (a, x) = 0.7 (in all other cases, R0 I (w, w0 ) = 0).
Now, it is easily verified that I satisfies S1 and S.

2

From a computational complexity point of view, the fuzzy entailment problem can be proven
to be a PSPACE-complete problem, as is the classical entailment problem.
Proposition 4 Let  be a fuzzy KB and let  be a fuzzy assertion. Determining whether
| is a PSPACE-complete problem.
a
Proof: We have seen that termination of the above algorithm is guaranteed. Additionally,
for a crisp KB K, define K = {h  1i :   K}. By definition, each   K is KBnormalised and h  0.5i is query-normalised. Then from Proposition 2 it follows that
K |=  iff K |h  0.5i. From the PSPACE-completeness of the entailment problem in
crisp ALC (Schmidt-Schau & Smolka, 1991), PSPACE-hardness of the fuzzy entailment
problem follows. Unfortunately, our algorithm, as it is, requires exponential space due a
well know problem inherited from the crisp case. Indeed, it easily verified that a completion
of S = {x:C}, where C is the concept
(R.A11 ) u (R.A12 ) u R.((R.A21 ) u (R.A22 ) u . . . R.((R.An1 ) u (R.An2 )) . . .)
contains at least 2n + 1 variables. In order to require polynomial space, Schmidt-Schau
and Smolka (1991) introduced the so-called trace rule (T ) for the  operator. The (T )
rule modifies the () rule as shown below.
156

fiReasoning within Fuzzy DLs

()

(T )

w:R.C  (w, x):R, x:C
if x new variable and there is no w0 such that both (w, w0 ):R and w0 :C
are already in the actual constraint set
w:R.C  (w, x):R, x:C
if x new variable and no (w, w0 ):R0 is already in the actual set of constraints.

The difference between the () rule and the (T ) is that the latter is applied only once
for an object w. We are thus compelled to make a nondeterministic choice amongst the
constraints of the form w:R.C. Furthermore, it is convenient to apply a trace rule only if
none of the other (u), (t), () and () rules are applicable.
We say that a set of constraints S 0 is a trace of a set S if S 0 obtained from S by
application of the rules where the () has been replaced by (T ). Schmidt-Schau and
Smolka (1991) have shown that a set of constraints S = {x:C} is satisfiable iff no trace S 0
of S contains a clash. As the size of a trace S 0 of S is bounded polynomially by the size of
S, polynomial space is sufficient to prove satisfiability.
The above trace rule works if we start from a constraint set of the form {x:C}. In
the general case, we have to rely on so-called pre-completions (Baader & Hollunder, 1991b;
Donini et al., 1994). A set of constraints S 0 is said to be a pre-completion of a given set
of constraints S, if it is obtained from S by the application of the (u), (t), () and ()
rules, and none of these rules is applicable to S 0 (the size of S 0 is polynomially bounded
by the size of S). As a consequence of this pre-processing step, all role relationships
(w, w0 ):R  S 0 can be ignored, i.e. removed from S 0 , because they no longer carry any
additional information. Now, in a second step we can apply the method above by checking
whether no trace from S 0 contains a clash. In summary, a set of constraints S is satisfiable
iff there is a pre-completion S 0 of S such that no trace S 00 of S 0 contains a clash.
In the fuzzy case, similar trace rules can easily be defined. For instance, the correspondent trace rule of the ( ) rule is
(T  )

hw:R.C  ni  h(w, x):R  ni, hx:C  ni
if x new variable and no h(w, w0 ):R0  mi is already in
the actual set of fuzzy constraints.

The trace rules correspondent to the rules (> ), ( ) and (< ) are defined similarly. By
proceeding as for the crisp case, it can be shown that (i) a set of fuzzy constraints S
is satisfiable iff there is a pre-completion S 0 of S such that no trace S 00 of S 0 contains a
clash; and (ii) the size of a trace S 00 of S is bounded polynomially by the size of S. As a
consequence, the satisfiability problem is in PSPACE, which completes the proof. 2
This result establishes an important property about our fuzzy DL. In effect, it says that no
additional computational cost has to be paid for the major expressive power.
5.2 A Decision Procedure for the Subsumption Problem
In this section we address the subsumption problem, i.e. deciding whether C T D, where
C and D are two concepts and  is a fuzzy terminology. As we have seen (see Example 4),
157

fiStraccia

C T D can be reduced to the case of an empty terminology by applying the KB expansion
process. So, without loss of generality, we can limit our attention to the case C  D.
At first, an analogue to relation (12) holds. In fact, it can easily be shown that
Proposition 5 Let C and D be two concepts. It follows that C  D iff for all n > 0
ha:C  ni|ha:D  ni, where a is a new individual.
a
Proof:
 .) Assume that C  D holds. Suppose to the contrary that n > 0 such that
ha:C  ni |
6 ha:D  ni. Therefore, there is an interpretation I and an n > 0 such that
C I (aI )  n and DI (aI ) < n. But, from the hypothesis n  C I (aI )  DI (aI ) < n follows.
Absurd.
 .) Assume that for all n > 0, ha:C  ni|ha:D  ni holds. Suppose to the contrary
that C 6 D holds. Therefore, there is an interpretation I and d  I such that C I (d) >
DI (d)  0. Let us extent I to a such that aI = d and consider n = C I (d) > 0. Of course,
I satisfies ha:C  ni. Therefore, from the hypothesis it follows that I satisfies ha:D  ni,
i.e. DI (d)  n = C I (d) > DI (d). Absurd. 2
How can we check whether for all n > 0 ha:C  ni|ha:D  ni holds? A solution to this
problem, restricted to the propositional case, is given by Straccia (2000a). Indeed, it is
shown that
Proposition 6 (Straccia, 2000a) Let p and q be two propositions, 0 < n1  0.5 and
1  n2 > 0.5. It follows that for all n > 0, hp  ni|hq  ni iff for both m  {n1 , n2 },
hp  mi|hq  mi holds.
a
The above proposition establishes that, at the propositional level, in order to check whether
hp  ni|hq  ni holds for all n, it is sufficient to check the entailment relation with respect
to two values n1 , n2 . The first being less or equal than 0.5, while the second being greater
than 0.5, respectively. This is due to the fact that for given values n, n0  0.5, any proof of
hp  ni|hq  ni can be converted into a proof for hp  n0 i|hq  n0 i and vice-versa. The
case where n, n0 > 0.5 is similar.
The above proposition can be extended to our fuzzy DL as well.
Lemma 1 Let C and D be two concepts, 0 < n, n0  0.5 and let a be an individual. It
follows that ha:C  ni|ha:D  ni iff ha:C  n0 i|ha:D  n0 i.
a
Proof:
It is enough to show that S = {ha:C  ni, ha:D < ni} is satisfiable iff S 0 =
{ha:C  n0 i, ha:D < n0 i} is satisfiable.
 .) Assume that S is satisfiable. So, there is a clash-free completion S of S. With
S[n/n0 ] we indicate the set of fuzzy constraints obtained from S, by replacing any value n
in S with n0 and any value 1  n in S with 1  n0 , respectively. We will show that S[n/n0 ]
is a clash-free completion of S 0 and, thus, S 0 is satisfiable.
Let r1 , . . . , rk , k  0 be the sequence of inference rule applications, which applied to S
get S. Let S0 = S, let Sk = S and for 1  i  k let Si be the set of fuzzy constraints
obtained from Si1 by the application of the ri rule to Si1 .
By induction on k, we show that (i) the sequence of inference rules r1 , . . . , rk can be
applied to S 0 as well; (ii) for S 0 0 = S 0 , S 0 k = S 0 and S 0 i the set of fuzzy constraints obtained
158

fiReasoning within Fuzzy DLs

from S 0 i1 by the application of the ri rule to S 0 i1 , we have that S 0 i = Si [n/n0 ] and, thus,
S 0 = S 0 k = Sk [n/n0 ] = S[n/n0 ]; and (iii) if Sk is a clash-free completion of S then S 0 k is a
clash-free completion of S 0 as well.
case k = 0: No rule is applicable to S and S0 = S is a completion of S. By case analysis, (i) it is easily verified that no rule is applicable to S 0 and (ii) S 0 = S 0 0 =
S0 [n/n0 ] = S[n/n0 ]. (iii) So, S 0 0 is a completion of S 0 . We show that S 0 0 is clashfree. Assume to the contrary that S 0 0 , i.e. S 0 contains a clash. As a consequence,
S 0 = {ha:C  n0 i, ha:C < n0 i}. But then, S is {ha:C  ni, ha:C < ni}, contrary to the
assumption that S is clash-free.
induction step: by case analysis on the rule rk . We limit our presentation to the ( )
rule as for the other the proof is similar.
If rk is ( ) then it can be verified that there are hw:R.C 0  ni and h(w, w0 ):R > 1  ni
in Sk1 such that hw0 :C 0  ni 6 Sk1 and hw0 :C 0  ni  Sk . By induction, Sk1 [n/n0 ] =
S 0 k1 and, thus, both hw:R.C 0  n0 i and h(w, w0 ):R > 1  n0 i are in S 0 k1 , while
hw0 :C 0  n0 i 6 S 0 k1 . Therefore, (i) rule rk is applicable to S 0 k1 and hw0 :C 0  n0 i 
S 0 k ; (ii) so, S 0 k = Sk [n/n0 ]; (iii) from S 0 k = Sk [n/n0 ] and, as Sk is a completion
of S, by case analysis, it is easily verified that no rule is further applicable to S 0 k .
Therefore, S 0 k is a completion of S 0 . Let us show that S 0 k is clash free. Assume to
the contrary that S 0 k contains a clash. If one of the cases in Table 1 holds, then from
S 0 k = Sk [n/n0 ] it follows easily that there is a clash in Sk as well, which is contrary to
assumption that Sk is clash-free. On the other hand, if there is a conjugated pair of
fuzzy constraints in S 0 k (see Table 2), then one of the following three pairs is in S 0 k :
(a) h  n0 i and h < n0 i; (b) h  1  n0 i and h > 1  n0 i; and (c) h < n0 i and
h > 1  n0 i (note that n, n0  0.5). Again, as S 0 k = Sk [n/n0 ], it follows that there is
a conjugated pair in Sk as well, which is contrary to assumption that Sk is clash-free.
 .) Can be proven similarly to  .). 2
By proceeding as for Lemma 1 it can be shown that
Lemma 2 Let C and D be two concepts, 1  n, n0 > 0.5 and let a be an individual. It
follows that ha:C  ni|ha:D  ni iff ha:C  n0 i|ha:D  n0 i.
a
From Lemma 1 and Lemma 2 it follows that
Proposition 7 Let C and D be two concepts, 0 < n1  0.5, 1  n2 > 0.5 and let a be
an individual. It follows that for all n > 0 ha:C  ni|ha:D  ni iff for both m  {n1 , n2 },
ha:C  mi|ha:D  mi holds.
a
As a consequence, the subsumption problem can be reduced to the entailment problem for
which we have a decision algorithm.
159

fiStraccia

5.3 A Decision Procedure for the BTVB Problem
We address now the problem of determining glb(, ) and lub(, ). This is important, as
computing, e.g. glb(, ), is in fact the way to answer a query of type to which degree is
 (at least) true, given the (imprecise) facts in ?.
Without loss of generality, we will assume that all concepts are in NNF (Negation Normal
Form). Straccia (2000b) has shown that, in case of fuzzy propositional logic, from a set  of
fuzzy propositions of the form hp  ni and hp  ni, where p is a proposition, it is possible
to determine a finite set N   [0, 1], where |N  | is O(||), such that glb(, q)  N  ,
i.e. the greatest lower bound of a proposition q w.r.t.  has to be an element of N  .
Therefore, glb(, q) can be determined by computing the greatest value n  N  such that
|hq  ni. An easy way to search for this n is to order the elements of N  and then
to perform a binary search among these values by successive entailment tests. Dually,
as lub(, q) = 1  glb(, q) holds, the lub can either be computed from the glb or, as
lub(, q)  1  N  , where 1  N  = {1  n : n  N  }, we can compute it by determining
the smallest value in 1  N  .

Proposition 8 (Straccia, 2000b) Let  be a set of fuzzy propositions in NNF and let q
be a proposition. Then glb(, q)  N  and lub(, q)  1  N  , where
N

= {0, 0.5, 1} 
{n : hp  ni  } 
{1  n : hp  ni  }

1  N  = {1  n : n  N  }.
a
The above Proposition 8 can easily be extended our fuzzy description logic case. Essentially,
the quantifiers do not change the possible values of glb(, F ) and lub(, F ).
Proposition 9 Let  be a set of fuzzy assertions in NNF and let  be an assertion. Then
glb(, )  N  and lub(, )  1  N  , where
N

= {0, 0.5, 1} 
{n : h  ni  } 
{1  n : h  ni  }

1  N  = {1  n : n  N  }.
a
Proof: Let us show that glb(, )  N  . Let m be glb(, ). By definition, if m = 0 then
S =   {h < ni} is satisfiable for any n > 0 and 0  N  . Otherwise, m > 0 is the largest
value such that S =   {h < mi} is not satisfiable. Let us mark each sub-expression in 
with a  , so that we can trace the components of the query assertion  during a deduction.
160

fiReasoning within Fuzzy DLs

Consider a completion S 0 of S. Starting from h < mi, by applying the rules of inference,
only  marked expressions of type h0 < mi or h0 > 1  mi can appear in S 0 . Furthermore,
as S is not satisfiable, S 0 contains a clash, i.e. the value m is the largest value such that all
completions S 0 of S contain a clash. Let us analyse S 0 . As S 0 contains a clash, then either
(i) there is a clash according to Table 1, or (ii) there is a clash according to Table 2. If
(i) is the case, i.e. there is   S 0 which is a clash, then we have to distinguish between
two cases: (a)  is not marked with  and (b)  is marked with  . In the former case, S 0
contains a clash independently of the value m and, thus, the largest possible value m for
which S 0 contains a clash is 1. In the latter case, as m > 0, either  = hw: > 1  mi or
 = hw:> < mi which are both clashes for any value of m. As a consequence, the largest
possible value m for which S 0 contains a clash according to Table 1 is 1. Assume (ii) is the
case, i.e. a conjugated pair of fuzzy constraints  and  0 is in S 0 . Similarly to the previous
case, we have to distinguish the cases for which  and  0 are marked with  . There are four
cases:
(a)  = h  ki and  0 = h0  k 0 i are in S 0 , none is marked with  and k > k 0 .
Therefore, S 0 contains a clash for any value of m and, thus, the largest choice is 1;
(b)  = h  ki and  0 = h0 < mi are in S 0 , only  0 is marked with  and k  m.
Therefore, S 0 contains a clash for any value of m  k and, thus, the largest choice for m is
k. It is easily verified by case analysis on the rules that from   S 0 , k  N  follows;
(c)  = h  ki and  0 = h0 > 1  mi are in S 0 , only  0 is marked with  and k  1m.
Therefore, S 0 contains a clash for any value of m  1  k and, thus, the largest choice for
m is 1  k. It is easily verified by case analysis on the rules that from   S 0 , 1  k  N 
follows;
(d)  = h < mi and  0 = h0 > 1  mi are in S 0 , both are marked with  and m  1m.
Therefore, S 0 contains a clash for any value of m  0.5 and, thus, the largest choice for m
is 0.5.
Summing up, we have proved that the largest possible value for m is such that m 
2

N .

The algorithms computing glb(, ) and lub(, ) are described in Table 3. For instance,
by a binary search on N  , the value of glb(, ) can be determined in at most log |N  |
fuzzy entailment tests.

6. Conclusions and Future Work
In this work, we have presented a quite general fuzzy extension of the DL ALC, a significant
and expressive representative of the various DLs. Our fuzzy DL enables us to reason in
presence of imprecise ALC concepts, i.e. fuzzy ALC concepts. From a semantics point of
view, fuzzy concepts are interpreted as fuzzy sets i.e. given a concept C and an individual
a, C(a) is interpreted as the truth-value of the sentence a is C. From a syntax point of
view, we allow to specify lower and upper bounds of the truth-value of C(a). Complete
algorithms for reasoning in it have been presented, that is, we have devised algorithms for
solving the entailment problem, the subsumption problem as well as the best truth-value
bound problem.
161

fiStraccia

Algorithm M ax(, )
Set M in := 0 and M ax := 2.
1. Pick n  N  \ {0} such that M in < n < M ax. If there is no such n, then
set glb(, ) := M in and exit.
2. If |h  ni then set M in = n, else set M ax = n. Go to Step 1.
Algorithm M in(, )
Set M in := 0 and M ax := 2.
1. Pick n  (1  N  ) \ {0} such that M in < n < M ax. If there is no such n,
then set lub(, ) := min{M ax, 1} and exit.
2. If |h  ni then set M ax = n, else set M in = n. Go to Step 1.

Table 3: Algorithms M ax(, ) and M in(, )

An important point concerns computational complexity. The complexity result shows
that the additional expressive power has no impact from a computational complexity point
of view.
The extension of DLs to the management of vagueness is not new (Tresp & Molitor,
1998; Yen, 1991). Yen was the first, to the best of my knowledge, introducing vagueness
into a simple DL. His language has two interesting points not included into our language.
Firstly, it allows the definition of vague concepts by means of explicit membership functions
over a domain, e.g. LowPressure: domain(AirPressure); membershipf x(p.low(p)). Here
the domain over p ranges is given by AirPressure. p.low(p) determines the membership
degree of being a pressure p low. Secondly, the language allows concept modifiers, like Very
or Slightly, by means of which concepts like very low pressure can be defined through
VeryLowPressure: Very(LowPressure). This last idea has been generalised to ALC by Tresp
and Molitor (1998) where a certain type of concept modifiers are allowed. Strictly speaking, the language defined by Tresp and Molitor is more expressive, as we do not consider
concept modifiers. From a semantics point of view, the extension to Tresp and Molitors
language is quite straightforward. But, the cost that we have to pay for this increasing
expressive power is that, from a computational complexity and algorithms point of view,
things changes radically. Indeed, according to Tresp and Molitor for each completion a
linear optimisation problem is generated (set of inequations of the form op1 (t1 )Rop2 (t2 ) or
op1 (t1 )Rf (op2 (t2 )), where ti is a truth-value variable, R  {, , =, opi  {id, mi }, with
id(t) the identity and mi (t) is a modifier function over truth-value variables, respectively,
and f  {min, max}-derived from the semantics of the connectors u, t) and then solved for
the best value. Then, the minimum among all computed solutions is taken. The solutions
can be computed by relying on methods from the domain of linear programming, e.g. the
162

fiReasoning within Fuzzy DLs

simplex method (Papadimitriou & Steiglitz, 1982). While it is possible to devise a similar
approach for our fuzzy DL as well, we have seen that this is not necessary.
Both aspects considered by Tresp and Molitor and by Yen, although interesting, are
not crucial w.r.t. how we model logic-based multimedia information retrieval, where underlaying text, image and video analysis tools provide us fuzzy assertions e.g. of the form
ha:About.C  ni from which we may infer ha:About.D  mi.
This work can be used as a basis both for extending existing DL based systems and for
further research. In this latter case, there are several open points. For instance, it is not clear
yet how to reason both in case of fuzzy specialisation of the general form CD and in the
case cycles are allowed in a fuzzy KB. Another interesting topic for further research concerns
the semantics of fuzzy connectives. Of course several other choices for the semantics of the
connectives u, t, , ,  can be considered. While for a huge number of proposals given in
the literature their impact from a semantics point of view is well understood, the question
how they impact from a computational complexity and algorithms point of view remains
still open.

Acknowledgements
I would like to thank the three anonymous reviewers for their helpful comments on an early
version of this paper. This is an extension and revision of the paper appeared in AAAI-98.

References
Baader, F., & Hollunder, B. (1991a). KRIS: Knowledge representation and inference system,
system description. ACM SIGART Bulletin, 2, 814.
Baader, F., & Hollunder, B. (1991b). A terminological knowledge representation system
with complete inference algorithm. In Proc. of the Workshop on Processing Declarative
Knowledge, PDK-91, No. 567 in Lecture Notes in Artificial Intelligence, pp. 6786.
Springer-Verlag.
Bacchus, F. (1990). Representing and Reasoning with Probabilistic Knowledge. The MIT
Press.
Bellman, R., & Giertz, M. (1973). On the analytic formalism of the theory of fuzzy sets.
Information Sciences, 5, 149156.
Brachman, R. J. (1992). reducing CLASSIC to practice: Knowledge representation meets
reality. In Proc. of the 3rd Int. Conf. on the Principles of Knowledge Representation
and Reasoning (KR-92), pp. 247258. Morgan Kaufmann, Los Altos.
Buchheit, M., Donini, F. M., & Schaerf, A. (1993a). Decidable reasoning in terminological
knowledge representation systems. In Proc. of the 13th Int. Joint Conf. on Artificial Intelligence (IJCAI-93), pp. 704709 Chambery, France. Morgan Kaufmann, Los
Altos.
163

fiStraccia

Buchheit, M., Donini, F. M., & Schaerf, A. (1993b). Decidable reasoning in terminological
knowledge representation systems. Journal of Artificial Intelligence Research, 1, 109
138.
Chen, J., & Kundu, S. (1996). A sound and complete fuzzy logic system using Zadehs
implication operator. In Ras, Z. W., & Maciek, M. (Eds.), Proc. of the 9th Int. Sym.
on Methodologies for Intelligent Systems (ISMIS-96), No. 1079 in Lecture Notes in
Artificial Intelligence, pp. 233242. Springer-Verlag.
da Silva, R. M., Pereira, A. E. C., & Netto, M. A. (1994). A system of knowledge representation based on formulae of predicate calculus whose variables are annotated
by expressions of a fuzzy terminological logic. In Proc. of the 5th Int. Conf. on Information Processing and Managment of Uncertainty in Knowledge-Based Systems,
(IPMU-94), No. 945 in Lecture Notes in Computer Science. Springer-Verlag.
Donini, F. M., Lenzerini, M., Nardi, D., & Schaerf, A. (1994). Deduction in concept languages: From subsumption to instance checking. Journal of Logic and Computation,
4 (4), 423452.
Dubois, D., & Prade, H. (1980). Fuzzy Sets and Systems. Academic Press, New York, NJ.
Dubois, D., & Prade, H. (1994). Can we enforce full compositionality in uncertainty calculi?.
In Proc. of the 11th Nat. Conf. on Artificial Intelligence (AAAI-94), pp. 149154
Seattle, Washington.
Dubois, D., & Prade, H. (1996). Approximate and commonsense reasoning: From theory to
practice. In Ras, Z. W., & Maciek, M. (Eds.), Proc. of the 9th Int. Sym. on Methodologies for Intelligent Systems (ISMIS-96), No. 1079 in Lecture Notes in Artificial
Intelligence, pp. 1933. Springer-Verlag.
Halpern, J. Y. (1990). An analysis of first-order logics of probability. Artificial Intelligence
Journal, 46, 311350.
Heinsohn, J. (1994). Probabilistic description logics. In de Mantara, R. L., & Pool, D.
(Eds.), Proceedings of the 10th Conference on Uncertainty in Artificila Intelligence,
pp. 311318.
Hollunder, B. (1994). An alternative proof method for possibilistic logic and its application to terminological logics. In 10th Annual Conference on Uncertainty in Artificial
Intelligence Seattle, Washington. R. Lopez de Mantaras and D. Pool.
Horrocks, I. (1998). Using an expressive description logic: Fact or fiction?. In Proc. of the
8th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR-98).
Jager, M. (1994). Probabilistic reasoning in terminological logics. In Proceedings of KR94, 5-th International Conference on Principles of Knowledge Representation and
Reasoning, pp. 305316 Bonn, FRG.
164

fiReasoning within Fuzzy DLs

Koller, D., Levy, A., & Pfeffer, A. (1997). P-CLASSIC: A tractable probabilistic description
logic. In Proc. of the 14th Nat. Conf. on Artificial Intelligence (AAAI-97), pp. 390
397.
Kruse, R., Schwecke, E., & Heinsohn, J. (1991). Uncertainty and Vagueness in Knowledge
Based Systems. Springer-Verlag, Berlin, Germany.
Lee, R. C. T. (1972). Fuzzy logic and the resolution principle. Journal of the ACM, 19 (1),
109119.
Meghini, C., Sebastiani, F., & Straccia, U. (1997). Modelling the retrieval of structured
documents containing texts and images. In Proceedings of the First European Conference on Research and Advanced Technology for Digital Libraries, No. 1324 in Lecture
Notes in Computer Science, pp. 325344 Pisa, Italy.
Meghini, C., Sebastiani, F., & Straccia, U. (1998). Mirlog: A logic for multimedia information retrieval. In Crestani, F., Lalmas, M., & van Rijsbergen, C. (Eds.), Logic and
Uncertainty in Information Retrieval: Advanced models for the representation and
retrieval of information, Vol. 4 of The Kluwer International Series On Information
Retrieval, chap. 7, pp. 151185. Kluwer Academic Publishers, Boston, USA.
Meghini, C., & Straccia, U. (1996). A relevance terminological logic for information retrieval.
In Proceedings of the 19th Annual International ACM SIGIR Conference on Research
and Development in Information Retrieval (ACM SIGIR-96), pp. 197205 Zurich,
Switzerland.
Nebel, B. (1988). Computational complexity of terminological reasoning in BACK. Artificial
Intelligence, 34, 371383.
Nebel, B. (1990). Reasoning and revision in hybrid representation systems. Springer, Heidelberg, FRG.
Papadimitriou, C. H., & Steiglitz, K. (1982). Combinatorial Optimization: Algorithms and
Complexity. Prentice-Hall, Englewood Cliffs, New Jersey.
Pearl, J. (1988). Probabilistic Reasoning in Intelligent Systems: Networks of Plausible
Inference. Morgan Kaufmann, Los Altos.
Peltason, C. (1991). The BACK system  an overview. SIGART Bulletin, 2 (3), 114119.
Roth, D. (1996). On the hardness of approximate reasoning. Artificial Intelligence Journal,
82, 273302.
Schmidt-Schau, M., & Smolka, G. (1991). Attributive concept descriptions with complements. Artificial Intelligence, 48, 126.
Sebastiani, F. (1994). A probabilistic terminological logic for modelling information retrieval. In Proceedings of SIGIR-94, 17th ACM International Conference on Research
and Development in Information Retrieval, pp. 122130 Dublin, IRL. Published by
Springer Verlag, Heidelberg, FRG.
165

fiStraccia

Straccia, U. (1998). A fuzzy description logic. In Proc. of the 15th Nat. Conf. on Artificial
Intelligence (AAAI-98), pp. 594599 Madison, USA.
Straccia, U. (2000a). A note on the relationship between fuzzy logic and four-valued logic.
Technical report B4-22-10-2000, Istituto di Elaborazione dellInformazione, Consiglio
Nazionale delle Ricerche, Pisa, Italy.
Straccia, U. (2000b). Reasoning and experimenting within Zadehs fuzzy propositional logic.
Technical report 2000-b4-011, Istituto di Elaborazione dellInformazione, Consiglio
Nazionale delle Ricerche, Pisa, Italy.
Tresp, C., & Molitor, R. (1998). A description logic for vague knowledge. In Proc. of the
13th European Conf. on Artificial Intelligence (ECAI-98) Brighton (England).
Xiachun, C., Yunfei, J., & Xuhua, L. (1995). The rationality and decidability of fuzzy
implications. In Proc. of the 14th Int. Joint Conf. on Artificial Intelligence (IJCAI95), pp. 19101911 Montreal, Canada. MK.
Yen, J. (1991). Generalizing term subsumption languages to fuzzy logic. In Proc. of the 12th
Int. Joint Conf. on Artificial Intelligence (IJCAI-91), pp. 472477 Sydney, Australia.
Zadeh, L. A. (1965). Fuzzy sets. Information and Control, 8 (3), 338353.

166

fi