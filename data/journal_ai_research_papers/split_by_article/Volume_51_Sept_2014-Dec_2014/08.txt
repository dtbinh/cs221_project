Journal of Artificial Intelligence Research 51 (2014) 645-705

Submitted 05/14; published 12/14

The Complexity of Answering Conjunctive and Navigational
Queries over OWL 2 EL Knowledge Bases
Giorgio Stefanoni
Boris Motik

giorgio.stefanoni@cs.ox.ac.uk
boris.motik@cs.ox.ac.uk

Department of Computer Science, University of Oxford
Parks Road, Oxford OX1 3QD, United Kingdom

Markus Krotzsch
Sebastian Rudolph

markus.kroetzsch@tu-dresden.de
sebastian.rudolph@tu-dresden.de

Faculty of Computer Science, TU Dresden
Nothnitzer Strae 46, 01062 Dresden, Germany

Abstract
OWL 2 EL is a popular ontology language that supports role inclusionsaxioms of the
form S1    Sn v S that capture compositional properties of roles. Role inclusions closely
correspond to context-free grammars, which was used to show that answering conjunctive
queries (CQs) over OWL 2 EL knowledge bases with unrestricted role inclusions is undecidable. However, OWL 2 EL inherits from OWL 2 DL the syntactic regularity restriction on
role inclusions, which ensures that role chains implying a particular role can be described
using a finite automaton (FA). This is sufficient to ensure decidability of CQ answering;
however, the FAs can be worst-case exponential in size so the known approaches do not
provide a tight upper complexity bound.
In this paper, we solve this open problem and show that answering CQs over OWL
2 EL knowledge bases is PSpace-complete in combined complexity (i.e., the complexity
measured in the total size of the input). To this end, we use a novel encoding of regular role
inclusions using bounded-stack pushdown automatathat is, FAs extended with a stack of
bounded size. Apart from theoretical interest, our encoding can be used in practical tableau
algorithms to avoid the exponential blowup due to role inclusions. In addition, we sharpen
the lower complexity bound and show that the problem is PSpace-hard even if we consider
only role inclusions as part of the input (i.e., the query and all other parts of the knowledge
base are fixed). Finally, we turn our attention to navigational queries over OWL 2 EL
knowledge bases, and we show that answering positive, converse-free conjunctive graph
XPath queries is PSpace-complete as well; this is interesting since allowing the converse
operator in queries is known to make the problem ExpTime-hard. Thus, in this paper we
present several important contributions to the landscape of the complexity of answering
expressive queries over description logic knowledge bases.

1. Introduction
Description logics (DLs) (Baader, Calvanese, McGuinness, Nardi, & Patel-Schneider, 2010)
are a family of knowledge representation formalisms that logically underpin the Web Ontology Language OWL 2 (Cuenca Grau, Horrocks, Motik, Parsia, Patel-Schneider, & Sattler,
2008). DL knowledge bases describe a domain in terms of concepts (i.e., unary predicates),
roles (i.e., binary predicates), and individuals (i.e., constants), and they describe the relationships between concepts, roles, and individuals using logical axioms. DLs and OWL

c
2014
AI Access Foundation. All rights reserved.

fiStefanoni, Motik, Krotzsch, & Rudolph

2 have been steadily gaining in popularity because they provide the developers of modern
information systems with a flexible graph-like data model that is natural in countless application areas, such as the Semantic Web (Gutierrez, Hurtado, Mendelzon, & Perez, 2011),
social network analysis (Fan, 2012), and network traffic analysis (Barrett, Jacob, & Marathe,
2000). Answering queries over DL/OWL knowledge bases is the core service in applications
as diverse as monitoring financial products within the Italian Ministry of Economy and
Finance (De Giacomo et al., 2012), accessing real-time diagnostic data of turbines (Giese
et al., 2013), and integrating configuration data of air traffic control systems (Calvanese
et al., 2011). Due to the practical importance of query answering, theoretical investigation
of the expressivity and computational complexity of query languages has been high up on
the research agenda of the knowledge representation community in the past decade.
Conjunctive queries (CQs) (Chandra & Merlin, 1977) are the basic class of queries in
relational databases. Querying DL knowledge bases using CQs has been studied in a diverse range of settings (Calvanese, De Giacomo, Lembo, Lenzerini, & Rosati, 2007; PerezUrbina, Motik, & Horrocks, 2010; Rudolph & Glimm, 2010; Kontchakov, Lutz, Toman,
Wolter, & Zakharyaschev, 2011; Ortiz, Rudolph, & Simkus, 2011; Gottlob & Schwentick,
2012; Venetis, Stoilos, & Stamou, 2012). However, conjunctive queries are first-order definable and thus cannot express certain important properties such as graph reachability.
Regular path queries (RPQs) (Cruz, Mendelzon, & Wood, 1987; Barcelo, 2013) are an alternative query language capable of describing connections between graph vertices using
regular expressions, allowing users to navigate inside a graph. For example, the RPQ
(isPartOf   hasLocation) retrieves all pairs of vertices connected via zero or more isPartOf
edges followed by one hasLocation edge. Furthermore, 2RPQs extend RPQs with the converse operator (i.e., backward navigation) (Calvanese, Vardi, De Giacomo, & Lenzerini,
2000); nested regular expressions allow for existential quantification over paths (Perez,
Arenas, & Gutierrez, 2010); and C(2)RPQs extend both (2)RPQs and CQs to conjunctions of (2)RPQs (Calvanese, De Giacomo, Lenzerini, & Vardi, 2000; Bienvenu, Ortiz, &
Simkus, 2013). Finally, inspired by the XPath query language for XML, graph XPath queries
(GXQs) have been recently proposed as a language for querying graph databases (Libkin,
Martens, & Vrgoc, 2013) and DL knowledge bases (Kostylev, Reutter, & Vrgoc, 2014; Bienvenu, Calvanese, Ortiz, & Simkus, 2014). GXQs extend 2RPQs with negation on regular
expressions, and checking properties of vertices using Boolean combinations of node tests
that is, concepts or existential quantifications over paths. For example, the graph XPath
query (isPartOf   test(Cell  hhasSpecialityi)  hasLocation) refines the aforementioned RPQ
by requiring that the node between the isPartOf edges and the hasLocation edge is an instance of the Cell concept and does not have an outgoing hasSpeciality edge. Graph XPath
queries can be straightforwardly extended to conjunctive graph XPath queries (CGXQs). A
query in any of these languages is Boolean if it has no answer variables; hence, an answer
to such a query is a Boolean value.
1.1 Problem Setting
Although computing answers to a query over a DL knowledge base is a function problem, it
is common in the literature to consider the complexity of the associated decision problem
that is, of checking whether a Boolean query is entailed by the knowledge base. In this article

646

fiThe Complexity of Answering CQs and GXQs over OWL 2 EL KBs

we follow this well-established practice and analyse the computational properties of several
query languages over DL knowledge bases. We follow Vardi (1982) and measure the input
size in two ways: combined complexity measures the complexity in terms of the combined
size of the query and the knowledge base, while data complexity measures the complexity
in terms of the size of the data (i.e., the query and all other parts of the knowledge bases
are considered to be fixed).
The computational properties of query answering over DL knowledge bases depend on
the expressivity of both the constructs used in the knowledge base and the query language
used. In particular, conjunctive query answering over expressive description logics is at
least exponential in combined complexity (Glimm, Lutz, Horrocks, & Sattler, 2008; Lutz,
2008) and intractable in data complexity (Calvanese, De Giacomo, Lembo, Lenzerini, &
Rosati, 2013; Ortiz, Calvanese, & Eiter, 2008). The problem becomes tractable in data
complexity for the RL (Grosof, Horrocks, Volz, & Decker, 2003; ter Horst, 2005) and the
QL (Calvanese et al., 2007; Artale, Calvanese, Kontchakov, & Zakharyaschev, 2009) profiles
of OWL 2, and several worst-case optimal algorithms have been proposed that perform well
in practice (Urbani, van Harmelen, Schlobach, & Bal, 2011; Rodriguez-Muro & Calvanese,
2012). In this paper, however, we focus on the OWL 2 EL profile of OWL 2, which is based
on the EL family of DLs (Baader, Brandt, & Lutz, 2005). Basic reasoning problems for
OWL 2 EL, such as checking concept subsumption and instance checking, can be decided
in polynomial time (Baader et al., 2005; Krotzsch, 2011), which makes this language very
interesting for practical applications. Motivated by this observation, in this paper we present
several novel complexity results for answering queries over OWL 2 EL knowledge bases.
One of the important modelling constructs of OWL 2 EL are role inclusionsaxioms
of the form S1    Sn v S that express compositional properties of roles. For example, the
following inclusions state that role isPartOf is transitive and that, if x is located in y and y
is part of z, then x is located in z.
isPartOf  isPartOf v isPartOf

hasLocation  isPartOf v hasLocation

Prior to the introduction of the EL family, role inclusions had already been identified as
a source of undecidability in expressive DLs because they loosely correspond to context-free
grammars: if each inclusion S1    Sn v S in a knowledge base is seen as a production rule
S  S1    Sn , then the knowledge base induces a context-free language L(S) for each role
S. Using this correspondence, Wessel (2001) showed that checking satisfiability of ALCR
knowledge bases with unrestricted role inclusions is undecidable. To regain decidability,
Horrocks and Sattler (2004) proposed a syntactic regularity restriction on role inclusions
ensuring that each language L(S) is regular and can thus be recognised using a finite
automaton (FA); Kazakov (2008) later showed that, in some cases, the size of this automaton
is necessarily exponential in the knowledge base size. The OWL 2 DL profile of OWL 2
extends ALCR and thus incorporates the regularity restriction into its definition.
Even with unrestricted role inclusions, all standard reasoning problems for EL can be
solved in polynomial time (Baader et al., 2005). Moreover, Stefanoni, Motik, and Horrocks
(2013) showed that answering CQs over OWL 2 EL knowledge bases without role inclusions
is NP-complete. However, using the correspondence between role inclusions and contextfree grammars, Rosati (2007) and Krotzsch, Rudolph, and Hitzler (2007) independently
proved that answering CQs over EL knowledge bases with unrestricted role inclusions is
647

fiStefanoni, Motik, Krotzsch, & Rudolph

undecidable; furthermore, Krotzsch et al. (2007) also showed that checking concept subsumptions over EL knowledge bases with inverse roles and unrestricted role inclusions is
undecidable.
OWL 2 EL inherits the regularity restriction from OWL 2 DL, and so the undecidability proofs by Rosati (2007) and Krotzsch et al. (2007) do not apply to OWL 2 EL. In
fact, Krotzsch et al. (2007) showed that answering CQs over EL knowledge bases extended
with regular role inclusions is PSpace-hard in combined complexity, and they proposed a
CQ answering algorithm for a fragment of OWL 2 EL with regular role inclusions. This
algorithm, however, runs in PSpace only if, for each role S, language L(S) can be represented using an automaton of polynomial size; due to the mentioned result by Kazakov
(2008), this approach does not provide us with a matching PSpace upper bound for the
problem. Ortiz et al. (2011) proposed a different algorithm for answering CQs over OWL 2
EL knowledge bases (with regular role inclusions and without any restriction on the usage
of other features). Similarly to the algorithm by Krotzsch et al. (2007), the algorithm by
Ortiz et al. (2011) also encodes regular role inclusions using finite automata. Hence, while
both of these algorithms run in time polynomial in the size of the data and thus settle the
question of data complexity, they do not settle the question of combined complexity.
There are comparatively few works on studying the complexity of (conjunctive) graph
XPath queries over DL knowledge bases. In particular, Kostylev et al. (2014) observed that
GXQs are closely related to propositional dynamic logic with full negation (Harel, Tiuryn,
& Kozen, 2000), which immediately shows that answering GXQs over DL knowledge bases
is undecidable even with respect to the empty knowledge base. Several GXQ fragments
were proposed as a possible solution to this problem: path-positive GXQs disallow negation
over role expressions, and positive GXQs further prohibit negation over concepts as well.
Kostylev et al. (2014) showed that answering path-positive GXQs is intractable in data
complexity already for queries without the transitive closure operator and for knowledge
bases containing only instance assertions. Recently, Bienvenu et al. (2014) showed that
answering positive GXQs in a fragment of OWL 2 EL is tractable in data complexity, but
ExpTime-complete in combined complexity.
1.2 Our Contributions
In this paper, we present several novel complexity results on answering queries over OWL 2
EL knowledge bases.
First, we present the first CQ answering algorithm that can handle all of OWL 2 EL
(with regular role inclusions but without any restriction on the size of the FAs) and that
runs in PSpace, and thus we settle the open question of the combined complexity of
CQ answering for OWL 2 EL. Our result is based on a novel encoding of the languages
induced by regular role inclusions using pushdown automata (PDAs)that is, FAs extended
with a stack. We show that, for each role S, we can construct in polynomial time a
PDA that accepts language L(S) and whose computations use a stack of size linear in the
number of role inclusions. Bounded-stack PDAs (Anselmo, Giammarresi, & Varricchio,
2003) recognise precisely the class of regular languages and can be exponentially more
succinct than finite automata (Geffert, Mereghetti, & Palano, 2010). To obtain a CQ
answering algorithm running in PSpace, we extend the algorithm by Krotzsch et al. (2007)

648

fiThe Complexity of Answering CQs and GXQs over OWL 2 EL KBs

data
combined

ELHOdr

PTime

OWL 2 EL
PTime

Horn-SHOIQ
PTime

Horn-SROIQ
PTime

(Ortiz et al., 2011)

(Theorem 31)

(Ortiz et al., 2011)

(Ortiz et al., 2011)

NP

PSpace

ExpTime

2ExpTime

(Stefanoni et al., 2013)

(Theorem 31)

(Ortiz et al., 2011)

(Ortiz et al., 2011)

Table 1: The complexity landscape of CQ answering (all are completeness results)
to handle the universal role, keys, self-restrictions, and reflexive roles, thus covering all
features of the EL profile apart from datatypes, and we adapt it so that it can handle
regular role inclusions encoded using PDAs. Apart from allowing us to obtain the complexity
results presented in this paper, the tableau algorithm by Horrocks, Kutz, and Sattler (2006)
used in popular reasoners such as Pellet (Sirin, Parsia, Cuenca Grau, Kalyanpur, & Katz,
2007) and FaCT++ (Tsarkov & Horrocks, 2006) can be straightforwardly modified to use
bounded-stack PDAs instead of FAs, which could eliminate a potential source of inefficiency
in practice. Finally, for brevity and simplicity we do not deal with datatypes in this paper;
however, the set of OWL 2 EL datatypes has been designed so as to enable datatype
reasoning using an external datatype checking procedure (Baader, Brandt, & Lutz, 2008;
Cuenca Grau et al., 2008) that can be easily incorporated into our algorithm.
Second, we improve the PSpace lower bound by Krotzsch et al. (2007) by showing
that answering CQs in OWL 2 EL is PSpace-hard already if just the role inclusions are
considered as part of the input (i.e., the conjunctive query, the TBox, and the ABox are all
fixed). Furthermore, we show that CQs can be answered in polynomial time if the query
and the role inclusions are fixed, which emphasises the observation that role inclusions are
the main source of the problems PSpace-hardness.
Third, we show that positive, converse-free CGXQsthat is, CGXQs that do not allow
for negation over paths, negation of concepts, and the converse operatorcan be answered
over OWL 2 EL knowledge bases using polynomial space. In particular, OWL 2 EL allows
for role inclusions, self-restrictions, and reflexive roles, which allow us to polynomially reduce answering a CGXQ to answering a CQ over an extended knowledge base. We also
show that answering positive, converse-free GXQs (i.e., CGXQs with a single atom) can
be done in time polynomial in the input size. This result is interesting because Bienvenu
et al. (2014) proved that answering positive GXQs over EL knowledge bases is ExpTimecomplete; hence, adding the converse operator increases the complexity of GXQs. Our
results thus show that answering GXQs and CGXQs is as difficult as instance checking and
answering conjunctive queries, respectively, which at least from a theoretical perspective
makes GXQs and CGXQs appealing as query languages for OWL 2 EL knowledge bases.
1.3 Summary of the Complexity Landscape
Table 1 summarises the complexity landscape of answering CQs in various DLs related to
OWL 2 EL. Here, ELHOdr
 is the fragment of OWL 2 EL obtained by allowing only simple
role inclusions of the form T v S, and by disallowing the universal role, reflexive roles,
self-restrictions, and datatypes, and the combined complexity result for this logic is due to
Stefanoni et al. (2013). Furthermore, Horn-SHOIQ extends ELHOdr
 with inverse roles
and Horn qualified number restrictions, and Horn-SROIQ extends Horn-SHOIQ with role
649

fiStefanoni, Motik, Krotzsch, & Rudolph

data

positive
positive
converse-free converse-free
GXQs
CGXQs
PTime-c
PTime-c
(Theorem 34)

combined

PTime-c
(Theorem 34)

positive
GXQs

path-positive
GXQs

GXQs

PTime-h

coNP-h

coNP-h

(Theorem 34) (Bienvenu et al., 2014) (Kostylev et al., 2014) (Kostylev et al., 2014)

PSpace-c

ExpTime-h

ExpTime-h

undecidable

(Theorem 34) (Bienvenu et al., 2014) (Bienvenu et al., 2014) (Kostylev et al., 2014)

Table 2: The complexity of answering navigational queries over OWL 2 EL knowledge bases
(c means complete, and h means hard)

inclusions; the results for these logics are due to Ortiz et al. (2011). CQ answering is PTimecomplete in data complexity in all cases, which is essentially due to the fact that all of these
logics are Horn so no disjunctive reasoning is needed. For the combined complexity, the
table illustrates how the presence of different constructs affects the complexity of answering
CQs. In particular, extending ELHOdr
 with role inclusions increases the complexity from
NP to PSpace; by our PSpace lower bound, this increase is solely due to role inclusions.
Furthermore, extending ELHOdr
 with inverse roles increases the complexity from NP to
ExpTime. Finally, extending OWL 2 EL with inverse roles increases the complexity from
PSpace to 2ExpTime.
Table 2 summarises the complexity landscape of answering navigational queries over
OWL 2 EL knowledge bases. As one can see, adding the converse operator increases the
combined complexity of GXQs to ExpTime (Bienvenu et al., 2014). Moreover, adding
negation over node tests increases the data complexity of GXQs to coNP, whereas adding
negation over path expressions leads to the undecidability in combined complexity (Kostylev
et al., 2014). In contrast, existential quantification over paths does not increase the complexity: answering positive, converse-free (C)GXQs over OWL 2 EL knowledge bases is as
difficult as answering (C)RPQs over EL knowledge bases (Bienvenu et al., 2013).
1.4 Organisation of the Article
The rest of this article is organised as follows. In Section 2, we present the basic definitions
of finite automata, pushdown automata, the DL underpinning OWL 2 EL, and conjunctive
queries. In Section 3, we introduce our novel encoding of regular role inclusions using PDAs
of bounded stack size. In Section 4, we present the CQ answering algorithm for OWL 2
EL and discuss its complexity. In Section 5, we present our improved PSpace lower-bound
of answering CQs in OWL 2 EL. Finally, in Section 6, we introduce (conjunctive) graph
XPath queries, we show how to reduce the problem of answering positive, converse-free
conjunctive graph XPath queries to answering ordinary conjunctive queries, and we present
the aforementioned complexity results.

650

fiThe Complexity of Answering CQs and GXQs over OWL 2 EL KBs

2. Preliminaries
In this section we recapitulate the basic definitions of finite automata, pushdown automata,
the DL ELRO+ underpinning OWL 2 EL, and conjunctive queries. In the rest of the paper,
[i..j] is the set containing each natural number k  N such that i  k  j.
2.1 Automata and Language Theory
In this article, we use the standard notions of alphabets (which must be finite), strings, string
concatenation, Kleene operators, and languages from formal language theory (Hopcroft,
Motwani, & Ullman, 2003). We assume that alphabets do not contain the special symbol
, which we will use to label transitions in automata that do not consume input symbols.
Furthermore,  is the empty word. Finally, for w and w0 words, |w| is the number of symbols
occurring in w; and w  w0 is the unique word w00 such that w := w00  w0 if such w00 exists,
and otherwise w  w0 is undefined.
2.1.1 Finite Automata
A finite automaton (FA) is a tuple F = hQ, , , i, f i where Q is a finite set of states,  is
the input alphabet,  : Q    {} 7 2Q is the transition function, i  Q is the start state,
and f  Q is the final state. Such F is deterministic if |(s, )| = 0 and |(s, c)|  1 for each
s  Q and each c  ; otherwise, F is nondeterministic. The size |F| of F is the number
of symbols used to encode F on a tape of a Turing machine.
An instantaneous description of F is a pair hs, wi such that s  Q and w   . The
derivation relation ` for F is the smallest set such that, for all states s and s0 in Q, each
symbol c  , and each word w   , we have
 if s0  (s, c), then hs, c  wi ` hs0 , wi; and
 if s0  (s, ), then hs, wi ` hs0 , wi.
Let ` be the reflexive and transitive closure of `. Then, the language accepted by F is
defined as L(F) = {w   | hi, wi ` hf, i}. A language L is regular if and only if an FA
F exists such that L = L(F).
2.1.2 Pushdown Automata
A pushdown automaton (PDA) is a tuple P = hQ, , , , i, I, f, F i where Q is a finite set
of states;  is the input alphabet;  is the stack alphabet;  is a transition function mapping
each state s  Q, each symbol c    {}, and each stack symbol X   to a finite subset
(s, c, X)  Q   ; i  Q is the start state; I   is the start stack ; f  Q is the final
state; and F   is the final stack. The size |P| of P is the number of symbols used to
encode P on a tape of a Turing machine.
An instantaneous description of P is a triple hs, w, i such that s  Q, w   , and
   . We read the stack content  from left to rightthat is, the leftmost symbol in  is
the top of the stack. The derivation relation ` for P is the smallest set such that, for all
states s and s0 in Q, each symbol c  , each word w   , each stack symbol X  , and
all words  and  0 in  , we have

651

fiStefanoni, Motik, Krotzsch, & Rudolph

 hs0 ,  0 i  (s, c, X) implies hs, c  w, X  i ` hs0 , w,  0  i; and
 hs0 ,  0 i  (s, , X) implies hs, w, X  i ` hs0 , w,  0  i.
Let ` be the reflexive and transitive closure of relation `. Then, the language accepted by
P is defined as L(P) = {w   | hi, w, Ii ` hf, , F i}.
Our definitions of a PDA P and of a language L(P) are somewhat nonstandard: the
literature typically considers a Hopcroft PDA (Hopcroft et al., 2003) Ph that differs from
our definition in that it does not contain the final stack F and its initial stack I is a symbol
from  (rather than a word over ); moreover, the language accepted by Ph is defined as
Lh (Ph ) = {w   |    : hi, w, Ii ` hf, , i}. We show next that our definitions are
equivalent to the standard definitions by Hopcroft et al. (2003).
Proposition 1. The following two properties hold.
(1) For each PDA P, a Hopcroft PDA Ph exists such that L(P) = Lh (Ph ).
(2) For each Hopcroft PDA Ph , a PDA P exists such that Lh (Ph ) = L(P).
Proof (Sketch). We first prove property (1), after which we prove property (2).
(1) We show how to transform an arbitrary PDA P into a Hopcroft PDA Ph such that
L(P) = Lh (Ph ). Such Ph uses a fresh initial state i0 and fresh stack symbols Z0 and 
not occurring in . Symbol Z0 is the start stack symbol of Ph ; furthermore, Ph has a new
-transition that moves the PDA from state i0 to the initial state i of P by replacing Z0
with I  , where I is the start stack of P. At this point, Ph simulates P, always leaving
 at the bottom of the stack until it reaches the final state f of P. Next, Ph uses fresh
states s1 , . . . , s|F | and fresh -transitions that move Ph from state f to s|F | by reading F
from the stack. Finally, from s|F | , PDA Ph -moves to a fresh final state f 0 if the top-most
symbol on the stack is , thus accepting the input whenever P reaches f with F on its
stack. Automata P and Ph clearly accept the same languages.
(2) We show how to transform an arbitrary Hopcroft PDA Ph into a PDA P such that
Lh (Ph ) = L(P). PDA P uses a fresh stack symbol , its initial stack is I   where I is
the initial stack symbol of Ph , and its final stack is the empty word. Then P simulates Ph ,
always leaving  at the bottom of the stack until it reaches the final state f of Ph . Next, P
-moves to a fresh final state f 0 and pops the topmost symbol off the stack. At this point,
the PDA takes further -transitions to empty its stack, eventually reaching its final state
with the empty stack. Automata P and Ph clearly accept the same languages.
For k a natural number, the k-bounded language accepted by P is the set Lk (P) containing each word w   for which a derivation hs0 , w0 , 0 i `    ` hsn , wn , n i exists where
 s0 and sn are the start and the final state of P, respectively;
 w0 = w and wn = ;
 0 and n are the start and the final stack of P, respectively; and
 |i |  k for each i  [0..n].

652

fiThe Complexity of Answering CQs and GXQs over OWL 2 EL KBs

Then, P has a k-bounded stack if L(P) = Lk (P). As the stack of P is bounded by a
constant, PDA P can be simulated by a finite automaton that encodes the stack contents
using its states, and so L(P) is regular, but translating P into a finite automaton may
require space exponential in k (Geffert et al., 2010). In contrast, the following proposition
shows that there exists a PDA Pk such that L(Pk ) = Lk (P) and the size of Pk is polynomial
in the size of P and k.
Proposition 2. For each PDA P and natural number k, one can compute in polynomial
time a PDA Pk such that L(Pk ) = Lk (P).
Proof. Let P = hQ, , , , i, I, f, F i be a PDA and let k  N be a natural number. Let
Pk = hQk , , , k , ik , I, fk , F i be the PDA defined by
 Qk = Q  [0..k];
 transition function k is the smallest function such that, for each `  [0..k], each symbol
c    {}, all states s, s0  Q, and each word    such that hs0 , i  (s, c, X)
and ` + ||  1  k, we have hhs0 , ` + ||  1i, i  k (hs, `i, c, X); and
 ik = hi, |I|i and fk = hf, |F |i.
Clearly, Pk can be computed in time polynomial in the size of P and k. Let ` and `k be
the derivation relations for P and Pk , respectively. By the definitions of k and ik , we have
that hhs, `i, w, i `k hhs0 , ji, w0 ,  0 i if and only if hs, w, i ` hs0 , w0 ,  0 i, || = ` and | 0 | = j,
and max(`, j)  k. Thus, we have Lk (P) = L(Pk ), as required.
2.2 Description Logic ELRO+ and Conjunctive Queries
The description logic ELRO+ , underpinning OWL 2 EL, is defined w.r.t. a signature consisting of mutually disjoint and countably infinite alphabets C, R, and I of atomic concepts,
roles, and individuals, respectively. We assume that {>c , c }  C, where >c is the top
concept and c is the bottom concept; similarly, we assume that {>r , r }  R, where >r is
the top role (universal role) and r is the bottom role. For each individual a  I, expression
{a} is a nominal that is, a concept consisting precisely of individual a. Then, N is the set
containing nominal {a} for each individual a  I. We call each B  C  N a basic concept.
A role chain  is a word over R; for || = 0, we call  the empty role chain and we write it
as . Concepts, TBox axioms, RBox axioms, and ABox axioms are defined as specified in
Table 3. An ELRO+ TBox T is a finite set of concept inclusions, range restrictions, and
keys; and an ELRO+ RBox R is a finite set of role inclusions.
For R an ELRO+ RBox, let R := {>r }  {S  R | S occurs in R}; furthermore, the
rewrite relation =
 w.r.t. R is the smallest relation on role chains such that the following
holds for all role chains 1 and 2 .
 1  S  2 =
 1    2 for each axiom  v S  R.
 1  >r  2 =
 1    2 for each role chain   R .
Then =
 is the reflexivetransitive closure of 
= . For S a role, L(S) := {  R | S =
 }
is the language induced by RBox R. A role S is simple in R if, for each role chain  with
653

fiStefanoni, Motik, Krotzsch, & Rudolph

Concepts:
top concept
bottom concept
nominal
conjunction
self-restriction
existential restriction
Role chains:
top role
bottom role
empty role chain
nonempty role chain
TBox axioms:
concept inclusion
range restriction
key

RBox axioms:
role inclusion
ABox axioms:
concept assertion
role assertion

Syntax

Semantics

>c
c
{a}
C uD
S.Self
S.C

I

{aI }
C I  DI
{x  I | hx, xi  S I }
{x  I | y  C I : hx, yi  S I }

>r
r

S1    Sn

I  I

{hx, xi | x  I }
S1I      SnI

CvD
range(S, C)
key(C, S1 . . . Sn )

C I  DI
S I  I  C I
For all x, y, z1 , . . . , zn in I such that
individuals a, b, c1 , . . . , cn in I exist with
x = aI , y = bI , and zi = cIi for 1  i  n,
x = y holds whenever {x, y}  C I and
{hx, zi i, hy, zi i}  SiI for 1  i  n.

vS

I  S I
bI  S I
 SI

A(b)
S(a, b)

haI , bI i

Table 3: Interpreting ELRO+ concepts, roles, and axioms in an interpretation I = hI , I i

S=
 , we have ||  1. An ELRO+ ABox A is a finite set of concept and role assertions.
Finally, an ELRO+ knowledge base (KB) is a tuple K = hT , R, Ai where T is an ELRO+
TBox, R is an ELRO+ RBox, and A is an ELRO+ ABox such that
 for each concept S.Self occurring in T , role S is simple in R; and
 for each S1    Sn v S  R and each range(S 0 , C)  T such that S 0 =
 S, a role Sn0  R
0

0
exists such that Sn =
 Sn and range(Sn , C)  T .
Let |T |, |R|, and |A| be the numbers of symbols needed to encode T , R, and A, respectively,
on a tape of a Turing machine, and let |K| = |T |+|R|+|A|. Furthermore, for  a knowledge
base, a TBox, or an ABox, we define
I := {a  I | a occurs in }, N := {{a} | a  I }, and C := {A  C | A occurs in }.
654

fiThe Complexity of Answering CQs and GXQs over OWL 2 EL KBs

The semantics of ELRO+ is defined as follows. An interpretation is a tuple I = hI , I i
where I is a nonempty set of domain elements, called the domain of I, and I is the interpretation function that maps each individual a  I to a domain element aI  I , each
atomic concept A  C \ {>c , c } to a set AI  I , and each atomic role S  R \ {>r , r }
to a relation S I  I  I . Function I is extended to concepts and role chains as shown
in the upper part of Table 3, where  denotes composition of binary relations. An interpretation I is a model of K if it satisfies all axioms occurring in K as shown at the bottom of
Table 3. Moreover, K is consistent if a model of K exists; K is inconsistent if no model of
K exists; and K entails a first-order sentence  (resp. a concept inclusion C v D or a role
inclusion  v S), written K |=  (resp. K |= C v D or K |=  v S), if I |=  (resp. C I  DI
or I  S I ) for each model I of K. By the definition of L(S), we have that   L(S) implies
K |=  v S. Knowledge base consistency, entailment of concept inclusions, and entailment
of role inclusions can be decided in polynomial time (Krotzsch, 2011; Baader et al., 2005).
2.2.1 Conjunctive Queries
A term is an individual or a variable. An atom is an expression of the form A(t) or R(t0 , t)
where A is an atomic concept, R is a role, and t0 and t are terms. A conjunctive query (CQ)
is a formula q = ~y .(~x, ~y ) with  a conjunction of atoms over variables ~x  ~y . Variables ~x
are the answer variables of q. When ~x is empty, we call q = ~y .(~y ) a Boolean CQ (BCQ).
A substitution  is a partial mapping from variables to terms; and dom() and rng()
are the domain and the range of , respectively. For  a conjunction of atoms, () is the
result of applying substitution  to the atoms in . Then, (q) = ~z.(), where ~z contains
(i) (y) for each variable y  ~y such that (y) is a variable, and (ii) each variable y  ~y such
that (y) is undefined. Our definition of (q) is somewhat nonstandard because quantified
variables can also be replaced: for example, given q = y1 , y2 , y3 .R(y1 , y2 )  T (y1 , y3 ) and
 = {y2 7 a, y3 7 z}, we have (q) = y1 , z.R(y1 , a)  T (y1 , z).
Let K = hT , R, Ai be an ELRO+ knowledge base and let q = ~y .(~x, ~y ) be a CQ. Then
q is over K if q uses only the predicates and the individuals occurring in K. A substitution
 is a candidate answer for q over K, if dom() = ~x and rng()  IK , and such  is a certain
answer to q over K if and only if K |= (q). Answering q over K amounts to computing
the set of all certain answers to q over K. As stated, CQ answering is a function problem;
thus in this article we study the complexity of the associated decision problem named BCQ
answering, which is the problem of deciding, given a Boolean CQ q over K, whether K |= q.
Please note that BCQ answering is equivalent to the recognition problem which decides,
given a CQ q over K and a candidate answer , whether  is a certain answer to q over K.
Following Vardi (1982), combined complexity assumes that both q and K are part of the
input, and data complexity assumes that only the ABox A is part of the input.
2.3 Ensuring Decidability of BCQ Answering via Regularity
Rosati (2007) and Krotzsch et al. (2007) independently showed that answering Boolean
CQs over ELRO+ knowledge bases is undecidable. Intuitively, role inclusions can simulate derivations in context-free languages; thus, a Boolean CQ can check whether two
context-free languages have a non-empty intersection, which is a known undecidable problem (Hopcroft et al., 2003).

655

fiStefanoni, Motik, Krotzsch, & Rudolph

To regain decidability, we next recapitulate the definition of so-called regular RBoxes
by Horrocks and Sattler (2004). Let R be an ELRO+ RBox and let  be the smallest
transitive relation on R such that, for each   T  0 v S  R with S 6= T , we have T  S.
Then, RBox R is regular if  is irreflexive and each role inclusion  v S  R is of the form
(t1)  v S,
(t2) S  S v S,
(t3) S1    Sn  S v S and Si 6= S for each i  [1..n],
(t4) S1    Sn v S and Si 6= S for each i  [1..n], or
(t5) S  S1    Sn v S and Si 6= S for each i  [1..n].
By induction on  we then define the level lv(S) of each role S  R as follows: lv(S) = 0
if no T  R exists such that T  S; otherwise, lv(S) = 1 + max{lv(T ) | T  S}. Clearly,
lv(S) can be computed in time polynomial in |R|. In Section 4 we show that BCQ answering
over ELRO+ KBs with regular RBoxes is in PSpace.
2.4 Normalising ELRO+ Knowledge Bases
For simplicity, in the rest of this paper we assume that each ELRO+ knowledge base
K = hT , R, Ai is normalised, which is the case if the following properties hold.
(n1) We have IK 6= , and K 6|= {a} v {b} for all {a, b}  IK with a 6= b.
(n2) Each axiom in T is of one of the following forms, for A(i) basic concepts and S a role.
A1 u A2 v A3

A1 v S.A2

S.A1 v A2

A v S.Self

S.Self v A

(n3) Each axiom  v S  R is such that ||  2 and S 6= >r , and each role in T  A also
occurs in R.
We next show that each knowledge base K can be normalised in polynomial time without
affecting the regularity of the RBox component nor the answers to Boolean CQs.
Proposition 3. For each ELRO+ knowledge base K with a regular RBox and each Boolean
CQ q over K, one can compute in polynomial time a normalised ELRO+ knowledge base
K0 and a Boolean CQ q 0 such that
 the RBox of K0 is regular, and
 q 0 is over K0 , and K |= q if and only if K0 |= q 0 .
Proof. Let K be an ELRO+ KB with regular RBox and let q be a Boolean CQ over K.
We first satisfy property (n1). Let K1 be obtained from K by extending the ABox
of K with assertion >c (c) for c a fresh individual; clearly, K1 |= q if and only if K |= q.
Next, let K2 and q 0 be obtained from K1 and q, respectively, by uniformly substituting each
individual a with an arbitrary, but fixed, individual b such that K1 |= {a} v {b}. Entailment
656

fiThe Complexity of Answering CQs and GXQs over OWL 2 EL KBs

of concept inclusions can be decided in polynomial time, so K2 and q 0 can be computed in
polynomial time. Moreover, K2 and q 0 are obtained by replacing each individual a with an
arbitrary, but fixed individual b such that aI = bI for each model I of K1 , so q 0 is over K2 ,
and K2 |= q 0 if and only if K1 |= q.
We next satisfy property (n2). Let K3 be the result of eliminating all keys from K2 . As
one can see from Table 3, keys can only derive axioms of the form {a} v {b}; moreover,
the effects of such conclusions have already been captured by K2 , and so K3 |= q 0 if and
only if K2 |= q 0 . Next, we eliminate in polynomial time all range restrictions occurring in
K by applying the syntactic transformation by Baader et al. (2008); let K4 be the resulting
knowledge base. Since the definition of ELRO+ knowledge base carefully restricts the
interactions between role inclusions and range restrictions, we have K4 |= q 0 if and only if
K3 |= q 0 (Baader et al., 2008). Next, following Krotzsch (2011), we compute in polynomial
time a knowledge base K5 that satisfies (n2) such that K5 |= q 0 if and only if K4 |= q 0 .
We next satisfy property (n3). Let K6 be the result of exhaustively decomposing each
role inclusion  v S of the form (t3)(t5) with || > 2 occurring in K5 according to the
following rewrite rules, where each occurrence of role S 0 is fresh.
(t3) S1    Sn  S v S 7 {S 0  S v S,
S 1    Sn v S 0 }
0
(t4)
S1    Sn v S 7 {S  Sn v S, S1    Sn1 v S 0 }
(t5) S  S1    Sn v S 
7
{S  S 0 v S,
S 1    Sn v S 0 }
Only linearly many rewrite steps are required to satisfy (n3), and the resulting RBox is
regular. Furthermore, each model of K6 is also a model of K5 and each model I of K5
can be expanded to a model J of K6 by interpreting each role S 0 occurring in K6 \ K5 as
(S 0 )J = (0 )J , where 0 is the unique role chain such that 0 v S 0 occurs in K6 . Thus, we
have K6 |= q 0 if and only if K5 |= q 0 . Next, let K7 be the result of removing each axiom
 v >r in K6 ; all removed axioms are tautologies, so we have K7 |= q 0 if and only if K6 |= q 0 .
Finally, let K0 be the result of adding axiom r v S, for each role S that occurs in K7 but
does not occur in its RBox component. The axioms in K0 \ K7 preserve regularity and are
tautologies, so K0 |= q 0 if and only if K7 |= q 0 , as required.

3. Encoding Regular RBoxes Succinctly Using Bounded-Stack PDAs
Each reasoning algorithm for a DL with role inclusions known to us uses a step that checks
whether   L(S) holds for an arbitrary role chain  and a role S. For example, to check
whether K |= S(a, b) holds, an algorithm must ensure that, in each model of K, a role chain
  L(S) exists connecting the elements interpreting a and b. Although they characterise
languages L(S), role inclusions do not lend themselves well to language recognition, so all
algorithms known to us transform role inclusions into another, more manageable form. This
is analogous to the fact that, while regular expressions characterise regular languages, the
former are routinely transformed into FAs in order to facilitate language recognition.
Horrocks and Sattler (2004) showed that, for each regular RBox R and each role S
occurring in R, one can construct an FA FS such that L(FS ) = L(S). These FAs are used
in a tableau decision procedure for SROIQthe DL underpinning OWL 2 DL (Horrocks
et al., 2006). Given a SROIQ knowledge base, the tableau procedure tries to construct
657

fiStefanoni, Motik, Krotzsch, & Rudolph

S2

iS2

start




iS1

S1

fS2

iS1

fS1



S0

fS0

fS1





iS0

S1


iS0

S0

iS0

fS0

S0

fS0

iS0

S0

fS0

Figure 1: The FA FS2 as constructed following Horrocks and Sattler (2004)
a finite graph representing a model of the KB, in which edges are labelled by roles, and
vertices are labelled by concepts. The aforementioned FAs are used to ensure that universal
restriction S.C obey the constraints imposed by role inclusions; roughly speaking, this is
obtained by running FS over the graph while updating the current state of FS along the
path, and by labelling each reachable vertex in which the state of FS is final with concept
C. Simanck (2012) optimised the tableau procedure by simulating FAs on-the-fly, rather
than precomputing them in advance.
Horrocks and Sattler (2004) observed that their FAs can contain exponentially many
states. Kazakov (2008) proved that this is unavoidable in some cases: for the regular RBox
Rn containing axioms (1), the size of each FA F with L(F) = L(Sn ) is exponential in n.
Si1  Si1 v Si

i  [1..n]

(1)

This blowup in the number of states is caused by the simple model of computation underlying FAs, where the behaviour of the automaton is determined solely by the current state.
In the example above, we have   L(Sn ) whenever  consists of Si repeated j times for
some i  [0..n] with j = 2ni . Thus, while parsing such , the FA recognising L(Sn ) must
remember the number of occurrences of Si it has already seen, which can be achieved only
by using a different state for each number between 0 and 2n . Figure 1 shows the FA FS2
constructed by Horrocks and Sattler (2004): to remember the current state, FS2 contains
two copies of automaton FS1 , and each copy of FS1 contains two copies of automaton FS0 .
Hence, to obtain a PSpace procedure, we must devise a more succinct representation for
the languages induced by role inclusions. Towards this goal, we note that role inclusions are
closely related to context-free grammars, and that context-free languages can be efficiently
recognised using pushdown automata (Hopcroft et al., 2003)that is, FAs extended with
an infinite stack for storing contextual information. Hence, given a regular RBox R and a
role S occurring in R, we construct a PDA PS that accepts L(S). Unlike the FA shown in
Figure 1 that remembers contextual information using states, PDA PS uses the stack to
remember the current status of the computation and determine how to proceed. We show
that the number of states in PS is polynomial in the size of R, and that PS can recognise
L(S) by using a stack of size linear in the size of R; thus, PS provides us with the required
succinct encoding of FS . In Section 4, we use these PDAs in an algorithm that answers
Boolean CQs over ELRO+ knowledge bases using polynomial space.
658

fiThe Complexity of Answering CQs and GXQs over OWL 2 EL KBs

start

iS2

S2 , X/X

fS2
, X/X

, X/iS1  fS2  X

iS1

S1 , X/X

i>r

fS1

R, X/X

f>r

, X/X
, X/iS0  fS1  X

iS0

S0 , X/X

fS0

Figure 2: The PDA PS2 corresponding to the FA FS2 , where X  R and R  R
In the rest of this section, we fix an arbitrary regular RBox R. By Proposition 3, we
can assume that each role inclusion  v S  R is such that ||  2 and S 6= >r . For each
role S occurring in R , we next define the PDA PS .
Definition 4. Let S  R be a role. Then, PS = hQR , R , R , R , iS , , fS , i is the PDA
where QR = {iT , fT | T  R } is the set of states, R = QR  {} is the stack alphabet, and
R is the smallest transition function satisfying the following conditions for each X  R .
(r) For each T  R \ {>r }, we have hfT , Xi  R (iT , T, X).
(t1) For each  v T  R, we have hfT , Xi  R (iT , , X).
(t2) For each T  T v T  R, we have hiT , Xi  R (fT , , X).
(t3) For each T1  T v T  R, we have hiT1 , iT  Xi  R (iT , , X).
(t4) For each T1  T2 v T  R, we have hiT1 , iT2  fT  Xi  R (iT , , X).
(t5) For each T  T2 v T  R, we have hiT2 , fT  Xi  R (fT , , X).
(ur) For each T  R , we have hf>r , Xi  R (i>r , T, X).
(u1) hf>r , Xi  R (i>r , , X).
(u2) hi>r , Xi  R (f>r , , X).
(p) For each T  R and each s  QR , we have hs, i  R (fT , , s).
In the following examples, we present the PDA that succinctly encodes the FA FS2 , and
we explain the different types of transitions in Definition 4, and how the content of the
stack influences the computation of PDAs.
Example 5. Figure 2 shows the PDA PS2 corresponding to the FA FS2 in Figure 1. A
c, X/

transition hs0 , i  R (s, c, X) is shown as s  s0 , where X/ indicates that the transition replaces the top-most stack symbol X with word ; moreover, transitions of the form
(p) from Definition 4 are not shown in the figure for the sake of clarity. As one can see
from the figure, unlike in FA FS2 , there is no copying of states in PDA PS2 .
659

fiStefanoni, Motik, Krotzsch, & Rudolph

, X/X

start

iS

S, X/X

, X/i>r  fS  X

i>r

fS

R, X/X

f>r

, X/X

, X/fS  X
, X/iT  X

iP

iT

T, X/X

fT

, X/X
, X/X

P, X/X

fP
Figure 3: The PDA PS for the RBox in Example 6, where X  R and R  R
Example 6. To explain the different types of transitions in Definition 4 and how the stack
is used in the computation of a PDA, we use the regular RBox R containing role inclusions
(2)(6). Figure 3 shows PDA PS using the notation from Example 5.
vP

(2)

T T vT

(3)

P  >r v S

(4)

ST vS

(5)

P T vT

(6)

Each role T  R is associated with states iT and fT , and moving from the former to
the latter ensures that the PDA reads a role chain   L(T ). A transition of type (r) allows
the PDA to read T in state iT . An -transition of type (t1) from iT to fT is added if T
is reflexive, and it allows the PDA to read the empty role chain; in our example, axiom
(2) introduces the -transition from iP to fP . Moreover, an -transition of type (t2) from
fT to iT is added if T is transitive, and it allows the PDA to read any number of role
chains 1 , . . . , n  L(T ); in our example, axiom (3) introduces the -transition from fT
to iT . Transitions of types (ur), (u1), and (u2) analogously reflect the properties of >r :
(ur) allows the PDA to read an arbitrary role, and (u1) and (u2) reflect the reflexivity and
transitivity of >r , respectively. None of these transitions affect the PDAs stack.
To illustrate transitions of type (t4), we next show how, for 1 = P  S, PDA PS
determines that 1  L(S); the latter is ensured by axiom (4). Now assume that PDA PS is
in state iS with  on its stack. Due to axiom (4), PS can make an -transition of type (t4)
to state iP , pushing i>r  fS on the stack. Since the new state is iP , the PDA will next need
to read P ; furthermore, the stack content signals to the PDA that, after it finishes reading
P , it should move to state i>r to read >r and then to state fS to finish reading S. Indeed,
PS can then make a transition of type (r) to state fP to read P , followed by an -transition
of type (p) to state i>r popping i>r off the stack; next, the PDA can make a transition of
660

fiThe Complexity of Answering CQs and GXQs over OWL 2 EL KBs

type (ur) to state f>r reading S, followed by an -transition of type (p) to state fS popping
fS off the stack. At this point, the PDA accepts the input.
To illustrate transitions of types (t3) and (t5), we next show how, for 2 = S P T , PDA
PS determines that 2  L(S); the latter is ensured by axioms (5) and (6). Again, assume
that PDA PS is in state iS with  on its stack. PDA PS can then make a transition of type
(r) to state fS , reading S and leaving the stack unchanged; next, due to axiom (5), PS can
make an -transition of type (t5) to state iT , pushing fS on the stack. Due to axiom (6),
PDA PS can next make an -transition of type (t3) to state iP , pushing iT on the stack;
at this point, the stack contains iT  fS  . Next, the PDA can make a transition of type
(r) to state fP reading P , and then an -transition of type (p) to state iT popping iT off
the stack; furthermore, in an analogous way, the PDA can move to state fT reading T and
leaving fS   on the stack. Finally, the PDA can make an -transition of type (p) to state
fS popping fS off the stack. At this point, the PDA accepts the input.
To understand the benefit of using PDAs rather than FAs, note that PS reaches state iP
while recognising both 1 and 2 . Role P occurs in axioms (4) and (6), so when PS moves
into state iP in order to read an occurrence of P , it must remember which of the two
axioms caused the move so that it knows how to continue after reading P : for 1 , PS must
continue reading >r , whereas for 2 , it must continue reading T . Unlike the FAs by Horrocks
and Sattler (2004) that remember this information by copying states, PS remembers this
information on its stack: for 1 , it reaches iP with i>r  fS   on its stack, whereas for 2 ,
PS reaches iP with iT  fS   on its stack. Thus, the stack of PS is analogous to stacks in
programming languages: stack symbols correspond to return addresses, and transitions of
type (p) correspond to return statements.
The following proposition is immediate from the definition of PDA PS .
Proposition 7. PDA PS can be computed in time polynomial in |R|.
The following theorem states that PDA PS accepts L(S) and that PS has stack bounded
by the size of R. The proof of this result is given in Section 3.1.
Theorem 8. For each role S  R and each role chain ,
1.   L(PS ) if and only if   L(S), and
2. PS has stack bounded by 2  lv(S) + 1.
Theorem 8 gives rise to the following notion of the depth of RBox R, which provide us
with a global bound on the stack size of the PDAs encoding R.
Definition 9. The depth of the RBox R is defined as dR := maxSR (2  lv(S) + 1).
Finally, we outline how our bounded-stack encoding of regular RBoxes can reduce the
space used by the tableau algorithm for SROIQ. Since ELRO+ does not support inverse
roles, Definition 4 does not directly provide us with an encoding of the languages induced
by SROIQ RBoxes. Nevertheless, we can extend the construction above by completing
RBox R so that inv(Sn )    inv(S1 ) v inv(S)  R for each role inclusion S1    Sn v S in the
RBox, where inv() maps each role to its inverse. One can check that, for each (inverse) role
661

fiStefanoni, Motik, Krotzsch, & Rudolph

S, the PDA PS constructed using the completed RBox R encodes FS . Then, we can modify
the portion of the tableau algorithm responsible for checking the satisfaction of universal
restrictions by running a bounded-stack PDA over the graph constructed by the tableau
procedure. Roughly speaking, for each universal restriction S.C labelling a vertex, we run
PS over the graph while updating the current state and the stack of PS , and we label each
reachable vertex in which the current state and stack of PS are final with concept C. Since
PS and its stack are of size polynomial in |R|, this requires polynomial space, unlike the
FAs by Horrocks and Sattler (2004) and the optimised encoding by Simanck (2012), which
may require exponential space.
3.1 Proof of Correctness
In this section, we prove Theorem 8. Towards this goal, let ` be the derivation relation
w.r.t. transition function R ; furthermore, for each derivation step hs, , i ` hs0 , 0 ,  0 i,
we write hs, , i `x hs0 , 0 ,  0 i if hs0 , 0 ,  0 i can be obtained from hs, , i by applying a
transition of the form (x) from Definition 4 with x  {r, t1, . . . , t5, ur, u1, u2, p}.
3.1.1 Soundness and Stack Boundedness
In this section, we prove that, for each role S  R and each role chain ,
1.   L(PS ) implies that   L(S), and
2. PS has stack bounded by 2  lv(S) + 1.
To this end, we first show that PDA PS satisfies the following liveness property: if during
its computation PS pushes a state s  QR on the stack, then PS will eventually pop s off
the stack. Then, we show that each derivation of PS moving from state iS to state fS takes
one of five forms; we call such derivations regular. Finally, we show that regular derivations
satisfy properties (1) and (2).
We start by showing that each PDA PS satisfies the following liveness property.
Lemma 10. Let hs0 , 0 , 0  i `    ` hsn , n , n  i be an arbitrary derivation such that
s0 = iS , sn = fS , and 0 =  for some role S  R and some word   R . Then, for each
role T such that lv(T ) < lv(S) and each i  [0..n] such that si  {iT , fT } and i = s0i  i0
with s0i  QR , an index j  [i..n] exists such that
(a) sj = fT and j = i ;
(b) for each k  [i..j], word k is of the form k := k00  i for some k00  R ; and,
(c) sj+1 = s0i , j+1 = i0 , and j+1 = j .
Proof. Let hs0 , 0 , 0  i `    ` hsn , n , n  i be as above, and for each i  [0..n  1], let
xi  {r , t1 , . . . , t5 , ur , u1 , u2 , p} be the form of derivation step ithat is, we fix xi (arbitrarily if there is more than one possibility) such that hsi , i , i  i `xi hsi+1 , i+1 , i+1  i
holds. Furthermore, for each role T such that lv(T ) < lv(S), let IT be the set containing
each index i  [0..n] such that si  {iT , fT } and i is of the form i := s0i  i0 with s0i  QR .
Note that, for each index i  IT , due to lv(T ) < lv(S), si  {iT , fT }, and sn = fS , we have
662

fiThe Complexity of Answering CQs and GXQs over OWL 2 EL KBs

that i < nthat is, hsi , i , i  i ` hsi+1 , i+1 , i+1  i occurs in our derivation. Next, by
induction on m  N, we show that, for each role T with m = lv(T ) < lv(S) and each i  IT ,
some j  [i..n] exists satisfying properties (a)(c).
Base case (). Consider an arbitrary role T  R such that 0 = lv(T ) < lv(S). We
consider the interesting case where IT 6= ; otherwise, properties (a)(c) hold vacuously.
Since lv(T ) = 0 and si  {iT , fT }, we have xi  {r , t1 , t2 , ur , u1 , u2 , p}. By reverseinduction on IT (i.e., by induction starting from the maximal element), we next show that
each index i  IT satisfies the required properties.
Base case. Let i = max IT . If xi  {r , t1 , t2 , ur , u1 , u2 }, then si+1  {iT , fT } and
i+1 = i ; thus, we have i + 1  IT , which contradicts the maximality of i. The only
remaining possibility is xi = p, which implies that si = fT , si+1 = s0i , i+1 = i0 , and
i+1 = i ; but then, j = i satisfies properties (a)(c).
Inductive step. Consider an arbitrary index i  IT such that properties (a)(c) hold for
each `  IT with ` > i. If xi  {r , t1 , t2 , ur , u1 , u2 }, then si+1  {iT , fT } and i+1 = i ;
hence, ii+1  IT so, by the inductive hypothesis, an index j exists satisfying properties
(a)(c). Otherwise, if xi = p, then si = fT , si+1 = s0i , i+1 = i0 , and i+1 = i , so j = i
satisfies properties (a)(c).
Inductive Step (). Consider an arbitrary m  N such that properties (a)(c) hold for
each role P  R with lv(P )  m and lv(P ) < lv(S) and each index in IP . Furthermore,
consider an arbitrary role T such that m + 1 = lv(T ) < lv(S). We consider the interesting
case where IT 6= ; otherwise, properties (a)(c) hold vacuously. Recall that for each
 v S 0  R we have S 0 6= >r , so lv(>r ) = 0 and T 6= >r . Thus, each i  IT is such that
xi 6 {ur , u1 , u2 }. By reverse-induction on IT , we next show that each index i  IT satisfies
the required properties.
Base case (). Let i = max IT . If xi  {r , t1 , t2 }, then si+1  {iT , fT } and i+1 = i ;
thus, we have i + 1  IT , which contradicts the maximality of i. If xi  {t3 , t4 , t5 }, then
si+1  {iP , fP } for some role P such that lv(P ) < lv(T ) and lv(P ) < lv(S); furthermore, we
00  s   where s  {i , f } and  00
have that i+1 is of the form i+1 := i+1
i
T
T
T T
i+1 is a sequence
00
of zero or one states. Each state s occurring in i+1
is such that s  {iR , fR } for some role
R of level less than T . But then, by the inductive hypothesis (), an index ` > i exists
such that s` = sT and ` = i , which contradicts the maximality of i. Finally, if xi = p,
then si = fT , si+1 = s0i , i+1 = i0 , and i+1 = i , so j = i satisfies properties (a)(c).
Inductive step (). Consider an arbitrary index i  IT such that properties (a)(c) hold
for each index `  IT with ` > i, and consider the possible forms of xi .
 xi  {r , t1 , t2 }. Then, si+1  {iT , fT } and i+1 = i , so i + 1  IT . By the inductive
hypothesis (), an index j exists satisfying properties (a)(c).
 xi = t3 . Then, si+1 = iT1 and i+1 = iT  i for some role T1 with lv(T1 ) < lv(T ).
Thus, i + 1  IT1 . By the inductive hypothesis (), an index `  [i + 1..n] exists such
that s` = fT1 and ` = i+1 ; furthermore, for each k  [i + 1..`], we have that k is
of the form k := k00  i+1 for some word k00  R ; finally, s`+1 = iT and `+1 = i .
By the definition of IT , we have that ` + 1  IT . By the inductive hypothesis (), an
index j exists satisfying properties (a)(c).
663

fiStefanoni, Motik, Krotzsch, & Rudolph

 xi = t4 . Then, si+1 = iT1 and i+1 = iT2  fT  i for some roles T1 and T2 with
lv(T1 ) < lv(T ) and lv(T2 ) < lv(T ). Thus, i + 1  IT1 . By the inductive hypothesis
(), an index `1  [i + 1..n] exists such that s`1 = fT1 and `1 = i+1 ; furthermore, for
each k  [i..`1 ], we have that k is of the form k := k00  i+1 for some word k00  R ;
finally, s`1 +1 = iT2 and `1 +1 = fT  i . Then, `1 + 1  IT2 . Again, by the inductive
hypothesis (), an index `2  [`1 + 1..n] exists such that s`2 = fT2 and `2 = `1 +1 ;
furthermore, for each k  [`1 + 1..`2 ], we have that k is of the form k := k00  `1 +1
for some word k00  R ; finally, s`2 +1 = fT and `2 +1 = i . By the definition of IT , we
have that `2 + 1  IT . So, by the inductive hypothesis (), an index j exists satisfying
properties (a)(c).
 xi = t5 . Then, si+1 = iT2 and i+1 = fT  i for some role T2 with lv(T2 ) < lv(T ).
Then, i + 1  IT2 . By the inductive hypothesis (), an index `  [i + 1..n] exists
such that s` = fT2 and ` = i+1 ; for each k  [i..`], we have that k is of the form
k := k00  i+1 for some word k00  R ; finally, s`+1 = fT and `+1 = i . By the
definition of IT , we have that ` + 1  IT . So, by the inductive hypothesis (), an
index j exists satisfying properties (a)(c).
 xi = p. Then, si = fT , si+1 = s0i , i+1 = i0 , and i+1 = i . Therefore, j = i satisfies
properties (a)(c).
Next, for each role S  R , we define the notion of regular derivations of PS .
Definition 11. The set of regular derivations of P>r is inductively defined as follows, for
each role T  R , each role chain i  R , and each   R .
sequr hi>r , T  0 , i `ur hf>r , 0 , i is a regular derivation of P>r .
sequ1 hi>r , 0 , i `u1 hf>r , 0 , i is a regular derivation of P>r .
sequ2 If hi>r , 0 , i `    ` hf>r , k , i and hi>r , k , i `    ` hf>r , n , i are regular derivations of P>r , then the following is also a regular derivation of P>r .
hi>r , 0 , i `    ` hf>r , k , i `u2 hi>r , k , i `    ` hf>r , n , i
Next, consider an arbitrary natural number m  N and assume that regular derivations of
PT have already been defined for T = >r and each role T  R \ {>r } such that lv(T )  m.
Then, for each role S  R \ {>r } with lv(S) = m + 1, regular derivations of PS are defined
as follows, for each S(i)  R , each i  R , and each   R .
seqr hiS , S  0 , i `r hfS , 0 , i is a regular derivation of PS .
seqt1 If  v S  R, then hiS , 0 , i `t1 hfS , 0 , i is a regular derivation of PS .
seqt2 If S  S v S  R and hiS , 0 , i `    ` hfS , k , i and hiS , k , i `    ` hfS , n , i
are regular derivations of PS , then the following is also a regular derivation of PS .
hiS , 0 , i `    ` hfS , k , i `t2 hiS , k , i `    ` hfS , n , i

664

fiThe Complexity of Answering CQs and GXQs over OWL 2 EL KBs

seqt3 If S1  S v S  R, hiS1 , 0 , iS  i `    ` hfS1 , k , iS  i is a regular derivation of
PS1 , and hiS , k , i `    ` hfS , n , i is a regular derivation of PS , then the following
is also a regular derivation of PS .
hiS , 0 , i `t3 hiS1 , 0 , iS  i `    ` hfS1 , k , iS  i `p hiS , k , i `    ` hfS , n , i
seqt4 If S1 S2 v S  R, hiS1 , 0 , iS2  fS  i `    ` hfS1 , k , iS2  fS  i is a regular derivation of PS1 , and hiS2 , k , fS  i `    ` hfS2 , n , fS  i is a regular derivation of PS2 ,
then the following is also a regular derivation of PS .
hiS , 0 ,
hiS1 , 0 , iS2  fS
fS
hiS2 , k ,
hfS , n ,

i `t4
 i `    ` hfS1 , k , iS2  fS  i `p
fS  i `p
 i `    ` hfS2 , n ,
i

seqt5 If S  S2 v S  R, hiS , 0 , i `    ` hfS , k , i is a regular derivation of PS , and
hiS2 , k , fS  i `    ` hfS2 , n , fS  i is a regular derivation of PS2 , then the following is also a regular derivation of PS .
hiS , 0 , i `    ` hfS , k , i `t5 hiS2 , k , fS i `    ` hfS2 , n , fS i `p hfS , n , i
We are left to show that each derivation of PS that moves the PDA from the start state
iS to the final state fS is regular and that regular derivations satisfy the required properties.
In the following lemma, we show that derivations which leave a particular word  at the
bottom of the stack are regular and satisfy properties (1) and (2). Subsequently, we will
show that each accepting derivation of PS is of this form.
Lemma 12. For each role S  R , each word   R , and each derivation of the form
hs0 , 0 , 0  i `    ` hsn , n , n  i such that s0 = iS , sn = fS , and 0 = ,
(i) the derivation is regular for PS ;
(ii) for each i  [0..n], we have that |i |  2  lv(S); and
(iii) S 
=  0  n .
Proof. We prove the claim by induction on n  N+ .
Base case. For n = 1, consider an arbitrary role S  R , word   R , and sequence
hiS , 0 , 0  i ` hfS , 1 , 1  i. By Definition 4, only transitions from cases (r), (t1), (ur),
and (u1) move PS from state iS to state fS . These transitions leave the stack untouched,
so 1 =  = 0 and property (ii) holds. For properties (i) and (iii), we next consider the
four different forms that the sequence may take.
 hiS , S  1 , 0  i `r hfS , 1 , 1  i. Then S 6= >r , so this is a regular derivation of
PS by case seqr and (i) holds. Finally, 0  1 = S, which implies S =
 0  1 , and
so (iii) holds.
665

fiStefanoni, Motik, Krotzsch, & Rudolph

 hiS , 0 , 0  i `t1 hfS , 0 , 1  i. Then S 6= >r , so this is a regular derivation of PS
by case seqt1 and (i) holds. Finally, 0  1 = ; moreover, by case t1 of Definition 4,
we have  v S  R, so S =
 ; hence, S =
 0  1 and (iii) holds.
 hiS , T  1 , 0  i `ur hfS , 1 , 1  i. Then S = >r and T  R , so this is a regular
derivation of P>r by case sequr and (i) holds. Finally, 0  1 = T  R , which
implies S =
 0  1 , and so (iii) holds.
 hiS , 0 , 0  i `u1 hfS , 0 , 1  i. Then S = >r , so this is a regular derivation of P>r
by case sequ1 and (i) holds. Finally, 0  1 = ; hence, S =
 , and so (iii) holds.
Inductive step. Consider an arbitrary n  N+ and assume that (i)(iii) hold for each
role S 0  R , each word  0  R , and each derivation hs00 , 00 , 00   0 i `    ` hs0c , 0c , c0   0 i
of length at most n and of the form required by this lemma. Furthermore, consider an
arbitrary role S  R , an arbitrary word   R , and an arbitrary derivation
hs0 , 0 , 0  i `    ` hsn+1 , n+1 , n+1  i

(7)

of length n + 1 such that s0 = iS , 0 = , and sn+1 = fS . For each i  [0..n  1], let
xi  {r , t1 , . . . , t5 , ur , u1 , u2 , p} be the form of derivation step ithat is, we fix xi (arbitrarily if there is more than one possibility) such that hsi , i , i  i `xi hsi+1 , i+1 , i+1  i
holds. We next consider the possible forms the sequence might have, and we show that
properties (i)(iii) hold in each case.
(Case 1) S = >r . We consider the form of hs0 , 0 , 0  i `x0 hs1 , 1 , 1  i. Since
s0 = i>r , we have x0  {t1 , t3 , t4 , ur , u1 }. As R is normalised, each  v S 0  R is
such that S 0 6= >r , so x0  {ur, u1} and we have s1 = f>r and 1 =  = 0 . Since n > 1,
hs1 , 1 , 1  i `x1 hs2 , 1 , 2  i occurs in the sequence with x1  {t2 , t5 , u2 , p}. Since
s1 = f>r and R is normalised, we have x1  {u2 , p}; furthermore, since 1 =  and by our
assumption on the form of (7), we have x1 6= p. Hence, the only remaining possibility is
that x1 = u2 . By case (u2) in Definition 4, we have s2 = i>r , 2 = 1 , and 2 = 1 . We
next prove that properties (i)(iii) hold.
(i) By sequr and sequ1 , hs0 , 0 , 0  i `x0 hs1 , 1 , 1  i is a regular derivation of P>r . By
the inductive hypothesis, hs2 , 2 , 2  i `    ` hsn+1 , n+1 , n+1  i is also a regular
derivation of PS . By the definition of regular derivations, we have n = 2 = . But
then, (7) is a regular derivation of PS by case sequ2 .
(ii) Words 0 , 1 , 2 are all empty. By the inductive hypothesis, we have |` |  2  lv(>r )
for each `  [2..n + 1]. Therefore, |i |  2  lv(>r ) holds for each i  [0..n + 1].
(iii) By the inductive hypothesis, we have >r =
 2  n+1 . By cases (ur) and (u1), either
0  2 =  or 0  2 = T  R . But then, >r 
=  0  n+1 holds.
(Case 2) S 6= >r and k  [0..n] exists with hsk , k , k  i `t2 hsk+1 , k+1 , k+1  i and
sk = fS . Then, by case (t2) in Definition 4, we have S  S v S  R, sk+1 = iS , k+1 = k ,
and k+1 = k . We next prove that properties (i)(iii) hold.

666

fiThe Complexity of Answering CQs and GXQs over OWL 2 EL KBs

(i) By the inductive hypothesis, hs0 , 0 , 0 i `    ` hsk , k , k i is a regular derivation
of PS . By the definition of regular derivations, we have k = 0 = . Since sk+1 = iS
and k+1 = k = , we have that hsk+1 , k+1 , k+1  i `    ` hsn+1 , n+1 , n+1  i
is of the form shown in (7) and it is shorter than n + 1 so, by the inductive hypothesis,
it is a regular derivation of PS . Then, (7) is a regular derivation of PS by case seqt2 .
(ii) By the inductive hypothesis, we have |`1 |  2  lv(S) for each `1  [0..k], as well as
|`2 |  2  lv(S) for each `2  [k + 1..n + 1]. Therefore, |i |  2  lv(S) holds for each
i  [0..n + 1].
(iii) By the inductive hypothesis, we have S =
 0  k and S =
 k+1  n+1 . But then,

S  S v S  R and k+1 = k implies that S =
 0  n+1 holds.
(Case 3) S 6= >r and no `  [0..n] exists with hs` , ` , `  i `t2 hs`+1 , `+1 , `+1  i
and s` = fS , but k  [0..n] exists such that hsk , k , k  i `t5 hsk+1 , k+1 , k+1  i and
sk = fS . Then, let k be the largest such indexthat is, we assume that no m > k exists
such that hsm , m , m  i `t5 hsm+1 , m+1 , m+1  i and sm = fS . Then, by case (t5) in
Definition 4, for some role S2 of level less than S, we have that S  S2 v S  R, sk+1 = iS2 ,
k+1 = k , and k+1 = fS  k . We next prove that properties (i)(iii) hold.
(i) Since sk = fS , by the inductive hypothesis then hs0 , 0 , 0  i `    ` hsk , k , k  i
is a regular derivation of PS . By Definition 12, we have that k = 0 . Since sk+1 = iS2
and k+1 = fS  0 , by Lemma 10, an index j  [k + 1..n] exists such that sj = fS2
and j = k+1 ; furthermore, sj+1 = fS and j+1 = 0 and j+1 = j . We prove that
j + 1 = n + 1. For the sake of contradiction, assume that j + 1 < n + 1 and consider
the form of transition hsj+1 , j+1 , j+1  i `xj +1 hsj+2 , j+2 , j+2  i. Given that
sj+1 = fS and S 6= >r , we must have xj+1  {t2 , t5 , p}. By the initial assumption,
we have xj+1 6= t2 ; furthermore, by the maximality of k, we have xj+1 6= t5 ; finally,
since j+1 = 0 = , we have xj+1 6= p. Thus, j + 1 = n + 1, as required. It follows
that the sequence is of the following form, where k+1 = k and n+1 = n .
hiS , 0 ,
0  i `    ` hfS , k , 0  i `t5
hiS2 , k+1 , k+1  i `    ` hfS2 , n , n  i `p
hfS , n+1 , 0  i
By Lemma 10, for each `  [k + 1..n], we have that ` is of the form ` = `00  fS  0 . In
00
particular, words k+1
and n00 are both empty. Then, by the inductive hypothesis, we
have that hiS2 , k+1 , k+1  i `    ` hfS2 , n , n  i is a regular derivation of PS2 .
By case seqt5 , then (7) is a regular derivation of PS .
(ii) By the inductive hypothesis, for each `1  [0..k], we have that |`1 |  2  lv(S). Furthermore, for each `2  [k + 1..n], we have that |`002 |  2  lv(S2 ). Since lv(S2 ) < lv(S)
and `2 = `002  fS , we also have that |`2 |  2  lv(S). Given that n+1 = , for each
i  [0..n + 1], we have that |i |  2  lv(S).
(iii) By the inductive hypothesis, we have that S =
 0  k and S2 =
 k+1  n . Given

that S =
 S  S2 , that k+1 = k , and that n+1 = n , we obtain that S =
 0  n+1 .

667

fiStefanoni, Motik, Krotzsch, & Rudolph

(Case 4) S 6= >r and no `  [0..n] exists with hs` , ` , `  i `x` hs`+1 , `+1 , `+1  i,
s` = fS and x`  {t2 , t5 }; but hs0 , 0 , 0  i `t3 hs1 , 1 , 1  i. Then, by case (t3) in Definition 4, for some role S1 of level less than S, we have that S1  S v S  R, s1 = iS1 ,
1 = 0 , and 1 = iS  0 . We next prove that properties (i)(iii) hold.
(i) Since s1 = iS1 and 1 = iS  0 , by Lemma 10, some j  [1..n] exists such that sj = fS1
and j = 1 ; furthermore, sj+1 = iS and j+1 = 0 and j+1 = j . Then, the sequence
is of the following form, where 1 = 0 .
hiS , 0 ,
0  i `t3
j  i `p
1  i `    ` hfS1 , j ,
hiS1 , 1 ,
hiS , j+1 , j+1  i `    ` hfS , n+1 , n+1  i
By Lemma 10, for each `  [1..j], we have that ` is of the form ` = `00  iS  0 .
In particular, words 100 and j00 are both empty. By the inductive hypothesis, then
hiS1 , 0 , 1  i `    ` hfS1 , j , j  i is a regular derivation of PS1 . Since j+1 = 0 ,
by the inductive hypothesis, then hiS , j+1 , j+1  i `    ` hfS , n+1 , n+1  i is a
regular derivation of PS . By case seqt3 , then (7) is a regular derivation of PS .
(ii) By the inductive hypothesis, for each `2  [j + 1..n + 1], we have that |`2 |  2  lv(S);
furthermore, for each `1  [1..j], we have that |`001 |  2  lv(S1 ). Since lv(S1 ) < lv(S)
and `1 = `001  iS , we also have that |`1 |  2  lv(S). Finally, since 0 = , for each
i  [0..n + 1], we have that |i |  2  lv(S).
(iii) By the inductive hypothesis, we have that S1 =
 1  j and that S =
 j+1  n+1 .
Given that S =
 S1 S, that 1 = 0 , and that j+1 = j , we have that S =
 0 n+1 .
(Case 5) S 6= >r and no `  [0..n] exists with hs` , ` , `  i `x` hs`+1 , `+1 , `+1  i,
s` = fS , and x`  {t2 , t5 }; in addition, hs0 , 0 , 0  i `x0 hs1 , 1 , 1  i is such that x0 6= t3.
We next consider the remaining possibilities for x0 . As s0 = iS , we have x0 6 {t2 , t5 , u2 , p}
by cases (t2), (t5), (u2), and (p) of Definition 4; furthermore, due to S 6= >r , we have
x0 6 {ur , u1 } by cases (ur) and (u1) of Definition 4. Moreover, assume that x0  {r , t1 };
then, we have s1 = fS and 1 = 0 by cases (r) and (t1) of Definition 4; since n > 1 and
S 6= >r , the only possibility is that hs1 , 1 , 1  i `p hs2 , 2 , 2  i, which is impossible
due to 1 =  and our assumption on the form of (7). Hence, the only remaining possibility
is that x0 = t4 . By case (t4) in Definition 4, for some roles S1 and S2 of level less than
S, we have S1  S2 v S  R, s1 = iS1 , 1 = 0 , and 1 = iS2  fS  0 . We next prove that
properties (i)(iii) hold.
(i) Since s1 = iS1 and 1 = iS2  fS  0 , by Lemma 10, j1  [1..n] exists such that sj1 = fS1
and j1 = 1 ; furthermore, sj1 +1 = iS2 and j1 +1 = fS  0 and j1 +1 = j1 . Again,
by Lemma 10, j2  [j1 + 1..n] exists such that sj2 = fS2 and j2 = j1 +1 ; furthermore,
sj2 +1 = fS and j2 +1 = 0 and j2 +1 = j2 . Next, we prove that j2 + 1 = n + 1.
For the sake of contradiction, suppose that j2 + 1 < n + 1 and consider the form
of hsj2 +1 , j2 +1 , j2 +1  i `xj2 +1 hsj2 +2 , j2 +2 , j2 +2  i. Given that sj2 +1 = fS , we
must have that xj2 +1  {t2 , t5 , u2 , p}. However, we assumed that xj2 +1 6 {t2 , t5 }
and that S 6= >r , so xj2 +1 6= u2 ; finally, since j2 +1 = 0 = , we have xj2 +1 6= p.
668

fiThe Complexity of Answering CQs and GXQs over OWL 2 EL KBs

Therefore, we have j2 + 1 = n + 1, as required, and the sequence is of the following
form, for 1 = 0 , j1 +1 = j , and n+1 = n .
hiS , 0 ,
0  i `t4
hiS1 , 1 ,
1  i `    ` hfS1 , j1 , j1  i `p
hiS2 , j1 +1 , j1 +1  i `    ` hfS2 , n , n  i `p
hfS , n+1 , n+1  i
By Lemma 10, for each `1  [1..j1 ], word `1 is of the form `1 = `001  iS2  fS  0 .
In particular, words 100 and j001 are both empty. Then, by the inductive hypothesis,
we have that hiS1 , 1 , 1  i `    ` hfS1 , j1 , j1  i is a regular derivation of PS1 .
Similarly, by Lemma 10, for each `2  [j1 + 1..n], we have that `2 is of the form
`2 = `002  fS  0 . In particular, words j001 +1 and n00 are both empty. Then, by the
inductive hypothesis, we have that hiS2 , j1 +1 , j1 +1  i `    ` hfS2 , n , n  i is a
regular derivation of PS2 . By case seqt4 , then (7) is a regular derivation of PS .
(ii) By the inductive hypothesis, for each `1  [1..j1 ], we have that |`001 |  2  lv(S1 ). Since
lv(S1 ) < lv(S) and `1 = `001  iS2  fS , we also have that |`1 |  2  lv(S). Similarly, by
the inductive hypothesis, for each `2  [j1 + 1..n], we have that |`002 |  2  lv(S2 ). Since
lv(S2 ) < lv(S) and `2 = `002  fS , we also have that |`2 |  2  lv(S). Since 0 = , for
each i  [0..n + 1], we have that |i |  2  lv(S).
(iii) By the inductive hypothesis, we have that S1 =
 1 j1 and S2 =
 j1 +1  n . Given

that S =
 S1  S2 , that 1 = 0 , and that n+1 = n , we conclude that S =
 0  n+1 .
There are no other possibilities for the form of (7), so the claim of this lemma holds for
each derivation of that form.
We are finally ready to show that PDA PS satisfies properties (1) and (2).
Lemma 13. For each role S  R and each role chain , we have that
1.   L(PS ) implies   L(S), and
2. PS has stack bounded by 2  lv(S) + 1.
Proof. By the definition of PS , transitions resulting from case p in Definition 4 are the only
ones popping elements from the stack, and these never pop symbol ; hence, at each point
i in an accepting derivation of PS , the stack content i is of the form i := i0  . Then,
the two claims follow immediately from Lemma 12.
3.1.2 Completeness
We next prove that our encoding is also complete, thus proving Theorem 8.
Lemma 14. For each role S  R and each role chain , we have that   L(S) implies
  L(PS ).

669

fiStefanoni, Motik, Krotzsch, & Rudolph

Axiom Type
(t1)
vT
(t2)

(t3)

(t4)

(t5)

Derivation
i i `t1 hfT ,

00

hiT ,

 ,

T T vT

hiT ,
hiT ,

T  T  00 ,
T  00 ,

T1  T v T

hiT , T1  T  00 ,
hiT1 , T1  T  00 ,
hiT ,
T  00 ,

T1  T2 v T

hiT , T1  T2  00 ,
hiT1 , T1  T2  00 , iT2  fT
hiT2 ,
T2  00 ,
fT
00
hfT ,
 ,

T  T2 v T

hiT , T  T2  00 ,
hiT2 ,
T2  00 ,
hfT ,
00 ,

i i
i i

`r
`r

i i `t3
i T  i i ` r
i i `r
i i `t4
 i i ` r
 i i ` r
i i

i i `r
fT   i i ` r
i i

00 ,

i i

hfT , T  00 ,
hfT ,
00 ,

i i
i i

`t2

hfT1 , T  00 ,
hfT ,
00 ,

i T  i i
i i

`p

hfT1 , T2 00 , iT2  fT  i i `p
hfT2 ,
00 ,
fT   i i ` p
hfT , T2  00 ,
hfT2 ,
00 ,

i i `t5
fT   i i ` p

Table 4: Definition of derivation (9) depending on the form of axiom  v T .
Proof. Consider an arbitrary role S  R . In the following, for each role chain , we write
0
m
S =
  if  = S; furthermore, for each m  N+ , we write S =
  if role chains 1 , . . . , m
exist such that S =
 1 =
  =
 m and m = . By the definition of L(S), we have that
m
  L(S) if and only if a natural number m  N exists such that S =
 . By induction on
m
m  N, we next show that S =
  implies   L(PS ).
0

Base case. Let m = 0. Then, we have that S =
 S. We consider two cases depending
on the form of role S  R .
 S = >r . By case (ur) in Definition 4, we have that hi>r , >r , i `ur hf>r , , i.
 S  R \ {>r }. By case (r) in Definition 4, we have hiS , S, i `r hfS , , i.
In either case we have S  L(PS ), as required.
Inductive step. Consider an arbitrary m  N and assume that, for each role chain 0
m
such that S =
 0 , we have 0  L(PS ); we show that the same holds for m + 1. Then,
consider arbitrary role chains 1 , . . . , m+1 such that S =
 1 =
  =
 m =
 m+1 . By the
definition of relation =
, a role T  R and role chains 0 , , 00 exist such that role chain
m is of the form m := 0  T  00 , role chain m+1 is of the form m+1 := 0    00 , and
m
T =
 . Since S =
 0  T  00 , by the inductive hypothesis, we have 0  T  00  L(PS ), so a
sequence hs0 , 0 , 0 i `    ` hsn , n , n i of PS exists with s0 = iS and sn = fS ; furthermore,
0 =  and n = ; finally, 0 = 0  T  00 and n = . Then there exists an index
i  [0..n  1] such that i = T  00 and i+1 = 00 . Furthermore, for each j  [0..i], role chain


00
j is of the form j := 
j  T   for some role chain j  R . Next, consider the form of
xi in hsi , i , i i `xi hsi+1 , i+1 , i+1 i. By Definition 4, only transitions in cases (r) and (ur)
read symbols from the input, so xi  {r, ur}. We show that the lemma holds in each case.
670

fiThe Complexity of Answering CQs and GXQs over OWL 2 EL KBs

(Case 1) Consider the case in which xi = r . Then, we have si = iT and si+1 = fT ,
i = i+1 , and T  R \ {>r }. Due to T =
  and T 6= >r , we have  v T  R. Then, the
following is also a derivation of PS

00
00

hs0 , 
0     , 0 i `    ` hsi , i     , i i `

(8)



(9)

[The derivation from Table 4 for  v T ] `
00

hsi+1 ,  , i+1 i `    ` hsn , , n i

(10)

where the derivation in (9) is defined in Table 4 depending on the form of axiom  v T  R.
(Case 2) Consider the case in which xi = ur . Then, we have si = i>r and si+1 = f>r ,
i = i+1 and T  R . Then, the following is also a derivation of PS

00
00

hs0 , 
0     , 0 i `    ` hsi , i     , i i `
00

[The derivation seq(,  , i ) in (14)] `



00

hsi+1 ,  , i+1 i `    ` hsn , , n i
where the derivation seq(, 0 , i ) in (12) is inductively defined as follows.
(
hi>r , 00 , i i `u1 hf>r , 00 , i i
if  = ,
00
seq(,  , i ) :=
00
00
00
hi>r ,    , i i `ur hf>r ,    , i i `u2 seq(,  , i ) if  = P  .

(11)
(12)
(13)

(14)

Therefore, in either case, we have 0    00  L(PS ), as required.

4. A Polynomial Space BCQ Answering Algorithm for ELRO+
Each ELRO+ knowledge base K can be translated into a set of first-order Horn clauses, so
a Boolean CQ q over K can be answered by evaluating q over a so-called canonical model 
a model that can be homomorphically embedded into any other model of K. Canonical
models are usually obtained using chase. Many different chase variants have been studied
in the literature, each producing a different, but homomorphically equivalent, canonical
model (Johnson & Klug, 1984; Marnette, 2009; Cal, Gottlob, & Kifer, 2013; Baget, Leclere,
Mugnier, & Salvat, 2011). In this paper, we introduce a variant that we call consequencebased chase, and the (possibly infinite) set of assertions IK it produces on K we call the
universal interpretation of K. To compute IK , consequence-based chase initialises IK to
contain the ABox of K, as well as assertions {a}(a), >c (a), and >r (a, b) for all individuals a
and b occurring in K; then, it iteratively extends IK using chase rules. The slightly unusual
aspect of our chase variant is that it considers the axioms entailed by (and not only contained
in) K. For example, if IK at some point contains assertion A(w) and K |= A v S.B holds,
then IK is extended with assertions S(w, w0 ) and B(w0 ) where w0 is a fresh term; term w0 is
said to be auxiliary and have type S, B and concept type B. The BCQ answering algorithm
we present in this section is based on checking consequences of K, so our chase variant
makes our proofs simpler. Example 15 illustrates these aspects.
Example 15. Let K = hT , R, i be an ELRO+ KB, where T contains axioms (15)(21),
and R contains role inclusion (22).
{a} v S.A
671

(15)

fiStefanoni, Motik, Krotzsch, & Rudolph

a

b

S

S

1 S, A

2 S, A

a

S
T

3 T, B

R

S

b

6 S, B

S

S

S

4 S, C

oS,A

S

S

T

oT,B

oS,B

R
T

S

oS,C

T
S
S, A

S, A

5
T, B

Universal Interpretation

Compact Interpretation

Figure 4: The universal interpretation and the compact interpretation for K
A v S.A

(16)

{b} v S.A

(17)

{b} v T.B

(18)

{b} v S.C

(19)

C v T.B

(20)

C v R.{b}

(21)

ST vS

(22)

Figure 4 shows the universal interpretation IK of K. Assertions involving >c and >r are
not shown for clarity. The edges obtained via role inclusions are dashed; remaining edges
are solid, apart from the dotted edges, which denote repetition of solid edges. Black edges
are obtained using conventional chase variants, whereas the light grey subbranches of IK
are caused by axioms entailed by, but not occurring in, K. Auxiliary terms are labelled
using integers, and the terms type is shown next to each term. Universal interpretation IK
can be viewed as a family of directed trees whose roots are the individuals in K and where
solid edges point from parents to children or to the individuals in K. Axiom (16) makes IK
infinite, so a decision procedure for BCQ answering cannot simply materialise IK and then
evaluate the query in it; instead, a finitary representation of IK is needed.
By axioms (19), (20), and (22), we have K |= {b} v S.B; but then, since {b}(b)  IK ,
the consequence-based chase ensures that {S(b, 6), B(6)}  IK holds as well. In contrast,
commonly considered chase variants do not ensure {S(b, 6), B(6)}  IK because K does not
contain axiom {b} v S.B.
In the rest of this section, we present the first worst-case optimal algorithm that decides
K |= q given an arbitrary regular ELRO+ KB K and a Boolean CQ q over K. Towards this
goal, in Section 4.1 we review the existing approaches to answering CQs in DLs and discuss
672

fiThe Complexity of Answering CQs and GXQs over OWL 2 EL KBs

why these techniques do not provide an optimal procedure for ELRO+ ; in Section 4.2
we discuss the intuitions behind our algorithm; in Section 4.3 we introduce the algorithm
formally and show that it runs in polynomial space in the combined size of K and q and in
polynomial time in the size of K; and in Section 4.4 we prove the algorithms correctness.
4.1 Existing Approaches to Answering CQs
Techniques for answering conjunctive queries over DL knowledge bases developed thus far
can be broadly classified into the following three groups.
The first group consists of automata-based approaches for DLs such as Horn-SHIQ
and Horn-SROIQ (Ortiz et al., 2011), SH (Eiter, Ortiz, & Simkus, 2012a), and the fragment of ELRO+ obtained by disallowing the universal role, reflexive roles, and self restrictions (Krotzsch et al., 2007). All these techniques, however, require constructing automata
whose size can be exponential in the size of the knowledge base.
The second group consists of rewriting-based approaches. Roughly speaking, these approaches rewrite the query and/or the TBox into another formalism, usually a union of
CQs or a datalog program; the relevant answers can then be obtained by evaluating the
rewriting over the ABox. Rewriting-based approaches have been proposed for members
of the DL-Lite family (Artale et al., 2009; Calvanese et al., 2007), the DLs EL (Rosati,
2007), ELHIO (Perez-Urbina et al., 2010; Mora, Rosati, & Corcho, 2014) and HornSHIQ (Eiter, Ortiz, Simkus, Tran, & Xiao, 2012b), and members of the datalog family (Virgilio, Orsi, Tanca, & Torlone, 2012), to name just a few. No rewriting approach,
however, supports for both nominals and role inclusions. Moreover, a common shortcoming
is that rewritings can be exponential in the query and/or TBox size, so these approaches
may also use exponential space.
The third group consists of approaches based on a particular interpretation of K that
we call the compact interpretation. Figure 4 shows this interpretation for the KB K from
Example 15: it finitely approximates the universal interpretation by using individuals of the
form oS,B to represent all auxiliary terms of type S, B. The compact interpretation can thus
be materialised in space polynomial in |K|, and it can be used to answer instance queries
and test atomic subsumptions over K (Baader et al., 2005; Krotzsch, 2011). Materialising
the compact interpretation lies at the core of many reasoning algorithms for EL variants, so
it is natural to try to use this interpretation for answering CQs as well. Since the compact
interpretation is a model of K, each CQ that maps on the universal interpretation maps on
the compact interpretation as well; however, as Example 16 shows, the converse does not
necessarily hold.
Example 16. Let K be as in Example 15, and let q1 , q2 , and q3 be the following BCQs.
q1 = x. R(x, b)

q2 = x. S(a, x)  S(b, x)

q3 = x. T (b, x)  S(b, x)

The compact interpretation for K is shown in Figure 4; as one can see, it is obtained from
the universal interpretation by merging all terms of type S, B onto the individual oS,B . Now
query q1 can be mapped onto both the compact and the universal interpretation, while queries
q2 and q3 can be mapped only onto the compact interpretation. Thus, evaluating q2 and q3
over the compact interpretation produces unsound answers.
673

fiStefanoni, Motik, Krotzsch, & Rudolph

a

b

{a} a

b {b}

Ax

y B

R
R,D 1

S

T,B
3

S
S

S,B 5
S

R

T

T

T R,A
2

T
T

S

4 T,B

T

T

T
T,B
6

P
S
S

S

T,B

T

7

S
8 S,B

S

S

P,B 9

S
S

T

T,B 10

Universal Interpretation

S
11 S,B

S

z B

Skeleton for q

Figure 5: The universal interpretation of K and the skeleton for q
As a remedy, combined approaches were developed that first evaluate the query in the
compact interpretation and then filter the results to eliminate unsound answers. Such
approaches have been developed for members of the DL-Lite family (Kontchakov et al.,
2011; Lutz, Seylan, Toman, & Wolter, 2013) and the EL family (Lutz, Toman, & Wolter,
2009; Stefanoni et al., 2013) of DLs, and the datalog family (Gottlob, Manna, & Pieris,
2014) of rule-based languages. In particular, Stefanoni et al. (2013) developed a filtering
step applicable to the DL ELHOdr
 , but this step breaks down if K contains role inclusions.
Query q3 from Example 16 can be mapped onto the compact interpretation by mapping
atom S(b, x) to a dashed edge (i.e., to an edge obtained via role inclusions); moreover, q3
is tree-shaped, and so the filtering step by Stefanoni et al. (2013) does not identify this
match as unsound. This problem can be intuitively understood as follows. By unfolding
the query by (22), query q3 essentially asks whether role chains 1  L(S) and 2  L(T )
exist that label a path of solid edges in IK starting at b. In the compact interpretation,
this is satisfied by 1 = S  T and 2 = T when x is mapped to individual oT,B . Individual
oT,B , however, represents distinct terms 3 and 5 from IK ; hence, although 3 is connected
to b via 1 and 5 is connected to b via 2 , role chains 1 and 2 do not satisfy query q3 . In
other words, the compact interpretation is too small to represent the relevant conditions.
4.2 Intuitions
Our worst-case optimal procedure for BCQ answering in ELRO+ is shown in Algorithm 1
on page 681. It essentially extends and refines the algorithm by Krotzsch et al. (2007). We
explain the underlying intuitions using the knowledge base shown in Example 17.
Example 17. Let K be the ELRO+ knowledge base whose TBox contains axioms (23)(29)
and whose RBox contains role inclusions (30)(31).
{a} v R.A
A v T.{b}
674

(23)
(24)

fiThe Complexity of Answering CQs and GXQs over OWL 2 EL KBs

iS

S, X/X

fS

, X/fS  X

iT

T, X/X

fT

, X/X

Figure 6: The transitions of R corresponding to axioms (30)(31)
AvD

(25)

{b} v T.B

(26)

{b} v P.B

(27)

B v S.Self

(28)

B v T.B

(29)

T T vT

(30)

ST vS

(31)

Moreover, let q be the following Boolean CQ over K.
q = x, y, z. D(x)  T (x, z)  S(y, z)

(32)

Figure 5 shows the universal interpretation IK for K; notation is as in Example 15. The
solid looping edges on auxiliary terms of concept type B are obtained from axiom (28). One
can see that K |= q holds; for example, the following substitution  embeds q into IK .
 = {x 7 2, y 7 6, z 7 7}

(33)

Our algorithm uses the PDA encoding of the RBox described in Section 3. The transition
function R for axioms (30)(31) is shown in Figure 6; notation is the same as in Example 6;
and note that Figure 6 is contained in Figure 3.
We must prove the existence of a substitution  mapping q into IK . Such a substitution
 can map the binary atoms in q to the dashed edges in Figure 5. Dashed edges introduce
shortcuts between terms in IK , but each dashed edge can be unfolded into a path consisting
only of solid edges using the role inclusions in K. The solid paths in IK can be of two
types: auxiliary paths involve only auxiliary terms, whereas nominal paths require moving
through at least one individual. For instance, edge T (2, 7) can be unfolded into the path
T = T  T  T connecting 2 with b, b with 6, and 6 with 7. In contrast, edge S(6, 7) can
be unfolded into the path S = S  T connecting 6 with itself, and 6 with 7. Our algorithm
then uses PDAs with transition function from Figure 6 to represent each binary atom in
q as a sequence of binary atoms to be mapped over the corresponding solid path in IK .
Interpretation IK , however, is infinite, so the space of possible substitutions is also infinite.
Hence, to prove the existence of a substitution  mapping q into IK , we cannot simply
enumerate all of them, and we use Algorithm 1 instead.
675

fiStefanoni, Motik, Krotzsch, & Rudolph

In line 1 we check whether K is unsatisfiable; if so, then K |= q holds trivially. Next,
in line 2 we guess a substitution  and continue checking K |= (q); thus, this step takes
into account that variables could be mapped to individuals, and that two variables could be
mapped to the same term. In our example, we can guess  to be the identity mapping on
~y . In step 3, we then guess a finite structure, called the skeleton for (q), which represents
a (possibly infinite) set of substitutions mapping the variables of (q) to distinct auxiliary
terms in IK . Figure 5 shows the skeleton S for the query in Example 17: skeleton vertices
are the individuals of K and the variables of (q), and they are arranged as a forest whose
roots are the individuals; moreover, each vertex v of S is assigned an atomic concept (v).
After this step, skeleton S represents each substitution  (if any) satisfying the following
two properties:
1.  maps each variable x to a term of concept type (x), and
2. for each edge hv, v 0 i in S, we have that  (v 0 ) is a descendant of  (v) in IK .
We next extend S with conditions that prune this set of substitutions, with the goal of
leaving only substitutions compatible with (q)that is, that embed (q) into IK .
We establish compatibility with the unary atoms of (q) in line 4. In particular, consider
atom D(x) in (q). By property (1), each substitution  represented by the skeleton in
Figure 5 maps variable x to a term of concept type (x) = A, implying that A( (x))  IK
holds. But then, since K |= (x) v D holds, we know that D( (x))  IK holds as well; thus,
atom D(x) is satisfied for each substitution represented by S.
In contrast, we cannot establish compatibility of binary query atoms using entailment
checking only, because vertex labels and the relative position of vertices do not sufficiently
describe the substitutions. For example, substitution
1 = {x 7 2, y 7 9, z 7 10}

(34)

satisfies properties (1) and (2), but T (1 (x), 1 (z)) 6 IK .
To prune such substitutions, in lines 516 of Algorithm 1 we guess for each binary atom
in (q) how to unfold it as a sequence of solid steps in IK . As solid paths in IK can go
through nominals or through auxiliary terms only, the two possibilities are accounted for
by the guessing in line 8. Moreover, the skeleton already constrains the relative positions of
query terms, so we represent the unfolding of each binary atom by labelling each edge hv, v 0 i
in S with a set L(v, v 0 ) of bounded-stack PDAs with transition function from Figure 6 so
that each substitution  represented by S also satisfies the following property:
3. for each PDA P  L(v, v 0 ), a nonempty role chain   L(P) exists labelling a path in
IK over solid edges from  (v) to  (v 0 ).
We next illustrate how to label the edges of S so that all substitutions satisfying properties
(1)(3) are compatible with each binary atom of (q).
For T (x, z), we must ensure that, for each substitution  represented by S, a role chain
T  L(T ) exists connecting  (x) to  (z) using only solid edges. Since the relative positions
of  (x) and  (z) in IK is determined by S as shown in Figure 5, such a path must connect
 (x) with b, then connect b with  (y), and finally connect  (y) with  (z). In addition, we
can assume that no individuals occur on paths from b to  (y), and from  (y) to  (z): if a
676

fiThe Complexity of Answering CQs and GXQs over OWL 2 EL KBs

>r

D
R

{a}

R

B
T

A

S, T

T, P
T

{b}

start

B

S

start

Figure 7: On the left-hand side, the walking finite automaton wfa(A, {b}) (transitions involving >c and >r are not shown for clarity); on the right-hand side, the stationary finite automaton sfa(B)

path from  (x) to  (z) involves individuals other than b or if it visits b more than once, we
can absorb all such path segments into the subpath from  (x) to b. Thus, we check the
existence of such T by setting v0 = au = b in lines 78 (no guessing is possible in line 8 in
this case) and splitting in lines 711 the path T into the three subpaths. In particular,
in line 10 we guess states s0 , s1 , and s2 = fT and in line 11 we guess stack words 0 , 1 ,
and 2 =  with the following properties:
(i) the subpaths from  (x) to b are described by PDA PT0 whose start state and stack are
iT and , respectively, and the final state and stack are s0 and 0 , respectively;
(ii) the subpaths from b to  (y) are described by PDA PT1 whose start state and stack are
s0 and 0 , respectively, and the final state and stack are s1 and 1 , respectively; and
(iii) the subpaths from  (y) to  (z) are described by PDA PT2 whose start state and stack
are s1 and 1 , respectively, and the final state and stack are s2 and 2 , respectively.
We do not know what terms of IK variables y and z should be mapped to, so we cannot
check the existence of paths in (ii) and (iii) independently. Therefore, we add in line 12
PDAs PT1 and PT2 as constraints on edges hb, yi and hy, zi in S, respectively. The edges
of S thus accumulate all constraints that the moves to auxiliary terms must satisfy; later
we shall explain how in lines 1718 we check these constraints and, if this check passes,
how we know that we can map y and z to auxiliary terms whose concept types are (y)
and (z), respectively. In contrast, the path in (i) finishes in an individual, so we can
check existence of such a path independently from any other constraint. To this end, we
construct the walking finite automaton wfa(A, {b}) shown on the left-hand side of Figure
7. Such wfa(A, {b}) describes the moves in IK from terms with concept type (x) = A to
individual bthat is, such that   L(wfa(A, {b})) for each term w with concept type A
and for each role chain  connecting w to b in IK via solid edges; then, in line 14 we check
whether the intersection of the languages of wfa(A, {b}) and PT0 is empty. As wfa(A, {b})
is a FA and PT0 is a PDA, we can test the emptiness of the intersection of their languages in
polynomial time (Hopcroft et al., 2003). In our example, we can guess s0 = s1 = s2 = fT .
677

fiStefanoni, Motik, Krotzsch, & Rudolph

Thus, PT1 accepts the language T  , and because b is connected to 1 (y) by a solid edge
labelled by P , adding PT1 as constraint on edge hb, yi ensures that substitution 1 from (34)
does not satisfy property (3).
For S(y, z), we must ensure that, for each substitution  represented by S, a role chain
S  L(S) exists connecting  (y) to  (z) using only solid edges. Now even though z is a
descendant of y in S, in line 8 we could guess v0 = au = b, so that S connects  (y) with b
and then, without going through individuals, connects b with  (z) via  (y). In the rest of
this paragraph, however, we consider the case in which S connects  (y) with  (z) directly,
since that is the only possibility in our example, as one can see in Figure 5. Therefore, in
line 8, we guess v0 = t = y. But then, a path from  (y) to  (z) could first loop on  (y)
due to self-restrictions; then it must actually move from  (y) to  (z); and finally it could
loop on  (z). For reasons we discuss in the following paragraph, we absorb the latter loop
into a constraint added to edge hy, zi; however, we check the existence of the former loop
independently. Therefore, in lines 711 we split S into two subpaths. In particular, in
line 10 we guess states s0 and s1 = fS , and in line 11 we guess stack words 0 and 1 = 
with the following properties:
(i) the looping on  (y) is described by PDA PS0 whose start state and stack are iS and
, respectively, and the final state and stack are s0 and 0 , respectively; and
(ii) the subpaths from  (y) to  (z) that start with a move from  (y), but possibly involve
looping on  (z), are described by PDA PS1 whose start state and stack are s0 and 0 ,
respectively, and the final state and stack are s1 and 1 , respectively.
As in the previous case, we check (ii) by adding PS1 as constraint on edge hy, zi in S.
Furthermore, we check the existence of a path in (i) by constructing the stationary finite
automaton sfa(B) shown on the right-hand side of Figure 7. Such sfa(B) describes the
possible loops on terms with concept type (y) = B; that is, such that   L(sfa(B)) for
each term w with concept type B and for each role chain  corresponding to a (possibly
empty) loop on w; then, in line 16 we check whether the intersection of the languages
of sfa(B) and PS0 is empty. In our example, we guess s0 = s1 = fS ; thus PS0 accepts the
language S  T  , whereas PS1 accepts the language T  .
Before line 17, skeleton S represents all substitutions that are compatible with the
atoms in (q), but we must still show that at least one such substitution can be realised
by the universal interpretation IK . To this end, we apply Algorithm 2 on page 681 to each
edge hv, v 0 i in the skeleton, and thus we check whether terms  (v) and  (v 0 ) in IK exist
that satisfy properties (1)(3) for all PDAs in L(v, v 0 ). Roughly speaking, we solve this
problem by running all PDAs in parallel in lines 715 of Algorithm 2. However, we cannot
materialise IK , so we exploit a property of our consequence-based chase procedure: a term
w with concept type A is connected to a term w0 with concept type B in IK using a solid
edge labelled by S if and only if K |= A v S.B. Furthermore, the concept type of w fully
describes the solid paths to descendants of w, so we do not need to keep track of the actual
position in IK ; instead, we use variable concept to keep track of the current terms concept
type. Thus, in line 9 we check existence of edges in IK via entailment checking; after that,
for each PDA, in line 11 we guess a state s and a stack  of the PDA, in line 12 we check
whether the PDA can perform the move, and in line 14 we actually move the PDA. Due to
678

fiThe Complexity of Answering CQs and GXQs over OWL 2 EL KBs

self-restrictions and reflexive roles, however, the PDAs need not move in synchrony: after
each move over a solid edge, each of the PDAs can independently loop on the current term.
To this end, in line 11 we guess a state s0 and a stack  0 that the PDA moves into after
looping, and in line 13 we check whether the PDA can move from state s with stack  to
state s0 with stack  0 using a role chain compatible with the concept type of the term the
PDA is moving into, as given by the stationary finite automaton sfa(D). Because not all
PDAs are required to loop, FA sfa(D) accepts the empty word. Algorithm 2 thus checks
loops only after each move, which is why line 16 in Algorithm 1 is necessary. Lines 25
take into account that each of the PDAs is nondeterministic and so it can initially make
several -transitions; note that an explicit check for -transitions is required only initially
since line 13 allows for possible -transitions after each move along a solid edge. Finally, we
ensure termination of Algorithm 2 by observing that, since the stack of each PDA in L(v, v 0 )
is bounded, the number of current configurations of each of the PDA is exponential, and
so the number of distinct tuples of the current PDA configurations is exponential as well;
hence, the algorithm repeats computations after at most exponentially many steps. We
thus obtain a nondeterministic decision procedure running in polynomial space by using a
binary counter to stop the computation after all distinct configurations have been explored.
For the constraints added to S in the previous paragraphs, one can check that Algorithm 2
returns true on all edges of S; hence, K |= (q) holds, and thus K |= q holds as well.
4.3 Formalisation
We now formalise the intuitions from the previous section. Towards this goal, we fix a
normalised ELRO+ KB K = hT , R, Ai with a regular RBox R, we let QR , R , and R be
as specified in Definition 4, and we let dR be the depth of R as specified in Section 3. We
start by formalising the notion of a skeleton of a Boolean CQ.
Definition 18. A skeleton for a Boolean CQ q = ~y . (~y ) is a triple S = hV, E, i with
the following components.
1. V = IK  ~y is the set of vertices.
2. E  V  ~y is the set of edges such that the directed graph hV, Ei is a forest whose
roots are precisely the elements of IK .
3.  : ~y 7 {>c }  CK is a function that maps the existential variables of q to atomic
concepts. For convenience,  is extended to V by (v) := {v} for each v  IK .
A path in S is a nonempty sequence of (distinct) vertices v0 , . . . , vn such that n  0 and,
for each i  [0..n  1], we have that hvi , vi+1 i  E.
Please observe that, as K is in normal form, there exists at least one individual occurring
in K and thus V  I 6= . We next generalise the notion of a PDA encoding the RBox R
from Definition 4 by allowing arbitrary start and final states as well as arbitrary start and
final stacks of size at most dR . These generalised PDA will be used in our algorithm to
implement the splitting operation mentioned in Section 4.2.
Definition 19. For states s, s0  QR and words ,  0  R with ||  dR and | 0 |  dR , a
generalised PDA for R is given by pda(s, , s0 ,  0 ) := hQR , R , R , R , s, , s0 ,  0 i.
679

fiStefanoni, Motik, Krotzsch, & Rudolph

The following definition introduces automata that one can use to succinctly represent
the axioms that logically follow from K.
Definition 20. Let A and B be basic concepts. The walking finite automaton from A to
B is given by wfa(A, B) := hQ, R , w , A, Bi where Q and w are as follows.
 Q = {>c }  CK  NK .
 w is the transition function containing D  w (C, S) for each role S  R and all
states C and D in Q such that K |= C v S.D.
The stationary finite automaton for A is given by sfa(A) := h{A}, R , s , A, Ai where s
contains A  s (A, S) for each role S  R with K |= A v S.Self or K |=  v S.
Boolean CQs can be answered by the nondeterministic procedure entails shown in Algorithm 1, which uses an auxiliary procedure exist shown in Algorithm 2. The following
theorem states that entails(K, q) decides K |= q, and its proof is given in Section 4.4.
Theorem 21. Let q be a Boolean CQ over K. Then, K |= q if and only if a nondeterministic
computation exists such that entails(K, q) returns true.
Finally, we determine the complexity of the algorithm entails, and towards this goal we
first determine the complexity of the auxiliary function exist.
Lemma 22. Function exist(A, B, {Pj = pda(sj , j , s0j , j0 ) | 0  j  m}) can be implemented so that it uses space polynomial in m  |K| and, if the RBox R is fixed, it runs in
time polynomial in |T | + |A|.
Proof. Consider arbitrary A, B, and Pj = pda(sj , j , s0j , j0 ) as stated above; let M be as
in Algorithm 2; and let ` be the derivation relation corresponding to R . By the definition
of generalised PDAs, we have |j |  dR and |j0 |  dR for each j  [1..m].
By Proposition 2, using polynomial time one can compute PDAs accepting languages
LdR (pda(sj , j , s, )) and LdR (pda(s, , s0 ,  0 )) in lines 4 and 13; therefore, checks in lines
4 and 13 can be implemented so that they use time (and therefore space) polynomial in
|K| (Hopcroft et al., 2003, ch. 7).
For the space usage of Algorithm 2, please observe that the function stores the following
information at each computation step:
(a) an array state of length m such that state[j]  QR for each j  [1..m], an array stack of
length m such that stack[j]  R and |stack[j]|  dR for each j  [1..m],
(b) a generalised PDA in line 4,
(c) a generalised PDA and a stationary automaton in line 14,
(d) a concept concept  {A, >c }  CK in line 1,
(e) a binary counter k such that 1  k  M , and
(f) the depth dR of R, an atomic concept D  {>c }  CK , and a role S  R .
680

fiThe Complexity of Answering CQs and GXQs over OWL 2 EL KBs

Algorithm 1: entails(K, q)
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19

if K is inconsistent then return true
guess a substitution  with dom() = ~y and rng()  ~y  IK
guess a skeleton S = hV, E, i for (q)
if an atom A(t) in (q) exists such that K 6|= (t) v A then return false
foreach hv, v 0 i  E do let L(v, v 0 ) := 
foreach binary atom S(t, u) in (q) do
let au be the unique individual such that u is reachable from au in S
guess v0  {t, au } such that u is reachable from v0 in S
let v0 , . . . , vn be the unique path in S such that vn = u
guess states s0 , . . . , sn in QR such that sn = fS
guess words 0 , . . . .n in R such that n =  and |i |  dR for each i  [0..n]
foreach i  [1..n] do let L(vi1 , vi ) := L(vi1 , vi )  {pda(si1 , i1 , si , i )}
if v0  I then
if L(wfa((t), (v0 )))  L(pda(iS , , s0 , 0 )) =  then return false
else
if L(sfa((v0 )))  L(pda(iS , , s0 , 0 )) =  then return false
foreach hv, v 0 i  E do
if not exist((v), (v 0 ), L(v, v 0 )) then return false
return true

Algorithm 2: exist(A, B, {Pj = pda(sj , j , s0j , j0 ) | 0  j  m})
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19

let concept := A and let M := (1 + |CK |)  |QR |m  (|R |1+dR )m
for j = 1 to m do
guess a state s  QR and a word   R such that ||  dR
if  6 LdR (pda(sj , j , s, )) then return false
set state[j] := s and stack[j] := 
guess k  N such that 1  k  M
for r = 1 to k do
guess S  R and D  {>c }  CK
if K 6|= concept v S.D, or K |= D v {a} for some a  IK then return false
for j = 1 to m do
guess {s, s0 }  QR and {,  0 }  R with ||  dR and | 0 |  dR
if hstate[j], S, stack[j]i 6` hs, , i then return false
if L(sfa(D))  LdR (pda(s, , s0 ,  0 )) =  then return false
set state[j] := s0 and stack[j] :=  0
set concept := D
if concept 6= B then return false
if there exists an index j  [1..m] such that state[j] 6= s0j or stack[j] 6= j0 then
return false
return true

681

fiStefanoni, Motik, Krotzsch, & Rudolph

By the definition of dR , we have that dR is linearly bounded by the number of axioms occurring in R; hence, we need at most O(m  |R|) space to store the two arrays. Furthermore, we
need at most O(m  |K|) space to store the counter k using binary encoding. By Definition
20, the size of sfa(D) is polynomial in |K|; by Definition 4, the size of pda(s, , s0 ,  0 ) is polynomial in |R|. Overall, the space needed to store the required information is polynomial in
m  |K|. Finally, following Krotzsch (2011), we can realise the check in step 9 in polynomial
time. Thus, exist can be implemented so that it uses space polynomial in m  |K|.
Next, assume that the RBox R is fixed. Then dR , QR , R , and R are all fixed as
well; moreover, m is bounded by the size of R and so it is fixed, and M is linear in the
size of T and A. Thus, the number of alternatives in the nondeterministic step in line 3
of Algorithm 2 is fixed, so lines 15 require time polynomial in |T | + |A|. Furthermore,
instead of guessing k using the nondeterministic step 6, we can repeat lines 715 for each
k  [1..M ], which requires a linear number of iterations. To show that lines 715 can also
be implemented to run in polynomial time, we first define three sets which can be used to
perform the checks in lines 9, 12, and 13.
{hS, C, Di  R  (CK  NK  {>c })2 | K |= C v S.D and a  IK : K 6|= D v {a}} (35)
{hS, pda(s, , s0 ,  0 )i | for S  R with hs, S, i ` hs0 , ,  0 i} (36)
{hC, pda(s, , s0 ,  0 )i | for C  CK  {>c } with L(sfa(C))  LdR (pda(s, , s0 ,  0 )) 6= } (37)
Given that R is fixed, these sets can be computed in time polynomial in the size of T and
A. We next show that we can implement the for-loop in steps 715 to use space logarithmic
in the size of T , A, and of the sets in equations (35)(37). For the space usage in lines 715,
at each computation step of the for-loop we store the information from points (a)(f) above.
Since R and m are fixed, however, points (a)(c) require constant space. Furthermore, the
checks in lines 9, 12, and 13 can be performed by a lookup in sets (35)(37); by storing
these sets using a suitable binary encoding and by using a binary index into the sets, this
check can be implemented using logarithmic space. Finally, as CK and M are linear in the
size of T and A, we can store counter k, concepts D and concept, and role S using a binary
encoding, so the overall space the function needs to store is logarithmic in |T | + |A|, and the
size of the sets (35)(37). Thus, steps 715 require nondeterministic logarithmic space, and
it is well known that this implies that steps 715 can be implemented to run in polynomial
time. Finally, steps 1619 clearly require polynomial time. Consequently, function exist can
be implemented so that it runs in time polynomial in |T | + |A| for fixed R.
We are now ready to establish the complexity of function entails(K, q); in Section 5 we
shall show that our function is worst-case optimal in combined and data complexities.
Theorem 23. For q a BCQ over K, function entails(K, q) can be implemented so that
1. it uses space polynomial in the input size,
2. if the RBox R is fixed, it runs in nondeterministic polynomial time in the size of the
TBox T , the ABox A, and the query q, and
3. if the RBox R and the query q are fixed, it runs in (deterministic) polynomial time in
the size of the TBox T and the ABox A.
682

fiThe Complexity of Answering CQs and GXQs over OWL 2 EL KBs

Proof. Let q = ~y .(~y ) be a Boolean CQ over K.
As shown in Proposition 2, one can compute in lines 14 and 16 a PDA accepting language
LdR (pda(iS , , s0 , 0 )) in polynomial time, so the checks in lines 14 and 16 require time
(and therefore space) polynomial in |K| (Hopcroft et al., 2003, ch. 7). Moreover, the checks
in lines 1 and 4 also require time polynomial in |K| (Krotzsch, 2011).
For (1), please observe that the function entails as specified in Algorithm 1 stores the
following information at each computation step:
 a substitution  with dom() = ~y and rng()  ~y  IK ;
 a skeleton S = hV, E, i for (q);
 a path v0 , . . . , vn in S, a sequence of states s0 , . . . , sn in QR , and a sequence of words
0 , . . . , n in R such that |i |  dR for each i  [0..n];
 a function L mapping each edge hv, v 0 i  E to a set of generalised PDA; and,
 a walking automaton wfa((t), (v0 )) and a stationary automaton sfa((v0 )).
By the definition of skeleton for (q), we need space polynomial in the size q and K to
store S. Moreover, the length of the longest path in S is given by the number of variables
occurring in (q), so we can store the sequences of vertices, states, and words in space
polynomial in |q| and |K| as well. Also, each set L(v, v 0 ) contains at most m PDAs, where
m is the number of binary atoms occurring in (q). Then, by Lemma 22, entails can be
implemented so that it uses space polynomial in the input size.
For (2), assume that the RBox R is fixed. By Lemma 22, for a fixed RBox R, step 18
can be implemented so that it runs in time polynomial in |T | + |A|. Clearly, all other steps
in Algorithm 1 can be implemented to run in nondeterministic polynomial time in the size
of TBox T , ABox A, and query q. Consequently, for a fixed RBox R, function entails can
be implemented so that it runs in nondeterministic polynomial time in in the size of TBox
T , ABox A, and query q.
For (3), assume that the RBox R and the query q are fixed. Then dR , QR , R , and R
are all fixed as well. Given that the number of variables occurring in q is fixed, the number
of guessing steps required in steps 2 and 3 is fixed; also, the number of alternatives for these
steps is linear in |T | + |A|. Thus, steps 2 and 3 require polynomial time. Furthermore, the
maximum number of iterations of the for-loop in steps 616 is fixed and the length of the
longest path in S is fixed. Thus, the number of guessing steps in lines 11 and 12 is also
fixed. In addition, the number of alternatives for the guessing steps in lines 8, 11, and 12
is fixed as well. Therefore, steps 616 require time polynomial in |T | + |A|. Finally, since
the query is fixed, the maximum number of iterations of the for-loop in steps 17 and 18
is also fixed and so, by Lemma 22, steps 17 and 18 require time polynomial in T and A.
Therefore, entails can be implemented so that it runs in time polynomial in |T | + |A| for
fixed R and q.

683

fiStefanoni, Motik, Krotzsch, & Rudolph

4.4 Proof of Theorem 21
We now prove that our function entails(K, q) indeed decides K |= q. Towards this goal, we
start by proving the correctness of function exist, after which we introduce the universal
interpretation of K, and, finally, we show that entails is sound and complete.
4.4.1 Correctness of exist
The following proposition proves the correctness of function exist from Algorithm 2.
Lemma 24. Function exist(A, B, {Pj = pda(sj , j , s0j , j0 ) | 0  j  m}) returns true if
and only if there exist a natural number k  1, roles S1 , . . . , Sk , basic concepts A0 , . . . , Ak
with A0 = A and Ak = B, and role chains {j,i | j  [1..m] and i  [1..k]} such that the
following conditions hold for each i  [1..k] and each j  [1..m].
1. For each a  IK , we have K |= Ai1 v Si .Ai and K 6|= Ai v {a}.
2. For each role T occurring in j,i , we have K |= Ai v T.Self or K |=  v T .
3. S1  j,1    Sk  j,k  LdR (Pj ).
Proof. Consider arbitrary A, B, and Pj = pda(sj , j , s0j , j0 ) as stated in the lemma. Moreover, let ` be the derivation relation corresponding to R .
() Assume that there is a nondeterministic computation of exist such that the function
returns true. Let k  N be as guessed in step 6; we show that the for-loop in steps 715
satisfies the following invariant: after each iteration r, there exist roles S1 , . . . , Sr , basic
concepts A0 , . . . , Ar , and, for each j  [1..m], role chains j,1 , . . . , j,r such that A0 = A,
Ar = concept, and the following holds for each i  [1..r] and j  [1..m].
(i) K |= Ai1 v Si .Ai and, for each a  IK , we have K 6|= Ai v {a}.
(ii) For each role T occurring in j,i , we have K |= Ai v T.Self or K |=  v T .
(iii) S1  j,1    Sr  j,r  LdR (pda(sj , j , state[j], stack[j])).
Base case. Before the first iteration of the loop (i.e., after steps 15 and for r = 0),
we have concept = A, and   LdR (pda(sj , j , state[j], stack[j]) for each j  [1..m], so
properties (i)(iii) clearly hold.
Inductive step. Consider an arbitrary iteration r  [1..k  1] and assume that properties
(i)(iii) hold at the end of iteration r; we show that the same is true after iteration r + 1.
By the inductive hypothesis, there exist roles S1 , . . . , Sr , basic concepts A0 , . . . , Ar , and, for
each j  [1..m], role chains j,1 , . . . , j,r such that A0 = A, Ar = concept and properties
(i)(iii) hold. Let role Sr+1 = S and atomic concept Ar+1 = D be as guessed in step 8.
Clearly, we have K |= concept v Sr+1 .Ar+1 and that K 6|= Ar+1 v {a} for each a  IK , as
required for property (i). Furthermore, consider an arbitrary j  [1..m], let s, s0 , , and
 0 be as guessed in step 11, and let state[j] and stack[j] be as at the end of iteration r;
then, hstate[j], Sr+1 , stack[j]i ` hs, , i due to step 12; furthermore, due to step 13, a role
chain j,r+1 exists such that j,r+1  L(sfa(D))  LdR (pda(s, , s0 ,  0 )). By Definition 20
of stationary automata, for each role T occurring in j,r+1 we have K |= D v T.Self or
684

fiThe Complexity of Answering CQs and GXQs over OWL 2 EL KBs

K |=  v T , as required for property (ii). Finally, let state[j] and stack[j] be as specified
in step 14; then S1  j,1    Sr  j,r  Sr+1  j,r+1  LdR (pda(sj , j , state[j], stack[j])), so
property (iii) holds.
Step 16 ensures that concept = B; furthermore, steps 1718 ensure that state[j] = s0j and
stack[j] = j0 for each j  [1..m], so PDA Pj accepts S1  j,1    Sk  j,k . Thus, properties
(1)(3) of this lemma hold, as required.
() Let S1 , . . . , Sn be roles, let A0 , . . . , An be basic concepts with A0 = A and An = B,
and let j,i be role chains satisfying properties (1)(3) of this lemma. Each derivation for
S1  j,1    Sn  j,n of PDA Pj is of the following form, where sj,n+1 = s0j and j,n+1 = j0 :
hsj , S1  j,1    Sn  j,n , j i `
hs0j,1 ,

hsj,1 , S1  j,1    Sn  j,n , j,1 i `

j,1  S2    Sn  j,n ,

hsj,2 , S2  j,2    Sn  j,n , j,2 i `

0
j,1
i

(39)



(40)



(41)

. . . `

(42)

`

... `
hs0j,i ,

hsj,i , Si  j,i    Sn  j,n , j,i i `

j,i  Si+1    Sn  j,n ,

hsj,i+1 , Si+1  j,i    Sn  j,n , j,i+1 i `
hs0j,n ,

hsj,n , Sn  j,n , j,n i `
hsj,n+1 , , j,n+1 i

j,n ,

(38)



0
j,i
i
0
j,n
i

`



`

(43)
(44)

Transition from (38) to (39) is special in the sense that it allows Pj to make an arbitrary
number of -transitions; the rest of the derivation is regular and consists of reading Si and
j,i . Thus, sj,i and s0j,i are the states of Pj before and after, respectively, reading Si , and
0 are the respective stacks. By property (3) of this lemma, we have | |  d
j,i and j,i
j,i
R
0
and |j,i |  dR .
Let Xi = hAi , s1,i , 1,i , . . . , sm,i , m,i i. For each PDA, there are |QR | many different
P R
|R |` many difstates, 1+|CK | different elements in {>c }CK ; furthermore, there are d`=0
PdR
ferent stacks of length at most dR . As |R | > 0 and dR > 0, we have `=0 |R |`  |R |1+dR ;
consequently, there are at most M distinct such tuples. Thus, for some k  M , we have that
Xk = Xn+1 . But then, Ak = B; furthermore, for each j  [1..m], we have sj,k = sj,n+1 = s0j
and j,k = j,n+1 = j0 , so we have S1  j,1    Sk  j,k  LdR (Pj ).
We can now easily construct a nondeterministic computation of exist as follows. In
step 3, for each j we let s = sj,1 and  = j,1 ; clearly, condition in step 4 is not satisfied.
For each r in the for-loop in lines 715, we proceed as follows.
 In step 8 we let S = Si and D = Ai , respectively; clearly, condition in step 9 is not
satisfied due to property (1).
0 , and  0 = 
 For each j  [1..m], we let s = s0j,r , s0 = sj,r+1 ,  = j,r
j,r+1 ; clearly,
condition in step 12 is not satisfied due to the form of the derivation; furthermore,
condition in step 13 is not satisfied due to property (2) and Definition 20.

Finally, conditions in steps 16 and 17 are not satisfied due to the way in which we chose k.
Therefore, function exist returns true in step 19.

685

fiStefanoni, Motik, Krotzsch, & Rudolph

Rule
(cr1)
(cr2)

(cr3)

(cr4)
(cr5)

(cr6)

(cr7)

Precondition
K |= A1 u A2 v B
{A1 (w), A2 (w)}  I
K |= A v S.B
K |= B v {a} for some a  IK
A(w)  I
K |= A v S.B
K 6|= B v {a} for each a  IK
A(w)  I
K |= S.A v B
{S(w, w0 ), A(w0 )}  I
K |= S.Self v B
S(w, w)  I
role S is simple
K |= A v S.Self
A(w)  I
role S is simple
  L(S)
(w, w0 )  I

Conclusion
B(w)
S(w, a), B(a)

S(w, fS,B (w)), B(fS,B (w))
>c (fS,B (w)), >r (fS,B (w), fS,B (w))
>r (fS,B (w), w0 ) for each term w0 occurring in I
>r (w0 , fS,B (w)) for each term w0 occurring in I
B(w)
B(w)

S(w, w)

S(w, w0 )

Table 5: Rules of the consequence-based chase
4.4.2 Consequence-Based Chase and Universal Interpretations
To prove that entails(K, q) is sound and complete, we interpret K using the forest-shaped
universal interpretation described in Section 4.2. Towards this goal, we next define some
auxiliary notions, then define the universal interpretation, and, finally, we prove two properties of such interpretation.
The universe of K is the set of all terms built from the individuals occurring in K and the
unary function symbols of the form fS,A with S  R and A  CK . Since K is normalised,
the universe of K is nonempty. A fact is a ground atom constructed using the predicates
occurring in K and the terms from the universe of K. For a role chain  = S1    Sn , terms
w and w0 , and a set of facts I, we write (w, w0 )  I if (not necessarily distinct) terms
w = w0 , . . . , wn = w0 exists such that Si (wi1 , wi )  I for each i  [1..n]. A set of facts
I entails a Boolean CQ q = ~y . (~y ), written I |= q, if a substitution  exists such that
dom( ) = ~y and  (q)  I. The universal interpretation IK of K is defined as follows.
Definition 25. A chase rule from Table 5 is applicable to a set of facts I if the preconditions
of the rule are satisfied, but I does not contain all conclusions of the rule. A consequencebased chase (often just chase) for K is a sequence of sets of facts I0 , I1 , . . . where
I0 = {{a}(a), >c (a), >r (a, b) | {a, b}  IK }  A

(45)

and, for each i  1, set Ii+1 is obtained by extending Ii with the conclusion of one (arbitrarily
chosen) chase rule applicable to Ii , and Ii+1 = Ii if no chase rule is applicable to Ii . This
686

fiThe Complexity of Answering CQs and GXQs over OWL 2 EL KBs

sequence must be fairthat is, if a derivation rule is applicable to some Ii for a specific
precondition, then j  i exists suchSthat Ij+1 is obtained from Ij by applying the rule to the
mentioned precondition. Set IK = iN Ii is a universal interpretation of K.
Since K is in normal form, we have K 6|= {a} v {b} for all distinct individuals a and
b in IK ; hence, at most one individual a  IK exists in rule (cr2) such that K |= B v {a}.
Because of that, it is straightforward to see that IK is independent from the order in which
the chase rules are applied, so we call IK the universal interpretation of K. Moreover,
due to fairness, no derivation rule is applicable to IK that is, for each chase rule from
Table 5 either the preconditions of the rule are not satisfied in IK , or IK contains all the
conclusions of the rule. Finally, it is well-known that, if K is consistent, then IK can be
homomorphically embedded into any model of K (Krotzsch et al., 2007). Consequently, the
universal interpretation IK can be used to answer arbitrary Boolean CQs over K.
Fact 26. For each Boolean CQ q, we have K |= q if and only if K |= >c v c or IK |= q.
Next, we show how IK relates to the axioms entailed by K. To this end, let  be the
following function mapping each term w in the universe of K to a basic concept:
(
{w} if w  I
(w) :=
A
if w is of the form w = fS,A (w0 )
Proposition 27. The universal model IK satisfies the following properties.
1. For each A(w)  IK , we have K |= (w) v A.
2. For each S(w, w0 )  IK , a nonempty role chain  = 0  S1  1    m1  Sm  m with
  L(S) and terms w0 , . . . , wm from the universe of K with w0 = w and wm = w0
exist such that
(a) for each i  [1..m], either wi  IK , or an atomic concept Ai  {>c }  CK exists
such that wi = fSi ,Ai (wi1 ) and K 6|= Ai v {a} for each individual a  IK ,
(b) for each i  [1..m], we have K |= (wi1 ) v Si .(wi ), and
(c) for each i  [0..m] and each role T occurring in i , we have K |= (wi ) v T.Self
or K |=  v T .
Proof. Let I0 , I1 , . . . be a chase sequence for K. We show by induction on rule applications that properties (1) and (2) are satisfied for each A(w)  In and each S(w, w0 )  In ,
respectively, and that In additionally satisfies the following property:
3. For each term w occurring in In , we have K |= x.(w)(x).
By the definition of I0 and (cr3), for each In and all terms w and w0 occurring in In , we
clearly have {>c (w), >r (w, w0 ), >r (w0 , w)}  In .
Base case. Consider I0 , and note that each term w occurring in I0 is an individual so
(w) = {w}. Consider some A(a)  I0 ; then either A(a)  A, A = {a}, or A = >c , so we
have K |= {a} v A, and property (1) holds. Furthermore, consider some S(a, b)  I0 ; then
687

fiStefanoni, Motik, Krotzsch, & Rudolph

S(a, b)  A or S = >r , so we have K |= {a} v S.{b}, and property (2) holds for w0 = a,
w1 = b, and  = S. Finally, property (3) holds because K |= x.{a}(x) for each a  IK .
Inductive step. Assume that some In satisfies properties (1)(3). By considering each
derivation rule, we assume that the rule is applicable to In as shown in Table 5, and we
show that properties (1)(3) hold for all conclusions of the rule. Note that only rule (cr3)
can affect property (3), and we do not explicitly consider properties that hold vacuously.
(cr1) By the inductive hypothesis, we have K |= (w) v A1 and K |= (w) v A2 , which
implies K |= (w) v B, as required for property (1).
(cr2) By the inductive hypothesis, we have K |= (w) v A and K |= x.(w)(x), which
clearly imply K |= (w) v S.B and K |= x.B(x). Moreover, (a) = {a}, so K |= (a) v B,
and property (1) holds. Finally, since K |= (w) v S.(a), property (2) holds for w0 = w,
w1 = a, and  = S.
(cr3) Let w00 = fS,B (w). By the inductive hypothesis, we have K |= (w) v A and
K |= x.(w)(x), so we have K |= (w) v S.B and K |= x.B(x). Moreover, (w00 ) = B, so
K |= (w00 ) v B, K |= (w00 ) v >c , and K |= x.(w00 )(x), as required for properties (1) and
(3), respectively. For property (2), we consider all role assertions derived by the rule.
 S(w, w00 ). Note that K |= (w) v S.(w00 ) and K 6|= B v {a} for each a  IK , so
property (2) holds for w0 = w, w1 = w00 , and  = S.
 >r (w00 , w00 ). Clearly, property (2) holds for w0 = w00 and  = 0 = >r .
 >r (w00 , w0 ) for some term w0 occurring in In . Let a be the individual that w0 is rooted
in; then, >r (a, w0 )  In so, by the inductive hypothesis, a role chain   L(>r ) and
terms a = w0 , . . . , wm = w0 exist satisfying properties (a)(c). Since K |= x.(w00 )(x),
we have K |= (w00 ) v >r .{a}; thus, >r   and w00 , w0 , . . . , wm satisfy property (2).
 >r (w0 , w00 ) for some term w0 occurring in In . Then, >r (w0 , w)  In so, by the inductive
hypothesis, a role chain   L(>r ) and terms w0 = w0 , . . . , wm = w exist satisfying
properties (a)(c). But then,   >r and w0 , . . . , wm , w00 satisfy property (2).
(cr4) By the inductive hypothesis, we have K |= (w0 ) v A; moreover, terms w0 , . . . , wm
with w0 = w and wm = w0 and a nonempty role chain  = 0  S1  1    m1  Sm  m with
  L(S) exist satisfying properties (a)(c). By the definition of L(S), we have K |=  v S;
together with the entailments in properties (b) and (c), we have K |= (w) v S.(w0 ). But
then, we have K |= (w) v S.A, which implies K |= (w) v B, as required for property (1).
(cr5) By the inductive hypothesis, a nonempty role chain   L(S) exist satisfying
properties (a)(c); moreover, K |=  v S by the definition of L(S). Role S is simple, so
|| = 1, and therefore  can have one of the following two forms.
  = 0 and 0 = T . By property (c), we have K |= (w) v T.Self or K |=  v T .
Furthermore, due to K |=  v S, we have K |= T v S. But then, K |= (w) v S.Self,
and so K |= (w) v B holds, as required for property (1).
  = S1 . Terms w0 and w1 satisfying property (2) are then both equal to w; moreover,
w1 is not of the form fS1 ,A1 (w), so w  IK . Furthermore, by property (b) we have
688

fiThe Complexity of Answering CQs and GXQs over OWL 2 EL KBs

K |= (w) v S1 .(w); together with w  IK , we have K |= (w) v S1 .Self. Finally,
due to K |=  v S, we have K |= S1 v S. But then, K |= (w) v S.Self, and so
K |= (w) v B holds, as required for property (1).
(cr6) By the inductive hypothesis, we have K |= (w) v A, from which we can conclude
K |= (w) v S.Self, so property (2) holds for w0 = w and  = 0 = S.
(cr7) If  = , then w = w0 and K |=  v S, and property (2) holds for w0 = w
and  = 0 = S. Otherwise, assume that  is nonempty and of the form  = S1    Sk .
Thus, terms w0 , . . . , wk with w0 = w and wk = w0 exist such that Si (wi1 , wi )  In for
i
each i  [1..k]. By the inductive hypothesis, for each i  [1..k], terms w0i , . . . , wm
with
i
i
i
i
i
w0 = wi1 and wmi = wi and a role chain  with   L(Si ) exist satisfying properties
k
i1 = w i for each
(a)(c); note that w0i = w0 = w, that wm
= wk = w0 , and that wm
0
i1
k
1
k
i  [1..k]. By the definition of L(S), then       L(S), and so property (2) holds for
1 , . . . , wk , . . . , wk .
role chain 1    k and terms w0 , w11 , . . . , wm
mk
1
1
4.4.3 Soundness
We are now ready to show that our algorithm entails is sound.
Lemma 28. If a nondeterministic computation exists such that entails(K, q) returns true,
then K |= q.
Proof. Assume that a nondeterministic computation exists such that entails(K, q) returns
true. If our algorithm returns true in step 1, then K |= q, as K is inconsistent; hence, in the
rest of this proof, we assume that K is consistent and show that IK |= q. To this end, let
substitution , skeleton S = hV, E, i, and function L be as determined by entails. Graph
hV, Ei is a forest rooted in the individuals occurring in K so, by structural induction on this
forest, we define mapping  from V to the universe of K that will satisfy the following:
(i) for each v  V , we have (v)( (v))  IK ; and
(ii) for each hv, v 0 i  E and each Pj  L(v, v 0 ), a role chain j  L(Pj ) exists such that
j ( (v),  (v 0 ))  IK .
Base case. For each a  IK , let  (a) = a. Since (a) = {a} and {a}(a)  IK , the first
property clearly holds, and the second property is vacuous.
Inductive step. Consider hv, v 0 i  E such that  (v) has been defined, but  (v 0 ) has not;
let L(v, v 0 ) = {P1 , . . . , Pm }. Since exist((v), (v 0 ), L(v, v 0 )) returns true, by Lemma 24
we have that roles S1 , . . . , Sn , atomic concepts A1 , . . . , An , and, for each j  [1..m], a role
chain j = S1  j,1    Sn  j,n exist such that n  1, A0 = (v) and An = (v 0 ), and the
following holds for each i  [1..n] and each j  [1..m].
1. For each a  IK , we have K |= Ai1 v Si .Ai and K 6|= Ai v {a}.
2. For each role T occurring in j,i , we have K |= Ai v T.Self or K |=  v T .
3. j  LdR (Pj ).

689

fiStefanoni, Motik, Krotzsch, & Rudolph

Let w0 =  (v); let wi = fSi ,Ai (wi1 ) for i  [1..n]; and let  (v 0 ) = wn . Since A0 = (v), by
the inductive hypothesis we have A0 ( (v))  IK . Furthermore, (cr3) is not applicable to
IK so, for each i  [1..n], we have Si (wi1 , wi )  IK and Ai (wi )  IK ; thus, ( (v 0 ))  IK ,
as required. Finally, for each role T occurring in each j,i , we have K |= Ai v T.Self or
K |=  v T ; (cr6) and (cr7) are not applicable to IK , respectively, so we have T (wi , wi )  IK ;
thus, we have j ( (v),  (v 0 ))  IK , as required.
We next show that  ((q))  IK by considering independently each atom in (q). To
prove the lemma, we can combine  and  in the obvious way.
Consider an arbitrary unary atom A(t) in (q). By step 4 of Algorithm 1, we have
K |= (t) v A, which also implies K |= (t) u (t) v A. By property (i), we have
(t)( (t))  IK . Since rule (cr1) is not applicable to IK , we have A( (t))  IK , as required.
Consider an arbitrary binary atom S(t, u) in (q). Let v0 , . . . , vn , s0 , . . . , sn , and
0 , . . . , n be as determined in steps 811 when Algorithm 1 considers atom S(t, u). For each
i  [1..n], we have pda(si1 , i1 , si , i )  L(vi1 , vi ) by step 12; but then, by property (ii)
a role chain i exists such that i  L(pda(si1 , i1 , si , i )) and i ( (vi1 ),  (vi ))  IK .
Next, we define 0 by considering the following two cases.
 v0  I. By step 14 of Algorithm 1, a role chain 0 = S1    Sk exists such that
0  L(wfa((t), (v0 ))). By property (i), we have (t)( (t))  IK ; moreover, by Definition 20, basic concepts (t) = A0 , A1 , . . . , Ak = {v0 } exist with K |= Aj1 v Sj .Aj
for each j  [1..k]. Rules (cr2) and (cr3) are not applicable to IK , so we have
0 ( (t),  (v0 ))  IK .
 v0 6 I, which implies v0 = t. By step 16 of Algorithm 1, a role chain 0 = T1    Tk
exists such that 0  L(sfa((v0 ))). By property (i), we have (v0 )( (v0 ))  IK ;
moreover, by Definition 20, K |= (v0 ) v Tj .Self or K |=  v Tj for each j  [1..k].
Rules (cr6) and (cr7), respectively, are not applicable to IK , thus 0 ( (t),  (v0 ))  IK .
In either case, by steps 14 and 16 we have 0  L(pda(iS , , s0 , 0 )). Now let 0 = 0    n ;
note that we can have n = 0, in which case 0 = 0 . Clearly, we have 0 ( (t),  (vn ))  IK ,
where vn = u. Moreover, 0  L(pda(iS , , sn , n )) with sn = fS and n = . Finally,
rule (cr7) is not applicable to IK , so S( (t),  (u))  IK , as required.
4.4.4 Completeness
We next prove that our encoding is also complete, thus proving Theorem 21.
Lemma 29. If K |= q, then a nondeterministic computation exists such that entails(K, q)
returns true.
Proof. Assume that K |= q. If K is inconsistent, then entails(K, q) returns true, as required;
hence, in the rest of this proof, we assume that K is consistent. But then, IK |= q, so a
substitution  exists such that (q)  IK . Let  be as defined in Section 4.4.2.
For the substitution  in step 2, let (y) := (y) if (y)  I; otherwise, let (y) be an
arbitrary, but fixed, variable y 0 from q such that (y) = (y 0 ). It is straightforward to see
that ((q))  IK .

690

fiThe Complexity of Answering CQs and GXQs over OWL 2 EL KBs

For the skeleton S = hV, E, i in step 3, set V contains IK and the variables occurring
in (q), and (y) = ((v)) for each variable y  V . Furthermore, let  be the smallest
irreflexive and transitive relation on the universe of K such that w  fS,A (w) for each term
w in the universe of K; then, let hv, v 0 i  E if and only if (v)  (v 0 ) and no v 00  V exists
such that (v)  (v 00 )  (v 0 ). By the definition of , graph hV, Ei is a forest rooted in
IK , as required by Definition 18.
In step 4, for an arbitrary atom A(t) in (q), we have A((t))  IK ; by property (1) of
Proposition 27, we have K |= ((t)) v A; hence, the condition is not satisfied.
Now consider an arbitrary edge hv, v 0 i  E; and let w0 , . . . , wk be terms, let A1 , . . . , Ak
be atomic concepts, and let S1 , . . . , Sk be roles such that w0 = (v), wk = (v 0 ), and
wi = fSi ,Ai (wi1 ) for each i  [1..k]; finally, let A0 = (v). Note that all of these are
uniquely defined by the edge, and that, by the construction of IK , for each i  [1..k], we have
K |= Ai1 v Si .Ai and K 6|= Ai v {a} for each a  IK . Then, a role chain  is compatible
with the edge hv, v 0 i if role chains 1 , . . . , k exists such that  = S1  1    Sk  k and, for
each i  [1..k] and each role T occurring in i , we have K |= Ai v T.Self or K |=  v T .
In the rest of this proof we will show the following property.
() For each PDA P  L(v, v 0 ), a role chain   L(P) exists that is compatible with the
edge hv, v 0 i.
By Lemma 24 and the above definition of compatibility, property () implies that the
condition in step 18 is not satisfied for edge hv, v 0 i.
For the loop in steps 616, let S(t, u) be an arbitrary binary atom in (q); we next
determine the required nondeterministic choices that preserve () in step 12, and that
satisfy conditions in steps 14 and 16, which completes the proof of this lemma. Let au  IK
be the unique individual connected to u in hV, Ei. Since S((t), (u))  IK , a nonempty
role chain  = 0  S1  1    m1  Sm  m with   L(S) and terms w0 , . . . , wm from the
universe of K with w0 = (t) and wm = (u) exist satisfying property (2) of Proposition 27.
To define vertex v0 in step 8, we consider two possibilities, and for each we also define an
index `0  [0..m] such that w`0 = (v0 ).
 If some j  [0..m] exists such that wj  IK , let v0 = au and let `0 be the largest index
such that w`0 = au .
 Otherwise, let v0 = t and let `0 = 0.
Let v0 , . . . , vn be the unique path connecting v0 to u in S. By the definition of `0 and the
form of the terms w`0 +1 , . . . , wm , we have wj 6 I for each j  [`0 + 1..m]; (v0 ) = w`0 ;
and (vn ) = wm . Thus, for each i  [1..n], a unique index `i exists such that (vi ) = w`i .
Now let 0 = 0    S`0  `0 , and let i = S`i1 +1  `i1 +1    S`i  `i for each i  [1..n];
clearly,  = 0    n . By properties (a)(c) of Proposition 27, for each i  [1..n], role chain
i is compatible with the edge hvi1 , vi i. Furthermore,   L(S) and Theorem 8 imply
  LdR (pda(iS , , fS , )), and so states s0 , . . . , sn with sn = fS and words 0 , . . . , n with
n =  exist such that 0  LdR (pda(iS , , s0 , 0 )) and i  LdR (pda(si1 , i1 , si , i ) for
each i  [1..n]. Since each i is compatible with hvi1 , vi i, step 12 preserves property (),
as required. Finally, we consider step 13.

691

fiStefanoni, Motik, Krotzsch, & Rudolph

 v0  I. By property (b) of Proposition 27, K |= (wj1 ) v Sj .(wj ) for each j  [1..`0 ].
Furthermore, by property c of Proposition 27, K |= (wj ) v T.Self or K |=  v T for
each j  [0..`0 ] and each role T occurring in j ; thus, K |= (wj ) v T.(wj ). But
then, 0  L(wfa((t), (v0 ))), so condition in step 14 is not satisfied.
 v0 6 I, so v0 = t and 0 = 0 . By property (c) of Proposition 27, K |= (wj ) v T.Self
or K |=  v T for each role T occurring in 0 . But then, 0  L(sfa((v0 ))), so
condition in step 16 is not satisfied.

5. The Lower Complexity Bound
In the previous section, we presented a BCQ answering algorithm for ELRO+ that uses
space polynomial in the total size of the input. This algorithm is worst-case optimal in
combined complexity since Krotzsch et al. (2007) reduced the PSpace-hard problem of
checking nonemptiness of the intersection of the languages generated by m deterministic
finite automata F1 . . . Fm over a common alphabet  (Kozen, 1977) to BCQ answering in
ELRO+ . In the knowledge base K encoding the problem, a regular RBox contains roles
S1 . . . Sm such that L(Si ) = L(Fi ) for each i  [1..m]; furthermore, a TBox ensures that
the universal interpretation IK is a rooted tree so, for each    , a term w exists that
is reachable from the root by a chain T
of roles corresponding to ; finally, a Boolean CQ
contains m atoms that check whether i L(Fi ) is nonempty. We next improve this lower
bound by showing that the problem is hard already in the restricted setting where the query,
the TBox, and the ABox are all fixed, and just the RBox varies.
Theorem 30. For K a regular ELRO+ knowledge base and q a Boolean conjunctive query,
checking K |= q is PSpace-hard even when
 the query is fixed and consist of two binary atoms over a single quantified variable,
 the TBox is fixed and contains only axioms of the form A v S.A, and
 the ABox is fixed and contains a single unary assertion.
Proof. We reduce the PSpace-hard problem of deciding whether the intersection of the
languages generated by m deterministic finite automata is nonempty (Kozen, 1977). Let
0 be deterministic finite automata over alphabet 0 , let  and  be fresh symbols
F10 , . . . , Fm
1
2
not occurring in 0 , and let  = 0  {1 , 2 }. For each j  [1..m], let Fj = hQj , , j , ij , fj i
be the deterministic finite automaton over alphabet  obtained by extending Fj0 with a
transition labelled by 1 from the final state fj0 of Fj0 to T
itself, and with a transition labelled
0
0
by T
2 from fj to a fresh final state fj of Fj . Then,
j ) 6=  if and only if a word
T j L(F
0
w  j L(Fj ) exist such that |w| is odd: given w  j L(Fj ), if |w| is odd, then |w  1  2 |
is odd and w  1  2  L(Fj ) for each j  [1..m], and if |w| is even, then |w  2 | is odd and
w  2  L(Fj ) for each j  [1..m]. Finally, we assume w.l.o.g. that Qi  Qj 6=  and Qi  R
hold for each 1  i < j  m, and that   R as well.
Let w = ST1    Sn be a word in  such that n is odd, and let  =   Q1  . . .  Qm .
Clearly, w  j L(Fj ) holds if and only if a word w   of the form
n
n
w = e01    e0m  S1  o1m    o11  S2  e21    e2m       e1n1    en1
m  Sn  om    o1

692

(46)

fiThe Complexity of Answering CQs and GXQs over OWL 2 EL KBs

exists such that the following conditions hold for each j  [1..m]:
i
(i) for each i  [1..n] with i odd, we have oij  Qj and j (ei1
j , Si ) = oj ;
i
(ii) for each i  [1..n] with i even, we have eij  Qj and j (oi1
j , Si ) = ej ; and

(iii) e0j = ij and onj = fj .
Now let LO , LE , L1 , and L2 be the following languages.
LO :={e1    em  S  om    o1 | S   and j (ej , S) = oj , for each j  [1..m]}

(47)

LE :={om    o1  S  e1    em | S   and j (oj , S) = ej , for each j  [1..m]}

(48)



L1 :=(LO  )  LO

(49)


L2 :={i1    im }  (  LE )    {fm    f1 }

(50)

Consider an arbitrary word w   and the corresponding word w   . By the definition
of L1 , we have that w  L1 if w is of the form (46) and it satisfies property (i). Similarly,
by the definition of L2 , we have that w  L2 if w is of theT form (46) and it satisfies
properties (ii) and (iii). Thus, w  L1  L2 if and only if w  j L(Fj ). For simplicity, in
the rest of this proof, we will use the following equivalent formulations of L1 and L2 .
L1 =LO  (LO  )+  LO

(51)
+

L2 ={i1    im }    {fm    f1 }  {i1    im }  (  LE )    {fm    f1 }

(52)

TWe next define a knowledge base K and a fixed query q such that K |= q if and only
if j L(Fj ) 6= . We will present our construction in stages, and for each we will describe
how it affects the canonical model I = hI , I i of Kthat is, the model constructed using
the standard notion of chase (i.e., as in Definition 25, but with all semantic conditions on
K replaced by the syntactic checks for axioms in K). For simplicity, we first present K in
which the TBox depends on , and later we modify the encoding to use a fixed TBox.
The TBox T contains axioms (53), and the ABox A contains only axiom (54). We
assume that aI = a ; then, for each word    , a domain element a exists that is
connected to a via a chain of roles corresponding to .
A v.A

for each symbol   

(53)

A(a )

(54)

We next present an RBox R consisting of four parts, each encoding languages LO , LE ,
S,m+1
S,m
L1 , and L2 . Our encoding uses fresh roles LS,1
and LS,0
uniquely
O , . . . , LO
E , . . . , LE
0
associated with each role S  , as well as fresh roles LO , LE , L , L1 , L1 , L2 , and L02 .
The first part of R contains axioms (55)(57). It should be clear that, for all words
1 , 2   where 1 is a prefix of 2 , we have ha1 , a2 i  LIO if and only if 2  1  LO .
S v LS,m+1
O
ej 

LS,j+1
O

 oj v

LS,j
O

S  

(55)

j  [1..m] S   ej , oj  Qj with j (ej , S) = oj

(56)

LS,1
O v LO

(57)
693

fiStefanoni, Motik, Krotzsch, & Rudolph

The second part of R contains axioms (58)(60). It should be clear that, for all words
1 , 2   where 1 is a prefix of 2 , we have ha1 , a2 i  LIE if and only if 2  1  LE .

oj 

S,j1
LE

S v LS,0
E

S  

(58)

LS,j
E

j  [1..m] S   ej , oj  Qj with j (oj , S) = ej

(59)

 ej v

LS,m
v LE
E

(60)

The third part of R contains axioms (61)(65). It should be clear that, for all words
1 , 2   where 1 is a prefix of 2 , we have ha1 , a2 i  LI1 if and only if 2  1  L1 .
S v L

S  

(61)

LO v L1

(62)

L01
L01

(63)

v L1

(65)

LO  L v
L01  L01
L01  LO

v

(64)

The fourth part of R contains axioms (66)(69). It should be clear that, for all words
1 , 2   where 1 is a prefix of 2 , we have ha1 , a2 i  LI2 if and only if 2  1  L2 .
i1    im  L  fm    f1 v L2

(66)

L02
L02

(67)
(68)

 L  fm    f1 v L2

(69)

L  LE v
L02
i1    im 

L02



L02

v

Query q is given in (70). Then, K |= q if and only if a word    exists such that
ha , a i  LI1 and ha , a i  LI2 , and the latter is clearly the case if and only if   L1  L2 .
RBox R is regular and of size polynomial in the size of automata F1 , . . . , Fm .
q = y. L1 (a , y)  L2 (a , y)

(70)

We next tighten this reduction to use the fixed TBox T 0 consisting of axioms (71)(72),
where P0 and P1 are fresh roles.
A v P0 .A

(71)

A v P1 .A

(72)

Now let k = dlog2 ||e, and assume that each symbol    corresponds to a k-digit binary
number b1    bk with bi  {0, 1}. Then, let R0 be R extended with axioms (73).
Pb 1    Pb k v 

for each    corresponding to b1    bk

(73)

Finally, let K0 = hT 0 , R0 , Ai, and let I 0 be the canonical model of K0 . Axioms (54), (71),
and (72) ensure existence of a binary tree whose edges are labelled with roles P0 and P1 .
Furthermore, axioms (73) ensure that, for each    and each sequence of k edges in this
tree corresponding to the binary number assigned to , there is a shortcut in the tree
694

fiThe Complexity of Answering CQs and GXQs over OWL 2 EL KBs

labelled with . Thus, I can be homomorphically embedded into I 0 . Finally, roles P0 and
P1 do not occur in R and query q checks for existence of a domain element connected to a ;
therefore, the extra edges in I 0 are irrelevant. Consequently, the encoding of languages L1
and L2 works in the same way as with the varying TBox T .
Finally, we characterise the complexity of BCQ answering over ELRO+ knowledge bases.
Theorem 31. For K a regular ELRO+ KB and q a Boolean CQ, checking K |= q is
1. PTime-complete in data complexity,
2. NP-complete, if the RBox R is fixed, and
3. PSpace-complete in combined complexity.
Proof. Calvanese et al. (2006) proved that BCQ answering is PTime-hard in data complexity already for EL knowledge bases. Furthermore, when the query is not fixed, BCQ
answering is NP-hard already over relational databases (Chandra & Merlin, 1977). Then
the theorem follows by Theorems 23 and 30, and by Savitchs theorem.

6. Navigational Queries
The data in DL knowledge bases has graph-like structure, where unary assertions encode
properties of graph nodes and binary assertions encode graph edges. Conjunctive queries
cannot express recursive properties such as reachability, and so their expressivity is often insufficient in applications that require graph navigation. As the popularity of graph
databases is on the rise, a number of navigational languages for querying graph-like data
have been proposed; for example, regular path queries (Barcelo, 2013) use regular expressions to express complex navigational patterns between graph vertices, and graph XPath
queries (Libkin et al., 2013) extend regular path queries with the converse operator, negation on regular expressions, and checking properties of vertices using Boolean combinations
of concepts and existential quantifications over paths. In the DL context, the computational complexity of navigational queries has been studied for several expressive DLs and
members of the DL-Lite family and the EL(H) fragment of ELRO+ (Calvanese, Eiter, &
Ortiz, 2009; Bienvenu et al., 2013; Kostylev et al., 2014; Bienvenu et al., 2014). In order to
complete the complexity landscape of this problem, in this section we study the problem of
answering graph XPath queries over ELRO+ knowledge bases.
6.1 Graph XPath Queries
Graph XPath queries consist of node expressions and path expressions, whose syntaxes are
defined respectively by the following two context-free grammars for B a basic concept and
S a role.
  B |  | 1  2 | 1  2 | hi
  S | S  | 1  2 | 1 + 2 |  |  | test()
Following Libkin et al. (2013), we consider the following expression fragments.
695

fiStefanoni, Motik, Krotzsch, & Rudolph

P,E
4

P

g

P

P,F
3

S,D
5

R,S

a

R

b

U
P

S,D
6

S

S,A
7

S

U

P,A
2

S

f

P

R,S

c
B

R

d

R,S

e

S

P,E
1

Figure 8: Interpretation I
1. The path-positive fragment disallows path expressions of the form .
2. The positive fragment disallows path expressions of the form  and node expressions
of the form .
3. The converse-free fragment disallows path expressions of the form S  .
A graph XPath atom has the form (s) or (s, t), for  a node expression,  a path
expression, and s and t terms. A conjunctive graph XPath query (CGXQ) g is an expression
g = ~y . (~x, ~y ) where  is a conjunction of graph atoms over variables ~x  ~y ; variables ~x
are called the answer variables of g. If ~x = , then g = ~y . (~y ) is a Boolean CGXQ.
Path-positive, positive, and converse-free CGXQs are obtained by restricting query atoms
accordingly. Finally, a graph XPath query (GXQ) is a CGXQ containing a single atom.
To define the semantics of CGXQs, let I = hI , I i be a first-order interpretation. The
interpretation of node and path expressions in I is inductively defined as follows.
()I
(1  2 )I
(1  2 )I
(hi)I

=
=
=
=

I \ ()I
(1 )I  (2 )I
(1 )I  (2 )I
{x  I | y  I : hx, yi  I }

(S  )I
(1  2 )I
(1 + 2 )I
( )I
()I
(test())I

=
=
=
=
=
=

{hy, xi | hx, yi  S I }
(1 )I  (2 )I
(1 )I  (2 )I
(I )
I  I \ ()I
{hx, xi | x  I }

Please observe that the difference of path expressions 1 and 2 corresponds to (1 + 2 ),
whereas the intersection of 1 and 2 corresponds to (1 + 2 ); moreover, Libkin et al.
(2013) define a path expression , which in our setting corresponds to test(>c ). Satisfaction
of a Boolean CGXQ g in I and CGXQ entailment are defined in the obvious way; moreover,
Boolean CGXQ answering is the problem of checking K |= g.
Example 32. We illustrate these definitions using interpretation I shown in Figure 8;
notation is as in Example 15. Moreover, let 1 , 2 , and 3 be the following path expressions.
1 =(R  test(hS   test(A  B)i))

(74)

2 =(U  test(hP  test(A  B)i))

(75)

696

fiThe Complexity of Answering CQs and GXQs over OWL 2 EL KBs

Node expressions
TB = {B v CB }
T1 2 = {C1 u C1 v C1 2 }  T1  T2
T1 2 = {C1 v C1 2 , C2 v C1 2 }  T1  T2
Thi = {T .>c v Chi }  T
Path expressions
TS = 
T1 2 = T1  T2
T1 +2 = T1  T2
T = T
Ttest() = {C v Ttest() .Self}  T

RB = 
R1 2 = R1  R2
R1 2 = R1  R2
Rhi = R

RS = {S v TS }
R1 2 = {T1  T2 v T1 2 }  R1  R2
R1 +2 = {T1 v T1 +2 , T2 v T1 +2 }  R1  R2
R = { v T , T v T , T  T v T }  R
Rtest() = R

Table 6: Encoding positive, converse-free node and path expressions using axioms
3 =((R  S) )

(76)

Expression 1 is positive, and it retrieves all pairs of individuals that are connected by a
path of R-edges such that, for each element occurring in the path other than the first, there
exists an outgoing path of S-edges reaching a member of concept A t B. For example, we
have {haI , dI i, haI , eI i}  (1 )I .
In contrast, expression 2 is path-positive, and it retrieves all pairs of individuals that
are connected by a U -edge such that no P -successor exists that is a member of concept AtB.
For example, we have haI , g I i  (2 )I , but haI , f I i 6 (2 )I .
Finally, expression 3 is neither positive nor path-positive, and it retrieves all pairs of
individuals that are connected by a path not consisting of a sequence of edges described by
the regular expression (R  S) . For example, we have haI , dI i  (3 )I , but haI , eI i 6 (3 )I .
Let g = x, y, z.1 (x, y)  2 (x, z)  3 (x, y) be a conjunctive graph XPath query, and let
 = {x 7 a, y 7 d, z 7 g} be a substitution. Using Figure 8, one can check that I |= (g).
As observed by Kostylev et al. (2014), node expressions in graph XPath queries correspond precisely to formulas in propositional dynamic logic with negation (PDL ) (Harel
et al., 2000); the satisfiability problem for PDL is undecidable (Harel, 1984), so answering
GXQs under DL constraints is undecidable. Decidability results have been recently obtained for path-positive and positive queries over DL-Lite knowledge bases (Kostylev et al.,
2014). In addition, Kostylev et al. (2014) proved that, for all DLs, answering path-positive,
converse-free GXQs is coNP-hard in data-complexity. Finally, Bienvenu et al. (2014) proved
that answering positive GXQs over EL knowledge bases is ExpTime-complete. Thus, in
the rest of this section we focus on positive, converse-free graph XPath queries.
6.2 Complexity of Answering Positive, Converse-Free Graph XPath Queries
In the rest of this section, we fix an ELRO+ KB K = hT , R, Ai such that R is regular.
We next show that, given a positive, converse-free Boolean CGXQ g, one can construct in
polynomial time a regular ELRO+ KB K0 and a Boolean CQ q 0 such that K |= g if and
only if K0 |= q 0 . Our construction of K0 combines various expressive features of ELRO+ :
697

fiStefanoni, Motik, Krotzsch, & Rudolph

role inclusions and reflexive roles encode the path expressions of g in the RBox, and selfrestrictions encode the node expressions of g in the TBox.
Proposition 33. Given a positive, converse-free Boolean CGXQ g over K, one can compute
in time polynomial in |K| + |g| an ELRO+ KB K0 and a Boolean CQ q 0 such that the RBox
of K0 is regular, g and q 0 have equally many atoms, and K |= g if and only if K0 |= q 0 .
Proof. Let g = ~y . (~y ) be a positive, converse-free Boolean CGXQ over K. For each
positive node expression , let C be a fresh atomic concept uniquely associated with 
and, for each positive, converse-free path expression , let T be a fresh role uniquely
associated with . By structural induction, we associate with each  (resp. ) a TBox
T and an RBox R (resp. a TBox T and an RBox R ) as shown in Table 6. Then, let
K0 = hT  T 0 , R  R0 , Ai where TBox T 0 and RBox R0 are as follows.
[
[
[
[
T0=
T 
T
R0 =
R 
R
(s)

(s,t)

(s)

(s,t)

Now let q 0 = ~y .  0 (~y ) be the Boolean CQ where  0 contains C (s) for each atom (s)  
and T (s, t) for each atom (s, t)  . Clearly, g and q 0 have the same number of atoms;
moreover, since query g is over K, query q 0 is over K0 . Finally, both q 0 and K0 can be
computed in polynomial time in the input size, and the RBox of K0 is clearly regular. We
next show that K0 6|= q 0 if and only if K 6|= g.
() Assume that K0 6|= q 0 , so an interpretation I exists such that I |= K0 and I 6|= q 0 .
Since each axiom of K is also an axiom of K0 , we have that I |= K. Furthermore, for
each positive node expression  and positive path expression , we have I  (C )I and
I  (T )I . We prove this claim by simultaneous induction on the structure of node and
path expressions.
Base case. For the base case, let  be an arbitrary node expression of the form  = B and
let  be an arbitrary path expression of the form  = S. Since B v CB  T 0 , S v TS  R0 ,
and I is a model of K0 , the claim easily follows.
Inductive step. For the inductive step, we distinguish two cases.
First, consider an arbitrary node expression  such that the property holds for all node
and path expressions occurring in . Then let x be an arbitrary element of I and assume
that x  I ; we show that x  CI by considering the various forms that  can take.
  = 1  2 . Since x  I , we have x  I1 and x  I2 . By the inductive hypothesis,
we have x  CI1 and x  CI2 . By the definition of T 0 , we have C1 u C2 v C  T 0 .
Since I is a model of T 0 , we have x  CI , as required.
  = 1  2 . The proof for this case is similar to the one above.
  = hi. Since x  I , there exists y  I such that hx, yi  I . By the inductive
hypothesis, we have hx, yi  TI . By the definition of T 0 , we have T .>c v C  T 0 .
Since I is a model of T 0 , we have x  CI , as required.
Second, consider an arbitrary path expression  such that the property holds for all
node and path expressions occurring in . Then let x and y be arbitrary elements of I
and assume that hx, yi  I ; we show that hx, yi  TI by considering the various forms
that  can take.
698

fiThe Complexity of Answering CQs and GXQs over OWL 2 EL KBs

  = 1  2 . Since hx, yi  I , there exists z  I such that hx, zi  1I and
hz, yi  2I . By the inductive hypothesis, we have hx, zi  TI1 and hz, yi  TI2 .
Moreover, by the definition of R0 , we have T1  T2 v T  R0 . Since I is a model of
R0 , we have hx, yi  TI , as required.
  = 1 + 2 . Since hx, yi  I , we have that hx, yi  1I or hx, yi  2I . By the
inductive hypothesis, we have hx, yi  TI1 or hx, yi  TI2 . By the definition of R0 , we
have {T1 v T , T2 v T }  R0 . Since I is a model of R0 , we have hx, yi  TI .
  = 1 . First, consider the case in which x = y. By the definition of R0 , we have
 v T  R0 . Since I is a model of R0 , we have hx, yi  TI , as required. Otherwise,
consider the case in which x 6= y. Since hx, yi  I , elements x0 , . . . , xn with x0 = x
and xn = y exist in I such that n > 0 and hxi1 , xi i  1I for each i  [1..n]. By the
inductive hypothesis, for each i  [1..n], we have hxi1 , xi i  TI1 . By the definition
of R0 , we have T1  T1 v T  R0 . Since I is a model of R0 , we have hx, yi  T .
  = test(). It follows that x = y and that x  I . By the inductive hypothesis, we
have x  CI . By the definition of T 0 , we have C v T .Self  T 0 . Since I is a model
of T 0 , we have hx, yi  TI , as required.
But then, since node and path expressions in g are positive, I 6|= q 0 implies I 6|= g.
I0

() Assume that K 6|= g, so an interpretation I exists such that I |= K and I 6|= g. Let
be the interpretation obtained by extending I to the fresh concepts and roles as follows.
0

(C )I = I

0

0

(T )I = I

0

By the definition of K0 , it is straightforward to see that I 0 |= K0 ; furthermore, by the
definition of q 0 , it is straightforward to see that I 0 6|= q 0 , as required.
Next, we establish the complexity of answering positive, converse-free (C)GXQs over
ELRO+ knowledge bases.
Theorem 34. For K a regular ELRO+ KB and g a positive, converse-free Boolean CGXQ,
checking K |= g is PTime-complete in data complexity, and PSpace-complete in combined
complexity. For g a positive, converse-free Boolean GXQ, checking K |= g is PTimecomplete in combined and data complexities.
Proof. The hardness in data complexity of Boolean positive, converse-free (C)GXQs follows
from the PTime-hardness of instance checking in EL (Calvanese et al., 2006).
For positive, converse-free GXQs, hardness in combined complexity is inherited from the
PTime-hardness of TBox reasoning in EL (Baader et al., 2005). For the matching upper
bounds, Proposition 33 allows us to reduce Boolean GXQ answering to checking entailments
of the form K0 |= q 0 where q 0 is a BCQ containing only one atom. We next show that, for
each possible form of q 0 , we can reduce the latter problem to checking entailment of ELRO+
concept inclusions, which can be decided in PTime. In the following, c is an arbitrarily
chosen individual from IK0 .
 K0 |= A(a) if and only if K0 |= {a} v A.
699

fiStefanoni, Motik, Krotzsch, & Rudolph

 K0 |= y.A(y) if and only if K0 |= {c} v >r .A.
 K0 |= S(a, b) if and only if K0 |= {a} v S.{b}.
 K0 |= y.S(y, b) if and only if K0 |= {c} v >r .S.{b}.
 K0 |= y.S(a, y) if and only if K0 |= {a} v S.>c .
 K0 |= y1 , y2 .S(y1 , y2 ) if and only if K0 |= {c} v >r .S.>c .
For positive, converse-free CGXQs, hardness in combined complexity is given by Theorem 31, and the matching upper bounds follow from Theorem 23 and Proposition 33.

7. Conclusions
In this paper, we presented the first CQ answering algorithm for OWL 2 EL that runs
in PSpace, thus closing a longstanding open question. Our algorithm is based on an
innovative, succinct encoding of regular role inclusions using bounded-stack PDAthat is,
finite automata extended with a stack of fixed size. We believe this encoding is interesting
in its own right, as it can be used to optimise popular OWL 2 DL reasoners. Moreover, we
refined the previously known PSpace lower bound for CQ answering by showing that the
problem remains PSpace-hard even if the query, the TBox, and the ABox are all fixed (and
only the RBox varies); thus, we identify role inclusions as the only culprit for the problems
PSpace-hardness. Finally, we showed that positive, converse-free GXQs and CGXQs can
be answered over OWL 2 EL knowledge bases in PTime and PSpace, respectively; this is
interesting because Bienvenu et al. (2014) have showed that adding the converse operator
makes the problem ExpTime-hard. Thus, at least from a theoretical perspective, positive,
converse-free (C)GXQs seem to provide an adequate language for querying OWL 2 EL
knowledge bases.
We see two main open problems for our future work. First, by drawing inspiration
from the succinct encoding of role inclusions, we shall extend the combined approach by
Stefanoni et al. (2013) to OWL 2 EL and thus obtain a practical algorithm. Second, as static
query analysis is a fundamental task in query optimisation, we shall study the containment
problem for graph queries under ELRO+ constraints.

Acknowledgements
The results in this article are an extension of the results that were published in preliminary form by Krotzsch et al. (2007) in the Proceedings of the 6th International Semantic
Web Conference (ISWC 2007). This work was supported by Alcatel-Lucent; the EU FP7
project OPTIQUE; the EPSRC projects MASI3 , Score!, and DBOnto; and the DFG project
DIAMOND (Emmy Noether grant KR 4381/1-1).

References
Anselmo, M., Giammarresi, D., & Varricchio, S. (2003). Finite automata and non-selfembedding grammars. In Proceedings of the 7th International Conference on Im-

700

fiThe Complexity of Answering CQs and GXQs over OWL 2 EL KBs

plementation and Application of Automata, CIAA02, pp. 4756, Berlin, Heidelberg.
Springer-Verlag.
Artale, A., Calvanese, D., Kontchakov, R., & Zakharyaschev, M. (2009). The DL-Lite family
and relations. J. Artif. Intell. Res. (JAIR), 36, 169.
Baader, F., Brandt, S., & Lutz, C. (2005). Pushing the EL envelope. In Kaelbling, L. P.,
& Saffiotti, A. (Eds.), Proceedings of the 19th International Joint Conference on Artificial Intelligence (IJCAI 2005), pp. 364369, Edinburgh, UK. Morgan Kaufmann
Publishers.
Baader, F., Brandt, S., & Lutz, C. (2008). Pushing the EL envelope further. In Clark, K.,
& Patel-Schneider, P. F. (Eds.), In Proceedings of the OWLED 2008 DC Workshop
on OWL: Experiences and Directions.
Baader, F., Calvanese, D., McGuinness, D., Nardi, D., & Patel-Schneider, P. F. (Eds.).
(2010). The Description Logic Handbook: Theory, Implementation, and Applications.
Cambridge University Press. Paperback edition.
Baget, J.-F., Leclere, M., Mugnier, M.-L., & Salvat, E. (2011). On rules with existential
variables: Walking the decidability line. Artif. Intell., 175 (9-10), 16201654.
Barcelo, P. (2013). Querying graph databases. In Hull, R., & Fan, W. (Eds.), PODS, pp.
175188. ACM.
Barrett, C., Jacob, R., & Marathe, M. (2000). Formal-language-constrained path problems.
SIAM J. Comput., 30 (3), 809837.
Bienvenu, M., Calvanese, D., Ortiz, M., & Simkus, M. (2014). Nested regular path queries
in Description Logics. In Proc. of the 14th Int. Conf. on the Principles of Knowledge
Representation and Reasoning (KR 2014). AAAI Press.
Bienvenu, M., Ortiz, M., & Simkus, M. (2013). Conjunctive regular path queries in
lightweight Description Logics. In Rossi, F. (Ed.), IJCAI. IJCAI/AAAI.
Cal, A., Gottlob, G., & Kifer, M. (2013). Taming the infinite chase: Query answering under
expressive relational constraints. J. Artif. Intell. Res. (JAIR), 48, 115174.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., Poggi, A., Rodriguez-Muro, M.,
Rosati, R., Ruzzi, M., & Savo, D. F. (2011). The MASTRO system for Ontology-Based
Data Access. Semantic Web, 2 (1), 4353.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., & Rosati, R. (2006). Data
complexity of query answering in Description Logics. In Proc. of the 10th Int. Conf.
on the Principles of Knowledge Representation and Reasoning (KR 2006), pp. 260
270.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., & Rosati, R. (2007). Tractable
reasoning and efficient query answering in Description Logics: The DL-Lite family. J.
Autom. Reasoning, 39 (3), 385429.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., & Rosati, R. (2013). Data
complexity of query answering in Description Logics. Artificial Intelligence, 195, 335
360.

701

fiStefanoni, Motik, Krotzsch, & Rudolph

Calvanese, D., De Giacomo, G., Lenzerini, M., & Vardi, M. Y. (2000). Containment of
conjunctive regular path queries with inverse. In Proc. of the 7th Int. Conf. on the
Principles of Knowledge Representation and Reasoning (KR 2000), pp. 176185.
Calvanese, D., Eiter, T., & Ortiz, M. (2009). Regular path queries in expressive Description
Logics with nominals. In Boutilier, C. (Ed.), IJCAI 2009, Proceedings of the 21st
International Joint Conference on Artificial Intelligence, Pasadena, California, USA,
July 11-17, 2009, pp. 714720.
Calvanese, D., Vardi, M. Y., De Giacomo, G., & Lenzerini, M. (2000). View-based query
processing for regular path queries with inverse. In Proceedings of the Nineteenth ACM
SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems, PODS
00, pp. 5866, New York, NY, USA. ACM.
Chandra, A. K., & Merlin, P. M. (1977). Optimal implementation of conjunctive queries in
relational data bases. In Hopcroft, J. E., Friedman, E. P., & Harrison, M. A. (Eds.),
Proc. of the 9th annual ACM Symposium on Theory of Computing (STOC 77), pp.
7790, Boulder, CO, USA. ACM Press.
Cruz, I. F., Mendelzon, A. O., & Wood, P. T. (1987). A graphical query language supporting
recursion. SIGMOD Rec., 16 (3), 323330.
Cuenca Grau, B., Horrocks, I., Motik, B., Parsia, B., Patel-Schneider, P. F., & Sattler, U.
(2008). OWL 2: The next step for OWL. J. Web Sem., 6 (4), 309322.
De Giacomo, G., Lembo, D., Lenzerini, M., Poggi, A., Rosati, R., Ruzzi, M., & Savo, D. F.
(2012). MASTRO: A reasoner for effective Ontology-Based Data Access. In Horrocks,
I., Yatskevich, M., & Jimenez-Ruiz, E. (Eds.), ORE, Vol. 858 of CEUR Workshop
Proceedings. CEUR-WS.org.
Eiter, T., Ortiz, M., & Simkus, M. (2012a). Conjunctive query answering in the Description
Logic SH using knots. J. Comput. Syst. Sci., 78 (1), 4785.
Eiter, T., Ortiz, M., Simkus, M., Tran, T.-K., & Xiao, G. (2012b). Query rewriting for
Horn-SHIQ plus rules. In Hoffmann, J., & Selman, B. (Eds.), AAAI. AAAI Press.
Fan, W. (2012). Graph pattern matching revised for social network analysis. In Deutsch,
A. (Ed.), ICDT, pp. 821. ACM.
Geffert, V., Mereghetti, C., & Palano, B. (2010). More concise representation of regular
languages by automata and regular expressions. Information and computation, 208 (4),
385394.
Giese, M., Calvanese, D., Haase, P., Horrocks, I., Ioannidis, Y., Kllapi, H., Koubarakis, M.,
Lenzerini, M., Moller, R., Rodriguez-Muro, M., Ozcep, O., Rosati, R., Schlatte, R.,
Schmidt, M., Soylu, A., & Waaler, A. (2013). Scalable end-user access to big data. In
Akerkar, R. (Ed.), Big Data Computing. CRC Press.
Glimm, B., Lutz, C., Horrocks, I., & Sattler, U. (2008). Conjunctive query answering for
the Description Logic SHIQ. J. Artif. Intell. Res. (JAIR), 31, 157204.
Gottlob, G., Manna, M., & Pieris, A. (2014). Polynomial combined rewritings for existential
rules. In Proc. of the 14th Int. Conf. on the Principles of Knowledge Representation
and Reasoning (KR 2014). AAAI Press.
702

fiThe Complexity of Answering CQs and GXQs over OWL 2 EL KBs

Gottlob, G., & Schwentick, T. (2012). Rewriting ontological queries into small nonrecursive
datalog programs. In Brewka, G., Eiter, T., & McIlraith, S. A. (Eds.), Principles of
Knowledge Representation and Reasoning: Proceedings of the Thirteenth International
Conference, KR 2012, Rome, Italy, June 10-14, 2012. AAAI Press.
Grosof, B. N., Horrocks, I., Volz, R., & Decker, S. (2003). Description Logic Programs: Combining logic programs with Description Logic. In Proceedings of the 12th international
conference on World Wide Web, pp. 4857.
Gutierrez, C., Hurtado, C. A., Mendelzon, A. O., & Perez, J. (2011). Foundations of
semantic web databases. J. Comput. Syst. Sci., 77 (3), 520541.
Harel, D. (1984). Dynamic logic. In Gabbay, D., & Guenthner, F. (Eds.), Handbook of
Philosophical Logic Vol. II, pp. 497604. Reidel Publishing Company.
Harel, D., Tiuryn, J., & Kozen, D. (2000). Dynamic Logic. MIT Press, Cambridge, MA,
USA.
Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2003). Introduction to Automata Theory,
Languages, and Computation - international edition (2. ed). Addison-Wesley.
Horrocks, I., Kutz, O., & Sattler, U. (2006). The even more irresistible SROIQ. In Doherty,
P., Mylopoulos, J., & Welty, C. A. (Eds.), KR, pp. 5767. AAAI Press.
Horrocks, I., & Sattler, U. (2004). Decidability of SHIQ with complex role inclusion axioms.
Artificial Intelligence, 160 (12), 79104.
Johnson, D. S., & Klug, A. C. (1984). Testing containment of conjunctive queries under
functional and inclusion dependencies. J. Comput. Syst. Sci., 28 (1), 167189.
Kazakov, Y. (2008). RIQ and SROIQ are harder than SHOIQ. In Brewka, G., & Lang,
J. (Eds.), KR, pp. 274284. AAAI Press.
Kontchakov, R., Lutz, C., Toman, D., Wolter, F., & Zakharyaschev, M. (2011). The combined approach to Ontology-Based Data Access. In Walsh, T. (Ed.), IJCAI 2011,
Proceedings of the 22nd International Joint Conference on Artificial Intelligence,
Barcelona, Catalonia, Spain, July 16-22, 2011, pp. 26562661. IJCAI/AAAI.
Kostylev, E. V., Reutter, J. L., & Vrgoc, D. (2014). XPath for DL-Lite ontologies. In
Bienvenu, M., Ortiz, M., Rosati, R., & Simkus, M. (Eds.), Informal Proceedings of
the 27th International Workshop on Description Logics, Vienna, Austria, July 17-20,
2014., Vol. 1193 of CEUR Workshop Proceedings, pp. 258269. CEUR-WS.org.
Kozen, D. (1977). Lower bounds for natural proof systems. In FOCS, pp. 254266. IEEE
Computer Society.
Krotzsch, M. (2011). Efficient rule-based inferencing for OWL EL. In Walsh, T. (Ed.),
Proceedings of the 22nd International Joint Conference on Artificial Intelligence (IJCAI11). AAAI Press/IJCAI. 26682673.
Krotzsch, M., Rudolph, S., & Hitzler, P. (2007). Conjunctive queries for a tractable fragment
of OWL 1.1. In Aberer, K., Choi, K.-S., Noy, N., Allemang, D., Lee, K.-I., Nixon, L.,
Golbeck, J., Mika, P., Maynard, D., Mizoguchi, R., Schreiber, G., & Cudre-Mauroux,
P. (Eds.), Proceedings of the 6th International Semantic Web Conference (ISWC07),
Vol. 4825 of LNCS, pp. 310323. Springer.
703

fiStefanoni, Motik, Krotzsch, & Rudolph

Libkin, L., Martens, W., & Vrgoc, D. (2013). Querying graph databases with XPath. In
Tan, W.-C., Guerrini, G., Catania, B., & Gounaris, A. (Eds.), ICDT, pp. 129140.
ACM.
Lutz, C. (2008). The complexity of conjunctive query answering in expressive Description
Logics. In Automated Reasoning.
Lutz, C., Seylan, I., Toman, D., & Wolter, F. (2013). The combined approach to OBDA:
Taming role hierarchies using filters. In Alani, H., Kagal, L., Fokoue, A., Groth, P. T.,
Biemann, C., Parreira, J. X., Aroyo, L., Noy, N. F., Welty, C., & Janowicz, K. (Eds.),
International Semantic Web Conference (1), Vol. 8218 of Lecture Notes in Computer
Science, pp. 314330. Springer.
Lutz, C., Toman, D., & Wolter, F. (2009). Conjunctive query answering in the Description Logic EL using a relational database system. In Boutilier, C. (Ed.), IJCAI
2009, Proceedings of the 21st International Joint Conference on Artificial Intelligence,
Pasadena, California, USA, July 11-17, 2009, pp. 20702075.
Marnette, B. (2009). Generalized schema-mappings: From termination to tractability. In
Paredaens, J., & Su, J. (Eds.), PODS, pp. 1322. ACM.
Mora, J., Rosati, R., & Corcho, O. (2014). kyrie2: Query rewriting under extensional
constraints in ELHIO. In Mika, P., Tudorache, T., Bernstein, A., Welty, C., Knoblock,
C. A., Vrandecic, D., Groth, P. T., Noy, N. F., Janowicz, K., & Goble, C. A. (Eds.),
The Semantic Web - ISWC 2014 - 13th International Semantic Web Conference, Riva
del Garda, Italy, October 19-23, 2014. Proceedings, Part I, Vol. 8796 of Lecture Notes
in Computer Science, pp. 568583. Springer.
Ortiz, M., Calvanese, D., & Eiter, T. (2008). Data complexity of query answering in expressive Description Logics via tableaux. J. Autom. Reasoning, 41 (1), 6198.
Ortiz, M., Rudolph, S., & Simkus, M. (2011). Query answering in the Horn fragments of the
Description Logics SHOIQ and SROIQ. In Walsh, T. (Ed.), IJCAI 2011, Proceedings of the 22nd International Joint Conference on Artificial Intelligence, Barcelona,
Catalonia, Spain, July 16-22, 2011, pp. 10391044. IJCAI/AAAI.
Perez, J., Arenas, M., & Gutierrez, C. (2010). nSPARQL: A navigational language for RDF.
Web Semant., 8 (4), 255270.
Perez-Urbina, H., Motik, B., & Horrocks, I. (2010). Tractable query answering and rewriting
under Description Logic constraints. J. Applied Logic, 8 (2), 186209.
Rodriguez-Muro, M., & Calvanese, D. (2012). High performance query answering over
DL-Lite ontologies. In Brewka, G., Eiter, T., & McIlraith, S. A. (Eds.), Principles of
Knowledge Representation and Reasoning: Proceedings of the Thirteenth International
Conference, KR 2012, Rome, Italy, June 10-14, 2012. AAAI Press.
Rosati, R. (2007). On conjunctive query answering in EL. In Calvanese, D., Franconi, E.,
Haarslev, V., Lembo, D., Motik, B., Turhan, A.-Y., & Tessaris, S. (Eds.), Description
Logics, Vol. 250 of CEUR Workshop Proceedings. CEUR-WS.org.
Rudolph, S., & Glimm, B. (2010). Nominals, inverses, counting, and conjunctive queries or:
Why infinity is your friend!. J. Artif. Intell. Res. (JAIR), 39, 429481.
704

fiThe Complexity of Answering CQs and GXQs over OWL 2 EL KBs

Simanck, F. (2012). Elimination of complex rias without automata. In Kazakov, Y.,
Lembo, D., & Wolter, F. (Eds.), Proceedings of the 2012 International Workshop
on Description Logics, DL-2012, Rome, Italy, June 7-10, 2012, Vol. 846 of CEUR
Workshop Proceedings. CEUR-WS.org.
Sirin, E., Parsia, B., Cuenca Grau, B., Kalyanpur, A., & Katz, Y. (2007). Pellet: A practical
OWL-DL reasoner. J. Web Sem., 5 (2), 5153.
Stefanoni, G., Motik, B., & Horrocks, I. (2013). Introducing nominals to the combined
query answering approaches for EL. In desJardins, M., & Littman, M. L. (Eds.),
AAAI. AAAI Press.
ter Horst, H. J. (2005). Completeness, decidability and complexity of entailment for RDF
Schema and a semantic extension involving the OWL vocabulary. Web Semantics:
Science, Services and Agents on the World Wide Web, 3 (2-3), 79115.
Tsarkov, D., & Horrocks, I. (2006). FaCT++ Description Logic reasoner: System description. In Furbach, U., & Shankar, N. (Eds.), IJCAR, Vol. 4130 of Lecture Notes in
Computer Science, pp. 292297. Springer.
Urbani, J., van Harmelen, F., Schlobach, S., & Bal, H. E. (2011). QueryPIE: Backward
reasoning for OWL Horst over very large knowledge bases. In Aroyo, L., Welty, C.,
Alani, H., Taylor, J., Bernstein, A., Kagal, L., Noy, N. F., & Blomqvist, E. (Eds.),
International Semantic Web Conference (1), Vol. 7031 of Lecture Notes in Computer
Science, pp. 730745. Springer.
Vardi, M. Y. (1982). The complexity of relational query languages (extended abstract). In
Proceedings of the fourteenth annual ACM symposium on Theory of computing, STOC
82, pp. 137146, New York, NY, USA. ACM.
Venetis, T., Stoilos, G., & Stamou, G. B. (2012). Incremental query rewriting for OWL 2 QL.
In Kazakov, Y., Lembo, D., & Wolter, F. (Eds.), Proceedings of the 2012 International
Workshop on Description Logics, DL-2012, Rome, Italy, June 7-10, 2012, Vol. 846 of
CEUR Workshop Proceedings. CEUR-WS.org.
Virgilio, R. D., Orsi, G., Tanca, L., & Torlone, R. (2012). NYAYA: A system supporting the
uniform management of large sets of semantic data. In Kementsietsidis, A., & Salles,
M. A. V. (Eds.), IEEE 28th International Conference on Data Engineering (ICDE
2012), Washington, DC, USA (Arlington, Virginia), 1-5 April, 2012, pp. 13091312.
IEEE Computer Society.
Wessel, M. (2001). Obstacles on the Way to Qualitative Spatial Reasoning with Description
Logics: Some Undecidability Results. In Working Notes of the 2001 International
Description Logics Workshop (DL-2001), Vol. 49. CEUR-WS.org.

705

fi