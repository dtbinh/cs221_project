Journal of Artificial Intelligence Research 51 (2014) 555-577

Submitted 05/14; published 11/14

Iterative Plan Construction for the Workflow Satisfiability Problem
David Cohen
Jason Crampton
Andrei Gagarin
Gregory Gutin
Mark Jones

D.C OHEN @ RHUL . AC . UK
JASON .C RAMPTON @ RHUL . AC . UK
A NDREI .G AGARIN @ RHUL . AC . UK
G.G UTIN @ RHUL . AC . UK
M ARK .J ONES @ RHUL . AC . UK

Royal Holloway, University of London, UK

Abstract
The Workflow Satisfiability Problem (WSP) is a problem of practical interest that arises whenever tasks need to be performed by authorized users, subject to constraints defined by business
rules. We are required to decide whether there exists a plan  an assignment of tasks to authorized
users  such that all constraints are satisfied. It is natural to see the WSP as a subclass of the
Constraint Satisfaction Problem (CSP) in which the variables are tasks and the domain is the set
of users. What makes the WSP distinctive is that the number of tasks is usually very small compared to the number of users, so it is appropriate to ask for which constraint languages the WSP is
fixed-parameter tractable (FPT), parameterized by the number of tasks.
This novel approach to the WSP, using techniques from CSP, has enabled us to design a generic
algorithm which is FPT for several families of workflow constraints considered in the literature.
Furthermore, we prove that the union of FPT languages remains FPT if they satisfy a simple compatibility condition. Lastly, we identify a new FPT constraint language, user-independent constraints, that includes many of the constraints of interest in business processing systems. We
demonstrate that our generic algorithm has provably optimal running time O (2k log k ), for this
language, where k is the number of tasks.

1. Introduction
A workflow formalises a business process. It is a collection of interrelated tasks that are performed
by users in order to achieve some objective. In many situations, we wish to restrict the users that
can perform certain tasks. In particular, we may wish to specify lists of users who are authorized to
perform each of the workflow tasks. Additionally, we may wish  either because of the particular
requirements of the business logic or security requirements  to prevent certain combinations of
users from performing particular combinations of tasks (Crampton, 2005). Such constraints include
separation-of-duty (also known as the two-man rule), which may be used to prevent sensitive
combinations of tasks being performed by a single user, and binding-of-duty, which requires that a
particular combination of tasks is executed by the same user. The use of constraints in workflow
management systems to enforce security policies has been studied extensively in the last fifteen
years; for example see the work of Bertino, Ferrari, and Atluri (1999), Crampton (2005) or Wang
and Li (2010).
1.1 The Workflow Satisfiability Problem
It is possible that the combination of constraints and authorization lists is unsatisfiable, in the
sense that there does not exist an assignment of users to tasks such that all contraints are satisfied
c
2014
AI Access Foundation. All rights reserved.

fiC OHEN , C RAMPTON , G AGARIN , G UTIN , & J ONES

and every task is performed by an authorized user; perhaps the minimal example being a requirement
that two tasks are performed by the same user but the intersection of the authorization lists for these
tasks is empty. A plan that satisfies all constraints and allocates an authorized user to each task is said
to be valid. The Workflow Satisfiability Problem (WSP) takes a workflow specification as input
and returns a valid plan if one exists and a null value otherwise. It is important to determine whether
a business process is satisfiable or not, since an unsatisfiable one can never be completed without
violating the security policy encoded by the constraints and authorization lists. Wang and Li (2010)
have shown, by a reduction from G RAPH C OLORING, that the WSP is an NP-hard subclass of the
CSP, even when we only consider binary separation-of-duty constraints. Nevertheless, for practical
applications of the WSP, we require a solving algorithm that is as efficient as possible (Crampton &
Gutin, 2013, 2.2).
Many hard problems become less complex if some natural parameter of the instance is bounded.
Hence, we say a problem with input size n and parameter k is fixed-parameter tractable (FPT) if it
admits an algorithm with running time O(f (k)nd ), where d is a constant independent of n and k,
and f is a computable function depending only on k.1
Wang and Li (2010) were the first to observe that fixed-parameter algorithmics is an appropriate
way to study the WSP, because the number of tasks is usually small and often much smaller than the
number of users. (The literature does not directly support this assumption, although a widely-cited
study, Schaad, Moffett, & Jacob, 2001, found that the number of users exceeds that of job functions,
or roles, by a multiplicative factor of around 25; this finding has been confirmed by a recent followup study, Jayaraman, Ganesh, Tripunitara, Rinard, & Chapin, 2011. A workflow specification will
usually be concerned with a particular business objective and involve a small number of roles.
Taking roles as a proxy for tasks, it seems reasonable to assume that the number of users will be an
order of magnitude greater than the number of tasks.) We believe, therefore, that it is appropriate to
extend the work initiated by Wang and Li on the use of fixed parameter algorithms for solving the
WSP parameterized by the number of tasks, and, in particular, to ask which constraint languages
are fixed parameter tractable.
Wang and Li (2010) proved that, in general, the WSP is W[1]-hard and thus is highly unlikely
to admit a fixed-parameter algorithm. They also showed that the WSP is FPT if we consider only
separation-of-duty and binding-of-duty constraints. Crampton, Gutin, and Yeo (2013) obtained significantly faster fixed-parameter algorithms that were applicable to regular constraints, thereby
including the cases shown to be FPT by Wang and Li. This work, and other recent research, has
demonstrated the existence of fixed-parameter algorithms for the WSP in the presence of other constraint types (Crampton, Crowston, Gutin, Jones, & Ramanujan, 2013; Crampton & Gutin, 2013).
We define the WSP formally and introduce a number of different constraint types, including regular
constraints, in Section 2.
We will use the O notation, which suppresses polynomial factors.
That is,
g(n, k, m) = O (h(n, k, m)) if there exists a polynomial q(n, k, m) such that g(n, k, m) =
O(q(n, k, m)h(n, k, m)). In particular, an FPT algorithm is one that runs in time O (f (k)) for
some computable function f depending only on k.

1. An introduction to fixed-parameter algorithms and complexity can be found in, for example, the books by Downey
and Fellows (2013), or Niedermeier (Niedermeier, 2006).

556

fiI TERATIVE P LAN C ONSTRUCTION FOR THE W ORKFLOW S ATISFIABILITY P ROBLEM

1.2 The Relation Between the WSP and the CSP
The Constraint Satisfaction Problem (CSP) is a general paradigm for expressing, in a declarative
format, problems where variables are to be assigned values from some domain. The assignments
are constrained by restricting the allowed simultaneous assignments to some sets of variables. This
model is useful in many application areas including planning, scheduling, frequency assignment and
circuit verification (Rossi, van Beek, & Walsh, 2006). The CSP community is a well-established
research community dedicated to finding effective solution techniques for the CSP (Dechter, 2003).
The CSP is NP-hard, even when only binary not-equals constraints are allowed and the domain
has three elements, as we can reduce G RAPH 3-C OLORING to the CSP. 2 Hence, a considerable
effort has been made to understand the effect of restricting the type of allowed constraints. Recently there has been significant progress towards the completion of this research program and
there is now strong evidence to support the algebraic dichotomy conjecture of Bulatov, Jeavons
and Krokhin (2005), characterising precisely which kinds of constraint language lead to polynomial
solvability.
It is worth noting that the WSP is a subclass of the CSP where for each variable s (called a task
in WSP terminology) we have an arbitrary unary constraint (called an authorization) that assigns
possible values (called users) for s; this is called the conservative CSP. Note, however, that while
usually in CSP the number of variables is much larger than the number of values, for the WSP the
number of tasks is usually much smaller than the number of users. It is important to remember that
for the WSP we do not use the term constraint for authorizations and so when we define special
types of constraints, we do not extend these types to authorizations, which remain arbitrary.
1.3 Outline of the Paper
Our novel approach to the WSP using techniques for the CSP, characterising types of constraints
as constraint languages with particular characteristics, enables us to generalise and unify existing
algorithms. So, in this paper, for the first time, rather than considering algorithms for specific
constraints, we design a generic algorithm which is a fixed-parameter algorithm for several families
of workflow constraints considered in the literature. In particular we introduce the notions of userindependent constraints, which subsume a number of well-studied constraint types from the WSP
literature, including the regular constraints studied by Crampton et al. (2013).
Our generic algorithm builds plans incrementally, discarding partial plans that can never satisfy
the constraints. It is based on a naive algorithm, presented in Section 2.2. This naive algorithm
stores far more information than is required to solve the WSP, so its running time is no better than
exhaustively searching for a valid plan.
Our generic algorithm uses a general and classic paradigm: retain as little information as possible in every step of the algorithm. This paradigm is used in such classical polynomial-time algorithms as Gaussian elimination for solving systems of linear equations and constraint propagation
algorithms (used, for example, to solve 2SAT in polynomial time). Our generic algorithm uses
this paradigm in a problem-specific way, based on the concepts of extension-equivalence, planindistinguishability and patterns, enabling us to retain a single pattern for each equivalence class of
indistinguishable plans. Extension-equivalence and plan encodings are described in Section 3. The
way the solution is constructed by our algorithm is quite unusual because the accumulation of the
2. Wang and Lis NP-hardness result for the WSP is thus a restatement of this well-known result for CSP.

557

fiC OHEN , C RAMPTON , G AGARIN , G UTIN , & J ONES

(representatives of) set of solutions goes along the users (i.e., values for CSP), not along the tasks
(i.e., variables for CSP).
To analyze the running time of our algorithm we introduce the notion of diversity (see Definition 6). This notion is reminiscent of pathwidth (measures are taken over all prefixes and the largest
outcome is the diversity) with the difference that the diversity is based on the number of equivalence classes, hiding the actual structure behind the scenes. This approach might also be useful for
structural analysis of hypergraphs.
In Section 4, we describe our pattern-based algorithm and demonstrate that it is a fixedparameter algorithm for the WSP with user-independent constraints. We show the running time
of our algorithm is O (2k log k ) for the WSP with user-independent constraints and that there is
no algorithm of running time O (2o(k log k) ) for the WSP with user-independent constraints unless
the Exponential Time Hypothesis3 (ETH) fails. Thus, unlike the WSP with regular constraints
(and problems studied by Bodlaender, Cygan, Kratsch, & Nederlof, 2013; Fomin, Lokshtanov, &
Saurabh, 2014), the WSP with user-independent constraints is highly unlikely to admit an algorithm
of running time O (2O(k) ). To show that our generic algorithm is of interest for constraints other
than user-independent, we prove that the generic algorithm is a single-exponential algorithm for a
constraint language obtained by an equivalence relation on the set of users.
In Section 5 we show how our generic algorithm can deal with unions of constraint languages.
This leads to a generalisation of our result for user-independent constraints. In Section 6 we discuss
the results of computational experiments using an implementation of our algorithm (discussed in
full detail in the work of Cohen, Crampton, Gagarin, Gutin, & Jones, 2014). A brief conclusion is
given in in Section 7.

2. Background
We define a workflow schema to be a tuple (S, U, A, C), where S is the set of tasks in the workflow,
U is the set of users, A = {A(s) : s  S}, where A(s)  U is the authorization list for task s, and
C is a set of workflow constraints. A workflow constraint is a pair c = (L, ), where L  S and 
is a set of functions from L to U : L is the scope of the constraint;  specifies those assignments of
elements of U to elements of L that satisfy the constraint c.
Given T  S and X  U , a plan is a function  : T  X. Given a workflow constraint (L, ),
T  S and X  U , a plan  : T  X satisfies (L, ) if either L \ T 6=  or |L =  for some
  . A plan  : T  X is eligible if  satisfies every constraint in C. A plan  : T  X is
authorized if (s)  A(s) for all s  T . A plan is valid if it is both authorized and eligible. A plan
 : S  U is called a complete plan. An algorithm to solve the WSP takes a workflow schema
(S, U, A, C) as input and outputs a valid, complete plan, if one exists (and null, otherwise).
As a running example, consider the following instance of the WSP.
Instance 1. The task set S = {s1 , . . . , s4 } and the user set U = {u1 , . . . , u6 }. The authorization
lists are as follows (where a tick indicates that the given user is authorized for the given task):
3. The Exponential Time Hypothesis claims there is no algorithm of running time O (2o(n) ) for 3SAT on n variables (Impagliazzo, Paturi, & Zane, 2001).

558

fiI TERATIVE P LAN C ONSTRUCTION FOR THE W ORKFLOW S ATISFIABILITY P ROBLEM

s1
s2
s3
s4

u1
4

u2
4
4
4
4

u3

u4

u5

u6

4
4

4
4

4
4

4

The constraints are as follows: s1 and s2 must be assigned to the same user; s2 and s3 must
be assigned to different users; s3 and s4 must be assigned to different users; s1 and s4 must be
assigned to different users.
Example 1 illustrates the meanings of eligible, complete and authorised plans in the context of
Instance 1.
Example 1. The following table gives assignments for four plans, 1 , 2 , 3 , 4 :

1
2
3
4

s1
u1
u1
u1
u2

s2
u2
u1
u2

s3
u4
u4
u4
u4

s4
u5
u5
u5
u5

Authorized
4
4
4

Eligible
4
4
4

Complete
4
4
4

 1 is a complete plan which is authorized but not eligible, as s1 and s2 are assigned to
different users.
 2 is a complete plan which is eligible but not authorized, as u1 is not authorized for s2 .
 3 is a plan which is authorized and eligible, and therefore valid. However, 3 is not a
complete plan as there is no assignment for s2 .
 4 is a complete plan which is eligible and authorized. Thus 4 is a valid complete plan, and
is therefore a solution.
For an algorithm that runs on an instance (S, U, A, C) of the WSP, we will measure the running
time in terms of n = |U |, k = |S|, and m = |C|. (The set A of authorization lists consists of k
lists each of size at most n, so we do not need to consider the size of A separately when measuring
the running time.) We will say an algorithm runs in polynomial time if it has running time at most
p(n, k, m), where p(n, k, m) is polynomial in n, k and m.
2.1 WSP Constraints
In this paper we are interested in the complexity of the WSP when the workflow constraint language
(the set of permissible workflow constraints) is restricted. In this section we introduce the constraint
types of interest. All of them have practical applications for real world workflows.
We assume that all constraints and authorizations can be checked in polynomial time. This
means that it takes polynomial time to check whether any plan is authorized, eligible and valid.
The correctness of our algorithm is unaffected by this assumption, but choosing constraints not
checkable in polynomial time would naturally affect the running time.
559

fiC OHEN , C RAMPTON , G AGARIN , G UTIN , & J ONES

2.1.1 C ONSTRAINTS D EFINED BY A B INARY R ELATION
Constraints on two tasks, s and s0 , can be represented in the form (s, s0 , ), where  is a binary
relation on U (Crampton, 2005). A plan  satisfies such a constraint if (s)  (s0 ). Writing
= to denote the relation {(u, u) : u  U } and 6= to denote the relation {(u, v) : u, v  U, u 6= v},
separation-of-duty and binding-of-duty constraints may be represented in the form (s, s0 , 6=) and
(s, s0 , =), respectively. Crampton et al. (2013) considered constraints for which  is  or , where
 is an equivalence relation defined on U . A practical example of such workflow constraints is
when the equivalence relation partitions the users into different departments: constraints could then
enforce that two tasks be performed by members of the same department. Constraints that are not
restricted to singleton tasks have also been considered (Crampton et al., 2013; Wang & Li, 2010): a
plan  satisfies a constraint of the form (S 0 , S 00 , ) if there are tasks s0  S 0 and s00  S 00 such that
(s0 )  (s00 ).
2.1.2 C ARDINALITY C ONSTRAINTS
A tasks-per-user counting constraint has the form (t` , tr , T ), where 1 6 t` 6 tr 6 k and T  S. A
plan  satisfies (t` , tr , T ) if a user performs either no tasks in T or between t` and tr tasks. Tasksper-user counting constraints generalize the cardinality constraints which have been widely adopted
by the WSP community (American National Standards Institute, 2004; Bertino, Bonatti, & Ferrari,
2001; Joshi, Bertino, Latif, & Ghafoor, 2005; Sandhu, Coyne, Feinstein, & Youman, 1996).
2.1.3 R EGULAR C ONSTRAINTS
We say that C is regular if it satisfies the following condition: If a partition S1 , . . . , Sp of S is such
1
that for every
Sp i  [p] there exists an eligible complete plan  and user u with  (u) = Si , then
the plan i=1 (Si  ui ), where all ui s are distinct, is eligible. Regular constraints extend the set
of constraints considered by Wang and Li (2010). Crampton et al. (2013) show that the following
constraints are regular: (S 0 , S 00 , 6=); (S 0 , S 00 , =), where at least one of the sets S 0 , S 00 is a singleton;
tasks-per-user counting constraints of the form (t` , tr , T ), where t` = 1.
2.1.4 U SER -I NDEPENDENT C ONSTRAINTS
Many business rules are not concerned with the identities of the users that complete a set of tasks;
they are only concerned with the relationships between those users. Accordingly, we say a constraint (L, ) is user-independent if whenever    and  : U  U is a permutation, then
    . The most obvious example of a user-independent constraint is the requirement that two
tasks are performed by different users (separation-of-duty). As a more complex example suppose
that at most/at least/exactly p users are required to complete some sensitive set of tasks (cardinality
constraints), where p is usually small, i.e., 1, 2, 3 or so. There is a substantial literature on constraints as a method for specifying and enforcing business rules (for example, Gligor, Gavrila, &
Ferraiolo, 1998; Simon & Zurko, 1997), including work by researchers at SAP and IBM (for example, Basin, Burri, & Karjoth, 2014; Wolter & Schaad, 2007). The most widely studied constraints
are cardinality constraints and separation-of-duty, which form part of the ANSI standard on rolebased access control (American National Standards Institute, 2004), developed by the US National
Institute of Standards and Technology (NIST). In short, the literature and relevant standards suggest that user-independent constraints are those of most interest in business processes and workflow
560

fiI TERATIVE P LAN C ONSTRUCTION FOR THE W ORKFLOW S ATISFIABILITY P ROBLEM

management systems. Our definition of user-independent includes all the constraints defined in the
ANSI RBAC standard and many more.
Every regular constraint is user-independent, but many user-independent constraints are not
regular. Indeed, constraints of the type (S 0 , S 00 , =) are user-independent, but not necessarily
regular (Crampton et al., 2013). Many counting constraints in the Global Constraint Catalogue (Beldiceanu, Carlsson, & Rampon, 2012) are user-independent, but not regular. In particular, the constraint NVALUE, which bounds from above the number of users performing a set of
tasks, is user-independent but not regular. Note, however, that constraints of the form (s0 , s00 , )
and (s0 , s00 , 6) are not user-independent in general.
It is important to note that authorization lists, which are fundamental to any access control
system, when viewed as unary constraints, are certainly not user-independent. It is the presence of
both user-independent constraints and authorization lists in a workflow specification that makes the
WSP challenging.
2.2 A Naive Algorithm
The main aim of this section is to present a simple algorithm (Algorithm 1) which will solve any
instance of the WSP. The running time of the algorithm is slightly worse than a brute-force algorithm, but the algorithms basic structure provides a starting point from which to develop a more
efficient algorithm.
We need to introduce some additional notation and terminology.
Let  : T  X be a plan for some T  S, X  U . Then let TASK() = T and U SER() = X.
It is important for our generic algorithm that TASK() and U SER() are given as explicit parts of .
In particular, the set U SER() may be different from the set of users assigned to a task by . That is,
a user u can be in U SER() without there being a task s such that (s) = u. It is worth observing
that TASK() may be empty (because  may not allocate any tasks to users in X). For any T  S
and u  U , (T  u) denotes the plan  : T  {u} such that (s) = u for all s  T .
Two functions f1 : D1  E1 and f2 : D2  E2 are disjoint if D1  D2 = E1  E2 = . The
union of two disjoint functions f1 : D1  E1 , f2 : D2  E2 is a function f = f1  f2 such that
f : D1  D2  E1  E2 and f (d) = fi (d) for each d  Di , where i  {1, 2}. Let g : D  E
and h : E  F be functions. Then h  g denotes the composite function from D to F such that
h  g(d) = h(g(d)) for each d  D. For an integer p > 0, the set [p] = {1, 2, . . . , p}.
Proposition 1. Let (S, U, A, C) be an instance of the WSP, with n = |U |, k = |S| and m = |C|.
Then (S, U, A, C) can be solved in time O ((n + 1)k ) by Algorithm 1.
Proof. Let u1 , . . . , un be an ordering of U , and let Ui = {u1 , . . . , ui } for each i  [n]. For each
i  [n] in turn, we will construct the set i of all plans  such that U SER() = Ui and  is valid.
If the set n contains no plan  with TASK() = S, then (S, U, A, C) has no solution; otherwise,
any such plan is a solution for (S, U, A, C).
Algorithm 1 shows how to construct the sets i . It is not hard to verify that i contains exactly
every valid plan  with U SER() = Ui , for each i. This implies the correctness of our algorithm. It
remains to analyse the running time.
For each i  [n] and each T  S, there are at most i|T | valid plans  with U SER() =
Ui , TASK() = T . To construct 1 , we need to consider all plans  with U SER() = U1 , and there
are exactly 2k such plans. For each plan we can decide in polynomial time whether to add it to 1 .
561

fiC OHEN , C RAMPTON , G AGARIN , G UTIN , & J ONES

Algorithm 1: Naive solution procedure for the WSP
input : An instance (S, U, A, C) of the WSP
1 Construct an ordering u1 , . . . , un of U ;
2 Set 1 = ;
3 foreach T  S do
4
Set  = (T  u1 );
5
if  is eligible and u1  A(s) for all s  T then
6
Set 1 = 1  {};
7
end
8 end
9 Set i = 1;
10 while i < n do
11
Set i+1 = ;
12
foreach  0  i do
13
foreach T  S \ TASK( 0 ) do
14
if ui+1  A(s) for all s  T then
15
Set  =  0  (T  ui+1 );
16
if  is eligible then
17
Set i+1 = i+1  {};
18
end
19
end
20
end
21
end
22
Set i = i + 1;
23 end
24 foreach   n do
25
if TASK() = S then
26
return ;
27
end
28 end
29 return NULL ;

To construct i+1 for each i  [n  1], we need to consider every pair ( 0 , T ) where  0  i and
T  S \ TASK( 0 ). Consider the pair ( 0 , T ), where  0 is an (S 0 , Ui )-plan for some S 0  S, and
0
0
T  S \ S 0 . Thus there are i|S | possibilities
for  0 , and there
are 2|S||S | choices for T . Thus,
P
P
0
0
k
k
the total number of pairs is given by S 0 S i|S | 2|S||S | = j=0 j ij 2kj = (i + 2)k . For each
pair ( 0 , T ) we can decide whether
to add  0  (T  ui+1 ) to i+1 in polynomial time. Thus, to
P
k

k

k
construct all i takes time O ( n1
i=0 (i + 2) ) = O (n(n + 1) ) = O ((n + 1) ).

Algorithm 1 is inefficient even for small k, due to the fact that each i contains all valid plans
with U SER( 0 ) = {u1 , . . . , ui }. We show in the next section that it is not necessary to store so
much information to solve the WSP.

0

562

fiI TERATIVE P LAN C ONSTRUCTION FOR THE W ORKFLOW S ATISFIABILITY P ROBLEM

3. Plan-Indistinguishability Relations
We first introduce the notion of extension-equivalence, defined by an equivalence relation on the set
of all plans. Informally, the relation enables us to keep a single member of each equivalence class
when building plans incrementally.
Definition 1. Given an instance (S, U, A, C) of the WSP, and two eligible plans 1 and 2 , define
1  2 if the following conditions hold:
1. U SER(1 ) = U SER(2 ) and TASK(1 ) = TASK(2 );
2. 1   0 is eligible if and only if 2   0 is eligible, for any plan  0 disjoint from 1 and 2 .
Then  is an equivalence relation on the set of eligible plans, and we say 1 and 2 are extensionequivalent if 1  2 .
Example 2. Consider Instance 1.
Let 1 : {s3 , s4 }  {u2 , u4 } be the function such that 1 (s3 ) = u2 and 1 (s4 ) = u4 . Let
2 : {s3 , s4 }  {u2 , u4 } be the function such that 2 (s3 ) = u4 and 2 (s4 ) = u2 .
The plans 1 and 2 are both eligible, and U SER(1 ) = U SER(2 ) and TASK(1 ) =
TASK(2 ). For any plan  0 disjoint from 1 and 2 , the plan 1   0 will satisfy the constraints
(s2 , s3 , 6=), (s1 , s4 , 6=). Thus 1   0 is eligible if and only if  0 is eligible. Similarly, 2   0 is
eligible if and only if  0 is eligible. Thus 1   0 is eligible if and only if 2   0 is eligible, and so
1 and 2 are extension-equivalent.
Suppose that we had a polynomial time algorithm to check whether two eligible plans are
extension-equivalent. Then in Algorithm 1, we could keep track of just one plan from each equivalence class: when constructing i , we will only add 2 to i if there is no 1 extension-equivalent
to 2 already in i ; when we construct i+1 , we may use 1 as a proxy for 2 . If the number of
extension-equivalent classes is small compared to the number of plans, then the worst-case running
time of the algorithm may be substantially lower than that of Algorithm 1.
Unfortunately, it is not necessarily easy to decide if two eligible plans are extension-equivalent,
so this approach is not practical. However, we can always refine4 extension-equivalence to an equivalence relation for which equivalence is easy to determine. For example, the identity equivalence
relation where each plan is only equivalent to itself is such a refinement.
This refined equivalence relation may have more equivalence classes than extensionequivalence, but substantially fewer than the identity relation, so we may obtain a better running
time than the naive algorithm.
Definition 2. Given an instance (S, U, A, C) of the WSP, let  be the set of all eligible plans
and let  be an equivalence relation refining extension-equivalence on . We say  is a planindistinguishability relation (with respect to C) if, for all eligible 1 , 2 such that 1  2 , and for
any plan  0 disjoint from 1 and 2 such that 1   0 is eligible, we have that 1   0  2   0 .
Example 3. Let  be the identity relation on plans. That is, 1  2 if and only if U SER(1 ) =
U SER(2 ), TASK(1 ) = TASK(2 ), and 1 (s) = 2 (s) for all s  U SER(1 ). Then  is a
4. An equivalence relation 2 is a refinement of an equivalence relation 1 if every equivalence class of 2 is a subset
of some equivalence class of 1 .

563

fiC OHEN , C RAMPTON , G AGARIN , G UTIN , & J ONES

plan-indistinguishability relation. This shows that not every plan-indistinguishability relation is the
extension-equivalence relation. Indeed, the plans given in Example 2 are extension-equivalent but
not identical.
Recall that we refined extension-equivalence since it may be hard to determine whether two
eligible plans are extension-equivalent. It is therefore natural to assume the following:
Assumption 1. Given a plan-indistinguishability relation , it takes polynomial time to check
whether two eligible plans are equivalent under .
The correctness of our algorithms does not depend on this assumption. However, a poor choice
of the plan-indistinguishability relation could affect the running times.
We now describe appropriate plan-indistinguishability relations for the constraints that we will
be using. In each case determining if two eligible plans are equivalent under  will take polynomial
time.
3.1 Plan-Indistinguishability Relation for User-Independent Constraints
Lemma 1. Suppose all constraints are user-independent, and let ui be a relation such that 1 ui
2 if and only if
1. U SER(1 ) = U SER(2 ) and TASK(1 ) = TASK(2 );
2. For all s, t  TASK(1 ), 1 (s) = 1 (t) if and only if 2 (s) = 2 (t).
Then ui is a plan-indistinguishability relation on the set of eligible plans.
Proof. By definition of user-independent constraints, if  is an eligible plan and  : U  U is
a permutation, then    is also eligible. Suppose that 1 ui 2 , and let T = TASK(1 ) and
X = U SER(1 ). Let  0 : 1 (T )  2 (T ) be a function such that  0 (1 (t)) = 2 (t) for any
task t. Let  00 : X \ 1 (T )  X \ 2 (T ) be an arbitrary bijection (note that |1 (T )| = |2 (T )| by
Condition 2 of ui ). Let  =  0   00 . Then  is a permutation such that 2 =   1 . Thus 1 is
eligible if and only if 2 is eligible.
Now consider two eligible plans 1 , 2 such that 1 ui 2 , and a plan  0 disjoint from 1 and
2 . First we show that 1   0 ui 2   0 . It is clear that U SER(1   0 ) = U SER(2   0 ) and
TASK(1   0 ) = TASK(2   0 ). Now for any s, t  U SER(1   0 ), if (1   0 )(s) = (1   0 )(t),
then either s, t are both in TASK( 0 ), in which case (2   0 )(s) = (2   0 )(t) trivially, or s, t
are both in TASK(1 ), in which case 2 (s) = 2 (t) since 1 ui 2 , and hence (2   0 )(s) =
(2   0 )(t). Thus if (1   0 )(s) = (1   0 )(t) then (2   0 )(s) = (2   0 )(t) and, by a similar
argument, the converse holds. Thus 1   0 ui 2   0 . Furthermore, it follows by the argument
in the first paragraph that 1   0 is eligible if and only if 2   0 is eligible. Thus, the condition of
Definition 2 and the second condition of Definition 1 hold.
The first condition of ui trivially satisfies the first condition of Definition 1. Thus, ui satisfies
all the conditions of a plan-indistinguishability relation.
Example 4. Consider an instance of the WSP with users u1 , . . . u6 and tasks s1 , . . . , s6 in which
all constraints are user-independent. Let ui be the plan-indistinguishability relation given by
Lemma 1. Let c1 be the constraint with scope {s2 , s3 , s4 , s5 } such that c1 is satisfied if and only if
an even number of users are assigned to tasks in {s2 , s3 , s4 , s5 }. Let c2 be the constraint with scope
564

fiI TERATIVE P LAN C ONSTRUCTION FOR THE W ORKFLOW S ATISFIABILITY P ROBLEM

{s1 , s3 , s4 , s6 } such that c2 is satisfied if and only if either s1 and s3 are assigned to different users,
or s4 and s6 are assigned to different users. Suppose that c1 and c2 are the only constraints whose
scope contains tasks from both {s1 , s2 , s3 } and {s4 , s5 , s6 }.
Now consider the plans 1 , 2 : {s1 , s2 , s3 }  {u1 , u2 , u3 , u4 } such that 1 (s1 ) =
u1 , 1 (s2 ) = u2 , 1 (s3 ) = u1 , and 2 (s1 ) = u3 , 2 (s2 ) = u4 , 2 (s3 ) = u3 , and suppose that
1 , 2 are both eligible. Then 1 and 2 are equivalent under ui .
Observe that for any plan  0 disjoint from 1 and 2 , 1   0 is eligible if and only if 2   0
is eligible. As 1 and 2 both assign two users to {s2 , s3 },  0 must assign two users to {s4 , s5 } in
order to satisfy c1 . As 1 and 2 both assign s1 and s3 to the same user,  0 must assign s4 and s5
to different users in order to satisfy c2 . As long as these conditions are satisfied, and  0 satisfies all
constraints with scope in {s4 , s5 , s6 }, then 1   0 and 2   0 will both be eligible.
3.2 Plan-Indistinguishability Relation for Equivalence Relation Constraints
Recall that given a binary relation  on U , a constraint of the form (si , sj , ) is satisfied by a plan 
if (si )  (sj ). Recall that such constraints are not user-independent in general.
Lemma 2. Suppose  is an equivalence relation on U . Let V1 , . . . , Vl be the equivalence classes
of  over U . Suppose all constraints are of the form (si , sj , ) or (si , sj , 6). Let e be a relation
such that 1 e 2 if and only if
1. U SER(1 ) = U SER(2 ) and TASK(1 ) = TASK(2 );
2. For all equivalence classes Vj such that Vj  U SER(1 ) 6=  and Vj \ U SER(1 ) 6= , we
have that for all s  TASK(1 ), 1 (s)  Vj if and only if 2 (s)  Vj .
Then e is a plan-indistinguishability relation.
Proof. It is clear that e satisfies the first condition of Definition 1. Now suppose 1 , 2 are eligible
plans such that 1 e 2 , and let  0 be a plan disjoint from 1 and 2 . We first show that 1   0 is
eligible if and only if 2   0 is eligible.
Suppose that 1  0 is eligible. Consider two tasks t, t0  TASK(2  0 ). If {t, t0 }  TASK( 0 ),
then 2   0 will not falsify any constraint on t and t0 since it is equal to 1   0 when restricted to
{t, t0 } and 1   0 is eligible. If {t, t0 }  TASK(2 ), then 2   0 will not break any constraints
since 2 is eligible.
So we may assume that t  TASK(2 ), t0  TASK( 0 ). By definition, (2  0 )(t)  (2  0 )(t0 )
if and only if there exists j  [l] such that 2 (t),  0 (t0 )  Vj . Then Vj  U SER(2 ) 6=  and
Vj \ U SER(2 ) 6= . Therefore, by definition of e , 1 (s)  Vj if and only if 2 (s)  Vj , for all
s  TASK(1 ). In particular, 1 (t)  Vj , and so (1  0 )(t)  (1  0 )(t0 ). By a similar argument,
if (1   0 )(t)  (1   0 )(t0 ) then (2   0 )(t)  (2   0 )(t0 ). Therefore, every constraint is
satisfied by (1   0 ) if and only if it is satisfied by (2   0 ). Therefore if 1   0 is eligible then
so is 2   0 , and by a similar argument the converse holds.
It remains to show that 1   0 e 2   0 . It is clear that the user and task sets are the same.
As they have the same user set, the sets {Vj : Vj  U SER(1   0 ) 6= , Vj \ U SER(1   0 ) 6= }
and {Vj : Vj  U SER(2   0 ) 6= , Vj \ U SER(2   0 ) 6= } are the same. Furthermore, for each
Vj in this set and any s  TASK(1   0 ), if (1   0 )(s)  Vj then (2   0 )(s)  Vj , as either
s  TASK(1 ), in which case Vj  U SER(1 ) 6= , Vj \ U SER(1 ) 6=  and so 2 (s)  Vj , or
565

fiC OHEN , C RAMPTON , G AGARIN , G UTIN , & J ONES

s  TASK( 0 ), in which case (2   0 )(s) =  0 (s) = (1   0 )(s). By a similar argument, if
(2   0 )(s)  Vj , then (1   0 )(s)  Vj . Thus 1   0 e 2   0 .
Example 5. Let  be an equivalence relation on users with equivalence classes
{u1 }, {u2 }, {u3 , u4 , u5 }, {u6 , u7 , u8 }. Consider an instance of the WSP with users u1 , . . . , u8
and tasks s1 , . . . , s6 in which all constraints are of the form (si , sj , ) or (si , sj , 6). Let e be the
plan-indistinguishability relation given by Lemma 2. Suppose that the only constraints whose scope
contains tasks from both {s1 , s2 , s3 } and {s4 , s5 , s6 } are the constraints (s1 , s5 , 6), (s2 , s5 , ) and
(s2 , s6 , 6).
Now consider the plans 1 , 2 : {s1 , s2 , s3 }  {u1 , u2 , u3 , u4 } such that 1 (s1 ) =
u1 , 1 (s2 ) = u3 , 1 (s3 ) = u3 , and 2 (s1 ) = u2 , 2 (s2 ) = u3 , 2 (s3 ) = u4 , and suppose that
1 , 2 are both eligible. Then 1 and 2 are equivalent under e .
Observe that for any plan  0 disjoint from 1 and 2 , 1   0 is eligible if and only if 2   0
is eligible. The only -equivalence class with members in {u1 , u2 , u3 , u4 } and members not in
{u1 , u2 , u3 , u4 } is the class {u3 , u4 , u5 }. 1 and 2 both assign members of {u3 , u4 } to exactly the
set {s2 , s3 }. Thus for any plan  0 disjoint from 1 and 2 , 1   0 and 2   0 will both satisfy the
constraint (s1 , s5 , 6) whatever  0 assigns to s5 . They will both satisfy (s2 , s5 , ) only if  0 assigns
s5 to u5 , and they will both satisfy (s2 , s6 , 6) only if  0 does not assign s6 to u5 . As long as these
conditions are satisfied, and  0 satisfies all constraints with scope in {s4 , s5 , s6 }, then 1   0 and
2   0 will both be eligible.

4. A Generic Algorithm for the WSP
In what follows, for each X  U, T  S, we let [X, T ] denote the set of all eligible plans  with
U SER() = X an TASK() = T . In this section we will introduce an algorithm that works in a
similar way to Algorithm 1, except that instead of storing all valid plans over a particular set of users
or tasks, we will construct [X, T ]-representative sets for each task set T and certain user sets X.
By definition, the equivalence classes of any plan-indistinguishability relation necessarily partition
[X, T ]. Hence any such equivalence class has a representation of the form (X, T, ), where  is
dependent on the constraint language. In the remainder of this section we describe the algorithm
and give examples of these representations.
4.1 Encodings and Patterns
In our generic algorithm, we will construct plans iteratively, using at most one plan from each
equivalence class under a plan-indistinguishability relation. The running time of the algorithm will
depend on the number of equivalence classes under this relation, over certain sets of plans. To
ensure that sets of equivalence classes can be ordered and therefore searched and sorted efficiently,
we introduce the notion of encodings and patterns. Loosely speaking, an encoding is a function that
maps all the plans in a -equivalence class to the same element (the pattern of those plans). These
encodings ensure logarithmic-time access and insertion operations into a representative set of plans,
rather than the linear time that a naive method would allow.
Note that the use of encodings and patterns is not necessary for any of our fixed-parameter
tractability results; the same problems could be solved without the use of patterns and encodings in
fixed-parameter time, but the function in k would grow more quickly.

566

fiI TERATIVE P LAN C ONSTRUCTION FOR THE W ORKFLOW S ATISFIABILITY P ROBLEM

Definition 3. Given an instance (S, U, A, C) of the WSP and a plan-indistinguishability relation
, let  be the set of all plans. Let PAT be some set and consider a function ENC :   PAT. For
any X  U, T  S, let PAT[X, T ] = ENC([X, T ]). Then we say ENC is a -encoding (or an
encoding for ) if, for any X  U, T  S and any 1 , 2  [X, T ], we have that
1. ENC(1 ) = ENC(2 ) if and only if 1  2 ;
2. ENC(1 ) can be calculated in time polynomial in n, k, m;
3. There exists a linear ordering  on PAT[X, T ] such that, for p, p0  PAT[X, T ], we can decide
whether p  p0 in time polynomial in n, k, m.
The elements of PAT are called -patterns. If ENC() = p then we say p is the -pattern of .
The second and third conditions of Definition 3 ensure that we may use encodings to organise
our plans in a reasonable time. When  is clear from the context, we will refer to a -encoding as
an encoding and -patterns as patterns.
We note some complexity consequences of Definition 3 in the following:
Proposition 2. For an encoding of a plan-indistinguishability relation  and a set of patterns PAT ,
by assigning patterns in PAT to the nodes of a balanced binary tree, we can perform the following
two operations in time O (log(|PAT |)): (i) check whether p  PAT , and (ii) insert a pattern
p
/ PAT into PAT .
Proof. Recall that comparisons are polynomial in n, k, m. Now our result follows from the wellknown properties of balanced binary trees (e.g., see (Cormen, Stein, Rivest, & Leiserson, 2001)).
We now show that the plan-indistinguishability relations given in the previous section have
encodings. We first need to define a lexicographic order.
Definition 4. Given a totally ordered set (A, ), the (total) lexicographic order  on d-tuples from
Ad is defined as follows. We say that (x1 , . . . , xd )  (y1 , . . . , yd ) if either xj = yj for all j  [d]
or there is an i with xi < yi such that xj = yj for all j < i.
Taking A = N and d = k we obtain the natural lexicographic order on Nk0 .
We can also lexicographically order the sets of disjoint subsets of an ordered set T =
{t1 , . . . , tk }, where t1 <    < tk .
Definition 5. We associate a k-tuple (x1 , . . . , xk )  Nk0 with each set S of disjoint subsets
{S1 , . . . , Sr } of {t1 , . . . , tk } as follows. We have xi = 0 if ti 
/ rm=1 Sm . For ti  rm=1 Sm ,
 if there are j < i and m such that {ti , tj }  Sm then xi = xj ,
 otherwise xi = max{x1 , . . . , xi1 } + 1, where max  = 0.
We will write VEC(S) = (x1 , . . . , xk ). Note that VEC(S) can be computed in time O(k 2 ).
Thus, tasks in the same subset are assigned the same value; this assignment of integers
to tasks can be performed iteratively. For example, for T = {1, . . . , 8} and the sets A =
{{2, 4}, {3}, {5, 7}} and B = {{2, 3, 4}, {5, 7}}, we have VEC(A) = (0, 1, 2, 1, 3, 0, 3, 0) and
VEC (B) = (0, 1, 1, 1, 2, 0, 2, 0). So A is lexicographically bigger than B.
567

fiC OHEN , C RAMPTON , G AGARIN , G UTIN , & J ONES

Corollary 1. Let ui be the plan-indistinguishability relation given for a set of user-independent
constraints in Lemma 1. Then there exists an encoding for ui .
Proof. Let s1 , . . . , sk be an ordering of S and  a plan. Let S  = { 1 (u) : u  U SER()} and
let VEC() = VEC(S  ). For a plan , let ENC() be the tuple (U SER(), TASK(), VEC()).
It is clear that ENC(1 ) = ENC(2 ) if and only if 1 ui 2 , as r (si ) = r (sj ) if and only
if yi = yj in VEC(r ) = (y1 , . . . , yk ), for r  {1, 2}. Furthermore it is clear that ENC() can be
determined in polynomial time for any .
It remains to define a linear ordering on PAT[X, T ] for a given X  U, T  S. For two
patterns p = (X, T, (x1 , . . . , xk )), p0 = (X, T, (y1 , . . . , yk ))  PAT[X, T ], we define p  p0 if
(x1 , . . . , xk )  (y1 , . . . , yk ).
Example 6. Let ENC be the encoding given in the proof of Corollary 1. Let 1 , 2 be the plans
given in Example 4. Then ENC(1 ) = ENC(2 ) = {{u1 , u2 , u3 , u4 }, {s1 , s2 , s3 }, (1, 2, 1, 0, 0, 0)}.
Corollary 2. Let e be the plan-indistinguishability relation given for a set of constraints on equivalence relations in Lemma 2. Then there exists an encoding for e .
Proof. Suppose  is an equivalence relation on users, and let V1 , . . . , Vp be the equivalence classes
of  over U . Suppose all constraints are of the form (si , sj , ) or (si , sj , 6).
For a plan , define ENC() to be (U SER(), TASK(), T  ), where

	
T  =  1 (Vj  U SER()) : Vj  U SER() 6= , Vj \ U SER() 6= , 1  j  p .
It is clear that ENC(1 ) = ENC(2 ) if and only if 1 e 2 , as i (s)  Vj if and only if
s  i1 (Vj ), for i  {1, 2}. Furthermore it is clear that ENC() can be determined in polynomial
time for any .
It remains to define a linear ordering on PAT[X, T ] for a given X  U, T  S. Let  : T  X
be a plan. As T  is a set of disjoint subsets of TASK(), and T has a natural order, we can order
patterns in PAT[X, T ] according to the lexicographic order of T  .

Example 7. Let ENC be the encoding given in the proof of Corollary 2. Let 1 , 2 be the plans
given in Example 5. Then ENC(1 ) = ENC(2 ) = {{u1 , u2 , u3 , u4 }, {s1 , s2 , s3 }, {{s2 , s3 }}}.
4.2 The Generic Algorithm
We use the notion of diversity introduced in the next definition to analyse the running time of our
generic algorithm.
Definition 6. Let (S, U, A, C) be an instance of the WSP, with n = |U |, k = |S| and m = |C|, and
suppose  is a plan-indistinguishability relation with respect to C. Given an ordering u1 , . . . , un
of U , let Ui = {u1 , . . . , ui } for each i  [n]. Let wi be the number of equivalence classes of  over
the set [Ui , T ] of eligible plans. Then we define the diversity of  with respect to u1 , . . . , un to be
w = maxi[n] wi .
Since our generic algorithm only stores one plan from each equivalence class under , we need
the notion of a representative set.
568

fiI TERATIVE P LAN C ONSTRUCTION FOR THE W ORKFLOW S ATISFIABILITY P ROBLEM

Definition 7. Given an instance (S, U, A, C) of the WSP, let 0 be a set of eligible plans and let 
be a plan-indistinguishability relation. A set 00 is said to be a 0 -representative set with respect to
 if the following properties hold:
1. 00  0 ; every plan in 00 is valid;
2. for every valid  0  0 , there exists a  00  00 such that  0   00 .
When  is clear from context, we will say 00 is a 0 -representative set or a representative set
for 0 . Our generic algorithm is based on finding plan-indistinguishability relations for which there
exist small representative sets.
Theorem 1. Let (S, U, A, C) be an instance of the WSP, with n = |U |, k = |S| and m = |C|. Let
u1 , . . . , un be an ordering of U , and let Ui = {u1 , . . . , ui } for each i  [n], and U0 = . Suppose
 has diversity w with respect to u1 , . . . , un . Furthermore suppose that there exists a -encoding
ENC . Then (S, U, A, C) can be solved in time O  (3k w log w).
Proof. The proof proceeds by demonstrating the correctness and then bounding the running time of
Algorithm 2, which solves the WSP. To begin the proof, we give an overview of Algorithm 2.
 For each i  [n] in turn and each T  S, we will construct a representative set for [Ui , T ],
denoted by [Ui , T ] .
 As well as constructing the set [Ui , T ] , we also maintain a companion set PAT[Ui , T ] =
ENC ([Ui , T ] ). This provides an efficient way of representing the equivalence classes of
[Ui , T ] . In particular, it allows us to check whether a given valid plan  should be added
to [Ui , T ] , faster than by searching [Ui , T ] linearly.
 After [Un , S] has been constructed, it remains to check whether [Un , S] is non-empty,
as if there exists any valid complete plan , there exists a valid complete plan  0  [Un , S]
with    0 .
Algorithm 2 gives the details on how to construct [Ui , T ] for each i and T .
The proof of correctness of Algorithm 2 proceeds by induction. Observe first that for the case
of [U0 , T ] , if T 6=  then there is no possible plan in [U0 , T ], and so we set [U0 , T ] = . If
T =  then the only possible plan is the empty plan   ). This plan is added to [U0 , ] , as it
is trivially valid. Thus [U0 , T ] is a [U0 , T ]-representative set for each T .
So now assume that for all T  S the set [Ui , T ] has been constructed and is a [Ui , T ]representative set. Now consider the construction of [Ui+1 , T ] for some T  S. It is clear that
for any  added to [Ui+1 , T ] ,   [Ui+1 , T ], and  is eligible. Furthermore  is authorized,
as it is the union of the authorized plans  0  [Ui , T 0 ] and (T 00  ui+1 ). Thus every plan
in [Ui+1 , T ] is a valid plan in [Ui+1 , T ]. On the other hand, suppose  is a valid plan in
[Ui+1 , T ]. Then let T 00 =  1 ({ui+1 }) and T 0 = T \ T 00 , and let  0 = |Ui , so that  =
 0  (T 00  ui+1 ). By assumption, there exists  0   [Ui , T ] such that  0    0 . Consider
the plan   =  0   (T 00  ui+1 ). It is clear that   will be considered during the algorithm.
Furthermore, as  0    0 and  =  0  (T 00  ui+1 ), we have that    . Therefore   is
eligible (as  is eligible) and also authorized (as it is the union of two authorized plans). Therefore
569

fiC OHEN , C RAMPTON , G AGARIN , G UTIN , & J ONES

Algorithm 2: Generic algorithm for the WSP
input : An instance (S, U, A, C) of the WSP, an ordering u1 , . . . , un of U , a
plan-indistinguishability relation 
1 Set [U0 , ] = {(  )};
2 foreach  =
6 T  S do
3
Set [U0 , T ] = ;
4 end
5 Set i = 0;
6 while i < n do
7
foreach T  S do
8
Set [Ui+1 , T ] = ;
9
Set PAT[Ui+1 , T ] = ;
10
foreach T 0  T do
11
Set T 00 = T \ T 0 ;
12
if ui+1  A(s) for all s  T 00 then
13
foreach  0  [Ui , T 0 ] do
14
Set  =  0  (T 00  ui+1 );
15
if  is eligible then
16
Set p = ENC();
17
if p 
/ PAT[Ui+1 , T ] then
18
Insert p into PAT[Ui+1 , T ] ;
19
Set [Ui+1 , T ] = [Ui+1 , T ]  {};
20
end
21
end
22
end
23
end
24
end
25
end
26
Set i = i + 1;
27 end
28 if [Un , S] 6=  then
29
return   [Un , S] ;
30 else
31
return NULL;
32 end

  is valid and will be added to [Ui+1 , T ] unless [Ui+1 , T ] already contains another plan equivalent to . Thus, [Ui+1 , T ] contains a plan -equivalent to , from which it follows that
[Ui+1 , T ] is a [Ui+1 , T ]-representative set, as required.
It remains to analyse the running time of the algorithm. By Proposition 2, testing whether
a pattern p is in PAT[Ui , T ] and inserting p into PAT[Ui , T ] takes O (log(|PAT[Ui , T ] |)) time.
Since by Assumption 1 and our assumption on the time to check constraints and authorizations it
takes polynomial time to check eligibility, authorization and -equivalence of plans, the running
570

fiI TERATIVE P LAN C ONSTRUCTION FOR THE W ORKFLOW S ATISFIABILITY P ROBLEM

P
P
P
P

time of the algorithm is O ( n1
i=0
T S
T 0 T
[Ui ,T 0 ] log(|[Ui+1 , T ] |)). It is clear by
construction that [Ui , T 0 ] contains at most one plan for each -equivalence class over [Ui , T 0 ],
and soP
by definition
|[Ui , T 0 ] |  w for all i, T 0 . It follows that the running time of the algorithm
P
n1 P

is O ( i=0 T S T 0 T w log w) = O (3k w log w).
Remark 1. Rather than checking whether [Un , S] is non-empty at the end of the algorithm, we
could instead check whether [Ui , S] is non-empty after the construction of [Ui , S] for each i.
That is, we can stop our search as soon as we have a valid plan with task set S. This is likely to lead
to a saving in the running time of an implementation of the algorithm. As this paper is concerned
with the worst-case running time, which would be unaffected by this change, we perform the check
at the end of the algorithm in the interest of clarity.
4.3 Application to User-Independent Constraints and its Optimality
In this subsection, we show that the WSP with user-independent constraints is FPT. Let Bk denote
the kth Bell number, the number of partitions of a set with k elements.
Lemma 3. Let u1 , . . . , un be any ordering of U , and let ui be the plan-indistinguishability relation
given in Lemma 1. Then ui has diversity Bk with respect to u1 , . . . , un .
Proof. For any plan , the set { 1 (u) : u  U SER()} is a partition of the tasks in TASK().
Furthermore, two plans that generate the same partition are equivalent under ui . Therefore the
number of equivalence classes of ui over [Ui , T ] is exactly the number of possible partitions of
T , which is B|T | . Thus, Bk is the required diversity.
Theorem 2. If all constraints are user-independent, then the WSP can be solved in time
O (2k log k ).
Proof. Let u1 , . . . , un be any ordering of U , and let ui be the plan-indistinguishability relation
given in Lemma 1.
By Lemma 3, ui has diversity Bk with respect to u1 , . . . , un . Furthermore, by Corollary 1,
there exists an encoding for ui . Therefore, we may apply Theorem 1 with w = Bk , to get an
algorithm with running time O (3k Bk log Bk ) = O (2k log k ) as Bk < (0.792k/ ln(k + 1))k for
every k (Berend & Tassa, 2010).
The running time O (2k log k ) obtained is optimal in the sense that no algorithm of running time
exists, unless the ETH fails. In the proof of the following theorem, we use a result
from Lokshtanov, Marx, & Saurabh, 2011 (Theorem 2.2).

O (2o(k log k) )

Theorem 3. There is no algorithm for the WSP with user-independent constraints of running time
O (2o(k log k) ), unless the ETH fails.
Proof. We give a reduction from the problem kk I NDEPENDENT S ET: Given an integer parameter
k and a graph G with vertex set V = {(i, j) : i, j  [k]}, decide whether G has an independent set
I such that |I| = k and for each r  [k], there exists i such that (r, i)  I.
Informally, k  k I NDEPENDENT S ET gives us a graph on a k  k grid of vertices, and asks
whether there is an independent set with one vertex from each row. Lokshtanov et al. (2011) proved
that there is no algorithm to solve k  k I NDEPENDENT S ET in time 2o(k log k) , unless the ETH fails.
571

fiC OHEN , C RAMPTON , G AGARIN , G UTIN , & J ONES

Consider an instance of k  k I NDEPENDENT S ET with graph G. We will first produce an
equivalent instance of the WSP in which the constraints are not user-independent. We will then
refine this instance to one with user-independent constraints.
Let U = {u1 , . . . , uk } be a set of k users and S = {s1 , . . . , sk } a set of k tasks. Let the
authorization lists be A(si ) = U for all i  [k]. For i, j, h, l  [k], let c((i, j), (h, l)) denote
the constraint with scope {si , sh }, and which is satisfied by any plan  unless (si ) = uj and
(sh ) = ul . For every pair of vertices (i, j), (h, l) which are adjacent in G, add the constraint
c((i, j), (h, l)) to C.
We now show that (S, U, A, C) is a Y ES-instance of the WSP if and only if G has an independent set with one vertex from each row. Suppose (S, U, A, C) is a Y ES-instance of the WSP and
let  be a valid complete plan. Then for each i  [k], let f (i) be the unique j such that (si ) = uj .
Then I = {(i, f (i)) : i  [k]} is a set with one vertex from each row in G; furthermore, as  satisfies every constraint, no edge in G contains more than one element of I, and so I is an independent
set.
Conversely, suppose G is a Y ES-instance of k  k I NDEPENDENT
S ET. For each i  [k], let
S
f (i) be an integer such that (i, f (i))  I. Then observe that ki=1 ({si }  uf (i) ) is a valid complete
plan.
We now show how to reduce (S, U, A, C) to an instance of the WSP in which all constraints
are user-independent. The main idea is to introduce some new tasks representing the users, and in
the constraints, replace the mention of a particular user with the mention of the user that performs a
particular task.
Create k new tasks t1 , . . . , tk and let S 0 = S  {t1 , , . . . , tk }. Let the authorization lists be
0
A (s) = U for each s  S and A0 (ti ) = {ui } for each i  [k]. For each constraint c((i, j), (h, l))
in C, let d((i, j), (h, l)) be the constraint with scope {si , sh , tj , tl }, which is satisfied by any plan 
unless (si ) = (tj ) and (sh ) = (tl ). Let initially C 0 = C. Now replace, in C 0 , every constraint
c((i, j), (h, l)) with d((i, j, ), (h, l)).
Since they are defined by equalities, and no users are mentioned, the constraints in C 0 are userindependent. We now show that (S 0 , U, A0 , C 0 ) is equivalent to (S, U, A, C). First, suppose that 
is a valid complete plan for (S, U, A, C). Then let  0 : S 0  U be the plan such that  0 (si ) = (si )
for all i  [k], and  0 (tj ) = uj for all j  [k]. It is easy to check that if  satisfies every constraint
of C then  0 satisfies every constraint of C 0 . Since  0 is an authorized and eligible plan,  0 is a valid
complete plan for (S 0 , U, A0 , C 0 ).
Conversely, suppose that  0 is a valid complete plan for (S 0 , U, A0 , C 0 ). Since A0 (ti ) = {ui } for
each i  [k],  0 (ti ) = ui for every i  [k]. For each i  [k], let f (i) be the unique integer such that
 0 (si ) = uf (i) . Then define  : S  U by (si ) = uf (i) , and observe that all constraints in C are
satisfied by . So,  is a valid complete plan for (S, U, A, C).
4.4 Application to Equivalence Relation Constraints
It is known that restricting the WSP to have only equivalence relation constraints is enough to ensure
that the problem is FPT (Crampton et al., 2013). However, we can derive this result by applying our
algorithm directly having shown the appropriate properties of the language of equivalence relation
constraints. This serves to demonstrate the wide applicability of our approach.

572

fiI TERATIVE P LAN C ONSTRUCTION FOR THE W ORKFLOW S ATISFIABILITY P ROBLEM

Lemma 4. Let e be the plan-indistinguishability relation given for a set of equivalence relation
constraints in Lemma 2. Then there exists an ordering u1 , . . . , un of U such that e has diversity
2k with respect to U .
Proof. Suppose  is an equivalence relation on users, and let V1 , . . . , Vp be the equivalence classes
of  over U . Suppose all constraints are of the form (si , sj , ) or (si , sj , 6).
Let u1 , . . . , un be an ordering of U such that all the elements of Vj appear before all the elements
of Vj 0 , for any j < j 0 . Thus, for any i and any plan  with U SER() = Ui = {u1 , . . . , ui }, there is
at most one integer ji such that Vji  U SER() 6= , Vji \ U SER() 6= .
It follows that any two plans 1 , 2  [Ui , T ] are e -equivalent, for any i  [n], T  S,
provided that 1 (t)  Vji if and only if 2 (t)  Vji for any t  T . Therefore e has at most 2k
equivalence classes over [Ui , T ], as required.
Theorem 4. Suppose  is an equivalence relation on U . Suppose all constraints are of the form
(si , sj , ) or (si , sj , 6). Then the WSP can be solved in time O (6k ).
Proof. Let u1 , . . . , un be the ordering of U given by Lemma 4, and let e be the planindistinguishability relation given in Lemma 2.
By Lemma 4, e has diversity 2k with respect to u1 , . . . , un . Furthermore by Corollary 2, there
exists an encoding for e . Therefore, we may apply Theorem 1 with w = 2k , to get an algorithm
with running time O (3k 2k log(2k )) = O (6k ).

5. Unions of Constraint Languages
In this section we show how our approach allows us easily to combine constraint languages shown
to be FPT for the WSP. We do not need to build bespoke algorithms for the new constraint language
obtained, only to show that the two languages are in some sense compatible.
This highlights the advantages of our approach over previous methods, which required the development of new algorithms when different constraint languages were combined in an instance of
the WSP (e.g., see Crampton et al., 2013).
Theorem 5. Let (S, U, A, C1  C2 ) be an instance of the WSP, and suppose 1 is a planindistinguishability relation with respect to C1 and 2 is a plan-indistinguishability relation with
respect to C2 . Given an ordering u1 , . . . , un of U , let W1 be the diversity of 1 with respect to
u1 , . . . , un and W2 the diversity of 2 with respect to u1 , . . . , un .
Let  be the equivalence relation such that    0 if and only if  1  0 and  2  0 . Then
 is a plan-indistinguishability relation with respect to C1  C2 , and  has diversity W1 W2 with
respect to u1 , . . . , un .
Proof. We first show that  is a plan-indistinguishability relation with respect to C1  C2 . Let 
and  0 be eligible plans (with respect to C1  C2 ). As    0 implies  1  0 and 1 satisfies
the conditions of a plan-indistinguishability relation, it is clear that if    0 then U SER() =
U SER( 0 ) and TASK() = TASK( 0 ). Now consider a plan  00 disjoint from  and  0 . As 1 is a
plan-indistinguishability relation with respect to C1 and  1  0 , we have that    00 is C1 -eligible
if and only if  0   00 is. Similarly    00 is C2 -eligible if and only if  0   00 is. Observing that a
plan is C1  C2 -eligible if and only if it is C1 -eligible and C2 -eligible, this implies that    00 is
C1  C2 -eligible if and only if  0   00 is. Thus we have that  and  0 are extension equivalent.
573

fiC OHEN , C RAMPTON , G AGARIN , G UTIN , & J ONES

As 1 and 2 are plan-indistinguishability relations, we have that    00 1  0   00 and
   00 2  0   00 , and therefore    00   0   00 . Thus,  satisfies all the conditions of a
plan-indistinguishability relation.
To bound the diversity of  with respect to u1 , . . . , un , consider any T  S and Ui =
{u1 , . . . , ui }. It is enough to note that any -equivalent plans in [Ui , T ] must be in the same
1 and 2 -equivalence classes. As there are at most W1 choices for the 1 -equivalence class and
at most W2 choices for the 2 equivalence class,  has at most W1 W2 equivalence classes over
[Ui , T ].
Remark 2. Given an encoding ENC1 for 1 and an encoding ENC2 for 2 , we may construct an
encoding for . Given a plan , let ENC() be the ordered pair (ENC1 (), ENC2 ()). It is clear
that ENC() = ENC( 0 ) if and only if    0 .
Given sets T  S and Ui = {u1 , . . . , ui }, fix linear orderings of ENC1 ([Ui , T ]) and
ENC 2 ([Ui , T ]). Then let  be the lexicographic ordering of ENC ([Ui , T ]) = ENC 1 ([Ui , T ]) 
ENC 2 ([Ui , T ]).
There is nothing to stop us applying Theorem 5 multiple times, in order to get a planindistinguishability relation with bounded diversity for a union of several constraint languages.
Note that the diversity can be expected to grow exponentially with the number of languages in the
union. Thus, it makes sense to only apply Theorem 5 to the union of a small number of languages.
However, as long as there is a fixed number of languages, and each has a plan-indistinguishability
relation with fixed-parameter diversity, the resulting union of languages will also have a planindistinguishability relation with fixed-parameter diversity.
We can now use this result directly to show that if all our constraints are either user independent
or equivalence relation constraints, then the WSP is still FPT.
Theorem 6. Suppose  is an equivalence relation on U . Let (S, U, A, C) be an instance of the
WSP, and suppose that all constraints are either of the form, (s1 , s2 , ), (s1 , s2 , 6) or userindependent constraints. Then the WSP can be solved in time O (2k log k+k ).
Proof. Let Ce  C be the set of constraints of the form (s1 , s2 , ), (s1 , s2 , 6), and let Cui be the
remaining (user-independent) constraints.
Let u1 , . . . , un be the ordering of U given by Lemma 4. By Lemmas 2 and 4, there exists a planindistinguishability relation e for Ce that has diversity 2k with respect to u1 , . . . , un . Furthermore
by Corollary 2, e has an encoding. By Lemmas 1 and 3, there exists a plan-indistinguishability
relation ui for Cui that has diversity Bk with respect to u1 , . . . , un . Furthermore by Corollary 1,
ui has an encoding.
Therefore by Theorem 5, we may find a plan-indistinguishability relation  for C, such
that  has diversity Bk  2k with respect to u1 , . . . , un and  has an encoding. Thus we
may apply Theorem 1 with w = Bk  2k , to get a running time of O (3k Bk 2k log(Bk 2k )) =
O (3k 2k log k(1o(1))+k log(2k log k(1o(1))+k )) = O (2k log k+k ).

6. Computational Experiments with WSP Algorithms
Apart from conducting theoretical research on the WSP, Wang and Li (2010) carried out an experimental study of the problem. Due to the difficulty of acquiring real-world workflow instances,
574

fiI TERATIVE P LAN C ONSTRUCTION FOR THE W ORKFLOW S ATISFIABILITY P ROBLEM

Wang and Li used synthetic data in their experimental study. They encoded instances of the WSP
into pseudo-Boolean SAT in order to use a pseudo-Boolean SAT solver SAT4J.
We have implemented our algorithm and compared its performance to SAT4J on another set
of synthetic instances of the WSP (Cohen et al., 2014). These instances use k = 16, 20 and
24, n = 10k and user-independent (cardinality) constraints of three different types: we vary the
number of constraints and the proportions of the different constraint types; each user is authorized
for between 1 and 8 tasks for k = 16, between 1 and 10 tasks for k = 20, and between 1 and 12
tasks for k = 24. The algorithm was implemented in C++ and has been enhanced by the inclusion
of techniques employed in CSP solving, such as propagation. We also converted WSP instances into
pseudo-Boolean problems for processing by SAT4J. All experiments were performed on a MacBook
Pro computer with a 2.6 GHz Intel Core i5 processor and 8 GB 1600 MHz DDR3 RAM (running
Mac OS X 10.9.2).
For lightly-constrained instances, SAT4J was often faster than our algorithm, largely because
the number of patterns considered by our algorithm is large for such instances. However, for highlyconstrained instances, SAT4J was unable to compute a decision for a number of instances (because
it ran out of memory), in sharp contrast to our algorithm which solved all instances. Overall, on
average, our algorithm was faster than SAT4J and, in particular, was two orders of magnitude faster
for k = 16. Moreover, the time taken by our algorithm varies much less than that of SAT4J, even
for unsatisfiable instances, because the time taken is proportional to the product of the number of
patterns and the number of users. (In particular, in tested instances, it is much less dependent on the
number of constraints, a parameter that can cause significant fluctuations in the time taken by SAT4J
because it leads to a sharp increase in the number of variables in the pseudo-Boolean encoding.) Full
details of our results have been published (Cohen et al., 2014).

7. Conclusion
In this paper we introduced an algorithm based on the notion of plan-indistinguishability, applicable
to a wide range of WSP instances. We showed that our algorithm is powerful enough to be optimal,
in a sense, for the wide class of user-independent constraints. The generic algorithm is also a
fixed-parameter algorithm for equivalence relation constraints, which are not user-independent. We
showed how to deal with unions of different types of constraints using our generic algorithm. In
particular, we proved that the generic algorithm is a fixed-parameter algorithm for the union of
user-independent and equivalence relation constraints.

Acknowledgments
Our research was supported by EPSRC grant EP/K005162/1. We are grateful to the referees for
their useful comments and suggestions.

References
American National Standards Institute (2004).
CITS RBAC 359-2012).
575

Role Based Access Control (ANSI IN-

fiC OHEN , C RAMPTON , G AGARIN , G UTIN , & J ONES

Basin, D. A., Burri, S. J., & Karjoth, G. (2014). Obstruction-free authorization enforcement: Aligning security and business objectives. Journal of Computer Security, 22(5), 661698.
Beldiceanu, N., Carlsson, M., & Rampon, J.-X. (2012). Global constraint catalog, 2nd edition
(revision a). working copy 5195, Swedish Institute of Computer Science, Kista, Sweden.
Berend, D., & Tassa, T. (2010). Improved bounds on bell numbers and on moments of sums of
random variables. Probability and Mathematical Statistics, 30(2), 185205.
Bertino, E., Bonatti, P. A., & Ferrari, E. (2001). TRBAC: a temporal role-based access control
model. ACM Trans. Inf. Syst. Secur., 4(3), 191233.
Bertino, E., Ferrari, E., & Atluri, V. (1999). The specification and enforcement of authorization
constraints in workflow management systems. ACM Trans. Inf. Syst. Secur., 2(1), 65104.
Bodlaender, H. L., Cygan, M., Kratsch, S., & Nederlof, J. (2013). Deterministic single exponential
time algorithms for connectivity problems parameterized by treewidth. In Proceedings of the
40th International Conference on Automata, Languages, and Programming - Volume Part I,
ICALP13, pp. 196207, Berlin, Heidelberg. Springer-Verlag.
Bulatov, A., Jeavons, P., & Krokhin, A. (2005). Classifying the complexity of constraints using
finite algebras. SIAM Journal on Computing, 34, 720742.
Cohen, D., Crampton, J., Gagarin, A., Gutin, G., & Jones, M. (2014). Engineering algorithms
for workflow satisfiability problem with user-independent constraints. In Chen, J., Hopcroft,
J. E., & Wang, J. (Eds.), Frontiers in Algorithmics - 8th International Workshop, FAW 2014,
Zhangjiajie, China, June 28-30, 2014. Proceedings, Vol. 8497 of Lecture Notes in Computer
Science, pp. 4859. Springer.
Cormen, T. H., Stein, C., Rivest, R. L., & Leiserson, C. E. (2001). Introduction to Algorithms (2nd
edition). McGraw-Hill Higher Education.
Crampton, J., Crowston, R., Gutin, G., Jones, M., & Ramanujan, M. (2013). Fixed-parameter
tractability of workflow satisfiability in the presence of seniority constraints. In Fellows, M.,
Tan, X., & Zhu, B. (Eds.), Frontiers in Algorithmics and Algorithmic Aspects in Information
and Management, Vol. 7924 of Lecture Notes in Computer Science, pp. 198209. Springer
Berlin Heidelberg.
Crampton, J. (2005). A reference monitor for workflow systems with constrained task execution.
In Proceedings of the Tenth ACM Symposium on Access Control Models and Technologies,
SACMAT 05, pp. 3847, New York, NY, USA. ACM.
Crampton, J., & Gutin, G. (2013). Constraint expressions and workflow satisfiability. In Proceedings of the 18th ACM Symposium on Access Control Models and Technologies, SACMAT 13,
pp. 7384, New York, NY, USA. ACM.
Crampton, J., Gutin, G., & Yeo, A. (2013). On the parameterized complexity and kernelization of
the workflow satisfiability problem. ACM Trans. Inf. Syst. Secur., 16(1), 4:14:31.
Dechter, R. (2003). Constraint Processing. Morgan Kaufmann Publishers, 340 Pine Street, Sixth
Floor, San Francisco, CA 94104-3205.
Downey, R. G., & Fellows, M. R. (2013). Fundamentals of Parameterized Complexity. Texts in
Computer Science. Springer.
576

fiI TERATIVE P LAN C ONSTRUCTION FOR THE W ORKFLOW S ATISFIABILITY P ROBLEM

Fomin, F. V., Lokshtanov, D., & Saurabh, S. (2014). Efficient computation of representative sets
with applications in parameterized and exact algorithms. In Proceedings of the Twenty-Fifth
Annual ACM-SIAM Symposium on Discrete Algorithms, SODA 14, pp. 142151. SIAM.
Gligor, V., Gavrila, S., & Ferraiolo, D. (1998). On the formal definition of separation-of-duty policies and their composition. In 1998 IEEE Symposium on Security and Privacy, 1998. Proceedings., pp. 172183.
Impagliazzo, R., Paturi, R., & Zane, F. (2001). Which problems have strongly exponential complexity?. J. Comput. Syst. Sci., 63(4), 512530.
Jayaraman, K., Ganesh, V., Tripunitara, M. V., Rinard, M. C., & Chapin, S. J. (2011). ARBAC
policy for a large multi-national bank. CoRR, abs/1110.2849.
Joshi, J. B. D., Bertino, E., Latif, U., & Ghafoor, A. (2005). A generalized temporal role-based
access control model. IEEE Transactions on Knowledge and Data Engineering,, 17(1), 423.
Lokshtanov, D., Marx, D., & Saurabh, S. (2011). Slightly superexponential parameterized problems.
In Proceedings of the Twenty-second Annual ACM-SIAM Symposium on Discrete Algorithms,
SODA 11, pp. 760776. SIAM.
Niedermeier, R. (2006). Invitation to Fixed-Parameter Algorithms. Oxford University Press.
Rossi, F., van Beek, P., & Walsh, T. (Eds.). (2006). The Handbook of Constraint Programming.
Elsevier.
Sandhu, R. S., Coyne, E. J., Feinstein, H. L., & Youman, C. E. (1996). Role-based access control
models. Computer, 29(2), 3847.
Schaad, A., Moffett, J., & Jacob, J. (2001). The role-based access control system of a european
bank: A case study and discussion. In Proceedings of the Sixth ACM Symposium on Access
Control Models and Technologies, SACMAT 01, pp. 39, New York, NY, USA. ACM.
Simon, R., & Zurko, M. (1997). Separation of duty in role-based environments. In Computer
Security Foundations Workshop, 1997. Proceedings., 10th, pp. 183194.
Wang, Q., & Li, N. (2010). Satisfiability and resiliency in workflow authorization systems. ACM
Trans. Inf. Syst. Secur., 13(4), 40:140:35.
Wolter, C., & Schaad, A. (2007). Modeling of task-based authorization constraints in bpmn. In
Proceedings of the 5th International Conference on Business Process Management, BPM07,
pp. 6479, Berlin, Heidelberg. Springer-Verlag.

577

fi