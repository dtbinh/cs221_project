Journal of Artificial Intelligence Research 34 (2009) 499-520

Submitted 10/08; published 3/09

Exploiting Single-Cycle Symmetries in
Continuous Constraint Problems
Vicente Ruiz de Angulo
Carme Torras

ruiz@iri.upc.edu
torras@iri.upc.edu

Institut de Robotica i Informatica Industrial (CSIC-UPC)
Llorens i Artigas 4-6, 08028-Barcelona, Spain.
WWW home page: www.iri.upc.edu

Abstract
Symmetries in discrete constraint satisfaction problems have been explored and exploited in the last years, but symmetries in continuous constraint problems have not received the same attention. Here we focus on permutations of the variables consisting of
one single cycle. We propose a procedure that takes advantage of these symmetries by
interacting with a continuous constraint solver without interfering with it. A key concept
in this procedure are the classes of symmetric boxes formed by bisecting a n-dimensional
cube at the same point in all dimensions at the same time. We analyze these classes and
quantify them as a function of the cube dimensionality. Moreover, we propose a simple
algorithm to generate the representatives of all these classes for any number of variables at
very high rates. A problem example from the chemical field and the cyclic n-roots problem
are used to show the performance of the approach in practice.

1. Introduction
Symmetry exploitation in discrete constraint satisfaction problems (CSPs) has received a
great deal of attention lately. Since CSPs are usually solved using AI search algorithms, the
approaches dealing with symmetries fall into two groups: those that entail reformulating the
problem or adding constraints before search (Flener, Frisch, Hnich, Kiziltan, & Miguel, 2002;
Puget, 2005), and those that break symmetries along the search (Meseguer & Torras, 2001;
Gent, 2002). Permutations of variables, and interchangeability of values are commonly
addressed symmetries for which a repertoire of techniques have been developed, most of
them relying on computational group theory.
On the contrary, symmetries have been largely disregarded in continuous constraint
solving, despite the important growth in both theory and applications that this field has
recently experienced (Sam-haroud & Faltings, 1996; Benhamou & Goualard, 2000; Jermann
& Trombettoni, 2003; Porta, Ros, Thomas, & Torras, 2005). Continuous (or numerical)
constraint solving is often tackled using Branch-and-Prune (B&P) algorithms (Hentenryck,
Mcallester, & Kapur, 1997; Vu, Silaghi, Sam-Haroud, & Faltings, 2005), which iteratively
locate solutions inside an initial domain box, by alternating box subdivision (branching)
and box reduction (pruning) steps.
Motivated by a molecular conformation problem, in this paper we deal with the most
simple type of box symmetry, namely that in which some domain variables (i.e., box dimensions) undergo a single-cycle permutation leaving the constraints invariant. To be clear, if
the cycle involves n variables, our algorithm handles the n  1 symmetries (excluding the
c
2009
AI Access Foundation. All rights reserved.

fiRuiz de Angulo & Torras

identity) generated by this cycle by composition. Since the computational gain will be
shown to be roughly proportional to n, the longest cycle appearing in the problem formulation should be chosen as input to our algorithm.
This single-cycle permutation that leaves the constraints unchanged is a form of constraint symmetry in the terminology introduced by Cohen, Jeavons, Jefferson, Petrie, and
Smith (2006). Note that any constraint symmetry is also a solution symmetry, but not the
other way around. Thus, the symmetries we deal with are a subset of all possible solution
symmetries; the advantage is that they can be assessed (although perhaps are difficult to
find) from the problem formulation, therefore being operative.
Our approach to exploit symmetries in continuous constraint problems requires the
initial domain for the symmetric variables to be an n-cube, as it starts by subdividing this
cube at the same point along all dimensions at once. Since box symmetry is a transitive
relation, the subboxes resulting from the subdivision fall into equivalence classes. Then, a
B&P algorithm (or any similar continuous constraint solver) is called on only the subboxes
that are representatives of each symmetry equivalence class. Finally, for each solution found,
all its symmetric ones are generated. Note that symmetry handling doesnt interfere with
the inside workings of the constraint solver.

2. Symmetry in Continuous Constraint Problems
We are interested in solving the following general continuous Constraint Satisfaction Problem (continuous CSP): Find all points x = (x1 , . . . , xn ) lying in an initial box of Rn satisfying
the constraints f1 (x)  C1 , . . . , fm (x)  Cm , where fi is a function fi : Rn  R, and Ci is
an interval in R.
The only particular feature that we require of a Continuous Constraint Solver (CCS)
is that it has to work with an axis-aligned box in Rn as input. Also, we assume that the
CCS returns solution boxes. Note that a CCS returning solution points is a limit case still
contained in our framework.
We say that a function s : Rn  Rn is a point symmetry of the problem if there exists an
associated permutation   m such that fi (x) = f(i) (s(x)) and Ci = C(i) , i = 1, . . . , m.
We consider symmetry as a property that relates points that are equivalent as regards to a
continuous CSP. Concretely, from the above definition one can conclude that
 x is a solution to the problem iff s(x) is a solution to the problem.
Let s and t be two symmetries of a continuous CSP with associated permutations s
and t . It is easy to see that the composition of symmetries s(t()) is also a symmetry with
associated permutation s (t ()).
An interesting type of symmetries are permutations (bijective functions of a set onto
itself) of the components of x. Let D be a finite set. A cycle of length k is a permutation
 such that there exist distinct elements a1 , . . . ak  D such that (ai ) = (a(i+1)mod k )
and (z) = z for any other element z  D. Such a cycle is represented as (a1 , . . . ak ).
Every permutation can be expressed as a composition of disjoint cycles (i.e, cycles without
common elements), which is unique up to the order of the factors. Composition of cycles is
represented as concatenation, as for example (a1 , . . . ak )(b1 , . . . bl ). In this paper we focus
on a particular type of permutations, namely those constituted by a single cycle. In its
500

fiExploiting Single-Cycle Symmetries

simplest form1 , this is s(x1 , x2 , . . . xn ) = (x(1) , x(2) , . . . x(n) ) = (x2 , x3 ...xn , x1 ), where
(i) = (i + 1) mod n.
Example: n = 3, m = 4, x = (x1 , x2 , x3 )  [1, 1]  [1, 1]  [1, 1],
f1 (x) :

x21 + x22 + x23  [5, 5]  x21 + x22 + x23 = 5

f2 (x) :

2x1  x2  [0, ]  2x1  x2 > 0

f3 (x) :

2x2  x3  [0, ]  2x2  x3 > 0

f4 (x) :

2x3  x1  [0, ]  2x3  x1 > 0

There exists a symmetry s(x1 , x2 , x3 ) = (x2 , x3 , x1 ), for which there is no need of reordering the variables. The constraint permutation associated to s is (1) = 1, (2) = 3,
(3) = 4, and (4) = 2.
Generally there is not a unique symmetry for a given problem. If there exists a symmetry
s, then for example s2 (x) = s(s(x)) is another symmetry. In general, using the convention of
denoting s0 (x) the identity mapping, {si (x), i = 0 . . . n1} is the set of different symmetries
that can be obtained composing s(x) with itself, while for i > n we have that si (x) =
si mod n (x). Thus, a single-cycle symmetry generates by composition n  1 symmetries,
excluding the trivial identity mapping. Some of them may have different numbers of cycles.
Imagine for example that in a continuous CSP with n = 4 the permutation of variables (1
2 3 4) is a symmetry. Then, the permutation obtained by composing it twice, (1 3)(2 4),
is also a symmetry of the problem, but has a different number of cycles, and the longest
cycle has length two instead of four. Besides, the former permutation cannot be generated
from the latter. The algorithm presented in this paper deals with all the compositions
of a single-cycle symmetry, even if some of them are not single-cycle symmetries. The
gain obtained with the proposed algorithm will be shown to be roughly proportional to
the number of different compositions of the selected symmetry. Therefore, when several
single-cycle symmetries exist in a continuous CSP problem, the algorithm should be used
with that generating the most symmetries by composition, i.e., with that having the longest
cycle. Note that the single-cycle permutations we are dealing with need not encompass all
the problem variables, since the the remaining ones will be considered fixed (unitary cycles).

3. Box Symmetry
Since continuous constraint solvers work with boxes, we turn our attention now to the set
of points symmetric to those belonging to a box B  Rn . 2
Let s be a single-cycle symmetry corresponding to the circular variable shifting  introduced in the preceding section, and B = [x1 , x1 ]. . .[xn , xn ] a box in Rn . The box symme1. In general, the variables must be arranged in a suitable order before one can apply the circular shifting. Thus, the general form of a single-cycle symmetry is s(x) = h1 (g(h(x))), where
h(x1 , . . . xn ) = (x(1) , . . . , x(n) ),   n is a general permutation that orders the variables, and
g(x1 , . . . , xn ) = (x(1) , . . . x(n) ) is the circular shifting above. Thus, the cycle  defining the symmetry can be expressed as  = 1 ((())). Since the reordering does not change substantially the
presented concepts and algorithms, we have simplified notation in the paper by assuming that the order
of the component variables is the appropriate one, i.e., that  =  .
2. This set {s(x) s.t. x  B} is also a box if s(x) = (s1 (x), . . . , sn (x)) = (g1 (x(1) ), . . . , gn (x(n) )), where
si is the i-th component of s,  is an arbitrary permutation, and gi : R  R is any function such that if
I is an interval of R then {gi (x) s.t. x  I} is also an interval of R.

501

fiRuiz de Angulo & Torras

try function S is defined as S(B) = {s(x) s.t. x  B} = [x(1) , x(1) ]  . . .  [x(n) , x(n) ] =
[x2 , x2 ]  . . .  [xn , xn ]  [x1 , x1 ]. The box symmetry function has also an associated constraint permutation , which is the same associated to s. S i will denote S composed i
times. We say, then, that B1 and B2 are symmetric boxes if there exists i s.t. S i (B1 ) = B2 .
Box symmetry is an equivalence relation defining symmetry equivalence classes. Let
R(B) be the set of different boxes in the symmetry class of B, R(B) = {S i (B), i  {0, . . . , n
1}}. For instance, for box B 0 = [0, 4]  [2, 5]  [2, 5]  [0, 4]  [2, 5]  [2, 5], R(B 0 ) is composed
of S 0 (B 0 ) = B 0 , S 1 (B 0 ) = [2, 5][2, 5][0, 4][2, 5][2, 5][0, 4] and S 2 (B 0 ) = [2, 5][0, 4]
[2, 5][2, 5][0, 4][2, 5]. Note that S 3 (B 0 ) is again B 0 itself and that subsequent applications
of box symmetry would repeat the same sequence of boxes. We define the period P (B) of
a box B as P (B) = |R(B)|. It is easily shown that R(B) = {S i (B), i  {0, . . . , P (B)  1}}.
For example, for box B 0 , R(B 0 ) = {S 0 (B 0 ), S 1 (B 0 ), S 2 (B 0 )} and P (B 0 ) = 3.
Box symmetry has implications for the continuous CSP, which are a direct consequence
of the point symmetry case:
 If there is no solution inside a box B, there is no solution inside any of its symmetric
boxes either.
 A box B  B is a solution iff S i (B )  S i (B) is a solution box for all i  {1 . . . P (B) 
1}.
Sketch of proof for the first statement: Assume there is no solution inside B and there is
some solution xsol inside S i (B). By definition of box symmetry there exists a point x0sol  B
such that xsol = si (x0sol ). Using the property highlighted in Section 2 we deduce that x0sol
must be also a solution, which contradicts the hypothesis.
Sketch of proof for the second statement: A solution box is a box with at least a solution
point inside. Assume B  B is a solution box containing the solution point xsol . Inside
S i (B ) there is the point si (xsol ) that, by the property highlighted in Section 2, must be
also a solution. Conversely, assume now that S i (B )  B is a solution box. Thus it contains
at least a solution point, xsol . By definition of symmetric box, this point has a symmetric
point x0sol  B such that xsol = si (x0sol ). Using the property in Section 2 again we conclude
that x0sol must be also a solution and, thus, B is a solution box.
Both statements can be rephrased as follows :
 If the set of solution boxes contained in a box B is SolSet, the set of solution boxes
contained in its symmetric box S i (B) is {S i (B ) s.t. B  SolSet}
This means that once the solutions inside B have been found, the solutions inside its
symmetric boxes S i (B), i  {1 . . . P (B)  1} are available without hard calculations. In the
following sections we will show how to exploit this property to save much computing time
in a meta-algorithm that uses a CCS as a tool without interfering with it.
3.1 Box Symmetry Classes Obtained by Bisecting a n-cube
The algorithm we will propose to exploit box symmetry makes use of the symmetry classes
formed by bisecting a n-dimensional cube I n (i.e., of period 1) in all dimensions at the
same time and at the same point, resulting in 2n boxes. We will denote L and H the
two subintervals into which the original range I is divided. For example, for n = 2, we
502

fiExploiting Single-Cycle Symmetries

have the following set of boxes {L  L, L  H, H  L, H  H} whose periods are 1, 2,
2 and 1, respectively. And their symmetry classes are: {L  L}, {L  H, H  L}, and
{H  H}. Representing the two intervals L and H as 0 and 1, respectively, and dropping
the  symbol, the sub-boxes can be coded as binary numbers. Let SRn be the set of
representatives, formed by choosing the smallest box in binary order from each class. For
example, SR2 = {00, 01, 11}. Note that the cube I n to be partitioned can be thought of
as the the set of binary numbers of length n, and that SRn is nothing more than a subset
whose elements are different under circular shift.
The algorithm for exploiting symmetries and the way it uses SRn are explained in the
next section. Afterwards, in Sections 6 and 7, we study how many components SRn has,
how they are distributed and, more importantly, how can they be generated.

4. Algorithm to Exploit Box Symmetry
Algorithm 1: CSym1 algorithm.
Input: A n-cube, [xl , xh ]      [xl , xh ].
A single-cycle box symmetry, S.
A Continuous Constraint Solver, CCS.
Output: A set of boxes covering all solutions.

5

SolutionBoxSet  EmptySet
x  SelectBisectionPoint(xl , xh )
foreach b  SRn do
B  GenerateSubBox(b, xl , xh , x )
SolutionBoxSet  SolutionBoxSet  ProcessRepresentative(B)

6

return SolutionBoxSet

1
2
3
4

The symmetry exploitation algorithm we propose uses the CCS as an external routine.
The internals of the CCS must not be modified or known.
The idea is to first divide the initial box into a number of symmetry classes. Next, one
needs to process only a representative of each class with the CCS. At the end, by applying
box symmetries to the solution boxes obtained in this way, one would get all the solutions
lying in the space covered by the whole classes, i.e., the initial box. The advantage of this
procedure is that the CCS would have to process only a fraction of the initial box. Assuming
that the initial box is a n-cube covering the same interval [xl , xh ] in all dimensions, we can
directly apply the classes associated to SRn . A procedure to exploit single-cycle symmetries
in this way is presented in Algorithm 1.
Since SRn is a set of codes not real boxes we need a translation of the codes into
boxes for the given initial box. The operator GenerateSubBox(b, xl , xh , x ) returns the
box V = V1      Vn corresponding to code b = b1 . . . bn when [xl , xh ] is the range of the
initial box in all dimensions and x is the point in which this interval is bisected:
(
[xl , x ] if bi = 0,
Vi =
(1)
[x , xh ] if bi = 1.
503

fiRuiz de Angulo & Torras

The point x calculated by SelectBisectionPoint(xl , xh ) can be any such that xl <
< xh , but a reasonable one is (xl + xh )/2. The iterations over line 4 generate a set of
representative boxes such that, together with their symmetries, cover the initial n-cube.
ProcessRepresentative(B) returns all the solution boxes associated to B, that is, the
solutions inside R(B), or still in other words, the solutions inside B and inside its symmetric
boxes. ProcessRepresentative(B) is based on the property stated at the end of Section
3, which allows to obtain all the solutions in the class of B by processing only B with the
CCS. SolSet is the set of solutions found inside the representative box of the class, B.
ApplySymmetry(SolSet, S i ) calculates the set of solutions of box S i (B) by applying S i
to each of the boxes in SolSet. Since the number of symmetries of B is P (B), the benefits
of exploiting the symmetries of a class representative is proportional to its period.
x

Algorithm 2: The ProcessRepresentative function.
Input: A box, B.
A single-cycle box symmetry, S.
A Continuous Constraint Solver, CCS.
Output: The set of solution boxes contained in B and its symmetric boxes.

4

SolSet  CCS(B)
T otalSolSet  SolSet
for i=1: P (B)  1 do
T otalSolSet  T otalSolSet  ApplySymmetry(SolSet, S i )

5

return T otalSolSet

1
2
3

The correctness of the algorithm is easy to check. The set of boxes in which it searches explicitly or implicitly (by means of symmetry) for solutions is U = {R(B) s.t. B is a representative}.
In fact, U is the set of boxes formed by bisecting the initial box in all dimensions at the same
time and at the same point. U covers the whole initial box and, thus, the algorithm finds
all the solutions of the problem. Moreover, it finds each solution box only once, because
the boxes in U do not have any volume in common (they share at most a wall).
4.1 Discussion on the Efficiency of CSYM1
The CSym1 algorithm launches the CCS algorithm on |SRn | small boxes instead of on only
the original large one. Three factors affect its efficiency as compared to that of the standard
approach:
1. Fraction of domain processed. Only a fraction of the original domain is directly
dealt with by the CCS. This fraction is a function of the periods of the SRn components. One element of period p represents a class formed by p boxes, only one of
which is processed with the CCS. Since all the boxes of the classes are of equal size,
the above fraction can be calculated by dividing the number of representatives by the
n|
P |SRn |
total number of boxes in the classes, |SR
2n =
P (B) . The expected time gain
P

BSRn

P (B)

n
is the inverse of this quantity, BSR
denoted by IFDP (Inverse of the Fraction
|SRn |
of Domain Processed). When n grows (see Section 6), the majority of the elements

504

fiExploiting Single-Cycle Symmetries

of SRn have period n, and thus IFDP tends to n. However, for low n, IFDP can
be significantly smaller than n. This is the main factor determining the efficiency of
CSym1.
2. Smaller processed boxes. Since the CCS initial boxes using CSym1 are 2n times
smaller than the original initial box, the average size of the boxes processed by the
CCS is also smaller than in the standard case. Prune (box reduction or contraction)
step is carried out more quickly on smaller boxes in Branch-and-Prune algorithms.
In fact, best Branch-and-Prune algorithms have box contraction operators exhibiting
second-order convergence, but this contraction rate requires small enough boxes to
hold in practice.
3. Number of representatives. There is a disadvantage in fractioning excessively
the initial domain. We can see this by noting that, using the original large initial
box, if a contraction operator lowers the upper bound of a symmetric variable, this
information could be used to lower the upper bound of the same variable in many
representative boxes in SRn . As commented above, this contraction operator would
act more strongly on the representatives themselves, but the loss of parallelization
effect is anyway present. This factor is irrelevant for small-length cycle symmetries,
say up to n = 6, because |SRn | is very small (see Section 6 again) as compared to the
number of boxes that a CCS must process in general. However, when n approaches
20, the number of representatives begins to become overwhelming.

5. Two Illustrative Examples
The two problems below have been solved with the Branch-and-Prune CCS presented by
Porta, Ros, Thomas, Corcho, Canto, and Perez (2008). It is a polytope-based method
similar to that of Sherbrooke E. C. (1993) with global consistency, which exhibits quadratic
convergence. The machine used to carry out all the experiments in the paper is a 2.5 Ghz
G5 Apple computer.
5.1 Cycloheptane
Molecules can be modeled as mechanical chains by making some reasonable approximations.
If two atoms are joined by a chemical bond, one can assume that there is a rigid link between
them. Thus, the first approximation is that bond lengths are constant. The second one
is that the angles between two consecutive bonds are also constant. In other words, the
distances between the atoms in any subchain of three atoms are assumed to be constant. All
configurations of the atoms of the molecule that satisfy these distance constraints, sometimes
denoted rigid-geometry hypothesis, are valid conformations of the molecule in a kinematic
sense. The constraints induced by the rigid-geometry hypothesis are particularly strong
when the molecule topology forms loops, as in cycloalkanes. The problem of finding all
valid conformations of a molecule can be formulated as a distance-geometry (Blumenthal,
1953) problem in which some distances between points (atoms) are fixed and known, and
one must find the set of values of unknown (variable) distances that are compatible with
the embedding of the points in R3 . The unknown distances can be found by solving a set
505

fiRuiz de Angulo & Torras

of constraints consisting of equalities or inequalities of determinants formed with subsets of
the fixed and variable distances (Blumenthal, 1953).

d2
d3

d1
d7

d5

d6

d4

Figure 1: Cycloheptane. Disks represent carbon atoms. Constant and variable distances
between atoms are represented with continuous and dashed lines, respectively.

Figure 2: Three-dimensional projection of the cycloheptane solutions. The lightest (yellow)
boxes are the solutions found inside the representatives using the CCS (line 1 in
Algorithm 2). The other colored boxes are the solutions obtained by applying
symmetries to the yellow boxes (line 4 in Algorithm 2).

Figure 1 displays the known and unknown distances of the cycloheptane, a molecule basically composed of a ring of seven carbon atoms. The distance between two consecutive atoms
of the ring is constant and equal everywhere. The distance between two atoms connected to
506

fiExploiting Single-Cycle Symmetries

a same atom is also known and constant no matter the atoms. The problem in underconstrained, having an infinite number of solutions of dimensionality 1. The problem has several
symmetries. We use one of them, s(d1 , . . . , d7 ) = (d(1) , d(2) , . . . , d(7) ) = (d2 , d3 . . . , d7 , d1 ).
The length of the only cycle of this symmetry is n = 7, for which IFDP is 6.4.
The number of boxes processed using the raw CCS without symmetry handling is 1269,
while using CSym1 the total number is 196, giving a ratio of 6.47  IFDP. The problem is
solved in 4.64 minutes using CSym1, which compares very favorably with the 31.6 minutes
spent when using the algorithm of Porta et al. (2008) alone, a reduction by a factor of 6.81,
slightly greater than IFDP. This means that, although the number of representatives begins
to be relevant (|SR7 | = 20), factor 2 in Section 4.1 is more determining than factor 3 in
the same section, since the (small) time overhead introduced by handling box symmetries
is also included in the reported time. Figure 2 shows a projection into d1 , d2 and d3 of the
solutions obtained using CSym1. The solutions were found inside five representative boxes
of period seven, containing 16, 1, 4, 64 and 1 solution boxes, respectively, at the chosen level
of resolution. The total number of solutions boxes is therefore 7(16+1+4+64+1)= 602.
5.2 Cyclic n-roots Problem
The following polynomial equation system is the n = 5 instance of the so-called cyclic
n-roots problem as described by Bjorck and Froberg (1991).

x1 + x2 + x3 + x4 + x5 = 0
x1 x2 + x2 x3 + x3 x4 + x4 x5 + x5 x1 = 0
x1 x2 x3 + x2 x3 x4 + x3 x4 x5 + x4 x5 x1 + x5 x1 x2 = 0
x1 x2 x3 x4 + x2 x3 x4 x5 + x3 x4 x5 x1 + x4 x5 x1 x2 + x5 x1 x2 x3 = 0

(2)

x1 x2 x3 x4 x5  1 = 0

There are ten real solutions to this problem. The system has a single-cycle symmetry:
s(x1 , . . . , x5 ) = (x2 , x3 , x4 , x5 , x1 ), as well as a multiple-cycle symmetry not considered in
this paper. Thus, the cycle length is n = 5, |SR5 | = 8, and the IFDP is 4. When running
the CCS alone using as initial box [10, 10]5 , the number of processed boxes is 399, while
exploiting the aforementioned symmetry with the CSym1 algorithm this number reduces
to 66. In the last case, two solutions were found in a representative box of period 5, which
through symmetry led to the ten solutions. Running times are 16.86 seconds (CCS alone)
and 2.08 seconds (CSym1) giving a gain of more than eight. This is the double of the IFDP,
which highlights the benefits that factor 2 in Section 4.1 can bring to the efficacy of the
approach. The number of representatives is very small compared to the number of boxes
processed by the CCS alone, making factor 3 in Section 4.1 irrelevant in this case.
Table 1 contains the results for n=4 to n=8 of the cyclic n-roots problem in the [10, 10]n
domain, except for n=8 for which the domain was [5, 5]8 . For n=4 and n=8 there is a
continuum of solutions which, with the chosen resolution, produces 992 and 2435 solution
boxes, respectively. Because of this, the number of processed boxes for n=5 is smaller
than for n=4, but logically smaller also than for n=6 to n=8. Two observations can be
507

fiRuiz de Angulo & Torras

IFDP
number of processed boxes CCS alone
number of processed boxes CSym1
rate of processed boxes
time CCS alone
time CSym1
time gain CSym1

n=4

n=5

n= 6

n=7

2.7
1855
500
3.7
12.0
3.0
4.0

4.0
399
66
6.0
16.9
2.1
8.1

4.5
3343
510
6.6
642.0
95.8
6.7

6.4
38991
5070
7.7
20442.0
2689.7
7.6

n=8
(reduced domain)
7.1
108647
13304
8.2
227355.2
27296.5
8.3

Table 1: Results for the n-cyclic roots problem. Times are given in seconds.

made. First, the time gains are always higher than the corresponding IFDPs, implying a
preponderance of factor 2 in Section 4.1 over factor 3. Second, the time gain follows rather
accurately the rate between the number of processed boxes using the CCS alone and using
CSym1.
Tests on the cyclic n-roots problem using a classical CCSP solver, RealPaver (Granvilliers & Benhamou, 2006), have been carried out (Jermann, 2008). The results are preliminary and difficult to expose concisely, since there is a great variability depending on issues
such as the pruning method used (RealPaver offers several options) and how the problem
is coded (factorized or not). In every case, however, we have observed time gains greater
than expected by the IFDP.

6. Analysis of SRn : Counting the Number of Classes
Let us define some quantities of interest:
-Nn : Number of elements of SRn .
-FP n : Number of elements of SRn that correspond to full-period boxes, i.e., boxes of period
n.
-Nnm : Number of elements of SRn having m 1s.
-FP nm : Number of elements of SRn that correspond to full-period boxes having m 1s.
Polyas theorem (Polya & Read, 1987) could be used to determine some of these quantities for a given n by building a possibly huge polynomial and elucidating some of its
coefficients. We present a simpler way of calculating them and, at the same time, make the
reader familiar with the concepts that will be used in our algorithm to generate SRn .
We begin by looking for the expression of FP n . When any number of 1s is allowed,
the total number of binary numbers is 2n . The only periods that can exist in these binary
numbers are divisors of n. Thus, the following equation holds:
X

p FP p = 2n .

pdiv(n)

Segregating p = n,
508

(3)

fiExploiting Single-Cycle Symmetries

X

n FP n +

p FP p = 2n ,

(4)

p
FP p .
n

(5)

pdiv(n), p<n

and solving for FP n :
FP n =

2n

n

X
pdiv(n), p<n

This recurrence has a simple baseline condition: FP 1 = 2.
Then, Nn follows easily from
Nn =

X

FP p .

(6)

pdiv(n)

Segregating p = n, a more efficient formula is obtained:
Nn =

2n
+
n

X
pdiv(n), p<n

np
FP p .
n

(7)

This formula is valid for n > 1. The remaining case is N1 = 2.

n
We will use similar techniques to obtain FP nm and Nnm . There are m
binary numbers
having m 1s and n  m 0s. Some of these binary numbers are circular shifts of others
(like 011010 and 110100). The number of shifted versions of a binary number is the period
of the box being represented by the binary number. For example, 1010, of period 2, has
only another shifted version, 0101. A binary number representing a box of period p can be
n
seen as a concatenation of n/p numbers of length n/p
= p and period p. This means that
m
these concatenated numbers are full-period, and they have n/p
1s. Thus, the number of
binary numbers of period p when shifted numbers are counted as the same (i.e., the number
n
m . Only common divisors of n and m, which we denote
of classes of period p) is FP n/p
n/p
div(n, m), can be periods. Since there are p shifted versions of each binary number having
period p, we can write
 
X
n
n
m =
p FP n/p
.
(8)
n/p
m
pdiv(n,m)

With a change of variable f = n/p we get
X
f div(n,m)

n
FP nf mf =
f

 
n
.
m

(9)

Note that the index of the summation goes through the same values as before. We can
segregate the case f = 1 from the summand,
 
X
n
n
n FP nm +
FP nf mf =
,
(10)
f
m
f div(n,m), f >1

and, finally, we obtain
509

fiRuiz de Angulo & Torras

FP nm =

n
m



n

FP nf mf

X



f

f div(n,m), f >1

.

(11)

This is a recurrence relation from which FP nm can be computed using the following
baseline conditions:
(
0
=
1

FP nn , FP n0

if n > 1
if n = 1

(12)

Nnm is obtained adding up the number of classes of each period:
Nnm =

X

FP nf mf .

(13)

f div(n,m)

Segregating again f = 1, a more efficient formula is obtained:
Nnm =

 
n
+
m

X

n
)FP nf mf ,
f

(14)

(1  p)FP p mp ,

(15)

(1 

f div(n,m), f >1

then carrying out the change of variable p = n/f :
Nnm =

 
n
+
m

X

n

pdiv(n,m), p<n

Note the change in the summation range. This equation is valid whenever m > 0 and
m < n. Otherwise, Nnm = 1.
It is possible to extend the concept of FP n (and FP nm ) to reflect the number of members
p
):
of SRn having period p (and m 1s), which we denote Nnp (Nnm
Nnp

p
Nnm

(
0
=
FP p

if p 
/ div(n)
otherwise

(
0
=
FP p, mp
n

if p 
/ div(n, m)
otherwise

(16)

(17)

Figure 3(a) displays the number of classes (Nn ) as a function of n. The curve indicates
an exponential-like behavior. This is confirmed in Figure 3(b) using a larger logarithmic
scale, in which the curve appears almost perfectly linear. Figure 4 is an example of the
distribution of classes by period for n = 12. Figure 5 shows the percentage of full-period
classes in SRn (100 Nnn /Nn ). One can see that the percentage of classes with period different
from n is significant for low n, but approaches quickly 0 as n grows. Finally, Figures 6(a)
and 6(b) display the distribution of the classes in SRn by number of 1s for n = 12 and
n = 100, respectively. The majority of the classes concentrates in an interval in the middle
of the graphic, around n/2. This interval becomes relatively smaller when n grows.
510

finumber of classes of symmetric boxes

350
300
250
200
150
100
50
0

2

4

6

8

10

12

1x1011
1x1010
1x109
1x108
1x107
1x106
1x105
1x104
1x103
1x102
1x101
1

0

5

box dimensionality (i.e., number of variables)

10

15

20

25

30

(b)

Figure 3: Number of elements of SRn as a function of n.

100

10

1

1

2

3

4

35

box dimensionality (i.e., number of variables)

(a)

number of classes of symmetric boxes

number of classes of symmetric boxes

Exploiting Single-Cycle Symmetries

5

6

7

8

9

10

11

12

box period

Figure 4: Number of elements of SR12 distributed by period.

511

40

fiRuiz de Angulo & Torras

7. Generating SRn , the Classes of Symmetric Boxes
The naive procedure to obtain SRn would initially generate all boxes originated by bisecting
a n-dimensional cube at the same point in all dimensions at the same time. Then, one should
check each of the boxes in this set to detect whether it is a circular shift of some of the
others. The complete process of generating SRn in this way involves a huge number of
operations even for rather small dimensions. Although the SRn for a few ns could be precomputed and stored in a database, we suggest here an algorithm capable of calculating
SRn on the fly without significant computational overhead.

percentage of full-period classes

100

80

60

40

20

0
2

4

6

8

10

12

14

16

18

20

box dimensionality (i.e., number of variables)

Figure 5: Percentage of full-period elements in SRn as a function of n.

number of classes of symmetric boxes

number of classes of symmetric boxes

As made for counting, we distinguish different subsets of SRn on the basis of the number
of 1s and the period:
-SRnm : Subset of the elements of SRn having m 1s.
-SRpnm : Subset of the elements of SRn having m 1s and period p.
SRpn : Subset of the elements of SRn having period p.
From a global point of view, the generation of SRn is carried out as follows. First,
SRn0 is generated, which is constituted always by a unique member. Afterwards, all SRnm

70
60
50
40
30
20
10
0

0

2

4

6

8

10

12

1x1027
8x1026
6x1026
4x1026
2x1026

0

0

20

40

60

80

100

number of 1s in the code

number of 1s in the code

(a)

(b)

Figure 6: Number of elements of SRn distributed by number of 1s. (a) n =12. (b) n=100.

512

fiExploiting Single-Cycle Symmetries

for m = 1 . . . n are generated. The generation of SRnm is divided in each of the SRpnm ,
p  div(n, m), that compose it. The algorithm ClassGen described below generates all
full-period representatives for any given number of variables n > 1 and number of ones
m > 0, i.e., it generates SRnnm . The representatives of a lower period p  div(n, m) are
obtained by concatenating one same block n/p = f times. Therefore, in order to obtain
SRpnm , we generate SRpp m with our same algorithm, and then concatenate their elements
f

f times. Thus, without loss of generality, in what follows we describe the workings of the
algorithm ClassGen when it computes codes of full period, namely n.
We use a compact coding of the binary numbers representing the boxes consisting in
ordered lists or chains of numbers. The first number of the code is the number of 0s
appearing before the first 1 in the binary number. The i-th number of the code for i > 1 is
the number of 0s between the (i1)-th and the i-th 1s of the binary number. For example,
the number 0100010111 is codified as 13100. The length of this numerical codification is
the number of 1s of the codified binary number, which has been denoted by m.
There are binary numbers that cannot be codified in this way, because their last digit
is 0. But, except for the all zeros case, there is always an element of its class that can be
codified correctly (for example 0011 is an element of the class of 0110). As our objective is
to have only a representative of each class, this is rather an advantage, because half of the
boxes are already eliminated from the very beginning. The all zeros box, SRn0 , is common
to every n, and will be generated separately, as already mentioned.
The codification allows to determine if a box is full-period in the same way as in the
binary representation: the box has period n iff after a number of circular shifts lower than
the length of the numerical chain the result is never equal to the original. For instance, the
example above is full-period, but 22, corresponding to 001001, is not. The only difference
is that, in the new representation, at most m shifts must be compared.
The code of a box can be seen as a number of base n  m. In a full-period box, the m
circular shifts of the code are different numbers, and can be arranged in strictly increasing
numerical order. We will take as representative box of a class the largest element of the
class when expressed as a code (which is the smallest when expressed as a binary number).
For example, the class of 130 has two other elements that can be represented by our coding,
013 and 301, the latter being the chosen representative of the class.
Note that a box belonging to SRnm has n  m 0s or, equivalently, the sum of the
components of the code is n  m.
The output of the algorithm are all codes of length m, whose sum of components is
n  m, and which are both representatives of a class and full-period. Codes of length m
whose components sum up a desired number are rather easy to generate systematically.
The representativeness and full-period conditions are more difficult to guarantee efficiently.
We can handle them by exploiting the properties of our codes stated below, which make
use of the definition of i-compability.
We say that a code is i-compatible or compatible for position i if a sub-chain of it
beginning at position i > 1 and ending at the last position m (thus of length m  i + 1)
is strictly smaller in numerical terms than the sub-chain of the same length beginning at
the first position. For example, 423423 is compatible for positions 2 and 3, but it is not
4-compatible.
513

fiRuiz de Angulo & Torras

Property 1 A code is a class representative and it is full-period iff it is i-compatible for
all i s.t. 1 < i 6 m.
Thus, instead of comparing chains of length m (i.e., the code and its shifted versions),
we can determine the code validity comparing shorter sub-chains. A second property helps
us to devise a still faster and simpler algorithm:
Property 2 If a code is i-compatible and the sub-chain from position i to i + l is equal to
the sub-chain from position 1 to 1 + l then the code is also compatible for positions i + 1
through i + l.

Algorithm 3: CodeValidity algorithm.
Input: A code of length m expressed as an array, A.
Output: A boolean value indicating whether the code is valid, i.e., whether it is
full-period and a class representative.
1
2
3
4
5
6
7
8
9
10

i2
ctrol  1
V alidCode  True
while V alidCode & i < m do
if A[i] > A[ctrol] then V alidCode  F alse
else if A[i] < A[ctrol] then ctrol  1
else ctrol  ctrol + 1;
ii+1

/* A[i] = A[ctrol] */

if A[m]  A[ctrol] then V alidCode  F alse
return ValidCode

This property is interesting because it permits checking the validity of the code by
travelling along it at most once, as shown in Algorithm 3. The trick is that when the decision
of i-compatibility is being delayed because position i and the following numbers are the same
as those at the beginning of the string, if it finally resolves positively, the compatibility for
the intermediate numbers is also guaranteed. Hence, i-compatibility is either resolved with
a simple comparison or it requires l comparisons. In the latter case, either the compatibility
of l positions is also resolved (if the outcome is positive) or compatibility of intermediate
positions doesnt matter (because the outcome is negative and, thus, the code can be labelled
non valid without further checks). A ctrol variable is in charge of maintaining the last index
of the head sub-chain that is being compared in the current compatibility check. When
examining the compatibility of the current position i, if its value is lower than that of the
ctrol position, the code is for sure i-compatible and therefore we must only worry about
(i + 1)-compatibility by back-warding ctrol to the first position. If the value of the ctrol
position is equal to that of the current position i, the compatibility of position i is still to be
ascertained, and we continue advancing the current and the ctrol positions until the equality
disappears. In other words, the only condition that must be fulfilled for non rejecting as
invalid a code at position i is that
514

fiExploiting Single-Cycle Symmetries

Algorithm 4: ClassGen algorithm.
Input: The sum of the numbers that remain to be written on the right (from
position pos to m), sum.
The index of the next position to be written, pos.
The index of the current control element, whose value cannot be surpassed in
the
next position, ctrol.
The length of the code, m.
Array where class codes are being generated, A.
Output: A set of codes representing classes, SR.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18

SR  EmptySet
if pos = m then
if sum < A[ctrol] then
A[m]  sum
SR  {A};

/* otherwise, SR will remain EmptySet */

else
if pos = 1 then
LowerLimit = dsum/me
U pperLimit  sum
else
LowerLimit = 0
U pperLimit  Minimum(A[ctrol], sum)
for i = U pperLimit to LowerLimit do
A[pos]  i
if i = A[ctrol]Sand pos 6= 1 then
/* i = A[ctrol] = U pperLimit */
SR  SR ClassGen(sum  i, pos + 1, ctrol + 1, m, A)
else
/* i < A[ctrol] or pos = 1 */
S
SR  SR ClassGen(sum  i, pos + 1, 1, m, A)

19
20

return SR

A[i] 6 A[ctrol],

(18)

a condition that is transformed into A[i] < A[ctrol] when i = m to resolve the last of the
pending compatibility checks. As an aside, note that our codes are more general than the
raw binary numbers, and that representativeness and full-periodness are defined in the same
way for both. Therefore, the three properties and the CodeValidity algorithm apply also
to the raw binary numbers.
A rather direct way to generate SRnnm would be to generate all the codes of length
m whose sum of components is n  m (the number of zeros when expressed as a binary
number) and then filter each of them with CodeValidity. Instead, we have taken a more
515

fiRuiz de Angulo & Torras

efficient approach, generating only the codes that satisfy the conditions that need to be
checked explicitly in CodeValidity. Therefore, Algorithm 3 (presented only for clarity
purposes) is not used.
Our main procedure to obtain all full-period representatives having m 1s, i.e., SRnnm ,
is the recursive program presented in Algorithm 4. ClassGen(n  m, 1, 1, m, A), where A
is an array of length m, must be called to obtain SRnnm , for any given n > 1, m > 0. Each
call to the procedure writes a single component of the code at the position of A indicated
by the parameter pos, beginning with pos = 1, which is subsequently incremented at each
recursive call. The recursion finishes at the rightmost end of the code, when pos = m. The
first parameter, sum, is the sum of the components of the code that remain to be written.
The range of values written at each position pos is limited by LowerLimit and U pperLimit,
except for the last position m. In the following we show the correctness of the algorithm
by verifying that these limits are chosen to satisfy the two requirements of the code:
 The sum of the numbers of any code completed by the algorithm must be nm. First,
recall that the initial call to the algorithm is done using a parameter sum = n  m.
In any position 1  pos < m the number to be written must be greater than or
equal to the sum of the numbers still to be written, quantity represented by sum, so
that in subsequent positions it will be possible to write positive integers, or at least
zeros. This condition is imposed to U pperLimit in line 9 for pos = 1 and in line 12
(juxtaposed to code validity conditions) for 1 < pos < m. The number written at
pos is substracted from the sum parameter in the next recursive call. Finally, for
pos = m, the only possibility to satisfy the sum condition is to assign the value of
sum to the last element of the code.
 The code validity conditions, just as in CodeValidity, are that the number to be
written in position pos must be smaller than or equal to A[ctrol] for 1 < pos < m,
and strictly lower than A[ctrol] for pos = m. These conditions are reflected in the
U pperLimit assignments made in lines 12 and 3, respectively. LowerLimit is usually
(pos < 1, line 4) set to the smallest possible element of the codes, 0. But at the
beginning of the code (pos = 1, line 8) a more tight value can be chosen since, for
a value lower than the upper rounded value dsum/me, there is no way to distribute
what remains of sum among the other positions of the code without putting a value
greater than the initial one, which would make any such code non-representative.
The maintenance of the ctrol variable is similar to that within the CodeValidity
algorithm: if we write in pos something strictly minor than A[ctrol], ctrol is back-warded
to the first position. Otherwise, ctrol is incremented by 1 for the next recursive call to write
pos + 1.
The output of the algorithm is a list of valid codes in decreasing numerical order. For
instance, the output obtained when requesting SR993 with ClassGen(6, 1, 1, 3, A) is: {600,
510, 501, 420, 411, 402, 330, 321, 312}. In this example, the only case in which the recursion
arrives to pos = m without returning a valid code is the frustrated code 222, whose last
number is not written because the code is not full-period.
Figure 7 displays quantitative results that reflect the efficiency of ClassGen. The
dashed line accounts for the complete times required to generate all the class representatives
516

fiExploiting Single-Cycle Symmetries

total time
millions of representatives per second

1.4

20

1.2

1
15
0.8
10

0.6

total time (seconds)

number of representatives (millions/second)

25

0.4

5

0.2
0
5

10

15

20

25

30

0

dimensionality (number of variables)

Figure 7: Total time (dashed line) to generate SRn , and rates of generation (continuous
line) of class representatives as a function of n.

SRn for n = 2 to n = 30. It is worth noting that only SR30 requires more than a second to be
entirely generated. The continuous line encodes the division of |SRn | by the time required
to generate SRn , measured in millions of class representatives generated by second. It is
evident that the efficiency of ClassGen is very high and that it even grows slightly with
n. This behavior shows that the dead-ends in the recursion are statistically insignificant,
which proves the tightness of the bounds used to enforce the values of the code numbers.

8. Conclusions
We have approached the problem of exploiting symmetries in continuous constraint satisfaction problems using continuous constraint solvers. Our approach is general and can make
use of any box-oriented CCS as a black-box procedure. The particular symmetries we have
tackled are single-cycle permutations of the problem variables.
The suggested strategy is to bisect the domain, the n-cube initial box, simultaneously
in all dimensions at the same point. This forms a set of boxes that can be grouped in box
symmetry classes. A representative of each class is selected to be processed by the CCS
and all the symmetries of the representative are applied to the resulting solutions.
In this way, the solutions within the whole initial domain are found, while having processed only a fraction of it the set of representatives with the CCS. The time savings
obtained by processing a representative and applying its symmetries to the solutions tend
to be proportional to the number of symmetric boxes of the representative. Therefore, symmetry exploitation is complete for full-period representatives, since they have the maximum
number of symmetric boxes. Another factor that improves the efficiency above what could
517

fiRuiz de Angulo & Torras

be expected by these considerations is the smaller average size of the boxes processed by
the CCS with our approach.
We have also studied the automatic generation of the classes resulting from bisecting a
n-cube and analyzed their numerical properties. The algorithm for generating the classes
is very powerful, eliminating the convenience of any pre-calculated table. The numerical
analysis of the classes revealed that the average number of symmetries of the class representatives tends quickly to n as the number of variables, n, grows. This is good news,
since n is the maximum number of symmetries attainable with single-cycle symmetries of
n variables, leading to time reductions by a factor close to n. Nevertheless, for small n
there is still a significant fraction of the representatives not having the maximum number
of symmetries. Another weakness of the proposed strategy is the exponential growth in the
number of classes as a function of n.
The problems with small and large n should be tackled with a more refined subdivision
of the initial domain in box symmetry classes, which is left for near future work. We are
also currently approaching the extension of this work to deal with permutations of the
problem variables composed of several cycles. Another complementary research line is the
addition of constraints before the search with the CCS. These constraints will be specific for
each symmetry class. Finally, the extension to Branch-and-Bound algorithms for nonlinear
optimization could be envisaged.

Acknowledgments
This is an extended version of work presented at CP 2007 (Ruiz de Angulo & Torras, 2007).
The authors acknowledge support from the Generalitat de Catalunya under the consolidated
Robotics group, the Spanish Ministry of Science and Education, under the project DPI200760858, and the Comunitat de Treball dels Pirineus under project 2006ITT-10004.

References
Benhamou, F., & Goualard, F. (2000). Universally quantified interval constraints. In
Springer-Verlag (Ed.), CP 02: Proceedings of the 6th International Conference on
Principles and Practice of Constraint Programming, pp. 6782.
Bjorck, G., & Froberg, R. (1991). A faster way to count the solutions of inhomogeneous
systems of algebraic equations, with applications to cyclic n-roots. J. Symb. Comput.,
12 (3), 329336.
Blumenthal, L. (1953). Theory and aplications of distance geometry. Oxford University
Press.
Cohen, D., Jeavons, P., Jefferson, C., Petrie, K. E., & Smith, B. M. (2006). Symmetry
definitions for constraint satisfaction problems. Constraints, 11 (2-3), 115137.
Flener, P., Frisch, A., Hnich, B., Kiziltan, Z., & Miguel, I. (2002). Breaking row and column
symmetries in matrix models. In CP 02: Proceedings of the 8th International Conference on Principles and Practice of Constraint Programming, pp. 462476. Springer.
518

fiExploiting Single-Cycle Symmetries

Gent, I. P. (2002). Groups and constraints: Symmetry breaking during search. In In
Proceedings of CP-02, LNCS 2470, pp. 415430. Springer.
Granvilliers, L., & Benhamou, F. (2006). Realpaver: An interval solver using constraint
satisfaction techniques. ACM Trans. on Mathematical Software, 32, 138156.
Hentenryck, P. V., Mcallester, D., & Kapur, D. (1997). Solving polynomial systems using
a branch and prune approach. SIAM Journal on Numerical Analysis, 34, 797827.
Jermann, C., & Trombettoni, G. (2003). Inter-block backtracking : Exploiting the structure in continuous csps. In In: 2nd International Workshop on Global Constrained
Optimization and Constraint Satisfaction, pp. 1530. Springer.
Jermann, C. (2008). Personal communication..
Meseguer, P., & Torras, C. (2001). Exploiting symmetries within constraint satisfaction
search. Artif. Intell., 129 (1-2), 133163.
Polya, G., & Read, R. (1987). Combinatorial enumeration of groups, graphs and chemical
compounds. Springer-Verlag.
Porta, J. M., Ros, L., Thomas, F., Corcho, F., Canto, J., & Perez, J. (2008). Complete
maps of molecular loop conformational spaces. Journal of Computational Chemistry,
29 (1), 144155.
Porta, J. M., Ros, L., Thomas, F., & Torras, C. (2005). A branch-and-prune solver for
distance constraints. IEEE Trans. on Robotics, 21, 176187.
Puget, J.-F. (2005). Symmetry breaking revisited. Constraints, 10 (1), 2346.
Ruiz de Angulo, V., & Torras, C. (2007). Exploiting single-cycle symmetries in branchand-prune algorithms. In CP 07: Proceedings of the 13th International Conference
on Principles and Practice of Constraint Programming, pp. 864871.
Sam-haroud, D., & Faltings, B. (1996). Consistency techniques for continuous constraints.
Constraints, 1, 85118.
Sherbrooke E. C., P. N. M. (1993). Computation of the solution of nonlinear polynomial
systems. Computer Aided Geometric Design, 10, 379405.
Vu, X.-H., Silaghi, M., Sam-Haroud, D., & Faltings, B. (2005). Branch-and-prune search
strategies for numerical constraint solving. Tech. rep. LIA-Report 7, Swiss Federal
Institute of Technology (EPFL).

519

fi