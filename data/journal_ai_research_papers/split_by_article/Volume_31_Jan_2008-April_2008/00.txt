Journal of Artificial Intelligence Research 31 (2008) 1-32

Submitted 5/07; published 01/08

M INI M AX S AT: An Efficient Weighted Max-SAT Solver
Federico Heras
Javier Larrosa
Albert Oliveras

FHERAS @ LSI . UPC . EDU
LARROSA @ LSI . UPC . EDU
OLIVERAS @ LSI . UPC . EDU

Technical University of Catalonia, LSI Department
Jordi Girona 1-3, 08034, Barcelona, Spain.

Abstract
In this paper we introduce M INI M AX S AT, a new Max-SAT solver that is built on top of M IN It incorporates the best current SAT and Max-SAT techniques. It can handle hard clauses
(clauses of mandatory satisfaction as in SAT), soft clauses (clauses whose falsification is penalized by a cost as in Max-SAT) as well as pseudo-boolean objective functions and constraints. Its
main features are: learning and backjumping on hard clauses; resolution-based and substractionbased lower bounding; and lazy propagation with the two-watched literal scheme. Our empirical
evaluation comparing a wide set of solving alternatives on a broad set of optimization benchmarks
indicates that the performance of M INI M AX S AT is usually close to the best specialized alternative
and, in some cases, even better.
I S AT +.

1. Introduction
Max-SAT is the optimization version of SAT where the goal is to satisfy the maximum number of
clauses. It is considered one of the fundamental combinatorial optimization problems and many important problems can be naturally expressed as Max-SAT. They include academic problems such as
max cut or max clique, as well as real problems in domains like routing, bioinformatics, scheduling
or electronic markets.
There is a long tradition of theoretical work about the structural complexity (Papadimitriou,
1994) and approximability (Karloff & Zwick, 1997) of Max-SAT. Most of this work is restricted to
the simplest case in which all clauses are equally important (i.e., unweighted Max-SAT) and have a
fixed size (mainly binary or ternary). From a practical point of view, significant progress has been
made in the last 3 years (Shen & Zhang, 2004; Larrosa & Heras, 2005; Larrosa, Heras, & de Givry,
2007; Xing & Zhang, 2005; Li, Manya, & Planes, 2005, 2006). As a result, there is a handful of
new solvers that can deal, for the first time, with instances involving hundreds of variables.
The main motivation of our work comes from the study of Max-SAT instances modelling realworld problems. We usually encounter three features:
 The satisfaction of all clauses does not have the same importance, so each clause needs to be
associated with a weight that represents the cost of its violation. In the extreme case, which
often happens in practice as observed by Cha, Iwama, Kambayashi, and Miyazaki (1997),
there are clauses whose satisfaction is mandatory. They are usually modelled by associating
a very high weight with them.
 Literals do not appear randomly along the clauses. On the contrary, it is easy to identify
patterns, symmetries or other kinds of structures.
c
2008
AI Access Foundation. All rights reserved.

fiH ERAS , L ARROSA , & O LIVERAS

 In some problems there are mandatory clauses that reduce dramatically the number of feasible
assignments, so the optimization part of the problem only plays a secondary role. However,
in some other problems mandatory clauses are trivially satisfiable and the real difficulty lays
on the optimization part.
When we look at current Max-SAT solvers, we find that none of them is robust over these three
features. For instance, Li et al.s (2005, 2006) solvers are restricted to formulas in which all clauses
are equally important (i.e. unweighted Max-SAT), Shen and Zhangs (2004) one is restricted to binary clauses, the one described by Larrosa et al. (2007) seems to be efficient on very overconstrained
problems (i.e., only a small fraction of the clauses can be simultaneously satisfied), while the one by
Alsinet, Manya, and Planes (2005) seems to be efficient on slightly overconstrained problems (i.e.
almost all the clauses can be satisfied). The solver described by Argelich and Manya (2007), developed in parallel to the research described in this paper, can handle mandatory clauses and is the only
one that incorporates some learning, so it seems to perform well on structured problems. However,
all non-mandatory clauses must have the same weight. Finally, approaches based on translating a
Max-SAT instance into a SAT instance and solve them with a SAT solver seem to be effective in
highly structured problems in which almost all clauses are mandatory (Fu & Malik, 2006; Le Berre,
2006).
In this paper we introduce M INI M AX S AT, a new weighted Max-SAT solver that incorporates
the current best SAT and Max-SAT techniques. It is build on top of M INI S AT + (Een & Sorensson,
2006), so it borrows its capability to deal with pseudo-boolean problems and all the M INI S AT (Een
& Sorensson, 2003) features processing mandatory clauses such as learning and backjumping. We
have extended it allowing it to deal with weighted clauses, while preserving the two-watched literal
lazy propagation method. The main original contribution of M INI M AX S AT is that it implements
a novel and very efficient lower bounding technique. Specifically, it applies unit propagation in
order to detect disjoint subsets of mutually inconsistent clauses as done by Li et al. (2006). Then
it simplifies the problem following Larrosa and Heras (2005), Heras and Larrosa (2006), Larrosa
et al. (2007) in order to increment the lower bound. However, while in those works only the clauses
that accomplish specific patterns are transformed, in M INI M AX S AT there is no need to define such
patterns.
The structure of the paper is as follows: Section 2 provides preliminary definitions on SAT and
Section 3 presents state-of-the-art solving techniques incorporated in a modern SAT solver such as
M INI S AT. Then, Section 4 presents preliminary definitions on Max-SAT and Section 5 overviews
M INI M AX S AT. After that, Sections 6 and 7 focus on its lower bounding and additional features,
respectively. In Section 8 we present the benchmarks used in our empirical evaluation and we
report the experimental results. Finally, Section 9 presents related work and Section 10 concludes
and points out possible future work.

2. Preliminaries on SAT
In the sequel X = {x1 , x2 , . . . , xn } is the set of boolean variables. A literal is either a variable xi or its
negation xi . The variable to which literal l refers is noted var(l). Given a literal l, its negation l is xi
if l is xi and is xi if l is xi . A clause C is a disjunction of literals. The size of a clause, noted |C|, is the
number of literals that it has. The set of variables that appear in C is noted var(C). Sometimes we
associate a subscript Greek letter to a clause (e.g. (xi  x j ) ) in order to facilitate future references
of such clause.
2

fiM INI M AX S AT:

AN

E FFICIENT W EIGHTED M AX -SAT S OLVER

Algorithm 1: DPLL basic structure.
Function Search() : boolean
1
InitQueue( ) ;
2
Loop
3
UP( ) ;
4
if Conflict then
5
AnalyzeConflict( ) ;
6
if Top Conflict then return f alse ;
else
7
LearnClause( ) ;
8
Backjump( ) ;
9
10
11
12

else if all variables assigned then return true ;
else
l := SelectLiteral( ) ;
Enqueue(Q, l) ;

An assignment is a set of literals not containing a variable and its negation. Assignments of
maximal size n are called complete, otherwise they are called partial. Given an assignment A , a
variable x is unassigned if neither x nor x belong to A . Similarly, a literal l is unassigned if var(l)
is unassigned.
An assignment satisfies a literal iff it belongs to the assignment, it satisfies a clause iff it satisfies
one or more of its literals and it falsifies a clause iff it contains the negation of all its literals. In the
latter case we say that the clause is conflicting as it always happens with the empty clause, noted
2. A boolean formula F in conjunctive normal form (CNF) is a set of clauses representing their
conjunction. A model of F is a complete assignment that satisfies all the clauses in F .
If F has a model, we call it satisfiable, otherwise we say it is unsatisfiable. Moreover, if all
complete assignments satisfy F , we say that F is a tautology.
Clauses of size one are called unit clauses or simply units. When a formula contains a unit l, it
can be simplified by removing all clauses containing l and removing l from all the clauses where it
appears. The application of this rule until quiescence is called unit propagation (UP) and it is well
recognized as a fundamental propagation technique in all current SAT solvers.
Another well-known rule is resolution, which, given a formula containing two clauses of the
form (x  A), (x  B) (called clashing clauses), allows one to add a new clause (A  B) (called the
resolvent).

3. Overview of State-of-the-art DPLL-based SAT Solvers
In this section we overview the architecture of SAT solvers based on the DPLL (Davis, Logemann,
& Loveland, 1962) procedure. This procedure, currently regarded as the most efficient complete
search procedure for SAT, performs a systematic depth-first search on the space of assignments. An
internal node is associated to a partial assignment and its two successors are obtained by selecting
an unassigned variable x and extending the current assignment with x and x, respectively. At each
visited node, new units are derived due to the application of unit propagation (UP). If that leads
3

fiH ERAS , L ARROSA , & O LIVERAS

Algorithm 2: Unit Propagation.
Function UP(Q) : Conflict
while (Q contains non-propagated literals) do
13
l := GetFirstNonPropagatedLit(Q); MarkAsPropagated(l) ;
14
foreach clause C  l that becomes unit or falsified do
15
if C  l becomes a unit q then Enqueue(Q, q) ;
16
else if C  l becomes falsified then return Conflict ;
return None ;

to a conflicting clause, the procedure backtracks, performing non-chronological backtracking and
clause learning, as originally proposed by Silva and Sakallah (1996).
An algorithmic description of the DPLL procedure appears in Algorithm 1. The algorithm uses a
propagation queue Q which contains all units pending propagation and also contains a representation
of the current assignment.
First, propagation queue Q is filled with the units contained in the original formula (line 1). The
main loop starts in line 2 and at each iteration procedure UP is in charge of propagating all pending
units (line 3). If a conflicting clause is found (line 4), the conflict is analyzed (line 5) and as a result
a new clause is learned (i.e, inferred and recorded, line 7).
Then, the procedure backtracks, using the propagation queue Q to undo the assignment until
exactly one of the literals of the learned clause becomes unassigned (line 8). If one can further
backtrack while still maintaining this condition, it is advantageous to do so (this is commonly referred to as backjumping or non-chronological backtracking, see Silva & Sakallah, 1996). If UP
leads to no conflict, a new unassigned literal is selected to extend the current partial assignment.
The new literal is added to Q (line 10) and a new iteration takes place.
The procedure stops when a complete assignment is found (line 9) or when a top level conflict
is found (line 6). In the first case, the procedure returns true which indicates that a model has been
found, while in the second case it returns f alse which means that no model exists for the input
formula.
The performance of DPLL-based SAT solvers was greatly improved in 2001, when the SAT
solver C HAFF (Moskewicz, Madigan, Zhao, Zhang, & Malik, 2001) incorporated the two-watched
literal scheme for efficient unit propagation, the First UIP scheme (Zhang, Madigan, Moskewicz,
& Malik, 2001) for clause learning and the cheap VSIDS branching heuristic. Currently, most stateof-the-art SAT solvers, like M INI S AT (Een & Sorensson, 2003), implement small variations of all
these three features. In the following we describe them in more depth.
3.1 Unit Propagation
The aim of unit propagation is twofold: on the one hand, it finds all clauses that have become units
due to the current assignment, and on the other hand, it detects whether some clause has become
conflicting. A more concrete procedure is given in Algorithm 2. While non-propagated literals exist
in Q, it picks the oldest one l and marks it as propagated (line 13). Then all clauses containing l
that may have become falsified or units are traversed (we will later describe how these clauses are
detected). If one of such clauses becomes a unit q, it is enqueued in Q to be propagated later (line
4

fiM INI M AX S AT:

AN

E FFICIENT W EIGHTED M AX -SAT S OLVER

15). The procedure iterates until there are no more units to propagate or until a conflicting clause is
found (line 16).
There are two types of literals in Q: decision literals are those that the algorithm has heuristically
selected and assigned at a branching point (lines 11 and 12 in Algorithm 1); consequence literals are
those which are added because they are logical consequences of previous decision literals (line 15).
M INI S AT uses a non-standard queue to handle units pending propagation. Unlike classical queues,
after fetching an element, it is not removed, but just marked as such. Consequently, Q is formed
by two sets of elements: the already propagated literals and the literals pending propagation. The
advantage of such strategy is that at any execution point, Q also contains the current assignment.
Besides, the propagated literals of Q are divided into decision levels. Each decision level contains a
decision literal and the set of its related consequences. Furthermore, a literal l is associated with the
original clause that caused its propagation and it is noted as l(); such a clause is usually referred
to as the reason of l. Note that a decision literal l does not have a reason and will be represented as
ld .
Example 1 Consider the formula {(x1  x2 ) , (x1  x3 ) , (x4  x5 ) }. Before starting the execution,
the propagation queue is empty Q = [k]. We use the symbol k to separate propagated literals (on
the left) from literals pending propagation (on the right). If literal x1 is selected, it is added to
Q. Before propagation the queue contains Q = [kxd1 ]. UP will propagate x1 and add two new
consequences x2 and x3 . The propagation queue is now Q = [xd1 kx2 (), x3 ()] and the current
assignment is {x1 , x2 , x3 }. The propagation of x2 and x3 does not add new literals to Q, so it becomes
Q = [xd1 , x2 (), x3 ()k]
If x4 is decided, UP will add a new consequence x5 . After the propagation, we have Q =
d
[x1 , x2 (), x3 (), xd4 , x5 ()k]. The current assignment is {x1 , x2 , x3 , x4 , x5 }. Note that no more literals
can be propagated and a complete assignment has been found. Note as well that Q contains two
decision levels: the first one is formed by literals x1 , x2 and x3 while the second one is formed by
literals x4 and x5 .
3.1.1 L AZY DATA S TRUCTURES .
As mentioned, the aim of UP is to detect all units and all conflicting clauses. Taking into account
that this process typically takes up to 80% of the total runtime of a SAT solver, it is important to
design efficient data structures.
The first attempt was the use of adjacency lists. For each literal, one keeps the list of all clauses
in which the literal appears. Then, upon the addition of a literal l to the assignment, only clauses
containing l have to be traversed. The main drawback of further refinements to detect efficiently
when a clause has become unit, such as keeping counters indicating the number of unassigned
literals of a clause, is that they involved a considerable amount of work upon backtracking.
The method used by M INI S AT is the two-watched literal scheme introduced by Moskewicz et al.
(2001). Its basic idea is that a clause cannot be unit or conflicting if (i) it has one satisfied literal or
(ii) it has two unassigned literals.
The algorithm keeps two special literals for each clause, called the watched literals, initially
two unassigned literals, and tries to maintain the invariant that always one satisfied literal or two
unassigned literals are watched.
The invariant may be broken only if one of the two watched literals becomes falsified. In this
case, the clause is traversed looking for another non-false literal to watch in order to restore the
5

fiH ERAS , L ARROSA , & O LIVERAS

invariant. If one such literal cannot be found, the clause is declared to be true, unit or conflicting depending on the value of the other watched literal. Hence, when a literal l is added to the assignment,
the clauses that may have become falsified or unit (line 14 in Algorithm 2) are only those clauses
where l is watched.
The main advantage of such an approach is that no work on the clauses has to be done upon
backtracking. However, the main drawback is that the only way to know how many literals are
unassigned for a given clause is by traversing all its literals. Note that this information is used by
other techniques such as the Two-sided Jeroslow branching heuristic (See Section 3.3).
3.1.2 R ESOLUTION R EFUTATION T REES .
If UP detects a conflict, an unsatisfiable subset of clauses F 0 can be determined using the information provided by Q. Since F 0 is unsatisfiable, the empty clause 2 can be derived from F 0 via
resolution. Such resolution process is called a refutation. A refutation for an unsatisfiable clause set
F 0 is a resolution refutation tree (or simply a refutation tree) if every clause is used exactly once
during the resolution process.
A refutation tree  can be built from the propagation queue Q as follows: let C0 be the conflicting
clause. Traverse Q in a LIFO (Last In First Out) fashion until a clashing clause D0 is found. Then
resolution is applied between C0 and D0 , obtaining resolvent C1 . Next, the traversal of Q continues
until a clause D1 that clashes with C1 is found, giving resolvent C2 and we iterate the process until
the resolvent we obtain is the empty clause 2. The importance of refutation trees will become
relevant in Section 6.
Example 2 Consider F = {(x1 ) , (x1  x4 ) , (x1  x2 ) , (x1  x3  x4 ) , (x1  x2  x3 ) , (x1  x5 ) }.
If we apply unit propagation the unit clause  is enqueued producing Q = [kx1 ()]. Then x1 is
propagated and Q becomes [x1 ()kx4 (), x2 (), x5 ()]. After that, literal x4 is propagated causing
clause  to become unit and Q becomes [x1 (), x4 ()kx2 (), x5 (), x3 ()]. After that, literal x2
is propagated and clause  is found to be conflicting. Figure 1.a shows the state of Q after the
propagation.
Now we build the refutation tree. Starting from the tail of Q the first clause clashing with the
conflicting clause  is . Resolution between  and  generates the resolvent x1  x2  x4 . The first
clause clashing with x2 is , producing resolvent x1  x4 . The next clause clashing with x4 is  and
resolution generates x1 . Finally, we resolve with clause  and we obtain 2.Figure 1.b shows the
resulting refutation tree.
3.2 Learning and Backjumping
Learning and backjumping are best illustrated with an example (see Silva & Sakallah, 1996; Zhang
et al., 2001, for a precise description):
Example 3 Consider the formula {(x1  x2 ) , (x3  x4 ) , (x5  x6 ) , (x2  x5  x6 ) } and the partial
assignment {x1 , x2 , x3 , x4 , x5 , x6 } that leads to a conflict over clause . Suppose that the current
propagation queue is Q = [xd1 , x2 (), xd3 , x4 (), xd5 , x6 ()k].
In the example it is easy to see that decision xd1 is incompatible with decision xd5 . Such incompatibility can be represented with clause (x1  x5 ). Similarly, consequence x2 is incompatible with
decision xd5 and it can be represented with the clause (x2  x5 ).
6

fiM INI M AX S AT:

AN

E FFICIENT W EIGHTED M AX -SAT S OLVER

F = {(x1 ) , (x1  x4 ) , (x1  x2 ) , (x1  x3  x4 ) , (x1  x2  x3 ) , (x1  x5 ) }

(x1  x2  x3 ) (x1  x3  x4 )
x3 ()

x1  x2  x4

(x1  x2 )

x5 ()
x2 ()

x1  x4

(x1  x4 )

x1

(x1 )

x4 ()
x1 ()

2
a)

b)

Figure 1: Graphical representation of the propagation queue Q and a refutation tree  of example
2. On the top, the original formula F . On the left, the propagation Q after step 1. Arrows
indicate the order in which resolving clauses are selected. On the right, the resolution tree
computed in step 2.

Clause learning implements different techniques that are used to discover such implicit incompatibilities and adds them to the formula. Learned clauses can accelerate the subsequent search,
since they can increase the potential of future UP executions. However, it has been observed that
unrestricted clause learning can be impractical in some cases (recorded clauses consume memory
and repeated recording may lead to its exhaustion). For this reason, current SAT solvers incorporate
different clause deletion policies in order to remove some of the learned clauses.
Learned clauses can also be used to backjump if their presence would have allowed a unit propagation at an earlier decision level. In this case, we say that the clause is asserting and backjumping
can proceed by going back to that level and adding the unit propagated literal. Among the several
automated ways of generating asserting clauses, M INI S AT uses the so-called First Unique Implication Point (1UIP) (Zhang et al., 2001).
3.3 Branching Heuristic
Branching occurs in the function SelectLiteral (Algorithm 1). When there are no more literals
to propagate, this function chooses one variable from all the unassigned ones and assigns it a value.
7

fiH ERAS , L ARROSA , & O LIVERAS

The importance of the branching heuristic is well known, since different branching heuristic may
produce different-sized search trees.
Early branching heuristics include the Bohms Heuristic (Buro & Buning, 1993), the Maximum Ocurrences on Minimum sized clauses (MOM) (Freeman, 1995) and the Two sided-Jeroslow
Wang Heuristic (Jeroslow & Wang, 1990). Those heuristics try to choose the literal such that its
assignment will generate the largest number of implications or that satisfy most clauses. All these
heuristics are state dependent, that is, they use information about the state of the clauses given the
current assignment. In most of them, such information is the number of unassigned literals for each
clause. Hence, they were implemented jointly with data structures based on adjacency lists since
they keep such information. For instance, the Two sided-Jeroslow Wang Heuristic computes for
each literal l of F the following function:
J(l) =



2|C|

CF
s.t. lC

and selects the literal l that maximizes function J(l).
As solvers become more efficient, updating metrics of state-dependent heuristics dominates the
execution time. Hence M INI S AT uses a slight modification of a state-independent heuristic first
proposed by Moskewicz et al. (2001). Such heuristic, called Variable State Independent Decaying
Sum (VSIDS), selects the literal that appears more frequently over all clauses, but giving priority to
recently learned clauses. The advantage of this heuristic is that metrics only have to be updated when
clauses are learned. Since this only occurs occasionally, its computation has very low overhead. The
VSIDS heuristic suits perfectly with lazy data structures such as the two-watched literal scheme.

4. (Weighted) Max-SAT
A weighted clause is a pair (C, w), where C is a clause and w is an integer representing the cost
of its falsification, also called its weight. If a problem contains clauses that must be satisfied, we
call such clauses mandatory or hard and associate with them a special weight >. Non-mandatory
clauses are also called soft. A weighted formula in conjunctive normal form (WCNF) is a set of
weighted clauses. A model is a complete assignment that satisfies all mandatory clauses. The cost
of an assignment is the sum of weights of the clauses that it falsifies. Given a WCNF formula F ,
Weighted Max-SAT is the problem of finding a model of F of minimum cost. This cost will be
called the optimal cost of F . Note that if a formula contains only mandatory clauses, weighted
Max-SAT is equivalent to classical SAT. If all the clauses have weight 1, we have the so-called
(unweighted) Max-SAT problem. In the following, we will assume weighted Max-SAT.
We say that a weighted formula F 0 is a relaxation of a weighted formula F (noted F 0 v F ) if
the optimal cost of F 0 is less than or equal to the optimal cost in F (non-models are considered to
have cost infinity). We say that two weighted formulas F 0 and F are equivalent (noted F 0  F ) if
F 0 v F and F v F 0 .
Max-SAT simplification rules transforms a formula F into an equivalent, but presumably simpler formula F 0 . All SAT simplification rules (e.g. unit propagation, tautology removal,...) can be
directly applied to Max-SAT if restricted to mandatory clauses. However, several specific Max-SAT
simplification rules exist (Larrosa et al., 2007). For instance, if a formula contains clauses (C, u)
and (C, v), they can be replaced by (C, u + v). If it contains a clause (C, 0), it may be removed. If it
contains a unit (l, >), it can be simplified by removing all (including soft) clauses containing l and
8

fiM INI M AX S AT:

AN

E FFICIENT W EIGHTED M AX -SAT S OLVER

removing l from all the clauses (including soft clauses) where it appears. The application of this
rule until quiescence is the natural extension of unit propagation to Max-SAT.
The empty clause may appear in a weighted formula. If its weight is >, it is clear that the
formula does not have any model. If its weight is w < >, the cost of any assignment will include
that weight, so w is an obvious lower bound of the formula optimal cost. Weighted empty clauses
and their interpretation in terms of lower bounds will become relevant in Section 6.
As shown by Larrosa et al. (2007), the notion of resolution can be extended to weighted formulas
as follows 1 ,


(A  B, m),








 (x  A, u  m), 
(x  B, w  m),
{(x  A, u), (x  B, w)} 



(x  A  B, m), 






(x  A  B, m)

where A and B are arbitrary disjunctions of literals and m = min{u, w}.
(x  A, u) and (x  B, w) are called the prior clashing clauses, (A  B, m) is called the resolvent,
(x  A, u  m) and (x  B, w  m) are called the posterior clashing clauses, and (x  A  B, m) and
(x  A B, m) are called the compensation clauses. The effect of Max-SAT resolution, as in classical
resolution, is to infer (namely, make explicit) a connection between A and B. However, there is an
important difference between classical resolution and Max-SAT resolution. While the former yields
the addition of a new clause, Max-RES is a transformation rule. Namely, it requires the replacement
of the left-hand clauses by the right-hand clauses. The reason is that some cost of the prior clashing
clauses must be substracted in order to compensate the new inferred information. Consequently,
Max-RES is better understood as a movement of knowledge in the formula.
The resolution rule for Max-SAT preserves equivalence (). The last two compensation clauses
may lose the clausal form, so the following rule (Larrosa et al., 2007) may be needed to recover it:

A  l : |B| = 0
CNF(A  l  B, u) =

{(A  l  B, u)} CNF(A  B, u) : |B| > 0

Example 4 If we apply weighted resolution to the following clauses {(x1  x2 , 3), (x1  x2  x3 , 4)}
we obtain {(x2  x2  x3 , 3), (x1  x2 , 3  3), (x1  x2  x3 , 4  3), (x1  x2  (x2  x3 ), 3), (x1  x2  x2 
x3 , 3)}. The first clause can be simplified. The second clause can be omitted because it weight is
zero. The fifth clause can be omitted because it is a tautology. The fourth element is not a clause
because it is not a simple disjunction. Hence, we apply CNF rule to it and we obtain two new
clauses CNF(x1  x2  (x2  x3 ), 3) = {(x1  x2  x2  x3 , 3), (x1  x2  x3 , 3)}. Note that the first new
clause is a tautology. Therefore, we obtain the equivalent formula {(x2  x3 , 3), (x1  x2  x3 , 1), (x1 
x2  x3 , 3)}.

5. Overview of M INI M AX S AT
M INI M AX S AT is a weighted Max-SAT solver built on top of M INI S AT + (Een & Sorensson, 2006).
Any other DPLL-based SAT solver could have been used, but M INI S AT + was particularly wellsuited because of its short and open-source code. Besides, it can deal with pseudo-boolean constraints.
1. If A is the empty clause then A represents a tautology. For the special weight >, we have the relations >  m = >
and >  > = > (Larrosa et al., 2007)

9

fiH ERAS , L ARROSA , & O LIVERAS

Algorithm 3: M INI M AX S AT basic structure.
Function Search() : integer
17
ub := LocalSearch(); lb := 0 ;
18
InitQueue(Q) ;
19
Loop
20
Propagate() ;
21
if Hard Conflict then
AnalyzeConflict() ;
if Top Level Hard Conflict then return ub ;
else
LearnClause() ;
Backjump() ;
22

23
24
25

26

else if Soft Conflict then
ChronologicalBactrack() ;
if End of Search then return ub ;
else if all variables assigned then
ub := lb ;
if ub = 0 then return ub ;
ChronologicalBactrack() ;
if End of Search then return ub ;
else
l := SelectLiteral() ;
Enqueue(Q, l) ;

Given a WCNF formula (possibly containing hard and soft clauses), M INI M AX S AT returns the
cost of the optimal model (or > if there is no model). This is achieved by means of a branch-andbound search, as it is usually done to solve optimization problems.
Like M INI S AT, the tree of assignments is traversed in a depth-first manner. At each search point,
the algorithm tries to simplify the current formula and, ideally, detect a conflict, which would mean
that the current partial assignment cannot be successfully extended. M INI M AX S AT distinguishes
two types of conflicts: hard and soft. Hard conflicts indicate that there is no model extending the
current partial assignment (namely, all the mandatory clauses cannot be simultaneously satisfied).
Hard conflicts are detected taking only into account hard clauses and using the methods of M INI S AT.
When a hard conflict occurs, M INI M AX S AT learns a hard clause and backjumps as M INI S AT would
do. Soft conflicts indicate that the current partial assignment cannot be extended to an optimal
assignment. In order to identify soft conflicts, the algorithm maintains two values during the search:
 The cost of the best model found so far, which is an upper bound ub of the optimal solution.
 An underestimation of the best cost that can be achieved extending the current partial assignment into a model, which is a lower bound lb of the current subproblem.
A soft conflict is detected when lb  ub, because it means that the current assignment cannot lead to
an optimal model. When a soft conflict is detected, the algorithm backtracks chronologically. Note
10

fiM INI M AX S AT:

AN

E FFICIENT W EIGHTED M AX -SAT S OLVER

Algorithm 4: MiniMaxSat propagation.
Function MS-UP() : conflict
while (Q contains non-propagated literals) do
27
l := GetFirstNonPropagatedLit(Q); MarkAsPropagated(l) ;
 ;
28
lb := lb +V (l))
29
if lb  ub then return Soft Conflict ;
 >) that becomes unit or falsified do
30
foreach Hard clause (C l,

31
if (C  l, >) becomes unit (q, >) then Enqueue(Q, q) ;
 >) becomes falsified then return Hard Conflict ;
32
else if (C  l,
 u) that becomes unit do
33
foreach Soft clause (C l,

34
if (C l, u) becomes a unit (q, u) then V (q) := V (q) + u ;

35
36
37
38
39

return None ;
Function Propagate() : conflict
c := MS-UP( ) ;
if c = Hard or Soft Conflict then return c ;
improveLB( ) ;
if lb  ub then return Soft Conflict ;
return None ;

that one could also backjump by computing a clause expressing the reasons that led to lb  ub.
However, in the presence of lots of soft clauses, this approach ends up creating too many long
clauses which affect negatively to the efficience of the solver and hence we decided to perform
simple chronological backtracking.
We also want to remark that any soft clause (C, w) with w  ub must be satisfied in an optimal
assignment. Therefore, in the following we assume that such soft clauses are automatically transformed into hard clauses previous to search. Other than those ones, no other soft clause is promoted
into a hard one during the search.
An algorithmic description of M INI M AX S AT is presented in Algorithm 3. Before starting the
search, a good initial upper bound is obtained with a local search method (line 17) which may yield
the identification of some new hard clauses. In our current implementation we use U BCSAT (Tompkins & Hoos, 2004) with default parameters. The selected local search algorithm is IROTS (Iterated
Robust Tabu Search) (Smyth, Hoos, & Stutzle, 2003). Besides, the lower bound is initialized to
zero. Next, the queue Q is initialized with all unit hard clauses in the resulting formula (line 18).
The main loop starts in line 19 and each iteration is in charge of propagating all pending literals
(line 20) and, if no conflict is detected, attempting the extension of the current partial assignment
(line 26). Pending literals in Q are propagated in function Propagate (line 20), which may return a hard or soft conflict. If a hard conflict is encountered (line 21) the conflict is analyzed, a
new hard clause is learned and backjumping is performed. This is done as introduced in Section 3.
If a soft conflict is encountered (line 22) chronological backtracking is performed. If no conflict is
found (line 26), a literal is heuristically selected and added to Q for propagation in the next iteration.
However, if the current assignment is complete (line 23), the upper bound is updated. Search stops
if a zero-cost solution is found, since it cannot be further improved (line 24). Else, chronological
backtracking is performed (line 25). Note that backjumping leads to termination if a top level hard
11

fiH ERAS , L ARROSA , & O LIVERAS

conflict is found, while chronological backtracking leads to termination if the two values for the first
assigned variable have been tried.
Algorithm 4 describes the propagation process (function Propagate). It uses an array V (l)
which accumulates the weight of all soft clauses that have become unit over l; namely, original
clauses (A  l, w) such that the current assignment falsifies A. If no such clauses exists, we assume
V (l) = 0. First of all, it performs a Max-SAT-adapted form of unit propagation (MS-UP, line 35).
MS-UP iterates over the non-propagated literals l in Q (line 27). Firstly, adding l to the assignment
 we
may make a set of soft clauses falsified. Since the cost of all such clauses is kept in V (l),
add it to the lower bound (line 28). If the lower bound increment identifies a soft conflict, it is
returned (line 29). Then, if a hard clause becomes unit, the corresponding literal is added to Q
for future propagation (line 31). Finally, if a soft clause becomes a unit clause (q, u) (line 33), its
weight u is added to V (q) (line 34). If during this process a hard conflict is detected, the function
returns it (lines 32,36). Else, the algorithm attempts to detect a soft conflict with a call to procedure
improveLB (line 37), and it returns the soft conflict if it is found (line 38). In the next section a
detailed description of improveLB can be found. Finally, if no conflict is detected, the function
returns None (line 39).

6. Lower Bounding in M INI M AX S AT
In the following, we consider an arbitrary search state of M INI M AX S AT before the call to the
procedure improveLB. For the purpose of this section, such a search state can be characterized
by the current assignment. The current assignment determines the current subformula which is the
original formula conditioned by the current assignment: If a clause contains a literal that is part of
the current assignment, it is removed. Besides, all the literals whose negation appear in the current
assignment are removed from the clauses where they appear.
The value of lb maintained by M INI M AX S AT is precisely the aggregation of costs of all the
clauses that have become empty due to the current assignment. Similarly, we recall that the value
V (l) is the aggregation of costs of all the clauses that have become unit over l due to the current
assignment. Thus, the current subformula contains (2, lb) and (l,V (l)) for every l.
M INI M AX S AT computes its lower bound by deriving new soft empty clauses (2, w) through
a resolution process. Such clauses are added to the already existing clause (2, lb) producing an
increment of the lower bound.
 w) by (l, u  m), (l,
 w
As a first step, improveLB replaces each occurrence of (l, u) and (l,
m), (2, m) (with m = min{u, w}), which amounts to applying a restricted version of Max-SAT resolution known as Unit Neighborhood Resolution (UNR) (Larrosa et al., 2007).
It produces an immediate increment of the lower bound (i.e., the weight of the empty clause at
line 43) as it is illustrated in the following example,
Example 5 Consider the current state is {(2, 3), (x1 , 1), (x2 , 1), (x1 , 2), (x2 , 2), (x1  x2 , 3)}. UNR
would resolve on clauses (x1 , 1) and (x1 , 2) replacing them by (x1 , 1) and (2, 1) (all other compensation clauses are removed because their weight is zero or they are tautologies). The two empty
clauses can be grouped into (2, 3 + 1 = 4). UNR would also resolve on clauses (x2 , 1) and (x2 , 2)
replacing them by (x2 , 1) and (2, 1). The two empty clauses can be grouped into (2, 4 + 1 = 5). So,
the new equivalent formula is {(2, 5), (x1 , 1), (x2 , 1), (x1  x2 , 3)} with a higher lower bound of 5.
12

fiM INI M AX S AT:

AN

E FFICIENT W EIGHTED M AX -SAT S OLVER

Algorithm 5: Lower Bounding in M INI M AX S AT
Function SUP() : conflict
40
InitQueue(Q) ;
while (Q contains non-propagated literals) do
l := GetFirstNonPropagatedLit(Q); MarkAsPropagated(l) ;
41
foreach (Hard or Soft) Clause C  l that becomes unit or falsified do
if C  l becomes a unit q then Enqueue(Q, q) ;
else if C  l becomes falsified then return conflict ;

42
43
44
45
46
47
48

return None ;
Procedure improveLB() : lb
 w)  F do
foreach (l, v), (l,
 w  m), (2, m) with m := min (v, w) ;
replace them by (l, v  m), (l,
while SU P() = con f lict do
 := BuildTree() ;
m := minimum weight among clauses in ;
if Condition then ApplyResolution( , m ) ;
else lb := lb + m; remove weight m from clauses in ;

As a second step improveLB executes a simulation of unit propagation (SUP, line 44) in
which soft clauses are treated as if they were hard. First, SUP adds to Q all unit soft clauses (line
40). Then, the new literals in Q are propagated. When new (hard or soft) clauses become unit,
they are inserted in Q (line 41). If SUP yields a conflict, it means that there is a subset of (soft or
hard) clauses that cannot be simultaneously satisfied. We showed in Section 3 that Q can be used
to identify such subset and build a refutation tree . ImproveLB computes such a tree (line 45).
If we take into account again the weights of the clauses and apply Max-SAT resolution (Section 4)
as dictated by , one can see that it will produce a new clause (2, m), where m is the minimum
weight among all the clauses in the tree (line 46). It means that the extension of the current partial
assignment to the unassigned variables will have a cost of at least m.
It is important to remark that at each step in the Max-SAT resolution process we do not consider
the minimum of the weight of the two clauses, but rather the minimum of all the clauses in the
resolution tree. This is why m is passed as a parameter in line 47.
The result of the resolution process is the replacement of all the clauses in the leaves of  by
(2, m) and the corresponding compensation clauses (function ApplyResolution in line 47),
thus obtaining an equivalent formula with a lower bound increment of m. We call this procedure
resolution-based lower bounding.
Example 6 Consider the formula F = {(x1 , 2) , (x1  x4 , 1) , (x1  x2 , >) , (x1  x3  x4 , 2) , (x1 
x2  x3 , 3) , (x1  x5 , 1) }
Step 1. Apply SUP. Initially, the unit clause  is enqueued producing Q = [kx1 ()]. Then
x1 is propagated and Q becomes [x1 ()kx4 (), x2 (), x5 ()]. Literal x4 is propagated and clause 
becomes unit, producing Q = [x1 (), x4 ()kx2 (), x5 (), x3 ()]. After that, literal x2 is propagated
and clause  is found to be conflicting. Figure 2.a shows the state of Q after the propagation.
13

fiH ERAS , L ARROSA , & O LIVERAS

F = {(x1 , 2) , (x1  x4 , 2) , (x1  x2 , >) , (x1  x3  x4 , 2) , (x1  x2  x3 , 3) , (x1  x5 , 1) }

(x1  x2  x3 , 3) (x1  x3  x4 , 2)

x3 ()






x5 ()



x2 ()

(x1  x2  x3 , 1)
(x1  x2  x3  x4 , 2) (x1  x2  x4 , 2) (x1  x2 , >)
(x1  x2  x3  x4 , 2)
(x1  x2 , >)

(x1  x4 , 2)

(x1  x4 , 2)



x4 ()
x1 ()

(x1 , 2)

2

(x1 , 2)

(2, 2)

a)

b)

c)

F 0 = {(x1  x2 , >), (x1  x5 , 1), (2, 2), (x1  x2  x3 , 1), (x1  x2  x3  x4 , 2), (x1  x2  x3  x4 , 2)}
F

00

= {(x1  x2 , >), (x1  x2  x3 , 1), (x1  x5 , 1), (2, 2)}

Figure 2: Graphical representation of M INI M AX S AT lower bounding. On the top, the original
current formula F . On the left, the propagation Q after step 1. In the middle, the structure
of the refutation tree computed by the simulation of UP in step 2. On the right, the
effect of actually executing the Max-SAT resolution (step 3). The resulting formula F 0
appears bellow. If substraction-based lower bounding is performed, step 3 is replaced by
a substraction of weights, producing formula F 00 .

Step 2. Build the simulated refutation tree. Starting from the tail of Q the first clause clashing
with the conflicting clause  is . Resolution between  and  generates the resolvent x1  x2  x4 .
The first clause clashing with x2 is , producing resolvent x1  x4 . The next clause clashing with
x4 is  and resolution generates x1 . Finally, we resolve with clause  and we obtain 2.Figure 2.b
shows the resulting resolution tree.
Step 3. Apply Max-SAT resolution. We apply Max-SAT resolution as indicated by the refutation
tree computed in Step 2. Figure 2.c graphically shows the result of the process. Leaf clauses are
the original (weighted) clauses involved in the resolution. Each internal node indicates a resolution
step. The resolvents appear in the junction of the edges. Beside each resolvent, inside a box, there
are the compensation clauses that must be added to the formula to preserve equivalence. Since
clauses that are used in resolution must be removed, the resulting formula F 0 consists of the root of
14

fiM INI M AX S AT:

AN

E FFICIENT W EIGHTED M AX -SAT S OLVER

the tree ((2, 2)),all compensation clauses and all clauses not used in the refutation tree. That is, the
resulting formula is F 0 = {(x1  x2 , >), (x1  x5 , 1), (2, 2), (x1  x2  x3 , 1), (x1  x2  x3  x4 , 2), (x1 
x2  x3  x4 , 2)}. The soundness of Max-SAT resolution guarantees that F  F 0 .
Remark 1 All the transformations applied by the resolution-based lower bounding can be passed
on to descendent nodes because the changes preserve equivalence. Nevertheless, transformations
have to be restored when backtracking takes place.
An alternative to problem transformation through resolution is to identify the lower bound increment m and then substract it from all the clauses that would have participated in the resolution
tree. This procedure is similar to the lower bound computed by Li et al. (2005) and we call it
substraction-based (line 48) lower bounding.
Example 7 Consider formula F from the previous example. Steps 1 and 2 are identical. However,
substraction-based lower bounding would replace Step 3 by Step 3 that substracts weight 2 from
the clauses that appear in the refutation tree and then adds (2, 2) to the formula. The result is
F 00 = {(x1  x2 , >), (x1  x2  x3 , 1), (x1  x5 , 1), (2, 2)}. Note that F 00 v F .
Remark 2 All the substractions applied by the substraction-based lower bounding have to be restored before moving to a descendent node because they do not preserve equivalence.
After the increment of the lower bound with either technique, procedure SUP can be executed
again, which may yield new lower bound increments. The process is repeated until SUP does not
detect any conflict.
When comparing the two previous approaches, we observe that resolution-based lower bounding
has a larger overhead, because resolution steps need to be actually computed and their consequences
must be added to the current formula and removed upon backtracking. However, the effort invested
in the transformation may be well amortized because the increment obtained in the lower bound
becomes part of the current formula, so it does not have to be discovered again and again by all
the descendent nodes of the search. On the other hand, substraction-based lower bounding has a
smaller overhead because resolution needs not to be actually computed. This also facilitates the
context restoration upon backtracking.
M INI M AX S AT incorporates the two alternatives and chooses to apply one or the other heuristically (lines 47,48) depending on a specific condition (line 47). We observed that resolution-based
lower bounding seems to be more effective if resolution is only applied to low arity clauses. As a
consequence, after the identification of the resolution tree, M INI M AX S AT applies resolution-based
lower bounding only if the largest resolvent in the resolution tree has arity strictly less than 4. Otherwise, it applies substraction-based lower bounding. See Section 8 for more details.

7. Additional Features of M INI M AX S AT
In this section we overview other important features of M INI M AX S AT, namely the use of the twowatched literal scheme, its branching heuristic, the use of soft probing and how M INI M AX S AT
deals with pseudo-boolean functions.
15

fiH ERAS , L ARROSA , & O LIVERAS

7.1 Two-Watched Literals
M INI M AX S AT uses the two-watched literal scheme also on soft clauses. Recall that one of the main
advantages of this technique, when applied to pure SAT problems, is that when backtracking takes
place, no work has to be done on the clauses. Unfortunately, in the case of soft clauses some restoration needs to be done. When a soft clause becomes unit over literal l in function MS-UP, its weight
is added to V (l) and the clause is eliminated (or marked as eliminated) to avoid reusing it in the
lower bounding procedure. These changes, as well as any addition to lb, have to be restored when
backtracking is performed. However, note that during the executions of SUP (simulation of unit
propagation) all clauses are considered as hard. In this case the two-watched literal scheme works
exactly as in a SAT solver with both hard and soft clauses. When an inconsistency is detected by
SUP or it stops because there are no more literals to propagate, the initial state has to be recovered.
In that situation restoring the initial state is completely overhead free.
7.2 Branching Heuristic
M INI M AX S AT incorporates two alternative branching heuristics. The first one is the VSIDS heuristic (Moskewicz et al., 2001) disregarding soft clauses (that is, M INI S AT  S default). This heuristic is
likely to be good in structured problems in which learning and backjumping play a significant role,
as well as in problems in which it is difficult to find models (namely, the satisfaction component of
the problem is more difficult than the optimization component). Since this heuristic disregards soft
clauses, it is likely to be ineffective in problems where it is easy to find models and the difficulty
is to find the optimal one and prove its optimality. In the extreme case, where problems only contain soft clauses (every complete assignment is a model) the VSIDS heuristic is blind and therefore
completely useless.
To overcome this limitation of VSIDS, M INI M AX S AT also incorporates the Weighted Jeroslow
heuristic (Heras & Larrosa, 2006). It is the extension of the SAT Jeroslow heuristic described in
Section 3. Given a weighted formula F, for each literal l of F the following function is defined:
J(l) =



2|C|  w

(C,w)F
s.t. lC

where mandatory clauses are assumed to have a weight equal to the upper bound ub. The heuristic
selects the literal with the highest value of J(l). Its main disadvantage is that metrics need to be
updated at each visited node. In combination with the two-watched literal this updating becomes
expensive and does not seem to pay off in general. Thus, in our current implementation of the
heuristic, the J(l) values are computed only at the root node and used throughout all the solving
process. We found in our experiments that this heuristic is a good alternative in problems where
the difficulty lies on the optimization part (e.g. problems with many models). M INI M AX S AT
automatically changes from VSIDS to weighted Jeroslow if the problem does not contain any literal
l such that there are some hard clauses with l and some other hard clauses with l.
In both heuristics, if there is some literal l such that V (l) + lb  ub at some node of the search
tree, then l is the selected literal and l is never assigned.
16

fiM INI M AX S AT:

AN

E FFICIENT W EIGHTED M AX -SAT S OLVER

7.3 Soft Probing
Probing is a well-known SAT technique that allows the formulation of hypothetical scenarios (Lynce
& Silva, 2003). The idea is to temporarily assume that l is a hard unit clause and then execute unit
propagation. If UP yields a conflict, we know that any model extending the current assignment must
contain l. The process is iterated over all the literals until quiescence. Exhaustive experiments in
the SAT context indicate that it is too expensive to probe during the search (Le Berre, 2001; Lynce
& Silva, 2003), so it is normally done as a pre-process in order to reduce the initial number of
branching points.
We can easily extend this idea to Max-SAT. In that context, besides the discovery of unit hard
clauses, it may be used to make explicit weighted unit clauses. We call it soft probing. As in SAT, the
idea is to temporarily assume that l is a unit clause and then simulate unit propagation (i.e., execute
SUP()). Then, we build the resolution tree  from the propagation queue Q. If all the clauses in 
are hard, we know that l must be added to the assignment. Else, we can reproduce  applying Max m) where m is the minimum
SAT resolution with the weighted clauses and derive a unit clause (l,
weight among the clauses in . Having unit soft clauses upfront makes the future executions of
improveLB much more effective in the subsequent search. Besides, if we derive both (l, u) and
 w), we can generate via unit neighborhood resolution (see Example 5) an initial non-trivial lower
(l,
bound of min{u, w}. We tested soft probing during the search and as a preprocessing in several
benchmarks. We observed empirically that soft probing as a preprocessing was the best option as it
is in SAT.

Example 8 Consider formula F = {(x1  x2 , 1) , (x1  x3 , 1) , (x2  x3 , 1) }. If we assume x1 by
adding it to Q and then execute SUP a conflict is reached. We obtain Q = [xd1 , x2 (), x3 ()] and
we detect that  is a conflicting clause. The clauses involved in the refutation tree are , , and .
Resolving clauses  and  results in {(x1  x2 , 1) , (x1  x2 , 1), (x1  x2  x3 , 1), (x1  x2  x3 , 1)}. The
resolution of the previous resolvent and  produces the (equivalent) formula F 0 = {(x1 , 1), (x1 
x2  x3 , 1), (x1  x2  x3 , 1)}.
7.4 Pseudo-boolean Functions
A pseudo-boolean optimization problem (PBO) (Barth, 1995; Sheini & Sakallah, 2006; Een &
Sorensson, 2006) has the form:
minimize nj=1 c j  x j
subject to nj=1 ai j l j  bi , i = 1 . . . m
where x j  {0, 1}, l j is either x j or 1  x j , and c j , ai j and bi are non-negative integers.
If M INI M AX S AT is provided with a PBO instance, it translates it into a Max-SAT formula as follows: each pseudo boolean constraint is translated into a set of hard clauses using M INI S AT + (Een
& Sorensson, 2006) (the algorithm heuristically decides the most appropriate translation choosing
among adders, sorters or BDDs). The objective function is translated into a set of soft unit clauses.
Each summand c j  x j becomes a new soft unit clause (x j , c j ). After the translation M INI M AX S AT
is executed as usual.
17

fiH ERAS , L ARROSA , & O LIVERAS

8. Empirical Results
In this section we present the benchmarks and the solvers used in our empirical evaluation. Then,
we report the experiments performed in order to adjust the parameters of M INI M AX S AT. Finally, a
comparison with other solvers is presented.
8.1 Benchmarks and Encodings
Having a good set of problems is fundamental to show the effectiveness of new solvers. In the
following, we present several problems and we explain how to encode them as Weighted Max-SAT.
8.1.1 M AX - K -SAT
A k-SAT CNF formula is a CNF formula in which all clauses have size k. We generated random
unsatisfiable 2-SAT and 3-SAT formulas with the Cnfgen generator2 and solved the corresponding
MAX-SAT problem. In the benchmarks, we fixed the number of variables and varied the number of
clauses, which can be repeated.
8.1.2 M AX - CUT
Given a graph G = (V, E), a cut is defined by a subset of vertices U  V . The size of a cut is
the number of edges (vi , v j ) such that vi  U and v j  V  U . The Max-cut problem consists on
finding a cut of maximum size. It can be encoded as Max-SAT associating one variable xi to each
graph vertex. Value true (respectively, false) indicates that vertex vi belongs to U (respectively, to
V  U ). For each edge (vi , v j ), there are two soft clauses (xi  x j , 1), (xi  x j , 1). Given a complete
assignment, the number of violated clauses is |E|  S where S is the size of the cut associated to the
assignment. In our experiments we considered Max-Cut instances extracted from random graphs of
60 nodes with varying number of edges.
8.1.3 M AX - ONE
Given a satisfiable CNF formula, max-one is the problem of finding a model with a maximum
number of variables set to true. This problem can be encoded as Max-SAT by considering the
clauses in the original formula as mandatory and adding a weighted unary clause (xi , 1) for each
variable in the formula. Note that solving this problem is much harder than solving the usual SAT
problem, because the search cannot stop as soon as a model is found. The optimal model must be
found and its optimality must be proved. We considered the max-one problem over two types of
CNF formula: random 3-SAT instances of 120 variables (generated with Cnfgen), and structured
satisfiable instances coming from the 2002 SAT Competition3 .
8.1.4 M INIMUM V ERTEX C OVERING

AND

M AX -C LIQUE

Given a graph G = (V, E), a vertex covering is a set U  V such that for every edge (vi , v j ) either
vi  U or v j  U . The size of a vertex covering is |U |. The minimum vertex covering problem
consists in finding a covering of minimal size. It can be naturally formulated as (weighted) MaxSAT. We associate one variable xi to each graph vertex vi . Value true (respectively, false) indicates
2. A. van Gelder ftp://dimacs.rutgers.edu/pub/challenge/satisfiability/contributed/UCSC/instances
3. http://www.satcompetition.org/2002/

18

fiM INI M AX S AT:

AN

E FFICIENT W EIGHTED M AX -SAT S OLVER

that vertex vi belongs to U (respectively, to V U ). There is a binary hard (xi  x j , >) for each edge
(vi , v j ). It specifies that one or both of these two vertices have to be in the covering because there
is an edge connecting them. There is a unary clause (xi , 1) for each variable xi , in order to specify
that it is preferred not to add vertices to U . There is a simple way to transform minimum vertex
coverings into max-cliques and vice-versa (Fahle, 2002).
In our experiments, we considered maximum clique instances extracted from random graphs
with 150 nodes and varying number of edges. We also considered the 66 Max-Clique instances
from the DIMACS challenge4 .
8.1.5 C OMBINATORIAL AUCTIONS
A combinatorial auction is defined by a set of goods G and a set of bidders that bid for indivisible
subsets of goods. Each bid i is defined by the subset of requested goods Gi  G and the amount of
money offered. The bid-taker, who wants to maximize its revenue, must decide which bids are to be
accepted. Note that if two bids request the same good, they cannot be jointly accepted (Sandholm,
1999). In its Max-SAT encoding, there is one variable xi associated to each bid. There are unit
clauses (xi , ui ) indicating that if bid i is not accepted there is a loss of profit ui . Besides, for each
pair i, j of conflicting bids, there is a mandatory clause (xi  x j , >).
In our experiments, we used the CATS generator (K. Leyton-Brown & Shoham, 2000) that
allows to generate random instances inspired from real-world scenarios. In particular, we generated
instances from the Regions, Paths and Scheduling distributions. The number of goods was fixed to
60 and we increased the number of bids. By increasing the number of bids, instances become more
constrained (namely, there are more conflicting pairs of bids) and harder to solve.
8.1.6 M ISCELLANEOUS
We also considered the following sets of instances widely used in the literature:
 The unsatisfiable instances of the 2nd DIMACS Implementation Challenge 5 considered by
de Givry, Larrosa, Meseguer, and Schiex (2003) and Li et al. (2005): random 3-SAT instances
(aim and dubois), pigeon hole problem (hole) and coloring problems (pret). Observe that all
these instances are modelled as unweighted Max-SAT (i.e. all clauses have weight 1).
 Max-CSP random instances generated using the protocol specified by Larrosa and Schiex
(2003) and de Givry, Heras, Larrosa, and Zytnicki (2005). We distinguish 4 different sets of
problems: Dense Loose (DL), Dense Tight (DT), Sparse Loose (SL) and Sparse Tight (ST).
Tight instances have about 20 variables while loose instances have about 40 variables. Each
set contains 10 instances with 3 values and 10 instances with 4 values per variable.
 Planning (Cooper, Cussat-Blanc, de Roquemaurel, & Regnier, 2006) and graph coloring 6
structured instances taken from a Weighted Constraint Satisfaction Problem (WCSP) repository 7 .
4.
5.
6.
7.

ftp://dimacs.rutgers.edu/pub/challenge/graph/benchmarks/clique
http://mat.gsia.cmu.edu/challenge.html
http://mat.gsia.cmu.edu/COLORING02/benchmarks
http://mulcyber.toulouse.inra.fr/plugins/scmcvs/cvsweb.php/benchs/?cvsroot=toolbar

19

fiH ERAS , L ARROSA , & O LIVERAS

 Problems taken from the 2006 pseudo-boolean evaluation 8 : logic synthesis, misc (garden),
routing, MPI (Minimum Prime Implicant), MPS (miplib). These instances are encoded to
Max-SAT as specified in the previous section.
Note that Max-CSP, Planning and graph coloring instances are encoded into Max-SAT using the
direct encoding (Walsh, 2000).
8.2 Alternative Solvers
We compare M INI M AX S AT with several optimizers from different communities. We restricted our
comparison to freely available solvers. We considered the following ones:
 M AXSATZ (Li et al., 2006; Li, Manya, & Planes, 2007). Unweighted Max-SAT solver. It was
the best unweighted Max-SAT solver in the 2006 Max-SAT Evaluation.
 M AX -DPLL (Heras & Larrosa, 2006; Larrosa et al., 2007). Weighted Max-SAT solver. It is
part of the T OOLBAR package. It was the best solver for weighted Max-SAT and the second
best solver for unweighted Max-SAT in the 2006 Max-SAT Evaluation.
 T OOLBAR (Larrosa, 2002; Larrosa & Schiex, 2003; de Givry et al., 2003, 2005). It is a
state-of-the-art Weighted CSP solver.
 P UEBLO 1.5 (Sheini & Sakallah, 2006). It is a pseudo-boolean solver. It ranked first on
several categories of the 2005 Pseudo Boolean Evaluation.
 M INISAT + (Een & Sorensson, 2006). It is a pseudo-boolean solver that translates the problems into SAT and solves them with MiniSat. It ranked first on several categories of the 2005
Pseudo Boolean Evaluation.
Those instances taken from the pseudo-boolean evaluation were given in their original format to
P UEBLO and M INISAT +. All other instances were translated from Max-SAT to PBO by partitioning
the set of clauses into three sets: H contains the mandatory clauses (C, >), W contains the nonunary weighted clauses (C, u < >) and U contains the unary weighted clauses (l, u). For each
hard clause (C j , >)  H there is a pseudo boolean constraint C0j  1, where C0j is obtained from
C j by replacing  by + and negated variables x by 1  x. For each non-unary weighted clause
(C j , u j )  W there is a pseudo boolean constraint C0j + r j  1, where C0j is computed as before,
and r j is a new variable that, when set to 1, trivially satisfies the constraint. Finally, the objective
function to minimize is,



u jr j +



u jl j

(l j ,u j )U

(C j ,u j )W

8.3 Experimental Results
We divide the experiments in two parts. The purpose of the first part is to evaluate the impact
of the different techniques of M INI M AX S AT and set the different parameters. Since some of the
techniques can be effective in some benchmarks and useless or even counterproductive in some others (Brglez, Li, & Stallman, 2002), we aimed at finding a configuration such that M INI M AX S AT
8. http://www.cril.univ-artois.fr/PB06/

20

fiM INI M AX S AT:

AN

E FFICIENT W EIGHTED M AX -SAT S OLVER

performs reasonably well on all the instances. The purpose of the second part is to compare M IN I M AX S AT with alternative solvers. Since some of these solvers are specifically designed for some
type of problems, we do not expect that M INI M AX S AT will outperform them. We rather want to
show the robustness of M INI M AX S AT by showing that it is usually close in performance with the
best alternative for each type of problems.
Results are presented in plots and tables. Regarding tables, the first column contains the name
of the set of problems. The second column shows the number of instances. The remaining columns
report the performance of the different solvers. Each cell contains the average cpu time that the
solver required to solve all instances. If some solver could not solve all the instances of a set, a
number inside brackets indicates the number of solved instances and the average cpu time only
takes into account solved instances. If a cell contains a dash, it means that no instance could be
solved within the time limit. Regarding plots, note that the legend goes in accordance with the
performance of the solvers. The time limit was set to 900 seconds for each instance.
Our solver, written in C++, was implemented on top of M INISAT + (Een & Sorensson, 2006).
Executions were made on a 3.2 Ghz Xeon computer with Linux. In all the experiments with random
instances, samples had 30 instances and plots report mean cpu time in seconds.
8.4 Setting the Parameters of M INI M AX S AT
In the following we evaluate in order the importance of the following techniques inside M INI M AX S AT: lower bounding, soft probing, branching heuristics, learning and backjumping.
Starting from a basic version that guides search with the Jeroslow branching heuristic and has
the rest of techniques deactivated, we analyze them one by one. Each analysis studies one technique
and incorporates all the previously analyzed ones with the corresponding tuned parameters. In the
three first experiments we only consider little but challenging instances generated randomly in which
lower bounding plays a fundamental role to solve them. Finally, we consider structured instances in
which learning and backjumping is required to solve them.
8.4.1 L OWER

BOUNDING

In this experiment we analyze the impact of resolution-based lower bounding versus substractionbased lower bounding, as well as combined strategies. We considered the following combination
of the two techniques: when SUP detects an inconsistency and the refutation tree is computed,
we look at the resolvent with maximum size. If its size is less than or equal to a parameter K,
then resolution-based lower bounding is applied, otherwise substraction-based lower bounding is
applied. We tested K = {0, 1, 2, 3, 4, 5, }. Note that K = 0 corresponds to pure substraction-based
lower bounding (and therefore is similar to the approach of Li et al., 2005), while K =  corresponds
to a pure resolution-based lower bounding.
The results are presented in Figure 3. As can be seen, the pure substraction-based lower bounding K = 0 is always the worst option. Better results are obtained as K increases. However, the
improvement stops (or nearly stops) when K = 3. When K > 3 no significant improvement is noticed. The plot omits the K = 4 and K = 5 case for clarity reasons. Since higher values of K may
produce new clauses of higher size and this may cause overhead in some instances, we set K = 3
for the rest of the experiments.
21

fiH ERAS , L ARROSA , & O LIVERAS

(a) Max-2-SAT, 100 variables

15
10

(b) Max-3-SAT, 60 variables

K=0
K=1
K=2
K=3
K=inf

cpu time

cpu time

20

5
0
200 300 400 500 600 700 800

60
50
40
30
20
10
0

K=0
K=1
K=2
K=inf
K=3

300

number of clauses

400

500

600

700

800

number of clauses

cpu time

(c) Max-CUT, 60 nodes
14
12
10
8
6
4
2
0
200

K=0
K=1
K=2
K=3
K=inf

250

300

350

400

450

number of nodes

Figure 3: Performance of M INI M AX S AT with different mixed lower boundings (K = 0, 1, 2, 3, inf).

8.4.2 S OFT

PROBING

In our second experiment, we evaluate the impact of soft probing. In our preliminary experiments,
we observed that soft probing was too time consuming, so we decided to limit soft probing as
follows. Initially, we assign a propagation level of 0 to the variable to probe. Then, each new literal
to propagate is assigned a propagation level L + 1 if the literal that produces its propagation has
level L. We limited probing to propagate literals with a maximum propagation level of M. We
finally restricted M  2 since it gives the best results. Note that a propagation level is not the same
as a decision level.
We compare three alternatives: probing at each node of the search (S), probing as a pre-process
before search (P) and no probing at all (N). The results, in Figure 4, indicates that probing during
search is the worst option for Max-2-SAT and Max-3-SAT while it produces some improvement in
Max-CUT. Finally, probing as a preprocessing gives slightly improvement for Max-2-SAT and the
best results for Max-CUT. Note that soft probing as a preprocessing on Max-3-SAT has no effect
and is omitted from the plot (its results are similar to N). Given these results, we decided to include
soft probing only as a preprocessing.
8.4.3 J EROSLOW

BRANCHING HEURISTIC

In the following experiment, we evaluate the importance of the weighted Jeroslow heuristic. Figure
5 shows the time difference between M INI M AX S AT with the Jeroslow heuristic as in the previous
two experiments (Jeroslow) and without heuristic (None). The results indicates that guiding search
with the Jeroslow heuristic gives important speed ups. Hence, we maintain the Jeroslow heuristic
for M INI M AX S AT.
22

fiM INI M AX S AT:

AN

E FFICIENT W EIGHTED M AX -SAT S OLVER

(a) Max-2-SAT, 100 variables

cpu time

20
15

(b) Max-3-SAT, 60 variables

S
N
P

cpu time

25

10
5
0
200 300 400 500 600 700 800

70
60
50
40
30
20
10
0

S
N

300

number of clauses

400

500

600

700

800

number of clauses
(c) Max-CUT, 60 nodes

5

cpu time

4

N
S
P

3
2
1
0
300

350
400
450
number of nodes

500

Figure 4: Performance of M INI M AX S AT without soft probing, with probing as preprocessing (P)
and with probing during the search (S).

8.4.4 L EARNING ,

BACKJUMPING AND

VSIDS

In the final experiment, we evaluate the importance of learning and backjumping. For these experiments we use structured instances, since it is well known that learning and backjumping are only
useful in this type of problems. Besides, we also evaluate the importance of the VSIDS heuristic
in combination with learning and backjumping. Recall that this heuristic was specially designed to
work in cooperation with learning, so it is meaningless to analyze its effect by itself.
Table 6 reports the results of this experiment. The third column reports results without learning
and backjumping but with the lower bounding, probing and the Jeroslow heuristic (None). The
fourth column reports results adding learning and backjumping to the previous version (Learning).
The fifth column reports results adding learning, backjumping but changing the Jeroslow heuristic
by the VSIDS heuristic (VSIDS). The results show that M INI M AX S AT without learning and backjumping (None) is clearly the worst option. Significant improvements are obtained when learning
and backjumping (Learning) are added. Finally, adding the VSIDS heuristic (VSIDS) improve further the results specially on the routing instances. Based on those results, we incorporated learning
and backjumping to M INI M AX S AT.
Regarding the branching heuristic, for problems in which literals appear in hard clauses with
both polarities it applies the VSIDS heuristic, otherwise the Jeroslow heuristic is computed in the
root of the search tree as stated in Section 7. This choice is done once and for all before starting the
search.
23

fiH ERAS , L ARROSA , & O LIVERAS

(a) Max-2-SAT, 100 variables

15

(b) Max-3-SAT, 60 variables
100

None
Jeroslow

None
Jeroslow

80
cpu time

cpu time

20

10
5

60
40
20

0
200 300 400 500 600 700 800

0
300

number of clauses

400

500

600

700

800

number of clauses
(c) Max-CUT, 60 nodes

5
cpu time

4

None
Jeroslow

3
2
1
0
200 250 300 350 400 450 500
number of nodes

Figure 5: Performance of M INI M AX S AT without Heuristic (None) and with the Jeroslow heuristic
computed in the root node of the search tree (Jeroslow).

Problem
Max-One 3col
Max-One cnt
Max-One dp
Max-One ezfact32
Routing S3
Routing S4

n. inst.
40
3
6
10
5
10

None

13.57(1)
16.11(4)
654.94(2)
22.26(4)


Learning
29.06
119.53
40.03
0.70
1.02
410.61(2)

VSIDS
15.41
6.58
28.63
0.77
0.10
91.09(9)

Figure 6: Structured instances.
8.5 Comparison with Other Boolean Optimizers
When reporting results, we will omit a solver if it cannot deal with the corresponding instances
for technical reasons (e.g. it cannot deal with weighted clauses) or it performs extremely bad in
comparison with the others.
Figure 7 contains plots with the results on different benchmarks. Plots a and b reports results on
random unweighted Max-SAT instances. P UEBLO and M INISAT + are orders of magnitude slower,
so they are not included in the graphics. On Max-2-SAT (plot a), M INI M AX S AT lays between
M AX -DPLL and M AXSATZ, which is the best option. On Max-3-SAT (plot b) M INI M AX S AT
clearly outperforms M AX -DPLL and is very close to M AXSATZ, which is again the best. In both
Max-2-SAT and Max-3-SAT M AXSATZ is no more than 3 times faster than M INI M AX S AT.
24

fiM INI M AX S AT:

AN

E FFICIENT W EIGHTED M AX -SAT S OLVER

Plot c reports results on random Max-CUT instances. M INI M AX S AT performs slightly better
than M AXSATZ, which is the second alternative.
On random Max-One (plot d) M INI M AX S AT is the best solver by far. Almost all instances are
solved instantly while P UEBLO and M AX -DPLL require up to 10 seconds in the most difficult instances. M INISAT + performs very poorly. The results on structured Max-One instances are reported
in Figure 9. M INISAT + seems to be the fastest in general. M INI M AX S AT is close in performance
to P UEBLO. Note, however, that in the d p instances, M INI M AX S AT is the only system solving all
instances.
Plot e reports the results on Random Max-Clique instances. M INI M AX S AT is the best solver, up
to an order of magnitude faster than M AX -DPLL, the second best option. P UEBLO and M INISAT +
perform poorly again. Regarding the structured Dimacs instances, M INI M AX S AT is again the best
option. It solves 36 instances within the time limit, while M AX -DPLL,M INISAT + and P UEBLO
solve 34, 22 and 18 respectively.
Plots f , g and h present the results on Combinatorial Auctions following different distributions.
On the paths distribution, M INI M AX S AT is the best solver, twice faster than M AX -DPLL, which
ranks second. On the regions distribution, M INI M AX S AT is the best solver while M AX -DPLL is
the second best solver requiring double time. On the paths and regions distributions, P UEBLO and
M INISAT + perform very poorly. On the scheduling distribution, M INISAT + is the best solver while
M INI M AX S AT and M AX -DPLL are about one order of magnitude slower.
Results regarding the unsatisfiable DIMACS instances are presented in Figure 8. Note that all
these instances have optimum cost 1. Hence, as soon as M INI M AX S AT find a solution of cost 1,
all the clauses are declared hard and learning and backjumping can be applied when hard conflicts
arise. The results indicate that M AXSATZ and M AX -DPLL do not solve any instance on some sets
(Pret150 and Aim200), while M INI M AX S AT solves all sets of instances with the best times in all
of them, except for the hole instances in which M AXSATZ is slightly faster. If we encode these
problems in the most advantageous way for P UEBLO and M INISAT +, that is, as decision problems
rather than optimization problems they solve all the instances with similar times to M INI M AX S AT.
On the planning instances (Fig. 10) P UEBLO is the best solver. M INI M AX S AT is the second best
solver, T OOLBAR is the third and the last one is M INISAT +. This is not surprising since T OOLBAR
does not perform learning over the hard constraints. Results regarding graph coloring instances are
presented in Fig. 10. As can be observed, M INI M AX S AT is able to solve one more instance than
T OOLBAR, while P UEBLO and M INISAT + solve many less instances. On the Max-CSP problems
(Fig. 10) T OOLBAR solves all the instances instantly while P UEBLO is the worst option unable to
solve a lot of instances. M INI M AX S AT is clearly the second best solver and M INI S AT + is the third
best performing solver. Note that both of them solve all the instances.
Results regarding the instances taken from the pseudo-boolean evaluation can be found in Figure
11. Note that this is the first time that a Max-SAT solver is tested on pseudo-boolean instances.
Results indicate that no solver consistently outperforms the other and that M INI M AX S AT is fairly
competitive with P UEBLO and M INISAT +.
From all these results we can conclude that M INI M AX S AT is a very robust Weighted MaxSAT solver. It is very competitive for pure optimization problems and for problems with lots of
hard clauses and, sometimes, it is the best option.
As a final remark, note that M INI M AX S AT and almost all the previous benchmarks were submitted to the Second Max-SAT Evaluation 2007, a co-located event of the Tenth International Conference on Theory and Applications of Satisfiability Testing. Hence, the interested reader can find a
25

fiH ERAS , L ARROSA , & O LIVERAS

(a) Max-2-SAT, 100 variables
50
30

cpu time

Max-DPLL
MiniMaxSat
Maxsatz

40
cpu time

(b) Max-3-SAT, 60 variables

20
10
0
200 300 400 500 600 700 800 900

300
250
200
150
100
50
0

Max-DPLL
MiniMaxSat
Maxsatz

300 400 500 600 700 800 900

number of clauses

number of clauses

(c) Max-CUT, 60 nodes

8

cpu time

Max-DPLL
Maxsatz
MiniMaxSat

10
cpu time

(d) Max-ONE, random 3-SAT, 120 variables

6
4
2
0
300

350

400

450

500

30
Minisat+
25
Pueblo
Max-DPLL
20
MiniMaxSat
15
10
5
0
150 200 250 300 350 400 450 500 550

number of edges

number of hard clauses

(e) Max-Clique, 150 nodes
50

Minisat+
Pueblo
Max-DPLL
MiniMaxSat

30

Pueblo
Minisat+
Max-DPLL
MiniMaxSat

80
cpu time

40
cpu time

(f) C. Auctions PATHS, 60 Goods
100

20
10

60
40
20

0

0
0

25

50

75

100

70 80 90 100 110 120 130 140 150

connectivity (%)

number of bids

(g) C. Auctions SCHEDULING, 60 Goods

cpu time

40
30

(h) C. Auctions REGIONS, 60 Goods
20

Pueblo
Max-DPLL
MiniMaxSat
Minisat+

cpu time

50

20

15
10

Minisat+
Pueblo
Max-DPLL
MiniMaxSat

5

10
0

0
100

70 80 90 100 110 120 130 140 150
number of bids

120

140

160

180

200

number of bids

Figure 7: Plots of different benchmarks. Note that the order in the legend goes in accordance with
the performance of the solvers.

more exhaustive comparison, including more instances and solvers, in the Second Max-SAT Evaluation 2007 web page9 . The results of such evaluation showed that M INI M AX S AT was the best
performing solver in two of the four existing categories.
9. http://www.maxsat07.udl.es/

26

fiM INI M AX S AT:

AN

n. inst.
13
4
4
5
8
8
8

Problem
Dubois
Pret60
Pret150
Hole
Aim50
Aim100
Aim200

E FFICIENT W EIGHTED M AX -SAT S OLVER

M INI M AX S AT
0.02
0.07
0.01
8.68
0.00
0.00
0.00

M AXSATZ
148.18(7)
10.06

8.34
0.01
9.55


M AX -DPLL
174.33(6)
22.00

28.00
0.00
172.00


Figure 8: Unsatisfiable DIMACS instances.

Problem
3col80
3col100
3col120
3col140
cnt
dp
ezfact32

n. inst.
10
10
10
10
3
6
10

M INI M AX S AT
0.15
2.25
20.49
38.33
6.59
28.81
0.77

P UEBLO
0.10
1.73
14.52
83.17
0.13
1.19(3)
0.34

M INISAT +
0.02
0.12
0.74
1.61
0.12
1.21(4)
0.33

Figure 9: Structured Max-one instances.

Problem
Planning
Graph Coloring
Max-CSP DL
Max-CSP DT
Max-CSP SL
Max-CSP ST

n. inst.
71
22
20
20
20
20

Toolbar
4.02
49.29(16)
0.08
0.00
0.01
0.00

M INI M AX S AT
3.81
4.16(17)
0.20
0.01
0.03
0.01

P UEBLO
0.16
68.50(11)
349.08(13)

123.67


M INISAT +
7.40
0.57(11)
8.60
2.40
0.48
1.29

Figure 10: Results for WCSP and Max-CSP instances.

9. Related Work
Some previous work has been done about incorporating SAT-techniques inside a Max-SAT solver.
Alsinet et al. (2005) presented a lazy data structure to detect when clauses become unit, but it requires a static branching heuristic. Argelich and Manya (2006a) test different versions of a branch
and bound procedure. One of these versions uses the two-watched literals, but it uses a very basic
lower bounding. We can conclude that none of these previous approaches is as general as our use of
the two-watched literals. As far as we know, the rest of Max-SAT solvers are based on adjacency
lists. Therefore, they are presumably inefficient for unit propagation (Lynce & Silva, 2005), par27

fiH ERAS , L ARROSA , & O LIVERAS

Problem
misc
Logic synthesis
MPI
MPS
Routing

n. inst.
7
17
148
16
15

M INI M AX S AT
3.08(5)
82.55(2)
37.35(107)
22.65(5)
58.74(14)

P UEBLO
8.51(5)
36.21(5)
32.04(101)
36.90(8)
5.96

M INISAT +
0.14(5)
253.93(5)
3.06(105)
8.50(8)
13.09

Figure 11: Results for pseudo-boolean instances.
ticularly in the presence of long clauses. Argelich and Manya (2006b) enhance a Max-SAT branch
and bound procedure with learning over hard constraints, but it is used in combination with simple lower bounding techniques. An improved version is presented by Argelich and Manya (2007)
with a more powerful lower bound, but it does not incorporate the two-watched literal scheme,
backjumping, etc. To the best of our knowledge, no Max-SAT solver incorporates backjumping.
Note that M INI M AX S AT restricts backjumping to the occurrence of hard conflicts. Related works
on the integration of backjumping techniques into branch and bound include work by Zivan and
Meisels (2007) for Weighted CSP, Manquinho and Silva (2004) for pseudo-boolean optimization,
and Nieuwenhuis and Oliveras (2006) for SAT Modulo Theories.
Most Max-SAT solvers use variations of what we call substraction-based lower bounding. In
most cases, they search for special patterns of mutually inconsistent subsets of clauses (Shen &
Zhang, 2004; Xing & Zhang, 2005; Alsinet et al., 2005). For efficiency reasons, these patterns are
always restricted to small sets of small arity clauses (2 or 3 clauses or arity less than 3). M INI M AX S AT uses a natural weighted extension of the approach proposed by Li et al. (2005). It was the
first one able to detect inconsistencies in arbitrarily large sets of arbitrarily large clauses.
The idea of what we call resolution-based lower bounding was inspired from the WCSP domain
(Larrosa, 2002; Larrosa & Schiex, 2003; de Givry et al., 2003, 2005) and it was first proposed in
the Max-SAT context by Larrosa and Heras (2005) and further developed by Li et al. (2007), Heras
and Larrosa (2006), and Larrosa et al. (2007). In these works, only special patterns of fixed-size
resolution trees were executed. The use of simulated unit propagation allows M INI M AX S AT to
identify arbitrarily large resolution trees. In the following example, we present two inconsistent
subsets of clauses that are detected by M INI M AX S AT and transformed into an equivalent formula
while previous solvers cannot transform them since they are limited to specific patterns:
 {(x1 , w1 ), (x2 , w2 ), (x3 , w3 ), (x1  x2  x3 , w4 )}
 {(x1 , w1 ), (x1  x2 , w2 ), (x1  x2  x3 , w3 ), (x1  x2  x3  x4 , w4 ), (x1  x2  x3  x4 , w5 )}
In the first case, M INI M AX S AT replaces the clauses by (2, m) with m = min{w1 , w2 , w3 , w4 }
and a set of compensation clauses. For the second case, M INI M AX S AT replaces it by (2, m) with
m = min{w1 , w2 , w3 , w4 , w5 } and a set of compensation clauses. In both cases, the equivalence is
preserved. However, other solvers in the literature detect those inconsistent subset of clauses but
cannot transform the problem into an equivalent one (Li et al., 2007) or simply cannot detect them
(Heras & Larrosa, 2006).
Our probing method to derive weighted unit clauses is related to the 2  RES and cycle rule
of Heras and Larrosa (2006) and Larrosa et al. (2007), to failed literals of Li et al. (2006), and
28

fiM INI M AX S AT:

AN

E FFICIENT W EIGHTED M AX -SAT S OLVER

to singleton consistency in CSP (Debruyne & Bessiere, 1999). Again, the use of simulated unit
propagation allows M INI M AX S AT to identify arbitrarily large resolution trees.

10. Conclusions and Future Work
M INI M AX S AT is an efficient and very robust Max-SAT solver that can deal with hard and soft
clauses as well as pseudo-boolean functions. It incorporates the best available techniques for each
type of problems, so its performance is similar to the best specialized solver. Besides the development of M INI M AX S AT combining, for the first time, known techniques from different fields, the
main original contribution of this paper is a novel lower bounding technique based on resolution.
M INI M AX S AT lower bounding combines in a very clean and elegant way most of the approaches that have been proposed in the last years, mainly based on unit-propagation-based lower
bounding and resolution-based problem transformation. In this paper we use the information provided by the propagation queue (i) to determine a subset of inconsistent clauses and (ii) to determine
a simple ordering in which resolution can be applied to increase the lower bound and generate an
equivalent formula. However, this is not necessarily the best ordering to do so. It is easy to see that
different orderings may generate resolvents and compensation clauses of different arities. If one
selects the ordering that generates the smallest resolvents and compensation clauses the resulting
formula may be presumably simpler. Future work concerns the study of such orderings, the development of VSIDS-like heuristics for soft clauses and backjumping techniques for soft conflicts.

Acknowledgments
We would like to thank to Niklas Een and Niklas Sorensson for making M INISAT + code publicly
available. We are also grateful to the anonymous referees for their helpful suggestions on improving
the paper.
This work has been partially supported by the Spanish Ministry of Education and Science
through the projects TIN2006-15387-C03-02 (Heras and Larrosa) and TIN2004-03382 (Oliveras).

References
Alsinet, T., Manya, F., & Planes, J. (2005). Improved Exact Solvers for Weighted Max-SAT. In
Proceedings of SAT05, Vol. 3569 of LNCS, pp. 371377. Springer.
Argelich, J., & Manya, F. (2006a). Exact Max-SAT solvers for over-constrained problems. J.
Heuristics, 12(4-5), 375392.
Argelich, J., & Manya, F. (2006b). Learning Hard Constraints in Max-SAT. In Proceedings of
CSCLP06, Vol. 4651 of LNCS, pp. 112. Springer.
Argelich, J., & Manya, F. (2007). Partial Max-SAT Solvers with Clause Learning. In Proceedings
of SAT07, Vol. 4501 of LNCS, pp. 2840. Springer.
Barth, P. (1995). A Davis-Putnam Based Enumeration Algorithm for Linear pseudo-Boolean Optimization. Research report MPI-I-95-2-003, Max-Planck-Institut fur Informatik, Im Stadtwald, D-66123 Saarbrucken, Germany.
Brglez, F., Li, X., & Stallman, M. (2002). The role of a skeptic agent in testing and benchmarking
of SAT algorithms. In In Proceedings of SAT02, pp. 354361.
29

fiH ERAS , L ARROSA , & O LIVERAS

Buro, M., & Buning, H. K. (1993). Report on a SAT Competition. Bulletin of the European
Association for Theoretical Computer Science, 49, 143151.
Cha, B., Iwama, K., Kambayashi, Y., & Miyazaki, S. (1997). Local search algorithms for partial
MAXSAT. In Proceedings of AAAI97, pp. 263268. The MIT Press.
Cooper, M., Cussat-Blanc, S., de Roquemaurel, M., & Regnier, P. (2006). Soft Arc Consistency
Applied to Optimal Planning. In Proceedings of CP06, Vol. 4204 of LNCS, pp. 680684.
Springer.
Davis, M., Logemann, G., & Loveland, G. (1962). A machine program for theorem proving. Communications of the ACM, 5, 394397.
de Givry, S., Heras, F., Larrosa, J., & Zytnicki, M. (2005). Existential arc consistency: getting
closer to full arc consistency in weighted CSPs. In Proceedings of the 19th IJCAI, pp. 8489.
Professional Book Center.
de Givry, S., Larrosa, J., Meseguer, P., & Schiex, T. (2003). Solving Max-SAT as weighted CSP. In
Proceedings of CP03, Vol. 2833 of LNCS, pp. 363376. Springer.
Debruyne, R., & Bessiere, C. (1999). Some practicable filtering techniques for the constraint satisfaction problem. In Proceedings of ICJAI97, pp. 412417. Morgan Kaufmann.
Een, N., & Sorensson, N. (2003). An Extensible SAT-solver. In Proceedings of SAT03, Vol. 2919
of LNCS, pp. 502518. Springer.
Een, N., & Sorensson, N. (2006). Translating Pseudo-Boolean Constraints into SAT. Journal on
Satisfiability, Boolean Modeling and Computation, 2, 126.
Fahle, T. (2002). Simple and fast: Improving a branch-and-bound algorithm for maximum clique.
In Proceedings of ESA02, Vol. 2461 of LNCS, pp. 485498. Springer.
Freeman, J. W. (1995). Improvements to Propositional Satisfiability Search Algorithms. Ph.D.
thesis, University of Pennsylvania.
Fu, Z., & Malik, S. (2006). On Solving the Partial MAX-SAT Problem. In Proceedings of SAT06,
Vol. 4121 of LNCS, pp. 252265. Springer.
Heras, F., & Larrosa, J. (2006). New Inference Rules for Efficient Max-SAT Solving. In Proceedings
of the 21th AAAI. AAAI Press.
Jeroslow, R. G., & Wang, J. (1990). Solving propositional satisfiability problems. Annals of Mathematics and Artificial Intelligence, 1, 167187.
K. Leyton-Brown, M. P., & Shoham, Y. (2000). Towards a universal test suite for combinatorial
auction algorithms. In Proceedings of ACM Conference on Electronic Commerce00, pp.
6676.
Karloff, H. J., & Zwick, U. (1997). A 7/8-Approximation Algorithm for MAX 3SAT?. In FOCS,
pp. 406415.
Larrosa, J., & Heras, F. (2005). Resolution in Max-SAT and its relation to local consistency for
weighted CSPs. In Proceedings of IJCAI05, pp. 193198. Professional Book Center.
Larrosa, J., Heras, F., & de Givry, S. (2007). A logical approach to efficient max-sat solving. In
Artificial Intelligence. To appear.
30

fiM INI M AX S AT:

AN

E FFICIENT W EIGHTED M AX -SAT S OLVER

Larrosa, J., & Schiex, T. (2003). In the quest of the best form of local consistency for weighted
CSP. In Proceedings of the 18th IJCAI, pp. 239244.
Larrosa, J. (2002). Node and Arc Consistency in Weighted CSP. In Proceedings of AAAI02, pp.
4853. AAAI Press.
Le Berre, D. (2001). Exploiting the real power of Unit Propagation Lookahead. In Proceedings of
LICS Workshop on Theory and Applications of Satisfiability Testing.
Le Berre, D. (2006). The SAT4j project for Max-SAT.. http://www.sat4j.org/.
Li, C., Manya, F., & Planes, J. (2005). Exploiting Unit Propagation to Compute Lower Bounds
in Branch and Bound Max-SAT Solvers. In Proceedings of CP05, Vol. 3709 of LNCS, pp.
403414.
Li, C., Manya, F., & Planes, J. (2007). New Inference Rules for Max-SAT. In Journal of Artificial
Intelligence Research. To appear.
Li, C.-M., Manya, F., & Planes, J. (2006). Detecting Disjoint Inconsistent Subformulas for Computing Lower Bounds for Max-SAT. In Proceedings of the 21th AAAI. AAAI Press.
Lynce, I., & Silva, J. P. M. (2003). Probing-Based Preprocessing Techniques for Propositional
Satisfiability. In Proceedings of ICTAI03, pp. 105111. IEEE Computer Society.
Lynce, I., & Silva, J. P. M. (2005). Efficient data structures for backtrack search SAT solvers. Ann.
Math. Artif. Intell., 43(1), 137152.
Manquinho, V. M., & Silva, J. P. M. (2004). Satisfiability-Based Algorithms for Boolean Optimization. Ann. Math. Artif. Intell., 40(3-4), 353372.
Moskewicz, M. W., Madigan, C. F., Zhao, Y., Zhang, L., & Malik, S. (2001). Chaff: Engineering an
Efficient SAT Solver. In Proceedings of DAC01, pp. 530535. ACM.
Nieuwenhuis, R., & Oliveras, A. (2006). On SAT Modulo Theories and Optimization Problems. In
Proceedings of SAT06, Vol. 4121 of LNCS, pp. 156169. Springer.
Papadimitriou, C. (1994). Computational Complexity. Addison-Wesley, USA.
Sandholm, T. (1999). An Algorithm for Optimal Winner Determination in Combinatorial Auctions.
In Proceedings of IJCAI99, pp. 542547. Morgan Kaufmann.
Sheini, H. M., & Sakallah, K. A. (2006). Pueblo: A Hybrid Pseudo-Boolean SAT Solver. Journal
on Satisfiability, Boolean Modeling and Computation, 2, 165189.
Shen, H., & Zhang, H. (2004). Study of lower bounds for Max-2-SAT. In Proceedings of AAAI04,
pp. 185190. AAAI Press / The MIT Press.
Silva, J. P. M., & Sakallah, K. A. (1996). GRASP - a new search algorithm for satisfiability. In
ICCAD, pp. 220227.
Smyth, K., Hoos, H. H., & Stutzle, T. (2003). Iterated Robust Tabu Search for MAX-SAT. In
Proceedings of AI03, Vol. 2671 of LNCS, pp. 129144. Springer.
Tompkins, D. A. D., & Hoos, H. H. (2004). UBCSAT: An Implementation and Experimentation
Environment for SLS Algorithms for SAT & MAX-SAT. In Proceedings of SAT04, Vol.
3542 of LNCS, pp. 306320. Springer.
Walsh, T. (2000). SAT v CSP. In Proceedings of CP00, Vol. 1894 of LNCS, pp. 441456. Springer.
31

fiH ERAS , L ARROSA , & O LIVERAS

Xing, Z., & Zhang, W. (2005). MaxSolver: An efficient exact algorithm for (weighted) maximum
satisfiability. Artificial Intelligence, 164(1-2), 4780.
Zhang, L., Madigan, C. F., Moskewicz, M. W., & Malik, S. (2001). Efficient Conflict Driven Learning in Boolean Satisfiability Solver. In Proceedings of ICCAD01, pp. 279285.
Zivan, R., & Meisels, A. (2007). Conflict directed Backjumping for MaxCSPs. In Proceedings of
IJCAI07, pp. 198204.

32

fi