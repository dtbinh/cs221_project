Journal of Artificial Intelligence Research 26 (2006) 371-416

Submitted 11/05; published 8/06

Clause/Term Resolution and Learning in the Evaluation of
Quantified Boolean Formulas
Enrico Giunchiglia
Massimo Narizzano
Armando Tacchella

giunchiglia@unige.it
mox@dist.unige.it
tac@dist.unige.it

DIST - Universita di Genova
Viale Causa 13, 16145 Genova, Italy

Abstract
Resolution is the rule of inference at the basis of most procedures for automated reasoning. In these procedures, the input formula is first translated into an equisatisfiable
formula in conjunctive normal form (CNF) and then represented as a set of clauses. Deduction starts by inferring new clauses by resolution, and goes on until the empty clause is
generated or satisfiability of the set of clauses is proven, e.g., because no new clauses can
be generated.
In this paper, we restrict our attention to the problem of evaluating Quantified Boolean
Formulas (QBFs). In this setting, the above outlined deduction process is known to be
sound and complete if given a formula in CNF and if a form of resolution, called Qresolution, is used. We introduce Q-resolution on terms, to be used for formulas in disjunctive normal form. We show that the computation performed by most of the available
procedures for QBFs based on the Davis-Logemann-Loveland procedure (DLL) for propositional satisfiability corresponds to a tree in which Q-resolution on terms and clauses
alternate. This poses the theoretical bases for the introduction of learning, corresponding
to recording Q-resolution formulas associated with the nodes of the tree. We discuss the
problems related to the introduction of learning in DLL based procedures, and present
solutions extending state-of-the-art proposals coming from the literature on propositional
satisfiability. Finally, we show that our DLL based solver extended with learning, performs
significantly better on benchmarks used in the 2003 QBF solvers comparative evaluation.

1. Introduction
Resolution (Robinson, 1965) is the rule of inference at the basis of most procedures for
automated reasoning (see, e.g., Fermuller, Leitsch, Hustadt, & Tammet, 2001; Bachmair &
Ganzinger, 2001). In these procedures, the input formula is first translated into an equisatisfiable formula in conjunctive normal form (CNF) and then represented as a set of clauses.
Deduction starts by inferring new clauses by resolution, and goes on until the empty clause is
generated or satisfiability of the set of clauses is proven, e.g., because no new clauses can be
generated. Here we restrict our attention to the problem of evaluating Quantified Boolean
Formulas (QBFs). In this setting, the above outlined deduction process is known to be sound
and complete if given a formula in CNF and if a form of resolution, called Q-resolution,
is used (Kleine-Buning, Karpinski, & Flogel, 1995). However, most of the available decision
procedures for QBFs are based on and extend the Davis-Logemann-Loveland procedure
(DLL) (Davis, Logemann, & Loveland, 1962) for propositional satisfiability (SAT). In the
c
2006
AI Access Foundation. All rights reserved.

fiGiunchiglia, Narizzano & Tacchella

propositional case, it is well known that the computation performed by DLL corresponds
to a specific form of resolution called regular tree resolution (see, e.g., Urquhart, 1995).
In this paper we introduce Q-resolution on terms, to be used for formulas in disjunctive
normal form. We show that the computation performed by DLL based decision procedures
for QBFs corresponds to a tree in which Q-resolution on terms and clauses alternate. Such
correspondence poses the theoretical bases for the introduction of learning, corresponding
to recording Q-resolution formulas associated with the nodes of the tree. In particular,
recording Q-resolutions on clauses generalizes the popular nogood learning from constraint satisfaction and SAT literatures (see, e.g., Dechter, 1990; Bayardo, Jr. & Schrag,
1997): Each nogood corresponds to a set of assignments falsifying the input formula, and
it is useful for pruning assignments to the existential variables. Recording Q-resolutions on
terms corresponds to good learning: Each good corresponds to a set of assignments satisfying the input formula, and it is useful for pruning assignments to the universal variables.
We discuss the problems related to the introduction of learning in DLL based procedures for
QBFs, and present solutions extending state-of-the-art proposals coming from the literature
on SAT. To show the effectiveness of learning for the QBFs evaluation problem, we have
implemented it in QuBE, a state-of-the-art QBF solver. Using QuBE, we have done some
experimental tests on several real-world QBFs, corresponding to planning (Rintanen, 1999;
Castellini, Giunchiglia, & Tacchella, 2003) and circuit verification (Scholl & Becker, 2001;
Abdelwaheb & Basin, 2000) problems, which are our two primary application domains of
interest. The results witness the effectiveness of learning.
The paper is structured as follows. We first review the basics of Quantified Boolean
Logic, at the same time introducing some terminology and notation that will be used
throughout the paper. In Section 3, we introduce clause and term resolution, and their
relation to DLL based decision procedures for QBFs. Then, in Section 4, we introduce both
nogood and good learning, and then we show how they can be effectively integrated in DLL
based decision procedures for QBFs. The implementation and the experimental results are
presented in Section 5. The paper ends with the conclusions and some related work.
This paper builds on and extends in many ways our AAAI paper (Giunchiglia, Narizzano, & Tacchella, 2002). With respect to that paper, here (i) we introduce clause and
term resolution; (ii) we show the correspondence between clause/term Q-resolution and the
computation tree searched by DLL based decision procedures; (iii) on the basis of such
correspondence, we extend the basic backtracking search procedure, first with backjumping
and then with learning, and we prove their soundness and completeness; (iv) we discuss the
implementation in QuBE providing many more details, and (v) we present the results of a
much broader and detailed experimental analysis.
From here on, we simply write resolution for Q-resolution.

2. Quantified Boolean Logic
Consider a set P of symbols. A variable is an element of P. A literal is a variable or the
negation of a variable. In the following, for any literal l,
 |l| is the variable occurring in l; and
 l is the negation of l if l is a variable, and it is |l| otherwise.
372

fiClause/Term Resolution and Learning for Quantified Boolean Formulas

For the sake of simplicity, we consider only formulas in negation normal form (NNF).
Thus, for us, a propositional formula is a combination of literals using the k-ary (k  0)
connectives  (for conjunctions) and  (for disjunctions). In the following, we use True and
False as abbreviations for the empty conjunction and the empty disjunction respectively.
A QBF is an expression of the form
 = Q1 z1 Q2 z2 . . . Qn zn 

(n  0)

(1)

where
 every Qi (1  i  n) is a quantifier, either existential  or universal ,
 z1 , . . . , zn are distinct variables, and
  is a propositional formula in z1 , . . . , zn .
For example,
x1 yx2 ((x1  y  x2 )  (y  x2 )  (x2  ((x1  y)  (y  x2 ))))

(2)

is a QBF.
In (1), Q1 z1 . . . Qn zn is the prefix and  is the matrix. We also say that a literal l is
existential if |l| belongs to the prefix, and it is universal otherwise. Finally, in (1), we
define
 the level of a variable zi , to be 1 + the number of expressions Qj zj Qj+1 zj+1 in the
prefix with j  i and Qj 6= Qj+1 ;
 the level of a literal l, to be the level of |l|.
For example, in (2) x2 is existential and has level 1, y is universal and has level 2, x1 is
existential and has level 3.
The value or semantics of a QBF  can be defined recursively as follows:
1. If the prefix is empty, then  is evaluated according to the truth tables of propositional
logic.
2. If  is x,  is true if and only if x is true or x is true.
3. If  is y,  is true if and only if both y and y are true.
If  is (1) and l is a literal with |l| = zi , l is the QBF
 whose matrix is obtained from  by substituting
 zi with True and z i with False if l = zi , and
 zi with False and z i with True if l = z i .
 whose prefix is Q1 z1 Q2 z2 . . . Qi1 zi1 Qi+1 zi+1 . . . Qn zn .
It is easy to see that if  is a QBF without universal quantifiers, the problem of determining
the value of  reduces to the SAT problem.
Two QBFs are equivalent if they are either both true or both false.
373

fiGiunchiglia, Narizzano & Tacchella

3. Resolution and DLL Based Decision Procedures for QBFs
In this section we first introduce clause/term resolution and DLL based decision procedures
for QBFs, and then we show the correspondence between the two.
3.1 Clause and Term Resolution
According to our definition of QBF, the matrix can be any combination of conjunctions
and disjunctions of literals. However, using common clause form transformations based on
renaming first used by Tseitin (1970), it is possible to perform a linear time conversion
from an arbitrary QBF into an equivalent one with the matrix in conjunctive normal form
(CNF). These conversions are based on the fact that any QBF (1) is equivalent to
Q1 z1 Q2 z2 . . . Qn zn x((x  )  [x/])

(n  0)

where
  is a propositional formula but not a literal;
 x is a variable distinct from z1 , z2 , . . . , zn ; and
 [x/] is the propositional formula obtained from  substituting one or more occurrences of  with x.
Thus, if  is
((x1  y)  (y  x2 ))
then it follows that (2) is equivalent to
x1 yx2 x3 ((x1  y  x2 )  (y  x2 )  (x2  x3 )  (x1  y  x3 )  (y  x2  x3 ))

(3)

Thanks to such conversions, we can restrict our attention to QBFs with the matrix
in CNF, and represent the matrix of each formula as a set of clauses to be interpreted
conjunctively, where a clause is a finite set of literals to be interpreted disjunctively. Further,
we assume that each clause is non-tautological and minimal. A clause is tautological if it
contains both a variable and its negation. A clause C is minimal if the literals in C with
minimum level are existential. The minimal form of a clause C is the clause obtained from
C by deleting the universal literals which cause C to be non-minimal. For instance, in
(4), all the clauses are non-tautological and minimal. Our assumption that clauses are
non-tautological and minimal is not a restriction, as the following theorem states.
Theorem 1 Let  be a QBF with the matrix in CNF. Let 0 be the QBF obtained from 
by
1. eliminating tautological clauses; and
2. replacing each non-tautological and non-minimal clause with its minimal form.
 and 0 are equivalent.
374

fiClause/Term Resolution and Learning for Quantified Boolean Formulas

Proof. Clearly, tautological clauses can be eliminated from  and the result is an equivalent
QBF. Let C = {l1 , . . . , ln , ln+1 , . . . , lm } be a non-tautological and non-minimal clause in 
in which ln+1 , . . . , lm are the universal literals in C \ min(C) (0  n < m). Further, without
loss of generality, we assume that the level of li is less than or equal to the level of li+1 ,
1  i < m. Then,  has the form (p  m)
. . . Q1 |l1 | . . . |ln | . . . |ln+1 | . . . |lm |Qm+1 zm+1 . . . Qp zp {{l1 , . . . , ln , ln+1 , . . . , lm }, . . .},
standing for
. . . Q1 |l1 | . . . |ln | . . . |ln+1 | . . . |lm |Qm+1 zm+1 . . . Qp zp ((l1  . . .  ln  ln+1  . . .  lm )  ).
Then, by applying standard rules for quantifiers,  can be rewritten as
. . . Q1 |l1 | . . . |ln | . . . |ln+1 | . . . |lm |((l1  . . .  ln  ln+1  . . .  lm )  Qm+1 zm+1 . . . Qp zp ),
equivalent to
. . . Q1 |l1 | . . . |ln | . . . |ln+1 | . . . (|lm |(l1 . . .ln ln+1 . . .lm )|lm |Qm+1 zm+1 . . . Qp zp ),
equivalent to
. . . Q1 |l1 | . . . |ln | . . . |ln+1 | . . . ((l1  . . .  ln  ln+1  . . .  lm1 )  |lm |Qm+1 zm+1 . . . Qp zp ),
equivalent to
. . . Q1 |l1 | . . . |ln | . . . |ln+1 | . . . |lm |Qm+1 zm+1 . . . Qp zp ((l1  . . .  ln  ln+1  . . .  lm1 )  ),
i.e., the QBF obtained from  by deleting lm from the clause C. By iterating the above
reasoning process, all the literals in C \ min(C) can be eliminated from C, and hence the
thesis.

From here on, a QBF is in CNF if and only if the matrix is a conjunction of clauses,
and each clause is both minimal and non-tautological. If we represent the matrix of a QBF
as a set of clauses,
 the empty clause {} stands for False;
 the empty set of clauses {} stands for True;
 the formula {{}} is equivalent to False;
 the QBF (3) is written as
x1 yx2 x3 {{x1 , y, x2 }, {y, x2 }, {x2 , x3 }, {x1 , y, x3 }, {y, x2 , x3 }}.

(4)

Clause resolution (Kleine-Buning et al., 1995) is similar to an ordinary resolution where
only existential literals can be matched. More precisely, clause resolution (on a literal l) is
the rule
C1
C2
(5)
min(C)
where
375

fiGiunchiglia, Narizzano & Tacchella

(c1)
(c2)
(c3)
(c4)

{x1 , y, x2 }
{y, x2 }
{x2 , x3 }
{x1 , y, x3 }

Input
Input
Input
Input

formula
formula
formula
formula

(c5)
(c6)
(c7)
(c8)

{x1 }
{x3 , y}
{x1 }
{}

From
From
From
From

(c1),
(c2),
(c4),
(c5),

(c2)
(c3)
(c6)
(c7)

Table 1: A clause resolution deduction showing that (4) is false. The prefix is x1 yx2 x3 .

 l is an existential literal;
 C1 , C2 are two clauses such that {l, l}  (C1  C2 ), and for no literal l0 6= l, {l0 , l0 } 
(C1  C2 );
 C is (C1  C2 ) \ {l, l}.
C1 and C2 are the antecedents, and min(C) is the resolvent of the rule.
Theorem 2 ((Kleine-Buning et al., 1995)) Clause resolution is a sound and complete
proof system for deciding QBFs in CNF: a QBF in CNF is true if and only if the empty
clause is not derivable by clause resolution.
For instance, the fact that (4) is false follows from the deduction in Table 1.
Alternatively to the CNF conversion, we could have converted (2) into a QBF with the
matrix in disjunctive normal form (DNF), again in linear time, on the basis that any QBF
(1), is equivalent to
Q1 z1 Q2 z2 . . . Qn zn y((y  )  [y/])

(n  0),

assuming  is a propositional formula but not a literal, and that y is a variable distinct
from z1 , z2 , . . . , zn .
A simple recursive application of the above equivalence to (2) leads to the following
equivalent QBF:
x1 yx2 y1 y2 y3 y4 y5 y6 ((y1  y2  y3 )
(y 1  x1 )  (y 1  y)  (y 1  x2 )
(y 2  y)  (y 2  x2 )
(y 3  x2 )  (y 3  y4 )
(y 4  y5  y6 )
(y 5  x1 )  (y 5  y)
(y 6  y)  (y 6  x2 )).

(6)

Given a QBF with the matrix in DNF, we can represent the matrix as a set of terms
to be interpreted disjunctively, where a term is a finite set of literals to be interpreted
conjunctively. Further, we can assume that each term is non-contradictory and minimal. A
term is contradictory if it contains both a variable and its negation. A term T is minimal
if the literals in T with minimum level are universal. The minimal form of a term T is the
term obtained from T by deleting the existential literals which cause T to be non-minimal.
All the terms in (6) are non-contradictory and minimal. Analogously to what we have said
before for QBFs in CNF, if  is a QBF in DNF then we can assume that all the terms are
non-contradictory and minimal without loss of generality.
376

fiClause/Term Resolution and Learning for Quantified Boolean Formulas

Theorem 3 Let  be a QBF with the matrix in DNF. Let 0 be the QBF obtained from 
by
1. eliminating contradictory terms; and
2. replacing each non-contradictory and non-minimal term with its minimal form.
 and 0 are equivalent.
Proof. Analogous to the proof of Theorem 1.



As before, from here on, a QBF is in DNF if and only if the matrix is a disjunction of
terms, and each term is both minimal and non-contradictory.
We can introduce term resolution (on a literal l) which consists of the rule
T1
T2
min(T )
where
 l is an universal literal;
 T1 , T2 are two terms such that {l, l}  (T1  T2 ), and for no literal l0 6= l, {l0 , l0 } 
(T1  T2 );
 T is (T1  T2 ) \ {l, l}.
T1 and T2 are the antecedents, and min(T ) is the resolvent of the rule.
Theorem 4 Term resolution is a sound and complete proof system for deciding QBFs in
DNF: a QBF in DNF is true if and only if the empty term is derivable by term resolution.
Proof. The fact that term resolution is a sound and complete proof system follows from
the soundness and completeness of clause resolution.
Let  be a set of sets of literals, and  = Q1 z1 Q2 z2 . . . Qn zn  be a QBF in which  is
interpreted as a set of clauses. Without loss of generality we can assume that each clause
in  is non-tautological and minimal. Then the following chain of equivalences holds:
There exists a deduction  of the empty clause from  using clause resolution
if and only if
 is false
if and only if
The QBF  = Q1 z1 Q2 z2 . . . Qn zn  in which  is interpreted as a set of terms is true
if and only if
 is a deduction of the empty term from  using term resolution.
In the above chain of equivalences, Q is  if Q = , and is  if Q = .



As an example of a term resolution deduction of the empty term, consider the QBF :
x1 yx2 x3 ((x1  y  x2 )  (y  x2 )  (x2  x3 )  (x1  y  x3 )  (y  x2  x3 ))
377

fiGiunchiglia, Narizzano & Tacchella

i.e., the QBF obtained from (3) by simultaneously replacing  with ,  with ,  with ,
and  with . Then, the deduction in Table 1 is also a deduction of the empty term from
 using term resolution.
If the QBF  is not in DNF but in CNF then term resolution cannot be applied, and
thus term resolution is not sufficient for proving the truth or falsity of . However, if we
also have the following model generation rule

min(T )
where
  is the matrix of ; and
 T is a non-contradictory term such that for each clause C  , C  T 6= ,
we get a sound and complete proof system for QBFs in CNF. Intuitively, the model generation rule allows us to start from the minimal form of terms which propositionally entail
the matrix of the input formula.
Theorem 5 Term resolution and model generation is a sound and complete proof system
for deciding QBFs in CNF: a QBF in CNF is true if and only if the empty term is derivable
by term resolution and model generation.
Proof. Given a QBF  in CNF with matrix , by the model generation rule we can derive
a set  of terms of the form min(T ) such that
 each term T is a non-contradictory and such that for each clause C  , C  T 6= ;
and
 the disjunction of all the terms in  is propositionally logically equivalent to .
Let 0 be the QBF in DNF obtained by substituting  with  in .  and 0 have the
same value. Hence the thesis thanks to Theorem 4.


3.2 DLL Based Decision Procedures for QBFs
Given what we have said so far, an arbitrary QBF  can be converted (in linear time) into
an equivalent QBF in CNF. Because of this, from here to the end of the paper, we restrict
our attention to QBFs in such format. With this assumption, if  is (1) and l is a literal
with |l| = zi , we redefine l to be the QBF
 whose matrix is obtained from  by removing the clauses C with l  C, and by
removing l from the other clauses; and
 whose prefix is Q1 z1 Q2 z2 . . . Qi1 zi1 Qi+1 zi+1 . . . Qn zn .
378

fiClause/Term Resolution and Learning for Quantified Boolean Formulas

Further, we extend the notation to sequence of literals: If  = l1 ; l2 ; . . . ; lm (m  0),  is
defined as (. . . ((l1 )l2 ) . . .)lm .
Consider a QBF .
A simple procedure for determining the value of  starts with the empty assignment 
and recursively extends the current assignment  with z and/or z, where z is a heuristically
chosen variable at the highest level in  , until either the empty clause or the empty set of
clauses are produced in  . On the basis of the values of ;z and ;z , the value of  can
be determined according to the semantics of QBFs. The value of  is the value of  .
Cadoli, Giovanardi, Giovanardi and Schaerf (2002) introduced various improvements to
this basic procedure.
The first improvement is that we can directly conclude about the value of  if the
matrix of  contains a contradictory clause (Lemma 2.1 in Cadoli et al., 2002). A clause
C is contradictory if it contains no existential literal. An example of a contradictory clause
is the empty clause.
The second improvement allows us to directly extend  with l if l is unit or monotone
in  (Lemmas 2.4, 2.5, 2.6 in Cadoli et al., 2002). In (1), a literal l is:
 Unit if l is existential and for some m  0,
 a clause {l, l1 , . . . , lm } belongs to ; and
 each literal li (1  i  m) is universal and has a level lower than the level of l.
 Monotone or pure if
 either l is existential, l does not belong to any clause in , and l occurs in ;
 or l is universal, l does not belong to any clause in , and l occurs in .
For example, in a QBF of the form
. . . x1 yx2 . . . {{x1 , y}, {x2 }, . . .},
both x1 and x2 are unit. In the QBF
y1 x1 y2 x2 {{y 1 , y2 , x2 }, {x1 , y 2 , x2 }},
the only monotone literals are y1 and x1 .
With such improvements, the resulting procedure, called Q-DLL, is essentially the one
presented in the work of Cadoli, Giovanardi, and Schaerf (1998), which extends DLL in
order to deal with QBFs. Figure 1 is a simple, recursive presentation of it. In the figure,
given a QBF ,
1. False is returned if a contradictory clause is in the matrix of  (line 1); otherwise
2. True is returned if the matrix of  is empty (line 2); otherwise
3. at line 3,  is recursively extended to ; l if l is unit (and we say that l has been
assigned as unit); otherwise
379

fiGiunchiglia, Narizzano & Tacchella

0 function Q-DLL(, )
1
if (ha contradictory clause is in the matrix of  i) return False;
2
if (hthe matrix of  is emptyi) return True;
3
if (hl is unit in  i) return Q-DLL(, ; l);
4
if (hl is monotone in  i) return Q-DLL(, ; l);
5
l := ha literal at the highest level in  i;
6
if (hl is existentiali) return Q-DLL(, ; l) or Q-DLL(, ; l);
7
else return Q-DLL(, ; l) and Q-DLL(, ; l).
Figure 1: The algorithm of Q-DLL.
4. at line 4,  is recursively extended to ; l if l is monotone (and we say that l has been
assigned as monotone); otherwise
5. a literal l at the highest level is chosen and
 If l is existential (line 6),  is extended to ; l first (and we say that l has been
assigned as left split). If the result is False, ; l is tried and returned (and in
this case we say that l has been assigned as right split).
 Otherwise (line 7), l is universal,  is extended to ; l first (and we say that l
has been assigned as left split). If the result is True, ; l is tried and returned
(and in this case we say that l has been assigned as right split).
Theorem 6 Q-DLL(, ) returns True if  is true, and False otherwise.
Proof. Trivial consequence of Lemmas 2.1, 2.4, 2.5, 2.6 in the work of Cadoli, Giovanardi,
Giovanardi, and Schaerf (2002) and of the semantics of QBFs.

Given what we have said so far, it is clear that Q-DLL evaluates  by generating a
semantic tree (Robinson, 1968) in which each node corresponds to an invocation of Q-DLL
and thus to an assignment . For us,
 an assignment (for a QBF ) is a possibly empty sequence  = l1 ; l2 ; . . . ; lm (m  0)
of literals such that for each li in , li is unit, or monotone, or at the highest level in
l1 ;l2 ;...;li1 ;
 the (semantic) tree representing a run of Q-DLL on  is the tree
 having a node  for each call to Q-DLL(, ); and
 an edge connecting any two nodes  and ; l, where l is a literal.
Any tree representing a run of Q-DLL has at least the node .
As an example of a run of Q-DLL, consider the QBF (4). For simplicity, assume that
the literal returned at line 5 in Figure 1 is the negation of the first variable in the prefix
which occurs in the matrix of the QBF under consideration. Then, the tree searched by
Q-DLL when  is (4) can be represented as in Figure 2. In the figure:
380

fiClause/Term Resolution and Learning for Quantified Boolean Formulas

{}{{x1 , y, x2 }, {x1 , y, x3 }, {y, x2 }, {y, x2 , x3 }, {x2 , x3 }}{}
{x1 } hx1 , li {x1 }
{{y, x3 }, {y, x2 }, {y, x2 , x3 }, {x2 , x3 }}

{x1 } hx1 , ri {x1 }
{{y, x2 }, {y, x2 }, {y, x2 , x3 }, {x2 , x3 }}

hy, ri {x1 }
hy, li {y}
hy, li {y}
hy, ri {x1 }
hx2 , pi{y} {x1 , y, x2 }hx2 , ui{x1 }
hx2 , pi{y} {x1 , y, x3 }hx3 , ui{x1 }
{{}} {y, x2 }
{y} {} {y}
{y, x2 }hx2 , ui{y, x3 } {y} {} {y}
{{}} {x2 , x3 }

Figure 2: The tree generated by Q-DLL for (4). The matrix of (4) is shown at the root
node, and the prefix is x1 yx2 x3 . u, p, l, r stand for unit, pure, left
split, right split respectively, and have the obvious meaning.

 Each node is labeled with the literal assigned by Q-DLL in order to extend the assignment built so far. Thus, the assignment corresponding to a node is the sequence
of labels in the path from the root to the node. For instance, the assignment corresponding to the node with label x3 is x1 ; y; x3 .
 When literals are assigned as unit or monotone, the corresponding nodes are aligned
one below the other. Further for each assigned literal l, we also show whether l
has been assigned as unit, monotone, left or right split by marking it as u, p, l, r
respectively.
 When l has been assigned as a left or right split, we also show the matrix of ;l ,
where  is the sequence of literals assigned before l.
 When the node  is a leaf, then the matrix of  is either empty (in which case we
write {} below the node), or it contains a contradictory clause (in which case we
write {{}} below the node).
Considering Figure 2, it is easy to see that Q-DLL would correctly return False, meaning that (4) (and thus also (2)) is false.
3.3 Resolution and DLL Based Decision Procedures for QBFs
The well known correspondence in SAT between semantic trees and resolution (see, e.g.,
Urquhart, 1995) gives us the starting point for our analysis, aimed to establish a correspondence between Q-DLL and clause/term resolution.
Consider a QBF . Let  be the tree explored by Q-DLL for evaluating .
For the time being, assume that we are dealing with a SAT problem, i.e.,  does not
contain universal quantifiers. Then, Q-DLL reduces to DLL, and if  is false then we can
use  to generate a clause resolution deduction of the empty clause from . The basic idea
is to associate with each node  of  a clause C which is -falsified, i.e., such that for each
381

fiGiunchiglia, Narizzano & Tacchella

literal l  C, l is in . (We say that a literal l is in or has been assigned by l1 ; . . . ; lm if and
only if l  {l1 , . . . , lm }). More precisely:
 With every leaf  of , we associate an arbitrarily selected clause in the matrix of
 which is -falsified. At least one such clause exists because  contains the empty
clause.
 If C is the clause associated with a node ; l, then
1. If l 6 C then C is also the clause associated with . Notice that if l is monotone
in  then l 6 C.
2. If l  C and l is unit in  then the clause associated with  is the resolvent of
C and an arbitrarily selected clause of  which causes l to be unit in  .
3. If l  C and l is not unit in  then we have to consider the clause C 0 associated
with the node ; l. If l 6 C 0 then C 0 is the clause associated with  (as in the
first case). If l  C 0 , the clause associated with  is the resolvent of C and C 0 .
Lemma 1 Let  be a QBF without universal quantifiers. Let  be the tree searched by
Q-DLL(, ). Let  be an assignment for . If  is false, then the clause associated with
the node  of 
 is -falsified; and
 does not contain existential literals whose negation has been assigned as monotone
in .
Proof. Let S be the set of assignments in  which extend . Clearly, for each assignment
0  S, 0 is false ( does not contain universal quantifiers). On S, we define the partial
order relation  according to which two assignments 0 and 00 in S are such that 0  00
if and only if 0 extends 00 . Clearly  is well founded and the minimal elements are the
assignments extending  and corresponding to the leaves of .
If 0 extends  and is a leaf of , then 0 contains a contradictory clause C. Since
 does not contain universal quantifiers, C is 0 -falsified and is associated with the node
0 . Clearly, C does not contain existential literals whose negation has been assigned as
monotone.
By induction hypothesis, for each assignment 0 = 00 ; l  00 in S we have a 0 -falsified
clause not containing existential literals whose negation has been assigned as monotone.
We have to show the thesis for 00 . There are three cases:
1. l has been assigned as unit. Let C1 be the clause associated with 00 ; l. By induction
hypothesis, the thesis holds for C1 . If C1 does not contain l, the thesis trivially follows.
Otherwise, the clause associated with 00 is the resolvent C of C1 with a clause C2
that causes l to be unit in 00 . C2 is 00 ; l-falsified and it does not contain existential
literals whose negation has been assigned as monotone. C = C1  C2 \ {l, l} and thus
the thesis trivially holds.
2. l has been assigned as monotone. In this case the clause C associated with 00 is the
same clause associated with 00 ; l. By induction hypothesis C does not contain l and
thus C is 00 -falsified.
382

fiClause/Term Resolution and Learning for Quantified Boolean Formulas

3. l is a split. In this case we have a clause C1 associated with 00 ; l and a clause C2
associated with 00 ; l. The thesis holds for both C1 and C2 by induction hypothesis.
If C1 does not contain l, then the clause associated with 00 is C1 and the thesis
trivially holds. Otherwise, if C2 does not contain l, then the clause associated with
00 is C2 and again the thesis trivially holds. Otherwise, the clause associated with 00
is C1  C2 \ {l, l} and again the thesis trivially holds.

Theorem 7 Let  be a false QBF without universal quantifiers. The tree searched by QDLL(, ) corresponds to a clause resolution deduction of the empty clause.
Proof. Let  be a sequence of clauses obtained by listing the clauses in the matrix of 
according to an arbitrary order, followed by the clauses associated with the internal nodes
of the tree  searched by Q-DLL(, ), assuming  is visited in post order. Clearly,  is
a deduction.  is a deduction of the empty clause because the node  has an associated
-falsified clause (Lemma 1), i.e., the empty clause.

The theorem points out the close correspondence between the computation of Q-DLL
and clause resolution, assuming the input formula is false and that it does not contain
universal quantifiers. If the input formula does not contain universal quantifiers but is true,
still the tree explored by Q-DLL before generating the path ending with the empty matrix
corresponds to a sequence of clause resolutions, one for each maximal subtree whose leaves
 are such that  contains an empty clause.
If we no longer assume that the input formula  does not contain universal quantifiers,
and consider the case in which  is an arbitrary QBF, the situation gets more complicated,
also because of the possibility of assigning unit literals which are not at the highest level.
So, we now assume that if a literal l is assigned as unit at a node , then l is at the highest
level in  .
Then, if the input formula  is false, we can again use the tree  searched by Q-DLL to
generate a clause resolution deduction of the empty clause. The construction is analogous
to the one described before. The only difference is that we have to restrict our attention
to the minimal false subtree of , i.e., the tree obtained from  by deleting the subtrees
starting with a left split on a universal literal: These subtrees are originated from wrong
choices when deciding which branch to explore first. In the minimal false subtree 0 of ,
all the leaves terminate with the empty clause, and we can associate with each node of 0 a
clause exactly in the same way described above for the SAT case. For instance, if  is (4),
then Q-DLL assigns unit literals only when they are at the highest level. Figure 3 shows
the minimal false subtree of Q-DLLs computation, and the associated clause resolution
deduction of the empty clause. In the figure,
 the clause associated with each node is written in red and to the right of the node
itself;
 when a node corresponds to the assignment of a unit literal l, a clause of  which
causes l to be unit at that node (used in the corresponding clause resolution) is written
in red and to the left of the node.
383

fiGiunchiglia, Narizzano & Tacchella

{}{{x1 , y, x2 }, {x1 , y, x3 }, {y, x2 }, {y, x2 , x3 }, {x2 , x3 }}{}
{x1 } hx1 , li {x1 }
{{y, x3 }, {y, x2 }, {y, x2 , x3 }, {x2 , x3 }}

{x1 } hx1 , ri {x1 }
{{y, x2 }, {y, x2 }, {y, x2 , x3 }, {x2 , x3 }}

hy, ri {x1 }
{x1 , y, x3 }hx3 , ui{x1 }
{y, x2 }hx2 , ui{y, x3 }
{{}} {x2 , x3 }

hy, ri {x1 }
{x1 , y, x2 }hx2 , ui{x1 }
{{}} {y, x2 }

Figure 3: The clause resolution corresponding to the tree generated by Q-DLL for (4). The
prefix is x1 yx2 x3 .

Lemma 2 Let  be a false QBF. Let  be the minimal false subtree of the tree searched by
Q-DLL(, ) and assume that for each node ; l in , if l is unit in  then l is also at the
highest level in  . Let  be an assignment for . If  is false, then the clause associated
with the node  of 
 is -falsified; and
 does not contain existential literals whose negation has been assigned as monotone
in .
Proof. Trivial extension of the proof of Lemma 1. The assumption that for each node ; l
in , if l is unit in  then l is at the highest level in  , ensures that each clause associated
with a node  of  is -falsified.


Theorem 8 Let  be a false QBF. Let  be the minimal false subtree of the tree searched
by Q-DLL(, ) and assume that for each node ; l in , if l is unit in  then l is also at
the highest level in  . Then  corresponds to a clause resolution deduction of the empty
clause.
Proof. Given Lemma 2, the proof is analogous to the one of Theorem 7.



Regardless of whether the input formula is true or false, the tree explored by Q-DLL
may contain (exponentially many) subtrees whose nodes  are such that  is false. The
procedure described above, allows us to associate a clause resolution deduction with each
of such subtrees.
If the input formula  is true, the situation is simpler because so far we do not have unit
universal literals, and we can use the tree  searched by Q-DLL to generate a deduction
of the empty term from . Intuitively, the process is analogous to the one described when
 is false, except that the leaves of our term resolution deduction are terms corresponding
to the assignments computed by Q-DLL and entailing the matrix of . In details:
384

fiClause/Term Resolution and Learning for Quantified Boolean Formulas

 First, we have to restrict our attention to the minimal true subtree of , i.e., the tree
obtained from  by deleting the subtrees starting with a left split on an existential
literal: Analogously to the the case in which  is false, each leaf in a minimal true
subtree of  terminates with the empty matrix.
 Second, we associate with each node  a term, represented as a set, as follows:
 The term associated with each leaf is a minimal term min(T ) in which T 1
1. does not contain universal literals assigned as monotone,
2. has to propositionally entail the matrix, i.e., for each clause C in the matrix
of , T  C 6= , and
3. has to be a subset of the literals in , i.e., T  {l : l is in }.
 If T is the term associated with a node ; l, then
1. If l 6 T then T is the term associated with the node . Notice that if l is
either existential or both universal and monotone in  , then l 6 T .
2. If l  T then we have to consider also the term T 0 associated with the node
; l. If l 6 T 0 then T 0 is the term associated with  (as in the first case). If
l  T 0 , the term associated with  is the resolvent of T and T 0 .
It is easy to see that the term T associated with a node  is -entailed: Each literal in T
is also in .
Lemma 3 Let  be a true QBF. Let  be the minimal true subtree of the tree searched by
Q-DLL(, ). Let  be an assignment for . If  is true, then the term associated with
the node  of 
 is -entailed; and
 does not contain universal literals assigned as monotone.
Proof. Analogous to the proof of Lemma 2.



Theorem 9 Let  be a true QBF. Let  the minimal true subtree of the tree searched by
Q-DLL(, ). Then  corresponds to a model generation and term resolution deduction of
the empty term.
Proof. Let  be the sequence of terms obtained by listing the terms associated with the
nodes of  visited in post order. Clearly,  is a model generation and term resolution deduction.  is a deduction of the empty term because the node  has an associated -entailed
term (Lemma 3), i.e., the empty term.

As before, regardless of whether the input formula is true or false, the tree explored
by Q-DLL may contain (exponentially many) subtrees whose nodes are associated with
1. For the sake of efficiency, it is also important that the term T satisfies other properties. However, they
are not necessary for the time being, and will be discussed in the next section.

385

fiGiunchiglia, Narizzano & Tacchella

{}{{x1 , y, x2 }, {x1 , y, x3 }, {y, x2 }, {y, x2 , x3 }, {x2 , x3 }}{}
{x1 } hx1 , ri {x1 }
{x1 } hx1 , li {x1 }
{{y, x3 }, {y, x2 }, {y, x2 , x3 }, {x2 , x3 }} {{y, x2 }, {y, x2 }, {y, x2 , x3 }, {x2 , x3 }}
hy, li {y}
hx2 , pi{y}
{y, x2 } {} {y}

hy, li {y}
hx2 , pi{y}
{y, x2 } {} {y}

Figure 4: The term resolutions corresponding to the tree generated by Q-DLL for (4). The
prefix is x1 yx2 x3 .

{}{{x1 , y, x2 }, {x1 , y, x3 }, {y, x2 }, {y, x2 , x3 }, {x2 , x3 }}{}
{x1 } hx1 , li {x1 }
{{y, x3 }, {y, x2 }, {y, x2 , x3 }, {x2 , x3 }}

{x1 } hx1 , ri {x1 }
{{y, x2 }, {y, x2 }, {y, x2 , x3 }, {x2 , x3 }}

hy, li {y}
hy, li {y}
hy, ri {x1 }
hy, ri {x1 }
hx2 , pi{y} {x1 , y, x3 }hx3 , ui{x1 }
hx2 , pi{y} {x1 , y, x2 }hx2 , ui{x1 }
{y, x2 } {} {y}
{{}} {y, x2 }
{y, x2 }hx2 , ui{y, x3 } {y, x2 } {} {y}
{{}} {x2 , x3 }

Figure 5: The resolution corresponding to the tree generated by Q-DLL for (4). The prefix
is x1 yx2 x3 .

assignments  with  being true. The above described procedure allows us to associate
a term resolution deduction with each of such subtrees. For instance, if  is (4) there are
two maximal such subtrees, having roots x1 ; y and x1 ; y. The associated deductions are
represented in Figure 4. In the figure,
 we represent also the nodes along the path from the root to the subtrees,
 the term associated with each node is written in green and to the right of the node
itself,
 if  is a leaf, a non-contradictory term T entailing the matrix and whose minimal
form min(T ) is associated with , is written in green and to the left of .
Merging the trees in Figures 3 and 4 we obtain the whole tree of deductions corresponding to the search tree explored by Q-DLL (represented in Figure 5) in which clause and
term resolutions are intermixed.
386

fiClause/Term Resolution and Learning for Quantified Boolean Formulas

Now we consider the case in which the input QBF  is false and we no longer assume
that literals are assigned as unit only if they are at the highest level. We restrict our
attention to the minimal false subtree  of the tree searched by Q-DLL(, ). Then, the
procedure described above for associating a clause with each node of  may no longer work.
For one thing, given a leaf , there may be no -falsified clauses in the matrix of the input
formula. However, we are guaranteed about the existence of a -contradicted clause in the
matrix of the input formula. A clause C is -contradicted if2
 for each literal l in C, l is not in ; and
 for each existential literal l in C, l is in .
As long as we can associate with each node  of  a -contradicted clause (either belonging
to the matrix of  or obtained by clause resolution)  corresponds to a clause resolution
deduction of the empty clause: Indeed the clause associated with the root of  has to be
empty (remember that the resolvent of a clause resolution is in minimal form). Thus, the
obvious solution is to try to associate
1. with each leaf  a -contradicted clause in the input formula, and
2. with each internal node  a -contradicted clause obtained by resolving input clauses
and/or previously deduced clauses along the same lines outlined before.
In some cases the process runs smoothly. Consider for instance, a QBF of the form:
x1 x2 yx3 {{x1 , x3 }, {x2 , x3 }, {x2 , y, x3 }, . . .}.

(7)

Then, if we assume that a split on x1 occurs first, the following path will be explored (we
are using the same conventions of Figure 3):
hx1 , li
hx3 , ui
hx2 , ui
{{}}

(8)

and the clause associated with each node are:
hx1 , li
{x1 , x3 } hx3 , ui
{x2 , x3 } hx2 , ui
{{}}

{x1 }
{x1 }
{y, x3 }
{x2 , y, x3 }

where we see that:
1. the clause associated with the leaf  = x1 ; x3 ; x2 is not -falsified but is -contradicted;
and
2. With respect to the definition of contradictory clause given in Section 3.2, it is clear that a clause C is
contradictory if and only if it is -contradicted. Further, for any QBF  and assignment , there exists
a -contradicted clause in the matrix of , if and only if  contains a -contradicted clause, if and only
if  contains a contradictory clause.

387

fiGiunchiglia, Narizzano & Tacchella

0 function Rec-C-Resolve(, C1 , C2 , l, )
1
S := {l : l  C1 , l  C2 };
2
if (S = ) return C-Resolve(C1 , C2 );
3
l1 := han existential literal in C1 with level  than the level of all the literals in C1 }i;
4
C := ha clause in  which causes l1 to be unit in 0 , where 0 ; l1 is a prefix of i;
5
C3 := C-Resolve(C1 , C);
6
return Rec-C-Resolve(, C3 , C2 , l, ).
Figure 6: The algorithm of Rec-C-Resolve.
2. we are able to associate with each node  a -contradicted clause.
Unfortunately, in some cases things do not run so smoothly, i.e., it may not be possible
to associate a clause to an internal node by a simple single resolution between input and/or
previously deduced clauses. Indeed, some clause resolutions may be blocked because of
universal variables occurring both as y and y in the clauses to be used for the resolution.
Consider for instance a QBF of the form (obtained from (7) by replacing the clause {x2 , x3 }
with {x2 , y, x3 }):
x1 x2 yx3 {{x1 , x3 }, {x2 , y, x3 }, {x2 , y, x3 }, . . .}.

(9)

Then, (8) would be still a valid path, and the corresponding clause resolutions would be:
hx1 , li
{x1 , x3 } hx3 , ui
{x2 , y, x3 } hx2 , ui . . .
{{}} {x2 , y, x3 }

(10)

where it is not possible to perform the clause resolution associated with the node having
label hx2 , ui. As in the example, a clause resolution (5) may be blocked only because of
some blocking universal literal l
 with both l and l not in , and
 with l  C1 and l  C2 .
Since both C1 and C2 are in minimal form, this is only possible if both C1 and C2 contain
an existential literal l0
 having level less than or equal to the level of all the other literals in the clause; and
 assigned as unit.
Then, the obvious solution is to get rid, e.g., of the blocking literals l in C1 by resolving
away from C1 the existential literals with a level lower than the level of l.
This is the idea behind the procedure Rec-C-Resolve in Figure 6. In the figure, we
assume that
1.  is the input QBF;
388

fiClause/Term Resolution and Learning for Quantified Boolean Formulas

2. ; l is an assignment;
3. l is an existential literal which is either unit or at the highest level in  ;
4. C1 is a clause containing l, in minimal form and ; l-contradicted;
5. C2 is a clause containing l, in minimal form and ; l-contradicted. Further, if l is unit
in  , then C2 is a clause which causes l to be unit in  ;
6. C-Resolve(C1 , C2 ) returns the resolvent of the clause resolution between the two
clauses C1 and C2 .
From here on, if h, C1 , C2 , l, i satisfies the first 5 of the above conditions, we say that
the pair hC1 , C2 i is to be ; l-Rec-C-Resolved (in ). Given two clauses hC1 , C2 i to be
; l-Rec-C-Resolved:
1. The set S of universal literals blocking the clause resolution between C1 and C2 is
computed (line 1).
2. If S is empty, then we can simply return the resolvent between C1 and C2 (line 2);
otherwise
3. we pick an existential literal l1 in C1 having minimum level in C1 (line 3): l1 has
been assigned as unit earlier in the search, and we consider a clause C which caused
l1 to be assigned as unit (line 4). If C3 is the resolvent between C1 and C (line 5),
Rec-C-Resolve(, C3 , C2 , l, ) is returned (line 6).
If hC1 , C2 i are to be ; l-Rec-C-Resolved in , Rec-C-Resolve(, C1 , C2 , l, ) returns a minimal clause which is -contradicted and without existential literals whose negation has been
assigned as monotone in . This is formally stated by the following lemma.
Lemma 4 Let C1 and C2 be two clauses such that hC1 , C2 i is to be ; l-Rec-C-Resolved in
a QBF . Rec-C-Resolve(, C1 , C2 , l, ) terminates and returns a clause
 in minimal form and -contradicted; and
 which does not contain existential literals whose negation has been assigned as monotone in .
The proof of the lemma is quite long and it is reported in the appendix.
Assuming that the input QBF  is false, the construction of the deduction of the empty
clause (associated with the minimal false subtree  of the tree searched by Q-DLL) is the
following:
 With every leaf  of , we associate a clause C in the input formula which is contradicted.
 If C is the clause associated with a node ; l, then
1. If l 6 C or if l is universal then C is the clause associated with the parent of
; l, i.e., with the node . Notice that if l is existential and monotone in  then
l 6 C.
389

fiGiunchiglia, Narizzano & Tacchella

2. If l  C and l is unit in  then the clause associated with the node  is the
result of Rec-C-Resolve(, C, C 0 , l, ), where C 0 is a clause of  which causes l
to be unit in  .
3. If l  C, l is existential and not unit in  , then we have to consider also the
clause C 0 associated with the node ; l. If l 6 C 0 then C 0 is the clause associated
with  (as in the first case). If l  C 0 , the clause associated with the node  is
the result of Rec-C-Resolve(, C, C 0 , l, ).
In our example, if  is (9) and with reference to the deduction in (10), the blocked resolution is the one associated with the node x1 ; x3 ; x2 . Rec-C-Resolve(, {x2 , y, x3 }, {x2 , y, x3 }, x2 , x1 ; x3 )
1. at line 5, resolves {x2 , y, x3 } and {x1 ; x3 }, and the resolvent C3 is min({x1 , x2 , y}) =
{x1 , x2 }; and
2. the following recursive call to Rec-C-Resolve(, {x1 , x2 }, {x2 , y, x3 }, x2 , x1 ; x3 ) at line 6
returns {x1 , y, x3 }.
Thus, the clause associated with each node are:
hx1 , li
{x1 , x3 } hx3 , ui
{x2 , y, x3 } hx2 , ui
{{}}

{x1 }
{x1 }
{x1 , y, x3 }
{x2 , y, x3 }

Notice that, with reference to Figure 6, the choice of eliminating the blocking literals
in C1 while maintaining C2 invariant, is arbitrary. Indeed, we could eliminate the blocking
literals in C2 and maintain C1 invariant. In the case of the deduction in (10), this amounts
to eliminate the universal literal y in {x2 , y, x3 }: By resolving this clause with {x1 , x3 } on
x3 , we get the resolvent {x1 , x2 }, which leads to the following legal deduction:
hx1 , li
{x1 , x3 } hx3 , ui
(From {x2 , y, x3 }, {x1 , x3 }) {x1 , x2 } hx2 , ui
{{}}

{x1 }
{x1 }
{x1 , y, x3 }
{x2 , y, x3 }

Lemma 5 Let  be a false QBF. Let  be the minimal false subtree of the tree searched by
Q-DLL(, ). Let  be an assignment for . If  is false, then the clause associated with
the node  of 
 is in minimal form and -contradicted; and
 does not contain existential literals whose negation has been assigned as monotone
in .
Proof. By construction, each clause associated with a leaf  of  is -contradicted. We
now show that also the clause C associated with an internal node  of  is -contradicted,
assuming that the clause C 0 associated with its child ; l is ; l-contradicted. If  has also a
child ; l, we also assume that the clause C 00 associated with its child ; l is ; l-contradicted.
390

fiClause/Term Resolution and Learning for Quantified Boolean Formulas

1. If l 6 C 0 or if l is universal then C = C 0 . Hence, C is in minimal form. Since l 6 C 0
or l is universal, C 0 is ; l-contradicted if and only if C 0 is -contradicted. The thesis
follows because C = C 0 .
2. If l  C 0 and l is unit in  then C =Rec-C-Resolve(, C 0 , C 00 , l, ), where C 00 is a
clause of  which causes l to be unit in  . The thesis follows from Lemma 4.
3. If l  C, l is existential and not unit in  , then we have to consider also the clause
C 0 associated with the node ; l. Assuming l  C 0 (otherwise we would be in the first
case), the clause associated with  is the result of Rec-C-Resolve(, C, C 0 , l, ). As in
the previous case, the thesis follows from Lemma 4.

Theorem 10 Let  be a false QBF. Let  be the minimal false subtree of the tree searched
by Q-DLL(, ). Then  corresponds to a clause resolution deduction of the empty clause.
Proof. Given Lemma 5, the proof is analogous to the one of Theorem 7.



4. Backjumping and Learning in DLL Based Procedures for QBFs
In this section we first show that computing the resolvent associated with each node allows
to backjump some branches while backtracking (Subsection 4.1). Then, we show that
learning resolvents allows to prune the search tree in branches different from the ones in
which resolvents were computed and learned (Subsection 4.2).
4.1 Conflict and Solution Directed Backjumping
The procedure described in Section 3.2 uses a standard backtracking schema whenever the
empty clause (resp. matrix) is generated: Q-DLL will backtrack up to the first existential
(resp. universal) literal assigned as left split. For instance, given the QBF
y1 x1 y2 x2 x3 {{y1 , y2 , x2 }, {y1 , y 2 , x2 , x3 }, {y1 , x2 , x3 },
{y 1 , x1 , x3 }, {y 1 , y2 , x2 }, {y 1 , y2 , x2 }, {y 1 , x1 , y 2 , x3 }},

(11)

the tree searched by Q-DLL is represented in Figure 7, where we use the same conventions
as in Section 3.
In the 2001 work of Giunchiglia, Narizzano, and Tacchella (2001), it is shown that the
exploration of some branches is not necessary. In particular, if  is the input QBF and  is
an assignment, we show how it is possible to compute a reason for the (un)satisfiability
of  while backtracking. Intuitively speaking, a reason for the result of  is a subset  of
the literals in  such that for any other assignment 0
 which assigns to true or false the same literals assigned by  (i.e., such that {|l| :
l is in 0 } = {|l| : l is in }); and
 which extends  (i.e., such that   {l : l is in 0 }),
391

fiGiunchiglia, Narizzano & Tacchella

{}
{{y1 , y2 , x2 }, {y1 , y 2 , x2 , x3 }, {y1 , x2 , x3 },
{y 1 , x1 , x3 }, {y 1 , y2 , x2 }, {y 1 , y2 , x2 }, {y 1 , x1 , y 2 , x3 }}
{y 1 }hy 1 , li{y 1 }
{{y2 , x2 }, {y 2 , x2 , x3 }, {x2 , x3 }}
hy 2 , li{y 1 }
{y 1 , y 2 , x2 }hx2 , ui{y 1 }
{y 1 , x2 , x3 }hx3 , ui{y 1 }
{y 1 , x2 , x3 } {} {y 1 }

hy1 , ri{}
{{x1 , x3 }, {y2 , x2 }, {y2 , x2 }, {x1 , y 2 , x3 }}

hy2 , ri
{{x2 , x3 }, {x2 , x3 }}
hx2 , li
hx3 , ui
{}

hx1 , li{}
{y 1 , x1 , x3 }hx3 , ui{}
hy 2 , pi{}
{y 1 , y2 , x2 }hx2 , ui{}
{{}} {y 1 , y2 , x2 }

hx1 , ri
hx3 , pi
hy 2 , pi
hx2 , ui
{{}}

Figure 7: The resolution corresponding to the tree generated by Q-DLL for (11). The prefix
is y1 x1 y2 x2 x3 .

0 is equivalent to  . Then, by computing reasons, we can avoid to right split on a
literal l if l is not in the reason: assigning l to false would not change the result. The
resulting procedure is a generalization to QBF of the popular Conflict-directed Backjumping
(CBJ) (Prosser, 1993b), but also introduces the concept of Solution-directed Backjumping
(SBJ), for avoiding useless splits on universal variables.
In a later paper, Giunchiglia, Narizzano, and Tacchella (2003) show how it is possible
to optimize the computation of reasons. In particular, in that paper, it is shown that
 assuming  is unsatisfiable, we can consider reasons being a subset of the existential
literals in , while
 assuming  is satisfiable, we can consider reasons being a subset of the universal
literals in .
Apart from these optimizations, the tree searched by the procedures described in the former
and latter papers is the same, and, in the case of (11), the exploration of the branches
starting with hy2 , ri, hx1 , ri will be skipped (see Figure 7).
We now show that the computation of the resolutions corresponding to Q-DLL allows
to avoid the exploration of some branches pretty as much as CBJ and SBJ do: In the case
of the QBF (11), the branches being skipped will be the same skipped by CBJ and SBJ.
The key point is to think about Q-DLL as a procedure producing a clause (resp. term)
deduction of the empty clause (resp. term), proving that  is unsatisfiable (resp. satisfiable).
Then, according to the rules we use for associating a deduction to the tree searched by QDLL, we have that:
 If C is the clause associated with a node ; l and l 6 C, then the clause associated
with the node  is C, even if l is existential and it has been assigned as left split.
392

fiClause/Term Resolution and Learning for Quantified Boolean Formulas

0 function Q-DLL-BJ(, )
1
if (ha clause C is -contradictedi)
2
return C;
3
if (hthe matrix of  is emptyi) return ModelGenerate();
4
if (hl is unit in  i)
5
C := ha clause in the matrix of  which causes l to be unit in  i;
6
W R := Q-DLL-BJ(, ; l);
7
if (hW R is a termi or l 6 W R) return W R;
8
return Rec-C-Resolve(, W R, C, l, );
9
if (hl is monotone in  i) return Q-DLL-BJ(, ; l);
10
l := ha literal at the highest level in  i;
11
W R := Q-DLL-BJ(, ; l);
12
if (hl is existentiali and (hW R is a termi or l 6 W R)) return W R;
13
if (hl is universali and (hW R is a clausei or l 6 W R)) return W R;
14
W R0 := Q-DLL-BJ(, ; l);
15
if (hl is existentiali and (hW R0 is a termi or l 6 W R0 )) return W R0 ;
16
if (hl is universali and (hW R0 is a clausei or l 6 W R0 )) return W R0 ;
17
if (hl is existentiali) return Rec-C-Resolve(, W R0 , W R, l, );
18
return T-Resolve(W R0 , W R, l, ).
Figure 8: The algorithm of Q-DLL-BJ.
 Analogously, if T is the term associated with a node ; l and l 6 T , then the term
associated with the node  is T , even if l is universal and it has been assigned as left
split.
The above rules do not take into account the clause/term associated with the node ; l, and
thus there is no need to explore the branch starting with ; l.
Consider for example Figure 7, in which we use the standard conventions and, e.g., write
the clause (resp. term) associated with each node  in red (resp. green) to the right of
the node. With reference to the figure, it is clear that considering the term {y 1 } associated
with the node y 1 ; y 2 , there is no need to explore the branch starting with hy2 , ri in order to
associate a y 1 -entailed term with the node y 1 . Similarly, considering the empty clause {}
associated with the node y1 ; x1 , there is again no need to explore the branch starting with
hx1 , ri in order to associate a y1 -contradicted clause with the node y1 .
The procedure Q-DLL-BJ(, ) in Figure 8 incorporates these ideas. In the figure,
 ModelGenerate() returns the minimal form of a non-contradictory and -entailed
term T such that
 for each clause C  , C  T 6= ; and
 for each universal literal l in  assigned as monotone, l 6 T .
 Rec-C-Resolve(, C1 , C2 , l, ) is as in Figure 6.
393

fiGiunchiglia, Narizzano & Tacchella

 T-Resolve(T1 , T2 ) returns the resolvent of the term resolution between the two terms
T1 and T2 .
The behavior Q-DLL-BJ can be illustrated in a few words by saying that Q-DLL-BJ(, )
computes and returns the clause/term that would be associated with the node  in the tree
explored by Q-DLL. In particular, assuming
 that W R is the clause (resp. term) returned by Q-DLL-BJ(, ; l);
 that l is existential (resp. universal); and
 that l has been assigned as left split,
Q-DLL-BJ(, ) does not explore the branch starting with ; l if l 6 W R (resp. l 6 W R),
see line 12 (resp. line 13) in Q-DLL-BJ.
So far, with reference to Figure 7, we can interpret the clause (resp. term) in red
(resp. green) to the right of a node  as the value returned by Q-DLL-BJ(, ). Then,
considering the term {y 1 } associated with the node y 1 ; y 2 , Q-DLL-BJ does not explore the
branch starting with hy2 , ri. Similarly, considering the empty clause {} associated with the
node y1 ; x1 , Q-DLL-BJ again does not explore the branch starting with hx1 , ri.
Theorem 11 Q-DLL-BJ(, ) returns the empty clause if  is false, and the empty term
if  is true.
Proof.(Sketch) It is enough to notice that:
 If a node  has associated a clause C, then C is -contradicted, and C is the result
of a sequence of clause resolutions.
 If a node  has associated a term T , then T is -entailed, and T is the result of a
sequence of model generations and term resolutions.
Then, as in the previous section:
 If the empty clause is associated with the initial node , then  is false.
 If the empty term is associated with the initial node , then  is true.



4.2 Learning
Learning is a well known technique in SAT for avoiding the useless traversal of branches. In
SAT, learning amounts to storing (clause) resolvents associated with the nodes of the tree
explored by DLL: these resolvents are called nogoods and can be simply added to the set
of input clauses.
In the case of QBFs, the situation is different and more complicated. Indeed, we have
two types of resolutions (term and clause), and while the resolvents of clause resolutions
can be added conjunctively to the matrix, the resolvents of term resolutions (that we will
call goods) have to be considered as in disjunction to the matrix.
In practice, we have to handle three sets of formulas:
394

fiClause/Term Resolution and Learning for Quantified Boolean Formulas

 a set  of terms corresponding to the goods learned during the search;
 a set  of clauses corresponding to the matrix of the input QBF; and
 a set  of clauses corresponding to the nogoods learned during the search.
Formally, if  is a QBF of the form (1), a QBF  Extended with Learning (EQBF) is an
expression of the form
Q1 z1 . . . Qn zn h, , i
(n  0)
(12)
where
  is a set of terms, also called goods, to be interpreted disjunctively. Each good is
obtained by model generation and/or term resolution from ;
  is a set of clauses, also called nogoods, to be interpreted conjunctively. Each nogood
is obtained by clause resolution from .
Clearly,
Q1 z1 . . . Qn zn (  )
and
Q1 z1 . . . Qn zn (  )
are equivalent to (1).
Initially  and  are the empty set, and  is the input set of clauses. As the search
proceeds,
 Nogoods are determined while backtracking from a contradiction (i.e., on an assignment  and  is unsatisfiable) and are possibly added to ; and
 Goods are determined while backtracking from a solution (i.e., on an assignment 
and  is satisfiable) and are possibly added to .
In the following, we will use the term constraints when we want to refer to goods and
nogoods indifferently.
Consider an EQBF (12). Because of the constraints in  and/or , the search can be
pruned considerably. Indeed, while descending the search tree, any literal can be assigned
as long as we are guaranteed that we can reconstruct a valid clause/term deduction while
backtracking of the empty clause/term. The availability of already derived clauses/terms
allows to prune the search because of the constraints in  or : Given an assignment ,
if there exists a -contradicted clause C   (resp. a -satisfied term T  ) we can stop
the search and return C (resp. T ). A term T is -satisfied if
 for each literal l in T , l is not in ; and
 for each universal literal l in T , l is in .
Clearly, a -entailed term is also -satisfied. Further, we can extend the notion of unit to
take into account the constraints in  and/or . A literal l is
 unit in a EQBF (12) if
395

fiGiunchiglia, Narizzano & Tacchella

0 function Rec-Resolve(, W1 , W2 , l, )
1
S := {l : l  W1 , l  W2 };
2
if (S = ) return Resolve(W1 , W2 );
3
l0 := ha literal in W1 with level  than the level of all the literals in W1 }i;
4
W := ha constraint in  which causes l0 to be unit in 0 , where 0 ; l0 is a prefix of i;
5
W3 := Resolve(W1 , W );
6
return Rec-Resolve(, W3 , W2 , l, ).
Figure 9: The algorithm of Rec-Resolve.
 either l is existential and for some m  0,
 a clause {l, l1 , . . . , lm } belongs to  or , and
 each expression |li | (1  i  m) occurs at the right of |l| in the prefix of
(12).
 or l is universal and for some m  0,
 a term {l, l1 , . . . , lm } belongs to , and
 each expression |li | (1  i  m) occurs at the right of |l| in the prefix of
(12).
As for the definition of monotone literals, the crucial property that has to be ensured when
dealing with EQBFs, is that an existential (resp. universal) literal l assigned as monotone
in ; l should never enter in a nogood (resp. good) associated with a node extending ; l.
This is guaranteed by defining a literal l as monotone or pure if and only if3
 either l is existential and l does not belong to any constraint in   ;
 or l is universal and l does not belong to any constraint in   .
Because of the possibility of assigning also universal literals as unit, it may be the case
that some term resolutions may be blocked because of some existential literals l and l, each
occurring in one of the terms to be used in the antecedents of the term resolution. However,
the procedure Rec-C-Resolve presented in in Subsection 3.3 can be easily generalized to
work also for the case in which the constraints to be resolved are terms. The result is the
procedure Rec-Resolve(, W1 , W2 , l, ) in Figure 9, where it is assumed that
1.  is an EQBF;
3. There are various ways to guarantee that an existential literal l assigned as monotone in ; l does not
enter in a nogood associated with a node extending ; l. Another one is to
 keep the definition of existential monotone literal unchanged: An existential literal can be assigned
as monotone in (12) if l does not belong to any clause in ; and
 update  to (or proceed in the search as if  has been updated to)  \ {C : C  , l  C}.
Analogously for universal monotone literals. See the work of Giunchiglia, Narizzano and Tacchella (2004a) for more details and possibilities, including a discussion about the interaction between the
monotone rule and learning.

396

fiClause/Term Resolution and Learning for Quantified Boolean Formulas

2. ; l is an assignment;
3. l is an existential (resp. universal) literal which is either unit or at the highest level
in  ;
4. W1 is a clause (resp. term) containing l (resp. l), in minimal form and ; l-contradicted
(resp. ; l-satisfied);
5. W2 is a clause (resp. term) containing l (resp. l), in minimal form and ; l-contradicted
(resp. ; l-satisfied). Further, if l is unit in  , then W2 is a clause (resp. term) which
causes l to be unit in  ;
6. for each existential (resp. universal) literal l0 assigned as unit in 0 ; l0 , with 0 ; l0 a
prefix of ; l, there has to be a clause (resp. term) in  which causes l0 to be unit in
 0 .
7. Resolve(W1 , W2 ) returns C-Resolve(W1 , W2 ) (resp. T-Resolve(W1 , W2 )).
If h, W1 , W2 , l, i satisfy the first 6 of the above 7 conditions, we say that the pair hW1 , W2 i
is to be ; l-Rec-Resolved (in ).
In the above, if  is (12), l is defined as the EQBF obtained from  by
 removing from  and  (resp. ) the clauses C (resp. terms T ) with l  C (resp.
l  T ), and by removing l (resp. l) from the other clauses in    (resp. terms in
); and
 removing Q|l| from the prefix.
If  = l1 ; l2 ; . . . ; lm (m  0),  is defined as (. . . ((l1 )l2 ) . . .)lm .
If hW1 , W2 i are to be ; l-Rec-Resolved in , Rec-Resolve(, W1 , W2 , l, ) returns a
constraint in minimal form and -contradicted or -satisfied, as stated by the following
lemma.
Lemma 6 Let W1 and W2 be two clauses (resp. terms) such that hW1 , W2 i is to be ; lRec-Resolved in a EQBF . Rec-Resolve(, W1 , W2 , l, ) terminates and returns a minimal
clause (resp. term) which
 is -contradicted (resp. -satisfied); and
 does not contain existential literals whose negation has been (resp. universal literals
which have been) assigned as monotone in .
Proof.(Sketch) The proof is equal to (resp. analogous to) the proof of Lemma 4 if l is
existential (resp. universal).

The procedure Q-DLL-LN (, ) incorporates the above new definitions and ideas, and
is represented in Figure 10. Considering the figure,
 the definition of ModelGenerate() can be relaxed with respect to the definition provided in Subsection 4.1 in order to return the minimal form of a non-contradictory
and -satisfied term T such that
397

fiGiunchiglia, Narizzano & Tacchella

0  := {};
1  := {};
2 function Q-DLL-LN (, )
3
Q := hthe prefix of i;
4
 := hthe matrix of i;
5
if (ha -contradicted clause C is in   i)
6
return C;
7
if (ha -satisfied term T is in i)
8
return T ;
9
if (hthe matrix of  is emptyi) return ModelGenerate();
10
if (hl is unit in (Qh, , i) i)
11
W := ha constraint in      which causes l to be unit in (Qh, , i) i;
12
W R := Q-DLL-LN (, ; l);
13
if (hl is existentiali and (hW R is a termi or l 6 W R)) return W R;
14
if (hl is universali and (hW R is a clausei or l 6 W R)) return W R;
15
W R := Rec-Resolve(Qh, , i, W R, W, l, );
16
Learn(, W R);
17
return W R;
18
if (hl is monotone in (Qh, , i) i) return Q-DLL-LN (, ; l);
19
l := ha literal at the highest level in  i;
20
W R := Q-DLL-LN (, ; l);
21
if (hl is existentiali and (hW R is a termi or l 6 W R)) return W R;
22
if (hl is universali and (hW R is a clausei or l 6 W R)) return W R;
23
W R0 := Q-DLL-LN (, ; l);
24
if (hl is existentiali and (hW R0 is a termi or l 6 W R0 )) return W R0 ;
25
if (hl is universali and (hW R0 is a clausei or l 6 W R0 )) return W R0 ;
26
W R := Rec-Resolve(Qh, , i, W R0 , W R, l, );
27
Learn(, W R);
28
return W R.
Figure 10: The algorithm of Q-DLL-LN.
 for each clause C  , C  T 6= ; and
 for each universal literal l in  assigned as monotone, l 6 T .
 Learn(, W R) updates the set of goods and nogoods according to a given policy. Here
we simply assume that Learn(, W R) updates  and  to 0 and 0 respectively, and
that 0 and 0 satisfy the following conditions:
 0 is a subset of   {W R} if W R is a term, and of  otherwise;
 0 is a subset of   {W R} if W R is a clause, and of  otherwise; and
 for each existential (resp. universal) literal l assigned as unit in an initial prefix
0 ; l of , 0   (resp. 0 ) still contains a clause (resp. term) that causes l to
be assigned as unit in (Qh0 , , 0 i)0 .
398

fiClause/Term Resolution and Learning for Quantified Boolean Formulas

With reference to Figure 9, this last condition is necessary in order to guarantee the
existence of a constraint W satisfying the condition at line 4.
The above conditions on Learn(, W R) are very general and ensure the soundness and
completeness of Q-DLL-LN.
Theorem 12 Q-DLL-LN(, ) returns the empty clause if  is false, and the empty term
if  is true.
Proof. Analogous to the proof of Theorem 11.



To understand the benefits of learning, assume the input QBF is (4). The corresponding
EQBF is
x1 yx2 x3 h{}, {{x1 , y, x2 }, {y, x2 }, {x2 , x3 }, {x1 , y, x3 }, {y, x2 , x3 }}, {}i,
and the search proceeds as in Figure 2, with the first path leading to the empty matrix,
which starts the term resolution process. Assuming the term min({y, x2 }) = {y} is added
to the set of goods before checking the value of x1 ;y , as soon as x1 is assigned to true,
 y is detected to be unit and it is correspondingly assigned; and
 the path corresponding to the assignment x1 ; y is not explored.
As this example shows, (good) learning can avoid the useless exploration of some branches
that would be explored with a backtracking or backjumping schema. Indeed, we have been
assuming that the deduced term is learned while backtracking. A policy according to which
Learn(, W R) simply adds W R
 to  if W R is clause; and
 to  otherwise,
can be easily implemented. However, such simple policy may easily lead to store an exponential number of goods and/or nogoods (notice that we have a call to Learn(, W R) for
each literal assigned as unit or right split). Thus, practical implementations incorporate
policies guaranteed to be space bounded, i.e., ones that store a polynomial number of goods
and nogoods at most. In SAT, the three most popular space bounded learning schemes are:
 Size learning of order n (Dechter, 1990): a nogood is added to  if and only if its
cardinality is less or equal to n. Once added, it is never deleted.
 Relevance learning of order n (Ginsberg, 1993): given a current assignment , a
nogood C is always added to , and then it is deleted from  as soon as the number
of literals l in C and with l 6  is bigger than n.
 Unique Implication Point (UIP) based learning (Marques-Silva & Sakallah, 1996): a
nogood C is stored if and only if C contains only one literal at the maximum decision
level. Given an assignment , the decision level of a literal l in  is the number of
splits done before l in . With UIP based learning, the set  of added clauses is
periodically inspected and clauses are deleted according to various criteria.
399

fiGiunchiglia, Narizzano & Tacchella

Thus, in size learning, once a nogood is stored, it is never deleted. In relevance and UIP
based learning, nogoods are dynamically added and deleted depending on the current assignment. See the work of Bayardo (1996) for more details related to size and relevance
learning (including their complexity analysis), and the work of Zhang, Madigan, Moskewicz
and Malik (2001) for a discussion of various UIP based learning mechanisms for SAT. Size,
relevance, UIP based learning are just a few of the various possibilities for limiting the
number of stored clauses, and each one can be generalized in various ways when considering
QBFs instead of SAT formulas. In the next section, we will present the particular learning
schema that we implemented in QuBE.

5. Implementation and Experimental Analysis
In this section we first describe in some details the implementation of nogood and good
learning in QuBE, and then we report on some experimental analysis conducted in order to
evaluate the (separate) benefits of nogood and good learning, but also the relative efficiency
of our solver when compared to other state-of-the-art QBF solvers.
5.1 Implementation in QuBE
To evaluate the benefits deriving from learning, we have implemented both good and nogood learning in QuBE. QuBE is a QBF solver based on search which, on non-random
instances, compares well with respect to other state-of-the-art solvers based on search, like
semprop (Letz, 2002), yquaffle (Zhang & Malik, 2002a), i.e., the best solvers based
on search on non-random instances according to (Le Berre, Simon, & Tacchella, 2003),
see (Giunchiglia, Narizzano, & Tacchella, 2004c) for more details.
Besides learning, the version of QuBE that we used features
 efficient detection of unit and monotone literals using lazy data structures as in (Gent,
Giunchiglia, Narizzano, Rowley, & Tacchella, 2004);
 a branching strategy that exploits information gleaned from the input formula initially,
and leverages the information extracted in the learning phase.
See (Giunchiglia, Narizzano, & Tacchella, 2004b) for a description of these characteristics.
As for learning, the computation of nogoods and goods corresponding to the internal
nodes of the search tree is carried out by doing clause and term resolution between a
working reason which is initialized when backtracking starts, and the reasons stored
while descending the search tree
 for each unit literal, the stored reason is a constraint in which the literal is unit;
 for each literal assigned as right split, the stored reason is the constraint computed
while backtracking on the left branch;
 for monotone literals, the way working reasons are initialized ensures that existential
(resp. universal) monotone literals never belong to a working reason computed while
backtracking from a contradiction (resp. solution).
400

fiClause/Term Resolution and Learning for Quantified Boolean Formulas

Assume that  = l1 ; l2 ; . . . ; lm is the assignment corresponding to the leaf under consideration. Considering the problem of initializing the working reason, the way we do it in
QuBE is to
 return a -contradicted clause in the matrix of the input QBF or in the set of learned
nogoods, if we have a contradiction; and
 compute the minimal form of a -satisfied prime implicant of the matrix which contains as few universal literals as possible, if we have a solution.
In the second case, the computation of a prime implicant is important in order to have short
reasons, while having as few as possible universal literals is important in order to backjump
nodes. The above requirements are met by recursively removing irrelevant literals from the
set of literals in , starting from the universals ones. Given a set S of literals, we say that
a literal is irrelevant in S if for each clause C in the matrix with l  C there exists another
literal l0 in S with l0 V
 C. If prime() is the set of literals being the result of the recursive
procedure, the term prime()
 is satisfied by ;
 is a prime implicant of the matrix of the input QBF;
 is such that there does not exist another term satisfying the first two properties and
with a smaller (under set inclusion) set of universal literals.
In order to further reduce the number of universal literals in the initial goods, we take
advantage of the fact that the assignment  may be partial: For some literal l it may be
the case that neither l nor l is in . Then, we can use the existential literals not in ,
and with level lower than the level of all the universal literals in  assigned as left split, in
order to further reduce the number of universals in prime(). In fact, for any sequence 0
of literals extending  with existential literals, the set of universals in prime(0 ) is a subset
of prime(). For instance, considering the QBF (11) if  = y 1 ; y2 ; x2 ; x3 , then
 prime() is {y 1 , y2 , x2 , x3 }; and
 if we extend  to 0 = ; x1 then prime(0 ) is {x1 , y2 , x2 , x3 }.
Finally, when evaluating which universal literals in  are irrelevant, we follow the reverse
order in which they have been assigned, in order to try to backjump as high as possible in
the search tree.
As we said in the previous section, besides the problem of setting the initial working
reason, another problem with learning is that unconstrained storage of clauses (resp. terms)
obtained by the reasons of conflicts (resp. solutions) may lead to an exponential memory
blow up. In practice, it is necessary to introduce criteria
1. for limiting the constraints that have to be learned; and/or
2. for unlearning some of them.
401

fiGiunchiglia, Narizzano & Tacchella

The implementation of learning in QuBE works as follows. Assume that we are backtracking
on a literal l assigned at decision level n. The constraint corresponding to the reason for
the current conflict (resp. solution) is learned only if the following conditions are satisfied:
1. l is existential (resp. universal); and
2. all the assigned literals in the reason except l, are at a decision level strictly lower
than n; and
3. there are no open universal (resp. existential) literals in the reason that are before l
in the prefix.
Notice that these three conditions ensure that l is unit in the constraint corresponding
to the reason. Once QuBE has learned the constraint, it backjumps to the node at the
maximum decision level among the literals in the reason, excluding l. We say that l is
a Unique Implication Point (UIP) and therefore the lookback in QuBE is UIP based.
Notice that our definition of UIP generalizes to QBF the concepts first described by Silva
and Sakallah (1996) and used in the SAT solver grasp. On a SAT instance, QuBE lookback
scheme behaves similarly to the 1-UIP-learning scheme used in zCHAFF (and described
in Zhang et al., 2001). Even if QuBE is guaranteed to learn at most one clause (resp. term)
per each conflict (resp. solution), still the number of learned constraints may blow up, as
the number of backtracks can be exponential. To stop this course, QuBE scans periodically
the set of learned constraints in search of those that became irrelevant, i.e., clauses (resp.
terms) where the number of open literals exceeds a parameter n, corresponding to the
relevance order. Thus, our implementation uses UIP based learning to decide when to store
a constraint, and a relevance based criteria to decide when to forget a constraint. In the
experimental analysis presented in the next subsection, the parameter n has been set to 20
and the set of learned constraints is scanned every 5000 nodes.
Besides the above learning mechanism, our current version of QuBE features lazy data
structures for unit literal detection and propagation (as described in Gent et al., 2004),
monotone literal fixing (as described in Giunchiglia et al., 2004a), and a Variable State Independent Decaying Sum heuristic (VSIDS) (as introduced in SAT by Moskewicz, Madigan,
Zhao, Zhang, & Malik, 2001). As in SAT, the basic ideas of our heuristic are to (i) initially
rank literals on the basis of the occurrences in the matrix, (ii) increment the weight of the
literals in the learned constraints, and (iii) periodically divide by a constant the weight of
each literal.
5.2 Experimental Results
To evaluate the effectiveness of our implementation, we considered the 450 formal verification and planning benchmarks that constituted part of the 2003 QBF solvers comparative
evaluation4 : 25% of these instances comes from verification problems (described in Scholl
& Becker, 2001; Abdelwaheb & Basin, 2000), and the remaining are from planning domains (described in Rintanen, 1999; Castellini, Giunchiglia, & Tacchella, 2001). We start
our analysis considering QuBE with and without learning enabled. Both versions of QuBE
4. With respect to the non-random instances used in the 2003 QBF comparative evaluation, our test set
does not include the QBF encodings of the modal K formulas submitted by Pan and Vardi (2003).

402

fiClause/Term Resolution and Learning for Quantified Boolean Formulas

Figure 11: Effectiveness of learning: QuBE versus QuBE(cbj,sbj). CPU time (left) and
number of backtracks on the instances solved by both solvers (right).

compute goods and nogoods in order to backjump over irrelevant existential and universal
branching nodes. They differ in the treatment of the computed goods and nogoods:
 when learning is enabled, QuBE records both goods and nogoods;
 when learning is disabled, QuBE records neither nogoods nor goods.
We call the two versions QuBE(cln,sln) and QuBE(cbj,sbj) respectively, in order to
specify the type of look-back used by the two systems. Notice that we did not consider
QuBE with backtracking (i.e., the version which computes neither nogoods nor goods and
performs simple chronological backtracking) because it is not competitive with the other
solvers.
All the experiments were run on a farm of identical PCs, each one equipped with a
Pentium 4, 3.2GHz processor, 1GB of RAM, running Linux Debian (sarge). Finally,
each system had a timeout value of 900s per instance.
Figure 11 left shows the performances of QuBE(cln,sln) versus QuBE(cbj,sbj). In
the plot, the x-axis is the CPU-time of QuBE(cln,sln) and the y-axis is the CPU-time of
QuBE(cbj,sbj). A plotted point hx, yi represents a benchmark on which QuBE(cln,sln)
and QuBE(cbj,sbj) take x and y seconds respectively.5 For convenience, we also plot the
points hx, xi, each representing the benchmarks solved by QuBE(cln,sln) in x seconds.
The first observation is that learning pays off:
5. In principle, one point hx, yi could correspond to many benchmarks solved by QuBE(cln,sln) and
QuBE(cbj,sbj) in x and y seconds respectively. However, in this and in the other scatter diagrams that
we present, each point (except for the point h900, 900i, representing the instances on which both solvers
time-out) corresponds to a single instance in most cases.

403

fiGiunchiglia, Narizzano & Tacchella

Figure 12: Effectiveness of learning with a random heuristic: QuBE(rnd,cln,sln)[3] versus QuBE(rnd,cbj,sbj)[3]. CPU time (left) and number of backtracks on the
instances solved by both solvers (right).

 QuBE(cln,sln) (resp. QuBE(cbj,sbj)) is able to solve 16 (resp. 1) instances that
are not solved by QuBE(cbj,sbj) (resp. QuBE(cln,sln)); and
 among the instances solved by both solvers, QuBE(cln,sln) (resp. QuBE(cbj,sbj))
is at least one order of magnitude faster than QuBE(cbj,sbj) (resp. QuBE(cln,sln))
on 39 (resp. 0) instances.
In order to have an implementation-quality independent measure of the pruning introduced
by learning, the right plot in the figure shows the number of backtracks (i.e., the number
of solutions and conflicts found) of QuBE(cbj,sbj) versus QuBE(cln,sln) on the 358
problems solved by both systems. Here a plotted point hx, yi represents a benchmark
that is solved by QuBE(cln,sln) and QuBE(cbj,sbj) performing x and y backtracks
respectively. As it can be seen, learning substantially prunes the search space: There is no
point below the diagonal, meaning that it is never the case that QuBE(cbj,sbj) performs
less backtracks than QuBE(cln,sln).6 Still, learning has some overhead, and thus the
pruning caused by learning not always pays off in terms of speed, as proved by the few
points below the diagonal in the left plot.
The above experimental data are not entirely satisfactory for two reasons.
First, learning and the heuristic are tightly coupled in QuBE: Whenever QuBE learns a
constraint, it also increments the score of the literals in it. In QuBE(cbj,sbj) no constraint
6. This does not imply that the tree searched by QuBE(cln,sln) is a subtree of the tree searched by
QuBE(cbj,sbj): Indeed, the literal selected at each branching node by the two systems is not guaranteed
to be the same.

404

fiClause/Term Resolution and Learning for Quantified Boolean Formulas

Figure 13: Effectiveness of conflict learning:
QuBE(rnd,cln,sln)[3] versus
QuBE(rnd,cbj,sln)[3]. CPU time (left) and number of conflict backtracks on
the instances solved by both solvers (right).

is ever learned. As a consequence, in QuBE(cbj,sbj), (i) literals are initially sorted on the
basis of their occurrences in the input QBF, and (ii) the score of each literal is periodically
halved until it becomes 0. When all the literals have score 0, then literals at the same prefix
level are chosen according to their lexicographic order.
Second, independently from the heuristic being used, a plot showing the performances of
QuBE with and without learning, does not say which of the two learning schemes (conflict,
solution) is effective (Gent & Rowley, 2004).
To address the first problem, we consider QuBE with a random heuristic, i.e., a heuristic
which randomly selects a literal among those at the maximum level and not yet assigned.
We call the resulting systems QuBE(rnd,cln,sln) and QuBE(rnd,cbj,sbj) respectively:
As the names suggest, the first has learning enabled, while in the second learning has been
disabled. Because of the randomness, we run each solver 5 times on each instance. Then,
we define QuBE(rnd,cln,sln)[i] to be the system whose performances are, on a each
instance, the i-th best among the 5 results obtained by running QuBE(rnd,cln,sln) on
that instance. QuBE(rnd,cbj,sbj)[i] is defined analogously.
Figure 12 shows the CPU time (left) and number of backtracks on the solved instances
(right) of QuBE(rnd,cln,sln)[3] and QuBE(rnd,cbj,sbj)[3]. From the plots, it is easy
to see that QuBE(rnd,cln,sln)[3] is faster than QuBE(rnd,cbj,sbj)[3] in most cases.
To witness this fact
 QuBE(rnd,cln,sln) (resp. QuBE(rnd,cbj,sbj)) is able to solve 21 (resp. 2) instances that are not solved by QuBE(cbj,sbj) (resp. QuBE); and
405

fiGiunchiglia, Narizzano & Tacchella

Figure 14: Effectiveness of solution learning:
QuBE(rnd,cln,sln)[3] versus
QuBE(rnd,cln,sbj)[3]. CPU time (left) and number of solution backtracks on the instances solved by both solvers (right).

 among the instances solved by both solvers, QuBE (resp. QuBE(cbj,sbj)) is at least
one order of magnitude faster than QuBE(cbj,sbj) (resp. QuBE) on 68 (resp. 2)
instances.
Still, it is no longer the case that enabling learning always causes a reduction in the number
of backtracks. This can be because of the different literals selected at each branching node,
but also because pruning a node may prevent a long backjump (Prosser, 1993a) which
would cause a vast reduction of the search space. Interestingly, comparing with the results
in Figure 11, it seems that with a random heuristic learning becomes more important. This
fact witnesses also in our setting the well known tension between look-ahead and look-back
techniques: A smart look-ahead makes the look-back less important, and viceversa.
To address the second problem, we considered the systems QuBE(rnd,cbj,sln) and
QuBE(rnd,cln,sbj), i.e., the systems obtained from QuBE(rnd,cln,sln) by disabling
conflict learning and solution learning respectively. As usual, each system was run 5 times
on each instance, and QuBE(rnd,cbj,sln)[i] and QuBE(rnd,cln,sbj)[i] (1  i  5)
are defined as before. The left plots in Figures 13 and 14 show the performances of
QuBE(rnd,cln,sln)[3] versus QuBE(rnd,cbj,sln)[3] and QuBE(rnd,cln,sbj)[3] respectively. We also measured the number of backtracks. However, in order to better
highlight the pruning due to conflict (resp. solution) learning, the right plot in Figure 13
(resp. 14) shows the number of conflict (resp. solution) backtracks of QuBE(rnd,cbj,sln)[3]
(resp. QuBE(rnd,cln,sbj)[3]). From the plots, we see that both conflict and solution
learning prune the search space and pay off: In each plot, there are only a few points
well below the diagonal. Comparing the two left plots, we also see that, on the test set
406

fiClause/Term Resolution and Learning for Quantified Boolean Formulas

QuBE(rnd,cln,sln)[3]
QuBE(rnd,cln,sln)[1]
QuBE(rnd,cln,sln)[2]
QuBE(rnd,cln,sln)[4]
QuBE(rnd,cln,sln)[5]
QuBE(rnd,cbj,sbj)[1]
QuBE(rnd,cbj,sbj)[2]
QuBE(rnd,cbj,sbj)[3]
QuBE(rnd,cbj,sbj)[4]
QuBE(rnd,cbj,sbj)[5]
QuBE(rnd,cbj,sln)[1]
QuBE(rnd,cbj,sln)[2]
QuBE(rnd,cbj,sln)[3]
QuBE(rnd,cbj,sln)[4]
QuBE(rnd,cbj,sln)[5]
QuBE(rnd,cln,sbj)[1]
QuBE(rnd,cln,sbj)[2]
QuBE(rnd,cln,sbj)[3]
QuBE(rnd,cln,sbj)[4]
QuBE(rnd,cln,sbj)[5]

=
136
169
156
109
131
137
123
110
84
130
133
129
115
86
135
151
169
141
103

<
0
0
203
244
145
164
192
205
222
96
134
169
209
245
78
110
134
183
218

>
225
192
0
0
72
43
25
17
10
128
82
48
20
6
142
90
39
11
2


0
0
2
8
13
17
21
29
45
7
12
15
17
24
6
10
19
26
38


3
1
0
0
7
2
2
2
2
5
5
3
1
1
4
4
1
0
0

./
86
88
89
89
82
87
87
87
87
84
84
86
88
88
85
85
88
89
89

10<
0
0
27
61
27
43
68
83
99
20
27
40
54
87
7
15
29
51
69

0.1>
43
19
0
0
20
7
2
1
1
26
14
5
1
0
36
15
5
0
0

TO
86
88
91
97
95
104
108
116
132
91
96
101
105
112
91
95
107
115
127

Table 2: Comparison among various versions of QuBE. Each row compares a system written in the first column with respect to QuBE(rnd,cln,sln)[3] taken as reference.
If A is QuBE(rnd,cln,sln)[3] and B is a solver in the first column, then the other
columns report the number of problems that: =, A and B solve in the same
time; <, A and B solve but A takes less time than B; >, A and B solve but A
takes more time than B; , A solves while B does not; , A does not solve
while B does; ./, A and B do not solve; 10<, both A and B solve but on
which A is at least one order of magnitude faster; 0.1<, both A and B solve
but on which A is at least one order of magnitude slower; TO, B does not solve.
The number of timeouts for QuBE(rnd,cln,sln)[3] is 89.
that we considered, solution learning helps in solving problems more than conflict learning:
QuBE(rnd,cbj,sln)[3] times out on 101 while QuBE(rnd,cln,sbj)[3] times out on 107.
On the other hand, the two right plots suggest that conflict learning prunes more than solution learning, but this conclusion is not correct. Indeed, each plot shows either the number
of conflicts or the number of solutions: Pruning a node (no matter whether existential or
universal) may avoid finding (exponentially many) solutions and/or conflicts. In particular,
given that all the instances are in CNF and thus have the form
. . . yx1 x2 . . . xn 
(n  1) pruning any variable not in {x1 , x2 , . . . , xn } has the potential to prune 2n conflicts.
407

fiGiunchiglia, Narizzano & Tacchella

Some further and more detailed quantitative information about the CPU times is reported in Table 2. From the last column in the table we see that, if we indicate with TO(S)
the number of timeouts of system S, then, for each i  {1, 2, 3, 4, 5},
TO(QuBE(rnd,cln,sln)[i]) <

TO(QuBE(rnd,cbj,sln)[i])
< TO(QuBE(rnd,cbj,sbj)[i]).
TO(QuBE(rnd,cln,sbj)[i])

The above gives an indication of the capacity of the solvers, i.e., of their ability to solve
problems. In order to get an indication of their productivity, i.e., considering the problems
that they solve, their ability to solve them quickly, we can consider the number FS(S) being
the difference between the 0.1 > and 10 < columns: The lower FS(S) is, the better
S is. Here again we have
FS(QuBE(rnd,cln,sln)[i]) <

FS(QuBE(rnd,cbj,sln)[i])
< FS(QuBE(rnd,cbj,sbj)[i])
FS(QuBE(rnd,cln,sbj)[i])

for i  {1, 2, 3, 4, 5}. From the above, it is clear that both conflict and solution learning
allow to improve on capacity and productivity. Our experimental results thus seem to
contradict the negative results reported in Gents and Rowleys work (2004) for solution
based look-back mechanisms. However, those results are not comparable with ours, given
the different mechanisms implemented by the respective solvers (e.g., for computing the
initial solution and for monotone literal fixing), and the different experimental setting (e.g.,
the testset).

6. Conclusions and Related Work
This paper is based on and extends (Giunchiglia et al., 2002) which introduces nogood and
good learning for QBFs satisfiability. Here we show the correspondence between the computation trees searched by DLL based QBF solvers and clause/term resolution deductions.
Nogoods and goods are the clauses and terms respectively in the resolution deductions.
Under this perspective, learning simply amounts to storing nogoods and goods. We show
how to incorporate nogoods and goods learning in DLL based QBF solvers by considering
EQBFs (QBFs extended with learning), and then illustrate by means of examples that the
computation of nogoods and goods:
 allows for solution and conflict directed backjumping in the spirit of (Giunchiglia et al.,
2001, 2003); and
 if stored, allows for pruning branches in other parts of the search tree.
We present a high level description of algorithms incorporating such ideas, and formally
prove their soundness and completeness. We also discuss the problems related to effective
implementations in DLL based QBF solvers, and present (in some details) our implementation in QuBE, a state-of-the-art QBF solver. The experimental analysis shows that QuBE
enhanced with nogood and good learning is more effective, when considering a selection of
nonrandom problems consisting of planning and formal verification benchmarks. We also
show that QuBE is competitive with respect to the state of the art.
408

fiClause/Term Resolution and Learning for Quantified Boolean Formulas

As we already said, our work builds on (Giunchiglia et al., 2002). Other papers dealing
with learning in QBFs satisfiability are (Letz, 2002), (Zhang & Malik, 2002a) and (Gent &
Rowley, 2004). In particular, in (Letz, 2002) conflict and solution learning are called lemma
and model caching. The paper also proposes a technique based on model caching for dealing with QBFs having variable-independent subformulas. Zhang and Malik (2002a) propose
conflict learning (which is then extended to solution learning in Zhang & Malik, 2002b). In
the second paper, terms are called cubes. Gent and Rowley (2004) introduce a new form
of solution learning: This new technique revisits less solutions than standard techniques,
but the experimental results reported in the paper are not positive. All these works share
the same intuitions and thus propose similar techniques. Though it is difficult to establish
a precise relation among these works due to the differences in the terminology and/or the
different level of detail in the presentations,7 we believe that the main differences are at the
implementation level, i.e., in the way solution and conflict learning have been implemented.
It is therefore quite difficult if not impossible to compare the different alternatives, without
re-implementing or recasting the different learning mechanisms or even the different solvers
in a common framework. Indeed, the specific learning mechanism implemented within a
solver may be motivated by the other characteristics of the solver, e.g., by the data structures being used or by the heuristic. For instance, watched data structures (used, e.g., in
QuBE, yquaffle but not in semprop) allow for more efficient detection and propagation of unit and pure literals (Gent et al., 2004). As a consequence, solvers with watched
data structures may profitably maintain huge databases for goods and nogoods. For solvers
with standard data structures, the costs involved in managing such huge databases may
overwhelm the advantages. Considering each of these solvers as a whole, the experimental
analysis conducted in (Giunchiglia et al., 2004c) shows that our solver QuBE compares
well with respect to semprop and yquaffle on the 450 formal verification and planning
benchmarks that we considered also in this paper.

Acknowledgments
We would like to thank Ian Gent and Andrew Rowley for discussions related to the subject
of this paper, and the anonymous reviewers for their suggestions and corrections. This work
has been partially supported by MIUR.

Appendix A. Proof of Lemma 4
The proof is by well founded induction. Thus, the steps we follow are:
1. the definition of a well founded order on tuples hC1 , C2 , l, i;
2. the proof that the thesis holds for the minimal elements of the partial order; and
3. assuming that the thesis holds for all the tuples hC3 , C2 , l, i such that hC3 , C2 , l, i 
hC1 , C2 , l, i, the proof that the thesis holds also for hC1 , C2 , l, i.
7. For instance, in (Letz, 2002; Zhang & Malik, 2002b) but also in our initial work (Giunchiglia et al.,
2002), the method used for computing the initial working reason corresponding to a solution (procedure
ModelGenerate in Figure 10) is not detailed.

409

fiGiunchiglia, Narizzano & Tacchella

We have deliberately omitted what are the properties that the elements of the tuples
hC1 , C2 , l, i in the partial order have to satisfy. Indeed, the standard assumption would be
that C1 and C2 be two clauses such that hC1 , C2 i is to be ; l-Rec-C-Resolved. However,
this is not sufficient. Indeed, it may happen that starting from two clauses hC1 , C2 i to be
; l-Rec-C-Resolved (line numbers refer to Figure 6)
1. the set {l : l  C1 , l  C2 , l is universal} is not empty (see line 1);
2. the clause C3 computed as in line 5 of Figure 6 is not ; l-contradicted; and thus
3. the tuple hC3 , C2 , l, i is not an element of the partial order.
To better understand the problem, consider the following simple example:
x1 y1 x2 y2 x3 x4 {{x4 }, {x2 , y2 , x4 }, {y 2 , x3 }, {x1 , y 1 , x3 }, {x1 , y1 , x2 , x3 }}.

(13)

For this QBF :
1. x4 ; x2 ; y2 ; x3 ; x1 is an assignment producing a contradictory clause;
2. h{x1 , y1 , x2 , x3 },{x1 , y 1 , x3 }i are to be x4 ; x2 ; y2 ; x3 ; x1 -Rec-C-Resolved;
3. Rec-C-Resolve(, {x1 , y1 , x2 , x3 }, {x1 , y 1 , x3 }, x1 , x4 ; x2 ; y2 ; x3 ; x1 ),
(a) causes a call to Rec-C-Resolve(, {x1 , y1 , y2 , x4 }, {x1 , y 1 , x3 }, x1 , x4 ; x2 ; y2 ; x3 ; x1 ),
in which the clause C3 = {x1 , y1 , y2 , x4 } is not x4 ; x2 ; y2 ; x3 ; x1 -contradicted; but
(b) returns the clause {y 1 , x3 } which is x4 ; x2 ; y2 ; x3 ; x1 -contradicted, as expected.
The fact that the universal literal y2 which causes C3 not to be x4 ; x2 ; y2 ; x3 ; x1 -contradicted
does not appear in the clause returned by Rec-C-Resolve is due to the following two facts:
1. y2 has a lower level than the blocking literal y1 ; and
2. the negation of all the existential literals in C3 with a level lower than y2 are assigned
before y2 in x4 ; x2 ; y2 ; x3 ; x1 .
To formally define these notions, we need some additional notation. First, consider a
given clause C2 . ResC2 (C1 ) is the set of literals in C1 with a level lower than a literal
blocking the resolution between C1 and C2 . Formally:
ResC2 (C1 ) = {l : l  C1 , l0  BlockingC2 (C1 )level(l) < level(l0 )},
where
 for each literal l, level(l) is the prefix level of l; and
 BlockingC2 () is the function defined by
BlockingC2 (C1 ) = {l : l  C1 , l  C2 , l is universal}
Let  be an assignment. We say that a clause C1 is -contradictable (with respect to
C2 ) if
410

fiClause/Term Resolution and Learning for Quantified Boolean Formulas

1. for each existential literal l in C1 , l is in ;
2. for each universal literal l in C1 , if l is in  then
(a) l  ResC2 (C1 ); and
(b) for each existential literal l0 in C1 , if level(l0 ) < level(l) then l0 is to the left of l
in .
Clearly, if a clause is -contradicted then it is also -contradictable. Considering the QBF
(13), the clause {x1 , y1 , y2 , x4 } is not x4 ; x2 ; y2 ; x3 ; x1 -contradicted; but is x4 ; x2 ; y2 ; x3 ; x1 contradictable (with respect to {x1 , y 1 , x3 }).
Our well founded order and induction will be on the set of tuples hC1 , C2 , l, i in which
C1 is ; l-contradictable. As a preliminary step, we first define the well founded order on
literals according to which l0  l00 if and only if either l0 = l00 or both l0 and l00 are in  and
l0 has been assigned before l00 in  (i.e., l0 is to the left of l00 in ).
We extend the partial order relation  from literals to clauses (i) in minimal form, (ii)
containing l, and (iii) ; l-contradictable, by saying that for two such clauses C1 and C3 ,
C3  C1 if
 either C3 = C1 ;
E
E
E
E
00
0
00
 or l0  (ResE
C2 (C1 )\ResC2 (C3 ))l  (ResC2 (C3 )\ResC2 (C1 ))l  l , where ResC2 (C1 )
is the subset of existential literals in ResC2 (C1 ), and similarly for ResE
C2 (C3 ).

The above order is well founded, and the minimal elements are such that ResC2 (C) (or,
equivalently, BlockingC2 (C)) is empty.
Finally, consider the set W of tuples hC1 , C2 , l, i such that
1. ; l is an assignment;
2. l is an existential literal which is either unit or at the highest level in  ;
3. C1 is a clause containing l, in minimal form and ; l-contradictable with respect to
C2 ;
4. C2 contains l, is in minimal form and is ; l-contradicted. Further, if l is unit in  ,
then C2 is a clause which causes l to be unit in  .
On such set, we define a well founded order according to which hC3 , C2 , l, i  hC1 , C2 , l, i
if C3  C1 .
Now consider the procedure Rec-C-Resolve in Figure 6. We prove by well founded
induction that, for each tuple hC1 , C2 , l, i  W , Rec-C-Resolve(, C1 , C2 , l, ) terminates
and returns a clause C in minimal form and -contradicted. At the end, we will also show
that if we further assume that C1 is ; l-contradicted (and not simply ; l-contradictable),
then C does not contain existential literals whose negation has been assigned as monotone
in .
In the base case, C1 is such that ResC2 (C1 ) is empty. Hence, for each universal literal
l  C1 , l is not in  and thus C1 is ; l-contradicted. Since ResC2 (C1 ) is empty, the set S
computed at line 1 is empty and thus Rec-C-Resolve(, C1 , C2 , l, ) terminates returning
411

fiGiunchiglia, Narizzano & Tacchella

the resolvent C of C1 and C2 . Clearly C is in minimal form, and it is easy to show that C
is -contradicted.
For the step case, by induction hypothesis, we have that the thesis holds for Rec-CResolve(, C3 , C2 , l, ) and we have to show that it holds also for Rec-C-Resolve(, C1 , C2 , l, ),
assuming hC3 , C2 , l, i  hC1 , C2 , l, i. If the set ResC2 (C1 ) is empty, then see the base case.
Assume that ResC2 (C1 ) is not empty, and thus that also BlockingC2 (C1 ) is not empty.
From here on, let l0 be a literal in BlockingC2 (C1 ) with the highest level. l0 is not in 
because l0 6 ResC2 (C1 ) and C1 is ; l-contradictable. l0 is not in  because l0  C2 and C2
is ; l-contradicted. Further, level(l0 ) < level(l). To see why, consider the only two possible
cases:
1. l is unit in  : Since l0  C2 , and C2 is a clause which causes l to be unit in  , it
must be level(l0 ) = level(l0 ) < level(l).
2. l is at the highest level in  : Since both l0 and l0 are not in  and l is at the highest
level in  , level(l0 )  level(l). On the other hand, level(l0 ) 6= level(l) because l0 is
universal and l is existential.
Since C1 is in minimal form, there exists an existential literal l00 such that l00  C1 , l00 is
in , and with level(l00 ) < level(l0 ) < level(l). From here on, let l1 be an existential literal
in C1 (not necessarily distinct from l00 ) with level less than or equal to the level of all the
literals in C1 (see line 3). Since
level(l1 ) < level(l0 ) < level(l)

(14)

and l1 is in  (because C1 is ; l-contradictable), it follows that l1 has been assigned as unit,
and thus there exists a clause C in  which causes l1 to be unit in 0 , where 0 ; l1 is an
initial prefix of  (see line 4).
Consider the set
BlockingC (C1 ) = {l : l  C1 , l  C, l is universal}.
BlockingC (C1 ) is empty. In fact, for each universal literal l00  C
 if level(l00 ) < level(l1 ) then l00 6 C1 since C1 is in minimal form;
 if level(l00 ) > level(l1 ) then l00  l1 . Assume that l00  C1 . Since C1 is ; l-contradictable,
l1  l00 . However, l00  l1 and l1  l00 is not possible because l1 6= l00 (l1 is existential
and l00 is universal).
Since BlockingC (C1 ) is empty, we can resolve C and C1 on l1 , obtaining
C3 = min((C1  C) \ {l1 , l1 })
as resolvent. C3 is in minimal form and it contains l.
To show that C3  C1 it remains to be showed that C3 is ; l-contradictable. Indeed,
for each existential literal l in C3 , l is in , while for the universal literals in C3 , consider
the two cases:
412

fiClause/Term Resolution and Learning for Quantified Boolean Formulas

1. BlockingC2 (C3 ) is not empty. In this case, l0  BlockingC2 (C3 ). This is an easy
consequence of the following facts:
(a) for each literal l00  BlockingC2 (C), level(l00 ) < level(l0 ): l00  C2 by definition of
BlockingC2 (C), hence l00 is not in  because C2 is ; l-contradicted, and therefore
level(l00 ) < level(l1 ), and thus the thesis (see (14));
(b) BlockingC2 (C3 ) = (BlockingC2 (C1 )BlockingC2 (C))C3 and thus (BlockingC2 (C1 )
BlockingC2 (C)) \ BlockingC2 (C3 ) = (C  C1 ) \ ({l1 , l1 }  C3 ), i.e., the literals in
BlockingC2 (C1 )  BlockingC2 (C) and not in BlockingC2 (C3 ) are those that have
been omitted because of the minimal form of C3 ;
(c) BlockingC2 (C3 ) is not empty.
Since l0  BlockingC2 (C3 ), the literals in ResC2 (C1 ) which are also in C3 , also belong
to ResC2 (C3 ), i.e.,
ResC2 (C3 )  ResC2 (C1 )  C3 .
(15)
Now consider a universal literal l00  C1  C3 . If l00 is in  then
(a) l00  ResC2 (C1 ) because C1 is ; l-contradictable, and hence l00  ResC2 (C3 )
(see (15));
(b) for each existential literal l000 in C1 , if level(l000 ) < level(l00 ) then l000  l00 because
C1 is ; l-contradictable;
(c) for each existential literal l000 6= l1 in C, l000  l00 . In fact, level(l1 ) < level(l00 ),
l1  l00 because C1 is ; l-contradictable, and for each existential literal l000 6= l1 
C, l000  l1 .
Finally, consider a universal literal l00  C  C3 . If l00 is in  then level(l00 ) < level(l1 )
and hence
(a) l00  ResC2 (C3 ) because level(l1 ) < level(l0 ) (see (14)); and
(b) for each existential literal l000  C3 , if level(l000 ) < level(l00 ) then l000  C and hence
l000  l00 .
2. BlockingC2 (C3 ) is empty. Let m be the lowest among the level of the literals in C3 .
level(l0 ) < m since l0 6 C3 . Then, for each universal literal l00  C3 , l00 is not in , i.e.,
C3 is ; l-contradicted. In fact, assume that there exists a universal literal l00  C3 in
. Then, level(l00 ) > m and either l00  C1 or l00  C. Consider the first case l00  C1 .
Then, l00  ResC2 (C1 ) because C1 is ; l-contradictable, and then level(l00 ) < level(l0 ).
But this is not possible because level(l00 ) > m and level(l0 ) < m. Consider the case
l00  C. Then, level(l00 ) < level(l1 ) and hence level(l00 ) < level(l0 ) (see (14)) which is
again not possible.
Since C3  C1 , hC3 , C2 , l, i  hC1 , C2 , l, i, we can conclude by induction hypothesis that
Rec-C-Resolve(, C3 , C2 , l, ) returns a clause in minimal form and -contradicted.
413

fiGiunchiglia, Narizzano & Tacchella

Now we make the further assumption that the input clause C1 is ; l-contradicted.
Then, C1 does not contain existential literals whose negation has been assigned as monotone, and the same holds for C2 and for each clause C used at line 5. Hence, Rec-CResolve(, C3 , C2 , l, ) returns a clause without existential literals whose negation has been
assigned as monotone in .

References
Abdelwaheb, A., & Basin, D. (2000). Bounded model construction for monadic second-order
logics. In 12th International Conference on Computer-Aided Verification (CAV00),
No. 1855 in Lecture Notes in Computer Science, pp. 99113, Chicago, USA. SpringerVerlag.
Bachmair, L., & Ganzinger, H. (2001). Resolution theorem proving. In Robinson, A., &
Voronkov, A. (Eds.), Handbook of Automated Reasoning, Vol. I, chap. 2, pp. 1999.
Elsevier Science.
Bayardo, Jr., R. J., & Schrag, R. C. (1997). Using CSP look-back techniques to solve
real-world SAT instances. In Proceedings of the 14th National Conference on Artificial Intelligence and 9th Innovative Applications of Artificial Intelligence Conference
(AAAI-97/IAAI-97), pp. 203208, Menlo Park. AAAI Press.
Bayardo, Jr., Roberto J., & Miranker, D. P. (1996). A complexity analysis of space-bounded
learning algorithms for the constraint satisfaction problem. In Proceedings of the
Thirteenth National Conference on Artificial Intelligence and the Eighth Innovative
Applications of Artificial Intelligence Conference, pp. 298304, Menlo Park. AAAI
Press / MIT Press.
Cadoli, M., Schaerf, M., Giovanardi, A., & Giovanardi, M. (2002). An algorithm to evaluate
quantified Boolean formulae and its experimental evaluation. Journal of Automated
Reasoning, 28, 101142.
Cadoli, M., Giovanardi, A., & Schaerf, M. (1998). An algorithm to evaluate Quantified
Boolean Formulae. In Proceedings of the 15th National Conference on Artificial Intelligence (AAAI-98) and of the 10th Conference on Innovative Applications of Artificial
Intelligence (IAAI-98), pp. 262267, Menlo Park. AAAI Press.
Castellini, C., Giunchiglia, E., & Tacchella, A. (2001). Improvements to SAT-based conformant planning. In Proc. ECP.
Castellini, C., Giunchiglia, E., & Tacchella, A. (2003). SAT-based planning in complex
domains: Concurrency, constraints and nondeterminism. Artificial Intelligence, 147 (12), 85117.
Davis, M., Logemann, G., & Loveland, D. W. (1962). A machine program for theorem
proving. Communication of ACM, 5 (7), 394397.
de la Tour, T. B. (1990). Minimizing the Number of Clauses by Renaming. In Proc. of the
10th Conference on Automated Deduction, pp. 558572. Springer-Verlag.
Dechter, R. (1990). Enhancement schemes for constraint processing: Backjumping, learning,
and cutset decomposition. Artificial Intelligence, 41 (3), 273312.
414

fiClause/Term Resolution and Learning for Quantified Boolean Formulas

Fermuller, C. G., Leitsch, A., Hustadt, U., & Tammet, T. (2001). Resolution decision procedures. In Robinson, A., & Voronkov, A. (Eds.), Handbook of Automated Reasoning,
Vol. II, chap. 25, pp. 17911849. Elsevier Science B.V.
Gent, I., Giunchiglia, E., Narizzano, M., Rowley, A., & Tacchella, A. (2004). Watched data
structures for QBF solvers. In Giunchiglia, E., & Tacchella, A. (Eds.), Theory and
Applications of Satisfiability Testing, 6th International Conference, SAT 2003. Santa
Margherita Ligure, Italy, May 5-8, 2003 Selected Revised Papers, Vol. 2919 of Lecture
Notes in Computer Science, pp. 2536. Springer.
Gent, I. P., & Rowley, A. G. (2004). Solution learning and solution directed backjumping revisited. Tech. rep. APES-80-2004, APES Research Group. Available from
http://www.dcs.st-and.ac.uk/apes/apesreports.html.
Ginsberg, M. L. (1993). Dynamic backtracking. Journal of Artificial Intelligence Research,
1, 2546.
Giunchiglia, E., Narizzano, M., & Tacchella, A. (2001). Backjumping for quantified Boolean
logic satisfiability. In Proc. of the International Joint Conference on Artificial Intelligence (IJCAI2001).
Giunchiglia, E., Narizzano, M., & Tacchella, A. (2002). Learning for Quantified Boolean
Logic Satisfiability. In Proceedings of the Eighteenth National Conference on Artificial
Intelligence and Fourteenth Conference on Innovative Applications of Artificial Intelligence, July 28 - August 1, 2002, Edmonton, Alberta, Canada. AAAI Press, 2002,
pp. 649654.
Giunchiglia, E., Narizzano, M., & Tacchella, A. (2003). Backjumping for Quantified Boolean
Logic Satisfiability. Artificial Intelligence, 145, 99120.
Giunchiglia, E., Narizzano, M., & Tacchella, A. (2004a). Monotone literals and learning
in QBF reasoning. In Tenth International Conference on Principles and Practice of
Constraint Programming, CP 2004, pp. 260273.
Giunchiglia, E., Narizzano, M., & Tacchella, A. (2004b). Qbf reasoning on real-world instances. In Theory and Applications of Satisfiability Testing, 7th International Conference, SAT 2004, Vancouver, BC, Canada, May 10-13, 2004, Revised Selected Papers,
pp. 105121.
Giunchiglia, E., Narizzano, M., & Tacchella, A. (2004c). Qube++: An efficient qbf solver. In
5th International Conference on Formal Methods in Computer-Aided Design, FMCAD
2004, pp. 201213.
Kleine-Buning, H., Karpinski, M., & Flogel, A. (1995). Resolution for quantified Boolean
formulas. Information and Computation, 117 (1), 1218.
Le Berre, D., Simon, L., & Tacchella, A. (2003). Challenges in the QBF arena: the SAT03
evaluation of QBF solvers. In Sixth International Conference on Theory and Applications of Satisfiability Testing (SAT 2003), Vol. 2919 of LNCS. Springer Verlag.
Letz, R. (2002). Lemma and model caching in decision procedures for quantified Boolean
formulas. In Proceedings of Tableaux 2002, LNAI 2381, pp. 160175. Springer.
415

fiGiunchiglia, Narizzano & Tacchella

Marques-Silva, J. P., & Sakallah, K. A. (1996). GRASP - A New Search Algorithm for
Satisfiability. In Proceedings of IEEE/ACM International Conference on ComputerAided Design, pp. 220227.
Moskewicz, M. W., Madigan, C. F., Zhao, Y., Zhang, L., & Malik, S. (2001). Chaff: Engineering an Efficient SAT Solver. In Proceedings of the 38th Design Automation
Conference (DAC01), pp. 530535.
Pan, G., & Vardi, M. Y. (2003). Optimizing a BDD-based modal solver. In Automated
Deduction - CADE-19, 19th International Conference on Automated Deduction Miami
Beach, FL, USA, July 28 - August 2, 2003, Proceedings, pp. 7589.
Plaisted, D., & Greenbaum, S. (1986). A Structure-preserving Clause Form Translation.
Journal of Symbolic Computation, 2, 293304.
Prosser, P. (1993a). Domain filtering can degrade intelligent backjumping search. In Proceedings of the 13th International Joint Conference on Artificial Intelligence (IJCAI99-Vol2), pp. 262267.
Prosser, P. (1993b). Hybrid algorithms for the constraint satisfaction problem. Computational Intelligence, 9 (3), 268299.
Rintanen, J. (1999). Constructing conditional plans by a theorem prover. Journal of Artificial Intelligence Research, 10, 323352.
Robinson, A. (1965). A machine-oriented logic based on the resolution principle. Journal
of the ACM, 12 (1), 2341.
Robinson, A. (1968). The generalized resolution principle. In Machine Intelligence, Vol. 3,
pp. 7793. Oliver and Boyd, Edinburgh.
Scholl, C., & Becker, B. (2001). Checking equivalence for partial implementations. In
Proceedings of the 38th Design Automation Conference (DAC01), pp. 238243.
Tseitin, G. (1970). On the complexity of proofs in propositional logics. Seminars in Mathematics, 8.
Urquhart, A. (1995). The complexity of propositional proofs. The Bulletin of Symbolic
Logic, 1 (4), 425467.
Zhang, L., Madigan, C. F., Moskewicz, M. W., & Malik, S. (2001). Efficient conflict driven
learning in a Boolean satisfiability solver. In International Conference on ComputerAided Design (ICCAD01), pp. 279285.
Zhang, L., & Malik, S. (2002a). Conflict driven learning in a quantified Boolean satisfiability solver. In Proceedings of International Conference on Computer Aided Design
(ICCAD02).
Zhang, L., & Malik, S. (2002b). Towards a symmetric treatment of satisfaction and conflicts
in quantified Boolean formula evaluation. In Proceedings of the Eighth International
Conference on Principles and Practice of Constraint Programming, pp. 200215.

416

fi