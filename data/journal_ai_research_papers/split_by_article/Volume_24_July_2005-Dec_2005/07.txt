Journal of Artificial Intelligence Research 24 (2005) 919-931

Submitted 01/05; published 12/05

Engineering Note
Optiplan: Unifying IP-based and Graph-based Planning
Menkes H.L. van den Briel

menkes@asu.edu

Department of Industrial Engineering
Arizona State University, Tempe, AZ 85281 USA

Subbarao Kambhampati

rao@asu.edu

Department of Computer Science and Engineering
Arizona State University, Tempe, AZ 85281 USA

Abstract
The Optiplan planning system is the first integer programming-based planner that
successfully participated in the international planning competition. This engineering note
describes the architecture of Optiplan and provides the integer programming formulation
that enabled it to perform reasonably well in the competition. We also touch upon some
recent developments that make integer programming encodings significantly more competitive.

1. Introduction
Optiplan is a planning system that uses integer linear programming (IP) to solve STRIPS
planning problems. It is the first such system to take part in the international planning
competition (IPC) and was judged the second best performer in four competition domains
of the optimal track for propositional domains. Optiplans underlying integer programming
formulation extends the state change model by Vossen and his colleagues (1999). Its architecture is very similar to that of Blackbox (Kautz & Selman, 1999) and GP-CSP (Do &
Kambhampati, 2001), but instead of unifying satisfiability (SAT) or constraint satisfaction
(CSP) with graph based planning, Optiplan uses integer programming. Like Blackbox and
GP-CSP, Optiplan works in two phases. In the first phase a planning graph is built and
transformed into an IP formulation, then in the second phase the IP formulation is solved
using the commercial solver ILOG CPLEX (ILOG Inc., 2002).
A practical difference between the original state change model and Optiplan is that the
former takes as input all ground actions and fluents over all initialized plan steps, while
the latter takes as input just those actions and fluents that are instantiated by Graphplan
(Blum & Furst, 1995). It is well known that the use of planning graphs has a significant
effect on the size of the final encoding no matter what combinatorial transformation method
(IP, SAT, or CSP) is used. For instance, Kautz and Selman (1999) as well as Kambhampati
(1997) pointed out that Blackboxs success over Satplan (Kautz & Selman, 1992) was mainly
explained by Graphplans ability to produce better, more refined, propositional structures
than Satplan. In addition, Optiplan allows propositions to be deleted without being required
as preconditions. Such state changes are not modeled in the original state change model, and
therefore Optiplan can be considered to be a more general encoding. One more, although
c
2005
AI Access Foundation. All rights reserved.

fiVan den Briel, & Kambhampati

minor, implementation detail between Optiplan and the state change model is that Optiplan
reads in PDDL files.
This engineering note is organized as follows. Section 2 provides a brief background on
integer programming and Section 3 discusses previous IP approaches to planning. Section
4 describes the Optiplan planning system and its underlying IP formulation. In Section 5
we give some experimental results and look at Optiplans performance in the international
planning competition of 2004 (IPC4). Conclusions and a brief discussion on some recent
developments is given in Section 6.

2. Background
A linear program is represented by a linear objective function and a set of inequalities, such
as min{cx : Ax  b, x  0} where x an n-dimensional column vector of variables, A is an
m by n matrix, c an n-dimensional row vector, and b an m-dimensional column vector. If
all variables are constrained to be integers then we have an integer (linear) program, and if
all variables are restricted to 0-1 values then we have a binary integer program.
The most widely used method for solving general integer programs is by using branch
and bound on the linear programming relaxation. Branch and bound is a general search
method in which subproblems are created that restrict the range of the integer variables,
and the linear programming relaxation is a linear program obtained from the original integer
program by omitting the integrality constraints. An ideal formulation of an integer program
is one for which the solution of the linear programming relaxation is integral. Even though
every integer program has an ideal formulation (Wolsey, 1998), in practice it is very hard to
characterize the ideal formulation as it may require an exponential number of inequalities.
In problems where the ideal formulation cannot be determined, it is often desirable to find
a strong formulation of the integer program. Suppose that P1 = min{cx : A1 x  b1 , x  0}
and P2 = min{cx : A2 x  b2 , x  0} are the linear programming relaxations of two IP
formulations of a problem, then we say that formulation P1 is stronger than formulation P2
if P1  P2 . That is, the set of solutions of P1 is subsumed by the set of solutions of P2 .

3. Integer Programming Approaches to Planning
Despite the vast amount of research that has been conducted in the field of AI planning, the
use of linear programming (LP) and integer linear programming have only been explored at
a marginal level. This is quite surprising since (mixed) integer linear programming provide
feasible environments for using numeric constraints and arbitrary linear objective functions,
two important aspects in real-world planning problems.
Only a handful of works have explored the use of LP and IP techniques in AI planning.
Bylander (1997) developed an IP formulation for classical planning and used the LP relaxation as a heuristic for partial order planning. The results, however, do not seem to scale
well compared to planning graph and satisfiability based planners.
The difficulty in developing strong IP formulations is that the performance often depends on the way the IP formulation is constructed. Vossen et al. (1999) compared two
formulations for classical planning. First, they consider a straightforward IP formulation
based on converting the propositional representation given by Satplan (Kautz & Selman,
920

fiOptiplan: Unifying IP-based and Graph-based Planning

1992) to an IP formulation with variables that take the value 1 if a certain proposition
is true, and 0 otherwise. In this formulation, the assertions expressed by IP constraints
directly correspond to the logical conditions of the propositional representation. Second,
they consider an IP formulation in which the original propositional variables are replaced
by state change variables. State change variables take the value 1 if a certain proposition is
added, deleted, or persisted, and 0 otherwise. Vossen et al. show that the formulation based
on state change variables outperforms the straightforward formulation based on converting
the propositional representation.
Dimopoulos (2001) improves the IP formulation based on state change variables by identifying valid inequalities that tighten the formulation. Yet, even stronger IP formulations
are given by Bockmayr and Dimopoulos (1998, 1999), but their IP formulations contain
domain dependent knowledge and are, therefore, limited to solving problems of specific
problem domains only.
LP and IP techniques have also been explored for non-classical planning. Dimopoulos
and Gerevini (2002) describe a mixed integer programming formulation for temporal planning and Wolfman and Weld (1999) use an LP formulation in combination with a SAT
formulation to solve resource planning problems. Kautz and Walser (1999) also use IP
formulations for resource planning problems but, in addition, incorporate action costs and
complex objectives.
So far, none of these IP approaches to AI planning ever participated in the IPC, making
it harder to assess the relative effectiveness of this line of work. Optiplan, a planner based
on the state change formulation, is the first IP-based planner to do so.

4. Optiplan
Optiplan is a planning graph based planner and works as follows. First we build the
planning graph to the level where all the goal fluents appear non-mutex. Then we compile
the planning graph into an integer program and solve it. If no plan is found, the planning
graph is extended by one level and the new graph is again compiled into an integer program
and solved again. This process is repeated until a plan is found.
In the remainder of this section we give the IP formulation that is used by Optiplan. In
order to present the IP formulation we will use the following notation. F is the set of fluents
and A is the set of actions (operators). The fluents that are true in the initial state and
the fluents that must be true in the goal are given by I and G respectively. Furthermore,
we will use the sets:
 pref  A, f  F, set of actions that have fluent f as precondition;
 addf  A, f  F, set of actions that have fluent f as add effect;
 delf  A, f  F, set of actions that have fluent f as delete effect;
Variables are defined for each layer 1  t  T in the planning graph. There are
variables for the actions and there are variables for the possible state changes a fluent can
make, but only those variables that are reachable and relevant by planning graph analysis
are instantiated. For all a  A, t  1, ..., T we have the action variables
921

fiVan den Briel, & Kambhampati

ya,t =



1 if action a is executed in period t,
0 otherwise.

The no-op actions are not included in the ya,t variables but are represented separately
by the state change variable xmaintain
.
f,t
Optiplan is based on the state change formulation (Vossen et al., 1999). In this formulation fluents are not represented explicitly, instead state change variables are used to model
transitions in the world state. That is, a fluent is true if and only if it is added to the state by
preadd
xadd
, or if it is persisted from the previous state by xmaintain
. Optiplan extends
f,t or xf,t
f,t
the state change formulation (Vossen et al., 1999) by introducing an extra state change
variable, xdel
f,t , that allows actions to delete fluents without requiring them as preconditions.
The original state change formulation did not allow for these actions, so therefore we added
these new state change variables to keep track of such state changes and altered the model
to take these new variables into account. In the IPC4 domains of Airport and PSR there are
many actions that delete fluents without requiring them as preconditions, therefore making
the original state change formulation ineffective. Also, Optiplan instantiates only those
variables and constraints that are reachable and relevant through planning graph analysis,
and therefore creates a smaller encoding than the original one. For all f  F, t  1, ..., T
we have the following state change variables:

1 if fluent f is propagated in period t,
maintain
=
xf,t
0 otherwise.

1 if action a is executed in period t such that a  pref  a 
/ delf ,
preadd
xf,t
=
0 otherwise.

1 if action a is executed in period t such that a  pref  a  delf ,
predel
xf,t
=
0 otherwise.

1 if action a is executed in period t such that a 
/ pref  a  addf ,
=
xadd
f,t
0 otherwise.

1 if action a is executed in period tsuch that a 
/ pref  a  delf ,
xdel
=
f,t
0 otherwise.
In summary: xmaintain
= 1 if the truth value of a fluent is propagated; xpreadd
= 1 if an
f,t
f,t
action is executed that requires a fluent and does not delete it; xpredel
= 1 if an action is
f,t
add
executed that requires a fluent and deletes it; xf,t = 1 if an action is executed that does
not require a fluent and adds it; and xdel
f,t = 1 if an action is executed that does not require
a fluent and deletes it. The complete IP formulation of Optiplan is given by the following
objective function and constraints.

4.1 Objective
For classical AI planning problems, no minimization or maximization is required, instead
we want to find a feasible solution. The search for a solution, however, may be guided by
922

fiOptiplan: Unifying IP-based and Graph-based Planning

an objective function such as the minimization of the number of actions, which is currently
implemented in Optiplan. The objective function is given by:
min

XX

ya,t

(1)

aA iT

Since the constraints guarantee feasibility we could have used any linear objective function. For example, we could easily set up an objective to deal with cost-sensitive plans
(in the context of non-uniform action cost), utility-sensitive plans (in the context of oversubscription and goal utilities), or any other metric that can be transformed to a linear
expression. Indeed this flexibility to handle any linear objective function is one of the advantages of IP formulations.

4.2 Constraints
The requirements on the initial and goal transition are given by:
xadd
f,0 = 1
maintain preadd
xadd
, xf,0
f,0 , xf,0
maintain
xadd
+ xpreadd
f,T + xf,T
f,T

f  I

(2)

=0

f 
/I

(3)

1

f  G

(4)

Where constraints (2), and (3) add the initial fluents in step 0 so that they can be used
by the actions that appear in the first layer (step 1) of the planning graph. Constraints
(4) represent the goal state requirements, that is, fluents that appear in the goal must be
added or propagated in step T .
The state change variables are linked to the actions by the following effect implication
constraints. For each f  F and 1  t  T we have:
X
ya,t  xadd
(5)
f,t
aaddf \pref

ya,t  xadd
f,t
X

ya,t 

a  addf \ pref

xdel
f,t

(6)
(7)

adelf \pref

ya,t  xdel
f,t
X

a  delf \ pref

ya,t  xpreadd
f,t

(8)
(9)

apref \delf

ya,t  xpreadd
f,t
X

ya,t = xpredel
f,t

a  pref \ delf

(10)
(11)

apref delf

Where constraints (5) to (11) represent the logical relations between the action and
state change variables. The equality sign in (11) is because all actions that have f as a
923

fiVan den Briel, & Kambhampati

precondition and as a delete effect are mutually exclusive. This also means that we can
substitute out the xpredel
variables, which is what we have done in the implementation of
f,t
Optiplan. We will, however, use the variables here for clarity. Mutexes also appear between
different state change variables and these are expressed by constraints as follows:

predel
maintain
1
+ xdel
xadd
f,t + xf,t
f,t + xf,t

(12)

predel
xpreadd
+ xmaintain
+ xdel
1
f,t
f,t + xf,t
f,t

(13)

Where constraints (12) and (13) restrict certain state changes from occurring in parallel.
del
For example, xmaintain
(propagating fluent f at step t) is mutually exclusive with xadd
f,t
f,t , xf,t ,
and xpredel
(adding or deleting f at t).
f,t
Finally, the backward chaining requirements and binary constraints are represented by:

add
maintain
xpreadd
+ xmaintain
+ xpredel
 xpreadd
f,t
f,t
f,t
f,t1 + xf,t1 + xf,t1

f  F, t  1, ..., T

(14)

del maintain
xpreadd
, xpredel
, xadd
{0, 1}
f,t , xf,t , xf,t
f,t
f,t

(15)

ya,t {0, 1}

(16)

Where constraints (14) describe the backward chaining requirements, that is, if a fluent
f is added or maintained in step t1 then the state of f can be changed by an action in step
t through xpreadd
, or xpredel
, or it can be propagated through xmaintain
. Constraints (15)
f,t
f,t
f,t
and (16) are the binary constraints for the state change and action variables respectively.

Loc1

Truck1

Loc2

Truck2

Figure 1: A simple logistics example

4.3 Example
In this example, we show how some of the constraints are initialized and we comment on
the interaction between the state change variables and the action variables.
Consider a simple logistics example in which there are two locations, two trucks, and
one package. The package can only be transported from one location to another by one of
the trucks. We built a formulation for three plan steps. The initial state is that the package
924

fiOptiplan: Unifying IP-based and Graph-based Planning

and the trucks are all at location 1 as given in Figure 1. The initial state constraints are:
xadd
pack1

at loc1,0

xadd
truck1

at loc1,0
add
xtruck2 at loc1,0
add maintain preadd
xf,0 , xf,0
, xf,0

=1
=1
=1
=0

f 6= I

The goal is to get the package at location 2 in three plan steps, which is expressed as
follows:
xadd
pack1

at loc2,3

+ xmaintain
pack1 at

loc2,3

+ xpreadd
pack1 at

loc2,3

1

We will not write out all effect implication constraints, but we will comment on a few
of them. If xadd
f,t = 1 for a certain fluent f , then we have to execute at least one action a
that has f as an add effect and not as a precondition. For example:
yunload

truck1 at loc2,t

+ yunload

truck2 at loc2,t

 xadd
pack1

at loc2,t

preadd
The state changes for xdel
have a similar requirement, that is if we change
f,t and xf,t
the state through del or preadd then we must execute at least one action a with the corresponding effects. On the other hand, if we execute an action a then we must change all
fluent states according to the effects of a. For example:

yunload

truck1 at loc2,t

 xadd
pack1

yunload

truck1 at loc2,t



yunload

truck1 at loc2,t

=

at loc2,t
preadd
xtruck at loc2,t
xpredel
pack1 in truck1,t

There is a one-to-one correspondence (note the equality sign) between the execution of
actions and the xpredel
state change variables. This is because, actions that have the same
f,t
predel effect must be mutex. Mutexes are also present between state changes. For example,
a fluent f that is maintained (propagated) cannot be added or deleted. The only two state
changes that are not mutex are the add and the preadd. This is because the add state
change behaves like the preadd state change if the corresponding fluent is already present
in the state of the world. This is why we introduce two separate mutex constraints, one
that includes the add state change and one that includes the preadd. An example for the
constraints on the mutex state changes are as follows:
xadd
pack1

in truck1,t

xpreadd
pack1 in

truck1,t

+ xmaintain
pack1 in

truck1,t

+ xdel
pack1

in truck1,t

+ xpredel
pack1

in truck1,t

 1

+ xmaintain
pack1 in

truck1,t

+ xdel
pack1

in truck1,t

+ xpredel
pack1

in truck1,t

 1

The state of a fluent can change into another state only if correct state changes have
occurred previously. Hence, a fluent can be deleted, propagated, or used as preconditions
in step t if and only if it was added or propagated in step t  1. For example:
xpreadd
pack1 in

predel
maintain
truck1,t + xpack1 in truck1,t + xpack1 in truck1,t
add
maintain
xpreadd
pack1 in truck1,t1 + xpack1 in truck1,t1 + xpack1 in truck1,t1

925



fiVan den Briel, & Kambhampati

t=0
xadd
pack1
xadd
truck1
xadd
truck2

at loc1,0

t=1
yload truck1 at loc1,1
xadd
pack1 in truck1,1
xpredel
pack1 at loc1,1
xpreadd
truck1 at loc1,1

at loc1,0

xmaintain
truck2 at

at loc1,0

t=2
ydrive truck1 loc1 loc2,2
xmaintain
pack1 in truck1,2
xadd
truck1
xpredel
truck1

at loc2,2

t=3
yunload truck1 at loc2,3
xadd
pack1 at loc2,3
xpredel
pack1 in truck1,3
xpreadd
truck1 at loc2,3

at loc1,2

loc1,1

Table 1: Solution to the simple logistics example. All displayed variables have value 1 and
all other variables have value 0.

This simple problem has a total of 107 variables (41 action and 66 state change) and
91 constraints. However, planning graph analysis fixes 53 variables (28 action and 25 state
change) to zero. After substituting these values and applying presolve techniques that are
built in the ILOG CPLEX solver, this problem has only 13 variables and 17 constraints.
The solution for this example is given in Table 1. Note that, when there are no actions
that actively delete f , there is nothing that ensures xmaintain
to be true whenever f was
f,t
true in the preceding state (for example, see the fluent truck2 at loc1). Since negative
preconditions are not allowed, having the option of letting xmaintain
be false when it should
f,t
have been true cannot cause actions to become executable when they should not be. We
will not miss any solutions because constraints (4) ensure that the goal fluents are satisfied,
therefore forcing xmaintain
to be true whenever this helps us generate a plan.
f,t

5. Experimental Results
First we compare Optiplan with the original state change model, and then we check how
Optiplan performed in the IPC of 2004.
Optiplan and the original state change formulation are implemented in two different
languages. Optiplan is implemented in C++ using Concert Technology, which is a set of
libraries that allow you to embed ILOG CPLEX optimizers (ILOG Inc., 2002), and the
original state change model is implemented in AMPL (Fourer, Gay, & Kernighan, 1993),
which is a modeling language for mathematical programming. In order to compare the
formulations that are produced by these two implementations, they are written to an output
file using the MPS format. MPS is a standard data format that is often used for transferring
linear and integer linear programming problems between different applications. Once the
MPS file, which contains the IP formulation for the planning problem, is written, it is read
and solved by ILOG CPLEX 8.1 on a Pentium 2.67 GHz with 1.00 GB of RAM.
Table 3 shows the encoding size of the two implementations, where the encoding size is
characterized by the number of variables and the number of constraints in the formulation.
Both the encoding size before and after applying ILOG CPLEX presolve is given. Presolve is
a problem reduction technique (Brearley, Mitra, & Williams, 1975) that helps most linear
programming problems by simplifying, reducing and eliminating redundancies. In short,
926

fiOptiplan: Unifying IP-based and Graph-based Planning

Problem
bw-sussman
bw-12step
bw-large-a
att-log0
log-easy
log-a

State change model
Before presolve
After presolve
#Var. #Cons. #Var. #Cons.
486
878
196
347
3900
7372
1663
3105
6084
11628
2645
5022
1932
3175
25
35
24921
41457
1348
2168
50259
85324
3654
6168

Optiplan
Before presolve
After presolve
#Var. #Cons. #Var. #Cons.
407
593
105
143
3534
4998
868
1025
5639
8690
1800
2096
117
149
0
0
2534
3029
437
592
5746
7480
1479
2313

Table 2: Encoding size of the original state change formulation and Optiplan before and
after ILOG CPLEX presolve. #Var. and #Cons. give the number of variables
and constraints respectively.

Problem
bw-sussman
bw-12step
bw-large-a
bw-large-b
att-log0
att-log1
att-log2
att-log3
att-log4
att-loga
rocket-a
rocket-b
log-easy
log-a
log-b
log-c

#Var.
196
1663
2645
6331
25
114
249
2151
2147
2915
1532
1610
1348
3654
4255
5457

State change model
#Cons. #Nodes
347
0
3105
19
5022
2
12053
14
35
0
164
0
371
10
3686
15
3676
12
4968
975
2653
517
2787
191
2168
43
6168
600
6989
325
9111
970

Time
0.01
4.28
8.45
581.92
0.01
0.03
0.07
0.64
0.71
173.56
32.44
9.90
0.96
145.31
96.47
771.36

#Var.
105
868
1800
4780
0
29
81
181
360
1479
991
1071
437
1479
1718
2413

Optiplan
#Cons. #Nodes
143
0
1025
37
2096
0
5454
10
0
0
35
0
99
0
228
0
507
0
2312
19
1644
78
1788
24
592
0
2313
19
2620
187
3784
37

Time
0.01
1.65
0.72
72.58
0.01
0.01
0.01
0.03
0.04
2.71
5.48
3.12
0.04
2.66
14.06
16.07

Table 3: Performance and encoding size of the original state change formulation and Optiplan. #Var. and #Cons. give the number of variables and constraints after
ILOG CPLEX presolve, and #Nodes give the number of nodes explored during
branch-and-bound before finding the first feasible solution.

927

fiVan den Briel, & Kambhampati

presolve tries to remove redundant constraints and fixed variables from the formulation,
and aggregate (substitute out) variables if possible.
From the encoding size before presolve, which is the actual encoding size of the problem,
we can see how significant the use of planning graphs is. Optiplan, which instantiates
only those fluents and actions that are reachable and relevant through planning graph
analysis, produces encodings that in some cases are over one order of magnitude smaller than
the encodings produced by the original state change model, which instantiates all ground
fluents and actions. Although the difference in the encoding size reduces substantially
after applying presolve, planning graph analysis still finds redundancies that presolve fails
to detect. Consequently, the encodings produced by Optiplan are still smaller than the
encodings that are produced by the original state change model.
The performance (and the encoding size after presolve) of Optiplan and the original
state change model are given in Table 3. Performance is measured by the time to find the
first feasible solution. The results show the overall effectiveness of using planning graph
analysis. For all problems Optiplan not only generates smaller encodings it also performs
better than the encodings generated by the state change model.
5.1 IPC Results
Optiplan participated in the propositional domains of the optimal track in the IPC 2004. In
this track, planners could either minimize the number of actions, like BFHSP and Semsyn;
minimize makespan, like CPT, HSP*a, Optiplan, Satplan04, and TP-4; or minimize some
other metric.
The IPC results of the makespan optimal planners are given in Figure 2. All results were
evaluated by the competition organizers by looking at the runtime and plan quality graphs.
Also, all planners were compared to each other by estimating their asymptotic runtime and
by analyzing their solution quality performance. Out of the seven competition domains,
Optiplan was judged second best in four of them. This is quite remarkable because integer
programming has hitherto not been considered competitive in planning.
Optiplan reached second place in the Optical Telegraph and the Philosopher domains.
In these domains Optiplan is about one order of magnitude slower than Satplan04, but it
clearly outperforms all other participating planners. In the Pipesworld Tankage domain,
Optiplan was awarded second place together with Satplan04, and in the Satellite domain
Optiplan, CPT, and Semsyn all tied for second place. In the other domains Optiplan did
not perform too well. In the Airport domain, Optiplan solves the first 17 problems and
problem 19, but it takes the most time to do so. For the Pipesworld Notankage and the
PSR domains, Optiplan not only is the slowest it also solves the fewest number of problems
among the participating planners.
In looking at the domains and problems where Optiplan has difficulty scaling, we notice
that these are problems that lead to very large IP encodings. Since the size of the encoding is
a function of plan length, Optiplan often fails to solve problems that have long solution plans.
One way to resolve this issue is to de-link the encoding size from solution length, which is
what we have done in some of our recent work (van den Briel, Vossen, & Kambhampati,
2005). In fact, in the year following the IPC4 we developed novel IP encodings that (1)
928

fiOptiplan: Unifying IP-based and Graph-based Planning

model transitions in the individual fluents as separate but loosely coupled network flow
problems, and that (2) control the encoding length by generalizing the notion of parallelism.

6. Conclusions
The Optiplan planning system performs significantly better than the original state change
model by Vossen and his colleagues (1999). It performed respectably at the IPC4, but still
lags behind SAT- and CSP-based planners, like Blackbox(Chaff), Satplan04(Siege), and
GP-CSP. We believe, however, that this performance gap is not because IP techniques are
inferior to SAT and CSP, but rather a reflection of the types of IP formulations that have
been tried so far. Specifically, the encodings that have been tried until now have not been
tailored to the strengths of the IP solvers (Chandru & Hooker, 1999).
Our experience with Optiplan has encouraged us to continue working on improved IP
formulations for AI planning. In our recent work (van den Briel, Vossen, & Kambhampati,
2005) we model fluents as loosely coupled network flow problems and control the encoding
length by generalizing the notion of parallelism. The resulting IP encodings are solved
within a branch-and-cut algorithm and yield impressive results. Also, this new approach
has been shown to be highly competitive with the state-of-the-art SAT-based planners.

References
Blum, A., & Furst, M. (1995). Fast planning through planning graph analysis. In Proceedings
of the 14th International Joint Conference on Artificial Intelligence (IJCAI-95), pp.
16361642.
Bockmayr, A., & Dimopoulos, Y. (1998). Mixed integer programming models for planning problems. In Working notes of the CP-98 Constraint Problem Reformulation
Workshop.
Bockmayr, A., & Dimopoulos, Y. (1999). Integer programs and valid inequalities for planning problems. In Proceedings of the European Conference on Planning (ECP-99),
pp. 239251. Springer-Verlag.
Brearley, A., Mitra, G., & Williams, H. (1975). Analysis of mathematical programming
problems prior to applying the simplex algorithm. Mathematical Programming, 8,
5483.
Bylander, T. (1997). A linear programming heuristic for optimal planning. In AAAI97/IAAI-97 Proceedings, pp. 694699.
Chandru, V., & Hooker, J. (1999). Optimization Methods for Logical Inference. John Wiley
& Sons, New York.
Dimopoulos, Y. (2001). Improved integer programming models and heuristic search for
AI planning. In Proceedings of the European Conference on Planning (ECP-01), pp.
301313. Springer-Verlag.
929

fiVan den Briel, & Kambhampati

10000

10000

1000

1000

100
Time in sec.

Time in sec.

100
10
Optiplan

1

10
1
Optiplan

Satplan04
0.1

0.1

CPT

0.01

0.01
0

5

10

15

20

25

30

35

40

45

Satplan04
CPT

TP4

0

50

5

10

10000

10000

1000

1000

100

100

Time in sec.

Time in sec.

15

20

25

30

35

Satellite problem nr.

Airport problem nr.

10
Optiplan

1

10
1

Satplan04
0.1

Optiplan
0.1

CPT

Satplan04

TP4

CPT

0.01

0.01
0

5

10

15

20

25

30

35

40

45

50

0

5

10

20

25

30

1000

1000

100

100

10

Time in sec.

10000

Optiplan
Satplan04

1

HSPS-A
3

4

5

6

7

8

9

10

11

12 13

0

14

5

Satplan04

CPT

TP4

10

15

20

Philosophers problem nr.

Optical telegraph problem nr.

10000
Optiplan

1000

Satplan04
HSPS-A

100

TP4
CPT

10
1
0.1
0.01
0

50

Optiplan
HSPS-A

0.01

0.01
2

45

1
0.1

TP4

1

40

10

CPT
0.1

0

35

Pipesworld tankge problem nr.

10000

Time in sec.

Time in sec.

Pipesworld notankage problem nr.

15

5

10

15

20

25

30

35

40

45

50

PSR problem nr.

Figure 2: IPC 2004 results for the makespan optimal planners.

930

25

fiOptiplan: Unifying IP-based and Graph-based Planning

Dimopoulos, Y., & Gerevini, A. (2002). Temporal planning through mixed integer programming. In Proceeding of the AIPS Workshop on Planning for Temporal Domains,
pp. 28.
Do, M., & Kambhampati, S. (2001). Planning as constraint satisfaction: Solving the planning graph by compiling it into CSP. Artificial Intelligence, 132 (2), 151182.
Fourer, R., Gay, D., & Kernighan, B. (1993). AMPL: A Modeling Language for Mathematical Programming. Duxbury Press, Belmont, CA.
ILOG Inc., Mountain View, CA (2002). ILOG CPLEX 8.0 users manual.
Kambhampati, S. (1997). Challenges in bridging plan synthesis paradigms. In Proceedings
of the 16th International Joint Conference on Artificial Intelligence (IJCAI-97), pp.
4449.
Kautz, H., & Selman, B. (1992). Planning as satisfiability. In Proceedings of the European
Conference on Artificial Intelligence (ECAI).
Kautz, H., & Selman, B. (1999). Blackbox: Unifying sat-based and graph-based planning.
In Proceedings of the 18th International Joint Conference on Artificial Intelligence
(IJCAI-99), pp. 318325.
Kautz, H., & Walser, J. (1999). State-space planning by integer optimization. In AAAI99/IAAI-99 Proceedings, pp. 526533.
van den Briel, M., Vossen, T., & Kambhampati, S. (2005). Reviving integer programming approaches for AI planning: a branch-and-cut framework. In Proceedings of the
International Conference on Automated Planning and Scheduling (ICAPS-05), pp.
310319.
Vossen, T., Ball, M., Lotem, A., & Nau, D. (1999). On the use of integer programming
models in AI planning. In Proceedings of the 18th International Joint Conference on
Artificial Intelligence (IJCAI-99), pp. 304309.
Wolfman, S., & Weld, D. (1999). The LPSAT engine and its application to resource planning. In Proceedings of the 18th International Joint Conference on Artificial Intelligence (IJCAI-99), pp. 310317.
Wolsey, L. (1998). Integer Programming. Wiley-Interscience Series in Discrete Mathematics
and Optimization. John Wiley & Sons, New York.

931

fi