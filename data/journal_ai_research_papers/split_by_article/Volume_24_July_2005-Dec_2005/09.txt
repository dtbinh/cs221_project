Journal of Artificial Intelligence Research 24 (2005) 341-356

Submitted 11/04; published 09/05

Efficiency versus Convergence of Boolean Kernels for
On-Line Learning Algorithms
Roni Khardon

roni@cs.tufts.edu

Department of Computer Science, Tufts University
Medford, MA 02155

Dan Roth

danr@cs.uiuc.edu

Department of Computer Science, University of Illinois
Urbana, IL 61801 USA

Rocco A. Servedio

rocco@cs.columbia.edu

Department of Computer Science, Columbia University
New York, NY 10025

Abstract
The paper studies machine learning problems where each example is described using a
set of Boolean features and where hypotheses are represented by linear threshold elements.
One method of increasing the expressiveness of learned hypotheses in this context is to
expand the feature set to include conjunctions of basic features. This can be done explicitly
or where possible by using a kernel function. Focusing on the well known Perceptron
and Winnow algorithms, the paper demonstrates a tradeoff between the computational
efficiency with which the algorithm can be run over the expanded feature space and the
generalization ability of the corresponding learning algorithm.
We first describe several kernel functions which capture either limited forms of conjunctions or all conjunctions. We show that these kernels can be used to efficiently run
the Perceptron algorithm over a feature space of exponentially many conjunctions; however we also show that using such kernels, the Perceptron algorithm can provably make an
exponential number of mistakes even when learning simple functions.
We then consider the question of whether kernel functions can analogously be used
to run the multiplicative-update Winnow algorithm over an expanded feature space of
exponentially many conjunctions. Known upper bounds imply that the Winnow algorithm
can learn Disjunctive Normal Form (DNF) formulae with a polynomial mistake bound in
this setting. However, we prove that it is computationally hard to simulate Winnows
behavior for learning DNF over such a feature set. This implies that the kernel functions
which correspond to running Winnow for this problem are not efficiently computable, and
that there is no general construction that can run Winnow with kernels.

1. Introduction
The problem of classifying objects into one of two classes being positive and negative
examples of a concept is often studied in machine learning. The task in machine learning
is to extract such a classifier from given pre-classified examples - the problem of learning
from data. When each example is represented by a set of n numerical features, an example
c
2005
AI Access Foundation. All rights reserved.

fiKhardon, Roth, & Servedio

can be seen as a point in Euclidean space <n . A common representation for classifiers in
this case is a hyperplane of dimension (n  1) which splits the domain of examples into
two areas of positive and negative examples. Such a representation is known as a linear
threshold function, and many learning algorithms that output a hypothesis represented in
this manner have been developed, analyzed, implemented, and applied in practice. Of
particular interest in this paper are the well known Perceptron (Rosenblatt, 1958; Block,
1962; Novikoff, 1963) and Winnow (Littlestone, 1988) algorithms that have been intensively
studied in the literature.
It is also well known that the expressiveness of linear threshold functions is quite limited (Minsky & Papert, 1968). Despite this fact, both Perceptron and Winnow have been
applied successfully in recent years to several large scale real world classification problems.
As one example, the SNoW system (Roth, 1998; Carlson, Cumby, Rosen, & Roth, 1999) has
successfully applied variations of Perceptron and Winnow to problems in natural language
processing. The SNoW system extracts basic Boolean features x1 , . . . , xn from labeled pieces
of text data in order to represent the examples, thus the features have numerical values restricted to {0, 1}. There are several ways to enhance the set of basic features x 1 , . . . , xn
for Perceptron or Winnow. One idea is to expand the set of basic features x 1 , . . . , xn using
conjunctions such as (x1  x3  x4 ) and use these expanded higher-dimensional examples, in
which each conjunction plays the role of a basic feature, as the examples for Perceptron or
Winnow. This is in fact the approach which the SNoW system takes running Perceptron or
Winnow over a space of restricted conjunctions of these basic features. This idea is closely
related to the use of kernel methods, see e.g. the book of Cristianini and Shawe-Taylor
(2000), where a feature expansion is done implicitly through the kernel function. The approach clearly leads to an increase in expressiveness and thus may improve performance.
However, it also dramatically increases the number of features (from n to 3 n if all conjunctions are used), and thus may adversely affect both the computation time and convergence
rate of learning. The paper provides a theoretical study of the performance of Perceptron
and Winnow when run over expanded feature spaces such as these.
1.1 Background: On-Line Learning with Perceptron and Winnow
Before describing our results, we recall some necessary background on the on-line learning
model (Littlestone, 1988) and the Perceptron and Winnow algorithms.
Given an instance space X of possible examples, a concept is a mapping of instances into
one of two (or more) classes. A concept class C  2X is simply a set of concepts. In on-line
learning a concept class C is fixed in advance and an adversary can pick a concept c  C.
The learning is then modeled as a repeated game where in each iteration the adversary
picks an example x  X, the learner gives a guess for the value of c(x) and is then told the
correct value. We count one mistake for each iteration in which the value is not predicted
correctly. A learning algorithm learns a concept class C with mistake bound M if for any
choice of c  C and any (arbitrarily long) sequence of examples, the learner is guaranteed
to make at most M mistakes.
In this paper we consider the case where the examples are given by Boolean features,
that is X = {0, 1}n , and we have two class labels denoted by 1 and 1. Thus for x  {0, 1}n ,
a labeled example hx, 1i is a positive example, and a labeled example hx, 1i is a negative
342

fiEfficiency versus Convergence of Boolean Kernels

example. The concepts we consider are built using logical combinations of the n base
features and we are interested in mistake bounds that are polynomial in n.
1.1.1 Perceptron
Throughout its execution Perceptron maintains a weight vector w  < N which is initially
(0, . . . , 0). Upon receiving an example x  <N the algorithm predicts according to the
linear threshold function w  x  0. If the prediction is 1 and the label is 1 (false positive
prediction) then the vector w is set to w  x, while if the prediction is 1 and the label is 1
(false negative) then w is set to w + x. No change is made to w if the prediction is correct.
Many variants of this basic algorithm have been proposed and studied and in particular one
can add a non zero threshold as well as a learning rate that controls the size of update to
w. Some of these are discussed further in Section 3.
The famous Perceptron Convergence Theorem (Rosenblatt, 1958; Block, 1962; Novikoff,
1963) bounds the number of mistakes which the Perceptron algorithm can make:
Theorem 1 Let hx1 , y1 i, . . . , hxt , yt i be a sequence of labeled examples with xi  <N , kxi k 
R and yi  {1, 1} for all i. Let u  <N ,  > 0 be such that yi (u  xi )   for all i. Then
2
2
mistakes on this example sequence.
Perceptron makes at most R kuk
2
1.1.2 Winnow
The Winnow algorithm (Littlestone, 1988) has a very similar structure. Winnow maintains
a hypothesis vector w  <N which is initially w = (1, . . . , 1). Winnow is parameterized by
a promotion factor  > 1 and a threshold  > 0; upon receiving an example x  {0, 1} N
Winnow predicts according to the threshold function w  x  . If the prediction is 1 and the
label is 1 then for all i such that xi = 1 the value of wi is set to wi /; this is a demotion
step. If the prediction is 1 and the label is 1 then for all i such that xi = 1 the value of wi
is set to wi ; this is a promotion step. No change is made to w if the prediction is correct.
For our purposes the following mistake bound, implicit in Littlestones work (1988), is
of interest:
Theorem 2 Let the target function be a k-literal monotone disjunction f (x 1 , . . . , xN ) =
xi1      xik . For any sequence of examples in {0, 1}N labeled according to f the number

of prediction mistakes made by Winnow(, ) is at most 1
 N + k( + 1)(1 + log ).
1.2 Our Results
We are interested in the computational efficiency and convergence of the Perceptron and
Winnow algorithms when run over expanded feature spaces of conjunctions. Specifically,
we study the use of kernel functions to expand the feature space and thus enhance the
learning abilities of Perceptron and Winnow; we refer to these enhanced algorithms as
kernel Perceptron and kernel Winnow.
Our first result (cf. also the papers of Sadohara, 1991; Watkins, 1999; and Kowalczyk
et al., 2001) uses kernel functions to show that it is possible to efficiently run the kernel
Perceptron algorithm over an exponential number of conjunctive features.
343

fiKhardon, Roth, & Servedio

Result 1: (see Theorem 3) There is an algorithm that simulates Perceptron over the 3 n dimensional feature space of all conjunctions of n basic features. Given a sequence of t
labeled examples in {0, 1}n the prediction and update for each example take poly(n, t) time
steps. We also prove variants of this result in which the expanded feature space consists of
all monotone conjunctions or all conjunctions of some bounded size.
This result is closely related to one of the main open problems in learning theory:
efficient learnability of disjunctions of conjunctions, or DNF (Disjunctive Normal Form)
expressions.1 Since linear threshold elements can represent disjunctions (e.g. x1  x2  x3
is true iff x1 + x2 + x3  1), Theorem 1 and Result 1 imply that kernel Perceptron can be
used to learn DNF. However, in this framework the values of N and R in Theorem 1 can be
exponentially large (note that we have N = 3n and R = 2n/2 if all conjunctions are used),
and hence the mistake bound given by Theorem 1 is exponential rather than polynomial
in n. The question thus arises whether the exponential upper bound implied by Theorem
1 is essentially tight for the kernel Perceptron algorithm in the context of DNF learning.
We give an affirmative answer, thus showing that kernel Perceptron cannot efficiently learn
DNF.
Result 2: There is a monotone DNF f over x1 , . . . , xn and a sequence of examples labeled
according to f which causes the kernel Perceptron algorithm to make 2 (n) mistakes. This
result holds for generalized versions of the Perceptron algorithm where a fixed or updated
threshold and a learning rate are used. We also give a variant of this result showing
that kernel Perceptron fails in the Probably Approximately Correct (PAC) learning model
(Valiant, 1984) as well.
Turning to Winnow, an attractive feature of Theorem 2 is that for suitable ,  the bound
is logarithmic in the total number of features N (e.g.  = 2 and  = N ). Therefore, as
noted by several researchers (Maass & Warmuth, 1998), if a Winnow analogue of Theorem 3
could be obtained this would imply that DNF can be learned by a computationally efficient
algorithm with a poly(n)-mistake bound. However, we give strong evidence that no such
Winnow analogue of Theorem 3 can exist.
Result 3: There is no polynomial time algorithm which simulates Winnow over exponentially many monotone conjunctive features for learning monotone DNF unless every problem
in the complexity class #P can be solved in polynomial time. This result holds for a wide
range of parameter settings in the Winnow algorithm.
We observe that, in contrast to this negative result, Maass and Warmuth have shown
that the Winnow algorithm can be simulated efficiently over exponentially many conjunctive
features for learning some simple geometric concept classes (Maass & Warmuth, 1998).
Our results thus indicate a tradeoff between computational efficiency and convergence
of kernel algorithms for rich classes of Boolean functions such as DNF formulas; the kernel
1. Angluin (1990) proved that DNF expressions cannot be learned efficiently using equivalence queries
whose hypotheses are themselves DNF expressions. Since the model of exact learning from equivalence
queries only is equivalent to the mistake bound model which we consider in this paper, her result implies
that no online algorithm which uses DNF formulas as hypotheses can efficiently learn DNF. However,
this result does not preclude the efficient learnability of DNF using a different class of hypotheses. The
kernel Perceptron algorithm generates hypotheses which are thresholds of conjunctions rather than DNF
formulas, and thus Angluins negative results do not apply here.

344

fiEfficiency versus Convergence of Boolean Kernels

Perceptron algorithm is computationally efficient to run but has exponentially slow convergence, whereas kernel Winnow has rapid convergence but seems to require exponential
runtime.

2. Kernel Perceptron with Many Features
It is well known that the hypothesis w of the Perceptron algorithm is a linear combination
of the previous examples on which mistakes were made (Cristianini & Shaw-Taylor, 2000).
More precisely, if we let L(v)  {1, 1} denote the label of example v, then we have that
P
w = vM L(v)v where M is the set of examples on which the algorithm made a mistake.
P
P
Thus the prediction of Perceptron on x is 1 iff wx = ( vM L(v)v)x = vM L(v)(v x) 
0.
For an example x  {0, 1}n let (x) denote its transformation into an enhanced feature
space such as the space of all conjunctions. To run the Perceptron algorithm over the
enhanced space we must predict 1 iff w   (x)  0 where w  is the weight vector in
P
the enhanced space; from the above discussion this holds iff vM L(v)((v)  (x))  0.
P
Denoting K(v, x) = (v)  (x) this holds iff vM L(v)K(v, x)  0.
Thus we never need to construct the enhanced feature space explicitly; in order to run
Perceptron we need only be able to compute the kernel function K(v, x) efficiently. This is
the idea behind all so-called kernel methods, which can be applied to any algorithm (such
as support vector machines) whose prediction is a function of inner products of examples.
A more detailed discussion is given in the book of Cristianini and Shawe-Taylor (2000).
Thus the next theorem is simply obtained by presenting a kernel function capturing all
conjunctions.
Theorem 3 There is an algorithm that simulates Perceptron over the feature spaces of
(1) all conjunctions, (2) all monotone conjunctions, (3) conjunctions of size  k, and (4)
monotone conjunctions of size  k. Given a sequence of t labeled examples in {0, 1} n the
prediction and update for each example take poly(n, t) time steps.
Proof: For case (1) () includes all 3n conjunctions (with positive and negative literals) and
K(x, y) must compute the number of conjunctions which are true in both x and y. Clearly,
any literal in such a conjunction must satisfy both x and y and thus the corresponding bit
in x, y must have the same value. Thus each conjunction true in both x and y corresponds
to a subset of such bits. Counting all these conjunctions gives K(x, y) = 2same(x,y) where
same(x, y) is the number of original features that have the same value in x and y, i.e. the
number of bit positions i which have xi = yi . This kernel has been obtained independently
by Sadohara (2001).
To express all monotone monomials as in (2) we take K(x, y) = 2|xy| where |x  y| is
the number of active features common to both x and y, i.e. the number of bit positions
which have xi = yi = 1.
Similarly, for case (3) the number of conjunctions that satisfy both x and y is K(x, y) =
Pk same(x,y)
. This kernel is reported also by Watkins (1999). For case (4) we have
l=0
l


P
K(x, y) = kl=0 |xy|
.
2
l
345

fiKhardon, Roth, & Servedio

3. Kernel Perceptron with Many Mistakes
In this section we describe a simple monotone DNF target function and a sequence of
labeled examples which causes the monotone monomials kernel Perceptron algorithm to
make exponentially many mistakes.
For x, y  {0, 1}n we write |x| to denote the number of 1s in x and, as described above,
|xy| to denote the number of bit positions i which have xi = yi = 1. We need the following
well-known tail bound on sums of independent random variables which can be found in,
e.g., Section 9.3 of the book by Kearns and Vazirani (1994):
Fact 4 Let X1 , . . . , Xm be a sequence of m independent 0/1-valued random variables, each
P
of which has E[Xi ] = p. Let X denote m
i=1 Xi , so E[X] = pm. Then for 0    1, we
have
Pr[X > (1 + )pm]  emp

2 /3

and

Pr[X < (1  )pm]  emp

2 /2

.

We also use the following combinatorial property:
Lemma 5 There is a set S of n-bit strings S = {x1 , . . . , xt }  {0, 1}n with t = en/9600
such that |xi | = n/20 for 1  i  t and |xi  xj |  n/80 for 1  i < j  t.
Proof: We use the probabilistic method. For each i = 1, . . . , t let xi  {0, 1}n be chosen
by independently setting each bit to 1 with probability 1/10. For any i it is clear that
E[|xi |] = n/10. Applying Fact 4, we have that Pr[|xi | < n/20]  en/80 , and thus the
probability that any xi satisfies |xi | < n/20 is at most ten/80 . Similarly, for any i 6= j we
have E[|xi  xj |] = n/100. Applying Fact 4 we have that Pr[|xi  xj | > n/80]  en/4800 ,
and thus the probability that any xi , xj with
i 6= j satisfies |xi  xj | > n/80 is at most
 t  n/4800
t  n/4800
n/9600
+ ten/80 is less than 1. Thus for some
. For t = e
the value of 2 e
2 e
choice of x1 , . . . , xt we have each |xi |  n/20 and |xi  xj |  n/80. For any xi which has
|xi | > n/20 we can set |xi |  n/20 of the 1s to 0s, and the lemma is proved.
2
Now using the previous lemma we can construct a difficult data set for kernel Perceptron:
Theorem 6 There is a monotone DNF f over x1 , . . . , xn and a sequence of examples labeled
according to f which causes the kernel Perceptron algorithm to make 2(n) mistakes.
Proof: The target DNF with which we will use is very simple: it is the single conjunction
x1 x2 . . . xn . While the original Perceptron algorithm over the n features x1 , . . . , xn is easily
seen to make at most poly(n) mistakes for this target function, we now show that the
monotone kernel Perceptron algorithm which runs over a feature space of all 2 n monotone
monomials can make 2 + en/9600 mistakes.
Recall that at the beginning of the Perceptron algorithms execution all 2 n coordinates
of w are 0. The first example is the negative example 0n . The only monomial true in this
example is the empty monomial which is true in every example. Since w   (x) = 0 Perceptron incorrectly predicts 1 on this example. The resulting update causes the coefficient
w corresponding to the empty monomial to become 1 but all 2n  1 other coordinates
of w remain 0. The next example is the positive example 1n . For this example we have
w  (x) = 1 so Perceptron incorrectly predicts 1. Since all 2n monotone conjunctions
346

fiEfficiency versus Convergence of Boolean Kernels

are satisfied by this example the resulting update causes w to become 0 and all 2n  1
other coordinates of w  to become 1. The next en/9600 examples are the vectors x1 , . . . , xt
described in Lemma 5. Since each such example has |xi | = n/20 each example is negative;
however as we now show the Perceptron algorithm will predict 1 on each of these examples.
Fix any value 1  i  en/9600 and consider the hypothesis vector w  just before example
i
x is received. Since |xi | = n/20 the value of w   (xi ) is a sum of the 2n/20 different
coordinates wT which correspond to the monomials satisfied by xi . More precisely we have
P
P
w  (xi ) = T Ai wT + T Bi wT where Ai contains the monomials which are satisfied
by xi and xj for some j 6= i and Bi contains the monomials which are satisfied by xi but
no xj with j 6= i. We lower bound the two sums separately.
Let T be any monomial in Ai . By Lemma 5 any T  Ai contains at most n/80 variables

Pn/80 
monomials in Ai . Using the well known bound
and thus there can be at most r=0 n/20
r


P` `
(H()+o(1))`
where 0 <   1/2 and H(p) = p log p  (1  p) log(1  p) is
j=0 j = 2
the binary entropy function, which can be found e.g. as Theorem 1.4.5 of the book by
Van Lint (1992), there can be at most 20.8113(n/20)+o(n) < 20.041n terms in Ai . Moreover
the value of each wT must be at least en/9600 since wT decreases by at most 1 for each
P
example, and hence T Ai wT  en/9600 20.041n > 20.042n . On the other hand, any T  Bi
is false in all other examples and therefore wT has not been demoted and wT = 1. By
Lemma 5 for any r > n/80 every r-variable monomial satisfied by xi must belong to Bi ,


P
Pn/20
and hence T Bi wT  r=n/80+1 n/20
> 20.049n . Combining these inequalities we have
r
w  xi  20.042n + 20.049n > 0 and hence the Perceptron prediction on xi is 1.
2
Remark 7 At first sight it might seem that the result is limited to a simple special case of
the perceptron algorithm. Several variations exist that use: an added feature with a fixed
value that enables the algorithm to update the threshold indirectly (via a weight w), a non
zero fixed (initial) threshold , and a learning rate , and in particular all these three can
be used simultaneously. The generalized algorithm predicts according to the hypothesis
w  x + w   and updates w  w + x and w  w +  for promotions and similarly
for demotions. We show here that exponential lower bounds on the number of mistakes
can be derived for the more general algorithm as well. First, note that since our kernel
includes a feature for the empty monomial which is always true, the first parameter is
already accounted for. For the other two parameters note that there is a degree of freedom
between the learning rate  and fixed threshold  since multiplying both by the same factor
does not change the hypothesis and therefore it suffices to consider the threshold only. We
consider several cases for the value of the threshold. If  satisfies 0    2 0.047 then we
use the same sequence of examples. After the first two examples the algorithm makes a
promotion on 1n (it may or may not update on 0n but that is not important). For the
P
P
examples in the sequence the bounds on T Ai wT and T Bi wT are still valid so the
final inequality in the proof becomes w  xi  20.042n + 20.049n > 20.047n which is true for
sufficiently large n. If  > 20.047n then we can construct the following scenario. We use the
function f = x1  x2  . . .  xn , and the sequence of examples includes 2  1 repetitions of
the same example x where the first bit is 1 and all other bits are 0. The example x satisfies
exactly 2 monomials and therefore the algorithm will make mistakes on all the examples in
the sequence. If  < 0 then the initial hypothesis misclassifies 0n . We start the example
347

fiKhardon, Roth, & Servedio

sequence by repeating the example 0n until it is classified correctly, that is de times.
If the threshold is large in absolute value e.g.  < 20.042n we are done. Otherwise we
continue with the example 1n . Since all weights except for the empty monomial are zero at
this stage the examples 0n and 1n are classified in the same way so 1n is misclassified and
therefore the algorithm makes a promotion. The argument for the rest of the sequence is as
above (except for adding a term for the empty monomial) and the final inequality becomes
w  xi  20.042n  20.042n + 20.049n > 20.042n so each of the examples is misclassified. Thus
in all cases kernel Perceptron may make an exponential number of mistakes.
3.1 A Negative Result for the PAC Model
The proof above can be adapted to give a negative result for kernel Perceptron in the PAC
learning model (Valiant, 1984). In this model each example x is independently drawn from
a fixed probability distribution D and with high probability the learner must construct a
hypothesis h which has high accuracy relative to the target concept c under distribution D.
See the Kearns-Vazirani text (1994) for a detailed discussion of the PAC learning model.
Let D be the probability distribution over {0, 1}n which assigns weight 1/4 to the ex1
to each of the en/9600 examples
ample 0n , weight 1/4 to the example 1n , and weight 21 en/9600
x1 , . . . , xt .
Theorem 8 If kernel Perceptron is run using a sample of polynomial size p(n) then with
probability at least 1/16 the error of its final hypothesis is at least 0.49.
Proof: With probability 1/16, the first two examples received from D will be 0n and then
1n . Thus, with probability 1/16, after two examples (as in the proof above) the Perceptron
algorithm will have w = 0 and all other coefficients of w  equal to 1.
Consider the sequence of examples following these two examples. First note that in any
trial, any occurrence of an example other than 1n (i.e. any occurrence either of some xi or of
P
the 0n example) can decrease T [n] wT by at most 2n/20 . Since after the first two examples
P
we have w   (1n ) = T [n] wT = 2n  1, it follows that at least 219n/20  1 more examples
must occur before the 1n example will be incorrectly classified as a negative example. Since
we will only consider the performance of the algorithm for p(n) < 219n/20  1 steps, we
may ignore all subsequent occurrences of 1n since they will not change the algorithms
hypothesis.
Now observe that on the first example which is not 1n the algorithm will perform a
demotion resulting in w = 1 (possibly changing other coefficients as well). Since no
promotions will be performed on the rest of the sample, we get w  1 for the rest of
the learning process. It follows that all future occurrences of the example 0 n are correctly
classified and thus we may ignore them as well.
Considering examples xi from the sequence constructed above, we may ignore any example that is correctly classified since no update is made on it. It follows that when the
perceptron algorithm has gone over all examples, its hypothesis is formed by demotions on
examples in the sequence of xi s. The only difference from the scenario above is that the
algorithm may make several demotions on the same example if it occurs multiple times in
the sample. However, an inspection of the proof above shows that for any x i that has not
P
P
been seen by the algorithm, the bounds on T Ai wT and T Bi wT are still valid and
348

fiEfficiency versus Convergence of Boolean Kernels

therefore xi will be misclassified. Since the sample is of size p(n) and the sequence is of
size en/9600 the probability weight of examples in the sample is at most 0.01 for sufficiently
large n so the error of the hypothesis is at least 0.49.
2

4. Computational Hardness of Kernel Winnow
In this section, for x  {0, 1}n we let (x) denote the (2n  1)-element vector whose coordinates are all nonempty monomials (monotone conjunctions) over x1 , . . . , xn . We say that
a sequence of labeled examples hx1 , b1 i, . . . , hxt , bt i is monotone consistent if it is consistent
with some monotone function, i.e. xik  xjk for all k = 1, . . . , n implies bi  bj . If S is
monotone consistent and has t labeled examples then clearly there is a monotone DNF
formula consistent with S which contains at most t conjunctions. We consider the following
problem:
KERNEL WINNOW PREDICTION(, ) (KWP)
Instance: Monotone consistent sequence S = hx1 , b1 i, . . . , hxt , bt i of labeled examples with
each xi  {0, 1}m and each bi  {1, 1}; unlabeled example z  {0, 1}m .
Question: Is w   (z)  , where w  is the N = (2m  1)-dimensional hypothesis vector
generated by running Winnow(, ) on the example sequence h(x1 ), b1 i, . . . h(xt ), bt i?
In order to run Winnow over all 2m  1 nonempty monomials to learn monotone DNF,
one must be able to solve KWP efficiently. Our main result in this section is a proof
that KWP is computationally hard for a wide range of parameter settings which yield a
polynomial mistake bound for Winnow via Theorem 2.
Recall that #P is the class of all counting problems associated with N P decision problems; it is well known that if every function in #P is computable in polynomial time then
P = N P. See the book of Papadimitriou (1994) or the paper of Valiant (1979) for details
on #P. The following problem is #P-hard (Valiant, 1979):
MONOTONE 2-SAT (M2SAT)
Instance: Monotone 2-CNF Boolean formula F = c1  c2  . . .  cr with ci = (yi1  yi2 )
and each yij  {y1 , . . . , yn }; integer K such that 1  K  2n .
Question: Is |F 1 (1)|  K, i.e. does F have at least K satisfying assignments in {0, 1}n ?
Theorem 9 Fix any  > 0. Let N = 2m  1, let   1 + 1/m1 , and let   1 be such

that max( 1
 N , ( + 1)(1 + log )) = poly(m). If there is a polynomial time algorithm
for KWP(, ), then every function in #P is computable in polynomial time.
Proof: For N,  and  as described in the theorem a routine calculation shows that
1 + 1/m1    poly(m)

and

2m
   2poly(m) .
poly(m)

(1)

The proof is a reduction from the problem M2SAT. The high level idea of the proof is
simple: let (F, K) be an instance of M2SAT where F is defined over variables y1 , . . . , yn . The
Winnow algorithm maintains a weight wT for each monomial T over variables x1 , . . . , xn . We
define a 1-1 correspondence between these monomials T and truth assignments y T  {0, 1}n
349

fiKhardon, Roth, & Servedio

for F, and we give a sequence of examples for Winnow which causes wT  0 if F (y T ) = 0
and wT = 1 if F (y T ) = 1. The value of w   (z) is thus related to |F 1 (1)|. Note that
if we could control  as well this would be sufficient since we could use  = K and the
result will follow. However  is a parameter of the algorithm. We therefore have to make
additional updates so that w   (z)   + (|F 1 (1)|  K) so that w   (z)   if and
only if |F 1 (1)|  K. The details are somewhat involved since we must track the resolution
of approximations of the different values so that the final inner product will indeed give a
correct result with respect to the threshold.
General setup of the construction. In more detail, let
 U = n + 1 + d(dlog 4e + 1) log e,
n+1
 V = d log
 e + 1,
U +2
 W = d log
e + 1

and let m be defined as
m = n + U + 6V n2 + 6U W + 3.

(2)

Since   1 + 1/m1 , using the fact that log(1 + x)  x/2 for 0 < x < 1 we have that
log   1/(2m1 ), and from this it easily follows that m as specified above is polynomial in
n. We describe a polynomial time transformation which maps an n-variable instance (F, K)
of M2SAT to an m-variable instance (S, z) of KWP(, ) where S = hx 1 , b1 i, . . . , hxt , bt i
is monotone consistent, each xi and z belong to {0, 1}m , and w  (z)   if and only if
|F 1 (1)|  K.
The Winnow variables x1 , . . . , xm are divided into three sets A, B and C where A =
{x1 , . . . , xn }, B = {xn+1 , . . . , xn+U } and C = {xn+U +1 , . . . , xm }. The unlabeled example z
is 1n+U 0mnU , i.e. all variables in A and B are set to 1 and all variables in C are set to 0.
P
P
We thus have w  (z) = MA +MB +MAB where MA = 6=T A wT , MB = 6=T B wT and
P
MAB = T AB,T A6=,T B6= wT . We refer to monomials  6= T  A as type-A monomials,
monomials  6= T  B as type-B monomials, and monomials T  AB, T A 6= , T B 6= 
as type-AB monomials.
The example sequence S is divided into four stages. Stage 1 results in MA  |F 1 (1)|;
as described below the n variables in A correspond to the n variables in the CNF formula
F. Stage 2 results in MA  q |F 1 (1)| for some positive integer q which we specify later.
Stages 3 and 4 together result in MB + MAB    q K. Thus the final value of w   (z) is
approximately  + q (|F 1 (1)|  K), so we have w   (z)   if and only if |F 1 (1)|  K.
Since all variables in C are 0 in z, if T includes a variable in C then the value of wT
does not affect w   (z). The variables in C are slack variables which (i) make Winnow
perform the correct promotions/demotions and (ii) ensure that S is monotone consistent.
Stage 1: Setting MA  |F 1(1)|. We define the following correspondence between
truth assignments y T  {0, 1}n and monomials T  A : yiT = 0 if and only if xi is not
present in T. For each clause yi1  yi2 in F, Stage 1 contains V negative examples such that
xi1 = xi2 = 0 and xi = 1 for all other xi  A. We show below that (1) Winnow makes a
false positive prediction on each of these examples and (2) in Stage 1 Winnow never does a
350

fiEfficiency versus Convergence of Boolean Kernels

promotion on any example which has any variable in A set to 1. Consider any y T such that
F (y T ) = 0. Since our examples include an example y S such that y T  y S the monomial T
is demoted at least V times. As a result after Stage 1 we will have that for all T , w T = 1
if F (y T ) = 1 and 0 < wT  V if F (y T ) = 0. Thus we will have MA = |F 1 (1)| + 1 for
some 0 < 1 < 2n V < 21 .
We now show how the Stage 1 examples cause Winnow to make a false positive prediction
on negative examples which have xi1 = xi2 = 0 and xi = 1 for all other i in A as described
above. For each such negative example in Stage 1 six new slack variables x+1 , . . . , x+6  C
are used as follows: Stage 1 has dlog  (/3)e repeated instances of the positive example which
has x+1 = x+2 = 1 and all other bits 0. These examples cause promotions which result
in   wx+1 + wx+2 + wx+1 x+2 <  and hence wx+1  /3. Two other groups of
similar examples (the first with x+3 = x+4 = 1, the second with x+5 = x+6 = 1) cause
wx+3  /3 and wx+5  /3. The next example in S is the negative example which has
xi1 = xi2 = 0, xi = 1 for all other xi in A, x+1 = x+3 = x+5 = 1 and all other bits 0.
For this example w   (x) > wx+1 + wx+3 + wx+5   so Winnow makes a false positive
prediction.
Since F has at most n2 clauses and there are V negative examples per clause, this
construction can be carried out using 6V n2 slack variables xn+U +1 , . . . , xn+U +6V n2 . We
thus have (1) and (2) as claimed above.
Stage 2: Setting MA  q |F 1(1)|. The first Stage 2 example is a positive example
with xi = 1 for all xi  A, xn+U +6V n2 +1 = 1 and all other bits 0. Since each of the 2n
monomials which contain xn+U +6V n2 +1 and are satisfied by this example have wT = 1,
we have w   (x) = 2n + |F 1 (1)| + 1 < 2n+1 . Since  > 2m /poly(m) > 2n+1 (recall
from equation (2) that m > 6n2 ), after the resulting promotion we have w   (x) =
(2n + |F 1 (1)| + 1 ) < 2n+1 . Let
q = dlog (/2n+1 )e  1
so that
q 2n+1 <   q+1 2n+1 .

(3)

Stage 2 consists of q repeated instances of the positive example described above. After
these promotions we have w   (x) = q (2n + |F 1 (1)| + 1 ) < q 2n+1 < . Since 1 <
|F 1 (1)| + 1 < 2n we also have
q < MA = q (|F 1 (1)| + 1 ) < q 2n < /2.

(4)

Equation (4) gives the value which MA will have throughout the rest of the argument.
Some Calculations for Stages 3 and 4. At the start of Stage 3 each type-B and typeAB monomial T has wT = 1. There are n variables in A and U variables in B so at the
start of Stage 3 we have MB = 2U  1 and MAB = (2n  1)(2U  1). Since no example in
Stages 3 or 4 satisfies any xi in A, at the end of Stage 4 MA will still be q (|F 1 (1)| + 1 )
and MAB will still be (2n  1)(2U  1). Therefore at the end of Stage 4 we have
w  (z) = MB + q (|F 1 (1)| + 1 ) + (2n  1)(2U  1).
351

fiKhardon, Roth, & Servedio

To simplify notation let
D =   (2n  1)(2U  1)  q K.
Ideally at the end of Stage 4 the value of MB would be D  q 1 since this would imply that
w  (z) =  + q (|F 1 (1)|  K) which is at least  if and only if |F 1 (1)|  K. However it
is not necessary for MB to assume this exact value, since |F 1 (1)| must be an integer and
0 < 1 < 21 . As long as
1
(5)
D  MB < D +  q
2
we get that
1
 + q (|F 1 (1)|  K + 1 ) < w  (z) <  + q (|F 1 (1)|  K + 1 + ).
2
Now if |F 1 (1)|  K we clearly have w   (z)  . On the other hand if |F 1 (1)| < K
then since |F 1 (1)| is an integer value |F 1 (1)|  K  1 and we get w   (z) < . Therefore
all that remains is to construct the examples in Stages 3 and 4 so that that M B satisfies
Equation (5).
We next calculate an appropriate granularity for D. Note that K  2 n , so by Equation (3) we have that   q K > /2. Now recall from Equations (2) and (1) that m >
2
n + U + 6n2 and  > 2m /poly(m), so /2  2n+U +6n /poly(m)  2n 2U . Consequently we
certainly have that D > /4, and from Equation (3) we have that D > /4 >  q 2n1 > 14 q .
Let
c = dlog 4e,
so that we have
1
qc  q < D.
4

(6)

There is a unique smallest positive integer p > 1 which satisfies D  pqc < D + 41 q . The
Stage 3 examples will result in MB satisfying p < MB < p + 14 . We now have that:
1
qc < D  pqc < D + q
4
3 q
  
4
 q+1 2n+1  3qc
= 

qc

 (

c+1 n+1

2

 3).

(7)
(8)
(9)

Here (7) holds since K  1, and thus (by definition of D) we have D + q   which is
equivalent to Equation (7). Inequality (8) follows from Equations (6) and (3).
Hence we have that
1 < p  c+1 2n+1  3  2n+1+d(c+1) log e  3 = 2U  3,

(10)

where the second inequality in the above chain follows from Equation (9). We now use the
following lemma:
352

fiEfficiency versus Convergence of Boolean Kernels

Lemma 10 For all `  1, for all 1  p  2`  1, there is a monotone CNF F`,p over
` Boolean variables which has at most ` clauses, has exactly p satisfying assignments in
{0, 1}` , and can be constructed from ` and p in poly(`) time.
Proof: The proof is by induction on `. For the base case ` = 1 we have p = 1 and F `,p = x1 .
Assuming the lemma is true for ` = 1, . . . , k we now prove it for ` = k + 1 :
If 1  p  2k  1 then the desired CNF is Fk+1,p = xk+1  Fk,p . Since Fk,p has at most k
clauses Fk+1,p has at most k + 1 clauses. If 2k + 1  p  2k+1  1 then the desired CNF is
Fk+1,p = xk+1  Fk,p2k . By distributing xk over each clause of Fk,p2k we can write Fk+1,p
as a CNF with at most k clauses. If p = 2k then Fk,p = x1 .
2
Stage 3: Setting MB  p. Let FU,p be an r-clause monotone CNF formula over the
U variables in B which has p satisfying assignments. Similar to Stage 1, for each clause
of FU,p , Stage 3 has W negative examples corresponding to that clause, and as in Stage
1 slack variables in C are used to ensure that Winnow makes a false positive prediction
on each such negative example. Thus the examples in Stage 3 cause MB = p + 2 where
0 < 2 < 2U W < 41 . Since six slack variables in C are used for each negative example
and there are rW  U W negative examples, the slack variables xn+U +6V n2 +2 , . . . , xm2 are
sufficient for Stage 3.
Stage 4: Setting MB + MAB    q K. All that remains is to perform q  c
promotions on examples which have each xi in B set to 1. This will cause MB to equal
(p + 2 )qc . By the inequalities established above, this will give us
1
1
D  pqc < (p + 2 )qc = MB < D + q + 2 qc < D + q
4
2
which is as desired.
In order to guarantee q  c promotions we use two sequences of examples of length
n
U n
q  dU
log  e and d log  e  c respectively. We first show that these are positive numbers. It
follows directly from the definitions U = n + 1 + d(dlog  4e + 1) log e and c = dlog 4e
n
6n2 (by definition of m and Equation (1)) and  is bounded
that U
log   c. Since  > 2
by a polynomial in m, we clearly have that log(/2n+1 ) > U  n + log(). Now since
n+1 )
U n
n
q = dlog (/2n+1 )e  1 this implies that q > log(/2
1 > dU
log  e, so that q  d log  e > 0.
log()
n
The first q  d U
log  e examples in Stage 4 are all the same positive example which has
each xi in B set to 1 and xm1 = 1. The first time this example is received, we have
2
w  (x) = 2U + p + 2 < 2U +1 . Since  > 26n , by inspection of U we have 2U +1 < , so
n
Winnow performs a promotion. Similarly, after q  d U
log  e occurrences of this example, we
have
qd U n e
qd U n e
w  (x) =  log  (2U + p + 2 ) <  log  2U +1  q 2n+1 < 

so promotions are indeed performed at each occurrence, and
MB = 

n
qd U
e
log 

(p + 2 ).

n
The remaining examples in Stage 4 are d U
log  e  c repetitions of the positive example x
which has each xi in B set to 1 and xm = 1. If promotions occurred on each repetition of

353

fiKhardon, Roth, & Servedio

this example then we would have w   (x) = 

n
dU
ec
log 

(2U + 

n
qd U
e
log 

(p + 2 )), so we need

only show that this quantity is less than . We reexpress this quantity as 
qc (p + 2 ). We have

n
ec U
dU
log 
2

1
qc (p + 2 ) < pqc + qc
4
3 q
1
    + q
4
16
1 q
<  
2

+

(11)

d U n ec

where (11) follows from (7) and the definition of c. Finally, we have that  log  2U 
1

  22U nc log  <   22U n2 < 2
< 21 q , where the last inequality is by Equation (3)
2n+1
and the previous inequality is by inspection of the values of ,  and U . Combining the two
bounds above we see that indeed w   (x) < .
Finally, we observe that by construction the example sequence S is monotone consistent.
Since m = poly(n) and S contains poly(n) examples the transformation from M2SAT to
KWP(, ) is polynomial-time computable and the theorem is proved.
2(Theorem 9)

5. Conclusion
Linear threshold functions are a weak representation language for which we have interesting learning algorithms. Therefore, if linear learning algorithms are to learn expressive
functions, it is necessary to expand the feature space over which they are applied. This
work explores the tradeoff between computational efficiency and convergence when using
expanded feature spaces that capture conjunctions of base features.
We have shown that while each iteration of the kernel Perceptron algorithm can be
executed efficiently, the algorithm can provably require exponentially many updates even
when learning a function as simple as f (x) = x1 x2 . . . xn . On the other hand, the kernel
Winnow algorithm has a polynomial mistake bound for learning polynomial-size monotone
DNF, but our results show that under a widely accepted computational hardness assumption
it is impossible to efficiently simulate the execution of kernel Winnow. The latter also implies
that there is no general construction that will run Winnow using kernel functions.
Our results indicate that additive and multiplicative update algorithms lie on opposite
extremes of the tradeoff between computational efficiency and convergence; we believe that
this fact could have significant practical implications. By demonstrating the provable limitations of using kernel functions which correspond to high-degree feature expansions, our
results also lend theoretical justification to the common practice of using a small degree in
similar feature expansions such as the well-known polynomial kernel.2
Since the publication of the initial conference version of this work (Khardon, Roth, &
Servedio, 2002), several authors have explored closely related ideas. One can show that our
construction for the negative results for Perceptron does not extend (either in the PAC or
2. Our Boolean kernels are different than standard polynomial kernels in that all the conjunctions are
weighted equally, and also in that we allow negations.

354

fiEfficiency versus Convergence of Boolean Kernels

online setting) to related algorithms such as Support Vector Machines which work by constructing a maximum margin hypothesis consistent with the examples. The paper (Khardon
& Servedio, 2003) gives an analysis of the PAC learning performance of maximum margin
algorithms with the monotone monomials kernel, and derives several negative results thus
giving further negative evidence for the monomial kernel. In the paper (Cumby & Roth,
2003) a kernel for expressions in description logic (generalizing the monomials kernel) is
developed and successfully applied for natural language and molecular problems. Takimoto and Warmuth (2003) study the use of multiplicative update algorithms other than
Winnow (such as weighted majority) and obtain some positive results by restricting the
type of loss function used to be additive over base features. Chawla et al. (2004) have
studied Monte Carlo estimation approaches to approximately simulate the Winnow algorithms performance when run over a space of exponentially many features. The use of
kernel methods for logic learning and developing alternative methods for feature expansion
with multiplicative update algorithms remain interesting and challenging problems to be
investigated.

Acknowledgments
This work was partly done while Khardon was at the University of Edinburgh and partly
while Servedio was at Harvard University. The authors gratefully acknowledge financial
support for this work by EPSRC grant GR/N03167, NSF grant IIS-0099446 and a Research Semester Fellowship Award from Tufts University (Khardon), NSF grants ITR-IIS00-85836, ITR-IIS-0085980 and IIS-9984168 (Roth), and NSF grant CCR-98-77049 and NSF
Mathematical Sciences Postdoctoral Fellowship (Servedio).

References
Angluin, D. (1990). Negative results for equivalence queries. Machine Learning, 2, 121150.
Block, H. (1962). The perceptron: a model for brain functioning. Reviews of Modern
Physics, 34, 123135.
Carlson, A., Cumby, C., Rosen, J., & Roth, D. (1999). The SNoW learning architecture.
Tech. rep. UIUCDCS-R-99-2101, UIUC Computer Science Department.
Chawla, D., Li, L., & Scott., S. (2004). On approximating weighted sums with exponentially
many terms. Journal of Computer and System Sciences, 69, 196234.
Cristianini, N., & Shaw-Taylor, J. (2000). An Introduction to Support Vector Machines.
Cambridge Press.
Cumby, C., & Roth, D. (2003). On kernel methods for relational learning. In Proc. of the
International Conference on Machine Learning.
Kearns, M., & Vazirani, U. (1994). An Introduction to Computational Learning Theory.
MIT Press, Cambridge, MA.
355

fiKhardon, Roth, & Servedio

Khardon, R., Roth, D., & Servedio, R. (2002). Efficiency versus convergence of Boolean
kernels for on-line learning algorithms. In Dietterich, T. G., Becker, S., & Ghahramani,
Z. (Eds.), Advances in Neural Information Processing Systems 14, Cambridge, MA.
MIT Press.
Khardon, R., & Servedio, R. (2003). Maximum margin algorithms with Boolean kernels. In
Proceedings of the Sixteenth Annual Conference on Computational Learning Theory,
pp. 87101.
Lint, J. V. (1992). Introduction to Coding Theory. Springer-Verlag.
Littlestone, N. (1988). Learning quickly when irrelevant attributes abound: A new linearthreshold algorithm. Machine Learning, 2, 285318.
Maass, W., & Warmuth, M. K. (1998). Efficient learning with virtual threshold gates.
Information and Computation, 141 (1), 378386.
Minsky, M., & Papert, S. (1968). Perceptrons: an introduction to computational geometry.
MIT Press, Cambridge, MA.
Novikoff, A. (1963). On convergence proofs for perceptrons. In Proceeding of the Symposium
on the Mathematical Theory of Automata, Vol. 12, pp. 615622.
Papadimitriou, C. (1994). Computational Complexity. Addison-Wesley.
Rosenblatt, F. (1958). The Perceptron: a probabilistic model for information storage and
organization in the brain. Psychological Review, 65, 386407.
Roth, D. (1998). Learning to resolve natural language ambiguities: A unified approach. In
Proc. of the American Association of Artificial Intelligence, pp. 806813.
Sadohara, K. (2001). Learning of Boolean functions using support vector machines. In Proc.
of the Conference on Algorithmic Learning Theory, pp. 106118. Springer. LNAI 2225.
Takimoto, E., & Warmuth, M. (2003). Path kernels and multiplicative updates. Journal of
Machine Learning Research, 4, 773818.
Valiant, L. G. (1979). The complexity of enumeration and reliability problems. SIAM
Journal of Computing, 8, 410421.
Valiant, L. G. (1984). A theory of the learnable. Communications of the ACM, 27 (11),
11341142.
Watkins, C. (1999). Kernels from matching operations. Tech. rep. CSD-TR-98-07, Computer
Science Department, Royal Holloway, University of London.

356

fi