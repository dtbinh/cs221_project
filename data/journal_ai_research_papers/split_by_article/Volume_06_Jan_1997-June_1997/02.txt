Journal of Artificial Intelligence Research 6 (1997) 87-110

Submitted 7/96; published 3/97

A Uniform Framework for Concept Definitions in
Description Logics
Giuseppe De Giacomo

degiacomo@dis.uniroma1.it

Universita di Roma \La Sapienza"
Via Salaria 113, 00198 Roma, Italy

Maurizio Lenzerini

lenzerini@dis.uniroma1.it

Universita di Roma \La Sapienza"
Via Salaria 113, 00198 Roma, Italy

Abstract

Most modern formalisms used in Databases and Artificial Intelligence for describing an
application domain are based on the notions of class (or concept) and relationship among
classes. One interesting feature of such formalisms is the possibility of defining a class,
i.e., providing a set of properties that precisely characterize the instances of the class.
Many recent articles point out that there are several ways of assigning a meaning to a
class definition containing some sort of recursion. In this paper, we argue that, instead of
choosing a single style of semantics, we achieve better results by adopting a formalism that
allows for different semantics to coexist. We demonstrate the feasibility of our argument, by
presenting a knowledge representation formalism, the description logic ALCQ, with the
above characteristics. In addition to the constructs for conjunction, disjunction, negation,
quantifiers, and qualified number restrictions, ALCQ includes special fixpoint constructs
to express (suitably interpreted) recursive definitions. These constructs enable the usual
frame-based descriptions to be combined with definitions of recursive data structures such
as directed acyclic graphs, lists, streams, etc. We establish several properties of ALCQ,
including the decidability and the computational complexity of reasoning, by formulating
a correspondence with a particular modal logic of programs called the modal mu-calculus.

1. Introduction
Most modern formalisms used in Databases and Artificial Intelligence for representing an
application domain are based on the notions of class (or concept) and relationship among
classes. For example, the object-oriented and semantics data models developed in Databases
describe data in terms of classes (sometimes called entity types) and incorporate several
features for establishing various forms of relationships between classes. On the other hand,
the notion of class (often called concept or frame) and that of link among classes are provided
in all structured formalisms for Knowledge Representation (frame-based languages, semantic
networks, description logics, etc.). Finally, this notion is also present in several type systems
of programming languages, specially those based on the object-oriented paradigm.
There are basically two ways of using and describing classes (concepts). In the first one,
which we can call the prescriptive approach, the description formalism allows for expressing
a number of properties of a class, thus prescribing constraints that the instances of the class
must satisfy. In the second one, which we can call the definitional approach, the formalism
allows for providing the definition of a class, i.e., a set of properties that precisely characterc 1997 AI Access Foundation and Morgan Kaufmann Publishers. All rights reserved.

fiDe Giacomo & Lenzerini

ize the instances of the class. While the prescriptive approach is quite well understood and
established, the definitional approach is still the subject of an interesting debate, regarding
both its nature and its semantic foundation. In particular, it is well known that there are
various ways to assign a meaning to a class definition when it contains some sort of recursion
(Baader, 1990, 1991; Nebel, 1991; Beneventano & Bergamaschi, 1992; Beeri, 1990).
In this paper, we are concerned with the semantic problems related to the definitional
approach, arguing that, instead of choosing a single style of semantics for the knowledge
representation formalism, we achieve better results by allowing different semantics to coexist.
We discuss this issue in the context of Description Logics1 , which are logics originally
developed in Knowledge Representation to provide a formal reconstruction of frame-based
languages. Description logics describe the domain of interest in terms of concepts, which
represent classes of individuals, and roles, which are binary relations used to specify properties or attributes of individuals as well as links with other individuals (Nebel, 1990). Starting
from atomic concepts, denoted simply by a name, more complex concepts are built by using a suitable set of constructs. For example, the expression parent u male u 8child:male
denotes the concept of father (male parent) whose children are all male. The symbol u
denotes the construct for concept conjunction, while 8 denotes universal role quantification.
Typically, concepts are structured into hierarchies determined by the properties associated
with them. The hierarchical structure is defined in such a way that more specific concepts
inherit the properties of the more general ones.
We introduce a description logic, called ALCQ, which extends the well-known description logic ALC (Schmidt-Schau & Smolka, 1991) by including the so called qualified
number restrictions, which are a very general form of cardinality constraints on roles, and
special fixpoint constructs, which enable us to capture the various semantics for recursive
definitions within a single formalism. Notably, the availability of these constructs makes
it possible to combine the usual frame-based descriptions with definitions of recursive data
structures such as directed acyclic graphs, lists, streams, etc.
We establish several properties of ALCQ, including the decidability and the computational complexity of reasoning, by formulating a correspondence with a particular modal
logic of programs called the modal mu-calculus.
Recent articles, (e.g., Bergamaschi & Sartori, 1992; Borgida, 1992), advocate the use
of description logics as a unifying framework for several types of database and knowledge
representation formalisms. Indeed, it is possible to show that, depending on both the constructs and the semantics used, one can capture several database models and programming
language type systems by using description logics. Therefore, the study presented in this paper is not merely confined to description logics, but is also applicable to other representation
formalisms.
The paper is organized as follows. In Section 2, we present the basic notions regarding
both description logics and fixpoints. In Section 3, we motivate our approach through
a detailed discussion about the different semantics of concept definitions that have been
considered in the literature, and we argue for a formalism in which the various semantics
coexist. In Section 4, we present one such formalism, namely the logic ALCQ, and we
1. Also called Concept Languages or Terminological Languages.

88

fiConcept Definitions in Description Logics

discuss several of its properties. In Section 5 we study reasoning techniques for ALCQ
and expose the correspondence with modal mu-calculus. Finally, in Section 6, we draw the
conclusions and discuss some open problems.

2. Preliminaries
In this section, we briey present the basic notions regarding both description logics, and
fixpoints. The interested reader is referred to (Nebel, 1990) and (de Bakker, 1980) for a
more complete introduction to the subjects.

2.1 Description Logics

Description logics allow one to represent a domain of interest in terms of concepts and
roles. Concepts model classes of individuals, while roles model relationships between classes.
Starting with atomic concepts (denoted by A) and atomic roles (denoted by R), which are
concepts and roles described simply by a name, complex concepts and roles can be built by
means of suitable constructs.
In this section, we concentrate on the description logic ALCQ, obtained from the wellknown description logic ALC (Schmidt-Schau & Smolka, 1991) by including qualified number restrictions. These are cardinality constraints on the role fillers of a very general form,
where role fillers to which a constraint applies are selected by means of a generic concept
expression, the qualifier.
ALCQ concepts (denoted by C or D, possibly with a subscript) are composed inductively
according to the following abstract syntax (n denotes a natural number):

C ::= A j > j ? j :C j C1 u C2 j C1 t C2 j 9R:C j 8R:C j ( n R:C ) j ( n R:C ):
These constructs are not all independent. The following equalities hold: > = A t :A,

? = :>, 8R:C = :9R::C , and ( n R:C ) = :( n + 1 R:C ).

From a semantic point of view, concepts are interpreted as subsets of an abstract domain,
while roles are interpreted as binary relations over such a domain. More precisely, an
interpretation I = (I ; I ) consists of a domain of interpretation I , and an interpretation
function I mapping every atomic concept A to a subset of I and every atomic role R to
a subset of I  I .
The interpretation function I is extended to complex concepts of ALCQ (note that in
ALCQ roles are always atomic) as follows:

>I
?I
(:C )I
(C1 u C2 )I
(C1 t C2 )I
(9R:C )I
(8R:C )I
( n R:C )I
( n R:C )I

=
=
=
=
=
=
=
=
=

I

;

I , C I

C1I \ C2I
C1I [ C2I
fs 2 I j 9s0: (s; s0 ) 2 RI and s0 2 C I g
fs 2 I j 8s0: (s; s0 ) 2 RI implies s0 2 C I g
fs 2 I j #fs0 j (s; s0) 2 RI and s0 2 C I g  ng
fs 2 I j #fs0 j (s; s0) 2 RI and s0 2 C I g  ng
89

fiDe Giacomo & Lenzerini

where #S denotes the cardinality of the set S .
A concept C is satisfiable iff there exists an interpretation I such that C I 6= ;, otherwise
C is unsatisfiable. A concept C1 is subsumed by a concept C2, written as C1 v C1, iff for
every interpretation I , C1I  C2I .
Our knowledge expressed in terms of concepts and roles is assembled into a special
knowledge base, traditionally called TBox, which consists of a finite (possibly empty) set
of assertions. In order to be as general as possible, we assume that every assertion has the
form of an inclusion assertion (or simply inclusion):

C1 v C2

without any restriction on the form of the concepts C1 and C2 . A pair of inclusions of the
form fC1 v C2 ; C2 v C1 g is often written as C1  C2 and is called equivalence assertion.
An interpretation I satisfies an inclusion C1 v C2 iff C1I  C2I . An interpretation I is
a model of a TBox K iff I satisfies all inclusions in K.
Let K be a TBox. We say that a concept C is satisfiable in K, iff there exists a model
I of K such that C I 6= ;, unsatisfiable otherwise. We say that a concept C1 is subsumed by
a concept C2 in K, written K j= C1 v C2 , iff for every model I of K, C1I  C2I .

2.2 Fixpoints

We briey recall few notions on fixpoints. Consider the equation:
X = f (X )
where f is an operator from 2S to 2S (2S denotes the set of all subsets of a set S ). Every
solution E of this equation is called a fixpoint of the operator f (while every set E such that
f (E )  E is called pre-fixpoint, and every set E such that E  f (E ) is called post-fixpoint).
In general, an equation as the one above may have either no solution, a finite number of
solutions, or an infinite number of them. Among the various solutions, the smallest and the
greatest solutions (with respect to set-inclusion) have a prominent position, if they exist. A
fundamental result due to Tarski (Tarski, 1955) guarantees the existence and the uniqueness
of both such solutions in case f is monotonic wrt set-inclusion (), where f is monotonic
wrt  whenever E1  E2 implies f (E1 )  f (E2 ).
Theorem 1 (Tarski) Let S be a set, and f an operator from 2S to 2S that is monotonic
wrt . Then:
 There exists a unique least fixpoint of f , which is given by TfE  S j f (E )  Eg.
 There exists a unique greatest fixpoint of f , which is given by SfE  S j E  f (E )g.

3. Concept Definitions as Equations

We now analyze the notion of concept definition in detail. Let us ignore for the moment
knowledge bases as they have been introduced in the previous section, and let us consider a
different kind of assertion: the definition statement. Let the form of a definition statement
(or simply definition) be:
A =def C
90

fiConcept Definitions in Description Logics

where A is an atomic concept which cannot appear in the left-hand side of other definition
statements, and C is a concept expression in ALCQ. In principle, A =def C is intended to
provide an exact account for the concept to A in terms of C , i.e., to define A as the set of
the individuals satisfying C .
In specifying the semantics of definitions, we need to distinguish between two different
types of atomic concepts, namely, primitive concepts and defined concepts. Given a set of
definition statements, the primitive concepts are the atomic concepts that do not appear in
the left-hand side of any definition statement, whereas the defined concepts are those that
appear in the left-hand side of a definition statement.
Given an interpretation I = (I ; I ), the interpretation function I directly assigns
a subset of I to primitive concepts, but not to defined concepts. The meaning of a
defined concept A is assigned through its definition statement A =def C , extending the
interpretation function so as the following requirement is satisfied:
AI = C I :
(1)
Consider, for example, the definition statement:
parent =def 9child:>:
Note that the defined concept parent does not appear in the body of its definition statement.
By (1), the definition statement provides the definition for the concept parent, in the
following sense: in any interpretation I = (I ; I ), parentI denotes a single subset of I ,
exactly the one denoted by (9child:>)I , i.e., fs j 9t:(s; t) 2 childI g. In general, if a concept
A is defined in terms of primitive and already defined concepts, then for every interpretation
I there exists a unique way to extend the interpretation function to defined concepts, and
hence there is no doubt that the definition statement provides a definition of A.
Now, consider the following definition statement:
A =def 9child:A:
Given an interpretation I = (I ; I ), by (1) the statement is interpreted as the equation:
AI = fs 2 I j 9t:(s; t) 2 childI and t 2 AI g:
However such equation does not specify univocally how to extend the interpretation function
I to the defined concept A, since ; satisfies the equation as well as any set of individuals
where each member has an infinite chain of descendants that are also members.
In general, we call recursive definition statements2 (or simply recursive definitions),
definition statements of the form:
A =def F (A)
where F (A) stands for a concept that has A as a subconcept3 . According to (1), the recursive
definition A =def F (A) is interpreted simply as a sort of equation specifying that, given an
2. Terminological cycles in (Baader, 1990, 1991; Nebel, 1991). In the present discussion, for sake of simplicity, we do not consider mutual recursive definitions, as A =def F (B ), B =def F (A). We shall come
back to this point later on.
3. A subconcept of a concept C is any substring of C (including C itself) that is a concept, according to
the syntax rules.
0

91

fiDe Giacomo & Lenzerini

interpretation I , the subset of I that can be tied to the defined concept A must satisfy
the equation AI = F (A)I , i.e., must be one of its solutions. Observe that, in general, either
none, one, or several subsets of I may exist which are solutions of the above equation.
Another convenient way to consider a definition statement is to associate to it, for every
interpretation I , an operator from subsets of I to subsets of I instead of an equation, so
that the fixpoints of the operator correspond to the solutions of the equation. For example,
to the definition A =def 9child:A we associate the operator:

S:fs 2 I j 9t:(s; t) 2 childI and t 2 S g
for any interpretation I . In general as either none, one or multiple solutions exist for the
equation associated with a recursive definition, we have that either none, one or multiple
fixpoints exist for the corresponding operator.
In this situation the word \definition" itself seems misleading: the body of the definition
does not give a complete account of the defined concept. An additional criterion is needed
for selecting solutions of the associated equation, or equivalently, fixpoints of the associated
operator. In other words in addition to (1), a criterion is needed to extend univocally the
interpretations I to the defined concepts. This observation has led to various semantics,
each of which interprets recursive definitions differently, by choosing, a priori and once and
for all, which solutions, or equivalently which fixpoints, are to be assigned to the defining
concept of a recursive definition4.

3.1 Different Semantics for Recursive Definitions

In the literature on description logics, three semantics for recursive definitions have been
proposed (see Nebel, 1991):

 Descriptive Semantics
 Least Fixpoint Semantics
 Greatest Fixpoint Semantics
and which of these semantics is the \right" one is a long standing matter of debate. Below
we describe how each of the three semantics interprets recursive definitions, and present
some examples showing that the choice of the semantics depends in fact upon the concept
to be defined. But first, it should be stressed that only the descriptive semantics is able to
assign meaning to general inclusion assertions C1 v C2 introduced in the previous section.
According to the Descriptive Semantics, a recursive definition A =def F (A) is a constraint stating that, for any I , AI has to be a solution of the equation AI = F (A)I . Under
the descriptive semantics, A =def 9child:A simply states that the individuals in the class
A have a child in the class A, and the individuals that have a child in the class A are
themselves in the class A, where A is no better specified. In general the descriptive semantics is not appropriate to properly define recursive concepts, in the sense that, given an
4. We remark that a non-recursive definition is interpreted by the various semantics in the same way, since,
for every I , the equation associated to it has a single solution.

92

fiConcept Definitions in Description Logics

interpretation I , it is unable to assign a unique subset of I to the defined concept of the
recursive definition.
In fact under descriptive semantics definition statements are indistinguishable from the
equivalence assertions introduced in the previous section. In other words, the meaning
assigned to A =def F (A) is the same as that assigned to the equivalence assertion A  F (A).
Although such equivalence assertions can be used to specify if-and-only-if constraints, they
do not provide proper definitions when recursion is involved. For example, we can express
the fact that humans are mammals having parents that are humans, and on the converse,
that mammals having parents that are humans are humans themselves, in terms of the
equivalence assertion:

human  mammal u 9parent:> u 8parent:human:
Similarly we may require horses to satisfy an analogous property:

horse  mammal u 9parent:> u 8parent:horse:
However the two equivalence assertions above do not define human and horse as shown,

e.g., by the fact that (correctly) they do not imply that all humans are horses and vice-versa
(in contrast to what happen when a fixpoint semantics is used, see below).
The Least Fixpoint Semantics interprets a recursive definition statement A =def F (A)
by assigning to A the smallest possible extension in each interpretation I , among those that
satisfy AI =def F (A)I { i.e., the least fixpoint of the corresponding operator. In fact it is
always assumed that the operator associated with the definition statement is monotonic,
so that Theorem 1 applies and a least fixpoint exists and is unique, i.e., the corresponding
equation has a unique smallest solution. Hence under the least fixpoint semantics the
recursive definition statement A =def F (A) defines the concept A. It is easy to verify that
in the example A =def 9child:A, the least fixpoint semantics leads us to identify A with ?.
Indeed the empty set is a solution of the equation associated with the statement, and it is
obviously the smallest solution. Similarly if we interpret the definition statement:
human =def mammal u 9parent:> u 8parent:human
with the least fixpoint semantics, we have that humanI = ; for any interpretation I .
Observe that if, as above, we adopt a similar definition for horse, we get again horseI = ;,
so we can trivially infer that horse  human.
The least fixpoint semantics is particularly suitable for providing inductive definitions
of concepts. For example, consider the class of a list (LIST) defined as follows:
 An EMPTY-LIST is a LIST.
 A NODE that has exactly one successor that is a LIST is a LIST.
 Nothing else is a LIST.
The first two conditions can be captured by the following recursive definition statement5 :
list =def emptylist t (node u ( 1 succ:>) u 9succ:list)
5. Additionally we specify that the two concepts emptylist and node are disjoint.

93

fiDe Giacomo & Lenzerini

where ( 1 succ:>) forces succ to be a function. To enforce the third condition we must
assign the smallest possible extension to list. Thus, the class of LISTs can be naturally
defined by means of the above definition statement, interpreted according to the least
fixpoint semantics.
The Greatest Fixpoint Semantics interprets a recursive definition statement A =def F (A)
by assigning to A the largest possible extension in each interpretation I , among those that
satisfy AI =def F (A)I { i.e., the greatest fixpoint of the corresponding operator. Again, it
is assumed that such operator is monotonic in order to guaranty the existence an the unicity
of the greatest fixpoint (Theorem 1). As for the least fixpoint semantics, under the greatest
fixpoint semantics a recursive definition statement A =def F (A) defines the concept A. For
example, considering again the definition statement A =def 9child:A, the greatest fixpoint
semantics leads us to interpret A as the class of all the individuals having a child that in
turn is a member of A.
While the least fixpoint semantics naturally captures classes defined by induction, the
greatest fixpoint semantics naturally captures classes of individuals whose structure is nonwell-founded or co-inductive. An example is the class of STREAMs, modeling the wellknown linear data structure having a NODE as first element, and such that the rest of the
structure is a STREAM itself. Note that streams are similar to lists except that while lists
can be considered as finite sequences of nodes, streams are infinite sequences of nodes. Such
a class can be captured by the following recursive definition statement:

stream =def node u ( 1 succ:>) u 9succ:stream
with the proviso that the greatest possible extension is assigned to stream.
Finally, consider under the greatest fixpoint semantics the recursive definition statements:
human =def mammal u 9parent:> u 8parent:human
horse =def mammal u 9parent:> u 8parent:horse:
Although they do not assign the empty extension to both human and horse as the least
fixpoint semantics does, we do have again the rather counter intuitive consequence that
human  horse, since humanI = horseI for any interpretation I . In general under both
types of fixpoint semantics the particular name used to denote a defined concept does not
have any impact on the interpretation of it, since the meaning of the defined concept is
completely specified by its definition statement.

3.2 Least and Greatest Fixpoints as Concept Constructs

The above considerations show that arguing about which is the \right" semantics for recursive definitions is not really an issue. Each of them captures an essential use of recursive
equations: the descriptive semantics is appropriate to specify constraints on concepts and
is the only one that extends to the general inclusion assertions introduced in Section 2; the
least fixpoint semantics is appropriate to define a structure inductively; the greatest fixpoint
semantics is the appropriate to define non-well-founded structures. Generally, we may need
the three of them in the same knowledge base, in order to model the various properties of
the different concepts.
94

fiConcept Definitions in Description Logics

Our proposal in this paper is exactly in the direction of reconciling the various semantics
in the same knowledge base. This is pursued by means of a logic that incorporates two
constructs, X:F (X ) and X:F (X ) (the symbols X; Y; : : : stand for concept variables),
denoting, respectively, the least fixpoint and the greatest fixpoint of the operator associated
with the definition X =def F (X ), that is, for every I , the smallest solution and the greatest
solution of the equation X I = F (X )I .
In our approach, definition statements will never appear in a TBox. Instead, a knowledge
base will be simply a set of inclusion assertions (interpreted according to the descriptive semantics) that can involve fixpoint constructs. For example, in order to specify the properties
of the concepts of list, stream, human and horse we can use the following assertions6 :
list
 X:emptylist t (node u ( 1 succ:>) u 9succ:X )
stream  X:node u ( 1 succ:>) u 9succ:X

human  mammal u 9parent:> u 8parent:human
horse  mammal u 9parent:> u 8parent:horse:

Note that, if we then add to the above knowledge base the equivalence assertion:

mgm  X : mammal u 9parent:> u 8parent:X
defining the concept mgm (mammal generated by mammal), then it correctly turns out
that both human and horse are subsumed by mgm.

The availability of least and greatest fixpoint constructs, by allowing different semantics
to be used in the same TBox, makes it possible to model not only abstract classes, but also
inductively and co-inductively defined data structures, such as lists and streams. This is
particularly important if our objective is to integrate class-based representation formalisms
and programming systems (declarative or procedural), in order to make these formalisms
more useful in practice. Furthermore, we have the possibility of nesting fixpoints, thus
going beyond the simple equational format by which we motivated their introduction. As
an example, consider the following one:
Among the inhabitants of the planet \Plonk", a disease called \foo" is quite
common. Such a disease manifests itself in two forms: a \visible" one and a
\latent" one, and it has a rather intricate hereditary pattern. Individuals that
have the visible form transmit the visible form to at least one (say the first) direct
descendant (obviously, if there is any direct descendant), these ill descendants
in turn do the same, and so on, until someone transmits the latent form of the
disease. More precisely, along any chain of descendants, the visible form of the
disease sooner or later is interrupted, because either an individual has no direct
descendant or an individual transmits to some descendant the latent form. All
direct descendants (if any) of an individual that has the latent form inherit the
visible form. The pattern goes on like this, generation after generation, forever.
The hereditary pattern (foo hp) of the above disease can be defined as follows:
foo hp  X:Y:((visible u (9child:Y t 8child:?))t
(latent u 8child:(visible u X )))
6. We also include the assertion emptylist v :node, specifying that the concepts emptylist and node are
disjoint.

95

fiDe Giacomo & Lenzerini

where visible and latent denote the visible and the latent form respectively of the disease,
and are assumed to be disjoint (latent v :visible).

4. The Description Logic ALCQ
We provide a formal account of the meaning of the fixpoint constructs by introducing a
description logic, called ALCQ, which is obtained by adding these constructs to ALCQ.
We make use of the notions of scope, bound and free occurrences of variables, closed
formulae, etc. The definitions of these notions are the same as the analogues in first-order
logic, treating  and  as quantifiers. In addition, we use the symbol  as an abstraction
for either  or  .
The primitive symbols in ALCQ are atomic concepts, (concept) variables (denoted by
X; Y; : : :), and atomic roles which are the only roles admitted in the logic.
Concepts in ALCQ are formed inductively according to the following abstract syntax:

C ::= A j > j ? j :C j C1 u C2 j C1 t C2 j 9R:C j 8R:C j ( n R:C ) j ( n R:C ) j
X:C j X:C j X
where A denotes an atomic concept, R an atomic role, n a natural number, and X a variable,
and with the restriction that only a variable X occurring positively in C can be bounded by
a fixpoint  in X:C . We say that a variable X occurs positively in a concept C , if every
free occurrence of X is in the scope of an even number of negations, considering concepts
C 0 in ( n R:C 0 ) in the scope of one negation.
The two fixpoint constructs are mutually definable: X:C = :X::C [X=:X ] (where
C [X=:X ] is the concept obtained substituting all free occurrences of X by the concept
:X ).
As before, an interpretation I = (I ; I ) consists of a domain of interpretation I , and
a interpretation function I , which maps every atomic concept to a subset of I , and every
atomic role to a subset of I  I . But the presence of free variables does not allow us to
extend the interpretation function I directly to every concept of the logic. For this reason
we introduce valuations. A valuation  on an interpretation I is a mapping from variables
to subsets of I .
Given a valuation , we denote by [X=E ] the valuation identical to  except for
[X=E ](X ) = E . In other words, for every variable Y :

(

X
[X=E ](Y ) = E(Y ) ifif YY =
6= X
Let I be an interpretation and  a valuation on I . We assign meaning to concepts of
the logic by associating to I and  an extension function I , mapping concepts to subsets
of I , as follows:
96

fiConcept Definitions in Description Logics

XI
AI

>I
?I
(:C )I
(C1 u C2 )I
(C1 t C2 )I
(9R:C )I
(8R:C )I
( n R:C )I
( n R:C )I

(X:C )I
(X:C )I

=
=
=
=
=
=
=
=
=
=
=
=
=

(X )  I
AI  I
I

;

I , CI
(C1 )I \ (C2 )I
(C1 )I [ (C2 )I
fs 2 I j 9s0: (s; s0 ) 2 RI and s0 2 CI g
fs 2 I j 8s0: (s; s0 ) 2 RI implies s0 2 CI g
fs 2 I j #fs0 j (s; s0) 2 RI and s0 2 CI g  ng
fs 2 I j #fs0 j (s; s0) 2 RI and s0 2 CI g  ng
T
 I j CI[X=E ]  E g
SfE
fE  I j E  CI[X=E ] g

In the last two cases CI[X=E ] is interpreted as an operator from subsets E of I to subsets
of I . By the syntactic restriction enforced on variables, such an operator is guaranteed
to be monotonic wrt . Notice that free variables appearing in a concept are interpreted
similarly to atomic concepts.
A concept C is satisfiable, if there exists an interpretation I and a valuation  on I
such that CI 6= ;, otherwise C is unsatisfiable. A concept C1 is subsumed by a concept C2 ,
written as C1 v C2 , if for every interpretation I and every valuation  on I , (C1 )I  (C2 )I .
A ALCQ TBox is a finite (possibly empty) set of inclusion assertions C1 v C2 where
C1 and C2 are closed concepts of ALCQ. As before, we use equivalence assertions of the
form C1  C2 as an abbreviation for fC1 v C2 ; C2 v C1 g.
An interpretation I satisfies an inclusion assertion C1 v C2 , if (C1 )I  (C2 )I , where 
is any valuation on I (being C1 and C2 closed, and hence independent from valuations).
I is a model of a TBox K, if I satisfies all inclusion assertions in K. We say that a TBox
K is satisfiable, if it has a model. Observe that inclusion assertions in K are interpreted
according to the descriptive semantics.
We say that a TBox K logically implies an inclusion assertion C1 v C2 , written K j=
C1 v C2, if for every model I of K and every valuation  on I , (C1 )I  (C2 )I .

4.1 Properties of the Fixpoint Constructs

In the following, we use the notation C (X ) to indicate that the variable X occurs free in
the concept C (other variables could occur free in C as well), and the notation C (D), where
D is a concept, as a shorthand for C (X )[X=D] (i.e., the concept obtained substituting all
free occurrences of X in C (X ) by the concept D).
Let us comment briey on some simple properties of the logic. First, the concept
X:C (X ) is equivalent to the concept Y:C (Y ), as long as Y is free for X in C (X ). Second,
the extension function I assign to a closed concept a value which is independent of the actual
valuation . Hence X:C , where X does not occur in C , is equivalent to C . Third, since
X:C (X ) is a fixpoint we have that C (X:C (X )) is equivalent to X:C (X ). Furthermore,
we have that the concept X:C (X ) is always subsumed by the concept X:C (X ).
97

fiDe Giacomo & Lenzerini

The next property is more substantial. Consider the class of a single source finite
directed acyclic graphs (DAGs) defined inductively as follows7:
 The EMPTY-DAG is a DAG (base step).

 A NODE that has connections and all connections are DAGs, is a DAG (inductive
step).

 Nothing else is a DAG.
Consider now a ALCQ TBox K containing the two equivalence assertions:
dag of student  X : emptydag t (student u 9arc:> u 8arc:X )
dag of person  X : emptydag t (person u 9arc:> u 8arc:X )

which define the concepts dag of student and dag of person as the classes of DAGs whose
nodes are students and persons respectively. Assuming that students are persons, we want
to be able to infer that DAGs of students are DAGs of persons as well. That is, we want:

K j= student v person implies K j= dag of student v dag of person:
It turns out that for ALCQ such a property holds. To prove this, we introduce the

following two theorems.

Theorem 2 Let K be a ALCQ TBox, and C and D two ALCQ concepts in which a
variable X occurs free positively. Then:
K j= C v D implies K j= X:C v X:D:
Proof We proceed by contradiction8 . Assume that CI  DI holds for all models I of K
and all valuations  on I . And suppose that there exists a model I of K and a valuation 
on I such that (X:C )I 6 (X:D)I .

First we prove the result for  = . Let s be an individual in (X:C )I but not in
(X:D)I . Now, we have:

s 2 (X:C )I iff 8E  I : (CI[X=E ]  E implies s 2 E )

(2)

s 62 (X:D)I iff 9E 0  I : (DI[X=E ]  E 0 and s 62 E 0 ):

(3)

0

For the set E 0 in (3), the following expression holds:

CI[X=E ]  DI[X=E ]  E 0
0

0

7. We assume that a leaf of a DAG is a NODE with all arcs leading to a special DAG called EMPTY-DAG.
As an alternative, one can assume that a leaf of a DAG is a NODE having no connection at all. In the
latter case, the definition of dag would simplify to dag =def node u 8arc:dag (in which the general form
of inductive definitions { i.e., base case and inductive case { is less apparent).
8. For uniformity, we do not distinguish if X occurs free or not. Obviously if X does not occur free, the
result is trivial.

98

fiConcept Definitions in Description Logics

hence by (2) we have s 2 E 0 and by (3) we have s 62 E 0 , which is impossible.
The proof for  =  is similar. Let s be an individual in (X:C )I but not in (X:D)I .
Now, we have:

s 2 (X:C )I iff 9E 00  I : (E 00  CI[X=E ] and s 2 E 00)

(4)

s 62 (X:D)I iff 8E  I : (E  DI[X=E ] implies s 62 E ):

(5)

00

For the set E 00 in (4), the following expression holds:

E 00  CI[X=E ]  DI[X=E
00

00

]

hence by (4) we have s 2 E 00 and by (5) we have s 62 E 00 , which is impossible. 2
Above we have defined what it means for a variable X to occur positively in a concept C .
Similarly we say that a variable X occurs negatively in a concept C , if every free occurrence
of X is in the scope of an odd number of negations, considering concepts C 0 in ( n R:C 0 )
in the scope of one negation.

Theorem 3 Let K be a ALCQ TBox, and D(X ) a ALCQ concept with the variable X
as a free variable. Then, for any ALCQ concepts C1 and C2 :
K j= C1 v C2 implies

(

K j= D(C1) v D(C2) if X occurs positively in D(X )
K j= D(C2) v D(C1) if X occurs negatively in D(X )

Proof We prove the result by induction on the formation of D(X ).

Base case. If D(X ) = X , the result holds trivially.
Inductive cases. If D(X ) has the form :D0 (X ) j ( n R:C 0 ) , then X occurs positively
(negatively) in D0 (X ) and negatively (positively) in D(X ). By induction hypothesis K j=
D0 (Ci ) v D0(Cj ) (where i; j 2 f1; 2g and i 6= j ) and hence by the semantics of the constructs
K j= D(Cj ) v D(Ci).
If D(X ) has the form D10 (X ) u D20 (X ) j D10 (X ) t D20 (X ) j 8R:D0(X ) j ( n R:D0 (X )),
then X occurs positively (negatively) both in D0 (X ) and in D(X ). By induction hypothesis
K j= D0(Ci) v D0(Cj ) and hence by the semantics of the constructs K j= D(Ci) v D(Cj ).
It remains to prove the result for D(X ) = Y:D0 (X ) (Y 6= X ). In this case, by the
syntactic restriction enforced, Y occurs positively in D0 (X ) and hence by Theorem 2 we have
K j= D0(Ci) v D0(Cj ) implies K j= Y:D0(Ci ) v Y:D0 (Cj ), thus by induction hypothesis
we are done. 2
Going back to our example, we can, in fact, infer that DAGs of students are also DAGs of
persons. Indeed, by applying Theorem 3 and then Theorem 2, we have that K j= student v
person implies K j= X:emptydag t (studentu9arc:>u8arc:X ) v X:emptydag t (person u
9arc:> u 8arc:X ).
99

fiDe Giacomo & Lenzerini

4.2 Internalizing Assertions

We now show that logical implication in ALCQ TBoxes (thus also satisfiability of ALCQ
TBoxes) is reducible to unsatisfiability of a single ALCQ concept. To prove this result, we
introduce the notions of generated sub-interpretation and sub-valuation9.
Let I = (I ; I ) be an interpretation,
 a valuation on I , and s 2 I an individual.
s Is
s
I
We define the interpretation I = ( ;  ), and the valuation s on I s, as follows:
 I s = fs0 2 I j (s; s0) 2 (R1I [ : : : [ RmI )g.
 For each atomic role Ri, we have RiI s = RiI \ (I s  I s ).
 For each atomic concept A, we have AI s = AI \ I s .
 For each variable X , we have s(X ) = (X ) \ I s .
We call I s the sub-interpretation of I generated by s, and s the sub-valuation of  generated
by s.
For generated sub-interpretations and sub-valuations we can state the following lemma.

Lemma 4 Let C be a ALCQ concept. Then for any interpretation I , any valuation  on
I , and any individual s 2 I , we have:
8t 2 I s : t 2 CI iff t 2 CIss :
Proof Without loss of generality, we consider concepts formed according to the following
simplified abstract syntax: C ::= A j ? j :C j C1 u C2 j 9R:C j ( n R:C ) j X:C j X:

We prove the result by induction on the number of nested fixpoint constructs. Base
case. If in C there are no fixpoint constructs, the thesis can be proven by induction on the
formation of C .
Inductive case. We assume that the thesis holds for concepts C with k nested fixpoint
constructs, and we prove it for concepts X:C with k + 1. We recall that, by the TarskiKnaster Theorem on fixpoints (Tarski, 1955), t 2 (X:C )I iff there exists an ordinal ff such
that t 2 (ff X:C )I , where (ff X:C )I is defined by transfinite induction as:
 (0 X:C )I = ;

 (ff+1 X:C )I = CI[X=(ff X:C ) ]
 ( X:C )I = Sff< (ffX:C )I , if  is a limit ordinal.
I

Hence we proceed by transfinite induction on ordinals ff.
Base case of the transfinite induction. 0 X:C is defined as ?, thus trivially we have
t 2 (0 X:C )I iff t 2 (0 X:C )Iss .
Successor case of the transfinite induction. We want to show that t 2 (ff+1 X:C )I iff t 2
(ff+1 X:C )Iss , which reduces to:

t 2 CI[X=(ff X:C ) ] iff t 2 CIss[X=(ff X:C )ss ]:
I

I

9. Together these notions play the same role as that of generated sub-model in modal logics.

100

(6)

fiConcept Definitions in Description Logics

To prove this, we start by showing that:

t 2 CIss[X=(ff X:C )ss ] iff t 2 C(Is[X=(ff X:C ) ])s :
I

I

(7)

Notice that the two valuations above may differ only on the value of X . If it holds that:

t 2 XIss[X=(ff X:C )ss ] iff t 2 X(Is[X=(ff X:C ) ])s ;
I

I

(8)

then by straightforward induction on the formation of C we have that (7) holds as well.
Let us prove (8). We can write it as:

t 2 s[X=(ff X:C )Iss ](X ) iff t 2 ([X=(ff X:C )I ])s (X );
and since t 2 I s , this reduces to

t 2 (ff X:C )Iss iff t 2 (ff X:C )I :
which holds by transfinite inductive hypothesis.
Now, since C contains k fixpoint constructs, by inductive hypothesis on k, we have:

t 2 CI[X=(ff X:C ) ] iff t 2 C(Is[X=(ff X:C ) ])s :
I

I

Hence, considering (6) and (7), it follows that indeed t 2 (ff+1 X:C )I iff t 2 (ff+1 X:C )Iss .
Limit case of the transfinite induction. Let  be a limit ordinal, then t 2 ( X:C )I iff
there exists an ordinal ff <  such that t 2 (ff X:C )I . By transfinite induction hypothesis,
it holds that: t 2 (ff X:C )I iff t 2 (ff X:C )Iss , and thus:

t 2 ( X:C )I iff t 2 ( X:C )Iss :
This completes the transfinite induction. So for all ordinals ff it holds that:

t 2 (ff X:C )I iff t 2 (ff X:C )Iss :
The induction on the nesting of fixpoint constructs is completed as well, hence we have
proven the lemma. 2
Now we are ready to state the result mentioned above.

Theorem 5 Let K = fC1 v D1 ; : : : ; Cq v Dq g be a ALCQ TBox, and C and D two
ALCQ concepts. Then K j= C v D if and only if the ALCQ concept:
X:(8R1 :X u : : : u 8Rm :X u CK) u C u :D
(9)
is unsatisfiable, where R1 ; : : : ; Rm are all the atomic roles appearing in K, and CK = (:C1 t
D1 ) u : : : u (:Cq t Dq ).
101

fiDe Giacomo & Lenzerini

Proof If part. By contradiction. Assume that (9) is not satisfiable, and suppose that
K 6j= C v D, i.e., there exists an interpretation I , and a valuation  on I , such that I
is a model of K and CI 6 DI . It follows that, there exists an individual s 2 I such
that s 2 CI and s 2 (:D)I . On the other hand, the fact that I is a model of K implies
that (CK )I = I , and thus that (X:(8R1 :X u : : : u 8Rm :X u CK ))I = I . So we have
s 2 (X:(8R1 :X u : : : u 8Rm:X u CK ) u C u :D)I , i.e., (9) is satisfiable, contradicting the

hypotheses.
Only If part. Again we proceed by contradiction. Assume K j= C v D. And suppose
that (9) is satisfiable, i.e., there exists an interpretation I , a valuation  on I , and an
individual s 2 I , such that s 2 (X:(8R1 :X u : : : u 8Rm :X u CK ) u C u :D)I .
Now consider the sub-interpretation I s = (I s ; Iss ) and the sub-valuation s on I s
generated by s. On the one hand, we clearly have that (CK )Iss = I s , hence I s is a model
of K. On the other hand by Lemma 4 s 2 (X:(8R1 :X u : : : u8Rm :X u CK ) u C u:D)Iss , so it
follows that I s and s do not satisfy the subsumption C v D, contradicting the hypotheses.

2

This result states that satisfiability of ALCQ concepts and logical implication in
ALCQ TBoxes (and thus of satisfiability of ALCQ TBoxes) are not distinct reasoning
tasks. Hence in the following we will limit our attention to concept satisfiability without
loss of generality.

5. Reasoning with Fixpoints

In this section we concentrate on developing reasoning methods to check for satisfiability
concepts involving fixpoints. In particular, we exhibit a correspondence between ALCQ
and a well-known logic of programs, called modal mu-calculus (Kozen, 1983; Kozen &
Parikh, 1983; Streett & Emerson, 1984, 1989), that has been recently investigated for
expressing temporal properties of reactive and parallel processes (Stirling, 1992; Larsen,
1990; Cleaveland, 1990; Winsket, 1989; Dam, 1992).
To get a better insight on the correspondence between the two logics, we first study
the sublanguage ALC obtained from ALCQ leaving out qualified number restrictions10 .
Then, we study the full logic ALCQ.

5.1 Reasoning in ALC

Let us introduce modal mu-calculus formally. Formulae ; 	; : : : of modal mu-calculus
are formed inductively from atomic formulae A; : : : and variables X; : : : according to the
following abstract syntax:
; 	 ::= A j > j ? j : j  ^ 	 j  _ 	 j hai j [a] j X: j X: j X
where a is the generic element of a set of labels L, and every bounded occurrence of every
variable X must be in the scope of an even number of negation signs.
10. Observe that, in Theorem 5 qualified number restrictions play no role. Hence exactly the same reduction
from logical implication to unsatisfiability holds for ALC as well. This allows us to restrict our attention
to satisfiability only.

102

fiConcept Definitions in Description Logics

The semantics of modal mu-calculus is based on the notions of (Kripke) structure and
valuation. A Kripke structure M is a triple (S ; fRi j i 2 Lg; V ), where S is a set of states,
each Ri is a binary relation on S , and V is a mapping from atomic formulae to subsets of
S . A valuation  on M is a mapping from variables to subsets of S . To a Kripke structure
M and a valuation  on M, it is associated an extension function M
 defined inductively
as follows:
XM
= (X )  S
AM
= V (A)  S

M
>
= S
?M
= ;

(:)M
= S , M


M
M
( ^ 	)M
 =  \ 	
M
M
( _ 	) =  [ 	M

(hai)M
= fs 2 S j 9s0 : (s; s0 ) 2 Ra and s0 2 M

 g
0 : (s; s0 ) 2 Ra implies s0 2 M g
([a])M
=
f
s
2
S
j
8
s


T
M
(X:)M
 = SfE  S j [X=E ]  E g
(X:)M
= fE  S j E  M

[X=E ] g
A formula  is satisfiable if there exists a Kripke structure M and a valuation  on M such
that M
 6= ;.
The following theorem is the basis for the correspondence between ALC and the modal
mu-calculus.

Theorem 6 There exists a one-to-one linear-time function q mapping concepts of ALC
to formulae of modal mu-calculus such that: for any ALC concept C , C is satisfiable if
and only if q(C ) is satisfiable.

Proof We can define q in the following way: q(A) = A (atomic concepts are mapped
to atomic formulae), q(X ) = X , q(>) = >, q(?) = ?, q(:C ) = :q(C ), q(9R:C ) =
hRiq(C ) (atomic roles are mapped to labels), q(8R:C ) = [R]q(C ), q(X:C ) = X:q(C ),
and q(X:C ) = X:q(C ).
An interpretation I = (I ; I ) is equivalent to a Kripke structure M = (S ; fRi j i 2
Lg; V ) such that: S = I ; L is equal to the set of names of the atomic roles interpreted
in I ; RR = RI for each atomic role R; and V (A) = AI for each atomic concept A. In
addition, a valuation  on I is equivalent to a valuation 0 on M. Now both the extension
function associated with I and  and the extension function associated with M and 0
map, respectively, any concept C and the corresponding formula q(C ) to the same subset
of I = S . Hence the thesis follows. 2
It follows that we may transfer both decidability and complexity results for the modal
mu-calculus (Kozen & Parikh, 1983; Emerson & Jutla, 1988; Safra, 1988) to ALC . Thus,
we can immediately state what is the complexity of reasoning with ALC concepts and
ALC TBoxes.

Theorem 7 Satisfiability of ALC concepts, satisfiability of ALC TBoxes, and logical
implication in ALC TBoxes are EXPTIME-complete problems.
103

fiDe Giacomo & Lenzerini

Proof The satisfiability problem for modal mu-calculus is EXPTIME-complete (Emerson
& Jutla, 1988), hence by Theorem 6 and by Theorem 5 the thesis follows. 2

5.2 Reasoning in ALCQ
Next we exhibit a mapping from ALCQ concepts to formulae of variant of modal mucalculus, called deterministic modal mu-calculus, which has the same syntax as the modal
mu-calculus, but is interpreted over deterministic Kripke structures, that is Kripke structures M = (S ; fRi j i 2 Lg; V ) in which the relations Ri are partial functions (Streett &
Emerson, 1984).
Let us ignore for a moment the qualified number restriction constructs. Formulae of
ALCQ without qualified number restrictions are, in fact, formulae of the modal mucalculus, as shown in the previous section. By using a well-known technique developed
for propositional dynamic logic (Parikh, 1981), (nondeterministic) modal mu-calculus formulae can be reduced to deterministic modal mu-calculus formulae (Streett & Emerson,
1984), as shown below.
We use the following notations for usual operations on binary relations:  for chaining,
 for reexive transitive closure, + for transitive closure, and , for converse. We also use
the following abbreviations:
[R ]
[R+ ]

for
for
hR i for
hR+i for

X:( ^ [R]X )
[R][R ]
X:( _ hRiX )
hRihR i:

The reduction is as follows: in a formula , we recursively replace each subformulae of
the form [R] by [R][(Rnew ) ] and each subformulae of the form hRi by hRih(Rnew ) i,
where Rnew is a new symbol and both R and Rnew in the resulting formula are interpreted
as partial functions. Let us call the resulting formula 0 , we have that  is satisfiable if and
only if 0 is satisfiable.
We briey sketch the reasoning behind the proof of this statement. The if direction
is easy: it suces to observe that if M D = (S D ; fRDi j i 2 LD g; V D ) is a model of 0 ,
then can transform it into a model M = (S ; fRi j i 2 Lg; V ) of  by defining S = S D ,
L = LD , new, RR = RDR  (RDnew ) , and V = V D . The only if direction is as follows. We
recall that both nondeterministic and deterministic modal mu-calculus have the tree model
property (Streett & Emerson, 1989, 1984): if a formula has a model it has a tree model,
i.e., a model having the form of a tree11 . So without loss of generality we can restrict our
attention to tree models only. Now there is a one-to-one transformation from tree models
M T = (S T ; fRTi j i 2 LT g; V T ) of  to (tree) models M B = (S B ; fRBi j i 2 LB g; V B ) of
0 . Indeed, we put S B = S T , V B = V T , LB = LT , and given a state x 2 S T having as
11. Given a model of  we get a tree model simply by \unfolding" the original one.

104

fiConcept Definitions in Description Logics

RTR -successors z1; : : : ; zl ,12 we put (x; z1 ) 2 RBR , and (zi ; zi+1 ) 2 RBRnew , for i = 1; : : : ; l , 1.
In this way we have (x; zi ) 2 RTR if and only if (x; zi ) 2 RBR  (RBRnew ) .13

We remark that M T is required to be a tree because once we get M B we need to recover
the \original" RTR -predecessor x of a state zi , namely we need (RBR  (RBRnew ) ), to be
a partial function, otherwise, given a state zi , we would not know which of the various
(RBR  (RBRnew ) ), -successors is its original RTR -predecessor x, and therefore we would not
be able to reconstruct M T from M B .
By interpreting R and Rnew as partial functions, it easy to express qualified number
 )-successors of a state. For example:
restrictions as constraints on the chain of (R  Rnew
( 3 R:) can be expressed by
[R][(Rnew ) ](: _ [(Rnew )+ ](: _ [(Rnew )+ ](: _ [(Rnew )+ ]:)))
and can be read as \everywhere along the chain R  (Rnew ) there are at most three states
where  holds", which corresponds exactly to the intended meaning. Similarly ( 3 R:)
can be expressed by

hRih(Rnew ) i( ^ h(Rnew )+i( ^ h(Rnew )+ i))
and can be read as \somewhere along the chain R  (Rnew ) there are at least three states
where  holds", which again corresponds exactly to the intended meaning.
The above discussion allows us to state the following result.

Theorem 8 There exists a polynomial function t mapping concepts of ALCQ to formulae
of deterministic modal mu-calculus such that: for any ALCQ concept C , C is satisfiable

if and only if u(C ) is satisfiable.

Proof The function t is defined inductively as follows:
u(A)
u(X )
u(C1 u C1 )
u(C1 t C2 )
u(:C )
u(X:C )
u(X:C )
u(9R:C )
u(8R:C )

A
X
u(C1 ) ^ u(C2 )
u(C1 ) _ u(C2 )
:u(C )
X:u(C )
X:u(C )
hRih(Rnew )iu(C )
[R][(Rnew ) ]u(C )
where Rnew is a new role. Finally, ( n R:C ) and ( n R:C ) are mapped to the following
=
=
=
=
=
=
=
=
=

formulae:

12. We implicitly assume that M T is a finite branching tree model. This can be done without loss of
generality since modal mu-calculus has the finite model property, and hence unfolding a finite model we
get a finite branching tree model. Note however that it would suce to assume M T to be a countable
branching tree model.
13. Note that this construction is similar to the one often used in programming to reduce n-ary trees to
binary trees by coding children of a node as the combination of one child and its siblings.

105

fiDe Giacomo & Lenzerini

u(( n R:C )) =[R][(Rnew ) ](:u(C ) _ [(Rnew )+](:u(C )_
[(Rnew )+ ](: : : (:u(C ) _ [(Rnew )+ ]:u(C )) : : :)))
where the number of nested formulae of the form :u(C ) _ [(Rnew )+ ] is n, and

u(( n R:C )) =hRih(Rnew ) i(u(C ) ^ h(Rnew )+i(u(C )^
h(Rnew )+i(: : : (u(C ) ^ h(Rnew )+iu(C )) : : :)))
where the number of nested formulae of the form u(C ) ^ h(Rnew )+ i is n , 1.
u(C ) is clearly polynomial in the size of C (under the usual assumption that numbers in
C coded in unary). Moreover, following the technique in (Parikh, 1981; Streett & Emerson,
1984) that as been exposed above, it is easy to verify, by induction on the formation of the
concept C , that the mapping t preserves satisfiability. 2
It follows that we may transfer both decidability and complexity results for the deterministic modal mu-calculus (Streett & Emerson, 1984; Emerson & Jutla, 1988; Safra,
1988) to ALCQ. Thus, we can immediately state what is the complexity of reasoning with
ALCQ concepts and ALCQ TBoxes.

Theorem 9 Satisfiability of ALCQ concepts, satisfiability of ALCQ TBoxes, and logical
implication in ALCQ TBoxes are EXPTIME-complete problems.
Proof Satisfiability in deterministic modal mu-calculus is an EXPTIME-complete problem

(Streett & Emerson, 1984; Emerson & Jutla, 1988; Safra, 1988). Hence by Theorem 8 and
Theorem 5 the thesis follows. 2

6. Discussion and Conclusion

The work presented in this paper stems out from (De Giacomo, 1993), where the basic ideas
of introducing explicit fixpoint was first presented, and (De Giacomo & Lenzerini, 1994b),
where such idea was further elaborated and ALCQ was first introduced.
One of the main contributions of this work has been to devise a tight correspondence
between description logics with fixpoints and modal mu-calculus. In this respect we remark
that, while ALC corresponds directly to modal mu-calculus, the full ALCQ corresponds
to a variant of modal mu-calculus whose decidability and complexity had not been studied.
More precisely, a notion essentially equivalent to that of qualified number restrictions has
independently emerged in modal logics, namely that of graded modalities (Van der Hoek
& de Rijke, 1995; Van der Hoek, 1992; Fattorosi-Barnaba & De Caro, 1985; Fine, 1972).
However the combination of fixpoints and graded modalities had not been investigated
before in the setting of modal logics. Given the tight correspondence between ALC and
modal mu-calculus, ALCQ can be considered as modal mu-calculus augmented with graded
modalities. Hence the results in this paper apply to such a logic as well.
The research reported in this paper bears several similarities with the one on the correspondence between description logics and propositional dynamic logics (Baader, 1991;
106

fiConcept Definitions in Description Logics

Schild, 1991; De Giacomo & Lenzerini, 1994a, 1995; De Giacomo, 1995). In fact what characterize description logics based on propositional dynamic logics are the role constructs for
chaining, choice, test, and above all reexive transitive closure of roles, which is a limited
form of fixpoint. Such role constructs can be easily expressed by using the explicit fixpoints
introduced here. It suce to resort to the following equivalences:
9R1  R2 :C = 9R1:9R2:C
9R1 t R2:C = 9R1:C t 9R2:C
9R:C = X:(C t 9R:X )
9id(D):C = C u D:
Note that 8R :C = X:(C u 8R:X ). In (Calvanese, De Giacomo, & Lenzerini, 1995)
a further implicit form of fixpoint has been advocated, the so called well-founded role
construct wf (R). By explicit fixpoints, wf (R) is expressed simply as X:(8R:X ).
Our proposal of allowing for fixpoint constructs explicitly in the formalism is shared
by the study independently carried out by Schild in (Schild, 1994)14 . The main goal of
that work is to study both the expressive power and the computational complexity of
subsumption and satisfiability for TBoxes expressed in ALC (no fixpoint constructs), that
allow for mutually recursive definitions. To this end, a description logic is defined that
corresponds to a variant of the modal mu-calculus in which mutual fixpoints are allowed
but some restrictions on nested fixpoints are enforced (Vardi & Wolper, 1984). It is well
known that mutual fixpoints can be re-expressed by means of nested ones (see, for example,
Park, 1976; de Bakker, 1980). As a consequence of this observation it follows that the logic
introduced in this paper, is more expressive than the one analyzed in (Schild, 1994) since,
on the one hand, it allows nesting of fixpoints without any restriction, on the other hand
it makes it possible to state sophisticated forms of cardinality constraints on role fillers by
means of qualified number restrictions.
The present work can be extended along several directions. We conclude by outlining
two of them.
We already noticed that fixpoint constructs allow for representing not only abstract
classes, but also several data structures extensively used in software development. We
believe that this characteristic is an important step towards a satisfactory integration of
description logics with both traditional and declarative programming systems. Indeed the
description logic proposed in this paper provides powerful mechanisms for data structure
modeling. In particular, the properties stated in Section 4.1 can be the base to formulate a
notion of parametric concept15 . For instance, the expression (named dag of [Z ])
X : emptydag t (Z u 9arc:> u 8arc:X )
where Z is a formal parameter, denotes the class of DAGs whose nodes are left unspecified.
This class can be used in several ways in the TBox. For example, it can be instantiated
by binding the formal parameter to actual parameters, thus getting, say, dag of [student],
dag of [person], etc., which are concepts inheriting the properties of dag of [Z ].
14. In (Schild, 1994) number restrictions are not considered.
15. Note that parametric concepts can be introduced also in simpler logics which do not include fixpoint
constructs.

107

fiDe Giacomo & Lenzerini

Although ALCQ is a powerful logic, it lacks the construct for inverse roles which is
needed for example to correctly capture the notions of (finite) TREE, BINARY-TREE, etc.
Indeed, to define the concept of TREE (an EMPTY-TREE is a TREE; a NODE that has
at most one parent, some children, and all children are TREEs, is a TREE; nothing else is a
TREE) we can write tree  X : empty tree t (node u ( 1 child, :>) u9child:>u8child:X
where child, denotes the inverse of child. Notice that the introduction of inverse roles
does not pose any diculty from the semantical point of view; however, its impact on
the reasoning method needs to be investigated. More generally, a wide variety of concept
constructs can be studied in conjunction with fixpoints. The research on description logics
related to propositional dynamic logics in (De Giacomo & Lenzerini, 1994a, 1995; Calvanese
et al., 1995; De Giacomo, 1995) may give us hints on how to proceed along this direction.

References

Baader, F. (1990). Terminological cycles in KL-ONE-based knowledge representation languages. In Proc. of the 8th Nat. Conf. on Artificial Intelligence (AAAI-90), pp.
621{626 Boston, Ma.
Baader, F. (1991). Augmenting concept languages by transitive closure of roles: An alternative to terminological cycles. In Proc. of the 12th Int. Joint Conf. on Artificial
Intelligence (IJCAI-91) Sydney, Australia.
Beeri, C. (1990). A formal approach to object-oriented databases. Data and Knowledge
Engineering, 5, 353{382.
Beneventano, D., & Bergamaschi, S. (1992). Subsumption for complex object data models.
In Proc. of the 4th Int. Conf. on Database Theory (ICDT-92), No. 646 in Lecture
Notes in Computer Science, pp. 357{375. Springer-Verlag.
Bergamaschi, S., & Sartori, C. (1992). On taxonomic reasoning in conceptual design. ACM
Transaction on Database Systems, 17 (3), 385{422.
Borgida, A. (1992). From type systems to knowledge representation: Natural semantics
specifications for description logics. Journal of Intelligent and Cooperative Information
Systems, 1 (1), 93{126.
Calvanese, D., De Giacomo, G., & Lenzerini, M. (1995). Structured objects: modeling and
reasoning. In Proc. of the 4th Int. Conf. on Deductive and Object-Oriented Databases
(DOOD-95), Lecture Notes in Computer Science. Springer-Verlag.
Cleaveland, R. (1990). Tableaux-based model checking in the propositional mu-calculus.
Acta Informatica, 27, 725{747.
Dam, M. (1992). CTL* and ECTL* as fragments of the modal mu-calculus. In Proceeding of
the Col. on Trees and Algebra in Programming, No. 581 in Lecture Notes in Computer
Science, pp. 145{164. Springer-Verlag.
de Bakker, J. (1980). Mathematical Theory of Program Correctness. Prentice-Hall.
108

fiConcept Definitions in Description Logics

De Giacomo, G. (1993). Reconciling different semantics for concept definition (extended
abstract). In Proc. of the 1st COMPULOG Net Meeting on Knowledge Representation
and Reasoning Systems (CNKRR-93).
De Giacomo, G. (1995). Decidability of Class-Based Knowledge Representation Formalisms.
Ph.D. thesis, Dipartimento di Informatica e Sistemistica, Universita di Roma \La
Sapienza".
De Giacomo, G., & Lenzerini, M. (1994a). Boosting the correspondence between description
logics and propositional dynamic logics. In Proc. of the 12th Nat. Conf. on Artificial
Intelligence (AAAI-94), pp. 205{212. AAAI-Press/the MIT-Press.
De Giacomo, G., & Lenzerini, M. (1994b). Concept language with number restrictions and
fixpoints, and its relationship with mu-calculus. In Proc. of the 11th Eur. Conf. on
Artificial Intelligence (ECAI-94), pp. 411{415. John Wiley and Sons.
De Giacomo, G., & Lenzerini, M. (1995). What's in an aggregate: foundation for description
logics with tuples and set. In Proc. of the 14th Int. Conf. on Artificial Intelligence
(IJCAI-95).
Emerson, E. A., & Jutla, C. S. (1988). The complexity of tree automata and logics of
programs. In Proc. of the 20th An. Symp. on the Foundations of Computer Science
(FOCS-88), pp. 328{337.
Fattorosi-Barnaba, M., & De Caro, F. (1985). Graded modalities I. Studia Logica, 44,
197{221.
Fine, K. (1972). In so many possible worlds. Notre Dame Journal of Formal Logic, 13 (4),
516{520.
Kozen, D. (1983). Results on the propositional mu-calculus. Theoretical Computer Science,
27, 333{355.
Kozen, D., & Parikh, R. (1983). A decision procedure for the propositional mu-calculus. In
Proc. of the 2nd Work. on Logic of Programs, No. 164 in Lecture Notes in Computer
Science, pp. 313{325. Springer-Verlag.
Larsen, K. J. (1990). Proof systems for satisfiability in Hennessy-Milner logic with recursion.
Theoretical Computer Science, 72, 265{288.
Nebel, B. (1990). Reasoning and Revision in Hybrid Representation Systems. No. 422 in
Lecture Notes in Artificial Intelligence. Springer-Verlag.
Nebel, B. (1991). Terminological cycles: Semantics and computational properties. In Sowa,
J. F. (Ed.), Principles of Semantic Networks, pp. 331{361. Morgan Kaufmann, Los
Altos.
Parikh, R. (1981). Propositional dynamic logic of programs: A survey. In Proc. of the
1st Work. on Logic of Programs, No. 125 in Lecture Notes in Computer Science, pp.
102{144. Springer-Verlag.
109

fiDe Giacomo & Lenzerini

Park, D. (1976). Finiteness is mu-ineffable. Theoretical Computer Science, 3, 173{181.
Safra, S. (1988). On the complexity of !-automata. In Proc. of the 20th An. Symp. on the
Foundations of Computer Science (FOCS-88), pp. 319{327.
Schild, K. (1991). A correspondence theory for terminological logics: Preliminary report. In
Proc. of the 12th Int. Joint Conf. on Artificial Intelligence (IJCAI-91), pp. 466{471
Sydney, Australia.
Schild, K. (1994). Terminological cycles and the propositional -calculus. In Doyle, J.,
Sandewall, E., & Torasso, P. (Eds.), Proc. of the 4th Int. Conf. on the Principles
of Knowledge Representation and Reasoning (KR-94), pp. 509{520 Bonn. Morgan
Kaufmann, Los Altos.
Schmidt-Schau, M., & Smolka, G. (1991). Attributive concept descriptions with complements. Artificial Intelligence, 48 (1), 1{26.
Stirling, C. (1992). Modal and temporal logic. In Abramsky, S., Gabbay, D. M., & Maibaum,
T. S. E. (Eds.), Handbook of Logic in Computer Science, pp. 477{563. Clarendon Press,
Oxford.
Streett, R. S., & Emerson, E. A. (1984). The propositional mu-calculus is elementary. In
Proc. of the 6th Int. Col. on Automata, Languages and Programming, No. 172 in
Lecture Notes in Computer Science, pp. 465{472. Springer-Verlag.
Streett, R. S., & Emerson, E. A. (1989). An automata theoretic decision procedure for the
propositional mu-calculus. Information and Control, 81, 249{264.
Tarski, A. (1955). A lattice-theoretical fixpoint theorem and its applications. Pacific Journal
of Mathematics, 5, 285{309.
Van der Hoek, W. (1992). On the semantics of graded modalities. Journal of Applied
Non-Classical Logics, 2 (1), 81{123.
Van der Hoek, W., & de Rijke, M. (1995). Counting objects. Journal of Logic and Computation, 5 (3), 325{345.
Vardi, M. Y., & Wolper, P. (1984). Automata theoretic techniques for modal logics of
programs. In Proc. of the 16th An. Symp. on the Foundations of Computer Science
(FOCS-84), pp. 446{456.
Winsket, G. (1989). A note on model checking the modal  -calculus. In Proc. of the 11th
Int. Col. on Automata, Languages and Programming, No. 372 in Lecture Notes in
Computer Science, pp. 761{772. Springer-Verlag.

110

fi