Journal of Artificial Intelligence Research 47 (2013) 575-611

Submitted 02/13; published 07/13

A Refined View of Causal Graphs and Component Sizes:
SP-Closed Graph Classes and Beyond
Christer Backstrom
Peter Jonsson

christer.backstrom@liu.se
peter.jonsson@liu.se

Department of Computer Science
Linkoping University
SE-581 83 Linkoping, Sweden

Abstract
The causal graph of a planning instance is an important tool for planning both in
practice and in theory. The theoretical studies of causal graphs have largely analysed the
computational complexity of planning for instances where the causal graph has a certain
structure, often in combination with other parameters like the domain size of the variables.
Chen and Gimenez ignored even the structure and considered only the size of the weakly
connected components. They proved that planning is tractable if the components are
bounded by a constant and otherwise intractable. Their intractability result was, however,
conditioned by an assumption from parameterised complexity theory that has no known
useful relationship with the standard complexity classes. We approach the same problem
from the perspective of standard complexity classes, and prove that planning is NP-hard
for classes with unbounded components under an additional restriction we refer to as SPclosed. We then argue that most NP-hardness theorems for causal graphs are difficult to
apply and, thus, prove a more general result; even if the component sizes grow slowly and
the class is not densely populated with graphs, planning still cannot be tractable unless the
polynomial hierachy collapses. Both these results still hold when restricted to the class of
acyclic causal graphs. We finally give a partial characterization of the borderline between
NP-hard and NP-intermediate classes, giving further insight into the problem.

1. Introduction
We will first briefly explain what a causal graph is and give a short survey of applications
as well as theoretical results reported in the literature. Following that, we give an overview
of the new results presented in this article.
1.1 Background
The causal graph for a planning instance is an explicit description of the variable dependencies that are implicitly defined by the operators. More precisely, it is a directed graph
such that there is an arc from a variable x to another variable y if either x appears in the
precondition of an operator with an effect on y or some operator has effects on both x and y.
This standard definition of the causal graph can be traced back to Knoblock (1994)
although he did not give it a name. He used the causal graph in the Alpine algorithm,
as a guidance for partitioning and ordering the variables in the process of automatically
deriving state abstraction hierarchies. The actual name causal graph can be traced back
to Williams and Nayak (1997). Their approach was both more general and more restricted
c
2013
AI Access Foundation. All rights reserved.

fiBackstrom & Jonsson

than Knoblocks. On the one hand, they generalized the concept from binary variables to
multi-valued variables, but on the other hand, they considered only acyclic causal graphs
which implies that all operators are unary, i.e. every operator changes only one variable.
The context of their work was the reactive planner Burton for onboard space-ship control.
A causal model was compiled into a transition system that could be efficiently exploited by a
reactive controller to choose appropriate operators to achieve given goals. The compilation
was done in such a way that all operators were unary, and they claimed that this is often
possible in real applications. The resulting acyclicity of the causal graph was then exploited
by Burton, which traversed the graph bottom up in order to issue operators in an order
consistent with their causal relationships.
Jonsson and Backstrom (1998b) also studied acyclic causal graphs, but referred to them
as dependency graphs. They considered a subclass of such graphs having a particular structure and used this to implicitly define a corresponding class of planning instances, the 3S
class. This class has the property that it is always possible to decide in polynomial time if
there is a solution or not, but the solutions themselves may be of exponential length, thus
necessarily taking exponential time to generate. Although only one single restricted case,
the 3S class is probably the first example of relating structural properties of the causal graph
to the computational complexity of planning. A more general and extensive such analysis
was done by Domshlak and Dinitz (2001a), who analysed the complexity of planning for
classes of instances corresponding to a number of different possible structures of acyclic
causal graphs. However, their work was done in the context of multi-agent coordination
and the term causal graph was never used.
The first two of these papers may be viewed as early examples of exploiting the causal
graph in practice, while the latter papers form the starting point of the subsequent theoretical research into the relationships between planning complexity and the structure of
causal graphs.
An important step forward in the usage of causal graphs was the paper by Helmert
(2004) where he demonstrated that the causal graph is particularly useful in the context of
multi-valued variables. Previous research on the complexity of planning with multi-valued
variables had focussed on the structure of the domain-transition graphs for the variables
(Jonsson & Backstrom, 1998a), rather than the causal graph. Helmert realized the power
of using both the domain-transition graphs and the causal graph in heuristic planning.
This was exploited in practice in his highly succesful Fast Downward planner (Helmert,
2006a). It translates PDDL planning instances with binary variables into a representation
with multi-valued variables and then removes carefully chosen edges in the resulting causal
graph to make it acyclic. The resulting causal graph is then used to compute a heuristic
by hierarchically computing and composing plan lengths for subgraphs having one of the
particular structures studied by Domshlak and Dinitz (2001a). Somewhat similarly, Katz
and Domshlak (2010) identified subgraphs of the causal graph that have certain structures
that make planning for them tractable. They exploited this to be able to use larger variables
sets when constructing pattern databases. A further example of exploiting the causal graph
to make planning more efficient is the paper on factored planning by Brafman and Domshlak
(2006). They showed that the structure of the causal graph can be used as a guide for
deciding if and how a planning instance can be solved more efficiently by dividing it into
loosely coupled subinstances and use constraint processing. The basic idea of the causal
576

fiA Refined View of Causal Graphs and Component Sizes

graph to represent variable dependencies is, of course, quite general and not necessarily
restricted to planning. For instance, Wehrle and Helmert (2009) transferred the causal
graph concept to the context of model checking.
As previously mentioned, the two papers by Jonsson and Backstrom (1998b) and by
Domshlak and Dinitz (2001a) can be viewed as the starting point for a successful line of
research into studying the relationships between planning complexity and the structure
of the causal graph. While the 3S class by Jonsson and Backstrom was a very limited
special case, Domshlak and Dinitz studied classes of planning instances corresponding to a
number of more general graph structures, like in-stars (aka. inverted forks), out-stars (aka.
forks), directed path graphs (aka. directed chain graphs), polytrees and singly-connected
DAGs. Further results followed, for instance, in articles by Brafman and Domshlak (2003),
and Gimenez and Jonsson (2008). The latter article additionally showed that although 3S
instances can have exponential-length plans, it is possible to generate a macro representation
of such a plan in polynomial time, a result they extended also to some other classes defined
by the structure of the causal graph. Many of the complexity results in these papers use
additional numerical parameters in conjunction with the graph structure. Examples of such
parameters are the maximum domain size of the variables and the maximum in-degree of
the graph. While increasing the number of possible cases to analyse, it does allow for a
more fine-grained analysis in many cases. Consider for instance the case of directed path
graphs. Domshlak and Dinitz (2001a) proved that it is tractable to decide if there is a
plan for this case when the domains are binary, while Gimenez and Jonsson (2009) proved
that a domain size of 5 is sufficient to make the problem NP-hard. Similarly, Gimenez and
Jonsson (2012) proved tractability for planning instances with binary variables, a constant
number of prevail conditions and where the causal graph is a polytree. Also the paper
by Brafman and Domshlak (2006) fits into this line of theoretical research, exhibiting a
planning algorithm that runs in time exponential in two parameters, the tree-width of the
undirected version of the causal graph and the maximum number of times a variable must
change value.
While most research has been based on the standard definition of causal graphs that
was set already by Knoblock, although often in the generalisation to multi-valued variables,
there are important exceptions. One potential problem with the standard defintion is that
whenever two variables are both affected by the same operator, then the causal graph must
necessarily contain cycles, which is the major reason why the focus has mainly been on
planning with unary operators. In an attempt to circumvent this problem, Jonsson (2009)
defined a more relaxed variant of the causal graph that does not always introduce cycles for
non-unary operators, which can sometimes allow for a more fine-grained complexity analysis.
The previous results relate the structure of the causal graph to the complexity of satisficing planning, i.e. deciding if there is a plan. There has also been a corresponding branch
of research relating the structure of the causal graph to the complexity of cost-optimal
planning (cf., Katz & Domshlak, 2007, 2008, 2010; Katz & Keyder, 2012).
1.2 Our Contributions
All of the theoretical research above studies the complexity of planning based on the structure of the causal graph, and possibly other parameters like domain sizes. An important
577

fiBackstrom & Jonsson

milestone that deviates from this line of research was an article by Chen and Gimenez
(2010) who did not even consider the structure of the causal graph but only a simple quantitative measure, the size of the weakly connected components. They proved that deciding
if there is a plan can be done in polynomial time if and only if the size of the weakly connected components in the causal graph is bounded by a constant. In one sense, this is a
very sharp and final result. However, the intractability result for unbounded components is
conditional on the assumtion that W[1] 6 nu-FPT. This assumption relies on the theory
of parameterised complexity theory and neither the complexity classes nor the assumption
itself can be related to ordinary complexity classes in a clear way. Chen and Gimenez acknowledge that the problems they prove conditionally intractable include NP-intermediate
problems. Hence, we take their result as a take-off point for further investigation of how
the component sizes reflect on the standard complexity classes. Since we know from Chen
and Gimenez that not all graph classes with unbounded components are NP-hard we must
consider further restrictions in order to find NP-hard classes. We do so by adding a new
type of closure property, SP-closure, which is incomparable to subset-closure but is a subset of minor-closure, and prove that planning is NP-hard for any SP-closed graph class
with unbounded components. It should be noted that this result still holds for the class
of all acyclic graphs, which is important considering the practical relevance of acyclicity
previously mentioned.
While many graph classes that have been studied in the literature are indeed SP-closed,
there also exists natural classes that lack this property. We present one way of handling
such classes with the aid of non-uniform complexity theory. In this case, we are not able to
show NP-hardness but we can show that the polynomial hierarchy collapses to its second
level. This is a fairly general result that can be applied even when the component sizes grow
very slowly and the graph class is not very densely populated with graphs. Also this result
holds even if restricted to acyclic graphs. This result can be used to demonstrate clearly
that complexity results for planning based only on the class of causal graphs does not necessarily have any connection to the complexity of a generic planning problem having the same
class of causal graphs. This result also raises the question of where to find (preferably natural) NP-intermediate planning problems. Chen and Gimenez state that NP-intermediate
problems can be obtained by using methods similiar to the ones employed by Bodirsky and
Grohe (2008). Such problems are hard to describe as natural, though. They are based on
Ladners (1975) diagonalization technique that removes a large fraction of input strings from
a problem. It is apparently difficult to connect graph classes constructed by this technique
with simple conditions on component growth. As an alternative, we show that graph classes
where the component sizes grow polylogarithmically are NP-intermediate under the double
assumption that W[1] 6 nu-FPT and that the exponential time hypothesis (Impagliazzo
& Paturi, 2001) holds. We also show that for every k > 1, there exists a class Gk of graphs
such that component size is bounded by |V (G)|1/k for all G  Gk and the corresponding
planning problem is NP-hard. These results coarsely stake out the borderline between
NP-hard and NP-intermediate classes.
A possible conclusion from this paper is that complexity analysis of planning based only
on the structure of the causal graph is of limited value, and that additional parameters are
needed to achieve more useful results. While this may be a fair conclusion in general, there
are cases where the graph structure is sufficient. For instance, Katz, Hoffmann, and Domsh578

fiA Refined View of Causal Graphs and Component Sizes

lak (2013) have applied the result by Chen and Gimenez (2010) in the context of so called
red-black planning, a variant of delete relaxation for computing heuristics. Furthermore,
even when the structure of the causal graph has to be combined with other parameters, it
is still important to know the behaviour of each parameter in isolation.
The remainder of the article is structured as follows. In Section 2 we set the notation
and terminology used for planning and for graphs, and in Section 3 we define causal graphs
and structural planning in general. Section 4 contains a number of NP-hardness results for
various special graph classes that we need for the main results. The first of the two main
theorems of the article appears in Section 5, where we define the concept of SP-closed graph
classes and prove that planning is NP-hard for such classes when the component size is
unbounded. Section 6 discusses some of the problems with both the previous theorem and
other similar results in the literature. As a way around these problems, our second main
theorem shows that even without any closure requirements, planning is likely to be hard
even when the components grow slowly and the graphs do not appear densely in the class.
Section 7 contains some observations concerning the borderline between NP-intermediate
and NP-hard planning problems. The article ends with a discussion section.

2. Preliminaries
This section sets the terminology and notation for planning and graphs used in this article.
We write |X| to denote the cardinality of a set X or the length of a sequence X, i.e. the
number of elements in X, and we write ||X|| to denote the size of the representation of an
object X.
2.1 Planning
Since this article has many connections with the one by Chen and Gimenez (2010) we
follow their notation and terminology for plannning, which is a notational variant of SAS+
(Backstrom & Nebel, 1995).
An instance of the planning problem is a tuple  = (V, init, goal, A) whose components
are defined as follows:
 V is a finite set of variables, where each variable v  V has an associated finite domain
D(v). Note that variables are not necessarily propositional, that is, D(v) may be any
finite set. A state is a mapping s defined on the variables V such that s(v)  D(v) for
all v  V . A partial state is a mapping p defined on a subset vars(p) of the variables V
such that for all v  vars(p), it holds that p(v)  D(v), and p is otherwise undefined.
 init is a state called the initial state.
 goal is a partial state.
 A is a set of operators; each operator a  A consists of a precondition pre(a) and
a postcondition post(a) which are both partial states. We often use the notation
hpre ; posti to define an operator with precondition pre and postcondition post. For
instance, a = hx = 0, y = 1 ; z = 1i defines an operator a which is applicable in any
state s such that s(x) = 0 and s(y) = 1, and which has the effect of setting variable
z to 1.
579

fiBackstrom & Jonsson

When s is a state or a partial state and W is a subset of the variable set V , we write
s  W to denote the partial state resulting from restricting s to W . We say that a state s is
a goal state if goal = s  vars(goal).
We define a plan (for an instance ) to be a sequence of operators P = a1 , . . . , an .
Starting from a state s, we define the state resulting from s by applying a plan P , denoted
by s[P ], inductively as follows. For the empty plan P = , we define s[] = s. For non-empty
plans P we define s[P ] as follows, where a is the last operator in P and P 0 is the prefix of
P up to, but not including, a:
 If pre(a) 6= s[P 0 ]  vars(pre(a)) (that is, the preconditions of a are not satisfied in the
state s[P 0 ]), then s[P 0 , a] = s[P 0 ].
 Otherwise, s[P 0 , a] is the state equal to post(a) on variables v  vars(post(a)), and
equal to s[P 0 ] on variables v  V \ vars(post(a)).
A plan P is a solution plan if init[P ] is a goal state.
We are concerned with the computational problem plan existence (PlanExist): given an
instance  = (V, init, goal, A), decide if there exists a solution plan.
2.2 Graphs
A directed graph is a pair (V, E) where V is the vertex set and E  V  V is the edge set.
An undirected graph is a pair (V, E) where V is the vertex set and E  {{u, v} | u, v  V }
is the edge set. We will often only say graph and edge if it is clear from the context whether
it is directed or undirected. The notation V (G) refers to the vertex set of a graph G and
E(G) refers to its edge set. If e = (u, v) or e = {u, v} is an edge, then the vertices u and
v are incident with e. Furthermore, the directed edge (u, v) is an outgoing edge of u and
an incoming edge of v. For a directed graph G = (V, E), we write U (G) to denote the
correspsonding undirected graph U (G) = (V, EU ) where EU = {{u, v} | (u, v)  E}. That
is, U (G) is the undirected graph induced by G by ignoring the orientation of edges.
Let G = (V, E) be a directed graph and let v0 , . . . , vk  V such that v1 , . . . , vk are
distinct and (vi1 , vi )  E for all i (1  i  k). Then the sequence v0 , . . . , vk is a directed
path of length k in G if v0 6= vk and it is a directed cycle of length k in G if v0 = vk . Paths
and cycles in undirected graphs are defined analogously, except that there is no direction
to consider. A graph is acyclic if it contains no cycles.
Let G = (V, E) be a directed graph and let v  V be a vertex. Then, v is isolated if it
has no incoming or outgoing edges, v is a source if it has at least one outgoing edge but no
incoming edge, v is a sink if it has at least one incoming edge but no outgoing edge and
otherwise v is intermediate.
Let G = (VG , EG ) and H = (VH , EH ) be two directed graphs. Then G and H are
isomorphic (denoted G ' H) if there exists a bijective function f : VG  VH such that
(u, v)  EG if and only if (f (u), f (v))  EH . Furthermore, H is a subgraph of G if VH  VG
and EH  EG  (VH  VH ). When EH = EG  (VH  VH ) we say that the subgraph H
is induced by the vertex set VH . Isomorphisms and subgraphs are analogously defined for
undirected graphs.
Let G be an undirected graph. Then G is connected if there is a path between every
pair of vertices in G. A connected component of G is a maximal subgraph of G that is
580

fiA Refined View of Causal Graphs and Component Sizes

connected. Let G be a directed graph. Then G is weakly connected if U (G) is connected.
A weakly connected component of G is a maximal subgraph of G that is weakly connected.
That is, in a weakly connected component there are paths between every pair of vertices
if we ignore the direction of edges. Let G = (VG , EG ) and H = (VH , EH ) be two directed
graphs such that VG and VH are disjoint. Then the (disjoint) union of G and H is defined
as G  H = (VG  VH , EG  EH ) and is a commutative operation. Note that if a graph G
consists of the (weakly) connected components G1 , . . . , Gn , then G = G1  G2  . . .  Gn .
We further define some numeric graph parameters. For a directed graph G and a vertex
v  V (G), the indegree of v is |{u  V (G) | (u, v)  E(G)}|, i.e. the number of incoming
edges incident with v, and the outdegree of v is |{u  V (G) | (v, u)  E(G)}|, i.e. the number
of outgoing edges incident with v. For an undirected graph G, the degree of v  V (G) is
|{u  V (G) | {v, u}  E(G)}|, i.e. the number of edges incident with v. We extend this to
graphs as follows. If G is an undirected graph, then deg(G) denotes the largest degree of
any vertex in V (G). Similarly, if G is a directed graph then in-deg(G) denotes the largest
indegree of any vertex in V (G) and out-deg(G) denotes the largest outdegree of any vertex in
V (G). Furthermore, if G is an undirected graph, then path-length(G) denotes the length of
the longest path in G and cc-size(G) denotes the size of the largest connected component in
G. If G is a directed graph, then path-length(G) denotes the length of longest directed path
in G. We also define upath-length(G) = path-length(U (G)) and cc-size(G) = cc-size(U (G)).
That is, upath-length(G) is the length of the longest path in G if ignoring the direction of
edges and cc-size(G) is the size of the largest weakly connected component in G. Note that
if G is an undirected connected graph, then path-length(G) equals the diameter of G. We
extend all such numeric graph properties (in-deg, path-length etc.) to sets of graphs such
that if C is a set of graphs and prop is a graph property, then prop(C) = maxGC prop(G).
2.3 Special Graph Types
In the literature on causal graphs, as well as in this article, there are certain types of graphs
that are of particular interest and that are thus useful to refer to by names. We distinguish
the following types of undirected graphs: A tree is an undirected graph in which any two
vertices are connected by exactly one path, i.e. it is acyclic and connected. A path graph
is a tree where all vertices have degree 1 or 2, i.e. it is a tree that does not branch. A star
graph is a tree where all vertices except one, the centre vertex, have degree 1.
For directed graphs, we distinguish the following types: An in-star graph is a directed
graph G such that U (G) is a star graph and all edges are directed towards the centre.
An out-star graph is a directed graph G such that U (G) is a star graph and all edges are
directed out from the centre. A directed path graph is a directed graph G such that U (G)
is a path graph, in-deg(G)  1 and out-deg(G)  1, i.e. G is a directed path over all its
vertices and contains no other edges. A polytree is a directed graph G such that U (G) is
a tree, i.e. G is a weakly connected directed graph that can be constructed from a tree by
giving a unique direction to every edge. A polypath is a directed graph G such that U (G)
is a path graph, i.e. G is a weakly connected directed graph that can be constructed from
a path graph by giving a unique direction to every edge. A fence is a polypath where every
vertex is either a source or a sink, i.e. the edges alternate in direction at every vertex.
581

fiBackstrom & Jonsson

It should be noted that the out-star graph is usually called a directed star graph in
graph theory, while the in-star graph appears to have no standard name. We hence deviate
sligthly from standard terminology in order to have logical names for both graph types.
Also the polypath appears to have no standard name, but polypath is a logical term in
analogy with polytree. It should be further noted that a parallel terminology for certain
graph types has evolved in the literature on causal graphs in planning. For instance, instars, out-stars and directed paths are commonly referred to as inverted forks, forks and
directed chains, respectively.
Note that the number of sinks and sources in a polypath differ by at most one, i.e. a
polypath with m sinks has m + c sources for some c  {1, 0, 1}. Furthermore, every fence
is a polypath, but not every polypath is a fence.
We define the following graphs and graphs classes:
 Skin denotes the in-star graph with one centre vertex and k sources. Also define the
class Sin = {Skin | k  0}.
 Skout denotes the out-star with one centre vertex and k sinks. Also define the class
Sout = {Skout | k  0}.
 dPk denotes the directed path on k vertices. Also define the class dP = {dPk | 1  k}.
c , for c  {1, 0, 1}, denotes the fence with m sinks and m + c sources. Also define
 Fm
c | 1  m}, for each c  {1, 0, 1}, and the class F = F1 F0 F+1 .
the class Fc = {Fm

Examples of these graph types are illustrated in Figure 1.

v1
v5

v1
v2

vc
v4

v5

v3

v2

vc
v4

v0

v1

v2

v1

v2
u1

v3
u2

F31

v4

v3
S5out

S5in

v3

dP5

v1
u0

v2
u1

v3
u2

v1
u0

F30

v2
u1

v3
u2

u3

F3+1

Figure 1: Examples of some important graph types.
The following observation about polypaths will be used later on.
Proposition 1. Let G be a polypath with at most m sinks and m + 1 sources such that
path-length(G)  k. Then |V (G)|  2mk + 1.
582

fiA Refined View of Causal Graphs and Component Sizes

Proof. There are at most 2m distinct paths from a source to a sink, each of these having at
most k  1 intermediate vertices. Hence |V (G)|  m + (m + 1) + 2m(k  1) = 2mk + 1.
This bound is obviously tight in the case where there are m sinks and m + 1 sources, and
every path from a source to a sink contains exactly k  1 intermediate vertices.

3. Structurally Restricted Planning
The topic of study in this article is causal graphs for planning, but before discussing this
concept we first define the concept of domain-transition graphs (Jonsson & Backstrom,
1998a). Although not used explicitly in any of our results, it is useful for explaining some
of the proofs later in the article. Let  = (V, init, goal, A) be a planning instance. For each
variable v  V , we define the domain-transition graph (DTG) for v as a directed graph
(D(v), E), where for all x, y  D(v), E contains the edge (x, y) if there is some operator
a  A such that post(a)(v) = y and either pre(a)(v) = x or v 6 vars(pre(a)).
The causal graph for a planning instance describes how the variables of the instance
depends on each other, as implicitly defined by the operators.
Definition 2. The causal graph of a planning instance  = (V, init, goal, A) is the directed
graph CG() = (V, E) where E contains the edge (u, v) for every pair of distinct vertices u, v  V such that u  vars(pre(a))  vars(post(a)) and v  vars(post(a)) for some
operator a  A.
The causal graph gives some, but not all, information about the operators. For instance,
if the causal graph is acyclic, then all operators must be unary, i.e. |vars(post)(a)| = 1 for
all operators, since any non-unary operator must necessarily introduce a cycle according
to the definition. However, the presence of cycles does not necessarily mean that there are
non-unary operators. For instance, if both the edges (u, v) and (v, u) are present in the
graph, then this can mean that there is some operator a such that both u  vars(post(a))
and v  vars(post(a)). However, it can also mean that there are two operators a and a0 such
that u  vars(pre(a)), v  vars(post(a)), v  vars(pre(a0 )) and u  vars(post(a0 )), which could
thus both be unary operators. Similarly, the degree of the vertices provides an upper bound
on the number of pre- and postconditions of the operators, but no lower bound. Suppose
there is a vertex u with indegree 2 and incoming edges (v, u) and (w, u). This could mean
that there is some operator a such that u  vars(post(a)) and both v  vars(pre(a)) and
w  vars(pre(a)). However, it can also mean that there are two different operators a and a0
such that v  vars(pre(a)), u  vars(post(a)), w  vars(pre(a0 )) and u  vars(post(a0 )).
The PlanExist problem is extended from planning instances to causal graphs in the
following way. For a class C of directed graphs, PlanExist(C) is the problem of deciding
for an arbitrary planning instance  such that CG()  C, whether  has a solution or
not. That is, the complexity of PlanExist(C) refers to the complexity of the set of planning
instances whose causal graphs are members of C.
There are a number of results in the literature on the computational complexity of
planning for various classes of causal graphs. However, these results usually assume that
the graph class has a restricted structure, e.g. containing only in-stars or only directed
paths. A more general and abstract result is the following theorem.
583

fiBackstrom & Jonsson

Theorem 3. (Chen & Gimenez, 2010, Thm. 3.1) Let C be a class of directed graphs.
If cc-size(C) is bounded, then PlanExist(C) is solvable in polynomial time. If cc-size(C) is
unbounded, then PlanExist(C) is not polynomial-time solvable (unless W[1]  nu-FPT).
While the theorem describes a crisp borderline between tractable and intractable graph
classes, it does so under the assumption that W[1] 6 nu-FPT1 . Both these complexity
classes are from the theory of parameterised complexity and cannot be immediately related
to the usual complexity classes. It is out of the scope of this article to treat parameterised
complexity and we refer the reader to standard textbooks (Downey & Fellows, 1999; Flum
& Grohe, 2006). The result in the theorem is not a parameterised result, however; it is only
the condition that is parameterised, so it suffices to note that the intractability result holds
under a condition that is difficult to relate to other common assumptions, such as P 6= NP.
One of the reasons why Chen and Gimenez were forced to state the theorem in this way was
that a classification into polynomial and NP-hard classes would not have been exhaustive,
since there are graph classes that are NP-intermediate. (A problem is NP-intermediate if
it is neither in P nor NP-complete, unless P = NP.)
This theorem might be viewed as the starting point for the research reported in this
article, where we investigate this problem from the perspective of standard complexity
classes. For instance, NP-hardness can be proved in the case of unbounded components if
adding further restrictions, which we will do in Section 5.

4. Basic Constructions
This section presents some results that are necessary for the theorems later in the article.
The first three results, that planning is NP-hard for in-stars (aka. inverted forks), out-stars
(aka. forks) and directed paths (aka. directed chains), are known from the literature, while
the NP-hardness result for fences is new. We will, however, provide new proofs also for the
in-star and out-star cases. The major reason is that in Section 6 we will need to refer to
reductions that have certain precisely known properties. Furthermore, the original proofs
are only published in a technical report (Domshlak & Dinitz, 2001b) and may thus be hard
to access.
Lemma 4. (Domshlak & Dinitz, 2001a, Thm. 3.IV) PlanExist(Sin ) is NP-hard. This result
holds even when restricted to operators with at most 2 preconditions and 1 postcondition.
Proof. (New proof) Proof by reduction from 3SAT to a class of planning instances with
causal graphs in Sin . The reduction constructs a planning instance where each source in the
causal graph corresponds to one of the variables in the formula and the centre corresponds
to the clauses. The construction is illustrated in Figure 2 and formally defined as follows.
Let F = c1  . . .  cm be an arbitrary 3SAT formula with variables x1 , . . . , xn and clauses
c1 , . . . , cm . Construct a corresponding planning instance F = (V, init, goal, A) as follows:
 V = {vc , v1 , . . . , vn }, where
D(vc ) = {0, . . . , m} and
D(vi ) = {u, f, t}, for all i (1  i  n).
1. The condition can be simplified to W[1] 6 FPT if the class C is recursively enumerable.

584

fiA Refined View of Causal Graphs and Component Sizes

vc
0

1

2

t
u

t
u

t
u

f
v1

m

f
v2

f
vn

Figure 2: The in-star causal graph and the DTGs for the construction in the proof of
Lemma 4.

 init(vi ) = u, for all i (1  i  n), and init(vc ) = 0.
 goal(vc ) = m and goal is otherwise undefined.
 A consists of the following operators:
 For each i (1  i  n), A contains the operators
set-f(i) = hvi = u ; vi = f i and
set-t(i) = hvi = u ; vi = ti.
 For each clause ci = (`1i  `2i  `3i ) and each j (1  j  3), there is some k such
that `ji = xk or `ji = xk , so let A contain either the operator
verify-clause-pos(i, j) = hvc = i  1, vk = t ; vc = ii, if `ji = xk ,
or the operator
verify-clause-neg(i, j) = hvc = i  1, vk = f ; vc = ii, if `ji = xk .
Clearly, the instance F can be constructed in polynomial time and CG(F ) = Snin , so it
remains to prove that F has a solution if and only if F is satisfiable.
Each source variable vi can be changed independently. It starts with the undefined
value u and can be set to either t or f , corresponding to true and false, respectively, for the
corresponding variable xi in F . Once it is set to either t or f , it cannot be changed again.
That is, variables v1 , . . . , vn can be used to choose and commit to a truth assignment for
x1 , . . . , xn . The centre variable vc has one value, i, for each clause ci in F , plus the initial
value 0. It is possible to reach the goal value m from the inital value 0 by stepping through
585

fiBackstrom & Jonsson

all intermediate values in numerical order. For each such step, from i  1 to i, there are
three operators to choose from, corresponding to each of the literals in clause ci . The step
is possible only if one of v1 , . . . , vn is set to a value consistent with one of the literals in ci .
That is, the goal vc = m can be achieved if and only if variables v1 , . . . , vn are set to values
corresponding to a truth assignment for x1 , . . . , xn that satisfies F .
The restricted case (with respect to pre- and post-conditions) is immediate from the
construction above.
The problem is known to be tractable, though, if the domain size of the centre variable is
bounded by a constant (Katz & Domshlak, 2010). Furthermore, the causal graph heuristic
by Helmert (2004) is based on identifying in-star subgraphs of the causal graph, and it
should be noted that he provided a variant of the original proof due to some minor technical
differences in the problem formulations.
Lemma 5. (Domshlak & Dinitz, 2001a, Thm. 3.III) PlanExist(Sout ) is NP-hard. This result
holds even when restricted to operators with at most 1 precondition and 1 postcondition.
Proof. (New proof) Proof by reduction from 3SAT to a class of planning instances with
causal graphs in Sout . The reduction constructs a planning instance where the centre vertex
of the causal graph corresponds to the variables in the formula and each sink corresponds
to one of the clauses. The construction is illustrated in Figure 3 and formally defined as
follows.
v1

u

v2

vm

s

u

s

u

t0

t1

t2

tn

f0

f1

f2

fn

s

vc

Figure 3: The out-star causal graph and the DTGs for the construction in the proof of
Lemma 5.

Let F = c1  . . .  cm be an arbitrary 3SAT formula with variables x1 , . . . , xn and clauses
c1 , . . . , cm . Construct a corresponding planning instance F = (V, init, goal, A) as follows:
586

fiA Refined View of Causal Graphs and Component Sizes

 V = {vc , v1 , . . . , vm }, where
D(vc ) = {f0 , . . . , fn , t0 , . . . , tn } and
D(vi ) = {u, s}, for all i (1  i  m).
 init(vi ) = u, for all i (1  i  m), and init(vc ) = f0 .
 goal(vi ) = s, for all i (1  i  m), and goal(vc ) is undefined.
 A consists of the following operators:
 For each i (1  i  n), A contains the operators
step-c(fi1 , fi ) = hvc = fi1 ; vc = fi i,
step-c(fi1 , ti ) = hvc = fi1 ; vc = ti i,
step-c(ti1 , fi ) = hvc = ti1 ; vc = fi i and
step-c(ti1 , ti ) = hvc = ti1 ; vc = ti i.
 For each clause ci = (`1i  `2i  `3i ) and each j (1  j  3), there is a k such that
`ji = xk or `ji = xk , so let A contain either the operator
verify-clause-pos(i, j) = hvc = tk ; vi = si, if `ji = xk ,
or the operator
verify-clause-neg(i, j) = hvc = fk ; vi = si, if `ji = xk .
Clearly, the instance F can be constructed in polynomial time and CG(F ) = Snout , so it
remains to prove that F has a solution if and only if F is satisfiable.
Variable vc can be changed independently and it has two values, ti and fi , for each
variable xi in F , corresponding to the possible truth values for xi . In addition there is an
initial value f0 (and a dummy value t0 in order to simplify the formal definition). Both the
values tn and fn are reachable from the initial value f0 , and each such plan will correspond
to a path f0 , z1 , z2 , . . . , zn where each zi is either ti or fi . That is, vc must pass either value
ti or fi , but not both, for each i. Hence, any such path will correspond to a truth assignment
for the variables x1 , . . . , xn in F . For each clause ci in F , there is a corresponding variable
vi that can change value from the initial value u, unsatisfied, to the goal value s, satisfied.
Each vi has three operators to do this, one for each literal in ci . That is, if ci contains
a literal xk (or xk ) then vi can change value from u to s while vc has value tk (or fk ).
Hence, the goal v1 = . . . = vm = s can be achieved if and only if there is a path for vc
that corresponds to a truth assignment for x1 , . . . , xn that satisfies F . (Note, though, that
vc must not always follow a path all the way to fn or tn since a partial assignment may
sometimes be sufficient to prove satisfiability.)
The restricted case (with respect to pre- and post-conditions) is immediate from the
construction above.
The problem is known to be tractable, though, if the domain size of the centre variable is
bounded by a constant (Katz & Keyder, 2012).
The following result on planning with directed-path causal graphs is also known from
the literature.
Lemma 6. (Gimenez & Jonsson, 2009, Prop. 5.5) PlanExist(dP) is NP-hard, even when
all variables have domain size 5 and the operators have at most 2 preconditions and 1 postcondition.
587

fiBackstrom & Jonsson

We refer to Gimenez and Jonsson for the proof. However, we will implicitly use their
proof later in this article so there are a few important observations to make about it. The
reduction is from SAT and, thus, works also as a reduction from 3SAT. Furthermore, the
reduction transforms a formula with n variables and m clauses to a planning instance with
(2m + 4)n variables. As a final remark, this problem is known to be tractable if all variables
have a domain of size 2 (Domshlak & Dinitz, 2001a).
While the three previous results are known in the literature, the following result is new
to the best of our knowledge.
Lemma 7. PlanExist(F+1 ) is NP-hard. This result holds even when restricted to operators
with at most 2 preconditions and 1 postcondition.
Proof. Proof by reduction from 3SAT to a class of planning instances with causal graphs
in F+1 .
The reduction constructs a planning instance where each sink of the causal graph corresponds to one of the clauses in the formula, while each source corresponds to all variables.
Furthermore, the source variables are synchronized to have the same behaviour. The construction is illustrated in Figure 4 and formally defined as follows.
Let F = c1  . . .  cm be an arbitrary 3SAT formula with variables x1 , . . . , xn and clauses
c1 , . . . , cm . Construct a corresponding planning instance F as follows:
 V = {u0 , . . . , um , v1 , . . . , vm }, where
D(ui ) = {f0 , . . . , fn , t0 , . . . , tn }, for all i (0  i  m), and
u , tu , . . . , tu , f s , . . . f s , ts , . . . , ts , s}, for all i (1  i  m).
D(vi ) = {f0u , . . . , fm
m 0
m 0
m
0
 init(ui ) = f0 , for all i (0  i  m), and init(vi ) = f0u , for all i (1  i  m).
 goal(vi ) = s, for all i (1  i  m), and goal is otherwise undefined.
 Let A consist of the following operators:
 For all i, j (1  i  n, 0  j  m), A contains the operators
step-x(j, fi1 , fi ) = huj = fi1 ; uj = fi i,
step-x(j, fi1 , ti ) = huj = fi1 ; uj = ti i,
step-x(j, ti1 , fi ) = huj = ti1 ; uj = fi i and
step-x(j, ti1 , ti ) = huj = ti1 ; uj = ti i.
 For all i, j, (1  i  n, 1  j  m), A contains the operators
u
u , f u ) = hv = f u , u
step-clause-u(j, fi1
j
i1 j1 = fi , uj = fi ; vj = fi i,
i
u
u
u
u
step-clause-u(j, fi1 , ti ) = hvj = fi1 , uj1 = ti , uj = ti ; vj = ti i,
step-clause-u(j, tui1 , fiu ) = hvj = tui1 , uj1 = fi , uj = fi ; vj = fiu i,
step-clause-u(j, tui1 , tui ) = hvj = tui1 , uj1 = ti , uj = ti ; vj = tui i,
s , f s ) = hv = f s , u
s
step-clause-s(j, fi1
j
i
i1 j1 = fi , uj = fi ; vj = fi i,
s , ts ) = hv = f s , u
s
step-clause-s(j, fi1
j
i
i1 j1 = ti , uj = ti ; vj = ti i,
s
s
s
step-clause-s(j, ti1 , fi ) = hvj = ti1 , uj1 = fi , uj = fi ; vj = fis i,
step-clause-s(j, tsi1 , tsi ) = hvj = tsi1 , uj1 = ti , uj = ti ; vj = tsi i,
 For each j (1  j  m), A contains the operators
finalize-clause-f(j) = hvj = fns ; vj = si and
finalize-clause-t(j) = hvj = tsn ; vj = si.
588

fiA Refined View of Causal Graphs and Component Sizes

vi1

vi+1

vi
tu0

tu1

tu2

tun

f0u

f1u

f2u

fnu

x1  ci

x2  ci

ts0

ts1

ts2

tsn

f0s

f1s

f2s

fns

s

t0

t1

t2

tn

t0

t1

t2

tn

f0

f1

f2

fn

f0

f1

f2

fn

ui1

ui

Figure 4: The fence causal graph and the DTGs for the construction in the proof of
Lemma 7. (This example assumes that clause ci contains the literals x1 and x2 ).

 For each clause ci = (`1i  `2i  `3i ) and for each j (1  j  3), there is a k such
that `ji = xk or `ji = xk so let A contain either the operator
verify-pos(i, j) = hvi = tuk ; vi = tsk i, if `ji = xk ,
or the operator
verify-neg(i, j) = hvi = fku ; vi = fks i, if `ji = xk .
+1 . Hence,
Clearly, the instance F can be constructed in polynomial time and CG(F ) = Fm
it remains to prove that F has a solution if and only if F is satisfiable.
First consider only variables ui and vi , for some i. The construction of the domain and
the operators for ui is identical to the one for vc in the proof of Lemma 5, i.e. there is a
directed path from value f0 to fn or tn for every possible truth assignment for the variables
x1 , . . . , xn in F . Variable vi , corresponds to clause ci and contains two copies of the DTG for
ui , where the values differ only in the extra superscript, u or s. The latter copy is extended
with the additional value s, denoting that the clause has been satisfied. There are operators
that allows vi to mimic the behaviour of ui ; it can follow the corresponding path in either
of its two copies. Furthermore, for each of the three literals in ci there is an operator that

589

fiBackstrom & Jonsson

makes it possible to move from value zku to value zks if value zk of ui is consistent with this
s or ts in order to reach the goal value
literal. Since vi starts at f0u and must reach either fm
m
s, it is necessary for vi to make such a transition for one of the literals in ci . That is, if ui
follows the path f0 , z1 , . . . , zn then vi must follow the path f0u , z1u , . . . , zku , zks , . . . , zns , s, for
some k such that xk occurs in a literal in ci and zk is a satisfying truth value for this literal.
Now consider also variable ui1 . Since each operator that affects the value of vi either
has the same precondition on both ui1 and ui or no precondition on either, it follows that
ui1 and ui must both choose the same path if vi is to reach its goal. Since every variable vj
forces synchronization of its adjacent variables uj1 and uj in this manner, it follows that
all of u0 , . . . , um must choose exactly the same path for any plan that is a solution. It thus
follows from this and from the argument for ui and vi that the goal v1 = . . . = vm = s can
be achieved if and only if there is a path that all of u0 , . . . , um can choose such that this
path corresponds to a satisfying truth assignment for F .
For the restriction, we first note that it is immediate from the construction that operators
with 3 preconditions and 1 postcondition are sufficient. To see that 2 preconditions are
sufficient, consider the following variation on the construction. Each step-clause-u and stepclause-t operator is replaced with two operators as follows. As an example, consider an
u , tu ). First introduce an extra value f tu in D(v ). Then replace
operator step-clause-u(j, fi1
j
i
i
the operator with two new operators
u , f tu ) = hv = f u , u
u
step-clause-u(j, fi1
j
i
i1 j1 = ti ; vj = f ti i and
step-clause-u(j, f tui , tui ) = hvj = f tui , uj = ti ; vj = tui i.
u
Consider the step in the DTG for vj from fi1
to tui . In the original construction, this is
u , tu ), which requires that both u
done by the single operator step-clause-u(j, fi1
j1 and uj
i
u
have value ti . The modified construction instead requires two steps, first a step from fi1
u
u
to the new intermediate value f ti and then a step from this value to ti . The previous
conjunctive constraint that uj1 = uj = ti is replaced by a sequential constraint that first
uj1 = ti and then uj = ti . Although it is technically possible for uj1 to have moved on
to a new value when the second step is taken, this does not matter; both uj1 and uj must
still choose exactly the same path in their respective DTGs.
Corollary 8. PlanExist(F1 ), PlanExist(F0 ) and PlanExist(F) are NP-hard.
Proof. Neither of the two outer source vertices, u0 and um , are necessary in the construction
in the previous proof. Hence, by omitting either or both of these the reduction works also
for F1 and F0 . Finally, PlanExist(F) is NP-hard since F+1  F.
We now have all the basic results necessary for the main theorems of the following
two sections.

5. Graph Classes and Closure Properties
Like most other results in the literature, the results in the previous section are about classes
consisting of some particular graph type, like the class Sin of all in-stars or the class F of
all fences. This section will depart from this and instead study graph classes with certain
closure properties. We will first discuss the standard concepts of subgraph closure and minor
closure, finding that the first does not contain all the graphs we need while the latter results
590

fiA Refined View of Causal Graphs and Component Sizes

in a set with too many graphs. For that reason, we will define a new concept, SP-closure,
which is incomparable with subgraph closure but is a subset of minor closure. We will then
show that this closure concept defines a borderline between the non-NP-hard graph classes
and large number of useful NP-hard classes.
5.1 Subgraph Closure and Minor Closure
Suppose C is a class of graphs which is closed under taking subgraphs. Then for every graph
G in C it is the case that every subgraph H of G must also be in C. Subgraph closure is
not sufficient for our purposes, though. For instance, a subgraph of a polypath will always
be either a polypath or a graph where every weakly connected component is a polypath.
However, a polypath need not have any subgraphs that are fences of more than trivial size.
We will need a closure property that guarantees that if C contains a polypath with m sinks,
then it also contains a fence with m sinks. An obvious candidate for this is the concept of
minor-closure, which is a superset of the subgraph-closure. The concepts of graph minors
and minor-closure has rapidly evolved into a very important and useful research area in
mathematical as well as computational graph theory (Lovasz, 2005; Mohar, 2006).
In order to define graph minors we first need the concept of edge contraction, which is
commonly defined as follows, although other definitions occur in the literature.
Definition 9. Let G = (V, E) be a directed graph and let e = (u, v)  E be an edge such
that u 6= v. Then the contraction of e in G results in a new graph G0 = (V 0 , E 0 ), such that
 V 0 = (V \ {u, v})  {w} and
 E 0 = {(f (x), f (y)) | (x, y)  E, (x, y) 6= (u, v) and (x, y) 6= (v, u)},
where w is a new vertex, not in V , and the function f : V  V 0 is defined such that
f (u) = f (v) = w and otherwise f (x) = x.
That is, when an edge (u, v) is contracted, the two vertices u and v are replaced with
a single new vertex w and all edges that were previously incident with either u or v are
redirected to be incident with w. Figure 5 shows an example of edge contraction. We say
that a graph H is a contraction of another graph G if H can result from contracting zero
or more edges in G.
The concept of graph minors can now be defined as follows.
Definition 10. A directed graph H is a minor of a directed graph G if H is isomorphic to
a graph that can be obtained by zero or more edge contractions of a subgraph of G.
An example is illustrated in Figure 6. The graph G in the figure is a weakly connected
directed graph, which also happens to be a polypath. If vertex v9 is removed from G,
then the restriction to the remaining vertices is still a weakly connected graph which is a
subgraph of G. Removing also v4 results in the graph H, which consists of two weakly
connected components H1 and H2 . All of H, H1 and H2 are subgraphs of G, but they are
also minors of G, since a subgraph is a minor, by definition. Contracting the edge (v1 , v2 )
in H1 results in the graph M1 , where w1 is the new vertex replacing v1 and v2 . Similarly,
contracting the edge (v8 , v7 ) in H2 results in M2 . The graph M1 is a minor of G since it is
591

fiBackstrom & Jonsson

v9

v9
v10

v8

v10
v8

v2
v7

v5

v7

v1

v6

v5

w

v6

v3

v4

a) A graph G

v3

v4

b) The result of contracting edge (v1 , v2 ) in G.

Figure 5: Edge contraction.

the result of an edge contraction in the subgraph H1 of G and the graph M2 is analogously
a minor of G too. Also the graph M , consisting of the two components M1 and M2 is a
minor of G, since it is the result of two contractions in the subgraph H of G. While the
graphs H, H1 and H2 are both subgraphs and minors of G, the graphs M , M1 and M2 are
only minors of G, not subgraphs.

v6
v3
v2

v5
v4

v6
v7

v3
v8

v1

a) A polypath

v7

v2
v9

G

v5

v3
v8

w1

v5
M1

v1
H1

v6
w2
M2

H2

b) A subgraph H of G
(where H = H1  H2 )

c) A minor M of G
(where M = M1  M2 )

Figure 6: Subgraphs and minors.

A trivial example of a minor-closed class is the class of all graphs, which is minor-closed
since it contains all graphs and every minor of a graph is itself a graph. More interestingly,
many commonly studied graph types result in minor-closed classes. For instance, the class
Sin of all in-stars is minor-closed, as is the class Sout of all out-stars and the class dP of all
592

fiA Refined View of Causal Graphs and Component Sizes

directed paths. Furthermore, a weakly connected minor of a polypath is a polypath and a
weakly connected minor of a polytree is a polytree. As an illustration, once again consider
Figure 6. The graph G is a polypath, and the weakly connected graphs H1 , H2 , M1 and
M2 are all minors of G, but they are also polypaths. In fact, M1 and M2 are also fences.
Note though, that neither H nor M is a polypath, since they both consist of more than one
weakly connected component. It is worth noting, however, that the class F of all fences is
not minor-closed although every fence is a polypath; a weakly connected minor of a fence
must be a polypath, but it is not necessarily a fence.
Requiring minor-closed graph classes is, however, overly strong. For instance, it would
be sufficient to require that for every graph G  C, also every weakly connected minor of G
is in C. That is, in the example in Figure 6 we would require that H1 , H2 , M1 and M2 are
all in C if G is in C, but we would not require that also H and M are in C. This is both
reasonable and desirable in the context of causal graphs. If the causal graph of a planning
instance consists of two or more weakly connected components, then these components
correspond to entirely independent subinstances that can be solved separately.
Furthermore, certain natural restrictions do not mix well with minor-closed classes.
Consider, for instance, the example in Figure 7, with an acyclic graph G = (V, E), where
V = {v1 , v2 , v3 , v4 } and E = {(v1 , v2 ), (v2 , v3 ), (v3 , v4 ), (v1 , v4 )}. If we contract the edge
(v1 , v4 ) to a new vertex w we get a cycle graph on the vertices w, v2 , v3 . That is, a class of
acyclic graphs is not minor-closed in general, which is problematic considering the importance of acyclic causal graphs.

v1

v2

v4

v3

v2
w

a) An acyclic graph G

v3
b) The contraction of (v1 , v4 ) in G.

Figure 7: Contracting an edge in an acyclic graph can result in a cycle.

5.2 SP-Closed Graph Classes
In order to avoid problems with acyclicity (and other similar problems) and to avoid defining
special variants of the contraction and minor concepts, we instead identify a set of minimal
requirements that a closure must satisfy in order to imply NP-hardness for the PlanExist
problem. We will focus on one such set of restrictions, defining a concept we refer to as
SP-closure (where SP denotes that the set is closed under stars and polypaths).
Definition 11. Let G and H be two directed graphs. Then H is an SP-graph of G if H is
weakly connected and either of the following holds:
1. H is an in-star that is a subgraph of G,
593

fiBackstrom & Jonsson

2. H is an out-star that is a subgraph of G or
3. H can be obtained by zero or more contractions of some polypath G0 such that G0 is
a subgraph of G.
A class C of graphs is SP-closed if it contains every SP-graph of every graph G  C.
SP-closure has a number of interesting properties, including the following:
Proposition 12. Let G and H be directed graphs and let C be a class of directed graphs.
1. If G is a polypath, then every SP-graph of G is a polypath.
2. Every SP-graph of G is acyclic.
3. If H is an SP-graph of G, then H is a minor of G.
4. If C is minor-closed, then C is SP-closed.
Proof. 1) Suppose G is a polypath. Obviously, G cannot contain an in-star or out-star
with higher degree than two, and any such star is also a polypath. Hence, we only need to
consider the third case in the definition. We note that any weakly connected subgraph G0 of
G must also be a polypath, and that doing contractions on a polypath results in a polypath.
2) Immediate since in-stars, out-stars and polypaths are all acyclic and contracting edges
cannot introduce a cycle in any of these cases.
3) Immediate from the definitions of minors and SP-graphs.
4) Immediate from 3.
This proposition says that it makes sense to talk about SP-closed classes of polypaths
and SP-closed classes of acyclic graphs. It also says that SP-closure and minor-closure
are comparable concepts; the SP-closure of a class is a subset of the minor-closure of the
same class.
We can now prove the following result about SP-closed classes of polypaths, which we
need for the main theorem.
Lemma 13. Let C be an SP-closed class of polypaths. If cc-size(C) is unbounded, then
PlanExist(C) is NP-hard. This result holds even when restricted to operators with at most
2 preconditions and 1 postcondition.
Proof. Proof by cases depending on whether the directed path length of C is bounded or not.
Case 1: Suppose that path-length(C) is unbounded. Let n > 1 be an arbitrary integer.
Then there must be some graph G  C such that G contains a subgraph H that is a directed
path graph and V (H) = n. Obviously, H is an SP graph of G, since a directed path is
also a polypath. It follows that H  C since C is SP-closed. Furthermore, H ' dPn so
NP-hardness of PlanExist(C) follows from Lemma 6, since n was choosen arbitrarily.
Case 2: Instead suppose that path-length(C)  k for some constant k  0. Let n > 1 be
an arbitrary integer. Since all graphs in C are polypaths and cc-size(C) is unbounded, there
must be some polypath G  C such that V (G)  n. It thus follows from the assumption
and Proposition 1 that G must have at least m sinks and m + 1 sources, for some m such
594

fiA Refined View of Causal Graphs and Component Sizes

that V (G)  2mk + 1. There must, thus, be some subgraph G0 of G that is a polypath with
exactly m sinks and m + 1 sources (i.e. G0 is weakly connected) and there must, thus, also
+1 .
be a graph H that can be obtained by zero or more contractions of G0 such that H ' Fm
It follows that H  C since C is SP-closed. NP-hardness of PlanExist(C) thus follows from
Lemma 7, since n was choosen arbitrarily and k is constant.
To see that the result holds even if the operators under consideration have at most 2
preconditions and 1 postcondition, simply note that this restriction holds for all reductions
used in the underlying NP-hardness proofs in Section 4.
Chen and Gimenez (2010, Thm. 3.19) proved a similar result: If C is a class of polypaths2
with unbounded components and unbounded number of sources, then PlanExist(C) is not
polynomial-time solvable unless W[1]  nu-FPT.
In order to prove the main result of this section, we also need the Moore bound (Biggs,
1993, p. 180), which is stated as follows: for an arbitrary connected undirected graph G,
the maximum number of vertices is
|V (G)|  1 + d

k1
X

(d  1)i ,

(1)

i=0

where d = deg(G) and k = path-length(G).
We can now prove that under the additional restriction that graph classes are SPclosed, we can avoid NP-intermediate problems and prove NP-hardness for graph classes
with unbounded components.
Theorem 14. Let C be an SP-closed class of directed graphs. If cc-size(C) is unbounded,
then PlanExist(C) is NP-hard. This result holds even when restricted to operators with at
most 2 preconditions and 1 postcondition and all graphs in C are acyclic.
Proof. First suppose there is some constant k such that in-deg(C)  k, out-deg(C)  k and
upath-length(C)  k. Consider an arbitrary graph G  C. Obviously, deg(U (G))  2k and
path-length(U (G))  k, P
so it follows from the Moore bound that no component in U (G) can
i
have more than 1 + 2k k1
i=0 (2k  1) vertices. However, since cc-size(G) = cc-size(U (G))
and G was choosen arbitrarily, it follows that cc-size(C) is bounded. This contradicts the
assumption so at least one of in-deg(C), out-deg(C) and upath-length(C) is unbounded. The
remainder of the proof is by these three (possibly overlapping) cases.
Case 1: Suppose that in-deg(C) is unbounded. Let n > 0 be an arbitrary integer. Then
there must be some graph G  C containing a vertex with indegree n or more, so there must
also be a subgraph H of G such that H ' Snin . Hence, H  C since C is SP-closed. It thus
follows from Lemma 4 that PlanExist(C) is NP-hard, since n was choosen arbitrarily.
Case 2: Suppose that out-deg(C) is unbounded. This case is analogous to the previous
one, but using Lemma 5 instead of Lemma 4.
Case 3: Suppose that upath-length(C) is unbounded. Let n > 0 be an arbitrary integer.
Then there must be some graph G  C such that U (G) contains a path of length n, and there
must, thus, also be a subgraph H of G such that H is a polypath of length n. Obviously, H
2. Chen and Gimenez use the term source-sink configuration for polypath.

595

fiBackstrom & Jonsson

is an SP-graph of G (doing zero contractions) so H  C since C is SP-closed. It thus follows
from Lemma 13 that PlanExist(C) is NP-hard, since n was choosen arbitrarily.
To see that the result holds even if the operators under consideration have at most 2
preconditions and 1 postcondition, simply note that this restriction holds for all reductions
used in the underlying NP-hardness proofs in Section 4. Similarly, the acyclicity restriction
holds since the result is based only on in-stars, out-stars and polypaths, which are all
acyclic graphs.
This theorem is somewhat more restricted than the one by Chen and Gimenez since it
requires the additional constraint that C is SP-closed. On the other hand, it demonstrates
that SP-closure is a sufficient condition to avoid graph classes such that PlanExist is NPintermediate and, thus, sharpen the result to NP-hardness. It should be noted, though,
that this is not an exact characterization of all graph classes that are NP-hard for PlanExist.
There are other such graph classes, but SP-closure captures a large number of interesting
graph classes. For instance, the class of all acyclic graphs is SP-closed (recall that this class
is not minor-closed), although not every subclass of it is SP-closed. As an opposite example,
any non-empty class that does not contain a single acyclic graph cannot be SP-closed.

6. Beyond SP-Closed Graph Classes
This section is divided into three parts. We first discuss why the previous results, as well as
most other similar NP-hardness results in the literature, are problematic, which motivates
us to switch over to non-uniform complexity theory. The second part contains a number of
preparatory results that are required for the main theorem in the third part.
6.1 Why NP-Hardness is Not Enough
We refer to a planning problem as generic if it has instances of varying size, depending on
one or more parameters. An archetypical example is the blocks world, where the natural
parameter is the number of blocks. For a particular encoding and a specified number of
blocks, the variables and operators will be the same whatever the inital state and goal is.
That is, if we fix the encoding then we get a planning frame n = (Vn , An ) for every number,
n, of blocks. That is, n is the same for all instances with n blocks and is thus a function of
n. All instances (Vn , init, goal, An ) with n blocks will be instantiations of n with different
init and goal components but with the same Vn and An components. An instance can thus
be specified with three unique parameters, n, init and goal, where only the first parameter,
n, affects the size of the instance. Furthermore, the causal graph for an instance depends
only on the variables and the operators, which means that all instantiations of a frame n
have the same causal graph, which we denote CG(n ). The class of causal graphs for blocks
world instances will be D = {CG(1 ), CG(2 ), CG(3 ), . . .}, although 1 , 2 , 3 , . . ., and
thus also D, will differ depending on the encoding.
It is often possible to analyse the complexity of a particular generic planning problem.
Examples of this are the complexity of blocks-world planning (Gupta & Nau, 1992) and
the complexity of various problems from the International Planning Competitions (IPC)
(Helmert, 2003, 2006b). In the context of this article, though, we are rather interested
in the complexity of the class of causal graphs corresponding to a generic problem, than
596

fiA Refined View of Causal Graphs and Component Sizes

the complexity of the specific problem itself. Suppose that a class D of causal graphs
happens to be a subset of some class C of graphs such that we know that PlanExist(C) is
tractable. Then we can infer that also PlanExist(D) is tractable, and thus also that all
generic planning problems with causal graphs in D are tractable. However, in order to
prove that PlanExist(D) is NP-hard (or hard for some other complexity class) we would
have to prove that there is some class C of graphs such that PlanExist(C) is NP-hard and C
is a subset of D. Finding such a class C may not be trivial, though.
One problem is that the encoding can have a large influence on how densely or sparsely
the causal graphs occur with respect to size. Consider, for instance, blocks world encodings
with multi-valued variables and with boolean variables respectively. A typical encoding with
multi-valued variables will use one variable for the status of the hand and two variables for
each block, one for the position of the block and one to flag whether the block is clear or
not. That is, such encodings will use 2n + 1 variables for an n-block frame. An encoding
with boolean variables, on the other hand, will typically represent the block position with
a number of boolean variables, one for each other block that a block can be on. A boolean
encoding will thus use n2 + 1 variables for an n-block frame. While D will contain a graph
for every odd number of vertices in the first case, it will be increasingly sparse in the second
case. The class D of causal graphs for a generic planning problem will, thus, typically not
be SP-closed, or even closed under taking subsets. Furthermore, since D will typically not
contain a member for every possible number of vertices, it cannot possibly contain any of
the known NP-hard sets Sin , Sout , dP etc. as a subset. Hence, in order to prove that
a class D of causal graphs is hard for NP (or some other complexity class), it will often
be necessary to make a dedicated proof for D. This is often doable, however. A generic
planning problem has a corresponding function f that takes a parameter value n, e.g. the
number of blocks in blocks world, such that f (n) = n . If f is furthermore polynomialtime computable in the value of n, which will often be the case, then also the corresponding
causal graph, CG(n ), is polynomial-time computable. However, even if this can be done
for many generic planning problems, it will be a specific proof for every specific encoding of
every particular generic planning problem. The same holds for particular classes of causal
graphs; every specific class will typically require its own dedicated proof.
In order to get around these problems and to be able to prove a more general result that
does not depend on the specific planning problems or causal graphs, we switch over to nonuniform complexity. This makes it possible to prove more powerful results, while retaining
natural connections with the ordinary complexity classes. The basic vehicle for proving nonuniform complexity results is the advice-taking Turing machine, which is defined as follows.
Definition 15. An advice-taking Turing machine M has an associated sequence of advice
strings A0 , A1 , A2 , . . ., a special advice tape and an advice function A, from the natural
numbers to the advice sequence, s.t. A(n) = An . On input x the advice tape is immediately
loaded with A(||x||). After that M continues like an ordinary Turing machine, except that
it also has access to the advice written on the advice tape.
If there exists a polynomial p s.t. ||A(n)||  p(n), for all n > 0, then M is said to use
polynomial advice. The complexity class P/poly is the set of all decision problems that can
be solved on some advice-taking TM that runs in polynomial time using polynomial advice.
597

fiBackstrom & Jonsson

Note that the advice depends only on the size of the input, not its content, and need
not even be computable. Somewhat simplistically, an advice-taking Turing machine is a
machine that has an infinite data-base with constant access time. However, for each input
size there is only a polynomial amount of information while there might be an exponential
number of instances sharing this information. The power of polynomial advice is thus still
somewhat limited and useful relationships are known about how the non-uniform complexity
classes relate to the standard ones are known. One such result is the following.
Theorem 16. (Karp & Lipton, 1980, Thm. 6.1) If NP  P/poly, then the polynomial
hierarchy collapses to the second level.
6.2 Preparatory Results
Before carrying on to the main theorem of this section, we need a few auxiliary results. We
first show that if a planning instance has a causal graph G that is a subgraph of some graph
H, then the instance can be extended to an equivalent instance with H as causal graph.
Lemma 17. Let  be a planning instance and let G be a directed graph such that CG()
is a subgraph of G. Then there is a planning instance G such that
 G can be constructed from  in polynomial time,
 CG(G ) = G and
 G has a solution if and only if  has a solution.
Furthermore, G has the same maximum number of pre- and postconditions for its operators
as  (or one more if this value is zero in ).
Proof. Let  = (V, init, goal, A) be a planning instance and let CG() = (V, E). Let
G = (VG , EG ) be a directed graph such that CG() is a subgraph of G. Let U = VG \ V .
Construct a planning instance G = (VG , initG , goalG , AG ) as follows:
 DG (u) = {0, 1}, for all u  U , and
DG (v) = D(v)  {?}, for all v  V , (where ? is a new value not in D(v)).
 initG (v) = init(v), for all v  V , and
initG (u) = 0, for all u  U .
 goalG (v) = goal(v), for all v  V , and
goalG (u) is undefined for all u  U .
 Let AG consist of the following operators:
 Let AG contain all a  A.
 For each edge (x, v)  EG \ E such that x  VG and v  V , let AG also contain
an operator star(x, v) = hx = 0 ; v = ?i.
 For each edge (x, u)  EG such that x  VG and u  U , let AG also contain
an operator set(x, u) = hx = init(x) ; u = 1i.
598

fiA Refined View of Causal Graphs and Component Sizes

Obviously G can be constructed in polynomial time and CG(G ) = G, so it remains
to prove that G has a solution if and only if  has a solution.
Suppose P = a1 , . . . , an is a plan for . Then P is also a plan for G since goalG (u) is
undefined for all u  U and a1 , . . . , an  AG . To the contrary, suppose P = a1 , . . . , an is a
plan for G . For each operator ai in P , there are three cases: (1) ai  A, (2) ai is a set
operator or (3) ai is a star operator. In case 2, operator ai serves no purpose since it only
modifies some variable in U , which has an undefined goal value. In case 3, operator ai sets
some variable v  V to ? and has no effect on any other variables. If goalG (v) is undefined,
then ai serves no purpose. Otherwise there must be some operator aj , j > i, such that aj
can change v from ? to some value in D(v), i.e. ai serves no purpose in this case either. It
follows that the operator sequence P 0 obtained from P by removing all operators that are
not in A is also a plan for G . Furthermore, since P 0 contains only operators from A it is
also a plan for . It follows that  has a plan if and only if G has a plan.
This construction increases the maximum domain size by one but has very little effect
on the maximum number of pre- and postconditions. This is suitable for our purpose, since
we do not consider the influence of domain sizes in this article. Other constructions are
possible if we want to balance the various factors differently.
In the proof of the forthcoming theorem we will also do the opposite of taking graph
minors, that is, starting from a minor G of some target graph H we will extend G to H.
In order to do so, we need an operation similar to the opposite of edge contraction. This is
satisfied by a graph operation known as edge subdivision.
Definition 18. Let G = (V, E) be a directed graph and let (u, v)  E be an edge such that
u 6= v. Then the subdivision of (u, v) in G is a graph G0 = (V  {w}, E 0 ) where w is a new
vertex and E 0 = (E \ {(u, v)})  {(u, w), (w, v)}.
Although one might consider other definitions, e.g. in the case where both (u, v) and
(v, u) are in E, this one is sufficient for our purpose and it follows the usual extension to
directed graphs (cf., Kuhn, Osthus, & Young, 2008). Usually an operation called smoothing
is considered as the inverse of edge subdivision. However, smoothing can be viewed as a
restricted case of edge contraction, so it is reasonable to think of edge subdivision as a sort
of inverse of edge contraction. An example of edge subdivision is illustrated in Figure 8.
We further note that just like an edge contraction of a polypath is a polypath, also an edge
subdivision of a polypath is a polypath.
We also need an operation on planning instances corresponding to edge subdivision
in their causal graphs. For that purpose, we need a concept of variable substitution for
operators. We denote the substitution of a variable w for a variable v in a partial state s
with a[v/w], defined as:

if x = w,
 s(v),
s(x),
if x  vars(s) \ {v, w},
s[v/w](x) =

undefined, otherwise.
If a is an operator, then the operator a0 = a[v/w] is defined such that pre(a0 ) = pre(a)[v/w]
and post(a0 ) = post(a)[v/w].
599

fiBackstrom & Jonsson

v9

v9
v10

v8

v10
v8

v2
v7

v5

v7

v1

v6
v3

a) A graph G

v2

v6
v4

w

v5

v1
v3

v4

b) The result of subdividing edge (v1 , v2 ) in G.

Figure 8: Edge subdivision.

We now have the necessary concepts for modifying an arbitrary planning instance such
that the result corresponds to subdividing an edge in the causal graph of the instance.
However, we will only need to do this for instances where the causal graph is a polypath.
Before proving that this can be done, we first need the following lemma, which states a
certain reordering property for plans when the causal graph is a polypath. If we choose an
arbitrary vertex v in a polypath G and remove v from G, then G falls apart into two weakly
connected components C1 and C2 . In other words, the vertices of G can be partitioned
into three sets C0 , C1 and C2 such that C0 = {v} and there is no edge directly between
a vertex in C1 and a vertex in C2 . It then follows from the definition of causal graphs
that no operator that changes some variable in C1 can have a precondition on a variable
in C2 and vice versa. The following lemma utilises this fact to prove that any sequence
of operators that does not change variable v can be reordered such that all operators that
change variables in C1 come before all operators that change variables in C2 .
Lemma 19. Let  = (V, init, goal, A) be a planning instance such that G = CG() is a
polypath. Let v be an arbitrary variable in V , let C0 = {v} and let C1 , C2  V be the two
(possibly empty) weakly connected components of G that result if vertex v is removed from
G. Define Ai = {a  A | vars(post(a))  Ci } for all i (0  i  2). Let P be a plan for .
Let P1 , P2 and Q be operator sequences such that P = P1 , Q, P2 and Q contains no operator
from A0 . Let Q1 be the subsequence of Q containing only operators from A1 and let Q2
be the subsequence of Q containing only operators from A2 . Then P1 , Q1 , Q2 , P2 is a plan
for .
Proof. Assume C0 , C1 and C2 as defined in the lemma and recall that C0 = {v}. First
note that G is acyclic since it is a polypath, so all operators in A are unary. It follows
that {A0 , A1 , A2 } is a partition of A and, thus, that A0  A1  A2 = A. Let s0 = init[P1 ].
Obviously, (vars(pre(a))C2 = (vars(post(a))C2 =  for all a in Q1 and (vars(pre(a))C1 =
(vars(post(a))  C1 =  for all a in Q2 , i.e. for any state s it holds that s[a]  C2 = s  C2 for
all a in Q1 and that s[a]  C1 = s  C1 for all a in Q2 . Furthermore, for any state s it holds
600

fiA Refined View of Causal Graphs and Component Sizes

that s[a](v) = s(v) for all a in Q, since a 6 A0 . It follows that s0 [Q]  C1 = s0 [Q1 ]  C1 and
s0 [Q]  C2 = s0 [Q2 ]  C2 . Hence,
s0 [Q1 , Q2 ]  C0 = s0 [Q]  C0 ,
s0 [Q1 , Q2 ]  C1 = s0 [Q1 ]  C1 = s0 [Q]  C1 and
s0 [Q1 , Q2 ]  C2 = s0 [Q2 ]  C2 = s0 [Q]  C2 .
That is, s0 [Q1 , Q2 ] = s0 [Q] and it follows that also P1 , Q1 , Q2 , P2 is a plan for .
We now prove that if  is a planning instance such that CG() is a polypath, then we
can subdivide any edge in CG() and create a planning instance 0 such that CG(0 ) is
this subdivision of CG() and 0 is solvable if and only if  is solvable.
Lemma 20. Let  be a planning instance such that CG() is a polypath and let e be an
edge in CG(). Then there is a planning instance 0 such that
 0 can be constructed from  in polynomial time,
 CG(0 ) is an edge subdivision of e in CG() and
 0 has a solution if and only if  has a solution.
Proof. Let  = (V, init, goal, A) be a planning instance such that CG() is a polypath and
let e = (u, v) be an edge in CG(). Construct a new instance 0 = (V 0 , init0 , goal0 , A0 )
as follows:
 V 0 = V  {w}, where D(w) = D(u) and w 6 V .
 init0 (v) = init(v), for all v  V , and
init0 (w) = init(u).
 goal0 = goal.
 Let A0 consist of the following groups of operators:
1. Let A0 contain all operators a  A such that u 6 vars(pre(a)) or v 6 vars(post(a)).
2. Let A0 contain the operator a[u/w] for every operator a  A such that
u  vars(pre(a)) and v  vars(post(a)).
3. Let A0 contain an operator copy(u, w, x) = hu = x ; w = xi for every value
x  D(v).
The operators in group 1 are the original operators from A corresponding to all edges in
CG() except (u, v). The operators in group 2 are the operators from A corresponding
to edge (u, v) but modified to instead correspond to the new edge (w, v). The operators
in group 3 correspond to the new edge (u, w) and are defined such that variable w can
mimic variable u. Clearly, this is a polynomial-time construction and CG(0 ) is an edge
subdivision of CG(). It remains to prove that 0 has a plan if and only if  has a plan.
If: Suppose P = a1 , . . . , an is a plan for . Construct a new operator sequence P 0
over A0 from P as follows: First, for each ai in P such that u  vars(pre(ai )) and v 
vars(post(ai )), replace ai with ai [u/w]. Then, for each ai in P such that u  vars(post(ai )),
601

fiBackstrom & Jonsson

let x = post(ai )(u) and add operator copy(u, w, x) between ai and ai+1 . The resulting
sequence P 0 is a plan for 0 .
Only if: Suppose P = a1 , . . . , an is a plan for 0 . Define the corresponding state sequence
s0 , . . . , sn such that s0 = init0 and si = s0 [a1 , . . . , ai ] for all i (1  i  n). Without losing
generality, assume that P is a shortest plan for 0 , which implies that ai is applicable in
si1 for every i (1  i  n). Define three variable sets C0 , C1 and C2 as in Lemma 19 such
that C0 = {w}, v  C1 and u  C2 . Also define the corrsponding partition {A0 , A1 , A2 } of
A0 , i.e. Ai = {a  A0 | vars(post(a))  Ci } for all i (0  i  2). Then A0 contains all copy
operators and nothing else. Before proving the main result of this direction, we first prove
the following auxiliary result:
According to Lemma 19 we can assume that every longest subsequence ak , . . . , a` that
does not contain any operator from A0 is on the form ak , . . . , am , am+1 , . . . , a` such that
ak , . . . , am  A1 and am+1 , . . . , a`  A2 . Since it is a longest such sequence, it must
hold that either (1) k = 1 or (2) ak1  A0 . In case (1) we have sk1 = s0 = init0 , so
sk1 (u) = sk1 (w) since init0 (u) = init0 (w). In case (2) operator ak1 = copy(u, w, x) for
some x such that sk1 (w) = sk2 (u) = x. Hence, sk1 (u) = sk1 (w) = x since ak1 does
not change u. That is, in either case we have sk1 (u) = sk1 (w). Furthermore, for all i
(k  i  m) it holds that si  (C0  C2 ) = sk1  (C0  C2 ) since ai  A1 . It follows that
si (u) = si (w) for all i (k  i  m). Now, for every i (k  i  `), if w  vars(pre(ai )) then
ai must be on the form a[u/w], for some a  A, so v  vars(pre(ai )) by definition. Hence,
ai  A1 so i  m and it follows that si1 (u) = si1 (w). Since this proof holds for all longest
subsequences not containing any operator from A0 we can conclude the following, which
will be used below:
(*) For any operator ai in P such that ai = a[u/w] for some a  A, it holds that
si1 (u) = si1 (w).
We now prove the main result of this direction, that also  has a plan since 0 has a
plan. We do so by constructing a plan P 00 for  from P in two steps. First we construct an
intermediate operator sequence P 0 and then construct the plan P 00 from P 0 . The sequence
P 0 is technically not a plan for either  or 0 , but this intermediate step makes the proof
clearer. Temporarily introduce a virtual dummy operator dum that has no precondition
and no postcondition, i.e. it is applicable in any state and has no effect. Then construct
the new operator sequence P 0 = b1 , . . . , bn over A  {dum} as follows:
 If ai  A, then bi = ai .
 If ai is a copy operator, then bi = dum.
 Otherwise, ai = a[u/w] for some operator a  A, so let bi be that operator a.
Define the corresponding state sequence t0 , . . . , tn such that t0 = init0 and ti = t0 [b1 , . . . , bi ]
for all i (1  i  n). We claim that ti  V = si  V for all i (0  i  n). Proof by induction
over i:
Basis: t0 = s0 by definition.
Induction: Suppose ti1  V = si1  V for some i (1  i  n). There are three cases:
(1) ai = bi and ai  A. Then w is not in the pre- or postcondition of either ai or bi so
bi is applicable in ti1 since ai is applicable in si1 and ti1  V = si1  V by assumption.
Furthermore, ti  V = ti1 [bi ]  V = si1 [ai ]  V = si  V .
602

fiA Refined View of Causal Graphs and Component Sizes

(2) ai is a copy operator and bi = dum. It is immediate from the definition of bi
that it is applicable in ti1 and that ti = ti1 . Furthermore, vars(post(ai ))  V =  so
si  V = si1  V . Since ti1  V = si1  V by assumption it thus follows that ti  V = si  V .
(3) ai is bi [u/w] and bi  A. It follows from (*) that si1 (w) = si1 (u), so si1 (w) =
ti1 (u) since u  V and ti1  V = si1  V by assumption. Since ai is applicable in si1 ,
pre(ai )(w) = pre(bi )(u) and pre(ai )(x) = pre(bi )(x) for all variables in V \{u}, it follows that
bi is applicable in ti1 . By definition, vars(post(bi )) = vars(post(ai )) = {v}, since both ai
and bi must be unary, and it thus also follows from the definition that post(bi ) = post(ai ).
Hence, it also follows that ti  V = si  V , since ti1  V = si1  V by assumption.
We have thus shown that ti  V = si  V for all i (0  i  n). Furthermore, clearly
ti = ti1 for all i such that bi = dum. It follows that we can create a plan P 00 for  by
removing all dummy operators from P 0 .
We conclude that  has a solution if and only if 0 has a solution.
We will finally need the following observations about 3SAT instances. Let F be a 3SAT
formula with n variables and m clauses. If it contains no repeated clauses, then
m
n
 m  8n3 and, thus, ( )1/3  n  3m.
3
8
Furthermore, F can be represented as a list of 3m literals which requires 3m(1 + log n) 
3m(1 + log 3m) bits, plus some overhead. Hence, F can be represented by at most cm2 bits,
for some constant c, and we will later use the upper bound 40m3 , which is safe.
We also note that the reduction used in the proof of Lemma 6 transforms a 3SAT
instance with n variables and m clauses to a planning instance with N = (2m + 4)n
variables. However, n  3m so N  (2m + 4)  3m = 6m2 + 12m, which can be safely
overestimated with N  18m2 .
6.3 The Main Theorem
We are now prepared to state and prove the main theorem of this section. It follows from the
proof of Theorem 14 that if in-deg(C), out-deg(C) and upath-length(C) are all bounded for a
class C of graphs, then cc-size(C) is bounded. In that case it is immediate from Theorem 3
that planning is tractable for C. This begs the question what happens if these parameters are
not bounded by a constant, yet bounded by some slow-growing function? We will consider
the case when they are allowed to grow slowly, as long as they are polynomially related to
the instance size. Since we have also noted that practical planning problems will typically
not have a causal graph of every size, we will only require that for every graph G in C there
must also be some larger graph G0 in C of size at most p(|G|), for some polynomial p. We
also define the parameter  (G) = max{upath-length(G), in-deg(G), out-deg(G)}, and require
that  (G) and ||G|| are polynomially related. It turns out that planning is still hard under
these restrictions, as the following theorem says.
Theorem 21. Let p and q be increasing polynomials on the natural numbers. Let C be
a class of directed graphs containing a subset of weakly connected graphs G1 , G2 , G3 , . . .
such that:
1. |V (G1 )|  p(q(1)),
|V (Gi1 )| < |V (Gi )|  p(|V (Gi1 )|), for all i > 1, and
603

fiBackstrom & Jonsson

2. |V (Gi )|  q( (Gi )), for all i  1.
If PlanExist(C) is polynomial-time solvable, then the polynomial hierarchy collapses. This result holds even when restricted to operators with at most 2 preconditions and 1 postcondition
and all graphs in C are acyclic.
Proof. Let G1 , G2 , G3 , . . . be a sequence of weakly connected graphs in C as assumed in the
theorem. Let H1 , H2 , H3 , . . . be a sequence of graphs defined as follows: for each i > 0,
Hi = Gj for the smallest j such that q(i)  |V (Gj )|.
We first prove that i underestimates  (Hi ). Combining the requirement that q(i) 
|V (Gj )| with condition 2 of the theorem, that |V (Gj )|  q( (Gj )), we get q(i)  |V (Gj )| 
q( (Gj )). Since Hi = Gj we get q(i)  |V (Hi )|  q( (Hi )), that is, that i   (Hi ). It
follows that also i  |V (Hi )| holds.
We then prove that |V (Hi )| is polynomially bounded by p(q(i)). Since j is choosen as the
smallest value satisfying that q(i)  |V (Gj )|, it must be that either j = 1 or |V (Gj1 )| <
q(i). If j = 1, then Hi = Gj = G1 and |V (G1 )|  p(q(1)) by condition 1 in the theorem.
Hence, |V (Hi )| = |V (G1 )|  p(q(1))  p(q(i)), since p and q are increasing. Otherwise,
when j > 1, condition 1 of the lemma says that |V (Gj )|  p(|V (Gj1 )|). Combining
this with the inequality |V (Gj1 )| < q(i) yields that |V (Gj )|  p(|V (Gj1 )|) < p(q(i)),
that is, |V (Hi )|  p(q(i)) since Hi = Gj . Combining this with the previous result that
i  |V (Hi )| and the construction of Hi yields that H1 , H2 , H3 is a sequence of graphs with
non-decreasing and unbounded size.
Now, define a sequence A0 , A1 , A2 , . . . of tuples such that for all i  0, either of the
following holds:
1. in-deg(Hi )  i and Ai = (in-deg, Hi , Xi ) such that Xi is a subgraph of Hi and Xi ' Siin .
2. out-deg(Hi )  i and Ai = (out-deg, Hi , Xi ) such that Xi is a subgraph of Hi and
Xi ' Siout .
3. upath-length(Hi )  i and Ai = (upath-length, Hi , Xi ) such that Xi is a subgraph of Hi
and Xi is a polypath of length i.
For every i > 0, at least one of these three cases must hold since i   (Hi ).
Define an advice-taking Turing machine M that uses the sequence A1 , A2 , A3 , . . . as
advice and takes 3SAT formulae as input. Assume that the representation of each formula
F is padded to size 40m3 bits, where m is the number of clauses. Although somewhat
redundant, this is still a reasonable encoding in the sense of Garey and Johnson (1979).
Let M work as follows. Let F be an input formula with n variables and m clauses and
let t = ||F || = 40m3 . Then the advice is At = (x, Ht , Xt ). First M constructs a planning
instance F . There are three cases depending on x:
x = in-deg: By construction, Xt is a subgraph of Ht such that Ht ' Stin . Since t = 40m3
and n  3m, it follows that n  t, so Xt contains a subgraph H 0 such that H 0 ' Snin .
Construct F in the same way as in the proof of Lemma 4, using the vertices of H 0
as variables. Then, CG(F ) = H 0 .
x = out-deg: Analogous to previous case, but constructing F according to the proof of
Lemma 5 instead.
604

fiA Refined View of Causal Graphs and Component Sizes

x = upath-length: By construction, Xt is a subgraph of Ht which is a polypath of length
t = 40m3 . Suppose that Xt contains less than m sinks and m + 1 sources and that
path-length(Xt ) < 18m2 . It then follows from Proposition 1 that
|V (Xt )| < 2m  18m2 + 1 = 36m3 + 1 < 40m3 = t.
However, this contradicts the construction so Xt must either contain a directed path
of length 18m2 or have at least m sinks and m + 1 sources.
1. If Xt contains a subgraph H 0 which is a directed path of length 18m2 , then
construct a planning instance F according to the proof of Lemma 6, using the
vertices from H 0 as variables. Then, CG(F ) ' H 0 .
2. If Xt contains a subgraph H 0 which is a polypath with m sinks and m+1 sources,
then construct a planning instance 
F according to the proof of Lemma 7, us0
+1
ing the variables of H as variables. Then, CG(
F ) ' Fm . This graph is a
fence, i.e. a polypath where all directed paths are of length 1. Each such path
can be stretched to a directed path of arbitrary length by repeatedly applying
Lemma 20. The graph H 0 is a polypath that can be used as a template for
which paths in CG(
F ) to stretch and how much in order to get a graph that
0
is isomorphic to H . Instance 
F can thus be modified into a new instance F
such that CG(F ) ' H 0 .
All these constructions can be done in polynomial time, and for all cases, F has a
solution if and only if F is satisfiable. Furthermore, CG(F ) is isomorphic to a subgraph
of Ht in all four cases. According to Lemma 17 it is thus possible to extend F to a new
+
+
planning instance +
F such that CG(F ) ' Ht and F has a solution if and only if  has
a solution. This extension can be done in polynomial time according to the same lemma.
Since PlanExist(C) can be solved in polynomial time by assumption in the theorem,
it thus follows that M can solve 3SAT in polynomial time. However, this implies that
NP  P/poly, which is impossible unless the polynomial hierarchy collapses (Theorem 16).
To see that the result holds even if the operators under consideration have at most 2
preconditions and 1 postcondition, simply note that this restriction holds for all reductions
used in the underlying NP-hardness proofs in Section 4. Similarly, the acyclicity restriction
holds since the result is based only on in-stars, out-stars and polypaths, which are all
acyclic graphs.
Recall the generic blocks world encoding that we discussed in the beginning of this
section. The class D of causal graphs for these blocks-world instances satisfies the requirements in Theorem 21, which means that PlanExist(D) is not likely to be tractable. However,
finding non-optimal plans for blocks world is tractable; a plan of length at most twice the
length of the optimal plan can be found in polynomial time (Gupta & Nau, 1992). That is,
there are most likely more difficult problems than blocks world that happen to have exactly
the same causal graphs, which illustrates that the complexity of a generic planning problem
cannot be deduced from its corresponding class of causal graphs alone.
605

fiBackstrom & Jonsson

7. NP-Hard and NP-Intermediate Classes
The theorem by Chen and Gimenez (2010) states a crisp complexity-theoretic borderline: if
the component sizes are bounded by a constant, then planning is polynomial-time solvable
and, otherwise, planning is not polynomial-time solvable. We have exploited an extra
constraint, SP-closure, to be able to prove NP-hardness, which leaves a greyzone between
the polynomial cases and the NP-hard ones. If we no longer require the classes to be SPclosed, then they are no longer obviously NP-hard even if the components are unbounded.
The natural question then arises, can we say something about this middle ground? For
instance, can we say something about what the NP-intermediate cases may look like and
where the borderline between NP-hard and NP-intermediate is? Although it does not seem
likely that we could find any results that characterize this borderline exactly, we can at
least give some partial answers to these questions. We will do this by proving two theorems
related to the growth rate of the components. The first of these shows that planning is still
NP-hard if the components grow as O(|V (G)|1/k ) for integers k, while the second one shows
that planning is likely to be NP-intermediate if the components grow polylogarithmically.
Theorem 22. For every constant integer k > 1, there is a class Gk of graphs such that
cc-size(G)  |V (G)|1/k for all G  Gk and PlanExist(Gk ) is NP-hard.
Proof. Let k > 1 be an arbitrary integer. Construct the graph class Gk = {G1 , G2 , G3 , . . .}
as follows. For each m > 0, let Gm have mk1 components, each of them isomorphic to dPm ,
i.e. |V (Gm )| = mk so all components are of size m = |V (Gm )|1/k . We prove NP-hardness
of PlanExist(Gk ) by reduction from PlanExist(dP). Let  be an arbitrary planning instance
such that CG()  dP. Then CG() = dPm for some m > 0. Construct a new instance 0
which consists of mk1 renamed copies of . This is clearly a polynomial time construction
since k is constant and m < ||||. Furthermore, CG(0 ) is isomorphic to Gm and 0 has a
solution if and only if  has a solution. Hence, this is a polynomial reduction so it follows
from Lemma 6 that PlanExist(Gk ) is NP-hard.
Obviously, the size of the graphs is exponential in k.
Our second result must be conditioned by the assumption that the exponential time
hypothesis (Impagliazzo & Paturi, 2001; Impagliazzo, Paturi, & Zane, 2001) holds. This
hypothesis is a conjecture stated as follows.
Definition 23. For all constant integers k > 2, let sk be the infimum of all real numbers
 such that k-SAT can be solved in O(2n ) time, where n is the number of variables of an
instance. The exponential time hypothesis (ETH) is the conjecture that sk > 0 for all k > 2.
Informally, ETH says that satisfiability cannot be solved in subexponential time. ETH
is not just an arbitrarily choosen concept, but a quite strong assumption that allows for
defining a theory similar to the one of NP-completeness. There is a concept called SERF
(subexponential reduction family) reduction which preserves subexponential time solvability. There is also a concept called SERF-completeness which is similar to NP-completeness,
but based on SERF reductions. That is, there is a subclass of the NP-complete problems
that are also SERF-complete, meaning that these can all be SERF reduced to each other.
Hence, if one of these can be solved in subexponential time, then all of them can.
606

fiA Refined View of Causal Graphs and Component Sizes

Theorem 24. For all constant integers k > 0 and all classes C of directed graphs, if
cc-size(G)  logk |V (G)| for all G  C, then PlanExist(C) is not NP-hard unless ETH
is false.
Proof. Let k > 0 be an arbitrary integer. Let  be an arbitrary planning instance with n
variables of maximum domain size d such that cc-size(CG())  c. The components correspond to independent subinstances, which can thus be solved separately. Each component
has a state space of size dc or less, so a plan for the corresponding subinstance can be found
in O(d2c ) time, using Dijkstras algorithm. Since there are at most n components, the whole
instance can be solved in O(nd2c ) time. However, it follows from the standard assumptions
of reasonable encodings that both n  |||| and d  ||||, so a looser bound is that  can
be solved in O(x  x2c ) = O(x1+2c ) time, where x = ||||.
Suppose PlanExist(C) is NP-hard. Then there is a polynomial reduction from 3SAT
to PlanExist(C). Furthermore, the size of a 3SAT instance is polynomially bounded in the
number of variables. Hence, there must be some polynomial p such that for a 3SAT instance
with n variables, the corresponding planning instance  has size ||||  p(n).
Since the number of variables in  is upper bounded by ||||, it follows from the assumption that the component size is upper bounded by logk ||||  logk p(n). Hence,  can
k
be solved in O(p(n)1+2 log p(n) ) time, according to the earlier observation, and
p(n)1+2 log

k

p(n)

= (2log p(n) )1+2 log

k

p(n)

 (2(1+2 log

k

p(n)) logk p(n)

)  23 log

2k

2k

p(n)

.

2k

Furthermore, logk p(n)  O(logk n), since p is a polynomial, so 23 log p(n)  2O(log n) and
2k
it follows that  can be solved in 2O(log n) time. However, then  can be solved in 2n
time for arbitrarily small , which contradicts ETH. It follows that PlanExist(C) cannot be
NP-hard unless ETH is false.
Since the components are unbounded, this problem is not likely to be solvable in polynomial
time either. It is thus an NP-intermediate problem under the double assumption that
W[1] 6 nu-FPT and that ETH holds.
Theorems 22 and 24 together thus tell us something about where the borderline between
NP-intermediate and NP-hard graph classes is. However, it is not a very crisp distinction;
asymptotically, there is quite a gap between the polylogarithmic functions and the root
functions (i.e. functions on the form x1/k ). One may, for instance, note that the function
1

f (n) = 2(log n)

1
(log log n)c

lies within this gap whenever 0 < c < 1.

8. Discussion
SP-closed graph classes have appealing properties and fit in well as a concept stronger than
subgraph-closed but weaker than minor-closed. They also give a partial characterization of
where the borderline to NP-hardness lies. However, as noted earlier, it is possible to define
other types of graph classes which also imply that planning is NP-hard. One example is
the family G1 , G2 , G3 , . . . of classes in the proof of Theorem 22. Another more specialized
and, perhaps, contrived class is the following, intended to give a contrast to the SP-closure
concept and the Gk classes.
607

fiBackstrom & Jonsson

A tournament is a directed graph formed by giving directions to each edge in a complete
graph. Let T denote the set of tournaments and note that T is not SP-closed. However,
tournaments are Hamiltonian graphs (Redei, 1934) so if T is a tournament on n vertices,
then path-length(T ) = n  1. Furthermore, the path of length n  1 can be computed in
polynomial time (Bar-Noy & Naor, 1990).
Assume we are given a 3SAT formula F with n variables and m clauses. Let ` =
(2m + 4)n, i.e. ` is polynomially bounded in F . According to Lemma 6 we can thus
construct a planning instance F in polynomial time such that
1. F contains ` variables,
2. CG(F ) ' dP` , and
3. F has a solution if and only if F is satisfiable.
Choose an arbitrary tournament T with ` vertices in T. Find the path of length `1 in T
and identify it with CG(F ). Then add dummy operators corresponding to the remaining
edges of T . We have thus shown that there is a polynomial-time transformation from 3SAT
to PlanExist(T), and that PlanExist(T) is NP-hard. One may also note that variations of
this technique can be used for proving that PlanExist(T0 ) is NP-hard for many different
T0  T.
While we have not considered domain sizes or tractable restrictions in this article, we
note that the Theorem 24 may give some ideas for where to look for tractable cases. Consider
the case where all variable domains are bounded in size by some constant k and where
cc-size(G)  log V (G). Using the first part of the proof, we see that planning can be solved
in O(n  k 2 log n ) time. However, k 2 log n = (2log k )2 log n = (2log n )2 log k = n2 log k , which is
polynomial since k is a constant. That is, planning is tractable for this restricted case. Even
though this observation is straightforward, it is interesting as a contrast to Theorem 24. It
also suggests that there are even larger tractable subgraphs if we also consider additional
restrictions on the planning instances.
While we have explicitly commented on the sufficient number of pre- and postconditions
for the various results, there are also alternative such characterizations that might be relevant. It would bear to far to list all such possibilities, so let it suffice with one example.
The concept of prevail conditions, i.e. preconditions on variables that are not changed by
the operator, originate from the SAS+ formalism (Backstrom & Nebel, 1995) but has more
recently been considered also in the context of causal graphs. Gimenez and Jonsson (2012)
refer to an operator as k-dependent if it has a precondition on at most k variables that it
does not also change. We may note that the proofs of Lemmata 17 and 20 only introduce
operators that are 1-dependent, at most. Since the proof of Theorem 21 does not impose
any further such restrictions on the original planning instance, it follows that this theorem
holds also when all operators are 1-dependent, at most.
As a final question, one might wonder if it is of any practical use at all to know that
planning is tractable, or NP-intermediate, for severely limited component sizes? After all,
most planning instances are likely to have a causal graph that is weakly connected, that
is, the whole graph is one single component. To answer that question, the first important
observation to make is that the complexity of planning for instances is directly related to
the complexity of planning for the components separately. This is because there can be at
608

fiA Refined View of Causal Graphs and Component Sizes

most linearly (in the number of variables) many components. If planning can be solved in
polynomial time for all components of an instance, then it can be solved in polynomial time
for the whole instance. Conversely, if planning cannot be solved in polynomial time for the
whole instance, then there is at least one component which is not polynomial-time solvable.
That is, the complexity results for instances and for components are directly related to each
other. In other words, the results are relevant for all methods that artificially split the causal
graph into components, in one way or another. Examples are the causal-graph heuristic by
Helmert (2006a), factored planning (Brafman & Domshlak, 2006) and structural pattern
data bases (Katz & Domshlak, 2010).

Acknowledgments
The anonymous reviewers provided valuable comments and suggestions for improving this
article.

References
Backstrom, C., & Nebel, B. (1995). Complexity results for SAS+ planning. Computational
Intelligence, 11, 625656.
Bar-Noy, A., & Naor, J. (1990). Sorting, minimal feedback sets, and Hamilton paths in
tournaments. SIAM Journal on Discrete Mathematics, 3 (1), 720.
Biggs, N. (1993). Algebraic Graph Theory. Cambridge Univ. Press. 2nd ed.
Bodirsky, M., & Grohe, M. (2008). Non-dichotomies in constraint satisfaction complexity.
In Proceedings of the 35th International Colloquium on Automata, Languages and
Programming (ICALP 2008), Reykjavik, Iceland, pp. 184196.
Brafman, R. I., & Domshlak, C. (2003). Structure and complexity in planning with unary
operators. Journal of Artificial Intelligence Research, 18, 315349.
Brafman, R. I., & Domshlak, C. (2006). Factored planning: How, when, and when not. In
Proceedings of the 21st National Conference on Artificial Intelligence (AAAI 2006),
Boston, MA, USA, pp. 809814. AAAI Press.
Chen, H., & Gimenez, O. (2010). Causal graphs and structurally restricted planning. Journal of Computer and Systems Science, 76 (7), 579592.
Domshlak, C., & Dinitz, Y. (2001a). Multi-agent off-line coordination: Structure and complexity. In Proceedings of the 6th European Conference on Planning (ECP01), Toledo,
Spain.
Domshlak, C., & Dinitz, Y. (2001b). Multi-agent off-line coordination: Structure and complexity. Tech. rep., Department of Computer Science, Ben-Gurion University. CS-0104.
Downey, R. G., & Fellows, M. R. (1999). Parameterized Complexity. Monographs in Computer Science. Springer, New York.
Flum, J., & Grohe, M. (2006). Parameterized Complexity Theory, Vol. XIV of Texts in
Theoretical Computer Science. An EATCS Series. Springer, Berlin.
609

fiBackstrom & Jonsson

Garey, M. R., & Johnson, D. S. (1979). Computers and Intractability: A Guide to the Theory
of NP-Completeness. W. H. Freeman, New York.
Gimenez, O., & Jonsson, A. (2008). The complexity of planning problems with simple
causal graphs. Journal of Artificial Intelligence Research, 31, 319351.
Gimenez, O., & Jonsson, A. (2009). Planning over chain causal graphs for variables with
domains of size 5 is NP-hard. Journal of Artificial Intelligence Research, 34, 675706.
Gimenez, O., & Jonsson, A. (2012). The influence of k-dependence on the complexity of
planning. Artificial Intelligence, 177-179, 2545.
Gupta, N., & Nau, D. S. (1992). On the complexity of blocks-world planning. Artificial
Intelligence, 56 (2-3), 223254.
Helmert, M. (2003). Complexity results for standard benchmark domains in planning.
Artificial Intelligence, 143 (2), 219262.
Helmert, M. (2004). A planning heuristic based on causal graph analysis. In Proceedings
of the 14th International Conference on Automated Planning and Scheduling (ICAPS
2004), Whistler, BC, Canada, pp. 161170. AAAI Press.
Helmert, M. (2006a). The Fast Downward planning system. Journal of Artificial Intelligence
Research, 26, 191246.
Helmert, M. (2006b). New complexity results for classical planning benchmarks. In Proceedings of the 16th International Conference on Automated Planning and Scheduling
(ICAPS 2006), Cumbria, UK, pp. 5262. AAAI Press.
Impagliazzo, R., & Paturi, R. (2001). On the complexity of k-SAT. Journal of Computer
and System Science, 62 (2), 367375.
Impagliazzo, R., Paturi, R., & Zane, F. (2001). Which problems have strongly exponential
complexity?. Journal of Computer and System Science, 63 (4), 512530.
Jonsson, A. (2009). The role of macros in tractable planning. Journal of Artificial Intelligence Research, 36, 471511.
Jonsson, P., & Backstrom, C. (1998a). State-variable planning under structural restrictions:
Algorithms and complexity. Artificial Intelligence, 100 (1-2), 125176.
Jonsson, P., & Backstrom, C. (1998b). Tractable plan existence does not imply tractable
plan generation. Annals of Mathematics and Artificial Intelligence, 22 (3-4), 281296.
Karp, R. M., & Lipton, R. J. (1980). Some connections between nonuniform and uniform complexity classes. In Proceedings of the 12th ACM Symposium on Theory of
Computing (STOC80), Los Angeles, CA, USA, pp. 302309.
Katz, M., & Domshlak, C. (2007). Structural patterns of tractable sequentially-optimal
planning. In Proceedings of the 17th International Conference on Automated Planning
and Scheduling (ICAPS 2007), Providence, RI, USA, pp. 200207. AAAI Press.
Katz, M., & Domshlak, C. (2008). New islands of tractability of cost-optimal planning.
Journal of Artificial Intelligence Research, 32, 203288.
Katz, M., & Domshlak, C. (2010). Implicit abstraction heuristics. Journal of Artificial
Intelligence Research, 39, 51126.
610

fiA Refined View of Causal Graphs and Component Sizes

Katz, M., Hoffmann, J., & Domshlak, C. (2013). Who said we need to relax all variables?. In Proceedings of the 23rd International Conference on Automated Planning
and Scheduling (ICAPS 2013), Rome, Italy, 126134. AAAI Press.
Katz, M., & Keyder, E. (2012). Structural patterns beyond forks: Extending the complexity
boundaries of classical planning. In Proceedings of the 26th AAAI Conference on
Artificial Intelligence (AAAI 2012), Toronto, ON, Canada. AAAI Press.
Knoblock, C. A. (1994). Automatically generating abstractions for planning. Artificial
Intelligence, 68 (2), 243302.
Kuhn, D., Osthus, D., & Young, A. (2008). A note on complete subdivisions in digraphs of
large outdegree. Journal of Graph Theory, 57 (1), 16.
Ladner, R. E. (1975). On the structure of polynomial time reducibility. Journal of the
ACM, 22 (1), 155171.
Lovasz, L. (2005). Graph minor theory. Bulletin of the AMS, 43 (1), 7586.
Mohar, B. (2006). What is ... a graph minor. Notices of the AMS, 53 (3), 338339.
Redei, L. (1934). Ein kombinatorischer Satz. Acta Litteraria Szeged, 7, 3943.
Wehrle, M., & Helmert, M. (2009). The causal graph revisited for directed model checking.
In Proceedings of Static Analysis, the 16th International Symposium (SAS09), Los
Angeles, CA, USA, Vol. 5673 of LNCS, pp. 86101. Springer.
Williams, B., & Nayak, P. P. (1997). A reactive planner for a model-based executive.
In Proceedings of the 15th International Joint Conference on Artificial Intelligence
(IJCAI97), Nagoya, Japan, pp. 11781185.

611

fi