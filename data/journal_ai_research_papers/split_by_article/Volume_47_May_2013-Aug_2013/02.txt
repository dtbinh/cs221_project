Journal of Artificial Intelligence Research 47 (2013) 71-93

Submitted 11/12; published 05/13

Identifying the Class of Maxi-Consistent Operators in Argumentation
Srdjan Vesic

VESIC @ CRIL . FR

CRIL - CNRS
Rue Jean Souvraz SP 18
F 62307 Lens Cedex
FRANCE

Abstract
Dungs abstract argumentation theory can be seen as a general framework for non-monotonic
reasoning. An important question is then: what is the class of logics that can be subsumed as
instantiations of this theory? The goal of this paper is to identify and study the large class of
logic-based instantiations of Dungs theory which correspond to the maxi-consistent operator, i.e. to
the function which returns maximal consistent subsets of an inconsistent knowledge base. In other
words, we study the class of instantiations where every extension of the argumentation system
corresponds to exactly one maximal consistent subset of the knowledge base. We show that an
attack relation belonging to this class must be conflict-dependent, must not be valid, must not be
conflict-complete, must not be symmetric etc. Then, we show that some attack relations serve as
lower or upper bounds of the class (e.g. if an attack relation contains canonical undercut then it is
not a member of this class). By using our results, we show for all existing attack relations whether
or not they belong to this class. We also define new attack relations which are members of this
class. Finally, we interpret our results and discuss more general questions, like: what is the added
value of argumentation in such a setting? We believe that this work is a first step towards achieving
our long-term goal, which is to better understand the role of argumentation and, particularly, the
expressivity of logic-based instantiations of Dung-style argumentation frameworks.

1. Introduction
A question whether Dungs (1995) abstract theory can be used as a general framework for nonmonotonic reasoning has drawn a particular amount of attention among researchers in artificial
intelligence. More precisely, the question is: can existing or new approaches to reasoning be seen
as instantiations of Dungs theory? This is certainly a very general question. Furthermore, different
approaches suppose that the available knowledge is represented in different form. This paper studies the problem setting when one is given a finite inconsistent set of classical propositional logic
formulae, which we refer to as a knowledge base. There are a number of approaches for dealing
with inconsistent information: a notable example are paraconsistent logics (Priest, 2002) where one
is able to draw some (but not all) conclusions from an inconsistent set of formulae. Indeed, each
paraconsistent logic allows for a subset of the inferences that could be obtained using classical logic
with the same knowledge. Other examples of dealing with inconsistent knowledge include belief
revision (Gardenfors, 1988), belief merging (Konieczny & Perez, 2011) or voting (Arrow, Sen, &
Suzumura, 2002). To be completely precise, note that there are approaches where one is given a
multiset instead of a set, for example where several voters can express their knowledge or preferences and the number of agents stating / voting for a proposition is important. However, in this
paper, we suppose that the information is represented in form of a set.
c
2013
AI Access Foundation. All rights reserved.

fiV ESIC

Generally speaking, we call an operator a function which provides a way to go from an inconsistent knowledge base to a set of subsets of that knowledge base. Examples of operators are: a
function returning maximal for set inclusion consistent subsets of a knowledge base, called maxiconsistent operator, a function returning maximal for cardinality consistent subsets of a knowledge
base, called maxi-card operator, a function returning all consistent subsets of a knowledge base...
To understand how and to which extent Dungs theory can be used as a general framework for
reasoning, it is essential to study the link between the result obtained by applying an operator to a
knowledge base  and the extensions of the argumentation framework F = (Arg(), R), where
for a set S  , we denote by Arg(S) the set of all arguments that can be built from S, and by R
the relation used for identifying attacks between arguments. There are papers (Cayrol, 1995; Caminada & Amgoud, 2007; Amgoud & Besnard, 2009, 2010; Amgoud & Vesic, 2010; Gorogiannis
& Hunter, 2011) studying the notions which are somehow related to a link between a knowledge
base and the corresponding argumentation framework. However, since the work of Dung (1995),
there are almost no papers studying the link between an operator and an instantiation of Dungs theory. Cayrol (1995) showed that the instantiation of Dungs theory using stable semantics and direct
undercut as attack relation, corresponds to maxi-consistent operator. In argumentation community,
this one-to-one correspondence is sometimes identified as a main objection against pure logic-based
argumentation, because the additional value of constructing the argumentation framework is then
said to be questionable (since computing the extensions does not do more than applying maxiconsistent operator). However, a recent work by Vesic and van der Torre (2012) shows that there
exists a large class of logic-based instantiations of Dungs abstract theory having two interesting
features: (i) it returns extensions that do not correspond to maximal consistent subsets of the initial
knowledge base, and (ii) its result satisfies basic argumentation postulates (Caminada & Amgoud,
2007), e.g. consistency, closure... That paper shows that the space of logic-based instantiations of
Dungs theory is much larger than it was believed.
The previous result makes the question what is the class of operators that can be viewed as
instantiations of Dungs theory? even more relevant as a research topic. We now aim only at
giving a broad overview of this class. First note that, interestingly, there is a rather big class of
instantiations of Dungs theory returning inconsistent results, as showed by Caminada and Amgoud
(2007). However, one would normally prefer to avoid this type of behaviour, and to study the class
of instantiations returning consistent results.1 Thus, our long-term goal is to identify the whole
class of instantiations of Dungs theory that yield a consistent result. However, that is certainly a
hard task. We start by noticing that, given a set , the most common and a well-known way to deal
with inconsistent information is to use the maxi-consistent operator, i.e. to select maximal consistent
subsets of . Also, we conjecture that one of the biggest2 sub-classes of the class of instantiations
returning a consistent result is the class of instantiations corresponding to maxi-consistent operator.
That is why our first goal, and the main goal of this paper, is to study this class. (Note that a more
general approach would consider the set of maxi-consistent subsets of  and a selection function
f among the maxi-consistent subsets. Thus, only some maxi-consistent sets would be used for
reasoning. However, the present paper studies the case when all the maxi-consistent subsets of 
are taken into account since this already captures a significant number of systems.)
1. Note that while there is no consensus regarding some of the postulates (e.g. indirect consistency), some postulates
(e.g. direct consistency) enjoy much wider acceptance.
2. informally, but in the sense: in number of known instantiations

72

fiI DENTIFYING THE C LASS OF M AXI -C ONSISTENT O PERATORS IN A RGUMENTATION

More particularly, the paper aims to answering the following questions: What are the properties
of attack relations and semantics used in instantiations of Dungs theory that correspond to maxiconsistent operators? What are the necessary and sufficient conditions so that an attack relation
belongs to this class (under a given semantics)? What properties do they satisfy: must (not) they be
conflict-dependent, valid, symmetric, ... ? Can we identify sub-classes of attack relations belonging / not belonging to this class? Can we find the lower and / or the upper bound (in terms of set
inclusion) of this class of attack relations? Which existing (in the literature) attack relations belong
to this class under which semantics? Are there new attack relations belonging to this class?
The paper is organised as follows: Section 2 introduces the main notions of argumentation theory we use in the rest of the paper. Section 3 formally defines the class of instantiations corresponding to maxi-consistent operator. Section 4 shows what properties are satisfied by attack relations
belonging to this class. Section 5 identifies several classes of attack relations (not-)corresponding to
maxi-consistent operator. Section 6 shows for all (to the best of our knowledge) existing attack relations from literature whether or not they belong to this class, and also defines a new attack relation
which is a member of this class. The last section concludes and discusses related work.

2. Basics of Argumentation
As already mentioned, this paper supposes that one is given a set of classical propositional logic
formulae . We use the well-known (e.g. Besnard & Hunter, 2001; Amgoud & Cayrol, 2002;
Gorogiannis & Hunter, 2011) logic-based approach for instantiating Dungs theory. L denotes the
set of well-formed formulae, ` stands for classical entailment, and  for logical equivalence. We
use the notation MC() for the set of all maximal consistent subsets of .
A logical argument is defined as a pair (support, conclusion).
Definition 1 (Argument). An argument is a pair (, ) such that    is a minimal (for set
inclusion) consistent set of formulae such that  ` .
For an argument a = (, ), we use the function Supp(a) =  to denote its support and
Conc(a) =  to denote its conclusion.
Example 1. Let  = {,   , }. a = ({,   }, ), b = ({  },   ) and
c = ({, },   ) are some of the arguments that can be constructed from . For example,
Supp(a) = {,   } and Conc(a) = .
For a given set of formulae S, we denote by Arg(S) the set of arguments constructed from
S. Formally, Arg(S) = {a | a is an argument and Supp(a)  S}. Let Arg(L) denote the set of
all arguments that can be constructedSfrom the language of propositional logic. For a given set of
arguments E, we denote Base(E) = aE Supp(a). We suppose that function Arg is defined on L
and that function Base is defined on Arg(L); by slightly abusing the notation, we sometimes write
Arg (respectively Base) for the restriction of these functions on any set of formulae (respectively
arguments).
Definition 2 (Argumentation system). An argumentation system (AS) is a pair (A, R) where A 
Arg(L) is a set of arguments and R  A  A a binary relation. For each pair (a, b)  R, we say
that a attacks b. We also sometimes use notation aRb instead of (a, b)  R.
73

fiV ESIC

In order to simplify notation, we do not explicitly mention an argumentation system when it
is clear from the context which argumentation system we refer to. Since arguments are built from
formulae, we suppose that an attack relation is defined by specifying a condition such that for every
two arguments a and b, we have that a attacks b if and only if the condition from the definition of
attack relation is satisfied. For example, such a condition can be that the conclusion of a is logically
equivalent to the negation of the conclusion of b. We suppose that all attack relations are defined on
the set Arg(L)  Arg(L), and that for every set A  Arg(L), we use the restriction of the attack
relation on the set AA. That is why, in order to simplify notation, we simply write R for an attack
relation defined on the set Arg(L)  Arg(L) as well as for the restriction of that attack relation on
every set A  A, with A  Arg(L).
In order to determine mutually acceptable sets of arguments, different semantics have been
introduced in argumentation. We first introduce the basic notions of conflict-freeness and defence.
Definition 3 (Conflict-free, defence). Let F = (A, R) be an AS, E  A and a  A.
 E is conflict-free if and only if there exist no arguments a, b  E such that a R b
 E defends a if and only if for every b  A we have that if b R a then there exists c  E such
that c R b.
Let us now define the most commonly used semantics.
Definition 4 (Acceptability semantics). Let F = (A, R) be an AS and B  A. We say that a set B
is admissible if and only if it is conflict-free and defends all its elements.
 B is a complete extension if and only if B defends all its arguments and contains all the
arguments it defends.
 B is a preferred extension if and only if it is a maximal (with respect to set inclusion) admissible set.
 B is a stable extension if and only if B is conflict-free and for all a  A \ B, there exists b  B
such that b R a.
 B is a semi-stable extension if and only if B is a complete extension and the union of the set
B and the set of all arguments attacked by B is maximal (for set inclusion).
 B is a grounded extension if and only if B is a minimal (for set inclusion) complete extension.
 B is an ideal extension if and only if B is a maximal (for set inclusion) admissible set contained
in every preferred extension.
For an argumentation system F = (A, R) we denote by Extx (F); or, by a slight abuse of
notation, by Extx (A, R) the set of its extensions with respect to semantics x. We use abbreviations
c, p, s, ss, g and i for respectively complete, preferred, stable, semi-stable, grounded and ideal
semantics. For example, Extp (F) denotes the set of preferred extensions argumentation system F.
Example 2. Let F = (A, R) be an argumentation framework with A = {a, b, c, d} and R =
{(b, c), (c, b), (b, d), (c, d)}. There are two preferred/stable/semi-stable extensions: {a, b} and {a, c};
three complete extensions: {a}, {a, b} and {a, c}; and one grounded/ideal extension: {a}.
74

fiI DENTIFYING THE C LASS OF M AXI -C ONSISTENT O PERATORS IN A RGUMENTATION

3. Defining the Problem Setting
Until now, we specified how to, from a knowledge base , construct an argumentation system F =
(Arg(), R), and then, using a chosen semantics, calculate extensions. Since all the components
of the system except a semantics and an attack relation are fixed, then whether an instantiation
corresponds to maxi-consistent operator depends exclusively on those two components. The next
definition provides a formal definition of what we mean by saying that an instantiation of Dungs
framework corresponds to maxi-consistent operator. The idea is that the function Arg should be
a bijection between MC() and the extensions of the corresponding argumentation system.
Definition 5 (MC  Ext). Let x be an argumentation semantics. We say that attack relation R
satisfies (MC  Extx ) if and only if for every finite set of propositional formulae  we have that
Arg is a bijection between MC() and Extx (Arg(), R)
This means that for every set S  MC(), it holds that Arg(S)  Ext(Arg(), R) and for
every E  Ext(Arg(), R), there exists S  MC() such that E = Arg(S). For example, we say
that an attack relation R satisfies (MC  Extc ) if and only if for every finite , we have that Arg
is a bijection between MC() and Extc (Arg(), R). Sometimes, when it is clear from the context
which semantics we refer to or when a semantics is not important, we use the simplified notation
(MC  Ext). We say that an attack relation R falsifies (MC  Extx ) if and only if R does not satisfy
(MC  Extx ). The following example shows an attack relation that does not satisfy (MC  Exts ).
Example 3. Consider the attack relation known as defeating rebut, denoted by Rdr and defined
as follows: for two arguments a and b, we say that a attacks b and write aRdr b if and only if
Conc(a) ` Conc(b). This attack relation falsifies (MC  Exts ). To see why, it is sufficient to find
a set of formulae  such that Arg is not a bijection between MC() and (Arg(), Rdr ). To that end,
consider  = {  ,   } and denote F = (Arg(), Rdr ). We see that MC() = {S1 , S2 }
with S1 = {  } and S2 = {  }. Denote E1 = Arg(S1 ) and E2 = Arg(S2 ). If Exts (F) 6=
{E1 , E2 } then Rdr does not satisfy (MC  Exts ). Consider argument a = ({  },   ),
and note that a  E1 . Observe that for every argument b  Arg(), we have that bRdr a if and
only if Conc(b) ` (  ). In other words, for every argument b  Arg(), b attacks a if and
only if Conc(b) `   . Recall that from Definition 1 we know that for every argument b,
Supp(b) ` Conc(b). Thus, for every argument b  Arg(), if bRdr a then Supp(b) `   .
Since  = {  ,   } then there is no argument b  Arg() such that Supp(b) `   .
Thus, argument a is not attacked by any argument of E2 . This means that E2 is not a stable extension
of F. Consequently, Arg is not a bijection between MC() and Exts (F). Hence, Rdr falsifies
(MC  Exts ).
3.1 Complete and Incomplete Systems
There are two ways to study the link between an instantiated argumentation system F (containing
arguments and attacks between them) and the corresponding knowledge base  (containing formulae). The first scenario is as follows:
 choose an attack relation R and a semantics x
 start with a finite knowledge base 
75

fiV ESIC

 consider the system F = (Arg(), R), containing all the arguments that can be built from 
 compare the result obtained by using an operator on  and the one obtained by calculating
the extensions of F
In this case, we say that the obtained argumentation system is complete. Every complete system
has an infinite number of arguments, but for every complete system F, there exists a finite system
F 0 such that F and F 0 are equivalent. How to formally define equivalence between argumentation
systems is not the topic of the present paper; for more details the reader is invited to consult the
literature on this subject (Amgoud, Besnard, & Vesic, 2011).
The second possibility is to do the converse:
 for a given attack relation R and semantics x,
 start with an argumentation system F = (A, R),
 define  as the set of all formulae used in the supports of arguments of F, that is, define
def
 = Base(A)
 compare the result obtained by using an operator on  and the one obtained by calculating
the extensions of F
The obtained argumentation system may be incomplete, in the sense that A =
6 Arg(Base(A)).
There is an important difference between those two scenarios. Namely, in the first case, all the
arguments that can be built from  are considered when calculating Extx (F). In the second case, 
contains all the formulae from A, but in F, not all formulae are equally represented. Let us illustrate
this situation.
Example 4. Let R be defined as: for every a, b  Arg(L), (a, b)  R if and only if there exists
  Supp(b) such that Conc(a)  . Let us use preferred semantics. Let F = (A, R) and
A = {a, b} with a = ({,   }, ) and b = ({}, ). In this case, since b attacks a and not
vice versa, the only extension is E = {b}. Note that the conclusion of the only accepted argument is
. However, if we take  to be the union of all formulae used in supports of the arguments of F,
we obtain  = {, ,   }. There are two maximal consistent subsets of this knowledge base:
MC() = {{,   }, {,   }}.
It is clear that in a setting similar to that in the previous example, or, more generally, in the
second scenario, one cannot expect Arg to be a bijection between MC() and Ext(A, R). But, what
does an incomplete argumentation system stand for? How is it obtained? To conclude that a system
such that A 6= Arg(Base(A)) is meaningless would certainly be too hasty. Let us consider this
question in more detail. Namely, we know that missing arguments can be added by an intelligent
agent. Should we first add all the missing arguments and then calculate the extensions of the
complete version of our system? There are two possible answers: (1) yes, we must add missing
arguments in order to take into account all available information; (2) no, since we are given an
argumentation system and not all arguments have been constructed (in case of monological argumentation) or uttered (in the case of dialogical argumentation). Both arguments (1) and (2) make
sense in different applications: the first possibility corresponds to a case when we want to simulate a
resource unbounded agent, and take into account all the information (where information is seen as
76

fiI DENTIFYING THE C LASS OF M AXI -C ONSISTENT O PERATORS IN A RGUMENTATION

formulae) known by agent(s). Note that this has its disadvantages since by doing so, we ignore the
argumentational representation of the problem. The second possibility is to be used when we want
to know what the output of an argumentation system is, where we do take into account the fact that
not all arguments are constructed (e.g. because of the lack of computational resources, or since the
given argumentation framework is representing a dialogue in which not everything has been said).
Note that numerous works in the 1990s (Pollock, 1992; Vreeswijk, 1997; Loui, 1998) yield
conceptual and philosophical arguments supporting partial computation (i.e. incomplete systems).
An important part of Vreeswijks (1997) work is devoted to defining and constructing complete
argumentation systems. Loui (1998) discusses the philosophical difference between demonstrative
reasoning and non-demonstrative reasoning and claims that in a realistic (i.e. resource-bounded)
setting, not all reasons are demonstrative, and that process and disputation are essential to reasoning. Note, however, that none of those frameworks is an instantiation of Dungs system, and that
formalisations in those works differ a lot from the framework we studied in this paper. The goal of
the present paper is not to argue that complete systems are in any sense better than incomplete
ones (or vice versa), but only to study the possibilities and limits related to instantiating Dungs abstract theory. We will not further analyse the difference between complete and incomplete systems,
but we find it necessary to point out that they exist, in order to make the context of our research
question clear. In the second scenario, it is not reasonable to expect any correlation between the
result obtained directly from  and from F. That is why, in the rest of the paper we suppose the
first scenario.

4. Properties of Relations Satisfying (MCExt)
In this section, we analyse properties of attack relations satisfying (MC  Ext). We first show that
if this condition is satisfied, then the function Base : Ext(F)  MC() is the inverse function of
the function Arg : MC()  Ext(F).
Proposition 1. Let R be an attack relation and x an acceptability semantics. If relation R satisfies
(MC  Extx ) then:
 for every S  MC(), we have that S = Base(Arg(S)),
 for every E  Extx (F), we have that E = Arg(Base(E)).
Proof. Let  be a finite set of propositional formulae and let F = (Arg(), R).
 Let S  MC() and E = Arg(S). Since R satisfies (MC  Ext), then E  Extx (F). Let
S 0 = Base(E) and let us suppose that S 6= S 0 . Let us study two cases.
 Let S \ S 0 6=  and 0  S \ S 0 . This means that there is an argument a  E such that
0  Supp(a) with 0 
/ S, contradiction.
 Let S 0 \ S 6=  and 0  S 0 \ S. This means that there is an argument a  E such that
0  Supp(a). Contradiction with 0 
/ S.
Since S \ S 0 =  and S 0 \ S = , then S = S 0 ; In other words, Base(Arg(S)) = S.
 Let E  Extx (F) and S = Base(E). Since R satisfies (MC  Extx ), then there exists a
unique S 0  MC() such that Arg(S 0 ) = E. Let us prove that S = S 0 .
77

fiV ESIC

 Let us suppose that S \ S 0 6=  and let   S \ S 0 . This means that there is an argument
a  E such that   Supp(a). Contradiction with the fact  
/ S0.
 Suppose that S 0 \ S 6=  and that 0  S 0 \ S. From 0  S 0 , we conclude that there
exists a  E such that 0  Supp(a). Contradiction with the fact that 0 
/ S.
From S \ S 0 =  and S 0 \ S = , we conclude S = S 0 . Thus, Arg(Base(E)) = E.

Let us illustrate this result by the following example.
Example 5. Consider the attack relation known as direct undercut, denoted by Rdu and defined as
follows: for two arguments a and b, we say that a attacks b and we write aRdu b if and only if there
exists   Supp(b) such that Conc(a)  . It is known that direct undercut satisfies (MC  Exts )
(Cayrol, 1995). From Proposition 1, we see that for every , for every S  MC(), it holds that
S = Base(Arg(S)) and, more interestingly, that for every E  Exts (Arg(), Rdu ), we have that
E = Arg(Base(E)).
The previous result allows to easily show that if an attack relation satisfies (MC  Ext), then
every extension has a consistent base and the union of its arguments conclusions is consistent.
Corollary 1. Let R be an attack relation and x a semantics. Let R satisfy (MC  Extx ) and let 
be a finite set of formulae. Denote F = (Arg(), R). Then, for every E  Extx (F), we have:
 Base(E) is consistent
S
 aE Conc(a) is consistent
Proof. Let E  Extx (F). Since R satisfies (MC  Extx ), then there exists S  MC() such that
E = Arg(S). From Proposition 1, we obtain E = Arg(Base(E)). Since Arg is an injective function,
for every S 0  MC(), if E = Arg(S 0 ) then S = S 0 . Thus, S = Base(E). Consequently, Base(E) is
a consistent set. It is clear that
S for every argument a  E, we have that Base(E) ` Conc(a). Since
Base(E) is consistent, then aE Conc(a) is consistent as well.
Note that we can use the previous result to show that an attack relation does not satisfy (MC  Ext).
Namely, if an attack relation returns extensions having inconsistent bases, then it violates (MC  Ext).
Corollary 2. Let R be an attack relation, and x an acceptability semantics. If there exists a finite
knowledge base  such that there exists an extension E  Extx (Arg(), R) such that Base(E) is
inconsistent, then R does not satisfy (MC  Extx ).
4.1 On Conflict-Dependence and Validity
In this subsection, we study the link between satisfying (MC  Ext) and conflict-dependence and
validity. An attack relation is conflict-dependent if whenever an argument attacks another one, the
union of their supports is inconsistent (Amgoud & Besnard, 2009).
Definition 6 (Conflict-dependent). Let R  Arg(L)  Arg(L) be an attack relation. We say that R
is conflict-dependent if and only if for every a, b  Arg(L), if (a, b)  R then Supp(a)  Supp(b) `
.
78

fiI DENTIFYING THE C LASS OF M AXI -C ONSISTENT O PERATORS IN A RGUMENTATION

We now prove that conflict-dependence is a necessary condition for satisfying (MC  Ext). To
be completely precise, we here specify that we say that a semantics x returns conflict-free sets if
and only if for every argumentation system (A, R), for every E  Extx (A, R), it holds that E is
conflict-free with respect to R. All the semantics from Definition 4 return conflict-free sets.
Proposition 2. Let R be an attack relation and x a semantics returning conflict-free sets. If R
satisfies (MC  Extx ), then R is conflict-dependent.
Proof. Let us suppose the contrary, i.e. let R be an attack relation that is not conflict-dependent, let
 be a knowledge base and let a, b  Arg() with aRb and Supp(a)  Supp(b) being consistent.
Thus, there exists a set S  MC() such that Supp(a)Supp(b)  S. Since R satisfies (MC  Extx )
then E = Arg(S) is an extension of the corresponding argumentation system F = (Arg(), R).
This means that a, b  E. Contradiction with the assumption that x returns conflict-free extensions.
Thus, R must be conflict-dependent.
Having proved this, we know that a relation satisfying (MC  Ext) enjoys all the properties
of conflict-dependent relations. For example, it was shown that if an attack relation is conflictdependent, then there are no self-attacking arguments (Amgoud & Besnard, 2009).
Corollary 3. Let R be an attack relation and x a semantics returning conflict-free sets. If R satisfies
(MC  Extx ) then for every argument a  Arg(L), we have that such that (a, a) 
/ R.
Proof. From Proposition 2, we have that R is conflict-dependent. Then, there are no self-attacking
arguments (Amgoud & Besnard, 2009, Prop. 4).
This means that we have another way to identify (some of the) attack relations not satisfying
(MC  Ext): namely, if for an attack relation there exists a self-attacking argument, then the given
attack relation falsifies (MC  Ext) for all semantics returning conflict-free sets. Let us now study
the notion of validity (Amgoud & Besnard, 2010).
Definition 7 (Valid). Let R  Arg(L)  Arg(L) be an attack relation. We say that R is valid if
and only if for every E  Arg(L) it holds that if E is conflict-free, then Base(E) is consistent.
Let us now show that this property is incompatible with conflict-dependence.
Proposition 3. There exists no attack relation which is both conflict-dependent and valid.
Proof. Let R be an attack relation and suppose that R is both conflict-dependent and valid. Let
a = ({}, ), b = ({}, ), c = ({  },   ) and let E = {a, b, c}. Since R is
valid and Base(E) is inconsistent, then E is not conflict-free. Since R is conflict-dependent, then
(a, b) 
/ R, (b, a) 
/ R, (a, c) 
/ R, (c, a) 
/ R, (b, c) 
/ R, (c, b) 
/ R. Thus, E is conflict-free.
Contradiction.
This means that if an attack relation R satisfies (MC  Ext) then there must exist a set E which
is conflict-free with respect to R but whose base is inconsistent.
Corollary 4. Let R be an attack relation and x an acceptability semantics returning conflict-free
sets and let R satisfy (MC  Extx ). Then, R is not valid.
79

fiV ESIC

The proof of the previous fact is a consequence of Proposition 2 and Proposition 3. It is useful
since if an attack relation is valid, we can immediately conclude that it violates (MC  Extx ) for all
(possible) semantics returning conflict-free sets.
On the more general level, we see that asking for every conflict-free set to have a consistent base
is very demanding. Roughly speaking, this is due the fact that attacks are binary whereas minimal
conflicts may be ternary (or of a greater cardinality). Some authors argue that to obtain a consistent
result, one should concentrate on admissibility and not on conflict-freeness. For example, Caminada and Vesic (2012) claim that n-ary attacks, for n  3, are simulated in Dungs framework
throughout the notion of admissibility. Thus, an idea for future work could be to study an alternative
condition, which is that every admissible set has a consistent base.
4.2 Satisfying (MCExt) and Different Acceptability Semantics
In this subsection, we study the properties related to particular semantics. We show that if an attack
relation satisfies (MC  Ext) for stable semantics, then it satisfies it for semi-stable semantics also.
Then we identify conditions under which an attack relation satisfies (MC  Ext) for stable semantics. We provide a similar result for preferred semantics. We also identify a sufficient condition so
that an attack relation falsifies (MC  Ext) under complete semantics. Then, we discuss the case of
single-extension semantics, like grounded and ideal.
First, suppose that R satisfies (MC  Exts ). This means that for every finite set of formulae ,
function Arg is a bijection between MC() and Exts (Arg(), R). Since every finite set of formulae
has at least one maximal consistent subset (even if that is the empty set) then for every , it must
be that (Arg(), R) has at least one stable extension. Since there are stable extensions, then stable
and semi-stable semantics coincide (Caminada, 2006). Thus, we obtain the following proposition.
Proposition 4. Let R be an attack relation. If R satisfies (MC  Exts ) then:
 for every finite set of formulae  and F = (Arg(), R), we have that Exts (F) = Extss (F)
 R satisfies (MC  Extss ).
Let us now prove that in the case of stable semantics, if the image with respect to Arg of every
maximal consistent set is an extension and if the base of every extension is consistent, then the
attack relation in question satisfies (MC  Ext).
Proposition 5. Let R be an attack relation. If for every set of formulae  and F = (Arg(), R),
we have:
 for all S  MC(), Arg(S)  Exts (F), and
 for all E  Exts (F), Base(E) is consistent
then R satisfies (MC  Exts ).
Proof. Let us prove that R satisfies (MC  Exts ). We already know that for every S  MC(),
Arg(S)  Exts (F). Let us suppose that E  Exts (F) and let us prove that there exists a unique set
S  MC() such that Arg(S) = E. If we prove that such a set exists, then uniqueness is guaranteed
since for S, S 0  , if S 6= S 0 then Arg(S) 6= Arg(S 0 ) trivially holds. Thus, let us prove that there
exists S  MC() such that Arg(S) = E. Let S 0 = Base(E) and let us prove that S 0  MC()
80

fiI DENTIFYING THE C LASS OF M AXI -C ONSISTENT O PERATORS IN A RGUMENTATION

and Arg(S 0 ) = E. By means of contradiction, suppose that S 0 is a consistent but not maximal
consistent set. Then, there exists S 00  MC() such that S 0  S 00 . From the assumptions of this
proposition, we have that E 00 = Arg(S 00 ) is a stable extension of F. But we also have E ( E 00 . Since
no stable extension is a proper subset of another stable extension, then E is not a stable extension.
Contradiction. Thus, it must be that S 0  MC(). It is easy to see that E  Arg(Base(E)) (namely,
for every set of arguments, by applying the function Arg on its base, we obtain its superset). Let
us prove Arg(S 0 ) = E. Suppose the contrary. Then, E ( Arg(S 0 ). Since S 0  MC() then
Arg(S 0 )  Exts (F). Thus, E is not a stable extension (since no stable extension is a proper subset
of another stable extension).
We prove that similar two conditions are sufficient to guarantee that R satisfies (MC  Ext)
under preferred semantics.
Proposition 6. Let R be an attack relation. If for every set of formulae  and F = (Arg(), R),
we have:
 for all S  MC(), Arg(S)  Extp (F), and
 for all E  Extp (F), Base(E) is consistent
then R satisfies (MC  Extp ).
Proof of this property is similar to the proof of Proposition 5.
As a consequence of the two previous results, we can identify a sufficient condition so that R
satisfies both (MC  Exts ) and (MC  Extp ).
Corollary 5. Let R be an attack relation. If for every set of formulae  and F = (Arg(), R), we
have:
 for all S  MC(), Arg(S)  Exts (F), and
 for all E  Extp (F), Base(E) is consistent
then R satisfies both (MC  Exts ) and (MC  Extp ).
Proof. Since every stable extension is a preferred one (Dung, 1995), it is clear that R satisfies both
conditions of Proposition 5 and Proposition 6. By applying those propositions, we have that R
satisfies (MC  Exts ) and (MC  Extp ).
Let us now show that if an attack relation returns a stable extension having an inconsistent base,
then it violates (MC  Ext) for stable, semi-stable, preferred and complete semantics.
Proposition 7. Let R be an attack relation. If there exists a finite set of formulae  such that
F = (Arg(), R) has a stable extension E such that Base(E) is inconsistent, then R falsifies
(MC  Extx ) for x  {s, ss, p, c}.
Proof. We supposed that there exists a stable extension E  Exts (F) such that Base(E) ` . It
has been proved (Dung, 1995) that every stable extension is a preferred and a complete one. We also
know (Caminada, 2006) that E must be a semi-stable extension. By using Corollary 2, we conclude
that R does not satisfy (MC  Ext) for stable, semi-stable, preferred and complete semantics.
81

fiV ESIC

Let us now study the case of complete semantics. We show that it is not possible for an attack
relation to satisfy (MC  Extc ). The only condition we use in our result is that for every argument
a, if a has a formula  in its support, and   , then there exists an argument b  Arg() such
that b attacks a.
Proposition 8. Let R be an attack relation such that for every finite set of formulae , for every
a  Arg(), for every   Supp(a), if there exists    such that    then there exists
b  Arg() such that (b, a)  R. Then, R does not satisfy (MC  Extc ).
Proof. We prove that if an attack relation R satisfies the condition from this proposition, then it
falsifies (MC  Extc ). We use the proof by contradiction. In other words, the plan of the proof is as
follows: first, we suppose that R satisfies the given condition. Second, by means of contradiction,
we suppose that R satisfies (MC  Extc ). Third, we draw conclusions and obtain a contradiction.
Fourth, by reductio ad absurdum, we conclude that it must be that R falsifies (MC  Extc ).
So, let us start by supposing the condition from the proposition and suppose that R satisfies
(MC  Extc ). Thus, from Proposition 2, we obtain the R is conflict-dependent. Since R satisfies
(MC  Extc ), then for every , Arg is a bijection between MC() and Extc (Arg(), R). Consider
 = {, , } and denote F = (Arg(), R). It is clear that MC() = {S1 , S2 } with S1 = {, }
and S2 = {, }. Since R satisfies (MC  Extc ) then Extc (F) = {E1 , E2 } with E1 = Arg(S1 )
and E2 = Arg(S2 ).
Let us now obtain a contradiction by proving that E3 = Arg({}) is a complete extension. First,
prove that this set is conflict-free. Let a, b  E3 . Since R is conflict-dependent, then (a, b) 
/ R.
Thus, E3 is conflict-free.
Let us now prove that for all a  E3 , for all b  Arg() \ E3 , we have that (a, b) 
/ R and
(b, a) 
/ R. By means of contradiction, suppose the contrary. Again from conflict-dependence, we
have that Supp(a)  Supp(b) ` . It must be that {, }  Supp(a)  Supp(b). Since the support
of every argument is consistent, then Supp(a) contains either  or . Contradiction with the fact
a  Arg({}). Thus, E3 is an admissible set.
Let us now prove that E3 does not defend any arguments in Arg() \ E3 . To show this, we only
need to prove that every argument in Arg() \ E3 is attacked by at least one argument. Note that
for every a  Arg() \ E3 , it holds that a  E1 \ E2 or a  E2 \ E1 . Without loss of generality,
let a  E1 \ E2 . Let us prove that a is attacked. Note that in every argumentation system, every
non-attacked argument is in all complete extensions. Since a 
/ E2 , then a must be attacked. To sum
up:
 E3 is an admissible set
 E3 does not attack any argument in Arg() \ E3
 Arg() \ E3 does not attack any argument in E3
 every argument in Arg() \ E3 is attacked by at least one argument.
Thus, E3 is a complete extension. Contradiction with the claim that Extc (F) = {E1 , E2 }. By
reductio ad absurdum, we conclude that R does not satisfy (MC  Extc ).
What about the semantics which always return a unique extension, like grounded and ideal
semantics? In such a case, it is not reasonable to expect that there is a bijection between MC() and
82

fiI DENTIFYING THE C LASS OF M AXI -C ONSISTENT O PERATORS IN A RGUMENTATION

the set of extensions, since there can be several maximal consistent subsets of . Let us formally
state this fact.
Proposition 9. If x is a semantics such that for every argumentation system F we have |Extx (F)| =
1 then there is no attack relation R which satisfies (MC  Extx ).
Proof. Let  = {, , }. Denote F = (Arg(), R). There are two maximal consistent subsets
of , i.e. |MC()| = 2. Since we supposed that every argumentation system has exactly one
extension under semantics x, then there is no bijection between MC() and Extx (F).
The previous simple result is not surprising. The idea between those semantics is to have one
extension that contains all the arguments that should be accepted according to every point of view.
Thus, we can expect a link between the set of formulae not belonging to any minimal inconsistent
set and those extensions. Note that the sufficient conditions for R were identified (Gorogiannis
& Hunter, 2011) so that for every finite set  and F = (Arg(), R) we have that the grounded
and the ideal semantics coincide and that the extension is exactly Arg( \ (1  . . .  k )) where
{1 , . . . , k } is the set of all minimal (for set inclusion) inconsistent subsets of .

5. Identifying Classes of Attack Relations (Not-)Satisfying (MCExt)
The previous sections show how to identify properties that an attack relation satisfying (MC  Ext)
must satisfy. They also provide several results closely related to the choice of a specific acceptability semantics. In this section, we identify classes of attack relations which satisfy, do not satisfy
(MC  Ext), or serve as lower (upper) bounds (with respect to set inclusion) for (non-)satisfying
(MC  Ext).
We first show that the whole class of symmetric attack relations violates (MC  Ext) for all
semantics from Definition 4.
Proposition 10. If R is a symmetric attack relation, then for every x  {s, ss, p, c, g, i}, R falsifies
(MC  Extx ).
Proof. From Proposition 9, we see that R violates (MC  Extg ) and (MC  Exti ). Let us now
prove the same for other acceptability semantics.
If R is a symmetric attack relation, then every conflict-free set is admissible. Furthermore, it is
easy to see that in this case every maximal conflict-free set is a stable extension (and vice versa).
Since every finite argumentation system has at least one maximal conflict-free set, then every finite
argumentation system using a symmetric attack relation has at least one stable extension. Let R be
a symmetric relation and suppose that for at least one x  {s, ss, p, c}, R satisfies (MC  Extx ).
From Corollary 4, we conclude that R is not valid. This means that there exists a finite propositional
knowledge base  and F = (Arg(), R) such that there is a conflict-free set E  Arg() having
an inconsistent base. Let E 0  Arg() be a maximal conflict-free set containing E, i.e. such that
E  E 0 . Since E 0 is a maximal conflict-free set, then it is a stable extension of F. Since E 0 is a
stable extension, then it is also a semi-stable, preferred and a complete one. Since Base(E 0 ) ` 
then Corollary 2 implies that for all x  {s, ss, p, c}, R fails to satisfy (MC  Extx ).
We now identify another class of attack relations that do not satisfy (MC  Ext). Namely, we
show that every (possible) attack generating too many attacks falsifies (MC  Ext). First, we
83

fiV ESIC

need to formally define what we mean by too many attacks. We do this by introducing the notion
of conflict-completeness.
Definition 8 (Conflict-complete). Let R  Arg(L)  Arg(L) be an attack relation. We say that
R is conflict-complete if and only if for every minimal conflict C  L (i.e. for every inconsistent
set whose every proper subset is consistent), for every C1 , C2  C such that C1 6= , C2 6= ,
C1  C2 = C, for every argument a1 such that Supp(a1 ) = C1 , there exists an argument a2 such
that Supp(a2 ) = C2 and (a2 , a1 )  R.
Intuitively, an attack relation is conflict-complete if when two sets form a minimal conflict, then
every argument built from one of the two sets can be attacked by an argument from the other set.
This notion is inspired by the desire to describe properties of a class of existing (and new) attack
relations. For example, canonical undercut is conflict-complete.
We can show that if an attack relation is conflict-complete, then it falsifies (MC  Ext) for stable,
semi-stable, preferred and complete semantics.
Proposition 11. Let R be an attack relation. If R is conflict-complete then R does not satisfy
(MC  Extx ) for x  {s, ss, p, c}.
Proof. Let R be a conflict-complete attack relation and let us use the proof by contradiction. Thus,
suppose that there exist x  {s, ss, p, c} such that R satisfies (MC  Extx ) and obtain a contradiction. From Proposition 2, we have that R is conflict-dependent. Let  = {,   , }. Let
F = (Arg(), R) and E = Arg({})  Arg({  })  Arg({}). We prove that E is a stable
extension of F. First, prove that E is conflict-free. Let a, b  E and suppose (a, b)  R. From
conflict-dependence, we obtain Supp(a)  Supp(b) ` . Contradiction with the definition of E,
since there are no two arguments of E such that the union of their supports is inconsistent. Now,
prove that E attacks every argument in Arg() \ E. Let a0  Arg() \ E. There are three cases.
Case 1: Supp(a0 ) = {,   }. In this case, since R is conflict-complete, then a0 is attacked by
at least one argument from the set Arg(). Case 2: Supp(a0 ) = {, }. Again from conflictcompleteness, such an argument is attacked by an argument from the set Arg({  }). Case 3:
Supp(a0 ) = {  , } is also similar, since a0 is then attacked by an argument having support
{}. We conclude that E  Exts (F). It is easy to see that Base(E) ` . Proposition 7 now implies
that R does not satisfy (MC  Extx ) for every x  {s, ss, p, c}. Contradiction.
The previous part of this paper studies classes of attack relations. Let us now define
some
V
particular cases of attack relations. If  = {1 , . . . , k } is a set of formulae, notation  stands
for 1  . . .  k .
Definition 9 (Attack relations). Let a, b  Arg(L). We define the following attack relations:
V
 defeat: aRd b if and only if Conc(a) ` Supp(b)
 direct defeat: aRdd b if and only if there exists   Supp(b) such that Conc(a) ` 
V
 undercut: aRu b if and only if there exists   Supp(b) such that Conc(a)   
 direct undercut: aRdu b if and only if there exists   Supp(b) such that Conc(a)  
V
 canonical undercut: aRcu b if and only if Conc(a)   Supp(b)
84

fiI DENTIFYING THE C LASS OF M AXI -C ONSISTENT O PERATORS IN A RGUMENTATION

 rebut: aRr b if and only if Conc(a)  Conc(b)
 defeating rebut: aRdr b if and only if Conc(a) ` Conc(b)
 conflicting attack: aRc b if and only if Supp(a)  Supp(b) ` 
 rebut + direct undercut: aRrdu b if and only if aRr b or aRdu b
 big argument attack: aRba b if and only if there exists   Supp(b) such that Supp(a) ` .
The first seven items from the previous definition list are, to the best of our knowledge, all the
attack relations used in the logic-based argumentation literature. Finding the exact paper in which
each of them occurs for the first time would be quite a challenging task. We can say that rebut was
defined by Pollock (1987, 1992). Direct undercut was introduced in the work of Elvang-Gransson,
Fox, and Krause (1993) and Elvang-Gransson and Hunter (1995). Undercut and canonical undercut were defined in this form by Besnard and Hunter (2000, 2001). To the best of our knowledge,
conflicting attack was not used in the argumentation literature. A possibility to use such a relation
was mentioned (Besnard & Hunter, 2008, p. 35). We show that it is not enough to capture the
presence of inconsistency to make a good attack relation. Namely, we show later that this attack
relation may return inconsistent extensions. Rebut + direct undercut is added by the author of the
present paper, as an attempt to investigate the possibility to use rebut to detect some conflicts not
detected by direct undercut, but to avoid using a symmetric relation (rebut). The name big argument
attack and the idea behind this attack relation are due to L. van der Torre (personal communication,
June 18, 2012). This attack relation was coined with the goal to show that there are reasonable attack relations not taking into account the conclusion of an argument. We later show (Proposition 16)
that this attack relation also satisfies (MC  Ext). (The idea behind the name of this attack relation
is that it is sufficient to use only one argument per support since the conclusions are not important.
Those arguments are called big since one big argument plays a role of a whole class of normal
arguments, i.e. all the arguments having the same support. The attack relation is called big since it
is to be used between big arguments.)
The reader can easily check that canonical undercut is conflict-complete, which leads to the
conclusion that every attack relation containing canonical undercut (in the set-theoretic sense) is
also conflict-complete.
Proposition 12. Let R  Arg(L)  Arg(L) be an attack relation. If Rcu  R then R is conflictcomplete.
Thus, from Proposition 11, we conclude that every attack relation containing canonical undercut
falsifies (MC  Ext) for stable, semi-stable, preferred and complete semantics.
Corollary 6. Let R be an attack relation. If Rcu  R, then R does not satisfy (MC  Extx ) for
x  {s, ss, p, c}.
Since Rcu  Ru  Rd  Rc , then we obtain that as soon as an attack relation R contains Ru ,
or Rd or Rc then it falsifies (MC  Ext) for stable, semi-stable, preferred and complete semantics.
Corollary 7. Let R be an attack relation. If Ru  R, or Rd  R or Rc  R then R falsifies
(MC  Extx ) for x  {s, ss, p, c}.
85

fiV ESIC

Hence, there is a whole class of attack relations based on undercutting which do not satisfy
(MC  Ext). We also identified another class of attack relations, this time based on rebutting,
which do not satisfy (MC  Exts ). Namely, every attack relation contained in defeating rebut must
falsify (MC  Exts ). Observe how the proof of the following proposition is based on the idea from
Example 3.
Proposition 13. Let R be an attack relation. If R  Rdr then R does not satisfy (MC  Exts ).
Proof. Let us suppose the contrary, i.e. let R satisfy (MC  Exts ). Let  = {  ,   } and
F = (Arg(), R). We have that MC() = {S1 , S2 }, with S1 = {  } and S2 = {  }. Thus,
it must be that Exts (F) = {E1 , E2 } with E1 = Arg(S1 ) and E2 = Arg(S2 ). It is obvious that for an
argument a1 = ({  },   ) we must have a1  E1 . Since E2 is a stable extension, then there
must exist an argument a2  E2 such that (a2 , a1 )  R. Thus, it must be that Conc(a2 ) `   .
Consequently, Conc(a2 ) ` . Recall that Supp(a2 ) = {  } or Supp(a2 ) = {  }.
Contradiction.
Since Rr  Rdr then the previous conclusion holds for every relation contained in Rr .
Corollary 8. Let R be an attack relation. If R  Rr then R does not satisfy (MC  Exts ).
Proof. Let R  Rr . Since Rr  Rdr , then R  Rdr . From Proposition 13, R falsifies
(MC  Exts ).

6. Particular Attack Relations and (MCExt)
In the previous section, we identified classes of relations which do not satisfy (MC  Ext). In this
section, we examine in detail all the attack relations from Definition 9.
By using the results presented until now, we prove that direct undercut, direct defeat and big
argument attack satisfy (MC  Ext) for stable, semi-stable and preferred semantics, and falsify it
for other semantics, whereas other attack relations fail to satisfy (MC  Ext) for any semantics.
Note that it has been proved (Cayrol, 1995) that direct undercut satisfies (MC  Ext) in the case
of stable semantics. From Proposition 4, we conclude that direct undercut satisfies (MC  Ext)
for semi-stable semantics. So, we only need to prove that Rdu satisfies (MC  Ext) in the case of
preferred semantics.
Proposition 14. Attack relation Rdu satisfies (MC  Extx ) for x  {s, ss, p}.
Proof. We have already seen why Rdu satisfies (MC  Ext) under stable and semi-stable semantics. We now study the case of preferred semantics. Let  be a finite set of formulae and F =
(Arg(), Rdu ). Since it was already proved (Cayrol, 1995) that stable extensions of F are exactly
Arg(S), when S ranges over MC(), and since every stable extension is a preferred one, then it
is clear that for every S  MC() we have that Arg(S) is a preferred extension of F. Thanks to
Proposition 6, we now only need to prove that the base of every preferred extension is consistent.
This result follows from Prop. 34 by Gorogiannis and Hunter (2011), since relation Rdu satisfies
all the conditions of that proposition. Thus, direct undercut satisfies (MC  Extp ).
Example 6. Consider a relation ; for inferring from an inconsistent knowledge base defined as
follows: given a set , we write  ;  if and only if for every maximal consistent subset S of , it
86

fiI DENTIFYING THE C LASS OF M AXI -C ONSISTENT O PERATORS IN A RGUMENTATION

holds that S ` , where ` stands for classical entailment. Now, consider an argumentation system
using direct undercut as attack relation and stable semantics. From Proposition 14, we conclude
that for every , Arg is a bijection between MC() and Exts (Arg(), Rdu ). Roughly speaking, this
means that the set of formulae that can be inferred from  with respect to ; is equal to the set of
formulae that are conclusions of all the extensions of the corresponding argumentation framework
based on direct undercut and stable semantics. More formally: for every   L, for every formula
  L we have that:  ;  if and only if for every extension E  Exts (Arg(), Rdu ), there exists
a  E such that  = Conc(a).
Let us now show that Rdd also satisfies (MC  Ext) for stable, semi-stable and preferred semantics.
Proposition 15. Attack relation Rdd satisfies (MC  Extx ) for x  {s, ss, p}.
Proof. Let  be a finite knowledge base and F = (Arg(), Rdd ). Let S  MC(). It is easy to
see that E = Arg(S) is a stable extension of F. Namely, E is conflict-free since Rdd is conflictdependent. Furthermore, for every argument a0  Arg() \ E, it must be that Supp(a0 ) contains at
least one formulae    \ S. From this fact, it is easy to conclude that there exists an argument
a  E such that Supp(a)  S and Conc(a)   (since S is a maximal consistent set). Thus,
a attacks a0 which ends this part of the proof and shows why E  Exts (F). Since every stable
extension is a semi-stable and a preferred one, then E  Extss (F) and E  Extp (F). Let us now
suppose that E is a preferred extension of F. Since direct defeat satisfies conditions of Prop. 34 by
Gorogiannis and Hunter (2011), then we conclude that Base(E) is consistent. From Corollary 5,
we conclude that Rdd satisfies (MC  Ext) for stable and preferred semantics. Now, Proposition 4
implies that Rdd also satisfies (MC  Extss ).
We now show that it is not necessary to look at conclusions of arguments in order to satisfy
(MC  Ext). Namely, we can show that big argument attack satisfies (MC  Ext) for stable, semistable and preferred semantics.
Proposition 16. Attack relation Rba satisfies (MC  Extx ) for x  {s, ss, p}.
Proof. Let us first show that for every S  MC(), it holds that E = Arg(S) is a stable extension in
F = (Arg(), Rba ). Since Rba is conflict-dependent, then E is conflict-free. Let a0  Arg() \ E
and let us prove that there exists a  E such that aRba a0 . Since a0 
/ E, then there exists  
Supp(a0 ) such that  
/ S. Since S is a maximal consistent subset of , then S ` . Let S 0  S
be a minimal with respect to set inclusion consistent set such that S 0 `  (such a set exists since
S is consistent) and let a = (S 0 , ). a is an argument since S 0 is a minimal consistent set from
which  can be deduced. We see that (a, a0 )  Rba . This means that the image with respect to Arg
of every maximal consistent subset of  is a stable extension of F. Thus, it is also a semi-stable
and a preferred extension of F. Let us now prove that for every  and the corresponding F =
(Arg(), Rba ), the base of every preferred extension E of F is a consistent set. Let E  Extp (F)
and S = Base(E). Aiming to a contradiction, suppose the contrary, i.e. let S be an inconsistent set.
Let S 0  S be a minimal (with respect to set inclusion) inconsistent set. Denote S 0 = {1 , . . . , n }.
Let a  E be an argument such that n  Supp(a), and let a0 = (S 0 \ {n }, n ). It is clear that
(a0 , a)  Rba . Since E is a preferred extension, it is conflict-free, thus a0 
/ E. Furthermore, E
is admissible, so there must exist b  E such that (b, a)  Rba . Since (b, a)  Rba , then there
87

fiV ESIC

exists i  {1, . . . , n  1} such that Supp(b) ` i . Since i  S 0 , then there exists an argument
c  E such that i  Supp(c). According to the definition of Rba , that would mean that b attacks
c. Contradiction with the fact that E is conflict-free. So, S must be a consistent set. This shows that
for every  and the corresponding F = (Arg(), Rba ), the base of every preferred extension E of
F is a consistent set. From Corollary 5, we conclude that Rba satisfies (MC  Ext) for stable and
preferred semantics. Now, Proposition 4 implies that Rba also satisfies (MC  Extss ).
We already know that no relation satisfies (MC  Ext) for the grounded or ideal semantics. By
using Proposition 8, it is easy to conclude that Rdu , Rdd and Rba falsify (MC  Extc ).
Let us now prove that the remaining attack relations from Definition 9 do not satisfy (MC  Ext)
for neither of semantics from Definition 4.
Proposition 17. Attack relations Rd , Ru , Rcu , Rr , Rdr , Rrdu , Rc falsify (MC  Ext) for stable,
semi-stable, preferred, complete, grounded and ideal semantics.
Proof. Note that we already showed that no attack relation satisfies (MC  Ext) for grounded or
ideal semantics. So, in the rest of the proof, we only need to consider stable, semi-stable, preferred
and complete semantics.
Let us first consider the attack relations Rcu , Ru , Rd and Rc . By using Proposition 11, we
conclude that those relations violate (MC  Ext) for stable, semi-stable, preferred and complete
semantics.
It is obvious that relations Rr and Rc are symmetric. Note that Rdr is also symmetric: this
comes from the fact that  `  if and only if ,  `  if and only if  ` . Thus, Proposition
10 yields a conclusion that they do not satisfy (MC  Ext) for neither of the considered acceptability
semantics.
Let us now study the relation Rrdu . Let  = {,   , } and F = (Arg(), Rrdu ). Let
us define a set E of arguments as follows: E = {a  Arg() | Conc(a) 6  and Conc(a) 6
(  ) and Conc(a) 6 }.
Prove that E is conflict-free. Let a, b  E and let aRrdu b. Whether aRr b or aRdu b is not
important, since in both cases, we obtain Supp(a)  Supp(b) ` . Contradiction, since there are no
two formulae in  whose union is an inconsistent set. So E is a conflict-free set.
Suppose that a0  Arg() \ E. So, Conc(a0 )   or Conc(a0 )  (  ) or Conc(a0 )  .
In any of those cases, a0 is attacked by at least one argument from E, namely by ({}, ), or by
({  },   ), or by ({}, ). So, E is a stable extension, and consequently, semi-stable,
preferred and complete extension. It is obvious that Base(E) is an inconsistent set, so by Corollary 2
we conclude that Rrdu does not satisfy (MC  Ext) for stable, semi-stable, preferred and complete
semantics.

7. Discussion, Related and Future Work
This paper identified and studied the large class of instantiations of Dungs abstract theory corresponding to the maxi-consistent operator. In other words, we studied the instantiations where every
extension of the argumentation system corresponds to exactly one maximal consistent subset of the
knowledge base. We proved properties of attack relations belonging to this class: they must be
conflict-dependent, must not be valid, must not be conflict-complete, must not be symmetric etc.
We also identified some attack relations serving as lower or upper bounds of the class. By using our
88

fiI DENTIFYING THE C LASS OF M AXI -C ONSISTENT O PERATORS IN A RGUMENTATION

results, we showed for all existing attack relations from the argumentation literature whether or not
they belong to this class. We also showed for the first time that an attack relation not depending on
arguments conclusions can return reasonable results. Furthermore, we showed that such a relation
is a member of (MC  Ext) class.
Practical benefits of the work reported in this paper, and more generally, any work devoted to
studying the link between a class of instantiations of Dungs theory and an operator, can be resumed
as follows.
(I) A case when an instantiation of Dungs theory is shown to correspond to an existing operator.
First, such a work can help to validate an argumentation-based approach by showing in which
cases it returns a result comparable with that of a non argumentation-based approach. The possible
criticism of such an instantiation is that it is useless, since one can obtain the same result without
using argumentation. But, this is far from being true; namely, argumentation can be used for explanatory purposes. For example, if one wants to know why a certain conclusion is accepted, an
argument having that conclusion can be presented. That argument can be attacked by other arguments and so on. Also, it might be possible to construct only a part of the argumentation graph
related to the argument in question, thus having a better knowledge representation (i.e. ignoring the
parts of the knowledge base unrelated to the argument one wants to concentrate on).
The second benefit of this type of work is that it can help to reduce computational complexity
by using the simpler approach in the cases when the result obtained by an argumentation-based approaches and a non argumentation-based approaches is the same. Please note that the work in this
category (capturing an operator with an instantiation of Dungs theory) is far from being limited to
the case of the maxi-consistent operator, as it was shown by Vesic and van der Torre (2012) that
there exists a large class of instantiations of the abstract argumentation theory returning a consistent
result substantially different from the one returned by the maxi-consistent operator.
(II) A case when an instantiation of Dungs theory does not correspond to any existing operator.
Working on the links between instantiations of Dungs theory and operators can be even more
beneficial in the case when an instantiation of the abstract argumentation theory does not corresponding to any known operator happens to be found. We distinguish three possible situations.
(a) A case when an instantiation calculates a useful result which can be obtained by an operator, but that operator was unknown until now. In such a case, a new operator is discovered thanks to
argumentation. The question is then, in which situations to use argumentative approach, and when
to apply the operator? The answer depends on the balance between the need for computational
efficiency (which we conjecture is often on the side of the approach directly applying the operator)
and the need to represent knowledge in a format that is easy to grasp, argue and justify an accepted
piece of knowledge, which are the usual advantages of argumentation.
(b) A case when an instantiation of Dungs abstract theory returns a useful result which cannot
be obtained by any operator. Recall that an operator is a function that, for every finite knowledge
base, returns a set of its subsets. But, an argumentative approach could return a result that cannot
be represented in that form, for instance, if an argument (, ) is in an extension, whereas (, ) is
not, with  6= . Thus, the expressive power of the operator-based approach might be not enough
to distinguish those subtleties. A very important question of how to define such an instantiation is
still open. Another relevant issue is to see in which context such instantiations make sense and how
they can be applied.
89

fiV ESIC

(c) A case when an instantiation returns a bad result. This class regroups a set of instantiations
representing a behaviour one would like to avoid. The general question: how to distinguish useful
from bad instantiations? is certainly a hard one. Apart from a scientific debate, evaluation can
include tests on a set of benchmark examples. Note that the limits of testing a reasoning formalism
on a set of benchmark examples have been pointed out by Vreeswijk (1995). Another, more principled (and more demanding) way to proceed is to define a set of postulates to be satisfied by an
argumentation formalism (Caminada & Amgoud, 2007; Caminada, Carnielli, & Dunne, 2012).
As a remark, note that the fact that an instantiation may return an inconsistent result, does not
mean that it is completely useless. Namely, there might be cases when arguments are constructed
from an inconsistent knowledge base, and when one resolves just some of the existing inconsistencies by an argumentative approach, and then applies another inconsistency-tolerant approach.
Also, inconsistency handling is not the only use of argumentation. Thus, still in the same setting,
a drastic case would be to first use argumentation for another purpose (not dealing with at all with
inconsistencies) and then apply a different approach to reason with inconsistency.
We now review the related work. Maxi-consistent sets play a major role in the characterization of various forms of non-classical logical reasoning (Bochman, 2001) and in belief revision
(Alchourron, Gardenfors, & Makinson, 1985). The remainder of the section considers the papers
having a link with argumentation.
The paper by Cayrol (1995) is one of the early works relating the results obtained directly from
a knowledge base and by using an argumentative approach. In that paper, it was shown that direct
undercut satisfies (MC  Ext) for stable semantics, but no results for other semantics or attack
relations were provided. We not only studied other attack relations and other semantics, but also
provided a general study of properties an attack relation satisfying (MC  Ext) must also satisfy.
Amgoud and Vesic (2010) generalised the result by Cayrol (1995) for the case of prioritised
knowledge base, by showing that Arg is a bijection between preferred sub-theories (Brewka, 1989),
which generalise maximal consistent sets in case of prioritised knowledge base, and stable extensions of the corresponding preference-based argumentation system using direct undercut as an
attack relation and the weakest link principle as a preference relation.
Amgoud and Besnard (2009, 2010) also studied the link between a knowledge base and the corresponding argumentation system. Those papers introduced some important notions like conflictdependence and validity of an attack relation and proved numerous results related to consistency in
the underlying logic. However, note that the criterion (MC  Ext) was neither defined nor studied
in those papers; they provided (Amgoud & Besnard, 2010, Corollary 1) a link between MC() and
maximal conflict-free sets of F = (Arg(), R). Furthermore, this result is proved under hypotheses which are impossible to satisfy: the attack relation should be both valid and conflict-dependent,
which is impossible (as proved in Proposition 3). Some other results in that paper (Amgoud &
Besnard, 2010, e.g. Prop. 4) are proved only for an attack relation which is both conflict-dependent
and conflict-sensitive, which is not the case for any of the well-known attack relations. Consequently, the majority of the negative results of those papers are only applicable to a minority of
attack relations. Furthermore, examples in those papers are often incomplete systems; thus, it is
not surprising that there is no link between MC(Base(A)) and Ext(A, R) in those examples.
A recent paper by Gorogiannis and Hunter (2011) studied the properties of attack relations
in the case when a Dung-style argumentation system is instantiated with classical propositional
logic. Our work is related to those ideas, however, the focus of our paper is different. Our main
goal is to study to which extent Dungs theory can be used as a general framework for reasoning.
90

fiI DENTIFYING THE C LASS OF M AXI -C ONSISTENT O PERATORS IN A RGUMENTATION

On the technical side, we concentrate on studying the properties of the class of attack relations
satisfying (MC  Ext) and identifying attack relations serving as lower and upper bounds of classes
of relations non-satisfying (MC  Ext).
One of the open questions is to find a set of conditions such that an attack relation satisfies
those conditions if and only if it satisfies (MC  Ext). Until recently, direct undercut and direct
defeat were the only known attack relations satisfying this condition (Vesic, 2012). Consequently, it
seemed that the space of attack relations satisfying this condition is rather narrow (note the similarity
between direct undercut and direct defeat). However, the present paper shows that Rba also belongs
to (MC  Ext), this indicating that the class of instantiations corresponding to the maxi-consistent
operator is much larger.
The formal framework studied in this paper is that of classical propositional logic-based argumentation. The vast majority of ideas and considerations from the present paper hold for other
instantiations of Dungs theory, for example in the setting studied by Modgil and Prakken (2013).
In other words, the result obtained from those argumentation frameworks could also be compared
with that obtained by an operator. After slightly adapting the definition of an operator, one can study
the same questions: is there a link between the result obtained from an argumentation system and
that obtained by an operator (from the same strict and defeasible rules)? Can argumentation help us
find new operators? Are there argumentation systems returning a result that cannot be captured by
an operator? Answering those questions will certainly be a part of our future work.

Acknowledgments
The author would like to thank Leendert van der Torre for his assistance and advice. His useful
comments helped to improve the paper significantly. The author also thanks the three reviewers for
their helpful comments.
This paper is a revised and extended version of the conference paper: S. Vesic. Maxi-Consistent
Operators in Argumentation. Proceedings of the 20th European Conference on Artificial Intelligence (ECAI12), pages 810-815.
The major part of the work on this paper was carried out while the author was affiliated with
the Computer Science and Communication Research Unit at the University of Luxembourg. First,
the author started this work during the tenure of an ERCIM Alain Bensoussan Fellowship Programme, which is supported by the Marie Curie Co-funding of Regional, National and International Programmes (COFUND) of the European Commission. During this time, the author was also
funded by the National Research Fund, Luxembourg. Second, while still at the University of Luxembourg, the author continued the work on this paper during a FNR AFR postdoc project which
was supported by the National Research Fund, Luxembourg, and cofunded under the Marie Curie
Actions of the European Commission (FP7-COFUND). Third, at the time when he was finishing
the work on this paper, the author was a CRNS researcher affiliated with CRIL.

References
Alchourron, C. E., Gardenfors, P., & Makinson, D. (1985). On the logic of theory change: Partial
meet contraction and revision functions. Journal of Symbolic Logic, 50, 510530.
91

fiV ESIC

Amgoud, L., & Besnard, P. (2009). Bridging the gap between abstract argumentation systems
and logic. In International Conference on Scalable Uncertainty Management (SUM09), pp.
1227.
Amgoud, L., & Besnard, P. (2010). A formal analysis of logic-based argumentation systems. In
International Conference on Scalable Uncertainty Management (SUM10), pp. 4255.
Amgoud, L., Besnard, P., & Vesic, S. (2011). Identifying the core of logic-based argumentation
systems. In 23rd International Conference on Tools with Artificial Intelligence (ICTAI11),
pp. 633636.
Amgoud, L., & Cayrol, C. (2002). A reasoning model based on the production of acceptable arguments. Annals of Mathematics and Artificial Intelligence, 34, 197216.
Amgoud, L., & Vesic, S. (2010). Handling inconsistency with preference-based argumentation.
In Proceedings of the 4th International Conference on Scalable uncertainty Management
(SUM10), pp. 5669.
Arrow, K. J., Sen, A. K., & Suzumura, K. (Eds.). (2002). Handbook of Social Choice and Welfare.
North-Holland.
Besnard, P., & Hunter, A. (2000). Towards a logic-based theory of argumentation. In Proceedings of
the 17th National Conference on Artificial Intelligence (AAAI00), pp. 411416. AAAI Press
/ The MIT Press.
Besnard, P., & Hunter, A. (2001). A logic-based theory of deductive arguments. Artificial Intelligence Journal, 128, 203235.
Besnard, P., & Hunter, A. (2008). Elements of Argumentation. MIT Press.
Bochman, A. (2001). A logical theory of nonmonotonic inference and belief change - numerical
methods. Springer.
Brewka, G. (1989). Preferred subtheories: An extended logical framework for default reasoning.
In Proceedings of International Joint Conference on Artificial Intelligence (IJCAI89), pp.
10431048.
Caminada, M. (2006). Semi-stable semantics. In Proceedings of the 1st International Conference
on Computational Models of Argument (COMMA06), pp. 121130. IOS Press.
Caminada, M., & Amgoud, L. (2007). On the evaluation of argumentation formalisms. Artificial
Intelligence Journal, 171 (5-6), 286310.
Caminada, M., Carnielli, W., & Dunne, P. (2012). Semi-stable semantics. Journal of Logic and
Computation.
Caminada, M., & Vesic, S. (2012). On extended conflict-freeness in argumentation.. In Proceedings
of the 24th Benelux Conference on Artificial Intelligence (BNAIC12), pp. 4350.
Cayrol, C. (1995). On the relation between argumentation and non-monotonic coherence-based entailment. In Proceedings of the 14th International Joint Conference on Artificial Intelligence
(IJCAI95), pp. 14431448.
Dung, P. M. (1995). On the acceptability of arguments and its fundamental role in nonmonotonic reasoning, logic programming and n-person games. Artificial Intelligence Journal, 77,
321357.
92

fiI DENTIFYING THE C LASS OF M AXI -C ONSISTENT O PERATORS IN A RGUMENTATION

Elvang-Gransson, M., Fox, J., & Krause, P. (1993). Acceptability of arguments as logical uncertainty. In Proceedings of the 2nd European Conference on Symbolic and Quantitative
Approaches to Reasoning with Uncertainty (ECSQARU93), pp. 8590.
Elvang-Gransson, M., & Hunter, A. (1995). Argumentative logics: Reasoning with classically
inconsistent information. Data Knowl. Eng., 16(2), 125145.
Gardenfors, P. (1988). Knowledge in Flux  Modeling the dynamics of epistemic states. Cambridge,
MA, MIT Press.
Gorogiannis, N., & Hunter, A. (2011). Instantiating abstract argumentation with classical logic
arguments: Postulates and properties. Artificial Intelligence Journal, 175, 14791497.
Konieczny, S., & Perez, R. P. (2011). Logic based merging. Journal of Philosophical Logic, 40(2),
239270.
Loui, R. (1998). Process and policy: Resource-bounded nondemonstrative reasoning. Computational Intelligence, 14(1), 138.
Modgil, S., & Prakken, H. (2013). A general account of argumentation with preferences. Artificial
Intelligence, 195, 361397.
Pollock, J. (1987). Defeasible reasoning. Cognitive Science, 11(4), 481518.
Pollock, J. (1992). How to reason defeasibly. Artificial Intelligence Journal, 57, 142.
Priest, G. (2002). Paraconsistent logic. In Gabbay, D., & Guenthner, F. (Eds.), Handbook of Philosophical Logic, Vol. 6, pp. 287393. Dordrecht: Kluwer Academic Publishers.
Vesic, S. (2012). Maxi-consistent operators in argumentation. In 20th European Conference on
Artificial Intelligence (ECAI12), pp. 810815.
Vesic, S., & van der Torre, L. (2012). Beyond maxi-consistent argumentation operators. In 13th
European Conference on Logics in Artificial Intelligence (JELIA12), pp. 424436.
Vreeswijk, G. (1995). Interpolation of benchmark problems in defeasible reasoning. In Proceedings
of the Second World Conference on the Fundamentals of Artificial Intelligence (WOCFAI95),
pp. 453468.
Vreeswijk, G. (1997). Abstract argumentation systems. Artificial Intelligence Journal, 90, 225279.

93

fi