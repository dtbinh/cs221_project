Journal of Artificial Intelligence Research 15 (2001) 319-350

Submitted 9/00; published 11/01

Infinite-Horizon Policy-Gradient Estimation
Jonathan Baxter

JBAXTER @ WHIZBANG . COM

WhizBang! Labs.
4616 Henry Street Pittsburgh, PA 15213

Peter L. Bartlett

BARTLETT @ BARNHILLTECHNOLOGIES . COM

BIOwulf Technologies.
2030 Addison Street, Suite 102, Berkeley, CA 94704

Abstract
Gradient-based approaches to direct policy search in reinforcement learning have received
much recent attention as a means to solve problems of partial observability and to avoid some of
the problems associated with policy degradation in value-function methods. In this paper we introduce GPOMDP, a simulation-based algorithm for generating a biased estimate of the gradient of
the average reward in Partially Observable Markov Decision Processes (POMDPs) controlled by
parameterized stochastic policies. A similar algorithm was proposed by Kimura, Yamamura, and
Kobayashi (1995). The algorithms chief advantages are that it requires storage of only twice the
number of policy parameters, uses one free parameter fi 2 [0; 1) (which has a natural interpretation
in terms of bias-variance trade-off), and requires no knowledge of the underlying state. We prove
convergence of GPOMDP, and show how the correct choice of the parameter fi is related to the
mixing time of the controlled POMDP. We briefly describe extensions of GPOMDP to controlled
Markov chains, continuous state, observation and control spaces, multiple-agents, higher-order
derivatives, and a version for training stochastic policies with internal states. In a companion paper
(Baxter, Bartlett, & Weaver, 2001) we show how the gradient estimates generated by GPOMDP
can be used in both a traditional stochastic gradient algorithm and a conjugate-gradient procedure
to find local optima of the average reward.

1. Introduction
Dynamic Programming is the method of choice for solving problems of decision making under
uncertainty (Bertsekas, 1995). However, the application of Dynamic Programming becomes problematic in large or infinite state-spaces, in situations where the system dynamics are unknown, or
when the state is only partially observed. In such cases one looks for approximate techniques that
rely on simulation, rather than an explicit model, and parametric representations of either the valuefunction or the policy, rather than exact representations.
Simulation-based methods that rely on a parametric form of the value function tend to go by
the name Reinforcement Learning, and have been extensively studied in the Machine Learning
literature (Bertsekas & Tsitsiklis, 1996; Sutton & Barto, 1998). This approach has yielded some
remarkable empirical successes in a number of different domains, including learning to play checkers (Samuel, 1959), backgammon (Tesauro, 1992, 1994), and chess (Baxter, Tridgell, & Weaver,
2000), job-shop scheduling (Zhang & Dietterich, 1995) and dynamic channel allocation (Singh &
Bertsekas, 1997).
Despite this success, most algorithms for training approximate value functions suffer from the
same theoretical flaw: the performance of the greedy policy derived from the approximate valuefunction is not guaranteed to improve on each iteration, and in fact can be worse than the old policy

c 2001 AI Access Foundation and Morgan Kaufmann Publishers. All rights reserved.

fiBAXTER & BARTLETT

by an amount equal to the maximum approximation error over all states. This can happen even when
the parametric class contains a value function whose corresponding greedy policy is optimal. We
illustrate this with a concrete and very simple example in Appendix A.
An alternative approach that circumvents this problemthe approach we pursue hereis to
consider a class of stochastic policies parameterized by  2 R K , compute the gradient with respect
to  of the average reward, and then improve the policy by adjusting the parameters in the gradient
direction. Note that the policy could be directly parameterized, or it could be generated indirectly
from a value function. In the latter case the value-function parameters are the parameters of the
policy, but instead of being adjusted to minimize error between the approximate and true value
function, the parameters are adjusted to directly improve the performance of the policy generated
by the value function.
These policy-gradient algorithms have a long history in Operations Research, Statistics, Control Theory, Discrete Event Systems and Machine Learning. Before describing the contribution of
the present paper, it seems appropriate to introduce some background material explaining this approach. Readers already familiar with this material may want to skip directly to section 1.2, where
the contributions of the present paper are described.
1.1 A Brief History of Policy-Gradient Algorithms
For large-scale problems or problems where the system dynamics are unknown, the performance
gradient will not be computable in closed form1 . Thus the challenging aspect of the policy-gradient
approach is to find an algorithm for estimating the gradient via simulation. Naively, the gradient
can be calculated numerically by adjusting each parameter in turn and estimating the effect on performance via simulation (the so-called crude Monte-Carlo technique), but that will be prohibitively
inefficient for most problems. Somewhat surprisingly, under mild regularity conditions, it turns out
that the full gradient can be estimated from a single simulation of the system. The technique is
called the score function or likelihood ratio method and appears to have been first proposed in the
sixties (Aleksandrov, Sysoyev, & Shemeneva, 1968; Rubinstein, 1969) for computing performance
gradients in i.i.d. (independently and identically distributed) processes.
Specifically, suppose r X is a performance function that depends on some random variable
X , and q ; x is the probability that X x, parameterized by  2 RK . Under mild regularity
conditions, the gradient with respect to  of the expected performance,

( )

( )

may be written

To see this, rewrite (1) as a sum

=

() = Er(X );

(1)

r() = Er(X ) rqq(;(;XX)) :

(2)

() =

X

r() =

X

r(x)q(; x);

x
differentiate (one source of the requirement of mild regularity conditions) to obtain
x

r(x)rq(; x);

1. See equation (17) for a closed-form expression for the performance gradient.

320

fiP OLICY-G RADIENT E STIMATION

rewrite as

X

r() =

r(x)

rq(; x) q(; x);

( )

q ; x
x
and observe that this formula is equivalent to (2).
If a simulator is available to generate samples X distributed according to q ; x , then any
sequence X1 ; X2 ; : : : ; XN generated i.i.d. according to q ; x gives an unbiased estimate,

( )

( )
N
X
r^ () = N1 r(Xi) rqq(;(;XX)i) ;
(3)
i
i
^ () ! r() with probability one. The quantity
of r ( ). By the law of large numbers, r
rq(; X )=q(; X ) is known as the likelihood ratio or score function in classical statistics. If
the performance function r (X ) also depends on  , then r (X )rq (; X )=q (; X ) is replaced by
rr(; X ) + r(; X )rq(; X )=q(; X ) in (2).
=1

1.1.1 U NBIASED E STIMATES
P ROCESSES

OF THE

P ERFORMANCE G RADIENT

FOR

R EGENERATIVE

Extensions of the likelihood-ratio method to regenerative processes (including Markov Decision
Processes or MDPs) were given by Glynn (1986, 1990), Glynn and LEcuyer (1995) and Reiman
and Weiss (1986, 1989), and independently for episodic Partially Observable Markov Decision
Processes (POMDPs) by Williams (1992), who introduced the REINFORCE algorithm2 . Here the
i.i.d. samples X of the previous section are sequences of states X0 ; : : : ; XT (of random length)
encountered between visits to some designated recurrent state i , or sequences of states from some
start state to a goal state. In this case rq ; X =q ; X can be written as a sum

(

) (

)

rq(; X ) = TX rpXtXt+1 () ;
1

q(; X )

()

t=0

pXt Xt+1 ()

(4)

where pXt Xt+1  is the transition probability from Xt to Xt+1 given parameters  . Equation (4)
admits a recursive computation over the course of a regenerative cycle of the form z0
2 RK ,
and after each state transition Xt ! Xt+1 ,

=0

zt+1 = zt +

( ) (
)

) (

)

rpXtXt+1 () ;
pXt Xt+1 ()

so that each term r X rq ; X =q ; X in the estimate (3) is of the form3
in addition, r X0 ; : : : ; XT can be recursively computed by

(

(5)

r(X0 ; : : : ; XT )zT . If,

r(X0 ; : : : ; Xt+1 ) = (r(X0 ; : : : ; Xt ); Xt+1 )
for some function , then the estimate r (X0 ; : : : ; XT )zT for each cycle can be computed using
storage of only K + 1 parameters (K for zt and 1 parameter to update the performance function
r). Hence, the entire estimate (3) can be computed with storage of only 2K + 1 real parameters, as
follows.

2. A thresholded version of these algorithms for neuron-like elements was described earlier in Barto, Sutton, and Anderson (1983).
3. The vector zT is known in reinforcement learning as an eligibility trace. This terminology is used in Barto et al.
(1983).

321

fiBAXTER & BARTLETT

Algorithm 1.1: Policy-Gradient Algorithm for Regenerative Processes.
1. Set j

= 0, r = 0, z = 0, and  = 0 (z ;  2 RK ).
0

0

0

2. For each state transition Xt




3. If j

0

! Xt

+1

0

:

If the episode is finished (that is, Xt+1
j +1
j rt zt ,
j j ,
zt+1 ,
rt+1 .

 = +
= +1
=0
=0
Otherwise, set

rp

= i), set



zt+1 = zt + pXXtXtXt+1() ;
t+1
rt+1 = (rt ; Xt+1 ).
( )

= N return N =N , otherwise goto 2.

Examples of recursive
performance functions include the sum of a scalar reward over a cycle,
P

r(X0 ; : : : ; XT ) = Tt=0 r(Xt ) where r(i) is a scalar reward associated with state i (this corresponds to  ( ) being the average reward multiplied by the expected recurrence time E [T ]); the

1
()

negative length of the cycle (which can be implemented by assigning a reward of
to each state,
and is used when the task is to mimimize time taken to get to a goal state, since
  in this case is
PT
t
just E T ); the discounted reward from the start state, r X0 ; : : : ; XT
t=0 ff r Xt , where
ff 2 ; is the discount factor, and so on.
As Williams (1992) pointed out, a further simplification is possible in the case that rT
r X0 ; : : : ; XT is a sum of scalar rewards r Xt ; t depending on the state and possibly the time
t since the starting state (such as r Xt ; t r Xt , or r Xt ; t fft r Xt as above). In that case,
the update from a single regenerative cycle may be written as

[ ]
[0 1)

(

(

)

(



=

TX1
t=0

pXt Xt+1 ()

" t
X

s=0

( )

=

( )
)= ( ) (

rpXtXt+1 ()

()

)=

)=

r(Xs ; s) +

T
X
s=t+1

( )

#

r(Xs ; s) :

(

)

Because changes in pXt Xt+1  have no influence on the rewards r Xs ; s associated with earlier
states (s  t), we should be able to drop the first term in the parentheses on the right-hand-side and
write
TX1
T
rpXtXt+1  X
r X ;s :
(6)
p
 s=t+1 s
t=0 Xt Xt+1

=

()
()

(

)

Although the proof is not entirely trivial, this intuition can indeed be shown to be correct.
Equation (6) allows an even simpler recursive formula for estimating the performance gradient. Set z0
, and introduce a new variable s
. As before, set zt+1
zt
0
rpXtXt+1  =pXtXt+1  and s s if Xt+1 6 i , or s
and zt+1
otherwise. But
now, on each iteration, set t+1 r Xt ; s zt
t . Then t =t is our estimate of r  . Since t
is updated on every iteration, this suggests that we can do away with t altogether and simply update  directly: t+1 t t r Xt ; s zt , where the t are suitable step-sizes4 . Proving convergence

()

P

= =0
()

= +1
=
 = ( ) +
= + ( )



=0
=0

=0



4. The usual requirements on t for convergence of a stochastic gradient algorithm are t > 0,
1 2 < .
t=0 t

1

322

=

()

P1t=0 t

=

+


1, and

fiP OLICY-G RADIENT E STIMATION

of such an algorithm is not as straightforward as normal stochastic gradient algorithms because the
updates r Xt zt are not in the gradient direction (in expectation), although the sum of these updates
over a regenerative cycle are. Marbach and Tsitsiklis (1998) provide the only convergence proof that
we know of, albeit for a slightly different update of the form t+1
t t r Xt ; s  t zt ,
where  t is a moving estimate of the expected performance, and is also updated on-line (this
update was first suggested in the context of POMDPs by Jaakkola et al. (1995)).
Marbach and Tsitsiklis (1998) also considered the case of  -dependent rewards (recall the discussion after (3)), as did Baird and Moore (1999) with their VAPS algorithm (Value And Policy
Search). This last paper contains an interesting insight: through suitable choices of the performance
function r X0 ; : : : ; XT ;  , one can combine policy-gradient search with approximate value function methods. The resulting algorithms can be viewed as actor-critic techniques in the spirit of Barto
et al. (1983); the policy is the actor and the value function is the critic. The primary motivation is
to reduce variance in the policy-gradient estimates. Experimental evidence for this phenomenon
has been presented by a number of authors, including Barto et al. (1983), Kimura and Kobayashi
(1998a), and Baird and Moore (1999). More recent work on this subject includes that of Sutton
et al. (2000) and Konda and Tsitsiklis (2000). We discuss the use of VAPS-style updates further in
Section 6.2.
So far we have not addressed the question of how the parameterized state-transition probabilities pXt Xt+1  arise. Of course, they could simply be generated by parameterizing the matrix of
transition probabilities directly. Alternatively, in the case of MDPs or POMDPs, state transitions
are typically generated by feeding an observation Yt that depends stochastically on the state Xt
into a parameterized stochastic policy, which selects a control Ut at random from a set of available controls (approximate value-function based approaches that generate controls stochastically
via some form of lookahead also fall into this category). The distribution over successor states
pXt Xt+1 Ut is then a fixed function of the control. If we denote the probability of control ut given
parameters  and observation yt by ut ; yt , then all of the above discussion carries through with
rpXtXt+1  =pXtXt+1  replaced by rUt ; Yt =Ut ; Yt . In that case, Algorithm 1.1 is precisely Williams REINFORCE algorithm.
Algorithm 1.1 and the variants above have been extended to cover multiple agents (Peshkin
et al., 2000), policies with internal state (Meuleau et al., 1999), and importance sampling methods
(Meuleau et al., 2000). We also refer the reader to the work of Rubinstein and Shapiro (1993)
and Rubinstein and Melamed (1998) for in-depth analysis of the application of the likelihood-ratio
method to Discrete-Event Systems (DES), in particular networks of queues. Also worth mentioning
is the large literature on Infinitesimal Perturbation Analysis (IPA), which seeks a similar goal of estimating performance gradients, but operates under more restrictive assumptions than the likelihoodratio approach; see, for example, Ho and Cao (1991).

( )

= + [(

^( )

(

) ^( )]

)

()

( )
()

(

()

1.1.2 B IASED E STIMATES

OF THE

)
(

)

(

)

P ERFORMANCE G RADIENT

All the algorithms described in the previous section rely on an identifiable recurrent state i , either
to update the gradient estimate, or in the case of the on-line algorithm, to zero the eligibility trace
z . This reliance on a recurrent state can be problematic for two main reasons:
1. The variance of the algorithms is related to the recurrence time between visits to i , which
will typically grow as the state space grows. Furthermore, the time between visits depends on
323

fiBAXTER & BARTLETT

the parameters of the policy, and states that are frequently visited for the initial value of the
parameters may become very rare as performance improves.
2. In situations of partial observability it may be difficult to estimate the underlying states, and
therefore to determine when the gradient estimate should be updated, or the eligibility trace
zeroed.
If the system is available only through simulation, it seems difficult (if not impossible) to obtain
unbiased estimates of the gradient direction without access to a recurrent state. Thus, to solve 1
and 2, we must look to biased estimates. Two principle techniques for introducing bias have been
proposed, both of which may be viewed as artificial truncations of the eligibility trace z . The first
method takes as a starting point the formula5 for the eligibility trace at time t:

zt =

t 1
X

rpXsXs+1 ()
pXs Xs+1 ()

s=0

and simply truncates it at some (fixed, not random) number of terms n looking backwards (Glynn,
1990; Rubinstein, 1991, 1992; Cao & Wan, 1998):

zt (n) :=

t 1
X
s=t n

rpXsXs+1 () :
pXs Xs+1 ()

(7)

(n) is then updated after each transition Xt ! Xt by
rp
() rpXt nXt n+1 () ;
zt (n) = zt (n) + XtXt+1
pXt Xt+1 ()
pXt n Xt n+1 ()
and in the case of state-based rewards r (Xt ), the estimated gradient direction after T steps is
T
^rn() := 1 X zt (n)r(Xt ):
T n+1 t n
The eligibility trace zt

+1

+1

(8)

(9)

=

Unless n exceeds the maximum recurrence time (which is infinite in an ergodic Markov chain),
rn  is a biased estimate of the gradient direction, although as n ! 1, the bias approaches zero.
However the variance of rn   diverges in the limit of large n. This illustrates a natural trade-off
in the selection of the parameter n: it should be large enough to ensure the bias is acceptable (the
expectation of rn   should at least be within  of the true gradient direction), but not so large
that the variance is prohibitive. Experimental results by Cao and Wan (1998) illustrate nicely this
bias/variance trade-off.
One potential difficulty with this method is that the likelihood ratios rpXs Xs+1  =pXs Xs+1 
must be remembered for the previous n time steps, requiring storage of Kn parameters. Thus,
to obtain small bias, the memory may have to grow without bound. An alternative approach that
requires a fixed amount of memory is to discount the eligibility trace, rather than truncating it:

^ ()

^ ()

^ ()

90

()

zt+1 (fi ) := fizt (fi ) +

rpXtXt+1 () ;
pXt Xt+1 ()

()

(10)

r

5. For ease of exposition, we have kept the expression for z in terms of the likelihood ratios pXs Xs+1 ()=pXs Xs+1 ()
which rely on the availability of the underlying state Xs . If Xs is not available, pXs Xs+1 ()=pXs Xs+1 () should
be replaced with Us (; Ys )=Us (; Ys ).

r

r

324

fiP OLICY-G RADIENT E STIMATION

( )=0

where z0 fi
and fi
after T steps is simply

2 [0; 1) is a discount factor.
r^fi () := T1

TX1
t=0

In this case the estimated gradient direction

r(Xt )zt (fi ):

(11)

( ) ()
(( ) )

This is precisely the estimate we analyze in the present paper. A similar estimate with r Xt zt fi
replaced by r Xt
b zt fi where b is a reward baseline was proposed by Kimura et al. (1995,
1997) and for continuous control by Kimura and Kobayashi (1998b). In fact the use of r Xt
b
in place of r Xt does not affect the expectation of the estimates of the algorithm (although judicious choice of the reward baseline b can reduce the variance of the estimates). While the algorithm
presented by Kimura et al. (1995) provides estimates of the expectation under the stationary distribution of the gradient of the discounted reward, we will show that these are in fact biased estimates
of the gradient of the expected discounted reward. This arises because the stationary distribution
itself depends on the parameters. A similar estimate to (11) was also proposed by Marbach and
Tsitsiklis (1998), but this time with r Xt zt fi replaced by r Xt
  zt fi , where   is an
estimate of the average reward, and with zt zeroed on visits to an identifiable recurrent state.
As a final note, observe that the eligibility traces zt fi and zt n defined by (10) and (8) are
simply filtered versions of the sequence rpXt Xt+1  =pXt Xt+1  , a first-order, infinite impulse
response filter in the case of zt fi and an n-th order, finite impulse response filter in the case of
zt n . This raises the question, not addressed in this paper, of whether there is an interesting theory
of optimal filtering for policy-gradient estimators.

(( )
( )

) ()

( ) ()

( ( ) ^( )) ( )

()

()

()

()

^( )

()
()

1.2 Our Contribution
We describe GPOMDP, a general algorithm based upon (11) for generating a biased estimate of the
performance gradient r  in general POMDPs controlled by parameterized stochastic policies.
Here   denotes the average reward of the policy with parameters  2 RK . GPOMDP does
not rely on access to an underlying recurrent state. Writing rfi   for the expectation of the estimate produced by GPOMDP, we show that
r  , and more quantitatively that
fi !1 rfi  
rfi   is close to the true gradient provided = fi exceeds the mixing time of the Markov chain
induced by the POMDP6 . As with the truncated estimate above, the trade-off preventing the setting
of fi arbitrarily close to is that the variance of the algorithms estimates increase as fi approaches
. We prove convergence with probability 1 of GPOMDP for both discrete and continuous observation and control spaces. We present algorithms for both general parameterized Markov chains and
POMDPs controlled by parameterized stochastic policies.
There are several extensions to GPOMDP that we have investigated since the first version of
this paper was written. We outline these developments briefly in Section 7.
In a companion paper we show how the gradient estimates produced by GPOMDP can be used
to perform gradient ascent on the average reward   (Baxter et al., 2001). We describe both
traditional stochastic gradient algorithms, and a conjugate-gradient algorithm that utilizes gradient
estimates in a novel way to perform line searches. Experimental results are presented illustrat-

()

()

()
lim
( )= ( )
1 (1 )

()

1

1

()

6. The mixing-time result in this paper applies only to Markov chains with distinct eigenvalues. Better estimates of the
bias and variance of GPOMDP may be found in Bartlett and Baxter (2001), for more general Markov chains than
those treated here, and for more refined notions of the mixing time. Roughly speaking, the variance of GPOMDP
grows with 1=(1 fi ), while the bias decreases as a function of 1=(1 fi ).

325

fiBAXTER & BARTLETT

ing both the theoretical results of the present paper on a toy problem, and practical aspects of the
algorithms on a number of more realistic problems.

2. The Reinforcement Learning Problem
We model reinforcement learning as a Markov decision process (MDP) with a finite state space
S f ; : : : ; ng, and a stochastic matrix7 P pij giving the probability of transition from state
i to state j . Each state i has an associated reward8 r i . The matrix P belongs to a parameterized
class of stochastic matrices, P
fP   2 RK g. Denote the Markov chain corresponding to
P  by M  . We assume that these Markov chains and rewards satisfy the following assumptions:

= 1

()

=[ ]

()

:= ( ):

()

()

Assumption 1. Each P  2 P has a unique stationary distribution 
satisfying the balance equations

() := [(; 1); : : : ; (; n)]0

0 ()P () = 0 ()
(throughout  0 denotes the transpose of  ).
Assumption 2. The magnitudes of the rewards, jr (i)j, are uniformly bounded by R <
states i.

(12)

1 for all

Assumption 1 ensures that the Markov chain forms a single recurrent class for all parameters  .
Since any finite-state Markov chain always ends up in a recurrent class, and it is the properties of
this class that determine the long-term average reward, this assumption is mainly for convenience
so that we do not have to include the recurrence class as a quantifier in our theorems. However,
when we consider gradient-ascent algorithms Baxter et al. (2001), this assumption becomes more
restrictive since it guarantees that the recurrence class cannot change as the parameters are adjusted.
Ordinarily, a discussion of MDPs would not be complete without some mention of the actions
available in each state and the space of policies available to the learner. In particular, the parameters
 would usually determine a policy (either directly or indirectly via a value function), which would
then determine the transition probabilities P  . However, for our purposes we do not care how
the dependence of P on  arises, just that it satisfies Assumption 1 (and some differentiability
assumptions that we shall meet in the next section). Note also that it is easy to extend this setup
to the case where the rewards also depend on the parameters  or on the transitions i ! j . It is
equally straightforward to extend our algorithms and results to these cases. See Section 6.1 for an
illustration.
The goal is to find a  2 R K maximizing the average reward:
fi
"
#
TX1
fi
fi

E
r Xt fi X0 i ;
fi
T !1  T
t=0
where E denotes the expectation over all sequences X0 ; X1 ; : : : ; with transitions generated according to P  . Under Assumption 1,   is independent of the starting state i and is equal to
n
X

 ; i r i 0  r;
(13)
i=1

()

1

( ) := lim

()

=

()

( )=

where r

( )

( ) ()= ( )

= [r(1); : : : ; r(n)]0 (Bertsekas, 1995).


P

7. A stochastic matrix P = [pij ] has pij 0 for all i; j and n
j =1 pij = 1 for all i.
8. All the results in the present paper apply to bounded stochastic rewards, in which case r(i) is the expectation of the
reward in state i.

326

fiP OLICY-G RADIENT E STIMATION

3. Computing the Gradient of the Average Reward

()

For general MDPs little will be known about the average reward   , hence finding its optimum
will be problematic. However, in this section we will see that under general assumptions the gradient
r  exists, and so local optimization of   is possible.
To ensure the existence of suitable gradients (and the boundedness of certain random variables),
we require that the parameterized class of stochastic matrices satisfies the following additional assumption.

()

()

Assumption 3. The derivatives,

rP () :=
2 RK . The ratios

exist for all 



@pij ()
@k

i;j =1:::n;k=1:::K

2 fifi @p () fifi 3
ij
fi @k fi
4
5

pij ()

are uniformly bounded by B



i;j =1:::n;k=1:::K

< 1 for all  2 RK .

The second part of this assumption allows zero-probability transitions pij

() = 0 only if

rpij () is also zero, in which case we set 0=0 = 0. One example is if i ! j is a forbidden
transition, so that pij ( ) = 0 for all  2 RK . Another example satisfying the assumption is
pij () =
where 

= [

11

; : : : ; 1n ; : : : ; nn ] 2 Rn2

are the parameters of P

@pij ()=@ij
pij ()
@pij ()=@kl
pij ()

Assuming for the moment that r
dependencies,

eij
ij ;
j =1 e

Pn

=1
=

pij ();

(), for then

and

pkl ():

() exists (this will be justified shortly), then, suppressing 
r = r0r;
(14)

since the reward r does not depend on  . Note that our convention for r in this paper is that it takes
precedence over all other operations, so rg  f 
rg  f  . Equations like (14) should be
regarded as shorthand notation for K equations of the form

( ) ( ) = [ ( )] ( )

@()
@k

where k

=





@(; 1)
@(; n)
;:::;
[r(1); : : : ; r(n)]0
@k
@k

= 1; : : : ; K . To compute r, first differentiate the balance equations (12) to obtain
r0P + 0 rP = r0;
327

fiBAXTER & BARTLETT

and hence

r0(I P ) = 0 rP:

(15)

The system of equations defined by (15) is under-constrained because I P is not invertible (the
balance equations show that I P has a left eigenvector with zero eigenvalue). However, let e
denote the n-dimensional column vector consisting of all s, so that e 0 is the n  n matrix with the
stationary distribution  0 in each row. Since r 0 e r  0 e
r
, we can rewrite (15) as

1

= ( ) = (1) = 0





r0 I (P e0) = 0rP:
To see that the inverse
Then we can write

[I (P
"

lim (I

e0 )]
A)

T !1

T
X
t=0

1

exists, let A be any matrix satisfying
#

= Tlim
!1

At

[

t=0

= I Tlim
!1
= I:

Thus,

(I

" T
X

A)

1

=

1
X
t=0

TX
+1

At

AT +1

t=1

limt!1 At = 0.

#

At

At :

] =

0

It is easy to prove by induction that P e 0 t
P t eP0 which
to as t ! 1 by
 tconverges
1
0
0 . Hence, we can write
Assumption 1. So I
P e
exists and is equal to 1
P
e
t=0

[

(

)]



r0 = 0rP I P + e0
and so9



r = 0rP I P + e0





;

(16)

r:

(17)

1

1

For MDPs with a sufficiently small number of states, (17) could be solved exactly to yield the precise
gradient direction. However, in general, if the state space is small enough that an exact solution of
(17) is possible, then it will be small enough to derive the optimal policy using policy iteration and
table-lookup, and there would be no point in pursuing a gradient based approach in the first place10 .
Thus, for problems of practical interest, (17) will be intractable and we will need to find some
other way of computing the gradient. One approximate technique for doing this is presented in the
next section.
9. The argument leading to (16) coupled with the fact that  () is the unique solution to (12) can be used to justify the
existence of  . Specifically, we can run through the same steps computing the value of  ( +  ) for small  and
show that the expression (16) for  is the unique matrix satisfying  ( +  ) =  () +   () + O(  2 ).
10. Equation (17) may still be useful for POMDPs, since in that case there is no tractable dynamic programming
algorithm.

r

r

r

328

kk

fiP OLICY-G RADIENT E STIMATION

4. Approximating the Gradient in Parameterized Markov Chains
In this section, we show that the gradient can be split into two components, one of which becomes
negligible as a discount factor fi approaches .
For all fi 2 ; , let Jfi 
Jfi ; ; : : : ; Jfi ; n denote the vector of expected discounted
rewards from each state i:

[0 1)

( ) = [ ( 1)

Jfi (; i) := E

1

"

( )]

1
X
t=0

fitr

fi
fi
Xt fifi X0
fi

( )

#

=i

:

(18)

Where the  dependence is obvious, we just write Jfi .

2 [0; 1),
r = (1 fi )r0 Jfi + fi0rP Jfi :

Proposition 1. For all  2 R K and fi

(19)

Proof. Observe that Jfi satisfies the Bellman equations:

Jfi = r + fiP Jfi :

(20)

(Bertsekas, 1995). Hence,

r = r0r
= r0 [Jfi fiP Jfi ]
= r0Jfi fi r0Jfi + fi0 rP Jfi
= (1 fi )r0 Jfi + fi0rP Jfi :

by (15)

We shall see in the next section that the second term in (19) can be estimated from a single sample path of the Markov chain. In fact, Theorem 1 in (Kimura et al., 1997) shows that the gradient
estimates of the algorithm presented in that paper converge to
fi 0 rJfi . By the Bellman equations (20), this is equal to
fi fi 0 rP Jfi 0 rJfi , which implies
fi 0 rJfi fi0 rP Jfi .
Thus the algorithm of Kimura et al. (1997) also estimates the second term in the expression for
r  given by (19). It is important to note that 0rJfi 6 r 0 Jfi the two quantities disagree
by the first term in (19). This arises because the the stationary distribution itself depends on the
parameters. Hence, the algorithm of Kimura et al. (1997) does not estimate the gradient of the expected discounted reward. In fact, the expected discounted reward is simply =
fi times the
average reward   (Singh et al., 1994, Fact 7), so the gradient of the expected discounted reward
is proportional to the gradient of the average reward.
The following theorem shows that the first term in (19) becomes negligible as fi approaches .
Notice that this is not immediate from Proposition 1, since Jfi can become arbitrarily large in the
limit fi ! .

(1 ) (

+

(1

)

= [

]

)

()

(1 )

=

1 (1

()

)

1

1

Theorem 2. For all  2 RK ,

r = filim
r ;
! fi

(21)

rfi  := 0 rP Jfi :

(22)

1

where

329

fiBAXTER & BARTLETT

Proof. Recalling equation (17) and the discussion preceeding it, we have 11

r = 0rP
But rP e

1 
X



e0 r:

Pt

t=0

(23)

= r(P e) = r(1) = 0 since P is a stochastic matrix, so (23) can be rewritten as
r = 0

"
1
X

#

rP P t r:

t=0

(24)

2 [0; 1] be a discount factor and consider the expression

Now let fi

f (fi ) := 0

= lim
( )=

()

"
1
X

t=0

#

rP (fiP )t r

(25)

( )=

Clearly r
rfi .
fi !1 f fi . To complete the proof we just need to show that f fi
t
t
t
t
0
Since fiP
fi P ! fi e ! , we can invoke the observation before (16) to write

0

1
X
t=0
P

In particular, 1
t=0
of (25) and write12

(fiP )t = [I

(fiP )t converges, so we can take rP back out of the sum in the right-hand-side
f (fi ) = 0 rP

But

P1

t=0


fitP t r

fiP ] 1 :

= Jfi . Thus f (fi ) = 0rP Jfi

"1
X

t=0

#

fitP t

r:

(26)

= rfi .

1

Theorem 2 shows that rfi  is a good approximation to the gradient as fi approaches , but it
turns out that values of fi very close to lead to large variance in the estimates of rfi  that we
describe in the next section. However, the following theorem shows that
fi need not be too
small, provided the transition probability matrix P  has distinct eigenvalues, and the Markov
chain has a short mixing time. From any initial state, the distribution over states of a Markov chain
converges to the stationary distribution, provided the assumption (Assumption 1) about the existence
and uniqueness of the stationary distribution is satisfied (see, for example, Lancaster & Tismenetsky,
1985, Theorem 15.8.1, p. 552). The spectral resolution theorem (Lancaster & Tismenetsky, 1985,
Theorem 9.5.1, p. 314) implies that the distribution converges to stationarity at an exponential rate,
and the time constant in this convergence rate (the mixing time) depends on the eigenvalues of
the transition probability matrix. The existence of a unique stationary distribution implies that the

1

1

()

11. Since e 0 r = e , (23) motivates a different kind of algorithm for estimating  based on differential rewards
(Marbach & Tsitsiklis, 1998).
12. We cannot back P out of the sum in the right-hand-side of (24) because 1
P t diverges (P t e 0 ). The reason
1 P P t converges is that P t becomes orthogonal to P in the limit tof=0large t. Thus, we can view 1 P t
t=0
t=0
as a sum of two orthogonal components: an infinite one in the direction e and a finite one in the direction e? . It
1
t
t
is the finite component that we need to estimate. Approximating 1
t=0 P with t=0 (fiP ) is a way of rendering
the e-component finite while hopefully not altering the e? -component too much. There should be other substitutions
that lead to better approximations (in this context, see the final paragraph in Section 1.1).

P

r

r

r

330

P

P

r

!

P

P

fiP OLICY-G RADIENT E STIMATION

1

1

largest magnitude eigenvalue is and has multiplicity , and the corresponding left eigenvector is
the stationary distribution. We sort the eigenvalues i in decreasing order of magnitude, so that
1 > j2 j >    > js j for some  s  n. It turns out that j2 j determines the mixing time
of the chain.
The following theorem shows that if
fi is small compared to
j2j, the gradient approximation described above is accurate. Since we will be using the estimate as a direction in which to
update the parameters, the theorem compares the directions of the gradient and its estimate. In this
theorem, 2 A denotes the spectral condition number of a nonsingular matrix A, which is defined
as the product of the spectral norms of the matrices A and A 1 ,

1=

2

1

1

( )

2 (A) = kAk2 kA

where

1

k;
2

kAk = x max
kAxk;
kxk
2

:

=1

and kxk denotes the Euclidean norm of the vector x.

()

Theorem 3. Suppose that the transition probability matrix P  satisfies Assumption 1 with stationary distribution  0
1 ; : : : ; n , and has n distinct eigenvalues. Let S
x1 x2    xn be
the matrix of right eigenvectors of P corresponding, in order, to the eigenvalues
1 > j2 j 
    jn j. Then the normalized inner product between r and fi rfi  satisfies

=(

)

=(
1=

)


 kr(p ; : : : ; p )k p
  fi rfi 
1 fi
n
1 rkr

 =S
r0r
(27)
k
krk
1 fi j j ;
where  = diag( ; : : : ; n ).
Notice that r 0 r is the expectation under the stationary distribution of r (X ) .
As well as the mixing time (via j j), the bound in the theorem depends on another parameter of
the Markov chain: the spectral condition number of  = S . If the Markov chain is reversible (which
2

1 2

2

1

2

1

2

2

1 2

implies that the eigenvectors x1 ; : : : ; xn are orthogonal), this is equal to the ratio of the maximum
to the minimum probability of states under the stationary distribution. However, the eigenvectors
do not need to be nearly orthogonal. In fact, the condition that the transition probability matrix
have n distinct eigenvalues is not necessary; without it, the condition number is replaced by a more
complicated expression involving spectral norms of matrices of the form P i I .

(

)



Proof. The existence of n distinct eigenvalues implies that P can be expressed as S S 1 , where
1 ; : : : ; n (Lancaster & Tismenetsky, 1985, Theorem 4.10.2, p 153). It follows that for
any polynomial f , we can write f P
Sf S 1 .
Now, Proposition 1 shows that r fi rfi  r 0
fi Jfi . But

 = diag(

)

( ) = ()
= (1 )
(1 fi )Jfi = (1 fi ) r + fiP r + fi P r +    
= (1 fi ) I + fiP + fi!P +    r
1
X
= (1 fi )S
fi t t S r
2

2

2

2

1

= (1

fi)

n
X
j =1

t=0

xj y 0

331

j

1
X
t=0

(fij )

!

t

r;

fiBAXTER & BARTLETT

=(
=

)

where S 1
y1 ; : : : ; yn 0 .
It is easy to verify that yi is the left eigenvector corresponding to i , and that we can choose
y1  and x1 e. Thus we can write

=

(1

fi )Jfi = (1 fi )e0 r +

n
X

xj yj0

(1

!

fi )(fij )t r

t=0
j =2


n
X
fi
r
xj yj0
fi
j
j =2

= (1

fi )e +

= (1

fi )e + SMS 1 r;


1
1



1
M = diag 0;
1

where

1
X

fi
1 fi :
;:::;
fi2
1 fin

It follows from this and Proposition 1 that

  fi rfi 
r  (r r0(1
1 rkr
=
1
k
krk
0
= r  r (1 fi )Jfi
2

2

fi )Jfi )

krk

r
  r0 (1 fi )e + SMS r
=
krk
0
 SMS r
= r  rkr
k 

r 0 SMS r 

krk ;
p 
0
Since r = r
0  = , we can apply the Cauchy2

1

2

1

2

1

by the Cauchy-Schwartz inequality.
Schwartz inequality again to obtain

1 2

  fi rfi 
1 rkr

k





r



p

0

 



 = SMS
1 2

1

krk

2



r

:

(28)

We use spectral norms to bound the second factor in the numerator. It is clear from the definition
that the spectral norm of a product of nonsingular matrices satisfies kAB k2  kAk2 kB k2 , and that
the spectral norm of a diagonal matrix is given by k
d1 ; : : : ; dn k2
i jdi j. It follows that




 = SMS
1 2

1

diag(
) = max
 

r =  = SMS  =  = r

 
 

  = S  S  =   = r kM k

p
   = S r0r 1 1 fi jfi j :
1 2

1

1 2

1

2

2

1 2

1 2

1 2

1 2

2

1 2

2

Combining with Equation (28) proves (27).
332

2

fiP OLICY-G RADIENT E STIMATION

5. Estimating the Gradient in Parameterized Markov Chains
Algorithm 1 introduces MCG (Markov Chain Gradient), an algorithm for estimating the approximate gradient rfi  from a single on-line sample path X0 ; X1 ; : : : from the Markov chain M  .
MCG requires only K reals to be stored, where K is the dimension of the parameter space: K
parameters for the eligibility trace zt , and K parameters for the gradient estimate t . Note that
after T time steps T is the average so far of r Xt zt ,

()

2





( )

TX
1
T =
zt r(Xt ):
1

T

t=0

Algorithm 1 The MCG (Markov Chain Gradient) algorithm
1: Given:




Parameter  2 R K .
Parameterized class of stochastic matrices P
3 and 1.

= fP ():  2 RK g satisfying Assumptions

 fi 2 [0; 1).
 Arbitrary starting state X .
 State sequence X ; X ; : : :
0

generated by M ( ) (i.e. the Markov chain with transition
()).
 Reward sequence r(X ); r(X ); : : : satisfying Assumption 2.
Set z = 0 and  = 0 (z ;  2 RK ).
for each state Xt visited do
rp
( )
zt = fizt + XtXt+1
pXt Xt+1 ()
t = t + t [r(Xt )zt t ]
probabilities P

0

1

0

2:
3:
4:
5:
6:

0

0

0

1

0

+1

+1

1
+1

+1

+1

+1

end for

Theorem 4. Under Assumptions 1, 2 and 3, the MCG algorithm starting from any initial state X0
will generate a sequence 0 ; 1 ; : : : ; t ; : : : satisfying

 



lim t = rfi 

t!1

=

w.p.1:

(29)

()

Proof. Let fXt g fX0 ; X1 ; : : : g denote the random process corresponding to M  . If X0  
then the entire process is stationary. The proof can easily be generalized to arbitrary initial distributions using the fact that under Assumption 1, fXt g is asymptotically stationary. When fXt g is
333

fiBAXTER & BARTLETT

stationary, we can write

0 rP Jfi =

X

=

X

=

X

i;j
i;j
i;j

(i)rpij ()Jfi (j )
(i)pij ()

rpij () J (j )
p () fi
ij

Pr(Xt = i)Pr(Xt = j jXt = i) rppij(()) E(J (t + 1)jXt = j );
+1

+1

ij

where the first probability is with respect to the stationary distribution and

J (t + 1) =

( ( + 1)

)= (

1
X
s=t+1

fis

t

1

(30)

J (t + 1) is the process

r(Xs ):

)

The fact that E J t
jXt+1 Jfi Xt+1 for all Xt+1 follows from the boundedness of the
magnitudes of the rewards (Assumption 2) and Lebesgues dominated convergence theorem. We
can rewrite Equation (30) as




X
rp ()
0 rP Jfi = E i (Xt )j (Xt+1 ) ij J (t + 1) ;

pij ()

i;j

where i

() denotes the indicator function for state i,
(
1 if Xt = i;
i (Xt ) :=
0 otherwise;

and the expectation is again with respect to the stationary distribution. When Xt is chosen according
to the stationary distribution, the process fXt g is ergodic. Since the process fZt g defined by

Zt := i (Xt )j (Xt+1 )

rpij () J (t + 1)
pij ()

is obtained by taking a fixed
of fXt g, fZt g is also stationary and ergodic (Breiman, 1966,
fi function
fi
fi rpij () fi
Proposition 6.31). Since fi pij () fi is bounded by Assumption 3, from the ergodic theorem we have
(almost surely):

0 rP Jfi

TX
1
rp ()
= Tlim
i (Xt )j (Xt ) ij J (t + 1)
!1 T t
pij ()
i;j
TX
rpXtXt+1 () J (t + 1)
1
= Tlim
!1 T t
pXtXt+1 ()
" T
TX
1
X
r
pXtXt+1 () X
1
= Tlim
fi s t r(Xs ) +
!1 T t
pXtXt+1 () s t
s T
X

1

+1

=0

1

=0

1

1

=0

= +1

334

= +1

#

fis t

1

r(Xs ) :

(31)

fiP OLICY-G RADIENT E STIMATION

Concentrating on the second term in the right-hand-side of (31), observe that:
fi
fi TX1
fi
fi
fiT

1

t=0

rpXtXt+1 ()
pXt Xt+1 ()

1
X

fis t

s=T +1
TX1 fifi

1
T

fi
fi

1

fi
fi
Xs fifi
fi

r(

)

pXt Xt+1 ()

t=0
1
BR TX1 X

 T

= BR
T

1
X

rpXtXt+1 () fififi

t=0 s=T +1
TX1 T t

fi

t=0

1

fis

fi

t

s=T +1

fis

t

1

jr(Xs)j

1

fi

1 fiT
= BRfi
T (1 fi )2
! 0 as T ! 1;



jrp j
where R and B are the bounds on the magnitudes of the rewards and pijij from Assumptions 2
and 3. Hence,
TX1
T
rpXtXt+1  X
0 rP Jfi
(32)
fi s t 1 r Xs :
T !1 T
p

X
X
t t+1
t=0
s=t+1
Unrolling the equation for T in the MCG algorithm shows it is equal to

()
()

= lim 1


T
1 TX rpXtXt+1 () X
T t pXt Xt+1 () s t
1

=0

hence

fis

( )

t

1

r(is );

= +1

T ! 0rP Jfi w.p.1 as required.

6. Estimating the Gradient in Partially Observable Markov Decision Processes

()

Algorithm 1 applies to any parameterized class of stochastic matrices P  for which we can compute the gradients rpij  . In this section we consider the special case of P  that arise from a
parameterized class of randomized policies controlling a partially observable Markov decision process (POMDP). The partially observable qualification means we assume that these policies have
access to an observation process that depends on the state, but in general they may not see the state.
Specifically, assume that there are N controls U
f ; : : : ; N g and M observations Y
f ; : : : ; M g. Each u 2 U determines a stochastic matrix P u which does not depend on the
parameters  . For each state i 2 S , an observation Y 2 Y is generated independently according to
a probability distribution  i over observations in Y . We denote the probability of observation y
by y i . A randomized policy is simply a function  mapping observations y 2 Y into probability
distributions over the controls U . That is, for each observation y ,  y is a distribution over the
controls in U . Denote the probability under  of control u given observation y by u y .
To each randomized policy   and observation distribution   there corresponds a Markov
chain in which state transitions are generated by first selecting an observation y in state i according

()

= 1

1

()

()

=

()

()

()
()

()

335

()

fiBAXTER & BARTLETT

()

()

to the distribution  i , then selecting a control u according to the distribution  y , and then generating a transition to state j according to the probability pij u . To parameterize these chains we
parameterize the policies, so that  now becomes a function  ; y of a set of parameters  2 R K as
well as the observation y . The Markov chain corresponding to  has state transition matrix pij 
given by

()
( )

[ ( )]

pij () = EY  (i) EU (;Y ) pij (U ):

Equation (33) implies

rpij () =

X

(33)

y (i)pij (u)ru (; y):

u;y

(34)

Algorithm 2 introduces the GPOMDP algorithm (for Gradient of a Partially Observable Markov
Decision Process), a modified form of Algorithm 1 in which updates of zt are based on Ut ; Yt ,
rather than pXt Xt+1  . Note that Algorithm 2 does not require knowledge of the transition probability matrix P , nor of the observation process  ; it only requires knowledge of the randomized
policy . GPOMDP is essentially the algorithm proposed by Kimura et al. (1997) without the
reward baseline.
The algorithm GPOMDP assumes that the policy  is a function only of the current observation.
It is immediate that the same algorithm works for any finite history of observations. In general, an
optimal policy needs to be a function of the entire observation history. GPOMDP can be extended
to apply to policies with internal state (Aberdeen & Baxter, 2001).

(

()

)

Algorithm 2 The GPOMDP algorithm.
1: Given:




Parameterized class of randomized policies



(; ) :  2 RK

	

satisfying Assumption 4.

Partially observable Markov decision process which when controlled by the randomized
policies  ;  corresponds to a parameterized class of Markov chains satisfying Assumption 1.

( )

 fi 2 [0; 1).
 Arbitrary (unknown) starting state X .
 Observation sequence Y ; Y ; : : : generated by the POMDP with controls U ; U ; : : :
0

0

1

0

(; Yt).

generated randomly according to 


2:
3:
4:
5:
6:

( ) ( )

Reward sequence r X0 ; r X1 ; : : : satisfying Assumption 2, where
(hidden) sequence of states of the Markov decision process.

=0

 =0 
= + (( ))
 = + [ ( )

Set z0
and 0
(z0 ; 0 2 RK ).
for each observation Yt , control Ut , and subsequent reward r
rUt ; Yt
zt+1 fizt
Ut ; Yt
1
t+1
t t+1 r Xt+1 zt+1
t
end for

]

336

(Xt ) do
+1

X0 ; X1 ; : : :

1

is the

fiP OLICY-G RADIENT E STIMATION

For convergence of Algorithm 2 we need to replace Assumption 3 with a similar bound on the
gradient of :
Assumption 4. The derivatives,

exist for all u 2 U , y

@u (; y)
@k

2 Y and  2 RK . The ratios
fi
2 fifi
@u (;y) fi 3
fi @
fi
k
4
5

u (; y)

are uniformly bounded by B

y=1:::M ;u=1:::N ;k=1:::K

< 1 for all  2 RK .

Theorem 5. Under Assumptions 1, 2 and 4, Algorithm 2 starting from any initial state
generate a sequence 0 ; 1 ; : : : ; t ; : : : satisfying

 



lim t = rfi 

w.p.1:

t!1

X0

will

(35)

Proof. The proof follows the same lines as the proof of Theorem 4. In this case,

0 rP Jfi =

=
=
=

X

i;j

(i)rpij ()Jfi (j )

X

i;j;y;u
X

i;j;y;u
X

i;j;y;u

(i)pij (u)y (i)ru (; y)Jfi (j ) from (34)
(i)pij (u)y (i)

ru (; y)  (; y)J (j );
fi
 (; y) u
u

EZt0;

where the expectation is with respect to the stationary distribution of fXt g, and the process fZt0 g is
defined by
ru ; y J t ;
Zt0 i Xt j Xt+1 u Ut y Yt
u ; y

:= ( ) (

) ( ) ( ) (( )) ( + 1)

where Ut is the control process and Yt is the observation process. The result follows from the same
arguments used in the proof of Theorem 4.
6.1 Control dependent rewards

There are many circumstances in which the rewards may themselves depend on the controls u. For
example, some controls may consume more energy than others and so we may wish to add a penalty
term to the reward function in order to conserve energy. The simplest way to deal with this is to
define for each state i the expected reward r i by

( )

r(i) = EY  (i) EU (;Y ) r(U; i);
337

(36)

fiBAXTER & BARTLETT



and then redefine Jfi in terms of r:

Jfi (; i) :=

lim E

"

N !1

N
X
t=0

fi
fi
Xt fifi X0
fi

( )

fitr

#

=i

;

(37)

X0 ; X1 ; : : : . The performance gradient then becomes
r = r0r + 0rr;

where the expectation is over all trajectories

which can be approximated by

rfi  = 0 rP Jfi + rr ;








due to the fact that Jfi satisfies the Bellman equations (20) with r replaced by r .
For GPOMDP to take account of the dependence of r on the controls, its fifth line should be
replaced by

1
t = t + t + 1 r(Ut
+1



r
Ut+1 (; Yt )
; Xt ) zt +
t :
 (; Y )


+1

+1

+1

+1

Ut+1
t+1
It is straightforward to extend the proofs of Theorems 2, 3 and 5 to this setting.

6.2 Parameter dependent rewards
It is possible to modify GPOMDP when the rewards themselves depend directly on  . In this case,
the fifth line of GPOMDP is replaced with

t = t + t +1 1 [r(; Xt )zt + rr(; Xt ) t] :
+1

+1

+1

(38)

+1

( )

Again, the convergence and approximation theorems will carry through, provided rr ; i is uniformly bounded. Parameter-dependent rewards have been considered by Glynn (1990), Marbach
and Tsitsiklis (1998), and Baird and Moore (1999). In particular, Baird and Moore (1999) showed
how suitable choices of r ; i lead to a combination of value and policy search, or VAPS. For
example, if J ; i is an approximate value-function, then setting13

( )

~( )

h
i
1
~
~
r(; Xt ; Xt ) =
2 r(Xt ) + ffJ (; Xt ) J (; Xt ) ;
where r (Xt ) is the usual reward and ff 2 [0; 1) is a discount factor, gives an update that seeks to
2

1

1

minimize the expected Bellman error
n
X
i=1

2

(; i) 4r(i) + ff

n
X
j =1

32

pij ()J~(; j ) J~(; i)5 :

(39)

~( )

This will have the effect of both minimizing the Bellman error in J ; i , and driving the system
(via the policy) to states with small Bellman error. The motivation behind such an approach can
be understood if one considers a J that has zero Bellman error for all states. In that case a greedy
policy derived from J will be optimal, and regardless of how the actual policy is parameterized, the
expectation of zt r ; Xt ; Xt 1 will be zero and so will be the gradient computed by GPOMDP.
This kind of update is known as an actor-critic algorithm (Barto et al., 1983), with the policy playing
the role of the actor, and the value function playing the role of the critic.

(

~

13. The use of rewards r(; Xt ; Xt
analysis.

~

)

1 ) that depend on the current and previous

338

state does not substantially alter the

fiP OLICY-G RADIENT E STIMATION

6.3 Extensions to infinite state, observation, and control spaces
The convergence proof for Algorithm 2 relied on finite state (S ), observation (Y ) and control (U )
spaces. However, it should be clear that with no modification Algorithm 2 can be applied immediately to POMDPs with countably or uncountably infinite S and Y , and countable U . All that
changes is that pij u becomes a kernel p x; x0 ; u and  i becomes a density on observations. In
addition, with the appropriate interpretation of r=, it can be applied to uncountable U . Specifically, if U is a subset of R N then  y;  will be a probability density function on U with u y; 
the density at u. If U and Y are subsets of Euclidean space (but S is a finite set), Theorem 5 can be
extended to show that the estimates produced by this algorithm converge almost surely to rfi  . In
fact, we can prove a more general result that implies both this case of densities on subsets of R N as
well as the finite case of Theorem 5. We allow U and Y to be general spaces satisfying the following
topological assumption. (For definitions see, for example, (Dudley, 1989).)

()

(

)

()

( )

( )

Assumption 5. The control space U has an associated topology that is separable, Hausdorff, and
first-countable. For the corresponding Borel  -algebra B generated by this topology, there is a
-finite measure  defined on the measurable space U ; B . We say that  is the reference measure
for U .
Similarly, the observation space Y has a topology, Borel  -algebra, and reference measure
satisfying the same conditions.

(

)

In the case of Theorem 5, where U and Y are finite, the associated reference measure is the
counting measure. For U
RN and Y RM , the reference measure is Lebesgue measure. We
assume that the distributions  i and  ; y are absolutely continuous with respect to the reference
measures, and the corresponding Radon-Nikodym derivatives (probability masses in the finite case,
densities in the Euclidean case) satisfy the following assumption.

=

()

=

( )

( )

Assumption 6. For every y 2 Y and  2 R K , the probability measure  ; y is absolutely continuous with respect to the reference measure for U . For every i 2 S , the probability measure  i is
absolutely continuous with respect to the reference measure for Y .
Let  be the reference measure for U . For all u 2 U , y 2 Y ,  2 R K , and k 2 f ; : : : ; K g, the
derivatives

@ d(; y)
(u)
@k d

fi
fi @ du (;y)
fi @k d

exist and the ratios

< 1.

1

fi

(u)fifi
du ;y
d (u)
(

are bounded by B

()

)

With these assumptions, we can replace  in Algorithm 2 with the Radon-Nikodym derivative
of  with respect to the reference measure on U . In this case, we have the following convergence
result. This generalizes Theorem 5, and also applies to densities  on a Euclidean space U .

Theorem 6. Suppose the control space U and the observation space Y satisfy Assumption 5 and let

 be the reference measure on the control space U . Consider Algorithm 2 with
rUt (; Yt)
Ut (; Yt )
339

fiBAXTER & BARTLETT

replaced by

r d d;Yt (Ut ) :
(

)

( )

d(;Yt )
Ut
d
Under Assumptions 1, 2 and 6, this algorithm, starting from any initial state
sequence 0 ; 1 ; : : : ; t ; : : : satisfying

 



lim t = rfi 

t!1

X0

will generate a

w.p.1:

Proof. See Appendix B

7. New Results
Since the first version of this paper, we have extended GPOMDP to several new settings, and also
proved some new properties of the algorithm. In this section we briefly outline these results.
7.1 Multiple Agents

Instead of a single agent generating actions according to (; y ), suppose we have multiple agents
i = 1; : : : ; na , each with their own parameter set i and distinct observation of the environment
yi , and that generate their own actions ui according to a policy ui (i ; yi ). If the agents all receive the same reward signal r (Xt ) (they may be cooperating to solve the same task, for example),

then GPOMDP can be applied to the collective POMDP obtained by concatenating
 1 the nobserva
1
na , u
tions, controls, and
parameters
into
single
vectors
y
y
;
:
:
:
;
y
u ; : : : ; u a , and


1 ; : : : ; na respectively. An easy calculation shows that the gradient estimate generated
by GPOMDP in the collective case is precisely the same as that obtained by applying GPOMDP
to

1
each agent independently, and then concatenating the results. That is,
; : : : ; na , where
i is the estimate produced by GPOMDP applied to agent i. This leads to an on-line algorithm
in which the agents adjust their parameters independently and without any explicit communication,
yet collectively the adjustments are maximizing the global average reward. For similar observations in the context of REINFORCE and VAPS, see Peshkin et al. (2000). This algorithm gives a
biologically plausible synaptic weight-update rule when applied to networks of spiking neurons in
which the neurons are regarded as independent agents (Bartlett & Baxter, 1999), and has shown
some promise in a network routing application (Tao, Baxter, & Weaver, 2001).

=

=

=

= 






7.2 Policies with internal states
So far we have only considered purely reactive or memoryless policies in which the chosen control
is a function of only the current observation. GPOMDP is easily extended to cover the case of
policies that depend on finite histories of observations Yt ; Yt 1 ; : : : ; Yt k , but in general, for optimal
control of POMDPs, the policy must be a function of the entire observation history. Fortunately, the
observation history may be summarized in the form of a belief state (the current distribution over
states), which is itself updated based only upon the current observation, and knowledge of which
is sufficient for optimal behaviour (Smallwood & Sondik, 1973; Sondik, 1978). An extension of
GPOMDP to policies with parameterized internal belief states is described by Aberdeen and Baxter
(2001), similar in spirit to the extension of VAPS and REINFORCE described by Meuleau et al.
(1999).
340

fiP OLICY-G RADIENT E STIMATION

7.3 Higher-Order Derivatives
can be generalized to compute estimates of second and higher-order derivatives of the
average reward (assuming they exist), still from a single sample Rpath of the underlying POMDP.
To see this for second-order derivatives, observe that if  
q ; x r x dx for some twicedifferentiable density q ; x and performance measure r x , then

GPOMDP

()= ( )( )
()
Z
r () = r(x) rq(q;(;x)x) q(; x) dx

( )

2

2

where r2 denotes the matrix of second derivatives (Hessian). It can be verified that

r q(; x) = r log q(; x) + [r log q(; x)]
q(; x)
2

2

2

(40)

log ( )

where the second term on the right-hand-side is the outer product between r
q ; x and itself
(that is, the matrix with entries @=@i
q ; x @=@j q ; x ). Taking x to be a sequence of
states X0 ; X1 ; : : : ; XT between visits to a recurrent state i in a parameterized Markov chain (recall
T 1p
Section 1.1.1), we have q ; X
t=0 Xt Xt+1  , which combined with (40) yields

log ( )
log ( )
)=
()

(

r q(; X ) = TX r pXtXt+1 ()
2

q(; X )

1

TX1 

2

pXt Xt+1 ()

t=0

rpXtXt+1 ()  +
p
()
2

Xt Xt+1

t=0

"T 1
X

rpXtXt+1 ()

#2

pXtXt+1 ()

t=0

(the squared terms in this expression are also outer products). From this expression we can derive
a GPOMDP-like algorithm for computing a biased estimate of the Hessian r2   , which involves
maintainingin addition to the usual eligibility trace zt a second matrix trace updated as follows:

()

Zt+1

= fiZt + rp pXtXt+1(())
2



Xt Xt+1

rpXtXt+1 ()  :
p
( )
2

Xt Xt+1

( ) +



After T time steps the algorithm returns the average so far of r Xt Zt zt2 where the second term
is again an outer product. Computation of higher-order derivatives could be used in second-order
gradient methods for optimization of policy parameters.
7.4 Bias and Variance Bounds

()

()

Theorem 3 provides a bound on the bias of rfi   relative to r  that applies when the underlying Markov chain has distinct eigenvalues. We have extended this result to arbitrary Markov chains
(Bartlett & Baxter, 2001). However, the extra generality comes at a price, since the latter bound involves the number of states in the chain, whereas Theorem 3 does not. The same paper also supplies
a proof that the variance of GPOMDP scales as =
fi 2 , providing a formal justification for the
interpretation of fi in terms of bias/variance trade-off.

1 (1

)

8. Conclusion
We have presented a general algorithm (MCG) for computing arbitrarily accurate approximations
to the gradient of the average reward in a parameterized Markov chain. When the chains transition
matrix has distinct eigenvalues, the accuracy of the approximation was shown to be controlled by the
341

fiBAXTER & BARTLETT

size of the subdominant eigenvalue j2 j. We showed how the algorithm could be modified to apply
to partially observable Markov decision processes controlled by parameterized stochastic policies,
with both discrete and continuous control, observation and state spaces (GPOMDP). For the finite
state case, we proved convergence with probability 1 of both algorithms.
We briefly described extensions to multi-agent problems, policies with internal state, estimating
higher-order derivatives, generalizations of the bias result to chains with non-distinct eigenvalues,
and a new variance result. There are many avenues for further research. Continuous time results
should follow as extensions of the results presented here. The MCG and GPOMDP algorithms can
be applied to countably or uncountably infinite state spaces; convergence results are also needed in
these cases.
In the companion paper (Baxter et al., 2001), we present experimental results showing rapid
convergence of the estimates generated by GPOMDP to the true gradient r . We give on-line
variants of the algorithms of the present paper, and also variants of gradient ascent that make use of
the estimates of rfi  . We present experimental results showing the effectiveness of these algorithms
in a variety of problems, including a three-state MDP, a nonlinear physical control problem, and a
call-admission problem.
Acknowledgements
This work was supported by the Australian Research Council, and benefited from the comments of
several anonymous referees. Most of this research was performed while the authors were with the
Research School of Information Sciences and Engineering, Australian National University.

Appendix A. A Simple Example of Policy Degradation in Value-Function Learning
Approximate value-function approaches to reinforcement work by minimizing some form of error
between the approximate value function and the true value function. It has long been known that this
may not necessarily lead to improved policy performance from the new value function. We include
this appendix because it illustrates that this phenomenon can occur in the simplest possible system,
a two-state MDP, and also provides some geometric intuition for why the phenomenon arises.
Consider the two-state Markov decision process (MDP) in Figure 1. There are two controls
u1 ; u2 with corresponding transition probability matrices

P (u1 ) =

1
3
1
3

2

2
3
2
3



; P (u2 ) =

2

3
2
3

23

1
3
1
3



;

so that u1 always takes the system to state with probability = , regardless of the starting state (and
therefore to state with probability = ), and u2 does the opposite. Since state has a reward of ,
while state has a reward of , the optimal policy is to always select action u1 . Under this policy
the stationary distribution on states is 1 ; 2
= ; = , while the infinite-horizon discounted
value of each state i
; with discount value ff 2 ; is

1

1

0

=1 2

13
[

Jff (i) = E

] = [1 3 2 3]
[0 1)

1
X

fft r

fi
fi
Xt fifi X0
fi

( )

=i

2

1

!

;

t=0
where the expectation is over all state sequences X0 ; X1 ; X2 ; : : : with state transitions generated according to P u1 . Solving Bellmans equations: Jff r ffP u1 Jff , where Jff
Jff ; Jff 0
2ff
2ff
and r
r ; r 0 yields Jff
and Jff
.
3(1 ff)
3(1 ff)

( )
= [ (1) (2)]

= + ( )
(2) = 1 +

(1) =

342

= [ (1) (2)]

fiP OLICY-G RADIENT E STIMATION

r(1) = 0

r(2) = 1

1

2

Figure 1: Two-state Markov Decsision Process

~

~( ) =

Now, suppose we are trying to learn an approximate value function J for this MDP, i.e. , J i
w i for each state i ; and some scalar feature  ( must have dimensionality to ensure that
J really is approximate). Here w 2 R is the parameter being learnt. For the greedy policy obtained
from J to be optimal, J must value state above state . For the purposes of this illustration choose

;
, so that for J
> J , w must be negative.
Temporal Difference learning (or
 ) is one of the most popular techniques for training
approximate value functions (Sutton & Barto, 1998). It has been shown that for linear functions,
converges to a parameter w minimizing the expected squared loss under the stationary
distribution (Tsitsikilis & Van-Roy, 1997):

()
=1 2
~
~
2
~(2) ~(1)
(1) = 2 (2) = 1
TD( )
TD(1)
~

w = argmin

w

1

1

2
X

i=1

i [w(i) Jff (i)]2 :

(41)

Substituting the previous expressions for 1 ; 2 ;  and Jff under the optimal policy and solving
3+ff
for w , yields w
. Hence w > for all values of ff 2 ; , which is the wrong
9(1 ff)
sign. So we have a situation where the optimal policy is implementable as a greedy policy based
on an approximate value function in the class (just choose any w < ), yet
observing the
optimal policy will converge to a value function whose corresponding greedy policy implements the
suboptimal policy.
A geometrical illustration of why this occurs is shown in Figure 2. In this figure, points on the
graph
represent
p
p the values of the states. The scales of the state 1 and state 2 axes are weighted by
 and  respectively. In this way, the squared euclidean distance on the graph between
two points J and J corresponds to the expectation under the stationary distribution of the squared
difference between values:

=

0

[0 1)

0

(1)

hp




TD(1)

(2)
~

(1)J (1);

p

(2)J (2)

i

hp

(1)J~(1); (2)J~(2)
p

i2





2

= E J (X ) J~(X )

:

For any value function in the shaded region, the corresponding greedy policy is optimal, since
those value functions rank state 2 above state 1. The bold line represents the set of all realizable
approximate value functions w ; w
. The solution to (41) is then the approximate value
function found by projecting the point corresponding to the true value function Jff ; Jff
onto
this line. This is illustrated in the figure for ff
= . The projection is suboptimal because weighted
mean-squared distance in value-function space does not take account of the policy boundary.

( (1)

(2))
=3 5

[( (1) (2)]

Appendix B. Proof of Theorem 6
The proof needs the following topological lemma. For definitions see, for example, (Dudley, 1989,
pp. 2425).
343

fiBAXTER & BARTLETT

3

2

1

0

1

111111111111111
000000000000000
000000000000000
111111111111111
000000000000000
111111111111111
000000000000000
111111111111111
000000000000000
111111111111111
000000000000000
111111111111111
000000000000000
111111111111111
000000000000000
111111111111111
000000000000000
111111111111111
[J (1), J (2)]
000000000000000
111111111111111
000000000000000
111111111111111
000000000000000
111111111111111
000000000000000
111111111111111
000000000000000
111111111111111
000000000000000
111111111111111
000000000000000
111111111111111
000000000000000
111111111111111
000000000000000
111111111111111
000000000000000
111111111111111
000000000000000
111111111111111
000000000000000
111111111111111
000000000000000
111111111111111
000000000000000
111111111111111
[w * (1), w * (2)]
000000000000000
111111111111111
000000000000000
111111111111111
000000000000000
111111111111111
000000000000000
111111111111111
000000000000000
111111111111111
Legend
000000000000000
111111111111111
000000000000000
111111111111111
000000000000000
111111111111111
000000000000000
111111111111111
Optimal Policy:
000000000000000
111111111111111
000000000000000
111111111111111
000000000000000
111111111111111
Approximate
000000000000000
111111111111111
000000000000000
111111111111111
Value Function:
000000000000000
111111111111111
000000000000000
111111111111111
000000000000000
111111111111111
000000000000000
111111111111111
000000000000000
111111111111111
000000000000000
111111111111111
1

0

1

2

3

11
00
00
11
00
11
00
11

4

5

Figure 2: Plot of value-function space for the two-state system. Note that the scale of each axis has
been weighted by the square root of the stationary probability of the corresponding state
under the optimal policy. The solution found by TD(1) is simply the projection of the true
value function onto the set of approximate value functions.

(

)

Lemma 7. Let X; T be a topological space that is Hausdorff, separable, and first-countable.
Let B be the Borel  -algebra generated by T . Then the measurable space X; B has a sequence
S1; S2 ; : : :  B of sets that satisfies the following conditions:

(

1. Each Si is a partition of X (that is, X
have empty intersection).

2. For all x 2 X , fxg 2 B and

1
\

)

= SfS : S 2 Sig and any two distinct elements of Si

fS 2 Si : x 2 S g = fxg:

i=1

=

Proof. Since X is separable, it has a countable dense subset S
fx1 ; x2 ; : : :g. Since X is firstcountable, each of these xi has aScountable neighbourhood base, Ni . Now, construct the partitions
Si using the countable set N 1
; ; : : :, define
i=1 Ni as follows. Let S0 X and, for i

=

=

=1 2

Si = fS \ Ni : S 2 Si g [ fS \ (X Ni) : S 2 Si g :
1

1

344

fiP OLICY-G RADIENT E STIMATION

Clearly, each Si is a measurable partition of X . Since X is Hausdorff, for each pair x; x0 of distinct
points from X , there is a pair of disjoint open sets A and A0 such that x 2 A and x0 2 A0 . Since S
is dense, there is a pair s; s0 from S with s 2 A and s0 2 A0 . Also, N contains neighbourhoods Ns
and Ns0 with Ns  A and Ns0  A0 . So Ns and Ns0 are disjoint. Thus, for sufficiently large i, x
and x0 fall in distinct elements of the partition Si . Since this is true for any pair x; x0 , it follows that

1
\

fS 2 Si : x 2 S g  fxg:

i=1

The reverse inclusion
is trivial. The measurability of all singletons fxg follows from the measuraS
bility of Sx
i fS 2 Si S \ fxg g and the fact that fxg X Sx .

:=

:

=

=

We shall use Lemma 7 together with the following result to show that we can approximate
expectations of certain random variables using a single sample path of the Markov chain.

(

)

Lemma 8. Let X; B be a measurable space satisfying the conditions of Lemma 7, and let S1 ; S2 ; : : :
be a suitable sequence of partitions as in that lemma. Let  be a probability measure defined on this
space. Let f be an absolutely integrable function on X . For an event S , define

f (S ) =
For each x 2 X and
almost all x in X ,

k

R

S f d :

(S )

= 1; 2; : : :, let Sk (x) be the unique element of Sk containing x. Then for
lim f (Sk (x)) = f (x):
k!1

Proof. Clearly, the signed finite measure  defined by

(E ) =

Z

E

fd

is absolutely continuous with respect to , and Equation (42) defines
derivative of  with respect to . This derivative can also be defined as

(42)

f

as the Radon-Nikodym

(Sk (x))
d
(x) = klim
:
!1 (Sk (x))
d

See, for example, (Shilov & Gurevich, 1966, Section 10.2). By the Radon-Nikodym Theorem (Dudley, 1989, Theorem 5.5.4, p. 134), these two expressions are equal a.e. ().
Proof. (Theorem 6.) From the definitions,

rfi  = 0 rP Jfi

=

n X
n
X
i=1 j =1

(i)rpij ()Jfi (j ):

(43)

For every y ,  is absolutely continuous with respect to the reference measure , hence for any i and
j we can write
Z Z
d(; y)
pij () =
pij (u)
(u) d(u) d (i)(y):
d
Y U
345

fiBAXTER & BARTLETT

Since  and  do not depend on
under the integral to obtain

rpij () =

 and d(; y)=d is absolutely integrable,

Z Z

Y U

pij (u) r

d(; y)
(u) d(u) d (i)(y):
d

To avoid cluttering the notation, we shall use  to denote the distribution
denote the distribution  i on Y . With this notation, we have

()

rpij () =

we can differentiate

Z Z

Y U

pij

(; y) on U , and 

to

r d
d d d:
d
d

Now, let  be the probability measure on Y  U generated by  and  . We can write (43) as

rfi  =

X

i;j

(i)Jfi (j )

Z

YU

pij

r d
d d:
d
d

Using the notation of Lemma 8, we define

pij (S ) =

R

S pij d ;

(S )

Z
d
1
r(S ) = (S ) rdd d;
S d

for a measurable set S

 Y  U . Notice that, for a given i, j , and S ,
pij (S ) = Pr(Xt+1 = j jXt = i; (y; u) 2 S )
fi

!

d fi
r
r(S ) = E dd fififi Xt = i; (Yt ; Ut ) 2 S :
d

Let S1 ; S2 ; : : : be a sequence of partitions of Y  U as in Lemma 7, and let Sk
element of Sk containing y; u . Using Lemma 8, we have

( )

Z

YU

pij

Z
r d
d d =

d
d

lim pij (Sk (y; u)) r (Sk (y; u)) d(y; u)

YU k!1

= klim
!1

(y; u) denote the

X Z

S 2Sk

S

pij (S ) r(S ) d;

346

fiP OLICY-G RADIENT E STIMATION

where we have used Assumption 6 and the Lebesgue dominated convergence theorem to interchange
the integral and the limit. Hence,

rfi  = klim
!1

= klim
!1

X X

i;j S 2Sk

X

i;j;S

(i)(S )pij (S )Jfi (j )r(S )

Pr(Xt = i)Pr((Yt ; Ut ) 2 S )Pr(Xt = j jXt = i; (Yt ; Ut ) 2 S )
+1

fi

E (J (t + 1)jXt

+1

= klim
!1

X

i;j;S

"

d fi
r
= j ) E dd fififi Xt = i; (Yt; Ut ) 2 S
d

!

#

d
E i(Xt )S (Yt; Ut )j (Xt )J (t + 1) rdd ;
+1

d

where probabilities and expectations are with respect to the stationary distribution  of Xt , and the
distributions on Yt ; Ut . Now, the random process inside the expectation is asymptotically stationary
and ergodic. From the ergodic theorem, we have (almost surely)
d
X TX
r
1
rfi  = klim
lim
i (Xt )S (Yt ; Ut )j (Xt )J (t + 1) dd :
!1 T !1 T
1

+1

i;j;S t=0

d

It is easy to see that the double limit also exists when the order is reversed, so
TX
d
X
r
1
rfi  = Tlim
lim i(Xt )S (Yt ; Ut )j (Xt )J (t + 1) dd
!1 T
k!1
1

1
= Tlim
!1 T

t=0
TX1
t=0

+1

i;j;S
d
(;Yt )
r d Ut
d(;Yt ) U
t
d

( ) J (t + 1):
( )

The same argument as in the proof of Theorem 4 shows that the tails of
when
fi
fi
fi r d(;Yt ) U fi
t fi
fi
d
fi
fi d(;Y
t)
fi
fi
U
t
d

d

J (t + 1) can be ignored

( )
( )
and jr (Xt )j are uniformly bounded. It follows that T !  0 rP Jfi w.p.1, as required.
References
Aberdeen, D., & Baxter, J. (2001). Policy-gradient learning of controllers with internal state. Tech.
rep., Australian National University.
Aleksandrov, V. M., Sysoyev, V. I., & Shemeneva, V. V. (1968). Stochastic optimaization. Engineering Cybernetics, 5, 1116.
Baird, L., & Moore, A. (1999). Gradient descent for general reinforcement learning. In Advances
in Neural Information Processing Systems 11. MIT Press.
347

fiBAXTER & BARTLETT

Bartlett, P. L., & Baxter, J. (1999). Hebbian synaptic modifications in spiking neurons that learn.
Tech. rep., Research School of Information Sciences and Engineering, Australian National
University. http://csl.anu.edu.au/bartlett/papers/BartlettBaxter-Nov99.ps.gz.
Bartlett, P. L., & Baxter, J. (2001). Estimation and approximation bounds for gradient-based reinforcement learning. Journal of Computer and Systems Sciences, 62. Invited Paper: Special
Issue on COLT 2000.
Barto, A. G., Sutton, R. S., & Anderson, C. W. (1983). Neuronlike adaptive elements that can solve
difficult learning control problems. IEEE Transactions on Systems, Man, and Cybernetics,
SMC-13, 834846.
Baxter, J., Bartlett, P. L., & Weaver, L. (2001). Experiments with infinite-horizon, policy-gradient
estimation. Journal of Artificial Intelligence Research. To appear.
Baxter, J., Tridgell, A., & Weaver, L. (2000). Learning to play chess using temporal-differences.
Machine Learning, 40(3), 243263.
Bertsekas, D. P., & Tsitsiklis, J. N. (1996). Neuro-Dynamic Programming. Athena Scientific.
Bertsekas, D. P. (1995). Dynamic Programming and Optimal Control, Vol II. Athena Scientific.
Breiman, L. (1966). Probability. Addison-Wesley.
Cao, X.-R., & Wan, Y.-W. (1998). Algorithms for Sensitivity Analysis of Markov Chains Through
Potentials and Perturbation Realization. IEEE Transactions on Control Systems Technology,
6, 482492.
Dudley, R. M. (1989). Real Analysis and Probability. Wadsworth & Brooks/Cole, Belmont, California.
Glynn, P. W. (1986). Stochastic approximation for monte-carlo optimization. In Proceedings of the
1986 Winter Simulation Conference, pp. 356365.
Glynn, P. W. (1990). Likelihood ratio gradient estimation for stochastic systems. Communications
of the ACM, 33, 7584.
Glynn, P. W., & LEcuyer, P. (1995). Likelihood ratio gradient estimation for regenerative stochastic
recursions. Advances in Applied Probability, 27, 4 (1995), 27, 10191053.
Ho, Y.-C., & Cao, X.-R. (1991). Perturbation Analysis of Discrete Event Dynamic Systems. Kluwer
Academic, Boston.
Jaakkola, T., Singh, S. P., & Jordan, M. I. (1995). Reinforcement Learning Algorithm for Partially
Observable Markov Decision Problems. In Tesauro, G., Touretzky, D., & Leen, T. (Eds.),
Advances in Neural Information Processing Systems, Vol. 7. MIT Press, Cambridge, MA.
Kimura, H., & Kobayashi, S. (1998a). An analysis of actor/critic algorithms using eligibility traces:
Reinforcement learning with imperfect value functions. In Fifteenth International Conference
on Machine Learning, pp. 278286.
348

fiP OLICY-G RADIENT E STIMATION

Kimura, H., & Kobayashi, S. (1998b). Reinforcement learning for continuous action using stochastic gradient ascent. In Intelligent Autonomous Systems (IAS-5), pp. 288295.
Kimura, H., Miyazaki, K., & Kobayashi, S. (1997). Reinforcement learning in POMDPs with
function approximation. In Fisher, D. H. (Ed.), Proceedings of the Fourteenth International
Conference on Machine Learning (ICML97), pp. 152160.
Kimura, H., Yamamura, M., & Kobayashi, S. (1995). Reinforcement learning by stochastic hill
climbing on discounted reward. In Proceedings of the Twelfth International Conference on
Machine Learning (ICML95), pp. 295303.
Konda, V. R., & Tsitsiklis, J. N. (2000). Actor-Critic Algorithms. In Neural Information Processing
Systems 1999. MIT Press.
Lancaster, P., & Tismenetsky, M. (1985). The Theory of Matrices. Academic Press, San Diego, CA.
Marbach, P., & Tsitsiklis, J. N. (1998). Simulation-Based Optimization of Markov Reward Processes. Tech. rep., MIT.
Meuleau, N., Peshkin, L., Kaelbling, L. P., & Kim, K.-E. (2000). Off-policy policy search. Tech.
rep., MIT Artificical Intelligence Laboratory.
Meuleau, N., Peshkin, L., Kim, K.-E., & Kaelbling, L. P. (1999). Learning finite-state controllers for
partially observable environments. In Proceedings of the Fifteenth International Conference
on Uncertainty in Artificial Intelligence.
Peshkin, L., Kim, K.-E., Meuleau, N., & Kaelbling, L. P. (2000). Learning to cooperate via policy
search. In Proceedings of the Sixteenth International Conference on Uncertainty in Artificial
Intelligence.
Reiman, M. I., & Weiss, A. (1986). Sensitivity analysis via likelihood ratios. In Proceedings of the
1986 Winter Simulation Conference.
Reiman, M. I., & Weiss, A. (1989). Sensitivity analysis for simulations via likelihood ratios. Operations Research, 37.
Rubinstein, R. Y. (1969). Some Problems in Monte Carlo Optimization. Ph.D. thesis.
Rubinstein, R. Y. (1991). How to optimize complex stochastic systems from a single sample path
by the score function method. Annals of Operations Research, 27, 175211.
Rubinstein, R. Y. (1992). Decomposable score function estimators for sensitivity analysis and optimization of queueing networks. Annals of Operations Research, 39, 195229.
Rubinstein, R. Y., & Melamed, B. (1998). Modern Simulation and Modeling. Wiley, New York.
Rubinstein, R. Y., & Shapiro, A. (1993). Discrete Event Systems. Wiley, New York.
Samuel, A. L. (1959). Some Studies in Machine Learning Using the Game of Checkers. IBM
Journal of Research and Development, 3, 210229.
349

fiBAXTER & BARTLETT

Shilov, G. E., & Gurevich, B. L. (1966). Integral, Measure and Derivative: A Unified Approach.
Prentice-Hall, Englewood Cliffs, N.J.
Singh, S. P., Jaakkola, T., & Jordan, M. I. (1994). Learning Without State-Estimation in Partially
Observable Markovian Decision Processes. In Proceedings of the Eleventh International
Conference on Machine Learning.
Singh, S., & Bertsekas, D. (1997). Reinforcement learning for dynamic channel allocation in cellular telephone systems. In Advances in Neural Information Processing Systems: Proceedings
of the 1996 Conference, pp. 974980. MIT Press.
Smallwood, R. D., & Sondik, E. J. (1973). The optimal control of partially observable Markov
decision processes over a finite horizon. Operations Research, 21, 10711098.
Sondik, E. J. (1978). The optimal control of partially observable Markov decision processes over
the infinite horizon: Discounted costs. Operations Research, 26.
Sutton, R. S., & Barto, A. G. (1998). Reinforcement Learning: An Introduction. MIT Press,
Cambridge MA. ISBN 0-262-19398-1.
Sutton, R. S., McAllester, D., Singh, S., & Mansour, Y. (2000). Policy Gradient Methods for
Reinforcement Learning with Function Approximation. In Neural Information Processing
Systems 1999. MIT Press.
Tao, N., Baxter, J., & Weaver, L. (2001). A multi-agent, policy-gradient approach to network
routing. Tech. rep., Australian National University.
Tesauro, G. (1992). Practical Issues in Temporal Difference Learning. Machine Learning, 8, 257
278.
Tesauro, G. (1994). TD-Gammon, a self-teaching backgammon program, achieves master-level
play. Neural Computation, 6, 215219.
Tsitsikilis, J. N., & Van-Roy, B. (1997). An Analysis of Temporal Difference Learning with Function Approximation. IEEE Transactions on Automatic Control, 42(5), 674690.
Williams, R. J. (1992). Simple Statistical Gradient-Following Algorithms for Connectionist Reinforcement Learning. Machine Learning, 8, 229256.
Zhang, W., & Dietterich, T. (1995). A reinforcement learning approach to job-shop scheduling. In
Proceedings of the Fourteenth International Joint Conference on Artificial Intelligence, pp.
11141120. Morgan Kaufmann.

350

fi