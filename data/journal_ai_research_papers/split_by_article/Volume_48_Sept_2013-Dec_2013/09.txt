Journal of Artificial Intelligence Research 48 (2013) 415473

Submitted 05/13; published 11/13

Defeasible Inheritance-Based Description Logics
Giovanni Casini

GCasini@csir.co.za

Centre for Artificial Intelligence Research (CAIR)
CSIR Meraka Institute and UKZN, South Africa

Umberto Straccia

umberto.straccia@isti.cnr.it

Istituto di Scienze e Tecnologie dellInformazione (ISTI)
CNR, Italy

Abstract
Defeasible inheritance networks are a non-monotonic framework that deals with hierarchical knowledge. On the other hand, rational closure is acknowledged as a landmark of the
preferential approach to non-monotonic reasoning. We will combine these two approaches
and dene a new non-monotonic closure operation for propositional knowledge bases that
combines the advantages of both. Then we redene such a procedure for Description Logics
(DLs), a family of logics well-suited to model structured information. In both cases we will
provide a simple reasoning method that is built on top of the classical entailment relation
and, thus, is amenable of an implementation based on existing reasoners. Eventually, we
evaluate our approach on well-known landmark test examples.

1. Introduction
The notion of rational closure (Lehmann & Magidor, 1992) is acknowledged as a landmark
for non-monotonic reasoning due to its rm logical properties, but it has limited inference
capabilities: e.g. an exceptional class will not inherit any of the typical properties from its
superclass. Consider penguins: they are atypical birds, since they do not y, but they still
share a lot of typical properties of birds, e.g. they have wings. However, under rational
closure we may not infer that penguins have wings. On the other hand, Defeasible Inheritance Networks (INs) (Horty, 1994) are a non-monotonic framework appropriate for the
formalisation of hierarchical knowledge that does not have such a limitation, but exhibit
questionable logical properties (see Section 3.1).
We combine these two approaches and dene a new non-monotonic closure operation
for propositional knowledge bases that combines the advantages of both, and then we apply
the method to Description Logics (DLs) (Baader, Calvanese, McGuinness, Nardi, & PatelSchneider, 2003), a family of logics that are known to be well-suited to model structured
information.
1.1 Contributions and Roadmap
Section 2.1 is just a brief recap of a classical approach to inheritance nets, Hortys (1994)
skeptical extension, while Section 2.2 describes the classical rational closure for propositional
logic, generalising a method presented by Freund (1998). The remaining material addresses
our contributions that can be summarised as follows.
c
2013
AI Access Foundation. All rights reserved.

fiCasini & Straccia

1. In Section 3 we propose a new method to reason about INs that relies on the procedure for rational closure, and we present a Boolean extension of INs, called Boolean
defeasible Inheritance Networks (BINs).
2. Using BINs, we develop in Section 4 a defeasible inheritance-based propositional closure
that combines the advantages of both inheritance nets and rational closure.
3. Eventually, in Section 5 we apply the latter procedure to the case of defeasible inheritancebased description logics.
A major feature of the procedures we propose is that for propositional logic and DLs
we still maintain all desired logical properties of rational closure, but with more inferential
power with respect to exceptional classes. Moreover our method requires only the existence
of a decision procedure for classical entailment and, thus, can be implemented on top of
existing propositional SAT solvers and DL reasoners.
Please note that the present paper is a substantially revised and extended version of a
previous work (Casini & Straccia, 2011). Specically,
1. we provide an in-depth description of our reasoning model;
2. we extensively validate our approach w.r.t. to a series of landmark (test) examples
illustrated by Horty (1994) and Sandewall (2010) (see Appendix A);
3. we provide computational complexity results related to our reasoning procedures; and
4. we include the proofs supporting out major claims (see Appendix B); due to the
complexity of the notation, we add also a table summarising the meaning of the
symbols we use more frequently (Appendix C).
1.2 Related Work
We refer to two main approaches to non-monotonic reasoning: inheritance networks on one
hand and the preferential approach on the other.
Inheritance networks have been developed as a formalism for reasoning about taxonomic
information. From the original ideas of Touretzky (1986), the approach has richly developed
(Sandewall, 1986; Touretzky, Horty, & Thomason, 1987; Horty, Thomason, & Touretzky,
1987; Touretzky, Thomason, & Horty, 1991; Makinson, 1991; Simonet, 1996). See the works
by Horty (1994) and Thomason (1992) for an overview, while Gabbay and Schlecta (2009)
and Sandewall (2010) have more recently contributed to the eld. In particular, in order
to evaluate our proposal, we shall refer to the skeptical approach described by Horty (1987,
1994) as the landmark of the classical approach to inheritance networks.
On the other hand, Lehmann and Magidors rational closure falls into the preferential
approach to non-monotonic reasoning; such an approach, since the rst formulation by
Shoham (1988), has become a main representative of non-monotonic reasoning (Kraus,
Lehmann, & Magidor, 1990; Lehmann & Magidor, 1992; Makinson, 1994, 2005; Freund,
1998; Bochman, 2001; Rott, 2001; Schlechta, 2004), particularly appreciated for the solid
logical characterization of the consequence relation.
Eventually, our proposal shall be applied in the eld of description logics (Baader et al.,
2003). Several non-monotonic DLs exist (Baader & Hollunder, 1993; Bonatti, Faella, &
416

fiDefeasible Inheritance-Based Description Logics

Sauro, 2011c, 2011b; Brewka & Augustin, 1987; Britz, Heidema, & Meyer, 2008; Donini,
Nardi, & Rosati, 2002; Giordano, Olivetti, Gliozzi, & Pozzato, 2009; Giordano, Gliozzi,
Olivetti, & Pozzato, 2012b; Grimm & Hitzler, 2009; Knorr, Alferes, & Hitzler, 2011; Quantz
& Royer, 1992; Straccia, 1993), which integrate several kinds of non-monotonic reasoning
mechanism into DLs. Somewhat related to our proposal are the works by Britz et al. (2008)
and Giordano et al. (2009, 2012b), as they address the application of the preferential methods into the DL framework, but they do not refer to rational closure. In a previous publication (Casini & Straccia, 2010) we present a procedure to apply rational closure to DLs, and
such a procedure is at the basis of our actual proposal, but here we modify the approach in
order to amplify its inferential power.

2. Preliminaries
For completeness, we start with the basic notions about INs and propositional rational
closure we shall rely on.
2.1 Defeasible Inheritance Networks
In INs (Horty, 1994; Sandewall, 2010) there are classes (nodes), a strict subsumption relation
and a defeasible subsumption relation among such classes (links). We shall indicate nodes
by letters p, q . . ., and we shall describe an IN by a pair N = hS, U i, where S is a set of
strict links, while U is a set of defeasible links. Every link in N is a direct link, and it can
be strict or defeasible, positive or negative. Specically,
1. p  q: class p is subsumed by class q [positive strict link];
2. p 6 q: class p and class q are disjoint [negative strict link];
3. p  q: an element of the class p is usually an element of the class q [positive defeasible
link];
4. p 6 q: an element of the class p is usually not an element of the class q [negative
defeasible link].
Example 2.1. The typical penguin example could be represented as N = h{p  b}, {p 6
f, b  f, b  w}i, reading b as Bird, p as Penguin, f as Flying and w as has Wings.
In the presence of strict links only, the subsumption relation between the classes would
correspond simply to a transitive closure of the links: if p is subsumed by q and q is
subsumed by r, then p is subsumed by r. Instead, the presence of defeasible links implies
the possibility of potential inconsistencies in the hierarchy of classes, as in the penguin
example: a transitive closure of the subsumption relation would force us to conclude at
the same time that penguins are ying and non-ying creatures. Hence reasoning with
inheritance networks consists mainly in deciding which conclusions have to be considered
valid when faced with potential contradictions. In most of the classical approaches such
decisions are based on the notions of potential path and preemption (a procedure that,
given two conicting paths, allows to choose the one resting on more specic information,
invalidating the other). Among the various proposals, we shall briey present Hortys (1994)
417

fiCasini & Straccia

classical approach, to which we shall refer as a landmark. First, we recall the notion of path
that is shared by all the classical approaches to INs. We refer to the paths by means of
Greek letters (, , , ,  . . .), or with tuples indicating the sequence of the nodes involved.
For example, the triple  = hp, , qi indicates a path  that starts from the node p, passes
through the path , and ends into the node q.
Definition 2.1 (Potential Paths, Horty, 1994, p. 117). Given a net N = hS, U i, we can
define iteratively its paths (where 99K {, } and 699K {6, 6})1 :
 Every direct link in N is a simple path:
 If p 99K q  S, hp, qi is a positive path.
 If p 699K q  S, hp, qi is a negative path.
 Assume a path  = ht, , pi.
 If  is positive,
 If p 99K q  S, h, qi is a positive path.
 If p 699K q  S, h, qi is a negative path.
 If  is negative,
 If q  p  S, h, qi is a negative path.
If a path is composed only by strict links, it is a strict path, otherwise it is a defeasible
one.
A potential path represents a potential argumentation, and we have to decide if it is
valid or not. If the path is strict, it is automatically considered as valid, otherwise, in case
of potential conicts between the conclusions of distinct defeasible paths, we have to choose
which ones of them have to be considered as valid.
Using the notions of path and preemption, Horty denes an iterative construction of
an extension of a net, that is, of the set of the paths considered valid in the net. Due to
the complexity of the formal denition, we describe just roughly the procedure, referring to
Hortys work (1994, sect. 3), for a better insight.
The inductive construction of the paths is based on a notion of degree of paths. Once
we have identied the potential paths, we can dene also a notion of generalised path. That
is, a generalisation of defeasible paths that, given   {, 6, , , 6}, is dened as:
1. every direct link is a generalised path;
2. if  = h, pi is a generalised path, and p  q  N , then h, qi is a generalised path.
We associate to every defeasible path hp, , qi a number that corresponds to the number
of links in the longest generalised path between p and q, denoted as degN (hp, , qi).
In inheritance nets, the notion of contradiction corresponds to the notion of conflict:
we say that a path is conicted if there is another path with the same starting and end
points, but opposite polarity (i.e., we have two potential paths moving from a node p to a
1. We assume the link 6 to be symmetric, that is, if p 6 q  S, then q 6 p  S too.

418

fiDefeasible Inheritance-Based Description Logics

node q, but one is positive while the other is negative). If we are dealing with strict paths,
the presence of a conict points out an actual contradiction, while, dealing with defeasible
paths, the contradiction is just potential and could be resolved by the notion of preemption
(Horty, 1994, Def. 3.2.2) that allows to prefer the path relying on more specic information.
In the procedure dened by Horty we start with a net N , and, working iteratively on the
degree of the paths, we dene a sequence of pairs hN , Pi i, where Pi is the set of the paths
considered valid at the i-th step. In brief, given a net N = hS, U i, Hortys procedure results
into the construction of a sequence of sets of valid paths P0 , P1 , P2 , . . . where:
1. P0 = N ; and
2. Pn+1 is Pn united with all the paths of degree n + 1 and that are the extension of a
valid path of degree n and that preempt all the eventual conicting paths.
S
The skeptical extension of a net N is dened by 
n=1 Pn (Horty, 1994, sect. 2.2.2 and
3.3.2). To indicate that a (positive or negative, strict or defeasible) connection between two
nodes p and q is considered valid in Hortys skeptical extension we write N
p  q, with
  {, 6, , 6}.
Example 2.2. Consider example 2.1; following Hortys procedure we obtain a skeptical
extension of the net composed of the valid paths p  b, p 6 f, b  f, b  w, p  b  w.
Consistency. A net is considered inconsistent i we can validate two conicting paths,
that is, there is a pair of nodes p and q such that we can derive both a positive connection
(N
p  q or N
p  q) and a negative one (N
p 6 q or N
p 6 q) between
them.
2.2 Propositional Rational Closure
Non-monotonic systems can be analysed from the point of view of the properties of the consequence relations they dene (Makinson, 1994). From such a perspective INs do not satisfy
some desirable logical properties, presented below, such as (CM) and (CT) (Makinson, 1994,
pp. 56-57).
Even if the satisfaction of the structural properties we are going to present is not unanimously considered as a necessary condition for a formalization of defeasible reasoning,
since most of the interesting nonmonotonic logics do not satisfy some of them, we still consider their satisfaction as a desiderata: such properties are intuitive and give back a strong
logical characterization of the consequence relation, they have a solid semantic characterization based on preferential interpretation (Kraus et al., 1990; Lehmann & Magidor, 1992),
and have strong connections to the classic AGM approach to belief revision (Alchourron,
Gardenfors, & Makinson, 1985). Moreover the decision problem can be often reduced to
a procedure based on the classical decision problem (as in the proposal we are going to
present) allowing to implement the procedure on top of existing reasoners, and the systems
based on the preferential approach rarely give back counter-intuitive results. The main
problems are that the inferential power of such approaches is often too weak (we can often
point out conclusions that we would like to obtain, but that the system is not able to derive), and that the preferential approach has been developed for propositional logics, and
the attempts to extend it to rst-order languages have turned out to be quite problematic.
419

fiCasini & Straccia

The proposal we are going to present tries to overcome such inferential weaknesses, characteristic of the classical preferential approaches. After presenting it for the propositional
languages, we readapt the procedure to the expressivity of DLs since, even if the preferential approach cannot be easily reformulated for rst-order logics, it turns out to be still
appropriate for fragments of rst-order logic as DLs.
In what follows, we shall present a procedure for building the rational closure of a
knowledge base using the default-assumption approach (Poole, 1988; Makinson, 2005); such
an approach reduces the construction of the rational closure into a series of checks based on
the classical consequence relations. The procedure we are presenting heavily relies on the
one by Freund (1998).
Specically, consider a classical propositional language built on a nite set of propositional letters P = {p1 , . . . , pn }, using the classical connectives , , , , ; sentences will
be denoted by capital letters C, D, E . . ., while sets of sentences by capital Greek letters
, , . . ., and  and  will have the usual meaning of true and false; in the knowledge
bases, we shall indicate consequential information by means of C  D and C|D, respectively strict and defeasible conditionals, that have to be read respectively as If C, then
always D and If C, then typically D.  denotes the classical entailment relation, and,
given a set of formulae  or a set of strict conditionals T , we indicate by  and T the
monotonic entailment relations obtained adding to , respectively, the set of propositional
formulae  or the set of conditionals {C |= D | C  D  T } as extra information; we shall
use | also to indicate a generic non-monotonic consequence relation.
The knowledge base (KB) of an agent can be represented by means of conditionals or
by means of formulae; we call conditional knowledge base a pair hT , Di, where T is a nite
set of strict conditionals and D is a nite set of defeasible conditionals.
Example 2.3. The penguin example can be encoded as: K = hT , Di with T = {p  b} and
D = {p|f, b|f, b|w}.
Another way to formalize defeasible information may be based simply on formulae, using
the default-assumption approach: a default-assumption knowledge base is a pair h, i,
where  and  are sets of formulae representing respectively what the agent considers as
necessarily true and as typically true.
Example 2.4. The penguin example could be encoded as: K = h, i with  = {p  b}
and  = {b  f, p  f, b  w}.
We shall use the Greek letter  to distinguish default-assumption formulae (i.e., the
members of ). We next show how to map a conditional knowledge base into a defaultassumption knowledge base (we will transform KBs of the kind of the one in Example 2.3
into KBs of the kind in Example 2.4), and then we show a simple procedure to reason within
the latter, by relying only on a decision procedure for |=.
We proceed as follows: (i) we dene the notions of rational consequence relation and
rational closure, (ii) then, we describe a procedure to build a rational closure using a
default-assumption knowledge base.
420

fiDefeasible Inheritance-Based Description Logics

A consequence relation | is rational i it satises the following properties (Lehmann &
Magidor, 1992):
(REF)
(CT)

(CM)

(LLE)

(RW)

C|C for every C
C|D

Reexivity

C  D|F
C|F

C|D
C|F
C  D|F
C|F

C|D

Cautious Monotony

|= C  D
D|F

D |= F
C|F

Cut (Cumulative Transitivity)

Left Logical Equivalence

Right Weakening

(OR)

C|F
D|F
C  D|F

Left Disjunction

(RM)

C|F
C6|D
C  D|F

Rational Monotony

The rst six properties, (REF)(OR), characterise the class of the preferential consequence relations: that is, given a conditional base
D = {C1 |E1 , . . . , Cn |En } ,
we say that a conditional C|D is in the preferential closure P(D) i it is derivable from
D using the rules (REF)(OR) (Kraus et al., 1990). However, the preferential closure is
generally considered inferentially too weak to be satisfactory, and so it is natural to look
for stronger forms of closure.
The closure under the rule (RM) is considered, between the interesting rules, the
strongest one. However, given the form of such a rule (we have a negated conditional
between the premises), the rational extension of a conditional base D is not unique. Indeed,
we have multiple possibilities to close D under such a condition: for example, if we have
D = {C|F }, then neither C  D|F nor C|D are in D and we can choose to add to
D either of them in order to satisfy (RM); moreover, as this simple example shows, it is
possible that the consequence relation obtained from the intersection of dierent rational
extensions of a knowledge base does not satisfy (RM) anymore (in this particular case, the
intersection would not contain neither C  D|F nor C|D). Hence, to dene a rational
closure for a conditional base D, we have to choose one between the possible rational extensions of D. Lehmann and Magidor have dened a rational closure operation R that satises
a set of desiderata (Lehmann & Magidor, 1992, sect. 5.1-5.3).
1. P(D)  R(D). That is, the conditional base D and every conditional preferentially
derivable from it should be in the rational closure of D.
2. For every conditional of form C|, C|  R(D) i C|  P(D). Analogously, for
every conditional of form |C, |C  R(D) i |C  P(D). The conditionals of
421

fiCasini & Straccia

form C| dene what situations are simply considered impossible, while the conditionals of form |C indicate what is considered typical in general. Both such kinds
of information are properly managed by the preferential closure.
3. If we have that C|F  P(D), C|D, C D|F 
/ P(D), we prefer a closure operation
adding C  D|F instead of C|D: the sense of a rule as (RM) is to employ a constrained form of monotonicity (given C|F , we add C  D|F ), not to arbitrarily add
new defaults (the addition of C|D); hence, whenever possible, given a conditional
C|F we want to consider its strengthening C  D|F instead of the unmotivated
addition of a conditional C|D.
We shall not describe Lehmann and Magidors rational closure by referring to the original
formulation (Lehmann & Magidor, 1992). Instead, we shall directly refer to a correspondent
construction, heavily relying on the procedure dened by Freund (1998), and based on the
translation of a conditional KB into a default-assumption KB, which we illustrate next.
We start with a conditional KB K = hT , Di. The rst steps (Steps 1-3) are to dene
an exceptionality ranking for all the conditionals in the KB, following the analogous procedure by Lehmann and Magidor (1992): such a ranking will permit to distinguish correctly
the strict and the defeasible knowledge contained in the KB (Step 4), since part of the
strict knowledge could be implicitly contained in D. This will allow us to construct the
correspondent default-assumption KB (Steps 5-6). Specically:
Step 1. We translate the strict knowledge into defeasible conditionals, that is, we move
from a KB hT , Di to h, D  i, where
D  = D  {C  D| | C  D  T } .
Intuitively, in the preferential setting, saying that C  D is valid is equivalent to
saying that its negation is an absurdity ((C  D)|) (Bochman, 2001, sect. 6.5).
Step 2. We dene D  as the set of the materialisations of the conditionals in D  , i.e., the
material implications corresponding to such conditionals:
D  = {C  D | C|D  D  } .
Also, we indicate by AD the set of the antecedents of the conditionals in D  :
AD = {C | C|D  D  } .
Step 3. We dene an exceptionality ranking of the conditionals in D  (Lehmann & Magidor, 1992, sect. 2.6). We build such a ranking on the following notion of exceptionality.
Given a set of conditionals D, a formula C is exceptional for D i D preferentially
entails |C (i.e., |C  P(D)); recall that a conditional |C  R(D) i |C 
P(D).
A conditional C|D is said to be exceptional for D i its antecedent C is exceptional for D. The exceptionality of a proposition can be decided based on |= only
(Lehmann & Magidor, 1992, Corol. 5.22), as C is exceptional for a set of conditionals
422

fiDefeasible Inheritance-Based Description Logics

D (i.e., |C  P(D)) i D |= C, where D is the set of the materialisations of the
conditionals in D.
Let E(AD ) indicate the set of the antecedents that result exceptional w.r.t. D, that is
E(AD ) = {C  AD | D |= C} ,
and with E(D) the exceptional conditionals in D, i.e.,
E(D) = {C|D  D | C  E(AD )} .
Obviously, for every D, E(D)  D.
Step 3.1. Taking under consideration the knowledge base h, D  i, we can construct
iteratively a sequence E0 , E1 . . . of subsets of the conditional base D  in the following way:
E0 = D 
Ei+1 = E(Ei ) .
Since D  is a nite set, the construction will terminate with an (empty or nonempty) xed point of E, i.e., a set composed only of exceptional conditionals,
which materialisations negate all their own antecedents.
Step 3.2. Using such a sequence, we dene a ranking function r that associates to
every conditional in D  a number, representing its own level of exceptionality:
r(C|D) =



i
if C|D  Ei and C|D 
/ Ei+1
 if C|D  Ei for every i .

Step 4. In Step 3 we have dened the materialisation of D  and the rank of every conditional in it. Now,
Step 4.1. we can determine if D  is inconsistent. A conditional base D is inconsistent if from it we can derive the conditional |. We know from above that a
conditional of the form |C is in the rational closure of D i it is in its preferential closure, that is, given the result recalled in Step 3.1, we can check the
consistency of D  using D  : |  P(D  ) i D  |= ;
Step 4.2. if D  is consistent, we dene the background theory Te of the agent as2
Te = {  C | C|D  D  and r(C|D) = } .

Moreover, one may verify that for every conditional in T there is a logically
equivalent conditional in Te ;

2. One may easily verify the correctness of this definition referring to results in the work of Bochman
(2001, sect. 7.5.3, Definition 7.5.1, the definition of clash on p.178, Corollary 7.5.7, Definition 7.5.2, and
Lemma 7.5.5). It suffices to show that the set of the conditionals with  as ranking value represents
the greatest clash of D (the proof is quite immediate by the definition of the exceptionality ranking).

423

fiCasini & Straccia

e i.e., the
Step 4.3. once we have Te , we can also identify the set of conditionals D,

defeasible part of the information contained in D : i.e.,
e = {C|D  D  | r(C|D) < } (obviously, D
e  D) .
D

Essentially, so far we have moved into T the non-defeasible knowledge hidden in D,
e Moreover, we have the ranking values of all
obtaining a new conditional base hTe , Di.
e
the conditionals in D.

Step 5. Now we build the default-assumption characterization of the rational closure of
e To do so, we translate Te into a set of correspondent formulae ,
e i.e.,
hTe , Di.
e = {C |   C  Te } ,


e into a sequence of default-assumptions (i.e., formulae) .
e Specically, given
and D
e
the rank value of the conditionals in D, we construct a sequence of default assumptions
e = h0 , . . . , n i ,


e and
where n is the highest rank-value in D,
^
e and r(C|D)  i} .
i = {C  D | C|D  D

(1)

Dening the default-assumptions in this way, as presented by Freund (1998), we obtain
a set of default formulae, each one associated with a rank value, s.t. every default
formula is classically derivable from the preceding ones, that is,
i |= i+1 , for 0  i < n .
e and the default-assumption set ,
e according
Step 6. Given now the background theory 
e
e
to the steps dened so far, we associate to the agent the pair h, i. Combining such
steps with the main theorem in Freunds work (1998, Thm. 24), it can be shown that
e i
e is
the default-assumption characterisation of the agent by means of the pair h,
equivalent to the rational closure of the pair hT , Di dened by Lehmann and Magidor
(1992). That is,
Proposition 2.1. Given a knowledge base K = hT , Di,
C|D  R(K) ,
where R is the rational closure operation defined by Lehmann and Magidor (1992), iff
e  {i } |= D,
{C}  

e (we indicate it by
where i is the first formula in h0 , . . . , n i consistent with {C}  
C|h,
e i
e D).
424

fiDefeasible Inheritance-Based Description Logics

As a consequence, using the following knowledge base transformations
hT , Di

e
hTe , Di

h, D  i

e i
e ,
h,

()

e i
e by means of Proposition 2.1,
we can characterise the rational closure of hT , Di via h,
i.e.,
C|D  R(hT , Di) i C|h,
e i
e D .
So, we have a method to decide defeasible consequence under rational closure. Specically, given a defeasible knowledge base hT , Di and the propositions C and D,
1. once for all, apply to hT , Di the transformations () to obtain the defeasible knowle i;
e
edge base h,

e
e =
2. given C, determine i as the rst ({C}  )-consistent
formula of the sequence 
h0 , . . . , n i.
3. then decide if D follows under rational closure from C w.r.t. hT , Di by determining
e  {i }  D.
whether {C}  

Example 2.5. Consider again the case of the penguin, with the knowledge base of Example 2.3. First (Step1), we move the strict knowledge in T into the defeasible part, obtaining
D  = {p  b|, p|f, b|f, b|w} .
Then (Step2) we define the set of the materialisations
D  = {p  b  , p  f, b  f, b  w} ,
and the correspondent set of antecedents
AD = {p  b, b, p} .

We use the set of materialisations D  to determine the ranking value of the formulae in
AD and the conditionals in D  (Step3), obtaining
0 = r(b) = r(b|f ) = r(b|w)
1 = r(p) = r(p|f )
 = r(p  b) = r(p  b|) .
So (Step4), we define a conditional base

with

e = hTe , Di
e ,
K
Te = {  p  b}
e = {p|f, b|f, b|w}
D

(since in this case the strict and the defeasible part of the conditional base were correctly
e is the same as K).
separated already in the initial base K, we obtain that K
425

fiCasini & Straccia

Such a conditional base is translated into a knowledge base

(Step5), with

where

e i
e
h,
e = {p  b}

e = {0 , 1 } ,

0 = (p  f )  (b  f )  (b  w)
1 = p  f .

Using such default information, we conclude (Step6) that penguins do not fly, birds fly
and birds have wings.
Remark 1. Considering Example 2.5, it would be intuitive also to conclude that penguins
have wings (p|w), but in the rational closure a category that is recognized as atypical, as the
category of penguins in the present case (they are birds, but they dont fly, and consequently
r(p) = 1), cannot inherit any of the typical characteristics of their super classes. Hence we
are not allowed to conclude that, presumably, penguins have wings. Such a weak inferential
power is generally considered the main limit of the rational closure. On the other hand, as
we are going to see in the next section, INs manage successfully this kind of problems.
This procedure to determine the rational closure maintains the same computational
complexity as the classical decision procedure, since it is easily veried that all the transformations in () require at most O(|K|) entailment tests and, given also proposition 2.1
and the fact that the strict part can encode any (monotone) propositional theory, we have
that
Proposition 2.2. Deciding propositional defeasible consequence under rational closure (|, )
is coNP-complete.
Lehmann and Magidor (1992) specify also a semantic characterization of the propositional rational closure, and an alternative correspondent construction has been recently
presented by Giordano et al. (2012a). If we move from propositional logic to DLs, a version
of rational closure for the language ALC has previously been proposed (Casini & Straccia,
2010), and such a procedure can be semantically characterized by means of preferential DL
interpretations (Britz, Casini, Meyer, Moodley, & Varzinczak, 2013).
As seen above, rational closure denes a non-monotonic consequence relation with an intuitive behaviour and strong logical properties; however, as by Remark 1, it is also somewhat
weak, as often there are conclusions about exceptional situations that, despite intuitive, we
cannot derive. Such a behaviour is due to the fact that the procedure associates to a set of
premises only those conditionals that are at least as exceptional.
Next, we are going to rene rational closure in order to avoid such a loss of inferential
power w.r.t. exceptional premises. Our proposal is based on a modication of the initial
knowledge base: we add new conditionals that give information about exceptional cases that
426

fiDefeasible Inheritance-Based Description Logics

would be lost in the rational closure procedure. Such a renement is obtained using again
the ranking procedure, but applying it locally, that is, in order to decide if a conditional
C|D has to be added to our KB we apply the same procedure as in rational closure, but
we consider only the information that is relevant to the inferential connection between C
and D. For example, assume a knowledge base composed only of the set of conditionals
D = {p|q, q|r, q|t, p|t}; now, following the procedure for rational closure we obtain
that p is an exceptional proposition, the only one, and so we cannot derive neither p|r nor
p|t. But, while we do not want to derive p|t, as we already have p|t, intuitively we
do not have any reason to avoid the conclusion p|r. In fact, such a conclusion would be
desirable, since p is a q, and p being an r does not generate any conict with the rest of the
information in the knowledge base.
So, our aim is to specify a way to decide which information in the KB is relevant
w.r.t. a particular connection (in the above case, p|r). In order to determine such a local
relatedness we are going to consider INs: we use their graphical characterisation in order
to identify the relevant information w.r.t. the connection we want to investigate, and then
we apply the ranking procedure to the pieces of information recognised as relevant.

3. Boolean Defeasible Inheritance Networks
Here we present a new decision procedures for INs, based on classical propositional decisions,
that, in addition to being a main step in the nonmonotonic construction we are going to
present later on, turns out to be an interesting IN decision procedure per se.
In the following, we proceed as follows. At rst, we dene a procedure for INs, and then
we map it into propositional logic, obtaining the desired renement of rational closure.
3.1 Exceptionality Levels in Inheritance Nets
Our rst aim is to apply to INs a modied version of the decision procedure for rational
closure; we do this in order to dene a method for deciding validity in INs that rely on
propositional calculus so to allow easily (i) to extend such a method in order to include into
the language also the propositional connectives , , , and (ii) to integrate it with rational
closure, in order to extend the inferential power of rational closure without compromising
its logical properties. A non-negligible side product is that it is a propositional SAT-based
reasoning procedure.
We shall briey review the case of purely strict nets showing that this case is easily
manageable using propositional calculus, and then we shall focus on mixed nets.
3.1.1 Strict Nets
For the strict part of the nets we want to obtain the same valid connections as in all classical
proposals. If a net is composed only of strict links, i.e., N = hS, i, its valid connections and
its consistency can be easily checked using propositional calculus. Indeed, dene a classical
propositional language  using the nodes in N as propositional letters (call PN such a set
of propositional letters), and  and  as connectives, and translate the set of links S into
the set of the corresponding propositional implications
 = {p  q | p  q  S}  {p  q | p 6 q  S} .
427

fiCasini & Straccia

We indicate by l a literal in  (being a literal a propositional letter or its negation), and
we dene A as the set of the antecedents of the implications in , that is
A = {p | p  l  } .
Then we can derive the valid paths using  and classical consequence relation  3 .
Proposition 3.1. Consider a net N = hS, i and translate it into a set of propositional
implications . The following properties hold:
1. If N is a consistent net, there is a valid strict positive (resp., negative) path hp, , qi
from p to q, that is N
p  q (resp., N
p 6 q), iff   p  q (resp.,   p  q).
2. N is inconsistent iff   p for some p  A .
3. Deciding strict consequence can be done in polynomial time.
So we can treat the decision problem in strict nets by means of classical propositional
calculus, obtaining exactly the same valid strict paths as in the classical approaches to nets.
Note that there is a dierence in the notion of inconsistency between INs and propositional logic. As seen in Section 2.1, a net is considered inconsistent if there is a node p
that, simultaneously, is positively and negatively connected to another node q: p is and
is not, simultaneously, a subclass of q. In the inheritance nets, such a situation is interpreted as a contradiction, while in the propositional logic the correspondent situation
( |= (p  q)  (p  q)) would just force the negation of the propositional letter (i.e.,
node) p (  p), that would correspond to saying that no individual can fall under the
class p.
3.1.2 Mixed Nets
Now we consider nets with both strict and defeasible links. In what follows we will assume
that the strict part of a net N = hS, U i is inferentially closed, that is, if N
p  q (resp.,
if N
p 6 q) then p  q  S (resp. p 6 q  S).
Our procedure diers from the classical approaches to INs mainly because it is not based
on the notion of potential path; instead, we translate the nets links into propositional
formulae, and then we build an exceptionality ranking using a procedure that is similar to
the one dened for rational closure. The main dierence with the procedure dened for
rational closure lays on the local characterization of the exceptionality rankings: to check
if there is a valid connection between a pair of nodes p and q we proceed in dening an
exceptionality ranking of the nodes; however, we do not consider all the nodes in the net,
but only those related to p and q. Such a relation is determined by means of the notion
of course, that is a generalisation of the potential path.
Roughly, courses are simply routes on the net following the direction of the arrows,
without considering if each of them is a positive or a negative arrow.
Definition 3.1 (Course). Courses are defined as follows (where   {, 6, , 6}):
3. Note that strict links can be encoded as 2-CNF formulae, also called Krom formulae, and that the
propositional 2-SAT problem is in P .

428

fiDefeasible Inheritance-Based Description Logics

1. every link p  q in N is a course  = hp, qi in N ; and
2. if  = h, qi is a course and q  r is a link in N that does not already appear in ,
then   = h, ri is a course in N .
The omission of repetitions in courses is needed to guarantee the niteness of courses
even if the net contains cycles. So, given a net N dened by a nite number of links, there
is only a nite set C N of courses, that, in turn, are nite sequences of nodes. We denote
N the set of all the courses in N going from node p to the node q, i.e.,
with Cp,q
N
Cp,q
= {  C N |  = hp,   , qi for some   } .

We next provide a procedure that denes the validity of a defeasible connection between
two nodes p and q, via a mapping into propositional logic. Given a net N = hS, U i, we
dene a correspondent knowledge base
KN = hN , N i ,
where
N = {p  q | p  q  S}  {p  q | p 6 q  S}
and
N = {p  q | p  q  U }  {p  q | p 6 q  U } .
In the following, we may omit N if it is clear from the context.
We dene an exceptionality ranking of the nodes, that depends on the decision problem
with respect to p and q only.4
So, let
p,q = {r  t | r  t  ,   Cp,q } 
{r  t | r 6 t  ,   Cp,q } ,
and consider the set of relative antecedents (l being a literal)
Ap,q = {a | a  l  N  p,q } .
In the following, N will denote the supra classical entailment relation obtained adding
to  the set of propositional formulae N as extra axioms. For the strict part of the net, if
p N q (resp., p N q), then we say that q (resp., q) follows strictly from p in N , and
we indicate it by p N q (resp., p N q).
On the other hand, |N will indicate the inference relation for the defeasible part, that
is, p|N q has to be read as a member of the class p is typically also a member of the class
q in N . Analogously for p|N q in the negative case.
4. This is the main difference w.r.t. the procedure for propositional rational closure: while there we rank
all the information in the KB at once, here we rank only the information related to the connection we
are interested in, between p and q.

429

fiCasini & Straccia

Now, we use N and p,q to determine the exceptionality level. If we are investigating the connection between p and q, a node in Ap,q is exceptional if it is negated by the
information contained in  and p,q (compare with Step 3.2 in Section 2.2):
E(Ap,q ) = {a  Ap,q | p,q N a}
E(p,q ) = {a  b  p,q | a  E(Ap,q )} .
Therefore, like Step 3.3 of Section 2.2, we build a sequence
0 = Ap,q
i = E(i1 ) ,
and the corresponding sequence
E0 = p,q
Ei = E(Ei1 ) .
Since Ap,q and p,q are nite, and for every i i  i+1 and Ei+1  Ei , the sequences
terminate with an (empty or non-empty) xed point of the function E, as in Section 2.2.
Dene now a ranking function (like Step 3.4) r that associates to every implication in
p,q a number, representing its level of exceptionality:
rp,q (a) = i if a  i and a 
/ i+1
rp,q (a) =  if a  i for all i
rp,q (a  b) = i if (a  b)  Ei and (a  b) 
/ Ei+1
rp,q (a  b) =  if (a  b)  Ei for all i .
Clearly, r(a  b) = r(a) for every a  b  p,q . In the following, we assume that we
do not obtain any node with a ranking value of  (that is, the function E terminates with
an empty set). We will see later on (Proposition 3.6) that in this latter case the net is
inconsistent.
b p,q of the implications a  b  p,q that are at least as
We now consider the set 
exceptional as p,
b p,q = {a  b  p,q | r(a  b)  r(p)} ,


and eventually dene

b p,q  p  q
p|N q i 
N
b
p|N q i p,q N p  q .

In the language of the nets, we indicate the inference relation generated by such a
procedure by the symbol  . That is,
N



p  q i

p N q

N



p 6 q i

p N q

N
N



p  q i
p 6 q i

p|N q
p|N q .



So, given N = hS, U i and a pair of nodes hp, qi, our inference procedure for INs can be
summarised as follows:
430

fiDefeasible Inheritance-Based Description Logics

1. Close S under strict validity.
2. Check if there is a direct (and hence valid) link in N connecting p to q. If there is,
the connection is valid. Otherwise, proceed.
3. Determine the set Cp,q of the courses in N connecting p to q, map the links in S and
Cp,q into the sets of implications  and p,q , dene the set Ap,q of the antecedents of
the implications in   p,q .
4. Determine the ranking value of every proposition in Ap,q and every implication in
p,q .
b p,q of the implications that are at least as exceptional as p.
5. Dene the set 

6. Then decide N
b p,q  p  q).
(



p  q (N



b p,q  p  q
p 6 q) by determining whether 

Please note again that we rely on a decision procedure for  only. The examples below
illustrate the behaviour of our method.
Example 3.1. Consider Example 2.1 with additional links t  b and t  p (read t as
tweety).
w
b
f

t

p

Figure 1: Example 3.1
We translate the net into the following knowledge base
K = h, i ,
where
 = {t  b, t  p, p  b}
and
 = {p  f, b  f, b  w} .
Suppose now, we want to decide if t is connected to f (i.e., Tweety flies).
Since the link b  w does not appear in any course from t to f , we have
t,f

= {p  f, b  f }

At,f

= {t, b, p} ,
431

fiCasini & Straccia

and so we obtain
t,f  p and t,f  t .
Thus,
0 = r(b) = r(b  f )
1 = r(t) = r(p) = r(p  f )
So,
b t,f  t  f , we have
and, as 

b t,f = {p  f }

t|N f ,

as expected.
As next, we ask if t is connected to w (i.e., Tweety has wings). Now, we have
t,w = {b  w}
At,w = {t, b, p} .
As t,w does not imply the negation of any of the members of At,w , we have
0 = r(t) = r(p) = r(b) = r(b  w)
and

b t,w = t,w .


b t,w  t  w, we have
As 

t|N w ,

as expected.
Example 3.2. Consider the Nixon Diamond (see Figure 2), where n is Nixon, r is republican, q is quaker, and p is pacifist; it is another classical problem in nonmonotonic
reasoning, that is similar to the previous one but we are not informed if a path is more
specific of the other (while above the link p  b tells us that the information about the
penguins is more specific than the information about the birds). So, we do not want neither
n  p nor n 6 p validated.
q
p

n

r

Figure 2: Nixon diamond.
432

fiDefeasible Inheritance-Based Description Logics

The knowledge base K corresponding to the net is composed of
 = {n  r, n  q}
 = {r  p, q  p} .
We want to check if n is connected to p. So, n,p = , and the only negated antecedent is n
 n,p = . Since 
 n,p 6 n  p
(n,p  n): r(q  p) = r(r  p) = 0 while r(n) = 1, i.e., 
 n,p 6 n  p, we conclude that
and 
n 6 |N
n 6 |N

p
p .

The two following examples illustrate that our procedure and Hortys skeptical closure,
notwithstanding they often manifest similar results, do not always give back the same
results, nor one is included in the other.
Example 3.3. Consider the net in Figure 3.
f

g

x

p

a

m

n

y

Figure 3: Example 3.3
We want to investigate if there is a valid connection between a and p. According to
Hortys skeptical closure, we cannot conclude anything about a and p (N 6 a  p). Instead,
 a  p), since we have r(a) = r(f ) = r(g) =
with our approach we obtain a|K p (N
r(x) = 1.
Example 3.4. Consider the net in Figure 4.
p
c

t

e

f

b

Figure 4: Example 3.4
We want to investigate if there is a valid connection between p and b. According to
Horty (1994) we conclude N
p 6 b, while with our approach we cannot conclude anything.
433

fiCasini & Straccia

So, even if in many situations the results of the two approaches are the same, we can
obtain dierent results with them. Such dierent outcomes are mainly due to a dierence in
how conicts are interpreted. Consider Example 3.4, where we have an unresolved conict
between two paths from p to f , that is, no one of the two paths preempts the other, and so
none of them can be considered as valid, both in Hortys and in our approach. In Hortys
interpretation, such a conict prevents also the construction of paths starting at p and
passing through f : in order to be constructible a path has to be built augmenting a valid
shorter path, and thus we cannot construct any path starting from p and passing through
f (Horty, 1994, Def. 2.1.1). So, an unresolved conict totally eliminates the possibility to
consider such paths in more ample argumentations, where they could play some role. On
the other hand, in our approach we are not so radical about conicts: the fact that we
cannot conclude neither p  f nor p 6 f does not eliminate the possibility that in the
actual world one of such connections is true; simply we do not have enough information to
decide. The possibility of p  f to be eectively valid invites us to take under consideration
such a potential argumentation in moving from p to b. So, looking for a connection between
p and b in Example 3.4, while Horty cannot consider the path hp, c, t, f, bi, avoiding the
rise of a conict with the path hp, e, bi, in our approach we still consider the possibility
for hp, c, t, f i to be eectively true, allowing the path hp, c, t, f, bi to play a role in deciding
whether there is a valid connection between p and b. In such a way we have a potential
conict with hp, e, bi that prevents the validity of the latter. For other signicant examples
of our approach see Appendix A.
Notice that, even if it is built on the notion of courses, our procedure respects the
classical notion of potential path, that is, every valid connection corresponds to a potential
path on the net (Denition 2.1).
Proposition 3.2. Consider a net N . For every connection p|N q (resp., p|N q) validated
by our procedure, there is a corresponding positive (resp., negative) potential path from p to
q in the net N .
3.1.3 Inference Relation
Talking about nets, the structural properties characterizing rational consequence relations,
REF , CT , CM , and RM , take the following form5 :
(REF)
(CT)
(CM)
(RM)

N
N
N
N

p  q for every p  q  N
pq
N,p  q
rs
N
rs
pq
N
rs
N,p  q
rs
rs
N 6 pq
N , p6 q
rs

The meaning of the properties is still the same as the propositional case, simply readapted
to the expressivity of the INs: the net represents the information at our disposal, the
premises of the derivation, and the links are the informational atoms of our language.
5. with ,   {, 6}; N , a  b in the premises indicates the addition of the direct link a  b to the net N ;
6  indicates the opposite arrow of  (e.g. 6  is  iff  is 6)

434

fiDefeasible Inheritance-Based Description Logics

Hence, the sense of the rules is the same as before. (REF) indicates that whatever piece
of information (link) is in the premises, it appears also in the conclusions. (CT) is a cut
condition, that states that if the validity of a link can be derived from the links in the rest of
the net, such a link can be eliminated without aecting the set of the conclusions derivable
from the net. (CM) is a form of constrained monotony, opposite to (CT), that states that
whatever conclusion can be derived from the net, it can be added to the premises without
aecting the other conclusions. (CT) and (CM) have an intuitive appeal, and from the
logical point of view characterize
as a closure operation. The translation of (RM) is less
intuitive, since we do not have in INs a classical notion of negation, but we have only a
notion of conict; hence the sense of the rule is that, if p  q is not a consequence of N ,
then the addition of information conicting with p  q, i.e., p 6 q, should not aect the
defeasible consequences of the net N . The fact that INs do not share with classical logic
the notions of contradiction and negation makes this formulation of (RM) less intuitive and
interesting.
The proprieties (REF), (CT) and (CM) are often considered proprieties that a nonmonotonic consequence relation should satisfy (Kraus et al., 1990; Makinson, 1994), and so
it is interesting to check if they are satised in the IN formalism. We know that the classical
approaches to inheritance nets do not satisfy (CT) and (CM) (Makinson, 1994, pp. 56-57),
while our approach is logically more appealing.
Proposition 3.3.



satisfies (REF), (CT) and (CM).

While (RM) is not satised.
Proposition 3.4.



does not satisfy (RM).

The following example proves the proposition
Example 3.5. Consider the net in Figure 5. The net is composed of the links p  f ,
f  b, and p  t. We have N
p  b and N 6 t  b, but N , t 6 b 6 p  b.
b
f

t

p

Figure 5: Counterexample to RM.
This example actually shows that, dealing with the notion of negation and consistency
that characterize INs, (RM) does not look as a desirable property anymore, since the addition of t 6 b to the net creates a Nixon Diamond from which we do not want to derive
p  b (see Example 3.2).
435

fiCasini & Straccia

Other properties of logical consequence relations, left equivalence and right weakening,
have an analogous in the following properties:
(LE)
(RW)

N

pq N
pr N
N
rq
pq
N
qr
N
pr

N

rp

We also introduce a property that corresponds to the logical property of supra classicality (if C  D, then C|D), a rule satised by most non-monotonic consequence relations:
(Sup)

N
N

Proposition 3.5.

pq
pq


N
N

p 6 q
p 6 q

satisfies (LE), (RW ), and (Sup).

3.1.4 Consistency
As indicated at the end of Section 2.1, a net is considered inconsistent if we are forced
to conclude for some pair of nodes p, q that p and q are both positively and negatively
connected. Since, as seen above,  satises (Sup), we can say that a mixed net is consistent
i we cannot conclude both N  p  q and N  p 6 q for any pair of nodes p, q.
Now we are going to see that in order to check the consistency of a mixed net we can use
the ranking procedure: it is sucient to apply it to the whole net. As for the propositional
case (see Section 2.2), the ranking procedures dened on the nodes of a net terminates,
after a nite number of steps, into either an empty set n or a xed point of the function
E, i.e., the set of the nodes that result always exceptional. In such a case, we say that such
nodes have an innite ranking value (r(p) = ). If we want to check whether a net N is
consistent, it is sucient to apply the ranking procedure to the entire net, and see if there
are nodes with innite ranking.
Proposition 3.6. A net N is consistent iff we do not have a node p with r(p) = , that
is, we do not conclude both N  p  q and N  p 6 q for any pair p, q.
Example 3.6. The net in Figure 6 is an example of an inconsistent net, from which we
 t  f and N
 t 6 f . Such a net is translated into the
would conclude both N
b
f

t

p

Figure 6: An example of inconsistent net.
436

fiDefeasible Inheritance-Based Description Logics

knowledge base
 = {t  b, t  p, p  b, b  p}
 = {p  f, b  f } .
We proceed the ranking of the entire net, and we obtain that   p,   b and
  t, that is, E1 = . Hence,  is a fixed-point of the exceptionality ranking function,
and p, b, t have  as ranking value.
3.1.5 Properties
In the eld of inheritance networks, a taxonomy of the dierent approaches has been developed on the basis of some relevant properties (Horty, 1994). We briey check which of
them are satised by our approach.
 Purely defeasible / mixed nets. Cyclic / acyclic nets. Our procedure deals easily with
two properties that often create problems in the traditional approaches: the presence
of both strict and defeasible links (mixed nets), and the presence of cycles (cyclic
nets).
 Credulous / skeptical / directly skeptical approaches. Our approach corresponds to a
directly skeptical approach: given a net, we obtain a unique set of valid connections in
it (vs. the credulous approach, that allows for dierent sets of valid paths, possibly in
conict with each other), and such a unique set is not obtained from the intersection
of dierent possible extensions (as in some skeptical approaches), but it is obtained
from a single closure operation.
 Upward / downward chaining. For the denition of valid paths, we do not use any
form of induction on their length, neither starting from the initial node toward the
terminal node (upward chaining), nor in the reverse direction (downward chaining);
hence, no form of chaining is used in our procedure.
 On-path / off-path preemption. O-path preemption is the classical form of preemption, used also by Horty (1994, Def. 3.2.2), while on-path preemption is more
binding, requiring the preempting node to lie on the initial segment of the path it preempts (Horty, 1994, sect. 4.2.4). We do not exactly formalise a form of preemption,
since we do not confront directly the dierent paths between two nodes. However,
our procedure has a behaviour that is analogous to the use of o-path preemption.
3.1.6 Computational Complexity
To dene the overall complexity of our decision procedure over the nets, we have to consider
the complexity of the course-identication procedure, that is, given a net N = hS, U i and
two nodes s, t in N , which is the computational cost to identify s,t (note that  can easily
be computed in polynomial time), whose size is bounded polynomially by the size of N .
Given that the construction of courses is independent from the nature of the links (either
they are positive or negative, defeasible or strict), we can analyse the problem using simple
directed graphs. Given a net N = hS, U i, it is sucient to dene the correspondent directed
graph G = hV, Ei in the following way:
437

fiCasini & Straccia

 V is the set of nodes in N .
 E is a set of directed links ha, bi, with a, b  V , s.t. ha, bi  E i one of the following
holds:
a  b  S , a 6 b  S , a  b  U , a 6 b  U .
Recall that we have stated the presence of a 6 b in S implies that b 6 a is in S too. So,
for a 6 b  S we have both ha, bi and hb, ai in E.
Once we have dened G, let us recall a well-known result in graph theory saying that
in a directed graph, given two nodes p and q, determining if there is a path from p to q
can be determined in time O(|V | + |E|), e.g. using BFS (Breadth First Search) (Cormen,
Stein, Rivest, & Leiserson, 2001). Now, the following argument shows that indeed s,t can
be determined in polynomial time 6 . At rst, we check if there is a path between s and t.
If not, then s,t = . Otherwise, we call the procedure Delta(s) below:
Delta(s): for each outgoing edge hs, xi of s, such that both hs, xi and x are not marked,
do: if there is a path between x and t then mark both hs, xi and x, and recursively,
call Delta(x).
Once nished, s,t can immediately be build from the marked edges. Note that each edge
is marked once and each node is marked (i.e., explored) once and, thus, the algorithm is
bounded polynomially by the size of the graph.
Once we have found the set s,t and , we have to apply the decision procedure based
on the propositional rational closure to decide if there is a valid connection between p and
q (as for Section 2.2, the number of entailment tests is polynomially bounded by the size
of the net). As all formulae are 2-CNF, like Proposition 3.1, we obtain that the decision
procedure w.r.t. the net respects the complexity costs of the related propositional calculus.
Proposition 3.7. Deciding defeasible consequence under inheritance networks (
done in polynomial time.

)

can be

Eventually, if we want to determine all the valid links in the net N we have to consider
all the pairs of nodes in the net N . So, obtained the graph G = hV, Ei we have to repeat the
procedure for all the elements of the set of the pairs of nodes in the graph, whose cardinality
is |V |(|V |  1). Hence, again
Proposition 3.8. Computing all the valid connections in a net can be done in polynomial
time.
3.2 Boolean Inheritance Nets
We next extend INs by introducing in them the classical propositional connectives , , .
Despite such an extension has been felt as desirable, we are aware of just an attempt in this
direction (Horty & Thomason, 1990).
6. We are not interested here in figuring out a tight bound.

438

fiDefeasible Inheritance-Based Description Logics

c

c

cd

cd

d

d

Figure 7: Disjunction

Figure 8: Conjunction

3.2.1 Negation
So far, we have used the link 6 to indicate that two classes are disjoint: p 6 q has p  q
as logical meaning. We change the notation and substitute 6 with  , indicating with
p  q that class p and class q are complementary (i.e., p  q), and in general we
will indicate the complementary class of a class p with p. Hence, we can substitute every
link p 6 q in a net with four links: p  p, q  q, p  q, and q  p. Moreover, we
can eliminate the negative defeasible links, since p 6 q can be expressed as p  q  q.
So, we can transform an IN into a net using only the arrows , , and  . We shall
continue to use 6 as a macro indicating the valid negative strict connections obtained from
the composition of  and , that is, we indicate with p 6 q the presence of a path

. . d } q ,
p
| a {z. . .  b}  |c  .{z
n arrows

with n, m  0.

m arrows

3.2.2 Conjunction and Disjunction
Next, we extend inheritance nets to support conjunction and disjunction as well, by allowing
links a, b  c (conjunction of a and b is equivalent to c) and c  a, b (disjunction of a
and b is equivalent to c). We will assume that inheritance nets containing such kind of
links are closed according to the following rule: if there is a, b  c (resp., a, b  c) in
a net, then there are also c  a and c  b (resp., a  c and b  c) in the net. We call
these nets Boolean Defeasible Inheritance Networks (BINs). We shall use a  b and a  b
to indicate, respectively, that a node represents the conjunction or the disjunction of a and
b. Graphically, we indicate disjunctive and conjunctive links as in Figure 7 and Figure 8,
respectively.
We extend now our reasoning method to BINs. To do so, we need to amplify the notion
of course, introducing the notion of duct: we consider not only linear routes from one point
to another, but also parallel routes, in order to model the introduction of the conjunction
in the consequent and the introduction of the disjunction in the antecedent. Roughly,
 = hs,


, ti


will indicate a duct  that starts at node s and develops through the ducts  and   , both
reaching the node t.
439

fiCasini & Straccia

Definition 3.2 (Duct). Ducts are defined as follows (where   {, 6, , 6}):
1. every link p  q in N is a duct  = hp, qi in N ;
2. if  = h, qi is a duct and q  r is a link in N that does not already appear in , then
  = h, ri is a duct in N ;
3. if  = hq, i is a duct and r  q is a link in N that does not already appear in , then
  = hr, i is a duct in N ;
t,
4. if ht, , pi and hr,   , pi are ducts, then for s  t, r  S, hs, r,
 , pi is a duct; and

5. if hp, , ti and hp,   , ri are ducts, then for t, r  s  S, hp, ,t
 ,r , si is a duct.
Now our reasoning method for BINs is as follows. Given a net N = hS, U i, we can dene
a correspondent knowledge base K = h, i, where
 = {p  q | p  q  S}
 {p  q | p  q  S}
 {p  q  r | q, r  p  S}
 {p  q  r | p  q, r  S}
 {p  q | p 6 q  S}
 = {p  q | p  q  U } .
Now, we may proceed to the denition of |N as in Section 3.1, simply considering C N as
N (or simply C ) as the set of the ducts from p to q.
the set of the ducts in N , and Cp,q
p,q
Example 3.7. Consider the net N illustrated in Figure 9. The net N is mapped into the
e

d
g

a



b
c
f

Figure 9: Example 3.7
KB K = h, i, where

7

 = {c  d  g, f  g}
 = {a  b, b  c, b  d, b  e, a  f } .
7. To ease the reading, we have omitted the redundant implications such as g  c, obtained from c, d 
g, g  c  N .

440

fiDefeasible Inheritance-Based Description Logics

Now, we ask whether a is connected to c. It can be verified that
a,c = {a  b, b  c, b  d, a  f } .
Note that b  d  a,c , as there is a duct from a to c that passes through c and d in order
to reach g, and then back towards c. Now, the only negated antecedent is a (a,c  a)
and, thus,
b a,c = {a  b, a  f } .

b a,c 6 a  c and 
b a,c 6 a  c, we have
Since 

a6|N c and a6|N c .

In a similar way, we may show that a6|N d and a6|N d. This is the desirable result: since
a  f is a direct link, we have that a|N f (i.e., a|N (c  d)), and hence we know that
we cannot conclude both a|N c and a|N d. But, since we have no evidence whether one of
such conclusions has to be preferred to the other, we do not conclude either of them. The
result of our skeptical approach is that a6|N c, a6|N c, a6|N d, and a6|N d. On the other
hand, since the only duct connecting a to e is ha, b, ei (that is, the nodes c, d, g, and f do
not play any role in any possible argumentation connecting a to e), we can conclude a|N e.
3.2.3 Properties
We call BIN the inference relation dened by the just dened closure operation over BINs
and we have:
N

BIN

p  q i p  q

N

BIN

p 6 q i p  q

N

BIN

p  q i p|N q

N

BIN

p 6 q i p|N q .

BINs inherit the same structural properties of our INs, that is, (REF ), (CM ), and
(CT ). Analogously, (LE), (RW ), and (Sup) are still valid.
Proposition 3.9.
Proposition 3.10.

BIN

satisfies (REF ), (CM ), and (CT ).

BIN

satisfies (LE), (RW ), and (Sup).

Since the procedure dened in Section 3.1 is simply a special case of the procedure for
BINs, (RM) is falsied also for BINs by the same counter-example of proposition 3.4. Moreover, introduced conjunction and disjunction, we can express the analogous of the rules of
disjunction in the premises (OR) and conjunction in the consequent (AND):
(OR)

(AND)

N

BIN

pq N
N

N

BIN

sq N
BIN t  q

BIN

pq N
N

ps N
BIN p  t

BIN

441

BIN

t  p, s

BIN

q, s  t

fiCasini & Straccia

The sense is the same as in the propositional case, and it remains intuitive also in
the BIN environment: (OR) represents the validity of reasoning by cases, while (AND)
represents that the conjunction of distinct conclusions is still a valid conclusion from the
net.
Proposition 3.11.

BIN

satisfies (OR) and (AND).

3.2.4 Consistency
Also w.r.t. consistency, we obtain the same result as for INs, i.e., the net is consistent if the
ranking procedure terminates into an empty set.
Proposition 3.12. A BIN N is consistent iff we do not have any node p with r(p) = ,
that is, we cannot conclude both p  q and p 6 q for any pair p, q.
Remark 2. As seen in Section 3.1.4 the notion of consistency in inheritance nets is different from the notion of consistency for propositional logic. Using our procedure a net is
inconsistent if, applying the ranking function to the entire net, we obtain a node with  as
ranking value (see Proposition 3.6). Up to this point, if we find that a net is inconsistent,
we simply stop our decision procedure.
In what follows we are going to work with BINs in the framework of propositional logic.
So, in order to assimilate the notion of consistency with the one of propositional logic, from
now on we shall consider a modified version of our procedure for BINs. Suppose we have
to decide the validity of the connection between two nodes p, q in a net N . If N results
consistent, then we proceed as above, otherwise, if our net results inconsistent (some node
has infinite ranking value) we do not simply stop, but, in case r(p) < , we still apply our
procedure. Otherwise, if p itself has infinite ranking value (r(p) = ), we do not proceed
further.
3.2.5 Computational Complexity
As for INs, we have to determine s,t (computing  is again immediate) from the ducts
in a BIN. Now, it is not dicult to see that a recursive BFS graph travelling procedure
as the one devised for INs can be worked out for BINs as well. By illustration, refer to
Figure 9 and assume we are processing node b. Since from b, both d and c are reachable
and d, c  g  S, and, recursively, there is a path from g to c, we can mark hb, ci and hb, di,
and mark the conjunction d, c  g  S as visited. Again, all nodes and aggregated
nodes are visited at most ones, guaranteeing polynomial cost for computing s,t .
Now, while s,t and  can be determined in polynomial time, and as for Section 2.2,
the number of entailment tests is polynomially bounded by the size of the net, the strict
part may encode any propositional formula and, thus, unlike the case of INs, we have:
Proposition 3.13. Deciding defeasible consequence for BINs (
problem.

BIN )

is a coNP-complete

4. Defeasible Inheritance in Propositional Logic
Now, we depart from BINs and apply a similar reasoning procedure in the framework of
propositional logic, and show how to obtain a kind of closure of a knowledge base that
442

fiDefeasible Inheritance-Based Description Logics

results to be a rational consequence relation, but that is more informative than the classical
rational closure (Lehmann & Magidor, 1992).
We consider a propositional language with only , ,  as connectives. So, we start with
a conditional KB K = hT , Di (see Section 2.2), with T = {C1  D1 , . . . , Cn  Dn } and
D = {E1 |F1 , . . . , Em |Fm }.
Step 1. Given a conditional base K = hT , Di, check if K is preferentially consistent (that
is, check if its materialisation is consistent; Section 2.2, Step 4.1). If it is consistent,
we dene a BIN from K, i.e., a net NK = hSK , UK i, modelling the information in K
in the following way:
(i) we consider every formula C that appears as antecedent or as succedent in the
conditionals in K, and we create a node C representing each of them, modulo
logical equivalence (that is, a node C represents the class of the formulae logically
equivalent to C).
(ii) for each node we add also, if not already present, the complementary node (the
node representing its negation), and we link them by  ;
(iii) we add the strict links: if C  D  T we add the strict link C  D to the net;
we also add to SK all the strict links that correspond to the logical dependencies
between the formulae represented by the nodes w.r.t. the consequence relation
T . If  appears in a conditional, we add to the net a correspondent node ,
and, for every other node n in the net, we add a strict node n  . Analogously,
for  we add   n for every node n in the net.
(iv) eventually, for C|D  D, we add a defeasible link  from node C to node D.
Step 2. We apply the reasoning procedure for BINs to NK (Section 3.2) to identify all valid
defeasible connections C|N D and we add them as C|D to the conditional base K
to obtain a new conditional base K = hT , D  i 8 .
Step 3. Finally, we apply to K its rational closure (Section 2.2) and we dene a nonmonotonic consequence relation |K by
C|K D i C|D  R(K ) .
Now, we can show that
Proposition 4.1. |K is a rational consequence relation containing K.
Example 4.1. Consider again the penguin example. We modify it slightly in order to
consider also the use of the connectives. While birds (b) typically fly, live on trees, and have
wings (f , t, w), penguins do not fly and do not live on trees (f  t). So, our knowledge
base K = hT , Di will be:
T

= {p  b}

D = {b|f, b|t, b|w, p|f  t} .
8. We do not modify T , since all the strict connections valid in the net are classically derivable from T .

443

fiCasini & Straccia

Notwithstanding penguins atypicality as birds, penguins have wings, and we would like
to be able to derive it from the information at our disposal, that is, we would like to conclude
p|w. Please note that this is not possible using classical preferential approaches, but we
can obtain such a conclusion passing trough the first step of our closure operation, that is,
defining the corresponding net.
Specifically, from the knowledge base K we define the net in Figure 10 (the dashed arrows
are the strict arrows that are not explicit in the conditional base, but that are logically valid
and that are added to SK in the construction of the net NK ).
f  t



f


tf



p

t



f

t

p

b

w

w





b

Figure 10: Example 4.1
Using the procedure defined for BINs, from such a net we obtain a new knowledge base
K = hT , D  i ,
with
D  = {b|f, b|t, b|w, p|f  t, p|w, p|f, p|t, b|f  t} .
Note that, while the new conditionals
p|f,

p|t,

b|f  t

would be present also in the simple rational closure of K (we obtain them by Right Weakening), we have obtained also the conditional
p|w ,
444

fiDefeasible Inheritance-Based Description Logics

that would not be present in the rational closure of K (see Remark 1).
Now, following the procedure defined in Section 2.2, we compute the rational closure
of the new knowledge base K , obtaining a rational consequence relation that contains the
original K.
Please note that, if we were using only BINs, we could have not derived anything else,
since our vocabulary would be limited to the propositions expressed by the nodes; however,
by relying on the rational closure of propositional knowledge bases, we can reason using the
full expressivity of a propositional language, deriving new conditionals as, for example,
b  green|f ,
which can not be derived using BINs as green does not appear in the net.
The next example shows another characteristic of this approach. In the preferential
approach typicality is an absolute property of a proposition w.r.t. the agents knowledge
base, that is, if a class results atypical w.r.t. some other class (as penguins w.r.t. birds),
it results atypical w.r.t. the entire knowledge base. In our approach instead, typicality is
a comparative notion: we can consider a class as exceptional with respect to a superclass,
but absolutely typical with respect to another.
Example 4.2. Consider a red fish (r). It is both a fish (f ) and a pet (p). Typically, a fish
has gills (g) and scales (s), while pets are docile (d) and play with kids (k). Red fishes are
not typical pets, since they do not play with kids. So, the K = hT , Di is
T

= {r  f, r  p}

D = {r|k, p|k, p|d, f |g, f |s} .
In the rational closure red fishes, since they are atypical pets (they do not play with kids),
result atypical in general, and they cannot inherit any of the typical properties of all their
super classes.
Instead, we want red fishes to inherit, besides the properties of pets that are compatible
with them (d), also all the typical properties of fishes (g and s), since we consider them
typical fishes.
To do so, we translate our knowledge base into the net in Figure 11. From such a net
we obtain a new knowledge base K = hT , D  i, with
D  = {r|k, p|k, p|d, f |g, f |s, r|d, r|g, r|s}
and so we have derived exactly the desired conditionals.
Next, we compute the rational closure of K , following the procedure defined in Section
2.2, and we obtain a rational consequence relation containing K and more information about
red fishes, information that, as intuitive as it is, we would not be able to derive from the
simple rational closure of K.
Therefore, we have dened a new rational consequence relation for K that extends K,
as K  R(K ), and that contains intuitive conditionals not in the rational closure of K.
445

fiCasini & Straccia

g

g
f
f

s





s





p
d

r



r

d



p

k



k

Figure 11: Example 4.2
Consistency. Dened some inference procedure, a conditional base K is consistent i we
cannot derive |. We have seen (Section 2.2) that for rational closure a conditional base
is consistent i its preferential closure is consistent (|  R(K) i |  P(K)). Here,
given a base K, we obtain that our procedure preserves the preferential consistency of K:
as seen in Section 2.2, K is preferentially consistent i its rational closure is consistent (i.e.,
 6 |rc
K ), and we can prove the following.
Proposition 4.2. Given a conditional base K, |K  iff |  R(K).
By the results in Section 2.2, this corresponds to saying that |K  i K   (assuming
K = hT , Di, K = T  D).
Computational Complexity. Considering the procedures dened for the BINs, we can
conclude that the dened procedure has the same complexity of the rational closure, as it
is the composition of the procedure dened for BINs (Proposition 3.13) and a nal rational
closure operation (Proposition 2.2).
Proposition 4.3. For a propositional conditional base K, deciding C|K D is a coNPcomplete problem.

5. Defeasible Inheritance in DLs
Next, we apply our method to a signicant DL representative, namely ALC (Baader et al.,
2003, ch. 2). ALC corresponds to a fragment of rst order logic, using monadic predicates,
called concepts, and dyadic ones, called roles.
In order to stress the parallel between the procedure presented in Section 2.2 and the
proposal in ALC, we are going to use the same notation for the components playing an
analogous role in the two construction: we use p, q, r, . . . for concept names, and C, D, E, . . .
to indicate concepts in general, instead, respectively, of atomic propositions and propositions, and |= and | to indicate, respectively, the classical consequence relation of ALC and
446

fiDefeasible Inheritance-Based Description Logics

a non-monotonic consequence relation in ALC.  will indicate a default concept, that is, a
concept that we assume as applying to every individual, if not informed of the contrary.
We have a nite set of concept names C = {p, q, r, . . .}, a nite set of role names R =
{R, S, T, . . .} and the set L of ALC-concepts is dened inductively as follows: (i) C  L;
(ii) ,   L; (iii) C, D  L  C  D, C  D, C  L; and (iv) C  L, R  R 
R.C, R.C  L. Concept C  D is used as a shortcut of C  D. The symbols  and 
correspond, respectively, to the conjunction  and the disjunction  of classical logic.
Given a set of individuals O, indicated by bold letters a, b, c, . . ., an assertion is of
the form a:C (C  L) or of the form (a, b):R (R  R), respectively indicating that the
individual a is an instance of concept C, and that the individuals a and b are connected
by the role R.
A general inclusion axiom (GCI) is of the form C  D (C, D  L) and indicates that
any instance of C is also an instance of D. We use C = D as a shortcut of the pair of
C  D and D  C.
From a FOL point of view, assertions and inclusion axioms can easily be mapped in
FOL by the following transformation:
 (a:C) =  (a, C),
 (C  D) = x.( (x, C)   (x, D)),
 (x, A) = A(x),
 (x, C  D) =  (x, C)   (x, D),
 (x, R.C) = y.(R(x, y)   (y, C))
 (x, R.C) = y.(R(x, y)   (y, C))

 ((a, b):R) = R(a, b),
 (x, ) = (x),  (x, ) = (x),
 (x, C) =  (x, C),
 (x, C  D) =  (x, C)   (x, D),
where y is a new variable,
where y is a new variable .

Now, a classical knowledge base is dened by a pair K = hA, T i, where T is a nite
set of GCIs (the TBox ) and A is a nite set of assertions (the ABox ), whereas a defeasible
knowledge base is represented by a triple K = hA, T , Di, where additionally D is a nite
 D (an instance of a concept C is typically an instance of a concept
set of conditionals C 
9
D), with C, D  L .
Example 5.1. Consider again the penguin example. Just add a role P rey in the vocabulary,
where a role instantiation (a, b):P rey is read as a preys on b, and add also two more
concepts, i (insect) and f i (fish). An example of defeasible KB is
K = hA, T , Di
with
A = {a:p, b:b, (a, c):P rey, (b, c):P rey}
T = {p  b, i  f i}
 f, b  f, p  P rey.f i, b  P rey.i} .
D = {p 



The particular structure of a defeasible KB allows for the isolation of the pair hT , Di,
that we could call the conceptual system of the agent, from the information about the
individuals (formalized in A).
9. Since for the monotonic part we substitute the meta-linguistic conditionals C  D with formulae C  D,
we substitute also for the defeasible part of the knowledge base the conditionals C|D with conditional
 D, that we could call defeasible inclusion axioms.
formulae C 

447

fiCasini & Straccia

In what follows we are going to work with the information about concepts hT , Di rst,
exploiting the immediate analogy with the homonymous pair in the propositional setting,
and then we will address the case involving individuals as well. We show that by using
our method we overcome to the limits of classical rational closure, already presented for
ALC (Casini & Straccia, 2010), in a similar way as for the propositional case. Please note
that the procedure presented here is based on a slightly modied version of the procedure
for rational closure previously presented by Casini and Straccia (2010), i.e., on the one
presented by Britz et al. (2013). The latter is accompanied by a semantic characterization,
based on DL interpretations with a preferential relation dened over the individuals. Such a
semantic characterization of rational closure for ALC characterises all the steps of our procedure (the local applications of rational closure and the nal one). However, we still lack
a semantic characterization of the overall procedure, accounting also for the modularization
of the knowledge base done using the INs.
Step 1. Given a conceptual system K = hT , Di, check its preferential consistency, that is,
dene
T

= {C  D | C  D  T }

 D  D}
D = {C  D | C 

and construct a BIN NK from K. The process is the same as the one in Section 4,
just treat the concepts as propositions: nodes in NK represent the concepts appearing
as antecedents or consequents of the inclusion axioms in T and D (modulo logical
equivalence); for every node we add its complementary node, if not already present,
and we connect them by  ; every GCI C  D  T becomes a strict link C  D;
 D  D becomes a defeasible link C  D.
and every defeasible inclusion axiom C 
Moreover, consider the consequence relation T as the monotonic consequence relation
obtained adding the GCIs in T to , and add to the net the strict links representing
all the logical dependencies between nodes with respect to T 10 .
Step 2. Apply the reasoning procedure for BINs to NK (Section 3.2) to identify all the
 D to the conditional base
valid defeasible connections C  D, and add them as C 


K to obtain a new conditional base K = hT , D i.
Now, once we have augmented our knowledge base with new defeasible conditionals, we
proceed as follows.
  | C  D  T }.
Step 3. Dene D  = D   {C  D 
 D  D  } and let A  = {C | C  D  D  }.
Step 4. Dene D  = {C  D | C 
D


Step 5. Determine the exceptionality ranking of the conditionals in D  using the set of
the antecedents AD and the materialisations
in D  , where a concept C is exceptional
d
w.r.t. a set of conditionals D i |= D  C. The steps are the same of the propositional case (Step
3 in Section 2.2) by replacing the expression D |= C with the
d
expression |= D  C. In this way dene a ranking function r.
10. In order to create the strict part of the net it is possible to use the techniques introduced for the procedure
of classification of DL knowledge bases (Baader et al., 2003, ch. 9).

448

fiDefeasible Inheritance-Based Description Logics

Step 6. As Step 4.1, Section 2, verify if the KB is consistent, by checking the consistency
of D  . Then (as in Steps 4.2 - 4.3 in Section 2.2), dene the sets
 D  D  and r(C  D) = }
Te = {  C | C 





e
D = {C  D | C  D  D and r(C  D) < } .

e and ,
e with
Step 7. Dene (similarly to Step 5 in Section 2.2) the sets of concepts 

where
i =

l

e = {C |   C  T }

e = {0 , . . . , n } ,


D D
e and r(C
{C  D | C 




D)  i} .

As for Section 2, for every i , 0  i < n, |= i  i+1 .
Step 8. Now, we can dene the inference relation |K as
C|K D i |= C 

l

e  i  D,


e
where i is the rst {C}  -consistent
formula11 of the sequence h0 , . . . , n i. This is
the DL analogue as Step 6, Section 2.2.
Again, all steps require a decision procedure for the classical entailment relation |= of
DLs. We can redene the properties characterizing a rational consequence relation into the
framework of DLs.
We can show that
Proposition 5.1. |K is a rational consequence relation containing K.
That is, the analogous properties of the propositional rational consequence relation are
satised, namely:
(REF) C|K C
(LLE)

(CT)

C |K E

|=T C = D

D |K E

C  D |K E

(OR)
11. That is, 6|= C 

(RW)

C |K D

(CM)

C |K E
C |K E

D |K E

(RM)

C  D |K E
de
  i .

449

C |K D

|=T D  E

C |K E
C |K E

C |K D

C  D |K E
C |K D

C 6 |K E

C  E |K D

fiCasini & Straccia

Example 5.2. Consider example 5.1, where additionally we also add a role Born (Born(x, y)
is read as x is born from y), and a concept e (Egg). Consider
K = hT , Di ,
where
T

= {p  b, i  f i}

 P rey.f i  P rey., b  P rey.i  P rey., b  Born.e} .
D = {p 



p

b




Born.e

p



Born.e

b

P rey.f i  P rey.

P rey.i  P rey.



P rey.f i  P rey.

P rey.i  P rey.

Figure 12: Example 5.2
Now (Step 1), we build the correspondent net NK (figure 12), and we obtain (Step 2)
that
 Born.e} .
D  = D  {p 
Then we move to the rational closure. The pair hT , D  i is changed into (Step 3)
 , i  f i  ,
D  = { p  b 

 P rey.f i  P rey., b  P rey.i  P rey.,
p

 Born.e, p  Born.e} .
b


The set of the materialisations of D  is (Step 4)
D  = {p  b  , i  f i  , p  P rey.f i  P rey.,
b  P rey.i  P rey., b  Born.e, p  Born.e}
AD = {p  b, i  f i, p, b} .
We obtain now (Step 5) the exceptionality ranking of the conditionals:
 , i  f i  , p  P rey.f i  P rey.,
E0 = {p  b 


 P rey.i  P rey., b  Born.e, p  Born.e}
b


 , i  f i  , p  P rey.f i  P rey., p  Born.e}
E1 = {p  b 



 , i  f i  }
E2 = {p  b 

 , i  f i  } = E .
E3 = {p  b 
2


450

fiDefeasible Inheritance-Based Description Logics

From this we get the ranking values of every conditional in D  : namely,
 P rey.i  P rey.) = r(b  Born.e)
0 = r(b 

 P rey.f i  P rey.) = r(p  Born.e)
1 = r(p 

 ) = r(i  f i  ) .
 = r(p  b 


From this ranking, we obtain (Steps 6-7) a background theory
Te = {  (p  b),   (i  f i)} ,

e = {0 , 1 }, with
and a default-assumption set 

0 = (b  P rey.i  P rey.)  (b  Born.e) 

1

(p  P rey.f i  P rey.)  (p  Born.e)
= (p  P rey.f i  P rey.)  (p  Born.e)

to be used for the definition of the consequence relation |K (Step 8).
For example, we derive that typical penguins preys are fishes, i.e.,
p|K P rey.f i ,
and not insects, i.e.,
p|K P rey.i ,
and that also penguins are born from eggs, i.e.,
p|K Born.e ,
that would not be derivable from the rational closure, as presented by Casini and Straccia (2010).
Computational Complexity. From a computational complexity point of view, as deciding entailment in ALC is ExpTime-complete (Donini & Massacci, 2000) and, as for
Section 2.2, the number of entailment tests is polynomially bounded by the size of the
knowledge base, following exactly the same procedures dened for the propositional case,
we conclude that
Proposition 5.2. Deciding C|K D in ALC is an ExpTime-complete problem.
5.1 Closure Operation over Individuals
So far we left out the ABox, but we are going to consider it here. The procedure for the
ABox is built over the above procedure for the TBox, that is, we consider a knowledge base
hA, T , Di such that all the strict knowledge has already been moved into T , i.e., in D we
do not have axioms with  as ranking value (that is, they correspond to the sets Te and
e obtained using the procedure in the previous section). The basic idea of the following
D
procedure is to consider each individual named in the ABox as much typical as possible,
that is, to associate to it all the possible defeasible information that is consistent with the
rest of the knowledge base. In order to apply the defeasible information locally to each
451

fiCasini & Straccia

individual, we encode such information using the materialisations of the inclusion axioms,
e in the section
i.e., the set  = h1 , . . . , n i, s.t. |= i  i+1 for 1  i < n (the set 
12
above ). We want to be able to associate to each individual a  O (with O being the set
of the individuals named in the ABox) the strongest formula i that is consistent with the
e = hAD , T i, that we call
knowledge base. In such a way we dene a new knowledge base K
a ABox extension of the knowledge base hA, T , Di.
Definition 5.1 (ABox extension). Given a knowledge base K = hA, T , Di, a knowledge
base hAD , T i is an ABox extension of K = hA, T , Di iff
 hAD , T i is classically consistent and A  AD .
 AD \ A is composed of all the assertions a:C such that a  O and C = i for some i,
and for every h s.t. h < i,
hT , AD  {a:h }i |= 
The above denition identies the extensions of the original ABox A s.t. to every
individual is associated all the defeasible information that is consistent with the rest of the
knowledge base. Still, the main problem is that, since the individuals can be related to
each other through roles, the possibility of associating a default concept to an individual
can be inuenced by the default information associated to other individuals, as shown in
the following example.
 AR.A}
Example 5.3. Consider K = hA, Di, with A = {(a, b):R} and D = D0 = { 
(hence we have  = h0 i = hA  R.Ai). If we associate 0 to a, we obtain b:A and we
cannot associate 0 to b; on the other hand, if we apply 0 to b, we derive b:A and we are
not anymore able to associate 0 to a. Hence, we define two possible rational extensions of
K.


This implies that, given a knowledge base hA, T , Di, even if the closure of hT , Di is
always unique there is the possibility that we have more than one ABox extensions. A
simple procedure to obtain all the possible extensions of a knowledge base hA, T , Di, with
O the set of the individuals in named in A, is the following:
Definition 5.2 (Procedure for ABox extensions).
 Consider the set S of all the linear orders of the individuals in O;
 For each s = ha1 , . . . , am i in S do:
 Set j := 1
 Set AsD := A
 Repeat until j = m + 1:
 Find the first default i   such that hAsD  {aj :i }, T }i 6|=   .
 AsD := AsD  {aj :i }.
e and 
e must be done
12. Note that, given a conditional knowledge base, the procedure to determine Te , D
once for all.

452

fiDefeasible Inheritance-Based Description Logics

 j =j+1
 return hAsD , T i
where we indicate by AsD the ABox extension of A obtained using the sequence s.
Now, it can be shown that
Proposition 5.3. Given a linear order of the individuals in K, the above procedure determines an ABox extension of K. Vice-versa, every ABox extension of K corresponds to the
knowledge base generated by some linear order of the individuals in O.
e1 = hA{a:A  R.A}, i
For instance, related to Example 5.3, we obtain the extension K
e
from the order ha, bi, while K2 = hA  {b:A  R.A}, i is obtained from the order hb, ai.
Example 5.4. Refer to Example 5.1, and let K = {A, T , D}, where
A = {a:p, b:b, (a, c):P rey, (b, c):P rey}
T = {p  b, i  f i}
 f, b  P rey.i, p  f, p  P rey.f i}
D = {b 




From such a knowledge base we define a set  = {0 , 1 } with

0 = (b  f )  (b  P rey.i)  (p  f )  (p  P rey.f i)
1 = (p  f )  (p  P rey.f i) .
If we consider an order where a comes before b, then we associate 1 to a, and consequently c is presumed to be a fish and we are prevented in the association of 0 to b. If we
consider b before a, c is not a fish and we cannot apply 1 to a.
Now, if we x a priori a linear order s on the individuals, we can say that a:C is a
e |= a:C, where K
e is
defeasible consequence of K w.r.t. the order s, written K s a:C, i K
the ABox extension generated from K based on the order s.

For instance, related to Example 5.3 and order s1 = ha, bi, we may infer that K s1 a:A,
while with order s2 = hb, ai, we may infer that K s2 b:A.
The interesting point of such a consequence relation is that it still satises the properties
of a rational consequence relation in the following way.
453

fiCasini & Straccia

(REFDL )

hA, T , Di s a:C for every a:C  A

(LLEDL )

hA  {b:D}, T , Di s a:C
D=E
hA  {b:E}, T , Di s a:C

(RWDL )

hA, T , Di s a:C
CD
hA, T , Di s a:D

(CTDL )
(CMDL )

hA  {b:D}, T , Di s a:C
hA, T , Di s b:D
hA, T , Di s a:C
hA, T , Di s a:C
hA, T , Di s b:D
hA  {b:D}, T , Di s a:C

(ORDL )

hA  {b:D}, T , Di s a:C
hA  {b:E}, T , Di s a:C
hA  {b:D  E}, T , Di s a:C

(RMDL )

hA, T , Di s a:C
hA, T , Di 6s b:D
hA  {b:D}, T , Di s a:C

We can show that
Proposition 5.4. Given K and a linear order s of the individuals in K, the consequence
relation s satisfies the properties (REFDL )  (RMDL ).
Note that from a computational complexity point of view, as entailment w.r.t. a ALC TBox
is ExpTime-complete (Donini & Massacci, 2000) and the number of individuals in K is linearly bounded by |K|, we get immediately
Proposition 5.5. Deciding K s a:C in ALC is a ExpTime-complete problem.
In the presence of multiple ABox extensions, we can also dene the inference relation
, a more conservative inference relation independent from any order on the individuals,
that corresponds to the intersection of all the inference relations s modelling a rational
extension.
=

\

{s | s is a linear order on the elements of O}

However, there is the possibility that we lose the property of rational monotonicity, as
shown in the following example.
Example 5.5. Consider the knowledge base hA, Di s.t. A = {(a, b):R} and D = D0  D1 ,
 A  R.A,   B} and D = {A  B, R.A  B} (where D and D
with D0 = { 
1
0
1



are the sets of the conditionals of rank 0 and of the conditionals of rank 1, respectively).
We can define two sequences on the individuals, s = ha, bi and s = hb, ai, each of them


defining a different rational extension (s and s ), and let =s  s . We have that
B
hA, Di  a:B, since in both the extensions a:B holds (in s because of the axiom  


s
s

a:A.
6
and in  for the axiom r.A  B) while we have hA, Di 6 a:A, since hA, Di 
However, hA  {a:A}, Di 6 a:B, since hA  {a:A}, Di 6s a:B.
454

fiDefeasible Inheritance-Based Description Logics

We have no increase in the computational complexity of the decision procedure: assuming that the number of individuals named in the ABox is n, we have to perform a s -test
for each possible sequences s dened on the n individuals. That is, in the worst case we
k
need to do n! s tests, each of which can be done in time O(2|K| ) for some k. Now, it can
2
be shown that13 n! < 2n and, thus, the decision problem for  remains in ExpTime.
Proposition 5.6. Deciding K  a:C in ALC is a ExpTime-complete problem.
Notwithstanding, we conjecture that in many (probably most) of the real-world cases, a
knowledge base would have a single rational ABox extension, and in such cases (RMDL ) is
still valid. To check whether a knowledge base hA, T , Di has a single rational ABox extension, it is sucient to associate to each individual in O the strongest i modulo consistency
w.r.t hA, T , Di, exactly as in the procedure in Denition 5.2, but doing the consistency
check of aj :i w.r.t. the original A instead that w.r.t. AsD . In the end, check whether
hAsD , T i is consistent; in such a case we have obtained the only rational ABox extension of
hA, T , Di.
The following is a knowledge base with a unique ABox extension.
Example 5.6. Consider the KB in Example 5.4, where (b, c):P rey is replaced with (b, d):P rey.
Then, whatever is the order on the individuals, we obtain the following association between
the default formulae and the individuals: a:1 , b:0 , c:0 , and d:0 . Using the information
in these defaults, we obtain an unique default-assumption extension.

A semantic characterization of  and s , making use of preferential DL models, is
presented by Casini et al. (2013).
Now lets briey consider some heuristics that are useful in case we want to present to
the system specic ABox queries. Assume we want to know if a particular individual a
presumably falls under a concept C, and we want to draw the safest possible conclusion.
In the presence of multiple acceptable extensions, the classical solution is to use a skeptical
approach, i.e., to use the inference relation , corresponding to the intersection of all the
inference relations associated to each possible ordering s of the individuals appearing in A.
As we have seen above, in case of multiple rational extensions the computational complexity of the  decision problem does not rise w.r.t the classical ALC decision problem.
Moreover, in case of multiple extensions, the amount of defeasible information associable to
an individual a can be inuenced only by the individuals related to it by means of a role: it
is immediate to see that if there is no role-connection in the ABox between two individuals
a and b, then the information that is associated to a does not inuence at all the amount
of defeasible information that we can associate to b, and the other way around. Hence,
we can ease the decisions w.r.t. the ABox introducing the notion of cluster, i.e., a set of
individuals named in the ABox that are linked by means of a sequence of role connections.
To do so, given an ABox A, we indicate with Q the symmetric and transitive
S closure of all
the roles in our vocabulary, i.e., the symmetric and transitive closure of R.
Definition
5.3 (Cluster). Define Q as the reflexive, symmetric and transitive closure of
S
R. Given an individual a  O, we call the cluster of a the set [a] of the individuals

13. This can be shown by induction on n, or see e.g.http://lifecs.likai.org/2012/06/better-upper-bound-forfactorial.html.

455

fiCasini & Straccia

connected to a through Q:
[a] = {b  O | Q(a, b)} .
Hence, in order to know what we can presumably conclude about a, it is sucient to
determine s w.r.t. each sequence s of individuals in [a]. Let A[a] be the ABox obtained restricting A to the statements containing individuals in [a]; the query a:C is clearly decidable
using only A[a] .
Proposition 5.7. hA, T , Di  a:C iff hA[a] , T , Di s a:C for every ordering s of the
individuals in A[a] .
If we have a query about an individual a s.t. a is not named in the ABox (a 
/ O), we
do not have any constraints dened in the ABox about a, i.e., we only know a:; hence, for
each individual not appearing in the ABox, we can associate with it the strongest default
concept consistent with T , that is 0 : for any a s.t. a 
/ O, we can derive that presumably
a:C holds i hAa , T i |= a:C, where Aa = A  {a:0 }.

6. Comparison with Related Work
Between non-monotonic logics, the so-called preferential approach can be distinguished
from the other various proposals (as Reiters defaults, modal approaches, defeasible inheritance. . . ) mainly due its logical properties, since the former approach is committed to the
satisfaction of some desirable structural properties of the consequence relation (see Section
2.2). On the other hand, considering them from the point of view of the inferential capacity
the preferential approach often results weaker than other proposals, since often there are
desirable, intuitive conclusions that we cannot derive (see Remark 1).
In our proposal we have tried to combine the classical rational closure with inheritance
networks in order to overcome the inferential limits without prejudicing the logical properties
of the consequence relation.
In Section 3 we also present an alternative way to reason about defeasible inheritance.
Despite our proposal has been presented mainly to integrate it with propositional language
and rational closure, it results an interesting approach per se, and in Appendix A we
compare it with Hortys classical skeptical extension (Horty, 1994, sect. 2-3) and Sandewalls
landmark examples (Sandewall, 2010).
As indicated in the introduction, there have been many papers aimed at the implementation of non-monotonic reasoning into the DL formalisms. For most of such proposals the
comparison with our approach has to be done considering the dierent non-monotonic formalisms, independently from the DL-environment. So we refer to Makinsons work (1994)
for a comparison between the various non-monotonic approaches.
In the last years the main proposals for the implementation of nonmonotonic reasoning
in DLs have been connected to two approaches: the preferential one and circumscription.
In the preferential approach, the work by Britz and al. (Britz et al., 2008; Britz, Meyer,
& Varzinczak, 2011) on preferential DL semantics is strongly connected to our approach,
and one of the results has been the semantic characterization of rational closure cited above
(Britz et al., 2013).
Still very close to our approach is the work by Giordano et al. (2012b), that is based too
on a preferential approach. The conclusions that we can derive using the logic ALC+Tmin
456

fiDefeasible Inheritance-Based Description Logics

are intuitive, but the complexity of the decision problem for the ABox is co-NExpNP (Giordano et al., 2012b, Thm. 13), and the procedure cannot be reduced to classical entailment.
Among the proposals based on circumscription, the work by Bonatti et al. (2009) is
particularly representative. From the point of view of the quality of the inferences, in such
a proposal it results more dicult w.r.t. the preferential approach to draw the expected
conclusions. For example, assume that our knowledge base contains the information that
mammals typically live on land, but that whales are abnormal mammals that do not live
on the land, and the ABox contains the information a:M ammal  W hale. Not knowing
anything else about the individual a, we would like our reasoning system to reason on the
assumption that we are dealing with a typical mammal (since, moreover, it is specied that
a is not a whale) and hence being able to derive that a lives on the land. However, using
circumscription, the conclusions we can draw changes w.r.t. which concepts the user decides
to keep fixed or varying (a non-trivial choice), and the results can be that we are not able
to derive a:Habitat.Land, that we are able to derive it, or we can even derive that whales
do not exist (Bonatti et al., 2009, sect. 2.1). In our proposal instead, we can formalize the
problem with a knowledge base hA, T , Di with A = {a:M ammal} (we do not need to specify
that it is not a whale), T = {W hale  M ammal, W hale  Habitat.Land} and D =
 Habitat.Land}; without needing any kind of choice from the user, the system
{M ammal 
can derive automatically a:Habitat.Land. Moreover, we have seen that the computational
cost of our procedure involving an ABox is exponential, while in the circumscription case, for
languages analogous to ALC, the complexity of the instance problem is co-NExpNP (Bonatti
et al., 2009, sect. 4.1.1). Some of the issues just discussed have been addressed and solved
by Bonatti et al. (2010, 2011a), but only for circumscriptive systems that are specically
built for low-complexity DLs such as EL.
On the other hand, procedures based on circumscription are able to derive defeasible
information about individuals that are implicit in the ABox, that is, they can, for exam D that presumably a:R.D. Our procedure involving
ple, conclude from a:R.C and C 
ABoxes is not able to make such a kind of derivation, since we can add defeasible information
only to the individuals named in the ABox. We are working on a further renement of the
procedure in order to deal also with the implicit individuals; a rst attempt to take under
consideration also such individuals has been proposed in a previous publications (Casini &
Straccia, 2010, pp. 9-10), adding a completion procedure for the ABox in order to explicitly
name in the ABox the implicit individuals, but such a procedure needs to be rened.
Among the proposals regarding the introduction of probabilistic reasoning in DLs,
Lukasiewicz (2008) presents a combination of nonmonotonic and probabilistic reasoning.
The nonmonotonic part is based on the preferential approach, and he too presents a construction that augments the inferential power of rational closure. Let us consider his proposal by eliminating the probabilistic part, i.e., considering only conditionals associated to
probability 1 (conditionals (|)[1, 1] in his notation), since they convey the same meaning
as our defeasible conditionals. His procedure seems to give back the same results as ours in
most of the cases, but the two proposals dier in the general approach: he proceeds with a
renement of the ranking structure, while we use a renement of the content of the knowledge base. In fact, the behaviour of the two can dier. Consider for example a knowledge
 b, a  d, b  c, c  e, d  e} (in Lukasiewiczs notation it would
base h, Di, with D = {a 




correspond to a knowledge base with an empty TBox and a set P containing the conditionals
457

fiCasini & Straccia

(b|a)[1, 1], . . . ).14 In our construction we can derive a|c, since there is simply a duct ha, b, ci
from a to c, while in Lukasiewiczs approach we cannot, since we have to consider what follows from all the three preferred subset of the knowledge base that are consistent with
 b, a  d, b  c, c  e}, {a  b, a  d, b  c, d  e}, {a  b, a  d, c  e, d  e}),
a (that are {a 











and a|c does not follow from the latter.

7. Conclusions
By combining the classical rational closure with ideas from defeasible inheritance networks,
we have proposed a new rational consequence relation that overcomes some limits of both the
formalisms. By doing so, we have extended the defeasible inference capabilities by allowing
an atypical class still to inherit some properties from its superclass while maintaining the
desired logical properties of rational closure. The table below summarizes the structural
properties satised by the systems taken under consideration:15

REF
CT
CM
LE
RW
OR
RM

Horty





IN






BIN







PL








DL








As we can see, our proposals for defeasible inheritance-based propositional logic and
Description Logics still satisfy all axioms of classical rational closure. Another feature is
that our method does uniquely require the existence of a decision procedure of classical
entailment and, thus, can be implemented on top of exiting propositional SAT solvers and
DL reasoners. Since we have introduced a procedure that is interesting also from the point
of view of inheritance nets, we have presented the more comprehensive procedure for logical
knowledge bases making use of the nets formalism; notwithstanding, we are condent that
the procedure can be reformulated avoiding the shift from one formalism to another.
The procedure presented for ALC can be straightly extended to languages more expressive than ALC; on the other hand, at present the procedure needs a language that is
closed under propositional connectives, and hence we need to augment the expressivity of
the language in order to apply it to less expressive DL languages as EL, forcing in this way
an increase in the computational costs w.r.t. the classical decision problem.
Hence, looking for an adaptation of the procedure appropriate for dealing with tractable,
less expressive DLs is one of the main open problems of the present proposal, together with
a more proper semantic characterization of the procedure and the ability of reasoning in a
defeasible way about implicit individuals, as discussed in the previous section.
14. The example corresponds to the structure of Example.A.4 in Appendix A, just eliminating the link at
the center of the figure.
15. IN, BIN, PL, DL stand for our proposals for INs, Boolean INs, propositional logic and DLs, respectively.

458

fiDefeasible Inheritance-Based Description Logics

Appendix A. Examples
We are going to validate our decision procedures for inheritance nets against some signicant
examples proposed by Horty (1994) and Sandewall (2010). We shall use BINs, but, in order
to simplify the graphical representation, we shall also use 6 as a macro, as explained in
Section 3.2. As a side eect, we obtain an analogue behaviour for the propositional and DL
cases too.
Example A.1 (Horty, 1994, ex. 12 ). Consider the net in Figure 13. Horty claims that the
desirable conclusion should be a|p, since In the environment of mixed nets [. . . ] certain
kinds of compound defeasible paths can legitimately be thought to carry immediate information - namely, those paths consisting of a single defeasible link followed by a strict end
segment, of any length (Horty, 1994, p. 143). That corresponds to the condition of (RW ),
that, as we have seen in Section 3.1.2, our procedure satisfies.
r
s

p

a

t

Figure 13: Example A.1
Indeed, we translate the net into the KB K = h, i, with  = {a  s, s  t, r  p}
and  = {s  r, t  p}. We have a,p = , a,p |= s, and a,p |= a. So the only
implication in a,p with ranking grater than 0 is s  r, and, since s  r  a  p, we have
a|K p.
Example A.2 (Horty, 1994, ex. 18 ). Consider the net in Figure 14. In this example Horty
claims that we should not prefer the negative path ha, p, si over the positive path ha, r, si,
since the negative link a 6 q nullifies the path from p to r. Our procedure satisfies such a
claim.
p
a

q

s

r

Figure 14: Example A.2
Indeed, we translate the net into the KB K = h, i, with  =  and  = {a  p, a 
r, p  q, q  r, r  s, a  q, p  s}. We have a,s = , a,s  p, and a,p  a.
459

fiCasini & Straccia

Therefore, we have E1 = {a  p, a  r, a  q, p  q, p  s}. Now, E1  a, and a is the
only node of rank 2, with E2 = {a  p, a  r, a  q}. So we conclude neither a|s nor
a|s.
Example A.3 (Sandewall, 2010, ex. B.1, Double Diamond). Consider the net N = {S, U }
defined as (see Figure 15)
S = {s  s, r  r}
U

= {a  t, a  p, t  s, p  s, s  r, p  q, q  r}
s
r

t



s

r

q

a
p

Figure 15: Double diamond.
The net N is translated in the knowledge base K = {, } with  = {} and  = {a 
t, a  p, t  s, p  s, s  r, p  q, q  r}.
Using our method, from this net we derive neither a|r, nor a|r, as it should be.
However, we can derive a|q, which is a desirable result that is not derivable with Sandewalls
approach.
Example A.4 (Sandewall, 2010, ex. B.2, Simonets Scenario). Consider the net N = {S, U }
defined as (Figure 16)
S = {e  e}
U = {a  b, a  d, b  c, c  e, d  c, d  e} .
c
e

b


a

e
d

Figure 16: Simonets scenario.
460

fiDefeasible Inheritance-Based Description Logics

The net N is translated in the knowledge base K = {, } with  = {} and  = {a 
b, a  d, b  c, c  e, d  c, d  e}.
Using our method, from this net we derive a|e, as it should be, while Sandewall cannot
derive it. Moreover, he derives neither a|c nor b|e.
Example A.5 (Sandewall, 2010, ex. B.3, On-Path vs. O-Path Preemption). Consider the
net N = {S, U } defined as (see Figure 17)
S = {wa 6 ga}
U

= {c  re, c  ce, re  e, ce  e, e  ga, re  wa} .
e
ce

c

ga

wa
re

Figure 17: On-Path vs O-Path.
The net N is translated in the knowledge base K = {, } with  = {wa  ga} and
 = {c  re, c  ce, re  e, ce  e, e  ga, re  wa}.
The connection c  wa is valid only if we use a form of off-path preemption, while with
on-path preemptions it is not derivable. In our setting, we derive c|wa: even if we cannot
consider our method a form of preemption (at least explicitly), as said in Section 3.1.5 our
method gives back results that are analogous to those of off-path preemption.
The following examples use also conjunctions, so we are going to use BINs.
Example A.6 (Sandewall, 2010, ex. B.4, Juvenile Oender). The original Juvenile offender example is represented by the following net (see Figure 18) N = {S, U }, with
S = {b  g, b  m, p  p, m, g  m  g}
U

= {g  p, m  p} ,

where p is read as to be punished, g as guilty, m as is minor, b is Billy. We want
to express that m has the priority on g, and so that b N w. Since in our nets it is
possible to express conjunctions, we can solve the problem adding the link m  g  p and
m, g  m  g.
The net is translated in the knowledge base K = {, } with  = {b  g, b  m} and
 = {g  p, m  p, m  g  p}. From this knowledge base we derive b|p, as expected.
Example A.7 (Sandewall, 2010, ex. B.5, Campus Residence Scenario). As in example A.6,
in the Campus residence example there is the necessity to include priorities. We can solve
461

fiCasini & Straccia

m
mg

b



p

g

p

Figure 18: Juvenile oender.
the problem by inserting conjunctions. Indeed, the net N = {S, U } is composed by (see
Figure 19)
S = {t  ma, t  e, t  m, w 6 n, ma, e  ma  e}
U = {ma  e  w, m  n} ,
where ma is read as is married, e as employed, w as lives in west apartments, m as
male, n as lives in northern apartments, t is Tom. We want to express that ma  e has
the priority on m, and so that t  w results valid. to do so, we add the links mmae  w,
and m, ma  e  m  ma  e.
ma
ma  e
w

t

e

ma  e  m

n
m

Figure 19: Campus residence scenario.
The net is translated in the knowledge base K = {, } with  = {t  ma, t  e, t 
m, w  n} and  = {ma  e  w, m  n, m  ma  e  w}. From this knowledge base we
derive t|w, as expected.
We treat the last example as a propositional problem. Just to have a simpler net from
the graphical point of view we do not put the negation nodes that are useless for the
resolution, and we use a three-place conjunction link, just as a macro for the construction
of the conjunction of three nodes.
462

fiDefeasible Inheritance-Based Description Logics

Example A.8 (Sandewall, 2010, ex. B.6, Good Math Student Scenario). The knowledge
base K = {T , D} is composed by (see Figure 20)
T

= {t  gs, t  f m, t  mb, aa  ag}

D = {mb|ag, f m  ag|mm, mm  mb  gs|aa, f m|pm} ,

gs

mb
mm  mb  gs

t

ag
aa

f m  ag
mm
fm
pm

Figure 20: Good math student.
Sandewall identifies the following candidates for valid conclusions:
t|ag t|aa t|f m  ag
t|mm t|mm  mb t|mm  mb  gs

t|pm .

We cannot conclude any of the conditionals above. The point is that the net is highly
interconnected, especially by strict links, so that all the nodes have ranking 0, except for t
and mm  mb  gs that have ranking 1. Therefore, any of the conclusions above, with t as
premise, cannot be obtained.

Appendix B. Proofs
Proposition 3.1. Consider a net N = hS, i and translate it into a set of propositional
implications . The following properties hold:
1. If N is a consistent net, there is a valid strict positive (resp., negative) path hp, , qi
from p to q, that is N
p  q (resp., N
p 6 q), iff   p  q (resp.,   p  q).
2. N is inconsistent iff   p for some p  A .
463

fiCasini & Straccia

3. Deciding strict consequence can be done in polynomial time.
Proof. First, it is easy to prove by induction on the length of the paths that, if there is a
positive (resp., negative) path in S from p to q, then   p  q (resp.,   p  q). Hence
we have:
1a) If N is a consistent net and there is a valid strict positive (negative) path (p, , q)
from p to q, then   p  q (  p  q).
Moreover, if N is inconsistent, then we can conclude, for some p, q in it, p  q and
p 6 q, and so we have   p  q and   p  q, that is,   p. So we have one half of
the second statement.
2a) If  6 p for every p  A , then N is consistent.
Now we move to show the other halves of the statements.
1b) If N is a consistent net and   p  q (resp.,   p  q), then there is a valid strict
positive (resp., negative) path (p, , q) from p to q.
In order to model the classical consequence relation , we use the propositional resolution method. We use the symbol R to indicate the inferences in the resolution
method.
Every element of  has the forms p  q or p  q. Such implications correspond, in
the clause form, respectively to the clauses (i.e., sets of literals) {p, q} and {p, q}.
Call  the set of the clauses corresponding to . For example, if we assume that
 R {p, q} (that is,   p  q), we have that the set of clauses , {p}, {q} resolves
into the empty set (that is, , (p  q)  ).
1. Positive case (N
p  q): Assume   p  q for some p, q  PN . In order to
apply the refutational approach, p  q has to be negated, and, since (p  q)
is equivalent to p  q, we introduce the clauses {p}, {q}. So, in the resolution
approach   p  q is translated into , {p}, {q} R . We have also assumed
that  is consistent, and hence we have that  6R . Since the set  is composed
only of pairs of literals (of form {p, q} or {p, q}), every reduction step between
them gives back again a pair of literals (for example, from {p, q} and {q, r},
we obtain {p, r}). Therefore, in order to obtain the empty set we need to use
both {p} and {q} in the refutation procedure. So, the clause {q} must be
eliminated using a clause containing q. Such a clause must necessarily have the
form {ri , q} for some ri , and we obtain a new clause {ri }. Again, {ri } can
be eliminated only by a clause of form {rj , ri }, obtaining a clause {rj }. Since
the set  is nite, such a procedure has to terminate, and it can only be done if
we obtain a clause {p}, that can be resolved by {p}. That is, there has to be in
 a clause {p, rl }, for some rl , s.t. {rl } appears in the reduction procedure.
Now, the clauses of  used in the reduction process correspond to a chain of
links in the net S: p  rl , . . . , ri  q, that dene a valid path (p, , q) in S.
2. Negative case (N
p 6 q): assume   p  q for some p, q  PS . p  q has
to be negated and it is translated into the clauses {p}, {q}. {q} can be combined
464

fiDefeasible Inheritance-Based Description Logics

with a clause of form {q, ri } (that represents q  ri , that, in turn, represents
a link q 6 ri ) (case 1), or with a clause of form {q, ri } (i.e., q  ri , that, in
turn, is q  ri ) (case 2).
Case 1. We obtain the clause {ri }, and the procedure is the same of the positive
case. The clauses used in the reduction process correspond to a strict negative path of form: p  rl , . . . , rj  ri , ri 6 q.
Case 2. We obtain the clause {ri }, and we would have combine it with a clause of
form {ri , rj }, or of form {ri , rj }. In the former case we move to case
1, ending with a strict negative path p  rh , . . . , rl  rj , rj 6 ri , ri  q.
In the latter case we have a new clause {rj }, and we are again in case
2; however, such a procedure has to terminate, and, in order to terminate,
such a reduction procedure has at some point to move into the case 1. The
clauses used in the reduction procedure correspond to a path of form p 
ri , . . . , rj  rk , rk 6 rl , rl  rm , . . . , rn  q, where the link 6 corresponds
to the shift to the case 1.
2b) Automatically, we have also that if N is consistent, then  6 p for every p  A .
Otherwise, we would have   p  q and   p  q for some nodes p and q, that
would imply, by the procedure above, the inconsistency of N .
3) About the third point, consider that strict links can be encoded as 2-CNF formulae,
also called Krom formulae, and the propositional 2-SAT problem is in P .

Proposition 3.2. Consider a net N . For every connection p|N q (resp., p|N q) validated
by our procedure, there is a corresponding positive (resp., negative) potential path from p to
q in the net N .
b p,q . Our procedure states that p| q i 
b p,q    p  q (and
Proof. Dene the set 
N
b p,q    p  q). Following a procedure analogous to the one of the proof of
p|N q i 
proposition 3.1, we can show that the derivation of such implications is connected to the
presence of positive (negative) potential paths in the net.
Proposition 3.3.



satisfies (REF ), (CT ) and (CM ).

To prove this proposition we need rst to prove the following lemma.
 p  q (  {, 6}). Call  the set
Lemma B.1. Consider a net N = hS, U i s.t. N
of material implications corresponding to the links in S, and  the consequence relation
obtained adding to  the formulae in  as extra-axioms. Consider the net N  obtained
N
adding the link p  q in N . Then, for every pair of nodes r, s in N , we have that 
r,s and

N


r,s are equivalent w.r.t.  .

Proof. The two nets contain the same nodes. Given two nodes r and s, we have two possible
N  , we have C N  = C N  , and consequently
N  or p  q  C N  . If p  q 
/ Cr,s
cases: p  q 
/ Cr,s
r,s
r,s
r,s
 N  . If p  q  C N  , we have that C N   C N  , and consequently C N  C N , and the
N = 

r,s
p,q
r,s
r,s
r,s
r,s
r,s
465

fiCasini & Straccia





N and C N on one hand and C N and C N
correspondent sets of courses in the two nets (Cp,q
p,q
r,s
r,s
on the other) contain exactly the same nodes and the same links, apart, possibly, from p  q.
N
N
N
That corresponds to saying that N
p,q and p,q on one hand, and r,s and r,s on the other
contain exactly the same implications, apart, possibly, from p  lq (where lq  {q, q}),
and exactly the same set of antecedents.
 p  q, we have 
N
N
N
Since N
p,q  p  lq , and consequently p,q  p  lq . So, p,q


N
N
N
and N
p,q are  -equivalent, and then also r,s and r,s are  -equivalent. So, since r,s

N
and r,s are  -equivalent and contain the same set of antecedents, they generate the same
 N  are equivalent w.r.t.  .
 N and 
ranking, that is, 
r,s
r,s

Now we can prove Proposition 3.3.
Proof. The satisfaction of (REF ) is trivial, since every direct link is trivially valid.
(CT ): assume N  p  q and N , p  q  r  s. We call N  the net obtained adding p  q

N
in N . N   r  s means that 
r,s  r  ls (ls  {s, s}). By the lemma B.1 we have that
 N  r  ls , that is, N  r  s.
 N  are equivalent w.r.t.  , so we have also 
 N and 

r,s
r,s
r,s


(CM ): assume N
p  q and N
r  s. We call N  the net obtained adding p  q in
 N  r  ls . By the lemma B.1 we have that 
 N and 
 N
N . N  r  s means that 
r,s
r,s
r,s

 r  s.
N
are equivalent w.r.t.  , so we have also 

r

l
,
that
is,
N
,
p

q
s
r,s 
Proposition 3.5.



satisfies (LE), (RW ), and (Sup).

Proof. The proofs are immediate, considering our procedure and the fact that the implications corresponding to strict links are always present in each decision procedure.
Proposition 3.6 A net N is consistent iff we do not have a node p with r(p) = , that is,
we do not conclude both N  p  q and N  p 6 q for any pair p, q.
It is proved combining the following two lemmas.
Lemma B.2. Given a net N , and two nodes p and q in it, we can conclude both p|N q
and p|N q iff r(p) = .
Proof. From left to right. It is immediate from the denition of the ranking procedure: if
r(p) 6= , then the set of implications with at least the same ranking as p do not imply p,
and so they cannot imply both p  q and p  q for any q.
From right to left. If r(p) = , we have a set E 16 of implications (with p between
their antecedents) such that E  p. That implies E  p  q and E  p  q for
whichever q, that is, p|N q and p 6 |N q.
Lemma B.3. Every node with ranking  in a set of courses C has the same ranking value
in every set of courses extending C.
Proof. It is immediate from the monotony of the consequence relations N .
16. E is the set of -ranked defaults.

466

fiDefeasible Inheritance-Based Description Logics

From these lemmas we conclude that if a node p has innite ranking in a net, then the net is
inconsistent (p|N q and p|N q for some p and q), and, conversely, if a net is inconsistent,
then there is a node p with innite ranking.
Proposition 3.9

BIN

satisfies (REF ), (CM ), and (CT ).

Proof. The proof retraces the one for proposition 3.3.
Proposition 3.10

BIN

satisfies (LE), (RW ), and (Sup).

Proof. The proof retraces the one for proposition 3.5.
Proposition 3.11

BIN

satisfies (OR) and (AN D).

Proof. (OR): we have N BIN p  t and N BIN q  t, and we have p, q  s  S. Assume
 =. The case with  =6 is analogous.
 p,t  p  t and 
 q,t  q  t.
We have N BIN p  t and N BIN q  t, that is, 
Since N BIN p  t and N BIN q  t, by proposition 3.2 we have at least a duct between
p and t and one between q and t. So, since p, q  s, there is a duct from s to t. Moreover,
since there is at least a duct between s and t and p  s and q  s, every duct connecting
s to t allows for a duct connecting p to t and q to t. Hence, s,t  p,t and s,t  q,t
holds.
On the other hand, we have that, since p, q  s, s is connected to t by all the connections moving from p and from q. So, we have that p,t  s,t and q,t  s,t . Hence,
p,t = q,t = s,t holds and the ranking functions rs,t , rp,t , and rq,t are the same as they
work with the same sets of material implications.
At the propositional level, we have that  s  (p  q) and either rs,t (p)  rs,t (q) or
rs,t (q)  rs,t (p). Assume the former (the same reasoning applies in the other case). If
 q,t  
 p,t . Moreover, the least set in the exceptionality order
rs,t (p)  rs,t (q) we have that 
negating p does negate also q, and so is the least set in the exceptionality order negating
 p,t = 
 s,t . So, 
 s,t  p  t, and, since 
 q,t  
 p,t ,
t, that is, rs,t (t) = rs,t (p), and 


we have also s,t  q  t; hence by classical reasoning we obtain s,t  (p  q)  t,
 s,t  s  t. Eventually, N BIN s  t.
i.e., 
(AN D): we have N BIN p  q and N BIN p  s, and we have s, q  t  S. Every
duct connecting p to q and p to s are part of a duct connecting p to t by the addiction
of s, q  t, while every duct connecting p to t is part of a duct connecting p to q (resp.,
p to s) by the addiction of t  q (resp., t  s). So, p,q = p,s = p,t , and we obtain
N BIN p  t.
Proposition 3.12 A BIN N is consistent iff we do not have any node p with r(p) = ,
that is, we cannot conclude both p  q and p 6 q for any pair p, q.
Proof. The proof is similar to the one for proposition 3.6.
Proposition 4.1. |K is a rational consequence relation containing K.
Proof. |K has been obtained as the rational closure of K , so it is a rational consequence
relation. Moreover, R(K ) contains K , and, since K  K , it contains K too.
467

fiCasini & Straccia

Proposition 4.2. Given a conditional base K, |K  iff |  R(K).
Proof. It is sucient to prove that, given a conditional base K = hT , U i, and obtained its
extension K = hT , U  i (Steps 1-3), K is preferentially consistent i the conditional base K
is preferentially consistent too.
From right to left the proof is immediate, since K  K . From left to right, if K is
6 . Given that every conditional added in K corresponds
consistent that means that T D 
to an implication that is classically derivable from a subset of T  D, we have that T 
D   C(T  D) (where C is the classical closure operation associated to ). So we have
C(T  D  ) = C(T  D). Then,  
/ C(K ), and K is a consistent knowledge base too.
Proposition 5.1 |K is a rational consequence relation containing K.
Proof. It is sucient to show (1) that every inclusion axiom in T and in D is valid in |K ,
and (2) that |K satises the properties characterizing a rational consequence relation.
(1) By construction, if C  D  T , then   C  D  Te (that is, modulo logical
equivalence, T  Te ). Assume C|D  D. Then we have either r(C) = r(C|D) = ,
or r(C) = r(C|D)= i, for some i < . In the rst case we have   C  Te ,
e  D, which implies C| D. In the second case, we have that
and so  {C}  
K
 i  C  D, with i being the default-assumption associated to the premise C.
e  {i }  D, that is, C| D.
Hence we have  {C}  
K

(2) The consequence relation |K satises the properties of a rational consequence relation.
(REF ) is obviously satised, as (LLE) is. For (RW ), assume we have C|K D. That
e  {i }  D, that, given
means that for the rst C-consistent i in ,  {C}  
e
e D  E, implies  {C}    {i }  E, i.e., C|K E.

e  i  E, where i is the rst C 
(CT ) C  D|K E corresponds to  {C  D}  
D-consistent formula in . Analogously, C|K D means that for the rst Ce  {j }  D. Since  C  D  C, we have that
consistent j in ,  {C}  
j  i, that is,  j  i . Hence, we have that  {C  D}  T  {j }  E and
e  {j }  D, and, since  satises (CT ),  {C}  
e  {j }  E, that
 {C}  
is, C|K E.
e  {i }  E.
(CM ) C|K E means that for the rst C-consistent i in ,  {C}  
e  {i }  D for the same i . Hence, i
Analogously, C|K D means that  {C}  
e
is consistent with CD, and, by the monotony of , we have  {CD}{
i} 
E, that is, C  D|K E.
e  {i }  E.
(OR) C|K E means that for the rst C-consistent i in ,  {C}  
e
Analogously, D|K E means that  {D}    {j }  E for the rst D-consistent
j in . We have three options: j = i, j < i or i < j. In the rst case,
the default-assumption associated with C  D is i , and, since  satises OR,
 {C  D}  T  {i }  E, that is, C  D|K E. If j < i, we have that j  i , and
e
that j is the rst CD-consistent default in . Hence we have  {D}{
j} 
e
E, and, by monotonicity,  {C}    {j }  E. Since  satises OR, we have
e  {j }  E, that is, C  D| E.
 {C  D}  
K
468

fiDefeasible Inheritance-Based Description Logics

e
(RM ) C 6 |K E corresponds to 6 {C} {
i }  E, where i is the rst C-consistent
e  {i }, and so i
formula in . This means that E is consistent with {C}  
e
is the rst C  E-consistent formula in . Since  {C}    {i }  D, by the
e  {i }  D, that is, C  E| D.
monotonicity of  we have  {C  E}  
K
Proposition 5.3 Given a linear order of the individuals in K, our procedure determines an
ABox extension of K. Vice-versa, every ABox extension of K corresponds to the knowledge
base generated by some linear order of the individuals in O.
Proof. The rst statement is quite immediate. For the second statement, assume that there
is a rational extension hA , T i of hA, T , Di that cannot be generated by any sequence s of
the elements of O. A associates to every individual x a default concept from , that we
indicate as x .
Now, consider a generic rational extension hAD , T i of hA, T , Di that can be generated
using a sequence of elements of O. The following procedure allows to dene a sequence s
of the elements of O s.t. hAD , T i can be generated using s, i.e., hAD , T i = hAsD , T i.
Take each element of O and associate to it the strongest default concept in  consistent
with the knowledge base hA, T i (call it  x ). Look for an individual x s.t. x =  x , and
consider x the rst element of the sequence s. Update A with x:x , and repeat the procedure, until every individual has been associated to a default formula. With this procedure
we can generate a sequence over the dominion of the individuals that generates hAD , T i
from hA, T , Di.
Since there is no sequence s that can generate hA , T i, the above procedure has to fail,
that is, at some point it will not be possible to associate to any x a default  x s.t. x =  x .
That means that, for all the remaining x, x 6=  x ; for each such x, either x   x or
 x  x . The rst case is not possible, since hA , T i would be inconsistent ( x has to be a
maximally consistent default). Hence  x  x and x 6=  x for all the remaining x. In such
a case, hA , T i would not be a rational extension of hA, T , Di, since we could have another
consistent model with stronger defaults associated to some individuals.
Proposition 5.4 Given K and a linear order s of the individuals in K, the consequence
relation s satisfies the properties (REFDL )  (RMDL ).
Proof. For REFDL , LLEDL and RWDL the proof is quite immediate. For CTDL and
CMDL , assume hA, T , Di s b:D, that is hAsD , T i  b:D. Hence, b:D is consistent with
hAsD , T i; this implies that for the rst individual in the sequence s, let it be a, and for
every i  , a:i is consistent with hA, T i i it is consistent with hA  {b:D}, T i, and the
procedure associates to a the same default formula either we start with A or with A{b:D}.
The same happens for all the following individuals in the sequence s. So we have that
hAsD  {b:D}, T i = h(A  {b:D})sD , T i and hAsD  {b:D}, T i  a:C i h(A  {b:D})sD , T i 
a:C. Since  satises CT and CM , we have that hAsD , T i  a:C i h(A{b:D})sD , T i  a:C,
that is, hA, T , Di s a:C i hA  {b:D}, T , Di s a:C.
For ORDL , assume that hA  {b:D}, T , Di s a:C, hA  {b:E}, T , Di s a:C, and that
b is in the nth position in the sequence s. So, for the rst n  1 elements of s the association
with the default-formulae is the same in both the models. For b, assume that the procedure
469

fiCasini & Straccia

assigns b:i in case b:D, and b:j in case b:E. We can have either i = j ,  i  j , or
 j  i . In the rst case the procedure for the assignment of the defaults continues in the
same way in both the knowledge bases, and it is the same also if we have b:D  E, that
is, hA  {b:D}, T , Di, hA  {b:E}, T , Di, and hA  {b:D  E}, T , Di are completed exactly
with the same defaults, obtaining, respectively, the ABoxes (A  {b:D})sD = A  {b:D},
(A  {b:E})sD , = A  {b:E}, and (A  {b:D  E})sD = A  {b:D  E}, for some ABox
A . So we have that A  {b:D}  a:C and A  {b:E}  a:C, and, since  satises OR,
we obtain A  {b:D  E}  a:C, that is, h(A  {b:D  E})sD , T i  a:C. If i  j and
b:D  E, the procedure associates to b the strongest of the two defaults, that is, i . Since
i is not consistent with b:E, in every following consistency check the procedure will be
forced to consider that b:D holds, and the assignment of the defaults to the individuals will
proceed as in the case where b:D holds, and hA  {b:D  E}, T , Di will entail the same
formulae as hA  {b:D}, T , Di. Analogously, if j  i , the default-assumption extension of
hA  {b:D  E}, T , Di will correspond to the one of hA  {b:E}, T , Di.
Finally, for RMDL , b:D is consistent with hAsD , T i, so the presence of b:D in the
knowledge base does not inuence the association of the defaults to the individuals, and
AsD  (A  {b:D})sD . Eventually, hAsD , T i  a:C implies h(A  {b:D})sD , T i  a:C, i.e.
hA  {b:D}, T , Di s a:C.
Proposition 5.7 hA, T , Di  a:C iff hA[a] , T , Di s a:C for every ordering s of the individuals in A[a].
Proof. The proof is quite immediate. Assume hA[a] , T , Di 6s a:C for some s. Let s be a
sequence of the individuals named in A obtained using s as initial segment. Hence we have

that hA, T , Di 6s a:C, the implies hA, T , Di 6 a:C.
Now assume hA, T , Di 6 a:C. Hence, for some sequence s hA, T , Di 
6 s a:C. Let s be a

restriction of s to the individuals named in A[a] ; then we have that hA, T , Di 
6 s a:C.

Appendix C. Table of the Main Symbols
Since the paper considers dierent elds, the notation has turned out to be quite complex.
We add here a table to summarize the main symbols used in the paper.

N
Cp,q

IN/BIN
nodes
strict conditional
defeasible conditional
consequence relation
conjunction, disjunction
links in the courses/ducts
between p and q

PL
atoms
propositions
strict conditional
defeasible conditional
links in the ducts
between p and q

DL
concept names
concepts
individuals
strict conditional
defeasible conditional
links in the ducts
between p and q

N
p,q

materialisations of the
N
links in Cp,q

materialisations of the
N
links in Cp,q

materialisations of the
N
links in Cp,q

N

p,q

conditionals in N
p,q
as exceptional as p

conditionals in N
p,q
as exceptional as p

conditionals in N
p,q
as exceptional as p

p, q, . . .
C, D, . . .
a, b, . . .

|
, 

470

fiDefeasible Inheritance-Based Description Logics

References
Alchourron, C., Gardenfors, P., & Makinson, D. (1985). On the logic of theory change:
Partial meet contraction and revision functions. Journal of Symbolic Logic, 50, pp.
510530.
Baader, F., Calvanese, D., McGuinness, D., Nardi, D., & Patel-Schneider, P. F. (Eds.).
(2003). The Description Logic Handbook: Theory, Implementation, and Applications.
Cambridge University Press.
Baader, F., & Hollunder, B. (1993). How to prefer more specic defaults in terminological
default logic. In Proceedings of IJCAI-93, pp. 669674. Morgan Kaufmann Publishers.
Bochman, A. (2001). A logical theory of nonmonotonic inference and belief change. SpringerVerlag.
Bonatti, P. A., Lutz, C., & Wolter, F. (2009). The complexity of circumscription in description logic. Journal of Artificial Intelligence Research, 35, pp. 717773.
Bonatti, P. A., Faella, M., & Sauro, L. (2010). EL with default attributes and overriding. In
Patel-Schneider, P. F., Pan, Y., Hitzler, P., Mika, P., Zhang, L., Pan, J. Z., Horrocks,
I., & Glimm, B. (Eds.), International Semantic Web Conference (1), Vol. 6496 of
Lecture Notes in Computer Science, pp. 6479. Springer.
Bonatti, P. A., Faella, M., & Sauro, L. (2011a). Adding default attributes to EL++ . In
Burgard, W., & Roth, D. (Eds.), Proceedings of AAAI-11. AAAI Press.
Bonatti, P. A., Faella, M., & Sauro, L. (2011b). Defeasible inclusions in low-complexity
DLs. Journal of Artificial Intelligence Research, 42, pp. 719764.
Bonatti, P. A., Faella, M., & Sauro, L. (2011c). On the complexity of el with defeasible
inclusions. In Proceedings of IJCAI-11, pp. 762767. AAAI Press/IJCAI.
Brewka, G., & Augustin, D. S. (1987). The logic of inheritance in frame systems. In
Proceedings of IJCAI-87, pp. 483488. Morgan Kaufmann Publishers.
Britz, K., Casini, G., Meyer, T., Moodley, K., & Varzinczak, I. (2013). Ordered Interpretations and Entailment for Defeasible Description Logics. Tech. rep., CAIR, CSIR
Meraka and UKZN, South Africa.
Britz, K., Heidema, J., & Meyer, T. A. (2008). Semantic preferential subsumption. In
Brewka, G., & Lang, J. (Eds.), Proceedings of KR-08, pp. 476484. AAAI Press.
Britz, K., Meyer, T., & Varzinczak, I. J. (2011). Semantic foundation for preferential
description logics. In Wang, D., & Reynolds, M. (Eds.), Australasian Conference on
Artificial Intelligence, Vol. 7106 of Lecture Notes in Computer Science, pp. 491500.
Springer.
Casini, G., Meyer, T., Moodley, K., & Varzinczak, I. (2013). Nonmonotonic reasoning in
description logics. Rational closure for the ABox. In Proceedings of DL-13, pp. 7790.
CEUR Workshop Proceedings.
Casini, G., & Straccia, U. (2010). Rational closure for defeasible description logics. In
Janhunen, T., & Niemela, I. (Eds.), Proceedings of JELIA-10, Vol. 6341 of Lecture
Notes in Computer Science, pp. 7790. Springer.
471

fiCasini & Straccia

Casini, G., & Straccia, U. (2011). Defeasible inheritance-based description logics. In Proceedings of IJCAI-11, pp. 813818.
Cormen, T. H., Stein, C., Rivest, R. L., & Leiserson, C. E. (2001). Introduction to Algorithms
(2nd edition). McGraw-Hill Higher Education.
Donini, F. M., & Massacci, F. (2000). EXPTIME tableaux for ALC. Artificial Intelligence,
124 (1), pp. 87138.
Donini, F. M., Nardi, D., & Rosati, R. (2002). Description logics of minimal knowledge and
negation as failure. Transactions on Computational Logic, 3 (2), pp. 177225.
Freund, M. (1998). Preferential reasoning in the perspective of Poole default logic. Artificial
Intelligence, 98 (1-2), pp. 209235.
Gabbay, D. M., & Schlechta, K. (2009). Defeasible inheritance systems and reactive diagrams. Logic Journal of the IGPL, 17 (1), pp. 154.
Giordano, L., Gliozzi, V., Olivetti, N., & Pozzato, G. L. (2012a). A minimal model semantics
for nonmonotonic reasoning. In Proceedings of JELIA-12, Vol. 7519 of Lecture Notes
in Computer Science, pp. 228241. Springer.
Giordano, L., Gliozzi, V., Olivetti, N., & Pozzato, G. L. (2012b). A non-monotonic description logic for reasoning about typicality. Artificial Intelligence, 195, pp. 165202.
Giordano, L., Olivetti, N., Gliozzi, V., & Pozzato, G. L. (2009). ALC+T: a preferential
extension of description logics. Fundam. Inform., 96 (3), 341372.
Grimm, S., & Hitzler, P. (2009). A preferential tableaux calculus for circumscriptive ALCO.
In Proceedings of RR-09, pp. 4054. Springer-Verlag.
Horty, J. F. (1994). Some direct theories of nonmonotonic inheritance. In Handbook of
logic in artificial intelligence and logic programming: nonmonotonic reasoning and
uncertain reasoning, Vol. 3, pp. 111187. Oxford University Press.
Horty, J. F., & Thomason, R. H. (1990). Boolean extensions of inheritance networks. In
Proceedings of AAAI-90, pp. 633639. AAAI Press.
Horty, J. F., Thomason, R. H., & Touretzky, D. S. (1987). A skeptical theory of inheritance
in nonmonotonic semantic networks. In Proceedings of AAAI-87. AAAI Press.
Knorr, M., Alferes, J. J., & Hitzler, P. (2011). Local closed world reasoning with description
logics under the well-founded semantics. Artificial Intelligence, 175 (9-10), 15281554.
Kraus, S., Lehmann, D., & Magidor, M. (1990). Nonmonotonic reasoning, preferential
models and cumulative logics. Artificial Intelligence, 44 (1-2), pp. 167207.
Lehmann, D., & Magidor, M. (1992). What does a conditional knowledge base entail?.
Artificial Intelligence, 55 (1), pp. 160.
Lukasiewicz, T. (2008). Expressive probabilistic description logics. Artificial Intelligence,
172 (6-7), pp. 852883.
Makinson, D. (1994). General patterns in nonmonotonic reasoning. In Handbook of logic in
artificial intelligence and logic programming: nonmonotonic reasoning and uncertain
reasoning, Vol. 3, pp. 35110. Oxford University Press.
472

fiDefeasible Inheritance-Based Description Logics

Makinson, D. (2005). Bridges from Classical to Nonmonotonic Logic. Kings College Publications.
Makinson, D., & Schlechta, K. (1991). Floating conclusions and zombie paths. Artificial
Intelligence, 48, pp. 199209.
Poole, D. (1988). A logical framework for default reasoning. Artificial Intelligence, 36 (1),
2747.
Quantz, J., & Royer, V. (1992). A preference semantics for defaults in terminological logics.
In Proceedings of KR-92, pp. 294305.
Rott, H. (2001). Change, Choice and Inference: a study of belief revision and nonmonotonic
reasoning. Oxford University Press.
Sandewall, E. (1986). Nonmonotonic inference rules for multiple inheritance with exceptions.
In Proceedings of the IEEE-86, pp. 13451353.
Sandewall, E. (2010). Defeasible inheritance with doubt index and its axiomatic characterization. Artificial Intelligence, 18 (174), pp. 14311459.
Schlechta, K. (2004). Coherent Systems. Elsevier.
Shoham, Y. (1988). Reasoning about change: time and causation from the standpoint of
artificial intelligence. MIT Press.
Simonet, G. (1996). On sandewalls paper: Nonmonotonic inference rules for multiple inheritance with exceptions. Artificial Intelligence, 86, pp. 359374.
Straccia, U. (1993). Default inheritance reasoning in hybrid KL-ONE style logics. Proceedings of IJCAI-93, 676681.
Thomason, R. H. (1992). NETL and subsequent path-based inheritance theories. In
Lehmann, F. (Ed.), Semantic Networks in Artificial Intelligence, pp. 179204. Pergamon Press.
Touretzky, D. S. (1986). The mathematics of inheritance systems. Pitman.
Touretzky, D. S., Horty, J. F., & Thomason, R. H. (1987). A clash of intuitions: the current
state of nonmonotonic multiple inheritance systems. In Proceedings of IJCAI-87 Vol. 1, pp. 476482. Morgan Kaufmann Publishers.
Touretzky, D. S., Thomason, R. H., & Horty, J. F. (1991). A skeptics menagerie: conictors,
preemptors, reinstates, and zombies in nonmonotonic inheritance. In Proceedings of
IJCAI-91, pp. 478483. Morgan Kaufmann Publishers.

473

fi