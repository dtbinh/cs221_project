Journal of Artificial Intelligence Research 48 (2013)

Submitted 5/2013; published 12/2013

Exact Query Reformulation over Databases
with First-order and Description Logics Ontologies
Enrico Franconi
Volha Kerhet
Nhung Ngo

franconi@inf.unibz.it
kerhet@inf.unibz.it
ngo@inf.unibz.it

Free University of Bozen-Bolzano, Italy

Abstract
We study a general framework for query rewriting in the presence of an arbitrary
first-order logic ontology over a database signature. The framework supports deciding the
existence of a safe-range first-order equivalent reformulation of a query in terms of the
database signature, and if so, it provides an effective approach to construct the reformulation based on interpolation using standard theorem proving techniques (e.g., tableau).
Since the reformulation is a safe-range formula, it is effectively executable as an SQL query.
At the end, we present a non-trivial application of the framework with ontologies in the
very expressive ALCHOIQ description logic, by providing effective means to compute
safe-range first-order exact reformulations of queries.

1. Introduction
We address the problem of query reformulation with expressive ontologies over databases.
An ontology provides a conceptual view of the database and it is composed by constraints
on a vocabulary extending the basic vocabulary of the data. Querying a database using
the terms in such a richer ontology allows for more flexibility than using only the basic
vocabulary of the relational database directly.
In this paper we study and develop a query rewriting framework applicable to knowledge
representation systems where data is stored in a classical finite relational database, in a way
that in the literature has been called the locally-closed world assumption (Etzioni, Golden,
& Weld, 1997), exact views (Marx, 2007; Nash, Segoufin, & Vianu, 2010; Fan, Geerts,
& Zheng, 2012), or DBox (Seylan, Franconi, & de Bruijn, 2009; Franconi, Ibanez-Garcia,
& Seylan, 2011). A DBox is a set of ground atoms which semantically behaves like a
database, i.e., the interpretation of the database predicates in the DBox is exactly equal
to the database relations. The DBox predicates are closed, i.e., their extensions are the
same in every interpretation, whereas the other predicates in the ontology are open, i.e.,
their extensions may vary among different interpretations. We do not consider here the
open interpretation for the database predicates (also called ABox or sound views). In an
ABox, the interpretation of database predicates contains the database relations and possibly
more. This notion is less faithful in the representation of a database semantics since it would
allow for spurious interpretations of database predicates with additional unwanted tuples
not present in the original database.
In our general framework an ontology is a set of first-order formulas, and queries are
(possibly open) first-order formulas. Within this setting, the framework provides precise
semantic conditions to decide the existence of a safe-range first-order equivalent reformulac
2013
AI Access Foundation. All rights reserved.

fiFranconi, Kerhet, & Ngo

tion of a query in terms of the database signature. It also provides an effective approach to
construct the reformulation with sufficient conditions. We are interested in safe-range reformulations of queries because their range-restricted syntax is needed to reduce the original
query answering problem to a relational algebra evaluation (e.g., via SQL) over the original
database (Abiteboul, Hull, & Vianu, 1995). Our framework points out several conditions on
the ontologies and the queries to guarantee the existence of a safe-range reformulation. We
show that these conditions are feasible in practice and we also provide an efficient method
to ensure their validation. Standard theorem proving techniques can be used to compute
the reformulation.
In order to be complete, our framework is applicable to ontologies and queries expressed
in any fragment of first-order logic enjoying finitely controllable determinacy (Nash et al.,
2010), a stronger property than the finite model property of the logic. If the employed logic
does not enjoy finitely controllable determinacy our approach would become sound but
incomplete, but still effectively implementable using standard theorem proving techniques.
We have explored non-trivial applications where the framework is complete; in this paper,
the application with ALCHOIQ ontologies and concept queries is discussed. We show how
(i) to check whether the answers to a given query with an ontology are solely determined
by the extension of the DBox predicates and, if so, (ii) to find an equivalent rewriting of the
query in terms of the DBox predicates to allow the use of standard database technology for
answering the query. This means we benefit from the low computational complexity in the
size of the data for answering queries on relational databases. In addition, it is possible to
reuse standard techniques of description logics reasoning to find rewritings, such as in the
paper by Seylan et al. (2009).
The query reformulation problem has received strong interest in classical relational
database research as well as modern knowledge representation studies. Differently from
the mainstream research on query reformulation (Halevy, 2001), which is mostly based
on perfect or maximally contained rewritings with sound views under relatively inexpressive constraints (see, e.g., the DL-Lite approach in Artale, Calvanese, Kontchakov, & Zakharyaschev, 2009), we focus here on exact rewritings with exact views, since it characterises
precisely the query answering problem with ontologies and databases, in the case when the
exact semantics of the database must be preserved. As an example, consider a ground negative query over a given standard relational database; by adding an ontology on top of it, its
answer is not supposed to changesince the query uses only the signature of the database
and additional constraints are not supposed to change the meaning of the querywhereas
if the database were treated as an ABox (sound views) the answer may change in presence
of an ontology. This may be important from the application perspective: a DBox preserves
the behaviour of the legacy application queries over a relational database. Moreover, by
focussing on exact reformulations of definable queries (as opposed to considering the certain
answer semantics to arbitrary queries, such as in DL-Lite), we guarantee that answers to
queries can be subsequently composed in an arbitrary way: this may be important to legacy
database applications.
This work extends the works on exact rewritings with exact views by Marx (2007) and
Nash et al. (2010) by focussing on safe-range reformulations and on the conditions ensuring
their existence, and by considering general first-order ontologies extending the database
signature, rather than just local as view constraints over the database predicates (Halevy,
886

fiExact Query Reformulation over DBs with FO and DL Ontologies

2001). This paper extends the papers by Franconi, Kerhet, and Ngo (2012a, 2012b) by
providing a precise semantic characterisation for the existence of an exact reformulation
(Theorem 4) as opposed to just sufficient conditions, by considering the much more expressive description logic ALCHOIQ, and by providing all the proofs.
The paper is organised as follows: section 2 provides the necessary formal background
and definitions; section 3 introduces the notion of a query determined by a database; section 4 introduces a characterisation of the query reformulation problem; in sections 5 and 6
the conditions allowing for an effective reformulation are analysed, and a sound and complete algorithm to compute the reformulation is introduced. Finally, we present the case of
ALCHOIQ ontologies. All the proofs are presented in details in the Appendix.

2. Preliminaries
Let FOL(C, P) be a classical function-free first-order language with equality over a signature
 = (C, P), where C is a finite set of constants and P is a set of predicates with associated
arities. In the rest of this paper we will refer to an arbitrary fragment of FOL(C, P), which
will be called L.
We denote with P{1 ,...,n } the set of all predicates occurring in the formulas 1 , . . . , n ,
with C{1 ,...,n } the set of all constants occurring in the formulas 1 , . . . , n ; for the sake of
brevity, instead of P{} (resp. C{} ) we write P (resp. C ). We denote with (1 , . . . , n )
the signature of the formulas 1 , . . . , n , namely the union of P{1 ,...,n } and C{1 ,...,n } .
We denote the arity of a predicate P as ar(P ). Given a formula , we denote the set of
all variables appearing in  as var(), and the set of the free variables appearing in  as
free(); we may use for  the notation [X] , where X = free() is the (possibly empty)
set of free variables of the formula.
A database (instance) DB is a finite set of ground atoms of the form P (c1 , . . . , cn ), where
P  P, n-ary predicate, and ci  C (1  i  n). The set of all predicates appearing in a
database DB is denoted as PDB , and the set of all constants appearing in DB is called the
active domain of DB, and is denoted as CDB . A (possibly empty) finite set KB of closed
formulas will be called an ontology.
As usual, an interpretation I = hI , I i includes a non-empty setthe domain I and
an interpretation function I defined over constants and predicates of the signature. We say
that interpretations I = hI , I i and J = hJ , J i are equal, written I = J , if I = J
and I = J . An interpretation I embeds a database DB, if it holds that aI = a for every
database constant a  CDB (the standard name assumption (SNA), customary in databases,
see Abiteboul et al., 1995) and that (c1 , . . . , cn )  P I if and only if P (c1 , . . . , cn )  DB. We
denote the set of all interpretations embedding a database DB as E(DB).
In other words, in every interpretation embedding a DB the interpretation of any
database predicate is always the same and it is given exactly by its content in the database;
this is, in general, not the case for the interpretation of the non-database predicates. We
say that all the database predicates are closed, while all the other predicates are open and
may be interpreted differently in different interpretations. We do not consider here the open
world assumption (the ABox ) for embedding a database in an interpretation. In an open
world, an interpretation I soundly embeds a database if it holds that (c1 , . . . , cn )  P I if
(but not only if) P (c1 , . . . , cn )  DB.
887

fiFranconi, Kerhet, & Ngo

In order to allow for an arbitrary database to be embedded, we generalise the standard
name assumption to all the constants in C; this implies that the domain of any interpretation
necessarily includes the set of all the constants C. The finiteness of C corresponds to the
finite ability of a database system to represent distinct constant symbols; C is meant to be
unknown in advance, since different database systems may have different limits. We will
see that the framework introduced here will not depend on the choice of C.
Given an interpretation I = hI , I i, we denote as I|S the interpretation restricted to
the smaller signature S  P  C, i.e., the interpretation with the same domain I and the
same interpretation function I defined only for the constants and predicates from the set
S. The semantic active domain of a signature  0  P  C in an interpretation I, denoted
adom( 0 , I), is the set of all elements of the domain I occurring in interpretations of
predicates and constants from  0 in I:
adom( 0 , I) :=

[

[

P  0 (a1 ,...,an )P I

{a1 , . . . , an } 

[

{cI }.

c 0

If  0  PDB  C, then for any interpretations I and J embedding DB we have:
adom( 0 , I) = adom( 0 , J ); so, for such a case we introduce the notation adom( 0 , DB) :=
adom( 0 , I), where I is any interpretation embedding the database DB. Intuitively
adom( 0 , DB) includes the constants from  0 and from DB appearing in the relations corresponding to the predicates from  0 .
Let X be a set of variable symbols and S a set; a substitution is a total function  : X 7 S
assigning an element in S to each variable in X, including the empty substitution  when
X = . Domain and image (range) of a substitution  are written as dom() and rng()
respectively. Given a subset of the set of constants C0  C, we write that a formula [X]
is true in an interpretation I with its free variables substituted according to a substitution
 : X 7 C0 as (I |= [X/] ). Given an interpretation I = hI , I i and a subset of
its domain   I , we write that a formula [X] is true in I with its free variables
interpreted according to a substitution  : X 7  as (I,  |= ). The extension domain of
aSformula [X] with respect to the interpretation I is defined as the set of domain elements
{rng() | dom() = X, rng()  , I,  |= [X] }.
As usual, an interpretation in which a closed formula is true is called a model for
the formula; the set of all models of a formula  (resp. KB) is denoted as M () (resp.
M (KB)). A database DB is legal for an ontology KB if there exists a model of KB embedding
DB. In the following, we will consider only consistent non-tautological ontologies and legal
databases.
2.1 Queries
A query is a (possibly closed) formula. Given a query Q[X] , we define its certain answer
over KB and DB as follows:
Definition 1 (Certain Answer). The (certain) answer of a query Q[X] to a database DB
under the ontology KB is the set of substitutions with constants:
{ | dom() = X, rng()  C,  I  M (KB)  E(DB) : I |= Q[X/] }.
888

fiExact Query Reformulation over DBs with FO and DL Ontologies

Query answering is defined as an entailment problem, and as such it is going to have the
same (high) complexity as entailment.
Note, that if a query Q is closed (i.e., a Boolean query), then the certain answer is {} if
Q is true in all the models of the ontology embedding the database, and  otherwise. In the
following, we assume that the closed formula Q[X/] is neither valid nor inconsistent under
the ontology KB, given a substitution  : X 7 C assigning to variables distinct constants
not appearing in Q, nor in KB, nor in CDB : this would lead to trivial reformulations.
We now show that we can weaken the standard name assumption for the constants by
just assuming unique names, without changing the certain answers. As we said before, an
interpretation I satisfies the standard name assumption if cI = c for any c  C. Alternatively, an interpretation I satisfies the unique name assumption (UNA) if aI 6= bI for
any different a, b  C. We denote the set of all interpretations satisfying standard name
assumption as I(SNA). We denote the set of all interpretations satisfying unique name
assumption as I(UNA). The following proposition allows us to freely interchange the standard name and the unique name assumptions with interpretations embedding databases.
This is of practical advantage, since we can encode the unique name assumption in classical
first-order logic reasoners, and many description logics reasoners do support natively the
unique name assumption as an extension to OWL.
Proposition 1 (SNA vs UNA). For any query Q[X] , ontology KB and database DB,
{ | dom() = X, rng()  C,  I  I(SNA)  M (KB)  E(DB) : I |= Q[X/] } =
{ | dom() = X, rng()  C,  I  I(UNA)  M (KB)  E(DB) : I |= Q[X/] }.
Since a query can be an arbitrary first-order formula, its answer may depend on the
domain, which we do not know in advance. For example, the query Q(x) = Student(x)
over the database Student(a), Student(b), with domain {a, b, c} has the answer {x = c},
while with domain {a, b, c, d} has the answer {x = c, x = d}. Therefore, the notion of
domain independent queries has been introduced in relational databases. Here we adapt
the classical definitions (Avron, 2008; Abiteboul et al., 1995) to our framework: we need
a more general version of domain independence, namely domain independence w.r.t an
ontology, i.e., restricted to the models of an ontology.
Definition 2 (Domain Independence). A formula Q[X] is domain independent with
respect to an ontology KB iff for every two models I and J of KB (i.e., I = hI , I i
and J = hJ , J i) which agree on the interpretation of the predicates and constants (i.e.
I = J ), and for every substitution  : X 7 I  J we have:
rng()  I and I,  |= Q[X] iff
rng()  J and J ,  |= Q[X] .
The above definition reduces to the classical definition of domain independence whenever
the ontology is empty.
A weaker version of domain independencewhich is relevant for open formulasis the
following.
Definition 3 (Ground Domain Independence). A formula Q[X] is ground domain independent iff Q[X/] is domain independent for every substitution  : X 7 C.
889

fiFranconi, Kerhet, & Ngo

For example, the formula P (x) is ground domain independent, but it is not domain independent.
The problem of checking whether a FOL formula is domain independent is undecidable
(Abiteboul et al., 1995). The well known safe-range syntactic fragment of FOL introduced
by Codd is an equally expressive language; indeed any safe-range formula is domain independent, and any domain independent formula can be easily transformed into a logically
equivalent safe-range formula. Intuitively, a formula is safe-range if and only if its variables
are bounded by positive predicates or equalities (for full details see Appendix A.3). For
example, the formula A(x)  B(x) is safe-range, while queries A(x) and x. A(x) are
not. To check whether a formula is safe-range, the formula is transformed into a logically
equivalent safe-range normal form and its range restriction is computed according to a set
of syntax based rules; the range restriction of a formula is a subset of its free variables, and
if this coincides with the free variables then the formula is said to be safe-range (Abiteboul
et al., 1995). Similar to domain independence, a formula is ground safe-range if any grounding of this formula is safe-range. An ontology KB is safe-range (domain independent), if
every formula in KB is safe-range (domain independent).
The safe-range fragment of first-order logic with the standard name assumption is
equally expressive to the relational algebra, which is the core of SQL (Abiteboul et al.,
1995).

3. Determinacy
The certain answer to a query includes all the substitutions which make the query true in
all the models of the ontology embedding the database: so, if a substitution would make the
query true only in some model, then it would be discarded from the certain answer. In other
words, it may be the case that the answer to the query is not necessarily the same among
all the models of the ontology embedding the database. In this case, the query is not fully
determined by the given source data; indeed, there is some answer which is possible, but
not certain. Due to the indeterminacy of the query with respect to the data, the complexity
to compute the certain answer in general increases up to the complexity of entailment in
the logic. In this paper we focus on the case when a query has the same answer over all the
models of the ontology embedding the database, namely, when the information requested
by the query is fully available from the source data without ambiguity. In this way, the
indeterminacy disappears, and the complexity of the process may decrease (see section 4).
The determinacy of a query w.r.t. a source database (Nash et al., 2010; Marx, 2007; Fan
et al., 2012) has been called implicit definability of a formula (the query) from a set of
predicates (the database predicates) by Beth (1953).
Definition 4 (Finite Determinacy or Implicit Definability). A query Q[X] is (finitely)
determined by (or implicitly definable from) the database predicates PDB under KB iff for
any two models I and J of the ontology KBboth with a finite interpretation to the
database predicates PDB whenever I|PDB C = J |PDB C then for every substitution
 : X 7 I we have: I,  |= Q[X] iff J ,  |= Q[X] .
Intuitively, the answer of an implicitly definable query does not depend on the interpretation of non-database predicates. Once the database and a domain are fixed, it is never
890

fiExact Query Reformulation over DBs with FO and DL Ontologies

the case that a substitution would make the query true in some model of the ontology
and false in others, since the truth value of an implicitly defined query depends only on
the interpretation of the database predicates and constants and on the domain (which are
fixed). In practice, by focussing on finite determinacy of queries we guarantee that the user
can always interpret the answers as being not only certain, but also exactnamely that
whatever is not in the answer can never be part of the answer in any possible world.
In the following we focus on ontologies and queries in those fragments of FOL(C, P) for
which determinacy under models with a finite interpretation of database predicates (finite
determinacy) and determinacy under models with an unrestricted interpretation of database
predicates (unrestricted determinacy) coincide. We say that these fragments have finitely
controllable determinacy: we require that whenever a query is finitely determined then it is
also determined in unrestricted models (the reverse is trivially true). Indeed, the results in
this paper would fail if finite determinacy and unrestricted determinacy do not coincide: it
can be shown (Gurevich, 1984) that Theorem 1 below fails if we consider only models with
a finite interpretation of database predicates.
Example 1 (Example from database theory). Let P = {P, R, A}, PDB = {P, R},
KB = {x, y, z. R(x, y)  R(x, z)  y = z,
x, y. R(x, y)  z. R(z, x),
(x, y. R(x, y)  z. R(y, z))  (x. A(x)  P (x))}.
The formula x, y. R(x, y)  z. R(y, z) is entailed from the first two formulas only over
finite interpretations of R. The query Q = A(x) is finitely determined by P (it is equivalent
to P (x) under the models with a finite interpretation of R), but it is not determined by any
database predicate under models with an unrestricted interpretation of R. This knowledge
base does not enjoy finitely controllable determinacy.
The exact reformulation of a query (Nash et al., 2010) (also called explicit definition by
Beth, 1953) is a formula logically equivalent to the query which makes use only of database
predicates and constants.
Definition 5 (Exact Reformulation or Explicit Definability). A query Q[X] is explicitly definable from the database predicates PDB under the ontology KB iff there is some
b[X] in FOL(C, P), such that KB |= X.Q[X]  Q
b[X] and (Q)
b  PDB . We call
formula Q
b[X] an exact reformulation of Q[X] under KB over PDB .
this formula Q
Determinacy of a query is completely characterised by the existence of an exact reformulation of the query: it is well known that a first-order query is determined by database
predicates if and only if there exists a first-order exact reformulation.
Theorem 1 (Projective Beth definability, Beth, 1953). A query Q is implicitly definable from the database predicates PDB under an ontology KB, iff it is explicitly definable as
b in FOL(C, P) over PDB under KB.
a formula Q
e the formula obtained from it by uniformly replacing
Let Q be any formula in L and Q
every occurrence of each non-database predicate P with a new predicate Pe. We extend this
renaming operator e to any set of formulas in a natural way. One can check whether a query
is implicitly definable by using the following theorem.
Theorem 2 (Testing Determinacy, Beth, 1953). A query Q[X] is implicitly definable
g |= X.Q[X]  Q
e[X] .
from the database predicates PDB under the ontology KB iff KB  KB

891

fiFranconi, Kerhet, & Ngo

4. Exact Safe-Range Query Reformulation
In this section we analyse the conditions under which the original query answering problem
corresponding to an entailment problem can be reduced systematically to a model checking
problem of a safe-range formula over the database (e.g., using a database system with
SQL). Given a database signature PDB , an ontology KB, and a query Q[X] expressed in L
and determined by the database predicates, our goal is to find a safe-range reformulation
b[X] of Q[X] in FOL(C, P), that when evaluated as a relational algebra expression over a
Q
legal database instance, gives the same answer as the certain answer of Q[X] to the database
under KB. This can be reformulated as the following problem:
Problem 1 (Exact safe-range Query Reformulation). Find an exact reformulation
b[X] of Q[X] under KB as a safe-range query in FOL(C, P) over PDB .
Q
Since an exact reformulation is equivalent under the ontology to the original query, the
certain answer of the original query and of the reformulated query are identical. More
precisely, the following proposition holds.
Proposition 2. Given a database DB, let Q[X] be implicitly definable from PDB under KB
b[X] be an exact reformulation of Q[X] under KB over PDB , then:
and let Q
{ | dom() = X, rng()  C,  I  M (KB)  E(DB) : I |= Q[X/] } =
b[X/] }.
{ | dom() = X, rng()  C,  I  M (KB)  E(DB) : I |= Q
From the above equation it is clear that in order to answer an exactly reformulated query,
one may still need to consider all the models of the ontology embedding the database, i.e.,
we still have an entailment problem to solve. The following theorem states the condition
to reduce the original query answering problembased on entailmentto the problem of
checking the validity of the exact reformulation over a single model: the condition is that
the reformulation should be domain independent. Indeed there is only one interpretation
(with a particular domain) embedding the database with the signature restricted to the
database predicates.
Theorem 3 (Adequacy of Exact safe-range Query Reformulation). Let DB be
b[X] is an exact domain
a database which is legal for KB, and let Q[X] be a query. If Q
independent (or safe-range) reformulation of Q[X] under KB over PDB , then:
{ | dom() = X, rng()  C,  I  M (KB)  E(DB) : I |= Q[X/] } =
b DB), I = hC, I i  E(DB) : I|P
{ | dom() = X, rng()  adom((Q),

DB C

b[X/] }.
|= Q

A safe-range reformulation is necessary to transform a first-order query to a relational
algebra query which can then be evaluated by using SQL techniques. The theorem above
shows in addition that being safe-range is also a sufficient property for an exact reformulation to be correctly evaluated as an SQL query. Let us now see an example in which we
cannot reduce the problem of answering an exact reformulation to model checking over a
database, if the exact reformulation is not safe-range.
Example 2. Let P = {P, A}, PDB = {P }, C = {a},
DB = {P (a, a)}, KB = {y. P (a, y)  A(y)},
b[X] = y. P (x, y) (i.e., X = {x}).
Q[X] = Q
892

fiExact Query Reformulation over DBs with FO and DL Ontologies

 C includes the active domain CDB (it is actually equal).
 DB is legal for KB because there is I = h{a}, I i such that P I = {(a, a)}, AI = 
and obviously, I  M (KB).
 { | dom() = X, rng()  C,  I  M (KB)  E(DB) : I |= Q[X/] } =  because
one can take I = h{a, b}, I i such that P I = {(a, a)}, AI = {b}; then I  M (KB) 
E(DB), but for the only possible substitution {x  a} we have: I 6|= y P (a, y).
 However,
b DB), I = hC, I i  E(DB) : I|P C |= Q
b[X/] } =
{ | dom() = X, rng()  adom((Q),
DB

{x  a}
As we have seen, answers to a query for which a reformulation exists will contain only
constants from the active domain of the database and the query; therefore, ground statements in the ontology involving non-database predicates and non-active domain constants
(for example, as ABox statements) will not play any role in the final evaluation of the
reformulated query over the database.

5. Conditions for an Exact Safe-Range Reformulation
We have just seen the importance of getting an exact safe-range query reformulation. In
this section we are going to study the conditions under which an exact safe-range query
reformulation exists.
First of all, we will focus on the semantic notion of safe-range namely domain independence. While implicit definability isas we already knowa sufficient condition for the
existence of an exact reformulation, it does not guarantee alone the existence of a domain
independent reformulation.
Example 3. Let P = {A, B}, PDB = {A}, KB = {x.B(x)  A(x)}, Q = B(x).
Then Q is implicitly definable from PDB under KB, and every exact reformulation of Q over
PDB under KB is logically equivalent to A(x) and not domain independent.
By looking at the example, it seems that the reason for the non domain independent
reformulation lies in the fact that the ontology, which is domain independent, cannot guarantee existence of an exact domain independent reformulation of the non domain independent
query. However, let us consider the following example:
Example 4. Let PDB = {A, C}, KB = {A(a),
y B(y)  C(x). It is easy to see that KB is
is implicitly definable from PDB under KB, and
independent reformulation of Q.

x. A(x)  B(x)} and let a query Q =
domain independent and Q is not. Q
b = A(a)  C(x) is an exact domain
Q

It is obvious that in spite of the fact that the query Q is not domain independent, it
is domain independent with respect to the ontology KB. In other words, in this case the
ontology guarantees the existence of an exact domain independent reformulation.
With queries that are domain independent with respect to an ontology, the following
theorem holds, giving the semantic requirements for the existence of an exact domain
independent reformulation.
893

fiFranconi, Kerhet, & Ngo

Theorem 4 (Semantic Characterisation). Given a set of database predicates PDB , a
domain independent ontology KB, and a query Q[X] , a domain independent exact reformub[X] of Q[X] over PDB under KB exists if and only if Q[X] is implicitly definable from
lation Q
PDB under KB and it is domain independent with respect to KB.
The above theorem shows us the semantic conditions to have an exact domain independent reformulation of a query, but it does not give us a method to compute such reformulation and its equivalent safe-range form. The following theorem gives us sufficient
conditions for the existence of an exact safe-range reformulation in any decidable fragment of
FOL(C, P) where finite and unrestricted determinacy coincide, and gives us a constructive
way to compute it, if it exists.
Theorem 5 (Constructive). If:
g |= X. Q[X]  Q
e[X] (that is, Q[X] is implicitly definable),
1. KB  KB
2. Q[X] is safe-range (that is, Q[X] is domain independent),
3. KB is safe-range (that is, KB is domain independent),
b[X] of Q[X] as a safe-range query in FOL(C, P)
then there exists an exact reformulation Q
over PDB under KB, that can be obtained constructively.
In order to constructively compute the exact safe-range query reformulation we use the
b[X] from a
tableau based method to find the Craigs interpolant (Fitting, 1996) to compute Q
gQ
e[X] ). See Section 6 for full details.
validity proof of the implication (KB  Q[X] )  (KB
Let us now consider a fully worked out example, adapted from the paper by Nash et al.
(2010).
Example 5. Given: P = {R, V1 , V2 , V3 , A}, PDB = {V1 , V2 , V3 , Adom} where Adom is the
active domain of DB,
KB = { x, y. V1 (x, y)  z, v. R(z, x)  R(z, v)  R(v, y),
x, y. V2 (x, y)  z. R(x, z)  R(z, y),
x, y. V3 (x, y)  z, v. R(x, z)  R(z, v)  R(v, y),
Q(x, y) = z, v, u. R(z, x)  R(z, v)  R(v, u)  R(u, y)}.
The conditions of the theorem are satisfied: Q(x, y) is implicitly definable from PDB under
KB; Q(x, y) is safe-range; KB is safe-range.
b y)
Therefore, with the tableau method one finds the Craigs interpolant to compute Q(x,
g
e
b
from a validity proof of the implication (KB  Q[X] )  (KB  Q[X] ) and obtain Q(x, y) =
z. V1 (x, z)  v. (V2 (v, z)  V3 (v, y))an exact ground safe-range reformulation. Since
b y)  Adom(x) 
the answer of Q is in the active domain, we also have KB |= Q(x,
b
Adom(y). Then KB |= Q(x, y)  Q(x, y)  Adom(x)  Adom(y). Therefore, z. V1 (x, z) 
v. (V2 (v, z)  V3 (v, y))Adom(x)Adom(y) is an exact safe-range reformulation of Q(x, y)
from PDB under KB.
894

fiExact Query Reformulation over DBs with FO and DL Ontologies

6. Constructing the Safe-Range Reformulation
In this section we introduce a method to compute a safe-range reformulation of an implicitly
definable query when conditions in theorem 5 are satisfied. The method is based on the
notion of interpolant introduced by Craig (1957).
Definition 6 (Interpolant). The sentence  is an interpolant for the sentence   
in FOL(C, P), if all predicate and constant symbols of  are in the set of predicate and
constant symbols of both  and , and both    and    are valid sentences in
FOL(C, P).
Theorem 6 (Craigs interpolation). If    is a valid sentence in FOL(C, P), and
neither  nor  are valid, then there exists an interpolant.
Note, that the Beth definability (Theorem 1) and Craigs interpolation theorem do not
hold for all fragments of FOL(C, P): an interpolant may not always be expressed in the
fragment itself, but obviously it is in FOL(C, P) (because of Theorem 6).
An interpolant is used to find an exact reformulation of a given implicitly definable
query as follows.
Theorem 7 (Interpolant as definition). Let Q[X] be a query with n  0 free variables
implicitly definable from the database predicates PDB under the ontology KB. Then, the
closed formula with c1 , ..., cn distinct constant symbols in C not appearing in KB or Q[X] :
^
^
g Q
e[X/c ,...,c ] )
(( KB)  Q[X/c1 ,...,cn ] )  (( KB)
(1)
n
1
b[c ,...,c /X] is an exact reformulation of Q[X] under KB over
is valid, and its interpolant Q
n
1
PDB .
Therefore, to find an exact reformulation of an implicitly definable query in terms of
database predicates it is enough to find an interpolant of the implication (1) and then to
substitute all the constants c1 , . . . , cn back with the free variables X of the original query.
An interpolant can be constructed from a validity proof of (1) by using automated theorem
proving techniques such as tableau or resolution. In order to guarantee the safe-range
property of the reformulation, we use a tableau method as in the book by Fitting (1996).
6.1 Tableau-based Method to Compute an Interpolant
In this section we recall in our context the tableau based method to compute an interpolant (Fitting, 1996).
Assume    is valid, therefore    is unsatisfiable. Then there is a closed tableau
corresponding to   . In order to compute an interpolant from this tableau one needs
to modify it to a biased tableau.
Definition 7 (Biased tableau). A biased tableau for formulas    is a tree T = (V, E)
where:
 V is a set of nodes, each node is labelled by a set of biased formulas. A biased formula
is an expression in the form of L() or R() where  is a formula. For each node n,
S(n) denotes the set of biased formulas labelling n.
895

fiFranconi, Kerhet, & Ngo

 The root of the tree is labelled by {L(), R()}
 E is a set of edges. Given 2 nodes n1 and n2 , (n1 , n2 )  E iff there is a biased
completion rule from n1 to n2 . We say there is a biased completion rule from n1 to
n2 if
 Y () is the result of applying a rule to X(), where X and Y refer to L or R
(for some rules, there are two possibilities of choosing Y ()), and
 S(n2 ) = (S(n1 ) \ {X()})  {Y ()}.
Let C be the set of all constants in the input formulas of the tableau. C par extends C
with an infinite set of new constants. A constant is new if it does not occur anywhere in
the tableau. With these notations, we have the following rules :
 Propositional rules
X()
X()

Negation rules
X(>)
X()

rule
X(1  2 )

X()
X(>)

X(1 )
X(2 )

rule
X((1  2 ))
X(1 ) | X(2 )

 First order rules
rule
X(x.)

rule
X(x.)

X((t))
for any t  C par

X((c))
for a new constant c

 Equality rules
reflexivity rule

replacement rule
X(t = u)
Y ((t))

X()
t

X(t = t)
occurs in 

Y ((u))

C par

A node in the tableau is closed if it contains X() and Y (). If a node is closed, no
rule is applied. In the other words, it becomes a leaf of the tree. A branch is closed if it
contains a closed node and a tableau is closed if all of its branches are closed. Obviously, if
the standard tableau for FOL is closed then so is the biased tableau and vice versa.
Given a closed biased tableau, the interpolant is computed by applying interpolant rules.
int
An interpolant rule is written as S  I, where I is a formula and
S = {L(1 ), L(2 ), ..., L(n ), R(1 ), R(2 ), ..., R(m )}.
 Rules for closed branches
int

int

r1. S  {L(), L()}  

r2. S  {R(), R()}  >

int

int

r3. S  {L()}  

r4. S  {R()}  >
int

int

r5. S  {L(), R()}  

r6. S  {R(), L()}  
896

fiExact Query Reformulation over DBs with FO and DL Ontologies

 Rules for propositional cases
int
S  {X()}  I
p1.

p4.

p6.

int

p2.

int

S  {X()}  I
int
S  {X(1 ), X(2 )}  I

S  {X(>)}  I
int

int

p3.

S  {X()}  I
int

S  {X()}  I
S  {X(>)}  I
int
int
S  {L(1 )}  I1 S  {L(2 )}  I2
p5.

int

int

S  {X(1  2 )}  I
S  {L((1  2 ))}  I1  I2
int
int
S  {R(1 )}  I1 S  {R(2 )}  I2
int

S  {R((1  2 ))}  I1  I2
 Rules for first order cases :
int
S  {X((p))}  I
f1.

f2.

f3.

f4.

f5.

where p is a parameter that does not occur in S or 

int

S  {X(x.(x))}  I
int
S  {L((c))}  I
int

if c occurs in {1 , ..., n }

S  {L(x.(x))}  I
int
S  {R((c))}  I
int

if c occurs in {1 , ..., m }

S  {R(x.(x))}  I
int
S  {L((c))}  I
int

S  {L(x.(x))}  x.I[c/x]
int
S  {R((c))}  I
int

if c does not occur in {1 , ..., n }
if c does not occur in {1 , ..., m }

S  {R(x.(x))}  x.I[c/x]
 Rules for equality cases
int
S  {X((p)), X(t = t)}  I
e1.

e3.

int

int

e2.

S  {X((p))}  I
int
S  {L((u)), R(t = u)}  I
int

S  {X((u)), X(t = u)}  I
int

S  {X((t)), X(t = u)}  I
if u occurs in (t), 1 , ..., m

S  {L((t)), R(t = u)}  t = u  I
int
S  {R((u)), L(t = u)}  I

if u occurs in (t), 1 , ..., m
int
S  {R((t)), L(t = u)}  t = u  I
int
S  {L((u)), R(t = u)}  I
e5.
if u does not occur in (t), 1 , ..., m
int
S  {L((t)), R(t = u)}  I[u/t]
int
S  {R((u)), L(t = u)}  I
e6.
if u does not occur in (t), 1 , ..., m
int
S  {R((t)), L(t = u)}  I[u/t]
e4.

In summary, in order to compute an interpolant of  and , one first need to generate
a biased tableaux proof of unsatisfiability of    using biased completion rules and then
apply interpolant rules from bottom leaves up to the root.
Let us consider an example to demonstrate how the method works.
Example 6. Let P = {S, G, U }, PDB = {S, U },
897

fiFranconi, Kerhet, & Ngo

KB = { x(S(x)  (G(x)  U (x)))
x(G(x)  S(x))
x(U (x)  S(x))
x(G(x)  U (x))}
Q(x) = G(x)
Obviously, Q is implicitly definable from S and U , since the ontology states that G and
U partition S. Now we will follow the tableau method to find its exact reformulation. For
int
compactness, we use the notation S I instead of S  I.
S0 = {L(x(S(x)  (G(x)  U (x)))),
L(x(G(x)  S(x))),
L(x(U (x)  S(x))),
L(x(G(x)  U (x))),
L(G(c)),
R(x(S(x)  (G1 (x)  U (x)))),
R(x(G1 (x)  S(x))),
R(x(U (x)  S(x))),
R(x(G1 (x)  U (x))),
R(G1 (c))}
By applying the rule for  and removing the implication, we have:
S1 = {L(S(c)  G(c)  U (c)),
L(G(c)  S(c))),
L(U (c)  S(c)),
L(G(c)  U (c)),
L(G(c)),
R(S(c)  G1 (c)  U (c)),
R(G1 (c)  S(c)),
R(U (c)  S(c)),
R(G1 (c)  U (c)),
R(G1 (c))}
and the interpolant of S1 can be computed as follows:
S4  {R(S(c)}S(c)

S4  {R(U (c))}U (c)

S4 = S3  {R(S(c)  U (c))}(S(c)U (c))



S3  {R(G1 (c))}>

(S(c)U (c))

B.7

S2  {L(G(c))}

S3 = S2  {L(U (c))}

(S(c)U (c))

S2 = S1  {L(S(c))}

(S(c)U (c))

B.5

S1  {L(G(c))}

B.3

S1

b
Therefore, S(c)U (c) is the interpolant and Q(x)
= S(x)U (x) is an exact reformulation
of Q(x).
898

fiExact Query Reformulation over DBs with FO and DL Ontologies

Algorithm 1 Safe-range Reformulation
Input: a safe-range KB, a safe-range and implicitly definable query Q[X] .
Output: an exact safe-range reformulation.
b[X] as in Theorem 7
1: Compute the interpolant Q
b[X] do
2: For each free variable x which is not bounded by any positive predicate in Q
b[X] := Q
b[X]  Adom b (x)
Q
Q
b[X]
3: Return Q

6.2 A Safe-Range Reformulation
Now we want to show that the reformulation computed by the above tableau based method
under the condition of Theorem 5 generates a ground safe-range query.
Theorem 8 (Ground safe-range Reformulation). Let KB be an ontology, and let Q be
a query which is implicitly definable from PDB . If KB and Q are safe-range then a rewritten
b obtained using the tableau method described in Section 6.1 is ground safe-range.
query Q
In other words, the conditions of Theorem 8 guarantee that all quantified variables in the
reformulation are range-restricted. We need to consider now the still unsafe free variables.
The theorem below will help us deal with non-range-restricted free variables. Let us first
define the active domain predicate of a query Q as the safe-range formula:
Adom Q (x) :=
 W
W
P PQ z1 , . . . , zar(P )1 . P (x, z1 , . . . , zar(P )1 )  . . .  P (z1 , . . . , zar(P )1 , x) 
cCQ (x = c).

Theorem 9 (Range of the query). Let KB be a domain independent ontology, and let
Q[x1 ,...,xn ] be a query which is domain independent with respect to KB. Then
KB |= x1 , . . . , xn . Q[x1 ,...,xn ]  Adom Q (x1 )  . . .  Adom Q (xn ).
Given a safe-range ontology, a safe-range and implicitly definable query is obviously
domain independent with respect to the ontology. In this case, Theorem 9 says that the
answer of the reformulation can only include active domain elements. Therefore, the active
domain predicate can be used as a guard for free variables which are not bounded by any
positive predicate.
Based on Theorem 8 and Theorem 9, we propose a complete procedure to construct a
safe-range reformulation in Algorithm 1.

7. The Guarded Negation Fragment of ALCHOIQ
ALCHOIQ is an extension of the description logic ALC with role hierarchies, individuals,
inverse roles, and qualified cardinality restrictions: it corresponds to the SHOIQ description logic without transitive roles; it is the logic at the basis of OWL. The syntax and
semantics of ALCHOIQ concept expressions is summarised in the Figure 1, where A is an
atomic concept, C and D are concepts, o is an individual name, P is an atomic role, and
R is either P or P  . The forall and the qualified and unqualified atmost operators can be
derived by using negation and the atleast operator in the usual way. A TBox in ALCHOIQ
899

fiFranconi, Kerhet, & Ngo

Syntax
A
{o}
P
P
C
C uD
C tD
 nR
 nR.C

Semantics
AI  I
{oI }  I
P I  I  I
{(y, x)|(x, y)  P I }
I \C I
C I  DI
C I  DI
{x|#({y|(x, y)  RI })  n}
{x|#({y|(x, y)  RI }  C I )  n}

Figure 1: Syntax and semantics of ALCHOIQ concepts and roles
is a set of concept inclusion axioms C v D and role inclusion axioms R v S (where C, D
are concepts and R, S are roles) with the usual description logics semantics.
In this section, we present an application of Theorem 5, by introducing the ALCHOIQGN
description logic, the guarded negation syntactic fragment of ALCHOIQ (Figure 2) which
happens to express exactly the domain independent concepts and TBoxes of ALCHOIQ.
The language restricts ALCHOIQ by just prescribing that negated concepts should be
guarded by some generalised atom (an atomic concept, a nominal, an unqualified atleast
number restriction), i.e., absolute negation is forbidden. Similarly, the derived forall and
atmost operators would be guarded by using their standard definition as the dual of the
atleast operator, but with the guarded negation. ALCHOIQGN is actually at the intersection of the GNFO fragment (Barany, ten Cate, & Otto, 2012) and ALCHOIQ (see
Appendix A.5 for details on GNFO).
ALCHOIQGN has the very important property of coinciding with the domain independent fragment of ALCHOIQ, therefore providing an excellent candidate language for
ontologies and queries satisfying the conditions of Theorem 5.
Theorem 10 (Expressive power equivalence). The domain independent fragment of
ALCHOIQ and ALCHOIQGN are equally expressive.
In other words the theorem says that any domain independent TBox axiom and any
domain independent concept query in ALCHOIQ is logically equivalent, respectively, to a
TBox axiom and a concept query in ALCHOIQGN , and vice-versa. This theorem provides
the description logics version of Codds theorem. Codds theorem states that the safe-range
syntactic fragment of FOL and the domain-independent fragment of FOL are precisely
equivalent in expressive power; that is, a database query can be formulated in one language
if and only if it can be expressed in the other.
R
B
C

::=
::=
::=

P | P
A | {o} |  nR
B |  nR.C |  nR.C | B u C | C u D | C t D
Figure 2: Syntax of ALCHOIQGN concepts and roles
900

fiExact Query Reformulation over DBs with FO and DL Ontologies

7.1 Applying the Constructive Theorem
We want to reformulate concept queries over an ontology with a DBox so that the reformulated query can be evaluated as an SQL query over the database represented by the DBox.
In this context, the database is a DBox, the ontology is an ALCHOIQGN TBox, and the
query is an ALCHOIQGN concept query. A concept query is either an ALCHOIQGN
concept expression denoting an open formula with one free variable, or an ALCHOIQGN
ABox concept assertion denoting a boolean query. As expected, a DBox includes ground
atomic statements of the form A(a) and P (a, b) (where A is an atomic concept and P is an
atomic role). From Theorem 10 we can draw the following corollary.
Corollary 1. ALCHOIQGN TBoxes and concept queries are domain independent.
We can also prove the following theorem.
Theorem 11. ALCHOIQGN TBoxes with concept queries have finitely controllable determinacy.
Therefore, we satisfy the conditions of Theorem 5, with a language which is like the
very expressive ALCHOIQ description logic, but with guarded negation.
We argue that non-guarded negation should not appear in a cleanly designed ontology,
and, if present, should be fixed. Indeed, the use of absolute negative informationsuch as,
e.g., in a non-male is a female ( male v female)should be discouraged by a clean
design methodology, since the subsumer would include all sorts of objects in the universe
(but the ones of the subsumee type) without any obvious control. Only guarded negative
information in the subsumee should be allowedsuch as in the axiom a non-male person
is a female (person u  male v female).
This observation suggests a fix for non-guarded negations: for every non-guarded negation users will be asked to replace it by a guarded one, where the guard may be an arbitrary
atomic concept, or nominal, or non-qualified existential. Therefore, the user is asked to make
explicit the type of that concept, in a way to make it domain independent; note that the
type could be also a fresh new atomic concept. We believe that the fix we are proposing
for ALCHOIQ is a reasonable one, and would make all ALCHOIQ ontologies eligible to
be used with our framework.
7.2 A Complete Procedure
ALCHOIQGN is a decidable logic and it is a feasible application of our general framework.
Given an ALCHOIQGN ontology KB and a concept query Q, we can apply the procedure
below to generate a safe-range reformulation over the database concepts and roles (based
on the constructive theorem, all the conditions of which are satisfied), if it exists.
Input: An ALCHOIQGN TBox KB, a concept query Q in ALCHOIQGN , and a
database signature (database atomic concepts and roles).
g |= Q  Q
e using
1. Check the implicit definability of the query Q by testing if KB  KB
a standard OWL2 reasoner (ALCHOIQGN is a sublanguage of OWL2). Continue if
this holds.
901

fiFranconi, Kerhet, & Ngo

b from the tableau proof generated in step 1 (see
2. Compute a safe-range reformulation Q
Section 6). This can be implemented as a simple extension of a standard DL reasoner
even in the presence of the most important optimisation techniques such as semantic
branching, absorption, and backjumping as explained by Seylan et al. (2009) and ten
Cate, Franconi, and Seylan (2011).
b expressed over the database signature.
Output: A safe-range reformulation Q
Note that the procedure for checking determinacy and computing the reformulation
could be run in offline mode at compile time. Indeed, it could be run for each atomic concept
in the ontology, and store persistently the outcome for each of them if the reformulation has
been successful. This pre-computation may be an expensive operation, sinceas we have
seenit is based on entailment, but the complexity involves only the size of the ontology
and not of the data.
In order to get an idea about the size of the reformulations, for the ALCF I description
logic there is a tableau-based algorithm computing explicit definitions of at most double
exponential size (ten Cate et al., 2011; ten Cate, Franconi, & Seylan, 2013); this algorithm is
optimal because it is also shown that the smallest explicit definition of an implicitly defined
concept may be double exponentially long in the size of the input TBox.
Clearly, similarly to DL-Lite reformulations, more research is needed in order to optimise
the reformulation step in order to make it practical. However, note that the framework
presented here has a clear advantage from the point of view of conceptual modelling since
implicit definitions (that is, queries) under general TBoxes can be double exponentially
more succinct than acyclic concept definitions (that is, explicit queries over the database).
There is also another interesting open problem about checking that a given database
is legal with respect to a given ontology. Remember that a database DB is legal for an
ontology KB if there exists a model of KB embedding DB. This check involves heavy
computations for which an optimised algorithm is still unknown: as a matter of fact, the
only known method today is to reduce the problem to a satisfiability problem where the
database is embedded in a TBox using nominals (Franconi et al., 2011). More research is
needed in order to optimise the reasoning with nominals in this special case.
Appendix A.5 contains all the definitions and theorems needed to prove theorems 10
and 11.

8. Conclusion
We have introduced a framework to compute the exact reformulation of first-order queries
to a database under ontologies. We have found the exact conditions which guarantee that
a safe-range reformulation exists, and we show that it can be evaluated as a relational
algebra query over the database to give the same answer as the original query under the
ontology. A non-trivial case study has been presented in the field of description logics, with
the ALCHOIQ language.
We have also implemented a tool based on the Prover9 theorem prover (McCune, 2011).
Given an arbitrary first-order ontology, a database signature, and an arbitrary first-order
query in TPTP syntax, the tool performs all the tests on them to check whether a reformulation can be computed, and it computes an optimal safe-range reformulation.
902

fiExact Query Reformulation over DBs with FO and DL Ontologies

This framework is useful in data exchange-like scenarios, where the target database
(made by determined relations) should be materialised as a proper database, over which
arbitrary queries should be performed. This is not achieved in a context with non-exact
rewritings preserving the certain answers. In our scenario with description logics ontologies,
rewritings of concept queries are pre-computed offline once. We have shown that our framework works in theory also in the case of arbitrary safe-range first-order queries, and our tool
shows that this is possible in practice. In the case of description logics, we are working on
extending the theoretical framework with conjunctive queries: we need finitely controllable
determinacy with conjunctive queries, which seems to follow for some description logic from
the works by Barany, Gottlob, and Otto (2010) and Rosati (2011).
In future work, we would like to study optimisations of reformulations. From the practical perspective, since there might be many rewritten queries from one original query, the
problem of selecting an optimised query in terms of query evaluation is very important. In
fact, one has to take into account which criteria should be used to optimise, such as: the
size of the rewritings, the numbers of used predicates, the priority of predicates, the number
of relational operators, and clever usage of duplicates. With the tool, we plan to evaluate
our proposed technique in a real context.
Concurrently, we are exploring the problem of fixing real ontologies in order to enforce
definability when it is known it should be the case (Franconi, Ngo, & Sherkhonov, 2012c).
This happens when it is intuitively obvious that the answer of a query can be found from
the available data (that is, the query is definable from the database), but the mediating
ontology does not entail the definability. We introduce the novel problem of definability
abduction and we solve it completely in the data exchange scenario.
We thank the anonymous reviewers for the very useful comments we got on earlier versions of this paper. We wish to thank Alex Borgida, Tommaso Di Noia, Umberto Straccia,
David Toman, and Grant Weddell for the fruitful discussions we had on the topics of this
paper.

Appendix A. Proofs
A.1 Proofs of Section 2
Proposition 1
Proof.

Let

Asna = { | dom() = X, rng()  C,  I  I(SNA)M (KB)E(DB) : I |= Q[X/] }
and
Auna = { | dom() = X, rng()  C,  I  I(UNA)M (KB)E(DB) : I |= Q[X/] }
Since SNA is stricter than UNA, i.e. I(SNA)  I(UNA), we have: Auna  Asna trivially.
Let   Asna . If  
/ Auna then there is an interpretation I = hI , I i embedding
DB and satisfying UNA such that I  M (KB) and I 6|= Q[X/] . Let us construct new


interpretation J = hJ , J i embedding DB as follows:


 J := (I \ {aI | a  C})  C;
903

fiFranconi, Kerhet, & Ngo



 for each constant a  C, aJ := a;


 for every predicate P  P, PJ is constructed from PI by replacing of each element
aI  PI , where a is some constant, with a.
Obviously, J satisfies SNA and J and I are isomorphic. Since first-order logic sentences cannot distinguish two isomorphic structures, J 6|= Q[X/] which contradicts with
the assumption   Asna . Therefore   Auna .
A.2 Proofs of Section 4
Proposition 2.
b[X] is an exact reformulation of Q[X] , KB |= X.Q[X]  Q
b[X] . Then, for any
Proof. Since Q
I
b[X] ,
model I  M (KB) and for any substitution  : X 7  we have: I,  |= Q[X]  Q
b[X] ).
which is equivalent to (I,  |= Q[X]  I,  |= Q
Now, let  be any substitution from { | dom() = X, rng() = C,  I  M (KB) 
E(DB) : I |= Q[X/] }, and I = h, I i be any model of the KB embedding the DB (if
there are any). Let  := I  a composition of the substitution  and the interpretation
function I (i.e. (x) = a   iff (x) = c  C and cI = a). Then I,  |= Q[X] 
b[X]  I |= Q
b
b
I |= Q[X/] and I,  |= Q
[X/] . Summing up: I |= Q[X/]  I |= Q[X/] .
b[X/] }. The
Hence,   { | dom() = X, rng() = C,  I  M (KB)  E(DB) : I |= Q
inverse inclusion can be proved similarly.
Theorem 3.
Proof. First of all recall that we assume SNA. In order to prove the theorem, one needs the
following two propositions.
Proposition 3 (Domain Independence). A query Q[X] is domain independent iff for
every two interpretations I = hI , I i and J = hJ , J i which agree on the interpretation
of the predicates from PQ (and all constants C), and for every substitution  : X 7 I J
we have:
rng()  I and I,  |= Q[X]
iff
rng()  J and J ,  |= Q[X] .
Proof. () Obviously, if the second part of the proposition holds, then the query is domain
independent.
() Suppose, the query is domain independent. Let I = hI , I i and J = hJ , J i
be any two interpretations, which agree on the interpretation of all the predicates from PQ
(and all constants C), that is I|PQ C = J |PQ C . Let us fix any substitution  : X 7 I J
(if the query is closed, we just omit everything, that concerns a substitution below in the
proof) such that:
rng()  I and I,  |= Q[X] .
(2)
904

fiExact Query Reformulation over DBs with FO and DL Ontologies

0

0

Let us consider interpretations I 0 = hI , I i and J 0 = hJ , J i, such that I|PQ C =
0
0
0
I 0 |PQ C

= J |PQ C = J |PQ C , and P  P \ PQ : P I =  = P J . Let us consider now I and
I 0 . They have the same domain and interpret all the predicates and constants, occurring
in Q[X] equally. Therefore, since I,  |= Q[X] (by (2)), I 0 ,  |= Q[X] .
Let us consider interpretations I 0 and J 0 . By construction, they agree on interpretation of all predicates and constants. Therefore, we can apply the definition of domain
independence to them. Then, since
rng()  I and I 0 ,  |= Q[X] ,

(3)

rng()  J and J 0 ,  |= Q[X] .

(4)

we have, that
Then again interpretations J and J 0 have the same domain and interpret all the predicates
and constants, occurring in Q[X] equally. Thus, because of (4),
rng()  J and J ,  |= Q[X] .

(5)

Therefore, (2) = (5). Similarly (5) = (2), and the proposition is proved.

Proposition 4. If Q[X] is domain independent, then for any interpretation I = h, I i
and any substitution  : X 7 , such that I,  |= Q[X] , the following holds:
rng()  adom((Q[X] ), I).
Proof. Assume, that X = {x}, that is Q has one free variable x (the proof can be easily
extended then to the general case).
Let us prove by contradiction. Suppose, there exists a substitution {x  b} such that
I, {x  b} |= Q(x) and b   \ adom((Q(x)), I). Let us consider interpretation I 0 =
h  {a}, I i, where a is any brand-new element, that does not appear in . Then I 0 , {x 
b} |= Q(x) because of domain independence of Q(x). Consider then another interpretation
00
I 00 = h  {a}, I i such that occurrence of b in interpretation of any predicate is replaced
with the element a. In other words, for any n-ary predicate P  P \ (Q(x)), (. . . , a, . . .) 
00
0
P I iff (. . . , b, . . .)  P I (since by supposition b does not appear in interpretations of
predicates in the query). Interpretations of all the other predicates and all the constants
are the same. Then I 00 satisfies SNA (even if b  C). Then, since I 0 , {x  b} |= Q[X] , by
construction of I 00 we have: I 00 , {x  a} |= Q(x), because we changed just interpretations
of predicates, that do not appear in the query. Then since I 0 and I 00 have the same domain
and agree on interpretations of all the predicates in Q(x) and all constants, the following
holds: I 0 , {x  a} |= Q(x).
Let us now consider interpretations I = h, I i and I 0 = h  {a}, I i. They have the
same interpretation function. Therefore, since Q(x) is domain independent and I 0 , {x 
a} |= Q(x), we have: rng({x  a})  . That is a  . It is a contradiction, because by
supposition a 6 .
905

fiFranconi, Kerhet, & Ngo

Now we prove the theorem itself.
L := { | dom() = X, rng()  C,  I  M (KB)  E(DB) : I |= Q[X/] };
b DB), I = hC, I i  E(DB) : I|P
R := { | dom() = X, rng()  adom((Q),

DB C

b[X/] }.
|= Q

b
Let   L. Then for any I  M (KB)  E(DB) we have: I |= Q[X/] and I |= Q
[X/] ,
because of Proposition 2.
Consider any J = hC, I i embedding DB. I and J agree on interpretations of C
b  P which is a subset of PDB .
(since we have SNA) and predicates from the set (Q)
b[X] is domain independent, by Proposition 3 we have: J |= Q
b
Then, since Q
[X/] . Since
b
b
b
(Q[X] )  PDB  C, J |P C |= Q
. Since Q[X] is domain independent, by Proposition
DB

[X/]

b[X] ), J ). adom((Q
b[X] ), J ) = adom((Q
b[X] ), DB), because
4 we have: rng()  adom((Q
b[X] )  PDB  C. Therefore, rng()  adom((Q
b[X] ), DB). Then
we assume SNA and (Q
  R and, hence, L  R.
b[X] ), DB)). Then for any J = hC, I i embedding DB we
Let   R (rng()  adom((Q
b
b
have: J |PDB C |= Q
[X/] . Then J |= Q[X/] . Consider any I  M (KB)  E(DB). Then J
b
and I agree on interpretations of C (since we have SNA) and PDB . Since (Q
)  PDB C
[X/]

b[X] is domain independent, by Proposition 3 we have: I |= Q
b
b
and Q
[X/] . Since Q[X] is exact
reformulation of Q[X] under KB over PDB , by Proposition 2 we have: I |= Q[X/] . Then
  L and, hence, R  L.
Theorem 3 is proved completely.
A.3 Definitions and Proofs of Section 5
Proposition 5. Let KB be a domain independent ontology. If interpretation I = hI , I i
is a model of KB, then any J = hJ , J i, such that I = J , is also a model of KB.
Proof. Let  be any sentence from KB. Then, since I is a model of KB, I |= .  is domain
independent, because KB is domain independent. Hence, since I = J , J |= . Thus, J is
a model of any sentence from KB. It means, that J is a model of KB.

Proposition 6. Let KB be an ontology, and let Q[X] be a query which is domain independent
with respect to KB. Any exact reformulation of Q[X] under KB (over any set of predicates)
is also domain independent with respect to KB.
b[X] be any exact reformulation of Q[X] under KB (over some set of predicates),
Proof. Let Q
I
I
I = h ,  i and J = hJ , J i be any two models of KB such that I = J , and
 : X 7 I  J be any substitution such that
b[X] .
rng()  I and I,  |= Q
b
Then, since Q[X] is exact reformulation of Q[X] , we have: I,  |= Q[X] . Then, since Q[X]
is domain independent with respect to KB, we have:
rng()  J and J ,  |= Q[X] .
b[X] is exact reformulation of Q[X] , we have: J ,  |= Q
b[X] . Thus, Q
b[X]
And again, since Q
is domain independent with respect to KB by definition.

906

fiExact Query Reformulation over DBs with FO and DL Ontologies

Lemma 1. Let KB be a domain independent ontology, and let Q[X] be a query which is
domain independent with respect to KB. Then for any I = h, I i which is a model of KB
and any substitution  : X 7  such that I,  |= Q[X] the following holds:
rng()  adom((Q[X] ), I).
Proof. Without loss of generality assume, that X = {x}, that is Q has one free variable x
(the proof can be easily extended then to the general case).
Let us prove by contradiction. Suppose that I, {x  b} |= Q(x), where b   \
adom((Q[X] ), I). Since KB is domain independent, for any brand-new element a, that
does not appear in , interpretation I = h  {a}, I i is also a model of KB by Proposition
5. Then, since Q(x) is domain independent with respect to KB and I and I have the same
interpretation function, I, {x  b} |= Q(x).
1
Consider a new interpretation I 1 = h  {a}, I i constructed from I such that occurrence of b in interpretation of any predicate is replaced by element a. In other words, for
1
any n-ary predicate P  P \ PQ , (. . . , a, . . .)  P I iff (. . . , b, . . .)  P I (since by supposition
b does not appear in interpretations of predicates in the query).
Then, since I, {x  b} |= Q(x) and by construction of I 1 we have: I 1 , {x  a} |= Q(x)
(since we simply replace b, that does not appear neither as a constant in Q(x) nor in
interpretations of predicates in Q(x), with a). Then, since I and I 1 have the same domain
  {a} and agree on interpretations of all the predicates from Q(x) and all the constants
(since we assume SNA), we have: I, {x  a} |= Q(x).
Let us now consider interpretations I = h, I i and I = h  {a}, I i. They are both
models of KB and have the same interpretation function I . So, since Q(x) is domain
independent with respect to KB and I, {x  a} |= Q(x), we have: a   and I, {x 
a} |= Q(x) by definition of domain independence with respect to an ontology. It is a
contradiction, because by supposition a 6 . The lemma is proved.
Let  be any set of formulas. Then Adom  is defined similarly to Adom Q , where Q is
a query.
Lemma 2. Let KB be a domain independent ontology, and let Q[X] (X = {x1 , ..., xn }) be a
query which is domain independent with respect to KB. Then the following holds:
KB |= X.Q[X]  Q[X] |Adom KBQ
where Q[X] |Adom KBQ is Q0 [X]  Adom KBQ (x1 )  ...  Adom KBQ (xn ), and Q0 [X] is Q[X]
such that:
 Every sub-formula of Q[X] in the form of x.(x) is replaced by x.(x)Adom KBQ (x)
 Every sub-formula of Q[X] in the form of x.(x) is replaced by x.Adom KBQ (x) 
(x)
Proof. Without loss of generality, we will prove the lemma when n = 1. In this case, we
write Q(x) instead of Q[X] . We prove by contradiction.
Assume there is a model I = hI , I i of KB and an element a  I such that I, {x 
a} |= Q(x) but I, {x  a} 6|= Q(x)|Adom KBQ .
907

fiFranconi, Kerhet, & Ngo

We construct a new interpretation J = hAdom IKBQ  C, J i such that for any predicate
P  PKBQ , P J := P I , and for any predicate P  P \ PKBQ , P J := .
Since KB is domain independent, J is also a model of KB by Proposition 5. Then,
J , {x  a} |= Q(x) because Q is domain independent with respect to KB. As a consequence, however, J , {x  a} |= Q(x)|Adom KBQ by the definition of Q(x)|Adom KBQ .
Q(x)|Adom KBQ is safe-range by construction (see Definition 10). Hence, it is domain
independent. Therefore I, {x  a} |= Q(x)|Adom KBQ . Contradiction.
Assume there is a model I = hI , I i of KB and an element a  I such that I, {x 
a} |= Q(x)|Adom KBQ but I, {x  a} 6|= Q(x). One can lead to a contradiction similarly
as above. Therefore, the lemma is proved.
Theorem 4.
Proof. The theorem can be proved after Theorem 5.
 The if direction. Based on Lemma 2, one can see that exact reformulations of Q[X]
are also exact reformulations of Q[X] |Adom KBQ . Since Q[X] |Adom KBQ is safe-range
and KB can always be transformed to a logically equivalent safe-range ontology KB 0 ,
b[X] found in Theorem 5 which takes
obviously the exact safe-range reformulation Q
0
KB and Q[X] |Adom KBQ as its input is the exact domain independent reformulation
of Q[X] .
 The only if direction.
b[X] of Q[X]
Suppose, that there exists an exact domain independent reformulation Q
over PDB under KB. Then it is domain independent with respect to KB. Hence, by
Proposition 6, Q[X] is domain independent with respect to KB. Since there exists an
exact reformulation of Q[X] , Q[X] is implicitly definable from PDB under KB by the
Theorem 1.
The theorem is proved completely.
In order to help readers follow easier, we recall here formal definitions of safe-range and
safe-range normal form (Abiteboul et al., 1995).
Definition 8 (safe-range normal form). denoted by SRNF
A first order formula can be transformed to SRNF by following steps :
 Variable substitution: no distinct pair of quantifiers may employ same variable.
 Remove universal quantifiers
 Remove implications
 Push negation
 Flatten and/or
908

fiExact Query Reformulation over DBs with FO and DL Ontologies

Definition 9 (Range restriction of a formula). denoted by rr
Input : a formula  in SRNF
Output : a subset of free() or 
Case  of
 R(e1 , ..., en ) : rr() = set of variables in e1 , ..., en
 x = a or a = x, where a is a constant : rr() = {x}
 x = y : rr() = 
 1  2 : rr() = rr(1 )  rr(2 )
 1  2 : rr() = rr(1 )  rr(2 )
 1  x = y : rr() = rr(1 ) if {x, y}  rr(1 ) = ; rr() = rr(1 )  {x, y} otherwise
 1 : rr() =   rr(1 )
 x1 : rr() = rr(1 )\{x} if x  rr(1 ); rr() =  otherwise
Note :   Z =   Z = \Z = Z\ = 
Definition 10 (safe-range). A formula  is safe-range iff rr(SRNF()) = free().
Definition 11 (ground safe-range). A formula  is ground safe-range iff after substitution of free variables of  with constants it becomes safe-range.
Observation 1.
1. For any query Q[X] and any interpretation I = h, I i the following holds:
Adom IQ = adom((Q[X] ), I).
2. Adom Q (x) is safe-range.
Theorem 5.
Proof. The theorem can be proved after Theorem 8 and Theorem 9.
We will use the following lemma in the proof.
Lemma 3. If KB is an ontology, Q[X] (X = {x1 , . . . , xn }) is ground safe-range query and
KB |= X. Q[X]  1 (x1 )  . . .  n (xn ),

(6)

b[X] := Q[X] 1 (x1 ). . .n (xn )
where 1 , . . . , n are n safe-range formulas, then the query Q
b
is safe-range and KB |= X. Q[X]  Q[X] .
909

fiFranconi, Kerhet, & Ngo

Proof. Let Q0[X] be a safe-range normal form of the query Q[X] , i.e. Q0[X] := SRNF(Q[X] ) =
Y. [XY] , where [XY] is in conjunctive normal form (the safe-range normal form of the
query is in prenex normal form). Then Q0[X] is ground safe-range, and KB |= Q0[X]  Q[X] .
Hence, KB |= X. Q0[X]  1 (x1 )  . . .  n (xn ). Let Q00[X] := Q0[X]  10 (x1 )  . . .  n0 (xn ),
where each i0 (xi ) = SRNF(i (xi )). Then by 6, KB |= Q0[X]  Q00[X] . On the other hand
b[X]  Q00 by construction. Summing up everything, we have: KB |= Q
b[X] 
KB |= X. Q
[X]

b[X] is safe-range.
Q[X] and the only thing we need to prove is that Q
00
0
One can see, that Q[X]  Y. ([XY] 1 (x1 ). . .n0 (xn )) which is a safe-range normal
b[X] . Since Q0 = Y. [XY] is ground safe-range, then rr([XY] ) \ X = Y0  Y,
form of Q
[X]

where for any y  Y\Y0 there exists a conjunct x = y in [XY] , for some x  X. Then, since
each i0 (xi ) is safe-range, by definition of range restriction rr([XY] 10 (x1 ). . .n0 (xn )) =
X  Y, and then rr(Y. ([XY]  10 (x1 )  . . .  n0 (xn ))) = X = free(Q00[X] ). Therefore,
b[X] is safeY. ([XY]  10 (x1 )  . . .  n0 (xn )) is safe-range by definition, and hence Q
range.
Let us continue to prove the theorem.
b by using
If X = , (Q is closed) then we build an exact safe-range reformulation Q
Theorem 8.
Suppose now, X = {x1 , . . . , xn }. Since Q[X] is safe-range and implicitly definable from
PDB , we apply Theorem 8 for Q[X] and construct a ground safe-range rewriting Q0[X] expressed over PDB such that KB |= X. Q[X]  Q0[X] . Since Q[X] is domain independent
(since it is safe-range), it is also domain independent with respect to KB. Hence, by Proposition 6, Q0[X] is also domain independent with respect to KB. Moreover, KB is safe-range
and, hence, domain independent. Then by Theorem 9:
KB |= X. Q0[X]  Adom Q (x1 )  . . .  Adom Q (xn ).
By the second item of Observation 1 Adom Q (x) is a safe-range formula. Then by Lemma 3
b[X] := Q0  Adom Q0 (x1 )  . . .  Adom Q0 (xn ) is safe-range and KB |= X. Q0 
the query Q
[X]
[X]
b[X] . Since KB |= X. Q[X]  Q0 , we have: KB |= X. Q[X]  Q
b[X] . Therefore, the
Q
[X]

b[X] is the one we were looking for.
constructed query Q
Theorem 5 is proved completely.
A.4 Proofs of Section 6
Theorem 7.
Proof. First we will prove that if Q is implicitly definable then the formula (1) is valid.
g |= X.Q[X]  Q
g
Applying syntactic definition of implicit definability: KB  KB
[X] . Therefore,
when
we
replace
X
by
a
set
of
constants
c
,
...,
c
,
the
following
formula
is valid
1
n
V
Vg
e[X/c ,...,c ] ). As a consequence, (1) is valid.
( KB  KB)
 (Q[X/c1 ,...,cn ]  Q
n
1
b[c ,...,c /X] ) where Q
b[X/c ,...,c ] is a Craig interNext, we have to prove KB |= (Q[X]  Q
n
0
n1
1
b[X/c ,...,c ] is an interpolant:
polant of (1). Since Q
1

n

910

fiExact Query Reformulation over DBs with FO and DL Ontologies

V
b[X/c ,...,c ]
1. (( KB)  Q[X/c1 ,...,cn ] )  Q
n
1
b[X/c ,...,c ] )
Then : KB |= (Q[X/c1 ,...,cn ]  Q
n
1
g Q
e[X/c ,...,c ] )
b[X/c ,...,c ]  ((V KB)
2. Q
n
n
1
1
g |= (Q
b[X/c ,...,c ]  Q
e[X/c ,...,c ] ).
Then : KB
n
n
1
1
b  PDB , the relation KB |= (Q
b[X/c ,...,c ]  Q[X/c ,...,c ] ) holds as well
Since (Q)
n
n
1
1
From(1)(2) we have the expected statement.
b[X/c ,...,c ] )  PDB then (Q
b[c ,...,c /X] )  PDB .
Last but not least, since (Q
n
n
1
1
b[c ,...,c /X] is really an explicit definition of Q
With above statements, Q
n
1
Theorem 8.
Proof. We need the following propositions to prove the theorem.
Proposition 7. 1  2 is safe-range and closed iff 1 and 2 are safe-range and closed.
Proof. We have:
 rr(1  2 ) = rr(1 )  rr(2 )
 free(1  2 ) = free(1 )  free(2 )
 rr(1 ) =  or rr(1 )  free(1 )
 rr(2 ) =  or rr(2 )  free(2 )
 1  2 is closed iff f ree(1 ) = free(2 ) = 
 1 is closed iff free(1 ) = 
 2 is closed iff free(2 ) = 
 1  2 is safe-range iff rr(1  2 ) = free(1  2 )
 1 is safe-range iff rr(1 ) = free(1 )
 1 is safe-range iff rr(2 ) = free(2 )
Therefore:
 1  2 is closed iff 1 and 2 are closed
 1  2 is closed, safe-range iff 1 and 2 are closed, safe-range.

Proposition 8. 1  2 is safe-range and closed iff 1 and 2 are safe-range and closed.
Proof. We have:
 rr(1  2 ) = rr(1 )  rr(2 )
911

fiFranconi, Kerhet, & Ngo

 free(1  2 ) = free(1 )  free(2 )
 rr(1 ) =  or rr(1 )  free(1 )
 rr(2 ) =  or rr(2 )  free(2 )
 1  2 is closed iff free(1 ) = free(2 ) = 
 1 is closed iff free(1 ) = 
 2 is closed iff free(2 ) = 
 1  2 is safe-range iff rr(1  2 ) = free(1  2 )
 1 is safe-range iff rr(1 ) = free(1 )
 1 is safe-range iff rr(2 ) = free(2 )
Therefore:
 1  2 is closed iff 1 and 2 are closed
 1  2 is closed, safe-range iff 1 and 2 are closed, safe-range.

Proposition 9. ~x(~x) is closed and safe-range then (~t) is closed and safe-range where
~t are constants.
Proof. Obviously, if ~x(~x) is closed then (~t) is closed.
Assume that (~t) is not safe-range. Since its closed rr(SRNF((~t))) = 
 SRNF((~t)) must contain a subformula which is in the form ~z0 (~t, ~z)
where ~z 6 rr(SRNF(0 (~t, ~z)))
 SRNF((~x)) must contain a subformula which is in the form ~z0 (~x, ~z)
where ~z 6 rr(SRNF(0 (~x, ~z)))
 SRNF((~x)) must contain a subformula which is in the form ~z0 (~x, ~z)
where ~z 6 rr(SRNF(0 (~x, ~z))) because pushing negation does not effect the formula under

 rr(SRNF((~x))) = 
 rr(SRNF(~x(~x))) = 
 rr(SRNF(~x(~x))) = 
~x(~x) is not safe-range
 contradiction.
Proposition 10. ~x(~x) is closed and safe-range then (~t) is closed and safe-range where
~t are constants.
Proof. Undoubtedly, if ~x(~x) is closed then (~t) is closed.
Assume that (~t) is not safe-range. Since it is closed, rr(SRNF((~t))) = 
 SRNF((~t)) must contain a subformula which is in the form ~z0 (~t, ~z)
where ~z 6 rr(SRNF(0 (~t, ~z)))
912

fiExact Query Reformulation over DBs with FO and DL Ontologies

 SRNF((~x)) must contain a subformula which is in the form ~z0 (~x, ~z)
where ~z 6 rr(SRNF(0 (~x, ~z)))
 rr(SRNF((~x))) = 
 rr(SRNF(~x(~x))) = 
~x(~x) is not safe-range
 contradiction.
Based on these propositions, we prove Theorem 8 as follows.
First, we will show that if  and  are closed and safe-range and    is valid then
so is their interpolant. Assume T is a biased tableau of of   . Therefore the root node
of T is S = {L(), R()}. Based on all the tableau expansion rules and above propositions, at every expansion step where S = {L(1 ), ..., L(n ), R(1 ), ..., R(m )}, 1 , ..., n
and 1 , ..., m are safe-range and closed(*) .
Now we need to prove that the interpolant at each step is safe-range and closed (**) by
induction on the shape of proof and the set of rules in Section 6.
 Rules for closed branches: Its trivial because  and  are safe-range and closed
because of (*)
 Rules for propositional case :
For the rule (p1)(p2)(p3)(p4) nothing changes, so one does not need to prove.
For the rule (p5), apply the Proposition 8, (**) holds.
For the rule (p6), apply the Proposition 7,(**) holds.
 Rules for first order case :
For the rule (f1) (f2) (f3) nothing changes, so one does not need to prove.
For the rule (f4), since c does not occur in {1 , ..., n } then the only case to have c in
int
I is that S contains R((c)). Therefore S  {L((c))}  I = (c). Since x.(x) is
safe-range (due to (*)) then x.I[c/x] is safe-range too
For the rule (f5), since c does not occur in {1 , ..., m } then the only case to have c in
int
I is that S contains L((c)). Therefore S  {R((c))}  I = (c). Since x.(x)
is safe-range (due to (*)) then x.I[c/x] is safe-range too
 Rules for equality : Because all the input formulas are closed and do not contain
function symbols, all equations are ground. Therefore, they do not influence the
safe-range property of interpolant in each step.
As a consequence, because Q(~c), KB, KB 0 ,Q0 (~c) are closed and safe-range then so is the
b c) of KB  Q(~c) and KB 0  Q0 (~c).
interpolant Q(~
Theorem 9.
Proof. As a consequence of Lemma 1, Theorem 9 holds.
913

fiFranconi, Kerhet, & Ngo

A.5 Definitions and Proofs of Section 7
The safe-range fragment of ALCHOIQ. We call any axiom (concept) in ALCHOIQ
(ground) safe-range, if the corresponding logically equivalent (open) formula in FOL(C, P)
is (ground) safe-range. For any concept C we denote the corresponding logically equivalent
formula in FOL(C, P) with one free variable x as C(x). Unfortunately concept inclusion
axioms in ALCHOIQ ontologies may not be safe-range: for example, the axiom  male v
female is not safe-range. It is easy to see that an axiom C v D is not safe-range if and only
if C(x) is not safe-range and D(x) is safe-range: just observe that the axiom is logically
equivalent to the formula x. C(x)  D(x) in FOL(C, P) (which is actually in a saferange normal form). The following proposition provides recursive rules deciding whether
an ALCHOIQ concept is safe-range.
Proposition 11. Let A be an atomic concept, let C and D be ALCHOIQ concepts, and
let R be either an atomic role or an inverse atomic role. Then:
1. A, {o},  nR,  nR.C are safe-range;
2. C u D is safe-range if and only if C is safe-range or D is safe-range;
3. C t D is safe-range if and only if C is safe-range and D is safe-range;
4. C is safe-range if and only if C is not safe-range.
Proof. It is enough to prove the proposition just for atomic roles because the order of
variables in binary atoms of a first-order logic translation of an ALCHOIQ concept does
not affect the safe-range property of the translation. Therefore hereafter we assume that R
is an atomic role.
 Since A is an atomic concept, A(x) is safe-range.
 {o}(x) = (x = o) - safe-range.
 ( nR)(x) = x1 , . . . , xn . R(x, x1 )  . . .  R(x, xn )  (x1 6= x2 )  . . .  (xn1 6= xn ) safe-range.
 ( nR.C)(x) = x1 , . . . , xn . R(x, x1 )  . . .  R(x, xn )  C(x1 )  . . .  C(xn )  (x1 6=
x2 )  . . .  (xn1 6= xn ) - safe-range.
 Let us prove, that (C u D)(x) = C(x)  D(x) is safe-range if and only if C(x) is
safe-range or D(x) is safe-range.
) Let C(x) or D(x) be safe-range and let both of them be in safe-range normal
forms. Then
C(x)  D(x) is safe-range by definition.
) Let C(x)  D(x) be safe-range and in safe-range normal form (i.e. both C(x) and
D(x) are in safe-range normal form). Let us prove by contradiction. Suppose, both
C(x) and D(x) are not safe-range. Then C(x)  D(x) is not safe-range by definition.
It is a contradiction. Therefore, C(x) is safe-range or D(x) is safe-range.
914

fiExact Query Reformulation over DBs with FO and DL Ontologies

 Let us prove, that (C t D)(x) = C(x)  D(x) is safe-range if and only if C(x) is
safe-range and D(x) is safe-range.
) Let C(x) and D(x) be both safe-range and in safe-range normal forms. Then
C(x)  D(x) is safe-range by definition.
) Let C(x)  D(x) be safe-range and in safe-range normal form (i.e. both C(x) and
D(x) are in safe-range normal form). Let us prove by contradiction. Suppose, C(x)
or D(x) is not safe-range. Then C(x)  D(x) is not safe-range by definition. It is a
contradiction. Therefore, C(x) is safe-range and D(x) is safe-range.
 Let us prove, that C(x) is safe-range if and only if C(x) is not safe-range.
) Let C(x) be safe-range. Let us prove by contradiction. Let C(x) be also saferange. Then both C(x) and C(x) are domain independent. But one can easily see
(looking at the definition of domain independence), that it is impossible. Therefore,
C(x) is not safe-range. ) We need to prove, that if C(x) is not safe-range, then
C(x) is safe-range.
Let us prove by induction on structure of the formula. Suppose, the item is true for
any subformula of the formula C(x).
Suppose, C(x) is not safe-range. Let us consider (using already proved items) all the
possible cases, when C(x) is not safe-range.
 C(x) = (R.D)(x) = y. R(x, y)  D(y)  y.R(x, y)D(y) - not safe-range,
where D is any (possibly complex) concept. Then C(x) = y.R(x, y)  D(y)
is safe-range by definition.
 Suppose, C(x) = (D u F )(x) is not safe-range. Then D(x) is not safe-range and
F (x) is not safe-range. Since both D(x) and F (x) are subformulas of C(x), by
applying the current item we get: D(x) and F (x) are safe-range. C(x) 
(D(x)  F (x))  D(x)  F (x) - safe-range, because D(x) and F (x) are
safe-range.
 Suppose, C(x) = (D t F )(x) is not safe-range. Then D(x) is not safe-range or
F (x) is not safe-range. Since both D(x) and F (x) are subformulas of C(x), by
applying the current item we get: either D(x) or F (x) is safe-range. C(x) 
(D(x)  F (x))  D(x)  F (x) - safe-range, because either D(x) or F (x)
is safe-range.
 Suppose, C(x) = D(x) is not safe-range. We need to prove, that C(x)  D(x)
is safe-range. Let us prove by contradiction. Suppose, D(x) is not safe-range.
Then, since D(x) is a subformula of C(x), by applying the current item we get:
D(x)  C(x) is safe-range. It is a contradiction. Hence, C(x) is safe-range.
The item is proved completely.
The proposition is proved completely.
Proposition 12. All ALCHOIQ role inclusion axioms are safe-range.
915

fiFranconi, Kerhet, & Ngo

Proof. Let S v R be any role inclusion axiom in ALCHOIQ. The formula x, y. S(x, y) 
R(x, y) is a first-order logic translation of the axiom, where (x, y) stands for (x, y) if the
preceding role is atomic and (x, y) stands for (y, x) if the preceding role is inverse atomic.
This formula is safe-range.
Guarded negation first-order logic. We recall the definition of guarded negation firstorder logic (GNFO) given in the paper by Barany et al. (2012). GNFO is a fragment of
first-order logic consisting of all formulas generated by the following recursive definition:
 ::= R(t1 , . . . , tn ) | t1 = t2 | 1  2 | 1  2 | x.  |   

(7)

where each ti is either a variable or a constant,  in    is an atomic formula (possibly
an equality statement) containing all free variables of .
Guarded negation fragment of ALCHOIQ. Now we consider ALCHOIQGN - a
guarded negation fragment of ALCHOIQ (i.e. an intersection of GNFO and ALCHOIQ).
We say, that
 a concept C is an ALCHOIQGN concept if C is an ALCHOIQ concept and the
corresponding first-order logic translation C(x) is expressed in GNFO;
 a concept inclusion axiom C v D is an ALCHOIQGN concept inclusion axiom if
C and D are ALCHOIQ concepts and the formula x. C(x)  D(x) (which is
equivalent to the first-order translation of C v D) is expressed in GNFO;
 a role inclusion axiom S v R is an ALCHOIQGN role inclusion axiom if S and R are
roles (atomic or inverse atomic) and the formula x, y. S(x, y)  R(x, y) , where
(x, y) stands for (x, y) if the preceding role is atomic and (x, y) stands for (y, x) if
the preceding role is inverse atomic, is expressed in GNFO.
It is easy to see, that any ALCHOIQ role inclusion axiom is an ALCHOIQGN role inclusion
axiom. Then because of Proposition 12 the following holds.
Proposition 13.

 All ALCHOIQGN role inclusion axioms are safe-range.

 All safe-range role inclusion axioms in ALCHOIQ are in ALCHOIQGN .
From the definition of GNFO and ALCHOIQ it follows, that the complex concept C
of the logic ALCHOIQGN is recursively defined as follows:
B ::= A | {o} |  nR
C ::= B |  nR.C |  nR.C | B u C | C u D | C t D

(8)

where A is an atomic concept, R is an atomic role or an inverse atomic role, and C and D
are ALCHOIQGN concepts (possibly complex).
Note, that in general, according to the definition (7) of GNFO all formulas with atleast
operator for n  2 are not in GNFO because of non-guarded inequality statements xi 6=
xj . We fix this by assuming that inequality relation is actually a special binary database
predicate. This assumption is usual for databases.
916

fiExact Query Reformulation over DBs with FO and DL Ontologies

Also strictly speaking  nR u C is not in GNFO. Indeed, the formula
(x1 , . . . , xn . R(x, x1 )  . . .  R(x, xn )  (x1 6= x2 )  . . .  (xn1 6= xn ))  C(x) is not in
GNFO (R(x, y) here stands for P (x, y) if R stands for an atomic role P , and R(x, y) stands
for P (y, x) if R stands for an inverse atomic role P  ), but it can be easily transformed to a
logically equivalent GNFO one by simply shifting the parentheses: x1 , . . . , xn . (R(x, x1 ) 
. . .  R(x, xn )  (x1 6= x2 )  . . .  (xn1 6= xn )  C(x)). So, we can assume, that the formula
 nR u C is in ALCHOIQGN .
Proposition 14. All ALCHOIQGN concepts are safe-range.
Proof. Let us prove by induction on the structure of ALCHOIQGN concepts defined by
(8).
1. A, {o},  nR,  nR.C,  nR.C (C is an ALCHOIQGN concept) are safe-range
because of the item 1 of Proposition 11.
2. For any atomic concept A, any individual o any role R and any natural number n the
concepts A u C, {o} u C and  nR u C are safe-range because of the item 3 of
Proposition 11 and since A, {o} and  nR are safe-range by the first item.
3. Suppose, that ALCHOIQGN concepts C and D are safe-range. Then the concepts
C u D and C t D are safe-range by the items 2 and 3 of Proposition 11 respectively.
The proposition is proved.
Lemma 4. For any safe-range concept C in ALCHOIQ the following holds:
C v B1 t . . . t Bn ,
where Bi appears as a subconcept in C and is one of the following concepts:
 an atomic concept A;
 {o}, where o is an individual name;
  nR, where R is an atomic role or inverse atomic role, n is a natural number.
Proof. Let us prove the proposition by induction for all safe-range concepts of ALCHOIQ.
 A, {o},  nR,  nR.C are safe-range by Proposition 11. A v A, {o} v {o},  nR v
 nR,  nR.C v  nR.
Suppose now that C is a complex safe-range concept and the proposition holds for all
safe-range subconcepts of C.
1. C = C1 u C2 - safe-range. Then either C1 or C2 is safe-range. Let C1 be safe-range.
Hence, C1 v B1 t . . . t Bm , where Bi is a concept of the aforementioned type. Then
C1 u C2 v C1 v B 1 t . . . t B m .
2. C = C1 t C2 - safe-range. Then C1 and C2 are safe-range. Hence, C1 v B1 t . . . t Bk
and C2 v Bk+1 t . . . t Bm , where Bi is a concept of the aforementioned type. Then
C1 t C2 v (B1 t . . . t Bk ) t (Bk+1 t . . . t Bm ) v B1 t . . . t Bm .
917

fiFranconi, Kerhet, & Ngo

3. C = D is safe-range. By Proposition 11 it is possible if and only if D is not saferange. That is one of the following cases takes place.
 D = D1 u D2 . Then D  D1 t D2 . And we reduced this case to the item 2.
 D = D1 t D2 . Then D  D1 u D2 . And we reduced this case to the item 1.
 D = D1 . Then D  D1  D1 . Hence, D1 is a safe-range subconcept of D.
Then the proposition holds for D1 and, hence, also for C, because C  D  D1 .
The lemma is proved completely.
Lemma 5. For any ALCHOIQ concept C there exists an ALCHOIQGN concept C 0 such
that either C  C 0 or C  C 0 .
Proof. Suppose that the lemma holds for all ALCHOIQ subconcepts of the ALCHOIQ
concept C. Let us prove it for C.
1. Base. A, {o},  nR are ALCHOIQGN concepts by the definition of ALCHOIQGN
concept (8).
2. C =  nR.D and D0 is an ALCHOIQGN concept such that D  D0 or D 
D0 . Then C  nR.D0 or C  nR.D0 .  nR.D0 and  nR.D0 are both
ALCHOIQGN concepts. Hence, the item is proved.
3. C = D and D0 is an ALCHOIQGN concept such that D  D0 or D  D0 . Then
C  D0 or C  D0  D0 . The item is proved.
4. C = C1 u C2 and C10 is an ALCHOIQGN concept such that C1  C10 or C1  C10 , C20
is an ALCHOIQGN concept such that C2  C20 or C2  C20 . Consider all possible
cases.
(a) C1  C10 and C2  C20 . Then C  C 0 , where C 0 = C10 u C20 is an ALCHOIQGN
concept (because C10 and C20 are ALCHOIQGN concepts).
(b) C1  C10 and C2  C20 . Then C  C10 u C20  (C10 t C20 ) = C 0 , where
C 0 = C10 tC20 is an ALCHOIQGN concept (because C10 and C20 are ALCHOIQGN
concepts).
(c) C1  C10 and C2  C20 (the case when C1  C10 and C2  C20 is the similar
one). Then C  C10 u C20 . Since C10 is an ALCHOIQGN concept by Proposition
14 it is safe-range and, hence, by Lemma 4 C10 v B1 t . . . t Bn , where each Bi is
either an atomic concept A or {o} or R. Then C10  C10 u (B1 t . . . t Bn ) and,
hence, C  C10 u (B1 t . . . t Bn ) u C20  C10 u (B1 u C20 t . . . t Bn u C20 ). Each
disjunct Bi u C20 is an ALCHOIQGN concept (because C2 is ALCHOIQGN
concept and by the definition (8) of ALCHOIQGN concepts). Then C 0 = C10 u
(B1 u C20 t . . . t Bn u C20 ) is an ALCHOIQGN concept. C  C 0 . The item is
proved.
5. C = C1 t C2  (C1 u C2 ). This case is reduced to the items 3 and 4.
918

fiExact Query Reformulation over DBs with FO and DL Ontologies

The lemma is proved completely.
Corollary 2. For any ALCHOIQ concept C and any concept B, which is either an atom
A or {o} or  nR, the concept B u C is equivalent to some ALCHOIQGN concept.
Proof. By Lemma 5 there exists an ALCHOIQGN concept C 0 such that either C  C 0
or C  C 0 . Then B u C  B u C 0 or B u C  B u C 0 . Both B u C 0 and B u C 0
are ALCHOIQGN concepts (by the definition (8) of ALCHOIQGN concepts). Hence, the
corollary is proved.
Proposition 15. Any safe-range ALCHOIQ concept is equivalent to some ALCHOIQGN
concept.
Proof. Let C be any safe-range ALCHOIQ concept. By Lemma 4 C v B1 t . . . t Bn ,
where each Bi is either an atom A or {o} or  nR. Then C  C u (B1 t . . . t Bn ) 
B1 uCt. . .tBn uC. By the corollary 2 for each disjunct Bi uC there exists an ALCHOIQGN
concept Di such that Bi u C  Di . Then C  D1 t . . . t Dn . The concept D1 t . . . t Dn is an
ALCHOIQGN concept as a disjunction of ALCHOIQGN concepts. Hence, the proposition
is proved.
Proposition 16. All ALCHOIQGN concept inclusion axioms are safe-range.
Proof. Let C v D be any concept inclusion axiom in ALCHOIQGN . It means that the
corresponding first-order logic translation x. C(x)  D(x) is in GNFO. Hence, C(x) 
D(x) is in GNFO or, that is the same, C u D is in ALCHOIQGN . It is easy to see, that
x. C(x)  D(x) is safe-range if and only if the formula C(x)  D(x) is safe-range, that
is if and only if the corresponding ALCHOIQGN concept C u D is safe-range. But by
Proposition 14 any ALCHOIQGN concept is safe-range. The proposition is proved.
Lemma 6. For any safe-range ALCHOIQ concept C and any ALCHOIQ concept D the
concept C u D is equivalent to some ALCHOIQGN concept C 0 u D0 , where C 0 and D0 are
ALCHOIQGN concepts.
Proof. Since C is safe-range by Lemma 4 C v B1 t . . . t Bn , where each Bi is either an
atomic concept A or {o} or R. Then C  C u (B1 t . . . t Bn ) and, hence, C u D 
C u (B1 t . . . t Bn ) u D  C u (B1 u D t . . . t Bn u D). By the corollary 2 each disjunct
Bn uD is an ALCHOIQGN concept. Hence, D0 := B1 uDt. . .tBn uD is an ALCHOIQGN
concept. Since C is s safe-range by Proposition 15 there exists an ALCHOIQGN concept
C 0 such that C  C 0 . Then C u D  C 0 u D0 , and C 0 u D0 is an ALCHOIQGN concept,
where C 0 and D0 are ALCHOIQGN concepts.
Proposition 17. Any safe-range ALCHOIQ concept inclusion axiom C v D can be transformed to a concept inclusion axiom C 0 v D0 , where C 0 and D0 are ALCHOIQGN .
Proof. Let C v D be any safe-range ALCHOIQ concept inclusion axiom. Then the corresponding formula x. C(x)  D(x) is safe-range. Then the first-order logic formula
C(x)  D(x) is safe-range, or, that is the same, the ALCHOIQ concept C u D is saferange. By Proposition 11 we have that C is safe-range or D is safe-range.
919

fiFranconi, Kerhet, & Ngo

 C is safe-range. Then by Lemma 6 there exist two ALCHOIQGN concepts C 0 and
D0 such that C u D is logically equivalent to the ALCHOIQGN concept C 0 u D0 .
Then x. C(x)  D(x) is logically equivalent to x. C 0 (x)  D0 (x). Hence, C v D
is logically equivalent to C 0 v D0 (C 0 and D0 are ALCHOIQGN concepts).
 D is safe-range. The proof is similar to the previous item.
The proposition is proved completely.
Proposition 18. For any two ALCHOIQGN concepts C and D the axiom C v D is an
ALCHOIQGN concept inclusion axiom.
Proof. The axiom C v D is logically equivalent to the first-order logic formula x. C(x)
D(x), where C(x) and D(x) are in GNFO. Then x. C(x)  D(x) is also in GNFO. Hence,
by the definition of ALCHOIQGN concept inclusion axiom the axiom C v D is an
ALCHOIQGN concept inclusion axiom.
Propositions 17 and 18 imply the following.
Proposition 19. Any safe-range ALCHOIQ concept inclusion axiom is equivalent to some
ALCHOIQGN concept inclusion axiom.
We consider a connection between safe-range fragment of ALCHOIQ and guarded negation fragment of ALCHOIQ, that is ALCHOIQGN . When we say fragment, we mean a
set of TBox assertions (concept and role inclusion axioms) and concepts (open formulas) of
ALCHOIQ satisfying a particular property (e.g safe-range or guarded negation). Taking
into account propositions 14, 15, 16, 19 and 13, we have the following theorem.
Proposition 20. The safe-range fragment of ALCHOIQ and ALCHOIQGN are equally
expressive.
This proves Theorem 10:
Theorem 10 (Expressive power equivalence). The domain independent fragment of
ALCHOIQ and ALCHOIQGN are equally expressive.
Theorem 11. ALCHOIQGN TBoxes have finitely controllable determinacy of concept
queries.
Proof. We need to prove, that for any ALCHOIQGN TBox T (ontology), any concept
query Q in ALCHOIQGN and any set of database predicates PDB , whenever the query is
finitely determined by the database predicates under the ontology then it is also determined
in unrestricted models.
Suppose, that Q is finitely determined by PDB under T . Then from Theorem 2 it
e where |=fin P means entailment over models with a
follows, that T  Te |=fin PDB Q v Q,
DB
e
finite interpretation to the database predicates. Hence, in particular T  Te |=fin Q v Q,
where |=fin means entailment over finite models. Hereafter let  be one sentence, that is a
first-order logic translation of a conjunction of all axioms in the TBox T . Then from the
aforementioned entailment we have:
e
|=fin (  e
 )  (x. Q(x)  Q(x)).
920

(9)

fiExact Query Reformulation over DBs with FO and DL Ontologies

e
By Proposition 14 Q(x) is safe-range. Hence, Q(x)  Q(x)
is safe-range, hence the
e is safe-range and, hence, by Proposition 15 there exists an
ALCHOIQ concept Q u Q
e  C 0 . Then x. Q(x)  Q(x)
e
ALCHOIQGN concept C 0 such that Q u Q
 x.C 0 (x)
and the following holds:
|=fin (  e
 )  (x.C 0 (x)).
(10)
x.C 0 (x) is in GNFO, because C 0 (x) is in GNFO. Since all the axioms in T are ALCHOIQGN
TBox axioms, the sentences  and e are in GNFO. Then the sentence   e
 is in GNFO.
Therefore the right hand side of the entailment (10) is in GNFO. Then ((  e
) 
(x.C 0 (x))) is also in GNFO and by the entailment (10) does not have a finite model.
Then, since GNFO has the finite model property, ((  e
 )  (x.C 0 (x))) is unsatisfiable. Hence, we have:
|= (  e
 )  (x.C 0 (x)).
e
Since x.C 0 (x)  x. Q(x)  Q(x),
the following holds:
e
|= (  e
 )  (x. Q(x)  Q(x)).
e By Theorem 2 it means, that the query Q is determined in
Then T  Te |= Q v Q.
unrestricted models by the database predicates PDB under the ontology T .
The proposition is proved.

References
Abiteboul, S., Hull, R., & Vianu, V. (1995). Foundations of Databases. Addison-Wesley.
Artale, A., Calvanese, D., Kontchakov, R., & Zakharyaschev, M. (2009). The DL-Lite family
and relations. J. Artif. Intell. Res. (JAIR), 36, 169.
Avron, A. (2008). Constructibility and decidability versus domain independence and absoluteness. Theor. Comput. Sci., 394, 144158.
Barany, V., Gottlob, G., & Otto, M. (2010). Querying the guarded fragment. In Proceedings
of the 25th Annual IEEE Symposium on Logic in Computer Science (LICS 2010), pp.
110.
Barany, V., ten Cate, B., & Otto, M. (2012). Queries with guarded negation (full version).
CoRR, abs/1203.0077.
Beth, E. (1953). On Padoas method in the theory of definition. Indagationes Mathematicae,
15, 330339.
Craig, W. (1957). Three uses of the Herbrand-Gentzen theorem in relating model theory
and proof theory. J. Symb. Log., 22 (3), 269285.
Etzioni, O., Golden, K., & Weld, D. S. (1997). Sound and efficient closed-world reasoning
for planning. Artif. Intell., 89, 113148.
Fan, W., Geerts, F., & Zheng, L. (2012). View determinacy for preserving selected information in data transformations. Inf. Syst., 37, 112.
Fitting, M. (1996). First-order logic and automated theorem proving (2nd edition). Springer.
921

fiFranconi, Kerhet, & Ngo

Franconi, E., Ibanez-Garcia, Y. A., & Seylan, Inanc. (2011). Query answering with DBoxes
is hard. Electronic Notes in Theoretical Computer Science, Elsevier, 278, 7184.
Franconi, E., Kerhet, V., & Ngo, N. (2012a). Exact query reformulation over SHOQ DBoxes.
In Proc. of the 2012 International workshop on Description Logics (DL-2012).
Franconi, E., Kerhet, V., & Ngo, N. (2012b). Exact query reformulation with first-order ontologies and databases. In Logics in Artificial Intelligence - 13th European Conference,
JELIA 2012, pp. 202214.
Franconi, E., Ngo, N., & Sherkhonov, E. (2012c). The definability abduction problem for
data exchange. In Web Reasoning and Rule Systems - 6th International Conference
RR 2012.
Gurevich, Y. (1984). Toward logic tailored for computational complexity. In Computation
and Proof Theory, Vol. 1104, pp. 175216. Springer.
Halevy, A. Y. (2001). Answering queries using views: A survey. The VLDB Journal, 10,
270294.
Marx, M. (2007). Queries determined by views: pack your views. In Proceedings of the 26th
ACM symposium on Principles of Database Systems, PODS 07, pp. 2330.
McCune, W. (20052011).
prover9.

Prover9 and Mace4.

http://www.cs.unm.edu/~mccune/

Nash, A., Segoufin, L., & Vianu, V. (2010). Views and queries: Determinacy and rewriting.
ACM Trans. Database Syst., 35, 21:121:41.
Rosati, R. (2011). On the finite controllability of conjunctive query answering in databases
under open-world assumption. J. Comput. Syst. Sci., 77 (3), 572594.
Seylan, Inanc., Franconi, E., & de Bruijn, J. (2009). Effective query rewriting with ontologies over DBoxes. In Proc. of the 21st International Joint Conference on Artificial
Intelligence (IJCAI 2009), pp. 923925.
ten Cate, B., Franconi, E., & Seylan, Inanc. (2011). Beth definability in expressive description logics. In Proc. of the 22nd International Joint Conference on Artificial
Intelligence (IJCAI 2011), pp. 10991106.
ten Cate, B., Franconi, E., & Seylan, Inanc. (2013). Beth definability in expressive description logics. Journal of Artificial Intelligence Research (JAIR), 48, 347414.

922

fi