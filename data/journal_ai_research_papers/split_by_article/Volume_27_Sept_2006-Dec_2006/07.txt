Journal of Artificial Intelligence Research 27 (2006) 419-439

Submitted 12/05; published 12/06

Engineering Note
FluCaP: A Heuristic Search Planner for First-Order MDPs
Steffen Holldobler
Eldar Karabaev
Olga Skvortsova

sh@iccl.tu-dresden.de
eldar@iccl.tu-dresden.de
skvortsova@iccl.tu-dresden.de

International Center for Computational Logic
Technische Universitat Dresden, Dresden, Germany

Abstract
We present a heuristic search algorithm for solving first-order Markov Decision Processes (FOMDPs). Our approach combines first-order state abstraction that avoids evaluating states individually, and heuristic search that avoids evaluating all states. Firstly,
in contrast to existing systems, which start with propositionalizing the FOMDP and then
perform state abstraction on its propositionalized version we apply state abstraction directly on the FOMDP avoiding propositionalization. This kind of abstraction is referred to
as first-order state abstraction. Secondly, guided by an admissible heuristic, the search is
restricted to those states that are reachable from the initial state. We demonstrate the usefulness of the above techniques for solving FOMDPs with a system, referred to as FluCaP
(formerly, FCPlanner), that entered the probabilistic track of the 2004 International Planning Competition (IPC2004) and demonstrated an advantage over other planners on the
problems represented in first-order terms.

1. Introduction
Markov decision processes (MDPs) have been adopted as a representational and computational model for decision-theoretic planning problems in much recent work, e.g., by Barto,
Bradtke, and Singh (1995). The basic solution techniques for MDPs rely on the dynamic
programming (DP) principle (Boutilier, Dean, & Hanks, 1999). Unfortunately, classical dynamic programming algorithms require explicit enumeration of the state space that grows
exponentially with the number of variables relevant to the planning domain. Therefore,
these algorithms do not scale up to complex AI planning problems.
However, several methods that avoid explicit state enumeration have been developed
recently. One technique, referred to as state abstraction, exploits the structure of the factored MDP representation to solve problems efficiently, circumventing explicit state space
enumeration (Boutilier et al., 1999). Another technique, referred to as heuristic search,
restricts the computation to states that are reachable from the initial state, e.g., RTDP
by Barto et al. (1995), envelope DP by Dean, Kaelbling, Kirman, and Nicholson (1995) and
LAO by Feng and Hansen (2002). One existing approach that combines both these techniques is the symbolic LAO algorithm by Feng and Hansen (2002) which performs heuristic
search symbolically for factored MDPs. It exploits state abstraction, i.e., manipulates sets of
states instead of individual states. More precisely, following the SPUDD approach by Hoey,
St-Aubin, Hu, and Boutilier (1999), all MDP components, value functions, policies, and
admissible heuristic functions are compactly represented using algebraic decision diagrams
c
2006
AI Access Foundation. All rights reserved.

fiHolldobler, Karabaev & Skvortsova

(ADDs). This allows computations of the LAO algorithm to be performed efficiently using
ADDs.
Following ideas of symbolic LAO , given an initial state, we use an admissible heuristic
to restrict search only to those states that are reachable from the initial state. Moreover,
we exploit state abstraction in order to avoid evaluating states individually. Thus, our
work is very much in the spirit of symbolic LAO but extends it in an important way.
Whereas the symbolic LAO algorithm starts with propositionalization of the FOMDP,
and only after that performs state abstraction on its propositionalized version by means of
propositional ADDs, we apply state abstraction directly on the structure of the FOMDP,
avoiding propositionalization. This kind of abstraction is referred to as first-order state
abstraction.
Recently, following work by Boutilier, Reiter, and Price (2001), Holldobler and Skvortsova
(2004) have developed an algorithm, referred to as first-order value iteration (FOVI) that
exploits first-order state abstraction. The dynamics of an MDP is specified in the Probabilistic Fluent Calculus established by Holldobler and Schneeberger (1990), which is a
first-order language for reasoning about states and actions. More precisely, FOVI produces
a logical representation of value functions and policies by constructing first-order formulae
that partition the state space into clusters, referred to as abstract states. In effect, the
algorithm performs value iteration on top of these clusters, obviating the need for explicit
state enumeration. This allows problems that are represented in first-order terms to be
solved without requiring explicit state enumeration or propositionalization.
Indeed, propositionalizing FOMDPs can be very impractical: the number of propositions grows considerably with the number of domain objects and relations. This has a
dramatic impact on the complexity of the algorithms that depends directly on the number of propositions. Finally, systems for solving FOMDPs that rely on propositionalizing
states also propositionalize actions which is problematic in first-order domains, because the
number of ground actions also grows dramatically with domain size.
In this paper, we address these limitations by proposing an approach for solving FOMDPs
that combines first-order state abstraction and heuristic search in a novel way, exploiting
the power of logical representations. Our algorithm can be viewed as a first-order generalization of LAO , in which our contribution is to show how to perform heuristic search
for first-order MDPs, circumventing their propositionalization. In fact, we show how to
improve the performance of symbolic LAO by providing a compact first-order MDP representation using Probabilistic Fluent Calculus instead of propositional ADDs. Alternatively,
our approach can be considered as a way to improve the efficiency of the FOVI algorithm
by using heuristic search together with symbolic dynamic programming.

2. First-order Representation of MDPs
Recently, several representations for propositionally-factored MDPs have been proposed,
including dynamic Bayesian networks by Boutilier et al. (1999) and ADDs by Hoey et al.
(1999). For instance, the SPUDD algorithm by Hoey et al. (1999) has been used to solve
MDPs with hundreds of millions of states optimally, producing logical descriptions of value
functions that involve only hundreds of distinct values. This work demonstrates that large
420

fiFluCaP: A Heuristic Search Planner for First-Order MDPs

MDPs, described in a logical fashion, can often be solved optimally by exploiting the logical
structure of the problem.
Meanwhile, many realistic planning domains are best represented in first-order terms.
However, most existing implemented solutions for first-order MDPs rely on propositionalization, i.e., eliminate all variables at the outset of a solution attempt by instantiating terms
with all possible combinations of domain objects. This technique can be very impractical
because the number of propositions grows dramatically with the number of domain objects
and relations.
For example, consider the following goal statement taken from the colored Blocksworld
scenario, where the blocks, in addition to unique identifiers, are associated with colors.
G = X0 . . . X7 . red(X0 )  green(X1 )  blue(X2 )  red(X3 )  red(X4 )
red(X5 )  green(X6 )  green(X7 )  T ower(X0 , . . . , X7 ) ,
where T ower(X0 , . . . , X7 ) represents the fact that all eight blocks comprise one tower. We
assume that the number of blocks in the domain and their color distribution agrees with
that in the goal statement, namely there are eight blocks a, b, . . . , h in the domain, where
four of them are red, three are green and one is blue. Then, the full propositionalization
of the goal statement G results in 4!3!1! = 144 different ground towers, because there are
exactly that many ways of arranging four red, three green and one blue block in a tower of
eight blocks with the required color characteristics.
The number of ground combinations, and hence, the complexity of reasoning in a propositional planner, depends dramatically on the number of blocks and, most importantly, on
the number of colors in the domain. The fewer colors a domain contains, the harder it is to
solve by a propositional planner. For example, a goal statement G0 , that is the same as G
above, but all eight blocks are of the same color, results in 8! = 40320 ground towers, when
grounded.
To address these limitations, we propose a concise representation of FOMDPs within the
Probabilistic Fluent Calculus which is a logical approach to modelling dynamically changing
systems based on first-order logic. But first, we briefly describe the basics of the theory of
MDPs.
2.1 MDPs
A Markov decision process (MDP), is a tuple (Z, A, P, R, C), where Z is a finite set of
states, A is a finite set of actions, and P : Z  Z  A  [0, 1], written P(z 0 |z, a), specifies
transition probabilities. In particular, P(z 0 |z, a) denotes the probability of ending up at
state z 0 given that the agent was in state z and action a was executed. R : Z  R is a realvalued reward function associating with each state z its immediate utility R(z). C : A  R
is a real-valued cost function associating a cost C(a) with each action a. A sequential
decision problem consists of an MDP and is the problem of finding a policy  : Z  A that
maximizes the total expected discounted reward received when executing the policy  over
an infinite (or indefinite) horizon.
The value of state z, when starting in z and following the policy  afterwards, can be
computed by the following system of linear equations:
X
V (z) = R(z) + C((z)) + 
P(z 0 |z, (z))V (z 0 ),
z 0 Z

421

fiHolldobler, Karabaev & Skvortsova

where 0    1 is a discount factor. We take  equal to 1 for indefinite-horizon problems
only, i.e., when a goal is reached the system enters an absorbing state in which no further
rewards or costs are accrued. The optimal value function V  satisfies:
X
V  (z) = R(z) + max{C(a) + 
P(z 0 |z, a)V  (z 0 )} ,
aA

z 0 Z

for each z  Z.
For the competition, the expected total reward model was used as the optimality criterion. Without discounting, some care is required in the design of planning problems to
ensure that the expected total reward is bounded for the optimal policy. The following
restrictions were made for problems used in the planning competition:
1. Each problem had a goal statement, identifying a set of absorbing goal states.
2. A positive reward was associated with transitioning into a goal state.
3. A cost was associated with each action.
4. A done action was available in all states, which could be used to end further accumulation of reward.
These conditions ensure that an MDP model of a planning problem is a positive bounded
model described by Puterman (1994). The only positive reward is for transitioning into a
goal state. Since goal states are absorbing, that is, they have no outgoing transitions, the
maximum value of any state is bounded by the goal reward. Furthermore, the done action
ensures that there is an action available in each state that guarantees a non-negative future
reward.
2.2 Probabilistic Fluent Calculus
Fluent Calculus (FC) by Holldobler and Schneeberger (1990) was originally set up as a
first-order logic program with equality using SLDE-resolution as the sole inference rule.
The Probabilistic Fluent Calculus (PFC) is an extension of the original FC for expressing
planning domains with actions which have probabilistic effects.
States
Formally, let  denote a set of function symbols. We distinguish two function symbols in
, namely the binary function symbol , which is associative, commutative, and admits
the unit element, and a constant 1. Let  =  \ {, 1}. Non-variable  -terms are
called fluents. The function names of fluents are referred to as fluent names. For example,
on(X, table) is a fluent meaning informally that some block X is on the table, where on
is a fluent name. Fluent terms are defined inductively as follows: 1 is a fluent term; each
fluent is a fluent term; F  G is a fluent term, if F and G are fluent terms. For example,
on(b, table)  holding(X) is a fluent term denoting informally that the block b is on the table
and some block X is in the robots gripper. In other words, freely occurring variables are
assumed to be existentially quantified.
422

fiFluCaP: A Heuristic Search Planner for First-Order MDPs

We assume that each fluent may occur at most once in a state. Moreover, function
symbols, except for the binary  operator, constant 1, fluent names and constants, are
disallowed. In addition, the binary function symbol  is allowed to appear only as an
outermost connective in a fluent term. We denote a set of fluents as F and a set of fluent
terms as LF , respectively. An abstract state is defined by a pair (P, N ), where P  LF and
N  LF . We denote individual states by z, z1 , z2 etc., abstract states by Z, Z1 , Z2 etc.
and a set of abstract states LP N .
The interpretation over F, denoted as I, is the pair (, I ), where the domain  is a set
of all finite sets of ground fluents from F; and an interpretation function I which assigns
to each fluent term F a set F I   and to each abstract state Z = (P, N ) a set Z I  
as follows:
F I = {d   | .F   d}
Z I = {d   | .P   d  N  N . d 
/ (N )I },
where  is a substitution. For example, Figure 1 depicts the interpretation of an abstract
state Z
Z = (on(X, a)  on(a, table), {on(Y, X), holding(X 0 )})
that can be informally read: There exists a block X that is on the block a which is on
the table, there is no such block Y that is on X and there exists no such block X 0 that
the robot holds. Since Z I contains all such finite sets of ground fluents that satisfy the
P -part and do not satisfy any of the elements of the N -part, we subtract all sets of ground
fluents that belong to each of Ni  N from the set of ground fluents that correspond
to the P -part. Thus, the bold area in Figure 1 contains exactly those sets of ground
fluents (or, individual states) that do satisfy the P -part of Z and none of the elements of
its N -part. For example, an individual state z1 = {on(b, a), on(a, table)} belongs to Z I ,
whereas z2 = {on(b, a), on(a, table), holding(c)} does not. In other words, abstract states
are characterized by means of conditions that must hold in each ground instance thereof
and, thus, they represent clusters of individual states. In this way, abstract states embody
a form of state space abstraction. This kind of abstraction is referred to as first-order state
abstraction.
Actions
Actions are first-order terms starting with an action function symbol. For example, the
action of picking up some block X from another block Y might be denoted as pickup (X, Y ).
Formally, let Na denote a set of action names disjoint with . An action space is a tuple
A = (A, Pre , Eff ), where A is a set of terms of the form a(p1 , . . . , pn ), referred to as
actions, with a  Na and each pi being either a variable, or a constant; Pre : A  LP N is
a precondition of a; and Eff : A  LP N is an effect of a.
So far, we have described deterministic actions only. But actions in PFC may have
probabilistic effects as well. Similar to the work by Boutilier et al. (2001), we decompose a
stochastic action into deterministic primitives under natures control, referred to as natures
choices. We use a relation symbol choice/2 to model natures choice. Consider the action
pickup (X, Y ):
choice (pickup (X, Y ), A) 
(A = pickupS (X, Y )  A = pickupF (X, Y )) ,
423

fiHolldobler, Karabaev & Skvortsova

{on(b,a), on(a,table)}
{on(c,a), on(a,table), on(b,d)}
{on(b,a), on(a,table), holding(c)}
{on(c,a), on(a,table), on(b,c)}
{on(b,a), on(a,table)}
{on(c,a), on(a,table), on(b,d)}
{on(b,a), on(a,table), holding(c)}
{on(c,a), on(a,table), on(b,c)}

(b)

(a)
{on(b,a), on(a,table)}

{on(c,a), on(a,table), on(b,d)}
{on(b,a), on(a,table), holding(c)}
{on(c,a), on(a,table), on(b,c)}

(c)
Figure 1: (a) Interpretation of the fluent term F = on(X, a)  on(a, table); (b) Bold area is
the interpretation of the abstract state Z 0 = (on(X, a)  on(a, table), {on(Y, X)});
(c) Bold area is the interpretation of the abstract state Z = (on(X, a) 
on(a, table), {on(Y, X), holding(X 0 )}).

424

fiFluCaP: A Heuristic Search Planner for First-Order MDPs

where pickupS (X, Y ) and pickupF (X, Y ) define two natures choices for action pickup (X, Y ),
viz., that it succeeds or fails. For example, the natures choice pickupS can be defined as
follows:
Pre (pickupS (X, Y )) := (on(X, Y )  e, {on(W, X)})
Eff (pickupS (X, Y )) := (holding(X), {on(X, Y )}) ,
where the fluent e denotes the empty robots gripper. For simplicity, we denote the set of
natures choices of an action a as Ch (a) := {aj |choice (a, aj )}. Please note that nowhere
do these action descriptions restrict the domain of discourse to some pre-specified set of
blocks.
For each of natures choices aj associated with an action a we define the probability
prob (aj , a, Z) denoting the probability with which one of natures choices aj is chosen in a
state Z. For example,
prob (pickupS (X, Y ), pickup (X, Y ), Z) = .75
states that the probability for the successful execution of the pickup action in state Z is
.75.
In the next step, we define the reward function for each state. For example, we might
want to give a reward of 500 to all states in which some block X is on block a and 0,
otherwise:
reward (Z) = 500  Z v (on(X, a), )
reward (Z) = 0  Z 6v (on(X, a), ) ,
where v denotes the subsumption relation, which will be described in detail in Section 3.2.1.
One should observe that we have specified the reward function without explicit state enumeration. Instead, the state space is divided into two abstract states depending on whether
or not, a block X is on block a. Likewise, value functions can be specified with respect to
the abstract states only. This is in contrast to classical DP algorithms, in which the states
are explicitly enumerated. Action costs can be analogously defined as follows:
cost(pickup (X, Y )) = 3
penalizing the execution of the pickup -action with the value of 3.
Inference Mechanism
Herein, we show how to perform inferences, i.e., compute successors of a given abstract state,
with action schemata directly, avoiding unnecessary grounding. We note that computation
of predecessors can be performed in a similar way.
Let Z = (P, N ) be an abstract state, a(p1 , . . . , pn ) be an action with parameters
p1 , . . . , pn , preconditions Pre (a) = (Pp , Np ) and effects Eff (a) = (Pe , Ne ). Let  and 
be substitutions. An action a(p1 , . . . , pn ) is forward applicable, or simply applicable, to Z
with  and , denoted as forward (Z, a, , ), if the following conditions hold:
(f1) (Pp  U1 ) =AC1 P
(f2) Np  Np .N  N .(P  N  U2 ) =AC1 (P  Np ) ,
425

fiHolldobler, Karabaev & Skvortsova

where U1 and U2 are new AC1-variables and AC1 is the equational theory for  that is
represented by the following system of associativity, commutativity, and unit element
equations:
EAC1 = { (X, Y, Z) X  (Y  Z) = (X  Y )  Z
(X, Y ) X  Y = Y  X
(X) X  1 = X
}.
In other words, the conditions (f1) and (f2) guarantee that Z contains both positive and
negative preconditions of the action a. If an action a is forward applicable to Z with  and
 then Zsucc = (P 0 , N 0 ), where
P 0 := (Pe  U1 )
N 0 := N  \ Np   Ne 

(1)

is referred to as the a-successor of Z with  and  and denoted as succ(Z, a, , ).
For example, consider the action pickupS (X, Y ) as defined above, take Z = (P, N ) =
(on(b, table)  on(X1 , b)  e, {on(X2 , X1 )}). The action pickupS (X, Y ) is forward applicable
to Z with  = {X 7 X1 , Y 7 b, U1 7 on(b, table)} and  = {X2 7 W, U2 7 1}. Thus,
Zsucc = succ(Z, pickupS (X, Y ), , ) = (P 0 , N 0 ) with
P 0 = holding(X1 )  on(b, table) N 0 = {on(X1 , b)} .

3. First-Order LAO*
We present a generalization of the symbolic LAO algorithm by Feng and Hansen (2002),
referred to as first-order LAO (FOLAO ), for solving FOMDPs. Symbolic LAO is a
heuristic search algorithm that exploits state abstraction for solving factored MDPs. Given
an initial state, symbolic LAO uses an admissible heuristic to focus computation on the
parts of the state space that are reachable from the initial state. Moreover, it specifies MDP
components, value functions, policies, and admissible heuristics using propositional ADDs.
This allows symbolic LAO to manipulate sets of states instead of individual states.
Despite the fact that symbolic LAO shows an advantageous behaviour in comparison
to classical non-symbolic LAO by Hansen and Zilberstein (2001) that evaluates states
individually, it suffers from an important drawback. While solving FOMDPs, symbolic
LAO propositionalizes the problem. This approach is impractical for large FOMDPs. Our
intention is to show how to improve the performance of symbolic LAO by providing a
compact first-order representation of MDPs so that the heuristic search can be performed
without propositionalization. More precisely, we propose to switch the representational
formalism for FOMDPs in symbolic LAO from propositional ADDs to Probabilistic Fluent
Calculus. The FOLAO algorithm is presented in Figure 2.
As symbolic LAO , FOLAO has two phases that alternate until a complete solution
is found, which is guaranteed to be optimal. First, it expands the best partial policy and
evaluates the states on its fringe using an admissible heuristic function. Then it performs
dynamic programming on the states visited by the best partial policy, to update their values
and possibly revise the current best partial policy. We note that we focus on partial policies
that map a subcollection of states into actions.
426

fiFluCaP: A Heuristic Search Planner for First-Order MDPs

policyExpansion(, S 0 , G)
E := F := 
f rom := S 0
repeat S
S
{succ(Z, aj , , )},
to :=
Zf rom aj Ch(a)

where (a, , ) := (Z)
F := F  (to  G)
E := E  f rom
f rom := to  G  E
until (f rom = )
E := E  F
G := G  F
return (E, F, G)
FOVI(E, A, prob, reward, cost, , V )
repeat
V 0 := V
loop for each Z  E
loop for each a  A
loop for each ,  such that forward (Z, a, , )
Q(Z, a, ,
P) := reward(Z) + cost(a)+

prob(aj , a, Z)  V 0 (succ(Z, aj , , ))
aj Ch(a)

end loop
end loop
V (Z) := max Q(Z, a, , )
(a,,)

end loop
V := normalize(V )
r := kV  V 0 k
until stopping criterion
 := extractP olicy(V )
return (V, , r)
FOLAO (A, prob, reward, cost, , S 0 , h, )
V := h
G := 
For each Z  S 0 , initialize  with an arbitrary action
repeat
(E, F, G) := policyExpansion(, S 0 , G)
(V, , r) := FOVI(E, A, prob, reward, cost, , V )
until (F = ) and r  
return (, V )

Figure 2: First-order LAO algorithm.
In the policy expansion step, we perform reachability analysis to find the set F of states
that have not yet been expanded, but are reachable from the set S 0 of initial states by
following the partial policy . The set of states G contains states that have been expanded
so far. By expanding a partial policy we mean that it will be defined for a larger set of
states in the dynamic programming step. In symbolic LAO , reachability analysis on ADDs
is performed by means of the image operator from symbolic model checking, that computes
427

fiHolldobler, Karabaev & Skvortsova

the set to of successor states following the best current policy. Instead, in FOLAO , we apply
the succ-operator, defined in Equation 1. One should observe that since the reachability
analysis in FOLAO is performed on abstract states that are defined as first-order entities,
the reasoning about successor states is kept on the first-order level. In contrast, symbolic
LAO would first instantiate S 0 with all possible combinations of objects, in order to be
able to perform computations using propositional ADDs later on.
In contrast to symbolic LAO , where the dynamic programming step is performed using
a modified version of SPUDD, we employ a modified first-order value iteration algorithm
(FOVI). The original FOVI by Holldobler and Skvortsova (2004) performs value iteration
over the entire state space. We modify it so that it computes on states that are reachable
from the initial states, more precisely, on the set E of states that are visited by the best current partial policy. In this way, we improve the efficiency of the original FOVI algorithm by
using reachability analysis together with symbolic dynamic programming. FOVI produces
a PFC representation of value functions and policies by constructing first-order formulae
that partition the state space into abstract states. In effect, it performs value iteration on
top of abstract states, obviating the need for explicit state enumeration.
Given a FOMDP and a value function represented in PFC, FOVI returns the best partial
value function V , the best partial policy  and the residual r. In order to update the values
of the states Z in E, we assign the values from the current value function to the successors
of Z. We compute successors with respect to all natures choices aj . The residual r is
computed as the absolute value of the largest difference between the current and the newly
computed value functions V 0 and V , respectively. We note that the newly computed value
function V is taken in its normalized form, i.e., as a result of the normalize procedure that
will be described in Section 3.2.1. Extraction of a best partial policy  is straightforward:
One simply needs to extract the maximizing actions from the best partial value function V .
As with symbolic LAO , FOLAO converges to an -optimal policy when three conditions are met: (1) its current policy does not have any unexpanded states, (2) the residual
r is less than the predefined threshold , and (3) the value function is initialized with an admissible heuristic. The original convergence proofs for LAO and symbolic LAO by Hansen
and Zilberstein (2001) carry over in a straightforward way to FOLAO .
When calling FOLAO , we initialize the value function with an admissible heuristic
function h that focuses the search on a subset of reachable states. A simple way to create
an admissible heuristic is to use dynamic programming to compute an approximate value
function. Therefore, in order to obtain an admissible heuristic h in FOLAO , we perform
several iterations of the original FOVI. We start the algorithm on an initial value function
that is admissible. Since each step of FOVI preserves admissibility, the resulting value
function is admissible as well. The initial value function assigns the goal reward to each
state thereby overestimating the optimal value, since the goal reward is the maximal possible
reward.
Since all computations of FOLAO are performed on abstract states instead of individual
states, FOMDPs are solved avoiding explicit state and action enumeration and propositionalization. The first-order reasoning leads to better performance of FOLAO in comparison
to symbolic LAO , as shown in Section 4.
428

fiFluCaP: A Heuristic Search Planner for First-Order MDPs

from = { Z 0 }
Z0

a11

a12

Z1
F,G
Z2

to = { Z 1 , Z 2 }
F = {Z1,Z 2 }
E = { Z 0 , Z 1 , Z 2}
G = {Z1,Z 2 }

from = { Z 0 }

Z1

Z0

G

FOVIA ({ Z 0 , Z 1 , Z 2})

a)

a21

Z2

a22

F
Z3

from = { Z 2 }
Z0

to = { Z 2 , Z 3 }
F = {Z3}
E = {Z0}

b)

to = { Z 4 , Z 5 }
Z 1 F = { Z , Z ,Z }
4
5
3
,
,
{
Z
Z
Z
=
E
2
3 ,Z 4 ,Z 5 }
0
,
,
{
Z
=
Z
Z
G
G
3 ,Z 4 ,Z 5 }
2
1
a11

Z2
Z3

Z4
a12

F

c)

Z5

FOVIA ( { Z 0 , Z 2 , Z 3 , Z 4 , Z 5 } )

Figure 3: Policy Expansion.

3.1 Policy Expansion
The policy expansion step in FOLAO is very similar to the one in the symbolic LAO
algorithm. Therefore, we illustrate the expansion procedure by means of an example. Assume that we start from the initial state Z0 and two nondeterministic actions a1 and a2 are
applicable in Z0 , each having two outcomes a11 , a12 and a21 , a22 , respectively. Without loss
of generality, we assume that the current best policy  chooses a1 as an optimal action at
state Z0 . We construct the successors Z1 and Z2 of Z0 with respect to both outcomes a11
and a12 of the action a1 .
The fringe set F as well as the set G of states expanded so far contain the states Z1
and Z2 only, whereas, the set E of states visited by the best current partial policy gets the
state Z0 in addition. See Figure 3a. In the next step, FOVI is performed on the set E. We
assume that the values have been updated in such a way that a2 becomes an optimal action
in Z0 . Thus, the successors of Z0 have to be recomputed with respect to the optimal action
a2 . See Figure 3b.
One should observe that one of the a2 -successors of Z0 , namely Z2 , is an element of the
set G and thus, it has been contained already in the fringe F during the previous expansion
step. Hence, the state Z2 should be expanded and its value recomputed. This is shown
in Figure 3c, where states Z4 and Z5 are a1 -successors of Z2 , under assumption that a1
is an optimal action in Z2 . As a result, the fringe set F contains the newly discovered
states Z3 , Z4 and Z5 and we perform FOVI on E = {Z0 , Z2 , Z3 , Z4 , Z5 }. The state Z1 is
not contained in E, because it does not belong to the best current partial policy, and the
429

fiHolldobler, Karabaev & Skvortsova

dynamic programming step is performed only on the states that were visited by the best
current partial policy.
3.2 First-Order Value Iteration
In FOLAO , the first-order value iteration algorithm (FOVI) serves two purposes: First, we
perform several iterations of FOVI in order to create an admissible heuristic h in FOLAO .
Second, in the dynamic programming step of FOLAO , we apply FOVI on the states visited
by the best partial policy in order to update their values and possibly revise the current
best partial policy.
The original FOVI by Holldobler and Skvortsova (2004) takes a finite state space of
abstract states, a finite set of stochastic actions, real-valued reward and cost functions, and
an initial value function as input. It produces a first-order representation of the optimal
value function and policy by exploiting the logical structure of a FOMDP. Thus, FOVI can
be seen as a first-order counterpart of the classical value iteration algorithm by Bellman
(1957).
3.2.1 Normalization
Following the ideas of Boutilier et al. (2001), FOVI relies on the normalization of the state
space that represents the value function. By normalization of a state space, we mean an
equivalence-preserving procedure that reduces the size of a state space. This would have an
effect only if a state space contains redundant entries, which is usually the case in symbolic
computations.
Although normalization is considered to be an important issue, it has been done by
hand so far. To the best of our knowledge, the preliminary implementation of the approach by Boutilier et al. (2001) performs only rudimentary logical simplifications and the
authors suggest using an automated first-order theorem prover for the normalization task.
Holldobler and Skvortsova (2004) have developed an automated normalization procedure
for FOVI that, given a state space, delivers an equivalent one that contains no redundancy.
The technique employs the notion of a subsumption relation.
More formally, let Z1 = (P1 , N1 ) and Z2 = (P2 , N2 ) be abstract states. Then Z1 is said
to be subsumed by Z2 , written Z1 v Z2 , if and only if there exist substitutions  and  such
that the following conditions hold:
(s1) (P2  U1 ) =AC1 P1
(s2) N2  N2 .N1  N1 .(P1  N1  U2 ) =AC1 (P1  N2 ) ,
where U1 and U2 are new AC1-variables. The motivation for the notion of subsumption
on abstract states is inherited from the notion of -subsumption between first-order clauses
by Robinson (1965) with the difference that abstract states contain more complicated negative parts in contrast to the first-order clauses.
For example, consider two abstract states Z1 and Z2 that are defined as follows:
Z1 = (on(X1 , a)  on(a, table), {red(Y1 )})
Z2 = (on(X2 , a), {red(X2 )}) ,
430

fiFluCaP: A Heuristic Search Planner for First-Order MDPs

N
0
1
2
3
4
5
6
7
8
9

Number of states
Supdate
Snorm
9
6
24
14
94
23
129
33
328
39
361
48
604
52
627
54
795
56
811
59

Time, msec
Update Norm
144
1
393
3
884
12
1377
16
2079
46
2519
51
3268
107
3534
110
3873
157
4131
154

Runtime, msec

Runtime w/o norm, msec

145
396
896
1393
2125
2570
3375
3644
4030
4285

144
593
2219
13293
77514
805753
n/a
n/a
n/a
n/a

Table 1: Representative timing results for first ten iterations of FOVI.
where Z1 informally asserts that some block X1 is on the block a which is on the table and
no blocks are red. Whereas Z2 informally states that some block X2 is on the block a and
X2 is not red. We show that Z1 v Z2 . The relation holds since both conditions (s1) and
(s2) are satisfied. Indeed,
(on(X2 , a)  U1 ) =AC1 on(X1 , a)  on(a, table)
and
(on(X1 , a)  on(a, table)  red(Y1 )  U2 ) = (on(X1 , a)  on(a, table)  red(X2 ))
with  = {X2 7 X1 , U1 7 on(a, table)} and  = {Y1 7 X1 , U2 7 1}.
One should note that subsumption in the language of abstract states inherits the complexity bounds of -subsumption (Kapur & Narendran, 1986). Namely, deciding subsumption between two abstract states is NP-complete, in general. However, Karabaev et al.
(2006) have recently developed an efficient algorithm that delivers all solutions of the subsumption problem for the case where abstract states are fluent terms.
For the purpose of normalization, it is convenient to represent the value function as a
set of pairs of the form hZ, i, where Z is an abstract state and  is a real value. In essence,
the normalization algorithm can be seen as an exhaustive application of the following simplification rule to the value function V .
hZ1 , i hZ2 , i
Z1 v Z2
hZ2 , i
Table 1 illustrates the importance of the normalization algorithm by providing some representative timing results for the first ten iterations of FOVI. The experiments were carried
out on the problem taken from the colored Blocksworld scenario consisting of ten blocks.
Even on such a relatively simple problem FOVI with the normalization switched off does
not scale beyond the sixth iteration.
The results in Table 1 demonstrate that the normalization during some iteration of
FOVI dramatically shrinks the computational effort during the next iterations. The columns
labelled Supdate and Snorm show the size of the state space after performing the value updates
431

fiHolldobler, Karabaev & Skvortsova

and the normalization, respectively. For example, the normalization factor, i.e., the ratio
between the number Supdate of states obtained after performing one update step and the
number Snorm of states obtained after performing the normalization step, at the seventh
iteration is 11.6. This means that more than ninety percent of the state space contained
redundant information. The fourth and fifth columns in Table 1 contain the time Update
and Norm spent on performing value updates and on the normalization, respectively. The
total runtime Runtime, when the normalization is switched on, is given in the sixth column.
The seventh column labelled Runtime w/o norm depicts the total runtime of FOVI when the
normalization is switched off. If we would sum up all values in the seventh column and the
values in the sixth column up to the sixth iteration inclusively, subtract the latter from the
former and divide the result by the total time Norm needed for performing normalization
during the first six iterations, then we would obtain the normalization gain of about three
orders of magnitude.

4. Experimental Evaluation
We demonstrate the advantages of combining the heuristic search together with first-order
state abstraction on a system, referred to as FluCaP, that has successfully entered the
probabilistic track of the 2004 International Planning Competition (IPC2004). The experimental results were all obtained using RedHat Linux running on a 3.4GHz Pentium IV
machine with 3GB of RAM.
In Table 2, we present the performance comparison of FluCaP together with symbolic
LAO on examples taken from the colored Blocksworld (BW) scenario that was introduced
during IPC2004.
Our main objective was to investigate whether first-order state abstraction using logic
could improve the computational behaviour of a planning system for solving FOMDPs. The
colored BW problems were our main interest since they were the only ones represented in
first-order terms and hence the only ones that allowed us to make use of the first-order
state abstraction. Therefore, we have concentrated on the design of a domain-dependent
planning system that was tuned for the problems taken from the Blocksworld scenario.
The colored BW problems differ from the classical BW ones in that, along with the
unique identifier, each block is assigned a specific color. A goal formula, specified in firstorder terms, provides an arrangement of colors instead of an arrangement of blocks.
At the outset of solving a colored BW problem, symbolic LAO starts by propositionalizing its components, namely, the goal statement and actions. Only after that, the abstraction
using propositional ADDs is applied. In contrast, FluCaP performs first-order abstraction on a colored BW problem directly, avoiding unnecessary grounding. In the following,
we show how an abstraction technique affects the computation of a heuristic function. To
create an admissible heuristic, FluCaP performs twenty iterations of FOVI and symbolic
LAO performs twenty iterations of an approximate value iteration algorithm similar to
APRICODD by St-Aubin, Hoey, and Boutilier (2000). The columns labelled H.time and
NAS show the time needed for computing a heuristic function and the number of abstract
states it covers, respectively. In comparison to FluCaP, symbolic LAO needs to evaluate
fewer abstract states in the heuristic function but takes considerably more time. One can
432

fiFluCaP: A Heuristic Search Planner for First-Order MDPs

FluCaP

FluCaP

31.1
8.7
25.1
9.5
16.5
12.7
285.4
76.7
128.5 85.0
63.3
135.0
n/a
757.0
2813
718.3
443.6 1241
n/a
n/a
n/a
n/a
n/a
n/a
n/a
n/a
n/a
n/a

LAO*

LAO*

FluCaP

FOVI

FluCaP

LAO*

FluCaP

494 22.3 22.0 23.4
496 23.1 17.8 22.7
495 27.3 11.7 15.7
493 137.6 78.5 261.6
492 150.5 33.0 119.1
496 221.3 16.6 56.4
491 1644 198.1 2776
494 1265 161.6 1809
494 2210 27.3 317.7
n/a n/a 1212 n/a
n/a n/a 598.5 n/a
n/a n/a 215.3 1908
n/a n/a 1809 n/a
n/a n/a 3548 n/a

4.2
1.3
0.3
21.0
9.3
1.2
171.3
143.6
12.3
804.1
301.2
153.2
1733
1751

35
34
32
68
82
46
143
112
101
n/a
n/a
n/a
n/a
n/a

410
172
55
1061
539
130
2953
2133
425
8328
3956
2019
7276
15225

1077
687
278
3847
1738
902
12014
7591
2109
n/a
n/a
7251
n/a
n/a

0.86
0.86
0.86
7.05
7.05
7.05
65.9
65.9
65.9
n/a
n/a
n/a
n/a
n/a

0.82
0.68
0.66
4.24
6.50
6.24
23.6
51.2
61.2
66.6
379.7
1121
1.2  107
2.5  107

2.7
2.1
1.9
3.1
2.3
2.0
3.5
2.4
2.0
4.1
3.0
2.3
5.7
6.1

Table 2: Performance comparison of FluCaP (denoted as FluCaP) and symbolic LAO
(denoted as LAO*), where the cells n/a denote the fact that a planner did not
deliver a solution within the time limit of one hour. NAS and NGS are number of
abstract and ground states, respectively.

conclude that abstract states in symbolic LAO enjoy more complex structure than those
in FluCaP.
We note that, in comparison to FOVI, FluCaP restricts the value iteration to a smaller
state space. Intuitively, the value function, which is delivered by FOVI, covers a larger
state space, because the time that is allocated for the heuristic search in FluCaP is now
used for performing additional iterations in FOVI. The results in the column labelled %
justify that the harder the problem is (that is, the more colors it contains), the higher the
percentage of runtime spent on normalization. Almost on all test problems, the effort spent
on normalization takes three percent of the total runtime on average.
In order to compare the heuristic accuracy, we present in the column labelled NGS the
number of ground states which the heuristic assigns non-zero values to. One can see that the
heuristics returned by FluCaP and symbolic LAO have similar accuracy, but FluCaP
takes much less time to compute them. This reflects the advantage of the plain first-order
abstraction in comparison to the marriage of propositionalization with abstraction using
propositional ADDs. In some examples, we gain several orders of magnitude in H.time.
The column labelled Total time presents the time needed to solve a problem. During this
time, a planner must execute 30 runs from an initial state to a goal state. A one-hour block
is allocated for each problem. We note that, in comparison to FluCaP, the time required
by heuristic search in symbolic LAO (i.e., difference between Total time and H.time) grows
considerably faster in the size of the problem. This reflects the potential of employing
433

%

FOVI

15
17

494
495
495
493
493
495
491
494
494
n/a
n/a
n/a
n/a
n/a

NGS, 103

NAS
FluCaP

8

494
495
495
493
492
494
491
494
494
490
490
492
486
481

H.time, sec.
LAO*

7

494
496
496
493
493
495
492
494
494
n/a
n/a
n/a
n/a
n/a

Total time, sec.

FluCaP

6

FOVI

5

C
4
3
2
4
3
2
4
3
2
4
3
2
3
4

FluCaP

B

Total av. reward
LAO*

Problem

fiHolldobler, Karabaev & Skvortsova

B
20
22
24
26
28
30
32
34
36

Total av. reward, 500
489.0
487.4
492.0
482.8
493.0
491.2
476.0
475.6
n/a

Total time, sec.
137.5
293.8
757.3
817.0
2511.3
3580.4
3953.8
3954.1
n/a

H.time, sec.
56.8
110.2
409.8
117.2
823.3
1174.0
781.8
939.4
n/a

NAS
711
976
1676
1141
2832
4290
2811
3248
n/a

NGS  1021
1.7
1.1  103
1.0  106
4.6  108
8.6  1011
1.1  1015
7.4  1017
9.6 1020
n/a

Table 3: Performance of FluCaP on larger instances of one-color Blocksworld problems,
where the cells n/a denote the fact that a planner did not deliver a solution within
the time limit.

first-order abstraction instead of abstraction based on propositional ADDs during heuristic
search.
The average reward obtained over 30 runs, shown in column Total av. reward, is the
planners evaluation score. The reward value close to 500 (which is the maximum possible
reward) simply indicates that a planner found a reasonably good policy. Each time the
number of blocks B increases by 1, the running time for symbolic LAO increases roughly
10 times. Thus, it could not scale to problems having more than seven blocks. This is
in contrast to FluCaP which could solve problems of seventeen blocks. We note that
the number of colors C in a problem affects the efficiency of an abstraction technique. In
FluCaP, as C decreases, the abstraction rate increases which, in turn, is reflected by the
dramatic decrease in runtime. The opposite holds for symbolic LAO .
In addition, we compare FluCaP with two variants. The first one, denoted as FOVI,
performs no heuristic search at all, but rather, employs FOVI to compute the -optimal
total value function from which a policy is extracted. The second one, denoted as FluCaP ,
performs trivial heuristic search starting with an initial value function as an admissible
heuristic. As expected, FluCaP that combines heuristic search and FOVI demonstrates
an advantage over plain FOVI and trivial heuristic search. These results illustrate the
significance of heuristic search in general (FluCaP vs. FOVI) and the importance of heuristic
accuracy, in particular (FluCaP vs. FluCaP ). FOVI and FluCaP do not scale to problems
with more than seven blocks.
Table 3 presents the performance results of FluCaP on larger instances of one-color
BW problems with the number of blocks varying from twenty to thirty four. We believe that
FluCaP does not scale to problems of larger size because the implementation is not yet
well optimized. In general, we believe that the FluCaP system should not be as sensitive
to the size of a problem as propositional planners are.
Our experiments were targeted at the one-color problems only because they are, on the
one hand, the simplest ones for us and, on the other hand, the bottleneck for propositional
planners. The structure of one-color problems allows us to apply first-order state abstraction in its full power. For example, for a 34-blocks problem FluCaP operates on about
3.3 thousand abstract states that explode to 9.6  1041 individual states after proposition434

fiFluCaP: A Heuristic Search Planner for First-Order MDPs

Total av. reward, 500
UMass

Michigan

Purdue1

Purdue2

Purdue3

Caracas

Toulouse

C
3
3
5
0
0
0
0
0
0

Dresden

B
5
8
11
5
8
11
15
18
21

Canberra

Problem

494.6
486.5
479.7
494.6
489.7
479.1
467.5
351.8
285.7

496.4
492.8
486.3
494.6
489.9
n/a
n/a
n/a
n/a

n/a
n/a
n/a
494.8
n/a
n/a
n/a
n/a
n/a

n/a
n/a
n/a
n/a
n/a
n/a
n/a
n/a
n/a

496.5
486.6
481.3
494.1
488.7
480.3
469.4
462.4
455.7

496.5
486.4
481.5
494.6
490.3
479.7
467.7
-54.9
455.1

495.8
487.2
481.9
494.4
490
481.1
486.3
n/a
459

n/a
n/a
n/a
494.9
488.8
465.7
397.2
n/a
n/a

n/a
n/a
n/a
494.1
n/a
n/a
n/a
n/a
n/a

Table 4: Official competition results for colored and non-colored Blocksworld scenarios.
May, 2004. The n/a-entries in the table indicate that either a planner was not
successful in solving a problem or did not attempt to solve it.

alization. A propositional planner must be highly optimized in order to cope with this
non-trivial state space.
We note that additional colors in larger instances (more than 20 blocks) of BW problems
cause dramatic increase in computational time, so we consider these problems as being
unsolved. One should also observe that the number of abstract states NAS increases with
the number of blocks non-monotonically because the problems are generated randomly. For
example, the 30-blocks problem happens to be harder than the 34-blocks one. Finally, we
note that all results that appear in Tables 2 and 3 were obtained by using the new version of
the evaluation software that does not rely on propositionalization in contrast to the initial
version that was used during the competition.
Table 4 presents the competition results from IPC2004, where FluCaP was competitive
in comparison with other planners on colored BW problems. FluCaP did not perform
well on non-colored BW problems because these problems were propositional ones (that
is, goal statements and initial states are ground) and FluCaP does not yet incorporate
optimization techniques applied in modern propositional planners. The contestants are
indicated by their origin. For example, Dresden - FluCaP, UMass - symbolic LAO etc.
Because only the pickup action has cost 1, the gain of five points in total reward means
that the plan contains ten fewer actions on average. The competition domains and log files
are available in an online appendix of Younes, Littman, Weissman, and Asmuth (2005).
Although the empirical results that are presented in this work were obtained on the
domain-dependent version of FluCaP, we have recently developed in (Karabaev et al.,
2006) an efficient domain-independent inference mechanism that is the core of a domainindependent version of FluCaP.
435

fiHolldobler, Karabaev & Skvortsova

5. Related Work
We follow the symbolic DP (SDP) approach within Situation Calculus (SC) of Boutilier
et al. (2001) in using first-order state abstraction for FOMDPs. One difference is in the
representation language: We use PFC instead of SC. In the course of symbolic value iteration, a state space may contain redundant abstract states that dramatically affect the
algorithms efficiency. In order to achieve computational savings, normalization must be performed to remove this redundancy. However, in the original work by Boutilier et al. (2001)
this was done by hand. To the best of our knowledge, the preliminary implementation of
the SDP approach within SC uses human-provided rewrite rules for logical simplification.
In contrast, Holldobler and Skvortsova (2004) have developed an automated normalization
procedure for FOVI that is incorporated in the competition version of FluCaP and brings
the computational gain of several orders of magnitude. Another crucial difference is that our
algorithm uses heuristic search to limit the number of states for which a policy is computed.
The ReBel algorithm by Kersting, van Otterlo, and De Raedt (2004) relates to FOLAO
in that it also uses a representation language that is simpler than Situation Calculus. This
feature makes the state space normalization computationally feasible.
In motivation, our approach is closely connected to Relational Envelope-based Planning
(REBP) by Gardiol and Kaelbling (2003) that represents MDP dynamics by a compact set
of relational rules and extends the envelope method by Dean et al. (1995). However, REBP
propositionalizes actions first, and only afterwards employs abstraction using equivalenceclass sampling. In contrast, FOLAO directly applies state and action abstraction on the
first-order structure of an MDP. In this respect, REBP is closer to symbolic LAO than to
FOLAO . Moreover, in contrast to PFC, action descriptions in REBP do not allow negation
to appear in preconditions or in effects. In organization, FOLAO , as symbolic LAO , is
similar to real-time DP by Barto et al. (1995) that is an online search algorithm for MDPs.
In contrast, FOLAO works offline.
All the above algorithms can be classified as deductive approaches to solving FOMDPs.
They can be characterized by the following features: (1) they are model-based, (2) they
aim at exact solutions, and (3) logical reasoning methods are used to compute abstractions.
We should note that FOVI aims at exact solution for a FOMDP, whereas FOLAO , due
to the heuristic search that avoids evaluating all states, seeks for an approximate solution.
Therefore, it would be more appropriate to classify FOLAO as an approximate deductive
approach to FOMDPs.
In another vein, there is some research on developing inductive approaches to solving
FOMDPs, e.g., by Fern, Yoon, and Givan (2003). The authors propose the approximate
policy iteration (API) algorithm, where they replace the use of cost-function approximations
as policy representations in API with direct, compact state-action mappings, and use a
standard relational learner to learn these mappings. In effect, Fern et al. provide policylanguage biases that enable solution of very large relational MDPs. All inductive approaches
can be characterized by the following features: (1) they are model-free, (2) they aim at
approximate solutions, and (3) an abstract model is used to generate biased samples from
the underlying FOMDP and the abstract model is altered based on them.
A recent approach by Gretton and Thiebaux (2004) proposes an inductive policy construction algorithm that strikes a middle-ground between deductive and inductive tech436

fiFluCaP: A Heuristic Search Planner for First-Order MDPs

niques. The idea is to use reasoning, in particular first-order regression, to automatically
generate a hypothesis language, which is then used as input by an inductive solver. The
approach by Gretton and Thiebaux is related to SDP and to our approach in the sense that
a first-order domain specification language as well as logical reasoning are employed.

6. Conclusions
We have proposed an approach that combines heuristic search and first-order state abstraction for solving FOMDPs more efficiently. Our approach can be seen as two-fold:
First, we use dynamic programming to compute an approximate value function that serves
as an admissible heuristic. Then heuristic search is performed to find an exact solution
for those states that are reachable from the initial state. In both phases, we exploit the
power of first-order state abstraction in order to avoid evaluating states individually. As
experimental results show, our approach breaks new ground in exploring the efficiency of
first-order representations in solving MDPs. In comparison to existing MDP planners that
must propositionalize the domain, e.g., symbolic LAO , our solution scales better on larger
FOMDPs.
However, there is plenty remaining to be done. For example, we are interested in the
question of to what extent the optimization techniques applied in modern propositional
planners can be combined with first-order state abstraction. In future competitions, we
would like to face problems where the goal and/or initial states are only partially defined
and where the underlying domain contains infinitely many objects.
The current version of FOLAO is targeted at the problems that allow for efficient
first-order state abstraction. More precisely, these are the problems that can be polynomially translated into PFC. For example in the colored BW domain, existentially-closed
goal descriptions were linearly translated into the equivalent PFC representation. Whereas
universally-closed goal descriptions would require full propositionalization. Thus, the current version of PFC is less first-order expressive than, e.g., Situation Calculus. In the future,
it would be interesting to study the extensions of the PFC language, in particular, to find
the trade-off between the PFCs expressive power and the tractability of solution methods
for FOMDPs based on PFC.

Acknowledgements
We are very grateful to all anonymous reviewers for the thorough reading of the previous versions of this paper. We also thank Zhengzhu Feng for fruitful discussions and for
providing us with the executable of the symbolic LAO planner. We greatly appreciate
David E. Smith for his patience and encouragement. His valuable comments have helped
us to improve this paper. Olga Skvortsova was supported by a grant within the Graduate Programme GRK 334 Specification of discrete processes and systems of processes
by operational models and logics under auspices of the Deutsche Forschungsgemeinschaft
(DFG).
437

fiHolldobler, Karabaev & Skvortsova

References
Barto, A. G., Bradtke, S. J., & Singh, S. P. (1995). Learning to act using real-time dynamic
programming. Artificial Intelligence, 72 (1-2), 81138.
Bellman, R. E. (1957). Dynamic programming. Princeton University Press, Princeton, NJ,
USA.
Boutilier, C., Dean, T., & Hanks, S. (1999). Decision-theoretic planning: Structural assumptions and computational leverage. Journal of Artificial Intelligence Research,
11, 194.
Boutilier, C., Reiter, R., & Price, B. (2001). Symbolic Dynamic Programming for FirstOrder MDPs. In Nebel, B. (Ed.), Proceedings of the Seventeenth International Conference on Artificial Intelligence (IJCAI2001), pp. 690700. Morgan Kaufmann.
Dean, T., Kaelbling, L., Kirman, J., & Nicholson, A. (1995). Planning under time constraints
in stochastic domains. Artificial Intelligence, 76, 3574.
Feng, Z., & Hansen, E. (2002). Symbolic heuristic search for factored Markov Decision Processes. In Dechter, R., Kearns, M., & Sutton, R. (Eds.), Proceedings of the Eighteenth
National Conference on Artificial Intelligence (AAAI2002), pp. 455460, Edmonton,
Canada. AAAI Press.
Fern, A., Yoon, S., & Givan, R. (2003). Approximate policy iteration with a policy language
bias. In Thrun, S., Saul, L., & Scholkopf, B. (Eds.), Proceedings of the Seventeenth Annual Conference on Neural Information Processing Systems (NIPS2003), Vancouver,
Canada. MIT Press.
Gardiol, N., & Kaelbling, L. (2003). Envelope-based planning in relational MDPs. In Thrun,
S., Saul, L., & Scholkopf, B. (Eds.), Proceedings of the Seventeenth Annual Conference
on Neural Information Processing Systems (NIPS2003), Vancouver, Canada. MIT
Press.
Gretton, C., & Thiebaux, S. (2004). Exploiting first-order regression in inductive policy
selection. In Chickering, M., & Halpern, J. (Eds.), Proceedings of the Twentieth Conference on Uncertainty in Artificial Intelligence (UAI2004), Banff, Canada. Morgan
Kaufmann.
Hansen, E., & Zilberstein, S. (2001). LAO*: A heuristic search algorithm that finds solutions
with loops. Artificial Intelligence, 129, 3562.
Hoey, J., St-Aubin, R., Hu, A., & Boutilier, C. (1999). SPUDD: Stochastic Planning using
Decision Diagrams. In Laskey, K. B., & Prade, H. (Eds.), Proceedings of the Fifteenth Conference on Uncertainty in Artificial Intelligence (UAI1999), pp. 279288,
Stockholm. Morgan Kaufmann.
Holldobler, S., & Schneeberger, J. (1990). A new deductive approach to planning. New
Generation Computing, 8, 225244.
Holldobler, S., & Skvortsova, O. (2004). A Logic-Based Approach to Dynamic Programming.
In Proceedings of the Workshop on Learning and Planning in Markov Processes
Advances and Challenges at the Nineteenth National Conference on Artificial Intelligence (AAAI04), pp. 3136, San Jose, CA. AAAI Press.
438

fiFluCaP: A Heuristic Search Planner for First-Order MDPs

Kapur, D., & Narendran, P. (1986). NP-completeness of the set unification and matching
problems. In Siekmann, J. H. (Ed.), Proceedings of the Eighth International Conference in Automated Deduction (CADE1986), pp. 489495, Oxford, England. Springer
Verlag.
Karabaev, E., Ramme, G., & Skvortsova, O. (2006). Efficient symbolic reasoning for firstorder MDPs. In Proceedings of the Workshop on Planning, Learning and Monitoring
with Uncertainty and Dynamic Worlds at the Seventeenth European Conference on
Artificial Intelligence (ECAI2006), Riva del Garda, Italy. To appear.
Kersting, K., van Otterlo, M., & De Raedt, L. (2004). Bellman goes relational. In Brodley,
C. E. (Ed.), Proceedings of the Twenty-First International Conference in Machine
Learning (ICML2004), pp. 465472, Banff, Canada. ACM.
Puterman, M. L. (1994). Markov Decision Processes - Discrete Stochastic Dynamic Programming. John Wiley & Sons, Inc., New York, NY.
Robinson, J. (1965). A machine-learning logic based on the resolution principle. Journal of
the Association for Computing Machinery, 12 (1), 2341.
St-Aubin, R., Hoey, H., & Boutilier, C. (2000). APRICODD: Approximate policy construction using decision diagrams. In Leen, T. K., Dietterich, T. G., & Tresp, V. (Eds.),
Proceedings of the Fourteenth Annual Conference on Neural Information Processing
Systems (NIPS2000), pp. 10891095, Denver. MIT Press.
Younes, H., Littman, M., Weissman, D., & Asmuth, J. (2005). The first probabilistic track
of the International Planning Competition. Journal of Artificial Intelligence Research,
24, 851887.

439

fi