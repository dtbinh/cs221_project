Journal of Artificial Intelligence Research 50 (2014) 31-70

Submitted 08/13; published 05/14

Knowledge Forgetting in Answer Set Programming
Yisong Wang

CSC . YSWANG @ GZU . EDU . CN

Department of Computer Science,
Guizhou University, Guiyang, China

Yan Zhang
Yi Zhou

YAN @ SCEM . UWS . EDU . AU
YZHOU @ SCEM . UWS . EDU . AU

Artificial Intelligence Research Group,
University of Western Sydney, Australia

Mingyi Zhang

ZHANGMINGYI 045@ GMAIL . COM

Guizhou Academy of Sciences, Guiyang, China

Abstract
The ability of discarding or hiding irrelevant information has been recognized as an important
feature for knowledge based systems, including answer set programming. The notion of strong
equivalence in answer set programming plays an important role for different problems as it gives
rise to a substitution principle and amounts to knowledge equivalence of logic programs. In this
paper, we uniformly propose a semantic knowledge forgetting, called HT- and FLP-forgetting, for
logic programs under stable model and FLP-stable model semantics, respectively. Our proposed
knowledge forgetting discards exactly the knowledge of a logic program which is relevant to forgotten variables. Thus it preserves strong equivalence in the sense that strongly equivalent logic
programs will remain strongly equivalent after forgetting the same variables. We show that this
semantic forgetting result is always expressible; and we prove a representation theorem stating that
the HT- and FLP-forgetting can be precisely characterized by Zhang-Zhous four forgetting postulates under the HT- and FLP-model semantics, respectively. We also reveal underlying connections
between the proposed forgetting and the forgetting of propositional logic, and provide complexity
results for decision problems in relation to the forgetting. An application of the proposed forgetting
is also considered in a conflict solving scenario.

1. Introduction
Motivated by Lin and Reiters seminal work (Lin & Reiter, 1994), the notion of forgetting in propositional and first-order logics  distilling from a knowledge base only the part that is relevant to
a subset of the alphabet  has attracted extensive interests in the KR community, (e.g., see Lang
& Marquis, 2010; Zhou & Zhang, 2011). In recent years, researchers have developed forgetting
notions and theories in other non-classical logic systems from various perspectives, such as forgetting in description logics (Kontchakov, Wolter, & Zakharyaschev, 2008; Wang, Wang, Topor, &
Pan, 2010; Lutz & Wolter, 2011; Packer, Gibbins, & Jennings, 2011), forgetting in logic programs
(Zhang & Foo, 2006; Eiter & Wang, 2008; Wong, 2009; Wang, Wang, & Zhang, 2013), and forgetting in modal logic (Zhang & Zhou, 2009; Su, Sattar, Lv, & Zhang, 2009; van Ditmarsch, Herzig,
Lang, & Marquis, 2009; Liu & Wen, 2011). As a logical notion, forgetting has also been studied
under some different terms such as variable elimination (Lang, Liberatore, & Marquis, 2003), irrelevance, independence, irredundancy, novelty, or separability (Bobrow, Subramanian, Greiner, &
c
2014
AI Access Foundation. All rights reserved.

fiWANG , Z HANG , Z HOU , & Z HANG

Pearl, 1997). It has been shown that in the study of modeling agents behaviors, forgetting plays an
important role in conflict resolution (Zhang & Foo, 2006; Lang & Marquis, 2010).
In propositional logic, the result of forgetting an atom p from a formula , written Forget(, {p}),
is the formula [p/]  [p/>], where [p/] and [p/>] is the formula obtained from  by replacing each occurrence of atom p with  (false) and > (true) respectively. Forgetting a set of atoms
from a formula  is defined as Forget(, V  {p}) = Forget(Forget(, {p}), V ) (Lin, 2001). It is
easy to see that the forgetting preserves logical equivalence. That is, logically equivalent formulas
(theories) will remain logically equivalent after forgetting the same atoms. It is well known that, if
 does not mention any atoms from V then
 |=  iff Forget(, V ) |= .
In this sense the forgetting in propositional logic, called propositional forgetting, is a knowledge
forgetting since Forget(, V ) exactly contains the logical content of  that is irrelevant to V .
For logic programs under stable model/answer set semantics (Gelfond & Lifschitz, 1988), the issue of logical equivalence is rather complicated due to its different notions of equivalence: (weak)
equivalence and strong equivalence. Two logic programs 1 and 2 are (weakly) equivalent if and
only if 1 and 2 have the same stable models; 1 and 2 are strongly equivalent if and only if
1   and 2   are equivalent for every logic program . It is well known that strong equivalence is an important concept in answer set programming (ASP), because it amounts to knowledge
equivalence which captures the logical content of a logic program (Osorio & Zacarias, 2004; Osorio
& Cuevas, 2007; Delgrande, Schaub, Tompits, & Woltran, 2013), and can be used for simplifying
logic programs where two strongly equivalent rules may be interchangeable without affecting the
original logic programs stable models (Pearce, Tompits, & Woltran, 2001; Ferraris, Lee, & Lifschitz, 2011; Lin & Chen, 2007; Lin & Zhou, 2011). The strong equivalence can be characterized
in the logic here-and-there (HT), viz, two logic programs are strongly equivalent if and only if they
have the same HT-models (Lifschitz, Pearce, & Valverde, 2001). For instance, a rule of the following form p  p   has the same HT-models as that of > (tautology), where  can be an arbitrary
formula. Thus it can be safely removed from every logic programs without changing their stable
models.
Besides the stable model/answer set semantics of logic programs (Gelfond & Lifschitz, 1988),
FLP-stable model semantics also steadily gains its importance (Faber, Pfeifer, & Leone, 2011;
Truszczynski, 2010). The notion of strong equivalence is similarly generalized to logic programs
under FLP-stable models semantics: two theories 1 and 2 are strongly FLP-equivalent if and only
if 1   and 2   have the same FLP-stable models for every logic program . It is shown that
this strong equivalence can be characterized in terms of FLP-models, viz, two logic programs are
strongly FLP-equivalent if and only if they have the same FLP-models (Truszczynski, 2010).
When we develop the notion of forgetting in logic programs, preserving strong equivalence is
important, like that the propositional forgetting preserves equivalence of propositional logic. Consider that two agents need to achieve an agreement for a certain goal, where each agents knowledge
base is represented by a logic program. Suppose that there are two consistent1 logic programs, but
their combination is inconsistent. To achieve a consistent combination, one may forget some atoms
from each of the logic programs, so that the combination of their forgetting results is consistent.
Then forgetting may be effectively used to solve the conflict between the two agents knowledge
1. A logic program is consistent if it has some stable models.

32

fiK NOWLEDGE F ORGETTING

IN

A NSWER S ET P ROGRAMMING

bases (Zhang & Foo, 2006; Eiter & Wang, 2008; Lang & Marquis, 2010). For the purpose of simplicity, on the other hand, agents may also replace their knowledge bases with strongly equivalent
but syntactically simpler ones.
Let us consider a simple Yale Shooting scenario where the logic program  consisting of the
following rules:2
shoot  not aux;

aux  not shoot;

 aux, shoot.

Here aux is used to generate possible occurrences of action shoot. One can be interested in which
logic program represents the same knowledge as that of  when the auxiliary atom aux is ignored.
This intuitively results in a logic program 0 consisting of the rule3 :
shoot  not not shoot,
which captures exactly the knowledge of  that is irrelevant to aux. We will see that 0 can be
obtained from  by HT-forgetting aux (cf. Example 5 with other atom names), while it cannot be
obtained in terms of previous forgetting approaches in logic programming (cf. Example 11).
It turns out that preserving strong equivalence in forgetting is challenging. There have been
several attempts to define the notion of forgetting in logic programs, but none of these approaches
is fully satisfactory. Zhang and Foo (2006) first defined syntax oriented weak and strong forgetting
notions for normal logic programs. But these forgetting notions preserve neither (weak) equivalence
nor strong equivalence. Eiter and Wang (2008) then proposed a semantic forgetting for consistent
disjunctive logic programs, which preserves equivalence but not strong equivalence. They specifically indicated the importance of preserving strong equivalence in logic programming forgetting
and raised this issue as a future work. Wong (2009) proposed two forgetting operators for disjunctive logic programs. Although the two operators indeed preserve strong equivalence, it may lose the
intuition of weakening under various circumstances (see Section 5 for details). A recently proposed
forgetting for logic programs may introduce extra knowledge (cf., see Wang et al., 2013, Ex. 2).
Thus it is not a knowledge forgetting.
Together with preserving strong equivalence, expressiveness is another desired criterion for
logic programming forgetting. Ideally we would expect that the result of forgetting some atoms
from a logic program is still expressible by a logic program. This is particularly necessary when we
view agents knowledge bases as logic programs and forgetting is employed as a means of conflict
solving among these agents knowledge bases (Zhang & Foo, 2006). While previous logic programming forgetting approaches all meet this criterion, as we will see in this paper, once we consider
forgetting in arbitrary logic programs, retaining expressibility is challenging objective to achieve for
a semantic forgetting notion.
Finally, we believe that as a way of weakening, knowledge forgetting in logic programs should
obey some common intuitions shared by forgetting in classical logics. For instance, forgetting
something from a logic program should lead to a weaker program in certain sense. On the other
hand, such weakening should only be associated to the relevant information that has been forgotten.
For this purpose, Zhang and Zhou (2009) proposed four forgetting postulates to formalize these
common intuitions and showed that forgetting in propositional logic and modal logic S5 can be
precisely captured by these postulates. Surprisingly, none of previous forgetting notions in logic
2. This is due to one of the anonymous reviewers.
3. The rule is strongly equivalent to the choice rule 0{shoot}1 but it is not a normal rule.

33

fiWANG , Z HANG , Z HOU , & Z HANG

programs actually satisfies Zhang-Zhous postulates. In this sense these previous forgetting notions
for logic programs are not knowledge forgetting operators.
In summary, we consider the following criteria that a knowledge forgetting notion in logic programs should meet:
 Expressibility. The result of forgetting in an arbitrary logic program should also be expressible via a logic program;
 Preserving strong equivalence. Two strongly equivalent logic programs should remain strongly
equivalent after forgetting the same variables;
 Satisfying common intuitions of forgetting. Preferably, forgetting in logic programs should
be semantically characterized by Zhang-Zhous four forgetting postulates.
In this paper we present a comprehensive study on knowledge forgetting in the context of arbitrary logic programs (propositional theories) under stable model and FLP-stable models semantics,
called HT- and FLP-forgetting respectively. We show that the HT- and FLP-forgetting meet all above
criteria, and hence have primary advantages when compared to previous logic program forgetting
notions.
The main contributions of the paper may be summarized as follows, where ?  {HT, FLP },
- As a starting point, we investigate the model theoretical characterization for strong equivalence of logic programs under stable model and FLP-stable model semantics, and explore their
strong equivalence by the equivalence in propositional logic.
- We propose a semantic ?-forgetting for logic programs under ?-stable model semantics respectively. Here HT-stable model means stable model. The ?-forgetting result is always
expressible via a logic program and it preserves strong equivalence under stable model and
FLP-stable model semantics.
- We investigate semantic properties of the ?-forgetting, and show that the ?-forgetting satisfies
Zhang-Zhous four postulates under the ?-model respectively. In particular, the forgetting
result consists of the logical content that is irrelevant to forgotten atoms.
- We establish the underlying connections between ?-forgetting and propositional forgetting,
based on which we provide complexity results for some decision problems in relation to ?forgetting. In particular, we show that resulting checking  deciding if a logic program is a
result of ?-forgetting a set of atoms from a logic program  is P2 -complete, while the related
inference problem in terms of ?-forgetting varies from co-NP-complete to P2 -complete.
The theoretical negative results confirm that it is not a easy task to simplify logic programs
by forgetting. But fortunately, this kind of simplification can be computed offline in general.
For instance, a problem domain description involves a lot of auxiliary propositional variables.
One can firstly simplify the description by forgetting (part of) the auxiliary propositional
variables, like a kind of compilation (Lang et al., 2003).
- Finally we consider an application of knowledge forgetting in the solving of conflicts in the
context of logic programming.
34

fiK NOWLEDGE F ORGETTING

IN

A NSWER S ET P ROGRAMMING

The rest of the paper is organized as follows. Section 2 briefly reviews necessary concepts and
notions of answer set programming. Section 3 presents the characterizations for strong equivalence
of logic programs. We firstly present a uniform definition of the knowledge forgetting for logic
programs in section 4, and then explore their expressibility, forgetting postulates, relationship with
propositional forgetting, computational complexity and an application of knowledge forgetting in
conflict solving. Section 5 discusses other forgetting approaches in logic programs, and finally,
Section 6 concludes the paper with some remarks. All the proofs in the paper are deferred to
Appendix for clarity.
This paper is the revised and extended version of a paper which appeared in Proceedings of KR
2012 (Wang, Zhang, Zhou, & Zhang, 2012).

2. Answer Set Programming
In this section we briefly recall the basic notions of logic programming under stable model semantics, including its syntax, reduction, stable model (Ferraris, 2005) and FLP-stable models (Truszczynski, 2010) and strong equivalence (Lifschitz et al., 2001; Truszczynski, 2010). In the paper a stable
model is called an HT-stable model for convenience, and we assume ?  {HT , FLP }.
We assume a propositional language LA over the finite set A of propositional atoms, which is
called the signature of the language LA .
2.1 Syntax
The formulas of LA are built from the signature4 A and the 0-place connective  (false) using
the binary connectives ,  and  as follows:
 ::=  | p |    |    |   

(1)

where p  A. > (true) is the shorthand of   ,  for   , and    for (  )  ( 
). A theory is a set of formulas.
An interpretation is a set I of atoms from A, where each atom of A is viewed to be true if it is in
I, and false otherwise. In propositional logic, the notions of model and satisfaction relation |= are
defined as usual. In the following we denote A \ X by X for X  A, Mod() for {M |M |= },
/ M} where
   for Mod() = Mod() (i.e.  is equivalent to ) and M for {I  A|I 
A
M  2 . A formula  is irrelevant to a set V of atoms, written IR(, V ), if there exists a formula
 mentioning no atoms from V such that   .
For convenience,
we
W
V also define the following notations. Let S be a finite set of formulas.
W
We denote SV(resp.
S) the disjunction (resp. conjunction) of all formulas in S, where 
denotes  and  denotes >, and |S| the cardinality of S. Similarly by S (resp. S) we mean
{ |   S} (resp. { |   S}).
2.2 Reduct and Stable Models
Let  be a formula and X  A. The ?-reduct of  w.r.t. X, written Red? (, X), is recursively and
uniformly defined as follows:
4. In the rest of this paper, whenever there is no confusion, we may not explicitly mention the signature when we talk
about formulas of LA .

35

fiWANG , Z HANG , Z HOU , & Z HANG

(?-R1) Red? (, X) = ;
(?-R2) Red? (p, X) = p if X |= p, and  otherwise;
(?-R3) Red? (1  2 , X) = Red? (1 , X)  Red? (2 , X) if X |= 1  2 where   {, }, and
 otherwise;
(HT-R4) RedHT (1  2 , X) = RedHT (1 , X)  RedHT (2 , X) if X |= 1  2 , and  otherwise;

 1  RedFLP (2 , X), if X |= 1  2 ;
(FLP-R4) RedFLP (1  2 , X) =
>,
if X 6|= 1 ;

,
otherwise (i.e. X 6|= 1  2 ).

Definition 1 A set X  A is a ?-stable model of a formula  if X is a minimal (under set inclusion)
model of Red? (, X). We denote the set of ?-stable models of  by SM ? ().
Please note that, traditionally, the HT-reduct is named reduct; Red HT (, X) is written as X ;
HT-stable model is called stable model (Ferraris, 2005); and RedFLP (, X) is written as X 
(Truszczynski, 2010).
It is known that, HT-stable models and FLP-stable models are not comparable in the sense that
some HT-stable models are not FLP-stable models, and some FLP-stable models are not HT-stable
models (cf., see Truszczynski, 2010, Exs. 1, 2, 4 and 5).
Example 1 Let us consider the following formulas:
 Let  = p  p  p. We have that
RedHT (, )  , RedHT (, {p})  >, RedFLP (, )  , RedHT (, {p})  p.
Thus SM HT () = , while SM FLP () = {{p}}.
 Let 1 = p  p and 2 = p  p. We have the following:
RedHT (i , )  > and RedHT (i , {p})  p, for i = 1, 2,
RedFLP (1 , )  >, Red FLP (1 , {p})  p, RedFLP (2 , )  >, RedFLP (2 , {p})  >.
Thus, while SM FLP (1 ) =

SM HT (1 )

= {, {p}}, SM FLP (2 ) = {}.

Definition 2 Two formulas 1 and 2 are ?-SM -equivalent (under ?-stable model semantics), written 1 ?SM 2 , iff they have the same ?-stable models.
Here the notion of HT-SM -equivalence is indeed the notion of equivalence in logic programs
under stable model semantics (cf., see Lifschitz et al., 2001, Thm. 1).
36

fiK NOWLEDGE F ORGETTING

IN

A NSWER S ET P ROGRAMMING

2.3 Strong Equivalence and Knowledge of Logic Programs
Unlike the equivalence in propositional logic, the equivalence of logic programs does not allow
equivalent replacement i.e.,   1 and   2 may have different stable models, even though 1
and 2 are equivalent.
Example 2 Let 1 = p  q and 2 = p  p. As SM ? (1 ) = SM ? (2 ) = {}, 1 and 2 are
?-SM-equivalent; however, p  1 has a ?-stable model {p, q} while the unique ?-stable model of
p  2 is {p}. Thus it does not allow replacing 1 by 2 in p  1 . It also indicates that 1 has
different knowledge from 2 under the ?-stable model semantics.
This motivates the notion of strong equivalence.
Definition 3 Two formulas 1 and 2 are strongly ?-equivalent (under ?-stable model semantics)
iff   1 ?SM   2 for every formula . In the case 1 and 2 are strongly ?-equivalent, they
are ?-knowledge equivalent.
It is known that the notion of strong ?-equivalence can be captured in terms of ?-models, where
a ?-interpretation is a pair hX, Y i such that X  Y  A. The ?-satisfiability (thus ?-models),
denoted by |=? , is recursively defined as follows:
(?-S1) hX, Y i 6|=? ;
(?-S2) hX, Y i |=? p if p  X;
(?-S3) hX, Y i |=? 1  2 if hX, Y i |=? 1 or hX, Y i |=? 2 ;
(?-S4) hX, Y i |=? 1  2 if hX, Y i |=? 1 and hX, Y i |=? 2 ;
(HT-S5) hX, Y i |=HT 1  2 if Y |= 1  2 ; and hX, Y i |=HT 1 implies hX, Y i |=HT 2 ;
(FLP-S5) hX, Y i |=FLP 1  2 if Y |= 1  2 ; and Y 6|= 1 or X 6|= 1 or hX, Y i |=FLP 2 .
By Mod? () we denote the set of all ?-models of formula . Please note here that, ? can be
either HT or FLP . In particular, ModHT () (resp. ModFLP ()) denotes the set of all HT-models (resp.
FLP-models) of . For the formulas 1 and 2 in Example 2, one can check that none of h, {p}i,
h{p}, {p}i or h{p}, {p, q}i is a ?-model of 1 , while every ?-interpretation is a ?-model of 2 .
Definition 4 A formula  is a logical ?-consequence of a formula , written  |=? , iff Mod? () 
Mod? (); two formulas  and  are ?-equivalent (under ?-model semantics), written  ? , iff
Mod? () = Mod? ().
In the following proposition, item (i) is proved by Lifschitz, Tang, and Turner (cf., see Lifschitz
et al., 1999, (iii) of Prop. 6).
Proposition 1 Let A, B, C, D be set of atoms. We have the following
V
W
V
W
(i) (A  B)  (D  C) HT (A  B  C)  D.
V
W
V
W
(ii) (A  B)  (D  C) |=FLP (A  B  C)  D.
37

fiWANG , Z HANG , Z HOU , & Z HANG

Please note here that the inverse of (ii) does not generally hold. For instance, p  p FLP >
while h, {p}i 6|=FLP p  p.
Given two formulas 1 and 2 , it is known that 1 and 2 are strongly HT-equivalent under
HT -stable model semantics if and only if they are HT -equivalent, viz. 1  HT 2 ; 1 and 2 are
strongly FLP -equivalent under FLP -stable model semantics if and only if they are FLP -equivalent,
viz. 1 FLP 2 (cf., see Truszczynski, 2010, Thm. 7). It is commonly recognized that strong
equivalence amounts to knowledge equivalence of formulas. That is, strong ?-equivalence captures
the logical content of a formula under ?-stable model semantics (Osorio & Zacarias, 2004; Osorio
& Cuevas, 2007; Delgrande et al., 2013). Now we formally define the knowledge of logic programs.
Definition 5 The ?-knowledge of a formula  under ?-stable model semantics, written Cn? (),
consists of the logical ?-consequence of , viz, Cn? () = { |  |=? }.
The ?-knowledge of a formula stands for the ?-logical content of the formula. For instance,
CnHT (>) = CnHT (p  p)  CnHT (p  q).
Recall that, under ?-model semantics, every formula can be transformed into a conjunction of
formulas in the following normal form:
^
_
(B  C)  (A  D)
(2)
where A, B, C, D are sets of atoms (cf., for ? = HT, see Cabalar & Ferraris, 2007, Thm. 2;
Truszczynski, 2010, Thm. 9 for ? = FLP ). That is, for every formula , there is a conjunction
of formulas in the form (2) which is strongly ?-equivalent to .
A formula of the form (2) is called a rule, which is also generally written as
a1 ; . . . ; al ; not d1 ; . . . ; not dn  b1 , . . . , bk , not c1 , . . . , not cm

(3)

where A = {ai |1  i  l}, B = {bi |1  i  k}, C = {ci |1  i  m} and D = {di |1  i  n}.
A logic program is a finite set of rules. Let r be a rule of the form (2). It is said to be
 disjunctive if D = ;
 positive if C = D = ;
 normal if |A|  1 and D = ; and
 Horn if |A|  1 and C = D = .
A logic program is disjunctive (resp. positive, normal, and Horn) iff it consists of disjunctive
(resp. positive, normal, Horn) rules. A logic program is ?-consistent (under ?-stable model semantics) if it has at least one ?-stable model.
It is known that every logic program has the same HT-models and FLP-models (cf., see Truszczynski, 2010, Prop. 8).
Proposition 2 Every logic program has the same HT- and

FLP-models.

3. Characterizations of Knowledge Equivalence
In the section, from the perspective of ?-models, we consider the characterization for knowledge
equivalence of various logic programs firstly, and relate the knowledge equivalence to the equivalence of propositional logic secondly.
38

fiK NOWLEDGE F ORGETTING

IN

A NSWER S ET P ROGRAMMING

3.1 Model Theoretical Characterization
We firstly recall some basic properties of the ?-satisfiability (Ferraris & Lifschitz, 2005; Ferraris,
2005; Truszczynski, 2010).
Proposition 3 Let  be a formula and X  Y  A.
(i) If hX, Y i |=?  then hY, Y i |=?  (i.e., Y |= ).
(ii) hX, Y i |=?  iff Y |= .
(iii) hX, Y i |=?  iff X |= Red? (, Y ).
A collection M of ?-interpretations is ?-expressible whenever there exists a formula  such that
Mod? () = M. A collection M of ?-interpretations may be not ?-expressible. For instance, there
is no formula whose ?-models are the ones in M = {h, {p}i}. The reason is that if there is a
formula  such that Mod? () = M then we have h{p}, {p}i |=?  by (i) of Proposition 3. This
requires h{p}, {p}i belonging to Mod? (), a contradiction.
Given a formula  and X  Y  A, hX, Y i is a ?-countermodel of  if hX, Y i 6|=?  and
hY, Y i |=? ; hY, Y i is a ?-countermodel of  if hY, Y i 6|=? . Let X  Y  A, we define the
following formulas:
_
(X  Y )  ((Y \ X)  (Y \ X)),
_
^
FLP (X, Y ) = (X  Y )  (X  Y ),
^
(Y, Y ) = (Y  Y )  ,
_
^
(X, Y ) = (X  Y )  (Y \ X).
HT (X, Y ) =

^

(4)
(5)
(6)
(7)

Here ? (X, Y ) and (Y, Y ) is to capture the ?-countermodel hX, Y i and hY, Y i respectively.
The following lemma shows that the ?-countermodel can be captured by a formula (cf., for
? = HT, see Cabalar & Ferraris, 2007, Prop. 1; Truszczynski, 2010, Props. 5 and 6 for ? = FLP ).
Lemma 1 Let X  Y  A and U  V  A.
(i) hU, V i is a ?-countermodel of ? (X, Y ) iff U = X and V = Y .
(ii) hU, V i is a ?-countermodel of (Y, Y ) iff V = Y .
Proposition 4 A collection M of ?-interpretations is ?-expressible iff
hX, Y i  M implies hY, Y i  M.
Actually, if M satisfy condition (8) then the following logic program
? = {? (X, Y )|hX, Y i 
/ M and hY, Y i  M}  {(Y, Y )|hY, Y i 
/ M}
captures M in the sense that Mod? (? ) = M.
39

(8)

fiWANG , Z HANG , Z HOU , & Z HANG

Note that Wong (2009) presented a model-theoretical characterization for the HT-models of
disjunctive logic programs (cf., see Wong, 2009, Thm. 2.7). Formally speaking, a collection M of
HT-interpretations is disjunctively HT-expressible, i.e., there is a disjunctive logic program  such
that ModHT () = M, iff the condition (8) and the following one hold:
if hX, Y i  M, Y  Y 0 and hY 0 , Y 0 i  M then hX, Y 0 i  M.

(9)

Together with Proposition 2, we have
Corollary 1 A collection M of
tions (8) and (9) hold.

FLP -interpretations

is disjunctively

FLP -expressible

iff the condi-

Actually, if M satisfies the conditions (8) and (9) then the following disjunctive logic program
captures M.
 = {(X, Y )|hX, Y i 
/ M and hY, Y i  M}  {(Y, Y )|hY, Y i 
/ M}.
Lemma
V
W2 Let A, B beVtwo sets
W of atoms, and X  Y  A. hX, Y i |=?
B  A and Y |= B  A.

V

B 

W

A iff X |=

Proposition 5 A set M of ?-interpretations is positively ?-expressible, i.e., there is a positive logic
program  s.t Mod? () = M, iff M satisfies the criteria:
hX, Y i  M iff X  Y, hX, Xi  M and hY, Y i  M.

(10)

As
Va matter
W of fact, in the case M satisfies the condition (10), the positive logic program  =
/ M} captures M.
{ X  X|hX, Xi 

Corollary 2 Two positive logic programs are strongly ?-equivalent if and only if they are equivalent
in propositional logic.

Eiter, Fink, Tompits, and Woltran (2004) have showed that a disjunctive logic program  is
strongly equivalent to a normal logic program if and only if  is closed under here-intersection, i.e.,
for every pair of HT-models hX, Y i and hX 0 , Y i of , hX  X 0 , Y i is also an HT-model of  (cf.,
see Eiter et al., 2004, Thms. 1 and 2). In terms of the characterization of disjunctive logic programs
and Proposition 2, we obtain a ?-model characterization for normal logic programs as follows.
Corollary 3 A set M of ?-interpretations is normally ?-expressible, i.e., there is a normal logic
program  such that Mod? () = M, iff M satisfies, in addition to (8) and (9), the following
criteria:
if hX, Y i  M and hX 0 , Y i  M then hX  X 0 , Y i  M.
(11)
Proposition 6 A collection M of ?-interpretations is Horn ?-expressible, i.e., there is a Horn logic
program  such that Mod? () = M, iff M satisfies, in addition to (10), the following criteria:
hX, Y i  M and hH, T i  M  hX  H, Y  T i  M.
40

(12)

fiK NOWLEDGE F ORGETTING

IN

A NSWER S ET P ROGRAMMING

3.2 Relating Knowledge Equivalence to Propositional Logic
It is proved that strong equivalence of logic programs under stable model semantics can be related
to the equivalence in propositional logic (Pearce et al., 2001; Lin, 2002). This holds for the strong
FLP-equivalence of logic programs as we will show in the following.
Firstly, we extend the language LA to LAA0 where A0 = {p0 |p  A} and p0 s are fresh atoms.
For each expression  of LA , by 0 we denote the result obtained from  by replacing each atom p
from A by the corresponding atom p0 in A0 . In the following we denote
(A) = {p  p0 | p  A}.

(13)

Please note that, for each model M of (A), M has a splitting MA and MA0 where MA = M  A
and MA0 = M  A0 and, for every p  MA , the atom p0 of A0 belongs to MA0 . For M  A0 we
denote by M  the set {p  A|p0  M }.
Definition 6 HT [.] and FLP [.] are recursively defined as follows:
(T1) ? [] = ;
(T2) ? [p] = p;
(T3) ? [1  2 ] = ? [1 ]  ? [2 ] where   {, };
(HT-T4) HT [1  2 ] = (01  02 )  (HT [1 ]  HT [2 ]);
(FLP-T4) FLP [1  2 ] = (01  02 )  (1  01  FLP [2 ]).
Please note that the translation HT is same to the translation  defined by Pearce, Tompits, and
Woltran (2001). One can verify that HT [] = 0  HT [], while FLP [] = 0 . Given a
theory  of LA , we define ? [] = {? [] |   }. It is evident that ? [] is in linear size of .
Example 3 Let  = p  p  p. We have that
HT [] = ((p0  p0 )  p0 )  ((p  p  p0 )  p)  p0 ,
FLP [] = ((p0  p0 )  p0 )  ((p  p)  (p0  p0 )  p)  p0  p.
The unique FLP-model (over the signature {p}) of  is h{p}, {p}i. However,  has two HT-models
h, {p}i and h{p}, {p}i. Over the signature {p, p0 }, one can easily check that {HT []}  (A) has
two models {p, p0 } and {p0 }, while {FLP []}  (A) has a unique model {p, p0 }.
V
W
Proposition 7 Let  = (B  C)  (A  D), where A, B, C, D are subsets of A. Then we
have (A) |= FLP []  HT [].
The following proposition connects the ?-equivalence with the equivalence in classical propositional logic (cf., for ? = HT, see Pearce et al., 2001, Lem. 2).
Proposition 8 Let  be a formula of LA and X  Y  A. Then hX, Y i is a ?-model of  iff
X  Y 0 is a model of (A)  {? []}.
41

fiWANG , Z HANG , Z HOU , & Z HANG

The following theorem shows that the strong ?-equivalence of logic programs under ?-stable
model semantics can be reduced to the equivalence in propositional logic (cf., for ? = HT, see
Ferraris et al., 2011, Thm. 9; or Lin & Zhou, 2011, (5) of Thm. 6).
Theorem 4 Two formulas  and  have the same ?-models (over A) iff (A){? []} and (A)
{? []} have the same models (over A  A0 ).
Based on the theorem, we obtain the following complexity result (cf., for ? =
Tompits, & Woltran, 2009, Thms. 8 and 11).

HT ,

see Pearce,

Proposition 9 (i) The problem of deciding if a formula is ?-satisfiable is NP-complete.
(ii) The problem of deciding if two formulas are ?-equivalent is co-NP-complete.

4. Knowledge Forgetting in Logic Programs
As mentioned in the introduction, we concentrate on the knowledge forgetting of logic programs
under stable model semantics. It is formally stated as following:
Definition 7 (Knowledge forgetting) Let  be a logic program and V  A. A logic program  is
a result of ?-knowledge forgetting V from , if and only if  consists of the ?-knowledge of  that
mentions no atom from V .
We will show that such a knowledge forgetting result always exists and it is unique up to strong
equivalence (cf. Theorem 6) after a semantic ?-forgetting is defined and explored.
Let V, X, Y be sets of atoms. The set Y is V -bisimilar to X, written Y V X, if Y \V = X \V .
It intuitively states that the interpretations X and Y agree with each other on those atoms not in V .
Two ?-interpretations hH, T i and hX, Y i are V -bisimilar, written hH, T i V hX, Y i, if H V X
and T V Y . Now, we are in the position to define the semantic knowledge forgetting in terms of
bisimulation.
Definition 8 (Semantic knowledge forgetting) Let  be a formula and V  A. A formula  is a
result of (semantic) ?-forgetting V from  whenever, for every ?-interpretation M ,
M  Mod? () iff M 0  Mod? () s.t M V M 0 .

(14)

According the definition, one can see that the ?-models of  can somehow exactly constructed from
those of . This motivates us to define the following notion of extension.
Let V, X, Y be sets of atoms. The V -extension of X, denoted by XV , is the collection of
interpretations that are V -bisimilar to X. The V -extension of a ?-interpretation hH, T i, denoted
by hH, T iV , is the collection of ?-interpretations that are V -similar to hH, T i. For instance, let
hH, T i = h{p, q}, {p, q}i and V = {q, r}. Then hH, T iV contains h{p}, {p}i, h{p}, {p, q}i,
h{p}, {p, q, r}i, h{p, q, r}, {p, q, r}i and so on. Intuitively speaking, the V -extension of an interpretation M is the collection of interpretations formed from M by freely adding or removing some
atoms
Sin V . The V -extension of a collection M of (?-)interpretations, written MV , is the collection M V .
In classical propositional logic if M corresponds to a formula , i.e. M = Mod(), then MV
corresponds to a formula whose truth value has nothing to do with the atoms in V . The intended
meaning in the case of ?-models is similar when MV corresponds to a formula under ?-model
42

fiK NOWLEDGE F ORGETTING

IN

A NSWER S ET P ROGRAMMING

semantics that is relevant to only the atoms not in V . In other words, suppose MV = Mod? ().
If hX, Y i |=?  then hH, T i |=?  where H (resp. T ) is obtained from X (resp. Y ) by freely
adding or removing any atoms in V whenever H  T . The following lemma shows an equivalent
condition for the semantic ?-knowledge forgetting.
Lemma 3 Let  be a formula and V  A. A formula  is a result of ?-forgetting V from , iff the
following condition holds:
Mod? () = Mod? ()V .
(15)
This condition of ?-forgetting is a generalization of the forgetting in propositional logic (Lin &
Reiter, 1994) in terms of the following corollary.
Corollary 5 A formula  is a result of forgetting a set V of atoms in a formula  iff Mod() =
Mod()V , where Mod(.) refers to classical propositional logic.
A syntactic counterpart of the forgetting in propositional logic is defined as follows (Lin, 2001;
Lang et al., 2003):
Forget(, {p}) = [p/]  [p/>],
Forget(, V  {p}) = Forget(Forget(, {p}), V )
where [p/>] (resp. [p/]) is the formula obtained from  by replacing every occurrence of the
atom p with > (resp. ).
As ?-interpretations are related to the given signature A, in what follows, we shall assume that
the signature of a formula/theory is implicitly given by the atoms occurring in the formula/theory,
unless explicitly stated otherwise. The example below illustrates how ?-forgetting results can be
computed.
Example 4 Let  be the following formula
(p  q)  (q  p)  (p  )  (q  ).
Over the signature {p, q}, we have Mod? () = {h, {p, q}i, h{p, q}, {p, q}i}. Please note here
that ? can be either HT or FLP. Then from Definition 8, we can verify that Mod? (){p} =
{h, {q}i, h{q}, {q}i}{p} . It corresponds to the formula  = (p  q  )  (p  q)   under
the ?-model semantics by Proposition 4. As a matter of fact, we have  ? q   ? q.
Note that Forget(, {p}) = [p/>]  [p/]  q and q 6? q. It shows that, unlike the
syntactic counterpart of the forgetting in classical propositional logic, the ?-forgetting results cannot
be computed via [p/>]  [p/] as Mod? (q) = {h, {q}i, h{q}, {q}i}, while Mod? (q) =
{h{q}, {q}i} (over the signature {q}).

4.1 Expressibility
Please note that Definition 8 does not guarantee the existence of the forgetting results, however the
next theorem shows that the ?-forgetting result always exists. It also implies that the ?-forgetting
result is unique (up to strong ?-equivalence).
43

fiWANG , Z HANG , Z HOU , & Z HANG

Theorem 6 (Expressibility theorem) Let  be a formula and V a set of atoms. There exists a
formula  such that Mod? () = Mod? ()V .
Here, the uniqueness up to strong ?-equivalence of the ?-forgetting result follows from the fact
that, if a formula  0 is a result ?-forgetting V from  as well then Mod? ( 0 ) = Mod? ()V =
Mod? (), which shows that  and  0 are strongly ?-equivalent under the ?-stable model semantics.
Based on the expressibility result and by abusing the denotation, we denote the forgetting result
by Forget? (, V ):
Definition 9 Let  be a formula and V  A. Forget? (, V ) is a formula  s.t Mod? () =
Mod? ()V , i.e., Forget? (, V ) is a result of ?-forgetting V from .
In this sense Forget? is an operator which maps a formula and a set of atoms to a formula. According
to Definition 8 and the expressibility theorem, the following corollary easily follows.
Corollary 7 Let ,  be formulas, V , V1 and V2 be sets of atoms.
(i) Forget? (Forget ? (, V1 ), V2 ) ? Forget? (Forget ? (, V2 ), V1 ).
(ii) If  ?  then Forget? (, V ) ? Forget? (, V ).
It firstly states that ?-forgetting is independent of the order of forgotten atoms, and secondly, the
?-forgetting preserves strong ?-equivalence of logic programs under ?-stable model semantics.
To further investigate the properties of the forgetting, we introduce a notion of irrelevance under
?-model semantics.
Definition 10 A formula  is ?-irrelevant to a set V of atoms, denoted as IR? (, V ), if there exists
a formula  mentioning no atoms from V and  ? .
Some basic properties on ?-forgetting are presented below.
Proposition 10 Let  and  be two formulas and V a set of atoms.
(i) IR? (Forget ? (, V ), V ).
(ii)  has a ?-model iff Forget? (, V ) has.
(iii)  |=? Forget? (, V ).
(iv) If  |=?  then Forget? (, V ) |=? Forget? (, V ).
(v) Forget? (  , V ) ? Forget? (, V )  Forget? (, V ).
(vi) Forget? (  , V ) |=? Forget? (, V )  Forget? (, V ).
(vii) Forget? (  , V ) ? Forget? (, V )   if IR? (, V ).
44

fiK NOWLEDGE F ORGETTING

IN

A NSWER S ET P ROGRAMMING

Intuitively, (i) of the Proposition says that the ?-forgetting result is irrelevant to atoms in V ,
i.e., those forgotten atoms. In this sense, the signature of ?-forgetting result can be constrained
to A \ V . The intended meaning of the others can be easily read out. E.g., item (iii) says that this
forgetting is a kind of weakening, while item (v) shows that the forgetting has a distributive property
for disjunction.
As mentioned earlier, disjunctive programs, positive programs, normal logic programs and Horn
programs are four types of special cases of (arbitrary) logic programs under our setting. Then it is
interesting to consider whether the expressibility result also holds for each of these special programs.
For instance, we would like to know whether the result of ?-forgetting in a disjunctive (positive,
normal, and Horn) logic program is still expressible by a disjunctive (resp. positive, normal, and
Horn) logic program.
As indicated by the following two examples, HT- and FLP-forgetting in disjunctive, positive and
normal logic programs is possibly not expressible in either disjunctive or positive logic programs.
For simplicity, we identify a singleton set {} as  when it is clear from its context, and thus we
denote Forget? (, {p}) as Forget? (, p), and IR? (, {p}) as IR? (, p), and M{p} as Mp etc..
Example 5 Consider the following normal logic program  over signature {p, q}:
(p  q)  (q  p)  (p  q  ).
We have that Mod? () = {h{p}, {p}i, h{q}, {q}i} and
Mod? ()p = {h, i, h{q}, {q}i}{p} .
Here h{p}, {p}i{p} = h, i{p} . It implies that Forget? (, p) ? q  q. It can be easily seen that
q  q cannot be expressed as a disjunctive logic program because Mod? ()p does not satisfy (9).
Hence Forget? (, p) cannot be expressed by a normal logic program.
Please note that q  q HT q  q. Thus q  q is also a result of HT-forgetting p from .
However, q  q is not a result of FLP-forgetting p from  as q  q FLP > 6FLP q  q. 
Example 6 Let  be a positive logic program over signature {p, q, r} as follows:
(p  q  r)  (p  q  r)  (p  r  q)  (q  r  p).
It is not difficult to verify that, over the signature {p, r}, Mod? (){q} consists of
h, i, h, {p, r}i, h{p}, {p}i, h{p}, {p, r}i, h{r}, {r}i, h{r}, {p, r}i, h{p, r}, {p, r}i.
Clearly it does not satisfy the condition (9). Hence it can not captured by a disjunctive logic program. As a matter of fact, we have the following
Forget HT (, q) HT HT (, {p})  HT (, {r}) = (r  p  p)  (p  r  r),
Forget FLP (, q) FLP FLP (, {p})  FLP (, {r}) = (r  p  r  p)  (p  p  r  r)
in terms of Proposition 4. Interestingly, this example also shows that, though a logic program may
have the same HT-models as FLP-models, its HT-forgetting result may be different from its FLPforgetting result.

45

fiWANG , Z HANG , Z HOU , & Z HANG

The HT- and FLP-forgetting in Horn logic programs is of special interest, because unlike disjunctive, positive and normal logic programs, the result of HT- and FLP-forgetting result in a Horn
logic program is always expressible by a Horn logic program, as we show below.
Theorem 8 (Horn expressibility) Let  be a Horn logic program and V  A. There is a Horn
logic program 0 such that Forget? (, V ) ? 0 .
Having obtained the model-theoretical characterization of the classes of disjunctive and normal
logic programs respectively, we can easily derive a sufficient and necessary condition for HT- and
FLP-forgetting results to remain in the same class, i.e., the result of HT- and FLP-forgetting a set of
atoms in a disjunctive (resp. normal) logic program is a disjunctive (resp. normal) logic program.
Proposition 11 Let  be a disjunctive logic program, V  A. We have that Forget? (, V ) is
expressible in disjunctive logic programs if and only if,
hH1 , T1 i |=? , hT2 , T2 i |=?  and T1  T2  hH3 , T3 i |=?  such that hH3 , T3 i V hH1 , T2 i.
Proposition 12 Let  be a normal logic program, V  A. Then Forget? (, V ) is expressible in
normal logic programs if and only if, in addition to condition (16), the following condition holds,
hH1 , T1 i |=? , hH2 , T2 i |=?  and T1 V T2
 hH3 , T3 i |=?  such that H3 V H1  H2 and (T3 V T1 or T3 V T2 ).

(16)

4.2 Forgetting Postulates
Zhang and Zhou (2009) proposed four forgetting postulates in their work of knowledge forgetting,
and showed that their knowledge forgetting can be precisely characterized by the four postulates.
They further argued that these postulates should be viewed as a general semantic characterization
for knowledge forgetting in other logics. Indeed, the classical propositional forgetting can be also
characterized by these postulates. In terms of forgetting in logic programs, as we addressed in the
introduction, imposing these postulates is not feasible for existing approaches. In the following,
we show that ?-forgetting is exactly captured by these postulates, which we think is one major
advantage over other logic program forgetting approaches.
The notion of forgetting is closely related to that of uniform interpolation property (Visser, 1996;
Goranko & Otto, 2007), for instance, the forgetting in description logics (Lutz & Wolter, 2011) and
the semantic forgetting in logic programs (Gabbay, Pearce, & Valverde, 2011). The following
corollary follows from Theorem 6, which actually implies the uniform interpolation property of the
logics under ?-model semantics. Namely, for any formulas  and  with  |=? , there exists a
formula  such that  |=? ,  |=?  and  contains only the atoms occurring in both  and . The
formula  is called a uniform interpolant of  and . This is stated as:
Corollary 9 Let  and  be two formulas, V a set of atoms and IR? (, V ).
 |=? 

iff

Forget? (, V ) |=? .

Let  and  be two formulas and V a set of atoms. The following are Zhang-Zhous four
postulates for logic programs under ?-model semantics.
46

fiK NOWLEDGE F ORGETTING

IN

A NSWER S ET P ROGRAMMING

(W) Weakening:  |=? .
(PP) Positive persistence: if IR? (, V ) and  |=?  then  |=? .
(NP) Negative persistence: if IR? (, V ) and  6|=?  then  6|=? .
(IR) Irrelevance: IR? (, V ).
By specifying  ? Forget? (, V ), (W), (PP), (NP) and (IR) are called postulates for knowledge
forgetting in logic programs under ?-stable model semantics. Viz,  is a result of ?-forgetting V
in . Based on the uniform interpolation property (cf. Corollary 9), we can show the following
representation theorem.
Theorem 10 (Representation theorem) Let  and  be two formulas and V a set of atoms. Then
the following statements are equivalent:
(i)  ? Forget? (, V ).
(ii)  ? {0 |  |=? 0 and IR? (0 , V )}.
(iii) Postulates (W), (PP), (NP) and (IR) hold.
This theorem justifies that the knowledge forgetting (cf. Definition 7) exists and is unique up to
strong equivalence.
An obvious consequence follows from the representation theorem is that
Forget? (, V ) ? { |  |=?  and IR? (, V )}.
It says that the result of ?-forgetting V from  consists of the ?-logical consequence of  that
is ?-irrelevant to V . For this reason the forgetting is a knowledge forgetting of logic programs
under stable models semantics. As we have mentioned in the introduction that none of the other
forgetting approaches in logic programs is a knowledge forgetting since it does not satisfy some of
the postulates (see Section 5 for details).
One should note that the representation theorem is applicable for the forgetting in classical
propositional logic, viz, Forget(, V )  { |  |=  and IR(, V )}.
4.3 Relating to Propositional Forgetting
It has been shown that strong equivalence of logic programs may be related to the equivalence of
propositional logic (Pearce et al., 2001; Lin, 2002). As the ?-forgetting preserves strong equivalence
of logic programs under ?-stable model semantics, it is worth exploring further connections between
?-forgetting and the forgetting in propositional logic. In this section, we undertake an in-depth
investigation on this aspect.
We first provide a direct connection between ?-forgetting and propositional forgetting via the
following proposition.
Proposition 13 Let , 0 ,  be formulas and V  A such that  ? Forget? (, V ) and 0 
Forget(, V ). Then
(i)   0 .
47

fiWANG , Z HANG , Z HOU , & Z HANG

(ii) 0 |=? .
The result (i) in Proposition 13 simply says that the result of ?-forgetting and classical propositional forgetting are equivalent in classical propositional logic. Thus the forgetting in classic propositional logic can be computed by a ?-forgetting in logic programs. However as we have seen in
Example 4, Forget? (, V ) is possibly not ?-equivalent to Forget(, V ). The reverse of (ii) does not
hold generally. For instance, Forget? (p, q) ? p, while Forget(p, q)  p, and evidently
p 6|=? p. From this result and Theorem 8, we immediately have the following corollary.
Corollary 11 Let  be a Horn logic program and V a set of atoms. Then Forget(, V ) is expressible by a Horn logic program.
The following result states that, for Horn logic programs, ?-forgetting and the forgetting of
propositional logic are strongly ?-equivalent. Thus it provides a method of computing ?-forgetting
results of Horn logic programs through the propositional forgetting.
Proposition 14 Let  and 0 be two Horn logic programs, and V a set of atoms such that 0 
Forget(, V ). Then 0 ? Forget? (, V ).
The following proposition states that the ?-forgetting of double negative formulas is closely
connected with the classical propositional forgetting, which will be used to prove some complexity
results later.
Proposition 15 Let  and  be two formulas and V a set of atoms.
(i)   Forget(, V ) iff  ? Forget? (, V ).
(ii) Forget(, V )  Forget(, V ) iff Forget? (, V ) ? Forget? (, V ).
As it is known that the strong equivalence of logic programs is closed related to the equivalence
in propositional logic by translating logic programs into propositional theories (Pearce et al., 2001;
Lin, 2002). This motivates us to investigate the connection between the forgettings in the view of
the translations. Now our main result of this section is stated as follows.
Theorem 12 (?-forgetting vs propositional forgetting) Let  and  be two formulas of LA and
V  A. Then
 ? Forget? (, V ) iff (A) |= ? []  Forget((A)  {? []}, V  V 0 ).
By Theorem 12, we know that to check whether a formula  is a result of ?-forgetting a set
V of atoms from a formula , it is equivalent to check whether ? [] is classically equivalent
to Forget((A)  {? []}, V  V 0 ) under the theory (A). The following example shows an
application of this theorem.
Example 7 [Example 5 continued] Recall that  is the following formula:
(p  q)  (q  p)  (p  q  )
48

fiK NOWLEDGE F ORGETTING

IN

A NSWER S ET P ROGRAMMING

and Forget? (, p) ? q  q. Over the signature {p, q}, (A) = (p  p0 )  (q  q 0 ) and, the
program translation yields:
? ()  (p0  q)  (p0  q 0 )  (q 0  p)  (q 0  p0 )  (p0  q 0 ).
Now we have that Forget(? []  (A), {p, p0 }) is equivalent to:
(q  q 0 )  (q  q 0 ),

i.e.

(q 0  q)  (q  q 0 )

which is equivalent to q 0  q under the theory ({q}) = {q  q 0 }. One can further check that
? [q  q] = q 0  q  q  q 0  q (under the theory ({q})). Thus the formula q  q is a result
of ?-forgetting p from  by Theorem 12.

The following example further shows that (A) occurring in Forget? ({ []}  (A), V  V 0 )
is necessary for Theorem 12.
Example 8 [Continued from Example 6] Recall that A = {p, q, r}, (A) = {p  p0 , q  q 0 , r 
r 0 } and  consists of
(p  q  r)  (p  q  r)  (p  r  q)  (q  r  p).
We have that,
HT []    ,
(A) |= ? []    ,
FLP []  (p  q  r)  (p  q  p0  q 0  r)  (p  r  p0  r 0  q)  (q  r  q 0  r 0  p)  
where  = (p0  q 0  r 0 )  (p0  r 0  q 0 )  (q 0  r 0  p0 ).
One can check that
Forget(HT [], {q, q 0 })  >,
(A) |= Forget(FLP [], {q, q 0 })  >.
Recall that the formula 1 = (r  p  p)  (p  r  r) is a result of HT-forgetting q from ;
and 2 = (r  p  r  p)  (p  p  r  r) is a result of FLP-forgetting q from . We have
that
HT [1 ]  01  (r  r 0  p  p  p0 )  (p  p0  r  r  r 0 ),
FLP [2 ]  02  (r  r 0  p  r  p0 )  (p  p0  p  r  r 0 ).
Under the theory (A), we have
(A) |= HT [1 ]  (p0  p  r 0 )  (r 0  r  p0 ),
(A) |= HT [1 ]  (p0  p  r 0 )  (r 0  r  p0 ).
One can verify further that the model {p0 } of (A) is not a model of HT [1 ], nor it is a model of
FLP [2 ], i.e. (A) 6|= HT [1 ]  > and (A) 6|= FLP [2 ]  >. Actually, we have that,
(A) |= Forget({? []}  (A), {q, q 0 })  ((p0  r 0 )  (p  r)  (p0  r 0 )).
One can check further that
(A) |= (p0  p  r 0 )  (r 0  r  p0 )  ((p0  r 0 )  (p  r)  (p0  r 0 )),
which shows that 1 (resp. 2 ) is a result of HT-forgetting (resp.
49

FLP-forgetting)

q from .



fiWANG , Z HANG , Z HOU , & Z HANG

The following result states that we can reduce checking whether the ?-forgetting results of two
formulas are strongly ?-equivalent to checking whether the propositional forgetting results of corresponding two formulas are equivalent.
Proposition 16 Let  and  be two formulas of LA and V a set of atoms. Then Forget? (, V ) ?
Forget? (, V ) iff the following condition holds:
Forget({? []}  (A), V  V 0 )  Forget({? []}  (A), V  V 0 ).
4.4 Computation and Complexity
Theorem 6 and Propositions 4 and 10 imply a naive approach to compute ?-forgetting results. Formally speaking, given a formula  over a signature A and a set V of atoms, Forget? (, V ) can be
computed as follows:
(Step 1) Evaluating all ?-models of , denoted by M.
(Step 2) Restrict M to A \ V , denoted by M|V , i.e.
M|V = {hH \ V, T \ V i|hH, T i  M}.
(Step 3) Enumerating the following formulas (over the signature A \ V ) from M|V :
 ? (X, Y ) if hX, Y i 
/ M|V but hY, Y i  M|V ,
 (Y, Y ) if hY, Y i 
/ M|V .
(Step 4) Finally, conjunct all the constructed formulas, denoted by .
Corollary 13 Let , V and  be given as above. Then  ? Forget? (, V ).
Alternatively, in terms of Theorem 10, we can compute Forget? (, V ) by enumerating the ?consequences of  that are ?-irrelevant to V . As there exist sound and complete axiomatic systems
for the HT-logic (Jongh & Hendriks, 2003), checking HT-consequence relation is axiomatically
doable. Though a sound and complete axiomatic system for FLP-logic is recently unknown, we still
can enumerate all the formulas of form (2) over the signature A \ V and check if they are FLPconsequence of . Nevertheless, it is also observed that from a computational viewpoint, like the
propositional forgetting, each of the above two approaches would be expensive. This appears to be
inevitable in terms of the following complexity results, unless the complexity hierarchy collapses.
Theorem 14 Let  and  be two formulas and V a set of atoms.
(i) The problem of deciding if  ? Forget? (, V ) is co-NP-complete.
(ii) The problem of deciding if Forget? (, V ) ? Forget? (, V ) is P2 -complete.
(iii) The problem of deciding if  ? Forget? (, V ) is P2 -complete.
50

fiK NOWLEDGE F ORGETTING

IN

A NSWER S ET P ROGRAMMING

According to our representation theorem (i.e. Theorem 10), the result (i) in Theorem 14 means
that checking if  is ?-irrelevant to V , i.e. IR? (, V ), is intractable. The result (ii) of Theorem 14,
on the other hand, presents the complexity of ?-forgetting equivalence checking, i.e., if two formulas
are strongly ?-equivalent when they are restricted to a common signatures. The last result (iii) of
Theorem 14 states that checking if a formula is a result of ?-forgetting is generally difficult.
Proposition 17 Let  and  be two formulas and V a set of atoms.
(i) The problem of deciding whether  |=? Forget? (, V ) is P2 -complete.
(ii) The problem of deciding whether Forget? (, V ) |=?  is co-NP-complete.
Theorem 14 and Proposition 17 tell us that for ?-forgetting, in general the complexity of resulting checking and inference problems is located at the same level of the complexity polynomial
hierarchy as the propositional forgetting.
4.5 Conflict Solving Based on Knowledge Forgetting
In the following, we consider the application of the proposed forgetting in conflict solving for logic
program contexts, that represent a knowledge system consisting of knowledge bases of multiple
agents.
Definition 11 A logic program context is an n-ary tuple  = (1 , . . . , n ) where i is a consistent
logic program.  is ?-conflict-free if 1      n is consistent under ?-stable model semantics.
Definition 12 Let  = (1 , . . . , n ) be a logic program context. A ?-solution of  is a minimal
subset S of A such that (Forget? (1 , S), . . . , Forget? (n , S)) is ?-conflict-free, where A is the
underlying signature.
It is obvious that  is a ?-solution of ?-conflict-free logic program context .
We consider the following simplified Zhang and Foos conflict solving scenario (cf., see Zhang
& Foo, 2006, Ex. 6).
Example 9 A couple John and Mary are discussing their family investment plan. There are four
different shares shareA, shareB, shareC and shareD, where shareA and shareB are of high risk
but also have high return; shareC and shareD are of low risk and may be suitable for a long term
investment. Johns and Marys investment preference over these shares are encoded as the following
logic programs J and m respectively:
J :

M :

r1 :sA  not sB,

r10 :sC ,

r2 :sC  not sD,

r20 :sD ,

r3 :sD  not sC,

r30 :sB  not sA, not sC,

r4 :  sC, sD,
r40 :  sA, sB,
where s# stands for share#. The intuitive meaning of these rules can be easily read out. E.g. rule r1
says that John wants to buy shareA if he dont buy shareB, while rules r2 , r3 and r4 mean that John
wants to buy shareC or shareD, but not both of them.
51

fiWANG , Z HANG , Z HOU , & Z HANG

As one can see that J  M has no ?-stable model due to the confliction between rule r4 and
r10 , r20 , the logic program context  = (J , M ) is not ?-conflict-free.
For S = {sD}, we have the following
Forget HT (J , S) HT {sA  not sB,
Forget HT (M , S) HT {sC ,

sC; not sC },

sB  not sA, not sC,

 sA, sB}.

One can check that Forget HT (J , S)  Forget HT (M , S) has a unique HT-stable model {sA, sC}.
Thus S is an HT-solution of . It can be said that John and Mary may have an agreement on
their investment plan about shares shareA, shareB and shareC if they agree to give up the belief
(knowledge) about shareD. It results in an investment to shares shareA and shareC, but not to
shareB.
One can further check that, under the FLP-stable model semantics, if John and Mary can give up
the belief about shareD then it results in the same investment plan to shares shareA and shareC, but
not to share shareB. The reason is that Forget FLP (J , S)Forget FLP (M , S) has a unique FLP-stable
model {sA, sC}.

5. Related Work
In this section we compare the ?-forgetting with weak and strong forgetting (Zhang & Foo, 2006),
semantic forgetting (Eiter & Wang, 2008) and the forgetting operators FS and FW (Wong, 2009).
5.1 Weak and Strong Forgetting
Let  be a normal logic program and p a propositional atom. The reduction of  with respect to p,
denoted by Red(, {p}), is the normal logic program obtained from  by
(1) for each rule r of  with p  Head(r), if there is a rule r 0 in  such that p  Body+ (r 0 ), then
replacing r 0 with
Head(r 0 )  Body(r), Body(r 0 ) \ {p}.
(2) if there is such a rule r 0 in  and it has been replaced by a new rule in the previous step, then
removing the rule r from the remaining normal logic program.
Let X be a set of propositional atoms. Then the reduction of  with respect to X is inductively
defined as follows:
Red(, ) = ,
Red(, X  {p}) = Red(Red(, {p}), X).
The strong forgetting p in a normal logic program  is the normal logic program SForget(, {p})
obtained from Red(, {p}) by removing each rule r if either r is valid 5 or p  Head(r) 
Body+ (r)  Body (r). The weak forgetting p in  is the normal logic program WForget(, {p})
obtained from Red(, {p}) by firstly removing each rule r if either r is valid, or p  Head(r) 
Body+ (r) and then removing not p from the remaining rules.
5. A rule r is valid if Head(r)  Body+ (r) 6=  or Body+ (r)  Body (r) 6= .

52

fiK NOWLEDGE F ORGETTING

IN

A NSWER S ET P ROGRAMMING

Let X be a set of atoms. The strong (and weak) forgetting X in  is recursively defined as
SForget(, ) = ;

WForget(, ) = ;

SForget(, X  {p}) = SForget(SForget(, {p}), X);
WForget(, X  {p}) = WForget(WForget(, {p}), X).
It is known that the two forgetting operators are independent of the ordering of forgotten atoms in
the sense of strong HT-equivalence of logic programs under HT-stable model semantics (cf., see
Zhang & Foo, 2006, Prop. 2).
Example 10 Consider the below two normal logic programs:
 = {p  q,

q  p,

r  not p},

 = {p  q,

q  p,

r  not q}.

One can check that  and  are strongly equivalent. We have that
SForget(, {p}) = ,

WForget(, {p}) = {r },

SForget(, {p}) = WForget(, {p}) = {r  not q}.
The example shows that neither weak forgetting preserves strong equivalence, nor is strong forgetting. One can further verify that  |=? q  r   and  6|=? r for ?  {HT, FLP }. Thus
the strong forgetting does not satisfy positive persistence, and the weak forgetting does not satisfy weakening and negative persistence. Actually, for HT- and FLP-forgetting, we have the
following
Forget HT (, p) HT Forget HT (, p) HT {q  r  },
Forget FLP (, p) FLP Forget FLP (, p) FLP {q  r  }.
Here  FLP  follows from the fact that  HT  and Proposition 2.



5.2 Semantic Forgetting
Having addressed certain issues of weak and strong forgetting, Eiter and Wang (2008) proposed
a semantic forgetting for consistent disjunctive logic programs. Formally speaking, let  be a
consistent disjunctive logic program and p an atom. A set M of atoms is a p-stable model of  iff
M is a stable model of  and there is no stable model M  of  such that M  \ {p}  M \ {p}. A
disjunctive logic program 0 represents the result of forgetting about p in , if
 0 does not mention the atom p, and
 a set M 0 of atoms is a stable model of 0 iff  has a p-stable model M such that M 0 p M .
In terms of the above definition, such forgetting results are not unique under strong equivalence.
This means, their forgetting does not preserve strong equivalence. To compute the result of forgetting an atom in a consistent disjunctive logic program, they proposed three algorithms forget1 ,
forget2 and forget3 (Eiter & Wang, 2008). The example below further demonstrates the difference
between this semantic forgetting and the ?-forgetting.
53

fiWANG , Z HANG , Z HOU , & Z HANG

Example 11 Let  = {p  q} be a program over signature A = {p, q, r}. Although program  has nothing to do with the atom r, we have that forgeti (, r) =  (i = 1, 2, 3), which
seems not intuitive as it loses some information irrelevant to what we want to forget. However
Forget? (, r) ? .

This example also shows that the semantic forgetting does not satisfy positive persistence
postulate as  |=? q  p, which is lost in the semantic forgetting result forgeti (, r) for i = 1, 2, 3.
5.3 Forgetting Operators FS and FW
Wong (2009) developed his forgetting for disjunctive logic programs. Differently from the work
of Zhang and Foo (2006), and Eiter and Wang (2008), Wongs forgetting is defined based on the
HT-logic. In this sense, his approach probably shares a common logic ground with HT-forgetting.
Wong also defined two forgetting operators FS and FW , which correspond to two series of program
transformations. See Appendix D for the detailed definitions.
The interesting feature of Wongs forgetting is that it preserves strong equivalence. However,
a major issue with this forgetting is that: on one hand, the forgetting FS may cause unnecessary
information loss; on the other hand, the forgetting FW may also introduce extra information that
one does not want, as illustrated by the following example.
Example 12 Let us consider the normal logic program  consisting of:
a  x,

y  a, not z,

q  not p,

p  not q,

 p, q.

Then we have:
FS (, {a, p}) HT {y  x, not z},
FW (, {a, p}) HT {y  x, not z,

 x,

Forget HT (, {a, p}) HT {y  x, not z,
Forget FLP (, {a, p}) FLP {y  x, not z,

q },
q  not not q},
q  not not q}.

Since  |=HT {q  not not q}, which is irrelevant to atoms a and p, it seems to us that forgetting
{a, p} from  should not affect this fact. But FS (, {a, p}) 6|=HT {q  not not q}. In this sense,
we see that FS has lost some information that we wish to keep. This shows that the operator FS does
not satisfy positive persistence postulate.
On the other hand, from the fact that  6|=HT q but FW (, {a, p}) |=HT q, it appears that FW may
introduce unnecessary information, which indeed conflicts our intuition of program weakening via
forgetting, i.e., it does not satisfy the weakening postulate.

As we mentioned in the introduction, the following example confirms that an expected result
can not be obtained from either one of the above three forgetting approaches.
Example 13 [Continued from Example 5] For the normal logic program :
(p  q)  (q  p)  (p  q  ),
54

fiK NOWLEDGE F ORGETTING

IN

A NSWER S ET P ROGRAMMING

we have the following:
SForget(, {p}) = forget1 (, {p}) = FS (, {p}) = ,
WForget(, {p}) = FW (, {p}) = {q}.
Here, the expected logic program that represents the same information of  when the auxiliary atom
p is ignored should be q  q.


6. Concluding Remarks
In this paper two semantic knowledge forgetting approaches, called HT- and FLP-forgetting respectively, were proposed for logic programs under stable model and FLP-stable model semantics respectively. These knowledge forgetting results can be captured by the corresponding logical consequence of forgotten logic programs that are irrelevant to forgotten atoms. It consequently preserves
strong equivalence of logic programs under HT- and FLP-stable model semantics respectively. This
is a major advantage when compared to other existing forgetting approaches in logic programming.
As a starting point, we investigated the model theoretical characterization of logic programs under HT- and FLP-stable model semantics, and studied their respective strong equivalence problems
using classical propositional logic equivalence. Many properties of forgetting have been explored,
such as existence of forgetting results, a representation theorem, and the complexity of some decision problems related to these forgettings. We also considered an application of knowledge forgetting in conflict solving.
Although we have presented abstract approaches to computing the forgetting results and we
showed the underlying difficulties of the computation, it is valuable to study practical algorithms
for different subclasses of logic programs. Another challenging future work is to extend the knowledge forgetting to other nonmonotonic systems, and in particular first-order logic programs (Ferraris
et al., 2011). As we have mentioned in the introduction that forgetting can be effectively used to
solve some confliction, e.g. the strong and weak forgetting (Zhang & Foo, 2006) and the propositional forgetting (Lang & Marquis, 2010), such an application of knowledge forgetting deserves
further studying.
As what we concentrate upon in this paper is knowledge forgetting in logic programs, which is
based on the notion of strong equivalence, an interesting work is to consider forgetting under the
stable model semantics of logic programs along the work (Wang et al., 2013). Last but not least,
logic programs under supported model semantics enjoys some similar properties as that of logic
programs under HT- and FLP-stable models semantics (Truszczynski, 2010), we will consider the
knowledge forgetting for logic programs under the supported model semantics in another paper.

Acknowledgments
We thank Mirek Truszczynski for encouraging us to consider knowledge forgetting for logic programs under the FLP-stable model semantics. We thank the anonymous reviewers for their insightful comments, and Robin Bianchi for his help on formatting the paper. Yisong Wang is partially
supported by the National Natural Science Foundation of China grant 61370161 and Stadholder
Foundation of Guizhou Province under grant (2012)62.
55

fiWANG , Z HANG , Z HOU , & Z HANG

Appendix A. Proofs for Section 2
Proposition 1 Let A, B, C, D be set of atoms. We have the following
V
W
V
W
(i) (A  B)  (D  C) HT (A  B  C)  D.
V
W
V
W
(ii) (A  B)  (D  C) |=FLP (A  B  C)  D.

V
W
Proof:
(ii)
Suppose
hX,
Y
i
is
an
FLP-model of (A  B)  (D  C) but not an FLP-model
V
W
of (A  B  C)  D. It follows that the following conditions hold:
V
V
(a) X |= (A  B  C), which implies X |= (A  B).
V
V
V
(b) Y |= (A  B  C), which implies Y |= (A  B)  C, and
W
W
(c) hX, Y i 6|=FLP D, i.e. X 6|= D.
W
W
W
The conditions (a) and (b) show that hX, Y i |=FLP (D  C), i.e. X |= D or Y |= C.
Together with the conditions (b) and (c), a contradiction follows.


Appendix B. Proofs for Section 3
Proposition 4 A collection M of ?-interpretations is ?-expressible iff
hX, Y i  M implies hY, Y i  M.

(17)

Actually, if M satisfy condition (17) then the following logic program
? = {? (X, Y )|hX, Y i 
/ M and hY, Y i  M}  {(Y, Y )|hY, Y i 
/ M}
captures M in the sense that Mod? (? ) = M.
Proof: The direction from left to right follows from (i) of Proposition 3. We prove the other
direction. Let ? be the propositional theory consisting of, for every X  Y  A,
 ? (X, Y ) if hX, Y i 
/ M and hY, Y i  M, and
 (Y, Y ) if hY, Y i 
/ M.
By Lemma 1, Mod? (? ) = M.



Lemma
V
W2 Let A, B beVtwo sets
W of atoms, and X  Y  A. hX, Y i |=?
B  A and Y |= B  A.

V

B 

W

A iff X |=

Proof: According to (iii) of Proposition 3 and Proposition 2, it is sufficient to show that, for the
case ? = HT,
^
_
^
_
^
_
X |= ( B 
A)Y iff X |=
B
A and Y |=
B
A.

V
W
V
W Y
Note that Y |= B  A and X |= ( B)Y implies X
V () W
V |= ( A) . Suppose X 6|=
B  A, i.e. B  X and A  X = . It follows that Y |= B due to B  Y , and then
56

fiK NOWLEDGE F ORGETTING

IN

A NSWER S ET P ROGRAMMING

W
V
V
V
W
Y |= A,Wi.e. A  Y 6= . Thus we have X |= ( B)Y since ( B)Y = B. By X |= ( A)Y
i.e. X |= A, we have X  A 6= , a contradiction.
V
W
V
W
()VWe need only to show
X |= ( B)Y  ( A)Y since Y |=
B 
A. Suppose
W
X |=V( B)YW and X 6|= ( A)Y . The former implies B  X  Y , thus X  A 6=  by
X |= B  A. The latter implies X  (A  Y ) = , which means X  A =  since X  Y , a
contradiction.

Proposition 5 A set M of ?-interpretations is positively ?-expressible, i.e., there is a positive logic
program  s.t Mod? () = M, iff M satisfies the criteria:
hX, Y i  M iff X  Y, hX, Xi  M and hY, Y i  M.

(18)

Actually, if M satisfy condition (18) then the following logic program
^
_
X|hX, Xi 
/ M}
? = { X 

captures M in the sense that Mod? (? ) = M.

Proof: It suffices to prove the case ? = HT by Proposition 2.
() Let  be a positive logic program whose HT-models are exact the ones in M. For every
HT-interpretation hX, Y i, by Lemma 2, hX, Y i |= HT  iff X  Y , X |=  i.e. hX, Xi |= HT ,
and hY, Y i |=HT  i.e. Y |=  since every rule of  is positive. The condition (18) follows.
() Let N = {X  A|hX, Xi  M}. We construct the propositional theory  consisting of
^
_
X
X

for every X  N (= 2A \ N ).
Firstly we show
V Mod()
W = N . Suppose X |=  and X 6 N . We have that X  N . It follows
that X 6|=  as X  X belongs to . On the
V other hand,
W suppose X  N and X 6|= . It
follows that there exists X 0  N such that X 6|= X 0  X 0 , i.e., X 0  X and X  X 0 = ,
from which we have X = X 0 thus X  N , a contradiction.
Secondly we show ModHT () = M. On the one hand, let hX, Y i |=HT . We have that X |= 
and Y |=  by Lemma 2. It follows X, Y  N , which implies hX, Xi  M and hY, Y i  M.
Thus hX, Y i  M by (18). On the other hand, let hX, Y i  M. In terms of (18), we have
hX, Xi  M and hY, Y i  M. Thus X  N and Y  N , i.e. X |=  and Y |= . Thus
hX, Y i |=HT  by Lemma 2.

Proposition 6 A collection M of ?-interpretations is Horn ?-expressible, i.e., there is a Horn logic
program  such that Mod? () = M, iff M satisfies, in addition to (10), the following criteria:
hX, Y i  M and hH, T i  M  hX  H, Y  T i  M.

(19)

Proof: It suffices to prove the case ? = HT by Proposition 2.
() Suppose  is a Horn logic program such that ModHT () = M. By Proposition 5,
ModHT () satisfies (18). Suppose hX, Y i and hH, T i are two HT-models of . It follows that
X, Y, H and T are models of  by Lemma 2. Thus X  H |=  and Y  T |= , by which
hX  H, Y  T i |=  due to X  H  Y  T .
57

fiWANG , Z HANG , Z HOU , & Z HANG

() Let N and  be the ones defined in the proof of Proposition 5. If X, Y  N then X  Y 
N according to (19). It follows that there exists a Horn logic program (a set of Horn clauses) whose
0
models are exactly the
Vones inWN . As a matter of fact, the Horn program  can be constructed from
 by replacing each X  Y with
^
^
X  p1 , . . . , X  pk
(20)

T
where X  Y =  and {Y 0 \ X|X  Y 0 and Y 0  N } = {p1 , . . . , pk }.
We firstly show   0 by proving


^
_ 
^
^
X
Y  X
 |=
pi 
1ik

V
W
where pi (1  i  k) are defined in (20). The direction from right to left is trivial as V X  W Y
belongs to V
. Let us consider the other direction. Suppose H |= , H is a model of X  Y
and H 6|= X  pi for some i (1  i  k). We have that X  H and H  Y 6= . It follows
that H is some element of {Y 0 \ X|X  Y 0 and Y 0  N } and then {p1 , . . . , pk }  H. It is a
contradiction.
Finally ModHT (0 ) = M follows from ModHT () = M and Proposition 5.

V
W
Proposition 7 Let  = (B  C)  (A  D), where A, B, C, D are subsets of A. Then we
have (A) |= FLP []  HT [].
Proof: Note that HT [p] = p  p0 and FLP [p] = p0 . We have
HT [] = 0 

^

^

B

(c  c0 ) 

cC

_

A

_

!

(d  d0 ) ,

dD

^

_
FLP [] = 0 
(B  C  B 0  C 0 )  (A  D 0 ) .

Since (A) |= p  p0  p0 , we have that
0

(A) |= HT []   

!
^
_
_
0
0
d ,
(B  C ) 
A
dD

0

(A) |= FLP []   
It completes the proof.

^


_
(B  C )  (A  D 0 ) .
0



Proposition 8 Let  be a formula of LA and X  Y  A. hX, Y i is a ?-model of  iff X  Y 0 is
a model of (A)  {? []}.
Proof: We prove the case ? =

FLP

by induction on the structures of . Let X  Y  A.

  = p or  = . It is trivial for  = . On the other hand, hX, Y i |=FLP p iff X |= p iff
X  Y 0 |= p.
58

fiK NOWLEDGE F ORGETTING

IN

A NSWER S ET P ROGRAMMING

  = 1  2 where   {, }. It follows from the inductive assumption.
  = 1  2 . We have FLP [1  2 ] = (01  02 )  (1  01  FLP [2 ]). Recall that
hX, Y i |=FLP 1  2 iff
 Y |= (1  2 ) and,
 either (a) X 6|= 1 , or (b) Y 6|= 1 , or (c) hX, Y i |=FLP 2 .
Note that
 Y |= (1  2 ) iff Y 0 |= 01  02 iff X  Y 0 |= 01  02 , and
 (a) X 6|= 1 iff X  Y 0 6|= 1 , (b) Y 6|= 1 iff Y 0 6|= 01 iff X  Y 0 6|= 01 , and (c)
hX, Y i |=FLP 2 iff X  Y 0 |= FLP [2 ] by the inductive assumption.
It follows that hX, Y i |=FLP 1  2 iff X  Y 0 |= FLP [1  2 ].


This completes the proof.

Theorem 4 Two formulas  and  have the same ?-models (over LA ) iff (A)  {? []} and
(A)  {? []} have the same models (over LAA0 ).
Proof: We prove the case ? = FLP .
() M |= (A)  {FLP []}
iff MA  MA0 |= (A)  {FLP []}
0

 i |=
iff hMA , MA
0
FLP  by Proposition 8, here MA0 = {p|p  MA0 }

iff hMA , MA0 i |=FLP  since  FLP 
iff MA  MA0 |= (A)  {FLP []} by Proposition 8
iff M |= (A)  {FLP []}.
() hX, Y i |=FLP 
iff X  Y 0 |= (A)  {FLP []} by Proposition 8, here Y 0 = {p0 |p  Y }
iff X  Y 0 |= (A)  {FLP []} since (A)  {FLP []}  (A)  {FLP []}
iff hX, Y i |=FLP  by Proposition 8.



Proposition 9 (i) The problem of deciding if a formula is ?-satisfiable is NP-complete.
(ii) The problem of deciding if two formulas are ?-equivalent is co-NP-complete.
Proof: (i) Membership. If a formula  is FLP-satisfiable then there exists an FLP-interpretation
hH, T i such that hH, T i |=FLP . It is feasible to guess such an FLP-interpretation and check the
condition hH, T i |=FLP . Thus the problem is in NP.
Hardness. It follows from the fact that  is FLP-satisfiable iff  is satisfiable, which is NPhard, by (ii) of Proposition 3. This shows that the problem is NP-hard.
(ii) Membership. If  6FLP  then there exists hH, T i such that, either
(a) hH, T i |=FLP  and hH, T i 6|=FLP , or
(b) hH, T i 6|=FLP  and hH, T i |=FLP .
59

fiWANG , Z HANG , Z HOU , & Z HANG

To guess such an FLP-interpretation hH, T i and to check the conditions (a) and (b) are feasible in
polynomial time in the size of  and . Thus the problem in co-NP.
Hardness. We have that  FLP 
iff  has no FLP-model
iff  has no model by (ii) of Proposition 3
iff  is valid, which is co-NP-hard. Thus the problem is co-NP-hard.


Appendix C. Proofs for Section 4
Lemma 3 Let  be a formula and V  A. A formula  is a result of ?-forgetting V from , iff the
following condition holds:
Mod? () = Mod? ()V .
Proof:  is a result of ?-knowledge forgetting V from 
iff, for every ?-interpretation M , M |=?  iff there exists M 0 |=?  s.t. M V M 0
iff Mod? () = {M is an ?-interpretation | M 0 |=?  and M V M 0 }
iff Mod? () = Mod()V .



Lemma 4 Let X, Y, H, T and V be subsets of A.
(i) If X V H and Y V T then X  Y V H  T and X  Y V H  T .
(ii) If X V H and Y 0 V 0 T 0 then H  T 0 V V 0 X  Y 0 .
Proof: (i) Note that (X  Y ) \ V
=(X \ V )  (Y \ V )
=(H \ V )  (T \ V ) due to X V H and Y V T
=(H  T ) \ V .
Thus X  Y V T  T . We can similarly prove X  Y V H  T .
(ii) Please note that Y 0 = {p0 |p  Y }, V 0 = {p0 |p  V } and T 0 = {p0 |p  V }. We have that
(H  T 0 ) \ (V  V 0 ).
= (H \ (V  V 0 ))  (T 0 \ (V  V 0 ))
= (H \ V )  (T 0 \ V 0 ) since H  V 0 =  and T 0  V = 
= (X \ V )  (Y 0 \ V 0 ) since H V H and T 0 V 0 Y 0
= (X \ (V  V 0 ))  (Y 0 \ (V  V 0 )) since X  V 0 =  and Y 0  V = 
= (X  Y 0 ) \ (V  V 0 ).

It follows that H  T 0 V V 0 X  Y 0 .
Theorem 6 (Expressibility theorem) Let  be a formula and V a set of atoms. There exists a
formula  such that Mod? () = Mod? ()V .
Proof: For every hX, Y i  Mod? ()V , there exists hH, T i |=?  such that hH, T i V hX, Y i,
i.e. X V H and Y V T . By (i) of Proposition 3, hT, T i |=? . Thus hY, Y i  Mod? ()V
due to hY, Y i V hT, T i. It follows that the collection Mod? ()V satisfies the condition (8), then
there is a formula  such that Mod? () = Mod? ()V by Proposition 4.

Lemma 5 A formula  is ?-irrelevant to a set V of atoms iff hH, T i |=?  implies hX, Y i |=? 
for every two ?-interpretations hX, Y i and hH, T i with hX, Y i V hH, T i
60

fiK NOWLEDGE F ORGETTING

IN

A NSWER S ET P ROGRAMMING

Proof:  is ?-irrelevant to V
iff there exists a formula  mentioning no atoms in V such that  ? 
iff there exists a formula  mentioning no atoms in V s.t Mod? () = Mod? ()
iff Mod? () = {hX, Y i|X  Y and hH, T i V hX, Y i s.t hH, T i |=? }
iff hH, T i |=?  implies hX, Y i |=?  for every two ?-interpretations hX, Y i and hH, T i such that
hX, Y i V hH, T i.

Proposition 10 Let  and  be two formulas and V a set of atoms.
(i) IR? (Forget ? (, V ), V ).
(ii)  has a ?-model iff Forget? (, V ) has.
(iii)  |=? Forget? (, V ).
(iv) If  |=?  then Forget? (, V ) |=? Forget? (, V ).
(v) Forget? (  , V ) ? Forget? (, V )  Forget? (, V ).
(vi) Forget? (  , V ) |=? Forget? (, V )  Forget? (, V ).
(vii) Forget? (  , V ) ? Forget? (, V )   if IR? (, V ).
Proof: (i) It immediately follows from Lemma 5.
(ii) It is evident that Mod? () 6=  iff Mod? ()V 6=  by Definition 8.
(iii) It is easy to see that Mod? ()  Mod? ()V by Definition 8.
(iv) Let  |=? , and hH, T i |=? Forget? (, V ), i.e. hH, T i  Mod? ()V . In terms of
Definition 8, there exists hH 0 , T 0 i |=?  such that hH, T i V hH 0 , T 0 i. It implies that hH 0 , T 0 i |=?
 since  |=? . Thus hH, T i  Mod? ()V , i.e. hH, T i |=? Forget? (, V ).
(v) hH, T i |=? Forget? (  , V )
iff hH, T i  Mod? (  )V
iff hH 0 , T 0 i |=?    such that hH, T i V hH 0 , T 0 i
iff hH 0 , T 0 i such that hH, T i V hH 0 , T 0 i and, either hH 0 , T 0 i |=?  or hH 0 , T 0 i |=? 
iff hH, T i  Mod? ()V or hH, T i  Mod? ()V
iff hH, T i |=? Forget? (, V ) or hH, T i |=? Forget? (, V )
iff hH, T i |=? Forget? (, V )  Forget? (, V ).
(vi) hH, T i |=? Forget? (  , V )
 hH, T i  Mod? (  )V
 hH 0 , T 0 i |=?    such that hH, T i V hH 0 , T 0 i
 hH 0 , T 0 i such that. hH, T i V hH 0 , T 0 i, hH 0 , T 0 i |=?  and hH 0 , T 0 i |=? 
 hH, T i  Mod? ()V and hH, T i  Mod? ()V
 hH, T i |=? Forget? (, V ) and hH, T i |=? Forget? (, V )
 hH, T i |=? Forget? (, V )  Forget? (, V ).
(vii) The direction from left to right follows from (vi) and the fact IR(, V ), i.e. Forget? (, V ) ?
. Let us consider the other direction.
hH, T i |=? Forget? (, V )  
 hH, T i |=? Forget? (, V ) and hH, T i |=? 
 hH 0 , T 0 i |=?  such that hH, T i V hH 0 , T 0 i, and hH, T i |=? 
61

fiWANG , Z HANG , Z HOU , & Z HANG

 hH, T i V hH 0 , T 0 i such that hH 0 , T 0 i |=?    by IR(, V ) and Lemma 5
 hH, T i  Mod? (  )V
 hH, T i |=? Forget? (  , V ).



Theorem 8 (Horn expressibility) Let  be a Horn logic program and V  A. There is a Horn
logic program 0 such that Forget? (, V ) ? 0 .
Proof: In terms of Proposition 2, it suffices to prove for ? = HT. Let M = ModHT ()V . By
Proposition 6, it is sufficient to show that M satisfies conditions (5) and (12).
We first prove that M satisfies (5). For each HT-interpretation hX, Y i  M, we have that
X  Y , and there exists hH, T i  ModHT () such that hX, Y i V hH, T i. Note that  is positive,
which shows that hH, Hi and hT, T i are HT-models of  by Lemma 2. Thus hX, Xi  M and
hY, Y i  M due to X V H and T V Y . On the other hand, suppose hX, Xi  M, hY, Y i  M
and X  Y . There exist two HT-models hH 0 , T 0 i and hH 00 , T 00 i of  such that hH 0 , T 0 i V hX, Xi
and hH 00 , T 00 i V hY, Y i. By Lemma 2, we have H 0 |= , T 0 |= , H 00 |=  and T 00 |= . Since
models of Horn theories are closed under set intersection (Alfred, 1951), H 0  H 00 |= . By
Lemma 2 again, we have hH 0  H 00 , T 00 i |=HT . By Lemma 4, H 0  H 00 V X  Y (= X). Thus
hH 0  H 00 , T 00 i V hX, Y i. It follows hX, Y i  M.
Now we show that M satisfies (12). Suppose hX, Y i and hH, T i are two HT-interpretations
in M. It follows that there are two HT-models hX 0 , Y 0 i and hH 0 , T 0 i of  such that hX 0 , Y 0 i V
hX, Y i and hH 0 , T 0 i V hH, T i. Since  is Horn, we have that hH 0  X 0 , T 0  Y 0 i |=HT  by
Proposition 6. By Lemma 4, we have H 0  X 0 V H  X and Y 0  T 0 V Y  T . It implies
hH 0  X 0 , T 0  Y 0 i V hX  H, Y  T i, thus hX  H, Y  T i  M.

Proposition 11 Let  be a disjunctive logic program, V  A. We have that Forget? (, V ) is
expressible in disjunctive logic programs if and only if,
hH1 , T1 i |=? , hT2 , T2 i |=?  and T1  T2  hH3 , T3 i |=?  such that hH3 , T3 i V hH1 , T2 i.
Proof: By Proposition 2, it suffices to prove ? = HT. Let 0 HT Forget HT (, V ). The direction
from left to right is obvious. We show the other direction.
Suppose that 0 is not expressible in disjunctive logic programs. There exists hX, Y i |=HT 0 ,
Y  Y 0 and hY 0 , Y 0 i |=HT 0 such that hX, Y 0 i 6|=HT 0 . It follows that, for each hH1 , T1 i |=HT 
and hT2 , T2 i |=HT  such that hH1 , T1 i V hX, Y i, T2 V Y 0 and T1  T2 , there exists no
hH3 , T3 i |=HT  such that hH3 , T3 i V hH1 , T2 i, viz. hH3 , T3 i V hX, Y 0 i by hX, Y 0 i V
hH1 , T2 i, a contradiction.

Proposition 12 Let  be a normal logic program, V  A. Then Forget? (, V ) is expressible in
normal logic programs if and only if, in addition to condition (21), the following condition holds,
hH1 , T1 i |=? , hH2 , T2 i |=?  and T1 V T2
 hH3 , T3 i |=?  such that H3 V H1  H2 and (T3 V T1 or T3 V T2 ).

(21)

Proof: By Proposition 2, it suffices to prove ? = HT. Let 0 HT Forget HT (, V ). The direction
from left to right is easy. We consider the other direction in what follows.
In terms of Proposition 11 and Corollary 3, it is sufficient to show that, for each hX, Y i |=HT 0
and hX 0 , Y i |=HT 0 , hX  X 0 , Y i |=HT 0 according to Corollary 3. Suppose that hX, Y i and
62

fiK NOWLEDGE F ORGETTING

IN

A NSWER S ET P ROGRAMMING

hX 0 , Y i are two HT-models of 0 . There are two HT-models hH1 , T1 i and hH2 , T2 i of  such
that hX, Y i V hH1 , T1 i and hX 0 , Y i V hH2 , T2 i. It follows that T1 V T2 and, by condition (21), there exists an HT-model hH3 , T3 i of  satisfying either hH3 , T3 i V hH1  H2 , T1 i or
hH3 , T3 i V hH1  H2 , T2 i, which shows hH3 , T3 i V hX  X 0 , Y i, hence hX  X 0 , Y i |=HT
0 .

Theorem 10 (Representation theorem) Let  and  be two formulas and V a set of atoms. Then
the following statements are equivalent:
(i)  ? Forget? (, V ).
(ii)  ? {0 |  |=? 0 and IR? (0 , V )}.
(iii) Postulates (W), (PP), (NP) and (IR) hold.
Proof: Let ? = { |  |=?  and IR? (, V )}. It is evident that IR? (? , V ).
The equivalence between (i) and (ii) follows from Corollary 9. (ii) obviously implies (iii). It
suffices to show (iii)  (ii).
By Positive Persistence, we have  |=?  for each   ? , from which follows Mod? () 
Mod? (? ). On the other hand, by ( W)  |=?  and (IR) IR? (, V ), it follows   ? . Thus
Mod? (? )  Mod? (). Thus  ? ? .

Proposition 13 Let , 0 ,  be formulas and V  A such that  ? Forget? (, V ) and 0 
Forget(, V ). Then
(i)   0 .
(ii) 0 |=? .
Proof: (i) T |= 
iff hT, T i |=?  by (i) of Proposition 3
iff hT, T i |=? Forget? (, V ) since  ? Forget? (, V )
iff hY, Y i |=?  such that hT, T i V hY, Y i by Definition 8
iff Y |=  such that T V Y by (i) of Proposition 3
iff T |= Forget(, V ) by Corollary 5
iff T |= 0 since 0  Forget(, V ).
(ii) hH, T i |=? 0
 T |= 0 by (i) of Proposition 3
 T |= Forget(, V ) since 0  Forget(, V )
 Y |=  such that Y V T by Corollary 5
 hH \ V, Y i |=?  such that Y V T by (ii) of Proposition 3
 hH, T i |=? Forget? (, V ) due to hH \ V, Y i V hH, T i and Definition 8
 hH, T i |=?  due to Forget? (, V ) ? .



Proposition 14 Let  and 0 be two Horn logic programs, and V a set of atoms such that 0 
Forget(, V ). Then 0 ? Forget? (, V ).
63

fiWANG , Z HANG , Z HOU , & Z HANG

Proof: By Proposition 2, it suffices to show ? = HT.
() hH 0 , T 0 i |=HT 0
 H 0 |= 0 and T 0 |= 0 by Lemma 2
 H, T such that H |= , T |= , H V H 0 and T V T 0 by 0  Forget(, V )
 H, T such that H  T |= , T |= , H  T V H 0 and T V T 0
 H, T such that hH  T, T i |=HT  and hH  T, T i V hH 0 , T 0 i
 hH 0 , T 0 i |=HT Forget HT (, V ).
() hH 0 , T 0 i |=HT Forget HT (, V )
 hH, T i |=HT  such that hH 0 , T 0 i V hH, T i
 H  T such that H |= , T |=  and hH 0 , T 0 i V hH, T i by Lemma 2
 H 0 |= Forget(, V ) and T 0 |= Forget(, V )
 H 0 |= 0 and T 0 |= 0 due to 0  Forget(, V )
 hH 0 , T 0 i |=HT 0 .
Proposition 15 Let  and  be two formulas and V a set of atoms.
(i)   Forget(, V ) iff  ? Forget? (, V ).
(ii) Forget(, V )  Forget(, V ) iff Forget? (, V ) ? Forget? (, V ).
Proof: (i) () hH, T i |=? 
iff T |= , i.e. T |=  by (ii) of Proposition 3
iff T |= Forget(, V ) since   Forget(, V )
iff Y |=  i.e. Y |=  such that Y V T by Corollary 5
iff hH \ V, Y i |=?  (H \ V  T \ V = Y \ V ) by (ii) of Proposition 3
iff hH, T i |=? Forget? (, V ) by Definition 8.
() T |=  i.e. T |= 
iff hH, T i |=?  by (ii) of Proposition 3
iff hH, T i |=? Forget? (, V ) for H  T since  ? Forget? (, V )
iff hX, Y i |=?  such that hH, T i V hX, Y i by Definition 8
iff Y |=  such that Y V T by (ii) or Proposition 3
iff T |= Forget(, V ) by Corollary 5.
(ii) () hH, T i |=? Forget? (, V )
iff hX, Y i |=?  such that hX, Y i V hH, T i by Definition 8
iff Y |=  i.e. Y |=  such that Y V T by (ii) of Proposition 3
iff T |= Forget(, V ) by Corollary 5
iff T |= Forget(, V ) since Forget(, V )  Forget(, V )
iff Y 0 |=  i.e. Y 0 |=  such that Y 0 V T by Definition 8
iff hX \ V, Y 0 i |=?  by (ii) of Proposition 3 (X \ V  Y \ V = Y 0 \ V )
iff hH, T i |=? Forget? (, V ) by hH, T i V hX \ V, Y 0 i and Definition 8.
() T |= Forget(, V )
iff Y |=  i.e. Y |=  such that Y V T by Corollary 5
iff hX, Y i |=?  such that Y V T by (ii) of Proposition 3
iff hX \ V, T i |=? Forget? (, V ) hX \ V, T i V hX, Y i and by Definition 8
iff hX \ V, T i |=? Forget? (, V ) since Forget? (, V ) ? Forget? (, V )
iff hX 0 , Y 0 i |=?  such that hX \ V, T i V hX 0 , Y 0 i by Definition 8
64



fiK NOWLEDGE F ORGETTING

IN

A NSWER S ET P ROGRAMMING

iff Y 0 |=  i.e. Y 0 |=  such that T V Y 0 by (ii) of Proposition 3
iff T |= Forget(, V ) by Corollary 5.



Theorem 12 (?-forgetting vs propositional forgetting) Let  and  be two formulas of LA and
V  A. Then
 ? Forget? (, V ) iff (A) |= ? []  Forget((A)  {? []}, V  V 0 ).
 be a model of (A).
Proof: () Let M = MA  MA
0
M |= (A)  {? []}
 i |=  by Proposition 8
iff hMA , MA
0
?
 i |= Forget (, V ) since   Forget (, V )
iff hMA , MA
0
?
?
?
?
 i by Definition 8
iff hH, T i |=?  such that hH, T i V hMA , MA
0

iff hH, T i |=?  such that H V MA and T V MA
0
0
iff H  T |= (A)  {? []} and H V MA and T 0 V 0 MA0 by Proposition 8
iff H  T 0 |= (A)  {? []} and H  T 0 V V 0 MA  MA0 by Lemma 4
iff MA  MA0 |= Forget((A)  {? []}, V  V 0 ) by Definition 8
iff M |= Forget((A)  {? []}, V  V 0 ).
() hX, Y i |=? 
iff X  Y 0 |= (A)  {? []} by Proposition 8
iff X  Y 0 |= (A)  Forget((A)  {? []}, V  V 0 )
iff M |= (A)  {? []} such that M V V 0 X  Y 0
 i |=  such that M  M   X  Y by Proposition 8
iff hMA , MA
0
V
?
A
A0
 i by Definition 8.
iff hX, Y i |=? Forget? (, V ) due to hX, Y i V hMA , MA
0



Proposition 16 Let  and  be two formulas of LA and V a set of atoms. Then Forget? (, V ) ?
Forget? (, V ) iff the following condition holds:
Forget({? []}  (A), V  V 0 )  Forget({? []}  (A), V  V 0 ).
Proof: () We show Forget({? []  (A), V  V 0 ) |= Forget({? []  (A), V  V 0 ). The
other side can be similarly proved.
M |= Forget({? []}  (A), V  V 0 )
 N  A  A0 such that N V V 0 M and N |= {? []}  (A)
 hX, Y i |=?  with N = X  Y 0 by Proposition 8
 hX, Y i |=? Forget? (, V ) by (iii) of Proposition 10
 hX, Y i |=? Forget? (, V ) as Forget? (, V ) ? Forget? (, V )
 hH, T i |=?  such that hH, T i V hX, Y i by Definition 8
 H  T 0 |= ? []  (A) by Proposition 8
 X  Y 0 |= Forget({? []}  (A), V  V 0 ) as H  T 0 V V 0 X  Y 0
 M |= Forget({? []}  (A), V  V 0 ) by M V V 0 X  Y 0 (= N ).
() We show Forget? (, V ) |=? Forget? (, V ). The other side is similar.
hH, T i |=? Forget? (, V )
 hX, Y i |=?  such that hH, T i V hX, Y i) by Definition 8
 X  Y 0 |= {? []}  (A) by Proposition 8
 X  Y 0 |= Forget({? []}  (A), V  V 0 )
65

fiWANG , Z HANG , Z HOU , & Z HANG

 X  Y 0 |= Forget({? []}  (A), V  V 0 )
 H1  T10 |= {? []}  (A) such that H1  T10 V V 0 X  Y 0
 hH1 , T1 i |=?  by Proposition 8
 hX, Y i |=? Forget? (, V ) as hX, Y i V hH1 , T1 i by Definition 8
 hH, T i |=? Forget? (, V ) as hX, Y i V hH, T i.



Theorem 14 Let  and  be two formulas and V a set of atoms.
(i) The problem of deciding if  ? Forget? (, V ) is co-NP-complete.
(ii) The problem of deciding if Forget? (, V ) ? Forget? (, V ) is P2 -complete.
(iii) The problem of deciding if  ? Forget? (, V ) is P2 -complete.
Proof: (i) Membership. Recall that  |=? Forget? (, V ) by (iii) of Proposition 10. We have
 6? Forget? (, V )
iff Forget? (, V ) 6|=? 
iff hX, Y i |=? Forget? (, V ) and hX, Y i 6|=? 
iff hH, T i |=?  such that hH, T i V hX, Y i and hX, Y i 6|=? .
Since both guessing hH, T i, hX, Y i and checking the ?-satisfiability can be done in polynomial
time in the size of  and V . Thus the complement of  6? Forget? (, V ), i.e.  ? Forget? (, V ),
is in co-NP.
The hardness follows from the fact that, by (i) of Proposition 15,  ? Forget? (, V ) iff
  Forget(, V ), which is co-NP-complete (cf., see Lang et al., 2003, Prop. 10).
(ii) Membership. If Forget? (, V ) 6? Forget? (, V ) then there exists a ?-interpretation hH, T i
such that either
(a) hH, T i |=? Forget? (, V ) and hH, T i 6|=? Forget? (, V ), or
(b) hH, T i 6|=? Forget? (, V ) and hH, T i |=? Forget? (, V ).
On the one hand, to guess a ?-interpretation hH, T i is feasible by a nondeterministic Turing machine. On the other hand, checking if hH, T i |=?  is feasible by a deterministic Turing machine;
and hH, T i |=? Forget? (, V ) iff there exists hX, Y i |=?  such that hX, Y i V hH, T i. Thus
checking the conditions (a) and (b) can be done in polynomial time in the size of  and  by calling
a nondeterministic Turing machine. Thus the problem is in P2 .
Note that, by (ii) of Proposition 15, Forget? (, V ) ? Forget? (, V ) iff Forget(, V ) 
Forget(, V ), which is P2 -complete (cf., see Lang et al., 2003, Prop. 24). Thus the hardness
follows.
(iii) Membership. Note that  6? Forget? (, V ) iff there is a ?-interpretation hH, T i such that
 hH, T i |=?  and hH, T i 6|=? Forget? (, V ), or
 hH, T i 6|=?  and hH, T i |=? Forget? (, V ).
Similar to the case of (ii), the guessing and checking are in polynomial time in the size of ,  and
V by calling a nondeterministic Turing machine. Thus the problem is in P2 .
Note that  ? Forget? (, V ) iff  ? Forget? (, V ) and Forget? (, V ) ? Forget? (, V ),
the latter is P2 -hard by (ii). Then the hardness follows.

66

fiK NOWLEDGE F ORGETTING

IN

A NSWER S ET P ROGRAMMING

Proposition 17 Let  and  be two formulas and V a set of atoms.
(i) The problem of deciding whether  |=? Forget? (, V ) is P2 -complete.
(ii) The problem of deciding whether Forget? (, V ) |=?  is co-NP-complete.
Proof: (i) Membership. Recall that  6|=? Forget? (, V ) iff there exists a ?-model hH, T i of 
such that hH, T i 6|= Forget? (, V ). As hH, T i 6|= Forget? (, V ) iff hX, Y i 6|=  for every ?interpretation hX, Y i such that hX, Y i V hH, T i. Such hH, T i can be guessed in polynomial
time in the size of ,  and V . Checking hH, T i 6|= Forget? (, V ) is possible in polynomial time
in the size of ,  and V by calling a nondeterministic Turing machine. Thus the original problem
is in p2 .
Hardness. It follows from the following fact:
> |=? Forget? (, V )
iff > ? Forget? (, V )
iff >  Forget(, V ) by (i) of Proposition 15 (> ? >)
iff the QBF V V  is valid, which is P2 -complete (Papadimitriou, 1994).
(ii) Membership. Note that
Forget? (, V ) 6|=? 
iff hH, T i |=? Forget? (, V ) such that hH, T i 6|= 
iff hX, Y i |=?  such that hX, Y i V hH, T i and hH, T i 6|= .
Since the guessing and checking are both polynomial in the size of ,  and V , the original problem
is in co-NP.
Hardness follows from the fact that
Forget? (, V ) |=? 
iff  |=?  by (ii) of Proposition 10
iff  has no ?-model, which is co-NP-complete by Proposition 9.


Appendix D. Forgetting Operators FW and FS
Wong proposed six postulates and argued that the postulates should to respected by all forgetting
operators in disjunctive logic programs under strong equivalence:
(F-1) If  |=HT  then F (, a) |=HT F (, a);
(F-2) If a does not appear in , then F ({r}  , a) HT F ({r}, a)  ;
(F-3) F (, a) does not contain any atoms not in ;
(F-4) If F (, a) |=HT r then F ({s}, a) |=HT r for some s  Cn();
(F-5) If F (, a) |=HT (A  B, not C), then  |=HT (A  B, not C, not a);
(F-6) F (F (, a), b) HT F (F (, b), a)
where F is a forgetting operator, ,  and  are disjunctive logic programs, a and b are atoms, r is
a disjunctive rule, and
Cn() ={r| r is a disjunctive rule such that  |=HT r and var(r)  var()}.
67

fiWANG , Z HANG , Z HOU , & Z HANG

where var() is the set of atoms occurring in .
Accordingly, he proposed two forgetting operators FS and FW : the result of forgetting an atom
a from a disjunctive logic program  is defined by the below procedure:
(1) Let 1 = Cn().
(2) Form 1 , remove rules of the form (A  B, a, not C), replace each rule of the form (A 
{a}  B, not C, not a) with (A  B, not C, not a). Let the resulting logic program be 2 .
(3) Replace or remove each rule in 2 , of the form (A  B, not C, not a) or (A  {a} 
B, not C) according to the following table:
S
W

A  B, not C, not a
(remove)
A  B, not C

A  {a}  B, not C
(remove)
A  B, not C

Let 3 be the resulting logic program.
The logic program 3 is the result of forgetting p from .

References
Alfred, H. (1951). On sentences which are true of direct unions of algebras. The Journal of Symbolic
Logic, 16(1), 1421.
Bobrow, D. G., Subramanian, D., Greiner, R., & Pearl, J. (Eds.). (1997). Special issue on relevance
97 (1-2). Artificial Intelligence Journal.
Cabalar, P., & Ferraris, P. (2007). Propositional theories are strongly equivalent to logic programs.
Theory and Practice of Logic Programming, 7(6), 745759.
Delgrande, J. P., Schaub, T., Tompits, H., & Woltran, S. (2013). A model-theoretic approach to
belief change in answer set programming. ACM Transactions on Computational Logic, 14(2),
A:1A:42.
Eiter, T., Fink, M., Tompits, H., & Woltran, S. (2004). On eliminating disjunctions in stable logic
programming. In Principles of Knowledge Representation and Reasoning: Proceedings of
the Ninth International Conference (KR2004), pp. 447458, Whistler, Canada. AAAI Press.
Eiter, T., & Wang, K. (2008). Semantic forgetting in answer set programming. Artificial Intelligence,
172(14), 16441672.
Faber, W., Pfeifer, G., & Leone, N. (2011). Semantics and complexity of recursive aggregates in
answer set programming. Artificial Intelligence, 175(1), 278298.
Ferraris, P. (2005). Answer sets for propositional theories. In Logic Programming and Nonmonotonic Reasoning, 8th International Conference, Vol. 3662 of Lecture Notes in Computer Science, pp. 119131, Diamante, Italy. Springer.
Ferraris, P., Lee, J., & Lifschitz, V. (2011). Stable models and circumscription. Artificial Intelligence, 175(1), 236263.
Ferraris, P., & Lifschitz, V. (2005). Mathematical foundations of answer set programming. In
Artemov, S. N., Barringer, H., dAvila Garcez, A. S., Lamb, L. C., & Woods, J. (Eds.), We Will
Show Them! Essays in Honour of Dov Gabbay, Vol. 1, pp. 615664. College Publications.
68

fiK NOWLEDGE F ORGETTING

IN

A NSWER S ET P ROGRAMMING

Gabbay, D. M., Pearce, D., & Valverde, A. (2011). Interpolable formulas in equilibrium logic and
answer set programming. Journal of Artificial Intelligence Research, 42, 917943.
Gelfond, M., & Lifschitz, V. (1988). The stable model semantics for logic programming. In Proceedings of the Fifth International Conference and Symposium on Logic Programming, pp.
10701080, Seattle, Washington. MIT Press.
Goranko, V., & Otto, M. (2007). Handbook of Modal Logic, Vol. 3, chap. 5 Model Theory Of Modal
Logic, pp. 249329. Elsevier.
Jongh, D. D., & Hendriks, L. (2003). Characterization of strongly equivalent logic programs in
intermediate logics. Theory and Practice of Logic Programming, 3(3), 259270.
Kontchakov, R., Wolter, F., & Zakharyaschev, M. (2008). Can you tell the difference between dl-lite
ontologies?. In Principles of Knowledge Representation and Reasoning: Proceedings of the
Eleventh International Conference, KR 2008, pp. 285295, Sydney, Australia. AAAI Press.
Lang, J., Liberatore, P., & Marquis, P. (2003). Propositional independence: Formula-variable independence and forgetting. Journal of Artificial Intelligence Research, 18, 391443.
Lang, J., & Marquis, P. (2010). Reasoning under inconsistency: A forgetting-based approach. Artificial Intelligence, 174(12-13), 799823.
Lifschitz, V., Pearce, D., & Valverde, A. (2001). Strongly equivalent logic programs. ACM Transactions on Computational Logic, 2(4), 526541.
Lifschitz, V., Tang, L. R., & Turner, H. (1999). Nested expressions in logic programs. Annals of
Mathematics and Artificial Intelligence, 25(3-4), 369389.
Lin, F. (2001). On strongest necessary and weakest sufficient conditions. Artificial Intelligence,
128(1-2), 143159.
Lin, F. (2002). Reducing strong equivalence of logic programs to entailment in classical propositional logic. In Proceedings of the Eights International Conference on Principles and Knowledge Representation and Reasoning (KR-02), pp. 170176, Toulouse, France. Morgan Kaufmann.
Lin, F., & Chen, Y. (2007). Discovering classes of strongly equivalent logic programs. Journal of
Artificial Intelligence Research, 28, 431451.
Lin, F., & Reiter, R. (1994). Forget it!. In In Proceedings of the AAAI Fall Symposium on Relevance,
pp. 154159.
Lin, F., & Zhou, Y. (2011). From answer set logic programming to circumscription via logic of GK.
Artificial Intelligence, 175(1), 264277.
Liu, Y., & Wen, X. (2011). On the progression of knowledge in the situation calculus. In IJCAI
2011, Proceedings of the 22nd International Joint Conference on Artificial Intelligence, pp.
976982, Barcelona, Catalonia, Spain. IJCAI/AAAI.
Lutz, C., & Wolter, F. (2011). Foundations for uniform interpolation and forgetting in expressive
description logics. In IJCAI 2011, Proceedings of the 22nd International Joint Conference on
Artificial Intelligence, pp. 989995, Barcelona, Catalonia, Spain. IJCAI/AAAI.
Osorio, M., & Cuevas, V. (2007). Updates in answer set programming: An approach based on basic
structural properties. TPLP, 7(4), 451479.
69

fiWANG , Z HANG , Z HOU , & Z HANG

Osorio, M., & Zacarias, F. (2004). On updates of logic programs: A properties-based approach. In
Seipel, D., & Torres, J. M. T. (Eds.), FoIKS, Vol. 2942 of Lecture Notes in Computer Science,
pp. 231241. Springer.
Packer, H. S., Gibbins, N., & Jennings, N. R. (2011). An on-line algorithm for semantic forgetting. In IJCAI 2011, Proceedings of the 22nd International Joint Conference on Artificial
Intelligence, pp. 27042709, Barcelona, Catalonia, Spain. IJCAI/AAAI.
Papadimitriou, C. H. (1994). Computational complexity. Addison Wesley.
Pearce, D., Tompits, H., & Woltran, S. (2001). Encodings for equilibrium logic and logic programs
with nested expressions. In Proceedings of the10th Portuguese Conference on Artificial Intelligence on Progress in Artificial Intelligence, Knowledge Extraction, Multi-agent Systems,
Logic Programming and Constraint Solving, pp. 306320, London, UK. Springer-Verlag.
Pearce, D., Tompits, H., & Woltran, S. (2009). Characterising equilibrium logic and nested logic
programs: Reductions and complexity. Theory and Practice of Logic Programming, 9(5),
565616.
Su, K., Sattar, A., Lv, G., & Zhang, Y. (2009). Variable forgetting in reasoning about knowledge.
Journal of Artificial Intelligence Research, 35, 677716.
Truszczynski, M. (2010). Reducts of propositional theories, satisfiability relations, and generalizations of semantics of logic programs. Artificial Intelligence, 174(16-17), 12851306.
van Ditmarsch, H. P., Herzig, A., Lang, J., & Marquis, P. (2009). Introspective forgetting. Synthese,
169(2), 405423.
Visser, A. (1996). Uniform interpolation and layered bisimulation. In Godel96, pp. 139164.
Wang, Y., Wang, K., & Zhang, M. (2013). Forgetting for answer set programs revisited. In IJCAI
2013, Proceedings of the 23rd International Joint Conference on Artificial Intelligence, pp.
11621168, Beijing, China. IJCAI/AAAI.
Wang, Y., Zhang, Y., Zhou, Y., & Zhang, M. (2012). Forgetting in logic programs under strong
equivalence. In Principles of Knowledge Representation and Reasoning: Proceedings of the
Thirteenth International Conference, pp. 643647, Rome, Italy. AAAI Press.
Wang, Z., Wang, K., Topor, R. W., & Pan, J. Z. (2010). Forgetting for knowledge bases in dl-lite.
Annuals of Mathematics and Artificial Intelligence, 58(1-2), 117151.
Wong, K.-S. (2009). Forgetting in Logic Programs. Ph.D. thesis, The University of New South
Wales.
Zhang, Y., & Foo, N. Y. (2006). Solving logic program conflict through strong and weak forgettings.
Artificial Intelligence, 170(8-9), 739778.
Zhang, Y., & Zhou, Y. (2009). Knowledge forgetting: Properties and applications. Artificial Intelligence, 173(16-17), 15251537.
Zhou, Y., & Zhang, Y. (2011). Bounded forgetting. In Proceedings of the Twenty-Fifth AAAI
Conference on Artificial Intelligence, AAAI 2011, pp. 280285, San Francisco, California,
USA. AAAI Press.

70

fi