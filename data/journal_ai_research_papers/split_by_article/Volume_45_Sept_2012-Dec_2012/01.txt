Journal of Artificial Intelligence Research 45 (2012) 4778

Submitted 03/12; published 09/12

The Tractability of CSP Classes Defined by Forbidden Patterns
David A. Cohen

dave@cs.rhul.ac.uk

Department of Computer Science
Royal Holloway, University of London
Egham, Surrey, UK

Martin C. Cooper

cooper@irit.fr

IRIT
University of Toulouse III, 31062 Toulouse, France

Paid Creed

p.creed@qmul.ac.uk

School of Mathematical Sciences
Queen Mary, University of London
Mile End, London, UK

Daniel Marx

dmarx@cs.bme.hu

Computer and Automation Research Institute
Hungarian Academy of Sciences (MTA SZTAKI)
Budapest, Hungary

Andras Z. Salamon

andras.salamon@ed.ac.uk

Laboratory for Foundations of Computer Science
School of Informatics, University of Edinburgh, UK

Abstract
The constraint satisfaction problem (CSP) is a general problem central to computer
science and artificial intelligence. Although the CSP is NP-hard in general, considerable
effort has been spent on identifying tractable subclasses. The main two approaches consider
structural properties (restrictions on the hypergraph of constraint scopes) and relational
properties (restrictions on the language of constraint relations). Recently, some authors
have considered hybrid properties that restrict the constraint hypergraph and the relations
simultaneously.
Our key contribution is the novel concept of a CSP pattern and classes of problems
defined by forbidden patterns (which can be viewed as forbidding generic sub-problems). We
describe the theoretical framework which can be used to reason about classes of problems
defined by forbidden patterns. We show that this framework generalises certain known
hybrid tractable classes.
Although we are not close to obtaining a complete characterisation concerning the
tractability of general forbidden patterns, we prove a dichotomy in a special case: classes
of problems that arise when we can only forbid binary negative patterns (generic subproblems in which only disallowed tuples are specified). In this case we show that all (finite
sets of) forbidden patterns define either polynomial-time solvable or NP-complete classes
of instances.
c
2012
AI Access Foundation. All rights reserved.

fiCohen, Cooper, Creed, Marx & Salamon

1. Introduction
In the constraint satisfaction paradigm we consider computational problems in which we
have to assign values (from a domain) to variables, under some constraints. Each constraint
limits the (simultaneous) values that a list of variables (its scope) can be assigned. In a
typical situation some pair of variables might represent the starting times of two jobs in a
machine shop scheduling problem. A reasonable constraint would require a minimum time
gap between the values assigned to these two variables.
Constraint satisfaction has proved to be a useful modelling tool in a variety of contexts,
such as scheduling, timetabling, planning, bio-informatics and computer vision. This has
led to the development of a number of successful constraint solvers. Unfortunately, solving
general constraint satisfaction problem (CSP) instances is NP-hard and so there has been
significant research effort into finding tractable fragments of the CSP.
In principle we can stratify the CSP in two quite distinct and natural ways. The structure of the constraint scopes of an instance of the CSP can be thought of as a hypergraph
where the variables are the vertices, or more generally as a relational structure. We can find
tractable classes by restricting this relational structure, while allowing arbitrary constraints
on the resulting scopes (Dechter & Pearl, 1987). Sub-problems of the general constraint
problem obtained by such restrictions are called structural. Alternatively, the set of allowed assignments to the variables in the scope can be seen as a relation. We can choose
to allow only specified kinds of constraint relations, but allow these to interact in an arbitrary structure (Jeavons, Cohen, & Gyssens, 1997). Such restrictions are called relational
or language-based.
Structural subclasses are defined by specifying a set of hypergraphs (or relational structures) which are the allowed structures for CSP instances. It has been shown that tractable
structural classes are characterised by limiting appropriate (structural) width measures
(Dechter & Pearl, 1989; Freuder, 1990; Gyssens, Jeavons, & Cohen, 1994; Gottlob, Leone,
& Scarcello, 2002; Marx, 2010a, 2010b). For example, a tractable structural class of binary
CSPs is obtained whenever we restrict the constraint structure (which is a graph in this
case) to have bounded tree width (Dechter & Pearl, 1989; Freuder, 1990). In fact, it has
been shown that, subject to certain complexity-theoretic assumptions, the only structures
which give rise to tractable CSPs are those with bounded (hyper-)tree width (Dalmau,
Kolaitis, & Vardi, 2002; Grohe, 2006, 2007; Marx, 2010a, 2010b).
Relational subclasses are defined by specifying a set of constraint relations. The complexity of the subclass arising from any such restriction is precisely determined by the so
called polymorphisms of the set of relations (Bulatov, Jeavons, & Krokhin, 2005; Cohen
& Jeavons, 2006). The polymorphisms specify that, whenever some set of tuples is in a
constraint relation, then it cannot be the case that a particular tuple (the result of applying
the polymorphism) is not in the constraint relation. It is thus the relationship between allowed tuples and disallowed tuples inside the constraint relations that is of key importance
to the relational tractability of any given class of instances. Whilst a general dichotomy has
not yet been proven for the relational case, many dichotomies on sub-problems have been
obtained, for instance those by Bulatov (2003), Bulatov et al. (2005) or Bulatov (2006).
48

fiTractability of CSP Classes Defined by Forbidden Patterns

Using only structural or only relational restrictions limits the possible subclasses that
can be defined. By allowing restrictions on both the structure and the relations we are able
to identify new tractable classes. We call these restrictions hybrid reasons for tractability.
Several hybrid results have been published for binary CSPs (Jegou, 1993; Weigel & Bliek,
1998; Cohen, 2003; Salamon & Jeavons, 2008; Cooper, Jeavons, & Salamon, 2010; Cooper &
Zivny, 2011b). Instead of looking at the set of constraint scopes or the constraint language,
these results captured tractability based on the properties of the (coloured) microstructure
of CSP instances. The microstructure of a binary CSP instance is the graph hV, Ei where V
is the set of possible assignments of values to variables and E is the set of pairs of mutually
consistent variable-value assignments (Jegou, 1993). In the coloured microstructure, the
vertices representing an assignment to variable vi are labelled by a colour representing
variable vi . This maintains the distinction between assignments to different variables.
The coloured microstructure of a CSP instance captures both the structure and the
relations of a CSP instance and so it is a natural place to look for tractable classes which are
neither purely structural nor purely relational. Of the results on (coloured) microstructure
properties, three are of particular note. First it was observed that the class of instances
with a perfect microstructure is tractable (Salamon & Jeavons, 2008). This is a proper
generalisation of the well known hybrid tractable CSP class whose instances allow arbitrary
unary constraints and in which every pair of variables is constrained to be not equal (Regin,
1994; van Hoeve, 2001), and of the hybrid class whose microstructure is triangulated (Jegou,
1993; Weigel & Bliek, 1998; Cohen, 2003). The perfect microstructure property excludes
an infinite set of induced subgraphs from the microstructure.
Secondly, the Joint Winner Property (JWP) (Cooper & Zivny, 2011b) applied to CSPs
provides a different hybrid class that also strictly generalises the class of CSP instances
with a disequality constraint (6=) between every pair of variables and an arbitrary set of
unary constraints, but does so by forbidding a single pattern (a subgraph) in the coloured
microstructure. The JWP has been generalized to hierarchies of soft non-binary constraints (Cooper & Zivny, 2011a), including, for example, soft hierarchical global cardinality
constraints, by reduction to a minimum convex cost flow problem.
Thirdly, the so called broken-triangle property properly extends the structural notion
of acyclicity to a more interesting hybrid class (Cooper et al., 2010). The broken triangle
property is specified by excluding a particular pattern in the coloured microstructure. It is
the notion of forbidden pattern that we study in this paper. We therefore work directly with
the CSP instance (or equivalently its coloured microstructure) rather than its microstructure
abstraction which is a simple graph. This allows us to introduce a language for expressing
hybrid classes in terms of forbidden patterns, providing a framework in which to search
for novel hybrid tractable classes. In the case of binary negative patterns we are able
to characterise all tractable (finite sets of) forbidden patterns. We also state a necessary
condition for the tractability of a (finite set of) general patterns.
1.1 Contributions
In this paper we generalise the definition of a CSP instance to that of a CSP pattern
which has three types of tuple in its constraint relations, tuples which are explicitly al49

fiCohen, Cooper, Creed, Marx & Salamon

lowed/disallowed and tuples which are labelled as unknown1 . By defining a natural notion
of containment of patterns in a CSP, we are able to describe problems defined by forbidden
patterns: a class of CSP instances defined by forbidding a particular pattern  are exactly
those instances that do not contain . We use this framework to capture tractability by
identifying local patterns of allowed and disallowed tuples (within small groups of connected
constraints) whose absence is enough to guarantee tractability.
Using the concept of forbidden patterns, we lay foundations for a theory that can be
used to reason about classes of CSPs defined by hybrid properties. Since this is the first
work of this kind, we primarily focus on the simplest case: binary patterns in which tuples
are either disallowed or unknown (called negative patterns). We give a large class of binary
negative patterns which give rise to intractable classes of problems and, using this, show
that any negative pattern that defines a tractable class of problems must have a certain
structure. We are able to prove that this structure is also enough to guarantee tractability
thus providing a dichotomy for tractability defined by forbidding binary negative patterns.
Importantly, our intractability results also allow us to give a necessary condition on the
form of general tractable patterns.
The remainder of the paper is structured as follows. In Section 2 we define constraint
satisfaction problems, and give other definitions used in the paper. Then, in Section 3, we
define the notion of a CSP pattern and describe classes of problems defined by forbidden
patterns. We give some examples of tractable classes defined by forbidden patterns on three
variables. In Section 4 we show that one must take the size of patterns into account to have
a notion of maximal classes defined by forbidding patterns. In general, we are not yet able
to make any conjecture concerning a dichotomy for hybrid tractability defined by general
forbidden patterns. However, in Section 5 we are able to give a necessary condition for such
a class to be tractable and in Section 6 prove the dichotomy for negative patterns. Finally,
in Section 7 we summarise our results and discuss directions for future research.

2. Preliminaries
Definition 2.1. A CSP instance is a triple hV, D, Ci where:
 V is a finite set of variables (with n = |V |).
 D is a finite set called the domain (with d = |D|).
 C is a set of constraints. Each constraint c  C is a pair c = h, i where:
  is a list of distinct variables called the scope of c.
  is a relation over D of arity || called the relation of c. It is the set of tuples
allowed by c.
A solution to the CSP instance P = hV, D, Ci is a mapping s : V  D where, for each
h, i  C we have s()   (where s() represents the tuple resulting from the application
of s component-wise to the list of variables ).
1. This can be viewed as the natural generalisation of the CSP to a three-valued logic.

50

fiTractability of CSP Classes Defined by Forbidden Patterns

For simplicity of presentation, we assume that all variables have the same domains.
Unary constraints can be used to impose different domains for different variables.
The arity of a CSP is the largest arity of any of its constraint scopes. Our long-term
aim is to identify all tractable subclasses of the CSP problem which can be detected in
polynomial time. In this paper we describe a general theory of forbidden patterns for
arbitrary arity but only consider the implications of the new theory for tractable classes of
arity two (binary) problems specified by finite sets of forbidden patterns. In such cases we
are certain that class membership can be decided in polynomial time.
The CSP decision problem, which asks whether a particular CSP instance has a solution,
is already NP-complete for binary CSPs. For example, there is a straightforward reduction
from graph colouring to this problem in which the set of colours is used as the domain of
the CSP instance, vertices i of the graph map to CSP variables vi , and edges {i, j} map to
disequality constraints vi 6= vj .
It will sometimes be convenient in this paper to use an equivalent functional formulation
of a constraint. In this alternative formulation the scope  of the constraint h, i is abstracted to a set of variables and each possible assignment is seen as a function f :   D.
The constraint relation in this alternative view is then a function from the set of possible
assignments, D , into the set {T, F } where, by convention, the tuples which occur in the
constraint relation are those which map to T . It follows that any assignment to the set of
all variables is allowed by h, i when its restriction to  is mapped to T by .
Definition 2.2. For any function f : X  Y and S  X, the notation f |S means the
function with domain S satisfying f |S (x) = f (x) for all x  S.
Given a set V of variables and a domain D, a constraint in functional representation
is a pair h, i where   V and  : D  {T, F }. A CSP instance in functional representation is a triple hV, D, Ci where C is a set of constraints in functional representation.
A solution (to a CSP instance hV, D, Ci in functional representation) is a mapping
s : V  D where, for each h, i  C we have (s| ) = T .
The functional formulation is clearly equivalent to the relational formulation and we
will use whichever seems more appropriate throughout the paper. The choice will always
be clear from the context.
The following notions are standard in the study of the CSP. A binary CSP instance is
one where the maximum arity of any constraint scope is two. The subproblem of I on
variables U  V is the instance hU, D, CU i where CU is the set of constraints h, i  C
such that   U . The instance I is arc-consistent if v1 , v2  V , each solution to the
subproblem of I on {v1 } can be extended to a solution to the subproblem of I on {v1 , v2 }.
The constraint graph of a binary CSP instance I = hV, D, Ci is the graph with vertices
V and edges the set of scopes of binary constraints in C. Since it is often convenient to
consider that a (possibly irrelevant) constraint exists between every pair of variables, we
introduce the refined notion of true constraint graph.
Definition 2.3. A binary constraint between v1 and v2 is improper if it allows every pair
of values allowed by the unary constraints on v1 and v2 , and proper otherwise.
The true constraint graph of a binary CSP instance is the constraint graph of the
instance after removing any improper binary constraints.
51

fiCohen, Cooper, Creed, Marx & Salamon

We may also sometimes need to disregard unary constraints so we have the following.
Definition 2.4. The binary reduction of a CSP instance is obtained by removing from
the constraint set all those constraints whose scope does not have arity two.

3. Forbidden Patterns in CSP
In this paper we explain how we can define classes of CSP instances by forbidding the
occurrence of certain patterns. A CSP pattern is a generalisation of a CSP instance. In a
CSP pattern we define the relations relative to a three-valued logic on {T, F, U }, meaning
that the pattern can be seen as representing the set of CSP instances in which each undefined value U is replaced by either T or F . Forbidding a CSP pattern is equivalent to
simultaneously forbidding all these instances as sub-problems.
Definition 3.1. We define a three-valued logic on {T, F, U }, where U stands for unknown
or undefined. The set {T, F, U } is partially ordered so that U < T and U < F but T and F
are incomparable. Let D be a finite set. A k-ary three-valued relation on D is a function
 : Dk  {T, F, U }. Given k-ary three-valued relations  and 0 , we say  realises 0 if
x  Dk (x)  0 (x).
We can extend the definition of a CSP or constraint pattern to include additional structure on the set of variable names or the set of domain values, as a set of relations on the
set in question. Adding structure makes patterns more specific. We can therefore capture larger, and hence more interesting, tractable classes. For example, when the domain
is totally ordered we can define the tractable max-closed class (Jeavons & Cooper, 1995);
when we have an independent total order for the domain of each variable we can capture
the renamable Horn class (Green & Cohen, 2003); and placing an order on variables in a
pattern will allow us to define the class of tree-structured CSP instances.
Definition 3.2. A CSP pattern is a quadruple  = hV, D, C, Si, where:
 V is the set of variables, with an associated relational structure with universe V .
 D is the domain, with an associated relational structure with universe D.
 C is a set of constraint patterns. Each constraint pattern c  C is a pair c = h, i,
where   V , the scope  of c, is a list of distinct variables and  : D  {T, F, U } is
the three-valued relation (in functional representation) of c. A constraint pattern
is non-trivial if its three-valued relation maps at least one tuple to {T, F }.
 S is the structure, a set consisting of the relational structures associated with its
variable set and its domain.
The arity of a CSP pattern  is the maximum arity of any constraint pattern h, i of .
Our most basic type of pattern is one which employs no structure, with S empty. We
also frequently require patterns which use a disequality relation 6=, applied to every pair
52

fiTractability of CSP Classes Defined by Forbidden Patterns

from some specified subset of variables, and we allow several such subsets of variables in
the structure.
In this paper the relations occurring in the structure all have arity two, and their interpretation is limited to a few selected binary relations representing disequality or a partial
order. When the structure of a variable set or domain is clear from the context, we will not
explicitly mention it. Different kinds of structure can be imposed on CSP patterns; indeed
structures specified by more general relations would be an interesting area for future study.
The weakest structure that we will consider only allows us to say when two variables are
distinct. Thus the structure S of a CSP pattern is then simply a set of disequalities between
subsets of variables. In this paper we denote such disequalities by NEQ(v1 , . . . , vr ) meaning
that variables v1 , v2 , . . . , vr are all pairwise distinct. A pattern with such a structure will
be called flat. Indeed, in this paper we are mostly concerned with flat patterns. If two
variables occur together in the scope of some constraint pattern, then we also assume that
S implicitly includes the disequality NEQ(v1 , v2 ).
Thus CSP patterns are defined using relational structures with three sorts: for variables,
for domain values, and for variable-value assignments. The constraint patterns of a CSP
pattern are then three-valued relations over the sort of variable-value assignments. If a CSP
pattern is flat then its structure specifies relations over the sort of variables. A partial order
over the variables is also a relation over the sort of variables, and partial orders over domain
values are relations over the sort of domain values.
For simplicity of presentation, we assume throughout this paper that no two constraint
patterns in C have the same scope (and that, in the case of CSP instances, that no two
constraints have the same scope). We will represent binary CSP patterns by simple diagrams. Each oval represents the domain of a variable, each dot a domain value. The tuples
in constraint patterns with value F are shown as dashed lines, those with value T as solid
lines and those with value U are not depicted at all.
Definition 3.3. A constraint pattern h, i will be called negative if  never takes the
value T . A CSP pattern  is negative if every constraint pattern in  is negative.
3.1 Patterns, CSPs and Occurrence
In a CSP instance it is implicitly assumed that all variables and all domain values are
distinct. This is equivalent to the existence of implicit disequalities NEQ between all variable
names and all domain values. A CSP instance is just a CSP pattern (with a structure that
all variables and all domain values are distinct) in which the three-valued relations of the
constraint patterns never take the value U . That is, we decide for each possible tuple
whether it is in the relation or not. Furthermore, in a CSP instance, for each pair of
variables we assume that a constraint exists with this scope; if no explicit constraint is
given on this scope, then we assume that the relation is complete, i.e. it contains all tuples.
This can be contrasted with CSP patterns for which the absence of an explicit constraint
on a pair of variables implies that the truth value of each tuple is undefined.
In order to define classes of CSP instances by forbidding patterns, we require a formal
definition of an occurrence (containment) of a pattern within an instance. We define the
more general notion of containment of one CSP pattern within another pattern. Informally,
the names of the variables and domain elements of a CSP pattern are inconsequential and
53

fiCohen, Cooper, Creed, Marx & Salamon

a containment allows a renaming of the variables and the domain values of each variable.
Thus, in order to define the containment of patterns, we firstly require a formal definition
of a renaming. In an arbitrary renaming, unless explicitly prohibited by a disequality in
the structure, two distinct variables may map to the same variable and two distinct domain
values may map to the same domain value. Furthermore, when a pattern occurs in another,
it may use only a subset of the variables of the second pattern; hence the notion we require
is known as a renaming-extension.
A domain labelling of a set of variables is just an assignment of domain values to those
variables. Variable and domain renaming induces a mapping on the domain labellings of
scopes of constraints: we simply assign the renamed domain values to the renamed variables. There is a natural way to extend this mapping of domain labellings to a mapping
of a constraint pattern: the truth-value of each mapped domain labelling is the same as
the truth-value of the original domain labelling. However, it may occur that two domain
labellings of some scope map to the same domain labelling, so instead the resulting value
is taken to be the greatest of the original truth-values. (In order for this process to be
well-defined, if two domain labellings of a constraint are mapped to the same domain labelling, then their original truth-values must be comparable.) This leads to the following
formal definition of a renaming-extension which is the first step towards the definition of
containment.
Definition 3.4. Let  = hV, D, C, Si and 0 = hV 0 , D0 , C 0 , S 0 i be CSP patterns.
We say that 0 is a renaming-extension of  if there exist a variable-renaming function s : V  V 0 and a domain-renaming function t : V  D  D0 such that s, t and
the assignment-renaming function F : V  D  V 0  D0 induced by (s, t) and defined by
F (hv, ai) = hs(v), t(v, a)i satisfy:
 For each constraint pattern h, i  C, for any two domain labellings `, `0  D for
which F (`) = F (`0 ), we have that (`) and (`0 ) are comparable, where F (`) denotes
the assignment f : s()  D0 such that v  , f (s(v)) = t(v, `(v)).
 C 0 = {hs(), 0 i | h, i  C}, where, for each assignment f : s()  D0 , 0 (f ) = U if
F (`) 6= f for every `  D , and 0 (f ) = max {(`) | F (`) = f } otherwise.
 If  has any structure, then s, t and F preserve this structure. The mapping s induces
a homomorphism between the relational structures of the variable-sets, and mapping
t induces a homomorphism between the relational structures of the domains. (In
particular, if NEQ(v1 , v2 )  S, then s(v1 ) 6= s(v2 ) and NEQ(s(v1 ), s(v2 ))  S 0 .)
We will use patterns to define sets of CSP instances by forbidding the occurrence (containment) of the patterns in the CSP instances. In this way we will be able to characterise
tractable subclasses of the CSP. Informally, a pattern  is said to occur in a CSP instance
P if we can find a sub-problem Q of P (formed by taking subsets of variables and domains)
which realises . Q realises  if, after renaming of variables and domain values in , each
constraint pattern in  is realised by the corresponding constraint in Q. By Definition 3.4,
during a renaming-extension, extra variables, domain values and disequalities can be introduced. Thus we only need to combine the notions of renaming-extension and realisation to
formally define what we mean by a pattern occurring in another pattern (and, in particular,
in a CSP instance).
54

fiTractability of CSP Classes Defined by Forbidden Patterns

Definition 3.5. We say that a CSP pattern  occurs in a CSP pattern P = hV, D, C, Si
(or that P contains ), denoted   P , if there is a renaming-extension hV, D, C 0 , Si of 
where, for every constraint pattern h, 0 i  C 0 there is a constraint pattern h, i  C and,
furthermore,  realises 0 .
Pattern 1
d0
b
b

c

d

b

a
a

c

d

y

x

d
z

y

x

(i)

c

a
y

x

(ii)

(iii)

Pattern 2
b

d

a

c
y

x

Example 3.6. This example describes three simple containments. Consider the three CSP
patterns, Pattern 1(i)(iii). These patterns occur in, or are contained in, Pattern 2 by the
mappings F1 , F2 , and F3 , respectively, which we will now describe.
F1 is simply a bijection. Although the patterns are different, this is a valid containment
of Pattern 1(i) into Pattern 2 because the three-valued relation of Pattern 2 is a realisation
of the three-valued relation in Pattern 1(i): we are replacing (b, d) 7 U by (b, d) 7 F .
F2 maps (x, a), (x, b), and (y, c) to themselves, and maps both (y, d) and (y, d0 ) to
(y, d). This merging of domain elements is possible because the values of the three-valued
constraint relation of Pattern 1(ii) are comparable on tuples involving the assignments (y, d)
and (y, d0 ) and, furthermore, the restriction of the three-valued relation of Pattern 1(ii)
to either of these two assignments is realised by the three-valued constraint relation of
Pattern 2: (b, d) 7 F and (a, d) 7 T . For example, we are replacing (a, d0 ) 7 U by
(a, d) 7 T . In a similar manner, Pattern 1(i) is also contained in Pattern 2 by the simple
mapping F10 which maps both of (x, b), (x, a) to (x, b) and both of (y, c), (y, d) to (y, c).
Finally, F3 maps (y, c) and (y, d) to themselves, and maps (x, a) and (z, b) in Pattern 1(iii) to (x, a) and (x, b), respectively, in Pattern 2. This merging of variables is pos55

fiCohen, Cooper, Creed, Marx & Salamon

sible because the three-valued relations agree and because there is no NEQ(x, z) structure
in Pattern 1(iii).

Pattern 3
z
b

b

d

d

z
c

a
y

x

c

a
y

x

NEQ(x, z)
(i)

(ii)

Throughout this paper, we use the notation NEQ(v1 , . . . , vr ) to denote the fact that the
variables v1 , . . . , vr of a CSP pattern are distinct. It is worth discussing what this structure
implies as far as Definition 3.4 is concerned. Structure in the source pattern must be
preserved in the target pattern. Thus Pattern 1(iii) occurs in Pattern 3(i), but Pattern 3(i)
is not contained in Pattern 1(iii) since the structure NEQ(x, z) is not preserved in the target
pattern. The structure NEQ(v1 , v2 ) is considered to be preserved by a renaming-extension
0 of  even if it is not explicitly given in 0 but is implicit, for example, due to the existence
of a non-trivial constraint pattern h, i in 0 such that v1 , v2  . As an example, consider
the two CSP patterns, Pattern 3(i)(ii). Pattern 3(i) can be mapped to Pattern 3(ii) by
a simple bijection so that the three-valued relation of Pattern 3(ii) is a realisation of the
three-valued relation in Pattern 3(i). The structure NEQ(x, z) is considered to be preserved
by this mapping due to the existence of a non-trivial constraint pattern between variables
x and z in Pattern 3(ii). Hence, Pattern 3(i) occurs in Pattern 3(ii).
Before continuing we need to define what we mean when we say that a class of CSP
instances is definable by forbidden patterns.
Definition 3.7. Let C be any class of CSP instances with maximum arity k. We say that
C is definable by forbidden patterns if there is some set of patterns X for which the set
of CSP instances of maximum arity k in which none of the patterns in X occur are precisely
the instances in C.
Notation: Let X be a set of CSP patterns with maximum arity k. We will use CSP(X ) to
denote the set of CSP instances in which no element   X occurs. When X is a singleton
{} we will use CSP() to denote CSP({}).
In this paper, we only consider classes CSP(X ) for sets X of CSP patterns which are
binary in the sense that all constraint patterns have scope of size exactly two.
For all X such that all patterns in X are binary, CSP(X ) is closed under arc consistency
(in the sense that the arc consistency closure of any instance I  CSP(X ) belongs to
56

fiTractability of CSP Classes Defined by Forbidden Patterns

CSP(X )) and any other operation which only updates unary constraints. Indeed, changing
unary constraints cannot introduce any of the patterns X in any instance I  CSP(X ).
3.2 Tractable Patterns
In this paper we will define, by forbidding certain patterns, tractable subclasses of the CSP.
Furthermore, we will give examples of truly hybrid classes (i.e. classes not definable by
purely relational or purely structural properties).
Definition 3.8. A finite set of patterns X is intractable if CSP(X ) is NP-hard. It is
tractable if there is a polynomial-time algorithm to solve CSP(X ). A single pattern  is
tractable (intractable) if {} is tractable (intractable). (We assume throughout this paper
that P6= NP, and therefore that the sets of tractable and intractable patterns are disjoint.)
It is worth observing that classes of CSP instances defined by forbidding patterns do
not have a fixed domain. Recall, however, that each CSP instance has a finite domain. Any
structure present in a CSP instance is assumed given as part of the instance. In particular,
all variables in a CSP instance are assumed to be distinct. For finite sets of patterns X ,
the number of possible renaming-extensions into a particular instance P is polynomial in
the size of P . Hence we can determine whether an instance lies in CSP(X ) by exhaustive
search in polynomial time.
We will need the following simple lemmas for our proofs of intractability results in later
sections of this paper.
Lemma 3.9. If 1  2 and 2  3 , then 1  3 .
Proof. If   0 , then each constraint pattern h, i of  maps to a constraint pattern h 0 , 0 i
such that 0 realises . The transitivity of  follows from the following facts:
 The realisation operation is transitive.
 If 1  2 and 2  3 , then by Definition 3.4, any structure in 1 is preserved in 2
and hence in 3 .
Lemma 3.10. Let X and T be sets of CSP patterns and suppose that for every pattern
  T , there is some pattern   X for which    . Then CSP(X )  CSP(T ).
Proof. Let P  CSP(X ), so  6 P for each   X . Then we cannot have   P for any
  T , since this would imply that there exists some   X such that     P and hence
that   P by Lemma 3.9. Hence, P  CSP(T ).
Corollary 3.11. Let X and T be sets of CSP patterns and suppose that for every pattern
  T , there is some pattern   X for which    .
We then have that CSP(T ) is intractable if CSP(X ) is intractable and conversely, that
CSP(X ) is tractable whenever CSP(T ) is tractable.
Finally, we give some examples of tractable patterns. The first example is a negative
pattern since the only truth-values in the relations are F and U .
57

fiCohen, Cooper, Creed, Marx & Salamon

Pattern 4 A very simple negative pattern.
v
a

x
c
c0

w
b
NEQ(v, w, x)

Example 3.12. Consider Pattern 4. This defines a class of CSPs which is trivially tractable.
Forbidding Pattern 4 ensures that there are no paths of more than two variables in the true
constraint graph. Thus, any problem forbidding Pattern 4 can be decomposed into a set of
independent sub-problems, each with at most two variables.

Example 3.13. Cooper and Zivny (2011b) showed that forbidding the pattern Negtrans
shown in Pattern 5 describes a tractable class of CSP instances. This can be seen as a generalisation of the well-known tractable class of problems, AllDifferent+unary (Costa,
1994; Regin, 1994; van Hoeve, 2001): an instance of this class consists of a set of variables
V , a set of arbitrary unary constraints on V , and the constraint v 6= w defined on each pair
of distinct variables v, w  V . Forbidding Negtrans is equivalent to saying that disallowed
tuples form a transitive relation, i.e. if (hv, ai , hx, bi) and (hx, bi , hw, ci) are disallowed then
(hv, ai , hw, ci) must also be disallowed. Thus Negtrans does not occur in any binary CSP
instance in the class AllDifferent+unary by the transitivity of equality (equality being
exactly what is disallowed).

Pattern 5 Negative transitive pattern (Negtrans)
v
x

w

NEQ(v, w, x)
Cooper and Zivny (2011b) also recently showed that the tractable class defined by
forbidding Pattern 5 (Negtrans) can be extended to soft constraint problems.
58

fiTractability of CSP Classes Defined by Forbidden Patterns

3.3 Tractable Patterns with Structure
This paper primarily studies patterns with a weak structure in that the only conditions that
are imposed are that variables are distinct. However, it is worth pointing out that adding
structure to a pattern allows us to capture larger classes of instances. In Example 3.14
below we show that a forbidden pattern can capture the class of CSPs with tree width 1
by adding a variable-ordering to Pattern 4. In this case pattern containment must preserve
the total order. For an ordered pattern , we will consider an unordered CSP P to be in
CSP() if there exists some ordering of the variable set of P such that  is forbidden. In
order for  to define a tractable class, it must be possible to find this ordering in polynomial
time. This is the case for the patterns in Examples 3.14 and 3.15.
Pattern 6 Tree structure pattern (Tree)

v1
v3
v2
v1 < v2 < v3
Example 3.14. Consider the pattern Tree, given as Pattern 6. We will show that the class
CSP(Tree) is exactly the set of CSPs whose true constraint graph is a forest (i.e. has tree
width 1). First, suppose P  CSP(Tree). Then, there exists some ordering  = (v1 , . . . , vn )
such that each variable shares a proper constraint with at most one variable preceding it
in the ordering. On the other hand, suppose P is a CSP whose true constraint graph is a
tree. By ordering the vertices according to a pre-order traversal, we obtain an ordering in
which each variable shares a proper constraint with at most one variable preceding it in the
ordering (its parent); thus, P  CSP(Tree).

Example 3.15. Forbidding the pattern BTP shown in Pattern 7 is known as the brokentriangle property (Cooper et al., 2010). In order to capture this class by a forbidden
pattern we again have to impose a total order on pattern variables. Cooper et al. (2010)
proved that the class of CSP instances CSP(BTP) can be solved in polynomial time and,
indeed, that CSP instances in CSP(BTP) for some unknown total ordering of the variables
can be recognised and solved in polynomial time.

It is easy to see that Tree (shown in Pattern 6) occurs in BTP (with some truthvalues U being changed to T ). It follows from Lemma 3.10 that CSP(Tree)  CSP(BTP).
Hence the class CSP(BTP) includes all CSP instances whose true constraint graph is a tree.
However, CSP(BTP) also includes certain CSP instances whose true constraint graph has
59

fiCohen, Cooper, Creed, Marx & Salamon

Pattern 7 Broken triangle pattern (BTP)

b

v1

a
v3
v2
v1 < v2 < v3

tree width r for any value of r: consider, for example, a CSP instance with r + 1 variables
and an identical constraint between every pair of variables which simply disallows the single
tuple h0, 0i.
For any tractable forbidden pattern with an order imposed on the variables, we can
obtain another tractable class by considering problems forbidding the pattern without this
ordering condition. The class obtained is generally smaller, because it is easier to establish
containment of the flat pattern. For example, consider Pattern 4 which is the flat version of
Pattern 6. We have seen that forbidding Pattern 4 gives rise to the class of CSP instances
in which there are no paths of length greater than two in the true constraint graph. On the
other hand, forbidding Pattern 6 gives the much larger class of CSP instances in which the
true constraint graph has tree width 1.
In the case of the broken-triangle property, we also obtain a strictly smaller tractable
class by forbidding Pattern 7 for all triples of variables v1 , v2 , v3 irrespective of their order.
We can easily exhibit a CSP instance that shows this inclusion to be strict: for example, the
3-variable CSP instance over Boolean domains consisting of the two constraints v1 = v2 ,
v1 = v3 with the variable ordering v1 < v2 < v3 . This unordered version of BTP was
recently used to obtain a dichotomy for patterns consisting of 2 constraints (Cooper &
Escamocher, 2012).

4. On Maximal Tractable Classes Defined by Forbidden Patterns
In relational tractability we can define a maximal tractable sub-problem of the CSP problem
given by a set  of possible relations. Such a class of relations is maximal if it is not possible
to add even one more relation to  without sacrificing tractability.
In the case of structural tractability the picture is less clear, since here we measure the
complexity of an infinite set of hypergraphs (or, more generally, relational structures). We
obtain tractability if we have a bound on some width measure of these structures. Whatever
width measure is chosen we have a containment of the class with width bounded by k inside
that of the class of width bounded by k +1 and so no maximal class is possible (although for
each k there is a unique maximal class of structurally tractable instances). In this section,
we show that in the case of forbidden patterns the situation is similar.
60

fiTractability of CSP Classes Defined by Forbidden Patterns

Definition 4.1. Let  = hV, D, C, Si and  = hV 0 , D0 , C 0 , S 0 i be any two flat CSP patterns.
 0 and DD
 0 . Now, extend each constraint pattern in
We can form the disjoint unions V V
 0 by setting the value of any tuple including elements of D0 to
C to be over the domain DD
 0.
be U , and extend similarly the constraint patterns in C 0 : in this way we can define C C
 0 by forming the disjoint union of S and S 0 and adding all
Also define the structure S S
0
disequalities NEQ(v, v ) for all v  V and v 0  V 0 . Then we set the disjoint union of 
 = hV V
 0 , DD
 0 , C C
 0 , S S
 0 i.
and  to be 
Lemma 4.2. Let  and  be flat non-empty (i.e. containing at least one variable) binary
CSP patterns. Then
 ).
CSP()  CSP( ) ( CSP(
 ) is tractable whenever CSP() and CSP( ) are tractable.
Moreover, we have that CSP(
Proof. We begin by showing the strict inclusion
 ).
CSP()  CSP( ) ( CSP(
That the inclusion holds follows directly from Lemma 3.10. Among all patterns in which 
occurs, let  be a pattern with the smallest number of variables. We define   similarly.
To see that the inclusion is strict, observe that  and  occur in a CSP pattern whose
domain is the disjoint union of those for  and   , but whose variable set has size equal
to the larger of the variable sets of  and   . Any CSP instance containing this pattern
is neither in CSP() nor in CSP( ). However, we can construct a CSP instance containing
 ), as the structure of 
 imposing disequalities
this pattern which is contained in CSP(

between variables of  and  means that  is not contained in this pattern: there are
simply not enough variables.
 ). If P  CSP()  CSP( ) then P can be solved in polynomial
Suppose P  CSP(
time, by the tractability of CSP() and CSP( ).
So we may suppose that   P . Choose a particular occurrence of  in P and let 
denote the set of variables used in the containment. Consider any assignment t :  
D. Let Pt denote the problem obtained by making this assignment and then enforcing
arc-consistency on the resulting problem. This corresponds to adding some new unary
constraints to P .
 must occur in P . To see this, observe that
We will show that if  occurs in Pt then 
any containment of  in Pm naturally induces a containment of  in P that extends to a
 in P , by considering the occurrence of  in . Thus, we can conclude
containment of 
that Pt  CSP( ), and so can be solved in polynomial time.
By construction, any solution to Pt extends to a solution to P by adding the assignment
t to the variables . Moreover, every solution to P corresponds to a solution to Pt for some
t :   D. Since the size of  is fixed, we can iterate over the solutions to  in polynomial
time. If P has a solution, then we will find it as the solution to some Pt . If we find that no
Pt has a solution, then we know P does not have a solution. Thus, since we can solve each
Pt in polynomial time, we can also solve P in polynomial time.
Corollary 4.3. No tractable class defined by forbidding a flat pattern is maximal.
61

fiCohen, Cooper, Creed, Marx & Salamon

 defined by the disjoint
Proof. Let  be any tractable flat pattern. Consider the pattern 

union of two copies of . By Lemma 4.2 we have that CSP()
is tractable but also that
 ,
CSP() ( CSP()
and hence CSP() is not a maximal tractable class.
It follows that we cannot characterise tractable forbidden patterns by exhibiting all
maximal tractable classes defined by forbidding a pattern (or any finite set of patterns,
since by Lemma 4.2 such a finite set can be replaced by a single pattern). Indeed, a
consequence of Lemma 4.2 is that we can construct an infinite chain of patterns, such that
forbidding each one gives rise to a slightly larger tractable class. Naturally, if we place an
upper bound on the size of the patterns then there are only finitely many patterns that we
can consider, so maximal tractable classes defined by forbidden patterns of bounded size
necessarily exist.

5. Binary Flat Negative Patterns
For the moment, we are not able to make a conjecture concerning the complete characterisation of the complexity of general forbidden patterns, although we conjecture that a
dichotomy exists. Nonetheless, by restricting our attention to a special case, forbidden
binary flat negative patterns, we are able to obtain a dichotomy. Recall that a pattern is
flat if the only structure that can be imposed is that variables are distinct, and that it is
negative if in all of its constraint patterns h, i,  never takes the value T .
We begin by defining three particular patterns and one infinite class of patterns. We
then use these patterns to characterise a very large class of intractable patterns. We prove
that any finite set of flat negative patterns not in this class has a simple structure: one of
the patterns must be contained in one of a particular set of patterns, which we call pivots.
This means that any tractable such set of patterns must include a pattern which occurs in
a pivot pattern. Furthermore, we demonstrate that forbidding any pivot pattern gives rise
to a tractable class. This then leads to a simple characterisation of the tractability of finite
sets of binary flat negative patterns.
Pattern 8 Cycle(6)
c0
c
v1

v2

v3

v6

v5

NEQ(v1 , . . . , v6 )

62

v4

fiTractability of CSP Classes Defined by Forbidden Patterns

Pattern 9 Valency
x1

x01

x2

x02

x3

x03
NEQ(x1 , x2 , x3 , x01 )  NEQ(x01 , x02 , x03 )

Pattern 10 Path

v1

v2

v3

w1

w2

w3

NEQ(v1 , v2 , v3 , w1 )  NEQ(w1 , w2 , w3 )
In Definition 5.1 below, we define the concept of a neg-connected binary pattern. These
correspond to binary patterns  such that the true constraint graph of every realisation of
 as a binary CSP instance is a connected graph. We first generalise the notion of true
constraint graph to CSP patterns. We call the resulting graph the negative structure graph.
Definition 5.1. Let  be any binary pattern. The vertices of the negative structure
graph G are the variables of . A pair of vertices is an edge in G if and only if they form
a scope in  whose constraint pattern assigns at least one tuple the value F . We say that
a pattern  is neg-connected if its negative structure graph is connected. In the case of
negative patterns, we use the simpler term connected instead of neg-connected.
Pattern 9 (Valency), Pattern 10 (Path) and Pattern 11 (Valency+Path) are not
connected. Note that a pattern which is not connected may occur in a connected pattern
(and vice versa). Pattern 8 shows Cycle(6) which is connected. This is just one example
of the generic pattern Cycle(k) where k  2. The only structure for Cycle(k) is that
all variables are distinct, except for the special case k = 2 for which the structure also
includes NEQ(c, c0 ). This additional requirement means that Cycle(2) is composed of a
single binary constraint pattern containing two distinct disallowed tuples. The following
theorem uses these patterns to show that most patterns are intractable.

63

fiCohen, Cooper, Creed, Marx & Salamon

Pattern 11 Valency+Path
v1

v2
w1
v3

w2

w3

x

NEQ(v1 , v2 , v3 ), NEQ(w1 , w2 , w3 ), and NEQ(x, w2 )
Theorem 5.2. Let X be any finite set of neg-connected binary patterns. If, for each   X ,
at least one of Cycle(k) (for some k  2), Valency, Path, or Valency+Path occurs
in , then X is intractable.
Proof. Let X be a finite set of neg-connected negative binary patterns and let ` be the
number of variables in the largest element of X .
Assuming at least one of the four patterns occurs in each   X , we can construct a
class of CSPs in which no element of X occurs and to which we have a polynomial-time
reduction from the well-known NP-complete problem 3SAT (Garey & Johnson, 1979).
The construction will involve three gadgets, examples of which are shown in Figure 1.
These gadgets each serve a particular purpose:
1. The cycle gadget, shown in Figure 1(a) for the special case of 4 variables, enforces
that a cycle of Boolean variables (v1 , v2 , . . . , vr ) all take the same value.
2. The clause gadget in Figure 1(b) is equivalent to the clause v1  v2  v3 , since vC has
a value in its domain if and only if one of the three vi variables is set to true. We can
obtain all other 3-clauses on these three variables by inverting the domains of the vi
variables.
3. The line gadget in Figure 1(c), imposes the constraint v1  v2 . It can also be used to
impose the logically equivalent constraint v2  v1 .
The cycle gadget will be connected to the clause gadget via line gadgets. These three types
of gadgets have been specified to ensure that at most one negative edge is adjacent to any
vertex in the coloured microstructure, except when the cycle gadget is connected to a line
gadget.
Now, suppose that we have an instance  of 3SAT with n propositional variables
X1 , . . . , Xn and m clauses C1 , . . . , Cm .
We begin our construction of a CSP instance P to solve the 3SAT instance  by using
n copies of the cycle gadget (Figure 1(a)), each with m(` + 1) variables. For i = 1, . . . , n,
m(`+1)
the variables along the ith copy of this cycle are denoted by (vi1 , vi2 , . . . , vi
). In any
64

fiTractability of CSP Classes Defined by Forbidden Patterns

v1
T
F

v2

vC
v2

v1

v3

T
F
v3
T
F

v4
(a)

(b)

T
F
v1

v2
(c)

Figure 1: (a) Making copies of the same variable (v1 = v2 = v3 = v4 ). (b) Imposing the
ternary constraint vC = v1  v2  v3 . (c) A line of constraints of length 4 which
imposes v1  v2 .

solution to a CSP instance P with these and other constraints, we will have that the
variables vij , j = 1, . . . , m(` + 1) must all have the same value, di . We can therefore consider
each vij as a copy of Xi .
Consider the clause Cw . There are eight cases to consider but they are all very similar
so we will show the details for just one case. Suppose that Cw  Xi  Xj  Xk . We
build the clause gadget (Figure 1(b)) with the three Boolean variables being ciw , cjw and ckw
and invert the domain of ckw since it occurs negatively in Cw . Then any solution s to our
constructed CSP must satisfy s(ciw )  s(cjw )  s(ckw ) = T .
We complete the insertion of Cw into the CSP instance by adding some line gadgets of
length ` + 1 (Figure 1(c)). We connect the cycle gadgets corresponding to Xi , Xj and Xk
w(`+1)
to the clause gadget for clause Cw since Xi , Xj and Xk occur in Cw . We connect vi
w(`+1)
to ciw since Xi is positive in Cw , so s(ciw ) = T is only possible when s(vi
) = T , for
65

fiCohen, Cooper, Creed, Marx & Salamon

w(`+1)

any solution s. Similarly, we connect vj
to cjw . Finally, since Xk occurs negatively in
Cw , we impose the line constraints in the other direction. This ensures that s(ckw ) = F is
w(`+1)
only possible when s(vk
) = F . Imposing these constraints ensures that a solution is
only possible when at least one of the cycles corresponding to variables Xi , Xj , and Xk is
assigned a value that would make the corresponding literal in Cw true.
We continue this construction for each clause of the 3SAT instance. Since ` is a constant,
this is clearly a polynomial reduction from 3SAT.
We now show that any CSP instance P constructed in the manner we have just described cannot contain any pattern in X . We do this by showing that no neg-connected
pattern containing Cycle(k) (for 2  k  `), Valency, Path, or Valency+Path can
occur in the instance. This is sufficient to show that the CSP instance P does not contain
any of the patterns in X .
In the CSP instance P no constraint contains more than one disallowed tuple. Thus,
any   X for which Cycle(2)   cannot occur in P . Furthermore, P is built from
cycles of length m(` + 1) and paths of length ` + 1, and so cannot contain any cycles on less
than ` + 1 vertices. Thus, since ` is the maximum number of vertices in any element of X ,
it follows that no   X for which Cycle(k)  , for any k  3, can occur in P .
We define the valency of a variable x to be the number of distinct variables which share
a constraint pattern with x. Suppose Valency  , where   X is neg-connected. For
this to be possible we require that there is a variable of valency four in , or a pair of
variables of valency three connected by a path of length at most ` in the negative structure
graph of . Certainly P has no variables of valency four. Moreover, the fact that P was
built using paths of length ` + 1 means that no two of its valency three variables are joined
by a path of length at most `. Thus,   X does not occur in P if Valency  .
Next, consider the case when Path  , where   X is neg-connected. Here  must
have two distinct (but possibly overlapping) three-variable lines (with disallowed tuples in
these constraint patterns that match at domain values) separated by at most ` variables.
The only place where disallowed tuples can meet in P is when we connect the line gadget
to the cycle gadget. These connection sites are always at distance greater than `, so we can
conclude that  6 P whenever Path  .
Finally, consider the case where Valency+Path  , where   X is neg-connected.
Here,  must have a variable of valency at least 3 and a path of constraint patterns on
three variables with intersecting disallowed tuples, and these must be connected by a path
of less than ` variables in the negative structure graph of . As observed above, the only
places in P where we can have disallowed tuples meeting is where the line gadget meets
the cycle gadget, and there is a path of at least ` variables between each one of these points
and every other variable of valency 3. Thus,  6 P whenever Valency+Path  .
It remains to consider which sets of negative binary patterns could be tractable. For
this, we need to define the pivot patterns, Pivot(r), which contain every tractable negative
binary pattern.
Definition 5.3. Let V = {p}  {v1 , . . . , vr }  {w1 , . . . , wr }  {x1 , . . . , xr }, D = {a, b}
and S = {NEQ(p, v1 , . . . , vr , w1 , . . . , wr , x1 , . . . , xr )}. We define the pattern Pivot(r) =
66

fiTractability of CSP Classes Defined by Forbidden Patterns

Pattern 12 Pivot(3)
v3

v2

v1
w1

w2

w3

p
a
x3

x2

x1

b

NEQ(p, v1 , v2 , v3 , w1 , w2 , w3 , x1 , x2 , x3 )

hV, D, Cp  Cv  Cw  Cx , Si, where
Cp = {h(p, v1 ), ab i , h(p, w1 ), ab i , h(p, x1 ), bb i}
Cv = {h(vi , vi+1 ), ab i | i = 1, . . . , r  1}
Cw = {h(wi , wi+1 ), ab i | i = 1, . . . , r  1}
Cx = {h(xi , xi+1 ), ab i | i = 1, . . . , r  1}
and where ab (a, b) = F , ab (s, t) = U (for all (s, t) 6= (a, b)), bb (b, b) = F , bb (s, t) = U
(for all (s, t) 6= (b, b)). The pattern Pivot(r) has the structure S that all its variables are
distinct. See Pattern 12 for an example, Pivot(3).
We say that a pattern  on variables v1 , . . . , vr is a distinct-variable pattern if its
structure includes NEQ(v1 , . . . , vr ). The following proposition characterises those sets of
connected binary flat negative distinct-variable patterns which Theorem 5.2 does not prove
intractable.
Proposition 5.4. Any connected binary flat negative distinct-variable pattern  either
contains Cycle(k) (for some k  3), Valency, Path, or Valency+Path, or itself
occurs in Pivot(r) for some integer r  ||.
Proof. Suppose  does not contain any of the patterns Valency, Cycle(k) (for any k  3),
Path, or Valency+Path. Recall that the valency of a variable x is the number of distinct
variables which share a constraint pattern with x. Since  does not contain Valency it
can only contain one variable of valency three and all other variables must have valency
at most two. Moreover, since Cycle(k) 6  for k  3, the negative structure graph of 
does not contain any cycles. Thus, since  is connected, the negative structure graph of
 consists of up to three disjoint paths joined at a single vertex. If two disallowed tuples
67

fiCohen, Cooper, Creed, Marx & Salamon

over distinct scopes intersect, then we call the union of the scopes the footprint of the
intersection. The fact that the negative structure graph of  is acyclic and that  does not
contain Path means that all such pairs of intersecting disallowed tuples in  must have the
same footprint. Moreover, the fact that  does not contain Valency+Path means that
all such intersections must occur at the variable with valency 3, if it exists. The fact that 
is flat and negative means that in a renaming-extension any pair of disallowed tuples ha, bi,
hc, di over the same scope hu, vi in  can be merged by the domain-renaming function t,
i.e. t(hu, ai) = t(hu, ci) and t(hv, bi) = t(hv, di). It then follows that  occurs in Pivot(r),
for some r  ||.
Corollary 5.5. Let X be a finite set of connected binary flat negative distinct-variable
patterns. Then CSP(X ) is tractable only if there is some   X that occurs in Pivot(r),
for some integer r  ||.
We now prove the same result for patterns which are not necessarily distinct-variable.
Corollary 5.6. Let X be a finite set of connected binary flat negative patterns. Then
CSP(X ) is tractable only if there is some   X that occurs in Pivot(r), for some integer
r  ||.
Proof. For  a connected binary flat negative pattern, let dv() denote the set of connected
binary flat negative distinct-variable patterns in which  occurs, which have the same
domain as  and at most || variables. We use dv(X ) to denote the union of the sets dv()
for   X .
By Lemma 3.10, CSP()  CSP(dv()). For every CSP instance P such that   P ,
we have   P for some   dv(). It follows that CSP(dv())  CSP(), and hence
CSP() = CSP(dv()). Since CSP(X ) is just the intersection of the CSP() for   X
and CSP(dv(X )) the intersection of the CSP(dv()) for   X , we have that CSP(X ) =
CSP(dv(X )).
By Corollary 5.5, CSP(dv(X )) is tractable only if some pattern   dv(), for some
  X , occurs in Pivot(r) for some r  | |. But, by definition of dv(),  occurs in 
and | |  ||. Therefore, CSP(X ) is tractable only if  occurs in Pivot(r) for some integer
r  ||.
For an arbitrary (not necessarily flat or negative) binary CSP pattern , we denote
by neg() the flat negative pattern obtained from  by replacing all truth-values T by
U in all constraint patterns in  and ignoring any structure beyond disequalities between
variables. Recall that the structure of a flat pattern only contains disequality relations
between variables, so neg() is a flat pattern by definition. For a set of patterns X ,
neg(X ) is naturally defined as the set neg(X ) = {neg() :   X }. Clearly CSP(neg(X ))
 CSP(X ). The following result follows immediately from Corollary 5.6. It provides a
necessary condition for tractability of general patterns.
Corollary 5.7. Let X be a finite set of binary patterns such that for each   X , neg() is
connected. Then CSP(X ) is tractable only if there is some   X such that neg() occurs
in Pivot(r), for some integer r  ||.
68

fiTractability of CSP Classes Defined by Forbidden Patterns

6. The Pivot Theorem
Theorem 6.1. Pivot(r) is tractable for all r  1.
This theorem together with Corollary 5.6 immediately provides a dichotomy for finite
sets of connected binary flat negative patterns. Most of this section is devoted to the proof
of this theorem (which we call the pivot theorem). We conclude this section by giving a
dichotomy for finite sets of flat negative patterns which are not necessarily connected.
We will need some definitions from graph theory.
Definition 6.2. A subdivision of a graph G is a graph obtained by replacing some edges
of G with simple paths.
A minor of a graph G is any graph obtained from G by deleting edges, contracting
edges and removing isolated vertices. A graph H is a topological minor of a graph G if a
subdivision of H is a subgraph of G.
We will need to use the following well-known theorem of Robertson and Seymour (1986).
Theorem 6.3. For every planar graph H there is an integer k > 0 such that if a graph
does not contain H as a minor, then its tree width is at most k.
In particular, if a graph has large tree width, then it contains a large grid minor. In this
section we will consider hexagonal grid minors instead (see Figure 2). The reason for this is
the well-known fact that if a graph of maximum degree three is a minor of another graph,
then it is a topological minor and the latter notion is more convenient for our proofs. As
illustrated in Figure 2, an h hexagonal grid is a graph composed of hexagons in a honeycomb
pattern: its width h is the number of hexagons in both horizontal and vertical directions.
Definition 6.4. Let g : r  N be such that every graph of tree width at least g(r) contains
the 3(r + 4) hexagonal grid as a topological minor.
Let us observe the following simple property first:
Lemma 6.5. Any three degree three vertices of the hexagonal grid of width 3r begin disjoint
paths of length r.
Proof. If each vertex is in a different row then we can simply choose a path for each of them
along their row (in the direction away from the nearest boundary of the grid). See vertices
a, b and c in Figure 2 to visualise this typical situation.
Otherwise it may be possible, by rotating the grid through 120 or 240 degrees to get all
three vertices to lie on different rows. If we cannot separate the vertices by rotating then
they are the corners of an equilateral triangle, such as x, y, z or p, q, r in the diagram.
If the triangle has an interior row, such as Row 4 for x, y, z in the diagram, then we
can extend two vertices along their row and drop the third to the interior row and then
along that row. Thus, for example, the path beginning at y would drop down one row and
continue along Row 4.
The only remaining case is when the three vertices form an equilateral triangle occupying
just two adjacent rows, like p, q, r in the diagram. In this case there is some orientation
for which the two vertices that are on the same row do not both lie along the edge of the
69

fiCohen, Cooper, Creed, Marx & Salamon

grid. In the diagram we can rotate either 120 or 240 degrees to achieve this for p, q, r.
Now we can extend two of the three vertices along their row and the third can shift away
from the centre of the triangle in order to find an empty row along which the path can be
extended.
Row 6
b

y

x

Row 5
Row 4

z

Row 3
a
c
Row 2
Row 1
Row 0

r
p

q

Figure 2: A hexagonal grid of width 6 with the rows picked out in bold and numbered.
The following combinatorial result is crucial for our algorithm, but it is interesting in
its own right:
Lemma 6.6. Let G be a 3-connected graph of tree width at least g(r) and let a, b, c be
distinct vertices of G. Then G contains 3 pairwise vertex disjoint paths starting at a, b, c,
respectively, and each having length r.
Proof. Let H be the 3(r + 4) hexagonal grid. By the definition of g(r), graph G contains
H as a topological minor. Note that H contains some vertices of degree 2 on the boundary,
which will cause some complications in the proof. To avoid this complication, we observe
that H is a subdivision of a graph H  whose every vertex has degree 3 and we will focus
on the graph H  instead.

Let HG
denote the subdivision of H  appearing in G and let S denote the vertices of

degree three in HG
. By Mengers theorem (Dirac, 1966) there are vertex-disjoint paths Pa ,
Pb , Pc in G from a, b, c to distinct vertices sa , sb , sc in S, respectively. Choose the paths in

such a way that the total number of edges used by them that are not in HG
is minimized.

Let x, y  S be two vertices that correspond to adjacent vertices in H . This means

that HG
contains a path Q with endpoints x and y whose internal vertices are disjoint
from S. Suppose that, say, Pa contains an internal vertex of Q. We claim that either (1)
x, y  {sa , sb , sc } or (2) sa  {x, y} and Pb , Pc are disjoint from Q. Suppose that (1) does
not hold, say, x 6 {sa , sb , sc }. Consider the internal vertex q of Q closest to x that is used
70

fiTractability of CSP Classes Defined by Forbidden Patterns

by one of the paths. We can reroute this path from q to x without using any further edges

outside HG
. This would create a new set of paths with smaller number of edges outside


HG , unless the rerouted path did not use any further edges outside HG
after q. This is
only possible if the path goes from q to y on Q. But this means that there is only one path
intersecting Q: no path intersects Q between q and x by the definition of q and the same
path uses all the vertices from q to y. Thus case (2) holds.
By Lemma 6.5 there are three independent paths of length r + 4 from the vertices sa , sb
and sc in the (non subdivided) hexagonal grid H, which correspond to paths Xa , Xb , Xc in

HG
. We will use these paths to create three independent paths of length at least r from a, b
and c in G. By definition, the path Xa does not go through sb or sc . Therefore, by the claim
in the previous paragraph, Xa is disjoint from Pb and Pc : if Xa uses the path Q between x
and y, then sb , sc 6 {x, y} means that neither (1) or (2) can happen if Pb or Pc intersects
Q. If Xa is disjoint from Pa as well, then we create a new path Ta by simply concatenating
Pa and Xa . Otherwise, the only way Xa can intersect Pa is on the first subdivided edge
of H  where Xa goes (this is the only place where case (2) of the claim can happen). In
this case, we create a new path Ta by following Pa until it meets this subdivided edge and
then following Xa . As each edge of H  corresponds to up to 4 edges of H, path Ta could
meet up to 4 edges of H fewer than what Xa does. The path Ta will, in either case, meet
at least r subdivided edges of H and so has length at least r. We can build Tb and Tc in an
analogous fashion.
We will require the following technical lemma in our proofs.
Lemma 6.7. Let P be any binary CSP instance. Suppose that the assignment of d to x, or
of d0 to y both extend to a solution of P but that there is no solution assigning both d to x
and d0 to y. Then there is a path of proper binary constraints between x and y. Furthermore,
there is such a path such that the first constraint along this path disallows some tuple hd, d1 i
and the last constraint disallows some tuple hd2 , d0 i.
Proof. Let Sx be any solution to P including the assignment of d to x and similarly let Sy
be any solution to P including the assignment of d0 to y.
Define a graph G on the variables of P . There is an edge from x to a variable z if and
only if the assignment of d to x is incompatible with some domain value for z. Similarly,
there is an edge from y to a variable z if and only if the assignment of d0 to y is incompatible
with some domain value for z. Finally there is an edge between any two variables other
than x and y if and only if the constraint between them is proper.
Let Cx be the component of G containing x. Define an assignment S to the variables
of P by setting S(z) = Sx (z) if z  Cx and S(z) = Sy (z) otherwise. This is a solution to
P since the only possible unsatisfied constraint would have to be between a variable of Cx
and a variable not in Cx , but by the choice of Cx this cannot happen.
By hypothesis, we know that S(y) 6= d0 and so we have the required path of proper
binary constraints.
Note that if in Lemma 6.7 there is a binary constraint between x and y that forbids
assigning d to x and d0 to y, then setting d1 = d0 and d2 = d yields the required path of
proper binary constraints, of length one.
We first show that CSP(Pivot(r)) is tractable in a special case with restricted structure.
71

fiCohen, Cooper, Creed, Marx & Salamon

Lemma 6.8. The subclass of CSP(Pivot(r)) consisting of instances:
 which have an arc-consistent binary reduction;
 which have no unary constraints on variables of degree two in the constraint graph;
 where the true constraint graph is a subdivided three-connected graph,

has time complexity O n3 dg(r)+1 .

Proof. Let P be an instance satisfying the conditions of the lemma. In time O nd2 , we
join the binary constraints along each subdivided edge eliminating intermediate variables
as we go, to obtain the instance P 0 , whose constraint graph is three-connected, but which
may have some improper binary constraints and arbitrary unary constraints. Let G denote
the true constraint graph of P and G0 the three-connected graph obtained from G by
contracting subdivided edges. The true constraint graph of P 0 is a subgraph of G0 on the
same vertex-set.

We can solve P 0  CSP(Negtrans) in time O n2 d3 (n + d) (Cooper & Zivny, 2011b).

This is clearly O n3 dg(r)+1 since g(r)  3 for all r. Furthermore, if G0 has tree width at

most g(r) then P 0 can be solved in time O ndg(r)+1 (Dechter & Pearl, 1989). In either
case this solution can be extended to a solution of the original instance P in time O(nd).
The only remaining case to consider is when Negtrans occurs in P 0 and the tree
width of G0 is also at least g(r). We will complete the proof by deriving the contradiction
P 6 CSP(Pivot(r)), in order to show that this case cannot occur.
Suppose Negtrans occurs in P 0 on variables a, b, c and values da , db , dc :
da

dc

a

c
db
b

By Lemma 6.6, G0 contains 3 vertex-disjoint paths Ta , Tb , Tc starting at a, b, c, respectively, each having length at least r. Recall that the true constraint graph G of the
original instance P was a subdivided three-connected graph and that P 0 was obtained from
P by joining binary constraints along subdivided edges. Let Ta , Tb , Tc denote the paths in
G corresponding to Ta , Tb , Tc in G0 . Recall also that Negtrans occurs in P 0 on variables
a, b, c and values da , db , dc .
Now let a and c be the first vertices along the subdivided edges from b to a and c in
G. The embedding of Negtrans in P 0 shows that hdb , da i is disallowed by the join of the
arc-consistent path from b to a. Since this path is, by construction, a subdivision of an
edge of P 0 we know that no unary constraints occur on any internal vertices. We also know,
by arc consistency of the binary constraints, that the assignments a = da or b = db both
extend to a consistent assignment to the path between a and b. So, by Lemma 6.7 we know
that there is some value da in the domain of a such that hdb , da i is disallowed in P by the
72

fiTractability of CSP Classes Defined by Forbidden Patterns

constraint between b and a. Similarly there is a value dc for which hdb , dc i is disallowed in P
by the constraint between a and c. By appending the path from b to a to the path Ta and
the path from b to c to Tc , together with Tb , we obtain three independent paths of length at
least r of proper constraints in P , beginning at variable b, two beginning with constraints
disallowing a tuple with value db at b. So we have shown that Pivot(r) does indeed occur
in P and we are done.
CSP(Pivot(r)) places an upper bound on the length of the chain of dependencies that
may have to be followed to discard a partial solution that cannot be extended to a solution.
Informally speaking, forbidding the Pivot(r) pattern bounds the amount of local search
that may have to be done when extending a partial solution to a larger partial solution. The
amount of effort that may be required increases with the length of such chains of inference,
and this worst-case behaviour is quantified more precisely in the following result. We first
require some definitions.
Definition 6.9. Let G be a graph and U be a subset of the vertices of G. The induced graph
G[U ] of G on U is the graph with vertex set U and whose edges are those edges of G which
connect two vertices of U .
For graphs G = hV, Ei and G0 = hV 0 , E 0 i define G  G0 = hV  V 0 , E  E 0 i.
In a graph G we say that hU1 , U2 i is a separation if G = G[U1 ]  G[U2 ] and neither of
U1 , U2 is a subset of the other. The separator of the separation hU1 , U2 i is U1  U2 and
its order is |U1  U2 |. A minimal separator is one of minimal order.
The torso of U1 in the separation hU1 , U2 i is obtained from the induced graph G[U1 ] by
adding every edge between the vertices of the separator of hU1 , U2 i.

Theorem 6.10. The class of Pivot(r)-free instances is solvable in time O n3 dg(r)+3 .
Proof. We will prove the result by induction on the number of variables.
The base case is straightforward. When the instance has fewer than g(r)+3 variables, we
can clearly solve it by exhaustive search in time O n3 dg(r)+3 . For the inductive case we can

assume that we can solve all smaller instances with n < k variables in time O n3 dg(r)+3 .
Let P be any Pivot(r)-free instance with n = k variables. First make P arc-consistent
in time O(n2 d2 ) (Bessiere, Regin, Yap, & Zhang, 2005). Since P is now arc-consistent, unary
constraints no longer have any effect. Remove all unary and improper binary constraints
from P in time O(n2 d2 ). Let G be the true constraint graph of the resulting instance, P 0 .
If G has no separation of order two then it is either three-connected or has at most three
vertices. In the three-connected case we can solve P 0 , and hence P , in time O n3 dg(r)+1
by Lemma 6.8. If P has at most three variables then it is trivial to solve in time O(d3 ).
So, we can assume that G has a separation of order two. By definition of the torso any
size-2 separator of a torso is a size-2 separator of G. Hence we can find a size-2 separation
hU1 , U2 i where the torso of U1 has no separation of order two. So we can assume that the
torso of U1 is either three-connected or has at most three vertices.
Now consider the separator M = U1  U2 of hU1 , U2 i. If M is empty then P 0 is composed of two smaller independent
Pivot(r)-free instances and so can be solved in time

3
g(r)+3
3
g(r)+3
O n1 d
+ O n2 d
where n1 + n2 = n and 1  n1 , n2 < n. It follows that we can

solve P in time O n3 dg(r)+3 , so we are done.
73

fiCohen, Cooper, Creed, Marx & Salamon

If M = {m} then we consider the structure of G[U1 ]. It is three-connected, so m
vertex has degree at least three. In this case we can add any unary constraint on m
and, by Lemma 6.8, solve the instance in time O n3 dg(r)+1 . Hence we can find, in time

O dn3 dg(r)+1 , which values of the variable m extend to all variables of U1 . Adding this restriction as a unary constraint on variable m leaves the induced instance on U2 Pivot(r)-free

and we see, by induction, that we can solve P 0 in time O dn3 dg(r)+1 + (n  1)3 dg(r)+3 =

O n3 dg(r)+3 , so we are done.
Finally we must consider M = {x, y}. Since M is minimal we know that G[U2 ] is
connected and there is a path between x and y in U2 . Denote by Q the CSP instance
induced on G[U1 ], together with some path in U2 from x to y. The constraint graph of
Q is a subdivision of the torso of U1 which is either three-connected or has at most three
vertices. In the latter case Q has tree width at most two so, after the addition of unary
constraints on x and y, can be solved in time O(n2 d3 ) (Dechter & Pearl, 1989). If the torso
of U1 is three-connected then the degrees of x and of y in Q are at least three. After the
addition of any
 unary constraints on x and y we can, by Lemma 6.8, solve this case in time
O n3 dg(r)+1 . Hence we can solve Q with all possible unary constraints on x and y which

only allow one value for each of x and y, in time O d2 n3 dg(r)+1 .
For each value of variable x we now know whether it extends to some solution on all
the variables in Q. Similarly, for each value of variable y we know whether it extends to a
solution on all variables in Q. We can express these two restrictions as unary constraints,
u(x) and u(y) on x and y. Lastly we find the binary constraint c(x, y) on x and y which
specifies precisely which pairs of values, allowed by u(x) and u(y), extend to all variables
of U1 . This we obtain by solving the subdivided three-connected instance and seeing which
pairs are disallowed by the subdivided edge in U2  for such pairs we do not set the constraint
relation in c(x, y) to F .
If u(x) allows no values for x then P has no solution and we stop.
Now consider the instance R, which is induced by P 0 on U2 together with the constraints
u(x), u(y) and c(x, y). By construction, P has a solution if and only if R has a solution.
Any Pivot(t) occurring in R must use a pair of values disallowed by c(x, y) since it cannot
occur in P 0 . Suppose that hd, d0 i is disallowed by c(x, y). It follows that the assignment of d
to x, or of d0 to y both extend to a solution of Q but assigning both d to x and d0 to y does
not extend to a solution of the problem induced by P 0 on U1 . By Lemma 6.7 there is a path
of proper constraints between x and y in G[U1 ]. Furthermore, the first constraint along this
path disallows some tuple hd, d1 i and the last constraint disallows some tuple hd2 , d0 i. It
follows that we cannot embed Pivot(r) in the instance R induced on U2 together with the
constraint c(x, y) (otherwise we would have been able to embed it
 in the instance P ).
Since R  CSP(Pivot(r)), we can solve it in time O n3 dg(r)+3 by our inductive hypoth

esis. Thus, in this final case, the complexity is O d2 n3 dg(r)+1 + n3 dg(r)+3 = O n3 dg(r)+3
and we are done.
Theorem 6.1 is important as it gives us a tractable class of CSPs defined by forbidding
a negative pattern which, unlike CSP(Tree), contains problems of unbounded tree width,
and so cannot be captured by structural tractability. This is true even for Pivot(1). As
an example of a class of CSP instances in CSP(Pivot(1)) with unbounded tree width,
consider the n-variable CSP instance Pn with domain {1, . . . , n} whose constraint graph
74

fiTractability of CSP Classes Defined by Forbidden Patterns

is the complete graph and, for each pair of distinct values i, j  {1, . . . , n}, the constraint
on variables vi , vj disallows a single pair of assignments (hvi , ji , hvj , ii). Since each assignment hvi , ji occurs in a single disallowed tuple, Pivot(1) does not occur in Pn , and hence
Pn  CSP(Pivot(1)). To produce an example of a class of instances in CSP(Pivot(1))
with unbounded tree width and which are not in CSP(Negtrans), we can modify Pn by
introducing a Boolean variable vij for each pair i < j and by replacing the constraint on
variables vi , vj by constraints on vi , vij and on vj , vij : the former disallowing the single pair
of assignments (hvi , ji , hvij , 0i) and the latter the pair of assignments (hvj , ii , hvij , 0i). The
pattern Negtrans occurs on each triple of assignments (hvi , ji , hvij , 0i , hvj , ii).
The dichotomy for finite sets of connected binary flat negative patterns now follows
directly from Theorem 6.1 and Corollary 5.6.
Theorem 6.11. Let X be a finite set of connected binary flat negative patterns. Then X is
tractable if and only if there is some   X that is contained in Pivot(r), for some integer
r  ||.
Informally speaking, this dichotomy states that bounding the length of problematic
Pivot(r)-style inference chains leads to tractability, and moreover that when a class of
instances defined by a finite set of forbidden flat patterns is tractable, then it must avoid
problematic inference chains of this form.
This dichotomy easily extends to patterns which are not necessarily connected. When
a negative pattern  is not connected, it can be decomposed into connected patterns corresponding to the connected components of the negative structure graph of . We call these
patterns the connected components of .
Corollary 6.12. Let X be a finite set of binary flat negative patterns. Then X is tractable
if and only if for some   X , each of the connected components of  is contained in
Pivot(r), for some integer r  ||.
Proof. Let X be a finite set of binary flat negative patterns. Let CC() represent the set of
connected components of a pattern , and CC(X ) the union of all the sets CC() (  X ).
Suppose that X is tractable. Consider an arbitrary subset X 0 of CC(X ) such that the
set X 0 contains exactly one connected component from each pattern   X . By Lemma 3.10
CSP(X 0 )  CSP(X ), and hence X 0 is also tractable. Therefore, by Corollary 5.6, there is
some pattern 0  X 0 that occurs in Pivot(r), for some integer r  |0 |. The only way this
can be true for all possible choices of X 0 is if there is some   X such that all connected
components of  occur in Pivot(r), for some integer r  ||.
On the other hand, suppose that for some   X , each of the connected components of
  X occurs in Pivot(r), where r  ||. Let k be the number of connected components
of . Then  occurs in the disjoint union of k copies of Pivot(r). This is tractable by
Theorem 6.1 and k  1 applications of Lemma 4.2. It follows that , and hence X , is
tractable.

7. Conclusion
In this paper we described a framework for identifying classes of CSPs in terms of forbidden
patterns, to be used as a tool for identifying tractable classes of the CSP. We gave several
examples of small patterns that can be used to define tractable classes of CSPs.
75

fiCohen, Cooper, Creed, Marx & Salamon

In the search for a general result, we restricted ourselves to the special case of binary
patterns and binary CSPs. In Theorem 5.2 we showed that CSP(X ) is NP-hard if every
pattern in a set X contains at least one of four patterns (Patterns 8, 9, 10, and 11). Moreover,
we showed that any binary flat negative pattern  that does not contain any of these patterns
must itself be contained within (possibly several copies of) a special type of pattern called
a pivot. Hence, being contained in (several copies of) a pivot is a necessary condition for
pattern  to be tractable. We then showed that forbidding the pivot pattern defines a
tractable class.
Beyond this dichotomy for binary flat negative patterns, it will be interesting to see
what new tractable classes can be defined by more general binary patterns or by non-binary
patterns. In particular, an important area of future research is determining all maximal
tractable classes of problems defined by patterns of some fixed size (given by the number of
variables or the number of variable-value assignments). A further avenue for future research
is the characterisation of the complexity of patterns involving structure that uses more than
just disequalities between groups of variables, such as a total ordering on its variables.

Acknowledgments
The authors acknowledge support from ANR Project ANR-10-BLAN-0210, EPSRC grants
EP/F011776/1 and EP/I011935/1, ERC Starting Grant PARAMTIGHT (No. 280152), and
EPSRC platform grant EP/F028288/1.

References
Bessiere, C., Regin, J.-C., Yap, R. H. C., & Zhang, Y. (2005). An optimal coarse-grained
arc consistency algorithm. Artificial Intelligence, 165 (2), pp. 165185. doi:10.1016/
j.artint.2005.02.004.
Bulatov, A., Jeavons, P., & Krokhin, A. (2005). Classifying the complexity of constraints
using finite algebras. SIAM Journal on Computing, 34 (3), pp. 720742. doi:10.
1137/S0097539700376676.
Bulatov, A. A. (2003). Tractable conservative constraint satisfaction problems. In LICS 03:
Proceedings of 18th IEEE Symposium on Logic in Computer Science, pp. 321330.
doi:10.1109/LICS.2003.1210072.
Bulatov, A. A. (2006). A dichotomy theorem for constraint satisfaction problems on a 3element set. Journal of the ACM, 53 (1), pp. 66120. doi:10.1145/1120582.1120584.
Cohen, D., & Jeavons, P. (2006). The complexity of constraint languages. In Rossi et al.
(Rossi et al., 2006), chap. 8, pp. 245280.
Cohen, D. A. (2003). A new class of binary CSPs for which arc-consistency is a decision
procedure. In CP 03: Proceedings of the 9th International Conference on Principles
and Practice of Constraint Programming, No. 2833 in Lecture Notes in Computer
Science, pp. 807811. Springer-Verlag. doi:10.1007/978-3-540-45193-8_57.
Cooper, M. C., & Escamocher, G. (2012). A Dichotomy for 2-Constraint Forbidden CSP
Patterns. In AAAI 12: Proceedings of the Twenty-Sixth AAAI Conference on Ar76

fiTractability of CSP Classes Defined by Forbidden Patterns

tificial Intelligence. Available from: https://www.aaai.org/ocs/index.php/AAAI/
AAAI12/paper/view/4960/5225.
Cooper, M. C., Jeavons, P. G., & Salamon, A. Z. (2010). Generalizing constraint satisfaction
on trees: Hybrid tractability and variable elimination. Artificial Intelligence, 174 (9
10), pp. 570584. doi:10.1016/j.artint.2010.03.002.
Cooper, M. C., & Zivny, S. (2011a). Hierarchically nested convex VCSP. In CP 11: Proceedings of the 17th International Conference on Principles and Practice of Constraint
Programming, pp. 187194. Springer-Verlag. doi:10.1007/978-3-642-23786-7_16.
Cooper, M. C., & Zivny, S. (2011b). Hybrid tractability of valued constraint problems.
Artificial Intelligence, 175 (910), pp. 15551569. doi:10.1016/j.artint.2011.02.
003.
Costa, M.-C. (1994). Persistency in maximum cardinality bipartite matchings. Operations
Research Letters, 15 (3), pp. 143149. doi:10.1016/0167-6377(94)90049-3.
Dalmau, V., Kolaitis, P. G., & Vardi, M. Y. (2002). Constraint satisfaction, bounded
treewidth, and finite-variable logics. In CP 02: Proceedings of the 8th International Conference on Principles and Practice of Constraint Programming, No. 2470
in Lecture Notes in Computer Science, pp. 310326. Springer-Verlag. doi:10.1007/
3-540-46135-3_21.
Dechter, R., & Pearl, J. (1987). Network-based heuristics for constraint-satisfaction problems. Artificial Intelligence, 34 (1), pp. 138. doi:10.1016/0004-3702(87)90002-6.
Dechter, R., & Pearl, J. (1989). Tree clustering for constraint networks. Artificial Intelligence, 38 (3), pp. 353366. doi:10.1016/0004-3702(89)90037-4.
Dirac, G. A. (1966). Short proof of Mengers graph theorem. Mathematika, 13 (1), pp.
4244. doi:10.1112/S0025579300004162.
Freuder, E. C. (1990). Complexity of K-Tree Structured Constraint Satisfaction Problems.
In AAAI 90: Proceedings of the Eighth National Conference on Artificial Intelligence,
pp. 49. Available from: http://www.aaai.org/Library/AAAI/1990/aaai90-001.
php.
Garey, M. R., & Johnson, D. S. (1979). Computers and Intractability: A Guide to the Theory
of NP-Completeness. W. H. Freeman, San Francisco, CA.
Gottlob, G., Leone, N., & Scarcello, F. (2002). Hypertree decompositions and tractable
queries. Journal of Computer and System Sciences, 64 (3), pp. 579627. doi:10.
1006/jcss.2001.1809.
Green, M. J., & Cohen, D. A. (2003). Tractability by approximating constraint languages.
In CP 03: Proceedings of the 9th International Conference on Principles and Practice
of Constraint Programming, Vol. 2833 of Lecture Notes in Computer Science, pp. 392
406. Springer-Verlag. doi:10.1007/978-3-540-45193-8_27.
Grohe, M. (2006). The structure of tractable constraint satisfaction problems. In MFCS 06:
Proceedings of the 31st Symposium on Mathematical Foundations of Computer Science, Vol. 4162 of Lecture Notes in Computer Science, pp. 5872. Springer-Verlag.
doi:10.1007/11821069_5.
77

fiCohen, Cooper, Creed, Marx & Salamon

Grohe, M. (2007). The complexity of homomorphism and constraint satisfaction problems
seen from the other side. Journal of the ACM, 54 (1), pp. 124. doi:10.1145/
1206035.1206036.
Gyssens, M., Jeavons, P. G., & Cohen, D. A. (1994). Decomposing constraint satisfaction
problems using database techniques. Artificial Intelligence, 66 (1), pp. 5789. doi:
10.1016/0004-3702(94)90003-5.
Jeavons, P., Cohen, D., & Gyssens, M. (1997). Closure properties of constraints. Journal
of the ACM, 44 (4), pp. 527548. doi:10.1145/263867.263489.
Jeavons, P. G., & Cooper, M. C. (1995). Tractable constraints on ordered domains. Artificial
Intelligence, 79 (2), pp. 327339. doi:10.1016/0004-3702(95)00107-7.
Jegou, P. (1993). Decomposition of domains based on the micro-structure of finite
constraint-satisfaction problems. In AAAI 93: Proceedings of the Eleventh National Conference on Artificial Intelligence, pp. 731736. Available from: http:
//www.aaai.org/Library/AAAI/1993/aaai93-109.php.
Marx, D. (2010a). Can you beat treewidth?. Theory of Computing, 6 (1), pp. 85112.
doi:10.4086/toc.2010.v006a005.
Marx, D. (2010b). Tractable hypergraph properties for constraint satisfaction and conjunctive queries. In STOC 10: Proceedings of the 42nd ACM symposium on Theory of
computing, pp. 735744. ACM. doi:10.1145/1806689.1806790.
Regin, J.-C. (1994). A filtering algorithm for constraints of difference in CSPs. In AAAI 94:
Proceedings of the Twelfth National Conference on Artificial Intelligence, Vol. 1, pp.
362367. Available from: http://www.aaai.org/Library/AAAI/1994/aaai94-055.
php.
Robertson, N., & Seymour, P. D. (1986). Graph minors. V. Excluding a planar graph. Journal of Combinatorial Theory, Series B, 41, pp. 92114. doi:10.1016/0095-8956(86)
90030-4.
Rossi, F., van Beek, P., & Walsh, T. (Eds.). (2006). Handbook of Constraint Programming.
Foundations of Artificial Intelligence. Elsevier.
Salamon, A. Z., & Jeavons, P. G. (2008). Perfect constraints are tractable. In CP 08:
Proceedings of the 14th International Conference on Principles and Practice of Constraint Programming, Vol. 5202 of Lecture Notes in Computer Science, pp. 524528.
Springer-Verlag. doi:10.1007/978-3-540-85958-1_35.
van Hoeve, W. J. (2001). The alldifferent Constraint: A Survey. In Proceedings of the 6th
Annual Workshop of the ERCIM Working Group on Constraints. Available from:
http://arxiv.org/abs/cs/0105015v1.
Weigel, R., & Bliek, C. (1998). On reformulation of constraint satisfaction problems. In
ECAI 98: Proceedings of the 13th European Conference on Artificial Intelligence, pp.
254258.

78

fi