Journal of Artificial Intelligence Research 45 (2012) 731-759

Submitted 06/12; published 12/12

Tractable Set Constraints
Manuel Bodirsky

bodirsky@lix.polytechnique.fr

Ecole Polytechnique, LIX
(UMR 7161 du CNRS)
91128 Palaiseau, France

Martin Hils

hils@math.univ-paris-diderot.fr

Institut de Mathematiques de Jussieu
(UMR 7586 du CNRS)
Universite Paris Diderot Paris 7
UFR de Mathematiques
75205 Paris Cedex 13, France

Abstract
Many fundamental problems in artificial intelligence, knowledge representation, and
verification involve reasoning about sets and relations between sets and can be modeled as
set constraint satisfaction problems (set CSPs). Such problems are frequently intractable,
but there are several important set CSPs that are known to be polynomial-time tractable.
We introduce a large class of set CSPs that can be solved in quadratic time. Our class,
which we call EI, contains all previously known tractable set CSPs, but also some new
ones that are of crucial importance for example in description logics. The class of EI set
constraints has an elegant universal-algebraic characterization, which we use to show that
every set constraint language that properly contains all EI set constraints already has a
finite sublanguage with an NP-hard constraint satisfaction problem.

1. Introduction
Constraint satisfaction problems are computational problems where, informally, the input
consists of a finite set of variables and a finite set of constraints imposed on those variables;
the task is to decide whether there is an assignment of values to the variables such that all
the constraints are simultaneously satisfied. Set constraint satisfaction problems are special
constraint satisfaction problems where the values are sets, and the constraints might, for
instance, force that one set y includes another set x, or that one set x is disjoint to another
set y. The constraints might also be ternary (or, more generally, of any finite arity), such
as the constraint that the intersection of two sets x and y is contained in z, in symbols
px X yq  z.
To systematically study the computational complexity of constraint satisfaction problems, it has turned out to be a fruitful approach to consider constraint satisfaction problems
CSPpq where the set of allowed constraints is formed from a fixed finite set  of relations
R  Dk over a (possibly infinite) common domain D. For example, if D equals Q, the
rational numbers, and  is tu where  is the usual order of the rationals, then CSPpq
is the problem of deciding whether a given set of (binary) constraints of the form x  y
has a common solution over the rational numbers. This way of parametrizing the conc
2012
AI Access Foundation. All rights reserved.

fiBodirsky & Hils

straint satisfaction problem by a constraint language  has led to many strong algorithmic
results (e.g., Bulatov & Dalmau, 2006; Idziak, Markovic, McKenzie, Valeriote, & Willard,
2010; Barto & Kozik, 2009; Bodirsky & Kutz, 2007; Bodirsky & Kara, 2009), and to many
powerful hardness conditions for large classes of constraint satisfaction problems (Schaefer,
1978; Bulatov, Krokhin, & Jeavons, 2005; Bulatov, 2003, 2006; Bodirsky & Kara, 2009).
A set constraint language  is a set of relations R  pP pNqqk where the common domain
D  P pNq is the set of all subsets of the natural numbers; moreover, we require that each
relation R can be defined by a Boolean combination of equations over the signature [, \, c,
0, and 1, which are function symbols for intersection, union, complementation, the empty
and full set, respectively. Details of the formal definition of set constraint languages can be
found in Section 3. In Section 4, we give many examples of set constraint languages. The
choice of N is just for notational convenience; we could have selected any infinite set for our
purposes, e.g., Rn instead of N, a more natural choice in spatial reasoning. One may even
replace P pNq by any infinite Boolean algebra (see Theorem 28).
In the following, a set constraint satisfaction problem (set CSP) is a problem of the form
CSPpq for a finite set constraint language . It has been shown by Marriott and Odersky
that all set CSPs are contained in NP.
Drakengren and Jonsson (1998) initiated the search for set CSPs that can be solved
in polynomial time. They showed that CSPpt, ||, uq can be solved in polynomial time,
where
 x  y holds iff x is a subset of or equal to y;
 x || y holds iff x and y are disjoint sets; and
 x  y holds iff x and y are distinct sets.
They also showed that CSPpq can be solved in polynomial time if all relations in  can be
defined by formulas of the form
x1

 y1 _    _ xk  yk _ x0  y0

x1

 y1 _    _ xk  yk _ x0 || y0

or of the form

where x0 , . . . , xk , y0 , . . . , yk are not necessarily distinct variables (Drakengren & Jonsson,
1998, Thm. 20). We will call the set of all relations that can be defined in this way Drakengren and Jonssons set constraint language. It is easy to see that the algorithm they
present runs in time quadratic in the size of the input. On the other hand, they also show
that if  contains the relation defined by x1  y1 _ x2  y2 and the relation defined by
x1  x0 _ x2  x0 then the problem CSPpq is NP-hard (Drakengren & Jonsson, 1998,
Thm. 22).
1.1 Contributions and Outline.
We present a significant extension of Drakengren and Jonssons (1998) set constraint language (Section 4) whose CSP can still be solved in quadratic time in the input size (Section 5); we call this set constraint language EI. Unlike Drakengren and Jonssons set
732

fiTractable Set Constraints

constraint language, our language also contains the ternary relation defined by px X y q  z,
which is a relation that is of particular interest in description logics  we will discuss this
below. Moreover, we show that any further extension of EI contains a finite sublanguage
with an NP-hard set CSP (Section 6), using concepts from model theory and universal
algebra. In this sense, we present a maximal tractable class of set constraint satisfaction
problems.
Our algorithm is based on the concept of independence in constraint languages which
was discovered several times independently in the 90s (Lassez & McAloon, 1989; Jonsson &
Backstrom, 1998; Marriott & Odersky, 1996, see also Koubarakis, 2001; Broxvall, Jonsson,
& Renz, 2002; Cohen, Jeavons, Jonsson, & Koubarakis, 2000); however, we apply this
concept twice in a novel, nested way, which leads to a two level resolution procedure that
can be implemented to run in quadratic time. The technique we use to prove the correctness
of the algorithm is also an important contribution of our paper, and we believe that a similar
approach can be applied in many other contexts; our technique is inspired by the already
mentioned connection to universal algebra.
1.2 Application Areas and Related Literature
We mention three different contexts where set constraints appeared in the literature.
1.2.1 Set Constraints for Programming Languages.
Set constraints find applications in program analysis; here, a set constraint is of the form
X  Y , where X and Y are set expressions. Examples of set expressions are 0 (denoting
the empty set), set-valued variables, and union and intersection of sets, but also expressions
of the form f pZ1 , Z2 q where f is a function symbol and Z1 , Z2 are again set expressions.
Unfortunately, the worst-case complexity of most of the reasoning tasks considered in this
setting is very high, often EXPTIME-hard (for a survey on this, see Aiken, 1994). More
recently, it has been shown that the quantifier-free combination of set constraints (without
function symbols) and cardinality constraints (quantifier-free Pressburger arithmetic) has
a satisfiability problem in NP (Kuncak & Rinard, 2007). This logic (called QFBAPA) is
interesting for program verification (Kuncak, Nguyen, & Rinard, 2006).
1.2.2 Tractable Description Logics.
Description logics are a family of knowledge representation formalisms that can be used to
formalize and reason with concept definitions. The computational complexity of most of the
computational tasks that have been studied for the various formalisms is usually quite high.
However, in the last years a series of description logics, for example EL, EL , Horn-FL0 ,
and various extensions and fragments (Kusters & Molitor, 2002; Baader, 2003; Baader,
Brandt, & Lutz, 2005; Krotzsch, Rudolph, & Hitzler, 2006), has been discovered where
crucial tasks such as e.g. entailment, concept satisfiability and knowledge base satisfiability
can be decided in polynomial time.
Two of the basic assertions that can be made in EL
and Horn-FL0 are C1 ||C2 (there
is no C1 that is also C2 ) and C1 X C2  C3 (every C1 that is C2 is also C3 ), for concept
names C1 , C2 , C3 . These are EI set constraints, and the latter has not been treated in
733

fiBodirsky & Hils

the framework of Drakengren and Jonsson. None of the description logics with a tractable
knowledge base satisfiability problem contains all EI set constraints.
1.2.3 Spatial Reasoning.
Several spatial reasoning formalisms (like RCC-5 and RCC-8) are closely related to set constraint satisfaction problems. These formalisms allow to reason about relations between
regions; in the fundamental formalism RCC-5 (see, e.g., Jonsson & Drakengren, 1997),
one can think of a region as a non-empty set, and possible (binary) relationships are containment, disjointness, equality, overlap, and disjunctive combinations thereof. Thus, the
exclusion of the empty set is the most prominent difference between the set constraint languages studied by Drakengren and Jonsson (1998)  contained in the class of set constraint
languages considered here  and RCC-5 and its fragments. We will see in Section 3 that
the CSP for RCC-5 and the CSPs for all its reducts are set CSPs (Proposition 2).

2. Constraint Satisfaction Problems
To use existing terminology in logic and model theory, it will be convenient to describe
constraint languages by structures (see, e.g., Hodges, 1993). A structure  is a tuple
pD; f1, f2, . . . , R1, R2, . . . q where D is a set (the domain of ), each fi is a function from
Dki  D (where ki is called the arity of fi ), and each Ri is a relation over D, i.e., a subset
of Dli (where li is called the arity of Ri ). For each function fi we assume that there is a
function symbol which we denote by fi , and for each relation Ri we have a relation symbol
which we denote by Ri . Constant symbols will be treated as 0-ary function symbols. The
set  of all relation and function symbols for some structure  is called the signature of ,
and we also say that  is a  -structure. If the signature of  only contains relation symbols
and no function symbols, we also say that  is a relational structure. In the context of
constraint satisfaction, relational structures  are also called constraint languages, and a
constraint language 1 is called a sublanguage (or reduct) of a constraint language  if the
relations in 1 are a subset of the relations in  (and  is called an expansion of 1 ).
Let  be a relational structure with domain D and a finite signature  . The constraint
satisfaction problem for  is the following computational problem, also denoted by CSPpq:
given a finite set of variables V and a conjunction  of finitely many atomic formulas of the
form Rpx1 , . . . , xk q, where x1 , . . . , xk P V and R P  , is  satisfiable in ; that is, does there
exist an assignment s : V  D such that for every constraint Rpx1 , . . . , xk q in the input we
have that pspx1 q, . . . , spxk qq P R ?
The mapping s is also called a solution to the instance  of CSPpq, and the conjuncts
of  are called constraints. Note that we only introduce constraint satisfaction problems
CSPpq for finite constraint languages, i.e., relational structures  with a finite relational
signature.

Example 1. The problem CSPppQ; qq is the problem of deciding whether a given set of
constraints of the form x  y has a solution that simultaneously satisfies all constraints.
734

fiTractable Set Constraints

3. Set Constraint Languages
In this section, we give formal definitions of set constraint languages. Let S be the structure with domain P pNq, the set of all subsets of natural numbers, and with signature
t[, \, c, 0, 1u, where



[ is a binary function symbol that denotes intersection, i.e., [S  X;
\ is a binary function symbol for union, i.e., \S  Y;

 c is a unary function symbol for complementation, i.e., cS is the function that maps
S  N to NzS;
 0 and 1 are constants (treated as 0-ary function symbols) denoting the empty set
and the full set N, respectively.

H

Sometimes, we simply write [ for the function [S and \ for the function \S , i.e., we do
not distinguish between a function symbol and the respective function. We use the symbols
[, \ and not the symbols X, Y to prevent confusion with meta-mathematical usages of X
and Y in the text.
A set constraint language is a relational structure whose relations have a quantifier-free
definition in S. We always allow equality in first-order formulas, and the equality symbol
 is always interpreted to be the true equality relation on the domain of the structure. We
write x  y as an abbreviation for x [ y  x.
Example 2. The ternary relation px, y, z q
definition z [ px [ y q  x [ y over S.

P P pN q3 | x [ y  z

(

has the quantifier-free

Theorem 1 (See Marriott & Odersky, 1996, Proposition 5.8). Let  be a set constraint
language with a finite signature. Then CSPpq is in NP.
It is easy to see that there are NP-hard set CSPs, as shown in the next example.
Example 3. Consider the set constraint language  that contains the eight relations

tpx, y, zq | x  1 _ y  1 _ z  1u
tpx, y, zq | x  1 _ y  1 _ z  1u
tpx, y, zq | x  1 _ y  1 _ z  1u
tpx, y, zq | x  1 _ y  1 _ z  1u
tpx, y, zq | x  1 _ y  1 _ z  1u
tpx, y, zq | x  1 _ y  1 _ z  1u
tpx, y, zq | x  1 _ y  1 _ z  1u
tpx, y, zq | x  1 _ y  1 _ z  1u .
Then the set CSP for those relations is the well-known 3-SAT problem, which is NPcomplete (Garey & Johnson, 1978).
It is well-known that the structure pP pNq; \, [, c, 0, 1q is a Boolean algebra, with
735

fiBodirsky & Hils

 0 playing the role of false, and 1 playing the role of true;
 c playing the role of


;

[ and \ playing the role of ^ and _, respectively.

We refer to the work of Koppelberg (1989) for background on Boolean algebras.
To not confuse logical connectives with the connectives of Boolean algebras, we always
use the symbols [, \, and c instead of the usual function symbols ^, _, and in Boolean
algebras. To facilitate the notation, we also write x instead of cpxq, and x  y instead of
p x  y q.
We assume that all terms t over the functional signature
t[, \, c, 0, 1u are written in


(inner) conjunctive normal form (CNF), i.e., as t  ni1 nj i 1 lij where lij is either of the
form x or of the form x for a variable x. Note that every term over t[, \, c, 0, 1u can be rewritten into an equivalent term of this form, using the usual laws of Boolean algebras (Boole,
1847). We allow the special
case n  0 (in which case t becomes 1), and the special case
ni
ni  0 (in which case j 1 lij becomes 0). We refer to ci : tlij | 1  j  ni u as an
(inner) clause of t, and to lij as an (inner) literal of ci . We say that a set of inner clauses
is satisfiable if there exists an assignment from V  P pNq such that for all inner clauses,
the
union of the evaluation of all literals equals N (this is the case if and only if the formula
n
i1 ci  1 has a satisfying assignment).
Example 4. Inequality x  y on P pNq can be equivalently written as py \ xq[px \ y q  1;
in this formula, we have two inner clauses, each with a positive and a negative inner literal.
We assume that all quantifier-free formulas  over the signature
t[, \, c, 0, 1u are written

mi
in (outer) conjunctive normal form (CNF), i.e., as   m
j 1 Lij where Lij is either
i1
of the form t  1 (a positive (outer) literal ) or of the form t  1 (a negative (outer) literal ).
Again, it is well-known and easy to see that we can for every quantifier-free formula find
a formula in this form which is equivalent to it in every Boolean algebra. We refer to
Ci : tLij | 1  j  mi u as an (outer) clause of , and to Lij as an (outer) literal of Ci .
Whenever convenient, we identify  with its set of clauses.
Example 5. Consider the formula px  y ^ y  z q _ px  y ^ y  z q. It can be rewritten
as px  y _ y  z q^px  y _ y  z q. When we subsequently replace inequality literals x  y
by py \ xq [ px \ y q  1 (see Example 4), we arrive at a formula which is in the discussed
normal form: it has two outer clauses, one with two positive outer literals, and the other
with two negative outer literals.
As mentioned in the introduction, all CSPs for reducts of RCC-5 (and therefore also
many reducts of RCC-8) can be formulated as set CSPs. The network satisfaction problem for RCC-5 can be seen as the CSP for the following structure RCC-5 with domain
P pNqztHu and all binary relations given as follows: for each relation R of RCC-5 there
exists a quantifier-free t\, [, c, 0, 1u-formula px1 , x2 q such that ps1 , s2 q P R if and only if
both s1 and s2 are non-empty, and ps1 , s2 q is true in S. It is clear that there are only
finitely many inequivalent quantifier-free formulas over the language t\, [, c, 0, 1u, and
hence RCC-5 has only finitely many relations.
736

fiTractable Set Constraints

Proposition 2. Let  be a reduct of RCC-5. Then there exists a set constraint language 
such that CSPpq and CSPpq are the same problem.
Proof. Let 1 , . . . , n be the formulas the define the relations of  (which has domain
P pNqztHu). Let  be the structure with domain P pNq and relations R1 , . . . , Rn defined
by 1 , . . . , n in S. That is, the only difference between  and  is the additional element
tHu, which appears in none of the relations of . We have to prove that every finite
conjunction  of atomic formulas of the form Ri px1 , . . . , xk q is satisfiable in  if and only if
the conjunction is satisfiable in . If  is satisfiable over  then it is clearly also satisfiable
over  since  is an induced substructure of . Conversely, if  is satisfiable over , then
any solution must have the property that if spxi q  H, then xi does not appear in any
constraint (since the constraints force that their arguments are non-empty). Hence, setting
spxi q to any non-empty subset of N will still be a solution, which implies the claim.
Proposition 2 shows that the class of set CSPs contains the class of all CSPs for reducts
of RCC-5. The inclusion is clearly strict: there are set CSPs that cannot be formulated as
CSPs for reducts of RCC-5, since relations in set constraint languages can have arbitrary
arity, while reducts of RCC-5 only contain binary relations.

4. Horn-Horn Set Constraints
In this section, we study Horn-Horn set constraints, a class of set constraints which admits
an intuitive syntactic description and which is thus easy to define. Universal algebraic
considerations on this class in Section 4.2 lead us to another class of set constraints, called
EI and introduced in Section 4.3. This class strictly contains the class of Horn-Horn set
constraints. Its universal algebraic description is the key for the maximality result which
we will prove in Section 6. As for tractability, set constraint languages from EI allow for a
(linear-time) reduction to satisfiability of Horn-Horn clauses (see Proposition 22). We note
that these classes of set constraints (Horn-Horn and EI) have not been studied before.
4.1 Horn-Horn Relations
Definition 3. A quantifier-free formula is called Horn-Horn if
1. every outer clause is outer Horn, i.e., contains at most one positive outer literal, and
2. every inner clause of positive outer literals is inner Horn, i.e., contains at most one
positive inner literal.
A relation R  P pNqk is called
 outer Horn if it can be defined over S by a conjunction of outer Horn clauses;
 inner Horn if it can be defined over S by a formula of the form pc1 [    [ ck q
where each ci is inner Horn;

1

 Horn-Horn if it can be defined by a Horn-Horn formula over S.
Example 6. Inequality

 is Horn-Horn: recall that it may defined by py \ xq[px \ yq  1.
737

fiBodirsky & Hils

Example 7. Using the previous example, the relation
easily be seen to be Horn-Horn, too.
Example 8. The ternary relation tpx, y, z q | x [ y
has the Horn-Horn definition x \ y \ z  1.

tpx, y, u, vq | x  y _ u  vu can

 zu, which we have encountered above,

Proposition 4. Drakengren and Jonssons set constraint language only contains Horn-Horn
relations.
Proof. The disjointness relation || has the definition x \ y  1, so is inner Horn. The
inequality relation  is Horn-Horn since both inner clauses in its definition py \ xq[px \ y q 
1 have only one positive inner literal. The inclusion relation x  y has the definition
y \ x  1, so is inner Horn.
Horn-Horn is preserved under adding additional outer disequality literals to the outer
clauses, so all relations considered in Drakengren and Jonssons language are Horn-Horn.
4.2 Universal Algebraic Preliminaries
As we will see in this section, the class of Horn-Horn formulas is preserved by several
important functions defined on the set of subsets of natural numbers.
Definition 5.
 Let i : pP pNqq2  P pNq be the function that maps a pair of sets pS1 , S2 q
to the set t2a | a P S1 u Y t2a 1 | a P S2 u;

 denote by Fin the set of finite non-empty subsets of N, and let F : P pNq  P pFin q,
F pS q : tS0

 S | S0 is finite and non-emptyu ;

 let G : N  Fin be a bijection (since both sets are countable, such a bijection exists);
 let e : P pNq  P pNq be defined by
epS q  tG1 pT q | T

P F pS qu ;

 let ei be the function defined by eipx, y q  epipx, y qq.
Intuitively, the functions e and ei are designed so that they forget unions (this will be
formalized in Definition 34), while preserving the other basic operations in S (see Lemma
11 and Proposition 8 for the case of e).
Definition 6. Let f : pP pNqqk  P pNq be a function, and R  P pNql be a relation. Then
we say that f preserves R if the following holds: for all a1 , . . . , ak P pP pNqql we have that
pf pa11, . . . , ak1 q, . . . , f pa1l , . . . , akl qq P R if ai P R for all i  k. If f does not preserve R, we
also say that f violates R. We say that f strongly preserves R if for all a1 , . . . , ak P pP pNqql
we have that pf pa11 , . . . , ak1 q, . . . , f pa1l , . . . , akl qq P R if and only if ai P R for all i  k. If  is
a first-order formula that defines a relation R over S, and f preserves (strongly preserves)
R, then we also say that f preserves (strongly preserves) . Finally, if g : pP pNqql  P pNq is
a function, we say that f preserves (strongly preserves) g if it preserves (strongly
preserves)
(
the graph of g, i.e., the relation px1 , . . . , xl , g px1 , . . . , xl qq | x1 , . . . , xl  N .
738

fiTractable Set Constraints

Note that if an injective function f preserves a function g, then it also strongly preserves
g.
Example 9. Consider the function f : pP pNqq2  P pNq, px, y q  x \ y. Then f preserves
, since x \ y  x1 \ y1 whenever x  x1 and y1  y. On the other hand, f does not strongly
preserve , as is shown by f pN, Hq  f pH, Nq.
Fact 7. The mapping i is an isomorphism between S2 and S.
Proof. The mapping
 i can be inverted by the mapping that sends S  N to ta | 2a P
S u, ta | 2a 1 P S u . It is straightforward to verify that i strongly preserves 0, 1, c, \, [.
 Clearly, ipx, y q  H if and only if x  y

 H.

 Similarly, since the natural numbers are partitioned by the even and odd numbers,
ipx, y q  N if and only if x  y  N.
 Let S1 and S2 be subsets of N. To verify that i preserves c we have to show that
ipcpS1 , S2 qq, which is by definition equal to ipS1 , S2 q, equals cpipS1 , S2 qq. Suppose
that a  2a1 . Then:
a P i pS 1 , S 2 q  a 1

P S1

 a1 R S1
 2a1 R ipS1, S2q
 a P ipS1, S2q

The argument for a  2a1
even strongly preserves c.

1 is analogous. Thus, i preserves c. Since i is injective, it

 Let pS1 , S2 q and pT1 , T2 q be from pP pNq2 . We have to show that ippS1 , S2 q\pT1 , T2 qq,
which is by definition equal to ipS1 \ T1 , S2 \ T2 q, equals ipS1 , S2 q \ ipT1 , T2 q. With
a  2a1 as before:
a P ipS1 \ T1 , S2 \ T2 q  a1

P pS1 \ T1q

 2a1 P ipS1, S2q \ ipT1, T2q

The argument for a  2a1 1 is again analogous. Thus, i preserves
injective, it even strongly preserves \.
The verification for

\.

Since i is

[ is similar to that for \.

Proposition 8. The function e has the following properties.
 e is injective,

[, and
for x, y, z P P pNq such that x \ y 
epxq \ epy q  epz q.

 e strongly preserves 1, 0, and


z, not x

739



y, and not y



x, we have that

fiBodirsky & Hils

Proof. We verify the properties one by one. Since G is bijective, epxq  epy q if and only if
x and y have the same finite subsets. This is the case if and only if x  y, and hence e is
injective. Thus, to prove that e strongly preserves 1, 0, and [, it suffices to check that e
preserves 1, 0, and [.
Since G is bijective, we have that GpNq equals the set of all finite subsets of N, and
hence epNq  N, which shows that e preserves 1. We also compute epHq  G1 pF pHqq 
G1 pHq  H.
Next, we verify that for all x, y P P pNq we have epxq [ epy q  epx [ y q. Let a P N be
arbitrary. We have a P epxq [ epy q if and only if Gpaq P F pxq X F py q. By definition of F
and since Gpaq is a finite subset of N, this is the case if and only if Gpaq P F px [ y q. This
is the case if and only if a P epx [ y q, which concludes the proof that e preserves [.
We verify that if x \ y  z, not x  y, and not y  x, then epxq \ epy q  epz q. First
observe that for all u, v  N with u  v we have epuq  epv q since e preserves [. This
implies that epxq \ epy q  epz q. Since x  y and y  x, there are a, b such that a P x,
a R y, b P y, b R x. Then we have that ta, bu P F pz q, but ta, bu R F pxq Y F py q. Hence,
G1 pta, buq P epz q, but G1 pta, buq R epxq \ epy q. This shows that epz q  epxq \ epy q.
Note that in particular e preserves , , and ||. Moreover, epcpxqq  cpepxqq: this
follows from preservation of ||, since x||cpxq, and therefore epxq||epcpxqq, which is equivalent
to the inclusion above. Both e and i strongly preserve [, 0, and 1, and therefore also ei
strongly preserves [, 0, and 1.
The following is a direct consequence of the fact that isomorphisms between k and 
preserve Horn formulas over ; since the simple proof is instructive for what follows, we
give it for the special case that is relevant here.
Proposition 9. Outer Horn relations are preserved by i.
Proof. Let  be a conjunction of outer Horn clauses with variables V . Let tt0  1, t1 
1, . . . , tk  1u be an outer clause of . Let u, v : V  P pNq be two assignments that satisfy
this clause. Let w : V  P pNq be given by x  ipupxq, v pxqq. Suppose that w satisfies
tj  1 for all 1  j  k. Since i is injective we must have that tj  1 for both u and v for
1  j  k, and therefore neither assignment satisfies the negative literals. Hence, u and v
must satisfy t0  1. Since i is an isomorphism between S2 and S, it preserves in particular
t0  1, and hence w also satisfies t0  1.
Proposition 10. Inner Horn relations are strongly preserved by e.






Proof. Observe that x \ p j y j q  1 is equivalent to x [ p j yj q  j yj , which is strongly
preserved by e since e strongly preserves [. This clearly implies the statement.
Note that Proposition 9 and Proposition 10 imply that ei strongly preserves inner Horn
relations. We later also need the following.

 N, where k  1. Then the following are equivalent.
epx1 q \    \ epxk q \ epy1 q \    \ epyl q  1.

there exists an i  k such that xi \ p j y j q  1.

Lemma 11. Let x1 , . . . , xk , y1 , . . . , yl
1.
2.

740

fiTractable Set Constraints

3. there exists an i  k such that epxi q \ p


j

epyj qq  1.

 0, we have that j yjl  1 if and only if jl epyj q  1.
Proof. For the implication 
from p1q to p2q, suppose that there is for every i  k an ai P N
such that ai R Xi : xi \ p j y j q. Let c be G1 ta1 , a2 , . . . , ak u . Then for each i  k, we


have that c R epxi q \ j l epyj q. To see this, first observe that ai P j l yj [ xi . Therefore,
ta1, . . . , ak u P jl F pyj q [ F pxiq for all i  k. We conclude that c R epx1q \    \ epxk q \
epy1 q \    \ epyl q.
The implication p2q  p3q follows directly from Proposition 10. The implication p3q 
p1q is trivial. The second statement is a direct consequence of Proposition 10.
For k

Proposition 12. Every Horn-Horn relation is preserved by e and i, and so in particular
by ei.
Proof. Suppose that R has a Horn-Horn definition  over S with variables V . Since R is
in particular outer Horn, it is preserved by i by Proposition 9.
Now we verify that R is preserved by e. Let u : V  P pNq be an assignment that
satisfies . That is, u satisfies at least one literal in each outer clause of . It suffices to
show that the assignment v : V  P pNq defined by x  epupxqq satisfies the same outer
literal. Suppose first that the outer literal is positive; because  is Horn-Horn, it is of the
form x \ y1 \    \ yl  1 or of the form y1 \    \ yl  1, which is preserved by e by
Lemma 11.
Now, suppose that the outer literal is negative, that is, of the form x1 \    \ xk \ y1 \
   \ yl  1 for some k  0. We will treat the case k  1, the other case being similar.
Suppose for contradiction that v px1 q \ 
  \ vpxk q \ vpy1q \    \ vpyl q  1. By Lemma 11,
there exists an i  k such that upxi q \ p j upy j qq  1. But then we have in particular that
upx1 q \    \ upxk q \ upy1 q \    \ upyl q  1, in contradiction to the assumption that u
satisfies .
4.3 EI Set Constraints
In this section we introduce the class of EI set constraints, show that it strictly contains
all Horn-Horn relations, give several examples and non-examples. Then we present an
algorithmic reduction from CSPs for EI set constraints to satisfiability for finite sets of
Horn-Horn clauses.
Definition 13. The set of all relations with a quantifier-free definition over S that are
preserved by the operation ei is denoted by EI.
Remark. Note that the definition of the operation ei (Definition 5) involved a bijection G
between N and Fin ; we will see later (Proposition 36 and Proposition 37) that the class
EI is independent from the precise choice of G.
Recall from Proposition 12 that EI contains all Horn-Horn relations. We now present
examples of relations that are not from EI, and examples of relations that are in EI but
not Horn-Horn.
741

fiBodirsky & Hils

Example 10. We give an example of a relation that is clearly not from EI. The relation
R  tpx, y q | x \ y  1u is violated by ei: consider S1  t2a | a P Nu and S2  t2a
1 | a P Nu. Then pS1 , S2 q P R, and since i is an isomorphism between S2 and S we
also have that pipS1 , S1 q, ipS2 , S2 qq P R. Since neither ipS1 , S1 q  ipS2 , S2 q nor ipS2 , S2 q 
ipS1 , S1 q, we get that epipS1 , S1 qq \ epipS2 , S2 qq  ep1q  1 by Proposition 8. Therefore,
peipS1, S1q, eipS2, S2qq R R which is what we wanted to show.
Example 11. The relation R  tpx, y, z q | px  y q _ py  z qu is also not preserved by
ei: note that p0, 1, 1q, p0, 0, 1q P R, but eip0, 0q, eip1, 0q, and eip1, 1q are pairwise distinct
since ei is injective.
Example 12. The formula

p x [ y  xq
^ px [ y  yq
^ pv  1 _ u  1 _ x \ y  1q
is clearly not Horn-Horn. However, the relation defined by the formula is from EI: if
px1, y1, u1, u2q und px2, y2, u2, v2q are from that relation, then neither ipx1, x2q  ipy1, y2q nor
ipy1 , y2 q  ipx1 , x2 q. By Proposition 8, peipx1 , x2 q, eipy1 , y1 q, eipu1 , u2 q, eipv1 , v2 qq satisfies
the formula. There is no equivalent Horn-Horn formula, since the formula is not preserved
by i.
Example 13. The formula ppx \ y  1q _ pu \ v  1qq ^ px \ y  1q ^ px \ y  1q is not
Horn-Horn. However, it is preserved by e and by i: the reason is that one of its clauses has
the negative literal x \ y  1, and the conjuncts tx \ y  1u and tx \ y  1u. Therefore,
for every tuple t P R the tuple eptq satisfies x \ y  1 and is in R as well. By Proposition 9,
R is preserved by i. In this case, the authors suspect that there is no equivalent Horn-Horn
formula. More generally, it is open whether there exist formulas that are preserved by e and
i, but that are not equivalent to a Horn-Horn formula.
Corollary 14. The class of Horn-Horn relations is a proper subclass of EI.
Proof. Proposition 12 shows that EI contains all Horn-Horn relations. Example 12 shows
that the inclusion is strict.
We prepare now some results that can be viewed as a partial converse of Proposition 12.
Definition 15. A quantifier-free formula  (in the syntactic form described at the end of
Section 3) is called reduced if if every formula obtained from  by removing an outer literal
is not equivalent to  over S.
We note that a slightly different notion of a reduced formula has been introduced by
Bodirsky, Chen, and Pinsker (2010). The variant we are using here is better suited for our
purposes.
Lemma 16. In the structure S, every quantifier-free formula is equivalent to a reduced
formula.
742

fiTractable Set Constraints

Proof. It is clear that every quantifier-free formula can be written as a formula  in CNF
and in the form as we have discussed it after Theorem 1. We now remove successively outer
literals as long as this results in an equivalent formula.
We first prove a partial converse of Proposition 9.
Proposition 17. Let  be a reduced formula that is preserved by i. Then each outer clause
of  is Horn.
Proof. Let V be the set of variables of . Assume for contradiction that  contains an outer
clause with two positive literals, t1  1 and t2  1. If we remove the literal t1  1 from
its clause C, the resulting formula is inequivalent to , and hence there is an assignment
s1 : V  P pNq that satisfies none of the literals of C except for t1  1. Similarly, there is
an assignment s2 : V  P pNq that satisfies none of the literals of C except for t2  1. By
injectivity of i, and since i strongly preserves c, [, \, and 1, the assignment s : V  P pNq
defined by x  ips1 pxq, s2 pxqq does not satisfy the two literals t1  1 and t2  1. Since i
strongly preserves c, \, [, none of the other literals in C is satisfied by those mappings as
well, in contradiction to the assumption that  is preserved by i.
Definition 18. Let V be a set of variables, and s : V  P pNq be a mapping. Then a
function from V  P pNq of the form x  epspxqq is called a core assignment.
Lemma 19. For every quantifier-free formula  there exists a formula  such that all inner
clauses are inner Horn, and such that  and  have the same satisfying core assignments.
If  is preserved by ei, then the set of all satisfying core assignments of  is closed under
ei.
Proof. Suppose that  has an outer clause C with a positive outer literal t  1 such that t
contains an inner clause c : x1 \    \ xk \ y 1 \    \ y l that is not Horn, i.e., k  2. Then
we replace the outer literal t  1 in  by k literals t1  1, . . . , tk  1 where ti is obtained
from t by replacing c by xi \ y 1 \    \ y l .
We claim that the resulting formula 1 has the same set of satisfying core assignments.
Observe that xi \ y 1 \    \ y l  c, and hence ti  1 implies t  1. An arbitrary satisfying
assignment of 1 satisfies either one of the positive outer literals ti  1, in which case that
observation shows that it also satisfies , or it satisfies one of the other outer literals of C,
in which case it also satisfies this literal in . Hence, 1 implies . Conversely, let s be a
satisfying core assignment of . If s satisfies a literal from C other than t  1, then it also
satisfies this literal in 1 , and s satisfies 1 . Otherwise, s must satisfy t  1, and hence
spx1 q\  \ spxk q\ spy1 q\  \ spyl q  1. Since s is a core assignment, Lemma 11 implies
that there exists an i  k such that spxi q \ spy1 q \    \ spyl q  1. So s satisfies 1 .
Suppose that  has an outer clause C with a negative outer literal t  1 such that t
contains an inner clause c : x1 \    \ xk \ y 1 \    \ y l that is not Horn, i.e., k  2.
Then we replace the clause C in  by k clauses C1 , . . . , Ck where Ck is obtained from C
by replacing c with xi \ y 1 \    \ y l .
We claim that the resulting formula 1 has the same set of satisfying core assignments.
Observe that x1 \    \ xk \ y 1 \    \ y l  1 implies that xi \ y 1 \    \ y l  1, for every
i  k. The observation shows that an arbitrary assignment of  is also an assignment of 1 .
743

fiBodirsky & Hils

Conversely, let s be a satisfying core assignment of 1 . If s satisfies one of the other literals
of C other than t  1, then s satisfies . Otherwise, s must satisfy xi \ y 1 \  \ y l  1 for
all i  k, and by Lemma 11 we have that s also satisfies x1 \    \ xk \ y 1 \    \ y l  1.
We perform these replacements until we obtain a formula 1 where all inner clauses are
Horn; this formula satisfies the requirements of the first statement of the lemma.
To prove the second statement, let u, v : V  P pNq be two satisfying core assignments
of 1 . Since 1 and  have the same satisfying core assignments, u and v also satisfy . Then
the mapping w : V  P pNq given by x  eipupxq, v pxqq is a core assignment, and because
ei preserves , the mapping w satisfies . Since  and 1 have the same core assignments,
w is also a satisfying assignment of 1 , which proves the statement.
We now single out a technical condition which guarantees, under some extra condition
(see Proposition 21) that formulas satisfying a certain universl algebraic property are HornHorn. This will allow us to perform a reduction from a CSP associated to a (finite) set
constraint languages from EI to satisfiability of Horn-Horn clauses.
Definition 20. A quantifier-free formula  (in the syntactic form described at the end of
Section 3) is called strongly reduced if every formula obtained from  by removing an outer
literal does not have the same set of satisfying core assignments over S.
Proposition 21. Let  be a strongly reduced formula all of whose inner clauses are Horn.
If the set of satisfying core assignments of  is closed under ei, then  is Horn-Horn.
Proof. Let V be the set of variables of . It suffices to show that all clauses of  are outer
Horn. Assume for contradiction that  contains an outer clause with two positive literals,
t1  1 and t2  1. If we remove the literal t1  1 from its clause C, the resulting formula
has strictly less satisfying core assignments; this shows the existence of a core assignment
s1 : V  P pNq that satisfies none of the literals of C except for t1  1. Similarly, there exists
a core assignment s2 : V  P pNq that satisfies none of the literals of C except for t2  1.
By assumption, the inner clauses of t1 and t2 are Horn. We claim that the assignment
s : V  P pNq defined by x  eips1 pxq, s2 pxqq does not satisfy the clause C. Since ei
strongly preserves inner Horn clauses, we have that s does not satisfy t1  1 _ t2  1. For
the same reasons s does not satisfy any other literals in C; this contradicts the assumption
that the satisfying core assignments for  are preserved by ei.
Satisfiability of Horn-Horn clauses is the computational problem to decide whether,
given a finite set S of Horn-Horn clauses, there is a satisfying assignment for S.
Proposition 22. Let  be a finite set constraint language from EI. Then CSPpq can be
reduced in linear time to satisfiability of Horn-Horn clauses.
Proof. Let  be an instance of CSPpq, and let V be the set of variables that appear in
. For each constraint Rpx1 , . . . , xk q from , let R be the definition of R over S. By
Lemma 19, there exists a formula R that has the same satisfying core assignments as R
and where all inner clauses are Horn; moreover, since R is preserved by ei, the lemma
asserts that the set of all satisfying core assignments of R is preserved by ei. We can
assume without loss of generality that R is strongly reduced; this can be seen similarly to
Lemma 16. By Proposition 21, the formula R is Horn-Horn.
744

fiTractable Set Constraints

Let  be the set of all Horn-Horn clauses of formulas R px1 , . . . , xk q obtained from constraints Rpx1 , . . . , xk q in  in the described manner. We claim that  is a satisfiable instance
of CSPpq if and only if  is satisfiable. This follows from the fact that for each constraint
Rpx1 , . . . , xk q in , the formulas R and R have the same satisfying core assignments, and
that both R and R are preserved by ei (for R this follows from Proposition 12), so in
particular by the function x  eipx, xq.
Note that in Proposition 22 we reduce satisfiability for EI to satisfiability for a proper
subclass of Horn-Horn set constraints: while for general Horn-Horn set constraints we allow
that inner clauses of negative outer literals are not Horn, the reduction only produces HornHorn clauses where all inner clauses are Horn.

5. Algorithm for Horn-Horn Set Constraints
We present an algorithm that takes as input a set  of Horn-Horn clauses and decides
satisfiability of  over S  pP pNq; \, [, c, 0, 1q in time quadratic to the length of the input.
By Proposition 22, this section will therefore conclude the proof that CSPpq is tractable
when all relations in  are from EI.
As mentioned in the introduction, our algorithm is based on two procedures, both
resolution-like. The inner procedure is essentially the well-known positive unit resolution
procedure for Horn-SAT, and the outer procedure is basically an algorithm that has been
used in the literature about independence in constraint satisfaction (see, e.g., Jonsson &
Backstrom, 1998; Koubarakis, 2001; Broxvall et al., 2002; Cohen et al., 2000). Our contribution in this section is the way how to nest these two algorithms to obtain a polynomial-time
decision procedure for satisfiability of Horn-Horn clauses.
We start by discussing the first procedure of our algorithm, which we call the inner
resolution algorithm. As in the case of Boolean positive unit resolution (Dowling & Gallier,
1984) one can implement the procedure Inner-Res such that it runs in linear time in the
input size.
Lemma 23. Let  be a finite set of inner Horn clauses. Then the following are equivalent.
1.



  1 is satisfiable over S.

2. Inner-Respq from Figure 1 accepts.
3.



  1 has a solution whose image is contained in


tH, Nu.

Proof. It is obvious that   1 is unsatisfiable when Inner-Respq rejects; in fact, for
all
inner clauses c derived by Inner-Res from , the formula c  1 is logically implied by

  1. Conversely, if the algorithm accepts then we can set all eliminated variables to
N and all remaining variables to H, which satisfies all clauses: in the removed clauses the
positive literal is satisfied, and in the remaining clauses we have at least one negative literal
at the final stage of the algorithm, and all clauses with negative literals at the final stage
of the algorithm are satisfied.




The proof of the previous lemma shows that   1 is satisfiable over S if and only if
  1 is satisfiable over the two-element Boolean algebra. As we will see in the following,
745

fiBodirsky & Hils

Inner-Res()
// Input: A finite set  of inner Horn clauses
// Accepts iff   1 is satisfiable
During the entire algorithm:
if  contains an empty clause, then reject.
Repeat := true
While Repeat = true do
Repeat := false
If  contains a positive unit clause txu then
Repeat := true
Remove all clauses where the literal x occurs.
Remove the literal x from all clauses.
End if
Loop
Accept



Figure 1: Inner Resolution Algorithm.
this holds more generally (and not only for inner Horn clauses). The following should be
well-known, and can be shown with the same proof as given by Koppelberg (1989) for the
weaker Proposition 2.19 there. We give the proof here for the convenience of the reader.
Fact 24. Let t1 , t2 be terms over

t[, \, c, 0, 1u. Then the following are equivalent:

 1 ^ t2  1 is satisfiable over the two-element Boolean algebra;
t1  1 ^ t2  1 is satisfiable over all Boolean algebras;
t1  1 ^ t2  1 is satisfiable over some Boolean algebra;
t1  1 ^ t2  1 is satisfiable over some finite Boolean algebra.

1. t1
2.
3.
4.

Proof. Obviously, (1) implies (2), and (2) implies (3).
For (3) implies (4), assume that t1  1 ^ t2  1 has a satisfying assignment in some
Boolean algebra C. Let x1 , . . . , xn be the variables which occur in t1 or t2 , and let xi  ci
be a satisfying assignment. Then t1  1 ^ t2  1 is satisfiable in the Boolean sub-algebra
n
C1 of C generated by tc1 , . . . , cn u, and C1 is finite (it has at most 2p2 q elements).
For (4) implies (1), first note that any finite Boolean algebra is isomorphic to the Boolean
algebra pP pX q; [, \, c, 0, 1q of subsets of some finite set X. If x P X, consider the map hx :
P pX q  t0, 1u, hpY q : 1 if x P Y , and hpY q  0 otherwise. Then hx is a homomorphism
of Boolean algebras. In particular, this shows that for every non-zero element a of a finite
Boolean algebra C, there is a homomorphism h from C to the two-element Boolean algebra
such that hpaq  0. Now suppose (4), and assume that t1  1 ^ t2  1 has a satisfying
assignment in some finite Boolean algebra C. Let c be the element denoted by t2 in C
under this assignment, so c  1. Now let h be a homomorphism from C to t0, 1u such that
hpcq  0, i.e. hpcq  1. By construction, the image of the satisfying assignment under h is
a satisfying assignment of t1  1 ^ t2  1 in t0, 1u.
746

fiTractable Set Constraints

The same statement for t1  1 instead of t1  1 ^ t2  1 has been given in Proposition
2.19 (Koppelberg, 1989). Fact 24 has the following consequence that is crucial for the way
how we use the inner resolution procedure in our algorithm.
Lemma 25. Let  be a finite set of inner Horn clauses. The following are equivalent:
1. Inner-RespYtx1 , . . . , xk , y0 , . . . , yl uq rejects.


 1 over S.


Proof.
  1 implies that x1 \    \ xk \ y 1 \    \ y l  1 if and only if
 
1 ^ x1 \   
\ xk \ y1 \    \ yl  1 is unsatisfiable over S. By Fact 24, this is the case if
and only if   1 ^ x1 \    \ xk \ y 1 \    \
y  1 is unsatisfiable over the 2-element
 l
Boolean algebra, which is the case if and only if   1 ^ x1 \  \ xk \ y 1 \  \ y l  0 is
2.

  1 implies that x1 \    \ xk \ y 1 \    \ y l

unsatisfiable over the two-element Boolean algebra. As we have seen in Lemma 23, this in
turn holds if and only if Inner-RespYtx1  1, . . . , xk  1, y1  1, . . . , yl  1uq rejects.
Outer-Res()
// Input: A finite set  of Horn-Horn clauses
// Accepts iff  is satisfiable over pP pNq; [, \, c, 0, 1q
During the entire algorithm:
if  contains an empty clause, then reject.
Repeat := true
While Repeat = true do
Repeat := false
Let  be the set of all inner Horn clauses of terms t
from positive unit clauses tt  1u in .
If Inner-Res rejects , then reject.
For each negative literal t  1 in clauses from 
For each inner clause D  tx1 , . . . , xk , y 1 , . . . , y l u of t
Call Inner-Res on
 Y tx1  1, . . . , xk  1, y0  1, . . . , yl  1u
If Inner-Res rejects then remove clause D from t
End for
If all clauses in t have been removed, then
Remove outer literal t  1 from its clause
Repeat := true
End for
Loop
Accept

Figure 2: Outer Resolution Algorithm.
Theorem 26. The algorithm Outer-Res in Figure 2 decides satisfiability for sets of HornHorn clauses in quadratic time.
Proof. We first argue that if the algorithm rejects , then  has indeed no solution. First
note that during the whole argument, the set of clauses  has the same satisfying tuples
747

fiBodirsky & Hils

(i.e., the corresponding formulas are equivalent): Observe that only negative literals get
removed from clauses, and that a negative literal t  1 only gets removed from a clause
when Inner-Res rejects  Y tx1  1, . . . , xk  1, y0  1, . . . , yl  1u for each inner clause
tx1, . . . , xk , y1, . . . , yl u of t. By Lemma 25, if Inner-Res rejects  Ytx1  1, . . . , xk  1, y0 
1, . . . , yl  1u then  implies that x1 \    \ xk \ y 1 \    \ y l  1. Hence, the positive
unit clauses imply that t  1 and therefore the literal t  1 can be removed from the clause
without changing the set of satisfying tuples. Now the algorithm rejects if either Inner-Res
rejects  or if it derives the empty clause. In both cases it is clear that  is not satisfiable.
Thus, it suffices to construct a solution when the algorithm accepts. Let  be the set of
all inner clauses of terms from positive unit clauses at the final stage, when the algorithm
accepts. For each remaining negative outer literal tt  1u and each remaining inner clause
D  tx1 , . . . , xk , y 1 , . . . , y l u of t there exists an assignment D from V  P pNq that satisfies
 Ytx1 \  \ xk \ y 1 \  \ y l  1u: otherwise, by Lemma 25, the inner resolution algorithm
would have rejected  Y tx1  1, . . . , xk  1, y0  1, . . . , yl  1u, and would have removed
the inner clause D from t. Let D1 , . . . , Ds be an enumeration of all remaining inner clauses
D that appear in all remaining negative outer literals.
Write is for the s-ary operation defined by px1 , . . . , xs q  ipx1 , ipx2 , . . . , ipxs1 , xs q    qq
(where i is as in Fact 7). We claim that s : V  P pNq given by
x  is pD1 pxq, . . . , Ds pxqq

satisfies all clauses in . Let C be a clause from . By assumption, at the final stage of the
algorithm, the clause C is still non-empty. Also note that since all formulas in the input
were Horn-Horn, they contain at most one positive literal. This holds in particular for C,
and we therefore only have to distinguish the following cases:
 At the final state of the algorithm, C still contains a negative literal t  1. Since t  1
has not been removed, there is a remaining inner clause D  tx1 , . . . , xk , y 1 , . . . , y l u
of t. Observe that spx1 q \    \ spxk q \ spy1 q \    \ spyl q  1 if and only if Dj px1 q \
   \ Dj pxk q \ Dj py1q \    \ Dj pyl q  1 for all 1  j  s. Hence, and since
D px1 q \    \ D pxk q \ D py1 q \    \ D pyl q  1, s satisfies t  1. This shows that
s satisfies C.
 All negative literals have been removed from C during the algorithm. The positive
literal t0  1 of C is such that the inner clauses of t0 are Horn. They will be part of
, and therefore t0  1 is satisfied by s. Indeed, by assumption the assignments Dj
satisfy , and  is preserved by i.
We conclude that s is a solution to . The inner resolution algorithm has a linear time
complexity; the outer resolution algorithm performs at most a linear number of calls to
the inner resolution algorithm, and it is straightforward to implement all necessary data
structures for outer resolution to obtain a running time that is quadratic in the input
size.
Combining Proposition 22 with Theorem 26, we obtain the following.
Theorem 27. Let  be a finite set constraint language from EI. Then CSPpq can be
solved in quadratic time.
748

fiTractable Set Constraints

6. Maximal Tractability
In this section we show that the class EI is a maximal tractable set constraint language.
More specifically, let  be a set constraint language that strictly contains all EI relations.
We then show that  contains a finite set of relations 1 such that already the problem
CSPp1 q is NP-hard (Theorem 40).
6.1 The Universal-Algebraic Approach
In our proof we use the so-called universal-algebraic approach to the complexity of constraint satisfaction problems, which requires that we re-formulate set CSPs as constraint
satisfaction problems for -categorical structures. For a more detailed introduction to the
universal-algebraic approach for -categorical structures (see Bodirsky, 2012). A structure
 with a countable domain is called -categorical if all countable structures that satisfy
the same first-order sentences as  are isomorphic to  (see, e.g., Hodges, 1993). By the
theorem of Ryll-Nardzewski, and for countable signatures, this is equivalent to requiring
that every relation that is preserved by the automorphisms1 of  is first-order definable in
 (see, e.g., Hodges, 1993). A useful consequence of this is that in an -categorical structure , whenever two tuples c  pc1 , . . . , cn q and d  pd1 , . . . , dn q from  satisfy the same
first-order formulas, there is an automorphism  of  which maps c to d.
An example of an -categorical structure is pQ; q (by Cantors theorem), and a nonexample is given by pZ; q. Note that pQ; q and pZ; q have the same CSP; indeed, any two
infinite linear orders share the same CSP, since they even have the same finite substructures.
A characterisation of those infinite structures for which there is an -categorical structure
having the same CSP has been given by Bodirsky, Hils, and Martin (2011). Empirically,
it can be observed that constraint satisfaction problems studied in temporal and spatial
reasoning are typically called qualitative if and only if they can be formulated with an
-categorical template.
Set constraint languages are in general not -categorical (this follows easily by the
mentioned theorem of Ryll-Nardzewski). However, every set CSP can be formulated as the
CSP of an -categorical structure. To see this, we first have to recall some basic facts about
Boolean algebras. All countable atomless2 Boolean algebras are isomorphic (Koppelberg,
1989, Corollary 5.16; see also Hodges, 1993, Example 4 on page 100). Let A denote such a
countable atomless Boolean algebra, and let A denote the domain of A. Again, we use [
and \ to denote join and meet in A, respectively. Since the axioms of Boolean algebras and
the property of not having atoms can all be written as first-order sentences, it follows that A
is -categorical. A structure B has quantifier elimination if every first-order formula is over
B equivalent to a quantifier-free formula. It is well-known that A has quantifier elimination
(see Hodges, 1993, Exercise 17 on page 391). We will also make use of the following.
Theorem 28 (Marriott & Odersky, 1996, Corollary 5.7). A quantifier-free formula is satisfiable in some infinite Boolean algebra if and only if it is satisfiable in all infinite Boolean
algebras.
1. An isomorphism of a structure  with itself is called an automorphism of .
2. An atom in a Boolean algebra is an element x  0 such that for all y with x X y
y  0. If a Boolean algebra does not contains atoms, it is called atomless.

749

 y and x  y we have

fiBodirsky & Hils

In particular, when B is an infinite Boolean algebra and 1 , . . . , n are quantifier-free
formulas over the signature t[, \, c, 0, 1u, and when  is the relational structure with signature tR1 , . . . , Rn u where Ri is for each i  n defined by i over B, then CSPpq does not
depend on the choice of B.
A fundamental concept in the complexity theory of constraint satisfaction problems is
the notion of primitive positive definitions. A first-order formula is called primitive positive
(pp) if it is of the form
Dx1, . . . , xn p1 ^    ^ mq
where for each i  m the formula i is of the form Rpy1 , . . . , yl q or of the form y1  y2 , and
where R is a relation symbol and y1 , y2 , . . . , yl are either free variables or from tx1 , . . . , xn u.
We say that a k-ary relation R  Dk is primitive positive definable (pp definable) over a
 -structure  with domain D iff there exists a primitive positive formula px1 , . . . , xk q with
the k free variables x1 , . . . , xk such that a tuple pb1 , . . . , bk q is in R if and only if pb1 , . . . , bk q
is true in .
Example 14. The relation tpx, y q P P pNq2 | x  y u is pp definable in pP pNq; S, q where
S  tpx, y, z q | x [ y  z u. The pp definition is S px, x, y q ^ x  y (the definition is even
quantifier-free).
Example 15. The relation tpx1 , x2 , x3 , y q P P pNq4 | x1 [ x2 [ x3  y u is pp definable
in pP pNq; S q where S  tpx, y, z q | x [ y  z u. The pp definition is Du pS px1 , x2 , uq ^
S pu, x3 , y qq.
When every relation of a structure  is preserved by an operation f , then f is called a
polymorphism of . Note that polymorphisms of  also preserve all relations that have a pp
definition in . The following has been shown for finite domain constraint satisfaction by
Bulatov et al. (2005); the easy proof also works for infinite domain constraint satisfaction.
Lemma 29. Let R be a relation with a primitive positive definition in a structure . Then
CSPpq and the CSP for the expansion of  by the relation R are polynomial-time equivalent.
The following theorem is one of the reasons why it is useful to work with -categorical
templates (when this is possible).
Theorem 30 (Bodirsky & Nesetril, 2006). Let  be an -categorical structure. Then R is
primitive positive definable in  if and only if R is preserved by all polymorphisms of .
The previous and the next result together can be used to translate questions about
primitive positive definability 
into purely operational questions. Let D be a set, let Opnq
pnq the set of operations on D of finite arity. An
be Dn  D, and let O be 8
n1 O
p
n
q
operation  P O is called a projection if for some fixed i P t1, . . . , nu and for all n-tuples
px1, . . . , xnq P Dn we have the identity px1, . . . , xnq  xi. The composition of a k-ary
operation f and k operations g1 , . . . , gk of arity n is the n-ary operation defined by

pf pg1, . . . , gk qqpx1, . . . , xnq

 f g1px1, . . . , xnq, . . . , gk px1, . . . , xnq .
750

fiTractable Set Constraints

Definition 31. We say that F  O locally generates f : Dn  D if for every finite subset
A of D there is an operation g : Dn  D that can be obtained from the operations in F
and projection maps by composition such that f paq  g paq for all a P An .
Theorem 32 (see Szendrei, 1986, Corollary 1.9; also Bodirsky, 2012, Proposition 5.2.1). Let
F  O be a set of operations with domain D. Then an operation f : Dk  D preserves all
finitary relations that are preserved by all operations in F if and only if F locally generates
f.
The set of all automorphisms of a structure  is denoted by Autpq. In the following, we
always consider sets of operations F that contain AutpAq, and therefore make the following
convention. For F  O, we say that F generates f P O if F Y AutpAq locally generates f .
6.2 EI Set Constraints over the Atomless Boolean Algebra
In the previous subsection we have seen that all set CSPs can be formulated as CSPs for
-categorical structures. In this section, we describe those -categorical templates that
correspond to set CSPs for EI set constraints. In order to do so, we define analogs of the
operations e and i, defined on A instead of P pNq.
Proposition 33. There is an isomorphism i between A2 and A.
Proof. It is straightforward to verify that A2 is again a countable atomless Boolean algebra.

Motivated by the properties of e described in Lemma 11, we make the following definition.
Definition 34. Let B and B1 be two arbitrary Boolean algebras with domains B and B 1 ,
respectively, and let g : B  B 1 be a function that strongly preserves [, 0, and 1. We say
that g forgets unions if for all k  1, l  0, and x1 , . . . , xk , y1 , . . . , yl P B we have
epx1 q \    \ epxk q \ epy1 q \    \ epyl q  1
if and only if there exists an i  k such that xi \ y1 \    \ yl

 1.

Proposition 35. There exists an injection e : A  A that strongly preserves
in A, and that forgets unions.

[, 0, and 1

Proof. The construction of e is by a standard application of Konigs tree lemma for categorical structures (see, e.g., Bodirsky & Dalmau, 2012, Lemma 2); it suffices to show
that there is an injection f from every finite induced substructure B of A to A such that f
strongly preserves [, 0, and 1, and forgets unions.
So let B be such a finite substructure of A, and let B be the domain of B. Let C 
pP pB q; [, \, c, 0, 1q be the Boolean algebra of the subsets of B. We claim that g : B  P pB q
given by g p1q  1 and g pxq  tz | z  0 ^ z B xu for x  1
 preserves 0 and 1: this is by definition;
751

fiBodirsky & Hils

 preserves

[: for x, y P B (including the case that x  1 or y  1) we have
g pxq [C g py q  tz | z  0 ^ z B x ^ z B y u
(
 z | z  0 ^ z B px [B y q
 g p x [B y q ;

 is injective: if x, y
x  y;
 strongly preserves

P B such that gpxq  gpyq, then x B y and y B x, and hence
[: this follows from the previous two items;

 forgets unions: this can be shown analogously to the proof of Lemma 11.






Indeed, one has xi \ y1 \    \ yl  1 iff xi B j yj iff xi [ j yj  j yj iff


g pxi q[ j g pyj q  j g pyj q iff g pxi q\ g py1 q\  \ g pyl q  1. Thus, xi \ y1 \  \ yl  1
for some 1  i  k implies g px1 q \    \ g pxk q \ g py1 q \    \ g pyl q  1.
To prove the converse, we use that the finite Boolean algebra B may be identified with
pP pAq; [, \, c, 0, 1q for some finite set A. If Xi : xi \ y1 \  \ yl  1 for i  1, . . . , k,
we may choose ai P AzXi , i.e. ai P j yj [ xi , for i  1, . . . , k. Let C : ta1 , . . . , ak u 
A, so C P B. By construction, for i  k one has tC u R g pxi q \ g py1 q \    \ g pyl q. In
particular, it follows that g px1 q \    \ g pxk q \ g py1 q \    \ g pyl q  1.
Clearly, there is an embedding h from C into A. Then f : hpg q is a homomorphism from
B to A that forgets unions.
Proposition 36. Let  be a quantifier-free formula over the signature t[, \, c, 0, 1u. Then
e preserves  over S if and only if e preserves  over A. Moreover, every operation from
A  A that strongly preserves [, 0, and 1 and forgets unions generates e, and is generated
by e.
Proof. Let a be a tuple of elements from A. Clearly, there exists a tuple b of elements from
P pNq such that a and b satisfy the same set  of quantifier-free formulas; this follows from
the fact that every finite Boolean algebra is the Boolean algebra of subsets of a finite set.
Now observe that whether or not the tuple epbq satisfies a quantifier-free formula  only
depends on , by Lemma 11. Since e strongly preserves [, 0, and 1, and forgets unions,
the same is true for the quantifier-free formulas that hold on epaq. Hence, e preserves 
over A if and only if e preserves  over S.
To prove the second part of the statement, we use Theorem 32. Suppose that c and
d are tuples (of the same length) of elements from A that satisfy the same quantifier-free
formulas. Since A has quantifier-elimination, it follows that c and d satisfy the same firstorder formulas in A. By the consequence of the theorem of Ryll-Nardzewski mentioned at
 By the
the beginning of Section 6.1, there exists an automorphism  of A that maps c to d.
above observations and Theorem 32, this implies that all operations that strongly preserve
[, 0, and 1, and forget unions generate each other.
r be the operation px, y q  epipx, y qq.
Let ei
752

fiTractable Set Constraints

Proposition 37. Let  be a quantifier-free formula over the signature t[, \, c, 0, 1u. Then
r preserves  over A. Moreover, every binary operation
ei preserves  over S if and only if ei
r and is generated by
g that strongly preserves [, 0, and 1, and forgets unions generates ei,
r
ei.
Proof. The arguments are similar to the ones given in the proof of Proposition 36. If a1
and a2 are n-tuples of elements from A, there are n-tuples b1 , b2 of elements from P pNq such
that pa1 , a2 q and pb1 , b2 q satisfy the same set  of quantifier-free formulas. Whether or not
eipb1 , b2 q satisfies a quantifier-free formula  only depends on , as ei strongly preserves [,
r pa1 , a2 q, and so ei
r preserves  over A if
0, and 1, and forgets unions. The same holds for ei
and only if ei preserves  over S.
The proof of the second part of the statement is identical to the one for Proposition 36.

6.3 The Central Argument
We now give the central argument for the maximal tractability of EI, stated in universalalgebraic language. We say that an operation from Ak  A depends on the argument
i P t1, . . . , k u if there is no pk 1q-ary operation f 1 such that for all x1 , . . . , xk P A
f px1 , . . . , xk q  f 1 px1 , . . . , xi1 , xi

1 , . . . , xk

q.

We can equivalently characterize k-ary operations that depend on the i-th argument by
requiring that there are x1 , . . . , xk P A and x1i P A such that
f px1 , . . . , xk q  f px1 , . . . , xi1 , x1i , xi

1 , . . . , xk

q.

The following is a general fact about injective maps.
Lemma 38. Let f : Ak  A be a function that depends on all arguments, and which is
locally generated by a set of injective operations F. Then f is injective.
Proof. We first prove that every term T px1 , . . . , xn q formed from operations from F over
the variables x1 , . . . , xn such that every variable appears at least once defines an injective
map. We prove this by induction over the term structure. In case that n  1 and T is just
x1 there is nothing to show. Otherwise, T has the form f pT1 , . . . , Tk q for a k-ary f P F such
that Tj  Tj pxi1 , . . . , ximpj q q is for all j  k a term over operations from F with variables
xi1 , . . . , ximpj q each of which appears at least once in Tj . Now suppose that a1 , . . . , an P A
and b1 , . . . , bn P A are such that T pa1 , . . . , an q  T pb1 , . . . , bn q. We want to show that ai  bi
for all i  n. Since f is injective we must have that Tj pai1 , . . . , aimpj q q  Tj pbi1 , . . . , bimpj q q
for all j  k. Since every variable from x1 , . . . , xn appears in T at least once, the variable
xi must appear in Tj , for some j  k. Since Tj defines an injective operation by inductive
assumptions, we must have that ai  bi . It follows that T defines an injective map.
Now suppose that f is an operation that is locally generated by F and depends on
all arguments. Thus, for each i there are ci1 , . . . , cin and di such that f pci1 , . . . , cin q 
f pci1 , . . . , cii1 , di , cii 1 , . . . , cin q. Let a1 , . . . , an , b1 , . . . , bn P A be such that f pa1 , . . . , an q 
f pb1 , . . . , bn q. We have to show that a1  b1 , . . . , an  bn . Since f is locally generated
753

fiBodirsky & Hils

by F, there exists a term T px1 , . . . , xn q composed from the variables x1 , . . . , xn and operations from F such that T pe1 , . . . , en q  f pe1 , . . . , en q for all elements e1 , . . . , en from the
set ta1 , . . . , an , b1 , . . . , bn , c11 , . . . , cnn , d1 , . . . , dn u. For all i, the variable xi must appear in
T px1 , . . . , xn q because T pci1 , . . . , cin q  T pci1 , . . . , cii1 , di , cii 1 , . . . , cin q. Hence, the argument
from the beginning of the proof shows that T px1 , . . . , xn q defines an injective map, and
therefore that a1  b1 , . . . , an  bn . We have shown that f is injective.
r u. Then either tf u generates ei,
r or f
Theorem 39. Let f be an operation generated by tei
is generated by teu.

r u.
Proof. To show the statement of the theorem, let f be a k-ary operation generated by tei
For the sake of notation, let x1 , . . . , xl be the arguments on which f depends, for l  k.
Let f 1 : Al  A be the operation given by f 1 px1 , . . . , xl q  f px1 , . . . , xl1 , xl , xl , . . . , xl q.
Observe that f 1 depends on all arguments, and is locally generated by injective operations;
by Lemma 38, f 1 is injective. Since f 1 is generated by operations that preserve 0, 1, and
[, also f 1 preserves them. As f 1 is injective, it even strongly preserves 0, 1, and [.
Consider first the case that l  1, i.e., f 1 is unary. If for all finite subsets of A, the
operation f 1 equals an automorphism of A, then f is generated by AutpAq and there is
nothing to show. So assume otherwise; that is, assume that there is a finite set S  A
such that there is no a P AutpAq with f 1 pxq  apxq for all x P S. We claim that f 1 forgets
unions. To see this, let u1 , . . . , um , v1 , . . . , vn be from A such that f 1 pu1 q \    \ f 1 pum q \
 u, there is a term T pxq composed
f 1 pv1 q \    \ f 1 pvn q  1. Since f 1 is generated by tei
r
from ei, the automorphisms of A, and a single variable x such that f 1 pxq  T pxq for all
x P S Y tu1 , . . . , um , v1 , . . . , vn u. By the choice of S, this term cannot be composed of
automorphisms alone, and hence there must be a P AutpAq and operational terms T1 , T2
r such that f 1 pxq  apei
r pT1 pxq, T2 pxqqq for all
composed from automorphisms of A and ei
r
x P S. As ei forgets unions, there exists an i  k such that T1 pui q\ T1 pv1 q\  \ Tl pvn q  1.
Since T1 strongly preserves [, this means that ui \ v 1 \    \ v n  1 (see the proof of
Proposition 10), which is what we wanted to show. By Proposition 36 it follows that f 1 is
generated by e. But then f is generated by e as well.
Next, consider the case that l  1. Let g be the binary operation defined by g px, y q 
1
f px, y, . . . , y q. This functions depends on both arguments, and so cannot be generated by
the automorphisms of A alone. Hence, there is a term of the form
r pT1 px, y q, T2 px, y qqq
T px, y q  apei

where
 a P AutpAq,
r the automorphisms of A, and the
 T1 and T2 are operational terms composed from ei,
two variables x and y,

 g px, y q  T px, y q for all px, y q P tu1 , . . . , um , v1 , . . . , vn u.

We claim that g forgets unions. Assume g pu1 q\  \ g pum q\ g pv1 q\  \ g pvn q  1 for
some elements u1  pu11 , u21 q, . . . , um  pu1m , u2m q, v1  pv11 , v12 q, . . . , vn  pvn1 , vn2 q from A2 .
r forgets unions, there exists an i  k such that T1 pui q\ T1 pv1 q\  \ T1 pvn q  1 and
Since ei
754

fiTractable Set Constraints

T2 pui q\T2 pv1 q\  \T2 pvn q  1. Suppose first that T1 depends on both arguments. Then T1
defines an injective operation and strongly preserves [. It follows that ui \ v 1 \  \ v n  1
in A2 since these equations are inner Horn. We can argue similarly if T2 depends on both
arguments, and in those cases we have established that g forgets unions. Suppose now
that each of T1 and T2 does not depend on both arguments. Consider first the case that
T1 only depends on the first argument. Then the function x  T1 px, xq is injective and
strongly preserves [, and from T1 pui q \ T1 pv1 q \    \ T1 pvn q  1 we derive as above that
u1i \ v11 \    \ vn1  1 holds in A. In this case, T2 must depend on the second argument,
since T depends on both arguments. We therefore also have that u2i \ v12 \  \ vn2  1 holds
in A. The situation that T1 only depends on the second argument and T2 only depends on
r
the first argument is analogous. So g forgets unions. By Proposition 37, g generates ei.
r
Consequently, also f generates ei.
Theorem 40. Let  be a set constraint language. Suppose that  contains all relations from
EI, and also contains a relation that is not from EI. Then there is a finite sublanguage 1
of  such that CSPp1 q is NP-hard.
Proof. When R1 , R2 , . . . are the relations of , let 1 , 2 , . . . be quantifier-free formulas that
define R1 , R2 , . . . over S  pP pNq; \, [, c, 0, 1q. Let R1A , R2A , . . . be the relations defined
by 1 , 2 , . . . over A, and let  be the relational structure with domain A and exactly those
r and contains
relations. By Proposition 37,  contains a relation that is not preserved by ei,
r Consider the set F of all polymorphisms of . By
all relations that are preserved by ei.
Theorem 32, all operations in F are locally generated by eri.
The set F does not contain eri, since this would contradict by Theorem 32 the fact
r Since F is locally closed, it follows
that  contains a relation that is not preserved by ei.
from Theorem 39 that all operations f P F are generated by e. But then the relation
tpx, y, zq | x  y  z _ x  y  zu is preserved by all operations in F (we have already seen
this relation in Example 5), and hence pp definable in  by Theorem 30. This relation has
an NP-complete CSP (Bodirsky & Kara, 2008). Let 1 be the reduct of  that contains
exactly the relations that appear in the pp definition of tpx, y, z q | x  y  z _ x  y  z u
in . Clearly, there are finitely many such relations; we denote the corresponding relation
symbols by  1   . By Lemma 29, CSPp1 q is NP-hard.
This establishes also the hardness of CSPpq: let 1 be the  1 -reduct of . We claim
that CSPp1 q and CSPp1 q are the same computational problem. We have to show that
a conjunction of atomic  1 -formulas  is satisfiable in 1 if and only if it is true in 1 .
Replacing each atomic  1 -formula in  by its quantifier-free definition, this follows from
Theorem 28.

7. Concluding Remarks
We have introduced the powerful set constraint language of EI set constraints, which in
particular contains all Horn-Horn set constraints and all previously studied tractable set
constraint languages. Constraint satisfaction problems over EI can be solved in polynomial
 even quadratic  time. Our tractability result is complemented by a complexity result
which shows that tractability of EI set constraints is best-possible within a large class of
set constraint languages.
755

fiBodirsky & Hils

We would also like to remark that there is an algorithm to test whether a given finite set
constraint language (where relations in the language are given by quantifier-free formulas
over the signature t\, [, c, 0, 1u) is contained in EI. This means that the so-called metaproblem for EI set constraints can be decided effectively.
Proposition 41. There is an algorithm to test whether a given quantifier-free formula over
the signature t\, [, c, 0, 1u defines a relation from EI.
Proof. It is clear that  can be effectively transformed into the normal form that is described
in Section 3, so we will from now on assume that  is a conjunction of outer clauses, and
that each atomic formula is of the form t  1 where t is in inner conjunctive normal form.
Let n be the number of variables of . We have to test that for any two n-tuples u1 , u2
of elements of P pNq that satisfy , the n-tuple eipu1 , u2 q satisfies  as well. Note that
whether or not a tuple satisfies  in S only depends on the Boolean algebra generated
by the entries of this tuple in S. Any Boolean algebra generated by n elements is of size
n
at most 22 ; therefore, there are finitely many cases to check. For each pair of Boolean
algebras with generating tuples u1 , u2 , we check whether eipu1 , u2 q satisfies  as follows. By
Lemma 11, eipu1 , u2 q satisfies an atomic formula t  1 if and only if for every inner clause
x1 \ 
   \ xk \ epy1q \    \ epy1q of t there exists an i  k such that ipu1, u
2 q satisfies
xi \ j y j  1. This in turn is true if and only if both u1 and u2 satisfy xi \ j y j  1.
The truth value of non-atomic formulas of the tuple eipu1 , u2 q can then be computed from
the truth value of the atomic formulas in the usual way.

Finally we would also like to remark that one can analogously obtain tractability for
the class of constraints where the inner clauses of the positive outer literals are dual Horn
(i.e., have at most one negative literal). All statements and proofs for the respective result
can be obtained by dualizing in the following formal sense: the dual of a relation R that is
definable over a Boolean algebra is the relation tcptq | t P Ru. The dual of a k-ary operation
f on the same domain is the operation px1 , . . . , xk q  cpf pcpx1 q, . . . , cpxk qqq. The proofs
then translate literally into proofs for the dualized versions of the statements.

Acknowledgments
An extended abstract of this article appeared in the proceedings of IJCAI11 (Bodirsky, Hils,
& Krimkevitch, 2011)3 . We want to thank Francois Bossiere who pointed out mistakes in
the conference version of the paper. One mistake concerned the reduction from the CSP
for languages from EI to satisfiability of Horn-Horn clauses; the other concerned a problem
in a previous proof of Theorem 26.
Manuel Bodirsky has received funding from the ERC under the European Communitys
Seventh Framework Programme (FP7/2007-2013 Grant Agreement no. 257039).
3. The third author of the conference version left the author team for the preparation of the journal version.

756

fiTractable Set Constraints

References
Aiken, A. (1994). Set constraints: Results, applications, and future directions. In Proceedings
of the Second Workshop on the Principles and Practice of Constraint Programming,
pp. 326335.
Baader, F. (2003). Least common subsumers and most specific concepts in a description logic
with existential restrictions and terminological cycles. In Proceedings of International
Joint Conferences on Artificial Intelligence (IJCAI), pp. 319324.
Baader, F., Brandt, S., & Lutz, C. (2005). Pushing the EL envelope. In International Joint
Conferences on Artificial Intelligence (IJCAI), pp. 364369.
Barto, L., & Kozik, M. (2009). Constraint satisfaction problems of bounded width. In
Proceedings of the Annual Symposium on Foundations of Computer Science (FOCS),
pp. 595603.
Bodirsky, M. (2012). Complexity classification in infinite-domain constraint satisfaction.
Memoire dhabilitation a diriger des recherches, Universite Diderot  Paris 7. Available
at arXiv:1201.0856.
Bodirsky, M., Chen, H., & Pinsker, M. (2010). The reducts of equality up to primitive
positive interdefinability. Journal of Symbolic Logic, 75 (4), 12491292.
Bodirsky, M., & Dalmau, V. (2012). Datalog and constraint satisfaction with infinite templates. To appear in the Journal on Computer and System Sciences. A preliminary
version appeared in the proceedings of the Symposium on Theoretical Aspects of
Computer Science (STACS05).
Bodirsky, M., Hils, M., & Krimkevitch, A. (2011). Tractable set constraints. In Proceedings
of International Joint Conferences on Artificial Intelligence (IJCAI), pp. 510515.
Bodirsky, M., Hils, M., & Martin, B. (2011). On the scope of the universal-algebraic approach to constraint satisfaction. To appear in Logical Methods in Computer Science (LMCS), 9099. Available at arXiv:0909.5097v3. An extended abstract that
announced some of the results appeared in the proceedings of Logic in Computer
Science (LICS10).
Bodirsky, M., & Kara, J. (2008). The complexity of equality constraint languages. Theory of
Computing Systems, 3 (2), 136158. A conference version appeared in the proceedings
of Computer Science Russia (CSR06).
Bodirsky, M., & Kara, J. (2009). The complexity of temporal constraint satisfaction problems. Journal of the ACM, 57 (2), 141. An extended abstract appeared in the
Proceedings of the Symposium on Theory of Computing (STOC08).
Bodirsky, M., & Kutz, M. (2007). Determining the consistency of partial tree descriptions.
Artificial Intelligence, 171, 185196.
Bodirsky, M., & Nesetril, J. (2006). Constraint satisfaction with countable homogeneous
templates. Journal of Logic and Computation, 16 (3), 359373.
Boole, G. (1847). An Investigation of the Laws of Thought. Walton, London. Reprinted by
Philisophical Library, New York, 1954.
757

fiBodirsky & Hils

Broxvall, M., Jonsson, P., & Renz, J. (2002). Disjunctions, independence, refinements.
Artificial Intelligence, 140 (1/2), 153173.
Bulatov, A. A. (2003). Tractable conservative constraint satisfaction problems. In Proceedings of the Symposium on Logic in Computer Science (LICS), pp. 321330, Ottawa,
Canada.
Bulatov, A. A. (2006). A dichotomy theorem for constraint satisfaction problems on a
3-element set. Journal of the ACM, 53 (1), 66120.
Bulatov, A. A., & Dalmau, V. (2006). A simple algorithm for Maltsev constraints. SIAM
Journal on Computing, 36 (1), 1627.
Bulatov, A. A., Krokhin, A. A., & Jeavons, P. G. (2005). Classifying the complexity of
constraints using finite algebras. SIAM Journal on Computing, 34, 720742.
Cohen, D., Jeavons, P., Jonsson, P., & Koubarakis, M. (2000). Building tractable disjunctive
constraints. Journal of the ACM, 47 (5), 826853.
Dowling, W. F., & Gallier, J. H. (1984). Linear-time algorithms for testing the satisfiability
of propositional Horn formulae. The Journal of Logic Programming, 1 (3), 267284.
Drakengren, T., & Jonsson, P. (1998). Reasoning about set constraints applied to tractable
inference in intuitionistic logic. Journal of Logic and Computation, 8 (6), 855875.
Garey, M., & Johnson, D. (1978). A guide to NP-completeness. CSLI Press, Stanford.
Hodges, W. (1993). Model theory. Cambridge University Press.
Idziak, P. M., Markovic, P., McKenzie, R., Valeriote, M., & Willard, R. (2010). Tractability
and learnability arising from algebras with few subpowers. SIAM Journal on Computing, 39 (7), 30233037.
Jonsson, P., & Backstrom, C. (1998). A unifying approach to temporal constraint reasoning.
Artificial Intelligence, 102 (1), 143155.
Jonsson, P., & Drakengren, T. (1997). A complete classification of tractability in RCC-5.
Journal of Artificial Intelligence Research, 6, 211221.
Koppelberg, S. (1989). Projective boolean algebras. In Handbook of Boolean Algebras,
Vol. 3, pp. 741773. North Holland, Amsterdam-New York-Oxford- Tokyo.
Koubarakis, M. (2001). Tractable disjunctions of linear constraints: Basic results and applications to temporal reasoning. Theoretical Computer Science, 266, 311339.
Krotzsch, M., Rudolph, S., & Hitzler, P. (2006). On the complexity of Horn description
logics. In OWL: Experiences and Directions Workshop.
Kuncak, V., Nguyen, H. H., & Rinard, M. C. (2006). Deciding boolean algebra with presburger arithmetic. Journal of Automatic Reasoning, 36 (3), 213239.
Kuncak, V., & Rinard, M. C. (2007). Towards efficient satisfiability checking for boolean
algebra with presburger arithmetic. In Proceedings of the International Conference
on automated deduction (CADE), pp. 215230.
Kusters, R., & Molitor, R. (2002). Approximating most specific concepts in description
logics with existential restrictions. AI Communications, 15 (1), 4759.
758

fiTractable Set Constraints

Lassez, J.-L., & McAloon, K. (1989). Independence of negative constraints. In International
Joint Conference on Theory and Practice of Software Development (TAPSOFT), Volume 1, pp. 1927.
Marriott, K., & Odersky, M. (1996). Negative Boolean constraints. Theoretical Computer
Science, 160 (1&2), 365380.
Schaefer, T. J. (1978). The complexity of satisfiability problems. In Proceedings of the
Symposium on Theory of Computing (STOC), pp. 216226.
Szendrei, A. (1986). Clones in universal algebra. Seminaire de Mathematiques Superieures.
Les Presses de lUniversite de Montreal.

759

fi