Journal of Artificial Intelligence Research 23 (2005) 421-440

Submitted 07/04; published 04/05

On the Practical use of Variable Elimination in Constraint
Optimization Problems: Still-life as a Case Study
Javier Larrosa
Enric Morancho
David Niso

larrosa@lsi.upc.edu
enricm@ac.upc.edu
niso57@casal.upc.edu

Universitat Politecnica de Catalunya
Jordi Girona 1-3, 08034 Barcelona, Spain

Abstract
Variable elimination is a general technique for constraint processing. It is often discarded because of its high space complexity. However, it can be extremely useful when
combined with other techniques. In this paper we study the applicability of variable elimination to the challenging problem of finding still-lifes. We illustrate several alternatives:
variable elimination as a stand-alone algorithm, interleaved with search, and as a source of
good quality lower bounds. We show that these techniques are the best known option both
theoretically and empirically. In our experiments we have been able to solve the n = 20
instance, which is far beyond reach with alternative approaches.

1. Introduction
Many problems arising in domains such as resource allocation (Cabon, de Givry, Lobjois,
Schiex, & Warners, 1999), combinatorial auctions (Sandholm, 1999), bioinformatics and
probabilistic reasoning (Pearl, 1988) can be naturally modeled as constraint satisfaction
and optimization problems. The two main solving schemas are search and inference. Search
algorithms constitute the usual solving approach. They transform a problem into a set of
subproblems by selecting one variable and instantiating it with its different alternatives.
Subproblems are solved applying recursively the same transformation rule. The recursion
defines a search tree that is normally traversed in a depth-first manner, which has the
benefit of requiring only polynomial space. The practical efficiency of search algorithms
greatly depends on their ability to detect and prune redundant subtrees. In the worst-case,
search algorithms need to explore the whole search tree. Nevertheless, pruning techniques
make them much more effective.
Inference algorithms (also known as decomposition methods) solve a problem by a sequence of transformations that reduce the problem size, while preserving its optimal cost. A
well known example is bucket elimination (BE, also known as variable elimination) (Bertele
& Brioschi, 1972; Dechter, 1999). The algorithm proceeds by selecting one variable at a
time and replacing it by a new constraint which summarizes the effect of the chosen variable. The main drawback of BE is that new constraints may have large arities which require
exponentially time and space to process and store. However, a nice property of BE is that
its worst-case time and space complexities can be tightly bounded by a structural parameter called induced width. The exponential space complexity limits severely the algorithms
c
2005
AI Access Foundation. All rights reserved.

fiLarrosa, Morancho & Niso

practical usefulness. Thus, in the constraint satisfaction community variable elimination is
often disregarded.
In this paper we consider the challenging problem of finding still-lifes which are stable
patterns of maximum density in the game of life. This academic problem has been recently
included in the CSPlib repository1 and a dedicated web page2 has been set to maintain
up-to-date results. In Bosch and Trick (2002), the still-life problem is solved using two
different approaches: integer programming and constraint programming, both of them based
on search. None of them could solve up to the n = 8 problem within reasonable time. Their
best results were obtained with a hybrid approach which combines the two techniques and
exploits the problem symmetries in order to reduce the search space. With their algorithm,
they solved the n = 15 case in about 8 days of cpu. Smith (2002) proposed an interesting
alternative using pure constraint programming techniques, and solving the problem in its
dual form. In her work, Smith could not improve the n = 15 limit. Although not explicitly
2
mentioned, these two works use algorithms with worst-case time complexity O(2(n ) ).
In this paper we show the usefulness of variable elimination techniques. First we apply
plain BE. Against what could be expected, we observe that BE is competitive with stateof-the-art alternatives. Next, we introduce a more sophisticated algorithm that combines
search and variable elimination (following the ideas of Larrosa & Dechter, 2003) and uses
a lower bound based on mini-buckets (following the ideas of Kask & Dechter, 2001). With
our algorithm, we solve in one minute the n = 15 instance. We have been able to solve up to
the n = 20 instance, which was far beyond reach with previous techniques. For readability
reasons, we only describe the main ideas and omit algorithmic details.3
The structure of the paper is the following: In the next Section we give some preliminary
definitions. In Section 3 we solve the problem with plain BE. In Section 4 we introduce the
hybrid algorithm with which we obtained the results reported in Section 5. In Section 6 we
discuss how the ideas explored in this article can be extended to other domains. Besides,
we report additional experimental results. Finally, Section 7 gives some conclusions and
lines of future work.

2. Preliminaries
In this Section we first define the still-life problem. Next, we define the weighted CSP
framework and formulate the still-life as a weighted CSP. Finally, we review the main
solving techniques for weighted CSPS.
2.1 Life and Still-Life
The game of life (Gardner, 1970) is played over an infinite checkerboard, where each square
is called a cell. Each cell has eight neighbors: the eight cells that share one or two corners
with it. The only player places checkers on some cells. If there is a checker on it, the cell
is alive, else it is dead. The state of the board evolves iteratively according to the following
three rules: (1) if a cell has exactly two living neighbors then its state remains the same
1. www.csplib.org
2. www.ai.sri.com/~ nysmith/life
3. The interested reader can find an extended version, along with the source code of our implementation
in www.lsi.upc.edu/~ larrosa/publications

422

fiOn the practical use of variable elimination

3

1

3

1

1

3

1

Xc

4

2

A

2

2

B

2

D

C

E

Figure 1: A: A 3  3 still-life. B: constraint graph of a simple WCSP instance with four
variables and three cost functions. C: the constraint graph after assigning variable
x4 . D: the constraint graph after clustering variables x3 and x4 . E: the constraint
graph after eliminating variable x4 .

in the next iteration, (2) if a cell has exactly three living neighbors then it is alive in the
next iteration and (3) if a cell has fewer than two or more than three living neighbors,
then it is dead in the next iteration. Although defined in terms of extremely simple rules,
the game of life has proven mathematically rich and it has attracted the interest of both
mathematicians and computer scientists.
The still-life problem SL(n) consist on finding a nn stable pattern of maximum density
in the game of life. All cells outside the pattern are assumed to be dead. Considering the
rules of the game, it is easy to see that each cell (i, j) must satisfy the following three
conditions: (1) if the cell is alive, it must have exactly two or three living neighbors, (2) if
the cell is dead, it must not have three living neighbors, and (3) if the cell is at the grid
boundary (i.e, i = 1 or i = n or j = 1 or j = n), it cannot be part of a sequence of three
consecutive living cells along the boundary. The last condition is needed because three
consecutive living cells at a boundary would produce living cells outside the grid.
Example 1 Figure 1.A shows a solution to SL(3). It is easy to verify that all its cells
satisfy the previous conditions, hence it is stable. The pattern is optimal because it has 6
living cells and no 3  3 stable pattern with more that 6 living cells exists.

2.2 Weighted CSP
A weighted constraint satisfaction problem (WCSP) (Bistarelli, Montanari, & Rossi, 1997)
is defined by a tuple (X, D, F), where X = {x1 , . . . , xn } is a set of variables taking values
from their finite domains Di  D. F is a set of weighted constraints (i.e., cost functions).
Each f  F is defined over a subset of variables, var(f ), called its scope. The objective
function is the sum of all functions in F,
F =

X

f

f F

and the goal is to find the instantiation of variables that minimizes the objective function.
Example 2 Consider a WCSP with four variables X = {xi }4i=1 with domains Di = {0, 1}
and three cost functions: f1 (x1 , x4 ) = x1 + x4 , f2 (x2 , x3 ) = x2 x3 and f3 (x2 , x4 ) = x2 + x4 .
423

fiLarrosa, Morancho & Niso

The objective function is F (x1 , x2 , x3 , x4 ) = x1 + x4 + x2 x3 + x2 + x4 . Clearly, the optimal
cost is 0, which is obtained with every variable taking value 0.
Constraints can be given explicitly by means of tables, or implicitly as mathematical
expressions or computing procedures. Infeasible partial assignments are specified by constraints that assign cost  to them. The assignment of value a to variable xi is noted
xi = a. A partial assignment is a tuple t = (xi1 = v1 , xi2 = v2 ,    , xij = vj ). The extension
of t to xi = a is noted t  (xi = a). WCSPs instances are graphically depicted by means
of their interaction or constraint graph, which has one node per variable and one edge connecting any two nodes that appear in the same scope of some cost function. For instance,
Figure 1.B shows the constraint graph of the problem in the previous example.
2.3 Overview of Some Solving Techniques
In this Subsection we review some solving techniques widely used when reasoning with
constraints.
2.3.1 search
WCSPs are typically solved with depth-first search. Search algorithms can be defined in
terms of instantiating functions,
Definition 1 Let P = (X, D, F) a WCSP instance, f a function in F, xi a variable in
var(f ), and v a value in Di . Instantiating f with xi = v is a new function with scope
var(f )  {xi } which returns for each tuple t, f (t  (xi = v)). Instantiating P with xi = v is
a new problem P |xi =v = (X  {xi }, D  {Di }, F 0 ), where F 0 is obtained by instantiating all
the functions in F that mention xi with xi = v.
For instance, instantiating the problem of Example 2 with x4 = 1, produces a new
problem with three variables {xi }3i=1 and three cost functions: f1 (x1 , x4 = 1) = x1 + 1,
f2 (x2 , x3 ) = x2 x3 and f3 (x2 , x4 = 1) = x2 + 1. Figure 1.C shows the corresponding
constraint graph, obtained from the original graph by removing the instantiated variable x4
and all adjacent edges. Observe that the new graph depends on the instantiated variable,
but does not depend on the value assigned to it.
Search algorithms transform the current problem P into a set of subproblems. Usually
it is done by selecting one variable xi which is instantiated with its different domain values
(P |xi =v1 , P |xi =v2 ,    , P |xi =vd ). This transformation is called branching. In each subproblem the same process is recursively applied, which defines a tree of subproblems. Search
algorithms expand subproblems until a trivial case is achieved: there is no variable left, or
a pruning condition is detected. In optimization problems, pruning conditions are usually
defined in terms of lower and upper bounds. Search keeps the cost of the best solution so
far, which is an upper bound of the optimal cost. At each node, a lower bound of the best
cost obtainable underneath is computed. If the lower bound is greater than or equal to the
upper bound, it is safe to backtrack.
The size of the search tree is O(dn ) (being d the size of the largest domain) which bounds
the time complexity. If the tree is traversed depth-first, the space complexity is polynomial.
424

fiOn the practical use of variable elimination

2.3.2 clustering
A well-known technique for constraint processing is clustering (Dechter & Pearl, 1989). It
merges several variables into one meta-variable, while preserving the problem semantics.
Clustering variables xi and xj produces meta-variable xk , whose domain is Di  Dj . Cost
functions must be accordingly clustered. For instance, in the problem of Example 2, clustering variables x3 and x4 produces variable xc with domain Dc = {(0, 0), (0, 1), (1, 0), (1, 1)}.
Cost functions f2 and f3 are clustered into fc (x2 , xc ) = f2 + f3 . With the new variable
notation fc = x2 xc [1] + x2 + xc [2], where xc [i] denotes the i-th component of xc . Function
f1 needs to be reformulated as f1 (x1 , xc ) = x1 + xc [2]. The constraint graph of the resulting
problem is obtained by merging the clustered variables and connecting the meta-node with
all nodes that were adjacent to some of the clustered variables. Figure 1.D shows the constraint graph after the clustering of x3 and x4 . The typical use of clustering is to transform
a cyclic constraint graph into an acyclic one, which can be solved efficiently thereafter.
2.3.3 variable elimination
Variable elimination is based on the following two operations,
Definition 2 The sum of two functions f and g, noted (f + g), is a new function with
scope var(f )  var(g) which returns for each tuple the sum of costs of f and g,
(f + g)(t) = f (t) + g(t)
Definition 3 The elimination of variable xi from f , noted f  xi , is a new function with
scope var(f )  {xi } which returns for each tuple t the cost of the best extension of t to xi ,
(f  xi )(t) = min {f (t  (xi = a))}
aDi

Observe that when f is a unary function (i.e., arity one), eliminating the only variable
in its scope produces a constant.
Definition 4 Let P = (X, D, F) be a WCSP instance. Let xi  X be an arbitrary variable
and let Bi be the set of all cost functions having xi in their scope (Bi is called the bucket of
xi ). We define gi as
X
gi = (
f )  xi
f Bi

The elimination of xi transforms P into a new problem P xi = {X  {xi }, D  {Di }, (F 
Bi )  {gi }}. In words, P xi is obtained by replacing xi and all the functions in its bucket
by gi .
P and P xi have the same optimal cost because, by construction, gi compensates the
absence of xi . The constraint graph of P xi is obtained by forming a clique with all the
nodes adjacent to node xi and then removing xi and all its adjacent edges. For example,
eliminating x4 in the problem of Example 2 produces a new problem with three variables
{xi }3i=1 and two cost functions: f2 and g4 . The scope of g4 is {x1 , x2 } and it is defined as,
425

fiLarrosa, Morancho & Niso

g4 = (f1 + f3 )  x4 = (x1 + x4 + x2 + x4 )  x4 = x1 + x2 . Figure 1.D shows the constraint
graph after the elimination.
In the previous example, the new function g4 could be expressed as a mathematical expression. Unfortunately, in general, the result of summing functions or eliminating variables
cannot be expressed intensionally, and new cost functions must be stored extensionally in
tables. Consequently, the space complexity of computing P xi is proportional to the numQ
ber of entries of gi , which is: ( xj var(gi ) |Dj |). Since xj  var(gi ) iff xj is adjacent to xi
Q
in the constraint graph, the previous expression can be rewritten as ( xj N (i,GP ) |Dj |),
where GP is the constraint graph of P and N (i, GP ) is the set of neighbors of xi in GP .
The time complexity of computing P xi is its space complexity multiplied by the cost of
computing each entry of gi .
Bucket elimination (BE) works in two phases. In the first phase, it eliminates variables
one at a time in reverse order. In the elimination of xi , the new gi function is computed
and added to the corresponding bucket. The elimination of x1 produces an empty-scope
function (i.e., a constant) which is the optimal cost of the problem. In the second phase, BE
considers variables in increasing order and generates the optimal assignment of variables.
The time and space complexity of BE is exponential on a structural parameter from the
constraint graph, called induced width, which captures the maximum arity among all the
gi functions. Without any additional overhead BE can also compute the number of optimal
solutions (see Dechter, 1999, for details).
2.3.4 super-buckets
In some cases, it may be convenient to eliminate a set of variables simultaneously (Dechter
& Fatah, 2001). The elimination of the set of variables Y is performed by collecting in BY
the set of functions mentioning at least one variable of Y . Variables in Y and functions in
BY are replaced by a new function gY defined as,
gY = (

X

f)  Y

f BY

The set BY is called a super-bucket. Note that the elimination of Y can be seen as the
clustering of its variables into a meta-variable xY followed by its elimination.
2.3.5 mini-buckets
When the space complexity of BE is too high, an approximation, called mini buckets
(Dechter & Rish, 2003), can be used. Consider the elimination of xi , with its associated
bucket Bi = {fi1 , . . . , fik }. BE would compute,
gi = (

X

f )  xi

f Bi

The time and space complexity of this computation depends on the arity of gi . If it is beyond
our available resources, we can partition bucket Bi into so-called mini-buckets Bi1 , . . . , Bik
where the number of variables in the scopes of each mini-bucket is bounded by a parameter.
Then we can compute,
X
gij = (
f )  xi , j = 1..k
f Bij

426

fiOn the practical use of variable elimination

6

7

6

1

2

2
2
8

9
3

5

1

8

2

8

9

9
3

1

3

1

8

9

5

5

5

4

4
4

4

A

B

C

D

Figure 2: A constraint graph and its evolution over a sequence of variable eliminations and
instantiations.

where each gij has a bounded arity. Since,
gij

gi

zX }|

(

f Bi

{

f )  xi 

k z X }|
X

(

{

f )  xi

j=1 f Bij

the elimination of variables using mini-buckets yields a lower bound of the actual optimal
cost.
2.3.6 combining search and variable elimination
When plain BE is too costly in space, we can combine it with search (Larrosa & Dechter,
2003). Consider a WCSP whose constraint graph is depicted in Figure 2.A. Suppose that
we want to eliminate a variable but we do not want to compute and store constraints with
arity higher than two. Then we can only take into consideration variables connected to at
most two variables. In the example, variable x7 is the only one that can be selected. Its
elimination transforms the problem into another one whose constraint graph is depicted in
Figure 2.B. Now x6 has its degree decreased to two, so it can also be eliminated. The
new constraint graph is depicted in Figure 2.C. At this point, every variable has degree
greater than two, so we switch to a search schema which selects a variable, say x3 , branches
over its values and produces a set of subproblems, one for each value in its domain. All of
them have the same constraint graph, depicted in Figure 2.D. For each subproblem, it is
possible to eliminate variable x8 and x4 . After their elimination it is possible to eliminate
x2 and x9 , and subsequently x5 and x1 . Eliminations after branching have to be done at
every subproblem since the new constraints with which the eliminated variables are replaced
differ from one subproblem to another. In the example, only one branching has been made.
Therefore, the elimination of variables has reduced the search tree size from d9 to d, where
d is the size of the domains. In the example, we bounded the arity of the new constraints
to two, but it can be generalized to an arbitrary value.

3. Solving Still-life with Variable Elimination
SL(n) can be easily formulated as a WCSP. The most natural formulation associates one
variable xij with each cell (i, j). Each variable has two domain values. If xij = 0 the cell is
427

fiLarrosa, Morancho & Niso

X1
j 2

j 1

j

i 2

j+1

j+2

X2

i 1

X3

i

X4

i+1

X5

i +2

X6

B

A

Figure 3: A: Structure of the constraint graph of SL(n). The node in the center, associated
to cell (i, j), is linked to all cells it interacts with. The shadowed area indicates
the scope of fij . B (left): Constraint graph of SL(6) after clustering cells into
row variables. B (from left to right: Evolution of the constraint graph during the
execution of BE.

dead, if xij = 1 it is alive. There is a cost function fij for each variable xij . The scope of
fij is xij and all its neighbors. It evaluates the stability of xij : if xij is unstable given its
neighbors, fij returns ; else fij returns 1  xij .4 The objective function to be minimized
is,
F =

n X
n
X

fij

i=1 j=1

If the instantiation X represents an unstable pattern, F (X) returns ; else it returns the
number of dead cells. fij can be stored as a table with 29 entries and evaluated in constant
time.
Figure 3.A illustrates the structure of the constraint graph of SL(n). The picture shows
an arbitrary node xij linked to all the nodes it interacts with. For instance, there is an edge
between xij and xi,j+1 because xi,j+1 is a neighbor of xij in the grid and, consequently,
both variables are in the scope of fij . There is an edge between xij and xi1,j2 because
both cells are neighbors of xi1,j1 in the grid and, therefore, both appear in the scope of
fi1,j1 . The shadowed area represents the scope of fij (namely, xij and all its neighbors).
The complete graph is obtained by extending this connectivity pattern to all nodes in the
graph.
For the sake of clarity, we use an equivalent but more compact SL(n) formulation
that makes BE easier to describe and implement: we cluster all variables of each row
into a single meta-variable. Thus, xi denotes the state of cells in the i-th row (namely,
xi = (xi1 , xi2 , . . . , xin ) with xij  {0, 1}). Accordingly, it takes values over the sequences of
n bits or, equivalently, over the natural numbers in the interval [0..2n  1]. Cost functions
are accordingly clustered: there is a cost function fi associated with each row i, defined as,
fi =

n
X

fij

j=1

4. Recall that, as a WCSP, the task is to minimize the number of dead cells. Therefore, we give cost 1 to
dead cells and cost 0 to living cells.

428

fiOn the practical use of variable elimination

For internal rows, the scope of fi is {xi1 , xi , xi+1 }. The cost function of the top row, f1 ,
has scope {x1 , x2 }. The cost function of the bottom row, fn , has scope {xn1 , xn }. If there
is some unstable cell in xi , fi (xi1 , xi , xi+1 ) = . Else, it returns the number of dead cells
in xi . Evaluating fi is (n) because all the bits of the arguments need to be checked. The
new, equivalent, objective function is,
F =

n
X

fi

i=1

Figure 3.B (left) shows the constraint graph of SL(6) with this formulation. An arbitrary
variable xi is connected with the two variables above and the two variables below. The
sequential structure of the constraint graph makes BE very intuitive. It eliminates variables
in decreasing orders. The elimination of xi produces a new function gi = (fi1 + gi+1 )  xi
with scope {xi2 , xi1 }. Figure 3.B (from left to right) shows the evolution of the constraint
graph along the elimination of its variables. Formally, BE applies a recursion that transforms
subproblem P into P xi , where xi is the variable in P with the highest index. It satisfies
the following property,
Property 1 Let gi be the function added by BE to replace xi . Then gi (a, b) is the cost of
the best extension of (xi2 = a, xi1 = b) to the eliminated variables (xi , . . . , xn ). Formally,
gi (a, b) =

min

vi Di ,...,vn Dn

{fi1 (a, b, vi ) + fi (b, vi , vi+1 ) +

+fi+1 (vi , vi+1 , vi+2 ) + . . .
+fn1 (vn2 , vn1 , vn ) + fn (vn1 , vn )}
If gi (a, b) = , it means that the pattern a, b cannot be extended to the inferior rows
with a stable pattern. If gi (a, b) = k (with k 6= ), it means that a, b can be extended and
the optimal extension has k dead cells from xi1 to xn .
The space complexity of BE (n  22n ), due to the space required to store n functions
gi extensionally (2n  2n entries each). Regarding time, computing each entry of gi has
cost (n  2n ) (finding the minimum of 2n alternatives, the computation of each one is
(n)). Since each gi has 22n entries, the total time complexity is (n2  23n ). Observe that
solving SL(n) with BE is an exponential improvement over search algorithms, which have
2
time complexity O(2n ).
Table 4 reports some empirical results. They were obtained with a 2 Ghz Pentium IV
machine with 2 Gb of memory. The first columns reports the problem size, the second
reports the optimal cost as the number of dead cells (in parenthesis, the number of living
cells), the third column reports the number of optimal solutions. We count as different
two solutions even if one can be transformed to the other through a problem symmetry.
The fourth column reports the CPU time of BE in seconds. The fifth, sixth and seventh
columns report the results obtained with the three approaches tried by Bosch and Trick
(2002):5 constraint programming (CP), integer programming (IP), and a more sophisticated
algorithm (CP/IP) which combines CP and IP, and exploits the problem symmetries.
5. The corresponding OPL code is available at http://mat.gsia.cmu.edu/LIFE.

429

fiLarrosa, Morancho & Niso

n
5
6
7
8
9
10
11
12
13
14
15

opt
9(16)
18(18)
21(28)
28(36)
38(43)
46(54)
57(64)
68(76)
79(90)
92(104)
106(119)

n. sol.
1
48
2
1
76
3590
73
129126
1682
11
?

BE
0
0
0
0
4
27
210
1638
13788
105
*

CP
0
0
4
76
> 600
*
*
*
*
*
*

IP
0
1
3
26
> 600
*
*
*
*
*
*

CP/IP
0
0
0
2
20
60
153
11536
12050
5  105
7  105

Figure 4: Experimental results of four different algorithms on the still-life problem. Times
are in seconds.

It can be observed that BE clearly outperforms CP and IP by orders of magnitude.
The n = 14 case is the largest instance that we could solve due to exhausting the available
space. Comparing BE with CP/IP, we observe that there is no clear winner. An additional
observation is that BE scales up very regularly, each execution requiring roughly eight times
more time and four times more space than the previous, which is in clear accordance with
the algorithm complexity.

4. Combining Search and Variable Elimination
One way to overcome the high space complexity of BE is to combine search and variable
elimination in a hybrid approach HYB (Larrosa & Schiex, 2003). The idea is to use search
(i.e, instantiations) in order to break the problem into independent smaller parts where
variable elimination can be efficiently performed.
Let us reformulate the problem in a more convenient way for the hybrid algorithm. For
the sake of simplicity and without loss of generality consider that n is even. We cluster
R
row variables into three meta-variables: xC
i denotes the two central cells of row i, xi and
n
L
xi denote the 2  1 remaining cells on the right and left, respectively (see Figure 5.A).
L
R
Consequently, xC
i takes values in the range [0..3], xi and xi take values in the range
n
1
[0..2 2  1]. Cost functions are accordingly clustered,
n

fiL

=

2
X

fiR =

fij ,

n
X
j= n
+1
2

j=1

The new, equivalent, objective function is,
F =

n
X

(fiL + fiR )

i=1

430

fij

fiOn the practical use of variable elimination

Left

X

L
1

Center

X

C
1

Right

X

Left

R
1

Center

Right

X1

X2

X3
X

L
i

X

C
i

X

R
i

X4

X

L
n

X

C
n

X

X5

R
n

X6

B

A
Left

Center

Right

Left

Center

Right

X1
X1
X2
X2
X3
X3
X4
X4
X5
X5
X6
X6
C

D

Figure 5: Formulation of SL(n) used by the hybrid algorithm. A: Each row is clustered
into three variables. B: Constraint graph of SL(6). C: Constraint graph after
C
C
the assignment of xC
n , xn1 and xn2 . D: Constraint graph after the elimination
L
R
of xn and xn .

431

fiLarrosa, Morancho & Niso

C
L C
L
C
The scopes of internal row functions, fiL and fiR , are {xL
i1 , xi1 , xi , xi , xi+1 , xi+1 } and
C
R
C
R
C
R
L
R
L
C
C
{xi1 , xi1 , xi , xi , xi+1 , xi+1 }. Top functions f1 and f1 have scopes {x1 , x1 , xL
2 , x2 }
R C
R
L
R
L
C
L C
and {xC
1 , x1 , x2 , x2 }. Bottom functions fn and fn have scopes {xn1 , xn1 , xn , xn } and
R
C
R
C
{xn1 , xn1 , xn , xn }. Figure 5.B shows the corresponding constraint graph. The imporR
tance of this formulation is that xL
i and xi are independent (i.e, there is no edge in the
constraint graph connecting left and right variables).

The hybrid algorithm HYB searches over the central variables and eliminates the lateral
variables. Variables are considered in decreasing order of their index. Thus, the algorithm
C
C
starts instantiating xC
n , xn1 and xn2 , which produces a subproblem with the constraint
R
graph shown in Figure 5.C. Observe that variable xL
n (respectively, xn ) is only connected
L
L
R
R
with variables xn1 and xn2 (respectively, xn1 and xn2 ). Then it is eliminated producing
L
R
R
R
a new function gnL with scope {xL
n2 , xn1 } (respectively, gn with scope {xn2 , xn1 }).
Figure 5.D shows the resulting constraint graph. Lateral variables have domains of size
n
n
2 2 1 . Hence, their elimination is space (2n ) and time (23 2 ). It is important to note that
C
C
these eliminations are subject to the current assignment of xC
n , xn1 and xn2 . Therefore,
they have to be recomputed when their value change. After the elimination of xL
n and
C
xR
,
the
algorithm
would
assign
variable
x
which
will
make
possible
the
elimination
of
n
n3
L
R
C
xn1 and xn1 , and so on. At an arbitrary level of search, the algorithm assigns xi , which
R
makes xL
i+2 and xi+2 independent of the central columns and only related to their two
L and
variables above. Then, it eliminates them by replacing the variables by functions gi+2
R with scopes {xL , xL } and {xR , xR }, respectively. Formally, HYB applies a recursion
gi+2
i
i+1
i
i+1
that transforms subproblem P into 4 simpler subproblems {((P |xC =v ) xL ) xR }3v=0 . It
i
i+2
i+2
satisfies the following property,

Property 2 Let giL be the function computed by HYB used to replace variable xL
i . Then
L
giL (a, b) is the cost of the best extension of (xL
=
a,
x
=
b)
to
eliminated
variables
i2
i1
L
R
(xL
i , . . . , xn ), conditioned to the current assignment. Similarly, for the right side, gi (a, b)
R
R
R
is the cost of the best extension of (xi2 = a, xi1 = b) to eliminated variables (xi , . . . , xR
n ),
conditioned to the current assignment.

L (a, b) among all comA consequence of the previous Property is that the minimum gi+2
binations of a and b is a lower bound of the best cost that can be obtained in the left
L (a, b)} +
part of the grid if we continue the current line of search. Therefore, mina,b {gi+2
R
mina,b {gi+2 (a, b)} is a valid lower bound of the current node and can be used for pruning
purposes.

The space complexity of the algorithm is (n  2n ), due to the giL and giR functions
which need to be explicitly stored. The time complexity is O(n  23.5n ), because O(4n )
nodes may be visited (n variables with domains of size 4) and the cost of processing each
n
node is (n  23 2 ) due to the variable eliminations.
Thus, comparing with BE, the time complexity increases from (n2 23n ) to O(n23.5n ).
This is the prize HYB pays for the space decrement from (n  22n ) to (n  2n ).
432

fiOn the practical use of variable elimination

4.1 Refining the Lower Bound
It is well-known that the average-case efficiency of search algorithms depends greatly on
the lower bound that they use. Our algorithm is using a poor lower bound based on the giL
and giR functions, only.
Kask and Dechter (2001) proposed a general method to incorporate information from
yet-unprocessed variables into the lower bound. Roughly, the idea is to run mini buckets
(MB) prior search and save intermediate functions for future use. MB is executed using the
reverse order in which search will instantiate the variables. When the execution of MB is
completed, the search algorithm is executed. At each node, it uses mini-bucket functions
as compiled look-ahead information. In this Subsection, we show how we have adapted this
idea to SL(n) and how we have integrated it into HYB.
C
R
Consider SL(n) formulated in terms of left, central and right variables (xL
i , xi , xi ).
L
C
R
The exact elimination of the first row variables (x1 , x1 , x1 ) can be done using super-bucket
B1 = {f1L , f1R , f2L , f2R } and computing the function,
C
R
h1 = (f1L + f1R + f2L + f2R )  {xL
1 , x1 , x1 }
C
R L C
R
The scope of h1 is {xL
2 , x2 , x2 , x3 , x3 , x3 }. Using the mini-buckets idea, we partition the
L
L
L
R
bucket into B1 = {f1 , f2 } and B1 = {f1R , f2R }. Then, we approximate h1 by two smaller
R
functions hL
1 and h1 ,
L
L
L C
hL
1 = (f1 + f2 )  {x1 , x1 }
R
R
C
R
hR
1 = (f1 + f2 )  {x1 , x1 }
R
L C
L C
C
R C
R
The scopes of hL
1 and h1 are {x2 , x2 , x3 , x3 } and {x2 , x2 , x3 , x3 }, respectively. The same
idea is repeated row by row in increasing order. In general, processing row i, yields two
functions,
L
L
L C
hL
i = (hi1 + fi+1 )  {xi , xi }
R
R
C
R
hR
i = (hi1 + fi+1 )  {xi , xi }
R
L
C
L
C
C
R
C
R
The scopes of hL
i and hi are {xi+1 , xi+1 , xi+2 , xi+2 } and {xi+1 , xi+1 , xi+2 , xi+2 }, respecL
0
0
tively. By construction, hi (a, a , b, b ) contains the cost of the best extension of a, a0 , b, b0
C
L C
to processed variables xL
i , xi , . . . , x1 , x1 considering left functions only. We have the same
0
0
property for hR
i (a , a, b , b) and right functions.
The complexity of MB is space (n2n ) and time (n2 21.5n ). Since these complexities
are smaller than the complexity of HYB, running this pre-process does not affect its overall
complexity.
R
After MB is executed, HYB can use the information recorded in the hL
i and hi functions.
L
R
Consider an arbitrary node in which HYB assigns xC
i and eliminates xi+2 and xi+2 . Let a
L
L
L (a, b)
and b be domain values of variables xi and xi+1 . From Property 2 we have that gi+2
contains the best extension of a, b that can be attained in the left part of rows i + 1
to n as long as the current assignment X C is maintained. Additionally, we have that
C
C
hL
i1 (a, xi , b, xi+1 ) contains the best extension of a, b that can be attained in the left part
L (a, b) + hL (a, xC , b, xC ) is a lower bound for a, b and X C
of rows i to 1. Therefore, gi+2
i1
i
i+1
of the left part of the grid. Consequently,
L
C
C
mina,b[0..2 n2 1 1] {gi+2
(a, b) + hL
i1 (a, xi , b, xi+1 )}

433

fiLarrosa, Morancho & Niso

is a lower bound of the left part of the grid for the current assignment. With the same
reasoning on the right part we have that,
L
C
C
mina,b[0..2 n2 1 1] {gi+2
(a, b) + hL
i1 (a, xi , b, xi+1 )} +
R
C
C
+mina,b[0..2 n2 1 1] {gi+2
(a, b) + hR
i1 (xi , a, xi+1 , b)}

is a lower bound of the current assignment.
4.2 Refining the Upper Bound
The efficiency of the algorithm also depends on the initial value of the upper bound. A
good upper bound facilitates pruning earlier in the search tree. Bosch and Trick (2002)
suggested to modify SL(n) by adding the additional constraint of considering symmetric
patterns, only. Since the space of solutions becomes considerably smaller, the problem is
presumably simpler. Clearly, the cost of an optimal symmetric stable pattern is an upper
bound of the optimal cost of SL(n). It has been observed that such upper bounds are very
tight.
Since the motivation of our work is to use variable elimination techniques, we have
considered still-lifes which are symmetric over a vertical reflection, because they can be
efficiently solved using BE. The symmetric still-life problem SSL(n) consists on finding a
n  n stable pattern of maximum density in the game of life subject to a vertical reflection
symmetry (namely, the state of cells (i, j) and (i, n  j + 1) must be the same.6
Adapting BE to solve SSL(n) is extremely simple: we only need to remove symmetrical
values from the domains. Let us assume that n is an even number (the odd case is similar).
We represent a symmetric sequences of bits of length n by considering the left side of the
sequence (i.e, the first n/2 bits). The right part is implicit in the left part. Thus, we
n
represent symmetrical sequences of n bits as integers in the interval [0..2 2  1]. Reversing a
sequence of bits a is noted a. Hence, if a is a sequence of n/2 bits, a  a is the corresponding
symmetrical sequence of n bits.
The complexity of BE, when applied to SSL(n) is time (n2 21.5n ) and space (n2n ).
Therefore, executing it prior HYB and setting the upper bound with its optimal cost does
not affect the overall complexity of the hybrid.
4.3 Further Exploitation of Symmetries
SL(n) is a highly symmetric problem. For any stable pattern, it is possible to create an
equivalent pattern by: (i) rotating the board by 90, 180 or 270 degrees, (ii) reflecting
the board horizontally, vertically or along one diagonal or (iii) doing any combination of
rotations and reflections.
Symmetries can be exploited at very different algorithmic levels. In general, we can
save any computation whose outcome is equivalent to a previous computation due to a
symmetry if we have kept its outcome. For instance, in MB it is not necessary to compute
0
0
L
0
0
hR
i (a , a, b , b) because it is equal to hi (a, a , b, b ) due to the vertical reflection symmetry.
C
C
Another example occurs in HYB. Let xn = vn , xC
n1 = vn1 , . . . , xi = vi be the current
6. Unlike Smiths (2002) work we cannot easily exploit a larger variety of symmetries such as rotations and
diagonal reflections.

434

fiOn the practical use of variable elimination

n
13
14
15
16
17
18
19
20
22
24
26
28

opt
79(90)
92(104)
106(119)
120(136)
137(152)
153(171)
171(190)
190(210)
?
?
?
?

opt-SSL
79
92
106
120
137
154
172
192
232
276
326
378

CP/IP
12050
5  105
7  105
*
*
*
*
*
*
*
*
*

BE
13788
105
*
*
*
*
*
*
*
*
*
*

HYB
2
2
58
7
1091
2029
56027
2  105
*
*
*
*

HYB no LB
2750
7400
2  105
6  105
*
*
*
*
*
*
*
*

HYB no UB
2
3
61
49
2612
2311
56865
2  105
*
*
*
*

Figure 6: Experimental results of three different algorithms on the still-life problem. Times
are in seconds.

C
C
assignment. The reversed assignment xC
n = vn , xn1 = vn1 , . . . , xi = vi is equivalent due
to the vertical reflection symmetry. Thus, if it has already been considered, the algorithm
can backtrack. Our implementation uses these tricks and some others which we do not
report because it would require a much lower level description of the algorithms.

5. Experimental Results
Figure 6 shows the empirical performance of our hybrid algorithm. The first column contains
the problem size. The second column contains the optimal value as the number of dead
cells (in parenthesis the corresponding number of living cells). The third column contains
the optimal value of the symmetrical problem SSL(n), obtained by executing BE. It can
be observed that SSL(n) provides very tight upper bounds to SL(n). The fourth column
reports the time obtained with the CP/IP algorithm (Bosch & Trick, 2002). The fifth
column reports times obtained with BE. The sixth column contains times obtained with
our hybrid algorithm HYB. As it can be seen, the performance of HYB is spectacular. The
n = 14 and n = 15 instances, which require several days of CPU, are solved by HYB in a few
seconds. Instances up to n = 18 are solved in less than one hour. The largest instance that
we can solve is n = 20, which requires about two days of CPU (Figure 7 shows the optimal
n = 19 and n = 20 still-lifes). Regarding space, our computer can handle executions of
HYB up to n = 22. However, neither the n = 21 nor the n = 22 instance could be solved
within a week of CPU. It may seem that solving the n = 20 instance is a petty progress with
respect previous results on the problem. This is clearly not the case. The search space of
2
2
the n = 15 and n = 20 instances have size 215 = 2225 and 220 = 2400 , respectively. Thus,
we have been able to solve a problem with a search space 2175 times larger than before.
Since BE scales up very regularly, we can accurately predict that it would require 4000 Gb
of memory and about 7 centuries to solve the n = 20 instance.
435

fiLarrosa, Morancho & Niso

Figure 7: Maximum density still-lifes for n = 19 and n = 20.

Since HYB combines several techniques, it is interesting to assess the impact of each
one. The seventh column reports times obtained with HYB without using mini-buckets
information in the lower bound. As can be seen, the algorithm is still better than plain BE,
but it performance is dramatically affected. The information gathered during the preprocess
improves the quality of the lower bound and anticipates pruning. Finally, the eighth column
reports times obtained with HYB without having the upper bound initialized to SSL(n).
In this case we see that the importance of this technique is quite limited. The reason is
that HYB, even with a bad initial upper bound, finds the optimum very rapidly and, after
that moment, the quality of the initial upper bound becomes irrelevant.

6. Extension to Other Domains
The SL(n) problem has a very well defined structure, and the hybrid algorithm that we
have proposed makes an ad hoc exploitation of it. It is easy to find the right variables to
instantiate and eliminate. It is also easy to find a variable order for which mini buckets
produces good quality lower bounds. A natural question is whether it is possible to apply
similar ideas to not so well structured problems. The answer is that it is often possible,
although we need to rely on more naive and consequently less efficient exploitation of the
problems structure. In this Section we support our claim by reporting additional experimental results on different benchmarks. In particular, we consider spot5 and DIMACS
instances. Spot5 instances are optimization problems taken from the scheduling of an earth
observation satellite (Bensana, Lemaitre, & Verfaillie, 1999). The DIMACS benchmark contains SAT instances from several domain. Since we are concerned with optimization tasks,
we have selected some unsatisfiable instances and solved the Max-SAT task (i.e, given an
unsatisfiable SAT instance, find the maximum number of clauses that can be simultaneously
satisfied), which can be modeled as a WCSP (de Givry, Larrosa, Meseguer, & Schiex, 2003).
We consider aim instances (artificially generated random 3-SAT), pret (graph coloring), ssa
and bf (circuit fault analysis).
Figure 8 shows the constraint graph of one instance of each domain, as visualized by
LEDA graph editor. It can be observed that these graphs do not have an obvious pattern
436

fiOn the practical use of variable elimination

Figure 8: Constraint graph of four WCSP instances. From the top-left corner, clockwise,
aim-100-1-6-no-1, pret60-25, ssa0432-003 and Spot5-404.

to be exploited. Thus, we have to use variable elimination techniques in a more naive way.
We solve the problems with the generic WCSP solver toolbar7 (TB). It performs a depthfirst branch-and-bound search and it is enhanced with general-purpose dynamic variable and
value ordering heuristics. We modified toolbar to combine search and variable elimination
as follows: at an arbitrary subproblem, every variable with degree less than 3 is eliminated.
Only when all the variables have degree larger than or equal to 3, an unassigned variable is
heuristically selected and each of its domain values are heuristically ordered and sequentially
instantiated. The process is recursively applied to each of the subproblems. Note that
this is a generic version of the HYB algorithm where the decision of which variables are
instantiated and which variables are eliminated is left to a heuristic, instead of establishing
7. Available at http://carlit.toulouse.inra.fr/cgi-bin/awki.cgi/SoftCSP.

437

fiLarrosa, Morancho & Niso

it by hand. We will refer to this implementation as TBHY B . Toolbar offers a variety
of lower bounds based on different forms of local consistency (Larrosa & Schiex, 2003).
One of them, directional arc consistency (DAC*), is essentially equivalent to mini-buckets
of size 2 and, therefore, similar in spirit to the lower bound computed by HYB. However,
unlike HYB where mini-buckets are executed only once as a pre-process, toolbar executes
DAC* at every search state, subject to the current subproblem. It has been shown by Kask
(2000) that this approach is generally more efficient. The other main difference with respect
HYB, is that toolbar executes DAC* subject to an arbitrary variable ordering (in HYB
a good order was identified from the problem structure). Other lower bounds available
in toolbar are node consistency (NC*) which is weaker than DAC*, and full directional
arc consistency (FDAC*) which can be seen as a (stronger) refinement of DAC*. We have
F DAC
B
experimented with four algorithms: TBN C , TBDAC , TBDAC
HY B and TBHY B , where A
denotes algorithm A with lower bound B.
Most spot5 instances are too difficult for toolbar. Therefore, we decreased their size
by letting toolbar make a sequence of k greedy assignments driven by its default variable
and value ordering heuristics. The result is a subproblem with k less variables. In the
following, Ik denotes instance I where k variables have been greedily assigned by toolbar
with default parameters.
Table 9 reports the result of these experiments. The first column indicates the instances
and subsequent columns indicate the CPU time (in seconds) required by the different algorithms. A time limit of 3600 seconds was set up for each execution. It can be observed that
toolbar with the weakest lower bound (TBN C ) is usually the most inefficient alternative.
It cannot solve any of the spot5 instances and also fails with several aim and ssa instances.
When toolbar is enhanced with a mini buckets lower bound (TBDAC ) all spot5 problems
are solved. In the other domains, the new lower bound does not produce a significant effect. When we further add variable elimination (TBDAC
HY B ) all the problems are solved. In
general, there is a clear speed-up. The worst improvements are in the pret instances where
the time is divided by a factor of 2 and the best ones are obtained in the spot5 50340 and
ssa7552-158 instances which are solved instantly. Typical speed-ups range from 5 to 10.
DAC ) has a limited
Finally, we observe that the addition of the stronger lower bound (TBFHY
B
effect in these problems. Only the execution of instance ssa7552-038 is clearly accelerated.
Therefore, from these experiments we can conclude that the main techniques that we used
to solve the still-life problem can also be successfully applied to other domains.

7. Conclusions
In this paper we have studied the applicability of variable elimination to the problem of
finding still-lifes. Finding still-lifes is a challenging problem and developing new solving
techniques is an interesting task per se. Thus, the first contribution of this paper is the
observation that plain variable elimination (i.e, BE) is competitive in practice and provides
time complexity exponentially better than search-based approaches. Besides, we have developed an algorithm with which we have been able to solve up to the n = 20 instance,
with which we clearly improved previous results. The second contribution of the paper
has a deeper insight. Our algorithm uses recent techniques based on variable elimination.
Since these techniques are little known and rarely applied in the constraints community,
438

fiOn the practical use of variable elimination

Problem
Spot5 4040
Spot5 408100
Spot5 412200
Spot5 414260
Spot5 50340
Spot5 505120
Spot5 507200
Spot5 509240
aim-100-1-6-no-1
aim-100-1-6-no-2
aim-100-1-6-no-3
aim-100-1-6-no-4
aim-100-2-0-no-1
aim-100-2-0-no-2
aim-100-2-0-no-3
aim-100-2-0-no-4
bf0432-007
pret60-25
pret60-40
ssa0432-003
ssa2670-141
ssa7552-038
ssa7552-158

T BN C
2516
1191
1222
2162
110
110
22
-

T BDAC
242
314
223
1533
546
3353
204
684
2007
931
850
1599
120
120
22
-

DAC
T BHY
B
40
48
47
221
0
84
58
166
1665
707
1960
2716
830
479
319
738
1206
49
48
5
749
20
0

F DAC
T BHY
B
40
43
42
139
0
84
42
121
1427
571
1627
2375
583
285
278
600
1312
56
56
5
767
2
1

Figure 9: Experimental results in some WCSP instances with four different algorithms.
Each column reports CPU time in seconds. Symbol - indicates that a time limit
of 3600 seconds has been reached.

the results presented in this paper add new evidence of their potential. We have also shown
that variable elimination can be used beyond the academic still-life problem by providing
experimental results in some unstructured realistic problems from different domains.

Acknowledgments
The authors are grateful to Barbara Smith, Neil Yorke-Smith and the anonymous reviewers
for their useful comments at different stages of the work reported in this article. Marti
Sanchez kindly made the plots in Figure 8. This research has been funded by the Spanish
CICYT under project TIC2002-04470-C03-01.

References
Bensana, E., Lemaitre, M., & Verfaillie, G. (1999). Earth observation satellite management.
Constraints, 4(3), 293299.
Bertele, U., & Brioschi, F. (1972). Nonserial Dynamic Programming. Academic Press.
439

fiLarrosa, Morancho & Niso

Bistarelli, S., Montanari, U., & Rossi, F. (1997). Semiring-based constraint satisfaction and
optimization. Journal of the ACM, 44 (2), 201236.
Bosch, R., & Trick, M. (2002). Constraint programming and hybrid formulations for three
life designs. In Proceedings of the International Workshop on Integration of AI and
OR Techniques in Constraint Programming for Combinatorial Optimization Problems,
CP-AI-OR02, pp. 7791.
Cabon, B., de Givry, S., Lobjois, L., Schiex, T., & Warners, J. (1999). Radio link frequency
assignment. Constraints, 4, 7989.
de Givry, S., Larrosa, J., Meseguer, P., & Schiex, T. (2003). Solving max-sat as weighted
csp. In Proc. of the 9th CP, pp. 363376, Kinsale, Ireland. LNCS 2833. Springer
Verlag.
Dechter, R. (1999). Bucket elimination: A unifying framework for reasoning. Artificial
Intelligence, 113, 4185.
Dechter, R., & Pearl, J. (1989). Tree clustering for constraint networks. Artificial Intelligence, 38, 353366.
Dechter, R., & Fatah, Y. E. (2001). Topological parameters for time-space tradeoff. Artificial
Intelligence, 125 (12), 93118.
Dechter, R., & Rish, I. (2003). Mini-buckets: A general scheme for bounded inference.
Journal of the ACM, 50 (2), 107153.
Gardner, M. (1970). The fantastic combinations of john conways new solitary game. Scientific American, 223, 120123.
Kask, K. (2000). New search heuristics for max-csp. In Proc. of the 6th CP, pp. 262277,
Singapore. LNCS 1894. Springer Verlag.
Kask, K., & Dechter, R. (2001). A general scheme for automatic generation of search
heuristics from specification dependencies. Artificial Intelligence, 129, 91131.
Larrosa, J., & Dechter, R. (2003). Boosting search with variable elimination in constraint
optimization and constraint satisfaction problems. Constraints, 8 (3), 303326.
Larrosa, J., & Schiex, T. (2003). In the quest of the best form of local consistency for
weighted csp. In Proc. of the 18th IJCAI, Acapulco, Mexico.
Pearl, J. (1988). Probabilistic Inference in Intelligent Systems. Networks of Plausible Inference. Morgan Kaufmann, San Mateo, CA.
Sandholm, T. (1999). An algorithm for optimal winner determination in combinatorial
auctions. In IJCAI-99, pp. 542547.
Smith, B. (2002). A dual graph translation of a problem in life. In Proc. of CP-2002, pp.
01, Ithaca, USA. LNCS. Springer Verlag.

440

fi