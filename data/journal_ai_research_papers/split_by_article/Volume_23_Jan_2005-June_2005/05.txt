Journal of Artificial Intelligence Research 23 (2005) 245-297

Submitted 12/03; published 03/05

Graduality in Argumentation
Claudette Cayrol
Marie-Christine Lagasquie-Schiex

ccayrol@irit.fr
lagasq@irit.fr

IRIT-UPS, 118 route de Narbonne
31062 Toulouse Cedex, FRANCE

Abstract
Argumentation is based on the exchange and valuation of interacting arguments, followed
by the selection of the most acceptable of them (for example, in order to take a decision,
to make a choice). Starting from the framework proposed by Dung in 1995, our purpose
is to introduce graduality in the selection of the best arguments, i.e. to be able to
partition the set of the arguments in more than the two usual subsets of selected and
non-selected arguments in order to represent different levels of selection. Our basic idea
is that an argument is all the more acceptable if it can be preferred to its attackers. First,
we discuss general principles underlying a gradual valuation of arguments based on their
interactions. Following these principles, we define several valuation models for an abstract
argumentation system. Then, we introduce graduality in the concept of acceptability
of arguments. We propose new acceptability classes and a refinement of existing classes
taking advantage of an available gradual valuation.

1. Introduction
As shown by Dung (1995), argumentation frameworks provide a unifying and powerful
tool for the study of several formal systems developed for common-sense reasoning, as well
as for giving a semantics to logic programs. Argumentation is based on the exchange and
valuation of interacting arguments which support opinions and assertions. It can be applied,
among others, in the legal domain, for collective decision support systems or for negotiation
support.
The fundamental characteristic of an argumentation system is the interaction between arguments. In particular, a relation of attack may exist between arguments. For example, if
the argument takes the form of a logical proof, arguments for a proposition and arguments
against this proposition can be advanced. In that case, the attack relation relies on logical
inconsistency.
The argumentation process is usually divided in two steps: a valuation of the relative
strength of the arguments, followed by the selection of the most acceptable arguments.
In the valuation step, it is usual to distinguish two different types of valuations:
intrinsic valuation: here, the value of an argument is independent of its interactions
with the other arguments. This enables to simply express to what extent an argument
increases the confidence in the statement it supports (see Pollock, 1992; Krause, Ambler, Elvang, & Fox, 1995; Parsons, 1997; Prakken & Sartor, 1997; Amgoud & Cayrol,
1998; Kohlas, Haenni, & Berzati, 2000; Pollock, 2001).
c
2005
AI Access Foundation. All rights reserved.

fiCayrol, Lagasquie-Schiex

For example, in the work of Krause et al. (1995), using the following knowledge base,
composed of (formula, probability) pairs {(1 , 0.8), (2 , 0.8), (3 , 0.8), ((1  2 
4 ), 1), ((1  3  4 ), 1)}, two arguments can be produced1 :
A1 =< {1 , 2 , (1  2  4 )}, 4 >
and A2 =< {1 , 3 , (1  3  4 )}, 4 >.

Both arguments have the same weight 0.8  0.8  1 = 0.64, and the formula  4 has
the weight 0.64 + 0.64  0.512 = 0.7682 .
interaction-based valuation: here the value of an argument depends on its attackers
(the arguments attacking it), the attackers of its attackers (the defenders), etc. 3
Several approaches have been proposed along this line (see Dung, 1995; Amgoud &
Cayrol, 1998; Jakobovits & Vermeir, 1999; Besnard & Hunter, 2001) which differ in
the sets of values used. Usually, two values are considered. However, there are very
few proposals which use more than two values (three values in Jakobovits & Vermeir,
1999, and an infinity of values in Besnard & Hunter, 2001).
For example, in the work of Besnard and Hunter (2001), the set of values is the
interval of the real line [0, 1]. In this case, with the set of arguments4 {A1 , A2 , A3 }
and considering that A1 attacks A2 which attacks A3 , the value of the argument A1
(resp. A2 , A3 ) is 1 (resp. 21 , 32 ).
Intrinsic valuation and interaction-based valuation have often been used separately, according to the considered applications. Some recent works however consider a combination of
both approaches (see Amgoud & Cayrol, 1998; Karacapilidis & Papadias, 2001; Pollock,
2001).
Considering now the selection of the more acceptable arguments, it is usual to distinguish
two approaches:
individual acceptability: here, the acceptability of an argument depends only on its
properties. For example, an argument can be said acceptable if and only if it does not
have any attacker (in this case, only the interaction between arguments is considered,
see Elvang-Goransson et al., 1993). In the context of an intrinsic valuation, an argument can also be said acceptable if and only if it is better than each of its attackers
(see Amgoud & Cayrol, 1998).
collective acceptability: in this case, the acceptability of a set of arguments is explicitly
defined. For example, to be acceptable, a set of arguments may not contain two
1. Here, the arguments are under the form of an Explanation-Conclusion Pair. This is one possible way
to compute arguments (see also Lin & Shoham, 1989; Vreeswijk, 1997; Pollock, 1992; Prakken & Sartor,
1997; Simari & Loui, 1992; Elvang-Goransson, Fox, & Krause, 1993; Kohlas et al., 2000; Amgoud &
Cayrol, 2002).
2. Weights being probabilities, the weight of an argument is the probability of the conjunction of the
formulae of the argument, and the weight of 4 is the probability of the disjunction of A1 and A2 .
3. Here, we consider only the interactions corresponding to attacks between arguments. There exist also
some other types of interactions (for example, arguments which reinforce other arguments instead of attacking them, see Karacapilidis & Papadias, 2001; Verheij, 2002). For this kind of interaction, graduality
has not been considered.
4. Here, the initial knowledge base is useless.

246

fiGraduality in argumentation

arguments such that one attacks the other (interactions between arguments are used).
Dungs (1995) framework is well suited for this kind of approach but allows only for
a binary classification: the argument belongs or does not belong to an acceptable set.
It is clear that except for intrinsic valuations, most proposals do not allow for any gradual
notion of valuation or acceptability (i.e. there is a low number of levels to describe values
and the acceptability is usually binary). Our aim is therefore to introduce graduality in
these two steps.
However, the processes of valuation and of selection are often linked together. This is the
case when the selection is done on the basis of the value of arguments5 or when the selection
defines a binary valuation on arguments. We will therefore:
first consider and discuss the general principles concerning the definition of a gradual
interaction-based valuation and then define some valuation models in an abstract
argumentation system,
then, introduce the notion of graduality in the definition of the acceptability using the
previously defined gradual valuations, but also some more classical mechanisms.
Some graduality has already been introduced in argumentation systems. For instance, in
the work of Pollock (2001), degrees of justification for beliefs are computed. Arguments are
sequences of conclusive and/or prima-facie inferences. Arguments are collected in a graph
where a node represents the conclusion of an argument, a support link ties a node to nodes
from which it is inferred, and an attack link indicates an attack between nodes. The degree
of justification of a belief is computed from the strength of the arguments concluding that
belief and the strength of the arguments concluding on an attacker of the belief.
Our work takes place in a more abstract framework since we do not consider any argument
structure. Our valuation models are based on interactions between arguments and directly
apply to arguments.
We use the framework defined by Dung (1995): a set of arguments and a binary attack
relation between arguments. We also use a graphical representation of argumentation systems (see Section 2). The gradualisation of interaction-based valuations will be presented
in Section 3. Then, in Section 4, we will consider different mechanisms leading to gradual
acceptability, sometimes relying on the gradual valuations defined in Section 3. We will
conclude in Section 5.
All the proofs of the properties stated in Sections 3 and 4 will be given in Appendix A.

2. Dungs (1995) framework and its graphical representation
We consider the abstract framework introduced by Dung (1995). An argumentation system
<A, R> is a set A of arguments and a binary relation R on A called an attack relation:
consider Ai and Aj  A, Ai RAj means that Ai attacks Aj or Aj is attacked by Ai (also
denoted by (Ai , Aj )  R).
5. For example, using Besnard and Hunters (2001) valuation, we can decide that all the arguments whose
value is > 0.5 are selected, because 0.5 is the mean value of the set of values; Another possibility, with
different valuations (interaction-based or intrinsic), is to accept an argument when its value is better
than the value of each of its attackers.

247

fiCayrol, Lagasquie-Schiex

An argumentation system is well-founded if and only if there is no infinite sequence A 0 , A1 ,
. . . , An , . . . such that i, Ai  A and Ai+1 RAi .
Here, we are not interested in the structure of the arguments and we consider an arbitrary
attack relation.
Notation: <A, R> defines a directed graph G called the attack graph. Consider A  A,
the set R (A) is the set of the arguments attacking A6 and the set R+ (A) is the set of the
arguments attacked by A7 .
Example 1
The system <A = {A1 , A2 , A3 , A4 }, R = {(A2 , A3 ), (A4 , A3 ), (A1 , A2 )}> defines the following graph G with the root8 A3 :
A1

A2
A3
A4

Definition 1 (Graphical representation of an argumentation system) Let G be the
attack graph associated with the argumentation system <A, R>, we define:
Leaf of the attack graph A leaf of G is an argument A  A without attackers9 .
Path in the attack graph A path from A to B is a sequence of arguments C = A1 
. . .  An such that:
A = A1 ,
A1 RA2 ,
...,
An1 RAn ,
An = B.
The length of the path is n  1 (the number of edges that are used in the path) and
will be denoted by lC .
A special case is the path10 from A to A whose length is 0.
The set of paths from A to B will be denoted by C(A, B).
6. R (A) = {Ai  A|Ai RA}.
7. R+ (A) = {Ai  A|ARAi }.
8. The word root is used in an informal sense (it just means that there are in the graph some paths
leading to this node). This term and other terms (leaf, branch, path, . . . ) which are used in this
document are standard in graph theory but may have a different definition. They are usual terms in the
argumentation domain. Please see Definition 1 in order to know their precise meaning in this document.
These definitions simply take into account the fact that the directed edges of our graph link attackers to
attacked argument).
9. A is a leaf iff R (A) = .
10. We will assume that there exists an infinity of such paths. This assumption greatly simplifies the handling
of leaves later in the paper.

248

fiGraduality in argumentation

Dependence, independence, root-dependence of a path
Consider 2 paths CA  C(A1 , An ) and CB  C(B1 , Bm ).
These two paths will be said dependent iff Ai  CA , Bj  CB such that Ai = Bj .
Otherwise they are independent.
These two paths will be said root-dependent in An iff An = Bm and Ai 6= An  CA ,
6 Bj  CB such that Ai = Bj .
Cycles in the attack graph A cycle11 is a path C = A1  . . .  An  A1 such that i, j 
[1, n], if i 6= j, then Ai 6= Aj .
A cycle C is isolated iff A  C, 6 B  A such that BRA and B 6 C.
Two cycles CA = A1  . . .  An  A1 and CB = B1  . . .  Bm  B1 are interconnected
iff i  [1, n], j  [1, m] such that Ai = Bj .
We use the notions of direct and indirect attackers and defenders. The notions introduced
here are inspired by related definitions first introduced by Dung (1995) but are not strictly
equivalent12 .
Definition 2 (Direct/Indirect Attackers/Defenders of an argument) Consider A 
A:
The direct attackers of A are the elements of R (A).
The direct defenders of A are the direct attackers of the elements of R (A).
The indirect attackers of A are the elements Ai defined by:
C  C(Ai , A) such that lC = 2k + 1, with k  1.
the indirect defenders of A are the elements Ai defined by:
C  C(Ai , A) such that lC = 2k, with k  2.
If the argument A is an attacker (direct or indirect) of the argument B, we say that A
attacks B (or that B is attacked by A). In the same way, if the argument A is a defender
(direct or indirect) of the argument B, then A defends B (or B is defended by A).
Note that an attacker can also be a defender (for example, if A1 attacks A2 which attacks
A3 , and A1 also attacks A3 ). In the same way, a direct attacker can be an indirect attacker
(for example, if A1 attacks A2 which attacks A3 which attacks A4 , and A1 also attacks A4 )
and the same thing may occur for the defenders.
Definition 3 (Attack branch and defence branch of an argument) Consider A 
A, an attack branch (resp. defence branch) for A is a path in G from a leaf to A whose
length is odd (resp. even). We say that A is the root of an attack branch (resp. a defence
branch).
11. This definition of a cycle corresponds to the definition of an elementary cycle in graph theory (an
elementary cycle does not contain 2 edges with the same initial extremity, or the same ending extremity).
12. In Dungs (1995) work, direct attackers (resp. defenders) are also indirect attackers (resp. defenders)
which is not true in our definitions.

249

fiCayrol, Lagasquie-Schiex

Note that this notion of defence is the basis of the usual notion of reinstatement (B attacks
C, A attacks B and C is reinstated because of A). In this paper, reinstatement is taken
into account indirectly, because the value of the argument C and the possibility for selecting
C will be increased thanks to the presence of A.
All these notions are illustrated on the following example:
Example 2

On this graph G, we can see:
a path from C2 to A whose length is 2 (C2  B1  A),
2 cycles A1  A3  A2  A1 and A1  A3  A4  A1 , of length
3, which are not isolated (note that A1  A3  A2  A1 
A3  A4  A1 is not a cycle with our definition),
the two previous cycles are interconnected (in A1 and A3 ),
the paths D1 C1 B1 and C3 B2 A are independent, the
paths D1  C1  B1  A and C3  B2  A are root-dependent
and the paths D1 C1 B1 A and C2 B1 A are dependent,
D1 , C2 , E1 are the leaves of G,
D1  C1  B1  A is an attack branch for A whose length is
3, C2  B1  A is a defence branch for A whose length is 2,
C2 , B1 and B2 are the direct attackers of A,
C1 , C2 (which is already a direct attacker of A) and C3 are
the direct defenders of A,
D1 and D2 are the two indirect attackers of A,
E1 is the only indirect defender of A.

A3

A4

A1

A2

A
B2

B1

C1

D1

C2

C3

D2

E1

3. Graduality in interaction-based valuations
We consider two different valuation methods for taking into account the quality of attackers
and defenders of an argument in order to define the value of an argument using only the
interaction between arguments13 :
In the first approach, the value of an argument only depends on the values of the direct
attackers of this argument. Therefore, defenders are taken into account through the
attackers. This approach is called local.
In the second approach, the value of an argument represents the set of all the attack
and the defence branches for this argument. This approach is called global.
The main difference between these two approaches is illustrated by the following example:
D

C1

C

B

B

C2

13. We pursue a work initiated in (Cayrol & Lagasquie-Schiex, 2003c) and propose some improvements.

250

fiGraduality in argumentation

In the local approach, B has two direct attackers (C2 and C1 ) whereas B 0 has only one
(C 0 ). Thus B 0 is better than B (since B 0 suffers one attack whereas B suffers two attacks).
In the global approach, two branches (one of attack and one of defence) lead to B whereas
only one branch of attack leads to B 0 . Thus B is better than B 0 (since it has at least one
defence whereas B 0 has none). In this case, C1 loses its negative status of attacker, since it
is in fact carrying a defence for B.
3.1 Local approach (generic valuation)
Some existing proposals can already be considered as examples of local valuations.
In Jakobovits and Vermeirs (1999) approach, a labelling of a set of arguments assigns a
status (accepted, rejected, undecided) to each argument using labels from the set {+, , ?}.
+ (resp. , ?) represents the accepted (resp. rejected, undecided) status. Intuitively,
an argument labelled with ? is both supported and weakened.
Definition 4 (Jakobovits and Vermeirs labellings, 1999) Let <A, R> be an argumentation system. A complete labelling of <A, R> is a function Lab : A  {+, ?, } such
that:
1. If Lab(A)  {?, } then B  R (A) such that Lab(B)  {+, ?}
2. If Lab(A)  {+, ?} then B  R (A)  R+ (A), Lab(B)  {?, }
The underlying intuition is that an argument can only be weakened (label  or ?) if one of
its direct attackers is supported (condition 1); an argument can get a support only if all its
direct attackers are weakened and an argument which is supported (label + or ?) weakens
the arguments it attacks (condition 2). So:
If
If
If
If

A has no attacker Lab(A) = +.
Lab(A) =? then B  R (A) such that Lab(B) =?.
(B  R (A), Lab(B) = ) then Lab(A) = +.
Lab(A) = + then B  R (A)  R+ (A), Lab(B) = .

Every argumentation system can be completely labelled. The associated semantics is that
S is an acceptable set of arguments iff there exists a complete labelling Lab of <A, R> such
that S = {A|Lab(A) = +}.
Other types of labellings are introduced by Jakobovits and Vermeir (1999) among which the
so-called rooted labelling which induces a corresponding rooted semantics. The idea is
to reject only the arguments attacked by accepted arguments: an attack by an undecided
argument is not rooted since an undecided attacker may become rejected.
Definition 5 (Jakobovits and Vermeirs labellings, 1999  continuation)
The complete labelling Lab is rooted iff A  A, if Lab(A) =  then B  R  (A) such that
Lab(B) = +.
The rooted semantics enables to clarify the links between all the other semantics introduced
by Jakobovits and Vermeir (1999) and some semantics introduced by Dung (1995).
251

fiCayrol, Lagasquie-Schiex

Example 3 On the following example:
An

An1

A2

A1

For n even, we obtain Lab(An ) = Lab(An2 ) = . . . = Lab(A2 ) = + and Lab(An1 ) =
Lab(An3 ) = . . . = Lab(A1 ) = .
For n odd, we obtain Lab(An ) = Lab(An2 ) = . . . = Lab(A1 ) = + and Lab(An1 ) =
Lab(An3 ) = . . . = Lab(A2 ) = 
Another type of local valuation has been introduced recently by Besnard and Hunter (2001)
for deductive arguments. The approach can be characterised as follows. An argument
is structured as a pair hsupport, conclusioni, where support is a consistent set of formulae
that enables to prove the formula conclusion. The attack relation considered here is strict
and cycles are not allowed. The notion of a tree of arguments allows a concise and
exhaustive representation of attackers and defenders of a given argument, root of the tree.
A function, called a categoriser, assigns a value to a tree of arguments. This value
represents the relative strength of an argument (root of the tree) given all its attackers and
defenders. Another function, called an accumulator, synthesises the values assigned to all
the argument trees whose root is an argument for (resp. against) a given conclusion. The
phase of categorisation therefore corresponds to an interaction-based valuation. Besnard
and Hunter (2001) introduce the following function Cat:
if R (A) = , then Cat(A) = 1
if R (A) 6=  with R (A) = {A1 , . . . , An }, Cat(A) =

1
1+Cat(A1 )+...+Cat(An )

Intuitively, the larger the number of direct attackers of an argument, the lower its value.
The larger the number of defenders of an argument, the larger its value.
Example 3 (continuation) We obtain:
Cat(A
n ) = 1, Cat(An1 ) = 0.5, Cat(An2 ) = 0.66, Cat(An3 ) = 0.6, . . . , and Cat(A1 ) =

( 5  1)/2 when n   (this value is the inverse of the golden ratio14 ).
So, we have:
If n is even Cat(An1 )  . . .  Cat(A3 )  Cat(A1 )  Cat(A2 )  . . .  Cat(An ) = 1
If n is odd Cat(An1 )  . . .  Cat(A2 )  Cat(A1 )  Cat(A3 )  . . .  Cat(An ) = 1
Our approach for local valuations is a generalisation of these two previous proposals in the
sense that Besnard and Hunters (2001) Cat function and Jakobovits and Vermeirs (1999)
labellings are instances of our approach.
The main idea is that the value of an argument is obtained with the composition of two
functions:
one for aggregating the values of all the direct attackers of the argument; so, this
function computes the value of the direct attack;
the other for computing the effect of the direct attack on the value of the argument:
if the value of the direct attack increases then the value of this argument decreases,
if the value of the direct attack decreases then the value of this argument increases.
14. The golden ratio is a famous number since the antiquity which has several interesting properties in
several domains (architecture, for example).

252

fiGraduality in argumentation

Let (W, ) be a totally ordered set with a minimum element (VMin ) and a subset V of W ,
that contains VMin and with a maximum element VMax .
Definition 6 (Generic gradual valuation) Let <A, R> be an argumentation system.
A valuation is a function v : A  V such that:
1. A  A, v(A)  VMin
2. A  A, if R (A) = , then v(A) = VMax
3. A  A, if R (A) = {A1 , . . . , An } 6= , then v(A) = g(h(v(A1 ), . . . , v(An )))
with h : V   W such that (V  denotes the set of all finite sequences of elements of V )
h(x) = x
h() = VMin
For any permutation (xi1 , . . . , xin ) of (x1 , . . . , xn ), h(xi1 , . . . , xin ) = h(x1 , . . . , xn )
h(x1 , . . . , xn , xn+1 )  h(x1 , . . . , xn )
if xi  x0i then h(x1 , . . . , xi , . . . , xn )  h(x1 , . . . , x0i , . . . , xn )
and g : W  V such that
g(VMin ) = VMax
g(VMax ) < VMax
g is non-increasing (if x  y then g(x)  g(y))
Note that h(x1 , . . . , xn )  max(x1 , . . . , xn ) is a logical consequence of the properties of the
function h.
A first property on the function g explains the behaviour of the local valuation in the case
of an argument which is the root of only one branch (like in Example 3):
Property 1 The function g satisfies for all n  1:
g(VMax )  g 3 (VMax )  . . .  g 2n+1 (VMax )  g 2n (VMax )  . . .  g 2 (VMax )  VMax
Moreover, if g is strictly non-increasing and g(VMax ) > VMin , the previous inequalities
become strict.
A second property shows that the local valuation induces an ordering relation on arguments:
Property 2 (Complete preordering) Let v be a valuation in the sense of Definition 6.
v induces a complete15 preordering  on the set of arguments A defined by: A  B iff
v(A)  v(B).
A third property handles the cycles:
15. A complete preordering on A means that any two elements of A are comparable.

253

fiCayrol, Lagasquie-Schiex

Property 3 (Value in a cycle) Let C be an isolated cycle of the attack graph, whose
length is n. If n is odd, all the arguments of the cycle have the same value and this value
is a fixpoint of the function g. If n is even, the value of each argument of the cycle is a
fixpoint of the function g n .
The following property shows the underlying principles satisfied by all the local valuations
defined according to our schema:
Property 4 (Underlying principles) The gradual valuation given by Definition 6 respects the following principles:
P1 The valuation is maximal for an argument without attackers and non maximal for an
attacked and undefended argument.
P2 The valuation of an argument is a function of the valuation of its direct attackers (the
direct attack).
P3 The valuation of an argument is a non-increasing function of the valuation of the direct
attack.
P4 Each attacker of an argument contributes to the increase of the valuation of the direct
attack for this argument.
The last properties explain why Jakobovits and Vermeir (1999) and Besnard and Hunter
(2001) propose instances of the local valuation described in Definition 6:
Property 5 (Link with Jakobovits & Vermeir, 1999)
Every rooted labelling of <A, R> in the sense of Jakobovits and Vermeir (1999) can be
defined as an instance of the generic valuation such that:
V = W = {, ?, +} with  < ? < +,
VMin = ,
VMax = +,
g defined by g() = +, g(+) = , g(?) =?
and h is the function max.
Property 6 (Link with Besnard & Hunter, 2001) The gradual valuation of Besnard
and Hunter (2001) can be defined as an instance of the generic valuation such that:
V = [0, 1],
W = [0, [,
VMin = 0,
VMax = 1,
1
g : W  V defined by g(x) = 1+x
and h defined by h(x1 , . . . , xn ) = x1 + . . . + xn .
254

fiGraduality in argumentation

Note that, in the work of Besnard and Hunter (2001), the valued graphs are acyclic. However, it is easy to show that the valuation proposed by Besnard and Hunter (2001) can be
generalised to graphs with cycles (in this case, we must solve second degree equations  see
Example 5).


















A






























B1B2B3









































C1

C3





C2
C4























































D1












D2
D3

































































E1















































































Example 4 Consider the following graph:

B4

In this example, with the generic valuation, we obtain:
v(E1 ) = v(D2 ) = v(D3 ) = v(C4 ) = v(B4 ) = VMax
v(D1 ) = v(C2 ) = v(C3 ) = v(B3 ) = g(VMax )
v(C1 ) = v(B2 ) = g 2 (VMax )
v(B1 ) = g(h(g 2 (VMax ), g(VMax )))
v(A) = g(h(g(h(g 2 (VMax ), g(VMax ))), g 2 (VMax ), g(VMax ), VMax ))
So, we have:
E 1 , D 2 , D 3 , C 4 , B4

C 1 , B2

D 1 , C 2 , C 3 , B3
However, the constraints on v(A) and v(B1 ) are insufficient to compare A and B1 with the
other arguments.
The same problem exists if we reduce the example to the hatched part of the graph in the
previous figure; we obtain E1 , D2  C1  D1 , C2 , but A and B1 cannot be compared with
the other arguments16 .
Now, we use the instance of the generic valuation proposed by Besnard and Hunter (2001):
v(E1 ) = v(D2 ) = v(D3 ) = v(C4 ) = v(B4 ) = 1,
v(D1 ) = v(C2 ) = v(C3 ) = v(B3 ) = 12 ,
v(C1 ) = v(B2 ) = 23 ,
16. v(A) = g 2 (h(g 2 (VMax , g(VMax ))) and v(B1 ) = g(h(g 2 (VMax ), g(VMax ))).

255

fiCayrol, Lagasquie-Schiex

6
,
v(B1 ) = 13
78
v(A) = 283 .

So, we have:
E 1 , D 2 , D 3 , C 4 , B4

C 1 , B2

D 1 , C 2 , C 3 , B3

B1

A
However, if we reduce the example to the hatched part of the graph, then the value of A is
13
19 . So, v(A) is better than v(B1 ) and v(D1 ), but also than v(C1 ) (A becomes better than
its defender).
Example 5 (Isolated cycle) Consider the following graph reduced to an isolated cycle:
A

B

.

A generic valuation gives v(A) = v(B) = fixpoint of g 2 .
If we use the instance proposed by Besnard and Hunter (2001), v(A) and v(B) are solutions
of the following second degree equation:
x2 + x  1 = 0.

1+ 5
So, we obtain: v(A) = v(B) =
 0.618 (the inverse of the golden ratio again).
2
3.2 Global approach (with tuples)
We now consider a second approach for the valuation step, called the global approach. Here,
the key idea is that the value of A must describe the subgraph whose root is A. So, we
want to memorise the length of each branch leading to A in a tuple (for an attack branch,
we have an odd integer, and for a defence branch, we have an even integer).
In this approach, the main constraint is that we must be able to identify the branches
leading to the argument and to compute their lengths. This is very easy in the case of an
acyclic graph. We therefore introduce first a global gradual valuation for acyclic graphs.
Then, in the next sections, we extend our proposition to the case of graphs with cycles, and
we study the properties of this global gradual valuation.
3.2.1 Gradual valuation with tuples for acyclic graphs
First, in order to record the lengths of the branches leading to the arguments, we use the
notion of tuples and we define some operations on these tuples:
256

fiGraduality in argumentation

Definition 7 (Tuple) A tuple is a sequence of integers. The tuple (0, . . . , 0, . . .) will be
|
{z
}
denoted by 0 . The tuple (1, . . . , 1, . . .) will be denoted by 1 .
|
{z
}





Notation 1 T denotes the set of the tuples built with positive integers.
Definition 8 (Operations on the tuples) We have two kinds of operations on tuples:
the concatenation of two tuples is defined by the function ? : T  T  T such that
0 ? t = t ? 0 = t for t 6= ()

(x1 , . . . , xn , . . .) ? (x01 , . . . , x0n , . . .) = Sort(x1 , . . . , xn , . . . , x01 , . . . , x0n , . . .)
Sort being the function which orders a tuple by increasing values.
the addition of a tuple and an integer is defined by the function  : T 
that

 T such

0  k = (k)
()  k = ()

(x1 , . . . , xn )  k = (x1 + k, . . . , xn + k)

(x1 , . . . , xn , . . .)  k = (x1 + k, . . . , xn + k, . . .) if (x1 , . . . , xn , . . .) 6= 0
Note that we allow infinite tuples, among other reasons, because they are needed later in
order to compute the ordering relations described in Section 3.2.4 (in particular when the
graph is cyclic).
The operations on the tuples have the following properties:
Property 7 (Properties of ? and )
The concatenation ? is commutative and associative.
For any tuple t and any integers k and k 0 , (t  k)  k 0 = t  (k + k 0 ).
For any integer k and any tuples t and t0 different from 017 , (t ? t0 )  k = (t  k) ? (t0  k).
In order to valuate the arguments, we split the set of the lengths of the branches leading
to the argument in two subsets, one for the lengths of defence branches (even integers) and
the other one for the lengths of attack branches (odd integers). This is captured by the
notion of tupled values:
Definition 9 (Tupled value) A tupled value is a pair of tuples vt = [vtp , vti ] with:
vtp is a tuple of even integers ordered by increased values; this tuple is called the even
component of vt;
vti is a tuple of odd integers ordered by increased values; this tuple is called the odd
component of vt.
17. Otherwise it is false : (0 ? (p))  k = (p + k), whereas (0  k) ? ((p)  k) = (k) ? (p + k) = (k, p + k).

257

fiCayrol, Lagasquie-Schiex

Notation 2 V denotes the subset of T  T of all tupled values (so, vt  V, vt is a pair
of tuples satisfying Definition 9).
Using this notion of tupled-values, we can define the computation process of the gradual
valuation with tuples18 in the case of acyclic graphs.
Definition 10 (Valuation with tuples for acyclic graphs) Let <A, R> be an argumentation system without cycles. A valuation with tuples is a function v : A  V such
that:
If A  A is a leaf then

v(A) = [0 , ()].

If A  A has direct attackers denoted by B1 , . . . , Bn , . . . then
v(A) = [vp (A), vi (A)] with:

vp (A) = (vi (B1 )1)?. . .?(vi (Bn )1)?. . .
vi (A) = (vp (B1 )1)?. . .?(vp (Bn )1)?. . .

Notes: The choice of the value [0 , ()] for the leaves is justified by the fact that the value
of an argument memorises all the lengths of the branches leading to the argument. Using
the same constraint, either vp (A) or vi (A) may be empty but not both19 .
Note also that the set of the direct attackers of an argument can be infinite (this property
will be used when we take into account an argumentation graph with cycles).
Example 6 On this graph, the valuation with tuples gives the following results:
A
B2

B1

C1

D1

On this graph G, we have:

C2

C3

D2

v(D1 ) = v(C2 ) = v(E1 ) = [0 , ()],
v(C1 ) = v(D2 ) = [(), (1)],
v(C3 ) = [(2), ()],
v(B1 ) = [(2), (1)],
v(B2 ) = [(), (3)],
v(A) = [(2, 4), (1, 3)].

E1

18. This definition is different from the definition given in (Cayrol & Lagasquie-Schiex, 2003c). The ideas
are the same but the formalisation is different.
19. The proof is the following:.
If A is not a leaf, at least one of the tuples is not empty, because there exists at least one branch
whose length is > 0 leading to A (see Definitions 8 and 10).
And, if A is a leaf, there also exists at least one defence branch because the path from A to A is
allowed and its length is 0 (in fact, there are an infinity of such paths  see Definition 1) and no attack
branch leading to the leaf (see Definition 10).
So, the value of a leaf is [0 , ()], and it is impossible that vp (A) = vi (A) = ().

258

fiGraduality in argumentation

3.2.2 Study of cycles
Handling cycles raises some important issues: the notion of branch is not always useful in a
cycle (for example, in an unattacked cycle like in Examples 5 and 7), and when this notion
is useful, the length of a branch can be defined in different ways.
Let us consider different examples:
Example 7 (Unattacked cycle) The graph is reduced to an unattacked cycle A  B  A
which attacks the argument C:
A

B

C

The notion of branch is useless in this case, because there is no leaf in the graph.
There are two possibilities:
First, one can consider that the cycle is like an infinite branch; so A (resp. B) is the
root of one branch whose length is . But the parity of the length of this branch is
undefined, and it is impossible to say if this branch is an attack branch or a defence
branch.
The second possibility is to consider that the cycle is like an infinity of branches; so
A (resp. B) is the root of an infinity of attack branches and defence branches whose
lengths are known and finite.
The second possibility means that the cycle may have two representations which are acyclic
but also infinite graphs (one with the root A and the other one with the root B). This is a
rewriting process of the cycle:
B4

A4

B1

B5

B6

A1

A2

A3

B2

B3

B4

A1

A5

A6

B1

B2

B3

A2

A3

A4

B

A

The Ai and Bi must be new arguments created during the rewriting process of the cycle.
Example 8 (Attacked cycle) The cycle A  B  A is attacked by at least one argument
which does not belong to the cycle (here, the attacker is the unattacked argument D):
259

fiCayrol, Lagasquie-Schiex

D

A

B

C

E

In this case, the notion of branch is useful because there exists one leaf in the graph, but the
difficulty is to compute the length of this branch. As in Example 7, we can consider either
that there is only one infinite branch (so, it is impossible to know if this branch is an attack
or a defence branch), or that there is an infinity of attack branches and defence branches
whose lengths are known and finite.
In the second case, the graph can be rewritten into the following structures:
D

D

A6

A3

D

D

B3

A4

A5

D

B3

A1

A2

D

B1

B2

B1

B2

A1

A2

A3

A

B

C

E

The Ai and Bi must be new arguments created during the rewriting process of the graph.
From the previous examples, we have chosen to manage a cycle as an infinity of attack
branches and defence branches whose lengths are known and finite because we would like to
be able to apply Definition 10 in all cases (acyclic graphs and graphs with cycles). However,
we need a rewriting process of the graph with cycles into an acyclic graph. There are two
different cases, one for the unattacked cycles and one for the attacked cycles:
Definition 11 (Rewriting of an unattacked cycle) Let C = A0  A1  . . .  An1  A0
an unattacked cycle. The graph G which contains C is rewritten as follows:
260

fiGraduality in argumentation

1. the cycle C is removed,
2. and replaced by the infinite acyclic graphs, one for each Ai , i = 0 . . . n  1:

%
Ai 11

%
Ai 21

Ai 22

Ai
...
...
...
...
...

-

Ai n1
1

Ai n1
2
...

Ai n1
n1

Ai n1

Ai n2
...

Ai nn1

Ai nn

-

Ai n+1
1

Ai n+1
2
...

Ai n+1
n1

Ai n+1
n

Ai n+1
n+1

...
...
...
...
...
...
...
...
...
...
...

3. the edges between each of the Ai and an argument which does not belong to C are kept.
Example 7  Unattacked cycle (continuation) The graph G containing the unattacked
cycle A  B  A and the argument C, which is attacked by A, is rewritten as follows:
C

A
%
A11

%
A21

A22

B
A31

A32

A33

%
B11

...
...
...
...
...
...

%
B12

B22

B13

B23

B33

...
...
...
...
...
...

where the Alk and Bkl are new arguments.
Definition 12 (Rewriting of an attacked cycle) Let C = A0  A1  . . .  An1  A0
an attacked cycle, the direct attacker of each Ai is denoted Bi , if it exists. The graph G
which contains C is rewritten as follows:
1. the cycle C is removed,
2. and replaced by the infinite acyclic graphs, one for each Ai i = 0 . . . n  1:
261

fiCayrol, Lagasquie-Schiex

%
Bi

%
Ai 11


B(i1+n) mod n

Ai
...
...
...
...
...

Ai n1
1

Ai n1
2
...

Ai n1
n1


Ai n1

Ai n2
...

Ai nn1

Ai nn

Bi

B(i+1) mod n

Ai n+1
1

Ai n+1
2
...

Ai n+1
n1

Ai n+1
n

Ai n+1
n+1


B(i1+n) mod n

...
...
...
...
...
...
...
...
...
...
...
...
...

(the branches leading to Bk exist iff Bk exists20 ).
3. the edges between each of the Ai and an argument which does not belong to C are kept.
4. the edges between each of the Bi and an argument which does not belong to C are kept.
Example 8  Attacked cycle (continuation) The graph G containing the cycle A 
B  A attacked in A by the argument D and with the argument C (resp. E) attacked by A
(resp. B) is rewritten as follows:
E

B

C

A
%
D


A21

A22

D

A41

A42

A43

A44

D

%
B11

D

...
...
...
...
...
...
...
...
...
...

where the Alk and Bkl are new arguments.
20. The operator mod is the modulo function.

262


B13

B23

B33

D

B15

B25

B35

B45

B55

D

...
...
...
...
...
...
...
...
...
...
...
...

fiGraduality in argumentation

Note: If there exist several cycles in a graph, we have two cases.
If they are not interconnected, we rewrite each cycle, and the valuation of the resulting
graph after rewriting does not depend on the order of cycles we select to rewrite
because the valuation process only uses the length of the branches.
If they are interconnected, they are considered as a metacyle which is in turn attacked or unattacked and the previous methodology can be used leading to a more
complex rewriting process which is not formalized here (see details and examples in
Appendix B).
3.2.3 A gradual valuation with tuples for general graphs
Using the definitions given in Sections 3.2.1 and 3.2.2, the gradual valuation with tuples
given by Definition 10 is applicable for arbitrary graphs after the rewriting process.
Let us apply the rewriting process and Definition 10 on different examples.
Example 7  Unattacked cycle (continuation)
Consider the following graph:
A

B

C

The rewriting of this graph has been given in Section 3.2.2.
Definition 10 produces:
vp (A) = (vi (A11 )  1) ? . . . ? (vi (An1 )  1) ? . . .
vi (A) = (vp (A11 )  1) ? . . . ? (vp (An1 )  1) ? . . .
Applying Definition 10 for different arguments in the rewritten graph produces the following
equalities:
v(Ann ) = [0 , ()] for each n  1
v(Ann1 ) = [(), (1)] for each n  2
m
m
v(Am
n ) = [vp (An+2 )  2, vi (An+2 )  2] for each n  1 and m  n + 2

So, using the above equalities in the formulae giving vp (A) and vi (A), we define two sequences of tuples : a sequence (xk , k  1) of infinite tuples of even integers, and a sequence
(yk , k  1) of infinite tuples of odd integers
n
xk = (2) ? (vi (A2k+1
2k1 )  1) ? . . . ? (vi (A2k1 )  1) ? . . .
n
yk = (1) ? (vp (A2k+1
2k1 )  1) ? . . . ? (vp (A2k1 )  1) ? . . .

263

fiCayrol, Lagasquie-Schiex

From the results stated in Property 7, it is easy to prove that vp (A) = x1 and for each k  1,
xk = (2) ? (xk+1  2).
Similarly, vi (A) = y1 and for each k  1, yk = (1) ? (yk+1  2).
These equations enable to prove that :
For each even integer p p > 0, p belongs to each tuple xi , i  1.
For each odd integer p, p belongs to each tuple yi , i  1.

The proof is done by induction on p.
So, v(A) = v(B) = [(2, 4, 6, . . .), (1, 3, 5, . . .)].
Then, v(C) = [(2, 4, 6, . . .), (3, 5, 7, . . .)].
Note that all the above results can be readily extended to an unattacked cycle of length n,
n  2.
Property 8 (Properties of unattacked cycles)
For each unattacked cycle, for each argument A of the cycle, v(A) = [(2, 4, 6, . . .), (1, 3, 5, . . .)].
Example 8  Attacked cycle (continuation)

Consider the following graph:

D

A

B

C

E

The rewriting of this graph has been given in Section 3.2.2.
Definition 10 produces:
vp (A) = (vi (D)  1) ? (vi (A21 )  1) ? . . . ? (vi (A2n
1 )  1) ? . . .
vi (A) = (vp (D)  1) ? (vp (A21 )  1) ? . . . ? (vp (A2n
1 )  1) ? . . .
and also
v(D) = [0 , ()]
v(Ann ) = [(), (1)] for each n  2
As done in the treatment of Example 7, the formulae giving vp (A) and vi (A) can be rewritten
in order to bring to light some interesting sequences of tuples.
264

fiGraduality in argumentation

2(k+p)

x0k = (vi (A2k
2k1 )  1) ? . . . ? (vi (A2k1 )  1) ? . . .
2(k+p)

yk0 = (1) ? (vp (A2k
2k1 )  1) ? . . . ? (vp (A2k1 )  1) ? . . .
Then, it is easy to prove that vp (A) = x01 and for each k  1, x0k = (x0k+1  2).
0
 2).
Similarly, vi (A) = y10 and for each k  1, yk0 = (1) ? (yk+1

The first equation enables to prove that x01 is the empty tuple21 .
The second equation has already been solved and produces y10 = (1, 3, 5, . . .).
So, v(A) = [(), (1, 3, 5, . . .)]. For B, we can reason as for A, and we have v(B) = [(2, 4, 6, . . .), ()].
Then, v(C) = [(2, 4, 6, . . .), ()], v(E) = [(), (3, 5, 7 . . .)].
Notation: in order to simplify the writing, we will not repeat the values inside the tuples
(we will just indicate under each value how many times it appears). For example:
[(2, 4, 4, 6, 6, 6, 8, 8, 8, 8 . . .), (3, 5, 5, 7, 7, 7, 9, 9, 9, 9 . . .)]
will be denoted by
[(2, |{z}
4 , |{z}
6 , |{z}
8 , . . .), (3, |{z}
5 , |{z}
7 , |{z}
9 , . . .)]
2

3

4

2

3

4

Conclusion about cycles Cycles are expensive since all the values obtained are infinite.
In appendix B, we introduce an algorithm for computing these tupled values. It uses a
process of value propagation and is parameterised by a maximum number of runs through
a cycle. This number will be used in order to stop the propagation mechanism and to
obtain finite (thus incomplete) tupled values.
3.2.4 Comparison of tupled values
In this section, we define the comparison relation between arguments (so, between some particular tupled values), using the following idea: an argument A is better than an argument
B iff A has a better defence (for it) and a lower attack (against it).
The first idea is to use a lexicographic ordering on the tuples. This lexicographic ordering
denoted by lex on T is defined by:
21. The proof is the following:.
x01 contains only even integers.
For each k, x0k 6= 0 since x0k is the result of the addition of a tuple and an integer.
If x01 is not empty, let e1 denote the least even integer present in x01 . As x01 = x02  2, x02 is not empty
and e2 will denote the least integer present in x02 . We have e1 = e2 + 2. So, we are able to build
a sequence of positive even integers e1 , e2 , . . ., which is strictly decreasing. That is impossible. So,
x01 = ().

265

fiCayrol, Lagasquie-Schiex

Definition 13 (Lexicographic ordering on tuples)
Let (x1 , . . . , xn , . . .) and (y1 , . . . , ym , . . .) be 2 finite or infinite tuples  T .
(x1 , . . . , xn , . . .) <lex (y1 , . . . , ym , . . .) iff i  1 such that:
j < i, xj = yj and
yi exists and:
either the tuple (x1 , . . . , xn , . . .) is finite with a number of elements equal to i  1
(so, xi does not exist),
or xi exists and xi < yi .
(x1 , . . . , xn , . . .) =lex (y1 , . . . , ym , . . .) iff the tuples contain the same number p   {}
of elements and i, 1  i  p, xi = yi .
So, we define: (x1 , . . . , xn , . . .) lex (y1 , . . . , ym , . . .) iff
(x1 , . . . , xn , . . .) =lex (y1 , . . . , ym , . . .) or (x1 , . . . , xn , . . .) <lex (y1 , . . . , ym , . . .).
The ordering <lex is a generalisation of the classical lexicographic ordering (see Xuong,
1992) to the case of infinite tuples. This ordering is complete but not well-founded (there
exist infinite sequences which are strictly non-increasing: (0) <lex (0, 0) <lex . . . <lex
(0, . . . , 0, . . .) <lex . . . <lex (0, 1)).
Since the even values and the odd values in the tupled value of an argument do not play
the same role, we cannot use a classical lexicographic comparison. So, we compare tupled
values in two steps:
The first step compares the number of attack branches and the number of defence
branches of each argument. So, we have two criteria (one for the defence and the other
for the attack). These criteria are aggregated using a cautious method: we conclude if
one of the arguments has more defence branches (it is better according to the defence
criterion) and less attack branches than the other argument (it is also better according
to the attack criterion). Note that we conclude positively only when all the criteria
agree: if one of the arguments has more defence branches (it is better according to
the defence criterion) and more attack branches than the other argument (it is worse
according to the attack criterion), the arguments are considered to be incomparable.
Else, the arguments have the same number of defence branches and the same number
of attack branches, and a second step compares the quality of the attacks and the
quality of the defences using the length of each branch. This comparison is made
with a lexicographic principle (see Definition 13) and gives two criteria which are
again aggregated using a cautious method. In case of disagreement, the arguments
are considered to be incomparable.
Let us consider some examples:
[(2), (1)] is better than [(2), (1, 1)] because there are less attack branches in the first
tupled value than in the second tupled value, the numbers of defence branches being
the same (first step).
[(2), (1)] is incomparable with [(2, 2), (1, 1)] because there are less defence branches
and less attack branches in the first tupled value than in the second tupled value (first
step).
266

fiGraduality in argumentation

[(2), (3)] is better than [(2), (1)] because there are weaker attack branches in the first
tupled value than in the second tupled value (the attack branch of the first tupled
value is longer than the one of the second tupled value), the defence branches being
the same (second step, using the lexicographic comparison applied on even parts then
on odd parts of the tupled values).
[(2), (3)] is better than [(4), (3)] because there are stronger defence branches in the
first tupled value than in the second tupled value (the defence branch is shorter in
the first tupled value than in the second tupled value), the attack branches being the
same (second step).
[(2), (1)] is incomparable with [(4), (3)] because there are worse attack branches and
better defence branches in the first tupled value than in the second tupled value
(second step).
The comparison of arguments is done using Algorithm 1 which implements the principle
of a double comparison (first quantitative, then qualitative) with two criteria (one defence
criterion and one attack criterion) using a cautious method.
Algorithm 1: Comparison of two tupled values
% Description of the parameters:
% v, w: 2 tupled values
% Notations:
%
|vp | (resp. |wp |): number of elements in the even component of v (resp. w)
%
if vp (resp. wp ) is infinite then |vp | (resp. |wp |) is taken equal to 
%
|vi | (resp. |wi |): number of elements in the odd component of v (resp. w)
%
if vi (resp. wi ) is infinite then |vi | (resp. |wi |) is taken equal to 
%
As usual,  will denote the strict relation associated with  defined by:
%
v  w iff v  w and not(w  v).

%
%
%
%
%
%
%
%
%

begin
if v = w then v  w AND w  v
% Case 1 %
2
else
3
if |vi | = |wi | AND |vp | = |wp | then
% lexicographic comparisons between vp and wp and between vi and wi %
4
if vp lex wp AND vi lex wi then v  w
% case 2 %
5
else
6
if vp lex wp AND vi lex wi then v  w
% case 3 %
7
else v 6 w AND v 6 w
% Incomparable tupled values. case 4 %
1

8
9
10
11
12

else
if |vi |  |wi | AND |vp |  |wp | then v  w
% case 5 %
else
if |vi |  |wi | AND |vp |  |wp | then v  w
% case 6 %
else v 6 w AND v 6 w
% Incomparable tupled values. Case 7 %

end

Algorithm 1 defines a partial preordering on the set v(A):
Property 9 (Partial preordering) Algorithm 1 defines a partial preordering  on the
set v(A).
267

fiCayrol, Lagasquie-Schiex

The tupled value [0 , ()] is the only maximal value of the partial preordering .
The tupled value [(), 1 ] is the only minimal value of the partial preordering .
Notation: the partial preordering  on the set v(A) induces a partial preordering on the
arguments (the partial preordering on A will be denoted like the partial preordering on
v(A)): A  B if and only if v(A)  v(B)22 .
In order to present the underlying principles satisfied by the global valuation, we first
consider the different ways for modifying the defence part or the attack part of an argument:
Definition 14 (Adding/removing a branch to an argument)
Let A be an argument whose tupled value is v(A) = [vp (A), vi (A)] with vp (A) = (xp1 , . . . , xpn )
and vi (A) = (xi1 , . . . , xim ) (vp (A) or vi (A) may be empty but not simultaneously).
Adding (resp. removing) a defence branch to A is defined by:
vp (A) becomes Sort(xp1 , . . . , xpn , xpn+1 ) where xpn+1 is the length of the added branch (resp.
j  [1..n] such that vp (A) becomes (xp1 , . . . , xpj1 , xpj+1 , . . . , xpn )).
And the same thing on vi (A) for adding (resp. removing) an attack branch to A.
Definition 15 (Increasing/decreasing the length of a branch of an argument)
Let A be an argument whose tupled value is v(A) = [vp (A), vi (A)] with vp (A) = (xp1 , . . . , xpn )
and vi (A) = (xi1 , . . . , xim ) (vp (A) or vi (A) may be empty but not simultaneously).
Increasing (resp. decreasing) the length of a defence branch of A is defined by:
p
p
0p
p
j  [1..n] such that vp (A) becomes (xp1 , . . . , xpj1 , x0p
j , xj+1 , . . . , xn ) where xj > xj (resp.
p
0p
p
x0p
j < xj ) and the parity of xj is the parity of xj .
And the same thing on vi (A) for increasing (resp. decreasing) an attack branch to A.
Definition 16 (Improvement/degradation of the defences/attacks)
Let A be an argument whose tupled value is v(A) = [vp (A), vi (A)] (vp (A) or vi (A) may be
empty but not simultaneously). We define:
An improvement (resp. degradation) of the defence consists in
adding a defence branch to A if initially vp (A) 6= 0 (resp. removing
a defence branch of A);
or decreasing (resp. increasing) the length of a defence branch of A;
or removing the only defence branch leading to A (resp. adding a defence branch leading to A if initially vp (A) = 0 );
An improvement (resp. degradation) of the attack consists in
adding (resp. removing) an attack branch to A;
or decreasing (resp. increasing) the length of an attack branch of A.
Property 10 (Underlying principles) Let v be a valuation with tuples (Definition 10)
associated with Algorithm 1, v respects the following principles:
P10 The valuation is maximal for an argument without attackers and non maximal for an
argument which is attacked (whether it is defended or not).
22. We will also use the notation B  A defined by: B  A iff A  B.

268

fiGraduality in argumentation

P20 The valuation of an argument takes into account all the branches which are rooted in
this argument.
P30 The improvement of the defence or the degradation of the attack of an argument leads
to an increase of the value of this argument.
P40 The improvement of the attack or the degradation of the defence of an argument leads
to a decrease of the value of the argument.
Example 4 (continuation)

With the valuation with tuples, we obtain:

v(E1 ) = v(D2 ) = v(D3 ) = v(C4 ) = v(B4 ) = [0 , ()],
v(D1 ) = v(C2 ) = v(C3 ) = v(B3 ) = [(), (1)],
v(C1 ) = v(B2 ) = [(2), ()],
v(B1 ) = [(2), (3)],
v(A) = [(2, 4), (1, 3, 3)].
So, we have:
E 1 , D 2 , D 3 , C 4 , B4

C 1 , B2

B1

D 1 , C 2 , C 3 , B3

but also

E 1 , D 2 , D 3 , C 4 , B4

A

A is incomparable with almost all the other arguments (except with the leaves of the graph).
Similarly, on the hatched part of the graph, we obtain the following results:
E1 , D2  C 1  B 1  A  D 1 , C 2
A is now comparable with all the other arguments (in particular, A is worse than its
defender C1 and than its direct attacker B1 ).
3.3 Main differences between local and global valuations
Cayrol and Lagasquie-Schiex (2003c) give a comparison of these approaches with some existing approaches (Dung, 1995; Jakobovits & Vermeir, 1999; Besnard & Hunter, 2001), and
also a comparison of the local approaches and the global approach. The improvement
of the global approach proposed in this paper does not modify the main results of this
comparison.
Let us recall here an example of the essential point which differentiates them (this example
has already been presented at the beginning of Section 3):
D

C1

C

B
C2

269

B

fiCayrol, Lagasquie-Schiex

In the local approach, B 0 is better than B (since B 0 suffers one attack whereas B suffers
two attacks).
In the global approach, B is better than B 0 (since it has at least a defence whereas B 0 has
none). In this case, C1 loses its negative status of attacker, since it is in fact carrying a
defence for B.
The following table synthesises the results about the different proposed valuations:
global approach
arguments
ing only
branches

havattack



arguments having
attack
branches
and
defence
branches



arguments
having only defence
branches



arguments
never attacked

local approach
arguments having
arguments
havonly one attacked
ing
only
one


direct
attacker
unattacked direct
(possibly
defended)
attacker
arguments having several attacked direct attackers (possibly defended)

arguments having
several unattacked
direct attackers



arguments
never attacked

The difference between the local approaches and the global approach is also illustrated by
the following property:
Property 11 (Independence of branches in the global approach)
Let A be an argument having the following direct attackers:
A1 whose value is v(A1 ) = [(a1p1 , . . . , a1pm ), (a1i1 , . . . , a1im )],
1
1
...,
An whose value is v(An ) = [(anp1 , . . . , anpmn ), (ani1 , . . . , animn )].
Let A0 be an argument having the following direct attackers:
A1p1 whose value is v(A1p1 ) = [(a1p1 )()],
...,
A1pm whose value is v(A1pm ) = [(a1pm )()],
1

1

1

A1i1 whose value is v(A1i1 ) = [()(a1i1 )],
...,
A1im whose value is v(A1im ) = [()(a1im )],
1
1
1
...,
Anp1 whose value is v(Anp1 ) = [(anp1 )()],
...,
270

fiGraduality in argumentation

Anpmn whose value is v(Anpmn ) = [(anpmn )()],
Ani1 whose value is v(Ani1 ) = [()(ani1 )],
...,
Animn whose value is v(Animn ) = [()(animn )].
Then v(A) = v(A0 ).
This property illustrates the independence of branches during the computation of the
values in the global approach, even when these branches are not graphically independent.
On the following example, A and A0 have the same value [(2, 2)()] though they are the root
of different subgraphs:
C1

C1
B

B1
A

A
C2

C2

B2

This property is not satisfied by the local approach since, using the underlying principles
of the local approach (see Property 4), the value of the argument A must be at least as
good as (and sometimes better than23 ) the value of the argument A0 (A having one direct
attacker, and A0 having two direct attackers).
3.4 Conclusion about valuation step
We have proposed two different gradual valuation models and we are now able to make a
distinction between different arguments using the preordering associated with a valuation
model. These valuations will be used for the selection of the arguments (see Section 4).

4. Graduality and acceptability
In this section, we now shift to the selection step and introduce graduality in the notion of
acceptability24 .
The basic idea is to select an argument depending on the non-selection of its direct attackers.
Following this idea, we propose two different methods:
The first method consists in refining the classical partition issued from Dungs collective acceptability; this refinement may be achieved using the gradual valuations
defined in Section 3.
The second method takes place in an individual acceptability and consists in defining
a new acceptability using only the gradual valuations defined in Section 3.
4.1 Dungs (1995) collective acceptability
In the framework of collective acceptability, we have to consider the acceptability of a set
of arguments. This acceptability is defined with respect to some properties and the sets
which satisfy these properties are called acceptable sets or extensions. An argument will be
said acceptable if and only if it belongs to an extension.
23. With the valuation proposed by Besnard and Hunter (2001), we obtain: v(A) = 34 and v(A0 ) = 12 .
24. This work has been presented in a workshop (Cayrol & Lagasquie-Schiex, 2003b).

271

fiCayrol, Lagasquie-Schiex

Definition 17 (Basic properties of extensions following Dung, 1995)
Let <A, R> be an argumentation system, we have:
Conflict-free set A set E  A is conflict-free if and only if 6 A, B  E such that ARB.
Collective defence Consider E  A, A  A. E collectively defends A if and only if
B  A, if BRA, C  E such that CRB. E defends all its elements if and only if
A  E, E collectively defends A.
Dung (1995) defines several semantics for collective acceptability: mainly, the admissible
semantics, the preferred semantics and the stable semantics (with corresponding extensions:
the admissible sets, the preferred extensions and the stable extensions).
Definition 18 (Some semantics and extensions following Dung, 1995) Let <A, R>
be an argumentation system.
Admissible semantics (admissible set) A set E  A is admissible if and only if E is
conflict-free and E defends all its elements.
Preferred semantics (preferred extension) A set E  A is a preferred extension if
and only if E is maximal for set inclusion among the admissible sets.
Stable semantics (stable extension) A set E  A is a stable extension if and only if E
is conflict-free and E attacks each argument which does not belong to E (A  A \ E,
B  E such that BRA).
Note that in all the above definitions, each attacker of a given argument is considered
separately (the direct attack as a whole is not considered). Dung (1995) proves that:
Any admissible set of <A, R> is included in a preferred extension of <A, R>.
There always exists at least one preferred extension of <A, R>.
If <A, R> is well-founded then there is only one preferred extension which is also the
only stable extension.
Any stable extension is also a preferred extension (the converse is false).
There is not always a stable extension.
Property 12 The set of leaves (i.e. {A|R (A) = }) is included in every preferred extension and in every stable extension.
4.2 Different levels of collective acceptability
Under a given semantics, and following Dung, the acceptability of an argument depends on
its membership to an extension under this semantics. We consider three possible cases 25 :
25. The terminology used in this section is also used in the domain of nonmonotonic reasoning (see Pinkas
& Loui, 1992): the word uni comes from the word universal which is a synonym of the word skeptical,
and the word exi comes from the word existential which is a synonym of the word credulous. We have
chosen to use the words uni and exi because they recall the logical quantificators  (for all) and  (exists
at least one).

272

fiGraduality in argumentation

the argument can be uni-accepted, when it belongs to all the extensions of this semantics,
or the argument can be exi-accepted, when it belongs to at least one extension of this
semantics,
or the argument can be not-accepted when it does not belong to any extension of this
semantics.
However, these three levels seem insufficient. For example, what should be concluded in
the case of two arguments A and B which are exi-accepted and such that ARB or BRA?
So, we introduce a new definition which takes into account the situation of the argument
w.r.t. its attackers. This refines the class of the exi-accepted arguments under a given
semantics S.
Definition 19 (Cleanly-accepted argument) Consider A  A, A is cleanly-accepted
if and only if A belongs to at least one extension of S and B  A such that BRA, B does
not belong to any extension of S.
Thus, we capture the idea that an argument will be better accepted, if its attackers are
not-accepted.
Property 13 Consider A  A and a semantics S such that each extension for S is conflictfree. If A is uni-accepted then A is cleanly-accepted. The converse is false.
The notion of cleanly-accepted argument refines the class of the exi-accepted arguments.
For a semantics S and an argument A, we have the following states:
A can be uni-accepted, if A belongs to all the extensions for S (so, it will also be
cleanly-accepted);
or A can be cleanly-accepted (so, it is by definition also exi-accepted); note that it is
possible that the argument is also uni-accepted;
or A can be only-exi-accepted, if A is not cleanly-accepted, but A is exi-accepted;
or A is not-accepted if A does not belong to any extension for S.
Example 9 Consider the following argumentation system.
There are two preferred extensions {D, C2 , A, G} and
J
{D, C2 , E, G, I}. So, for the preferred semantics, the acI
ceptability
levels are the following:
E
A
G
H

D

B

F

C1

C2

D, C2 and G are uni-accepted,
I is cleanly-accepted but not uni-accepted,
A and E are only-exi-accepted,
B, C1 , F , H and J are not-accepted.

Note that, in all the cases where there is only one extension, the first three levels of acceptability coincide26 . This is the case:
26. If there is only one extension then the fact that A belongs to all the extensions is equivalent to the
fact that A belongs to at least one extension. Moreover, with only one extension containing A, all the
attackers of A do not belong to an extension. So, A is cleanly-accepted.

273

fiCayrol, Lagasquie-Schiex

Under the preferred semantics, when there is no even cycle (see Doutre, 2002).
Under the basic semantics (another semantics proposed by Dung  see Dung, 1995;
Doutre, 2002  which is not presented here and which has only one extension).
Looking more closely, we can prove the following result (proof in Appendix A):
Property 14 Under the stable semantics, the class of the uni-accepted arguments coincides
with the class of the cleanly-accepted arguments.
Then, using a result issued from the work of Dunne and Bench-Capon (2001, 2002) and
reused by Doutre (2002) which shows that, when there is no odd cycle, all the preferred
extensions are stable27 , we apply Property 14 and we obtain the following consequence:
Consequence 1 Under the preferred semantics, when there is no odd cycle, the class of
the uni-accepted arguments coincides with the class of the cleanly-accepted arguments.
Finally, the exploitation of the gradual interaction-based valuations (see Section 3) allows
us to define new levels of collective acceptability.
Let v be a gradual valuation and let  be the associated preordering (partial or complete)
on A. This preordering can be used inside each acceptability level (for example, the level of
the exi-accepted arguments) in order to identify arguments which are better accepted than
others.
Example 9 (continuation)
graph:

Two different gradual valuations are applied on the same

0,674

0,590

0,482

J

A

E
I
0,694

H

G 0,666

0,441
0,4 B

D
1

C1

F

0,5

C2 1

0.5

Besnard & Hunters (2001) valuation
With the instance of the generic valuation proposed by Besnard and Hunter (2001) (see
Section 3.1), we obtain the following comparisons:
D, C2  I  E  G  J  C1 , F  A  H  B
27. This corresponds to the consistent argumentation system proposed by Dung (1995).

274

fiGraduality in argumentation

{
{

[(6,8,10,12,...),
2 3
{
{
{

(7,9,10,11,...)]
2 2 3

J

[(4,6,8,10,...),
(3,5,7,9,...)]

E
H

2 2 3

2 3

[(2,4,6,8,...),
(3,5,7,9...)]
A

G [(2),()]

{
{
{

{
{

[(4,6,8,10,...),
2 3
(5,7,9,11,...)]

{
{
{

[(6,8,10,12,...),
2 2 3
(5,7,9,11,...)]
{
{

I

[(2),(1)]

D

B

C1

[(0,...,0),()]

F [(),(1)]

C2 [(0,...,0),()]

[(),(1)]

Valuation with tuples

With the global valuation with tuples presented in Section 3.2, we obtain the following comparisons:
D, C2  G  B  F, C1
D, C2  A  E
D, C2  H  E
D, C2  I
D, C2  J
So, all the arguments belonging to a cycle are incomparable with G, B, F , C 1 and, even
between them, there are few comparison results.
If we apply the preordering induced by a valuation without respecting the acceptability
levels defined in this section, counter-intuitive situations may happen. In Example 9, we
obtain:
With the valuation of Besnard and Hunter (2001) and under the preferred semantics,
E  G despite the fact that G is uni-accepted and E is only-exi-accepted.
With the valuation with tuples and under the preferred semantics, H  E despite the
fact that E is only-exi-accepted and H is not-accepted.
These counter-intuitive situations illustrate the difference between the acceptability definition and the valuation definitions (even if both use the interaction between arguments, they
do not use it in the same way).
275

fiCayrol, Lagasquie-Schiex

4.3 Towards a gradual individual acceptability
The individual acceptability is based on the comparison of an argument with its attackers.
The first proposal has been to select an argument if and only if it does not have any attacker
(see Elvang-Goransson et al., 1993).
This has later been extended by Amgoud and Cayrol (1998) where, using a preference
relation between arguments (an intrinsic valuation), an argument is accepted if and only if
it is preferred to each of its attackers.
Following this proposal, we propose the same mechanism but with the interaction-based
valuation.
Given v a gradual valuation, the preordering induced by v can be directly used in order
to compare, from the acceptability point of view, an argument and its attackers 28 . This
defines a new class of acceptable arguments: well-defended arguments.
Definition 20 (Well-defended argument) Consider A  A, A is well-defended (for v)
if and only if B  A such that BRA, B 6 A.
Thus, we capture the idea that an argument will be better accepted if it is at least as good
as its direct attackers (or incomparable with them in the case of a partial ordering). The
set of well-defended arguments will depend on the valuation used.
Using this new notion, the set of the arguments is partitioned in three classes:
the first class contains the arguments which are not attacked,
the second class contains the arguments which are attacked but are well-defended,
the third class contains the other arguments (attacked and not well-defended).
Note that the set of the well-defended arguments corresponds to the union of the two first
classes. A further refinement uses the gradual valuation inside each of the classes as in
Section 4.2.
In Example 9 presented in Section 4.2, the well-defended arguments are:
D, C2 , G, H and A (A is incomparable with B but better than E) for the valuation
with tuples,
though with the valuation of Besnard and Hunter (2001) the well-defended arguments
are D, C2 , G, I and E (E is better than A).
Note also that, as in the semantics of Dung (1995), Definition 20 considers the attackers
one by one. It is not suitable for a valuation which handles the direct attack as a whole
(as the valuation of Besnard and Hunter (2001)  see the counterexamples presented in
Section 4.4).
28. This idea is also used in the notion of defeat proposed by Bench-Capon (2002). So, there is a link
between a well-defended argument and an argument which is not attacked in the sense of BenchCapon (2002) by its direct attackers. Note that, in the work of Bench-Capon (2002), the valuation is an
extra knowledge added in the argumentation framework. In contrast, here, the v-preference is extracted
from the attack graph.

276

fiGraduality in argumentation

4.4 Compatibility between acceptability and gradual valuation
Following the previous sections, the set of arguments can be partitioned in two different
ways:
First, given a semantics S and a gradual valuation v, it is possible to use the partition
issued from Dung (1995) which we have refined:
Uni
accepted
Cleanly
accepted

Exi
accepted

OnlyExi
accepted

Not
accepted

Refinement of each level with the gradual valuation v

Second, given a gradual valuation v, it is possible to use the partition induced by the
notion of well-defended arguments:
Attaked but
not Welldefended
Arguments

Attaked
Arguments


















WellDefended



for
the
valuation
v
















Unattacked
Arguments

A very natural and interesting question is: is it possible to find a semantics S and a gradual
valuation v such that the associated partitions have some compatibilities?
The following examples show that the class of the well-defended arguments does not correspond to the class of the cleanly-accepted arguments (in some cases, some uni-accepted
arguments are even not well-defended).
277

fiCayrol, Lagasquie-Schiex

4.4.1 Examples showing the non-compatibility in the general case
We give examples for each usual valuation (the global valuation with tuples and 2 instances
of the generic local valuation: Besnard & Hunter, 2001; Jakobovits & Vermeir, 1999) and
for the most classical semantics for acceptability (preferred semantics and stable semantics
of Dung, 1995).
Cleanly-accepted argument but not well-defended: There are 3 examples (each using a distinct valuation: one for the global valuation and two for the two well-known instances of
the local valuation):
the argument A is cleanly-accepted but it is not well-defended:
A

0.4

0.5

B1

B2

B3
0.5

C2

C3
1

0.5

C1
1

1

Only 1 preferred and stable extension = { C1, C2, C3, A}
B1, B2, B3 do not belong to a preferred extension
Bi
A forall i = 1, 2, 3

the argument A is cleanly-accepted but it is not well-defended:
?

C

2 preferred and stable extensions : {C,A} and {D,A}
B doesnt belong to a preferred extension
B
A

A


B
?
D
?

the argument I is cleanly-accepted but it is not well-defended:
[(4,4),(3)]
A
[(0,...0),()]

B

C

[(),(1)]

[(2),()]

D
[(),(3)]
H
[(),(3)]

E

F
[(4),(5,5)]

G
[(6,6),(5)]

I
[(6),(7,7)]

Only 1 preferred and stable extension = {A,C,F,I}
G doesnt belong to a preferred extension
G
I

Well-defended argument but not cleanly-accepted: Similarly, for the same three valuations,
we have:
the argument C is well-defended but it is not cleanly-accepted:
?
D
+

A
?

B
C
?

Only 1 preferred and stable extension : {D, B}
C
B
C doesnt not belong to a preferred or a stable extension

the argument F is well-defended but it is not cleanly-accepted:
278

fiGraduality in argumentation

0.618

2 preferred and stable extensions = {A,H,E} and {B,H,F}
F belongs to a preferred and stable extension
F
E and E belongs also to a preferred and stable extension
while E attacks F

0.618
B

A

E

G
0.5

0.472

H
1

F
0.679

the argument G is well-defended but it is not cleanly-accepted:
[(4,4),(3)]
A
[(0,...,0),()]

B

C

[(),(1)]

[(2),()]

D
[(),(3)]

E

F
[(4),(5,5)]

G
[(6,6),(5)]

I
[(6),(7,7)]

H
[(),(3)]

Only 1 preferred and stable extension = {A,C,F,I}
G
F
G doesnt belong to a preferred or stable extension

4.4.2 Particular cases leading to compatibility
In the context of an argumentation system with a finite relation R without cycles 29 , the
stable and the preferred semantics provide only one extension and the levels of uni-accepted,
exi-accepted, cleanly-accepted coincide.
In this context, there are at least two particular cases leading to compatibility.
First case: It deals with the global valuation with tuples.
Theorem 1 Let G be the graph associated with <A, R>, <A, R> being an argumentation
system with a finite relation R without cycles and satisfying the following condition: 
A  A such that
Xi , leaf of G,  only one path from Xi to A, Xi1  . . .  Xili  A with Xi1 = Xi and
li the length of this path (if li is even, this path is a defence branch for A, else it is
an attack branch),
all the paths from Xi to A are root-dependent in A,
Ai  A, Xj a leaf of G such that Ai belongs to a path from Xj to A.
Let v be a valuation with tuples. Let S be a semantics  {preferred, stable}.
1. B  A, B 6= A, B (exi, uni, cleanly) accepted for S iff B well-defended for v.
2. If A is (exi, uni, cleanly) accepted for S then A is well-defended for v (the converse
is false).
3. If A is well-defended for v and if all the branches leading to A are defence branches
for A then A is (exi, uni, cleanly) accepted for S.
29. So, (A, R) is well-founded.

279

fiCayrol, Lagasquie-Schiex

Note that Theorem 1 is, in general, not satisfied by a local valuation. See the following
counterexample for the valuation of Besnard and Hunter (2001):
0,4 A

0,5

1

B1

C1

0,5

B2

1 C2

0,5

B3

1 C3

The graph satisfies the condition stated in Theorem 1. The set of well-defended arguments
is {C1 , C2 , C3 } (so, A is not well-defended). Nevertheless, {C1 , C2 , C3 , A} is the preferred
extension.
Second case: This second case concerns the generic local valuation:
Theorem 2 Let <A, R> be an argumentation system with a finite relation R without
cycles. Let S be a semantics  {preferred, stable}. Let v be a generic local valuation
satisfying the following condition ():
(i = 1 . . . n, g(xi )  xi )  (g(h(x1 , . . . , xn ))  h(x1 , . . . , xn ))
()
A  A, A (exi, uni, cleanly) accepted for S iff A well-defended for v.
This theorem is a direct consequence of the following lemma:
Lemma 1 Let <A, R> be an argumentation system with a finite relation R without cycles.
Let S be a semantics  {preferred, stable}. Let v be a generic local valuation satisfying the
condition ().
(i) If A is exi-accepted and A has only one direct attacker B then A  B.
(ii) If B is not-accepted and B has only one direct attacker C then C  B.
Remark: The condition () stated in Theorem 2 is:
false for the local valuation proposed by Besnard and Hunter (2001) as shown in the
following graph:
0,4 A

0,5

1

We know that g(x) =

1
1+x

and

B1

C1

0,5

B2

0,5

B3

1 C2

1 C3
h(x1 , . . . , xn ) = ni=1 xi

(see Property 6). We get:

i = 1 . . . 3, xi = v(Bi ) = 0.5,
i = 1 . . . 3, g(xi ) = 0.66, so g(xi )  xi ,
and nevertheless g(h(x1 , x2 , x3 )) = v(A) = 0.4 6 h(x1 , x2 , x3 ) = 1.5.
280

fiGraduality in argumentation

false for the local valuations defined with h such that n > 1 with h(x1 , . . . , xn ) >
max(x1 , . . . , xn ) (for all the functions g strictly non-increasing): see the previous graph
where h(x1 , x2 , x3 ) = 1.5 and max(x1 , x2 , x3 ) = 0.5.
true for the local valuations defined with h = max (for all the functions g): if h = max
then g(h(x1 , . . . , xn )) = g(max(x1 , . . . , xn )) = g(xj ), xj being the maximum of the xi ;
and, by assumption, g(xi )  xi , xi , so in particular for xj ; so, we get:
g(h(x1 , . . . , xn )) = g(xj )  xj = max(x1 , . . . , xn ) = h(x1 , . . . , xn ).

5. Conclusion
In this paper, we have introduced graduality in the two main related issues of argumentation
systems:
the valuation of the arguments,
the acceptability of the arguments.
Regarding the first issue, we have defined two formalisms introducing an interaction-based
gradual valuation of arguments.
First, a generic gradual valuation which covers existing proposals (for example Besnard
& Hunter, 2001 and Jakobovits & Vermeir, 1999). This approach is essentially local
since it computes the value of the argument only from the value of its direct attackers.
Then, an approach based on a labelling which takes the form of a pair of tuples;
this labelling memorises the structure of the graph representing the interactions (the
attack graph), associating each branch with its length (number of the edges from
the leaf to the current node) in the attack graph (if the length of the branch is an even
integer, the branch is a defence branch for the current node, otherwise the branch is
an attack branch for the current node). This approach is said to be global since
it computes the value of the argument using the whole attack graph influencing the
argument.
We have shown that each of these valuations induces a preordering on the set of the arguments, and we have brought to light the main differences between these two approaches.
Regarding the second issue, two distinct approaches have been proposed:
First, in the context of the collective acceptability of Dung (1995): three levels of
acceptability (uni-accepted, exi-accepted, not-accepted) were already defined. More
graduality can be introduced in the collective acceptability using the notion of cleanlyaccepted arguments (those whose direct attackers are not-accepted).
Then, in the context of individual acceptability: using the previously defined gradual
valuations, the new notion of well-defended arguments has been introduced (those
which are preferred to their direct attackers in the sense of a given gradual valuation
v).
The first concept induces a refinement of the level of exi-accepted in two sublevels (cleanlyaccepted arguments and only-exi-accepted arguments). The gradual valuation allows graduality inside each level of this collective acceptability.
281

fiCayrol, Lagasquie-Schiex

The second concept induces two new levels of acceptability (well-defended arguments and
not-well-defended arguments). The gradual valuation also allows graduality inside each
level of this individual acceptability.
Regarding our initial purpose of introducing graduality in the definition of acceptability, we
have adopted a basic principle:
acceptability is strongly related to the interactions between arguments (represented
on the graph of interactions),
and an argument is all the more acceptable if it is preferred to its direct attackers.
Then, we have followed two different directions. One is based on a refinement of an existing
partition and remains in the framework of Dungs work. The other one is based on the
original concept of being well-defended, and deserves further investigation, in particular
from a computational point of view.

Acknowledgements
Thanks to the reviewers for their very interesting and constructive comments.
Thanks to Thomas Schiex for his help.

Appendix A. The proofs
In this section, we give the proofs of all the properties presented in Sections 3 and 4.
Proof
(of Property 1) By induction from VMin  g(VMax ) < VMax and by applying
function g twice.


Proof
(of Property 2) The valuation function v associates each argument A with a
value v(A) belonging to a set V which is a subset of a completely ordered set
W.


Proof
(of Property 3) Let C = An  An1  . . .  A2  A1 be a cycle:
If n is even: n = 2k and v(A1 ) = g(v(A2 )) = . . . = g 2k1 (v(A2k )) =
g 2k (v(A1 )); so, v(A1 ) is a fixpoint of g 2k = g n . It is the same for each Ai ,
1  i  2k.
However, the Ai may have different values: for example, for n = 2, with
the valuation of Jakobovits and Vermeir (1999), v(A1 ) = + and v(A2 ) = 
with g(+) =  and g() = +. If all the Ai have the same value, then this
value will be a fixpoint of g (because v(A1 ) = g(v(A2 )) = g(v(A1 ))).
282

fiGraduality in argumentation

If n is odd: n = 2k + 1 and v(A1 ) = g(v(A2 )) = . . . = g 2k (v(A2k+1 )) =
g 2k+1 (v(A1 )); so, v(A1 ) is a fixpoint of g 2k+1 = g n . It is the same for each
Ai , 1  i  2k + 1.
Since the function g is non-increasing, the function g 2k+1 is also nonincreasing and we can apply the following result: if a non-increasing function has fixpoints, these fixpoints are identical30 . So, v(A1 ) = . . . =
v(A2k+1 ). But, v(A1 ) = g(v(A2 )) = g(v(A1 )), so v(A1 ) is a fixpoint of g.
So, for all the 1  i  2k + 1, v(Ai ) is a fixpoint of g.

Proof
(of Property 4)
P1 is satisfied because: A  A, if A has no direct attacker (R (A) is empty),
then v(A) = VMax and g(VMax ) < VMax .
P2 is satisfied because if R (A) = {A1 , . . . , An }, h(v(A1 ), . . . , v(An )) evaluates
the direct attack of A.
P3 is satisfied because the function g is supposed to be non-increasing.
P4 is satisfied due to the properties of the function h.



Proof
(of Property 5) The valuation proposed by Jakobovits and Vermeir (1999) is
the following:
Let <A, R> be an argumentation system. A complete labelling of <A, R> is a
function Et : A  {+, ?, } such that:
1. If Et(A)  {?, } then B  R (A) such that Et(B)  {+, ?}

2. If Et(A)  {+, ?} then B  R (A) or  R+ (A), Et(B)  {?, }
Moreover, Jakobovits and Vermeir (1999) also define a complete rooted labelling
Et with: A  A, if Et(A) =  then B  R (A) such that Et(B) = +.

The translation of Et into a local gradual valuation is very easy:

g is defined by g() = +, g(+) = , g(?) =? and h is the function max.



Proof
(of Property 6) Besnard and Hunter (2001) introduce the following function
Cat (in the context of deductive arguments and for an acyclic graph):
if R (A) = , then Cat(A) = 1
30. Proof: let g be a non-increasing function, let  and  be two fixpoints of g. If  6= , we may suppose
that  > , so g()  g() (since g is non-increasing), so    (since  and  are fixpoints of g), which
is in contradiction with the assumption  > .

283

fiCayrol, Lagasquie-Schiex

if R (A) 6=  with R (A) = {A1 , . . . , An }, Cat(A) =

1
1+Cat(A1 )+...+Cat(An )

The translation of Cat into a gradual valuation is: V = [0, 1], W = [0, [,
1
and h is
VMin = 0 and VMax = 1 and g : W  V is defined by g(x) = 1+x
defined by h({x1 , . . . , xn }) = x1 +    + xn .

Proof
(of Property 7) Let t = (x1 , . . . , xn , . . .), t0 = (y1 , . . . , yn , . . .), t00 = (z1 , . . . , zn , . . .)
be tuples.
Commutativity of ?: t ? t0 = t0 ? t There are two cases:
if t or t0 = 0 , the property is given by Definition 8.
if t and t0 6= 0 :
t ? t0 = Sort(x1 , . . . , xn , . . . , y1 , . . . , yn , . . .)
= Sort(y1 , . . . , yn , . . . , x1 , . . . , xn , . . .)
= t0 ? t
Associativity of ?: (t ? t0 ) ? t00 = t ? (t0 ? t00 ) There are two cases:
if t or t0 or t00 = 0 , we can simplify the expression. For example, if
t = 0 :
(t ? t0 ) ? t00 = t0 ? t00
= t ? (t0 ? t00 )
if t, t0 and t00 6= 0 :
(t ? t0 ) ? t00 = Sort(x1 , . . . , xn , . . . , y1 , . . . , yn , . . . , z1 , . . . , zn , . . .)
= t ? (t0 ? t00 )
Property of : (t  k)  k 0 = t  (k + k 0 ) We have:
(t  k)  k 0 = (x1 + k, . . . , xn + k, . . .)  k 0

= (x1 + k + k 0 , . . . , xn + k + k 0 , . . .)

= t  (k + k 0 )
Distributivity: (t ? t0 )  k = (t  k) ? (t0  k) We have:
(t ? t0 )  k = Sort(x1 , . . . , xn , . . . , x01 , . . . , x0n , . . .)  k

= Sort(x1 + k, . . . , xn + k, . . . , x01 + k, . . . , x0n + k, . . .)

= (t  k) ? (t0  k)


284

fiGraduality in argumentation

Proof
(of Property 9) First, we show that the relation  defined by Algorithm 1 is
a partial ordering:
Let u, v, w be three tupled values, the relation  defined by Algorithm 1 is:
reflexive: u  u because u = u, so u  u AND u  u (case 1 of
Algorithm 1);
transitive: suppose that u  v and v  w and consider all the
possible cases:
if u = v:
if v = w: then u = w so u  w,
if |vi |  |wi | AND |vp | > |wp |: then |vi | = |ui |  |wi | AND
|vp | = |up | > |wp |, so u  w,
if |vi | < |wi | AND |vp |  |wp |: then |vi | = |ui | < |wi | AND
|vp | = |up |  |wp |, so u  w,
if |vi | = |wi | AND |vp | = |wp | AND vp lex wp AND
vi lex wi : then |vi | = |ui | = |wi | AND |vp | = |up | = |wp |
AND vp = up lex wp AND vi = ui lex wi , so u  w;
if |ui |  |vi | AND |up | > |vp |:
if v = w: then |ui |  |vi | = |wi | AND |up | > |vp | = |wp | so
u  w,
if |vi |  |wi | AND |vp | > |wp |: then |ui |  |vi |  |wi | AND
|up | > |vp | > |wp |, so u  w,
if |vi | < |wi | AND |vp |  |wp |: then |ui |  |vi | < |wi | AND
|up | > |vp |  |wp |, so u  w,
if |vi | = |wi | AND |vp | = |wp |: then |ui |  |vi | = |wi | AND
|up | > |vp | = |wp |, so u  w;
if |ui | < |vi | AND |up |  |vp |:
if v = w: then |ui | < |vi | = |wi | AND |up |  |vp | = |wp | so
u  w,
if |vi |  |wi | AND |vp | > |wp |: then |ui | < |vi |  |wi | AND
|up |  |vp | > |wp |, so u  w,
if |vi | < |wi | AND |vp |  |wp |: then |ui | < |vi | < |wi | AND
|up |  |vp |  |wp |, so u  w,
if |vi | = |wi | AND |vp | = |wp |: then |ui | < |vi | = |wi | AND
|up |  |vp | = |wp |, so u  w;
if |ui | = |vi | AND |up | = |vp | AND up lex vp AND ui lex
vi :
if v = w: then |ui | = |vi | = |wi | AND |up | = |vp | = |wp |
AND up lex vp = wp AND ui lex vi = wi so u  w,
if |vi |  |wi | AND |vp | > |wp |: then |ui | = |vi |  |wi | AND
|up | = |vp | > |wp |, so u  w,
285

fiCayrol, Lagasquie-Schiex

if |vi | < |wi | AND |vp |  |wp |: then |ui | = |vi | < |wi | AND
|up | = |vp |  |wp |, so u  w,
if |vi | = |wi | AND |vp | = |wp | AND vp lex wp AND
vi lex wi : then |ui | = |vi | = |wi | AND |up | = |vp | = |wp |
AND up lex vp lex wp AND ui lex vi lex wi , so
u  w.
In all cases, u  w.
Now, consider the maximal and minimal values:
The tupled value [0 , ()] is the unique maximal element for the preordering
: let v be a tupled value such that v 6= [0 , ()], then |vp |   and |vi |  0.
Compare [0 , ()] and v with Algorithm 1: [0 , ()] 6= v so the case number
1 is not used; then, |()| = 0  |vi | AND |0 | =   |vp | so there are two
cases:
if |vp | =  and |vi | = 0, the case 3 of Algorithm 1 is applied and
[0 , ()]  v,
else |vp |   and |vi |  0, the case 5 of Algorithm 1 is applied and
[0 , ()]  v.
The tupled value [(), 1 ] is the unique minimal element for the preordering
: let v be a tupled value such that v 6= [(), 1 ], then |vi |   and |vp |  0.
Compare [(), 1 ] and v with Algorithm 1: [(), 1 ] 6= v so the case number
1 is not used; then, |()| = 0  |vp | AND |1 | =   |vi | so there are two
cases:
if |vi | =  and |vp | = 0, the case 2 of Algorithm 1 is applied and
[(), 1 ]  v,
else |vi |   and |vp |  0, the case 6 of Algorithm 1 is applied and
[(), 1 ]  v.

Proof
(of Property 10) The principle P10 is satisfied by Definition 10 and by the
fact that [0 , ()] is the unique maximal element of v(A) (see Property 9).
The principle P20 is satisfied because of Definition 10.
The principles P30 and P40 are satisfied: all the possible cases of improvement/degradation of the defence/attack for a given argument (see Definition 16)
are applied case by case31 . Each case leads to a new argument. Using Algorithm 1, the comparison between the argument before and after the application
of the case shows that the principle P30 (or P40 , depending on the applied case)
31. We work case by case in order to avoid the complex cases in which we have several simultaneous simple
modifications. For example, the modification of the length of a branch which changes the status of the
branch (an even integer replaced by an odd integer) is a complex case corresponding to two simple cases:
the removal of a branch with a given status, then the addition of a new branch with a different status.

286

fiGraduality in argumentation

is satisfied.



Proof
(of Property 11) From Definition 10.



Proof
(of Property 12) First, we consider the case of the preferred extensions: Let
E be a preferred extension  A, we assume that E does not contain all the
unattacked arguments of A. So, let A  A be an unattacked argument such
that A 6 E.
Consider E  {A}:
If E  {A} is conflict-free then, with A an unattacked argument and E
a preferred extension, E  {A} collectively defends itself, so E  {A} is
admissible and E  E {A}. This contradicts the fact that E is a preferred
extension.
If E  {A} contains at least one conflict, then:

B  E such that BRA. This is impossible since A is unattacked.
or B  E such that ARB. But, since A is unattacked, @C  E
such that CRA. So, E does not collectively defend B, which is in
contradiction with the fact that E is a preferred extension.

So, the assumption E does not contain all the unattacked arguments of A
cannot hold.
Now, we consider stable extensions: Let E be a stable extension  A, we assume
that E does not contain all the unattacked arguments of A. So, let A  A be
an unattacked argument such that A 6 E.
Since A 6 E there exists in E another argument B which attacks A; This is
impossible since A is unattacked.
So, the assumption E does not contain all the unattacked arguments of A
cannot hold.


Proof
(of Property 13) An argument and one of its direct attackers cannot belong
to the same extension in the sense of Dung (1995) because the extension must
be conflict-free. So, since A is uni-accepted, it means that A belongs to all the
extensions, and none of the direct attackers of A belongs to these extensions.
For the converse, we use the following counterexample in the case of the preferred
semantics:
287

fiCayrol, Lagasquie-Schiex

F

A

K

C

B
H

J

E

G

There are two preferred extensions
{K, H, G} and {A, E, K, H}. The argument A is cleanly-accepted (B and
C do not belong to any preferred extension, and A belongs to at least one
of the two extensions). But, A is not
uni-accepted because it does not belong
to all preferred extensions.



Proof
(of Property 14) First, A uni-accepted  A cleanly-accepted is the result of
Property 13.
Conversely, let A be a cleanly-accepted argument, there exists at least one stable extension E such that A  E and B, BRA, B 6 E 0 , E 0 stable extension.
Using a reductio ad absurdum, we assume that there exists a stable extension
E 00 such that A 6 E 00 ; but, if A 6 E 00 , it means that B  E 00 such that BRA,
so, the direct attacker B of A belongs to a stable extension; so, there is a contradiction with the assumption (A is cleanly-accepted); so, E 00 does not exist
and A is uni-accepted.


Proof
(of Theorem 1)
1. We consider the arguments B  A such that B 6= A. Let Xi be a leaf, the
path C  C(Xi , A) is Xi1  . . .  Xili  A with Xi1 = Xi and li denoting the
length of the path (if li is even, this path is a defence branch for A, else it
is an attack branch).
The constraints from Xi1 to Xili are the following:
Xi1  Xi3  . . .  Xili  Xili 1  . . .  Xi4  Xi2 if li odd  1
or
Xi1  Xi3  . . .  Xili 1  Xili  . . .  Xi4  Xi2 if li even  2
So, for the path Xi1  . . .  Xili , the set of the well-defended arguments is
{Xi1 , Xi3 , . . . , Xili } if li is odd, {Xi1 , Xi3 , . . . , Xili 1 } otherwise (this is the
set of all the arguments having a value strictly better than those of their
direct attackers). This set will denoted by Accepi .
By definition, this set is conflict-free, it defends all its elements (because it
contains only the leaf of the path and all the arguments which are defended
by this leaf) and it attacks all the other arguments of the path. If we try
288

fiGraduality in argumentation

to include another argument of the path X  {Xi1 , . . . , Xili }\ Accepi , we
obtain a conflict (because all the other arguments of the path are attacked
by the elements of Accepi ). So, for {Xi1 , . . . , Xili }, Accepi is the only
preferred and stable extension.
Consider A0 = A \ {A}, with R0 being the restriction of R to A032 and
Union Accep= i Accepi , then Union Accep is the only preferred
and stable extension of <A0 , R0 >.
So, B  A, B 6= A, B is accepted iff B well-defended.

2. Now, consider A. If A is accepted then Union Accep {A} is the only
preferred and stable extension of <A, R>. So, i, Xili does not belong to
the extension. Then, i, Xili 1  Xili . Therefore, each branch leading to
A is a defence branch for A. So, i, v(Xili ) = [()(li  1)]. So, v(A) =
[(l1 , l2 , . . . , ln )()]. Then, i, v(A)  v(Xili ). Therefore, A is well-defended.
Using the following example, we show that the converse is false:
[(2,2)(3)] A

A1

[()(1)]

B1

C1
[(0...0)()]

[()(1)]

B2

[()(1)]

C2
[(0...0)()]

[(2)()]

B3

C3
[(0...0)()]

A is well-defended (A  B1 , A  B2 and A is incomparable with A1 ) but
not accepted.
3. Now, if A is well-defended and all the branches leading to A are defence
branches for A, then Union Accep {A} is conflict-free and A is defended
against each of its direct attackers (because Xili 1  Union Accep for each
branch i). So, Union Accep {A} is the preferred and stable extension
of <A, R> and A is accepted.


Proof
(of Lemma 1) Let <A, R> be an argumentation system with a finite relation
R without cycles (so, there is only one non empty preferred and stable extension
denoted by E). We know that:
if A is exi-accepted and if A has a direct attacker denoted by B then B is
not-accepted,
32. R0 is the restriction of R to A0 if and only if R0 = {(a, b)|aRb, a  A0 , b  A0 }.

289

fiCayrol, Lagasquie-Schiex

if B is not-accepted then there exists at least one argument C such that
CRB and C is exi-accepted (because B does not belong to E and E is
stable, so C must  E). So, a fortiori, if B is not-accepted and has only
one direct attacker C, then C will be exi-accepted.
The proof is done by induction on the depth of a proof tree for A or C.
Basic case for (i): A is exi-accepted with only one direct attacker B (BRA)
and C1 . . . Cn are the direct attackers of B; so, we have a proof tree whose
depth is 2 for A and one of the unattacked Ci , for example C1 ; so:
v(B) = g(h(v(C1 ), . . . , v(Cn )))
 g(v(C1 ))

because h(v(C1 ), . . . , v(Cn ))  h(v(C1 )) = v(C1 )

and g is non-increasing

 g(VMax )

because v(C1 ) = VMax

so:

v(A) = g(v(B))
 g 2 (VMax )
But, Property 1 says that g 2 (VMax )  g(VMax ), so v(A)  v(B).
Basic case for (ii): CRB with C the only direct attacker of B; so, we have
a proof tree whose depth is 0 for C, i.e. C is unattacked; so, v(C) = VMax
and v(B) = g(VMax )  v(C) (following Definition 6).
General case for (i): A is exi-accepted with only one direct attacker B
(BRA) and C1 . . . Cn are the direct attackers of B, with one of the Ci exiaccepted, for example C1 ; we consider the subgraph leading to C1 to which
we add C1 RBRA, and we assume:
g(v(C1 ))  v(C1 ) (induction assumption issued from (ii))
So:

v(B) = g(h(v(C1 ), . . . , v(Cn )))
 g(v(C1 ))
 v(C1 )

for the same reasons as in the basic case
by induction assumption

 h(v(C1 ), . . . , v(Cn ))

property of h

and with the non-increasing of g:

v(A) = g(v(B))
 g(h(v(C1 ), . . . , v(Cn ))) = v(B)
290

fiGraduality in argumentation

General case for (ii): B is not-accepted, so C is exi-accepted; we assume
that C has several direct attackers D1 . . . Dp which are all not-accepted
(because C is exi-accepted); we consider each subgraph leading to Di to
which we add Di RCRB and we assume:
i = 1 . . . p, g(v(Di ))  v(Di ) (induction assumption issued from (i))
so:
v(C) = g(h(v(D1 ), . . . , v(Dp )))
 h(v(D1 ), . . . , v(Dp ))

application of the condition ()
since the induction assumption
corresponds to the premise of ()

so:
v(B) = g(v(C))
 g(h(v(D1 ), . . . , v(Dp ))) = v(C)

Proof
(of Theorem 2) Assume that () is true and consider A  A which is exiaccepted. Let Bi , i = 1 . . . n, be the direct attackers of A. Then, for all i =
1 . . . n, in the subgraph leading to Bi and completed with Bi RA, we apply the
lemma and we obtain: g(v(Bi ))  v(Bi ), i = 1 . . . n. Thus, we have:
v(A) = g(h(v(B1 ), . . . , v(Bn )))
 h(v(B1 ), . . . , v(Bn ))

 v(Bi ), i = 1 . . . n

by applying ()
property of h

So, A is well-defended.
For the converse, let A  A be well-defended. Let B1 , . . . , Bn be the direct
attackers of A and assume that A is not exi-accepted. Then, there exists at
least one direct attacker Bi of A such that Bi is exi-accepted (because there is
only one preferred and stable extension). We can apply (ii) of the lemma on the
subgraph leading to Bi completed with Bi RA and we obtain g(v(Bi ))  v(Bi ).
So, there exists Bi a direct attacker of A such that:

v(A) = g(h(v(B1 ), . . . , v(Bn )))
 g(v(Bi ))

 v(Bi )

property of h and non-increasing of g
using the lemma
291

fiCayrol, Lagasquie-Schiex

This is in contradiction with A well-defended. So, A is exi-accepted.



Appendix B. Computation of tupled values
We propose an algorithm for computing the tupled values for an arbitrary graph (cyclic or
acyclic, the cycles may be isolated or not). This algorithm uses a principle of propagation
of values: an argument is evaluated when the values of its direct attackers are known.
We must consider the cycles as meta-arguments which are evaluated when all the direct
attackers of the cycle (i.e. the direct attackers of one of the elements of the cycle which
do not belong to the cycle) are evaluated.
The beginning of the process is as follows: we consider that all the arguments have the
initial value [0 , ()], and only the leaves of the graph are marked as having their final
values. Thus, we have the following partition of the graph G:
Gv : the part of the graph already evaluated (at the beginning, this part contains only
the leaves of the graph),
Gv : the part of the graph which is not evaluated (at the beginning, this part contains
all the arguments of the graph G except the leaves).
The algorithm also relies on a special data structure denoted by L giving the list of the
cycles in the graph and their main characteristics:
list of the arguments which belong to this cycle,
list of the arguments which belong to this cycle and which have direct attackers outside
the cycle (these arguments are called inputs of the cycle; those which will be used in
order to propagate the values across the cycle in the case of a non isolated cycle); this
list will be empty in the case of an isolated cycle.
Remark: For the sake of efficiency, the interconnected cycles (see Definition 1) will be
considered as a whole by the algorithm and will be used like a meta-cycle. For example,
the two cycles A  B  A and B  C  B which do not have any direct attacker outside
of the cycles, will be described in the data structure L as only one meta-cycle with the
following lists:
A, B, C,
nothing (because it is an isolated meta-cycle).
In order to avoid some ambiguity, these meta-cycles are defined as mcycles:
Definition 21 (mcycle) Let G be an attack graph. Let CC be the set of all the cycles of
G. Let CC 0  CC and CC 0 = {C1 , . . . , Cn } be a set of cycles.
Let ACC 0 be the set: {Aj such that Ci  CC 0 and Aj  Ci }.
If CC 0 satisfies the following properties:
Aj , Ak  ACC 0 ,  a path from Aj to Ak such that each element (arguments or edges
between arguments) of the path belongs to cycles of CC 0 ,
and Ck  CC \ CC 0 , 6 Ci  CC 0 such that Ck is interconnected with Ci .
292

fiGraduality in argumentation

Then the union of the Ci belonging to CC 0 is a mcycle.
Thus, we make a partition of CC using the notion of interconnection between cycles, each
element of the partition being a different mcycle. See on the following example:
A

J
C

B

E

F

G

I

K
D
L

In this graph, there are 6 cycles:
{J},
{I, J, K},
{K, L},
{B, C, D},
{C, E},
{F, G}.
and 3 mcycles:
{I, J, K, L},
{B, C, D, E},
{F, G}.
Algorithm 2 is the main algorithm used for computing the tupled values.
The function Add-Node (respectively Remove-Node) whose parameters are a subgraph
Gx of the attack graph and a node s, adds (resp. removes) s in (resp. of) Gx . The other
functions are described in (Cayrol & Lagasquie-Schiex, 2003a).
Algorithm 2 has been applied on an example after the step of rewriting (see Figure 1). Note
that in order to make the understanding of the results easier, we do not have created new
arguments (as in Definitions 11 and 12), but of course, it would be necessary for a rigorous
formalization.

293

fiCayrol, Lagasquie-Schiex

Algorithm 2: Algorithm for computing tupled values
% Description of parameters:
%
G: attack graph (partitioned in Gv and Gv )
%
L: data structure describing the mcycles
%
n: number of propagation steps for the mcycles
% Used variables:
%
A: the current argument (to be evaluated)
%
C: the current mcycle (to be evaluated) (containing A)
%
LAD: list of the direct attackers of C
%
Bi : the current direct attackers of A, or of C

begin
while there is at least one argument in Gv do
2
A = Choose-Argument(Gv )
3
if A does not belong to a mcycle C described in L then
4
if Bi  R (A), Bi is already evaluated then
5
Gv = Add-Node(Gv ,Evaluate-Node(A, R (A), 1))

%
%
%
%
%
%
%
%
%

1

Gv = Remove-Node(Gv , A)

6
7
8
9
10
11
12
13
14
15

% The value of A
% is the value of its
% direct attackers
% in which we add 1
% see Definition 10

else
if C is isolated then
Gv = Add-Mcycle(Gv ,Evaluate-Mcycle-Isolated(G, C, n))
Gv = Remove-Mcycle(Gv , C)

else
LAD = Find-Direct-Attackers-Mcycle(C, G)
if Bi  LAD, Bi is already evaluated then
Gv = Add-Mcycle(Gv ,
Evaluate-Mcycle-Not-Isolated(G, C, LAD,n))
Gv = Remove-Mcycle(Gv , C)

return G
end

16

294

%
%
%
%
%

fiGraduality in argumentation

A

C

B

D

E

G

F

The previous argumentation graph can be rewritten as follows:

A

A

A

A

B

B

B

C

A

C

A

C

D

B

B

D

B

B

E

C

C

E

C

C

C

D

D

A

A

A

B

B

A

B

C

A

C

B

A

C

D

B

B

C

B

B

E

A

C

C

C

C

C

B

B

B

....

....
B

C

....
D

....
E

G
F

The results of the valuation obtained after one propagation step are:
v(A) = [(0, . . . , 0)()],
v(B) = [(6, 8, 8, . . .)(1, 3, 5, . . .)],
v(C) = [(2, 4, 6, . . .)(5, . . .)],
v(D) = [(6, . . .)(3, 5, . . .)],
v(E) = [(4, 6, . . .)()],
v(F ) = [(8, . . .)(3, 5, 5, 7, 7, . . .)],
v(G) = [(2, 4, 6, . . .)(7, . . .)],
Figure 1: Example of rewriting

295

fiCayrol, Lagasquie-Schiex

References
Amgoud, L., & Cayrol, C. (1998). On the acceptability of arguments in preference-based
argumentation. In Cooper, G. F., & Moral, S. (Eds.), Proc. of the 14th Uncertainty
in Artificial Intelligence, pp. 17, Madison, Wisconsin. Morgan-Kaufmann.
Amgoud, L., & Cayrol, C. (2002). Inferring from inconsistency in preference-based argumentation frameworks. Journal of Automated Reasoning, 29, 125169.
Bench-Capon, T. J. (2002). Value based argumentation frameworks. In Benferhat, &
Giunchiglia (Eds.), Proc. of the 9th International Workshop on Nonmonotonic Reasoning (session on Argument, Dialogue and Decision), pp. 444453, Toulouse, France.
Besnard, P., & Hunter, A. (2001). A logic-based theory of deductive arguments. Artificial
Intelligence, 128 (1-2), 203235.
Cayrol, C., & Lagasquie-Schiex, M.-C. (2003a). Critique et amelioration de levaluation
graduelle par tuples pour le traitement des circuits. Rapport de recherche 2003-13-R,
Institut de Recherche en Informatique de Toulouse (I.R.I.T.), France.
Cayrol, C., & Lagasquie-Schiex, M.-C. (2003b). Gradual acceptability in argumentation
systems. In Proc. of the 3rd CMNA (International workshop on computational models
of natural argument), pp. 5558, Acapulco, Mexique.
Cayrol, C., & Lagasquie-Schiex, M.-C. (2003c). Gradual handling of contradiction in argumentation frameworks. In Bouchon-Meunier, B., L.Foulloy, & Yager, R. (Eds.),
Intelligent Systems for Information Processing: From representation to Applications,
chap. Reasoning, pp. 179190. Elsevier.
Doutre, S. (2002). Autour de la semantique preferee des systemes dargumentation. These,
Universite Paul Sabatier, IRIT.
Dung, P. M. (1995). On the acceptability of arguments and its fundamental role in nonmonotonic reasoning, logic programming and n-person games. Artificial Intelligence,
77, 321357.
Dunne, P. E., & Bench-Capon, T. J. (2001). Coherence in finite argument systems. Technical
report 01-006, University of Liverpool, Department of Computer Science (U.L.C.S.).
Dunne, P. E., & Bench-Capon, T. J. (2002). Coherence in finite argument system. Artificial
Intelligence, 141 (1-2), 187203.
Elvang-Goransson, M., Fox, J., & Krause, P. (1993). Dialectic reasoning with inconsistent
information. In Heckerman, D., & Mamdani, A. (Eds.), Proc. of the 9th UAI, pp.
114121, Washington, DC. Morgan-Kaufmann.
Jakobovits, H., & Vermeir, D. (1999). Robust semantics for argumentation frameworks.
Journal of logic and computation, 9(2), 215261.
Karacapilidis, N., & Papadias, D. (2001). Computer supported argumentation and collaborative decision making: the hermes system. Information systems, 26 (4), 259277.
Kohlas, J., Haenni, R., & Berzati, D. (2000). Probabilistic argumentation systems and
abduction. In Proc. of the 8th International Workshop on Non-Monotonic Reasoning
- special session on Uncertainty Frameworks in Non-Monotonic Reasoning, pp. 391
398, Breckenridge, Colorado.
296

fiGraduality in argumentation

Krause, P., Ambler, S., Elvang, M., & Fox, J. (1995). A logic of argumentation for reasoning
under uncertainty. Computational Intelligence, 11 (1), 113131.
Lin, F., & Shoham, Y. (1989). Argument systems - a uniform basis for non-monotonic
reasoning. In Proc. of the first International Conference On Principles of Knowledge
Representation and Reasoning (KR), pp. 245255.
Parsons, S. (1997). Normative argumentation and qualitative probability. In Proc. of the
first International Joint Conference on Qualitative and quantitative practical reasoning, ECSQARU-FAPR, LNAI 1244, pp. 466480, Germany.
Pinkas, G., & Loui, R. P. (1992). Reasoning from inconsistency: A taxonomy of principles
for resolving conflict. In Allen, J., Fikes, R., & Sandewall, E. (Eds.), Proc. of the 3rd
KR, pp. 709719, Cambridge, MA. Morgan-Kaufmann.
Pollock, J. L. (1992). How to reason defeasibly. Artificial Intelligence, 57, 142.
Pollock, J. L. (2001). Defeasible reasoning with variable degrees of justification. Artificial
Intelligence, 133, 233282.
Prakken, H., & Sartor, G. (1997). Argument-based extended logic programming with defeasible priorities. Journal of Applied Non-Classical Logics, 7, 2575.
Simari, G., & Loui, R. (1992). A mathematical treatment of defeasible reasoning and its
implementation. Artificial Intelligence, 53, 125157.
Verheij, B. (2002). On the existence and multiplicity of extension in dialectical argumentation. In Benferhat, S., & Giunchiglia, E. (Eds.), Proceedings of the 9th International
Workshop on Non-Monotonic Reasoning (NMR2002), pp. 416425.
Vreeswijk, G. (1997). Abstract argumentation systems. Artificial Intelligence, 90, 225279.
Xuong, N. (1992). Mathematiques discretes et informatique. Masson.

297

fi