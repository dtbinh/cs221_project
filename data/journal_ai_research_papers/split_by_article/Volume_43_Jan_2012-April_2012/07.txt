Journal of Artificial Intelligence Research 43 (2012) 419476

Submitted 08/11; published 03/12

Completeness Guarantees for Incomplete Ontology
Reasoners: Theory and Practice
Bernardo Cuenca Grau
Boris Motik
Giorgos Stoilos
Ian Horrocks

bernardo.cuenca.grau@cs.ox.ac.uk
boris.motik@cs.ox.ac.uk
giorgos.stoilos@cs.ox.ac.uk
ian.horrocks@cs.ox.ac.uk

Department of Computer Science, University of Oxford
Wolfson Building, Parks Road, OX1 3QD, Oxford

Abstract
To achieve scalability of query answering, the developers of Semantic Web applications
are often forced to use incomplete OWL 2 reasoners, which fail to derive all answers for
at least one query, ontology, and data set. The lack of completeness guarantees, however,
may be unacceptable for applications in areas such as health care and defence, where
missing answers can adversely aect the applications functionality. Furthermore, even
if an application can tolerate some level of incompleteness, it is often advantageous to
estimate how many and what kind of answers are being lost.
In this paper, we present a novel logic-based framework that allows one to check whether
a reasoner is complete for a given query Q and ontology T that is, whether the reasoner
is guaranteed to compute all answers to Q w.r.t. T and an arbitrary data set A. Since
ontologies and typical queries are often fixed at application design time, our approach allows
application developers to check whether a reasoner known to be incomplete in general is
actually complete for the kinds of input relevant for the application.
We also present a technique that, given a query Q, an ontology T , and reasoners
R1 and R2 that satisfy certain assumptions, can be used to determine whether, for each
data set A, reasoner R1 computes more answers to Q w.r.t. T and A than reasoner R2 .
This allows application developers to select the reasoner that provides the highest degree of
completeness for Q and T that is compatible with the applications scalability requirements.
Our results thus provide a theoretical and practical foundation for the design of future
ontology-based information systems that maximise scalability while minimising or even
eliminating incompleteness of query answers.

1. Introduction
Ecient management and querying of large amounts of data is a core problem for a growing
range of applications in fields as diverse as biology (Sidhu, Dillon, Chang, & Sidhu, 2005),
medicine (Golbreich, Zhang, & Bodenreider, 2006), geography (Goodwin, 2005), astronomy
(Derriere, Richard, & Preite-Martinez, 2006), agriculture (Soergel, Lauser, Liang, Fisseha,
Keizer, & Katz, 2004), and defence (Lacy, Aviles, Fraser, Gerber, Mulvehill, & Gaskill,
2005). In order to facilitate interoperability, such applications often use standard data
models and query languages. In particular, RDF (Hayes, 2004) provides a standard model
for semistructured data, SPARQL (Prudhommeaux & Seaborne, 2008) is a standard query
language for RDF, and ontology languages such as OWL (Horrocks, Patel-Schneider, &
van Harmelen, 2003) and OWL 2 (Cuenca Grau, Horrocks, Motik, Parsia, Patel-Schneider,
c
2012
AI Access Foundation. All rights reserved.

fiCuenca Grau, Motik, Stoilos & Horrocks

& Sattler, 2008b) can be used to describe background knowledge about the application
domain. Thus, answering SPARQL queries over RDF data sets structured using an OWL
ontology is a key service in ontology-based information systems.
An important question in the design of such systems is the selection of an appropriate
reasoner. Systems such as Pellet (Sirin, Parsia, Cuenca Grau, Kalyanpur, & Katz, 2007),
HermiT (Motik, Shearer, & Horrocks, 2009b), and RACER (Haarslev & Moller, 2001) are
based on (hyper)tableau algorithms that are provably completethat is, they are guaranteed to compute all answers for each query, ontology, and data set. Completeness, however,
comes at the cost of scalability, as answering queries over OWL 2 ontologies is of high computational complexity (Glimm, Horrocks, Lutz, & Sattler, 2007; Ortiz, Calvanese, & Eiter,
2008; Calvanese, De Giacomo, Lembo, Lenzerini, & Rosati, 2007; Lutz, Toman, & Wolter,
2009). Thus, complete systems often fail to meet the scalability demands of applications
that manage data sets consisting of hundreds of millions or even billions of assertions.
Scalability of query answering can be ensured by restricting the expressive power of the
ontology language to the level that makes provably complete reasoning tractable. This has
led to the development of three profiles of OWL 2 (Motik, Cuenca Grau, Horrocks, Wu,
Fokoue, & Lutz, 2009a): OWL 2 EL, OWL 2 RL, and OWL 2 QL. Query answering in all
three profiles can be implemented in polynomial time w.r.t. the size of data (and even in
logarithmic space in the case of OWL 2 QL). Such appealing theoretical properties have
spurred the development of specialised reasoners such as QuONTO (Acciarri, Calvanese,
De Giacomo, Lembo, Lenzerini, Palmieri, & Rosati, 2005) that target specific profiles and
typically reject ontologies that fall outside the target profile.
A dierent solution to the scalability problem is adopted in reasoners such as Oracles Semantic Data Store (Wu, Eadon, Das, Chong, Kolovski, Annamalai, & Srinivasan,
2008), Sesame (Broekstra, Kampman, & van Harmelen, 2002), Jena (McBride, Brian, 2001),
OWLim (Kiryakov, Ognyanov, & Manov, 2005), Minerva (Ma, Yang, Qiu, Xie, Pan, & Liu,
2006), DLE-Jena (Meditskos & Bassiliades, 2008), and Virtuoso (Erling & Mikhailov, 2009).
These reasoners accept all OWL 2 ontologies as inputthat is, they never reject inputs.
Furthermore, to the best of our knowledge, all of these systems are intended to be sound,
which means that all results of a query are indeed correct answers. Finally, these reasoners
typically use scalable reasoning techniques, such as various (deductive) database algorithms.
As a consequence, the reasoners are incomplete: for each reasoner, at least one query, ontology, and data set exist for which the reasoner does not return all answers to the query.
Some of these reasoners were actually designed to be complete for a particular profile of
OWL 2 (typically this is OWL 2 RL due to its close connection with datalog), and they
can often additionally handle certain kinds of axiom that fall outside the target profile.
Since incomplete reasoners can handle large data sets, they often provide the best practical choice for developers of ontology-based applications. For example, OWLim was used
for reasoning in the backend of the BBCs 2010 World Cup website, and Oracles reasoner is
being used by the University of Texas Health Science Center to improve large-scale public
health surveillance. In order to verify that the selected reasoner meets the applications
requirements, developers typically resort to empirical testing, in which they check the reasoners answers w.r.t. the application ontology and queries for representative data sets.
Although primarily intended for testing performance, benchmark suites such as the Lehigh
420

fiCompleteness Guarantees for Incomplete Ontology Reasoners

University Benchmark (LUBM) (Guo, Pan, & Heflin, 2005) and the University Ontology
Benchmark (UOBM) (Ma et al., 2006) have been used for such completeness testing.
Empirical completeness testing, however, has several important limitations. First, tests
are not generic, as data sets used for testing typically have a fixed and/or repetitive structure, which can skew test results. Second, test data is not exhaustive, as completeness is
tested only w.r.t. a limited number of data sets. Finally, query answers may not be verifiable: since complete reasoners fail to handle large data sets, they often cannot compute
the control answers needed to check the answers produced by an incomplete reasoner. As
a consequence, empirical completeness tests provide only limited assurance of a reasoners
ability to meet the requirements of a given application.
In this paper, we present a radically dierent approach to solving these problems. We
observed that, given a query Q and ontology T , even if a reasoner is not complete for the
language of T , the reasoner may be able to correctly answer Q w.r.t. T and an arbitrary data
set A; in such a case, we say that the reasoner is (Q, T )-complete. Given that ontology-based
applications often use a limited set of queries and a fixed ontology (or at least the queries and
the ontology evolve relatively slowly), a scalable reasoner that is generally incomplete, but
is (Q, T )-complete for all relevant combinations of Q and T , may provide a solid foundation
for ontology-based applications, allowing them to enjoy the best of both worlds: regardless
of the data set encountered, such applications will enjoy completeness guarantees normally
available only with computationally-intensive complete reasoners, while at the same time
exhibiting scalability levels normally available only by sacrificing completeness. To develop
an approach for testing the (Q, T )-completeness of a given reasoner, we proceed as follows.
In Section 3 we develop a logic-based framework that allows us to establish formally
provable (Q, T )-completeness guarantees. The following two notions are central to our
framework. First, in order to abstract away from the implementation details of concrete
reasoners, we introduce the notion of an abstract reasoner an idealised reasoner that captures the intended behaviour and salient features (such as soundness and monotonicity) of
a class of concrete reasoners. Second, we introduce the notion of a test suitea finite set
of data sets and queries. Intuitively, given Q and T , our goal is to construct a test suite
such that, if a reasoner correctly answers all queries on all data sets in the test suite, then
the reasoner is guaranteed to be (Q, T )-complete.
Unfortunately, as we show in Section 3.4, for certain Q and T , it is impossible to
construct a finite test suite that will provide the aforementioned completeness guarantees.
Therefore, we investigate assumptions on Q, T , and the reasoner under which testing (Q, T )completeness becomes practically feasible.
In Section 3.5 we consider the case where Q and T can be rewritten into a union of
conjunctive queries Rthat is, when answering Q w.r.t T and a data set A is equivalent
to evaluating R over A. For T expressed in OWL 2 QL, a rewriting R can be computed
using the algorithm by Calvanese et al. (2007); additionally, the algorithm by Perez-Urbina,
Motik, and Horrocks (2010) can sometimes compute R even if T is syntactically outside
this fragment. We show that such R can be converted into a test suite ER that can be used
for testing the (Q, T )-completeness of any reasoner that satisfies some basic assumptions;
roughly speaking, the reasoners answers should not depend on the names of the individuals
occurring in a data set, and its answers must increase monotonically when new data is added.
The size of each test in ER is polynomial in the size of the longest conjunctive query in R,
421

fiCuenca Grau, Motik, Stoilos & Horrocks

so it should be feasible to compute correct answers to the tests using a complete reasoner.
The number of tests in ER , however, can be exponential in the size of R, which may lead to
problems in practice. As a remedy, in Section 3.6 we strengthen our assumptions and require
the reasoner not to drop answers when merging individualsthat is, if the reasoner returns
a given inputs Q, T , and A, then for each (possibly noninjective) mapping  the reasoner
returns (a) given inputs Q, T , and (A)and we show that (Q, T )-completeness of such
reasoners can be checked using a test suite IR obtained from R by a linear transformation.
That Q and T should be rewritable into a union of conjunctive queries eectively prevents T from stating recursive axioms. To overcome this restriction, in Section 3.7 we consider first-order reproducible reasonersthat is, reasoners whose behaviour on Q, T , and A
can be seen as computing certain answers of Q w.r.t. some (possibly unknown) first-order
theory FT and A. Since FT can be a datalog program, most reasoners based on deductive
databases are first-order reproducible. In addition, we require Q and T to be rewritable
into datalog, an extension of datalog that allows for existential quantifiers and disjunction in rule heads. In many cases, T can be transformed into a datalog, program
using equivalence-preserving transformations; furthermore, the algorithm by Perez-Urbina
et al. (2010) can in many cases produce a plain datalog rewriting. We then show how to
transform a datalog, rewriting of Q and T into a test suite that can be used to test
(Q, T )-completeness of first-order reproducible reasoners.
In Section 4 we turn our attention to comparing incomplete reasoners. Roughly speaking, given Q and T , reasoner R1 is more complete than reasoner R2 if, for each data set A,
reasoner R1 computes all the answers to Q w.r.t. T and A that are computed by R2 . We
show that comparing incomplete reasoners is infeasible in general. Therefore, we introduce
the notion of compact reasonersthat is, reasoners whose behaviour on Q, T , and A can be
seen as first selecting some subset T  of T and then using a complete reasoner to evaluate
Q w.r.t. T  and A. Thus, the class of compact reasoners captures all reasoners that reduce
the input ontology T to a set of axioms that match certain parameters, such as fitting into
language fragments. For Q and T that can be rewritten into a union of conjunctive queries
R, we show that the test suite IR can be used to compare compact reasoners.
We have implemented our approaches for computing test suites, and have tested completeness of several well-known reasoners (see Section 5). These show that test suites can
be eciently computed for realistic ontologies. Furthermore, we were able to guarantee
(Q, T )-completeness of the evaluated reasoners for many queries and ontologies. Finally,
when no (Q, T )-completeness guarantee could be provided, we were able to compute a
counter-examplea small data set for which the reasoner at hand was incomplete.

2. Preliminaries
In this section we briefly introduce Description Logics (DLs) (Baader, McGuinness, Nardi, &
Patel-Schneider, 2002)a family of knowledge representation formalisms which underpin
the OWL and OWL 2 ontology languages. We describe description logics in the wider
framework of first-order logic since many of our results hold for arbitrary first-order theories.
We then introduce the datalog, and datalog languages, and we define the syntax and
semantics of unions of conjunctive queries (UCQs). Finally, we introduce the notions of
UCQ, datalog, and datalog, rewritings, which underpin many of our techniques.
422

fiCompleteness Guarantees for Incomplete Ontology Reasoners

2.1 Description Logics and First-Order Logic
Most of the results in this paper hold for arbitrary first-order theories, rather than description logics. Our work, however, is motivated by description logics and ontologies, so we use
the DL terminology throughout the paper; for example, we often talk about TBoxes and
ABoxes instead of first-order theories and sets of facts.
All definitions in this paper are implicitly parameterised by a signature  = P , I ,
which consists of countably infinite disjoint sets of predicates P and individuals (commonly
called constants in first-order logic) I . Each predicate is associated with a nonnegative
arity; predicates of zero arity are commonly called propositional symbols. The notions of
variables, terms, atoms, first-order formulae, and sentences are defined as usual (Fitting,
1996); we do not consider function symbols in this article and we assume all formulae to
be function-free. The atom that is false (true) in all interpretations is written  (). An
atom is a fact if it does not contain variables. We use the standard first-order notions of
satisfiability, unsatisfiability, and entailment (written |=) of sets of first-order sentences.
We assume that P contains the special equality and inequality predicates  and ,
respectively; atoms of the form (t1 , t2 ) and (t1 , t2 ) are commonly written as t1  t2 and
t1  t2 , respectively. We make a technical assumption that  and  are distinct predicates
rather than, as it is common in first-order logic, that t1  t2 is an abbreviation for (t1  t2 );
furthermore, we assume that each theory that uses  and  axiomatises their semantics as
follows, where (5) is instantiated for each predicate P of arity n and each i with 1  i  n.
x, y.[x  y  x  y  ]

(1)

x, y.[x  y  y  x]

(3)

x1 , . . . , xi , . . . , xn , yi .[P (x1 , . . . , xi , . . . , xn )  xi  yi  P (x1 , . . . , yi , . . . , xn )]

(5)

x.[x  x]

(2)

x, y, z.[x  y  y  z  x  z]

(4)

Note that, according to this assumption, each set of facts is satisfiable. For example, the
set of atoms {a  b, a  b} is satisfiable since both a  b and a  b are positive variable-free
atoms that are semantically independent from each other; moreover, axiom (1) is required
to obtain the expected contradiction.
An individual renaming (often just renaming) is a partial function  : I  I that
maps individuals to individuals. The domain and the range of  are written dom() and
rng(); unless otherwise noted, we assume that dom() is finite. For  an object containing
individuals (such as a formula, a set of formulae, or a tuple of individuals), ind() is the
set of individuals occurring in , and () is obtained from  by simultaneously replacing
each individual a  ind()  dom() with (a).
We use the notion of substitutions from first-order logic; that is, a substitution  is a
mapping of variables to terms. For  a term, an atom, or a formula, the result of applying
a substitution  to  is written as ().
A TBox T a is a finite set of first-order sentences that contains axioms (1)(5) whenever
 and/or  are used. An ABox A is a finite set of facts. Note that this definition allows
for atoms of the form a  b and a  b in ABoxes; furthermore, since ABoxes can contain
only positive atoms, each ABox (when considered without a TBox) is satisfiable.
423

fiCuenca Grau, Motik, Stoilos & Horrocks

DL Name
EL
FL
ALC
+(H)
+(R)
+(S)
+(I)
+(Q)
+(O)

Roles
R
R
R

Concepts
, A, C1  C2 , R.C
, A, C1  C2 , R.C
, , A, C, C1  C2 , C1  C2 , R.C, R.C
R.Self

TBox Axioms
C1  C2
C1  C2
C1  C2
R1  R2
RS T
Trans(R)

R
 nS.C,  nS.C
{a}

Table 1: Syntax of standard description logics. Typical extensions of EL, ALC, and FL
are named by appending calligraphic letters (H, R, S, I, Q, and/or O).
A description logic DL is a (usually infinite) recursive set of TBoxes satisfying the
following conditions:
 for each T  DL and each renaming , we have (T )  DL, and
 for each T  DL and each T   T , we have T   DL.

If T  DL, we say that T is a DL-TBox. Finally, FOL is the largest description logic that
contains all finite sets of first-order sentences over the signature in question.
We next present an overview of the DLs commonly considered in the literature. Typically, the predicates in DL signatures are required to be unary or binary; the former are
commonly called atomic concepts and the latter are commonly called atomic roles. DLs
typically use a specialised syntax, summarised in Table 1, that provides a set of constructors
for constructing complex concepts and roles from simpler ones, as well as dierent kinds
of axioms. Using the translation from Table 2, concepts can be translated into first-order
formulae with one free variable, roles can be translated into first-order formulae with two
free variables, and axioms can be translated into first-order sentences. Note that the translation uses counting quantifiers n and n , which can be expressed by using ordinary
quantifiers and equality by well-known transformations.
In the rest of this paper, we commonly write TBoxes and ABoxes in DL syntax; however,
to simplify the presentation, we identify T and A written in DL syntax with (T ) and (A).
2.2 Datalog,
We next introduce a fragment of first-order logic called datalog, as an extension of
datalog by Cal, Gottlob, Lukasiewicz, Marnette, and Pieris (2010). A datalog, rule
(or commonly just a rule) r is a formula of the form (6), where each Bj is an atom dierent
from  whose free variables are contained in x, and
 m = 1 and 1 (x, y1 ) = , or

 m  1 and, for each 1  i  m, formula i (x, yi ) is a conjunction of atoms dierent
from  whose free variables are contained in x  yi .
424

fiCompleteness Guarantees for Incomplete Ontology Reasoners

Mapping DL roles into first-order logic
(R, x, y) = R(x, y)
(R , x, y) = R(y, x)
Mapping DL concepts into first-order logic
(, x, y) = 
(, x, y) = 
(A, x, y) = A(x)
({a}, x, y) = x  a
(C, x, y) = (C, x, y)
(C  D, x, y) = (C, x, y)  (D, x, y)
(C  D, x, y) = (C, x, y)  (D, x, y)
(R.C, x, y) = y.[(R, x, y)  (C, y, x)]
(R.Self, x, y) = R(x, x)
(R.C, x, y) = y.[(R, x, y)  (C, y, x)]
( nS.C, x, y) = n y.[(S, x, y)  (C, y, x)]
( nS.C, x, y) = n y.[(S, x, y)  (C, y, x)]
Mapping TBox axioms into first-order logic
(C  D) = x.[(C, x, y)  (D, x, y)]
(R  S) = x, y.[(R, x, y)  (S, x, y)]
(Trans(R)) = x, y, z.[(R, x, y)  (R, y, z)  (R, x, z)]
(R  S  T ) = x, y, z.[(R, x, y)  (S, y, z)  (T, x, z)]
Mapping ABox axioms into first-order logic
(C(a)) = (C, a, y)
(R(a, b)) = R(a, b)
(a  b) = a  b
(a  b) = a  b
Table 2: Translation of DL syntax into first-order logic

x.[B1  . . .  Bn 

m


i=1

yi .i (x, yi )]

(6)

A rule is safe if each variable in x also occurs in some Bj ; unless otherwise noted, all rules
are assumed to be safe. For brevity, the outer quantifier x is commonly left implicit. The
body of r 
is the set of atoms body(r) = {B1 , . . . , Bn }, and the head of r is the formula
head(r) = m
yi .i (x, yi ). A datalog, program is a finite set of safe datalog, rules.
i=1 
Note that, since  and  are treated as ordinary predicates, they can occur in rules, provided
that their semantics is appropriately axiomatised; furthermore, note that the latter can be
achieved using datalog, rules.
Let r be a datalog, rule. Then, r is a datalog rule if head(r) contains no existential
quantifier. Also, r is a datalog rule if m = 1. Finally, r is a datalog rule if m = 1 and the
head of r is a single atom without existential quantifiers (Ceri, Gottlob, & Tanca, 1989).
In several places in this paper, we check whether a set of first-order sentences entails a
datalog, rule, which can be accomplished using the following simple result.
425

fiCuenca Grau, Motik, Stoilos & Horrocks

Proposition 2.1. Let F be a set of first-order sentences, and let r be a datalog, rule
of the form (6). Then, for each substitution  mapping the free variables of r to distinct
individuals not occurring in F or r, we have F |= r if and only if
F  {(B1 ), . . . , (Bn )} |=

m


i=1

yi .i ((x), yi )

Proof. Let x be the tuple of free variables in r and let  be an arbitrary substitution
mapping the variables in x to distinct individuals not occurring in F or r. The claim of
this proposition follows from the following equivalences:
F |= x.[B1  . . .  Bn 

m


yi .i (x, yi )]

i=1
m


F  {[x.B1  . . .  Bn 
F  {x.[B1  . . .  Bn  

F  {(B1 )  . . .  (Bn )  
F  {(B1 ), . . . , (Bn ), 

m


i

yi .i (x, yi )]} is unsatisfiable

i (skolem. of x)

m


i=1

yi .i ((x), yi )} is unsatisfiable

yi .i ((x), yi )} is unsatisfiable

i=1
m


F  {(B1 ), . . . , (Bn )} |=

yi .i (x, yi )]} is unsatisfiable

i=1
m


i=1

i=1

i

i
i

yi .i ((x), yi ).

2.3 Queries
In order to achieve a high degree of generality, we define a query Q as a finite set of firstorder sentences containing a distinct query predicate Q. Intuitively, the query predicate Q
determines the answers of Q. In order to simplify the notation, we typically assume that the
association between Q and the query predicate is implicit (e.g., we may require each query
to contain precisely one such predicate), and we assume that no query predicate occurs in
a TBox or an ABox.
A tuple of constants a is a certain answer to a query Q with query predicate Q with
respect to a TBox T and an ABox A if the arity of a agrees with the arity of Q and
T  A  Q |= Q(a). The set of all certain answers of Q w.r.t. T and A is denoted as
cert(Q, T , A). If the query predicate of Q is propositional (i.e., if the query is Boolean),
then cert(Q, T , A) is either empty or it contains the tuple of zero length; in such cases, we
commonly write cert(Q, T , A) = f and cert(Q, T , A) = t, respectively.
We use  as the special Boolean query that checks a first-order theory for unsatisfiability.
Thus, cert(, T , A) = t if and only if T  A is unsatisfiable.
A query Q with a query predicate Q is a union of conjunctive queries (UCQ) if it is a
datalog program in which each rule contains Q in the head but not in the body. A UCQ Q
is a conjunctive query (CQ) if it contains exactly one rule.
426

fiCompleteness Guarantees for Incomplete Ontology Reasoners

A union of conjunctive queries Q is ground if, for each rule r  Q, each variable occurring in the body of r also occurs in the head of r. Roughly speaking, when computing
cert(Q, T , A) for a ground Q, all variables in Q can be matched only to the individuals in T
and A, but not to unnamed objects whose existence is guaranteed by existential quantifiers.
Many state of the art reasoners used in practice support only ground UCQs. Note that
Q = {A(x)  Q(x), R(x, y)  Q(x, y)} is not a ground UCQ; in fact, Q is not even a valid
first-order theory since predicate Q does not have unique arity. To obtain a UCQ, one can
pad the head of the first rulethat is, one can introduce a special fresh individual null
and rewrite the rules as Q = {A(x)  Q(x, null ), R(x, y)  Q(x, y)}.
By the properties of first-order logic entailment, cert satisfies the following properties
for each query Q, all TBoxes T and T  , and all ABoxes A and A .
1. Monotonicity: T  T  and A  A imply
 cert(, T , A) = t implies cert(, T  , A ) = t, and
 cert(Q, T , A)  cert(Q, T  , A ).

2. Invariance under renamings: For each renaming  and each tuple of individuals a,
 cert(, T , A) = t implies cert(, (T ), (A)) = t, and

 a  cert(Q, T , A) implies (a)  cert((Q), (T ), (A)).
2.4 Rewritings
Intuitively, a rewriting of a query Q w.r.t. a TBox T is another query that captures all the
information from T that is relevant for answering Q over an arbitrary ABox A (Calvanese
et al., 2007; Artale, Calvanese, Kontchakov, & Zakharyaschev, 2009; Perez-Urbina et al.,
2010). In practice, UCQs (Calvanese et al., 2007) and datalog (Perez-Urbina et al., 2010)
are the most widely used target languages for query rewriting. For the sake of generality,
however, in this paper we use a notion of a datalog, rewriting.
Definition 2.2. Let Q be a query and let T be a TBox. A datalog, rewriting (or simply
a rewriting) of Q w.r.t. T is a triple R = RD , R , RQ  where
 RD is a datalog, program not containing  or Q such that T |= RD ,
 R is a datalog program such that head(r) =  for each r  R , and
 RQ is a UCQ whose query predicate is Q,
such that the following properties hold for each ABox A:
 cert(, T , A) = cert(, RD  R , A), and
 if cert(, T , A) = f, then cert(Q, T , A) = cert(RQ , RD  R , A).
Rewriting R is a datalog rewriting if RD is a datalog program. Furthermore, rewriting R
is a UCQ rewriting if RD = ; such an R is usually written as just R = R , RQ .
427

fiCuenca Grau, Motik, Stoilos & Horrocks

Note that Definition 2.2 requires T |= RD to hold, which precludes rewritings consisting
of axioms that are unsound w.r.t. T . For example, let Q = {A(x)  Q(x)} and T = ;
then, RD = {B(x)  A(x)} does not satisfy the definition of a rewriting since formula
B(x)  A(x) is not a logical consequence of T .
For a wide range of T and Q, a datalog, rewriting of Q w.r.t. T can be computed using
straightforward equivalence-preserving transformations of T ; this can be further optimised
by eliminating axioms from T that are irrelevant to answering Q. Furthermore, several
algorithms for computing UCQ and datalog rewritings have been proposed in the literature.
For example, Calvanese et al. (2007) showed how to compute a UCQ rewriting in cases when
T is expressed in a logic from the DL-Lite family, and this approach can be extended to the
OWL 2 QL profile of OWL 2 (Motik et al., 2009a). Similarly, Perez-Urbina et al. (2010)
proposed an algorithm for computing the simplest possible datalog rewriting when T is
expressed in the description logic ELHIO.
Rewritings produced by known algorithms often contain predicates that do not occur
in T and Q; such predicates are sometimes called fresh. For example, many rewriting
algorithms normalise TBoxes by replacing complex concepts with fresh atomic concepts. A
rewriting R = RD , R , RQ  obtained in such a way is unlikely to satisfy the requirement
that T |= RD . However, predicates occurring in R but not in T can often be eliminated
via unfolding. For example, let Q = {A(x)  Q(x)} and T = {R.S.B  A}, and assume
that a rewriting algorithm produces
RD = {S(x, y)  B(x)  C(x), R(x, y)  C(y)  A(x)}.
To satisfy Definition 2.2, predicate C can be unfolded and RD replaced with
RD = {R(x, y)  S(y, z)  B(z)  A(x)},
for which T |= RD holds. Unfolding, however, may not always be possible (e.g., this might
be the case when fresh predicates occur in recursive axioms), which may limit the applicability of some of the results presented in this paper.

3. Completeness Guarantees for Incomplete Reasoners
In this section, we introduce the formal framework that will allow us to establish completeness guarantees for incomplete reasoners. Our results are not restricted to any particular
description logic, but are applicable to all TBoxes that satisfy the following criterion.
Definition 3.1. A TBox T is admissible if a description logic DL exists such that T is
a DL-TBox, and both checking TBox satisfiability and answering Boolean UCQs w.r.t. an
arbitrary ABox are decidable for DL.
3.1 Concrete and Abstract Reasoners
Concrete reasoners are complex software systems that dier greatly in the functionality
and the supported interfaces, and that use a range of dierent implementation techniques.
To make our results general and independent from specific implementation techniques, we
introduce the notion of an abstract reasoner. An abstract reasoner can be thought of as an
428

fiCompleteness Guarantees for Incomplete Ontology Reasoners

idealised reasoner that captures the intended behaviour and salient features of a class of
concrete reasoners. A concrete reasoner belonging to this class may use arbitrary algorithms,
as long as their observable behaviour mirrors that of the abstract reasoner.
Definition 3.2. An abstract reasoner ans for a description logic DL is a computable function that takes as input an arbitrary DL-TBox T , an arbitrary ABox A, and either the
special unsatisfiability query  or an arbitrary UCQ Q. The return value of ans is defined
as follows:
 ans(, T , A) is either t or f;
 if ans(, T , A) = t, then ans(Q, T , A) is of no interest and can be arbitrary; and
 if ans(, T , A) = f, then ans(Q, T , A) is a finite set of tuples of individuals, where the
arity of each tuple is equal to the arity the query predicate of Q.
An abstract reasoner ans for DL is said to be applicable to a TBox T if T is a DL-TBox.
Intuitively, ans(, T , A) asks the abstract reasoner to check whether T  A is unsatisfiable, and ans(Q, T , A) asks the abstract reasoner to evaluate Q w.r.t. T  A. If T  A
is unsatisfiable, then each tuple of constants of the same arity as the query predicate Q
is an answer to Q on T  A; therefore, the result of ans(Q, T , A) is of interest only if
ans(, T , A) = fthat is, if ans identifies T  A as satisfiable.
Example 3.3. Consider the abstract reasoners rdf, rdfs, rl, and classify which, given as
input a UCQ Q, a TBox T , and an ABox A, compute the answer to Q w.r.t. T and A as
described next.
Abstract reasoner rdf ignores T and evaluates Q w.r.t. A; more precisely, rdf(, T , A) = f
and rdf(Q, T , A) = cert(Q, , A). Thus, rdf captures the behaviour of RDF reasoners.
Abstract reasoner rdfs evaluates Q w.r.t. A and a datalog program Prdfs that is constructed by translating each RDFS axiom  in T into an equivalent datalog rule; more
precisely, rdfs(, T , A) = f and rdfs(Q, T , A) = cert(Q, Prdfs , A). Thus, rdfs captures the
behaviour of RDFS reasoners such as Sesame.
Abstract reasoner rl evaluates Q w.r.t. A and a datalog program Prl that is constructed
by translating each OWL 2 RL axiom  in T into an equivalent datalog rule; more precisely,
rl(, T , A) = cert(, Prl , A) and rl(Q, T , A) = cert(Q, Prl , A). Thus, rl captures the behaviour
of OWL 2 RL reasoners such as Jena and Oracles Semantic Data Store.
Abstract reasoner classify first classifies T using a complete OWL 2 DL reasoner; that is,
it computes a TBox T  containing each subclass axiom A  B such that T |= A  B, and
A and B are atomic concepts occurring in T . The abstract reasoner then proceeds as rl,
but considers T  T  instead of T ; more precisely, classify(, T , A) = rl(, T  T  , Ain ) and
classify(Q, T , A) = rl(Q, T  T  , A). In this way, classify captures the behaviour of OWL 2
RL reasoners such as Minerva and DLE-Jena that try to be more complete by materialising
certain consequences of T .


An ideal abstract reasoner is one such that, for an arbitrary UCQ Q, TBox T , and
ABox A, we have ans(, T , A) = cert(, T , A), and ans(Q, T , A) = cert(Q, T , A) whenever
ans(, T , A) = f. We next introduce and discuss several properties of abstract reasoners
429

fiCuenca Grau, Motik, Stoilos & Horrocks

that are likely to aect how close they come to this ideal and that may also be relevant to
the applicability of our results.
The following notion of soundness describes abstract reasoners that return only answers
that logically follow from Q, T , and A.
Definition 3.4. An abstract reasoner ans for DL is sound if the following conditions hold
for each UCQ Q, DL-TBox T , and ABox A:
 ans(, T , A) = t implies cert(, T , A) = t; and
 ans(, T , A) = f implies ans(Q, T , A)  cert(Q, T , A).
The following notion of monotonicity describes abstract reasoners for which extending
the input TBox and ABox never leads to dropping answers. We also consider a weaker
notion of (Q, T )-monotonicity, in which the input query Q and TBox T are fixed.
Definition 3.5. An abstract reasoner ans for DL is monotonic if the following conditions
hold for each UCQ Q, all DL-TBoxes T and T  , and all ABoxes A and A such that T  T 
and A  A :
 ans(, T , A) = t implies ans(, T  , A ) = t; and
 ans(, T , A) = f and ans(, T  , A ) = f imply ans(Q, T , A)  ans(Q, T  , A ).
Given a UCQ Q and a DL-TBox T , ans is (Q, T )-monotonic if the following conditions
hold for all ABoxes A and A such that A  A :
 ans(, T , A) = t implies ans(, T , A ) = t; and
 ans(, T , A) = f and ans(, T , A ) = f imply ans(Q, T , A)  ans(Q, T , A ).
As discussed in Section 2.3, the logical consequences of a first-order theory are invariant
under renaming and merging of individuals. To define analogous properties for abstract
reasoners, we first introduce the notions of T -stable and (Q, T )-stable renamingsthat is,
renamings that leave all individuals occurring in T (respectively, in Q and T ) unchanged.
Definition 3.6. Let Q be a query, let T be a TBox, and let  be a renaming. Then,  is T stable if (a) = a for each individual a  dom()  ind(T ); furthermore,  is (Q, T )-stable
if (a) = a for each individual a  dom()  ind(Q  T ).
The following notion of weak faithfulness describes abstract reasoners whose answers
are invariant under replacement of individuals with fresh individuals. Furthermore, weak
(Q, T )-faithfulness relaxes this property to the case when Q and T are fixed.
Definition 3.7. An abstract reasoner ans for DL is weakly faithful if the following conditions hold for each UCQ Q, DL-TBox T , ABox A, injective renaming , and tuple a:
 ans(, T , A) = t and ind(T  A)  dom() imply ans(, (T ), (A)) = t; and
 ans(, T , A) = f, ind(Q  T  A)  dom(), and a  ans(Q, T , A) imply
ans(, (T ), (A)) = f and (a)  ans((Q), (T ), (A)).
430

fiCompleteness Guarantees for Incomplete Ontology Reasoners

Given a UCQ Q and a DL-TBox T , ans is weakly (Q, T )-faithful if the following conditions
hold for each ABox A, injective renaming , and tuple a:
 ans(, T , A) = t, ind(T  A)  dom(), and  is T -stable imply ans(, T , (A)) = t;
and
 ans(, T , A) = f, ind(Q  T  A)  dom(),  is (Q, T )-stable, and a  ans(Q, T , A)
imply ans(, T , (A)) = f and (a)  ans(Q, T , (A)).
The following notion of strong faithfulness describes abstract reasoners whose answers
are invariant under merging of individuals. Furthermore, strong (Q, T )-faithfulness relaxes
this property to the case when Q and T are fixed.
Definition 3.8. An abstract reasoner ans for DL is strongly faithful if the following conditions hold for each UCQ Q, DL-TBox T , ABox A, renaming , and tuple a:
 ans(, T , A) = t implies ans(, (T ), (A)) = t; and
 ans(, T , A) = f, a  ans(Q, T , A), and ans(, (T ), (A)) = f imply
(a)  ans((Q), (T ), (A)).
Given a UCQ Q and a DL-TBox T , ans is strongly (Q, T )-faithful if the following conditions hold for each ABox A, renaming , and tuple a:
 ans(, T , A) = t and  is T -stable imply ans(, T , (A)) = t; and
 ans(, T , A) = f,  is (Q, T )-stable, a  ans(Q, T , A), and ans(, T , (A)) = f imply
(a)  ans(Q, T , (A)).
The results that we present in the rest of this paper are applicable only to abstract
reasoners that satisfy various combinations of these properties; as a minimum, we require
(Q, T )-monotonicity and weak (Q, T )-faithfulness. The abstract reasoners described in Example 3.3 all satisfy these properties. Testing if this is the case for concrete reasoners may,
however, be infeasible in practice; indeed, we are not aware of a technique that would allow one to check whether a concrete reasoner satisfies the required properties. We believe,
however, that all concrete reasoners commonly used in practice are intended to be sound,
monotonic, and at least weakly faithful, and that strong faithfulness is a reasonable assumption in most cases. If a concrete reasoner fails to satisfy some of these properties on
certain inputs, this is likely to be due to implementation bugs; thus, any consequent failure
of completeness can be seen as a bug, and detecting such situations should be viewed as a
part of a more general problem of testing software systems.
We next present several examples of abstract reasoners that do not satisfy some of the
mentioned properties.
Example 3.9. Consider an abstract reasoner that behaves as rdf whenever the number
of assertions in the input ABox is smaller than a certain threshold, and that returns the
empty set of answers for larger ABoxes. Intuitively, such an abstract reasoner characterises
a concrete RDF reasoner that processes inputs only up to a certain size. Such a reasoner is
not (Q, T )-monotonic for an arbitrary Q and T .

431

fiCuenca Grau, Motik, Stoilos & Horrocks

Example 3.10. Consider an abstract reasoner that behaves like rdf, but that, for trust
reasons, removes from each input ABox all assertions whose individuals are blacklisted
(e.g., they come from an untrusted source). Such an abstract reasoner is not weakly (Q, T )faithful for an arbitrary Q and T .

Example 3.10 suggests that, for an abstract reasoner to be weakly faithful, it should not
make decisions that depend on specific names of individuals.
Example 3.11. Consider an abstract reasoner rl= that, given as input a UCQ Q, a TBox
T , and an ABox A, proceeds as follows. First, rl= computes the ABox A obtained by
evaluating the datalog program Prl from Example 3.3 over A. Second, rl= computes the
query Q= obtained from Q by adding to the body of each rule r  Q an inequality x  y
for all pairs of distinct variables x and y occurring in r. Third, rl= evaluates Q= over A
by considering A as a databasethat is, as a finite first-order interpretation in which each
individual is mapped to itself (and thus dierent individuals are distinct). Thus, rl= characterises concrete reasoners that evaluate queries by matching dierent variables to dierent
individuals. Abstract reasoner rl= is sound, monotonic, and weakly faithful, but it is not
strongly faithful. For example, given query Q = {R(x, y)  Q(x)}, ABox A = {R(a, b)},
and renaming  = {a  c, b  c}, we have rl= (Q, , A) = {a}, but rl= (Q, , (A)) = . 
Example 3.11 suggests that, for an abstract reasoner to be strongly faithful, it should
allow distinct variables in queries and axioms to be mapped to the same individuals.
We next identify classes of abstract reasoners that we use throughout this paper. Note
that soundness is not required, which contributes to the generality of our results.
Definition 3.12. Given a UCQ Q and a TBox T , CwQ,T (CsQ,T ) is the class of all (Q, T )monotonic and weakly (strongly) (Q, T )-faithful abstract reasoners applicable to T .
Finally, note that all the abstract reasoners introduced in Example 3.3 are sound, monotonic, and strongly (and therefore also weakly) faithful. Consequently, all concrete reasoners
based on reasoning techniques outlined in Example 3.3 can be considered sound, monotonic,
and strongly faithful, modulo implementation bugs.
3.2 Completeness of Abstract Reasoners
We next define the central notion of abstract reasoner completeness for a given query Q
and TBox T . Intuitively, a (Q, T )-complete abstract reasoner is indistinguishable from a
complete abstract reasoner when applied to Q, T , and an arbitrary ABox A.
Definition 3.13. Let DL be a description logic, and let ans be an abstract reasoner for DL.
Then, ans is (Q, T )-complete for a UCQ Q and a DL-TBox T if the following conditions
hold for each ABox A:
 if cert(, T , A) = t, then ans(, T , A) = t;
 if cert(, T , A) = f and ans(, T , A) = f, then cert(Q, T , A)  ans(Q, T , A).
Finally, ans is complete if it is (Q, T )-complete for each UCQ Q and each DL-TBox T .
432

fiCompleteness Guarantees for Incomplete Ontology Reasoners

Example 3.14. Consider the EL-TBox T consisting of the following axioms; the translation
of the axioms into first-order logic is shown after the  symbol.
takesCo.MathCo  St



MathSt  takesCo.MathCo



CalcCo  MathCo



St  Prof  



x, y.[takesCo(x, y)  MathCo(y)  St(x)]
x.[CalcCo(x)  MathCo(x)]

(7)
(8)

x.[MathSt(x)  y.[takesCo(x, y)  MathCo(y)]] (9)
x.[St(x)  Prof(x)  ]

(10)

Axiom (7) states that everyone taking a maths course is a student; axiom (8) states that
each calculus course is also a maths course; axiom (9) states that each maths student takes
some maths course; and axiom (10) states that no person can be both a student and a
professor. Axiom (8) is an RDFS axiom, and all other axioms in T apart from (9) are OWL
2 RL axioms. Consider also query (11) that retrieves students taking a maths course.
Q = {St(x)  takesCo(x, y)  MathCo(y)  Q(x)}

(11)

None of the abstract reasoners rdf, rdfs, rl, and classify from Example 3.3 are complete in
general for answering UCQs over EL-TBoxes. Furthermore, for Q and T from the previous
paragraph, abstract reasoners rdf, rdfs, and rl are not (Q, T )-complete, as all of them return
the empty set of answers for ABox A = {MathSt(c)}. In contrast, in the following sections
we will show that abstract reasoner classify is (Q, T )-completethat is, that it returns all
certain answers to Q, T , and an arbitrary ABox A.

3.3 Test Suites
Checking (Q, T )-completeness of a concrete reasoner by applying the reasoner to all possible
ABoxes and comparing the reasoners answers with that of a complete reasoner is clearly
infeasible in practice since there are infinitely many candidate input ABoxes. To obtain
a practical approach, we need a finite number of tests. We formalise this idea using the
following definition.
Definition 3.15. Let T be a TBox. A T -test suite is a pair S = S , SQ  where
 S is a finite set of ABoxes such that cert(, T , A) = t for each A  S , and
 SQ is a finite set of pairs A, Y where A is an ABox such that cert(, T , A) = f and
Y is a UCQ.
An abstract reasoner ans applicable to T passes a T -test suite S if ans satisfies the
following two conditions:
 for each A  S , we have ans(, T , A) = t, and
 for each A, Y  SQ , if ans(, T , A) = f, then cert(Y, T , A)  ans(Y, T , A).
Let Q be a UCQ, and let C be a class of abstract reasoners applicable to T . Then, S is
exhaustive for C and Q if each ans  C that passes S is (Q, T )-complete.
A T -test suite S is Q-simple if Q is the only query occurring in SQ ; then, SQ is commonly written as just a set of ABoxes, and A, Q  SQ is commonly abbreviated as A  SQ .
433

fiCuenca Grau, Motik, Stoilos & Horrocks

Intuitively, a T -test suite S = S , SQ  determines the tests that an abstract reasoner
should be subjected to. For a reasoner to pass S, it must correctly identify each ABox
A  S as unsatisfiable, and for each ABoxquery pair A, Y  SQ the reasoner must
correctly answer Y w.r.t. T and A.
Given Q and T , our goal is to identify a T -test suite S that is exhaustive for Qthat
is, a test suite such that each abstract reasoner that passes S is guaranteed to be (Q, T )complete. Depending on the properties of abstract reasoners, however, dierent test suites
may or may not achieve this goal. Therefore, the notion of exhaustiveness is relative to a
class of abstract reasoners C: if S is exhaustive for some class of abstract reasoners C, then
S can be used to test an arbitrary abstract reasoner in C. Note that S depends on the
target class of abstract reasoners, but not on the actual abstract reasoner being tested; in
order words, the construction of S depends on the properties that one can assume to hold
for the target abstract reasoner. Furthermore, if an abstract reasoner not contained in C
passes S, this will in general not imply a (Q, T )-completeness guarantee.
Example 3.16. Let Q and T be as specified in Example 3.14, and let A1 A6 be the
following ABoxes.
A1 = {takesCo(c, d), MathCo(d)}
A3 = {takesCo(c, d), CalcCo(d)}
A5 = {MathSt(c)}

A2 = {takesCo(c, c), MathCo(c)}
A4 = {takesCo(c, c), CalcCo(c)}
A6 = {St(c), Prof(c)}

In the following sections, we will show that the Q-simple T -test suite S = S , SQ  defined
by S = {A6 } and SQ = {A1 , . . . , A5 } is exhaustive for the class CwQ,T and Q; consequently,
S can be used to test all abstract reasoners from Example 3.3.
In particular, note that abstract reasoners rdf and rdfs fail all tests in S and SQ , and
that abstract reasoner rl fails the test A5  SQ ; furthermore, all failed tests provide a counterexample of (Q, T )-completeness. In contrast, abstract reasoner classify from Example
3.14 passes the tests in S, which implies that the abstract reasoner is indeed (Q, T )-complete.
Finally, consider a variant of the abstract reasoner classify that, similarly to the abstract
reasoner described in Example 3.9, returns the empty set of answers if the input ABox
contains more than, say, ten assertions. Such an abstract reasoner is not (Q, T )-monotonic
and hence does not belong to CwQ,T . This abstract reasoner clearly passes S; however, since
it does not belong to CwQ,T , passing S (correctly) does not imply that the abstract reasoner
is (Q, T )-complete.

We next state the following property, the proof of which is trivial.

Proposition 3.17. Let Q be a UCQ, let T be a TBox, and let C1 and C2 be classes of
abstract reasoners applicable to T such that C1  C2 .
1. If a T -test suite S is exhaustive for C2 and Q, then S is also exhaustive for C1 and Q.
2. If no T -test suite exists that is exhaustive for C1 and Q, then no T -test suite exists
that is exhaustive for C2 and Q.
Therefore, when proving existence of a T -test suite exhaustive for Q, the most general
result is the one that applies to the largest possible class of abstract reasoners. Furthermore,
434

fiCompleteness Guarantees for Incomplete Ontology Reasoners

in the following section we will identify cases for which no T -test suite exhaustive for Q
can be found; by Proposition 3.17 it suces to provide nonexistence results for the smallest
possible class of abstract reasoners.
We finish this section by pointing out an important practically relevant property of
Q-simple T -test suites, which has been illustrated in Example 3.16.
Proposition 3.18. Let S = S , SQ  be a Q-simple T -test suite and let ans be an abstract
reasoner applicable to T . If ans does not pass S, then ans is not (Q, T )-complete.
Proof. The ABox in S or SQ for which ans does not satisfy the conditions from Definition
3.15 is a counterexample for the (Q, T )-completeness of ans.
Thus, a Q-simple T -test suite S exhaustive for C and Q provides a sucient and necessary test for (Q, T )-completeness of the abstract reasoners in C. In contrast, if S is not
Q-simple, we show in Section 3.7 that then S provides only a sucient, but not also a
necessary test for (Q, T )-completeness of the abstract reasoners in C.
3.4 Negative Results
In Sections 3.5 (resp. Section 3.6) we identify restrictions on a UCQ Q and a TBox T
that guarantee existence of T -test suites exhaustive for CwQ,T (resp. CsQ,T ) and Q. Before
presenting these positive results, we first outline the limits of (Q, T )-completeness testing
and thus justify the restrictions we use in the following sections.
3.4.1 Monotonicity and Weak Faithfulness
Our approaches for testing (Q, T )-completeness of abstract reasoners are applicable only to
reasoners that are (Q, T )-monotonic and weakly (Q, T )-faithful. In this section, we provide
a formal justification for these requirements in the form of the following two theorems.
 Theorem 3.19 shows that exhaustive test suites do not exist if we consider the class
of abstract reasoners satisfying all properties from Section 3.1 apart from (Q, T )monotonicity; this includes soundness, strong faithfulness (which implies weak faithfulness), and monotonicity w.r.t. the TBox only.
 Theorem 3.20 shows that exhaustive test suites do not exist if we consider the class
of abstract reasoners satisfying all properties defined in Section 3.1 with the exception
of (Q, T )-weak faithfulness; these properties include soundness and monotonicity.
The negative results of Theorems 3.19 and 3.20 are very strong: they hold for smallest
classes of abstract reasoners we can define based on the notions introduced in Section 3.1 (by
Proposition 3.17, the smaller the class of abstract reasoners, the more general the negative
result); and they hold regardless of the Q and T considered (modulo a minor technicality:
unlike Theorem 3.19, Theorem 3.20 requires T to be satisfiable).
The proof of Theorem 3.19 can intuitively be understood as follows. We first assume
that S is a T -test suite exhaustive for Q and the class of abstract reasoners to which the
theorem applies. Then, we specify an abstract reasoner ans that does the right thing (i.e.,
it returns the correct answer) when it is given as input the query Q, the TBox T , and
435

fiCuenca Grau, Motik, Stoilos & Horrocks

an arbitrary ABox containing at most as many assertions as the largest test ABox in S;
otherwise, ans returns a sound, but an incomplete answer. We finally show the following
three properties of ans.
 Abstract reasoner ans belongs to the relevant class of abstract reasoners.
 Abstract reasoner ans passes S.
 Abstract reasoner ans is incomplete for at least one input ABox.
These three properties then show that S is not exhaustive for Q and the relevant class of
abstract reasoners. Intuitively, this means that the class of abstract reasoners is too large,
allowing abstract reasoners to treat their input in an erratic way.
Theorem 3.19. Let Q be an arbitrary UCQ, and let T be an arbitrary admissible TBox.
Then, no T -test suite exists that is exhaustive for Q and the class of all sound and strongly
faithful abstract reasoners applicable to T satisfying the following conditions for each TBox
T  with T  T  and each ABox A:
 ans(, T , A) = t implies ans(, T  , A) = t;
 ans(, T , A) = f and ans(, T  , A) = f imply ans(Q, T , A)  ans(Q, T  , A).
Proof. Consider an arbitrary T -test suite S = S , SQ . Let n be the maximum number of
assertions in an ABox from S. Furthermore, let ans be the abstract reasoner that takes as
input a UCQ Qin , an FOL-TBox Tin , and an ABox Ain . The result of ans(, Tin , Ain ) is
determined as follows.
1. Try to find a renaming  such that dom() = ind(T ) and (T )  Tin ; if no such 
exists, then return f.
2. If Ain contains at most n assertions, then check the satisfiability of (T )  Ain using
a sound and complete reasoner; return t if (T )  Ain is unsatisfiable.
3. Return f.
Furthermore, the result of ans(Qin , Tin , Ain ) is determined as follows.
4. Try to find a renaming  such that dom() = ind(Q  T ), (T )  Tin , and (Q) = Qin ;
if no such  exists, then return .
5. If Ain contains at most n assertions, then compute cert((Q), (T ), Ain ) using a sound
and complete reasoner and return the result.
6. Return .
Since T is admissible, checks in steps 2 and 5 can be performed in finite time; furthermore, step 1 can be realised by enumerating all mappings from ind(T ) to ind(Tin ), and step
4 can be realised analogously; consequently, ans can be implemented such that it terminates
on all inputs. To see that ans is sound and monotonic w.r.t. the TBox, consider arbitrary
input Qin , Tin , Tin , and Ain such that Tin  Tin .
436

fiCompleteness Guarantees for Incomplete Ontology Reasoners

 Assume that ans(, Tin , Ain ) = t. Then, on Qin , Tin , and Ain the abstract reasoner
returns in step 2 because (T )  Ain is unsatisfiable; but then, since (T )  Tin , we
have that Tin  Ain is unsatisfiable as well, as required for soundness. Furthermore,
since (T )  Tin  Tin , on Qin , Tin , and Ain the abstract reasoner returns in step 2
as well, so ans(, Tin , Ain ) = t, as required for monotonicity w.r.t. the TBox.
 Assume that a  ans(Qin , Tin , Ain ). Then, on Qin , Tin , and Ain the abstract reasoner
returns in step 5, and therefore we have a  cert((Q), (T ), Ain ); but then, since
(Q) = Qin and (T )  Tin , we have a  cert(Qin , Tin , Ain ), as required for soundness. Furthermore, since (T )  Tin  Tin , on Qin , Tin , and Ain the abstract reasoner
returns in step 5 as well, so a  ans(Qin , Tin , Ain ), as required for monotonicity w.r.t.
the TBox.
To see that ans is strongly faithful, consider an arbitrary renaming . If renaming 
exists such that (Q) = Qin and (T )  Tin , then clearly renaming   exists such that
  (Q) = (Qin ) and   (T )  (Tin ). Consequently, if ans(, Tin , Ain ) returns in step 2, then
ans(, (Tin ), (Ain )) returns in step 2 as well; similarly, if ans(Qin , Tin , Ain ) returns in step
5, then ans((Qin ), (Tin ), (Ain )) returns in step 5 as well; clearly, ans is strongly faithful.
Finally, it is straightforward to see that ans passes S.
Now let A be an ABox containing at least n + 1 assertions such that cert(Q, , A) = ;
such A clearly exists. If T  A is unsatisfiable, then ans(, T , A) = f; furthermore, if T  A
is satisfiable, then ans(Q, T , A) = ; consequently, ans is not (Q, T )-complete. Thus, S is
not exhaustive for Q and the class of abstract reasoners considered in this theorem.
We next prove Theorem 3.20. The proof is similar to the proof of Theorem 3.19, and
the main dierence is in the abstract reasoner ans we construct. In particular, given a test
suite S, we take ans to return the correct answer on the query Q, the TBox T , and each
ABox that contains only the individuals occurring in S; otherwise, the abstract reasoner
returns a sound, but an incomplete answer. Again, the class of the abstract reasoners is
too large, allowing ans to treat inputs in an erratic way.
Unlike Theorem 3.19, the following theorem requires T to be satisfiable; to understand
why, consider an arbitrary unsatisfiable TBox T and UCQ Q. Let S = S , SQ  be the
T -test suite defined by S = {} (i.e., S contains a single empty ABox) and SQ =  (i.e.,
SQ contains no ABoxes), and consider an arbitrary monotonic abstract reasoner ans that
passes S . Since ans passes S, we have ans(, T , ) = t; but then, since ans is monotonic,
for an arbitrary ABox A we have ans(, T , A) = t as well, which in turn implies that ans is
(Q, T )-complete. Failure to satisfy weak faithfulness is thus irrelevant if T is unsatisfiable.
Theorem 3.20. Let T be an arbitrary admissible and satisfiable TBox and let Q be an
arbitrary UCQ. Then, no T -test suite exists that is exhaustive for Q and the class of all
sound and monotonic abstract reasoners applicable to T .
Proof. Consider an arbitrary T -test suite S = S , SQ . Let I be the set of all individuals
occurring in S, Q, and T . Furthermore, let ans be the abstract reasoner that takes as
input a UCQ Qin , an FOL-TBox Tin , and an ABox Ain . The result of ans(, Tin , Ain ) is
determined as follows.
1. If T  Tin , then return f.
437

fiCuenca Grau, Motik, Stoilos & Horrocks

2. Let Ain,I be the set of assertions in Ain that mention only the individuals in I.
3. Check the satisfiability of T  Ain,I using a sound and complete reasoner; return t if
T  Ain,I is unsatisfiable, and return f otherwise.
Furthermore, given a UCQ Qin , the result of ans(Qin , Tin , Ain ) is determined as follows:
4. If T  Tin or Q =
 Qin , then return .
5. Let Ain,I be the set of assertions in Ain that mention only the individuals in I.
6. Compute cert(Q, T , Ain,I ) using a sound and complete reasoner and return the result.
That ans can be implemented such that it terminates on all inputs can be shown as in
the proof of Theorem 3.19. Furthermore, the soundness of ans follows from the following
two observations.
 Assume that ans(, Tin , Ain ) = t. Then, the abstract reasoner returns in step 3 since
T  Ain,I is unsatisfiable; but then, since T  Tin and Ain,I  Ain , we have that
Tin  Ain is unsatisfiable as well, as required.
 Assume that a  ans(Qin , Tin , Ain ). Then, the abstract reasoner returns in step 6,
and therefore we have a  cert(Q, T , Ain,I ); but then, since Q = Qin , T  Tin , and
Ain,I  Ain , we have a  cert(Qin , Tin , Ain ), as required.
For monotonicity, consider an arbitrary Tin and Ain such that Tin  Tin and Ain  Ain ;
clearly, we have T  Tin and Ain,I  Ain,I ; but then, by monotonicity of first-order logic,
ans(, Tin , Ain ) = t implies ans(, Tin , Ain ) = t, and ans(Q, Tin , Ain )  ans(Q, Tin , Ain ). Finally, it is straightforward to see that ans passes S.
Now consider an arbitrary ABox A such that ind(A)  I =  and cert(Q, , A) = ; such
A clearly exists. If T  A is unsatisfiable, since the ABox constructed in step 2 is empty
and T is satisfiable, we have ans(, T , A) = f; furthermore, if T  A is satisfiable, since the
ABox constructed in step 5 is empty, ans(Q, T , A) cannot contain individuals not occurring
in I; consequently, ans is not (Q, T )-complete. Thus, S is not exhaustive for Q and the
class of abstract reasoners considered in this theorem.
3.4.2 Monotonicity and Weak Faithfulness do not Suffice
Next, we show that (Q, T )-monotonicity and (Q, T )-faithfulness in general do not guarantee
existence of a T -test suite exhaustive for Q. In particular, Theorem 3.21 shows that, if T
contains a single recursive axiom, no test suite exists that is exhaustive for the class of
all sound, monotonic, and strongly faithful abstract reasoners (and by Proposition 3.17
for CsQ,T and CwQ,T as well, for each UCQ Q). Although our result is applicable only to a
particular Q and T , it is straightforward to adapt the proof to any TBox with a recursive
axiom that is relevant to the given query. Example 3.22, however, shows that the concept
of relevance is rather dicult to formalise: even if T entails a recursive axiom, this axiom
is not necessarily relevant to answering the query. In order not to complicate matters any
further, we state the following result for fixed Q and T , and we hope that our proof clearly
illustrates the limitations incurred by recursive axioms.
438

fiCompleteness Guarantees for Incomplete Ontology Reasoners

Theorem 3.21. For Q = {A(x)  Q(x)} and T = {R.A  A}, no T -test suite exists
that is exhaustive for Q and the class of all sound, monotonic, and strongly faithful abstract
reasoners applicable to T .

Proof. Consider an arbitrary T -test suite S = S , SQ . Since S is a T -test suite, S
contains only ABoxes A such that T  A is unsatisfiable; clearly, no such ABox exists for T
as stated in the theorem, so S = . Let SQ be an arbitrary, but finite, set of pairs A, Y
with A an ABox and Y a UCQ, and let n be the maximum number of assertions in an ABox
in SQ . Furthermore, consider the following ABox, where ai = aj for all 1  i < j  n + 1:
An+1 = {R(a0 , a1 ), . . . , R(an , an+1 ), A(an+1 )}
We next construct an abstract reasoner pEvaln with the following properties:
(P1) for each A, Y  SQ , we have cert(Y, T , A)  pEvaln (Y, T , A);
(P2) a0  pEvaln (Q, T , An+1 ); and
(P3) pEvaln is sound, monotonic, and strongly faithful.
Note that a0  cert(Q, T , An+1 ), so the above three properties imply that S is not exhaustive
for Q and the class of abstract reasoners considered in this theorem.
Abstract reasoner pEvaln accepts as input an FOL-TBox Tin and an ABox Ain . The
result of pEvaln (, Tin , Ain ) is determined as follows.
1. Return f.

Furthermore, given a UCQ Qin , the result of pEvaln (Qin , Tin , Ain ) is determined as follows.
2. If T  Tin or Q =
 Qin , return .
3. Asat := Ain
4. Repeat the following computation n times:
 Asat := Asat  {(A(x)) |  is a substitution s.t. {(R(x, y)), (A(y))}  Asat }
5. Return cert(Q, , Asat ).

Abstract reasoner pEvaln clearly satisfies Property (P2) because deriving the assertion A(a0 )
requires n+1 iterations of the loop in step 4. Furthermore, pEvaln also satisfies (P1) because
every ABox A occurring in SQ contains at most n individuals and T can be seen as the
rule R(x, y)  A(y)  A(x), which pEvaln applies n times to the input ABox Ain .
We finally show (P3). Abstract reasoner pEvaln is clearly sound. Furthermore, for each
renaming  we have (T ) = T and (Q) = Q, so pEvaln is clearly strongly faithful.
To show that pEvaln is monotonic, consider arbitrary Tin , Tin , Ain , and Ain such that
Tin  Tin and Ain  Ain ; since pEvaln (, Tin , Ain ) = f for each input, the following are the
only relevant cases.
 pEvaln returns  in step 2 on input Qin , Tin , and Ain , in which case either T  Tin or
Q = Qin . Since Tin  Tin , clearly pEvaln also returns  in step 2 on input Qin , Tin ,
and Ain , and monotonicity holds.
439

fiCuenca Grau, Motik, Stoilos & Horrocks

 pEvaln returns in step 5 on input Qin , Tin , and Ain . Then, pEvaln can return in either
step 2 or step 5 on input Qin , Tin and Ain ; in the former case, monotonicity holds
trivially, and in the latter case, pEvaln (Qin , Tin , Ain )  pEvaln (Qin , Tin , Ain ) follows
directly from the fact that Ain  Ain .
The following example shows that the presence of recursive axioms in T does not preclude the existence of a T -test suite exhaustive for Q.
Example 3.22. Consider Q and T defined as follows:
Q = {A(x)  B(x)  Q(x)}
T = {R.A  A, B  R.A}
Note that T contains the axiom mentioned in Theorem 3.21; however, note also that
T |= B  A, and so
R = , {B(x)  Q(x)}

is a UCQ rewriting of Q w.r.t. T . In Section 3.5 we show that the existence of a UCQ rewriting of Q w.r.t. T guarantees existence of a Q-simple T -test suite that is exhaustive for CwQ,T
(and hence also for CsQ,T ) and Q; for example, S = , { {B(a)} } is one such T -test suite.
Intuitively, T |= B  A is the only consequence of T that is relevant for answering Q; hence,
for T  = {B  A} and Q = {A(x)  Q(x)}, we have that cert(Q, T , A) = cert(Q , T , A) for
an arbitrary ABox A. Hence, the recursive axiom in T is irrelevant for answering Q, and
therefore its presence in T does not preclude the existence of a T -test suite that is exhaustive
for CwQ,T and Q.

3.5 Testing (Q, T )-Monotonic and Weakly (Q, T )-Faithful Abstract Reasoners

In this section, we identify a sucient condition that guarantees existence of a Q-simple
T -test suite S exhaustive for CwQ,T and Q; by Proposition 3.17, this result applies to CsQ,T
as well. Roughly speaking, such S can always be computed by instantiating the rules in a
UCQ rewriting of Q w.r.t. T in a suitable way. The requirement that Q should be UCQrewritable w.r.t. T invalidates the negative result of Theorem 3.21 since no UCQ rewriting
of Q = {A(x)  Q(x)} w.r.t. T = {R.A  A} exists.
This result allows one to compute Q-simple T -test suites exhaustive for Q in numerous
practically relevant cases. In particular, a UCQ rewriting is guaranteed to exist if T is
expressed in the DLs underpinning the QL profile of OWL 2 (Motik et al., 2009a; Calvanese
et al., 2007); furthermore, as illustrated in Example 3.22, a UCQ rewriting may exist even
if T is expressed in other fragments of OWL 2 such as the OWL 2 EL (Motik et al., 2009a;
Baader, Brandt, & Lutz, 2005). In practice, such rewritings can be computed using systems
such as QuOnto (Acciarri et al., 2005) and REQUIEM (Perez-Urbina et al., 2010).
We establish the desired result in two steps. First, in Section 3.5.1 we present a general
characterisation of Q-simple T -test suites exhaustive for CwQ,T and Q. Then, in Section
3.5.2 we use this characterisation to establish the desired connection between rewritings
and Q-simple T -test suites exhaustive for Q.
440

fiCompleteness Guarantees for Incomplete Ontology Reasoners

3.5.1 Characterisation of Simple and Exhaustive Test Suites
We next prove that a Q-simple T -test suite S = S , SQ  is exhaustive for CwQ,T and Q if
and only if S contains an isomorphic copy of each data pattern (i.e., a subset of an ABox)
that can produce a certain answer to Q and  w.r.t. T , but that preserves the identity of
the individuals occurring in T and Q. To show that this is not just a sucient, but also
a necessary condition for the existence of an exhaustive T -test suite, we observe that, if S
does not contain one such copy of a data pattern, we can always find an abstract reasoner
in CwQ,T that passes S but that misses certain answers obtained via the missing data pattern
and that is therefore not (Q, T )-complete.
Theorem 3.23. Let Q be a UCQ, let T be an admissible TBox, and let S = S , SQ  be
a Q-simple T -test suite. Then, S is exhaustive for CwQ,T and Q if and only if the following
properties are satisfied for each ABox A.
1. If T  A is unsatisfiable, then there exist an ABox A  S and an injective T -stable
renaming  such that dom() = ind(T  A ) and (A )  A.
2. If T  A is satisfiable, then for each tuple a  cert(Q, T , A) there exist an ABox
A  SQ , a tuple b  cert(Q, T , A ), and an injective (Q, T )-stable renaming  such
that (b) = a, dom() = ind(Q  T  A ), and (A )  A.
Proof. () Let S be an arbitrary Q-simple T -test suite that satisfies Properties 1 and 2;
we next show that S is exhaustive for CwQ,T and Q. Consider an arbitrary abstract reasoner
ans  CwQ,T that passes Sthat is, ans satisfies the following two properties:
(a) ans(, T , A ) = t for each A  S , and
(b) ans(, T , A ) = f implies cert(Q, T , A )  ans(Q, T , A ) for each A  SQ .
We next show that ans is (Q, T )-completethat is, that ans satisfies the two conditions in
Definition 3.13 for an arbitrary ABox A. For an arbitrary such A, we have the following
two possibilities, depending on the satisfiability of T  A.
Assume that T  A is unsatisfiable. Since S satisfies Property 1, there exist an ABox
A  S and an injective T -stable renaming  s.t. dom() = ind(T  A ) and (A )  A.
By Condition (a) we have ans(, T , A ) = t. Since ans is weakly (Q, T )-faithful,  is injective
and T -stable, and dom() = ind(T  A ), we have ans(, T , (A )) = t; finally, since ans is
(Q, T )-monotonic and (A )  A, we have ans(, T , A) = t, as required by Definition 3.13.
Assume that T  A is satisfiable and ans(, T , A) = f. Furthermore, consider an arbitrary tuple a  cert(Q, T , A). Since S satisfies Property 2, there exist an ABox A  SQ ,
a tuple b  cert(Q, T , A ), and an injective (Q, T )-stable renaming  such that (b) = a,
dom() = ind(Q  T  A ), and (A )  A. Since (A )  A, ans(, T , A) = f, and ans is
(Q, T )-monotonic, we have ans(, T , (A )) = f; furthermore, ind(T  A )  dom(),  is
injective and (Q, T )-stable, and ans is weakly (Q, T )-faithful, so ans(, T , (A )) = f implies ans(, T , A ) = f. But then, by Condition (b) we have cert(Q, T , A )  ans(Q, T , A ),
so b  ans(Q, T , A ). Since ans is weakly (Q, T )-faithful,  is injective and (Q, T )-stable,
and dom() = ind(Q  T  A ), we have (b)  ans(Q, T , (A )); since (b) = a, we have
441

fiCuenca Grau, Motik, Stoilos & Horrocks

a  ans(Q, T , (A )); finally, since ans is (Q, T )-monotonic and (A )  A, we then have
a  ans(Q, T , A), as required by Definition 3.13.

() Assume that S is exhaustive for CwQ,T and Q; we next show that Properties 1 and 2
are satisfied for an arbitrary ABox A. To this end, we consider a particular abstract reasoner
ans for which we prove that ans  CwQ,T and that ans passes S; this abstract reasoner will
help us identify the ABox, the tuple, and the renaming required to prove Properties 1 and 2.
Let ans be the abstract reasoner that takes as input a UCQ Qin , an FOL-TBox Tin ,
and an ABox Ain . The result of ans(, Tin , Ain ) is determined as follows.
1. If T =
 Tin , then return f.

2. For each ABox A  S , do the following.
(a) Check the satisfiability of T  A using a sound, complete, and terminating
reasoner.
(b) If T  A is unsatisfiable, and if an injective T -stable renaming  exists such that
dom() = ind(T  A ) and (A )  Ain , then return t.
3. Return f.
Furthermore, the result of ans(Qin , Tin , Ain ) is determined as follows.
4. If T =
 Tin or Q =
 Qin , then return .
5. Out := .
6. For each tuple a of constants occurring in Ain of arity equal to the arity of the query
predicate of Q, and for each A  SQ do the following.
(a) Compute C := cert(Q, T , A ) using a sound, complete and terminating reasoner.
(b) If a tuple b  C and an injective (Q, T )-stable renaming  exist such that
(b) = a, dom() = ind(Q  T  A ), and (A )  Ain , then add a to Out.
7. Return Out.
We next show that ans belongs to CwQ,T ; to this end, we prove that ans terminates on
all inputs, and that it is (Q, T )-monotonic and weakly (Q, T )-faithful.
Termination. Since T is admissible, checking satisfiability of T  A and the computation
of cert(Q, T , A ) are decidable, so the relevant sound, complete and terminating reasoners
exist. Furthermore, checking whether a T -stable (resp. (Q, T )-stable) injective renaming 
exists can be done by enumerating all renamings from ind(T  A ) (resp. ind(Q  T  A ))
to ind(T  Ain ) (resp. ind(Q  T  Ain )). Therefore, ans can be implemented such that it
terminates on each input.
(Q, T )-Monotonicity. Consider arbitrary input Qin , Tin , Ain , and Ain such that Ain  Ain .
 Assume that ans(, Tin , Ain ) = t, so on Tin and Ain the abstract reasoner terminates
in step 2(b) for some A  S and . But then, since (A )  Ain  Ain , on Tin
and Ain the abstract reasoner also terminates in step 2(b), so ans(, Tin , Ain ) = t, as
required.
442

fiCompleteness Guarantees for Incomplete Ontology Reasoners

 Assume that ans(, Tin , Ain ) = f and ans(, Tin , Ain ) = f, and consider an arbitrary
tuple a  ans(Qin , Tin , Ain ). Then a is added to Out in step 7(b) for some A  SQ
and . But then, since (A )  Ain  Ain , on Qin , Tin , and Ain the abstract reasoner
also adds a to Out in step 7(b), so a  ans(Qin , Tin , Ain ), as required.
Weak (Q, T )-Faithfulness. Consider an arbitrary input Qin , Tin , and Ain , and an arbitrary
injective renaming .
 Assume that ans(, Tin , Ain ) = t, dom()  ind(T  A), and  is T -stable. Thus, on
Tin and Ain the abstract reasoner terminates in step 2(b) for some A  S and . Let
 be the renaming such that  (c) = ((c)) for each c  ind(T  A ). Clearly, we have
dom( ) = ind(T  A ), renaming  is T -stable and injective, and  (A )  (Ain ).
Thus, on Tin and (Ain ) the abstract reasoner terminates in step 2(b), so we therefore
have ans(, Tin , (Ain )) = t, as required.
 Assume that ans(, Tin , Ain ) = f, dom()  ind(Q  T  A), and  is (Q, T )-stable,
and consider an arbitrary truple a  ans(Qin , Tin , Ain ). Then a is added to Out in step
7(b) for some A  SQ , , and b. Let  be the renaming defined s.t.  (c) = ((c))
for each individual c  ind(Q  T  A ). Clearly, we have dom( ) = ind(Q  T  A ),
renaming  is (Q, T )-stable and injective,  (A )  (Ain ), and  (b) = (a). Thus,
on Qin , Tin , and (Ain ) the abstract reasoner terminates in step 7(b) and we clearly
have (a)  ans(Qin , Tin , (Ain )), as required.
This concludes the proof that ans  CwQ,T . Furthermore, ans clearly passes S; but then,
since S is exhaustive for CwQ,T and Q, abstract reasoner ans is (Q, T )-complete. We next
prove the main claim of this theorem. To this end, consider an arbitrary ABox A; we have
the following possibilities, depending on the satisfiability of T  A.
 Assume that T  A is unsatisfiable. Then ans(, T , A) = t, so the abstract reasoner
returns in step 2(b) for some ABox A  S and some T -stable renaming  such that
(A )  A and dom() = ind(T  A ). Thus, Property 1 holds as required.
 Assume that T  A is satisfiable, and consider an arbitrary tuple a  cert(Q, T , A).
Then ans(, T , A) = f and a  ans(Q, T , A), so a is added to Out in step 7(b) for
some ABox A  SQ , tuple b  cert(Q, T , A ), and an injective (Q, T )-stable renaming
 such that (b) = a, dom() = ind(Q  T  A ), and (A )  A. Thus, Property 2
holds as required.
The following example illustrates Theorem 3.23.
Example 3.24. Let Q and T be as specified in Example 3.14, and let S = S , SQ  be
specified in Example 3.16. As we show in Section 3.5.2, S is exhaustive for CwQ,T and Q.
Consider now an ABox A = {St(a), MathSt(b), takesCo(a, b1 )}. Clearly, T  A is satisfiable and cert(Q, T , A) = {b}. By Theorem 3.23, this certain answer can be obtained by
evaluating Q w.r.t. T and an ABox in SQ . Indeed, note that ABox A5  SQ is isomorphic
to the subset A = {MathSt(b)} of A via renaming  = {b  c}, and that applying Q to T
and A5 produces c, which is isomorphic to b via .
443

fiCuenca Grau, Motik, Stoilos & Horrocks

Note also that, if we remove A5 from S, we no longer have a T -test suite that is
exhaustive for Q. For example, abstract reasoner rl from Example 3.16 would pass such a
test suite, but it would not return the required certain answers when applied to A5 (and,
consequently, when applied to A either).

3.5.2 Computing Test Suites Exhaustive for CwQ,T

Based on Theorem 3.23, in this section we show that a T -test suite exhaustive for CwQ,T and
Q an be obtained by instantiating a UCQ rewriting R of Q w.r.t. T that is, by replacing all
variables in R with individuals in all possible ways. Please note that such an instantiation
must be full, in the sense that all possible replacements must be considered. This is because
the class CwQ,T can contain abstract reasoners such as rl= from Example 3.11 that are not
strongly faithful and that may incorrectly handle the case when distinct variables are bound
to the same individuals.
Definition 3.25. Let I be a set of individuals, let r be a datalog rule, and let  be a
substitution. Then,  is an instantiation substitution for r w.r.t. I if (x)  I for each
variable x occurring in r. If the latter holds, then the instantiation of r w.r.t.  is the ABox
Ar := {(B) | B  body(r)}.
Let Q be a UCQ, let T be a TBox, let R = R , RQ  be a UCQ rewriting of Q w.r.t.
T , let m be the maximum number of distinct variables occurring in a rule in R, and let I
be a set containing all individuals occurring in R, Q, and T , as well as m fresh individuals.
R,I
R,I
The full instantiation of R w.r.t. I is the pair ER,I = ER,I
and ER,I
Q
 , EQ  where E
are the smallest sets of ABoxes such that
 Ar  ER,I
 for each r  R and each instantiation substitution  for r w.r.t. I, and
 Ar  ER,I
Q for each r  RQ and each instantiation substitution  for r w.r.t. I such
that cert(, R , Ar ) = f.
ER,I is clearly unique up to the renaming of the fresh individuals in I, so I is typically left
R
implicit, and one talks of the full instantiation ER = ER
 , EQ  of R.
Example 3.26. Let Q and T be as specified in Example 3.14, and let R = R , RQ  be
such that R = {St(x)  Prof(x)  } and RQ consists of the following datalog rules:
takesCo(x, y)  MathCo(y)  Q(x)
takesCo(x, y)  CalcCo(y)  Q(x)
MathSt(x)  Q(x)

Then, R is a UCQ rewriting of Q w.r.t. T , and one can see that the Q-simple T -test suite
S = S , SQ  from Example 3.16 is the full instantiation of R.


The following theorem shows that the full instantiation of a UCQ rewriting of Q w.r.t.
T is a Q-simple T -test suite exhaustive for CwQ,T and Q. According to this theorem, the
T -test suite S in Example 3.26 is exhaustive for CwQ,T and Q.
444

fiCompleteness Guarantees for Incomplete Ontology Reasoners

Theorem 3.27. Let Q be a UCQ, let T be an admissible TBox, let R = R , RQ  be a
R
UCQ rewriting of Q w.r.t. T , and let ER = ER
 , EQ  be the full instantiation of R. Then,
ER is a Q-simple T -test suite that is exhaustive for CwQ,T and Q.

Proof. Let I be the set of individuals that ER is obtained from. We first show that ER is
a Q-simple T -test suitethat is, that it satisfies the two properties in Definition 3.15.
 Consider an arbitrary ABox A  ER
 . Then, a rule r  R and an instantiation
substitution  for r exist such that A = Ar ; clearly cert(, {r}, A) = t; since R is a
UCQ rewriting, T  A is unsatisfiable, as required.
 Consider an arbitrary ABox A  ER
Q . Then, cert(, R , A) = f by Definition 3.25;
since R is a UCQ rewriting, T  A is satisfiable, as required.
We next show that ER satisfies Properties 1 and 2 of Theorem 3.23 for an arbitrary
ABox A.
(Property 1) Assume that T  A is unsatisfiable. Since R is a UCQ rewriting, by
Definition 2.2 we have cert(, R , A) = t; but then, a rule r  R and a substitution 
exist such that Ar  A and cert(, {r}, Ar ) = t. Let  be an injective renaming such that
for each individual c occurring in R or T we have (c) = c, and for each individual d
occurring in Ar but not in R and T we have that (d) is a fresh individual in I; such 
exists since the number of variables in r is smaller or equal to the number of fresh individuals
in I. Let  be an instantiation substitution for r such that (x) = ((x)) for each variable
R
x occurring in r; then Ar  ER
 holds since E is the full instantiation of R w.r.t. I. Let 
be any injective renaming that coincides with the inverse of  on each individual occurring
in Ar , R, or T ; such  exists since  is injective and the range of  contains each individual
occurring in Ar , R, and T . Clearly (Ar ) = Ar holds, so (Ar )  A. Furthermore,  is
clearly T -stable. Thus, Property (1) is satisfied for Ar  ER
 and .
(Property 2) Assume that T  A is satisfiable, and consider an arbitrarily chosen tuple
a  cert(Q, T , A). Since R is a UCQ rewriting, by Definition 2.2 we have cert(, R , A) = f
and a  cert(RQ , R , A); but then, clearly a  cert(RQ , , A) as well. Then, a rule r  RQ
and a substitution  exist such that Ar  A and a  cert({r}, , Ar ). Let  be an injective
renaming such that for each individual c occurring in R, Q, or T we have (c) = c, and
for each individual d occurring in Ar but not in R, Q, and T we have that (d) is a fresh
individual in I; such  clearly exists since the number of variables in r is smaller or equal
to the number of fresh individuals in I. Let  be an instantiation substitution for r such
R is
that (x) = ((x)) for each variable x occurring in r; then Ar  ER
Q holds since E
the full instantiation of R w.r.t. I. Let  be any injective renaming that coincides with
the inverse of  on each individual occurring in Ar , R, Q, or T ; such  exists since 
is injective and the range of  contains each individual occurring in Ar , R, Q, and T .
Furthermore, clearly a tuple b  cert({r}, , Ar ) exists such that (head(r)) = Q(b); since
R is a UCQ rewriting and T  Ar is satisfiable, we have b  cert(Q, T , Ar ); furthermore,
since  is injective, (b) = a clearly holds. But then, Property (2) is satisfied for Ar  ER
Q,

, and b.
445

fiCuenca Grau, Motik, Stoilos & Horrocks

3.5.3 Minimising Exhaustive Test Suites
In practice, it is clearly beneficial to compute test suites that are as small as possible.
This goal can be achieved by applying known techniques for minimising UCQ rewritings
(Calvanese et al., 2007; Perez-Urbina, Horrocks, & Motik, 2009). By Theorem 3.27, the
smallest such rewriting can be instantiated to obtain an exhaustive test suite.
State of the art query rewriting systems employ subsumption and condensation techniques in order to reduce the size of a rewriting. A datalog rule r subsumes a datalog rule
r if a substitution  exists such that (r)  r ; intuitively, r is then more general than r .
If a rewriting contains such rules r and r , then r can be safely removed from the rewriting.
Furthermore, if a rule r contains distinct unifiable body atoms Bi and Bj , a condensation
of r is the rule (r) where  is the most general unifier of Bi and Bj . If a rewriting contains
such rule r and (r) subsumes r, the rule can safely be replaced with (r). The following
example illustrates how these techniques can be used to obtain small test suites.
Example 3.28. Let Q and T be as specified in Example 3.14, and let R be the rewriting
of Q w.r.t. T from Example 3.26. Then R = R , RQ  where RQ consists of the following
rules is also a UCQ rewriting of Q w.r.t. T .
takesCo(x, y)  takesCo(x, z)  MathCo(y)  Q(x)

(12)

takesCo(x, y)  CalcCo(y)  Q(x)

(14)

MathSt(x)  Q(x)

(16)

takesCo(x, x)  CalcCo(x)  MathCo(x)  Q(x)

(13)

St(x)  MathSt(x)  Q(x)

(15)

By Theorem 3.27, the full instantiation of R is also a T -test suite exhaustive for CwQ,T and
Q. The rewriting R , however, contains redundancy and hence the resulting test suite is
unnecessarily large. In particular, by applying condensation to query (12), subsumption to
queries (13) and (14), and subsumption again to queries (15) and (16), we can obtain the
simpler rewriting R.

Finally, note that the test suites obtained via full instantiation can contain isomorphic
ABoxes. Clearly, all isomorphic copies of an ABox can safely be eliminated from a test
suite without losing exhaustiveness for CwQ,T and Q.
3.6 Testing (Q, T )-Monotonic and Strongly (Q, T )-Faithful Abstract Reasoners

Due to full instantiation, test suites obtained by Definition 3.25 can be exponentially larger
than the rewriting they are generated from. As a result, even rewritings of moderate size can
yield test suites containing thousands of ABoxes. Intuitively, full instantiation is required
to obtain a test suite exhaustive for the class CwQ,T because this class contains abstract
reasoners such as rl= from Example 3.11, which do not correctly handle the case when
distinct variables in a query are matched to the same individual.
In this section, we show that test suites exhaustive for the class CsQ,T can be obtained by
an injective instantiation of a rewritingthat is, by replacing each variable with a distinct
fresh individual. Test suites obtained in such a way are linear in the size of the rewriting,
and are thus substantially smaller than test suites obtained by full instantiation.
446

fiCompleteness Guarantees for Incomplete Ontology Reasoners

Example 3.29. Let Q and T be as specified in Example 3.14, and let S = S , SQ  be the
Q-simple T -test suite from Example 3.16. Furthermore, consider the abstract reasoner rl=
from Example 3.11 that is weakly, but not strongly (Q, T )-faithful. It is easy to check that
rl= returns complete answers on A1 and A3 , but not on A2 and A4 . Therefore, by Theorem
3.27, for S to be exhaustive for CwQ,T and Q, we must include in SQ ABoxes A2 and A4 ,
which are respectively obtained from ABoxes A1 and A3 by merging individual d into c.
Strongly (Q, T )-faithful abstract reasoners, however, correctly handle inputs obtained
by merging individuals. Based on this observation, in this section we show that the Q-simple
T -test suite S = S , SQ  where SQ = {A1 , A3 , A5 }, obtained by injectively instantiating
the rewriting R from Example 3.26, is exhaustive for CsQ,T and Q.



As in Section 3.5, we first develop a characterisation of Q-simple T -test suites that are
exhaustive for CsQ,T and Q; this result is analogous to Theorem 3.23.

Theorem 3.30. Let Q be a UCQ, let T be an admissible TBox, and let S = S , SQ  be
a Q-simple T -test suite. Then, S is exhaustive for CsQ,T and Q if and only if the following
properties are satisfied for each ABox A.
1. If T  A is unsatisfiable, then there exist an ABox A  S and a T -stable renaming
 such that dom() = ind(T  A ) and (A )  A.
2. If T  A is satisfiable, then for each tuple a  cert(Q, T , A) there exist an ABox
A  SQ , a tuple b  cert(Q, T , A ), and a (Q, T )-stable renaming  such that (b) = a,
dom() = ind(Q  T  A ), and (A )  A.
Proof. () Let S be an arbitrary Q-simple T -test suite that satisfies Properties 1 and 2;
we next show that S is exhaustive for CsQ,T and Q. Consider an arbitrary abstract reasoner
ans  CsQ,T that passes Sthat is, ans satisfies the following two properties:
(a) ans(, T , A ) = t for each A  S , and
(b) ans(, T , A ) = f implies cert(Q, T , A )  ans(Q, T , A ) for each A  SQ .
We next show that ans is (Q, T )-completethat is, that ans satisfies the two conditions in
Definition 3.13 for an arbitrary ABox A. For an arbitrary such A, we have the following
two possibilities, depending on the satisfiability of T  A.
Assume that T  A is unsatisfiable. Since S satisfies Property 1, there exist an ABox
A  S and a T -stable renaming  such that dom() = ind(T  A ) and (A )  A. By
Condition (a) we have ans(, T , A ) = t. Since ans is strongly (Q, T )-faithful and  is T stable, we have ans(, T , (A )) = t; finally, since ans is (Q, T )-monotonic and (A )  A,
we have ans(, T , A) = t, as required by Definition 3.13.
Assume that T  A is satisfiable and ans(, T , A) = f. Furthermore, consider an arbitrary tuple a  cert(Q, T , A). Since S satisfies Property 2, there exist an ABox A  SQ , a
tuple b  cert(Q, T , A ), and a (Q, T )-stable renaming  such that (b) = a, (A )  A, and
dom() = ind(Q  T  A ). Since (A )  A, ans(, T , A) = f, and ans is (Q, T )-monotonic,
we have ans(, T , (A )) = f; furthermore,  is (Q, T )-stable and ans is strongly faithful, so ans(, T , (A )) = f implies ans(, T , A ) = f. But then, by Condition (b) we have
cert(Q, T , A )  ans(Q, T , A ), so b  ans(Q, T , A ). Now ans is strongly (Q, T )-faithful and
447

fiCuenca Grau, Motik, Stoilos & Horrocks

 is (Q, T )-stable, so (b)  ans(Q, T , (A )); since (b) = a, we have a  ans(Q, T , (A ));
finally, since ans is (Q, T )-monotonic and (A )  A, we have a  ans(Q, T , A), as required
by Definition 3.13.
() Assume that S is exhaustive for CsQ,T and Q; we next show that Properties 1 and 2
are satisfied for an arbitrary ABox A. To this end, we consider a particular abstract reasoner
ans for which we prove that ans  CsQ,T and that ans passes S; this abstract reasoner will
help us identify the ABox, the tuple, and the renaming required to prove Properties 1 and 2.
Let ans be the abstract reasoner that takes as input a UCQ Qin , an FOL-TBox Tin ,
and an ABox Ain . The result of ans(, Tin , Ain ) is determined as follows.
1. If T =
 Tin , then return f.
2. For each ABox A  S , do the following.
(a) Check the satisfiability of T  A using a sound, complete, and terminating
reasoner.
(b) If T  A is unsatisfiable, and if a T -stable renaming  exists such that
dom() = ind(T  A ) and (A )  Ain , then return t.
3. Return f.
Furthermore, the result of ans(Qin , Tin , Ain ) is determined as follows.
4. If T =
 Tin or Q =
 Qin , then return .
5. Out := .
6. For each tuple a of constants occurring in Ain of arity equal to the arity of the query
predicate of Q, and for each A  SQ do the following.
(a) Compute C := cert(Q, T , A ) using a sound, complete and terminating reasoner.
(b) If a tuple b  C and a (Q, T )-stable renaming  exist such that (b) = a,
dom() = ind(Q  T  A ), and (A )  Ain , then add a to Out.

7. Return Out.
We next show that ans belongs to CsQ,T . The proofs that ans terminates and that it
is (Q, T )-monotonic are analogous to the proofs in Theorem 3.23. To show strong (Q, T )faithfulness, consider an arbitrary Qin , Tin , and Ain , and an arbitrary renaming .
 Assume that ans(, Tin , Ain ) = t and  is T -stable. Thus, on Tin and Ain the abstract
reasoner terminates in step 2(b) for some A  S and . Let  be the renaming such
that  (c) = ((c)) for each c  ind(T  A ). Clearly, we have dom( ) = ind(T  A ),
renaming  is T -stable, and  (A )  (Ain ). Thus, on Tin and (Ain ) the abstract
reasoner terminates in step 2(b), so we have ans(, Tin , (Ain )) = t, as required.
 Assume that ans(, Tin , Ain ) = f and  is (Q, T )-stable, and consider an arbitrary
tuple a  ans(Qin , Tin , Ain ). Then a is added to Out in step 7(b) for some A  SQ ,
448

fiCompleteness Guarantees for Incomplete Ontology Reasoners

, and b. Let  be the renaming defined such that  (c) = ((c)) for each individual c  ind(Q  T  A ). Clearly, we have dom( ) = ind(Q  T  A ), mapping  is
(Q, T )-stable,  (A )  (Ain ), and  (b) = (a). Thus, on Qin , Tin , and (Ain ) the
abstract reasoner terminates in step 7(b), so (a)  ans(Qin , Tin , (Ain )), as required.
This concludes the proof that ans  CsQ,T . Furthermore, ans clearly passes S; but then,
since S is exhaustive for CsQ,T and Q, abstract reasoner ans is (Q, T )-complete. The main
claim of this theorem can now be shown as in Theorem 3.23.
We next use Theorem 3.30 to show that a Q-simple T -test suite that is exhaustive for
and Q can be obtained as an injective instantiation of a UCQ rewriting of Q w.r.t. T .

CsQ,T

Definition 3.31. Let Q be a UCQ, let T be a TBox, let R = R , RQ  be a UCQ rewriting
of Q w.r.t. T , and let  be a substitution mapping each variable occurring in R into a distinct
R,
fresh individual. The injective instantiation of R w.r.t.  is the pair IR, = IR,
 , IQ 
where IR,
and IR,
are the smallest sets of ABoxes such that
Q

 Ar  IR,
for each r  R , and

 Ar  IR,
for each r  RQ such that cert(, R , Ar ) = f.
Q
IR, is clearly unique up to the renaming of the fresh individuals in , so  is typically left
R
implicit, and one talks of the injective instantiation IR = IR
 , IQ  of R.
Theorem 3.32. Let Q be a UCQ, let T be an admissible TBox, let R = R , RQ  be a
R
UCQ rewriting of Q w.r.t. T , and let IR = IR
 , IQ  be the injective instantiation of R.
Then, IR is a Q-simple T -test suite that is exhaustive for CsQ,T and Q.

Proof. Let  be the substitution that IR is obtained from. We first show that IR is a
Q-simple T -test suitethat is, that it satisfies the two properties in Definition 3.15.
r
 Consider an arbitrary A  IR
 . Then, a rule r  R exist such that A = A ; clearly
cert(, {r}, A) = t; since R is a UCQ rewriting, T  A is unsatisfiable, as required.

 Consider an arbitrary A  IR
Q . Then, cert(, R , A) = f by Definition 3.31; since R is
a UCQ rewriting, T  A is satisfiable, as required.
We next show that IR satisfies Properties 1 and 2 of Theorem 3.30 for an arbitrary
ABox A.
(Property 1) Assume that T  A is unsatisfiable. Since R is a UCQ rewriting, by
Definition 2.2 we have cert(, R , A) = t; but then, a rule r  R and a substitution 
exist such that Ar  A and cert(, {r}, Ar ) = t. Let  be a renaming such that for each
individual c occurring in R or T we have (c) = c, and for each variable x in r we have
((x)) = (x). Clearly, (Ar ) = Ar , so (Ar )  A. Furthermore, it is clear that  is
T -stable. Thus, Property (1) holds for Ar  IR
 and .
(Property 2) Assume that T  A is satisfiable, and consider an arbitrarily chosen tuple
a  cert(Q, T , A). Since R is a UCQ rewriting, by Definition 2.2 we have cert(, R , A) = f
and a  cert(RQ , R , A); but then, clearly a  cert(RQ , , A) as well. Then, a rule r  RQ
449

fiCuenca Grau, Motik, Stoilos & Horrocks

and a substitution  exist such that Ar  A and a  cert({r}, , Ar ). Let  be the renaming
such that for each individual c occurring in R, Q, or T we have (c) = c, and for each
variable x in r we have ((x)) = (x). Clearly, (Ar ) = Ar , so (Ar )  A. Furthermore,
it is clear that  is (Q, T )-stable. Finally, clearly a tuple b  cert({r}, , Ar ) exists such
that (head(r)) = Q(b); since R is a UCQ rewriting and T  Ar is satisfiable, we have
b  cert(Q, T , Ar ); furthermore, (b) = a clearly holds. But then, Property (2) is satisfied

for Ar  IR
,
,
and b.
Q
3.7 Dealing with Recursive Axioms
The negative result in Theorem 3.21 (which applies to both CwQ,T and CsQ,T ) depends on
the presence of a recursive axiom in the TBox; thus, the positive results in Sections 3.5
and 3.6 require the input UCQ to be rewritable w.r.t. the input TBox, which eectively
prohibits recursion in TBox axioms. Instead of disallowing recursive axioms, in this section
we overcome the limitation of Theorem 3.21 by placing additional requirements on the
abstract reasoners by requiring them to be first-order reproducible. Intuitively, the latter
means that the reasoners behaviour can be seen as complete reasoning in some unknown
first-order theory. Such abstract reasoners are not allowed to partially evaluate recursive
axioms, which invalidates the approach used to prove Theorem 3.21.
We show that a T -test suite exhaustive for Q and the class of first-order reproducible
abstract reasoners can be obtained by instantiating a datalog, rewriting of Q w.r.t. T .
Such rewritings exist for a wide range of TBoxes and queries, which in turn allows our
results to be applicable to a range of practically interesting cases. In contrast to test
suites computed from a UCQ rewriting, however, the test suites obtained from a datalog,
rewriting may not be Q-simple. In fact, we show in Section 3.7.2 that, for certain Q
and T , a T -test suite exhaustive for Q and the class of first-order reproducible abstract
reasoners exists, but no such test suite is Q-simple. This has an important practicallyrelevant consequence: if a T -test suite S is not Q-simple, a first-order reproducible abstract
reasoner that passes S is guaranteed to be (Q, T )-complete; however, if an abstract reasoner
does not pass S, in general we cannot conclude that the reasoner is not (Q, T )-complete.
3.7.1 First-Order Reproducible Abstract Reasoners
State of the art concrete reasoners such as Oracles reasoner, Jena, OWLim, Minerva, Virtuoso, and DLE-Jena are all implemented as RDF triple stores extended with deductive
database features. Given T and A as input, these reasoners first precompute all assertions
that follow from T  A in a preprocessing step. In practice, this step is commonly implemented by (a technique that can be seen as) evaluating a datalog program over A. After
preprocessing, these reasoners can then answer an arbitrary UCQ Q by simply evaluating
Q in the precomputed set of assertions.
Motivated by this observation, we next introduce the new class of first-order reproducible
abstract reasonersthat is, abstract reasoners whose behaviour can be conceived as complete reasoning in some unknown first-order theory. Note that this theory is not required to
be a datalog program; for example, it can contain existential quantifiers, which can be used
to capture the behaviour of concrete reasoners such as Jena and OWLim (Bishop, Kiryakov,
450

fiCompleteness Guarantees for Incomplete Ontology Reasoners

Ognyano, Peikov, Tashev, & Velkov, 2011) that handle existential quantifiers in the input
by introducing fresh individuals.
Definition 3.33. An abstract reasoner ans for a description logic DL is first-order reproducible if, for each DL-TBox T , a set of first-order sentences FT exists such that, for each
ABox A,
 ans(, T , A) = cert(, FT , A), and

 if ans(, T , A) = f, then for each UCQ Q, we have ans(Q, T , A) = cert(Q, FT , A).

If FT contains predicates and/or individuals not occurring in T , these are assumed to be
internal to ans and not accessible in queries, TBoxes, ABoxes, test suites, and so on.
Given a TBox T , CfT is the class of all first-order reproducible abstract reasoners applicable
to T .
Example 3.34. Abstract reasoners rdf, rdfs, rl and classify from Example 3.3 are all firstorder reproducible. Indeed, theory FT is empty in the case of rdf, and it is precisely Prdfs
and Prl in the cases of rdfs and rl, respectively. Finally, for abstract reasoner classify, theory
FT is the union of Prl and the program containing the axiom x.[A(x)  B(x)] for each
atomic subsumption A  B entailed by the input TBox.


Please note that a first-order reproducible abstract reasoner ans does not need to actually construct FT : it only matters that some (possibly unknown) theory FT exists that
characterises the reasoners behaviour as specified in Definition 3.33.
Since QFT A |= QFT A whenever A  A , each first-order reproducible abstract
reasoner is (Q, T )-monotonic for arbitrary Q and T . Furthermore, it is straightforward
to see that each first-order reproducible abstract reasoner is also strongly (Q, T )-faithful.
Consequently, we have CfT  CsQ,T for each UCQ Q and each TBox T .
We next show that the negative result in Theorem 3.21 does not directly apply to
the class CfT . In particular, we show that the abstract reasoner pEvaln used to prove
Theorem 3.21 is not first-order reproducible. Intuitively, pEvaln can be understood as
partial evaluation of a datalog programthat is, the rules in the program are applied to
the facts only a fixed number of times rather then until a fixpoint is reached.
Proposition 3.35. For each positive integer n, the abstract reasoner pEvaln defined in the
proof of Theorem 3.21 is not first-order reproducible.
Proof. Let T = {R.A  A}, let Q = {A(x)  Q(x)}, and consider an arbitrary nonnegative integer n. Furthermore, assume that pEvaln  CfT ; then, a finite set of first-order
sentences FT exists such that pEvaln (Q, T , A) = cert(Q, FT , A) for each ABox A.
Let k be a positive integer; furthermore, let rk be the datalog rule and let Ak be the
ABox defined as follows, for a0 , . . . , ak arbitrary distinct but fixed individuals not occurring
in Q  FT :
rk = R(x0 , x1 )  . . .  R(xk1 , xk )  A(xk )  A(x0 )
Ak = {R(a0 , a1 ), . . . , R(ak1 , ak ), A(ak )}
The following condition holds by Proposition 2.1:
FT |= rk

if and only if FT  Ak |= A(a0 )
451

(17)

fiCuenca Grau, Motik, Stoilos & Horrocks

By the definition of pEvaln , we have
a0  pEvaln (Q, T , Ak ) for each 1  k  n, and
a0  pEvaln (Q, T , Ak ) for each k > n.
Since pEvaln (Q, T , A) = cert(Q, FT , A), we have
a0  cert(Q, FT , Ak ) for each 1  k  n, and
a0  cert(Q, FT , Ak ) for each k > n.
Since Q contains only the atom A(x) in the body, we have
FT  Ak |= A(a0 ) for each 1  k  n, and
FT  Ak |= A(a0 ) for each k > n.
By condition (17), we then have
FT |= rk for each 1  k  n
FT |= rk for each k > n.
This, however, contradicts the obvious observation that r1 |= rk for each k  1.
Note that the proof of Proposition 3.35 relies on the fact that the theory FT only depends
on the input TBox, and not on the input query. As shown next, had we defined first-order
reproducible abstract reasoners by allowing FT to depend also on the input query, then the
negative result from Theorem 3.21 would have applied.
Definition 3.36. An abstract reasoner ans for DL first-order q-reproducible if, for each
UCQ Q and each DL-TBox T , a finite set of first-order sentences FQ,T exists such that,
for each ABox A,
 ans(, T , A) = cert(, FQ,T , A), and
 if ans(, T , A) = f, then ans(Q, T , A) = cert(Q, FQ,T , A).
Theorem 3.37. For Q = {A(x)  Q(x)} and T = {R.A  A}, no T -test suite exists
that is exhaustive for Q and the class of all sound, monotonic, strongly faithful, and qreproducible abstract reasoners applicable to T .
Proof. To prove this claim, it suces to show that, for each nonnegative integer n, the
abstract reasoner pEvaln defined in the proof of Theorem 3.21 is first-order q-reproducible.
Consider an arbitrary nonnegative integer n, an arbitrary DL-TBox T  , and an arbitrary
UCQ Q . We define FQ ,T  such that, if T  T  or Q = Q, then FQ ,T  = ; otherwise,
FQ ,T  consists of the following n rules:
A(x0 )  Q(x0 )

R(x0 , x1 )  A(x1 )  Q(x0 )
...

R(x0 , x1 )  R(x1 , x2 )  . . .  R(xn1 , xn )  A(xn )  Q(x0 )
452

fiCompleteness Guarantees for Incomplete Ontology Reasoners

Clearly, pEvaln (, T  , A ) = cert(, FQ ,T  , A ) = f for each UCQ Q , DL-TBox T  and
ABox A , as required. Furthermore, for each Q and T  such that either T  T  or Q = Q
and each ABox A , we have pEvaln (Q , T  , A ) = cert(Q , FQ ,T  , A ) = . Finally, for
Q = Q, each T  such that T  T  , and each ABox A , we clearly have pEvaln (Q , T  , A ) =
cert(Q , FQ ,T  , A ), as required.
3.7.2 Simple vs. Non-Simple Test Suites
Proposition 3.18 from Section 3.3 shows that each Q-simple T -test suite that is exhaustive
for Q and a class of abstract reasoners provides a sucient and necessary test for (Q, T )completeness. We next show that an analogous result does not hold if T contains recursive
axioms, even if we consider only first-order reproducible abstract reasoners. As in Theorem 3.21, we prove the claim for a fixed Q and T since the concept of relevant recursive
axioms might be dicult to formalise; however, our proof can easily be adapted to other
UCQs and TBoxes. Our result essentially states that no T -test suite exists that provides
a necessary and sucient condition for (Q, T )-completeness of each abstract reasoner in
CfT ; consequently, by Proposition 3.18 each T -test suite exhaustive for CfT and Q is not
Q-simple. Furthermore, in Section 3.7.3 we show how to compute a T -test suite exhaustive
for CfT and Q, so the following claim does not hold vacuously.
Theorem 3.38. Let Q = {A(x)  B(x)  Q(x)}, let T = {R.A  A}, and let C be the
class of all sound, monotonic, strongly faithful, and first-order reproducible abstract reasoners applicable to T . Then, no T -test suite S exists that satisfies the following two properties:
1. S is exhaustive for C and Q; and
2. for each abstract reasoner ans  C, if ans is (Q, T )-complete then ans passes S.
Proof. Assume that a T -test suite S = S , SQ  exists that satisfies properties 1 and 2 of
the theorem. Let n be the maximal number of assertions occurring in an ABox in S. We
next define two abstract reasoners ans1 and ans2 ; it is straightforward to check that both
are sound, monotonic, strongly faithful, and first-order reproducible.
Given an arbitrary FOL-TBox Tin , abstract reasoner ans1 uses the datalog program
FT1in defined as follows:
 If T  Tin , then FT1in = .
 If T  Tin , then FT1in contains the following n rules:
r0 =
r1 =
r2 =

B(x0 )  A(x0 )  A(x0 )
B(x0 )  R(x0 , x1 )  A(x1 )  A(x0 )
B(x0 )  R(x0 , x1 )  R(x1 , x2 )  A(x3 )  A(x0 )
...
rn = B(x0 )  R(x0 , x1 )  . . .  R(xn1 , xn )  A(xn )  A(x0 )
Given an arbitrary FOL-TBox Tin , abstract reasoner ans2 uses the datalog program
defined as follows, where predicate Z is private to FT2in (and hence it does not aect
the soundness of the abstract reasoner):
FT2in

453

fiCuenca Grau, Motik, Stoilos & Horrocks

 If T  Tin , then FT2in = .
 If T  Tin , then FT2in contains FT1in as well as the following rules:
rZ1 = R(x0 , x1 )  . . .  R(xn , xn+1 )  A(xn+1 )  Z(x0 )
rZ2 =
R(x0 , x1 )  Z(x1 )  Z(x0 )
rZ3 =
Z(x)  B(x)  A(x)
Now let A be an arbitrary ABox containing at most n assertions. We next show
that, for each assertion  not containing predicate Z, we have FT1in  A |=  if and only
if FT2in  A |= . The () direction is trivial since FT1in  FT2in , so we consider the ()
direction. Furthermore, since rZ3 is the only rule in FT2in \ FT1in that does not contain
Z in the head, the claim is nontrivial only if  is of the form A(a0 ) for some individual a0 occurring in A. Since the antecedent of rZ3 is satisfied for a0 , we have B(a0 )  A
and FT2in  A |= Z(a0 ). But then, for the latter to be implied by rZ1 and rZ2 , individuals
a0 , a1 , . . . , ak with 0  k exist such that R(ai , ai+1 )  A for each 1  i < k, and A(ak )  A.
Since A contains at most n assertions, w.l.o.g. we can assume that k  n. But then, since
FT1in contains rule rk , we have FT1in  A |= A(a0 ) as well, which proves our claim. As a consequence of this claim and the fact that all ABoxes in S contain at most n assertions, we have
cert(, FT1in , A) = cert(, FT2in , A) for each A  S , and cert(Y, FT1in , A) = cert(Y, FT2in , A)
for each A, Y  SQ .
Let A = {B(a0 ), R(a0 , a1 ), . . . , R(an , an+1 ), A(an+1 )}. Then cert(Q, T , A) = {a0 } and
cert(Q, FT1in , A) = , so ans1 is not (Q, T )-complete. Since S is exhaustive for C and Q,
abstract reasoner ans1 does not pass S; by the claim from the previous paragraph, abstract
reasoner ans2 does not pass S either. We next show that ans2 is (Q, T )-complete, which
contradicts the assumption that S satisfies property 2 and thus proves the claim of this
theorem.
Consider an arbitrary ABox A containing m assertions. Clearly, a0  cert(Q, T , A) if and
only if individuals a0 , a1 , . . . , ak with 0  k  m exist such that B(a0 )  A, R(ai , ai+1 )  A
for each 1  i < k, and A(ak )  A. Now assume that k  n; since rk  FT2in , we have
FT2in  A |= A(a0 ) and thus a0  cert(Q, FT2in , A). In contrast, assume that k > n; since
rZ1  FT2in , we have FT2in  A |= Z(akn1 ); since rZ2  FT2in , we have FT2in  A |= Z(ai )
for each 0  i  k  n  1; finally, since rZ3  FT2in , we have FT2in  A |= A(a0 ); but then,
a0  cert(Q, FT2in , A), as required.
As a corollary to Theorem 3.38, we next show that testing abstract reasoners in CfT
cannot be done in general using Q-simple test suites.
Corollary 3.39. For Q = {A(x)  B(x)  Q(x)} and T = {R.A  A}, no Q-simple T test suite exists that is exhaustive for Q and the class of all sound, monotonic, strongly
faithful, and first-order reproducible abstract reasoners applicable to T .
Proof. If S is a Q-simple T -test suite that is exhaustive for Q and the class mentioned in
the Theorem, by Proposition 3.18 each abstract reasoner ans from the class that does not
pass S is not (Q, T )-complete, which contradicts Theorem 3.38.
454

fiCompleteness Guarantees for Incomplete Ontology Reasoners

Theorem 3.38 eectively says that, if an abstract reasoner ans  CfT does not pass a T test suite S, we cannot conclude that ans is not (Q, T )-complete. Please note that this holds
only if ans fails a test of the form A, Y where Q =
 Y: if Q = Y, then A is a counterexample
to (Q, T )-completeness of ans. Thus, S may show ans to be not (Q, T )-complete, but it is
not guaranteed to do so. This is illustrated by the following example.
Example 3.40. Let Q = {A(x)  B(x)  Q(x)} and let T = {R.A  A, R.C  C}. Furthermore, let S = , SQ  be the general test suite defined as follows:
SQ = {

 { A(c) },
{ A(x)  B(x)  Q(x) } ,
 { R(c, d), A(d) }, { A(c)  Q } ,
 { R(c, d), C(d) }, { C(c)  Q } 
}

Let R = RD , , Q where RD = {R(x, y)  A(y)  A(x), R(x, y)  C(y)  C(x)}; clearly,
R is a rewriting Q w.r.t. T . In Section 3.7.3 we show how to compute S from R using a
variant of injective instantiation in a way that guarantees exhaustiveness for CfT and Q.
Now let ans1  CfT be the abstract reasoner defined by FT1 = {R(x, y)  A(y)  A(x)}.
The reasoner does not pass S since cert({C(c)  Q }, FT1 , {R(c, d), C(d)}) = f. Note, however, that the reasoner is (Q, T )-complete. Thus, if a test suite is not Q-simple, passing
it is a sucient, but not a necessary condition for (Q, T )-completeness. In fact, note that
T contains the TBox for Theorem 3.38, so by the theorem we cannot reduce S so that it
correctly identifies all reasoners in CfT that are not (Q, T )-complete.
In practice, however, one can try to mitigate this fundamental theoretical limitation by
eliminating the irrelevant axioms from the rewriting R and thus increasing the likelihood of
obtaining a T -test suite that a (Q, T )-complete abstract reasoner will pass. For example,
using the techniques by Cuenca Grau, Horrocks, Kazakov, and Sattler (2008a) we can
extract the module of R relevant to the query. In the example from the previous paragraph,
this would remove the rule R(x, y)  C(y)  C(x) from R, and injective instantiation will
produce the test suite S = , SQ  where SQ is defined as follows:
SQ = {

 { A(c) },
{ A(x)  B(x)  Q(x) } ,
 { R(c, d), A(d) }, { A(c)  Q } 
}

Abstract reasoner ans1 from the previous paragraph now passes S and is thus guaranteed
to be (Q, T )-complete.
Now let ans2 be the abstract reasoner defined by FT2 = {B(x)  R(x, y)  A(y)  A(x)}.
Clearly, abstract reasoner ans2 is not (Q, T )-complete, so ans2 does not pass SQ . From the
latter, however, we cannot immediately conclude that S is not (Q, T )-complete: the test
that fails does not involve the original query Q. As a possible remedy, we can try to unfold
R to a certain level and then injectively instantiate the result in hope of obtaining a T -test
suite that will identify ans2 as not being (Q, T )-complete. In particular, the first unfolding
of R produces the following query:
B(x)  R(x, y)  A(y)  Q(x)

Instantiating this rewriting produces the following test suite, which does not prove that
ans2 is not (Q, T )-complete.
SQ = {

 { B(c), R(c, d), A(d) }, { A(x)  B(x)  Q(x) }  }
455

fiCuenca Grau, Motik, Stoilos & Horrocks

Another round of unfolding, however, produces the following query:
B(x)  R(x, y)  R(y, z)  A(z)  Q(x)
Instantiating this query produces the following test suite:
S
Q ={

 { B(c), R(c, d), R(d, e), A(e) }, { A(x)  B(x)  Q(x) }  }

Now ans2 does not pass S
Q , so we can conclude that ans2 is not (Q, T )-complete.



To better understand Example 3.40, consider a first-order reproducible abstract reasoner
ans, an arbitrary UCQ Q, and a TBox T such that R = RD , , RQ  is a datalog rewriting
of Q w.r.t. T . Datalog program RD  RQ is equivalent to the (possibly infinite) UCQ RuQ
obtained from RD  RQ via exhaustive unfolding. We now have the following possibilities.
First, assume that ans is not (Q, T )-complete. Since RD  RQ is equivalent to RuQ , each
certain answer a to Q w.r.t. T and an arbitrary ABox A is produced by some r  RuQ .
But then, the injective instantiation Ar of r will provide us with the counterexample for
the (Q, T )-completeness of ans. Thus, we can prove that ans is not (Q, T )-complete by
generating the elements of RuQ in a fair manner (i.e., without indefinitely delaying the
generation of some element of RuQ ) and checking whether cert(Q, T , Ar )  ans(Q, T , Ar );
we are guaranteed to eventually encounter some r  RuQ that invalidates this condition and
thus proves that ans is not (Q, T )-complete.
Second, assume that ans is (Q, T )-complete. Using the above approach, we will determine that cert(Q, T , Ar )  ans(Q, T , Ar ) holds for each r  RuQ . Now if RuQ is finite (i.e., if
the unfolding of RD  RQ terminates), then RuQ is the UCQ rewriting of Q w.r.t. T , so by
the results from Section 3.6 we can conclude that ans is indeed (Q, T )-complete. If, however, RuQ is infinite, then we will never obtain a sucient assurance for the (Q, T )-complete
of ans. In the following section we show a possible remedy to this problem.
3.7.3 Testing First-Order Reproducible Abstract Reasoners
In this section, we show how to compute a T -test suite S = S , SQ  exhaustive for CfT
and Q from a datalog, rewriting R = RD , R , RQ  of Q w.r.t. T . Since first-order
reproducible abstract reasoners are strongly faithful, we need to consider only injective
instantiations of R. Thus, the rules in R and RQ should be instantiated as in Section 3.6.
A rule r  RD , however, is instantiated into a pair A, Y  SQ with A the ABox obtained
by instantiating the body of r and Y the Boolean UCQ obtained by instantiating the head
of r. Intuitively, such tests allow us to check whether the (unknown) first-order theory FT
that captures the behaviour of the abstract reasoner entails r.
Definition 3.41. Let Q be a UCQ with query predicate Q, let T be an admissible TBox,
let R = RD , R , RQ  be a datalog, rewriting of Q w.r.t. T , and let  be a substitution
mapping each variable occurring in R into a distinct fresh individual. The injective instanR,
R,
tiation of R w.r.t.  is the pair IR, = IR,
is the smallest set of ABoxes
 , IQ  where I
and IR,
is the smallest set of pairs of an ABox and a UCQ such that
Q
 Ar  IR,
for each r  R ,

456

fiCompleteness Guarantees for Incomplete Ontology Reasoners

 Ar , Q  IR,
for each r  RQ such that cert(, RD  R , Ar ) = f, and
Q
 Ar , Y  IR,
for each r  RD of the form (6) such that cert(, RD  R , Ar ) = f,
Q
where Y is the UCQ Y = {i ((x), yi )  Q | 1  i  m} with the propositional query
predicate Q .
IR, is clearly unique up to the renaming of the fresh individuals in , so  is typically left
R
implicit, and one talks of the injective instantiation IR = IR
 , IQ  of R.
Example 3.42. Consider the query Q = {A(x)  Q(x)} and the EL-TBox T consisting of
the following axioms, whose translation into first-order logic is shown after the  symbol.
R.A  B



BC



AD 



R.C  A



C  R.D



x, y.[R(x, y)  A(y)  B(x)]
x, y.[R(x, y)  C(y)  A(x)]
x.[B(x)  C(x)]

x.[C(x)  y.[R(x, y)  D(y)]]
x.[A(x)  D(x)  ]

Then, R = RD , R , RQ  as defined next is a datalog rewriting of Q w.r.t. T .
RD = { R(x, y)  A(y)  B(x), R(x, y)  C(y)  A(x), B(x)  C(x) }
R = { A(x)  D(x)   }

RQ = { A(x)  Q(x) }

R
The injective instantiation IR = IR
 , IQ  of R is shown below.

IR
 = { { A(c), D(c) } }

IR
{ A(x)  Q(x) } ,
Q = {  { A(c) },
 { R(c, d), A(d) }, { B(c)  Q } ,
 { R(c, d), C(d) }, { A(c)  Q } ,
 { B(c) },
{ C(c)  Q } 
}



We now show that the injective instantiation of a datalog, rewriting of Q w.r.t. T is
a T -test suite exhaustive for CfT and Q.
Theorem 3.43. Let Q be a UCQ, let T be a TBox, let R = RD , R , RQ  be a datalog,
R
R
rewriting of Q w.r.t. T , and let IR = IR
 , IQ  be the injective instantiation of R. Then, I
is a T -test suite that is exhaustive for CfT and Q.
Proof. Let  be the substitution that IR is obtained from. We first show that IR is a T -test
suite.
r
 Consider an arbitrary A  IR
 . Then, a rule r  R exist such that A = A ; clearly
cert(, {r}, A) = t, so cert(, RD  R , A) = t as well; since R is a datalog, rewriting of Q w.r.t. T , we have that T  A is unsatisfiable, as required.

457

fiCuenca Grau, Motik, Stoilos & Horrocks

 Consider an arbitrary A  IR
Q . Then, cert(, RD  R , A) = f by Definition 3.41;
,
since R is a datalog
rewriting of Q w.r.t. T , we have that T  A is satisfiable, as
required.
To show that IR is exhaustive for CfT and Q, consider an arbitrary abstract reasoner
ans  CfT that passes IR that is, ans satisfies the following two properties:
(a) ans(, T , A ) = t for each A  IR
 , and
(b) ans(, T , A ) = f implies cert(Y, T , A )  ans(Y, T , A ) for each Y, A   IR
Q.
Since ans is first-order reproducible, a set of first-order sentences FT exists such that, for
each ABox A, we have
 ans(, T , A) = cert(, FT , A), and
 if ans(, T , A) = f, then ans(Q, T , A) = cert(Q, FT , A).
By the assumption on FT in Definition 3.33 and the fact that  maps variables to fresh
individuals, we have rng()  ind(FT ) = .
Let R1D and R2D be the smallest sets of rules satisfying the following conditions for each
rule r  RD :
 cert(, FT , Ar ) = t implies r  R1D , where r is obtained from r by replacing the head
with , and
 cert(, FT , Ar ) = f implies r  R2D .
Furthermore, let R1Q and R2Q be the sets of rules obtained from RQ in an analogous way.
Since R1D  R2D is obtained from RD by replacing some head formulae with , we clearly
have R1D  R2D |= RD ; analogously, we have R1Q  R2Q |= RQ .

We next show that FT |= R ; the latter holds if and only if FT |= r for each rule r  R .
Consider an arbitrary rule r  R ; note that head(r) = . Then, by Definition 3.41 we have
r
r
Ar  IR
 ; by (a) we have ans(, T , A ) = t; by Definition 3.33 we have cert(, FT , A ) = t
and hence FT  Ar |= ; finally, since rng()  ind(FT ) = , by Proposition 2.1 we have
FT |= r, as required.
We next show that FT |= R1D ; the latter holds if and only if FT |= r for each rule r  R1D .
Consider an arbitrary rule r  R1D ; note that head(r) = . Then, by the definition of R1D
we have cert(, FT , Ar ) = t and hence FT  Ar |= ; finally, since rng()  ind(FT ) = , by
Proposition 2.1 we have FT |= r, as required.
In a completely analogous way as in the previous paragraph, it is possible to show that
FT |= R1Q .
We next show that FT |= R2D ; the latter holds if and only if FT |= r for each rule
r  R2D . Consider an arbitrary rule r  R2D of the form (6); by the definition of R2D we have
cert(, FT , Ar ) = f, so by Definition 3.33 we have ans(, T , Ar ) = f. Then, by Definition
3.41 we have Ar , Y  IR
x), yi )  Q | 1 i  m}. Note
Q where Y is the UCQ Y = {i ((
that T |= r by Definition 2.2, so by Proposition 2.1 we have that T  Ar |= m
x), yi );
i=1 i ((
by the definition of Y and the fact that Q does not occur in T , we have Y  T  Ar |= Q ;
458

fiCompleteness Guarantees for Incomplete Ontology Reasoners

but then, cert(Y, T , Ar ) = t. The latter observation, ans(, T , Ar ) = f, and (b) then imply
ans(Y, T , Ar ) = t, so by Definition 3.33 we have cert(Y, FT , Ar ) = t. Since Q occurs only

in Y (note that each predicate occurring
m in FT but not in T is private to FT , so Q cannot
r
occur in FT ), we have FT  A |= i=1 i ((x), yi ). Finally, since rng()  ind(FT ) = , by
Proposition 2.1 we have FT |= r, as required.
We next show that Q  FT |= R2Q ; the latter holds if and only if Q  FT |= r for each
rule r  R2Q . Consider an arbitrary rule r  R2Q ; note that head(r) is an atom with predicate
Q, and that by the definition of R2Q we have cert(, FT , Ar ) = f, so by Definition 3.33 we
have ans(, T , Ar ) = f. Furthermore, by Definition 3.41, we have cert(, RD  R , Ar ) = f.
Let a be the tuple of the arguments in (head(r)). Then, by Definition 3.41 we have
Ar , Q  IR
a  cert({r}, , Ar ), but then we have a  cert(RQ , RD  R , Ar )
Q ; clearly, 
by the monotonicity of first-order logic. Since R is a rewriting of Q w.r.t. T , by Definition 2.2 we have a  cert(Q, T , Ar ). The latter observation, ans(, T , Ar ) = f, and (b)
then imply a  ans(Q, T , Ar ). By Definition 3.33 we have a  cert(Q, FT , Ar ); hence,
FT  Ar |= Q(a). Finally, since we have rng()  ind(FT ) = , by Proposition 2.1 we have
FT |= r, as required.
The following table summarises the entailment relationships between various first-order
theories obtained thus far:
FT |= R
Q  FT |= R2Q

FT |= R1D
R1Q  R2Q |= RQ

FT |= R2D
R1D  R2D |= RD

FT |= R1Q

Clearly, this implies the following entailments:
FT |= RD  R

Q  FT |= RD  R  RQ

We now complete the proof of this theorem and show that ans is (Q, T )-complete. To
this end, consider an arbitrary ABox A; we have the following possibilities, depending on
the satisfiability of T  A.
 Assume that T  A is unsatisfiable. Then cert(, RD  R , A) = t by Definition
2.2; by the above mentioned entailments, we have cert(, FT , A) = t; consequently,
ans(, T , A) = t by Definition 3.33, as required.
 Assume that T  A is satisfiable and ans(, T , A) = f, and consider an arbitrary tuple
a  cert(Q, T , A). Then, cert(, RD  R , A) = f and a  cert(RQ , RD  R , A) by
Definition 2.2. By the above mentioned entailments, we have a  cert(Q, FT , A);
hence, a  ans(Q, T , A) by Definition 3.33, as required.
Note that the size of the test suite obtained by Theorem 3.43 is linear in the size of the
rewriting, which, we believe, makes our approach suitable for use in practice.
3.7.4 Testing Ground Queries
As shown in Section 3.7.2, if an abstract reasoner ans  CfT does not pass a T -test suite S
that is not Q-simple, we cannot always conclude that ans is not (Q, T )-complete. From a
practical point of view, it would be highly beneficial to identify situations where not passing
S would show that ans is indeed incomplete for Q and T . Furthermore, in applications where
459

fiCuenca Grau, Motik, Stoilos & Horrocks

prototypical queries are not known at design time, we would like to design completeness
tests that are query-independentthat is, which test an abstract reasoner for completeness
w.r.t. T regardless of the input data and query. In this section, we show that we can
achieve these two goals by focusing on ground queries. This restriction is not unreasonable
in practice, since any SPARQL query can be equivalently expressed as a ground UCQ.
We first define a query-independent notion of exhaustiveness of a test suite.
Definition 3.44. Let T be a TBox, let S be a T -test suite, and let C be a class of abstract
reasoners applicable to T . Then, S is exhaustive for C and all ground UCQs if each ans  C
that passes S is (Q, T )-complete for each ground UCQ Q.
Then, we define the notion of a ground rewriting of T a rewriting that captures all
query answers w.r.t. T , regardless of the input ground query and ABoxand we show how
to instantiate such ground rewritings.

Definition 3.45. A ground rewriting of a TBox T is a pair R = RD , R  such that, for
each ground UCQ Q, the triple RD , R , Q is a datalog rewriting of T w.r.t. Q. An

injective instantiation IR of such R is defined as IR = IR for R = RD , R , .
Note that Definition 3.45 implies that each variable occurring in the head of a rule
in R also occurs in the rule body. Tools such as REQUIEM and KAON2 can easily be
adapted to compute a ground rewriting of a TBox T in practice. We next show that
injective instantiation of a ground rewriting of T yields a T -test suite that provides us with
sucient and necessary check for completeness w.r.t. all ground UCQs.

Theorem 3.46. Let T be a TBox, and let R = RD , R  be a ground rewriting of T .
Then, the following two claims hold.
1. IR is exhaustive for CfT and all ground UCQs.
2. Each abstract reasoner ans  CfT that does not pass IR is not (Q, T )-complete for some
ground UCQ Q.

Proof. (Property 1) Consider an arbitrary abstract reasoner ans  CfT that passes IR . Let
FT be the first-order theory that characterises the behaviour of ans; as in the proof of
Theorem 3.43, the fact that ans passes IR implies FT |= RD  R . Furthermore, consider
an arbitrary ground UCQ Q and an arbitrary ABox A. That ans is (Q, T )-complete can
be shown as in the proof of Theorem 3.43, with the minor dierence that a  cert(Q, T , A)
implies a  cert(Q, RD  R , A) by Definition 3.45.
(Property 2) Note that, since R is a ground rewriting of T , by Definition 3.41 all UCQs
in IR are ground. Thus, if some abstract reasoner ans  CfT does not pass IR , this clearly
shows that ans is not (Q, T )-complete for some ground UCQ Q.

4. Comparing Incomplete Abstract Reasoners
In this section, we investigate techniques that, given a query Q and a TBox T , allow us to
determine whether an abstract reasoner ans2 is more complete than an abstract reasoner
ans1 that is, whether for all ABoxes A, abstract reasoner ans2 computes more answers to
Q and T than abstract reasoner ans1 . This idea is formalised by the following definition.
460

fiCompleteness Guarantees for Incomplete Ontology Reasoners

Definition 4.1. Let Q be a UCQ, let T be a TBox, and let ans1 and ans2 be abstract
reasoners applicable to T . Then, ans1 Q,T ans2 if the following conditions hold for each
ABox A:
1. cert(, T , A) = t and ans1 (, T , A) = t imply ans2 (, T , A) = t; and
2. cert(, T , A) = f, ans1 (, T , A) = f, and ans2 (, T , A) = f imply
ans1 (Q, T , A)  cert(Q, T , A)  ans2 (Q, T , A)  cert(Q, T , A).
Furthermore, ans1 <Q,T ans2 if ans1 Q,T ans2 and an ABox A exists such that at least one
of the following two conditions holds:
3. cert(, T , A) = t, ans1 (, T , A) = f, and ans2 (, T , A) = t; or
4. cert(, T , A) = f, ans1 (, T , A) = f, ans2 (, T , A) = f, and
ans1 (Q, T , A)  cert(Q, T , A)  ans2 (Q, T , A)  cert(Q, T , A).
Example 4.2. Consider the abstract reasoners rdf, rdfs, rl, and classify introduced in Example 3.3 and the query Q and TBox T from Example 3.14. We clearly have the following:
rdf Q,T rdfs Q,T rl Q,T classify
Furthermore, for any two of these abstract reasoners, an ABox exists that distinguishes the
abstracts reasoners w.r.t. Q and T ; for example, for ABox A = {takesCo(c, d), MathsCo(d)},
we have rdfs(Q, T , A ) =  and rl(Q, T , A ) = {c}. As a result, we also have the following:
rdf <Q,T rdfs <Q,T rl <Q,T classify



We would like to check whether ans1 Q,T ans2 and ans1 <Q,T ans2 for any given pair
of abstract reasoners by subjecting the reasoners to a finite set of tests. Towards this goal,
R
we next define the relations R
Q,T and <Q,T that compare abstract reasoners w.r.t. a given
finite set R of ABoxes. Ideally, given Q and T , we would like to compute a finite R such
R
that R
Q,T and <Q,T coincide with Q,T and <Q,T on all abstract reasoners from a class C
of interest. These ideas are captured by the following definitions.
Definition 4.3. Let Q be a UCQ, let T be a TBox, let R be a finite set of ABoxes, and let
ans1 and ans2 be abstract reasoners applicable to T .
Then, ans1 R
Q,T ans2 if Conditions 1 and 2 from Definition 4.1 hold for each ABox
R
A  R. Furthermore, ans1 <R
Q,T ans2 if ans1 Q,T ans2 and either Condition 3 or Condition
4 from Definition 4.1 holds for some ABox A  R.
Definition 4.4. Let Q be a UCQ, let T be a TBox, and let C be a class of abstract reasoners
applicable to T . A finite set R of ABoxes is (Q, T )-representative for C if the following
conditions hold for all ans1 , ans2  C:
1. ans1 R
Q,T ans2 if and only if ans1 Q,T ans2 ; and
461

fiCuenca Grau, Motik, Stoilos & Horrocks

2. ans1 <R
Q,T ans2 if and only if ans1 <Q,T ans2 .
As we show next, to prove that R is (Q, T )-representative, it suces to show the only
if implication in Condition 1 and the if implication in Condition 2 from Definition 4.4.
Proposition 4.5. Let Q be a UCQ, let T be a TBox, let C be a class of abstract reasoners
applicable to T , and let R be a finite set of ABoxes such that
1. ans1 R
Q,T ans2 implies ans1 Q,T ans2 , and
2. ans1 <Q,T ans2 implies ans1 <R
Q,T ans2 .
Then, R is (Q, T )-representative for C.
Proof. Note that ans1 Q,T ans2 trivially implies ans1 R
Q,T ans2 ; thus, Condition 1 of this
proposition clearly implies Condition 1 of Definition 4.4. Furthermore, if some ABox A  R
satisfies Condition 3 or 4 of Definition 4.1, Condition 1 or 2 of Definition 4.1 holds as well;
consequently, Conditions 1 and 2 of this proposition imply Condition 2 of Definition 4.4.
An obvious question is whether a Q-simple T -test suite that is exhaustive for a class
C and Q is also (Q, T )-representative for C. The following example shows that this is not
necessarily the case.
Example 4.6. Let Q and T be as specified in Example 3.14, and let R = {A1 , . . . , A6 } for
the ABoxes as specified in Example 3.16. As shown in Section 3, the Q-simple T -test suite
S = S , SQ  with S = {A6 } and SQ = {A1 , . . . , A5 } is exhaustive for CwQ,T and Q.
Let trivial be the abstract reasoner that returns the empty set on each input, and consider also the RDF-based abstract reasoner rdf from Example 3.3, which ignores the TBox
and evaluates the query directly against the ABox. Clearly, trivial Q,T rdf; furthermore,
trivial <Q,T rdf since for A = {St(c), takesCo(c, d), MathCo(d)} we have rdf(Q, T , A) = {c}
whereas trivial(Q, T , A) = . Both abstract reasoners, however, return the empty set of
answers for all ABoxes in R and thus rdf R
Q,T trivial. Hence, by using R we cannot
dierentiate the two abstract reasoners.

4.1 Negative Result
The following strong result shows that, for numerous TBoxes T , no finite set of ABoxes
exists that can dierentiate two arbitrary abstract reasoners from the class of all sound,
first-order reproducible, monotonic, and strongly faithful reasoners. Note that this result is
stronger than the negative result in Theorem 3.21, as it applies to a smaller class of abstract
reasoners and all TBoxes that imply at least one concept subsumption.
Theorem 4.7. Let T be an arbitrary TBox mentioning an atomic role R and atomic
concepts A and B such that T |= A  B, and let Q = {B(x)  Q(x)}. Then, no finite set
of ABoxes exists that is (Q, T )-representative for the class of all sound, monotonic, strongly
faithful, and first-order reproducible abstract reasoners applicable to T .
462

fiCompleteness Guarantees for Incomplete Ontology Reasoners

Proof. Assume that a finite set of ABoxes R exists that is (Q, T )-representative for the class
of all sound, monotonic, strongly faithful, and first-order reproducible abstract reasoners
applicable to T . Let n be the maximum number of assertions in an ABox in R.
For an arbitrary integer k  1, let ansk be the first-order reproducible abstract reasoner
that, given an FOL-TBox Tin , uses the following datalog program FTkin :
FTkin

=




if Tin | = A  B
A(x0 )  R(x0 , x1 )  . . .  R(xk1 , xk )  B(x0 ) if Tin |= A  B

Clearly, each ansk is sound, monotonic, and strongly faithful; furthermore, ansk (, T , A) = f
for each ABox A. We next show that ansn+1 (Q, T , A)  ansn+2 (Q, T , A) for each ABox
A  R. Consider an arbitrary a0  ansn+1 (Q, T , A); then, individuals a0 , a1 , . . . , an+1 exist
such that R(a1 , a )  A for each 1    n + 1. Since A contains at most n assertions
but the rule in FTn+1 contains n + 1 body atoms, we have ai = aj for some i = jthat is,
A contains an R-cycle. But then, the rule in FTn+2 can be matched to A by mapping x0 to
a0 , so a0  ansn+2 (Q, T , A). Therefore, we have ansn+1 R
Q,T ansn+2 .
For A = {A(a0 ), R(a0 , a1 ), . . . , R(an , an+1 )}, however, we have a0  ansn+1 (Q, T , A) and
ansn+2 (Q, T , A) = ; thus, ansn+1 Q,T ansn+2 does not hold, which contradicts our assumption that R is exhaustive for the class of abstract reasoners from this theorem.
4.2 Compact Abstract Reasoners
Theorem 4.7 suggests that we need to make additional assumptions on the abstract reasoners that we wish to compare using a finite set of ABoxes. In this section, we show that
representative sets of ABoxes can be computed in practice if we further restrict ourselves
to abstract reasoners that we call (Q, T )-compact. Intuitively, such an abstract reasoner
processes Q, T , and A by computing all certain answers of Q, A, and some subset T  of
T , where the subset depends only on T and Q. In other words, the behaviour of compact
abstract reasoners can be simulated by the following process: select the subset of axioms
in the input TBox that can be processed, and then compute all certain answers w.r.t. the
selected fragment of the TBox. The class of (Q, T )-compact abstract reasoners thus captures the properties of concrete reasoners such as Jena or Oracles Semantic Data Store that
discard axioms from the input TBox that fall outside a certain fragment (e.g., existential
restrictions on the right-hand of implications) and then encode the remaining axioms into
a suitable set of rules.
Definition 4.8. Let Q be a UCQ, and let T be a TBox. An abstract reasoner ans applicable
to T is (Q, T )-compact if a TBox T   T exists such that the following properties hold for
each ABox A:
1. cert(, T  , A) = t implies ans(, T , A) = t;
2. cert(, T  , A) = f implies ans(, T , A) = f and ans(Q, T , A) = cert(Q, T  , A).
Abstract reasoner ans is compact if it is (Q, T )-compact for each UCQ Q and each TBox
T to which ans is applicable. Finally, CcQ,T is the class of all (Q, T )-compact and strongly
(Q, T )-faithful abstract reasoners applicable to T .
463

fiCuenca Grau, Motik, Stoilos & Horrocks

Example 4.9. All abstract reasoners defined in Example 3.3 are (Q, T )-compact for the
query Q and EL-TBox T from Example 3.14. Indeed, for abstract reasoner rdf the subset
T  of T is given by T  = ; for abstract reasoner rdfs it is T  = {(8)}; for abstract reasoner
rl it is T  = {(8), (9), (10)}; and for abstract reasoner classify it is T  = T .

The abstract reasoners ansk defined in the proof of of Theorem 4.7 are not (Q, T )compact for the query and the TBoxes to which Theorem 4.7 applies.

Proposition 4.10. Let Q = {B(x)  Q(x)} and let T = {A  B, C  R.}. Then, for
each k  1, abstract reasoner ansk from the proof of Theorem 4.7 is not (Q, T )-compact.
Proof. Let Q and T be as stated in the theorem and consider an arbitrary k  1. Let A1
and A2 be ABoxes defined as follows:
A1 = {A(a0 )}

A2 = {A(a0 ), R(a0 , a1 ), . . . , R(ak1 , ak )}

Clearly, we have the following:
ansk (Q, T , A1 ) = 

ansk (Q, T , A2 ) = {a0 }

One can straightforwardly check, however, that the following holds for each T  with T   T :
cert(Q, T  , A1 ) = cert(Q, T  , A2 )
Thus, ansk is not (Q, T )-compact.
Thus, the negative result from Theorem 4.7 does not immediately apply to a class
containing only compact abstract reasoners.
4.3 Comparing Compact Abstract Reasoners
In this section, we show that a set of ABoxes that is (Q, T )-representative for CcQ,T can be
obtained by computing, for each subset T  of T , a Q-simple T  -test suite that is exhaustive

for CsQ,T . A minor complication arises due to the fact that T  can contain fewer individuals

than T . To deal with such cases correctly, the ABoxes in ST are not allowed to contain

individuals occurring in T but not in T  , and the ABoxes in STQ are not allowed to contain
individuals occurring in T but not in Q  T  . This assumption is without loss of generality:

given a (Q, T  )-test suite ST , one can replace all individuals in T but not in Q  T  with

fresh individuals; the result of such replacement is a (Q, T  )-test suite exhaustive for CsQ,T .
Theorem 4.11. Let Q be a UCQ, and let T be a TBox. Furthermore, for each T   T , let




ST = ST , STQ  be a Q-simple T  -test suite that is exhaustive for CsQ,T and Q such that


no ABox in ST contains an individual from ind(T ) \ ind(T  ) and no ABox in STQ contains
an individual from ind(T ) \ ind(Q  T  ). Then, the set R of ABoxes defined by



R=
ST  STQ
T  T

is (Q, T )-representative for CcQ,T .
464

fiCompleteness Guarantees for Incomplete Ontology Reasoners

Proof. Assume that R satisfies the conditions of the theorem, and let ans1 and ans2 be
arbitrary abstract reasoners in CcQ,T . We next show that ans1 and ans2 satisfy the two
properties in Proposition 4.5.
 Property 1 of Proposition 4.5:

ans1 R
Q,T ans2 implies ans1 Q,T ans2

 Property 2 of Proposition 4.5:

ans1 <Q,T ans2 implies ans1 <R
Q,T ans2

Since ans1 is (Q, T )-compact, a TBox T   T exists that satisfies the conditions of
Definition 4.8. Assume that ans1 R
Q,T ans2 ; we next show that Conditions 1 and 2 of
Definition 4.1 are satisfied for an arbitrary ABox A.
(Condition 1) Assume that cert(, T , A) = t and ans1 (, T , A) = t. By the contrapositive of property 2 of Definition 4.8, then cert(, T  , A) = t. Since R contains all the ABoxes

of some Q-simple T  -test suite that is exhaustive for CsQ,T and Q, by Theorem 3.30 there
exist an ABox A  R and a T  -stable renaming  such that dom() = ind(T   A ) and
(A )  A; since A does not contain individuals from ind(T ) \ ind(T  ), renaming  is also
T -stable. By the definition of a T  -test suite, cert(, T  , A ) = t; furthermore, by property 1

of Definition 4.8 we have ans1 (, T , A ) = t. Since ans1 R
Q,T ans2 we have ans2 (, T , A ) = t.

Since ans2 is strongly (Q, T )-faithful and  is T -stable, we have ans2 (, T , (A )) = t. Finally, since (A )  A and ans2 is (Q, T )-monotonic, we have ans2 (, T , A) = t, as required.
(Condition 2) Assume that cert(, T , A) = f, ans1 (, T , A) = f, and ans2 (, T , A) = f,
and consider an arbitrary tuple a  ans(Q, T , A)  cert(Q, T , A). By the contrapositive
of property 1 of Definition 4.8, then cert(, T  , A) = f; but then, by property 2 of Definition 4.8, we have a  cert(Q, T  , A). Since R contains all the ABoxes of some Q
simple T  -test suite that is exhaustive for CsQ,T and Q, by Theorem 3.30 there exist
an ABox A  R, a tuple b  cert(Q, T  , A ), and a (Q, T  )-stable renaming  such that
dom() = ind(Q  T   A ), (A )  A, and (b) = a; since A does not contain individuals from ind(T ) \ ind(Q  T  ), renaming  is also (Q, T )-stable. By the definition of a
(Q, T  )-test suite, cert(, T  , A ) = f; furthermore, by property 2 of Definition 4.8 we have
b  ans1 (Q, T , A ). Since ans1 R ans2 we have b  ans2 (Q, T , A ). Since ans2 is strongly
Q,T
(Q, T )-faithful and  is (Q, T )-stable, we have that a  ans2 (Q, T , (A )). Finally, since
(A )  A and ans2 is (Q, T )-monotonic, we have a  ans2 (Q, T , A), as required.
Assume that ans1 <Q,T ans2 . By Definition 4.1, then ans1 Q,T ans2 and an ABox
A exists satisfying Conditions 3 and 4 of Definition 4.1. Clearly, ans1 R
Q,T ans2 ; hence,
what remains to be shown is that R contains an ABox that satisfies Conditions 3 and 4
of Definition 4.1. Since ans1 is (Q, T )-compact, a TBox T   T exists that satisfies the
conditions of Definition 4.8.
(Condition 3) Assume that cert(, T , A) = t, and assume also that ans1 (, T , A) = t
and ans2 (, T , A) = f. As in the proof of Condition 1, we can identify an ABox A  R and
a T -stable renaming  such that ans1 (, T , A ) = t and (A )  A. Since ans2 is (Q, T )monotonic and ans2 (, T , A) = f, we have ans2 (, T , (A )) = f; furthermore, since ans2
is strongly (Q, T )-faithful and  is T -stable, we also have ans2 (, T , A ) = f. But then,
Condition 3 of Definition 4.1 is satisfied for A  R.
(Condition 4) Assume that cert(, T , A) = f and ans1 (, T , A) = ans2 (, T , A) = f, and
consider an arbitrary tuple a  [ans1 (Q, T , A)  cert(Q, T , A)] \ ans2 (Q, T , A). As in the
proof of Condition 2, we can identify an ABox A  R, a (Q, T )-stable renaming , and a
465

fiCuenca Grau, Motik, Stoilos & Horrocks

tuple b  cert(Q, T  , A ) such that (A )  A, (b) = a, and b  ans1 (Q, T , A ). Since ans2 is
(Q, T )-monotonic and a  ans2 (Q, T , A), we have a  ans2 (Q, T , (A )); furthermore, since
ans2 is strongly (Q, T )-faithful and  is (Q, T )-stable, we also have b  ans2 (Q, T , A ). But
then, Condition 4 of Definition 4.1 is satisfied for A  R.
Theorems 3.32 and 4.11 immediately suggest an approach for computing a set of ABoxes
that is a (Q, T )-representative for CcQ,T . First, we compute a UCQ rewriting of Q w.r.t.
each subset of T ; then, we instantiate each rule in each such rewriting using an injective
instantiation mapping; finally, we compute R as a union of all ABoxes in all test suites.
Such a nave procedure, however, is not practical since it requires computing an exponential
number of UCQ rewritings. We next present a more practical approach to computing a
set of ABoxes that is (Q, T )-representative for CcQ,T . Intuitively, instead of computing
exponentially many rewritings, one can compute a single UCQ rewriting of Q w.r.t. T that
is subset-closed that is, which contains a rewriting for each subset of T .
Definition 4.12. A UCQ rewriting R = R , RQ  of Q w.r.t. T is subset-closed if for
each T   T a tuple R = R , RQ  exists such that R  R , RQ  RQ and R is a
UCQ rewriting of Q w.r.t. T  .
The following corollary is an immediate consequence of Theorems 3.27, 3.32, and 4.11.

Corollary 4.13. Let Q be a UCQ, let T be a TBox, let R be a subset-closed UCQ rewriting
R
of Q w.r.t. T , and let IR = IR
 , IQ  be the injective instantiation of R. Then, the set of
Q,T
R
ABoxes R = IR
.
  IQ is (Q, T )-representative for Cc

Practical query rewriting systems such as REQUIEM are optimised to produce as small
a UCQ rewriting as possible, so their output is typically not subset-closed. Therefore,
our technique requires the modification of UCQ rewriting algorithms implemented in existing systems. As illustrated by the following example, the required modification typically
involves disabling (at least partially) subsumption-based optimisations.
Example 4.14. Let Q and T be as specified in Example 3.14, and let S = S , SQ  be
the T -test suite from Example 3.16. A system such as REQUIEM can compute such R
for the given Q and T . Note, however, that R is not subset-closed; for example, a UCQ
rewriting of Q w.r.t. T  =  is Q, and it is not a subset of RQ . The rewriting can be made
subset-closed by extending RQ with the following rules:
St(x)  takesCo(x, y)  MathCo(x, y)  Q(x)
St(x)  takesCo(x, y)  CalcCo(x, y)  Q(x)
MathSt(x)  St(x)  Q(x)

Systems such as REQUIEM, however, typically discard such rules by applying subsumption
optimisations described in Section 3.5.3.

As the following example shows, a subset-closed UCQ rewriting of Q w.r.t. T can, in
the worst case, be exponentially larger than the minimal UCQ rewritings of Q w.r.t. T .
Example 4.15. Let Q = {C(x)  Q(x)}, and let T be the following TBox:
T = {B  Ai | 1  i  n}  {A1  . . .  An  C}
466

fiCompleteness Guarantees for Incomplete Ontology Reasoners

Furthermore, let R = R , RQ  be such that R =  and RQ contains the following rules:
C(x)  Q(x)

B(x)  Q(x)

A1 (x)  . . .  An (x)  Q(x)
Clearly, R is a UCQ rewriting of Q w.r.t. T ; however, the number of rules in a subset-closed
UCQ rewriting of Q w.r.t. T is exponential in n.


5. Evaluation
We implemented our techniques for computing exhaustive test suites and for comparing incomplete concrete reasoners in a prototype tool called SyGENiA.1 Our tool uses REQUIEM
for computing UCQ and datalog rewritings.2
We considered two evaluation scenarios. The first one uses the well-known Lehigh
University Benchmark (LUBM) (Guo et al., 2005), which consists of a relatively small
TBox about an academic domain, 14 test queries, and a data generator. The second one
uses a small version of GALEN (Rector & Rogers, 2006)a complex ontology commonly
used in medical applications.
We evaluated the following concrete reasoners: Sesame v2.3-prl,3 DLE-Jena v2.0,4
OWLim v2.9.1,5 Minerva v1.5,6 and Jena v2.6.37 in all of its three variants (Micro, Mini,
and Max).
5.1 Computing Exhaustive Test Suites
Given a UCQ Q and a TBox T , our tool uses REQUIEM to compute a datalog rewriting
R for Q and T . If R is a UCQ rewriting, then our tool computes a simple test suite by
either full or injective instantiation (see Sections 3.5 and 3.6, respectively); otherwise, the
tool computes a non-simple test suite by instantiating R as described in Section 3.7.3.
5.1.1 Simple Test Suites
In the case of the LUBM benchmark, each of the 14 test queries leads to a UCQ rewriting w.r.t. the TBox.8 Therefore, we computed a UCQ rewriting for each query Q in the
benchmark using REQUIEM and instantiated it, both fully and injectively, thus obtaining
Q-simple T -test suites that are exhaustive for Q and CwQ,T and CsQ,T , respectively. The
times needed to compute the test suites and the size of each test suite are shown in Table
3, where S denotes the total number of ABoxes in the corresponding test suites.
1.
2.
3.
4.
5.
6.
7.
8.

http://code.google.com/p/sygenia/
http://www.cs.ox.ac.uk/projects/requiem/home.html
http://www.openrdf.org/
http://lpis.csd.auth.gr/systems/DLE-Jena/
http://www.ontotext.com/owlim/
http://www.alphaworks.ibm.com/tech/semanticstk
http://jena.sourceforge.net/
Since REQUIEM does not currently support individuals in the queries, we replaced the individuals in
queries by distinguished variables.

467

fiCuenca Grau, Motik, Stoilos & Horrocks

Q,T
Cw

CsQ,T

Q1
Time 1.2
S
2
Time 1.2
S
1

Q2 Q3 Q4 Q5 Q6 Q7 Q8 Q9 Q10 Q11 Q12 Q13 Q14
0.7 0.2 6.7 0.2 2.1 0.7
7
2.4 7.4 0.07 0.2 0.2 0.05
20 2 2 352 8 1207 345 3 092 5 3 919 7
25 10
1
0.6 0.2 0.6 0.2 1.2 0.4 1.5 2.5 0.6 0.05 0.1 0.1 0.08
4
1
22
4 169 37
36
1 169
2
3
5
1

Table 3: Computation of simple test suites for LUBM. Times are given in seconds.

Q,T
Cw

CsQ,T

Time
S
Time
S

Q1
14
6 049
2.2
79

Q2
34
12 085
6
151

Q3
67
12 085
40
151

Q4
4.6
79
1.7
25

Table 4: Computation of simple test suites for GALEN. Times are given in seconds.
As shown in the table, simple test suites could be computed in times ranging from 0.05
to 7 seconds, both for CwQ,T and CsQ,T . The optimisations implemented in REQUIEM ensure
that the UCQ rewritings are relatively small, so the resulting test suites also consist of a
relatively small number of ABoxes. Notice, however, the significant dierence between the
numbers of ABoxes in test suites obtained via injective instantiation (which range from 1
to 169 with an average of 32), and those obtained via full instantiation (which range from
1 to 3, 919 with an average of 702). Furthermore, each rule in a rewriting contains at most
6 atoms, therefore each ABox in a test suite also contains at most 6 assertions.
In the case of GALEN, we used the following sample queries, for which REQUIEM can
compute a UCQ rewriting:
Q1
Q2
Q3
Q4

:
:
:
:

HaemoglobinConcentrationProcedure(x)  Q(x)
PlateletCountProcedure(x)  Q(x)
LymphocyteCountProcedure(x)  Q(x)
HollowStructure(x)  Q(x)

We instantiated each UCQ rewriting both fully and injectively. The times needed to compute the test suites and the size of each test suite are shown in Table 4.
As shown in the table, simple test suites for GALEN can be computed in times ranging
from 1.7 to 67 seconds with an average of 33 seconds. Thus, computing test suites for
GALEN is more time consuming than for LUBM. This is unsurprising since the TBox of
GALEN is significantly more complex than that of LUBM. The number of ABoxes in the
test suites ranged from 25 to 151 in the case of injective instantiations and from 79 to over
12, 000 in the case of full instantiations; again, note the significant dierence between the
sizes of the two kinds of test suites. In all cases, however, each individual ABox was very
small, with the largest one containing only 11 assertions.
5.1.2 Non-Simple Test Suites
We also computed non-simple test suites for cases where no UCQ rewriting exists. As
already mentioned, all LUBM queries are UCQ-rewritable. Therefore, we manually added
the following query, for which REQUIEM computes a recursive datalog rewriting.
468

fiCompleteness Guarantees for Incomplete Ontology Reasoners

Time (s)
S

CfT

LUBM
Q15
1.4
22

Q5
5.2
41

GALEN
Q6 Q7
1.3 2.7
23
31

Q8
1.6
12

Table 5: General test suites computed from datalog rewritings for LUBM and GALEN.
System
Completeness Guarantee Completeness w.r.t. LUBM data set
JenaMax/DLE-Jena
Q1 Q14
Q1 Q14
OWLim
Q1 Q5 , Q7 , Q9 , Q11 Q14
Q1 Q14
Jena Mini/Micro
Q1 Q5 , Q7 , Q9 , Q11 Q14
Q1 Q14
Minerva
Q1 Q4 , Q9 , Q14
Q1 Q14
Sesame
Q1 , Q3 , Q11 , Q14
Q1 Q5 , Q11 , Q14

Table 6: Completeness guarantees for UCQ-rewritable queries in LUBM
Q15 :

Organization(x)  Q(x)

Due to the complex structure of the GALEN TBox, test queries that are not UCQ rewritable
can be easily identified. We have evaluated the following four.
Q5
Q6
Q7
Q8

:
:
:
:

WestergrenESRProcedure(x)  Q(x)
ArthroscopicProcedure(x)  Q(x)
TrueCavity(x)  Q(x)
BacterialCellWall(x)  Q(x)

Times needed to compute test suites and the size of each test suite are shown in Table 5.
5.2 Completeness Guarantees
As already discussed, existing concrete reasoners are captured by strongly (Q, T )-faithful
abstract reasoners. Hence, in order to establish completeness guarantees for such concrete
reasoners, we restricted our tests to test suites computed using injective instantiations.
5.2.1 Results for Simple Test Suites
Our results for the original queries of the LUBM benchmark are shown in Table 6. For
each concrete reasoner, the first column of the table shows the queries for which we were
able to prove completeness using our techniques (i.e., the queries that are complete for
an arbitrary data set), and the second column of the table shows the queries on which the
concrete reasoner computes all answers on the canonical LUBM data set with one university.
Our results clearly show that completeness w.r.t. the data set in the LUBM benchmark is
no guarantee of completeness for arbitrary data sets; for example, OWLim, Minerva, and
Jena Mini/Micro are complete for all queries w.r.t. the LUBM data set (and some of these
systems are even complete for the more expressive UOBM benchmark); however, for certain
queries, these systems were found to be incomplete for a data set in our test suites.
Jena Max and DLE-Jena are the only systems that are guaranteed to be complete for
all 14 LUBM queries regardless of the data setthat is, these systems behave exactly like a
complete OWL reasoner for all LUBM queries and the LUBM TBox. According to Jenas
469

fiCuenca Grau, Motik, Stoilos & Horrocks

documentation, Jena Max supports all types of axioms used in the LUBM TBox, hence it
is expected to be complete for the LUBM TBox and queries. Interestingly, when tested
with some of the LUBM data sets, Jena Max could not compute the answers to many of
the queries, so we used smaller LUBM data sets instead. This demonstrates an additional
advantage of our approach: it does not require reasoning w.r.t. very large data sets, since the
ABoxes in test suites typically contain only a small number of assertions. Regarding DLEJena, according to its technical description (Meditskos & Bassiliades, 2008), the system
uses a complete DL reasoner to materialise certain subsumptions in a preprocessing step
and then uses Jena to saturate the ABox, much like the abstract reasoner classify from
Example 3.3. Hence, DLE-Jena is at least as complete as Jena Mini and, in addition, it is
able to draw the inferences that Jena Mini is missing (see below).
OWLim is complete for all LUBM queries that do not involve reasoning with existential
quantifiers in the consequent of implications. It is well known that the latter is not supported
by the system. Jena Mini and Micro exhibited exactly the same behaviour as OWLim,
despite the fact that Jena Mini can handle a larger fragment of OWL than OWLim. Clearly,
the LUBM TBox and queries are not suciently complex to reveal the dierences between
OWLim, and Jena Mini/Micro.
Minerva is guaranteed to be complete for only six queries. Like DLE-Jena, it uses a
DL reasoner to materialise entailed subsumptions between atomic concepts, but it uses a
custom method for saturating the ABox. After investigating several ABoxes from the test
suites we concluded that Minerva cannot correctly handle (at-least) inverse role axioms; for
example, it cannot find the entailment { R  R , R(a, b) } |= R(b, a).
Finally, Sesame is complete for only four queries. This is unsurprising since Sesame is
an RDFS reasoner and is thus complete only for a small fragment of OWL 2 DL.
We next discuss the results of tests based on the GALEN ontology and test queries
Q1 Q4 . We could not run Jena Max since GALEN heavily uses existential restrictions,
which (according to Jenas documentation) might cause problems. Minerva was the only
system that provided completeness guarantee for at least one query (Q4 ); this is because
Minerva precomputes subsumption relationships between atomic concepts that depend on
existential restrictions on the right hand side of TBox axioms, which most other systems
do not handle. Also, unlike LUBM, the version of GALEN that we used does not contain
inverse roles, so Minerva performed much better on this ontology. All other systems were
identified as being incomplete for all test queries.
5.2.2 Results for Non-Simple Test Suites
Results for test queries that are not UCQ-rewritable are summarised in Table 7. Symbol
 indicates that the concrete reasoner was found complete for the given query. Furthermore, whenever a concrete reasoner failed a test suite, we tried to prove the reasoner to be
incomplete as discussed in the examples in Section 3.7.2; in all cases we were successful,
so symbol  indicates that the concrete reasoner was identified as being incomplete for a
given query. Finally, symbol  indicates that the concrete reasoner ran out of memory.
In the case of LUBM, we were able to establish completeness guarantees w.r.t. query
Q15 for OWLim, Jena Micro, DLE-Jena, and Jena Max. Note that all these systems
can handle recursive TBox statements, so completeness for Q15 is not surprising. RDFS,
470

fiCompleteness Guarantees for Incomplete Ontology Reasoners

OWLim
Jena Max
Jena Micro
DLE-Jena
Minerva
Sesame

LUBM
Q15







Q5






GALEN
Q6 Q7











Q8






Table 7: Completeness guarantees for datalog-rewritable queries

CsQ,T

Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 Q9 Q10 Q11 Q12 Q13 Q14
Time 1.4 1.1 0.2 1.8 0.8 1.2 9.5 7.8 - 0.9 0.05 0.5 0.6 0.04
R
1 24 17 130 136 219 925 777 - 219 2
74 185 1

Table 8: Representative sets of ABoxes for LUBM. Times are given in seconds.
however, cannot express recursive TBox statements involving roles, so Sesamean RDFS
reasonerfails to compute certain answers to some tests.
In the case of GALEN, completeness is guaranteed on query Q8 for OWLim, Jena Micro,
DLE-Jena, and Minerva, and additionally on query Q6 for Minerva. As already mentioned,
answers to queries on GALEN depend on positive occurrences of existential restrictions in
axioms, which most systems cannot handle. We could not run Jena Max on GALEN.
5.3 Comparing Incomplete Concrete Reasoners
We also implemented the techniques for comparing reasoners from Section 4.3. To this end,
we modified REQUIEM to compute subset-closed rewritings, which are then injectively
instantiated to obtain a (Q, T )-representative sets of ABoxes R.
5.3.1 Tests with LUBM
As shown in Table 8, representative sets of ABoxes could be computed in just a few seconds
for most LUBM queries. The only exception was Q9 , for which REQUIEM did not terminate
after disabling rule subsumption optimisations. The size of the representative sets ranged
between 1 and 777 ABoxes. As expected, representative sets contain more ABoxes than the
exhaustive test suites for the same query and TBox (see Table 3).
All combinations of system and query for which the tests in Section 5.2 identified the
system as incomplete are shown in Table 9. The table shows the proportion of certain
answers that each system returned when applied to the LUBM data set, the ABoxes in R,
and the ABoxes in the test suite S used in Section 5.2 to check the systems completeness.
As shown in the table, OWLim and Jena Micro exhibited the same behaviour and were
almost complete. In contrast, Sesame was the least complete for all queries. Furthermore,
please note the dierence between the values obtained for R and those for S; in particular,
Sesame did not compute any certain answer for Q5 on S, whereas the system is able to
compute certain answers for Q5 on some ABoxes (e.g., on the LUBM data set). This is
because the ABoxes in S cannot distinguish Sesame from a trivial reasoner that always
returns the empty set of answers; however, the set R can make such a distinction.
471

fiCuenca Grau, Motik, Stoilos & Horrocks

LUBM
S
R

Q5
1
0.25
0.8

Q6
1
0.86
0.86

LUBM
S
R

Q2
1
0.75
0.75

Q4
1
0.68
0.06

Minerva
Q8
Q10
Q12
1
1
1
0.98 0.86 0.25
0.81 0.84 0.92
Sesame
Q5
Q6
Q7
Q8
1
0.83 0.87 0.83
0
0.003 0.04 0.04
0.36 0.033 0.01 0.004
Q7
1
0.86
0.86

Q13
1
0.2
0.23

OWLim & JMicro
Q6
Q8
Q10
1
1
1
0.99
0.98
0.99
0.96
0.98
0.97

Q9
0.64
0
-

Q10
0.83
0.001
0.028

Q12
0
0.25
0.017

Q13
0
0.2
0.23

Table 9: Reasoner comparison for LUBM

CsQ,T

Time
R

Q1
15
140

Q2
46
266

Q3
70
266

Q4
2
127

Table 10: Representative sets of ABoxes for GALEN
5.3.2 Tests with GALEN
As shown in Table 10, representative sets of ABoxes for GALEN could be computed in
times ranging from 2 to 70 seconds, and each set contains only a small number of ABoxes.
For each system and query, Table 11 shows the proportion of certain answers returned
by the system on R and the test suite S from Section 5.2. Minerva was the most complete
system. Jena Micro was better than DLE-Jena (apart from query Q4 ), while DLE-Jena
and OWLim behaved in almost the same way (again apart from query Q4 ). As expected,
Sesame was the least complete system.
The discrepancies between OWLim, Jena Micro, DLE-Jena and Minerva are rather
surprising. OWLim and Jena theoretically support the same features of OWL; furthermore,
DLE-Jena is an extension of Jena (Meditskos & Bassiliades, 2008) so DLE-Jena should be
at least as complete as Jena, as in the case of LUBM. In order to explain these discrepancies,
we analysed the test suites for queries Q1 Q4 . More precisely, we selected ABoxes on which
OWLim fails to return all certain answers but on which Jena Micro is complete, and then
we identified the minimal set of TBox axioms that entail all certain answers. Our analysis
revealed that, for query Q4 , OWLim fails to find the entailment
T  {Device(a), HollowTopology(b), hasTopology(a, b)} |= HollowStructure(a),

which follows from the following GALEN axioms:

HollowTopology  Topology  hasState.Hollow
Device  SolidStructure

HollowStructure  SolidStructure  hasTopology.(Topology  hasState.Hollow)

Although existential restrictions appear in several axioms, we can observe that no reasoning
over existential variables is actually required, as the first and third axioms imply (by a simple
structural transformation) the following axiom:
SolidStructure  hasTopology.HollowTopology  HollowStructure
472

fiCompleteness Guarantees for Incomplete Ontology Reasoners

Sesame
OWLim
DLE-Jena
JMicro
Minerva

Q1
S
R
0.01 0.18
0.54 0.65
0.54 0.65
0.69 0.82
0.84 0.91

Q2
S
R
0 0.16
0.52 0.63
0.52 0.63
0.68 0.81
0.84 0.90

Q3
S
R
0 0.16
0.52 0.63
0.52 0.63
0.68 0.81
0.84 0.90

Q4
S
R
0.04 0.10
0.52 0.48
0.76 0.9
0.76 0.67
1
1

Table 11: Reasoner comparison on GALEN
This axiom entails the required answer, and both systems can deal with axioms of this form;
however, unlike Jena Micro, OWLim appears to be incapable of dealing with such cases.
Regarding DLE-Jena, according to its technical description (Meditskos & Bassiliades,
2008), the system has replaced several inference rules of Jena with queries to the DL reasoner, so it does not strictly extend Jena. Our investigation of the exhaustive test suite
for query Q4 revealed that DLE-Jena returns many answers that are based on existential
restrictions on the right hand side of TBox axioms which Jena misses; however, the investigation also revealed that DLE-Jena misses several inferences that Jenas TBox reasoner
can capture, which is probably due to the replacement of Jenas inference rules. This also
explains why DLE-Jena performs worse than Minerva on GALEN.
These results clearly show that the behaviour of systems greatly depends on the given
application scenario. For example, DLE-Jena was complete for all LUBM queries, but
it did not perform equally well on GALEN. In contrast, Minerva did not perform well on
LUBM, but it was the most complete system for GALEN. Our results thus allow application
developers to conduct a thorough comparison of reasoning systems for a given application.

6. Conclusion
In this paper we have proposed a theoretical framework and practical techniques for establishing formally provable and algorithmically verifiable completeness guarantees for incomplete ontology reasoners. Our approach radically departs from ad hoc evaluation based on
well-known benchmarks, and it provides a solid foundation for striking the balance between
scalability and completeness in practical applications.
Our approach also opens up numerous and exciting possibilities for future research. For
example, our work opens the door to the design of ontology-based information systems that
are optimised for a class of ontologies, queries, and data relevant to a particular application. Such information systems could maximise scalability of reasoning while still ensuring
completeness of query answers, even for rich ontologies and sophisticated queries.

Acknowledgments
This is an extended version of the paper How Incomplete is your Semantic Web Reasoner?
by Giorgos Stoilos, Bernardo Cuenca Grau, and Ian Horrocks published at AAAI 2010
and the paper Completeness Guarantees for Incomplete Reasoners by the same authors
published at ISWC 2010.
473

fiCuenca Grau, Motik, Stoilos & Horrocks

This research has been supported by the EU project SEALS (FP7-ICT-238975), and by
the EPSRC projects ExODA (EP/H051511/1) and HermiT (EP/F065841/1). B. Cuenca
Grau is supported by a Royal Society University Research Fellowship.

References
Acciarri, A., Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., Palmieri, M., &
Rosati, R. (2005). Quonto: Querying ontologies. In Proceedings of the 20th National
Conference on Artificial Intelligence (AAAI-05)., pp. 16701671. AAAI Press / The
MIT Press.
Artale, A., Calvanese, D., Kontchakov, R., & Zakharyaschev, M. (2009). The DL-Lite family
and relations. J. Artificial Intelligence Research (JAIR), 36, 169.
Baader, F., McGuinness, D., Nardi, D., & Patel-Schneider, P. (2002). The Description Logic
Handbook: Theory, implementation and applications. Cambridge University Press.
Baader, F., Brandt, S., & Lutz, C. (2005). Pushing the EL envelope. In Proceedings of
the 19th International Joint Conference on AI (IJCAI-05), pp. 364369. MorganKaufmann Publishers.
Bishop, B., Kiryakov, A., Ognyano, D., Peikov, I., Tashev, Z., & Velkov, R. (2011).
OWLIM: A family of scalable semantic repositories. Semantic Web, 2 (1), 3342.
Broekstra, J., Kampman, A., & van Harmelen, F. (2002). Sesame: A generic architecture for
storing and querying RDF and RDF Schema. In Proceedings of the 1st International
Semantic Web Conference (ISWC 2002), pp. 5468.
Cal, A., Gottlob, G., Lukasiewicz, T., Marnette, B., & Pieris, A. (2010). Datalog+/-: A
family of logical knowledge representation and query languages for new applications.
In Proc. of the 25th Annual IEEE Symposium on Logic in Computer Science (LICS),
pp. 228242.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., & Rosati, R. (2007). Tractable
reasoning and ecient query answering in description logics: The DL-Lite family.
Journal of Automated Reasoning, 39 (3), 385429.
Ceri, S., Gottlob, G., & Tanca, L. (1989). What you always wanted to know about datalog
(and never dared to ask). IEEE Trans. Knowledge Data Engineering, 1 (1), 146166.
Cuenca Grau, B., Horrocks, I., Kazakov, Y., & Sattler, U. (2008a). Modular Reuse of
Ontologies: Theory and Practice. Journal of Artificial Intelligence Research, 31, 273
318.
Cuenca Grau, B., Horrocks, I., Motik, B., Parsia, B., Patel-Schneider, P., & Sattler, U.
(2008b). OWL 2: The next step for OWL. Journal of Web Semantics (JWS), 6 (4),
309322.
Derriere, S., Richard, A., & Preite-Martinez, A. (2006). An Ontology of Astronomical
Object Types for the Virtual Observatory. In Proc. of the 26th meeting of the IAU:
Virtual Observatory in Action: New Science, New Technology, and Next Generation
Facilities, pp. 1718, Prague, Czech Republic.
474

fiCompleteness Guarantees for Incomplete Ontology Reasoners

Erling, O., & Mikhailov, I. (2009). RDF support in the virtuoso DBMS. In Pellegrini, T.,
Auer, S., Tochtermann, K., & Schaert, S. (Eds.), Networked Knowledge - Networked
Media, pp. 724. Springer Berlin / Heidelberg.
Fitting, M. (1996). First-Order Logic and Automated Theorem Proving, 2nd Edition. Texts
in Computer Science. Springer.
Glimm, B., Horrocks, I., Lutz, C., & Sattler, U. (2007). Conjunctive query answering for
the description logic SHIQ. In Proceedings of the International Joint Conference on
AI (IJCAI), pp. 399404.
Golbreich, C., Zhang, S., & Bodenreider, O. (2006). The Foundational Model of Anatomy
in OWL: Experience and Perspectives. Journal of Web Semantics, 4 (3), 181195.
Goodwin, J. (2005). Experiences of using OWL at the Ordnance Survey. In Proc. of the
OWL: Experiences and Directions Workshop (OWLED 2005), Galway, Ireland.
Guo, Y., Pan, Z., & Heflin, J. (2005). LUBM: A Benchmark for OWL Knowledge Base
Systems. Journal of Web Semantics, 3 (2), 158182.
Haarslev, V., & Moller, R. (2001). RACER System Description. In Gore, R., Leitsch, A., &
Nipkow, T. (Eds.), Proc. of the 1st Int. Joint Conf. on Automated Reasoning (IJCAR
2001), Vol. 2083 of LNAI, pp. 701706, Siena, Italy. Springer.
Hayes, P. (2004). RDF Semantics. World Wide Web Consortium (W3C) Recommendation.
Horrocks, I., Patel-Schneider, P. F., & van Harmelen, F. (2003). From SHIQ and RDF to
OWL: the making of a web ontology language. Journal Web Semantics, 1 (1), 726.
Kiryakov, A., Ognyanov, D., & Manov, D. (2005). Owlim-a pragmatic semantic repository
for owl.. In Dean, M., Guo, Y., Jun, W., Kaschek, R., Krishnaswamy, S., Pan, Z., &
Sheng, Q. Z. (Eds.), WISE Workshops, pp. 182192.
Lacy, L., Aviles, G., Fraser, K., Gerber, W., Mulvehill, A., & Gaskill, R. (2005). Experiences
Using OWL in Military Applications. In Proc. of the OWL: Experiences and Directions
Workshop (OWLED 2005), Galway, Ireland.
Lutz, C., Toman, D., & Wolter, F. (2009). Conjunctive query answering in the description
logic EL using a relational database system. In Proceedings of the 21st International
Joint Conference on AI (IJCAI), pp. 20702075.
Ma, L., Yang, Y., Qiu, Z., Xie, G. T., Pan, Y., & Liu, S. (2006). Towards a complete OWL
ontology benchmark. In Proceedings of the 3rd European Semantic Web Conference
(ESWC 2006), pp. 125139.
McBride, Brian (2001). Jena: Implementing the RDF Model and Syntax Specification. In
International Workshop on the Semantic Web 2001.
Meditskos, G., & Bassiliades, N. (2008). Combining a DL reasoner and a rule engine for
improving entailment-based OWL reasoning. In Proceedings of the 7th International
Semantic Web Conference (ISWC 2008), pp. 277292.
Motik, B., Cuenca Grau, B., Horrocks, I., Wu, Z., Fokoue, A., & Lutz, C. (2009a). OWL 2
Web Ontology Language Profiles. W3C Recommendation.
475

fiCuenca Grau, Motik, Stoilos & Horrocks

Motik, B., Shearer, R., & Horrocks, I. (2009b). Hypertableau Reasoning for Description
Logics. J. Artificial Intelligence Research (JAIR), 173 (14), 12751309.
Ortiz, M., Calvanese, D., & Eiter, T. (2008). Data complexity of query answering in expressive description logics via tableaux. Journal of Automated Reasoning, 41 (1), 6198.
Perez-Urbina, H., Horrocks, I., & Motik, B. (2009). Ecient Query Answering for OWL 2.
In Proceedings of the 8th International Semantic Web Conference (ISWC 2009), Vol.
5823 of LNCS, pp. 489504. Springer.
Perez-Urbina, H., Motik, B., & Horrocks, I. (2010). Tractable query answering and rewriting
under description logic constraints. Journal of Applied Logic, 8 (2), 186209.
Prudhommeaux, E., & Seaborne, A. (2008). SPARQL query language for RDF. World
Wide Web Consortium (W3C). W3C Recommendation.
Rector, A. L., & Rogers, J. (2006). Ontological and practical issues in using a description
logic to represent medical concept systems: Experience from galen. In Barahona,
P., Bry, F., Franconi, E., Henze, N., & Sattler, U. (Eds.), Reasoning Web, Second
International Summer School 2006, pp. 197231.
Sidhu, A., Dillon, T., Chang, E., & Sidhu, B. S. (2005). Protein Ontology Development
using OWL. In Proc. of the OWL: Experiences and Directions Workshop (OWLED
2005), Galway, Ireland.
Sirin, E., Parsia, B., Cuenca Grau, B., Kalyanpur, A., & Katz, Y. (2007). Pellet: A practical
OWL-DL reasoner. Journal of Web Semantics, 5 (2), 5153.
Soergel, D., Lauser, B., Liang, A., Fisseha, F., Keizer, J., & Katz, S. (2004). Reengineering
Thesauri for New Applications: The AGROVOC Example. J. of Digital Information,
4 (4).
Wu, Z., Eadon, G., Das, S., Chong, E. I., Kolovski, V., Annamalai, M., & Srinivasan, J.
(2008). Implementing an inference engine for rdfs/owl constructs and user-defined
rules in oracle. In Proceedings of the 2008 IEEE 24th International Conference on
Data Engineering (ICDE 08), pp. 12391248. IEEE Computer Society.

476

fi