Journal of Artificial Intelligence Research 43 (2012) 43-86

Submitted 07/11; published 01/12

Robust Local Search for Solving RCPSP/max with
Durational Uncertainty
Na Fu
Hoong Chuin Lau
Pradeep Varakantham

na.fu.2007@phdis.smu.edu.sg
hclau@smu.edu.sg
pradeepv@smu.edu.sg

School of Information Systems,
Singapore Management University,
80 Stamford Road, 178902 Singapore

Fei Xiao

feixiao@gmail.com

Google Inc.
1600 Amphitheatre Parkway Mountain View,
CA 94043 USA

Abstract
Scheduling problems in manufacturing, logistics and project management have frequently been modeled using the framework of Resource Constrained Project Scheduling
Problems with minimum and maximum time lags (RCPSP/max). Due to the importance
of these problems, providing scalable solution schedules for RCPSP/max problems is a
topic of extensive research. However, all existing methods for solving RCPSP/max assume
that durations of activities are known with certainty, an assumption that does not hold
in real world scheduling problems where unexpected external events such as manpower
availability, weather changes, etc. lead to delays or advances in completion of activities.
Thus, in this paper, our focus is on providing a scalable method for solving RCPSP/max
problems with durational uncertainty. To that end, we introduce the robust local search
method consisting of three key ideas: (a) Introducing and studying the properties of two
decision rule approximations used to compute start times of activities with respect to dynamic realizations of the durational uncertainty; (b) Deriving the expression for robust
makespan of an execution strategy based on decision rule approximations; and (c) A robust
local search mechanism to efficiently compute activity execution strategies that are robust
against durational uncertainty. Furthermore, we also provide enhancements to local search
that exploit temporal dependencies between activities. Our experimental results illustrate
that robust local search is able to provide robust execution strategies efficiently.

1. Introduction
Research in scheduling has typically considered problems with deterministic durations. In
real-world scheduling problems, unexpected external events such as manpower availability,
weather changes, etc. lead to uncertainty about durations of activities. There has been
a growing interest to account for such data uncertainty (Herroelen & Leus, 2005; Beck &
Wilson, 2007; Rodrguez, Vela, Puente, & Hernandez-Arauzo, 2009) while providing optimized schedules. This paper also focuses on this important issue of durational uncertainty
in scheduling problems. More specifically, we consider scheduling problems where there are
complex resource constraints and temporal dependencies between activities.
c
2012
AI Access Foundation. All rights reserved.

fiFu, Lau, Varakantham, & Xiao

There are broadly two approaches for tackling scheduling problems with durational
uncertainty. One is to adopt a hybrid of proactive and reactive methods, e.g., the work
of Vonder, Demeulemeester, and Herroelen (2007), where an initial baseline schedule is
computed offline, which is then modified (if required) during execution reactively based on
the occurrence of external events. The second approach, e.g., the paper by Mohring and
Stork (2000), is to design schedule policies that provide online decision rules such that at
time t, the policy decides which task(s) may start and which resource(s) to assign. In this
paper, we adopt the latter approach and focus on the computation of a robust schedule
policy.
From the computational perspective, stochasticity adds a great deal of complexity to the
underlying deterministic scheduling problem. For example, in the infinite-resource project
scheduling problem where processing times have two possible discrete values, the problem
of computing the expected makespan (or any point on the cumulative distribution of the
optimal makespan), is #P-hard (Hagstrom, 1988; Mohring,
2001). It has also been shown
P
that for the scheduling problem 1|stoch pj ; dj = d|E[ wj Uj ], the problem of computing a
policy (i.e., execution strategy) maximizing the probability that some job completes exactly
at the deadline is PSPACE-hard (Dean, Goemans, & Vondrak, 2004). Daniels and Carrillo
(1997) consider a one-machine scheduling problem with probabilistic durations, with an
objective to capture the likelihood that a schedule yields actual performance no worse than
a given target level. This has been shown to be NP-hard even though the underlying
deterministic problem can be solved in polynomial time.
The concrete problem of interest in this paper is the Resource Constrained Project
Scheduling Problem with minimum and maximum time lags (abbrev. RCPSP/max), which
is of great importance in manufacturing, logistics and project management. Though these
problems have been shown to be NP-Hard (Bartusch, Mohring, & Radermacher, 1988),
local search based techniques (Demeulemeester & Herroelen, 2002) have achieved great
success in solving these problems. Taking a cue from this and the recent advancements in
robust optimization, we propose a robust local search method for solving the RCPSP/max
problem under durational uncertainty with a risk management perspective. More precisely,
we (a) employ concepts from robust optimization to compute the robust makespan with
proven success probability (or risk of failure) for an execution strategy; and (b) then use
local search methods for computing an execution strategy that seeks to minimize this robust
makespan.
A recent approach (Beck & Wilson, 2007) provides techniques to compute the robust
baseline schedule from a risk management perspective, where durations of activities are
modeled as random variables. Given a value 0 <   1, they were interested to compute a schedule with minimal (probabilistic) makespan where the probability of successful
execution is at least 1   over all realizations of the durational uncertainty. The main
contribution there was to derive a lower bound for the -makespan of a given schedule by
solving a deterministic problem. They considered the Job-shop Scheduling Problem (JSP)
that represents a special case of RCPSP/max (which is the problem of interest in this
paper).
Unlike in JSPs, there are complex resource constraints and activity dependencies in
RCPSP/max problems with durational uncertainty. To account for these, we compute an
execution strategy (also known commonly as schedule policy) called Partial Order Schedule
44

fiRobust Local Search for Solving RCPSP/max with Durational Uncertainty

(POS) instead of a schedule. We combine techniques from robust optimization with classical
local search to compute a POS that minimizes the robust makespan. The robust makespan
is a value for which the probability of realized makespan for any schedule (derived from
POS) does not exceed it is greater than (1  ), over all realizations of uncertainty. Thus,
we compute an upper bound on makespan values as opposed to lower bound computation
in the work of Beck and Wilson (2007).
More specifically, we make three key contributions in this paper. Firstly, we introduce
two decision rule approximations to define expressions for start times of activities based
on random variables used to represent the durational uncertainties: (a) Segregated Linear
Approximation(SLA) and (b) Generalized Non-Linear Approximation (GNLA). Secondly,
we derive expressions for the upper bound on robust makespan by employing the one sided
Chebyshevs inequality on the decision rule approximations above. Finally, we perform local
search for an execution strategy using the robust makespan upper bound. We also provide
enhancements that consider feedback about robustness of execution strategies to improve
the performance of local search.
In order to demonstrate the effectiveness of our methods, we evaluate the performance on
benchmark problem sets of RCPSP/max and Job-shop Scheduling Problems (JSPs) with
durational uncertainty. Furthermore, we make an in house comparison amongst various
enhancements developed in this paper. Finally, due to the absence of competing algorithms
for solving RCPSP/max problems and to provide an indication of the performance provided
by robust local search, we compare against the existing best solver for JSPs with durational
uncertainty.
In the next section, we present a brief background of the models and solution concepts
referred to in this paper. We then present the decision rule approximations in Section 3 and
the computation of robust makespan upper bound in Section 4. The detailed description of
robust local search and its enhancements are provided in Section 5 and Section 6. Finally,
the experimental setup and results are provided in Section 7.

2. Preliminaries
In this section, we briefly describe the notations along with the scheduling models and
robust optimization concepts of relevance to this paper.
2.1 Definitions and Notations
As given by Ben-Tal and Nemirovski (2002), we also classify the variables in a stochastic
optimization problem into 2 types: Adjustable and Non-Adjustable variables.
Definition 1. Non-Adjustable variables are a priori decisions that must be made before the
actual realization of the uncertainty.
Definition 2. Adjustable variables (also known as recourse variables) are wait-and-see
variables that can adjust themselves when part of the uncertain data become known.
For example, in a scheduling problem such as RCPSP with uncertain task durations,
the non-adjustable variables will represent the execution policy, e.g., the POS proposed by
Policella, Smith, Cesta, and Oddi (2004), that need to be constructed a priori, while the
45

fiFu, Lau, Varakantham, & Xiao

adjustable variables are associated with the actual start times of the tasks, which will be
set with respect to the execution policy and dynamic realizations of uncertainty.
A random variable will be denoted by x and bold face lower case letters such as x
represent vectors.
2.2 RCPSP/max
We now describe the deterministic RCPSP/max scheduling problem along with the extension to handle durational uncertainty. We also explain the execution policy for an uncertain
duration extension of the RCPSP/max.
2.2.1 Deterministic RCPSP/max
The RCPSP/max problem (Bartusch et al., 1988) consists of N activities {a1 , a2 ..., aN },
where each activity aj (j = 1, ...N ) is to be executed for a certain amount of time units
without preemption. Each activity aj has a fixed duration or processing time dj , which is
assumed to be a non-negative real number or non-negative integer number. In addition,
dummy activities a0 and aN +1 with d0 = dN +1 = 0 are introduced to represent the beginning
and the completion of the project, respectively.
A start time schedule ss is an assignment of start times to all activities a1 , a2 ..., aN , i.e.
a vector ss = (st(a1 ), st(a2 ), ...st(aN )) where st(ai ) represents the start time of activity ai
and st(a0 ) is assumed to be 0. Let et(ai ) be the end time of activity ai . Since durations
are deterministic and preemption is not allowed, we then have
st(ai ) + di = et(ai ).

(1)

And the project makespan which is also the start time of the final dummy activity st(aN +1 )
equals
st(aN +1 ) = maxi=1,...N et(ai ).
(2)
Schedules are subject to two kinds of constraints, temporal constraints and resource
constraints. Temporal constraints restrict the time lags between activities. A minimum
time lag Tijmin between the start time of two different activities ai and aj says that
st(aj )  st(ai )  Tijmin

(3)

Specially, Tijmin = 0 means that activity aj cannot be started before activity ai begins. A
maximum time lag Tijmax between the start time of two different activities ai and aj says
that
st(aj )  st(ai )  Tijmax
(4)
Tijmax = 0 means that activity aj cannot be started after activity ai begins.
In this definition, time lags connect start times of two related activities, known as
start-to-start time lags. start-to-end, end-to-end, end-to-start time lags can be easily transformed to the general start-to-start time lags for the deterministic case as given by Bartusch
et al. (1988). A schedule ss = (st(a1 ), st(a2 ), ...st(aN )) is time feasible, if all the time lag
constraints are satisfied at the start times st(ai ) (i = 1, ...N ).
A resource unit is reusable and available for another activity once it is no longer used
by the current activity. Each type of resource has a limited capacity, Ck (k = 1, 2..., K)
46

fiRobust Local Search for Solving RCPSP/max with Durational Uncertainty

units. Each activity ai requires rik units of resource of type k where k = 1, 2..., K. Let
A(t) = {i  {1, 2...N }|st(ai )  t  et(ai )} be the set of activities which are being processed
at time instant t. A schedule is resource feasible if at each time instant t, the total demand
for a resource k does not exceed its capacity Ck , i.e.
X
rik  Ck .
(5)
iA(t)

A schedule ss is called feasible if it is both time and resource feasible. The objective of
the deterministic RCPSP/max scheduling problem is to find a feasible schedule so that the
project makespan is minimized.

Figure 1: Project Instance.

1

time

Figure 2: Example Schedule.

47

fiFu, Lau, Varakantham, & Xiao

Example 1. In Figure 1, we show a simple example of a deterministic RCPSP problem
which is a special case of RCPSP/max with only precedence constraints (rather than arbitrary time lags) between activities for expository purposes. Each circle indicates an activity
with the number inside the circle representing the activity ID. The two numbers on top of
each activity represent the duration and the number of units of the resource required by the
activity. In this example, there are 9 activities and one type of resource, with the capacity of
the resource limited to 10. It should be noted that the activities 0 and 10 are dummy activities introduced to have a source and sink in the dependency graph. Arrows between activities
represent temporal dependencies. A feasible schedule with makespan of 13 is represented in
Figure 2.
2.2.2 RCPSP/max with Durational Uncertainty and Robust Makespan
In this paper, we consider RCPSP/max problems with durational uncertainty. The duration
of an activity is specified as a sum of its mean value and its deviation: di = d0i + zi , where d0i
is the mean of di and zi is the perturbation part with an expected value of 0 and standard
deviation . It should be noted that irrespective of its distribution type, we can always
represent di as di = d0i + zi where d0i is the mean and zi is the perturbation part with
E(zi ) = 0. In addition, we also assume that these random variables, {zi }, corresponding to
durational uncertainty are independent of each other.
Similar to the deterministic RCPSP/max, the start-to-start constraints are still deterministic. However, unlike the deterministic case, other types of constraints (end-to-start
etc.) cannot be converted into deterministic start-to-start constraints . Instead the equivalent start-to-start constraint is a stochastic one as shown in the following expressions for
an end-to-start constraint. It should be noted that even though the converted constraints
are stochastic, our techniques will still be applicable (with minor modifications) to all types
of time lag constraints. Our robust local search techniques depend on the computation
of maximum and sum of random variables and even with stochastic time lag constraints
that remains the case. In this paper, for purposes of exposition, we present our techniques
assuming the temporal dependencies are provided as start-to-start constraints.
st(aj )  et(ai )  Tijmax
st(aj )  (st(ai ) + di )  Tijmax
st(aj )  st(ai )  Tijmax + di
In the deterministic setting, start time schedules can be computed and values of makespan
can be used to evaluate the performance of the schedule. However, when durational uncertainty is involved, the project makespan becomes a random variable and the schedule
is replaced by an execution strategy. In the following sections, we introduce the Partial
Order Schedule (POS) (Policella et al., 2004), which serves as an execution strategy of the
scheduling project.
Given a level of risk 0 <   1, the goal of our problem is to find such a strategy with a minimum value (across all strategies) of the robust makespan. We define the
robust makespan as a makespan value where the probability that any feasible schedule (i.e.
an assignment of start times to activities) instantiated from the strategy can be completed
before robust makespan is at least 1  .
48

fiRobust Local Search for Solving RCPSP/max with Durational Uncertainty

2.2.3 Partial Order Schedule
A Partial Order Schedule (POS) was first proposed by Policella et al. (2004). It is defined as
a set of activities, which are partially ordered such that any schedule with total activity order
that is consistent with the partial order is resource and time feasible. Mathematically, a POS
can be represented by a graph where a node represents an activity and the edges represent
the precedence constraints between the activities. Within a POS, each activity retains a set
of feasible start times, which provide the flexibility to respond to unexpected disruptions.
A POS can be constructed from a given RCPSP instance via a chaining algorithm (where
one such algorithm is described below).
1

Figure 3: Example of POS
Example 2. Figure 3 provides a POS for the problem instance introduced in Example 1.
There are 10 units of the resource and that is shown on the left most side of the figure.
Each unit represents a chain. An activity can require multiple resource units and hence
is shown on multiple resource units. For instance, activity 6 is shown on resource units
4, 7 and 8. A solid arrow between activities represents a temporal dependency provided
in the original problem. Solid arrow between activities 1 and 2 is one such example. A
dotted arrow between activities represents a temporal dependency that is introduced since
both activities have to be executed on the same resource unit. It is added to remove resource
conflict. An example for this is the dependency introduced between activity 2 and activity
6. For explanatory purposes we only consider one resource type in this example, however
in the most general case, there exists multiple resource types and a dependency diagram for
every resource type.
2.2.4 Chaining Algorithm
Chaining is a procedure of dispatching activities to different resource units (henceforth
referred to as chains) based on temporal and resource feasibility. During the chaining
process, each activity can be allocated to one or more resource chains based on the number
of resource requirement of the activity. During the chaining process, once an activity is
scheduled to be executed on a resource unit, an additional edge (indicating precedence
49

fiFu, Lau, Varakantham, & Xiao

relationship) is added between the last activity of the selected chain and this activity so as
to eliminate all possible resource conflicts.
In the following, we describe the basic chaining algorithm proposed by Policella et al.
(2004). In this algorithm, a feasible schedule is first obtained using a simple greedy heuristic.
Consequently, the POS is constructed through a chaining method as follows: First, the set
of activities are sorted according to their start times given in the feasible solution; Then, all
activities are allocated to different chains in that order, where each chain corresponds to a
unit of a certain type of resource. A chain is called available for an activity if the end time
of the last activity allocated on this chain is no greater than the start time of the activity
in the feasible schedule. Once an activity is allocated on a chain, a precedence constraint
between this activity and the last activity of the chain is posted. For those activities that
require more than one unit of one or more types of resources, they will be allocated to a
number of chains with the number equal to the overall number of resource units required
by the activity.
Example 3. Take Figure 3 for example. Given the schedule of Figure 2 as an input,activities
are first sorted according to their starting time and the sequence of activities can be presented
as: (7,1,2,8,3,5,4,6,9). The chaining procedure first picks activity 7 and randomly allocates
it to five chains to fulfill its resource requirement. The available chains are those belonging
to dummy activity 0.Thus, five chains 1 through 5 are created which posts the precedence
relationship from the current last activity 0 to activity 7. Activity 7 then becomes the last
activity on those chains. Activity 1 is treated in the same way. The available chains for
activity 2 are those belonging to activity 1. Activity 2 is then randomly assigned to chain 8
through 10 and an edge between activity 1 and activity 2 indicating precedence relationship is
added. This procedure continues until all activities are dispatched to chains that the number
equals its resource requirement, and finally the chained POS 3 is yielded. However, because
the randomness of the chaining procedure, activity 6 is allocated to chains that belong to
three different activities: activity 2, activity 1 and activity 7. This will tie together the
execution of three previously unrelated activities: (activity 2, activity 6),(activity 1, activity
6) and (activity 7, activity 6), which would decrease the flexibility of execution.
To reduce inter-dependencies between activities as much as possible during the chaining
procedure, Policella, Cesta, Oddi, and Smith (2009) developed two heuristics. One direct
advantage of such approaches is that synchronization points of a solution can be reduced:
 Activities that require more than one resource units are allocated to the same subset of
chains. This is achieved by scanning the list of available chains where the last activity
in the chain : (a) requires multiple resource units; and (b) was also previously assigned
another resource unit allocated to the current activity.
 Activities with a precedence constraint defined in the original problem are allocated
to the same set of chains. This is implemented by choosing a chain that has a last
activity with precedence constraint with the current activity.
Example 4. Figure 4 provides the POS computed by using the above mentioned chaining
algorithm for the RCPSP problem described in Example 1. When allocating activity 6,
50

fiRobust Local Search for Solving RCPSP/max with Durational Uncertainty

1

Figure 4: POS computed with Removed Synchronization Point
the available chains are divided into two sets: {chain 10, chain 9} and {chain 8, chain7,
chain6}. The first set contains chains for which the last activity (i.e. activity 5) is already
ordered in problem definition with respect to activity 6. A chain (for example, chain 10) is
randomly chosen from this set with the last activity on it as activity 5. Then, The remaining
available chains for activity 6 is redivided into two sets: {chain 9} and {chain 8, chain7,
chain6}. The first set contains the chains with activity 5 (i.e. the last activity of the first
picked chain) as the last activity and the second set are the remaining. Activity 6 is first
allocated to chains belonging to the first subset to satisfy all remaining resource requirements.
In this case, the synchronization points caused by activities 1 and 6, activities 7 and 6 being
allocated to different chains has disappeared.
2.3 Job-shop Scheduling Problem (JSP) with Durational Uncertainty
The classical JSP consists of a set of n jobs and a set of M machines. Each job Ji (i = 1, ...n)
consists of a sequence of ni operations denoted as Oij (j = 1, ...ni ) which have to be
processed in a given order. For
P convenience, we enumerate all operations of all jobs by Ok ,
where k = 1, ...N and N = nj=1 nj . Each operation Ok has a positive duration denoted
as dk and must be executed on a dedicated machine denoted as Mk . Once an operation is
started it must be executed for its entire duration. No operations that require the same
resource can overlap in their execution. Thus, operations can be partitioned into two sets:
job sets and resource sets. Job sets referring to operations corresponding to a job and
resource sets referring to all operations that require the same resource.
A solution s is a total ordering of operations on each resource set, which does not conflict
with the job ordering. A path of a solution s is a sequence of operations which follows both
the job ordering and the ordering on various resource sets of the solution s. The length of
a path is equal to the sum of the durations of the operations in the path. The makespan
of a solution s make(s) is the length of the longest path. The minimum makespan of
a JSP problem is defined to be the minimum value of makespans over all solutions, i.e.
mins make(s). Each operation Ok is associated with a start time of st(Ok ) and end time of
51

fiFu, Lau, Varakantham, & Xiao

et(Ok ). A schedule is an assignment of starting times st(Ok ) (k = 1, ...N ) to all operations
on the machines. The objective is to find a schedule which optimizes the total makespan
(makespan is the completion time of the last operation): maxN
k=1 et(Ok ), which is also the
minimum value of the longest path of all solutions. The job shop scheduling problem is
a special case of RCPSP in which resources have unary capacity and each activity (i.e.
operation) consumes only one resource.
We can propagate the same notations from RCPSP/max with durational uncertainty to
the JSP with durational uncertainty, i.e. the processing time of each activity (i.e. operation)
dOk is now modeled as a sum of an expected value d0Ok and a random part zOk : dOk =
d0Ok + zOk . The objective is to find the robust makespan with a given level of risk.
2.4 Segregated Random Variables
A primitive random variable zk is one which has zero mean. Examples of a primitive random
variable include U (a, a) (uniform distribution between constants a and a) and N (0, )
(normal distribution with mean 0 and variance  2 ). As mentioned earlier, we assume
that every uncertain distribution is equal to the sum of its nominal value (mean) and its
deviation, represented by one (or possibly more) primitive random variable z. In a straight
forward representation, there is only one primitive random variable zk associated with an
uncertain variable. In the recent work by Chen, Sim, Sun, and Zhang (2008), each primitive
random variable zk is represented by 2 segregated random variables zk+ (read z-plus) and zk
(z-minus):
z = z +  z 

(6)

z = max {z, 0}

(7)

+



z = max {z, 0} .

(8)

In the following Table 1, we give examples of the respective values of mean p , m and
variance p 2 , m 2 for the segregated variables z + and z  .
z
U (a, a)
N (0, )

V ar(z)

p 2 , m 2

p ,m

a2

5a2
48
(1) 2
2

a
4

2

3
2

Table 1: Values of the mean and variance for the segregated variables under Uniform and
Normal Distribution
The underlying assumption with the use of segregated random variables is that the mean
and variance of the individual segregated variables is provided for the random variables
employed. We are not aware of mean and variance values for segregated variables for
distributions other than normal and uniform.
2.5 Decision Rules for Optimization under Data Uncertainty
In optimization problems with data uncertainty, a decision rule specifies the dependence of
adjustable variables on the uncertainty parameters and the non-adjustable variables. Let z
52

fiRobust Local Search for Solving RCPSP/max with Durational Uncertainty

and x denote the set of primitive random variables and non-adjustable variables respectively.
An example is the linear decision rule framework proposed by Ben-Tal and Nemirovski
(2002), where the setting value of an adjustable decision variable S(x, z) is assumed to be
affinely dependent on a subset of the N number of primitive random variables:
S(x, z) = c0 +

N
X

ck (x)zk

(9)

k=1

where each ck (x) (1  k  N ) is a coefficient derived from x.
Another example is the segregated linear decision rule framework proposed by Chen
et al. (2008), where each adjustable decision variable
assumed tobe affinely dependent
 + is

+ 
on a set of some N segregated random variables z1 , z1 , . . . , zN
, zN . Hence, a segregated
linear decision rule has the following general form:
S(x, z) = c0 +



PN

k=1


+
 
c+
z
+
c
z
k k
k k .

(10)

As we will show below, a segregated linear decision rule allows us to easily obtain an upper
bound on a subset of random variables (see Eqn 14), which is not possible in the linear
decision rule framework proposed by Ben-Tal and Nemirovski (2002).
Given the mean and variance for each segregated variable E(zk+ ) = E(zk ) = k ,
2
2
, we can express the expected value and variance of
and V ar(zk ) = mk
V ar(zk+ ) = pk
any adjustable variable as:
E[S(x, z)] = c0 +

N
X



c+
k k + ck k



(11)

k=1

N n
o
X
 + 2  
2

V ar[S(x, z)] =
ck pk + ck mk  2c+
.
c

k
k k

(12)

k=1

3. Decision Rules for RCPSP/max with Durational Uncertainty
In RCPSP/max with durational uncertainty, a decision rule specifies the dependence of
activity start times on the durational uncertainty associated with other activities. To make
the comparison with Equation 9, x represents the POS to be generated; each tasks start
time is associated with the adjustable variable S(x, z), where c0 represents the earliest start
time of this task under the POS, and ck (x) encodes how task k is related to this task in the
POS.
In a scheduling context, the start time of an activity is dependent on the start times
of the preceding activities, i.e. Adjustable variables S(x, z) are dependent on one another.
Any activity will either start after the end of an activity (i.e. in series) or after the end
of multiple activities occurring simultaneously (i.e. in parallel). Thus, adjustable variables
are functions of other adjustable variables through the addition operator (to model serial
activities) and/or the maximum operator (to model parallel activities).
53

fiFu, Lau, Varakantham, & Xiao

Given M number of adjustable variables, we may express its sum as an adjustable
variable in the form of a segregated linear decision rule as follows:
PM
=

i=1 Si (x, z)
PM 0 PN nPM + +
i=1 ci +
k=1
i=1 ci,k zk

+

PM

 
i=1 ci,k zk

o
.

(13)

Similarly, given some set C of adjustable variables, we may also express the upper bound
on the maximum of these variables as an adjustable variable in the form of a segregated
linear decision rule:
maxiC {Si (x, z)}
n
o P
n
o
P
N


+
+
 maxiC {c0i } + N
max
{c
}z
+
max
{c
}z
.
iC
iC
k=1
k=1
i,k k
i,k k

(14)

More specifically, the output of solving a RCPSP/max involves a POS that is represented
as a graph with activities as vertices and precedence constraints between activities as the
edges. Given a POS graph, x = (V, E), where V is the set of activities and E is the set of
temporal dependencies (an edge (u, v) represents a temporal dependency that states that
activity v should occur after activity u). For any activity v  V , the decision rule for
computing its start time is defined recursively as follows:
Sv (x, z) = max {d0u + zu + Su (x, z)}.
(u,v)E

(15)

Equation 15 is a recursive expression that is defined as a combination of sum and maximum on a set of random variables. It should be noted that combinations of sum and maximum of random variables cannot be computed exactly and hence we present two operational
decision rule approximations to evaluate the recursive expression of Equation 15: (a) Segregated Linear Approximation(SLA); and (b) General Non-Linear Approximation(GNLA). It
should be noted that the Sv is computable as long as mean and variance of Su is computable
and this is demonstrated with both our approximations.
3.1 Segregated Linear Approximation (SLA)
In this decision rule, the duration for each activity is defined based on the segregated random
variables introduced in Section 2.4. For an uncertain duration d with mean processing
time d0 , we represent d as a sum of three components: its mean d0 , lateness z + (i.e.
 0}),
max{d  d0 , 0}), and earliness z  (i.e. max{d0  d,
d = d0 + z +  z  .

(16)

For a normally distributed duration, i.e., z  N {0, }, the respective values of mean
and variance for the segregated variables can be summarized as:

E[z + ] = E[z  ] = 
2
(  1) 2
V ar[z + ] = V ar[z  ] =
.
2
54

(17)
(18)

fiRobust Local Search for Solving RCPSP/max with Durational Uncertainty

Now we describe the computation of Sv (x, z) by representing durational uncertainty for
activities using segregated random variables. Upper bounds on both the sum and maximum
of random variables are derived as linear functions of segregated variables as illustrated
below:
 Sum of random variables : In the case of a project network involving k activities,
any two of which have either precedence constraints in between or competing for the
same resource units, a solution in the form of POS requires computation of the sum of
activity durations. The start time of the activity starting after the k-activity project
is expressed as:
P
Sk (x, (z+ , z )) = ki=1 (d0i + zi+  zi ).
(19)
P
Thus, the adjustable variable Sk a mean of ki=1 d0i with uncertainty captured by
Pk
+
a random variable, which has a positive segregated component of
i=1 zi and a
Pk

negative segregated component of
i=1 zi . Mean and variance of the segregated
variables are known and hence the mean and variance of Sk are easy to compute.
 Max of random variables: Consider activities that are executed concurrently, the
upper bound on the start time of an activity starting after the parallel k-activity
project network in SLA is represented by a linear function of the positive segregated
components of duration perturbations:
P
(20)
Sk (x, (z+ , z ))  maxi=1,...k {d0i } + ki=1 zi+ .
Thus, the adjustable variable Sk has an upper bound on the mean of maxi=1,...k {d0i }
with uncertainty
P captured by a random variable with the positive segregated component given by ki=1 zi+ and no negative segregated component. Mean and variance of
the segregated variables are known and hence the mean and variance of Sk are easy
to compute.
Since, in both cases (sum and max) Sk is expressed linearly on a subset of random segregated variables, the recursive computation is straightforward. Compared with other linear
decision rules (Ben-Tal & Nemirovski, 2002), the superiority of SLA (Chen et al., 2008) lies
in this ability to linearly express an upper bound on a subset of random variables by dissecting each uncertainty into its positive and negative components. While this approximation
increases tractability and scalability, it comes at the expense of losing accuracy.
3.2 General Non Linear Approximation (GNLA)
While SLA is efficient, it can typically provide loose upper bounds on robust makespan
due to the linear approximation for computing max of random variables. In this section,
we describe General Non Linear Approximation (GNLA), which is not restricted to only
affine dependencies. For clarity and comparison purposes, we use G to denote the start
time instead of S used in SLA.
Given the mean and variance values of duration uncertainty, we describe the approximation involved in computing mean and variance of the sum and max of activities that will
55

fiFu, Lau, Varakantham, & Xiao

be used in Equation 15. It should be recalled that irrespective of the distribution of the
 we can always represent d as d = d0 + z, where d0 is the mean of d
uncertain duration d,
and z is the perturbation part. Thus, E(z) = 0.
3.2.1 Sum of Random Variables
We compute sum of all stochastic durations in a serial k activity project network as follows:
Gk (x, z) =

k
X

(d0i + zi ).

(21)

i=1

In this case, we have a similar representation to SLA. Mean and variance of Gk are computed
as follows:
Since {zi }i=1,...k are random variables with zero mean, we can then calculate the expected
value as:
k
k
X
X
0
E[ (di + zi )] =
d0i .
i=1

(22)

i=1

Because {zi } are assumed to be independent of each other, the variance value is computed
by the following expression:
k
k
X
X
0
V ar[ (di + zi )] =
V ar[zi ],
i=1

(23)

i=1

and under normal distribution where zi  N (0, i ), we have
k
k
X
X
V ar[ (d0i + zi )] =
i2 .
i=1

(24)

i=1

Note that the expressions for expected value and variance in the case of serial activities are
identical to the ones used by Wu, Brown, and Beck (2009).
3.2.2 Max of Random Variables
For ease of explanation, we begin by considering two activities to be executed in parallel
and then extend the analysis to multiple parallel activities. In GNLA, (unlike in SLA) the
max of random variables itself is not approximated but the expected value and variance of
the max are approximately calculated.
Expected Value and Variance of Max of Two Variables
The decision rule to represent the starting time of an activity, which will begin after the
completion of two parallel activities is defined as:
G2 (z)  max{d01 , d02 } + max{z1 , z2 }.
Note that we tighten the bound in Eqn 20 by replacing z1+ + z2+ with max{z1 , z2 }.
56

(25)

fiRobust Local Search for Solving RCPSP/max with Durational Uncertainty

We now derive the expressions for expected value and variance of the adjustable variable,
i.e., the RHS term of Eqn 25. Firstly, we focus on the expected value:
E[max{d01 , d02 } + max{z1 , z2 }] = max{d01 , d02 } + E[max{z1 , z2 }].

(26)

In the general case, it is difficult to derive an exact expression for E[max{z1 , z2 }] and hence,
we provide an upper bound.
In the following Propositions 1 and 2, we compute expected value and variance for the
more general case of E(z)  0 (note that we assume E(z) = 0 for all primitive random variables). We calculate for the more general case because it will be required in the computation
of expected value and variance for more than two random variables (next subsection).
Proposition 1. The expected value for the maximum of two general distributions, z1 and
z2 with nonnegativepmeans is less than
1
1
V ar[z1 ] + V ar[z2 ] + (E[z1 ])2 + (E[z2 ])2 .
2 (E[z1 ] + E[z2 ]) + 2
Proof. We begin by considering the following two equalities:
max{z1 , z2 } + min{z1 , z2 } = z1 + z2
max{z1 , z2 }  min{z1 , z2 } = |z1  z2 |.
We now sum the above two equalities.
1
max{z1 , z2 } = (z1 + z2 + |z1  z2 |).
2

(27)

Thus, we can now compute the expected value of the maximum using the following equation:
1
E[max{z1 , z2 }] = (E[z1 ] + E[z2 ] + E|z1  z2 |).
2

(28)

In addition, by using the definition of variance, we obtain:
V ar|z1  z2 | = E(z1  z2 )2  (E|z1  z2 |)2  0.
Therefore,
p
E|z1  z2 | p E(z1  z2 )2
= pE(z12 ) + E(z22 )  2E(z1 )E(z2 )
 pE(z12 ) + E(z22 )
= V ar[z1 ] + V ar[z2 ] + E(z1 )2 + E(z2 )2 .
Substituting the final expression of Eqn 29 into Eqn 28 yields the bound
p
E[max{z1 , z2 }]  12 (E[z1 ] + E[z2 ]) + 12 V ar[z1 ] + V ar[z2 ] + (E[z1 ])2 + (E[z2 ])2 .

(29)

(30)

Hence the proof.
Note that in this paper, we assume E(z) = 0, thus, a tighter bound can be obtained
from Eqn 30:
p
(31)
E[max{z1 , z2 }]  21 V ar[z1 ] + V ar[z2 ].
57

fiFu, Lau, Varakantham, & Xiao

In the special case where {zi } (i = 1, ...k) are normally and identically distributed,
i.e. zi  N (0, ), we know from the work of Clark (1961) that there is a closed form
representation for the expected value of the maximum when k = 2:

E[max{z1 , z2 }] =  .

Now we focus on deriving expressions for variance of the maximum of two general
distributions, i.e., V ar[max(z1 , z2 )].
Proposition 2. The variance for the maximum of two general distributions, z1 and z2 with
nonnegative means is less than V ar(z1 ) + V ar(z2 ) + 21 (E(z1 ))2 + 12 (E(z2 ))2 .
Proof. From Eqn 27, we have
V ar[max(z1 , z2 )] = 41 V ar[z1 + z2 + |z1  z2 |]
= 14 (V ar[z1 + z2 ] + V ar|z1  z2 | + 2COV
p (z1 + z2 , |z1  z2 |))
1
 4 (V ar[z1 + z2 ] + V ar|z1  z2 | + 2 V ar[z1 + z2 ]V ar|z1  z2 |)
 12 (V ar[z1 + z2 ] + V ar|z1  z2 |).

(32)

Firstly, we consider the following two equations.
V ar|z1  z2 | = E(z1  z2 )2  (E|z1  z2 |)2
2

(33)

2

V ar(z1  z2 ) = E(z1  z2 )  (E(z1  z2 ))
Subtracting the second from the first yields

V ar|z1  z2 | = V ar(z1  z2 ) + (E(z1  z2 ))2  (E|z1  z2 |)2 .
Now, we substitute this expression into the last term of Eqn 32 to obtain:
V ar[max(z1 , z2 )]  V ar(z1 ) + V ar(z2 ) + 12 (E(z1 )  E(z2 ))2  21 (E|z1  z2 |)2 .

(34)

When no specific distribution about duration perturbation is known, we can obtain a
bound for V ar[max(z1 , z2 )] as:
V ar[max(z1 , z2 )]  V ar(z1 ) + V ar(z2 ) + 12 (E(z1 ))2 + 12 (E(z2 ))2 .

(35)

Hence the proof.
Note that in this paper, we assume E(z) = 0, thus, a tighter bound can be obtained
from Eqn 35:
V ar[max(z1 , z2 )]  V ar(z1 ) + V ar(z2 ).
(36)
It is interesting to consider the special case when both random variables are normally
distributed. We first state the following lemma1 .
1. This can be found in statistics texts, and found online at http://en.wikipedia.org/wiki/Halfnormal distribution.

58

fiRobust Local Search for Solving RCPSP/max with Durational Uncertainty

Lemma 3.1. If X is normally distributed X  N (0, ), then Y = |X| is half-normally
distributed, with
r
2
E(Y ) = 
.
(37)

Under normal distribution zi  N (0, i ), since z1  z2 is also normally distributed, and
z1  z2  N (0, 1 + 2 ), we can conclude from Lemma 3.1 that |z1  z2 | follows half-normal
distribution with
r
2
E|z1  z2 | = (1 + 2 )
.
(38)

Thus, if we substitute this expression into Eqn 34, we can express an upper bound on the
variance value for the maximum duration perturbation of two activities, when zi  N (0, i )
as :
V ar[max(z1 , z2 )]  (1 

2
1
)( 2 + 22 )  1 2 .
 1


(39)

Expected Value and Variance of Max of Multiple Variables
Extending from two to k (k > 2) parallel activities, the completion time can be upper
bounded by:
Gk (z)  max {d0i } + max {zi }.
(40)
i=1,...k
i=1,...k
In the following, we first compute the variance value of the above RHS term and then
use a similar procedure to compute the expected value. The basic expression for variance
of RHS is:
V ar[ max {d0i } + max {zi }] = V ar[ max {zi }].
(41)
i=1,...k

i=1,...k

i=1,...k

To obtain the value of V ar[ max {zi }] for general probability distributions, we take
i=1,...k

advantage of the analysis provided for the two-parallel-activity case above. The following
steps outline the overall idea:
(a) Firstly, we group the activity set {a1 , ..., ak } into a couple set {C1 , ..., Cd k e }, where
2

each element Cj (j = 1, ...d k2 e) contains two different activities Cj = {aj1 , aj2 } chosen from
the activity set. Note that when k is an odd, the final element in the couple set contains
just one activity.
(b) For each couple Cj , we apply the maximum operator on duration perturbations of involving activities. Denote cj = max{zj1 , zj2 }, where zj1 and zj2 are duration perturbations
of the two activities involved in Cj , then V ar(cj ) can be calculated based on the expression
for the two-parallel-activity case.
(c) Then we have max {zi } = max {cj }. (Note again just one activity is contained in
i=1,...k

j=1,...d k2 e

Cd k e when k is odd). Then, we can build another couple set from {C1 , ..., Cd k e }, and the
2
2
same method from steps (1) and (2) above is used to compute V ar[ max {cj }] based on
j=1,...d k2 e

Eqn 35 and/or Eqn 36 and/or Eqn 39.
59

fiFu, Lau, Varakantham, & Xiao

There are numerous ways (exponential in k) for generating the couple set {C1 , ..., Cd k e }
2
for k activities in parallel. Each of these couple sets can lead to different levels of tightness of
derived robust makespan. To compute the grouping which provides the best robust fitness
for random variables with generic distributions is an open problem. Instead, we focus on
a heuristic that computes the best grouping under normal distribution zi  N (0, i ). It is
obtained by solving the following optimization problem:
X
max
j1 j2
t
(42)
k
j=1,...b 2 c

where t denotes the grouping technique and is also the decision variable; {Cj } is the couple
set constructed from the activity set under grouping method t; j1 and j2 are the standard
deviations of data perturbation for durations of activities contained in Cj . The intuition for
employing this optimization problem is obtained from the Equation 39. It should be noted
that computing a tighter bound on variance implies considering the highest possible value
of the product of primitive variances. Hence, the reason for employing the optimization
problem of Equation 42.
Proposition 3. The solution t to the optimization problem of Eqn 42 is obtained by
ordering the k activities in a non-increasing order of their variance values and then grouping
all two nearest activities according to the order, i.e. Cj = {aj1 , aj2 }, where j = 1, ...b k2 c and
the standard deviations are in the following order:
11  12  21  22 , ...b k c1  b k c2 .
2

2

(43)

Proof. Suppose we have another grouping method t0 , in which all elements in the couple
set are the same as under t except two couples 2 where the ordering is different, i.e., Cm =
{am1 , an2 } and Cn = {am2 , an1 } (m 6= n), where Cm = {am1 , am2 } and Cn = {an1 , an2 }
under t . Without loss of generality, assume m > n and from Eqn 43, we have
m1  m2  n1  n2 .

(44)

Since t0 is supposed to provide a solution which is no less ( defined in Eqn 42) than t ,
i.e.
11 12 + ... + m1 n2 + ... + n1 m2 + ... + b k c1 b k c2
2
2

11 12 + ... + m1 m2 + ... + n1 n2 + ... + b k c1 b k c2 .
2
2
Therefore, we have
m1 n2 + n1 m2  m1 m2 + n1 n2 ,
which is equivalent to: (m1  n1 )(n2  m2 )  0.
This contradicts Eqn 44 (except the case where all standard deviations are equal, in which
case mixing the order does not affect anything). Thus, there exists no such t0 which is
different from t by at least two couples and has better objective value. The general case
2. It should be noted that if there is an ordering change in only one couple, then the method still produces
the same solution because within a couple the variance computation does not consider the order.

60

fiRobust Local Search for Solving RCPSP/max with Durational Uncertainty

that t0 has multiple (more than two) couples different from t can be easily derived from to
this case (and is omitted due to space constraints).
Hence the proof.
As for analyzing the expected value E[ max {zi }], we apply the same procedure emi=1,...k

ployed to calculate the variance, i.e., based on the group solution returned by the above
optimization problem, we first calculate the expected value for each couple and then, get
the final bound following Eqn 30 and/or Eqn 31 and/or Eqn 32.
At present, we are unable to show the effectivness of our grouping heuristic (Equation 42) analytically in the most general case. However, we show the intuition behind the
grouping heuristic by providing an analytical comparison3 on an example where there are
four activities (normally distributed durations) executed in parallel, i.e. zi  N (0, i ), and
we assume 1  2  3  4 (no loss of generality).
The representation of makespan under our grouping heuristic (denoted as Mheu ) and
random grouping (denoted as Mran ) are, respectively:
Mheu = max{d01 , d02 , d03 , d04 } + max{max{z1 , z2 }, max{z3 , z4 }}
Mran = max{d01 , d02 , d03 , d04 } + max{max{z1 , z4 }, max{z2 , z3 }}.
Let us first examine mean and variance values of Mheu . From Eqn 31, we have
p
E(max{z1 , z2 })  12 p12 + 22
E(max{z3 , z4 })  12 32 + 42 .

(45)

(46)

From Eqn 39, we have
V ar[max(z1 , z2 )]  (1  1 )(12 + 22 )  2 1 2
V ar[max(z3 , z4 )]  (1  1 )(32 + 42 )  2 3 4 .

(47)

From Eqn 30, Eqn 35, Eqn 46 and Eqn 47, we can obtain bounds of mean and variance
values of of Mheu are 4 :
q
p
p
P
1
1
2
2
2
2
E(Mheu )  const + 4 ( 1 + 2 + 3 + 4 ) + 2 ( 45  1 ) 4i=1 i2  2 (1 2 + 3 4 )
(48)
P
V ar(Mheu )  ( 98  1 ) 4i=1 i2  2 (1 2 + 3 4 ).
Similarly, mean and variance values of of Mran can also be calculated,
q
p
p
P
E(Mran )  const + 14 ( 12 + 42 + 22 + 32 ) + 12 ( 54  1 ) 4i=1 i2  2 (1 4 + 2 3 )
(49)
P
V ar(Mran )  ( 89  1 ) 4i=1 i2  2 (1 4 + 2 3 ).
From Eqn 57, bounds of fitness of Mheu (denoted by F itheu ) and Mran (denoted by
F itran ) can then be respectively represented as a function of RHS of Eqn 48 and Eqn 49.
We then examine the difference value between the two bounds, F itheu  F itran . Let us first
compare the first term of RHS of mean values in Eqn 48 and Eqn 49, since
p
p
p
p
2
2
2
( p
32 + 42 )2  ( 12 + p
22 + 32 )2
1 + 2 +
4 +
(50)
2
2
2
2
2
2
2
2
2
2
= 2 1 3 + 2 4 + 1 4 + 2 3  2 1 3 + 22 42 + 12 22 + 32 42
3. The calculation will use the robust fitness function provided in Definition 57 introduced in Section 4.
4. Note that const in Eqn 48 and Eqn 49 is max{d01 , d02 , d03 , d04 }.

61

fiFu, Lau, Varakantham, & Xiao

and from Proposition 3, we have
1 4 + 2 3  1 2 + 3 4 ,

(51)

12 42 + 22 32  (12 22 + 32 42 ) = (1 4 + 2 3 )2  (1 2 + 3 4 )2  0.

(52)

thus,

From Eqn 51, Eqn 52, Eqn 48 and Eqn 49, we have that the bounds of mean and variance
values of Mheu are lower than Mran . Given the robust fitness function in Eqn 57, we
conclude that
F itheu  F itran  0

(53)

which is independent of  and . In other words, our grouping heuristic can provide tighter
fitness bound than random grouping.

4. Robust Fitness Function
The makespan (start time of the dummy sink activity) for the RCPSP/max with durational uncertainty is a function of non-adjustable variables x and random variables representing durational uncertainty z and is represented using S(x, z) for SLA and G(x, z) for
GNLA. Recall that the robust optimization problem is to find the minimum value F  for
which the following probability bound is observed5 :
P (S(x, z)  F  )  (1  )

(54)

From the one-sided Chebyshevs Inequality, we can obtain a bound for the robust objective value F  as a function of its expected value and variance of the adjustable fitness
function, i.e.:
q
q
(55)
V ar[S(x, z)]  F   P (S(x, z)  F  )  (1  )
E[S(x, z)] + 1

Hence, we can reformulate our robust optimization problem as follows:
min F 
s.t.

E[S(x, z)] +

q

q
1


V ar[S(x, z)]  F 

(56)

From this model, we can now derive the robust fitness function which will be used in
our local search framework:
Definition 3. Given 0 <   1 and the adjustable fitness function S(x, z) defined above,
the robust fitness function, f (x, z, ), is defined as
r
q
1
f (x, z, ) = E[S(x, z)] +
V ar[S(x, z)]
(57)

The goal of the local search mechanism is to find a local minima of f . In addition, local
search typically requires the fitness function to be computed many times and hence it is
imperative that the computation of fitness function is efficient.
5. We show the computation of SLA robust fitness function. By substituting S with G, we obtain the
fitness function for GNLA.

62

fiRobust Local Search for Solving RCPSP/max with Durational Uncertainty

4.1 Schedule Infeasibility of a Given POS
It should be noted that the fitness function, f assumes that any schedule generated by the
POS, x is always executable. However, due to durational uncertainty and the maximum
time lags, the schedule is not always executable. A direct way to measure IP r(POS) the
probability of infeasibility of the POS (i.e. probability that the POS can lead to an infeasible schedule) lies in the computation of the probability of infeasibility of each activity ai
IP r(ai ), that there does not exist a feasible start time such that all temporal constraints
with respect to ai are satisfied. IP r(POS) can be calculated as the probability that at
least one activity is infeasible. However, due to temporal dependencies between activities
providing a theoretical expression for the overall probability of infeasibility is an open problem. Therefore, we propose a simulation approach, where we simulate POS execution over
multiple trials to compute this probability eciently and approximately. As an illustration,
we experimented with the benchmark J10 instances from the PSPLib (Kolisch, Schwindt,
& Sprecher, 1998) for RCPSP/max with additional durational uncertainty that follows a
normal distribution with mean 0 and variance 1. We generated 1000 sample realizations for
the POS obtained from SLA, and check for infeasibility with respect to the original temporal
(including the maximum time lag) constraints. Examples of the probability of infeasibility
obtained by our simulation for PSP1, PSP4, and PSP13 are 0.18, 0.17 and 0.001. However,
for the other problems PSP3, PSP5 etc. the probability of infeasibility was 0, because the
maximal time lags were much larger than the variance of durational uncertainty.

5. Robust Local Search Algorithm
This section will present how the decision rule approximations introduced by SLA, GNLA
are integrated with the robust fitness function and local search mechanisms to provide a
solution for the problems represented by RCPSP/max with durational uncertainty. Our
proposed algorithm is outlined as follows. Steps 1, 2, 5 and 6 are standard steps in a local
search algorithm. Steps 3 and 4 represent our departure from standard local search to deal
with uncertainty.
1. Generate initial solution
This is usually obtained using a simple greedy heuristic.
2. Generate neighborhood of solutions
Generate a pool of neighbor solutions from the current solution.
3. Employ one of the decision rule approximations (SLA and GNLA) for all
adjustable variables and check feasibility
For each candidate solution x in the solution pool, derive the coefficients Ck (x) for
each adjustable variable. Subsequently, for each solution check constraint violation
and reject those that are not feasible.
4. Evaluate robust fitness function f
For each feasible solution x, evaluate f to obtain the robust objective values. The
solution with the lowest robust objective value is the current best robust solution.
63

fiFu, Lau, Varakantham, & Xiao

5. Apply penalty (optional)
Some advanced local search strategies may require a penalty to be applied to prevent
it from being caught at a local minima. In the case of tabu-search for example, a
tabu-list is updated when a tabu move is applied. In the case of iterated local search,
a perturbation move will be applied to the current local minima.
6. Termination criteria
If the termination criteria is met, return the solution with the lowest robust fitness
function value else repeat the optimization cycle by determining the next move.
Algorithm 1 provides the robust local search algorithm guided by decision rule using
 , S  , S  with G , G , G , we obtain the local search algoSLA. By substituting Snow
now
min
min
rithm using GNLA. Given the RCPSP/max with durational uncertainty and the level of risk
(0 <   1), the algorithm returns the POS with the (locally) minimal robust makespan,
S  (or G by GNLA). In essence, we perform robust local search on the neighborhood set
of activity lists. An activity list (al) is defined as a precedence-constraint feasible sequence
that is used by heuristics to generate earliest start time schedules in solving the standard
RCPSP problem (Kolisch & Hartmann, 2005).
Different activity lists are explored by local moves. In our context, we only consider the
activity list as the sequence of activities which satisfy the non-negative minimal time lag
constraint. Due to the existence of maximal time lag constraint in RCPSP/max, scheduling
activities to their earliest possible start time based on the order position in the activity list
may restrict the schedule so much that it may not even return in a feasible schedule. Thus,
when we schedule each activity sequentially based on order position in the activity list, we
will assign its starting time by randomly picking a time from its domain of feasible start
times.
According to our experiments, this new randomized approach returns more feasible
solutions than the earliest start time one. After finding a feasible schedule, a POS will be
generated by applying the chaining procedure proposed by Policella et al. (2004). Then,
the S  (or G by GNLA) value will be computed according to the POS. Intuitively, using
the randomized approach may return a schedule with a large baseline scheduled completion
time. However, we can apply the shortest path algorithm on the resulting POS to generate
the earliest start time schedule for a smaller makespan.
As mentioned above, it may be difficult to find a feasible schedule that satisfies minimal
and maximal time lag constraints using the activity list. In fact, we believe that in the set
of all activity lists, many may not yield a feasible schedule. We overcome this problem as
follows. We define the set of activity lists which result in feasible (or infeasible) schedules
as F (or I). We seek to design a local search algorithm with the following characteristics:
a) Starting from an activity list in I, the local search should move to an activity list in F
within a short time. b) Starting from an activity list in F , the local search should move
to the activity list with the minimal S  (or G by GNLA)value. c) We also diversify the
exploration of activity lists in F by allowing the local search to move from an activity list
in F to an activity list in I, since activity lists in the F region may not be reachable from
one another by simple local moves. This has the flavor of strategic oscillation proposed in
meta-heuristics research.
64

fiRobust Local Search for Solving RCPSP/max with Durational Uncertainty

Algorithm 1 Robust Local Search
1: Generate an activity list al randomly
2: Find a start time schedule, ss randomly according to al
3: if al  F then
4:
P OS  chaining(ss)

Compute Snow
according P OS
5:


6:
Update Smin as Snow
7: else
8:
Record the first activity a which cannot be scheduled
9: end if
10: for i  1 to Max Iteration do
if al  I then
11:
12:
Shift activity a ahead in al randomly as al
else
13:
14:
Select two activities b and c in al randomly
15:
Swap b and c in al as al
16:
end if
17:
Find randomized start time schedule ss0 according to al
18:
if al0  F then
P OS 0  chaining(ss0 )
19:
20:
Compute S  according to P OS 0

21:
if al  I or S   Snow
then


22:
Snow  S
23:
al  al0

24:
if S   Smin
then


Smin  S
25:
26:
end if
27:
end if
28:
else if al  I then
29:
al  al0
30:
else
31:
p  rand(0, 1)
if p < 0.01 then
32:
33:
al  al0
34:
Record the first activity a which cannot be scheduled
35:
end if
36:
end if
37: end for

65

fiFu, Lau, Varakantham, & Xiao

The detailed robust local search procedure is given in Algorithm 1. The procedure starts
by randomly generating an activity list al, which is a sequence of activities that satisfy the
non-negative minimum time lag constraint (Line 1). In Line 2, a schedule ss is produced
based on ordering of activities in the activity list al. We first perform domain reduction
on the distance graph using the Floyd-Warshall algorithm, so that the feasible range of the
start time for each activity based on the temporal constraints can be obtained. We then
schedule each activity sequentially based on the order position in the activity list. For each
activity, we first pick a start time randomly from the feasible domain and evaluate resource
constraints for the duration of the activity (i.e. check if the current resource capacity exceeds
the resource amount used by that activity). If yes, we set the start time to that activity,
run the shortest path algorithm to reduce domains for the remaining activities, and update
current resource capacity due to consumption of that activity. If the resource constraints
are not satisfied, we will try to set the start time randomly again for a prescribed maximum
numbers of retries. Once the start time of current activity is set, we proceed iteratively
to the next activity according to the activity list. In Line 4, chaining() is employed to
generate a POS from a baseline schedule (section 2.2.4). M ax Iteration refers to the
maximum number of iterations in the robust local search. We apply two different types of
local moves. To converge quickly to an activity list in F, the first local move is designed
to schedule the activity that is causing a temporal or resource conflict to an earlier time.
It will randomly shift ahead the first activity which cannot be scheduled in the current
activity list (Line 12). When an activity list is in F, the second local move will randomly
pick two activities and swap them in the current activity list, while satisfying the nonnegative minimal time lag constraints (Line 14-15). The move will be accepted, if it results
in a smaller or equal S  value (Line 18-29). To explore different activity lists, we include
a small probability to accept the move which leads to an infeasible schedule (Line 31-35).
The probability to move from an activity list in F to one in I is set at 0.01. The minimal
 .
S  value will be saved as Smin

The worst-case computational complexity analysis is given as follows. For each iteration
in local search, there are three major components: randomized schedule generation, POS
construction and fitness calculation. In the process of randomized schedule generation, we
perform domain reduction and resource checking at each iteration, and thus the complexity
is O(N  (N 3 + H  K  w)) where N is the number of activities, H is the maximum planning
horizon, K is the number of types of resources, and w is the prescribed maximum number
of retries for each activity on setting the randomized start time. The POS construction
process works as follows: the set of activities are first sorted according to their start times
in the generated deterministic schedule and the sorting part costs O(N  logN ); then it
proceeds to allocate each activity the total units needed for each type of resource. Let
maxcap be the maximum capacity among all resources. The cost for computing POS is
then O(N  logN + N  K  maxcap ). When determining the fitness value of generated
POS, we examine edge by edge to check if it is connected in parallel or in serial with
respect to its predecessors and it costs O(N + e) where e is the number of edges in POS
(e < N 2 ). Thus, the worst-case complexity of our proposed robust local search algorithm is
O(T N  (N 3 + H  K  w + K  maxcap )) where T is the number of iterations in local search.
66

fiRobust Local Search for Solving RCPSP/max with Durational Uncertainty

6. Enhancing Robust Local Search
In this section, we describe two enhancements to improve the basic local search method
described in Section 5. Firstly, we describe ordering generation, which is a pre-processing
step used to identify precedence ordering between activities. This precedence ordering is
then used to focus the local search over activity lists. Secondly, we describe a new chaining
method to generate POS from a feasible schedule.
6.1 Ordering Generation
Ordering Generation is a pre-processing step that identifies precedence relationships between
pairs of activities. The key idea is that for certain pairs of activities, it is always better
(with respect to robust makespan) to have the same ordering among activities. Our goal is
to identify these pairs of activities and employ this ordering to focus the local search over
activity lists and in the chaining method used to compute POS from feasible schedule.
In deciding an ordering between a pair of activities, a and b, there are two key steps:
(i) Sample set generation: Generate two sets of m activity lists. The first set consists of m
activity lists where a occurs before b. The second set is generated by swapping activities a
and b in every activity list in the first set; (ii) Order determination: In this step, we first
compute POS and its robust makespan for all activity lists in the two sets. By comparing
the robust makespan values of corresponding activity lists in the two sets, we determine an
ordering between activities. We explain these steps in the following subsections.
For a problem with n activities, there are Cn2 pairs of activities. If we are to decide the
orders between all pairs, the ordering computation needs to be implemented for Cn2 times,
which is computationally expensive. Based on this observation, we first propose a PairsSelection heuristic to selectively choose a certain number of activities pairs whose ordering
can have a significant impact on the robust makespan.
The Pairs-Selection heuristic picks an activity pair: (a) If it is not precedence related in
the original problem definition; and (b) If there exists at least one type of resource, where
the total demand of both activities exceeds the resource capacity. The intuition behind
picking such an activity pair is that those two activities cannot be executed in parallel and
deciding an ordering relationship is imperative to eliminate the resource conflict. One main
advantage of the heuristic is that the number of pairs of activities that need to be ordered
is significantly reduced. Now, we describe the two steps of ordering generation below:
6.1.1 Sample Set Generation
We first randomly generate m activity lists as an initial sample set denoted by T . Each
element in T is an activity list represented as ali which is a sequence of all activities, where
i = 1, ...m, i.e.
T = {ali |ali = (a1 , a2 , ...an ), i  {1, ...m}}.
For each pair of activities (ak , al ) resulting from the Pairs-Selection heuristic, we define
two sample sets represented as T ak al and T al ak . T ak al has all the activity lists that are
in T , except that if an activity list has al before ak , then those activities are swapped.
T ak al = {aliak al |i  {1, ...m}},
67

fiFu, Lau, Varakantham, & Xiao

(
(a1 , a2 , ..., ak , ...al , ...an ) if ali = (a1 , a2 , ..., al , ...ak , ...an )
.
where aliak al =
ali
if ali = (a1 , a2 , ..., ak , ...al , ...an )
Similarly, T al ak can be constructed by incrementally selecting each activity list from
the initial set T with al  ak and reverse the order if ak  al , i.e.
T al ak = {alial ak |i  {1, ...m}},
(
(a1 , a2 , ..., al , ...ak , ...an ) if ali = (a1 , a2 , ..., ak , ...al , ...an )
where alial ak =
.
ali
if ali = (a1 , a2 , ..., al , ...ak , ...an )
Thus, each activity list in the sample set T ak al share the same positions of all activities
except ak and al with the corresponding activity list in set T al ak , where al precedes ak .
6.1.2 Order Determination
We then determine the activity order of each selected pair of activities based on the sample
sets obtained from last phase. For a pair (ak , al ), we construct a new instance by posting
a precedence constraint ak  al or al  ak to the original instance, and based on the new
instance, we determine the fitness which are denoted as fiak al and fial ak for aliak al and
alial ak , respectively.
Note that aliak al and alial ak share the same elements and the same positions except
the order of ak and al . Thus, the order of ak and al can be considered as a reason why the
fitness of aliak al and alial ak differs. To decide the order of ak and al , we define an index
variable denoted as ivak al that measures the percentage of samples where the one with the
order ak proceeds al wins, i.e.
P

ivak al = 

i

min(

a al
a ak
f k
f l
i
i
ak al
a ak ,0)
|f
f l
|
i
i

m

.

We then define an Index Parameter for activities ak and al denoted as IPak al as a
benchmark for the index variable ivak al in determining the order of ak and al . The parameter IPak al can be prescribed by users and different values (usually larger than 50%)
represent different levels of confidence that the order of ak and al matters in causing fitness
variance, and thus also represents different controllability of ivak al .
If the value of index variable ivak al is larger than the value of IPak al , we set the order
ak  al since there indicates a higher probability that a  b can provide better robustness
than b  a; If ivak al is less than 1  IPak al , we set al  ak ; And in other cases, no order
between ak and al is settled.
6.2 Improved Chaining based on Robustness Feedback
As noted in the Preliminaries section, for each activity a, there may exist multiple
choices of resource chains to which it can be assigned. In addition, different chaining heuristics will lead to POSes that can have different robust makespan values. In this section, we
propose a new chaining heuristic that dispatches activities to resource chains by predicting
the improvement in robust makespan of the generated POS.
68

fiRobust Local Search for Solving RCPSP/max with Durational Uncertainty

Algorithm 2 Robustness-Feedback Resource Chaining (Activity a, Schedule S, Order G)
1: C  Find set of available chains, C for activity a based on S
2: P  Collect chains from C with last activity of chain preceding a in problem
3: O  Collect chains from C with last activity of chain ordered before a in G
4: if P 6=  then
5:
k  Get first available chain in P
6: else if O 6=  then
7:
k  Get first available chain in O
8: else
9:
k  Get first available chain in C
10: end if
11: Post constraint between last activity of chain k (denoted as last(k)) and activity a
12: if a requires more than one resource unit then
13:
C1  chains in C which have last activity as last(k)
14:
C2  C \ C1
15:
for all resource units required by a do
16:
choose the first available chain belonging to C1
17:
if chain above is not feasible then
18:
choose the first available chain belonging to C2
19:
end if
20:
end for
21: end if
In the latest chaining method which aims to increase flexibility as described in Section 2.2.4, the chains are first randomly picked from a superior subset (i.e., chains where
the last activity is already ordered, or chains sharing the same last element). Since our objective is makespan-related and time becomes a concern, we build on the work of Policella
et al. (2009) and pick the first available chain wherever available. The updated chaining
method is called Robustness-Feedback based Resource Chaining.
Example 5. Figure 5 provides the POS provided by this chaining heuristic when used on
Example 1. As can be seen, compared to the POS in 4, the key difference is the allocation
of activity 5 and 6. With our new heuristic, it can be seen that there is more parallelism
and hence reduced robust makespan with high probability.
When employing the Ordering Generation algorithm in conjunction with the chaining
heuristic, we also consider the information about ordered pairs when allocating resource
units to an activity. The motivation is that once activity a and activity b (for example,
a  b) is ordered, there is a high probability that this precedence relationship can result
in a better solution. Algorithm 2 provides the pseudo code for the Robustness-Feedback
Resource Chaining heuristic with Ordering.

7. Experimental Evaluation
In this section, we first evaluate the scalability and quality of the execution strategies
provided by robust local search and the various enhancements introduced in this paper.
69

fiFu, Lau, Varakantham, & Xiao

1

Figure 5: POS by Robustness Feedback Chaining
Secondly, to establish a benchmark on the performance, we compare against the best known
technique for solving JSP problems with durational uncertainty. It should be noted that
the robust local search method is developed to solve RCPSP/max problems with durational
uncertainty and hence does not exploit the structure present in JSP problems. Furthermore,
as described earlier, the optimization metrics of both approaches are different.
7.1 Experimental Setup
We have two sets of problems that we consider and those are described in the subsections
below. Additionally, we also indicate the algorithms that are compared on each of the data
sets in this section.
7.1.1 RCPSP/max with Durational Uncertainty
The problems considered for RCPSP/max with durational uncertainty were obtained by
extending the three benchmark sets available for RCPSP/max problems, J10, J20 and
J30 as specified in the PSPLib (Kolisch et al., 1998). Each set contains 270 problem
instances with duration for each activity ranging between 1 and 10. The maximum number
of activities for J10, J20 and J30 are 10, 20 and 30, respectively. For each activity ai , we set
the expected value d0i of the stochastic duration as the corresponding deterministic duration
given by the benchmarks, and assume that duration uncertainty is normally distributed,
i.e. zi  N (0, ). Henceforth, we refer to J10, J20 and J30 as these RCPSP/max problems
with durational uncertainty. We run the algorithms on problems with four different duration
variabilities  = {0.1, 0.5, 1, 2} and four increasing levels of risk  = {0.01, 0.05, 0.1, 0.2}.
70

fiRobust Local Search for Solving RCPSP/max with Durational Uncertainty

On RCPSP/max problems with durational uncertainty, we compare the robust local
search that is guided using the two decision rule approximations SLA and GNLA. Furthermore, we also compare the different enhancements to robust local search on RCPSP/max
problems with durational uncertainty. We compare five different variants of robust local
search for each decision rule approximation: (a) (GNLA) refers to basic robust local search
guided by GNLA decision rule approximation; (b) (GNLA+RC) is the robust local search
with the new Robustness-feedback Chaining heuristic guided by GNLA; (c) (GNLA+) refers
to the basic robust local search with additional local search iterations, where the number
of local search iterations is determined based on the problem set (as described later); (d)
(GNLA+OG) is the Order Generation heuristic on top of GNLA guided robust local search;
and finally (e) (GNLA+OG+RC) has both Order Generation and Robustness-feedback
Chaining heuristics on GNLA guided robust local search.
The number of local search iterations for robust local search was set to 1000. To reduce
the stochasticity effects of robust local search, we average over 10 random executions for
each problem instance. Our code was implemented in C++ and executed on a Core(TM)2
Duo CPU 2.33GHz processor under FedoraCore 11 (Kernel Linux 2.6.29.4-167.fc11.i586).
7.1.2 JSP with Durational Uncertainty
For JSPs, (GNLA) is compared against the probabilistic makespan results provided by
Beck and Wilson (2007). For the benchmark problems, we consider the instances generated
using an existing generator in the work of Watson, Barbulescu, Whitley, and Howe (2002)
with durations drawn uniformly from the interval [1,99]. Specifically, we focus on three
sets of probabilistic JSPs of size {44,66,1010} (where a 44 problems consists of 4
jobs consisting of 4 activities each) and for each set, three uncertainty levels {0.1,0.5,1} are
considered.
7.2 Comparison between SLA and GNLA
We first compare the average robust makespan of 270 problem instances obtained by robust
local search that is guided by our decision rule approximations proposed in Section 3.1 and
Section 3.2. We refer to the robust makespan computed using SLA as S  and using GNLA
as G . Figure 6 provides these results for all three sets of RCPSP/max problems with
durational uncertainty. In these results, we show how the robust makespan is affected by
the level of risk  and the standard deviation  of duration uncertainty. X-axis represents
different combinations of risk and standard deviation of durational uncertainty, as shown in
the table of Figure 6. All runs on every instance takes a couple of seconds and hence we do
not report CPU times here. The key observations and conclusions of interest from Figure 6
are as follows:
 Irrespective of the , as the level of risk  increases, the robust makespan decreases
with both SLA and GNLA. Clearly, the lower risk that the planner is willing to take,
the higher is the robust value of the generated execution strategy. Our method is
capable of quantifying this trade off, which can help the planner to decide on the
desired strategies.
71

fiFu, Lau, Varakantham, & Xiao

105

95

G*

S*

85

75

65

55

45
1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

(a) Results of J10
146
136

G*

S*

126
116
106
96
86
76
1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

(b) Results of J20
170
160

G*

S*

150
140
130
120
110
100
1

2

3

4

5

6

7

8

9

10

11

12

13

14

(c) Results of J30

Figure 6: Comparison of Robustness between SLA and GNLA.
72

15

16

fiRobust Local Search for Solving RCPSP/max with Durational Uncertainty

 Irrespective of , as the degree of duration variability  increases, the robust makespan
increases with both SLA and GNLA, and the value becomes more sensitive to  when
the level of risk is constrained to a small value (e.g.  = 0.01).
 For lower values of , more specifically for 0.01, S  provides lower values of robust
makespan than G . On the other hand, for higher values of   {0.05, 0.1, 0.2}, G
provides superior performance to S  . We do not yet understand the reason for drop in
performance for  = 0.01, but this is observed consistently across all the RCPSP/max
benchmark problems.
For each problem instance, we also observe some monotonicity between the absolute
difference of robust makespan S  and G and risk values. When the level of risk  takes a
value around 0.02, S  (SLA) has a slightly lower value than G (GNLA). However, when
risk becomes more than 0.02, the superiority of GNLA increases with higher values of risk.
Figure 7 illustrates this on a randomly picked J10 instance with  = 1 and  = 2. The
same pattern is observed across all problem instances of J10, J20 and J30.
105

65

95

60

85

55

75

50

65

S*

45

S*

55

G*

40

G*

45

35

35

30

25

25

0.005 0.01 0.02 0.03 0.04 0.05 0.1 0.15 0.2 0.25 0.3

0.005 0.01 0.02 0.03 0.04 0.05 0.1 0.15 0.2 0.25 0.3

(a) Results from a randomly selected J10 example (b) Results from a randomly selected J10 example
with =1
with =2

Figure 7: Comparison of Robust Makespan.
Next, in Figure 8, we compare the quality of the execution strategies obtained by using
SLA and GNLA. More precisely, we compare the distributions of the actual makespans of
schedules computed using these decision rule approximations. For this purpose, we generate
a set of 100 samples of realizations of durational uncertainty and test with all 270 instances
of each benchmark set with different levels of risk  = 0.2,  = 0.1 and  = 0.05 to obtain
the respective POS, and then compute the actual makespans of schedules derived from the
respective POS under the given realization samples. This difference between real makespans
obtained from POSs generated by two different decision rule approximations was observed
across the board in all examples of the three sets for all values of  except 0.01. We randomly
select three problem instances from each benchmark set and present the results in Figure 8.
Figure 8 also compares the cumulative frequency distributions of the actual makespans. We
observe that GNLA provided far better realized makespans than SLA - both in absolute
terms, as well as distributionally. For J20, except in 2 cases, rest of the actual makespan
73

fiFu, Lau, Varakantham, & Xiao

82

100%
80

80%
78
76

60%

74

40%

72

20%

70

0%

68

69

71

73

75

77

79

81

(a) Results from randomly selected J10 example with  = 0.2

100%

60

80%
55
60%
50
40%
45

20%

40

0%
41

43

45

47

49

51

53

55

57

(b) Results from a randomly selected J20 example with  = 0.1
110
100%
105
80%
100

60%

95

40%
20%

90
0%
85

86 88 90 92 94 96 98 100 102 104 106 108

(c) Results from a randomly selected J30 example with  = 0.05

Figure 8: Comparison of Actual Makespans and Gap between S  and G .(Lines in left pictures from top down indicating: Computed S  , Actual S  by Simulation, Computed G , Actual G by Simulation.)

74

fiRobust Local Search for Solving RCPSP/max with Durational Uncertainty

values obtained by SLA were higher than the ones obtained by GNLA. Similar trends were
observed for J10 and J30.
To illustrate the difference of quality in absolute of the two upper bounds, we provide
four lines (computed S  , actual S  , computed G and actual G ) indicating the upper
bounds computed using the algorithms and in simulation over the 100 samples.
7.3 Comparing Robust Local Search Enhancements
Since, we have already shown GNLA performs better than SLA, we will only show the performance of our enhancements over GNLA in this section. It should be noted that enhancements over SLA provided similar results and conclusions with GNLA based enhancements
outperforming SLA based enhancements. Since Ordering Generation heuristic requires
additional rounds of robust makespan computation, we also include a benchmark called
(GNLA+) (which is GNLA plus extra iterations of local search) to make a fair comparison.
To avoid the complexity of considering all pairs of activities, we only consider those pairs
of activities where ordering would improve performance. We proposed the Pairs-Selection
heuristic to select these pairs of activities. The number of extra iterations of local search
for the (GNLA+) benchmark is the number of activity pairs picked by the Pairs-Selection
heuristic times the number of samples m used in the Ordering Generation process. The
experimental results shows that the average number of activity pairs of all 270 instances selected under the Pairs-Selection heuristic for J10, J20 and J30 are 5, 14, and 28 respectively.
In our work, we set m = 100. Thus, the extra iterations of the (GNLA+) benchmark for
J10, J20 and J30 are 500, 1400 and 2800, respectively. The performance of all our enhancements is shown in Figure 9(a), Figure 9(b), Figure 9(c) for J10, J20 and J30 respectively.
In all the charts,  is represented on the X-axis and robust makespan on the Y-axis. So,
lower values are better on the Y-axis.
Given below are some key observations and conclusions made from the results:
 Irrespective of the durational uncertainty, (GNLA+RC) and (GNLA+OG) provide
better robust makespan values than both (GNLA) and (GNLA+) for J10 and J30.
This indicates that the new Robustness Feedback Chaining heuristic and the Order
Determination are able to provide more robust partial ordered schedules for J10 and
J30. This improvement seems to increase further with more number of activities, i.e.
the difference is more obvious for instances in J30 than in J10. Furthermore, the
difference is consistently observed across all the problems. However, the improvement
is not consistent for J20 and there are cases where (GNLA+RC) and (GNLA+OG)
did not out perform (GNLA) and (GNLA+). For instance in J20 problems, (GNLA+)
provides better performance than (GNLA+RC) and (GNLA+OG) for  = 0.01 and
 = 1.5.
 The extra iterations of local search in (GNLA+) do not improve the solution quality
much for J10. However, it improves the solution quality for J20 and J30. This could
be because the optimal solution is obtained within 1000 iterations for the smaller
problems.
 In most cases, (GNLA+RC+OG) provides the lowest robust makespan among all the
enhancements. Thus, the OG and RC enhancements in combination do not degrade
75

fiFu, Lau, Varakantham, & Xiao

(a) Results of J10

76

fiRobust Local Search for Solving RCPSP/max with Durational Uncertainty

(b) Results of J20

77

fiFu, Lau, Varakantham, & Xiao

(c) Results of J30

Figure 9: Comparison of Robust Local Search Enhancements.

78

fiRobust Local Search for Solving RCPSP/max with Durational Uncertainty

MNPM
CB
G

Problem Size
44
UL=0.1 UL=0.5 UL=1
1.023
1.046
1.128
1.066
1.123
1.282

Problem Size
66
UL=0.1 UL=0.5 UL=1
1.021
1.073
1.168
1.095
1.190
1.273

Problem Size
1010
UL=0.1 UL=0.5 UL=1
1.024
1.101
1.215
1.210
1.225
1.263

Table 2: Comparison against CB solver(UL:Uncertainty Level).
the performance improvement obtained individually. In some cases, the difference is
significant such as in J10 for  = 0.1 and  = 0.01. On the other hand, there are
cases where (GNLA+RC+OG) does not provide the lowest robust makespan, such as
in J20 for  = 0.5 and  = 0.01.
7.4 Comparing on JSPs with Durational Uncertainty
In this section, we compare the performance of our GNLA approach (referred to as G )
with the best known solver for Job Shop Scheduling Problems proposed by Beck and Wilson (2007) (referred to as CB). For a fair comparison of the two approaches, we employ the
Mean Normalized Makespan (MNPM) metric defined by Beck and Wilson:
M N P M (a, L) =

1 X D(a, l)
|L|
Dlb (l)

(58)

lL

where L is a set of problem instances, D(a, l) is the probabilistic makespan (i.e., robust
makespan in our work) for instance l by algorithm a generated by Monte Carlo simulation,
Dlb (l) is a lower bound on the probabilistic makespan.
We denote the best MNPM values aross different algorithms reported by Beck and
Wilson as CB. We compare them with the MNPM values in our work which are obtained
by replacing D(a, l) in Eqn 58 with an upper bound of robust makespan from the POS
generated from GNLA-guided local search. All runs on 4  4 and 6  6 instances took less
than a minute, while 10  10 instances took about 15 minutes.
Table 2 provides the results. The performance of our solver is comparable to CB solver
across all problem instances. This comparison illustrates that our local search mechanism
is generic (different types of scheduling problems) and is also able to provide performance
on par with near optimal approaches. While the performance is comparable, CB provides
better MNPM values than our approach due to the following key reasons: (a) Our approach
does not exploit the structure specific to JSPs (jobs consisting of a sequence of operations).
We hope to improve our approach to exploit this in the near future. (b) Our robust local
search reasons with upper bounds (due to Chebyshev inequality), which can be loose.

8. Related Work
The Resource-Constrained Project Scheduling Problem with minimum and maximum time
lags, RCPSP/max, (or known as the Resource-Constrained Project Scheduling Problem
with Generalized Precedence Relations, RCPSP-GSR) is a strongly NP-hard combinatorial optimization problem; and even the decision problem of determining whether an
79

fiFu, Lau, Varakantham, & Xiao

RCPSP/max instance has a feasible solution or not is NP-complete (Bartusch et al., 1988).
A survey of recent developments and new applications for RCPSP/max has been given by
Neumann, Schwindt, and Zimmermann (2006).
However, we did not find much study that considers RCPSP/max under uncertainty.
One such paper dealing with variable durations on RCPSP/max is done by Lombardi and
Milano (2009), where activity durations range between given lower and upper bounds.
A precedence constraint posting approach (Policella, Cesta, Oddi, & Smith, 2007) was
adopted. Whereas in our work, we consider RCPSP/max with durational uncertainty where
each activity duration is modeled as a random variable with known mean and variance
values.
Research on scheduling under uncertainty has received much attention in both Artificial
Intelligence and Operations Research communities. For a complete survey of recent AI
papers on robust project scheduling up to 2004, one may refer to the work of Herroelen
and Leus (2005) and of production scheduling (Aytug, Lawley, McKay, Mohan, & Uzsoy,
2005). Broadly, one may classify the techniques to tackle scheduling with uncertainty into
two categories: Proactive Scheduling is to design a priori schedule or a schedule policy that
take into account the possible uncertainty that may occur; Reactive Scheduling modifies
or re-optimizes the baseline schedule when an unexpected event occurs. Here our interest
is on proactive scheduling and we are concerned with robust scheduling which focuses on
obtaining proactive schedules that maintain a high level of performance against uncertainty.
The main idea of proactive techniques is to build a global solution which hopefully does
not need to be revised at execution time. One can divide the research in this area into three
categories, according to how and when the information of uncertainties can be taken into
account in generating more robust and stable schedules than they would be without using
this information (Bidot, Vidal, Laborie, & Beck, 2009): 1. generating one complete generic
schedule which is proved to execute correctly in most scenarios arising during execution;
2. generating a flexible solution in which some decisions are postponed to be made until
execution; 3. generating a conditional solution in which mutually exclusive decisions are
developed,the one being chosen dependent on some observations during execution, like
markov decision processes. In the following, we briefly look at the first two cases since
they are related to our work.
8.1 Generating Generic Schedule
A first method for making a generic schedule that is insensitive to online perturbations is to
produce a complete and robust schedule by taking into account all possible scenarios, i.e. a
schedule with strong controllability (Vidal & Fargier, 1999). Rather than dealing with execution with 100% confidence, probabilistic techniques have been proposed that build schedules
with a probabilistic guarantee against a threshold value of an optimization metric such as
makespan. Another example of such generic schedule generation is fuzzy scheduling (Herroelen & Leus, 2005): instead of stochastic variables and probabilistic distributions, fuzzy
set scheduling use fuzzy numbers for modeling uncertainties based on possibility theory;
a recent work by Rodrguez et al. (2009) modeled uncertain durations as fuzzy numbers
and improved local search to solve the Job Shop Scheduling Problem. In the following,
80

fiRobust Local Search for Solving RCPSP/max with Durational Uncertainty

we provide further details on the work related to strong controllability and probabilistic
techniques.
8.1.1 Strong Controllable Techniques
Strong Controllability was introduced by Vidal and Fargier (1999) over Simple Temporal
Networks with Uncertainty (STNU) for which controllability is achievable in polynomial
time. With the existence of uncontrollable events that are controlled by exogenous factors, often referred to as Nature, an STNU is strongly controllable if there exists at least
one universal schedule that suits any situation. Such schedule might be computed off-line
beforehand. Strong controllability is the strictest form of STNU. A strongly controllable
network means that the schedule can be executed without regard to the contingent events.
It is useful in applications where contingent events cannot be observed exactly.
8.1.2 Probabilistic Techniques
Instead of generating a global solution suitable for all realizations of uncertainties, probabilistic techniques build a schedule that has a probabilistic guarantee of a deterministic
optimization measure with respect to a threshold value, e.g., find the schedule with the
highest probability that the project makespan will not exceed a particular value.
Daniels and Carrillo (1997) defined a -robust schedule as one that has maximum probability of achieving a given performance level, e.g., the total flow time is no greater than a
given threshold. They presented branch-and-bound and heuristic techniques to find a robust schedule in a one-machine manufacturing context that performs the best within a given
confidence level. As for the Job Shop Scheduling Problem, Beck and Wilson (2007) consider
activity durations as random variables; given a level of risk 0    1, they are interested
in a solution of minimal (probabilistic) makespan which has a probability of execution of
at least 1  .
8.2 Generating Flexible Schedule
Another way of producing robust schedule taking into account of uncertainty is to introduce
flexibility into the schedule. The idea is that only a subset of decisions are made offline and
the rest are postponed to be made online, so that decisions are only made when information
becomes more precise and certain (Bidot et al., 2009). In the following, we discuss three
subcategories of works that deal with generating flexible schedules.
8.2.1 Dynamic Controllable Techniques
An STNU is Dynamic Controllable (Vidal & Fargier, 1999) if there exists a solution that can
always be instantiated incrementally based on the outcomes of contingent edges in the past.
An execution strategy using dynamic controllability is needed to produce an incremental
solution based on the subsequent revelation of contingent events. Morris and Muscettola
(2005) proposed a pseudo-polynomial algorithm to handle dynamic controllability of STNUs
based on constraint satisfaction. Techniques were proposed by Wah and Xin (2004) to
optimize the bounds on durations of contingent edges such that the resulting STNU is
dynamic controllable.
81

fiFu, Lau, Varakantham, & Xiao

8.2.2 Redundancy-based Techniques
Redundancy-based scheduling is another proactive technique for scheduling. The idea is
to generate a schedule that includes the allocation of extra resources and/or time in the
schedule so that these buffers will help absorb the impact of unexpected events without
rescheduling during execution. Davenport, Gefflot, and Beck (2001) proposed techniques
for generating robust schedules based on the insertion of temporal slacks to critical activities that are allocated on possibly breakable resources. Lambrechts, Demeulemeester, and
Herroelen (2010) analytically determined the expected increase in activity duration due to
resource breakdown. Based on this information, simulation-based time buffering was used
to protect the schedule from disruptions caused by resource availability.
8.2.3 Partial Order Schedule (POS)
Even with buffering, baseline schedules may become brittle in face of unpredictable execution dynamics and can quickly get invalidated. Instead of baseline schedule, another line
of work is to consider design of good schedule policies. One such example is the notion
of Partial Order Schedules (POS) defined by Policella et al. (2004) which seeks to retain
temporal flexibility whenever the problem constraints allow it and can often absorb unexpected deviation from predictive assumptions. They considered robustness measures such
as fluidity and flexibility. Generating POS is another example of such flexible approaches: a
subset of sequencing decisions are made offline and the remaining decisions are made online
by using a dispatching rule (Bidot et al., 2009). Different methods of generating POS were
compared in terms of the robustness of the resulting schedules in the work of Rasconi, Cesta,
and Policella (2010). In our work, we apply the concept of POS as the execution policy.
Given an RCPSP/max instance, mean and variance values of the segregated variables of
data perturbations and the level of risk, the objective of our work is to determine POS with
a locally minimal robust value.
8.3 Scenario-based Optimization in Scheduling
Another line of work that deals with scheduling under uncertainty is based on the use of
scenarios (scenario-based optimization). For example, Kouvelis, Daniels, and Vairaktarakis
(2000) introduced the concept of robustness into scheduling problems. They considered uncertain processing times and proposed methods to generate a robust schedule based on the
maximum absolute deviation between the robust solution against all possible scenarios in a
given scenario set. A shortcoming of this kind of approach is that all scenarios are assumed
to be known in advance, and that the scenario space is usually exponentially large. Noteworthy of mention are the two notions of solution robustness and quality robustness, where
solution robustness (or stability) refers to the insensitivity of actual start times, whereas
quality robustness refers to the insensitivity of solution quality (i.e. makespan) to different
scenarios (Herroelen & Leus, 2005). Another pioneering scenario-based optimization work
is by Mulvey, Vanderbei, and Zenios (1995) which handles the tradeoff between solution
robustness (if a solution remains close to the optimal for all scenarios) and model robustness
(if a solution remains feasible for most scenarios).
82

fiRobust Local Search for Solving RCPSP/max with Durational Uncertainty

8.4 Robust Optimization in Scheduling
A recent development in Operations Research saw the potential of applying the concept of
Robust Optimization to deal with uncertainty. Ben-Tal and Nemirovski (2002) and Bertsimas and Sim (2003) proposed robust optimization models where no assumptions of the
underlying probability distribution of data are needed. The idea is often to approximate
data uncertainty by a tractable (convex) uncertainty set, and optimization is performed on
that set. This results in a robust counterpart formulation as a conic (such as second-order
cone) optimization problem which can be solved in polynomial time. However, only a few
works have been reported in the literature on applying robust optimization to scheduling,
due mainly to a high-degree combinational nature of the problem. One such application
is the process scheduling problem in chemical engineering, such as the works by Janak,
Lin, and Floudas (2007) and Li and Ierapetritou (2008). A notable recent breakthrough
in robust optimization on tractable approximation models to solve stochastic optimization
problems is found by Chen et al. (2008). This work makes use of linear segregated decision rules that are relevant to solving combinatorial scheduling problems with durational
uncertainty and our work exploit this mechanism and incorporate it into local search.

9. Conclusion
Given a level of risk 0 <   1 chosen by the planner, we investigated the problem of finding
the minimum (1  )-guaranteed makespan (i.e. Robust Makespan) and proposed methods
to find a schedule policy (POS) such that when uncertainty is dynamically realized, the
execution policy will result in a solution whose value is as good as robust makespan. We
first put forward a new decision rule utilized in scheduling to help specify the start times for
all activities with respect to execution policy and dynamic realizations of data uncertainty.
Based on the decision rule, new fitness function was then derived to evaluate robustness,
which was finally integrated into a local search framework to produce the solution with
robust makespan. Experimental results illustrate the improved performance of local search
with the new fitness evaluation, which provider tighter bounds on robust makespan and
better partial order schedules compared to the existing method.
For simplicity we have adopted an upper bound approach where we assume independence among the durational uncertainties. One future work is to treat correlations between
durational uncertainties, since a task duration could be correlated with some others in real
life. For example, correlations occur when an external event is not peculiar to a single
task, but more universal, such as weather conditions, seasonal peaks. In such situations,
the durational delays are correlated in the same direction. When this occurs, the decision
rules proposed in this paper break down unfortunately, since even if the covariances of
pairs of duration variables are given, it is very complex to analytically model the extent
to which one duration and any combination (resulting from SUM and MAX operators)
of other durations change together. This in turn complicates the analysis on the variance
of the makespan variable, and hence the robust makespan. Extending our work to handle
covariances is an interesting future direction.

83

fiFu, Lau, Varakantham, & Xiao

Acknowledgments
This paper extends previous research by Lau, Ou, and Xiao (2007) and Fu, Varakantham,
and Lau (2010). The authors wish to thank all reviewers for their insightful comments.

References
Aytug, H., Lawley, M. A., McKay, K., Mohan, S., & Uzsoy, R. (2005). Executing production schedules in the face of uncertainties: A review and some future directions. In
European Journal of Operational Research, Vol. 165(1), pp. 86110.
Bartusch, M., Mohring, R. H., & Radermacher, F. J. (1988). Scheduling project networks
with resource constraints and time windows. Annals of Operations Research, 16 (1-4),
201240.
Beck, J. C., & Wilson, N. (2007). Proactive algorithms for job shop scheduling with probabilistic durations. Journal of Artificial Intelligence Research, 28 (1), 183232.
Ben-Tal, A., & Nemirovski, A. (2002). Robust optimization - methodology and applications.
Mathematical Programming, 92, 453480.
Bertsimas, D., & Sim, M. (2003). Robust discrete optimization and network flows. Mathematical Programming, 98, 4971.
Bidot, J., Vidal, T., Laborie, P., & Beck, J. C. (2009). A theoretic and practical framework
for scheduling in a stochastic environment. Journal of Scheduling, 12, 315344.
Chen, X., Sim, M., Sun, P., & Zhang, J. (2008). A linear decision-based approximation
approach to stochastic programming. Operations Research, 56 (2), 344357.
Clark, C. E. (1961). The Greatest of a Finite Set of Random Variables. Operations Research,
9, 145162.
Daniels, R., & Carrillo, J. (1997). Beta-robust scheduling for single-machine systems with
uncertain processing times. IIE Transactions, 977985.
Davenport, A. J., Gefflot, C., & Beck, J. C. (2001). Slack-based techniques for robust
schedules. In Proceedings of the 6th European Conferences on Planning (ECP).
Dean, B. C., Goemans, M. X., & Vondrak, J. (2004). Approximating the stochastic knapsack
problem: The benefit of adaptivity. In FOCS, pp. 208217.
Demeulemeester, E. L., & Herroelen, W. S. (2002). Project scheduling : a research handbook.
Kluwer Academic Publishers, Boston.
Fu, N., Varakantham, P., & Lau, H. C. (2010). Towards finding robust execution strategies
for rcpsp/max with durational uncertainty. In Proceedings of International Conference
on Automated Planning and Scheduling (ICAPS), pp. 7380.
84

fiRobust Local Search for Solving RCPSP/max with Durational Uncertainty

Hagstrom, J. N. (1988). Computational complexity of pert problems. Networks, 18, 139
147.
Herroelen, W., & Leus, R. (2005). Project scheduling under uncertainty: Survey and
research potentials. In European Journal of Operational Research, Vol. 165(2), pp.
289306.
Janak, S., Lin, X., & Floudas, C. (2007). A new robust optimization approach for scheduling
under uncertainty :ii. uncertainty with known probability distribution. Computers and
Chemical Engineering, 31, 171195.
Kolisch, R., & Hartmann, S. (2005). Experimental investigation of heuristics for resourceconstrained project scheduling: An update.. European Journal of Operational Research.
Kolisch, R., Schwindt, C., & Sprecher, A. (1998). Benchmark Instances for Project Scheduling Problems, pp. 197212. Kluwer Academic Publishers, Boston.
Kouvelis, P., Daniels, R. L., & Vairaktarakis, G. (2000). Robust scheduling of a two-machine
flow shop with uncertain processing times. IIE Transactions, 32, 421432.
Lambrechts, O., Demeulemeester, E., & Herroelen, W. (2010). Time slack-based techniques
for robust project scheduling subject to resource uncertainty. Open access publications
from katholieke universiteit leuven urn:hdl:123456789/272147, Katholieke Universiteit
Leuven.
Lau, H. C., Ou, T., & Xiao, F. (2007). Robust local search and its application to generating
robust schedules. In Proceedings of International Conference on Automated Planning
and Scheduling (ICAPS), pp. 208215.
Li, Z., & Ierapetritou, M. G. (2008). Robust optimization for process scheduling under
uncertainty. Industrial and Engineering Chemistry Research, 47 (12), 41484157.
Lombardi, M., & Milano, M. (2009). A precedence constraint posting approach for the
rcpsp with time lags and variable durations. In Proceedings of the 15th international
conference on Principles and practice of constraint programming, CP09, pp. 569583
Berlin, Heidelberg. Springer-Verlag.
Mohring, R. H. (2001). Scheduling under uncertainty: Bounding the makespan distribution.
In Computational Discrete Mathematics, pp. 7997.
Mohring, R. H., & Stork, F. (2000). Linear preselective policies for stochastic project
scheduling. Mathematical Methods of Operations Research, 52 (3), 501515.
Morris, P., & Muscettola, N. (2005). Temporal dynamic controllability revisited. In Proceedings of the 20th National Conference on Artificial Intelligence, pp. 11931198. AAAI
Press.
Mulvey, J. M., Vanderbei, R. J., & Zenios, S. J. (1995). Robust optimization of large-scale
systems. Operations Research, 43.
85

fiFu, Lau, Varakantham, & Xiao

Neumann, K., Schwindt, C., & Zimmermann, J. (2006). Resource-constrained project
scheduling with time windows. International Series in Operations Research and Management Science, 92, 375408.
Policella, N., Cesta, A., Oddi, A., & Smith, S. (2009). Solve-and-robustify. Journal of
Scheduling, 12, 299314. 10.1007/s10951-008-0091-7.
Policella, N., Cesta, A., Oddi, A., & Smith, S. F. (2007). From precedence constraint posting
to partial order schedules: A csp approach to robust scheduling. AI Communications,
20, 163180.
Policella, N., Smith, S. F., Cesta, A., & Oddi, A. (2004). Generating robust schedules
through temporal flexibility.. In Proceedings of International Conference on Automated Planning and Scheduling (ICAPS), pp. 209218.
Rasconi, R., Cesta, A., & Policella, N. (2010). Validating scheduling approaches against
executional uncertainty. Journal of Intelligent Manufacturing, 21 (1), 4964.
Rodrguez, I. G., Vela, C. R., Puente, J., & Hernandez-Arauzo, A. (2009). Improved local
search for job shop scheduling with uncertain durations. In Proceedings of International Conference on Automated Planning and Scheduling (ICAPS).
Vidal, T., & Fargier, H. (1999). Handling contingency in temporal constraint networks: from
consistency to controllabilities. Journal of Experimental and Theoretical Artificial
Intelligence, 11, 2345.
Vonder, S., Demeulemeester, E., & Herroelen, W. (2007). A classification of predictivereactive project scheduling procedures. Journal of Scheduling, 10 (3), 195207.
Wah, B. W., & Xin, D. (2004). Optimization of bounds in temporal flexible planning
with dynamic controllability. IEEE International Conference on Tools with Artificial
Intelligence, 0, 4048.
Watson, J.-P., Barbulescu, L., Whitley, L. D., & Howe, A. E. (2002). Contrasting structured
and random permutation flow-shop scheduling problems: Search-space topology and
algorithm performance. INFORMS Journal on Computing, 14, 98123.
Wu, C. W., Brown, K. N., & Beck, J. C. (2009). Scheduling with uncertain durations: Modeling beta-robust scheduling with constraints.. Computers and Operations Research,
36, 23482356.

86

fi